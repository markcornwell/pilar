     .data
     .global "mrc_symbols"
     .align 8
mrc_symbols:
     .int 0xFF
     .global "mrc_string$e$q"
     .align 8
mrc_string$e$q:
     .int 0xFF
     .global "mrc_string$m$gsymbol"
     .align 8
mrc_string$m$gsymbol:
     .int 0xFF
     .global "mrc_append1"
     .align 8
mrc_append1:
     .int 0xFF
     .global "mrc_list$mref"
     .align 8
mrc_list$mref:
     .int 0xFF
     .global "mrc_list$mlength"
     .align 8
mrc_list$mlength:
     .int 0xFF
     .global "mrc_reverse"
     .align 8
mrc_reverse:
     .int 0xFF
     .global "mrc_list"
     .align 8
mrc_list:
     .int 0xFF
     .global "mrc_vector"
     .align 8
mrc_vector:
     .int 0xFF
     .global "mrc_string"
     .align 8
mrc_string:
     .int 0xFF
     .global "mrc_string$m$glist"
     .align 8
mrc_string$m$glist:
     .int 0xFF
     .global "mrc_integer$m$glist"
     .align 8
mrc_integer$m$glist:
     .int 0xFF
     .global "mrc_error"
     .align 8
mrc_error:
     .int 0xFF
     .global "mrc_primitives"
     .align 8
mrc_primitives:
     .int 0xFF
     .global "mrc_eh$uprocedure"
     .align 8
mrc_eh$uprocedure:
     .int 0xFF
     .global "mrc_eh$uargcount"
     .align 8
mrc_eh$uargcount:
     .int 0xFF
     .global "mrc_eh$uargcount$umin"
     .align 8
mrc_eh$uargcount$umin:
     .int 0xFF
     .global "mrc_eh$ufixnum"
     .align 8
mrc_eh$ufixnum:
     .int 0xFF
     .global "mrc_eh$ustring"
     .align 8
mrc_eh$ustring:
     .int 0xFF
     .global "mrc_eh$ucharacter"
     .align 8
mrc_eh$ucharacter:
     .int 0xFF
     .global "mrc_eh$upair"
     .align 8
mrc_eh$upair:
     .int 0xFF
     .global "mrc_eh$uvector"
     .align 8
mrc_eh$uvector:
     .int 0xFF
     .global "mrc_eh$ulength"
     .align 8
mrc_eh$ulength:
     .int 0xFF
     .global "mrc_eh$uvector$uindex"
     .align 8
mrc_eh$uvector$uindex:
     .int 0xFF
     .global "mrc_eh$ustring$uindex"
     .align 8
mrc_eh$ustring$uindex:
     .int 0xFF
     .global "mrc_zero$q"
     .align 8
mrc_zero$q:
     .int 0xFF
     .global "mrc_positive$q"
     .align 8
mrc_positive$q:
     .int 0xFF
     .global "mrc_negative$q"
     .align 8
mrc_negative$q:
     .int 0xFF
     .global "mrc_even$q"
     .align 8
mrc_even$q:
     .int 0xFF
     .global "mrc_odd$q"
     .align 8
mrc_odd$q:
     .int 0xFF
     .global "mrc_map"
     .align 8
mrc_map:
     .int 0xFF
     .global "mrc_for$meach"
     .align 8
mrc_for$meach:
     .int 0xFF
     .global "mrc_standard$mout"
     .align 8
mrc_standard$mout:
     .int 0xFF
     .global "mrc_current$moutput$mport"
     .align 8
mrc_current$moutput$mport:
     .int 0xFF
     .global "mrc_current$minput$mport"
     .align 8
mrc_current$minput$mport:
     .int 0xFF
     .global "mrc_port$mkind"
     .align 8
mrc_port$mkind:
     .int 0xFF
     .global "mrc_port$mpath"
     .align 8
mrc_port$mpath:
     .int 0xFF
     .global "mrc_port$mfd"
     .align 8
mrc_port$mfd:
     .int 0xFF
     .global "mrc_port$mbuf"
     .align 8
mrc_port$mbuf:
     .int 0xFF
     .global "mrc_port$mndx"
     .align 8
mrc_port$mndx:
     .int 0xFF
     .global "mrc_port$mndx$madd1"
     .align 8
mrc_port$mndx$madd1:
     .int 0xFF
     .global "mrc_port$mndx$mreset"
     .align 8
mrc_port$mndx$mreset:
     .int 0xFF
     .global "mrc_port$msize"
     .align 8
mrc_port$msize:
     .int 0xFF
     .global "mrc_write$mchar"
     .align 8
mrc_write$mchar:
     .int 0xFF
     .global "mrc_flush$moutput$mport"
     .align 8
mrc_flush$moutput$mport:
     .int 0xFF
     .global "mrc_exit"
     .align 8
mrc_exit:
     .int 0xFF
     .global "mrc_open$moutput$mfile"
     .align 8
mrc_open$moutput$mfile:
     .int 0xFF
     .global "mrc_close$minput$mport"
     .align 8
mrc_close$minput$mport:
     .int 0xFF
     .global "mrc_close$moutput$mport"
     .align 8
mrc_close$moutput$mport:
     .int 0xFF
     .global "mrc_base$mwrite"
     .align 8
mrc_base$mwrite:
     .int 0xFF
     .global "mrc_write"
     .align 8
mrc_write:
     .int 0xFF
     .global "mrc_display"
     .align 8
mrc_display:
     .int 0xFF
     .global "mrc_integer$m$gchar"
     .align 8
mrc_integer$m$gchar:
     .int 0xFF
     .global "mrc_standard$min"
     .align 8
mrc_standard$min:
     .int 0xFF
     .global "mrc_port$munread"
     .align 8
mrc_port$munread:
     .int 0xFF
     .global "mrc_port$munread$mclear"
     .align 8
mrc_port$munread$mclear:
     .int 0xFF
     .global "mrc_port$munread$mset$b"
     .align 8
mrc_port$munread$mset$b:
     .int 0xFF
     .global "mrc_port$mlast"
     .align 8
mrc_port$mlast:
     .int 0xFF
     .global "mrc_port$mlast$mset$b"
     .align 8
mrc_port$mlast$mset$b:
     .int 0xFF
     .global "mrc_input$mport$q"
     .align 8
mrc_input$mport$q:
     .int 0xFF
     .global "mrc_output$mport$q"
     .align 8
mrc_output$mport$q:
     .int 0xFF
     .global "mrc_open$minput$mfile"
     .align 8
mrc_open$minput$mfile:
     .int 0xFF
     .global "mrc_read$mchar"
     .align 8
mrc_read$mchar:
     .int 0xFF
     .global "mrc_fill$minput$mbuffer"
     .align 8
mrc_fill$minput$mbuffer:
     .int 0xFF
     .global "mrc_unread$mchar"
     .align 8
mrc_unread$mchar:
     .int 0xFF
     .text
     .global base_init
     .align 4
base_init:
# == explicit-begins  ==>
# (let ((interned-symbols (cons (make-symbol "nil" ()) ()))) (lambda () interned-symbols))
# == eliminate-let*  ==>
# (let ((interned-symbols (cons (make-symbol "nil" ()) ()))) (lambda () interned-symbols))
# == uniquify-variables  ==>
# (let ((f0 (cons (make-symbol "nil" ()) ()))) (lambda () f0))
# == vectorize-letrec  ==>
# (let ((f0 (cons (make-symbol "nil" ()) ()))) (lambda () f0))
# == eliminate-set!  ==>
# (let ((f0 (cons (make-symbol "nil" ()) ()))) (lambda () (let () f0)))
# == close-free-variables  ==>
# (let ((f0 (cons (make-symbol "nil" ()) ()))) (closure () (f0) (let () f0)))
# == eliminate-quote  ==>
# (let ((f0 (cons (make-symbol "nil" ()) ()))) (closure () (f0) (let () f0)))
# == eliminate-when/unless  ==>
# (let ((f0 (cons (make-symbol "nil" ()) ()))) (closure () (f0) (let () f0)))
# == eliminate-cond  ==>
# (let ((f0 (cons (make-symbol "nil" ()) ()))) (closure () (f0) (let () f0)))
# == external-symbols  ==>
# (let ((f0 (cons (make-symbol "nil" ()) ()))) (closure () (f0) (let () f0)))
# emit-expr (let ((f0 (cons (make-symbol "nil" ()) ()))) (closure () (f0) (let () f0)))
# emit-let
#  si   = 0
#  env  = ()
#  bindings = ((f0 (cons (make-symbol "nil" ()) ())))
#  body = (closure () (f0) (let () f0))
# emit-expr (cons (make-symbol "nil" ()) ())
# cons arg1=(make-symbol "nil" ()) arg2=()
# emit-expr (make-symbol "nil" ())
# make-symbol arg1="nil" arg2=()
# emit-expr "nil"
# string literal
    jmp _L_1
    .align 8,0x90
_L_0 :
    .int 12
    .ascii "nil"
_L_1:
    movl $_L_0, %eax
    orl $6, %eax
    movl %eax, 0(%esp)
# emit-expr ()
    movl $63, %eax     # immed ()
    movl %eax, 4(%ebp)
    movl 0(%esp), %eax
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    orl  $3, %eax
    add  $8, %ebp
# make-symbol end
    movl %eax, 0(%esp)
# emit-expr ()
    movl $63, %eax     # immed ()
    movl %eax, 4(%ebp)
    movl 0(%esp), %eax
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    or   $1, %al
    add  $8, %ebp
# cons end
    movl %eax, 0(%esp)  # stack save
# emit-expr (closure () (f0) (let () f0))
# emit-closure
# si = -4
# env = ((f0 . 0))
# expr = (closure () (f0) (let () f0))
    movl $_L_2, 0(%ebp)  # closure label
# emit-variable-ref
# env=((f0 . 0))
# var=f0
    movl 0(%esp), %eax  # stack load f0
# end emit-variable-ref
   movl  %eax, 4(%ebp)  # f0
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $8, %ebp     # bump ebp
    jmp _L_3            # jump around closure body
_L_2:
# check argument count
    cmp $0,%eax
    je _L_4
# invoke error handler eh_argcount
    .extern mrc_eh$uargcount
    movl mrc_eh$uargcount, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_4:
# emit-tail-expr
# si=-8
# env=((f0 . 4) (f0 . 0))
# expr=(let () f0)
# emit-tail-let
#  si   = -8
#  env  = ((f0 . 4) (f0 . 0))
#  bindings = ()
#  body = f0
# emit-tail-expr
# si=-8
# env=((f0 . 4) (f0 . 0))
# expr=f0
# emit-tail-variable-ref
# emit-variable-ref
# env=((f0 . 4) (f0 . 0))
# var=f0
    movl 2(%edi), %eax  # frame load f0
# end emit-variable-ref
    ret
# end emit-tail-variable ref
    .align 4,0x90
_L_3:
     movl %eax, mrc_symbols
# == explicit-begins  ==>
# (letrec ((slen= (lambda (s1 s2) (fx= (string-length s1) (string-length s2)))) (si= (lambda (s1 s2 i) (char=? (string-ref s1 i) (string-ref s2 i)))) (si<n= (lambda (s1 s2 i n) (if (fx= i n) #t (if (si= s1 s2 i) (si<n= s1 s2 (fx+ i 1) n) #f)))) (ss= (lambda (s1 s2) (if (slen= s1 s2) (si<n= s1 s2 0 (string-length s1)) #f)))) ss=)
# == eliminate-let*  ==>
# (letrec ((slen= (lambda (s1 s2) (fx= (string-length s1) (string-length s2)))) (si= (lambda (s1 s2 i) (char=? (string-ref s1 i) (string-ref s2 i)))) (si<n= (lambda (s1 s2 i n) (if (fx= i n) #t (if (si= s1 s2 i) (si<n= s1 s2 (fx+ i 1) n) #f)))) (ss= (lambda (s1 s2) (if (slen= s1 s2) (si<n= s1 s2 0 (string-length s1)) #f)))) ss=)
# == uniquify-variables  ==>
<<<<<<< HEAD
# (letrec ((f310791 (lambda (f310813 f310812) (fx= (string-length f310813) (string-length f310812)))) (f310790 (lambda (f310811 f310810 f310809) (char=? (string-ref f310811 f310809) (string-ref f310810 f310809)))) (f310789 (lambda (f310808 f310807 f310806 f310805) (if (fx= f310806 f310805) #t (if (f310790 f310808 f310807 f310806) (f310789 f310808 f310807 (fx+ f310806 1) f310805) #f)))) (f310788 (lambda (f310804 f310803) (if (f310791 f310804 f310803) (f310789 f310804 f310803 0 (string-length f310804)) #f)))) f310788)
# == vectorize-letrec  ==>
# (let ((f310791 (make-vector 1)) (f310790 (make-vector 1)) (f310789 (make-vector 1)) (f310788 (make-vector 1))) (begin (begin (vector-set! f310791 0 (lambda (f310813 f310812) (fx= (string-length f310813) (string-length f310812)))) (vector-set! f310790 0 (lambda (f310811 f310810 f310809) (char=? (string-ref f310811 f310809) (string-ref f310810 f310809)))) (vector-set! f310789 0 (lambda (f310808 f310807 f310806 f310805) (if (fx= f310806 f310805) #t (if ((vector-ref f310790 0) f310808 f310807 f310806) ((vector-ref f310789 0) f310808 f310807 (fx+ f310806 1) f310805) #f)))) (vector-set! f310788 0 (lambda (f310804 f310803) (if ((vector-ref f310791 0) f310804 f310803) ((vector-ref f310789 0) f310804 f310803 0 (string-length f310804)) #f)))) (vector-ref f310788 0)))
# == eliminate-set!  ==>
# (let ((f310791 (make-vector 1)) (f310790 (make-vector 1)) (f310789 (make-vector 1)) (f310788 (make-vector 1))) (begin (begin (vector-set! f310791 0 (lambda (f310813 f310812) (let ((f310813 f310813) (f310812 f310812)) (fx= (string-length f310813) (string-length f310812))))) (vector-set! f310790 0 (lambda (f310811 f310810 f310809) (let ((f310811 f310811) (f310810 f310810) (f310809 f310809)) (char=? (string-ref f310811 f310809) (string-ref f310810 f310809))))) (vector-set! f310789 0 (lambda (f310808 f310807 f310806 f310805) (let ((f310808 f310808) (f310807 f310807) (f310806 f310806) (f310805 f310805)) (if (fx= f310806 f310805) #t (if ((vector-ref f310790 0) f310808 f310807 f310806) ((vector-ref f310789 0) f310808 f310807 (fx+ f310806 1) f310805) #f))))) (vector-set! f310788 0 (lambda (f310804 f310803) (let ((f310804 f310804) (f310803 f310803)) (if ((vector-ref f310791 0) f310804 f310803) ((vector-ref f310789 0) f310804 f310803 0 (string-length f310804)) #f))))) (vector-ref f310788 0)))
# == close-free-variables  ==>
# (let ((f310791 (make-vector 1)) (f310790 (make-vector 1)) (f310789 (make-vector 1)) (f310788 (make-vector 1))) (begin (begin (vector-set! f310791 0 (closure (f310813 f310812) () (let ((f310813 f310813) (f310812 f310812)) (fx= (string-length f310813) (string-length f310812))))) (vector-set! f310790 0 (closure (f310811 f310810 f310809) () (let ((f310811 f310811) (f310810 f310810) (f310809 f310809)) (char=? (string-ref f310811 f310809) (string-ref f310810 f310809))))) (vector-set! f310789 0 (closure (f310808 f310807 f310806 f310805) (f310790 f310789) (let ((f310808 f310808) (f310807 f310807) (f310806 f310806) (f310805 f310805)) (if (fx= f310806 f310805) #t (if ((vector-ref f310790 0) f310808 f310807 f310806) ((vector-ref f310789 0) f310808 f310807 (fx+ f310806 1) f310805) #f))))) (vector-set! f310788 0 (closure (f310804 f310803) (f310791 f310789) (let ((f310804 f310804) (f310803 f310803)) (if ((vector-ref f310791 0) f310804 f310803) ((vector-ref f310789 0) f310804 f310803 0 (string-length f310804)) #f))))) (vector-ref f310788 0)))
# == eliminate-quote  ==>
# (let ((f310791 (make-vector 1)) (f310790 (make-vector 1)) (f310789 (make-vector 1)) (f310788 (make-vector 1))) (begin (begin (vector-set! f310791 0 (closure (f310813 f310812) () (let ((f310813 f310813) (f310812 f310812)) (fx= (string-length f310813) (string-length f310812))))) (vector-set! f310790 0 (closure (f310811 f310810 f310809) () (let ((f310811 f310811) (f310810 f310810) (f310809 f310809)) (char=? (string-ref f310811 f310809) (string-ref f310810 f310809))))) (vector-set! f310789 0 (closure (f310808 f310807 f310806 f310805) (f310790 f310789) (let ((f310808 f310808) (f310807 f310807) (f310806 f310806) (f310805 f310805)) (if (fx= f310806 f310805) #t (if ((vector-ref f310790 0) f310808 f310807 f310806) ((vector-ref f310789 0) f310808 f310807 (fx+ f310806 1) f310805) #f))))) (vector-set! f310788 0 (closure (f310804 f310803) (f310791 f310789) (let ((f310804 f310804) (f310803 f310803)) (if ((vector-ref f310791 0) f310804 f310803) ((vector-ref f310789 0) f310804 f310803 0 (string-length f310804)) #f))))) (vector-ref f310788 0)))
# == eliminate-when/unless  ==>
# (let ((f310791 (make-vector 1)) (f310790 (make-vector 1)) (f310789 (make-vector 1)) (f310788 (make-vector 1))) (begin (begin (vector-set! f310791 0 (closure (f310813 f310812) () (let ((f310813 f310813) (f310812 f310812)) (fx= (string-length f310813) (string-length f310812))))) (vector-set! f310790 0 (closure (f310811 f310810 f310809) () (let ((f310811 f310811) (f310810 f310810) (f310809 f310809)) (char=? (string-ref f310811 f310809) (string-ref f310810 f310809))))) (vector-set! f310789 0 (closure (f310808 f310807 f310806 f310805) (f310790 f310789) (let ((f310808 f310808) (f310807 f310807) (f310806 f310806) (f310805 f310805)) (if (fx= f310806 f310805) #t (if ((vector-ref f310790 0) f310808 f310807 f310806) ((vector-ref f310789 0) f310808 f310807 (fx+ f310806 1) f310805) #f))))) (vector-set! f310788 0 (closure (f310804 f310803) (f310791 f310789) (let ((f310804 f310804) (f310803 f310803)) (if ((vector-ref f310791 0) f310804 f310803) ((vector-ref f310789 0) f310804 f310803 0 (string-length f310804)) #f))))) (vector-ref f310788 0)))
# == eliminate-cond  ==>
# (let ((f310791 (make-vector 1)) (f310790 (make-vector 1)) (f310789 (make-vector 1)) (f310788 (make-vector 1))) (begin (begin (vector-set! f310791 0 (closure (f310813 f310812) () (let ((f310813 f310813) (f310812 f310812)) (fx= (string-length f310813) (string-length f310812))))) (vector-set! f310790 0 (closure (f310811 f310810 f310809) () (let ((f310811 f310811) (f310810 f310810) (f310809 f310809)) (char=? (string-ref f310811 f310809) (string-ref f310810 f310809))))) (vector-set! f310789 0 (closure (f310808 f310807 f310806 f310805) (f310790 f310789) (let ((f310808 f310808) (f310807 f310807) (f310806 f310806) (f310805 f310805)) (if (fx= f310806 f310805) #t (if ((vector-ref f310790 0) f310808 f310807 f310806) ((vector-ref f310789 0) f310808 f310807 (fx+ f310806 1) f310805) #f))))) (vector-set! f310788 0 (closure (f310804 f310803) (f310791 f310789) (let ((f310804 f310804) (f310803 f310803)) (if ((vector-ref f310791 0) f310804 f310803) ((vector-ref f310789 0) f310804 f310803 0 (string-length f310804)) #f))))) (vector-ref f310788 0)))
# == external-symbols  ==>
# (let ((f310791 (make-vector 1)) (f310790 (make-vector 1)) (f310789 (make-vector 1)) (f310788 (make-vector 1))) (begin (begin (vector-set! f310791 0 (closure (f310813 f310812) () (let ((f310813 f310813) (f310812 f310812)) (fx= (string-length f310813) (string-length f310812))))) (vector-set! f310790 0 (closure (f310811 f310810 f310809) () (let ((f310811 f310811) (f310810 f310810) (f310809 f310809)) (char=? (string-ref f310811 f310809) (string-ref f310810 f310809))))) (vector-set! f310789 0 (closure (f310808 f310807 f310806 f310805) (f310790 f310789) (let ((f310808 f310808) (f310807 f310807) (f310806 f310806) (f310805 f310805)) (if (fx= f310806 f310805) #t (if ((vector-ref f310790 0) f310808 f310807 f310806) ((vector-ref f310789 0) f310808 f310807 (fx+ f310806 1) f310805) #f))))) (vector-set! f310788 0 (closure (f310804 f310803) (f310791 f310789) (let ((f310804 f310804) (f310803 f310803)) (if ((vector-ref f310791 0) f310804 f310803) ((vector-ref f310789 0) f310804 f310803 0 (string-length f310804)) #f))))) (vector-ref f310788 0)))
# emit-expr (let ((f310791 (make-vector 1)) (f310790 (make-vector 1)) (f310789 (make-vector 1)) (f310788 (make-vector 1))) (begin (begin (vector-set! f310791 0 (closure (f310813 f310812) () (let ((f310813 f310813) (f310812 f310812)) (fx= (string-length f310813) (string-length f310812))))) (vector-set! f310790 0 (closure (f310811 f310810 f310809) () (let ((f310811 f310811) (f310810 f310810) (f310809 f310809)) (char=? (string-ref f310811 f310809) (string-ref f310810 f310809))))) (vector-set! f310789 0 (closure (f310808 f310807 f310806 f310805) (f310790 f310789) (let ((f310808 f310808) (f310807 f310807) (f310806 f310806) (f310805 f310805)) (if (fx= f310806 f310805) #t (if ((vector-ref f310790 0) f310808 f310807 f310806) ((vector-ref f310789 0) f310808 f310807 (fx+ f310806 1) f310805) #f))))) (vector-set! f310788 0 (closure (f310804 f310803) (f310791 f310789) (let ((f310804 f310804) (f310803 f310803)) (if ((vector-ref f310791 0) f310804 f310803) ((vector-ref f310789 0) f310804 f310803 0 (string-length f310804)) #f))))) (vector-ref f310788 0)))
# emit-let
#  si   = 0
#  env  = ()
#  bindings = ((f310791 (make-vector 1)) (f310790 (make-vector 1)) (f310789 (make-vector 1)) (f310788 (make-vector 1)))
#  body = (begin (begin (vector-set! f310791 0 (closure (f310813 f310812) () (let ((f310813 f310813) (f310812 f310812)) (fx= (string-length f310813) (string-length f310812))))) (vector-set! f310790 0 (closure (f310811 f310810 f310809) () (let ((f310811 f310811) (f310810 f310810) (f310809 f310809)) (char=? (string-ref f310811 f310809) (string-ref f310810 f310809))))) (vector-set! f310789 0 (closure (f310808 f310807 f310806 f310805) (f310790 f310789) (let ((f310808 f310808) (f310807 f310807) (f310806 f310806) (f310805 f310805)) (if (fx= f310806 f310805) #t (if ((vector-ref f310790 0) f310808 f310807 f310806) ((vector-ref f310789 0) f310808 f310807 (fx+ f310806 1) f310805) #f))))) (vector-set! f310788 0 (closure (f310804 f310803) (f310791 f310789) (let ((f310804 f310804) (f310803 f310803)) (if ((vector-ref f310791 0) f310804 f310803) ((vector-ref f310789 0) f310804 f310803 0 (string-length f310804)) #f))))) (vector-ref f310788 0))
=======
# (letrec ((f4 (lambda (f25 f26) (fx= (string-length f25) (string-length f26)))) (f3 (lambda (f22 f23 f24) (char=? (string-ref f22 f24) (string-ref f23 f24)))) (f2 (lambda (f18 f19 f20 f21) (if (fx= f20 f21) #t (if (f3 f18 f19 f20) (f2 f18 f19 (fx+ f20 1) f21) #f)))) (f1 (lambda (f16 f17) (if (f4 f16 f17) (f2 f16 f17 0 (string-length f16)) #f)))) f1)
# == vectorize-letrec  ==>
# (let ((f4 (make-vector 1)) (f3 (make-vector 1)) (f2 (make-vector 1)) (f1 (make-vector 1))) (begin (begin (vector-set! f4 0 (lambda (f25 f26) (fx= (string-length f25) (string-length f26)))) (vector-set! f3 0 (lambda (f22 f23 f24) (char=? (string-ref f22 f24) (string-ref f23 f24)))) (vector-set! f2 0 (lambda (f18 f19 f20 f21) (if (fx= f20 f21) #t (if ((vector-ref f3 0) f18 f19 f20) ((vector-ref f2 0) f18 f19 (fx+ f20 1) f21) #f)))) (vector-set! f1 0 (lambda (f16 f17) (if ((vector-ref f4 0) f16 f17) ((vector-ref f2 0) f16 f17 0 (string-length f16)) #f)))) (vector-ref f1 0)))
# == eliminate-set!  ==>
# (let ((f4 (make-vector 1)) (f3 (make-vector 1)) (f2 (make-vector 1)) (f1 (make-vector 1))) (begin (begin (vector-set! f4 0 (lambda (f25 f26) (let ((f25 f25) (f26 f26)) (fx= (string-length f25) (string-length f26))))) (vector-set! f3 0 (lambda (f22 f23 f24) (let ((f22 f22) (f23 f23) (f24 f24)) (char=? (string-ref f22 f24) (string-ref f23 f24))))) (vector-set! f2 0 (lambda (f18 f19 f20 f21) (let ((f18 f18) (f19 f19) (f20 f20) (f21 f21)) (if (fx= f20 f21) #t (if ((vector-ref f3 0) f18 f19 f20) ((vector-ref f2 0) f18 f19 (fx+ f20 1) f21) #f))))) (vector-set! f1 0 (lambda (f16 f17) (let ((f16 f16) (f17 f17)) (if ((vector-ref f4 0) f16 f17) ((vector-ref f2 0) f16 f17 0 (string-length f16)) #f))))) (vector-ref f1 0)))
# == close-free-variables  ==>
# (let ((f4 (make-vector 1)) (f3 (make-vector 1)) (f2 (make-vector 1)) (f1 (make-vector 1))) (begin (begin (vector-set! f4 0 (closure (f25 f26) () (let ((f25 f25) (f26 f26)) (fx= (string-length f25) (string-length f26))))) (vector-set! f3 0 (closure (f22 f23 f24) () (let ((f22 f22) (f23 f23) (f24 f24)) (char=? (string-ref f22 f24) (string-ref f23 f24))))) (vector-set! f2 0 (closure (f18 f19 f20 f21) (f3 f2) (let ((f18 f18) (f19 f19) (f20 f20) (f21 f21)) (if (fx= f20 f21) #t (if ((vector-ref f3 0) f18 f19 f20) ((vector-ref f2 0) f18 f19 (fx+ f20 1) f21) #f))))) (vector-set! f1 0 (closure (f16 f17) (f4 f2) (let ((f16 f16) (f17 f17)) (if ((vector-ref f4 0) f16 f17) ((vector-ref f2 0) f16 f17 0 (string-length f16)) #f))))) (vector-ref f1 0)))
# == eliminate-quote  ==>
# (let ((f4 (make-vector 1)) (f3 (make-vector 1)) (f2 (make-vector 1)) (f1 (make-vector 1))) (begin (begin (vector-set! f4 0 (closure (f25 f26) () (let ((f25 f25) (f26 f26)) (fx= (string-length f25) (string-length f26))))) (vector-set! f3 0 (closure (f22 f23 f24) () (let ((f22 f22) (f23 f23) (f24 f24)) (char=? (string-ref f22 f24) (string-ref f23 f24))))) (vector-set! f2 0 (closure (f18 f19 f20 f21) (f3 f2) (let ((f18 f18) (f19 f19) (f20 f20) (f21 f21)) (if (fx= f20 f21) #t (if ((vector-ref f3 0) f18 f19 f20) ((vector-ref f2 0) f18 f19 (fx+ f20 1) f21) #f))))) (vector-set! f1 0 (closure (f16 f17) (f4 f2) (let ((f16 f16) (f17 f17)) (if ((vector-ref f4 0) f16 f17) ((vector-ref f2 0) f16 f17 0 (string-length f16)) #f))))) (vector-ref f1 0)))
# == eliminate-when/unless  ==>
# (let ((f4 (make-vector 1)) (f3 (make-vector 1)) (f2 (make-vector 1)) (f1 (make-vector 1))) (begin (begin (vector-set! f4 0 (closure (f25 f26) () (let ((f25 f25) (f26 f26)) (fx= (string-length f25) (string-length f26))))) (vector-set! f3 0 (closure (f22 f23 f24) () (let ((f22 f22) (f23 f23) (f24 f24)) (char=? (string-ref f22 f24) (string-ref f23 f24))))) (vector-set! f2 0 (closure (f18 f19 f20 f21) (f3 f2) (let ((f18 f18) (f19 f19) (f20 f20) (f21 f21)) (if (fx= f20 f21) #t (if ((vector-ref f3 0) f18 f19 f20) ((vector-ref f2 0) f18 f19 (fx+ f20 1) f21) #f))))) (vector-set! f1 0 (closure (f16 f17) (f4 f2) (let ((f16 f16) (f17 f17)) (if ((vector-ref f4 0) f16 f17) ((vector-ref f2 0) f16 f17 0 (string-length f16)) #f))))) (vector-ref f1 0)))
# == eliminate-cond  ==>
# (let ((f4 (make-vector 1)) (f3 (make-vector 1)) (f2 (make-vector 1)) (f1 (make-vector 1))) (begin (begin (vector-set! f4 0 (closure (f25 f26) () (let ((f25 f25) (f26 f26)) (fx= (string-length f25) (string-length f26))))) (vector-set! f3 0 (closure (f22 f23 f24) () (let ((f22 f22) (f23 f23) (f24 f24)) (char=? (string-ref f22 f24) (string-ref f23 f24))))) (vector-set! f2 0 (closure (f18 f19 f20 f21) (f3 f2) (let ((f18 f18) (f19 f19) (f20 f20) (f21 f21)) (if (fx= f20 f21) #t (if ((vector-ref f3 0) f18 f19 f20) ((vector-ref f2 0) f18 f19 (fx+ f20 1) f21) #f))))) (vector-set! f1 0 (closure (f16 f17) (f4 f2) (let ((f16 f16) (f17 f17)) (if ((vector-ref f4 0) f16 f17) ((vector-ref f2 0) f16 f17 0 (string-length f16)) #f))))) (vector-ref f1 0)))
# == external-symbols  ==>
# (let ((f4 (make-vector 1)) (f3 (make-vector 1)) (f2 (make-vector 1)) (f1 (make-vector 1))) (begin (begin (vector-set! f4 0 (closure (f25 f26) () (let ((f25 f25) (f26 f26)) (fx= (string-length f25) (string-length f26))))) (vector-set! f3 0 (closure (f22 f23 f24) () (let ((f22 f22) (f23 f23) (f24 f24)) (char=? (string-ref f22 f24) (string-ref f23 f24))))) (vector-set! f2 0 (closure (f18 f19 f20 f21) (f3 f2) (let ((f18 f18) (f19 f19) (f20 f20) (f21 f21)) (if (fx= f20 f21) #t (if ((vector-ref f3 0) f18 f19 f20) ((vector-ref f2 0) f18 f19 (fx+ f20 1) f21) #f))))) (vector-set! f1 0 (closure (f16 f17) (f4 f2) (let ((f16 f16) (f17 f17)) (if ((vector-ref f4 0) f16 f17) ((vector-ref f2 0) f16 f17 0 (string-length f16)) #f))))) (vector-ref f1 0)))
# emit-expr (let ((f4 (make-vector 1)) (f3 (make-vector 1)) (f2 (make-vector 1)) (f1 (make-vector 1))) (begin (begin (vector-set! f4 0 (closure (f25 f26) () (let ((f25 f25) (f26 f26)) (fx= (string-length f25) (string-length f26))))) (vector-set! f3 0 (closure (f22 f23 f24) () (let ((f22 f22) (f23 f23) (f24 f24)) (char=? (string-ref f22 f24) (string-ref f23 f24))))) (vector-set! f2 0 (closure (f18 f19 f20 f21) (f3 f2) (let ((f18 f18) (f19 f19) (f20 f20) (f21 f21)) (if (fx= f20 f21) #t (if ((vector-ref f3 0) f18 f19 f20) ((vector-ref f2 0) f18 f19 (fx+ f20 1) f21) #f))))) (vector-set! f1 0 (closure (f16 f17) (f4 f2) (let ((f16 f16) (f17 f17)) (if ((vector-ref f4 0) f16 f17) ((vector-ref f2 0) f16 f17 0 (string-length f16)) #f))))) (vector-ref f1 0)))
# emit-let
#  si   = 0
#  env  = ()
#  bindings = ((f4 (make-vector 1)) (f3 (make-vector 1)) (f2 (make-vector 1)) (f1 (make-vector 1)))
#  body = (begin (begin (vector-set! f4 0 (closure (f25 f26) () (let ((f25 f25) (f26 f26)) (fx= (string-length f25) (string-length f26))))) (vector-set! f3 0 (closure (f22 f23 f24) () (let ((f22 f22) (f23 f23) (f24 f24)) (char=? (string-ref f22 f24) (string-ref f23 f24))))) (vector-set! f2 0 (closure (f18 f19 f20 f21) (f3 f2) (let ((f18 f18) (f19 f19) (f20 f20) (f21 f21)) (if (fx= f20 f21) #t (if ((vector-ref f3 0) f18 f19 f20) ((vector-ref f2 0) f18 f19 (fx+ f20 1) f21) #f))))) (vector-set! f1 0 (closure (f16 f17) (f4 f2) (let ((f16 f16) (f17 f17)) (if ((vector-ref f4 0) f16 f17) ((vector-ref f2 0) f16 f17 0 (string-length f16)) #f))))) (vector-ref f1 0))
>>>>>>> fix-implicit-begins
# emit-expr (make-vector 1)
# make-vector 1
# emit-expr 1
    movl $4, %eax     # immed 1
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_5"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_5:
# check the argument is a fixnum >= 0
    cmp $0,%eax
    jge _L_6
# invoke error handler eh_length
    .extern mrc_eh$ulength
    movl mrc_eh$ulength, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_6:
    movl %eax, %esi
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    orl  $5, %eax
    addl $4, %esi
    addl $4, %esi
    andl $-8, %esi
    addl %esi, %ebp
    movl %eax, 0(%esp)  # stack save
# emit-expr (make-vector 1)
# make-vector 1
# emit-expr 1
    movl $4, %eax     # immed 1
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_7"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_7:
# check the argument is a fixnum >= 0
    cmp $0,%eax
    jge _L_8
# invoke error handler eh_length
    .extern mrc_eh$ulength
    movl mrc_eh$ulength, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_8:
    movl %eax, %esi
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    orl  $5, %eax
    addl $4, %esi
    addl $4, %esi
    andl $-8, %esi
    addl %esi, %ebp
    movl %eax, -4(%esp)  # stack save
# emit-expr (make-vector 1)
# make-vector 1
# emit-expr 1
    movl $4, %eax     # immed 1
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_9"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_9:
# check the argument is a fixnum >= 0
    cmp $0,%eax
    jge _L_10
# invoke error handler eh_length
    .extern mrc_eh$ulength
    movl mrc_eh$ulength, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_10:
    movl %eax, %esi
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    orl  $5, %eax
    addl $4, %esi
    addl $4, %esi
    andl $-8, %esi
    addl %esi, %ebp
    movl %eax, -8(%esp)  # stack save
# emit-expr (make-vector 1)
# make-vector 1
# emit-expr 1
    movl $4, %eax     # immed 1
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_11"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_11:
# check the argument is a fixnum >= 0
    cmp $0,%eax
    jge _L_12
# invoke error handler eh_length
    .extern mrc_eh$ulength
    movl mrc_eh$ulength, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_12:
    movl %eax, %esi
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    orl  $5, %eax
    addl $4, %esi
    addl $4, %esi
    andl $-8, %esi
    addl %esi, %ebp
    movl %eax, -12(%esp)  # stack save
<<<<<<< HEAD
# emit-expr (begin (begin (vector-set! f310791 0 (closure (f310813 f310812) () (let ((f310813 f310813) (f310812 f310812)) (fx= (string-length f310813) (string-length f310812))))) (vector-set! f310790 0 (closure (f310811 f310810 f310809) () (let ((f310811 f310811) (f310810 f310810) (f310809 f310809)) (char=? (string-ref f310811 f310809) (string-ref f310810 f310809))))) (vector-set! f310789 0 (closure (f310808 f310807 f310806 f310805) (f310790 f310789) (let ((f310808 f310808) (f310807 f310807) (f310806 f310806) (f310805 f310805)) (if (fx= f310806 f310805) #t (if ((vector-ref f310790 0) f310808 f310807 f310806) ((vector-ref f310789 0) f310808 f310807 (fx+ f310806 1) f310805) #f))))) (vector-set! f310788 0 (closure (f310804 f310803) (f310791 f310789) (let ((f310804 f310804) (f310803 f310803)) (if ((vector-ref f310791 0) f310804 f310803) ((vector-ref f310789 0) f310804 f310803 0 (string-length f310804)) #f))))) (vector-ref f310788 0))
# emit-begin
#   expr=(begin (begin (vector-set! f310791 0 (closure (f310813 f310812) () (let ((f310813 f310813) (f310812 f310812)) (fx= (string-length f310813) (string-length f310812))))) (vector-set! f310790 0 (closure (f310811 f310810 f310809) () (let ((f310811 f310811) (f310810 f310810) (f310809 f310809)) (char=? (string-ref f310811 f310809) (string-ref f310810 f310809))))) (vector-set! f310789 0 (closure (f310808 f310807 f310806 f310805) (f310790 f310789) (let ((f310808 f310808) (f310807 f310807) (f310806 f310806) (f310805 f310805)) (if (fx= f310806 f310805) #t (if ((vector-ref f310790 0) f310808 f310807 f310806) ((vector-ref f310789 0) f310808 f310807 (fx+ f310806 1) f310805) #f))))) (vector-set! f310788 0 (closure (f310804 f310803) (f310791 f310789) (let ((f310804 f310804) (f310803 f310803)) (if ((vector-ref f310791 0) f310804 f310803) ((vector-ref f310789 0) f310804 f310803 0 (string-length f310804)) #f))))) (vector-ref f310788 0))
#   env=((f310788 . -12) (f310789 . -8) (f310790 . -4) (f310791 . 0))
# emit-expr (begin (vector-set! f310791 0 (closure (f310813 f310812) () (let ((f310813 f310813) (f310812 f310812)) (fx= (string-length f310813) (string-length f310812))))) (vector-set! f310790 0 (closure (f310811 f310810 f310809) () (let ((f310811 f310811) (f310810 f310810) (f310809 f310809)) (char=? (string-ref f310811 f310809) (string-ref f310810 f310809))))) (vector-set! f310789 0 (closure (f310808 f310807 f310806 f310805) (f310790 f310789) (let ((f310808 f310808) (f310807 f310807) (f310806 f310806) (f310805 f310805)) (if (fx= f310806 f310805) #t (if ((vector-ref f310790 0) f310808 f310807 f310806) ((vector-ref f310789 0) f310808 f310807 (fx+ f310806 1) f310805) #f))))) (vector-set! f310788 0 (closure (f310804 f310803) (f310791 f310789) (let ((f310804 f310804) (f310803 f310803)) (if ((vector-ref f310791 0) f310804 f310803) ((vector-ref f310789 0) f310804 f310803 0 (string-length f310804)) #f)))))
# emit-begin
#   expr=(begin (vector-set! f310791 0 (closure (f310813 f310812) () (let ((f310813 f310813) (f310812 f310812)) (fx= (string-length f310813) (string-length f310812))))) (vector-set! f310790 0 (closure (f310811 f310810 f310809) () (let ((f310811 f310811) (f310810 f310810) (f310809 f310809)) (char=? (string-ref f310811 f310809) (string-ref f310810 f310809))))) (vector-set! f310789 0 (closure (f310808 f310807 f310806 f310805) (f310790 f310789) (let ((f310808 f310808) (f310807 f310807) (f310806 f310806) (f310805 f310805)) (if (fx= f310806 f310805) #t (if ((vector-ref f310790 0) f310808 f310807 f310806) ((vector-ref f310789 0) f310808 f310807 (fx+ f310806 1) f310805) #f))))) (vector-set! f310788 0 (closure (f310804 f310803) (f310791 f310789) (let ((f310804 f310804) (f310803 f310803)) (if ((vector-ref f310791 0) f310804 f310803) ((vector-ref f310789 0) f310804 f310803 0 (string-length f310804)) #f)))))
#   env=((f310788 . -12) (f310789 . -8) (f310790 . -4) (f310791 . 0))
# emit-expr (vector-set! f310791 0 (closure (f310813 f310812) () (let ((f310813 f310813) (f310812 f310812)) (fx= (string-length f310813) (string-length f310812)))))
# emit-expr f310791
=======
# emit-expr (begin (begin (vector-set! f4 0 (closure (f25 f26) () (let ((f25 f25) (f26 f26)) (fx= (string-length f25) (string-length f26))))) (vector-set! f3 0 (closure (f22 f23 f24) () (let ((f22 f22) (f23 f23) (f24 f24)) (char=? (string-ref f22 f24) (string-ref f23 f24))))) (vector-set! f2 0 (closure (f18 f19 f20 f21) (f3 f2) (let ((f18 f18) (f19 f19) (f20 f20) (f21 f21)) (if (fx= f20 f21) #t (if ((vector-ref f3 0) f18 f19 f20) ((vector-ref f2 0) f18 f19 (fx+ f20 1) f21) #f))))) (vector-set! f1 0 (closure (f16 f17) (f4 f2) (let ((f16 f16) (f17 f17)) (if ((vector-ref f4 0) f16 f17) ((vector-ref f2 0) f16 f17 0 (string-length f16)) #f))))) (vector-ref f1 0))
# emit-begin
#   expr=(begin (begin (vector-set! f4 0 (closure (f25 f26) () (let ((f25 f25) (f26 f26)) (fx= (string-length f25) (string-length f26))))) (vector-set! f3 0 (closure (f22 f23 f24) () (let ((f22 f22) (f23 f23) (f24 f24)) (char=? (string-ref f22 f24) (string-ref f23 f24))))) (vector-set! f2 0 (closure (f18 f19 f20 f21) (f3 f2) (let ((f18 f18) (f19 f19) (f20 f20) (f21 f21)) (if (fx= f20 f21) #t (if ((vector-ref f3 0) f18 f19 f20) ((vector-ref f2 0) f18 f19 (fx+ f20 1) f21) #f))))) (vector-set! f1 0 (closure (f16 f17) (f4 f2) (let ((f16 f16) (f17 f17)) (if ((vector-ref f4 0) f16 f17) ((vector-ref f2 0) f16 f17 0 (string-length f16)) #f))))) (vector-ref f1 0))
#   env=((f1 . -12) (f2 . -8) (f3 . -4) (f4 . 0))
# emit-expr (begin (vector-set! f4 0 (closure (f25 f26) () (let ((f25 f25) (f26 f26)) (fx= (string-length f25) (string-length f26))))) (vector-set! f3 0 (closure (f22 f23 f24) () (let ((f22 f22) (f23 f23) (f24 f24)) (char=? (string-ref f22 f24) (string-ref f23 f24))))) (vector-set! f2 0 (closure (f18 f19 f20 f21) (f3 f2) (let ((f18 f18) (f19 f19) (f20 f20) (f21 f21)) (if (fx= f20 f21) #t (if ((vector-ref f3 0) f18 f19 f20) ((vector-ref f2 0) f18 f19 (fx+ f20 1) f21) #f))))) (vector-set! f1 0 (closure (f16 f17) (f4 f2) (let ((f16 f16) (f17 f17)) (if ((vector-ref f4 0) f16 f17) ((vector-ref f2 0) f16 f17 0 (string-length f16)) #f)))))
# emit-begin
#   expr=(begin (vector-set! f4 0 (closure (f25 f26) () (let ((f25 f25) (f26 f26)) (fx= (string-length f25) (string-length f26))))) (vector-set! f3 0 (closure (f22 f23 f24) () (let ((f22 f22) (f23 f23) (f24 f24)) (char=? (string-ref f22 f24) (string-ref f23 f24))))) (vector-set! f2 0 (closure (f18 f19 f20 f21) (f3 f2) (let ((f18 f18) (f19 f19) (f20 f20) (f21 f21)) (if (fx= f20 f21) #t (if ((vector-ref f3 0) f18 f19 f20) ((vector-ref f2 0) f18 f19 (fx+ f20 1) f21) #f))))) (vector-set! f1 0 (closure (f16 f17) (f4 f2) (let ((f16 f16) (f17 f17)) (if ((vector-ref f4 0) f16 f17) ((vector-ref f2 0) f16 f17 0 (string-length f16)) #f)))))
#   env=((f1 . -12) (f2 . -8) (f3 . -4) (f4 . 0))
# emit-expr (vector-set! f4 0 (closure (f25 f26) () (let ((f25 f25) (f26 f26)) (fx= (string-length f25) (string-length f26)))))
# emit-expr f4
>>>>>>> fix-implicit-begins
# emit-variable-ref
# env=((f1 . -12) (f2 . -8) (f3 . -4) (f4 . 0))
# var=f4
    movl 0(%esp), %eax  # stack load f4
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_13
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_13:
    movl %eax, -16(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_14"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_14:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_16
    cmp  $0,%eax
    jge _L_15
_L_16:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_15:
    movl %eax, -20(%esp)
<<<<<<< HEAD
# emit-expr (closure (f310813 f310812) () (let ((f310813 f310813) (f310812 f310812)) (fx= (string-length f310813) (string-length f310812))))
# emit-closure
# si = -24
# env = ((f310788 . -12) (f310789 . -8) (f310790 . -4) (f310791 . 0))
# expr = (closure (f310813 f310812) () (let ((f310813 f310813) (f310812 f310812)) (fx= (string-length f310813) (string-length f310812))))
    movl $_L_1883616, 0(%ebp)  # closure label
=======
# emit-expr (closure (f25 f26) () (let ((f25 f25) (f26 f26)) (fx= (string-length f25) (string-length f26))))
# emit-closure
# si = -24
# env = ((f1 . -12) (f2 . -8) (f3 . -4) (f4 . 0))
# expr = (closure (f25 f26) () (let ((f25 f25) (f26 f26)) (fx= (string-length f25) (string-length f26))))
    movl $_L_17, 0(%ebp)  # closure label
>>>>>>> fix-implicit-begins
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $8, %ebp     # bump ebp
    jmp _L_18            # jump around closure body
_L_17:
# check argument count
    cmp $8,%eax
    je _L_19
# invoke error handler eh_argcount
    .extern mrc_eh$uargcount
    movl mrc_eh$uargcount, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_19:
# emit-tail-expr
# si=-16
<<<<<<< HEAD
# env=((f310812 . -12) (f310813 . -8) (f310788 . -12) (f310789 . -8) (f310790 . -4) (f310791 . 0))
# expr=(let ((f310813 f310813) (f310812 f310812)) (fx= (string-length f310813) (string-length f310812)))
# emit-tail-let
#  si   = -16
#  env  = ((f310812 . -12) (f310813 . -8) (f310788 . -12) (f310789 . -8) (f310790 . -4) (f310791 . 0))
#  bindings = ((f310813 f310813) (f310812 f310812))
#  body = (fx= (string-length f310813) (string-length f310812))
# emit-expr f310813
# emit-variable-ref
# env=((f310812 . -12) (f310813 . -8) (f310788 . -12) (f310789 . -8) (f310790 . -4) (f310791 . 0))
# var=f310813
    movl -8(%esp), %eax  # stack load f310813
# end emit-variable-ref
    movl %eax, -16(%esp)  # stack save
# emit-expr f310812
# emit-variable-ref
# env=((f310812 . -12) (f310813 . -8) (f310788 . -12) (f310789 . -8) (f310790 . -4) (f310791 . 0))
# var=f310812
    movl -12(%esp), %eax  # stack load f310812
=======
# env=((f26 . -12) (f25 . -8) (f1 . -12) (f2 . -8) (f3 . -4) (f4 . 0))
# expr=(let ((f25 f25) (f26 f26)) (fx= (string-length f25) (string-length f26)))
# emit-tail-let
#  si   = -16
#  env  = ((f26 . -12) (f25 . -8) (f1 . -12) (f2 . -8) (f3 . -4) (f4 . 0))
#  bindings = ((f25 f25) (f26 f26))
#  body = (fx= (string-length f25) (string-length f26))
# emit-expr f25
# emit-variable-ref
# env=((f26 . -12) (f25 . -8) (f1 . -12) (f2 . -8) (f3 . -4) (f4 . 0))
# var=f25
    movl -8(%esp), %eax  # stack load f25
# end emit-variable-ref
    movl %eax, -16(%esp)  # stack save
# emit-expr f26
# emit-variable-ref
# env=((f26 . -12) (f25 . -8) (f1 . -12) (f2 . -8) (f3 . -4) (f4 . 0))
# var=f26
    movl -12(%esp), %eax  # stack load f26
>>>>>>> fix-implicit-begins
# end emit-variable-ref
    movl %eax, -20(%esp)  # stack save
# emit-tail-expr
# si=-24
<<<<<<< HEAD
# env=((f310812 . -20) (f310813 . -16) (f310812 . -12) (f310813 . -8) (f310788 . -12) (f310789 . -8) (f310790 . -4) (f310791 . 0))
# expr=(fx= (string-length f310813) (string-length f310812))
# tail primcall
# emit-expr (string-length f310812)
# emit-expr f310812
# emit-variable-ref
# env=((f310812 . -20) (f310813 . -16) (f310812 . -12) (f310813 . -8) (f310788 . -12) (f310789 . -8) (f310790 . -4) (f310791 . 0))
# var=f310812
    movl -20(%esp), %eax  # stack load f310812
=======
# env=((f26 . -20) (f25 . -16) (f26 . -12) (f25 . -8) (f1 . -12) (f2 . -8) (f3 . -4) (f4 . 0))
# expr=(fx= (string-length f25) (string-length f26))
# tail primcall
# emit-expr (string-length f26)
# emit-expr f26
# emit-variable-ref
# env=((f26 . -20) (f25 . -16) (f26 . -12) (f25 . -8) (f1 . -12) (f2 . -8) (f3 . -4) (f4 . 0))
# var=f26
    movl -20(%esp), %eax  # stack load f26
>>>>>>> fix-implicit-begins
# end emit-variable-ref
# check the argument is a string
    movl %eax,%ebx
    and $7, %bl
    cmp $6, %bl
    je _L_20
# invoke error handler eh_string
    .extern mrc_eh$ustring
    movl mrc_eh$ustring, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $160,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_20:
    movl -6(%eax), %eax
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_21"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $68,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_21:
    movl %eax, -24(%esp)
<<<<<<< HEAD
# emit-expr (string-length f310813)
# emit-expr f310813
# emit-variable-ref
# env=((f310812 . -20) (f310813 . -16) (f310812 . -12) (f310813 . -8) (f310788 . -12) (f310789 . -8) (f310790 . -4) (f310791 . 0))
# var=f310813
    movl -16(%esp), %eax  # stack load f310813
=======
# emit-expr (string-length f25)
# emit-expr f25
# emit-variable-ref
# env=((f26 . -20) (f25 . -16) (f26 . -12) (f25 . -8) (f1 . -12) (f2 . -8) (f3 . -4) (f4 . 0))
# var=f25
    movl -16(%esp), %eax  # stack load f25
>>>>>>> fix-implicit-begins
# end emit-variable-ref
# check the argument is a string
    movl %eax,%ebx
    and $7, %bl
    cmp $6, %bl
    je _L_22
# invoke error handler eh_string
    .extern mrc_eh$ustring
    movl mrc_eh$ustring, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $160,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_22:
    movl -6(%eax), %eax
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_23"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $68,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_23:
    cmp -24(%esp), %eax
    sete %al
    movzbl %al, %eax
    sal $6, %al
    or $47, %al
<<<<<<< HEAD
#return from tail (fx= (string-length f310813) (string-length f310812))
=======
#return from tail (fx= (string-length f25) (string-length f26))
>>>>>>> fix-implicit-begins
    ret
    .align 4,0x90
_L_18:
    movl -16(%esp), %ebx
    movl -20(%esp), %esi
    movl %eax, -1(%ebx,%esi)
<<<<<<< HEAD
# emit-expr (begin (vector-set! f310790 0 (closure (f310811 f310810 f310809) () (let ((f310811 f310811) (f310810 f310810) (f310809 f310809)) (char=? (string-ref f310811 f310809) (string-ref f310810 f310809))))) (vector-set! f310789 0 (closure (f310808 f310807 f310806 f310805) (f310790 f310789) (let ((f310808 f310808) (f310807 f310807) (f310806 f310806) (f310805 f310805)) (if (fx= f310806 f310805) #t (if ((vector-ref f310790 0) f310808 f310807 f310806) ((vector-ref f310789 0) f310808 f310807 (fx+ f310806 1) f310805) #f))))) (vector-set! f310788 0 (closure (f310804 f310803) (f310791 f310789) (let ((f310804 f310804) (f310803 f310803)) (if ((vector-ref f310791 0) f310804 f310803) ((vector-ref f310789 0) f310804 f310803 0 (string-length f310804)) #f)))))
# emit-begin
#   expr=(begin (vector-set! f310790 0 (closure (f310811 f310810 f310809) () (let ((f310811 f310811) (f310810 f310810) (f310809 f310809)) (char=? (string-ref f310811 f310809) (string-ref f310810 f310809))))) (vector-set! f310789 0 (closure (f310808 f310807 f310806 f310805) (f310790 f310789) (let ((f310808 f310808) (f310807 f310807) (f310806 f310806) (f310805 f310805)) (if (fx= f310806 f310805) #t (if ((vector-ref f310790 0) f310808 f310807 f310806) ((vector-ref f310789 0) f310808 f310807 (fx+ f310806 1) f310805) #f))))) (vector-set! f310788 0 (closure (f310804 f310803) (f310791 f310789) (let ((f310804 f310804) (f310803 f310803)) (if ((vector-ref f310791 0) f310804 f310803) ((vector-ref f310789 0) f310804 f310803 0 (string-length f310804)) #f)))))
#   env=((f310788 . -12) (f310789 . -8) (f310790 . -4) (f310791 . 0))
# emit-expr (vector-set! f310790 0 (closure (f310811 f310810 f310809) () (let ((f310811 f310811) (f310810 f310810) (f310809 f310809)) (char=? (string-ref f310811 f310809) (string-ref f310810 f310809)))))
# emit-expr f310790
=======
# emit-expr (begin (vector-set! f3 0 (closure (f22 f23 f24) () (let ((f22 f22) (f23 f23) (f24 f24)) (char=? (string-ref f22 f24) (string-ref f23 f24))))) (vector-set! f2 0 (closure (f18 f19 f20 f21) (f3 f2) (let ((f18 f18) (f19 f19) (f20 f20) (f21 f21)) (if (fx= f20 f21) #t (if ((vector-ref f3 0) f18 f19 f20) ((vector-ref f2 0) f18 f19 (fx+ f20 1) f21) #f))))) (vector-set! f1 0 (closure (f16 f17) (f4 f2) (let ((f16 f16) (f17 f17)) (if ((vector-ref f4 0) f16 f17) ((vector-ref f2 0) f16 f17 0 (string-length f16)) #f)))))
# emit-begin
#   expr=(begin (vector-set! f3 0 (closure (f22 f23 f24) () (let ((f22 f22) (f23 f23) (f24 f24)) (char=? (string-ref f22 f24) (string-ref f23 f24))))) (vector-set! f2 0 (closure (f18 f19 f20 f21) (f3 f2) (let ((f18 f18) (f19 f19) (f20 f20) (f21 f21)) (if (fx= f20 f21) #t (if ((vector-ref f3 0) f18 f19 f20) ((vector-ref f2 0) f18 f19 (fx+ f20 1) f21) #f))))) (vector-set! f1 0 (closure (f16 f17) (f4 f2) (let ((f16 f16) (f17 f17)) (if ((vector-ref f4 0) f16 f17) ((vector-ref f2 0) f16 f17 0 (string-length f16)) #f)))))
#   env=((f1 . -12) (f2 . -8) (f3 . -4) (f4 . 0))
# emit-expr (vector-set! f3 0 (closure (f22 f23 f24) () (let ((f22 f22) (f23 f23) (f24 f24)) (char=? (string-ref f22 f24) (string-ref f23 f24)))))
# emit-expr f3
>>>>>>> fix-implicit-begins
# emit-variable-ref
# env=((f1 . -12) (f2 . -8) (f3 . -4) (f4 . 0))
# var=f3
    movl -4(%esp), %eax  # stack load f3
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_24
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_24:
    movl %eax, -16(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_25"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_25:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_27
    cmp  $0,%eax
    jge _L_26
_L_27:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_26:
    movl %eax, -20(%esp)
<<<<<<< HEAD
# emit-expr (closure (f310811 f310810 f310809) () (let ((f310811 f310811) (f310810 f310810) (f310809 f310809)) (char=? (string-ref f310811 f310809) (string-ref f310810 f310809))))
# emit-closure
# si = -24
# env = ((f310788 . -12) (f310789 . -8) (f310790 . -4) (f310791 . 0))
# expr = (closure (f310811 f310810 f310809) () (let ((f310811 f310811) (f310810 f310810) (f310809 f310809)) (char=? (string-ref f310811 f310809) (string-ref f310810 f310809))))
    movl $_L_1883627, 0(%ebp)  # closure label
=======
# emit-expr (closure (f22 f23 f24) () (let ((f22 f22) (f23 f23) (f24 f24)) (char=? (string-ref f22 f24) (string-ref f23 f24))))
# emit-closure
# si = -24
# env = ((f1 . -12) (f2 . -8) (f3 . -4) (f4 . 0))
# expr = (closure (f22 f23 f24) () (let ((f22 f22) (f23 f23) (f24 f24)) (char=? (string-ref f22 f24) (string-ref f23 f24))))
    movl $_L_28, 0(%ebp)  # closure label
>>>>>>> fix-implicit-begins
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $8, %ebp     # bump ebp
    jmp _L_29            # jump around closure body
_L_28:
# check argument count
    cmp $12,%eax
    je _L_30
# invoke error handler eh_argcount
    .extern mrc_eh$uargcount
    movl mrc_eh$uargcount, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_30:
# emit-tail-expr
# si=-20
<<<<<<< HEAD
# env=((f310809 . -16) (f310810 . -12) (f310811 . -8) (f310788 . -12) (f310789 . -8) (f310790 . -4) (f310791 . 0))
# expr=(let ((f310811 f310811) (f310810 f310810) (f310809 f310809)) (char=? (string-ref f310811 f310809) (string-ref f310810 f310809)))
# emit-tail-let
#  si   = -20
#  env  = ((f310809 . -16) (f310810 . -12) (f310811 . -8) (f310788 . -12) (f310789 . -8) (f310790 . -4) (f310791 . 0))
#  bindings = ((f310811 f310811) (f310810 f310810) (f310809 f310809))
#  body = (char=? (string-ref f310811 f310809) (string-ref f310810 f310809))
# emit-expr f310811
# emit-variable-ref
# env=((f310809 . -16) (f310810 . -12) (f310811 . -8) (f310788 . -12) (f310789 . -8) (f310790 . -4) (f310791 . 0))
# var=f310811
    movl -8(%esp), %eax  # stack load f310811
=======
# env=((f24 . -16) (f23 . -12) (f22 . -8) (f1 . -12) (f2 . -8) (f3 . -4) (f4 . 0))
# expr=(let ((f22 f22) (f23 f23) (f24 f24)) (char=? (string-ref f22 f24) (string-ref f23 f24)))
# emit-tail-let
#  si   = -20
#  env  = ((f24 . -16) (f23 . -12) (f22 . -8) (f1 . -12) (f2 . -8) (f3 . -4) (f4 . 0))
#  bindings = ((f22 f22) (f23 f23) (f24 f24))
#  body = (char=? (string-ref f22 f24) (string-ref f23 f24))
# emit-expr f22
# emit-variable-ref
# env=((f24 . -16) (f23 . -12) (f22 . -8) (f1 . -12) (f2 . -8) (f3 . -4) (f4 . 0))
# var=f22
    movl -8(%esp), %eax  # stack load f22
>>>>>>> fix-implicit-begins
# end emit-variable-ref
    movl %eax, -20(%esp)  # stack save
# emit-expr f23
# emit-variable-ref
<<<<<<< HEAD
# env=((f310809 . -16) (f310810 . -12) (f310811 . -8) (f310788 . -12) (f310789 . -8) (f310790 . -4) (f310791 . 0))
# var=f310810
    movl -12(%esp), %eax  # stack load f310810
# end emit-variable-ref
    movl %eax, -24(%esp)  # stack save
# emit-expr f310809
# emit-variable-ref
# env=((f310809 . -16) (f310810 . -12) (f310811 . -8) (f310788 . -12) (f310789 . -8) (f310790 . -4) (f310791 . 0))
# var=f310809
    movl -16(%esp), %eax  # stack load f310809
=======
# env=((f24 . -16) (f23 . -12) (f22 . -8) (f1 . -12) (f2 . -8) (f3 . -4) (f4 . 0))
# var=f23
    movl -12(%esp), %eax  # stack load f23
# end emit-variable-ref
    movl %eax, -24(%esp)  # stack save
# emit-expr f24
# emit-variable-ref
# env=((f24 . -16) (f23 . -12) (f22 . -8) (f1 . -12) (f2 . -8) (f3 . -4) (f4 . 0))
# var=f24
    movl -16(%esp), %eax  # stack load f24
>>>>>>> fix-implicit-begins
# end emit-variable-ref
    movl %eax, -28(%esp)  # stack save
# emit-tail-expr
# si=-32
<<<<<<< HEAD
# env=((f310809 . -28) (f310810 . -24) (f310811 . -20) (f310809 . -16) (f310810 . -12) (f310811 . -8) (f310788 . -12) (f310789 . -8) (f310790 . -4) (f310791 . 0))
# expr=(char=? (string-ref f310811 f310809) (string-ref f310810 f310809))
# tail primcall
# char= c1=(string-ref f310811 f310809) c2=(string-ref f310810 f310809)
# emit-expr (string-ref f310811 f310809)
# emit-expr f310811
# emit-variable-ref
# env=((f310809 . -28) (f310810 . -24) (f310811 . -20) (f310809 . -16) (f310810 . -12) (f310811 . -8) (f310788 . -12) (f310789 . -8) (f310790 . -4) (f310791 . 0))
# var=f310811
    movl -20(%esp), %eax  # stack load f310811
=======
# env=((f24 . -28) (f23 . -24) (f22 . -20) (f24 . -16) (f23 . -12) (f22 . -8) (f1 . -12) (f2 . -8) (f3 . -4) (f4 . 0))
# expr=(char=? (string-ref f22 f24) (string-ref f23 f24))
# tail primcall
# char= c1=(string-ref f22 f24) c2=(string-ref f23 f24)
# emit-expr (string-ref f22 f24)
# emit-expr f22
# emit-variable-ref
# env=((f24 . -28) (f23 . -24) (f22 . -20) (f24 . -16) (f23 . -12) (f22 . -8) (f1 . -12) (f2 . -8) (f3 . -4) (f4 . 0))
# var=f22
    movl -20(%esp), %eax  # stack load f22
>>>>>>> fix-implicit-begins
# end emit-variable-ref
# check the argument is a string
    movl %eax,%ebx
    and $7, %bl
    cmp $6, %bl
    je _L_31
# invoke error handler eh_string
    .extern mrc_eh$ustring
    movl mrc_eh$ustring, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $164,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_31:
    movl %eax, -32(%esp)
<<<<<<< HEAD
# emit-expr f310809
# emit-variable-ref
# env=((f310809 . -28) (f310810 . -24) (f310811 . -20) (f310809 . -16) (f310810 . -12) (f310811 . -8) (f310788 . -12) (f310789 . -8) (f310790 . -4) (f310791 . 0))
# var=f310809
    movl -28(%esp), %eax  # stack load f310809
=======
# emit-expr f24
# emit-variable-ref
# env=((f24 . -28) (f23 . -24) (f22 . -20) (f24 . -16) (f23 . -12) (f22 . -8) (f1 . -12) (f2 . -8) (f3 . -4) (f4 . 0))
# var=f24
    movl -28(%esp), %eax  # stack load f24
>>>>>>> fix-implicit-begins
# end emit-variable-ref
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_32"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $164,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_32:
# check bounds on string index
    movl -32(%esp), %ebx
    cmp  %eax,-6(%ebx) 
    jle _L_34
    cmp  $0,%eax
    jge _L_33
_L_34:
# invoke error handler eh_string_index
    .extern mrc_eh$ustring$uindex
    movl mrc_eh$ustring$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $164,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_33:
    sar $2, %eax
    movl -32(%esp), %esi
    movl -2(%eax,%esi), %eax
    sal $8, %eax
    or  $15, %eax
# check the argument is a char
    movl %eax,%ebx
    and $255, %bl
    cmp $15, %bl
    je "_L_35"
# invoke error handler eh_character
    .extern mrc_eh$ucharacter
    movl mrc_eh$ucharacter, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $40,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_35:
    movb %ah, -32(%esp)
<<<<<<< HEAD
# emit-expr (string-ref f310810 f310809)
# emit-expr f310810
# emit-variable-ref
# env=((f310809 . -28) (f310810 . -24) (f310811 . -20) (f310809 . -16) (f310810 . -12) (f310811 . -8) (f310788 . -12) (f310789 . -8) (f310790 . -4) (f310791 . 0))
# var=f310810
    movl -24(%esp), %eax  # stack load f310810
=======
# emit-expr (string-ref f23 f24)
# emit-expr f23
# emit-variable-ref
# env=((f24 . -28) (f23 . -24) (f22 . -20) (f24 . -16) (f23 . -12) (f22 . -8) (f1 . -12) (f2 . -8) (f3 . -4) (f4 . 0))
# var=f23
    movl -24(%esp), %eax  # stack load f23
>>>>>>> fix-implicit-begins
# end emit-variable-ref
# check the argument is a string
    movl %eax,%ebx
    and $7, %bl
    cmp $6, %bl
    je _L_36
# invoke error handler eh_string
    .extern mrc_eh$ustring
    movl mrc_eh$ustring, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $164,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_36:
    movl %eax, -36(%esp)
<<<<<<< HEAD
# emit-expr f310809
# emit-variable-ref
# env=((f310809 . -28) (f310810 . -24) (f310811 . -20) (f310809 . -16) (f310810 . -12) (f310811 . -8) (f310788 . -12) (f310789 . -8) (f310790 . -4) (f310791 . 0))
# var=f310809
    movl -28(%esp), %eax  # stack load f310809
=======
# emit-expr f24
# emit-variable-ref
# env=((f24 . -28) (f23 . -24) (f22 . -20) (f24 . -16) (f23 . -12) (f22 . -8) (f1 . -12) (f2 . -8) (f3 . -4) (f4 . 0))
# var=f24
    movl -28(%esp), %eax  # stack load f24
>>>>>>> fix-implicit-begins
# end emit-variable-ref
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_37"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $164,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_37:
# check bounds on string index
    movl -36(%esp), %ebx
    cmp  %eax,-6(%ebx) 
    jle _L_39
    cmp  $0,%eax
    jge _L_38
_L_39:
# invoke error handler eh_string_index
    .extern mrc_eh$ustring$uindex
    movl mrc_eh$ustring$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $164,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_38:
    sar $2, %eax
    movl -36(%esp), %esi
    movl -2(%eax,%esi), %eax
    sal $8, %eax
    or  $15, %eax
# check the argument is a char
    movl %eax,%ebx
    and $255, %bl
    cmp $15, %bl
    je "_L_40"
# invoke error handler eh_character
    .extern mrc_eh$ucharacter
    movl mrc_eh$ucharacter, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $40,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_40:
    cmp %ah, -32(%esp)
    sete %al
    movzbl %al, %eax
    sal $6, %al
    or $47, %al
<<<<<<< HEAD
#return from tail (char=? (string-ref f310811 f310809) (string-ref f310810 f310809))
=======
#return from tail (char=? (string-ref f22 f24) (string-ref f23 f24))
>>>>>>> fix-implicit-begins
    ret
    .align 4,0x90
_L_29:
    movl -16(%esp), %ebx
    movl -20(%esp), %esi
    movl %eax, -1(%ebx,%esi)
<<<<<<< HEAD
# emit-expr (begin (vector-set! f310789 0 (closure (f310808 f310807 f310806 f310805) (f310790 f310789) (let ((f310808 f310808) (f310807 f310807) (f310806 f310806) (f310805 f310805)) (if (fx= f310806 f310805) #t (if ((vector-ref f310790 0) f310808 f310807 f310806) ((vector-ref f310789 0) f310808 f310807 (fx+ f310806 1) f310805) #f))))) (vector-set! f310788 0 (closure (f310804 f310803) (f310791 f310789) (let ((f310804 f310804) (f310803 f310803)) (if ((vector-ref f310791 0) f310804 f310803) ((vector-ref f310789 0) f310804 f310803 0 (string-length f310804)) #f)))))
# emit-begin
#   expr=(begin (vector-set! f310789 0 (closure (f310808 f310807 f310806 f310805) (f310790 f310789) (let ((f310808 f310808) (f310807 f310807) (f310806 f310806) (f310805 f310805)) (if (fx= f310806 f310805) #t (if ((vector-ref f310790 0) f310808 f310807 f310806) ((vector-ref f310789 0) f310808 f310807 (fx+ f310806 1) f310805) #f))))) (vector-set! f310788 0 (closure (f310804 f310803) (f310791 f310789) (let ((f310804 f310804) (f310803 f310803)) (if ((vector-ref f310791 0) f310804 f310803) ((vector-ref f310789 0) f310804 f310803 0 (string-length f310804)) #f)))))
#   env=((f310788 . -12) (f310789 . -8) (f310790 . -4) (f310791 . 0))
# emit-expr (vector-set! f310789 0 (closure (f310808 f310807 f310806 f310805) (f310790 f310789) (let ((f310808 f310808) (f310807 f310807) (f310806 f310806) (f310805 f310805)) (if (fx= f310806 f310805) #t (if ((vector-ref f310790 0) f310808 f310807 f310806) ((vector-ref f310789 0) f310808 f310807 (fx+ f310806 1) f310805) #f)))))
# emit-expr f310789
=======
# emit-expr (begin (vector-set! f2 0 (closure (f18 f19 f20 f21) (f3 f2) (let ((f18 f18) (f19 f19) (f20 f20) (f21 f21)) (if (fx= f20 f21) #t (if ((vector-ref f3 0) f18 f19 f20) ((vector-ref f2 0) f18 f19 (fx+ f20 1) f21) #f))))) (vector-set! f1 0 (closure (f16 f17) (f4 f2) (let ((f16 f16) (f17 f17)) (if ((vector-ref f4 0) f16 f17) ((vector-ref f2 0) f16 f17 0 (string-length f16)) #f)))))
# emit-begin
#   expr=(begin (vector-set! f2 0 (closure (f18 f19 f20 f21) (f3 f2) (let ((f18 f18) (f19 f19) (f20 f20) (f21 f21)) (if (fx= f20 f21) #t (if ((vector-ref f3 0) f18 f19 f20) ((vector-ref f2 0) f18 f19 (fx+ f20 1) f21) #f))))) (vector-set! f1 0 (closure (f16 f17) (f4 f2) (let ((f16 f16) (f17 f17)) (if ((vector-ref f4 0) f16 f17) ((vector-ref f2 0) f16 f17 0 (string-length f16)) #f)))))
#   env=((f1 . -12) (f2 . -8) (f3 . -4) (f4 . 0))
# emit-expr (vector-set! f2 0 (closure (f18 f19 f20 f21) (f3 f2) (let ((f18 f18) (f19 f19) (f20 f20) (f21 f21)) (if (fx= f20 f21) #t (if ((vector-ref f3 0) f18 f19 f20) ((vector-ref f2 0) f18 f19 (fx+ f20 1) f21) #f)))))
# emit-expr f2
>>>>>>> fix-implicit-begins
# emit-variable-ref
# env=((f1 . -12) (f2 . -8) (f3 . -4) (f4 . 0))
# var=f2
    movl -8(%esp), %eax  # stack load f2
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_41
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_41:
    movl %eax, -16(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_42"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_42:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_44
    cmp  $0,%eax
    jge _L_43
_L_44:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_43:
    movl %eax, -20(%esp)
<<<<<<< HEAD
# emit-expr (closure (f310808 f310807 f310806 f310805) (f310790 f310789) (let ((f310808 f310808) (f310807 f310807) (f310806 f310806) (f310805 f310805)) (if (fx= f310806 f310805) #t (if ((vector-ref f310790 0) f310808 f310807 f310806) ((vector-ref f310789 0) f310808 f310807 (fx+ f310806 1) f310805) #f))))
# emit-closure
# si = -24
# env = ((f310788 . -12) (f310789 . -8) (f310790 . -4) (f310791 . 0))
# expr = (closure (f310808 f310807 f310806 f310805) (f310790 f310789) (let ((f310808 f310808) (f310807 f310807) (f310806 f310806) (f310805 f310805)) (if (fx= f310806 f310805) #t (if ((vector-ref f310790 0) f310808 f310807 f310806) ((vector-ref f310789 0) f310808 f310807 (fx+ f310806 1) f310805) #f))))
    movl $_L_1883644, 0(%ebp)  # closure label
=======
# emit-expr (closure (f18 f19 f20 f21) (f3 f2) (let ((f18 f18) (f19 f19) (f20 f20) (f21 f21)) (if (fx= f20 f21) #t (if ((vector-ref f3 0) f18 f19 f20) ((vector-ref f2 0) f18 f19 (fx+ f20 1) f21) #f))))
# emit-closure
# si = -24
# env = ((f1 . -12) (f2 . -8) (f3 . -4) (f4 . 0))
# expr = (closure (f18 f19 f20 f21) (f3 f2) (let ((f18 f18) (f19 f19) (f20 f20) (f21 f21)) (if (fx= f20 f21) #t (if ((vector-ref f3 0) f18 f19 f20) ((vector-ref f2 0) f18 f19 (fx+ f20 1) f21) #f))))
    movl $_L_45, 0(%ebp)  # closure label
>>>>>>> fix-implicit-begins
# emit-variable-ref
# env=((f1 . -12) (f2 . -8) (f3 . -4) (f4 . 0))
# var=f3
    movl -4(%esp), %eax  # stack load f3
# end emit-variable-ref
   movl  %eax, 4(%ebp)  # f3
# emit-variable-ref
# env=((f1 . -12) (f2 . -8) (f3 . -4) (f4 . 0))
# var=f2
    movl -8(%esp), %eax  # stack load f2
# end emit-variable-ref
   movl  %eax, 8(%ebp)  # f2
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $16, %ebp     # bump ebp
    jmp _L_46            # jump around closure body
_L_45:
# check argument count
    cmp $16,%eax
    je _L_47
# invoke error handler eh_argcount
    .extern mrc_eh$uargcount
    movl mrc_eh$uargcount, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_47:
# emit-tail-expr
# si=-24
<<<<<<< HEAD
# env=((f310805 . -20) (f310806 . -16) (f310807 . -12) (f310808 . -8) (f310789 . 8) (f310790 . 4) (f310788 . -12) (f310789 . -8) (f310790 . -4) (f310791 . 0))
# expr=(let ((f310808 f310808) (f310807 f310807) (f310806 f310806) (f310805 f310805)) (if (fx= f310806 f310805) #t (if ((vector-ref f310790 0) f310808 f310807 f310806) ((vector-ref f310789 0) f310808 f310807 (fx+ f310806 1) f310805) #f)))
# emit-tail-let
#  si   = -24
#  env  = ((f310805 . -20) (f310806 . -16) (f310807 . -12) (f310808 . -8) (f310789 . 8) (f310790 . 4) (f310788 . -12) (f310789 . -8) (f310790 . -4) (f310791 . 0))
#  bindings = ((f310808 f310808) (f310807 f310807) (f310806 f310806) (f310805 f310805))
#  body = (if (fx= f310806 f310805) #t (if ((vector-ref f310790 0) f310808 f310807 f310806) ((vector-ref f310789 0) f310808 f310807 (fx+ f310806 1) f310805) #f))
# emit-expr f310808
# emit-variable-ref
# env=((f310805 . -20) (f310806 . -16) (f310807 . -12) (f310808 . -8) (f310789 . 8) (f310790 . 4) (f310788 . -12) (f310789 . -8) (f310790 . -4) (f310791 . 0))
# var=f310808
    movl -8(%esp), %eax  # stack load f310808
# end emit-variable-ref
    movl %eax, -24(%esp)  # stack save
# emit-expr f310807
# emit-variable-ref
# env=((f310805 . -20) (f310806 . -16) (f310807 . -12) (f310808 . -8) (f310789 . 8) (f310790 . 4) (f310788 . -12) (f310789 . -8) (f310790 . -4) (f310791 . 0))
# var=f310807
    movl -12(%esp), %eax  # stack load f310807
# end emit-variable-ref
    movl %eax, -28(%esp)  # stack save
# emit-expr f310806
# emit-variable-ref
# env=((f310805 . -20) (f310806 . -16) (f310807 . -12) (f310808 . -8) (f310789 . 8) (f310790 . 4) (f310788 . -12) (f310789 . -8) (f310790 . -4) (f310791 . 0))
# var=f310806
    movl -16(%esp), %eax  # stack load f310806
# end emit-variable-ref
    movl %eax, -32(%esp)  # stack save
# emit-expr f310805
# emit-variable-ref
# env=((f310805 . -20) (f310806 . -16) (f310807 . -12) (f310808 . -8) (f310789 . 8) (f310790 . 4) (f310788 . -12) (f310789 . -8) (f310790 . -4) (f310791 . 0))
# var=f310805
    movl -20(%esp), %eax  # stack load f310805
=======
# env=((f21 . -20) (f20 . -16) (f19 . -12) (f18 . -8) (f2 . 8) (f3 . 4) (f1 . -12) (f2 . -8) (f3 . -4) (f4 . 0))
# expr=(let ((f18 f18) (f19 f19) (f20 f20) (f21 f21)) (if (fx= f20 f21) #t (if ((vector-ref f3 0) f18 f19 f20) ((vector-ref f2 0) f18 f19 (fx+ f20 1) f21) #f)))
# emit-tail-let
#  si   = -24
#  env  = ((f21 . -20) (f20 . -16) (f19 . -12) (f18 . -8) (f2 . 8) (f3 . 4) (f1 . -12) (f2 . -8) (f3 . -4) (f4 . 0))
#  bindings = ((f18 f18) (f19 f19) (f20 f20) (f21 f21))
#  body = (if (fx= f20 f21) #t (if ((vector-ref f3 0) f18 f19 f20) ((vector-ref f2 0) f18 f19 (fx+ f20 1) f21) #f))
# emit-expr f18
# emit-variable-ref
# env=((f21 . -20) (f20 . -16) (f19 . -12) (f18 . -8) (f2 . 8) (f3 . 4) (f1 . -12) (f2 . -8) (f3 . -4) (f4 . 0))
# var=f18
    movl -8(%esp), %eax  # stack load f18
# end emit-variable-ref
    movl %eax, -24(%esp)  # stack save
# emit-expr f19
# emit-variable-ref
# env=((f21 . -20) (f20 . -16) (f19 . -12) (f18 . -8) (f2 . 8) (f3 . 4) (f1 . -12) (f2 . -8) (f3 . -4) (f4 . 0))
# var=f19
    movl -12(%esp), %eax  # stack load f19
# end emit-variable-ref
    movl %eax, -28(%esp)  # stack save
# emit-expr f20
# emit-variable-ref
# env=((f21 . -20) (f20 . -16) (f19 . -12) (f18 . -8) (f2 . 8) (f3 . 4) (f1 . -12) (f2 . -8) (f3 . -4) (f4 . 0))
# var=f20
    movl -16(%esp), %eax  # stack load f20
# end emit-variable-ref
    movl %eax, -32(%esp)  # stack save
# emit-expr f21
# emit-variable-ref
# env=((f21 . -20) (f20 . -16) (f19 . -12) (f18 . -8) (f2 . 8) (f3 . 4) (f1 . -12) (f2 . -8) (f3 . -4) (f4 . 0))
# var=f21
    movl -20(%esp), %eax  # stack load f21
>>>>>>> fix-implicit-begins
# end emit-variable-ref
    movl %eax, -36(%esp)  # stack save
# emit-tail-expr
# si=-40
<<<<<<< HEAD
# env=((f310805 . -36) (f310806 . -32) (f310807 . -28) (f310808 . -24) (f310805 . -20) (f310806 . -16) (f310807 . -12) (f310808 . -8) (f310789 . 8) (f310790 . 4) (f310788 . -12) (f310789 . -8) (f310790 . -4) (f310791 . 0))
# expr=(if (fx= f310806 f310805) #t (if ((vector-ref f310790 0) f310808 f310807 f310806) ((vector-ref f310789 0) f310808 f310807 (fx+ f310806 1) f310805) #f))
# emit-expr (fx= f310806 f310805)
# emit-expr f310805
# emit-variable-ref
# env=((f310805 . -36) (f310806 . -32) (f310807 . -28) (f310808 . -24) (f310805 . -20) (f310806 . -16) (f310807 . -12) (f310808 . -8) (f310789 . 8) (f310790 . 4) (f310788 . -12) (f310789 . -8) (f310790 . -4) (f310791 . 0))
# var=f310805
    movl -36(%esp), %eax  # stack load f310805
=======
# env=((f21 . -36) (f20 . -32) (f19 . -28) (f18 . -24) (f21 . -20) (f20 . -16) (f19 . -12) (f18 . -8) (f2 . 8) (f3 . 4) (f1 . -12) (f2 . -8) (f3 . -4) (f4 . 0))
# expr=(if (fx= f20 f21) #t (if ((vector-ref f3 0) f18 f19 f20) ((vector-ref f2 0) f18 f19 (fx+ f20 1) f21) #f))
# emit-expr (fx= f20 f21)
# emit-expr f21
# emit-variable-ref
# env=((f21 . -36) (f20 . -32) (f19 . -28) (f18 . -24) (f21 . -20) (f20 . -16) (f19 . -12) (f18 . -8) (f2 . 8) (f3 . 4) (f1 . -12) (f2 . -8) (f3 . -4) (f4 . 0))
# var=f21
    movl -36(%esp), %eax  # stack load f21
>>>>>>> fix-implicit-begins
# end emit-variable-ref
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_50"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $68,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_50:
    movl %eax, -40(%esp)
<<<<<<< HEAD
# emit-expr f310806
# emit-variable-ref
# env=((f310805 . -36) (f310806 . -32) (f310807 . -28) (f310808 . -24) (f310805 . -20) (f310806 . -16) (f310807 . -12) (f310808 . -8) (f310789 . 8) (f310790 . 4) (f310788 . -12) (f310789 . -8) (f310790 . -4) (f310791 . 0))
# var=f310806
    movl -32(%esp), %eax  # stack load f310806
=======
# emit-expr f20
# emit-variable-ref
# env=((f21 . -36) (f20 . -32) (f19 . -28) (f18 . -24) (f21 . -20) (f20 . -16) (f19 . -12) (f18 . -8) (f2 . 8) (f3 . 4) (f1 . -12) (f2 . -8) (f3 . -4) (f4 . 0))
# var=f20
    movl -32(%esp), %eax  # stack load f20
>>>>>>> fix-implicit-begins
# end emit-variable-ref
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_51"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $68,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_51:
    cmp -40(%esp), %eax
    sete %al
    movzbl %al, %eax
    sal $6, %al
    or $47, %al
    cmp $47, %al
    je _L_48
# emit-tail-expr
# si=-40
<<<<<<< HEAD
# env=((f310805 . -36) (f310806 . -32) (f310807 . -28) (f310808 . -24) (f310805 . -20) (f310806 . -16) (f310807 . -12) (f310808 . -8) (f310789 . 8) (f310790 . 4) (f310788 . -12) (f310789 . -8) (f310790 . -4) (f310791 . 0))
=======
# env=((f21 . -36) (f20 . -32) (f19 . -28) (f18 . -24) (f21 . -20) (f20 . -16) (f19 . -12) (f18 . -8) (f2 . 8) (f3 . 4) (f1 . -12) (f2 . -8) (f3 . -4) (f4 . 0))
>>>>>>> fix-implicit-begins
# expr=#t
    movl $111, %eax     # immed #t
    ret                  # immediate tail return
    jmp _L_49
_L_48:
# emit-tail-expr
# si=-40
<<<<<<< HEAD
# env=((f310805 . -36) (f310806 . -32) (f310807 . -28) (f310808 . -24) (f310805 . -20) (f310806 . -16) (f310807 . -12) (f310808 . -8) (f310789 . 8) (f310790 . 4) (f310788 . -12) (f310789 . -8) (f310790 . -4) (f310791 . 0))
# expr=(if ((vector-ref f310790 0) f310808 f310807 f310806) ((vector-ref f310789 0) f310808 f310807 (fx+ f310806 1) f310805) #f)
# emit-expr ((vector-ref f310790 0) f310808 f310807 f310806)
# funcall
#    si   =-40
#    env  = ((f310805 . -36) (f310806 . -32) (f310807 . -28) (f310808 . -24) (f310805 . -20) (f310806 . -16) (f310807 . -12) (f310808 . -8) (f310789 . 8) (f310790 . 4) (f310788 . -12) (f310789 . -8) (f310790 . -4) (f310791 . 0))
#    expr = (funcall (vector-ref f310790 0) f310808 f310807 f310806)
# emit-expr (vector-ref f310790 0)
# emit-expr f310790
# emit-variable-ref
# env=((f310805 . -36) (f310806 . -32) (f310807 . -28) (f310808 . -24) (f310805 . -20) (f310806 . -16) (f310807 . -12) (f310808 . -8) (f310789 . 8) (f310790 . 4) (f310788 . -12) (f310789 . -8) (f310790 . -4) (f310791 . 0))
# var=f310790
    movl 2(%edi), %eax  # frame load f310790
=======
# env=((f21 . -36) (f20 . -32) (f19 . -28) (f18 . -24) (f21 . -20) (f20 . -16) (f19 . -12) (f18 . -8) (f2 . 8) (f3 . 4) (f1 . -12) (f2 . -8) (f3 . -4) (f4 . 0))
# expr=(if ((vector-ref f3 0) f18 f19 f20) ((vector-ref f2 0) f18 f19 (fx+ f20 1) f21) #f)
# emit-expr ((vector-ref f3 0) f18 f19 f20)
# funcall
#    si   =-40
#    env  = ((f21 . -36) (f20 . -32) (f19 . -28) (f18 . -24) (f21 . -20) (f20 . -16) (f19 . -12) (f18 . -8) (f2 . 8) (f3 . 4) (f1 . -12) (f2 . -8) (f3 . -4) (f4 . 0))
#    expr = (funcall (vector-ref f3 0) f18 f19 f20)
# emit-expr (vector-ref f3 0)
# emit-expr f3
# emit-variable-ref
# env=((f21 . -36) (f20 . -32) (f19 . -28) (f18 . -24) (f21 . -20) (f20 . -16) (f19 . -12) (f18 . -8) (f2 . 8) (f3 . 4) (f1 . -12) (f2 . -8) (f3 . -4) (f4 . 0))
# var=f3
    movl 2(%edi), %eax  # frame load f3
>>>>>>> fix-implicit-begins
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_54
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_54:
    movl %eax, -48(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_55"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_55:
# check bounds on vector index
    movl -48(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_57
    cmp  $0,%eax
    jge _L_56
_L_57:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_56:
    movl -48(%esp), %esi
    movl -1(%eax,%esi), %eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_58"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_58":
   movl %eax,  -48(%esp)  # stash funcall-oper in closure slot
<<<<<<< HEAD
# emit-expr f310808
# emit-variable-ref
# env=((f310805 . -36) (f310806 . -32) (f310807 . -28) (f310808 . -24) (f310805 . -20) (f310806 . -16) (f310807 . -12) (f310808 . -8) (f310789 . 8) (f310790 . 4) (f310788 . -12) (f310789 . -8) (f310790 . -4) (f310791 . 0))
# var=f310808
    movl -24(%esp), %eax  # stack load f310808
# end emit-variable-ref
    mov %eax, -52(%esp)  # arg f310808
# emit-expr f310807
# emit-variable-ref
# env=((f310805 . -36) (f310806 . -32) (f310807 . -28) (f310808 . -24) (f310805 . -20) (f310806 . -16) (f310807 . -12) (f310808 . -8) (f310789 . 8) (f310790 . 4) (f310788 . -12) (f310789 . -8) (f310790 . -4) (f310791 . 0))
# var=f310807
    movl -28(%esp), %eax  # stack load f310807
# end emit-variable-ref
    mov %eax, -56(%esp)  # arg f310807
# emit-expr f310806
# emit-variable-ref
# env=((f310805 . -36) (f310806 . -32) (f310807 . -28) (f310808 . -24) (f310805 . -20) (f310806 . -16) (f310807 . -12) (f310808 . -8) (f310789 . 8) (f310790 . 4) (f310788 . -12) (f310789 . -8) (f310790 . -4) (f310791 . 0))
# var=f310806
    movl -32(%esp), %eax  # stack load f310806
# end emit-variable-ref
    mov %eax, -60(%esp)  # arg f310806
=======
# emit-expr f18
# emit-variable-ref
# env=((f21 . -36) (f20 . -32) (f19 . -28) (f18 . -24) (f21 . -20) (f20 . -16) (f19 . -12) (f18 . -8) (f2 . 8) (f3 . 4) (f1 . -12) (f2 . -8) (f3 . -4) (f4 . 0))
# var=f18
    movl -24(%esp), %eax  # stack load f18
# end emit-variable-ref
    mov %eax, -52(%esp)  # arg f18
# emit-expr f19
# emit-variable-ref
# env=((f21 . -36) (f20 . -32) (f19 . -28) (f18 . -24) (f21 . -20) (f20 . -16) (f19 . -12) (f18 . -8) (f2 . 8) (f3 . 4) (f1 . -12) (f2 . -8) (f3 . -4) (f4 . 0))
# var=f19
    movl -28(%esp), %eax  # stack load f19
# end emit-variable-ref
    mov %eax, -56(%esp)  # arg f19
# emit-expr f20
# emit-variable-ref
# env=((f21 . -36) (f20 . -32) (f19 . -28) (f18 . -24) (f21 . -20) (f20 . -16) (f19 . -12) (f18 . -8) (f2 . 8) (f3 . 4) (f1 . -12) (f2 . -8) (f3 . -4) (f4 . 0))
# var=f20
    movl -32(%esp), %eax  # stack load f20
# end emit-variable-ref
    mov %eax, -60(%esp)  # arg f20
>>>>>>> fix-implicit-begins
    movl -48(%esp), %edi   # load new closure to %edi
    add $-40, %esp   # adjust base
    movl $12,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $40, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    cmp $47, %al
    je _L_52
# emit-tail-expr
# si=-40
<<<<<<< HEAD
# env=((f310805 . -36) (f310806 . -32) (f310807 . -28) (f310808 . -24) (f310805 . -20) (f310806 . -16) (f310807 . -12) (f310808 . -8) (f310789 . 8) (f310790 . 4) (f310788 . -12) (f310789 . -8) (f310790 . -4) (f310791 . 0))
# expr=((vector-ref f310789 0) f310808 f310807 (fx+ f310806 1) f310805)
# emit-tail-funcall
#    si   =-40
#    env  = ((f310805 . -36) (f310806 . -32) (f310807 . -28) (f310808 . -24) (f310805 . -20) (f310806 . -16) (f310807 . -12) (f310808 . -8) (f310789 . 8) (f310790 . 4) (f310788 . -12) (f310789 . -8) (f310790 . -4) (f310791 . 0))
#    expr = (funcall (vector-ref f310789 0) f310808 f310807 (fx+ f310806 1) f310805)
# emit-expr (vector-ref f310789 0)
# emit-expr f310789
# emit-variable-ref
# env=((f310805 . -36) (f310806 . -32) (f310807 . -28) (f310808 . -24) (f310805 . -20) (f310806 . -16) (f310807 . -12) (f310808 . -8) (f310789 . 8) (f310790 . 4) (f310788 . -12) (f310789 . -8) (f310790 . -4) (f310791 . 0))
# var=f310789
    movl 6(%edi), %eax  # frame load f310789
=======
# env=((f21 . -36) (f20 . -32) (f19 . -28) (f18 . -24) (f21 . -20) (f20 . -16) (f19 . -12) (f18 . -8) (f2 . 8) (f3 . 4) (f1 . -12) (f2 . -8) (f3 . -4) (f4 . 0))
# expr=((vector-ref f2 0) f18 f19 (fx+ f20 1) f21)
# emit-tail-funcall
#    si   =-40
#    env  = ((f21 . -36) (f20 . -32) (f19 . -28) (f18 . -24) (f21 . -20) (f20 . -16) (f19 . -12) (f18 . -8) (f2 . 8) (f3 . 4) (f1 . -12) (f2 . -8) (f3 . -4) (f4 . 0))
#    expr = (funcall (vector-ref f2 0) f18 f19 (fx+ f20 1) f21)
# emit-expr (vector-ref f2 0)
# emit-expr f2
# emit-variable-ref
# env=((f21 . -36) (f20 . -32) (f19 . -28) (f18 . -24) (f21 . -20) (f20 . -16) (f19 . -12) (f18 . -8) (f2 . 8) (f3 . 4) (f1 . -12) (f2 . -8) (f3 . -4) (f4 . 0))
# var=f2
    movl 6(%edi), %eax  # frame load f2
>>>>>>> fix-implicit-begins
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_59
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_59:
    movl %eax, -40(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_60"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_60:
# check bounds on vector index
    movl -40(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_62
    cmp  $0,%eax
    jge _L_61
_L_62:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_61:
    movl -40(%esp), %esi
    movl -1(%eax,%esi), %eax
   movl %eax,  -40(%esp)  # stash funcall-oper in next closure slot
<<<<<<< HEAD
# emit-expr f310808
# emit-variable-ref
# env=((f310805 . -36) (f310806 . -32) (f310807 . -28) (f310808 . -24) (f310805 . -20) (f310806 . -16) (f310807 . -12) (f310808 . -8) (f310789 . 8) (f310790 . 4) (f310788 . -12) (f310789 . -8) (f310790 . -4) (f310791 . 0))
# var=f310808
    movl -24(%esp), %eax  # stack load f310808
# end emit-variable-ref
    mov %eax, -44(%esp)    # arg f310808
# emit-expr f310807
# emit-variable-ref
# env=((f310805 . -36) (f310806 . -32) (f310807 . -28) (f310808 . -24) (f310805 . -20) (f310806 . -16) (f310807 . -12) (f310808 . -8) (f310789 . 8) (f310790 . 4) (f310788 . -12) (f310789 . -8) (f310790 . -4) (f310791 . 0))
# var=f310807
    movl -28(%esp), %eax  # stack load f310807
# end emit-variable-ref
    mov %eax, -48(%esp)    # arg f310807
# emit-expr (fx+ f310806 1)
=======
# emit-expr f18
# emit-variable-ref
# env=((f21 . -36) (f20 . -32) (f19 . -28) (f18 . -24) (f21 . -20) (f20 . -16) (f19 . -12) (f18 . -8) (f2 . 8) (f3 . 4) (f1 . -12) (f2 . -8) (f3 . -4) (f4 . 0))
# var=f18
    movl -24(%esp), %eax  # stack load f18
# end emit-variable-ref
    mov %eax, -44(%esp)    # arg f18
# emit-expr f19
# emit-variable-ref
# env=((f21 . -36) (f20 . -32) (f19 . -28) (f18 . -24) (f21 . -20) (f20 . -16) (f19 . -12) (f18 . -8) (f2 . 8) (f3 . 4) (f1 . -12) (f2 . -8) (f3 . -4) (f4 . 0))
# var=f19
    movl -28(%esp), %eax  # stack load f19
# end emit-variable-ref
    mov %eax, -48(%esp)    # arg f19
# emit-expr (fx+ f20 1)
>>>>>>> fix-implicit-begins
# emit-expr 1
    movl $4, %eax     # immed 1
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_63"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $88,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_63:
    movl %eax, -52(%esp)  # fx+ push arg1
<<<<<<< HEAD
# emit-expr f310806
# emit-variable-ref
# env=((f310805 . -36) (f310806 . -32) (f310807 . -28) (f310808 . -24) (f310805 . -20) (f310806 . -16) (f310807 . -12) (f310808 . -8) (f310789 . 8) (f310790 . 4) (f310788 . -12) (f310789 . -8) (f310790 . -4) (f310791 . 0))
# var=f310806
    movl -32(%esp), %eax  # stack load f310806
=======
# emit-expr f20
# emit-variable-ref
# env=((f21 . -36) (f20 . -32) (f19 . -28) (f18 . -24) (f21 . -20) (f20 . -16) (f19 . -12) (f18 . -8) (f2 . 8) (f3 . 4) (f1 . -12) (f2 . -8) (f3 . -4) (f4 . 0))
# var=f20
    movl -32(%esp), %eax  # stack load f20
>>>>>>> fix-implicit-begins
# end emit-variable-ref
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_64"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $88,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_64:
    addl -52(%esp), %eax  # fx+ arg1 arg2
<<<<<<< HEAD
    mov %eax, -52(%esp)    # arg (fx+ f310806 1)
# emit-expr f310805
# emit-variable-ref
# env=((f310805 . -36) (f310806 . -32) (f310807 . -28) (f310808 . -24) (f310805 . -20) (f310806 . -16) (f310807 . -12) (f310808 . -8) (f310789 . 8) (f310790 . 4) (f310788 . -12) (f310789 . -8) (f310790 . -4) (f310791 . 0))
# var=f310805
    movl -36(%esp), %eax  # stack load f310805
# end emit-variable-ref
    mov %eax, -56(%esp)    # arg f310805
=======
    mov %eax, -52(%esp)    # arg (fx+ f20 1)
# emit-expr f21
# emit-variable-ref
# env=((f21 . -36) (f20 . -32) (f19 . -28) (f18 . -24) (f21 . -20) (f20 . -16) (f19 . -12) (f18 . -8) (f2 . 8) (f3 . 4) (f1 . -12) (f2 . -8) (f3 . -4) (f4 . 0))
# var=f21
    movl -36(%esp), %eax  # stack load f21
# end emit-variable-ref
    mov %eax, -56(%esp)    # arg f21
>>>>>>> fix-implicit-begins
    movl -40(%esp), %edi   # load new closure to %edi
# emit-shift-args:  size=5   si=-40  delta=36
    mov -40(%esp), %ebx  # shift frame cell
    mov %ebx, -4(%esp)  # down to base
# emit-shift-args:  size=4   si=-44  delta=36
    mov -44(%esp), %ebx  # shift frame cell
    mov %ebx, -8(%esp)  # down to base
# emit-shift-args:  size=3   si=-48  delta=36
    mov -48(%esp), %ebx  # shift frame cell
    mov %ebx, -12(%esp)  # down to base
# emit-shift-args:  size=2   si=-52  delta=36
    mov -52(%esp), %ebx  # shift frame cell
    mov %ebx, -16(%esp)  # down to base
# emit-shift-args:  size=1   si=-56  delta=36
    mov -56(%esp), %ebx  # shift frame cell
    mov %ebx, -20(%esp)  # down to base
# emit-shift-args:  size=0   si=-60  delta=36
    movl $16,%eax   # save arg count
    jmp *-2(%edi)  # tail-funcall
    jmp _L_53
_L_52:
# emit-tail-expr
# si=-40
<<<<<<< HEAD
# env=((f310805 . -36) (f310806 . -32) (f310807 . -28) (f310808 . -24) (f310805 . -20) (f310806 . -16) (f310807 . -12) (f310808 . -8) (f310789 . 8) (f310790 . 4) (f310788 . -12) (f310789 . -8) (f310790 . -4) (f310791 . 0))
=======
# env=((f21 . -36) (f20 . -32) (f19 . -28) (f18 . -24) (f21 . -20) (f20 . -16) (f19 . -12) (f18 . -8) (f2 . 8) (f3 . 4) (f1 . -12) (f2 . -8) (f3 . -4) (f4 . 0))
>>>>>>> fix-implicit-begins
# expr=#f
    movl $47, %eax     # immed #f
    ret                  # immediate tail return
_L_53:
_L_49:
    .align 4,0x90
_L_46:
    movl -16(%esp), %ebx
    movl -20(%esp), %esi
    movl %eax, -1(%ebx,%esi)
<<<<<<< HEAD
# emit-expr (begin (vector-set! f310788 0 (closure (f310804 f310803) (f310791 f310789) (let ((f310804 f310804) (f310803 f310803)) (if ((vector-ref f310791 0) f310804 f310803) ((vector-ref f310789 0) f310804 f310803 0 (string-length f310804)) #f)))))
# emit-begin
#   expr=(begin (vector-set! f310788 0 (closure (f310804 f310803) (f310791 f310789) (let ((f310804 f310804) (f310803 f310803)) (if ((vector-ref f310791 0) f310804 f310803) ((vector-ref f310789 0) f310804 f310803 0 (string-length f310804)) #f)))))
#   env=((f310788 . -12) (f310789 . -8) (f310790 . -4) (f310791 . 0))
# emit-expr (vector-set! f310788 0 (closure (f310804 f310803) (f310791 f310789) (let ((f310804 f310804) (f310803 f310803)) (if ((vector-ref f310791 0) f310804 f310803) ((vector-ref f310789 0) f310804 f310803 0 (string-length f310804)) #f))))
# emit-expr f310788
=======
# emit-expr (begin (vector-set! f1 0 (closure (f16 f17) (f4 f2) (let ((f16 f16) (f17 f17)) (if ((vector-ref f4 0) f16 f17) ((vector-ref f2 0) f16 f17 0 (string-length f16)) #f)))))
# emit-begin
#   expr=(begin (vector-set! f1 0 (closure (f16 f17) (f4 f2) (let ((f16 f16) (f17 f17)) (if ((vector-ref f4 0) f16 f17) ((vector-ref f2 0) f16 f17 0 (string-length f16)) #f)))))
#   env=((f1 . -12) (f2 . -8) (f3 . -4) (f4 . 0))
# emit-expr (vector-set! f1 0 (closure (f16 f17) (f4 f2) (let ((f16 f16) (f17 f17)) (if ((vector-ref f4 0) f16 f17) ((vector-ref f2 0) f16 f17 0 (string-length f16)) #f))))
# emit-expr f1
>>>>>>> fix-implicit-begins
# emit-variable-ref
# env=((f1 . -12) (f2 . -8) (f3 . -4) (f4 . 0))
# var=f1
    movl -12(%esp), %eax  # stack load f1
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_65
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_65:
    movl %eax, -16(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_66"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_66:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_68
    cmp  $0,%eax
    jge _L_67
_L_68:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_67:
    movl %eax, -20(%esp)
<<<<<<< HEAD
# emit-expr (closure (f310804 f310803) (f310791 f310789) (let ((f310804 f310804) (f310803 f310803)) (if ((vector-ref f310791 0) f310804 f310803) ((vector-ref f310789 0) f310804 f310803 0 (string-length f310804)) #f)))
# emit-closure
# si = -24
# env = ((f310788 . -12) (f310789 . -8) (f310790 . -4) (f310791 . 0))
# expr = (closure (f310804 f310803) (f310791 f310789) (let ((f310804 f310804) (f310803 f310803)) (if ((vector-ref f310791 0) f310804 f310803) ((vector-ref f310789 0) f310804 f310803 0 (string-length f310804)) #f)))
    movl $_L_1883668, 0(%ebp)  # closure label
=======
# emit-expr (closure (f16 f17) (f4 f2) (let ((f16 f16) (f17 f17)) (if ((vector-ref f4 0) f16 f17) ((vector-ref f2 0) f16 f17 0 (string-length f16)) #f)))
# emit-closure
# si = -24
# env = ((f1 . -12) (f2 . -8) (f3 . -4) (f4 . 0))
# expr = (closure (f16 f17) (f4 f2) (let ((f16 f16) (f17 f17)) (if ((vector-ref f4 0) f16 f17) ((vector-ref f2 0) f16 f17 0 (string-length f16)) #f)))
    movl $_L_69, 0(%ebp)  # closure label
>>>>>>> fix-implicit-begins
# emit-variable-ref
# env=((f1 . -12) (f2 . -8) (f3 . -4) (f4 . 0))
# var=f4
    movl 0(%esp), %eax  # stack load f4
# end emit-variable-ref
   movl  %eax, 4(%ebp)  # f4
# emit-variable-ref
# env=((f1 . -12) (f2 . -8) (f3 . -4) (f4 . 0))
# var=f2
    movl -8(%esp), %eax  # stack load f2
# end emit-variable-ref
   movl  %eax, 8(%ebp)  # f2
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $16, %ebp     # bump ebp
    jmp _L_70            # jump around closure body
_L_69:
# check argument count
    cmp $8,%eax
    je _L_71
# invoke error handler eh_argcount
    .extern mrc_eh$uargcount
    movl mrc_eh$uargcount, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_71:
# emit-tail-expr
# si=-16
<<<<<<< HEAD
# env=((f310803 . -12) (f310804 . -8) (f310789 . 8) (f310791 . 4) (f310788 . -12) (f310789 . -8) (f310790 . -4) (f310791 . 0))
# expr=(let ((f310804 f310804) (f310803 f310803)) (if ((vector-ref f310791 0) f310804 f310803) ((vector-ref f310789 0) f310804 f310803 0 (string-length f310804)) #f))
# emit-tail-let
#  si   = -16
#  env  = ((f310803 . -12) (f310804 . -8) (f310789 . 8) (f310791 . 4) (f310788 . -12) (f310789 . -8) (f310790 . -4) (f310791 . 0))
#  bindings = ((f310804 f310804) (f310803 f310803))
#  body = (if ((vector-ref f310791 0) f310804 f310803) ((vector-ref f310789 0) f310804 f310803 0 (string-length f310804)) #f)
# emit-expr f310804
# emit-variable-ref
# env=((f310803 . -12) (f310804 . -8) (f310789 . 8) (f310791 . 4) (f310788 . -12) (f310789 . -8) (f310790 . -4) (f310791 . 0))
# var=f310804
    movl -8(%esp), %eax  # stack load f310804
# end emit-variable-ref
    movl %eax, -16(%esp)  # stack save
# emit-expr f310803
# emit-variable-ref
# env=((f310803 . -12) (f310804 . -8) (f310789 . 8) (f310791 . 4) (f310788 . -12) (f310789 . -8) (f310790 . -4) (f310791 . 0))
# var=f310803
    movl -12(%esp), %eax  # stack load f310803
=======
# env=((f17 . -12) (f16 . -8) (f2 . 8) (f4 . 4) (f1 . -12) (f2 . -8) (f3 . -4) (f4 . 0))
# expr=(let ((f16 f16) (f17 f17)) (if ((vector-ref f4 0) f16 f17) ((vector-ref f2 0) f16 f17 0 (string-length f16)) #f))
# emit-tail-let
#  si   = -16
#  env  = ((f17 . -12) (f16 . -8) (f2 . 8) (f4 . 4) (f1 . -12) (f2 . -8) (f3 . -4) (f4 . 0))
#  bindings = ((f16 f16) (f17 f17))
#  body = (if ((vector-ref f4 0) f16 f17) ((vector-ref f2 0) f16 f17 0 (string-length f16)) #f)
# emit-expr f16
# emit-variable-ref
# env=((f17 . -12) (f16 . -8) (f2 . 8) (f4 . 4) (f1 . -12) (f2 . -8) (f3 . -4) (f4 . 0))
# var=f16
    movl -8(%esp), %eax  # stack load f16
# end emit-variable-ref
    movl %eax, -16(%esp)  # stack save
# emit-expr f17
# emit-variable-ref
# env=((f17 . -12) (f16 . -8) (f2 . 8) (f4 . 4) (f1 . -12) (f2 . -8) (f3 . -4) (f4 . 0))
# var=f17
    movl -12(%esp), %eax  # stack load f17
>>>>>>> fix-implicit-begins
# end emit-variable-ref
    movl %eax, -20(%esp)  # stack save
# emit-tail-expr
# si=-24
<<<<<<< HEAD
# env=((f310803 . -20) (f310804 . -16) (f310803 . -12) (f310804 . -8) (f310789 . 8) (f310791 . 4) (f310788 . -12) (f310789 . -8) (f310790 . -4) (f310791 . 0))
# expr=(if ((vector-ref f310791 0) f310804 f310803) ((vector-ref f310789 0) f310804 f310803 0 (string-length f310804)) #f)
# emit-expr ((vector-ref f310791 0) f310804 f310803)
# funcall
#    si   =-24
#    env  = ((f310803 . -20) (f310804 . -16) (f310803 . -12) (f310804 . -8) (f310789 . 8) (f310791 . 4) (f310788 . -12) (f310789 . -8) (f310790 . -4) (f310791 . 0))
#    expr = (funcall (vector-ref f310791 0) f310804 f310803)
# emit-expr (vector-ref f310791 0)
# emit-expr f310791
# emit-variable-ref
# env=((f310803 . -20) (f310804 . -16) (f310803 . -12) (f310804 . -8) (f310789 . 8) (f310791 . 4) (f310788 . -12) (f310789 . -8) (f310790 . -4) (f310791 . 0))
# var=f310791
    movl 2(%edi), %eax  # frame load f310791
=======
# env=((f17 . -20) (f16 . -16) (f17 . -12) (f16 . -8) (f2 . 8) (f4 . 4) (f1 . -12) (f2 . -8) (f3 . -4) (f4 . 0))
# expr=(if ((vector-ref f4 0) f16 f17) ((vector-ref f2 0) f16 f17 0 (string-length f16)) #f)
# emit-expr ((vector-ref f4 0) f16 f17)
# funcall
#    si   =-24
#    env  = ((f17 . -20) (f16 . -16) (f17 . -12) (f16 . -8) (f2 . 8) (f4 . 4) (f1 . -12) (f2 . -8) (f3 . -4) (f4 . 0))
#    expr = (funcall (vector-ref f4 0) f16 f17)
# emit-expr (vector-ref f4 0)
# emit-expr f4
# emit-variable-ref
# env=((f17 . -20) (f16 . -16) (f17 . -12) (f16 . -8) (f2 . 8) (f4 . 4) (f1 . -12) (f2 . -8) (f3 . -4) (f4 . 0))
# var=f4
    movl 2(%edi), %eax  # frame load f4
>>>>>>> fix-implicit-begins
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_74
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_74:
    movl %eax, -32(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_75"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_75:
# check bounds on vector index
    movl -32(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_77
    cmp  $0,%eax
    jge _L_76
_L_77:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_76:
    movl -32(%esp), %esi
    movl -1(%eax,%esi), %eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_78"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_78":
   movl %eax,  -32(%esp)  # stash funcall-oper in closure slot
<<<<<<< HEAD
# emit-expr f310804
# emit-variable-ref
# env=((f310803 . -20) (f310804 . -16) (f310803 . -12) (f310804 . -8) (f310789 . 8) (f310791 . 4) (f310788 . -12) (f310789 . -8) (f310790 . -4) (f310791 . 0))
# var=f310804
    movl -16(%esp), %eax  # stack load f310804
# end emit-variable-ref
    mov %eax, -36(%esp)  # arg f310804
# emit-expr f310803
# emit-variable-ref
# env=((f310803 . -20) (f310804 . -16) (f310803 . -12) (f310804 . -8) (f310789 . 8) (f310791 . 4) (f310788 . -12) (f310789 . -8) (f310790 . -4) (f310791 . 0))
# var=f310803
    movl -20(%esp), %eax  # stack load f310803
# end emit-variable-ref
    mov %eax, -40(%esp)  # arg f310803
=======
# emit-expr f16
# emit-variable-ref
# env=((f17 . -20) (f16 . -16) (f17 . -12) (f16 . -8) (f2 . 8) (f4 . 4) (f1 . -12) (f2 . -8) (f3 . -4) (f4 . 0))
# var=f16
    movl -16(%esp), %eax  # stack load f16
# end emit-variable-ref
    mov %eax, -36(%esp)  # arg f16
# emit-expr f17
# emit-variable-ref
# env=((f17 . -20) (f16 . -16) (f17 . -12) (f16 . -8) (f2 . 8) (f4 . 4) (f1 . -12) (f2 . -8) (f3 . -4) (f4 . 0))
# var=f17
    movl -20(%esp), %eax  # stack load f17
# end emit-variable-ref
    mov %eax, -40(%esp)  # arg f17
>>>>>>> fix-implicit-begins
    movl -32(%esp), %edi   # load new closure to %edi
    add $-24, %esp   # adjust base
    movl $8,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $24, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    cmp $47, %al
    je _L_72
# emit-tail-expr
# si=-24
<<<<<<< HEAD
# env=((f310803 . -20) (f310804 . -16) (f310803 . -12) (f310804 . -8) (f310789 . 8) (f310791 . 4) (f310788 . -12) (f310789 . -8) (f310790 . -4) (f310791 . 0))
# expr=((vector-ref f310789 0) f310804 f310803 0 (string-length f310804))
# emit-tail-funcall
#    si   =-24
#    env  = ((f310803 . -20) (f310804 . -16) (f310803 . -12) (f310804 . -8) (f310789 . 8) (f310791 . 4) (f310788 . -12) (f310789 . -8) (f310790 . -4) (f310791 . 0))
#    expr = (funcall (vector-ref f310789 0) f310804 f310803 0 (string-length f310804))
# emit-expr (vector-ref f310789 0)
# emit-expr f310789
# emit-variable-ref
# env=((f310803 . -20) (f310804 . -16) (f310803 . -12) (f310804 . -8) (f310789 . 8) (f310791 . 4) (f310788 . -12) (f310789 . -8) (f310790 . -4) (f310791 . 0))
# var=f310789
    movl 6(%edi), %eax  # frame load f310789
=======
# env=((f17 . -20) (f16 . -16) (f17 . -12) (f16 . -8) (f2 . 8) (f4 . 4) (f1 . -12) (f2 . -8) (f3 . -4) (f4 . 0))
# expr=((vector-ref f2 0) f16 f17 0 (string-length f16))
# emit-tail-funcall
#    si   =-24
#    env  = ((f17 . -20) (f16 . -16) (f17 . -12) (f16 . -8) (f2 . 8) (f4 . 4) (f1 . -12) (f2 . -8) (f3 . -4) (f4 . 0))
#    expr = (funcall (vector-ref f2 0) f16 f17 0 (string-length f16))
# emit-expr (vector-ref f2 0)
# emit-expr f2
# emit-variable-ref
# env=((f17 . -20) (f16 . -16) (f17 . -12) (f16 . -8) (f2 . 8) (f4 . 4) (f1 . -12) (f2 . -8) (f3 . -4) (f4 . 0))
# var=f2
    movl 6(%edi), %eax  # frame load f2
>>>>>>> fix-implicit-begins
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_79
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_79:
    movl %eax, -24(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_80"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_80:
# check bounds on vector index
    movl -24(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_82
    cmp  $0,%eax
    jge _L_81
_L_82:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_81:
    movl -24(%esp), %esi
    movl -1(%eax,%esi), %eax
   movl %eax,  -24(%esp)  # stash funcall-oper in next closure slot
<<<<<<< HEAD
# emit-expr f310804
# emit-variable-ref
# env=((f310803 . -20) (f310804 . -16) (f310803 . -12) (f310804 . -8) (f310789 . 8) (f310791 . 4) (f310788 . -12) (f310789 . -8) (f310790 . -4) (f310791 . 0))
# var=f310804
    movl -16(%esp), %eax  # stack load f310804
# end emit-variable-ref
    mov %eax, -28(%esp)    # arg f310804
# emit-expr f310803
# emit-variable-ref
# env=((f310803 . -20) (f310804 . -16) (f310803 . -12) (f310804 . -8) (f310789 . 8) (f310791 . 4) (f310788 . -12) (f310789 . -8) (f310790 . -4) (f310791 . 0))
# var=f310803
    movl -20(%esp), %eax  # stack load f310803
# end emit-variable-ref
    mov %eax, -32(%esp)    # arg f310803
# emit-expr 0
    movl $0, %eax     # immed 0
    mov %eax, -36(%esp)    # arg 0
# emit-expr (string-length f310804)
# emit-expr f310804
# emit-variable-ref
# env=((f310803 . -20) (f310804 . -16) (f310803 . -12) (f310804 . -8) (f310789 . 8) (f310791 . 4) (f310788 . -12) (f310789 . -8) (f310790 . -4) (f310791 . 0))
# var=f310804
    movl -16(%esp), %eax  # stack load f310804
=======
# emit-expr f16
# emit-variable-ref
# env=((f17 . -20) (f16 . -16) (f17 . -12) (f16 . -8) (f2 . 8) (f4 . 4) (f1 . -12) (f2 . -8) (f3 . -4) (f4 . 0))
# var=f16
    movl -16(%esp), %eax  # stack load f16
# end emit-variable-ref
    mov %eax, -28(%esp)    # arg f16
# emit-expr f17
# emit-variable-ref
# env=((f17 . -20) (f16 . -16) (f17 . -12) (f16 . -8) (f2 . 8) (f4 . 4) (f1 . -12) (f2 . -8) (f3 . -4) (f4 . 0))
# var=f17
    movl -20(%esp), %eax  # stack load f17
# end emit-variable-ref
    mov %eax, -32(%esp)    # arg f17
# emit-expr 0
    movl $0, %eax     # immed 0
    mov %eax, -36(%esp)    # arg 0
# emit-expr (string-length f16)
# emit-expr f16
# emit-variable-ref
# env=((f17 . -20) (f16 . -16) (f17 . -12) (f16 . -8) (f2 . 8) (f4 . 4) (f1 . -12) (f2 . -8) (f3 . -4) (f4 . 0))
# var=f16
    movl -16(%esp), %eax  # stack load f16
>>>>>>> fix-implicit-begins
# end emit-variable-ref
# check the argument is a string
    movl %eax,%ebx
    and $7, %bl
    cmp $6, %bl
    je _L_83
# invoke error handler eh_string
    .extern mrc_eh$ustring
    movl mrc_eh$ustring, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $160,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_83:
    movl -6(%eax), %eax
<<<<<<< HEAD
    mov %eax, -40(%esp)    # arg (string-length f310804)
=======
    mov %eax, -40(%esp)    # arg (string-length f16)
>>>>>>> fix-implicit-begins
    movl -24(%esp), %edi   # load new closure to %edi
# emit-shift-args:  size=5   si=-24  delta=20
    mov -24(%esp), %ebx  # shift frame cell
    mov %ebx, -4(%esp)  # down to base
# emit-shift-args:  size=4   si=-28  delta=20
    mov -28(%esp), %ebx  # shift frame cell
    mov %ebx, -8(%esp)  # down to base
# emit-shift-args:  size=3   si=-32  delta=20
    mov -32(%esp), %ebx  # shift frame cell
    mov %ebx, -12(%esp)  # down to base
# emit-shift-args:  size=2   si=-36  delta=20
    mov -36(%esp), %ebx  # shift frame cell
    mov %ebx, -16(%esp)  # down to base
# emit-shift-args:  size=1   si=-40  delta=20
    mov -40(%esp), %ebx  # shift frame cell
    mov %ebx, -20(%esp)  # down to base
# emit-shift-args:  size=0   si=-44  delta=20
    movl $16,%eax   # save arg count
    jmp *-2(%edi)  # tail-funcall
    jmp _L_73
_L_72:
# emit-tail-expr
# si=-24
<<<<<<< HEAD
# env=((f310803 . -20) (f310804 . -16) (f310803 . -12) (f310804 . -8) (f310789 . 8) (f310791 . 4) (f310788 . -12) (f310789 . -8) (f310790 . -4) (f310791 . 0))
=======
# env=((f17 . -20) (f16 . -16) (f17 . -12) (f16 . -8) (f2 . 8) (f4 . 4) (f1 . -12) (f2 . -8) (f3 . -4) (f4 . 0))
>>>>>>> fix-implicit-begins
# expr=#f
    movl $47, %eax     # immed #f
    ret                  # immediate tail return
_L_73:
    .align 4,0x90
_L_70:
    movl -16(%esp), %ebx
    movl -20(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin)
# emit-begin
#   expr=(begin)
#   env=((f1 . -12) (f2 . -8) (f3 . -4) (f4 . 0))
# emit-expr (begin (vector-ref f1 0))
# emit-begin
#   expr=(begin (vector-ref f1 0))
#   env=((f1 . -12) (f2 . -8) (f3 . -4) (f4 . 0))
# emit-expr (vector-ref f1 0)
# emit-expr f1
# emit-variable-ref
# env=((f1 . -12) (f2 . -8) (f3 . -4) (f4 . 0))
# var=f1
    movl -12(%esp), %eax  # stack load f1
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_84
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_84:
    movl %eax, -16(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_85"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_85:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_87
    cmp  $0,%eax
    jge _L_86
_L_87:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_86:
    movl -16(%esp), %esi
    movl -1(%eax,%esi), %eax
# emit-expr (begin)
# emit-begin
#   expr=(begin)
#   env=((f1 . -12) (f2 . -8) (f3 . -4) (f4 . 0))
     movl %eax, mrc_string$e$q
# == explicit-begins  ==>
# (letrec ((str->sym (lambda (str symlist) (if (string=? str (symbol->string (car symlist))) (car symlist) (if (null? (cdr symlist)) (let* ((new-sym (make-symbol str #f)) (new-cdr (cons new-sym ()))) (begin (set-cdr! symlist new-cdr) new-sym)) (str->sym str (cdr symlist))))))) (lambda (str) (str->sym str (symbols))))
# == eliminate-let*  ==>
# (letrec ((str->sym (lambda (str symlist) (if (string=? str (symbol->string (car symlist))) (car symlist) (if (null? (cdr symlist)) (let ((new-sym (make-symbol str #f))) (let ((new-cdr (cons new-sym ()))) (begin (set-cdr! symlist new-cdr) new-sym))) (str->sym str (cdr symlist))))))) (lambda (str) (str->sym str (symbols))))
# == uniquify-variables  ==>
<<<<<<< HEAD
# (letrec ((f310814 (lambda (f310824 f310823) (if (string=? f310824 (symbol->string (car f310823))) (car f310823) (if (null? (cdr f310823)) (let ((f310828 (make-symbol f310824 #f))) (let ((f310830 (cons f310828 ()))) (begin (set-cdr! f310823 f310830) f310828))) (f310814 f310824 (cdr f310823))))))) (lambda (f310832) (f310814 f310832 (symbols))))
# == vectorize-letrec  ==>
# (let ((f310814 (make-vector 1))) (begin (begin (vector-set! f310814 0 (lambda (f310824 f310823) (if (string=? f310824 (symbol->string (car f310823))) (car f310823) (if (null? (cdr f310823)) (let ((f310828 (make-symbol f310824 #f))) (let ((f310830 (cons f310828 ()))) (begin (set-cdr! f310823 f310830) f310828))) ((vector-ref f310814 0) f310824 (cdr f310823))))))) (lambda (f310832) ((vector-ref f310814 0) f310832 (symbols)))))
# == eliminate-set!  ==>
# (let ((f310814 (make-vector 1))) (begin (begin (vector-set! f310814 0 (lambda (f310824 f310823) (let ((f310824 f310824) (f310823 f310823)) (if (string=? f310824 (symbol->string (car f310823))) (car f310823) (if (null? (cdr f310823)) (let ((f310828 (make-symbol f310824 #f))) (let ((f310830 (cons f310828 ()))) (begin (set-cdr! f310823 f310830) f310828))) ((vector-ref f310814 0) f310824 (cdr f310823)))))))) (lambda (f310832) (let ((f310832 f310832)) ((vector-ref f310814 0) f310832 (symbols))))))
# == close-free-variables  ==>
# (let ((f310814 (make-vector 1))) (begin (begin (vector-set! f310814 0 (closure (f310824 f310823) (f310814) (let ((f310824 f310824) (f310823 f310823)) (if (string=? f310824 (symbol->string (car f310823))) (car f310823) (if (null? (cdr f310823)) (let ((f310828 (make-symbol f310824 #f))) (let ((f310830 (cons f310828 ()))) (begin (set-cdr! f310823 f310830) f310828))) ((vector-ref f310814 0) f310824 (cdr f310823)))))))) (closure (f310832) (f310814) (let ((f310832 f310832)) ((vector-ref f310814 0) f310832 (symbols))))))
# == eliminate-quote  ==>
# (let ((f310814 (make-vector 1))) (begin (begin (vector-set! f310814 0 (closure (f310824 f310823) (f310814) (let ((f310824 f310824) (f310823 f310823)) (if (string=? f310824 (symbol->string (car f310823))) (car f310823) (if (null? (cdr f310823)) (let ((f310828 (make-symbol f310824 #f))) (let ((f310830 (cons f310828 ()))) (begin (set-cdr! f310823 f310830) f310828))) ((vector-ref f310814 0) f310824 (cdr f310823)))))))) (closure (f310832) (f310814) (let ((f310832 f310832)) ((vector-ref f310814 0) f310832 (symbols))))))
# == eliminate-when/unless  ==>
# (let ((f310814 (make-vector 1))) (begin (begin (vector-set! f310814 0 (closure (f310824 f310823) (f310814) (let ((f310824 f310824) (f310823 f310823)) (if (string=? f310824 (symbol->string (car f310823))) (car f310823) (if (null? (cdr f310823)) (let ((f310828 (make-symbol f310824 #f))) (let ((f310830 (cons f310828 ()))) (begin (set-cdr! f310823 f310830) f310828))) ((vector-ref f310814 0) f310824 (cdr f310823)))))))) (closure (f310832) (f310814) (let ((f310832 f310832)) ((vector-ref f310814 0) f310832 (symbols))))))
# == eliminate-cond  ==>
# (let ((f310814 (make-vector 1))) (begin (begin (vector-set! f310814 0 (closure (f310824 f310823) (f310814) (let ((f310824 f310824) (f310823 f310823)) (if (string=? f310824 (symbol->string (car f310823))) (car f310823) (if (null? (cdr f310823)) (let ((f310828 (make-symbol f310824 #f))) (let ((f310830 (cons f310828 ()))) (begin (set-cdr! f310823 f310830) f310828))) ((vector-ref f310814 0) f310824 (cdr f310823)))))))) (closure (f310832) (f310814) (let ((f310832 f310832)) ((vector-ref f310814 0) f310832 (symbols))))))
# == external-symbols  ==>
# (let ((f310814 (make-vector 1))) (begin (begin (vector-set! f310814 0 (closure (f310824 f310823) (f310814) (let ((f310824 f310824) (f310823 f310823)) (if ((primitive-ref string=?) f310824 (symbol->string (car f310823))) (car f310823) (if (null? (cdr f310823)) (let ((f310828 (make-symbol f310824 #f))) (let ((f310830 (cons f310828 ()))) (begin (set-cdr! f310823 f310830) f310828))) ((vector-ref f310814 0) f310824 (cdr f310823)))))))) (closure (f310832) (f310814) (let ((f310832 f310832)) ((vector-ref f310814 0) f310832 ((primitive-ref symbols)))))))
# emit-expr (let ((f310814 (make-vector 1))) (begin (begin (vector-set! f310814 0 (closure (f310824 f310823) (f310814) (let ((f310824 f310824) (f310823 f310823)) (if ((primitive-ref string=?) f310824 (symbol->string (car f310823))) (car f310823) (if (null? (cdr f310823)) (let ((f310828 (make-symbol f310824 #f))) (let ((f310830 (cons f310828 ()))) (begin (set-cdr! f310823 f310830) f310828))) ((vector-ref f310814 0) f310824 (cdr f310823)))))))) (closure (f310832) (f310814) (let ((f310832 f310832)) ((vector-ref f310814 0) f310832 ((primitive-ref symbols)))))))
# emit-let
#  si   = 0
#  env  = ()
#  bindings = ((f310814 (make-vector 1)))
#  body = (begin (begin (vector-set! f310814 0 (closure (f310824 f310823) (f310814) (let ((f310824 f310824) (f310823 f310823)) (if ((primitive-ref string=?) f310824 (symbol->string (car f310823))) (car f310823) (if (null? (cdr f310823)) (let ((f310828 (make-symbol f310824 #f))) (let ((f310830 (cons f310828 ()))) (begin (set-cdr! f310823 f310830) f310828))) ((vector-ref f310814 0) f310824 (cdr f310823)))))))) (closure (f310832) (f310814) (let ((f310832 f310832)) ((vector-ref f310814 0) f310832 ((primitive-ref symbols))))))
=======
# (letrec ((f27 (lambda (f36 f37) (if (string=? f36 (symbol->string (car f37))) (car f37) (if (null? (cdr f37)) (let ((f41 (make-symbol f36 #f))) (let ((f43 (cons f41 ()))) (begin (set-cdr! f37 f43) f41))) (f27 f36 (cdr f37))))))) (lambda (f45) (f27 f45 (symbols))))
# == vectorize-letrec  ==>
# (let ((f27 (make-vector 1))) (begin (begin (vector-set! f27 0 (lambda (f36 f37) (if (string=? f36 (symbol->string (car f37))) (car f37) (if (null? (cdr f37)) (let ((f41 (make-symbol f36 #f))) (let ((f43 (cons f41 ()))) (begin (set-cdr! f37 f43) f41))) ((vector-ref f27 0) f36 (cdr f37))))))) (lambda (f45) ((vector-ref f27 0) f45 (symbols)))))
# == eliminate-set!  ==>
# (let ((f27 (make-vector 1))) (begin (begin (vector-set! f27 0 (lambda (f36 f37) (let ((f36 f36) (f37 f37)) (if (string=? f36 (symbol->string (car f37))) (car f37) (if (null? (cdr f37)) (let ((f41 (make-symbol f36 #f))) (let ((f43 (cons f41 ()))) (begin (set-cdr! f37 f43) f41))) ((vector-ref f27 0) f36 (cdr f37)))))))) (lambda (f45) (let ((f45 f45)) ((vector-ref f27 0) f45 (symbols))))))
# == close-free-variables  ==>
# (let ((f27 (make-vector 1))) (begin (begin (vector-set! f27 0 (closure (f36 f37) (f27) (let ((f36 f36) (f37 f37)) (if (string=? f36 (symbol->string (car f37))) (car f37) (if (null? (cdr f37)) (let ((f41 (make-symbol f36 #f))) (let ((f43 (cons f41 ()))) (begin (set-cdr! f37 f43) f41))) ((vector-ref f27 0) f36 (cdr f37)))))))) (closure (f45) (f27) (let ((f45 f45)) ((vector-ref f27 0) f45 (symbols))))))
# == eliminate-quote  ==>
# (let ((f27 (make-vector 1))) (begin (begin (vector-set! f27 0 (closure (f36 f37) (f27) (let ((f36 f36) (f37 f37)) (if (string=? f36 (symbol->string (car f37))) (car f37) (if (null? (cdr f37)) (let ((f41 (make-symbol f36 #f))) (let ((f43 (cons f41 ()))) (begin (set-cdr! f37 f43) f41))) ((vector-ref f27 0) f36 (cdr f37)))))))) (closure (f45) (f27) (let ((f45 f45)) ((vector-ref f27 0) f45 (symbols))))))
# == eliminate-when/unless  ==>
# (let ((f27 (make-vector 1))) (begin (begin (vector-set! f27 0 (closure (f36 f37) (f27) (let ((f36 f36) (f37 f37)) (if (string=? f36 (symbol->string (car f37))) (car f37) (if (null? (cdr f37)) (let ((f41 (make-symbol f36 #f))) (let ((f43 (cons f41 ()))) (begin (set-cdr! f37 f43) f41))) ((vector-ref f27 0) f36 (cdr f37)))))))) (closure (f45) (f27) (let ((f45 f45)) ((vector-ref f27 0) f45 (symbols))))))
# == eliminate-cond  ==>
# (let ((f27 (make-vector 1))) (begin (begin (vector-set! f27 0 (closure (f36 f37) (f27) (let ((f36 f36) (f37 f37)) (if (string=? f36 (symbol->string (car f37))) (car f37) (if (null? (cdr f37)) (let ((f41 (make-symbol f36 #f))) (let ((f43 (cons f41 ()))) (begin (set-cdr! f37 f43) f41))) ((vector-ref f27 0) f36 (cdr f37)))))))) (closure (f45) (f27) (let ((f45 f45)) ((vector-ref f27 0) f45 (symbols))))))
# == external-symbols  ==>
# (let ((f27 (make-vector 1))) (begin (begin (vector-set! f27 0 (closure (f36 f37) (f27) (let ((f36 f36) (f37 f37)) (if ((primitive-ref string=?) f36 (symbol->string (car f37))) (car f37) (if (null? (cdr f37)) (let ((f41 (make-symbol f36 #f))) (let ((f43 (cons f41 ()))) (begin (set-cdr! f37 f43) f41))) ((vector-ref f27 0) f36 (cdr f37)))))))) (closure (f45) (f27) (let ((f45 f45)) ((vector-ref f27 0) f45 ((primitive-ref symbols)))))))
# emit-expr (let ((f27 (make-vector 1))) (begin (begin (vector-set! f27 0 (closure (f36 f37) (f27) (let ((f36 f36) (f37 f37)) (if ((primitive-ref string=?) f36 (symbol->string (car f37))) (car f37) (if (null? (cdr f37)) (let ((f41 (make-symbol f36 #f))) (let ((f43 (cons f41 ()))) (begin (set-cdr! f37 f43) f41))) ((vector-ref f27 0) f36 (cdr f37)))))))) (closure (f45) (f27) (let ((f45 f45)) ((vector-ref f27 0) f45 ((primitive-ref symbols)))))))
# emit-let
#  si   = 0
#  env  = ()
#  bindings = ((f27 (make-vector 1)))
#  body = (begin (begin (vector-set! f27 0 (closure (f36 f37) (f27) (let ((f36 f36) (f37 f37)) (if ((primitive-ref string=?) f36 (symbol->string (car f37))) (car f37) (if (null? (cdr f37)) (let ((f41 (make-symbol f36 #f))) (let ((f43 (cons f41 ()))) (begin (set-cdr! f37 f43) f41))) ((vector-ref f27 0) f36 (cdr f37)))))))) (closure (f45) (f27) (let ((f45 f45)) ((vector-ref f27 0) f45 ((primitive-ref symbols))))))
>>>>>>> fix-implicit-begins
# emit-expr (make-vector 1)
# make-vector 1
# emit-expr 1
    movl $4, %eax     # immed 1
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_88"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_88:
# check the argument is a fixnum >= 0
    cmp $0,%eax
    jge _L_89
# invoke error handler eh_length
    .extern mrc_eh$ulength
    movl mrc_eh$ulength, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_89:
    movl %eax, %esi
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    orl  $5, %eax
    addl $4, %esi
    addl $4, %esi
    andl $-8, %esi
    addl %esi, %ebp
    movl %eax, 0(%esp)  # stack save
<<<<<<< HEAD
# emit-expr (begin (begin (vector-set! f310814 0 (closure (f310824 f310823) (f310814) (let ((f310824 f310824) (f310823 f310823)) (if ((primitive-ref string=?) f310824 (symbol->string (car f310823))) (car f310823) (if (null? (cdr f310823)) (let ((f310828 (make-symbol f310824 #f))) (let ((f310830 (cons f310828 ()))) (begin (set-cdr! f310823 f310830) f310828))) ((vector-ref f310814 0) f310824 (cdr f310823)))))))) (closure (f310832) (f310814) (let ((f310832 f310832)) ((vector-ref f310814 0) f310832 ((primitive-ref symbols))))))
# emit-begin
#   expr=(begin (begin (vector-set! f310814 0 (closure (f310824 f310823) (f310814) (let ((f310824 f310824) (f310823 f310823)) (if ((primitive-ref string=?) f310824 (symbol->string (car f310823))) (car f310823) (if (null? (cdr f310823)) (let ((f310828 (make-symbol f310824 #f))) (let ((f310830 (cons f310828 ()))) (begin (set-cdr! f310823 f310830) f310828))) ((vector-ref f310814 0) f310824 (cdr f310823)))))))) (closure (f310832) (f310814) (let ((f310832 f310832)) ((vector-ref f310814 0) f310832 ((primitive-ref symbols))))))
#   env=((f310814 . 0))
# emit-expr (begin (vector-set! f310814 0 (closure (f310824 f310823) (f310814) (let ((f310824 f310824) (f310823 f310823)) (if ((primitive-ref string=?) f310824 (symbol->string (car f310823))) (car f310823) (if (null? (cdr f310823)) (let ((f310828 (make-symbol f310824 #f))) (let ((f310830 (cons f310828 ()))) (begin (set-cdr! f310823 f310830) f310828))) ((vector-ref f310814 0) f310824 (cdr f310823))))))))
# emit-begin
#   expr=(begin (vector-set! f310814 0 (closure (f310824 f310823) (f310814) (let ((f310824 f310824) (f310823 f310823)) (if ((primitive-ref string=?) f310824 (symbol->string (car f310823))) (car f310823) (if (null? (cdr f310823)) (let ((f310828 (make-symbol f310824 #f))) (let ((f310830 (cons f310828 ()))) (begin (set-cdr! f310823 f310830) f310828))) ((vector-ref f310814 0) f310824 (cdr f310823))))))))
#   env=((f310814 . 0))
# emit-expr (vector-set! f310814 0 (closure (f310824 f310823) (f310814) (let ((f310824 f310824) (f310823 f310823)) (if ((primitive-ref string=?) f310824 (symbol->string (car f310823))) (car f310823) (if (null? (cdr f310823)) (let ((f310828 (make-symbol f310824 #f))) (let ((f310830 (cons f310828 ()))) (begin (set-cdr! f310823 f310830) f310828))) ((vector-ref f310814 0) f310824 (cdr f310823)))))))
# emit-expr f310814
=======
# emit-expr (begin (begin (vector-set! f27 0 (closure (f36 f37) (f27) (let ((f36 f36) (f37 f37)) (if ((primitive-ref string=?) f36 (symbol->string (car f37))) (car f37) (if (null? (cdr f37)) (let ((f41 (make-symbol f36 #f))) (let ((f43 (cons f41 ()))) (begin (set-cdr! f37 f43) f41))) ((vector-ref f27 0) f36 (cdr f37)))))))) (closure (f45) (f27) (let ((f45 f45)) ((vector-ref f27 0) f45 ((primitive-ref symbols))))))
# emit-begin
#   expr=(begin (begin (vector-set! f27 0 (closure (f36 f37) (f27) (let ((f36 f36) (f37 f37)) (if ((primitive-ref string=?) f36 (symbol->string (car f37))) (car f37) (if (null? (cdr f37)) (let ((f41 (make-symbol f36 #f))) (let ((f43 (cons f41 ()))) (begin (set-cdr! f37 f43) f41))) ((vector-ref f27 0) f36 (cdr f37)))))))) (closure (f45) (f27) (let ((f45 f45)) ((vector-ref f27 0) f45 ((primitive-ref symbols))))))
#   env=((f27 . 0))
# emit-expr (begin (vector-set! f27 0 (closure (f36 f37) (f27) (let ((f36 f36) (f37 f37)) (if ((primitive-ref string=?) f36 (symbol->string (car f37))) (car f37) (if (null? (cdr f37)) (let ((f41 (make-symbol f36 #f))) (let ((f43 (cons f41 ()))) (begin (set-cdr! f37 f43) f41))) ((vector-ref f27 0) f36 (cdr f37))))))))
# emit-begin
#   expr=(begin (vector-set! f27 0 (closure (f36 f37) (f27) (let ((f36 f36) (f37 f37)) (if ((primitive-ref string=?) f36 (symbol->string (car f37))) (car f37) (if (null? (cdr f37)) (let ((f41 (make-symbol f36 #f))) (let ((f43 (cons f41 ()))) (begin (set-cdr! f37 f43) f41))) ((vector-ref f27 0) f36 (cdr f37))))))))
#   env=((f27 . 0))
# emit-expr (vector-set! f27 0 (closure (f36 f37) (f27) (let ((f36 f36) (f37 f37)) (if ((primitive-ref string=?) f36 (symbol->string (car f37))) (car f37) (if (null? (cdr f37)) (let ((f41 (make-symbol f36 #f))) (let ((f43 (cons f41 ()))) (begin (set-cdr! f37 f43) f41))) ((vector-ref f27 0) f36 (cdr f37)))))))
# emit-expr f27
>>>>>>> fix-implicit-begins
# emit-variable-ref
# env=((f27 . 0))
# var=f27
    movl 0(%esp), %eax  # stack load f27
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_90
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_90:
    movl %eax, -4(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_91"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_91:
# check bounds on vector index
    movl -4(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_93
    cmp  $0,%eax
    jge _L_92
_L_93:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_92:
    movl %eax, -8(%esp)
<<<<<<< HEAD
# emit-expr (closure (f310824 f310823) (f310814) (let ((f310824 f310824) (f310823 f310823)) (if ((primitive-ref string=?) f310824 (symbol->string (car f310823))) (car f310823) (if (null? (cdr f310823)) (let ((f310828 (make-symbol f310824 #f))) (let ((f310830 (cons f310828 ()))) (begin (set-cdr! f310823 f310830) f310828))) ((vector-ref f310814 0) f310824 (cdr f310823))))))
# emit-closure
# si = -12
# env = ((f310814 . 0))
# expr = (closure (f310824 f310823) (f310814) (let ((f310824 f310824) (f310823 f310823)) (if ((primitive-ref string=?) f310824 (symbol->string (car f310823))) (car f310823) (if (null? (cdr f310823)) (let ((f310828 (make-symbol f310824 #f))) (let ((f310830 (cons f310828 ()))) (begin (set-cdr! f310823 f310830) f310828))) ((vector-ref f310814 0) f310824 (cdr f310823))))))
    movl $_L_1883693, 0(%ebp)  # closure label
=======
# emit-expr (closure (f36 f37) (f27) (let ((f36 f36) (f37 f37)) (if ((primitive-ref string=?) f36 (symbol->string (car f37))) (car f37) (if (null? (cdr f37)) (let ((f41 (make-symbol f36 #f))) (let ((f43 (cons f41 ()))) (begin (set-cdr! f37 f43) f41))) ((vector-ref f27 0) f36 (cdr f37))))))
# emit-closure
# si = -12
# env = ((f27 . 0))
# expr = (closure (f36 f37) (f27) (let ((f36 f36) (f37 f37)) (if ((primitive-ref string=?) f36 (symbol->string (car f37))) (car f37) (if (null? (cdr f37)) (let ((f41 (make-symbol f36 #f))) (let ((f43 (cons f41 ()))) (begin (set-cdr! f37 f43) f41))) ((vector-ref f27 0) f36 (cdr f37))))))
    movl $_L_94, 0(%ebp)  # closure label
>>>>>>> fix-implicit-begins
# emit-variable-ref
# env=((f27 . 0))
# var=f27
    movl 0(%esp), %eax  # stack load f27
# end emit-variable-ref
   movl  %eax, 4(%ebp)  # f27
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $8, %ebp     # bump ebp
    jmp _L_95            # jump around closure body
_L_94:
# check argument count
    cmp $8,%eax
    je _L_96
# invoke error handler eh_argcount
    .extern mrc_eh$uargcount
    movl mrc_eh$uargcount, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_96:
# emit-tail-expr
# si=-16
<<<<<<< HEAD
# env=((f310823 . -12) (f310824 . -8) (f310814 . 4) (f310814 . 0))
# expr=(let ((f310824 f310824) (f310823 f310823)) (if ((primitive-ref string=?) f310824 (symbol->string (car f310823))) (car f310823) (if (null? (cdr f310823)) (let ((f310828 (make-symbol f310824 #f))) (let ((f310830 (cons f310828 ()))) (begin (set-cdr! f310823 f310830) f310828))) ((vector-ref f310814 0) f310824 (cdr f310823)))))
# emit-tail-let
#  si   = -16
#  env  = ((f310823 . -12) (f310824 . -8) (f310814 . 4) (f310814 . 0))
#  bindings = ((f310824 f310824) (f310823 f310823))
#  body = (if ((primitive-ref string=?) f310824 (symbol->string (car f310823))) (car f310823) (if (null? (cdr f310823)) (let ((f310828 (make-symbol f310824 #f))) (let ((f310830 (cons f310828 ()))) (begin (set-cdr! f310823 f310830) f310828))) ((vector-ref f310814 0) f310824 (cdr f310823))))
# emit-expr f310824
# emit-variable-ref
# env=((f310823 . -12) (f310824 . -8) (f310814 . 4) (f310814 . 0))
# var=f310824
    movl -8(%esp), %eax  # stack load f310824
# end emit-variable-ref
    movl %eax, -16(%esp)  # stack save
# emit-expr f310823
# emit-variable-ref
# env=((f310823 . -12) (f310824 . -8) (f310814 . 4) (f310814 . 0))
# var=f310823
    movl -12(%esp), %eax  # stack load f310823
=======
# env=((f37 . -12) (f36 . -8) (f27 . 4) (f27 . 0))
# expr=(let ((f36 f36) (f37 f37)) (if ((primitive-ref string=?) f36 (symbol->string (car f37))) (car f37) (if (null? (cdr f37)) (let ((f41 (make-symbol f36 #f))) (let ((f43 (cons f41 ()))) (begin (set-cdr! f37 f43) f41))) ((vector-ref f27 0) f36 (cdr f37)))))
# emit-tail-let
#  si   = -16
#  env  = ((f37 . -12) (f36 . -8) (f27 . 4) (f27 . 0))
#  bindings = ((f36 f36) (f37 f37))
#  body = (if ((primitive-ref string=?) f36 (symbol->string (car f37))) (car f37) (if (null? (cdr f37)) (let ((f41 (make-symbol f36 #f))) (let ((f43 (cons f41 ()))) (begin (set-cdr! f37 f43) f41))) ((vector-ref f27 0) f36 (cdr f37))))
# emit-expr f36
# emit-variable-ref
# env=((f37 . -12) (f36 . -8) (f27 . 4) (f27 . 0))
# var=f36
    movl -8(%esp), %eax  # stack load f36
# end emit-variable-ref
    movl %eax, -16(%esp)  # stack save
# emit-expr f37
# emit-variable-ref
# env=((f37 . -12) (f36 . -8) (f27 . 4) (f27 . 0))
# var=f37
    movl -12(%esp), %eax  # stack load f37
>>>>>>> fix-implicit-begins
# end emit-variable-ref
    movl %eax, -20(%esp)  # stack save
# emit-tail-expr
# si=-24
<<<<<<< HEAD
# env=((f310823 . -20) (f310824 . -16) (f310823 . -12) (f310824 . -8) (f310814 . 4) (f310814 . 0))
# expr=(if ((primitive-ref string=?) f310824 (symbol->string (car f310823))) (car f310823) (if (null? (cdr f310823)) (let ((f310828 (make-symbol f310824 #f))) (let ((f310830 (cons f310828 ()))) (begin (set-cdr! f310823 f310830) f310828))) ((vector-ref f310814 0) f310824 (cdr f310823))))
# emit-expr ((primitive-ref string=?) f310824 (symbol->string (car f310823)))
# funcall
#    si   =-24
#    env  = ((f310823 . -20) (f310824 . -16) (f310823 . -12) (f310824 . -8) (f310814 . 4) (f310814 . 0))
#    expr = (funcall (primitive-ref string=?) f310824 (symbol->string (car f310823)))
=======
# env=((f37 . -20) (f36 . -16) (f37 . -12) (f36 . -8) (f27 . 4) (f27 . 0))
# expr=(if ((primitive-ref string=?) f36 (symbol->string (car f37))) (car f37) (if (null? (cdr f37)) (let ((f41 (make-symbol f36 #f))) (let ((f43 (cons f41 ()))) (begin (set-cdr! f37 f43) f41))) ((vector-ref f27 0) f36 (cdr f37))))
# emit-expr ((primitive-ref string=?) f36 (symbol->string (car f37)))
# funcall
#    si   =-24
#    env  = ((f37 . -20) (f36 . -16) (f37 . -12) (f36 . -8) (f27 . 4) (f27 . 0))
#    expr = (funcall (primitive-ref string=?) f36 (symbol->string (car f37)))
>>>>>>> fix-implicit-begins
# emit-expr (primitive-ref string=?)
    .extern mrc_string$e$q
    movl mrc_string$e$q,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_99"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_99":
   movl %eax,  -32(%esp)  # stash funcall-oper in closure slot
<<<<<<< HEAD
# emit-expr f310824
# emit-variable-ref
# env=((f310823 . -20) (f310824 . -16) (f310823 . -12) (f310824 . -8) (f310814 . 4) (f310814 . 0))
# var=f310824
    movl -16(%esp), %eax  # stack load f310824
# end emit-variable-ref
    mov %eax, -36(%esp)  # arg f310824
# emit-expr (symbol->string (car f310823))
# symbol->string (car f310823)
# emit-expr (car f310823)
# emit-expr f310823
# emit-variable-ref
# env=((f310823 . -20) (f310824 . -16) (f310823 . -12) (f310824 . -8) (f310814 . 4) (f310814 . 0))
# var=f310823
    movl -20(%esp), %eax  # stack load f310823
=======
# emit-expr f36
# emit-variable-ref
# env=((f37 . -20) (f36 . -16) (f37 . -12) (f36 . -8) (f27 . 4) (f27 . 0))
# var=f36
    movl -16(%esp), %eax  # stack load f36
# end emit-variable-ref
    mov %eax, -36(%esp)  # arg f36
# emit-expr (symbol->string (car f37))
# symbol->string (car f37)
# emit-expr (car f37)
# emit-expr f37
# emit-variable-ref
# env=((f37 . -20) (f36 . -16) (f37 . -12) (f36 . -8) (f27 . 4) (f27 . 0))
# var=f37
    movl -20(%esp), %eax  # stack load f37
>>>>>>> fix-implicit-begins
# end emit-variable-ref
# check the argument is a pair
    movl %eax,%ebx
    and $7, %bl
    cmp $1, %bl
    je _L_100
# invoke error handler eh_pair
    .extern mrc_eh$upair
    movl mrc_eh$upair, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $116,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_100:
    movl -1(%eax), %eax
    movl -3(%eax), %eax
<<<<<<< HEAD
    mov %eax, -40(%esp)  # arg (symbol->string (car f310823))
=======
    mov %eax, -40(%esp)  # arg (symbol->string (car f37))
>>>>>>> fix-implicit-begins
    movl -32(%esp), %edi   # load new closure to %edi
    add $-24, %esp   # adjust base
    movl $8,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $24, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    cmp $47, %al
    je _L_97
# emit-tail-expr
# si=-24
<<<<<<< HEAD
# env=((f310823 . -20) (f310824 . -16) (f310823 . -12) (f310824 . -8) (f310814 . 4) (f310814 . 0))
# expr=(car f310823)
# tail primcall
# emit-expr f310823
# emit-variable-ref
# env=((f310823 . -20) (f310824 . -16) (f310823 . -12) (f310824 . -8) (f310814 . 4) (f310814 . 0))
# var=f310823
    movl -20(%esp), %eax  # stack load f310823
=======
# env=((f37 . -20) (f36 . -16) (f37 . -12) (f36 . -8) (f27 . 4) (f27 . 0))
# expr=(car f37)
# tail primcall
# emit-expr f37
# emit-variable-ref
# env=((f37 . -20) (f36 . -16) (f37 . -12) (f36 . -8) (f27 . 4) (f27 . 0))
# var=f37
    movl -20(%esp), %eax  # stack load f37
>>>>>>> fix-implicit-begins
# end emit-variable-ref
# check the argument is a pair
    movl %eax,%ebx
    and $7, %bl
    cmp $1, %bl
    je _L_101
# invoke error handler eh_pair
    .extern mrc_eh$upair
    movl mrc_eh$upair, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $116,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_101:
    movl -1(%eax), %eax
<<<<<<< HEAD
#return from tail (car f310823)
=======
#return from tail (car f37)
>>>>>>> fix-implicit-begins
    ret
    jmp _L_98
_L_97:
# emit-tail-expr
# si=-24
<<<<<<< HEAD
# env=((f310823 . -20) (f310824 . -16) (f310823 . -12) (f310824 . -8) (f310814 . 4) (f310814 . 0))
# expr=(if (null? (cdr f310823)) (let ((f310828 (make-symbol f310824 #f))) (let ((f310830 (cons f310828 ()))) (begin (set-cdr! f310823 f310830) f310828))) ((vector-ref f310814 0) f310824 (cdr f310823)))
# emit-expr (null? (cdr f310823))
# emit-expr (cdr f310823)
# emit-expr f310823
# emit-variable-ref
# env=((f310823 . -20) (f310824 . -16) (f310823 . -12) (f310824 . -8) (f310814 . 4) (f310814 . 0))
# var=f310823
    movl -20(%esp), %eax  # stack load f310823
=======
# env=((f37 . -20) (f36 . -16) (f37 . -12) (f36 . -8) (f27 . 4) (f27 . 0))
# expr=(if (null? (cdr f37)) (let ((f41 (make-symbol f36 #f))) (let ((f43 (cons f41 ()))) (begin (set-cdr! f37 f43) f41))) ((vector-ref f27 0) f36 (cdr f37)))
# emit-expr (null? (cdr f37))
# emit-expr (cdr f37)
# emit-expr f37
# emit-variable-ref
# env=((f37 . -20) (f36 . -16) (f37 . -12) (f36 . -8) (f27 . 4) (f27 . 0))
# var=f37
    movl -20(%esp), %eax  # stack load f37
>>>>>>> fix-implicit-begins
# end emit-variable-ref
# check the argument is a pair
    movl %eax,%ebx
    and $7, %bl
    cmp $1, %bl
    je _L_104
# invoke error handler eh_pair
    .extern mrc_eh$upair
    movl mrc_eh$upair, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $120,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_104:
    movl 3(%eax), %eax
    cmp $63, %eax
    mov $0, %eax
    sete %al
    movzbl %al, %eax
    sal $6, %al
    or $47, %al
    cmp $47, %al
    je _L_102
# emit-tail-expr
# si=-24
<<<<<<< HEAD
# env=((f310823 . -20) (f310824 . -16) (f310823 . -12) (f310824 . -8) (f310814 . 4) (f310814 . 0))
# expr=(let ((f310828 (make-symbol f310824 #f))) (let ((f310830 (cons f310828 ()))) (begin (set-cdr! f310823 f310830) f310828)))
# emit-tail-let
#  si   = -24
#  env  = ((f310823 . -20) (f310824 . -16) (f310823 . -12) (f310824 . -8) (f310814 . 4) (f310814 . 0))
#  bindings = ((f310828 (make-symbol f310824 #f)))
#  body = (let ((f310830 (cons f310828 ()))) (begin (set-cdr! f310823 f310830) f310828))
# emit-expr (make-symbol f310824 #f)
# make-symbol arg1=f310824 arg2=#f
# emit-expr f310824
# emit-variable-ref
# env=((f310823 . -20) (f310824 . -16) (f310823 . -12) (f310824 . -8) (f310814 . 4) (f310814 . 0))
# var=f310824
    movl -16(%esp), %eax  # stack load f310824
=======
# env=((f37 . -20) (f36 . -16) (f37 . -12) (f36 . -8) (f27 . 4) (f27 . 0))
# expr=(let ((f41 (make-symbol f36 #f))) (let ((f43 (cons f41 ()))) (begin (set-cdr! f37 f43) f41)))
# emit-tail-let
#  si   = -24
#  env  = ((f37 . -20) (f36 . -16) (f37 . -12) (f36 . -8) (f27 . 4) (f27 . 0))
#  bindings = ((f41 (make-symbol f36 #f)))
#  body = (let ((f43 (cons f41 ()))) (begin (set-cdr! f37 f43) f41))
# emit-expr (make-symbol f36 #f)
# make-symbol arg1=f36 arg2=#f
# emit-expr f36
# emit-variable-ref
# env=((f37 . -20) (f36 . -16) (f37 . -12) (f36 . -8) (f27 . 4) (f27 . 0))
# var=f36
    movl -16(%esp), %eax  # stack load f36
>>>>>>> fix-implicit-begins
# end emit-variable-ref
    movl %eax, -24(%esp)
# emit-expr #f
    movl $47, %eax     # immed #f
    movl %eax, 4(%ebp)
    movl -24(%esp), %eax
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    orl  $3, %eax
    add  $8, %ebp
# make-symbol end
    movl %eax, -24(%esp)  # stack save
# emit-tail-expr
# si=-28
<<<<<<< HEAD
# env=((f310828 . -24) (f310823 . -20) (f310824 . -16) (f310823 . -12) (f310824 . -8) (f310814 . 4) (f310814 . 0))
# expr=(let ((f310830 (cons f310828 ()))) (begin (set-cdr! f310823 f310830) f310828))
# emit-tail-let
#  si   = -28
#  env  = ((f310828 . -24) (f310823 . -20) (f310824 . -16) (f310823 . -12) (f310824 . -8) (f310814 . 4) (f310814 . 0))
#  bindings = ((f310830 (cons f310828 ())))
#  body = (begin (set-cdr! f310823 f310830) f310828)
# emit-expr (cons f310828 ())
# cons arg1=f310828 arg2=()
# emit-expr f310828
# emit-variable-ref
# env=((f310828 . -24) (f310823 . -20) (f310824 . -16) (f310823 . -12) (f310824 . -8) (f310814 . 4) (f310814 . 0))
# var=f310828
    movl -24(%esp), %eax  # stack load f310828
=======
# env=((f41 . -24) (f37 . -20) (f36 . -16) (f37 . -12) (f36 . -8) (f27 . 4) (f27 . 0))
# expr=(let ((f43 (cons f41 ()))) (begin (set-cdr! f37 f43) f41))
# emit-tail-let
#  si   = -28
#  env  = ((f41 . -24) (f37 . -20) (f36 . -16) (f37 . -12) (f36 . -8) (f27 . 4) (f27 . 0))
#  bindings = ((f43 (cons f41 ())))
#  body = (begin (set-cdr! f37 f43) f41)
# emit-expr (cons f41 ())
# cons arg1=f41 arg2=()
# emit-expr f41
# emit-variable-ref
# env=((f41 . -24) (f37 . -20) (f36 . -16) (f37 . -12) (f36 . -8) (f27 . 4) (f27 . 0))
# var=f41
    movl -24(%esp), %eax  # stack load f41
>>>>>>> fix-implicit-begins
# end emit-variable-ref
    movl %eax, -28(%esp)
# emit-expr ()
    movl $63, %eax     # immed ()
    movl %eax, 4(%ebp)
    movl -28(%esp), %eax
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    or   $1, %al
    add  $8, %ebp
# cons end
    movl %eax, -28(%esp)  # stack save
# emit-tail-expr
# si=-32
<<<<<<< HEAD
# env=((f310830 . -28) (f310828 . -24) (f310823 . -20) (f310824 . -16) (f310823 . -12) (f310824 . -8) (f310814 . 4) (f310814 . 0))
# expr=(begin (set-cdr! f310823 f310830) f310828)
# tail-begin (begin (set-cdr! f310823 f310830) f310828)
#   env=((f310830 . -28) (f310828 . -24) (f310823 . -20) (f310824 . -16) (f310823 . -12) (f310824 . -8) (f310814 . 4) (f310814 . 0))
# emit-expr (set-cdr! f310823 f310830)
# emit-expr f310823
# emit-variable-ref
# env=((f310830 . -28) (f310828 . -24) (f310823 . -20) (f310824 . -16) (f310823 . -12) (f310824 . -8) (f310814 . 4) (f310814 . 0))
# var=f310823
    movl -20(%esp), %eax  # stack load f310823
=======
# env=((f43 . -28) (f41 . -24) (f37 . -20) (f36 . -16) (f37 . -12) (f36 . -8) (f27 . 4) (f27 . 0))
# expr=(begin (set-cdr! f37 f43) f41)
# tail-begin (begin (set-cdr! f37 f43) f41)
#   env=((f43 . -28) (f41 . -24) (f37 . -20) (f36 . -16) (f37 . -12) (f36 . -8) (f27 . 4) (f27 . 0))
# emit-expr (set-cdr! f37 f43)
# emit-expr f37
# emit-variable-ref
# env=((f43 . -28) (f41 . -24) (f37 . -20) (f36 . -16) (f37 . -12) (f36 . -8) (f27 . 4) (f27 . 0))
# var=f37
    movl -20(%esp), %eax  # stack load f37
>>>>>>> fix-implicit-begins
# end emit-variable-ref
# check the argument is a pair
    movl %eax,%ebx
    and $7, %bl
    cmp $1, %bl
    je _L_105
# invoke error handler eh_pair
    .extern mrc_eh$upair
    movl mrc_eh$upair, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $128,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_105:
    movl %eax, -32(%esp)
# emit-expr f43
# emit-variable-ref
<<<<<<< HEAD
# env=((f310830 . -28) (f310828 . -24) (f310823 . -20) (f310824 . -16) (f310823 . -12) (f310824 . -8) (f310814 . 4) (f310814 . 0))
# var=f310830
    movl -28(%esp), %eax  # stack load f310830
=======
# env=((f43 . -28) (f41 . -24) (f37 . -20) (f36 . -16) (f37 . -12) (f36 . -8) (f27 . 4) (f27 . 0))
# var=f43
    movl -28(%esp), %eax  # stack load f43
>>>>>>> fix-implicit-begins
# end emit-variable-ref
    movl -32(%esp), %ebx
    movl %eax, 3(%ebx)
# emit-tail-expr
# si=-32
<<<<<<< HEAD
# env=((f310830 . -28) (f310828 . -24) (f310823 . -20) (f310824 . -16) (f310823 . -12) (f310824 . -8) (f310814 . 4) (f310814 . 0))
# expr=(begin f310828)
# tail-begin (begin f310828)
#   env=((f310830 . -28) (f310828 . -24) (f310823 . -20) (f310824 . -16) (f310823 . -12) (f310824 . -8) (f310814 . 4) (f310814 . 0))
# emit-tail-expr
# si=-32
# env=((f310830 . -28) (f310828 . -24) (f310823 . -20) (f310824 . -16) (f310823 . -12) (f310824 . -8) (f310814 . 4) (f310814 . 0))
# expr=f310828
# emit-tail-variable-ref
# emit-variable-ref
# env=((f310830 . -28) (f310828 . -24) (f310823 . -20) (f310824 . -16) (f310823 . -12) (f310824 . -8) (f310814 . 4) (f310814 . 0))
# var=f310828
    movl -24(%esp), %eax  # stack load f310828
=======
# env=((f43 . -28) (f41 . -24) (f37 . -20) (f36 . -16) (f37 . -12) (f36 . -8) (f27 . 4) (f27 . 0))
# expr=(begin f41)
# tail-begin (begin f41)
#   env=((f43 . -28) (f41 . -24) (f37 . -20) (f36 . -16) (f37 . -12) (f36 . -8) (f27 . 4) (f27 . 0))
# emit-tail-expr
# si=-32
# env=((f43 . -28) (f41 . -24) (f37 . -20) (f36 . -16) (f37 . -12) (f36 . -8) (f27 . 4) (f27 . 0))
# expr=f41
# emit-tail-variable-ref
# emit-variable-ref
# env=((f43 . -28) (f41 . -24) (f37 . -20) (f36 . -16) (f37 . -12) (f36 . -8) (f27 . 4) (f27 . 0))
# var=f41
    movl -24(%esp), %eax  # stack load f41
>>>>>>> fix-implicit-begins
# end emit-variable-ref
    ret
# end emit-tail-variable ref
     ret   # return thru stack
    jmp _L_103
_L_102:
# emit-tail-expr
# si=-24
<<<<<<< HEAD
# env=((f310823 . -20) (f310824 . -16) (f310823 . -12) (f310824 . -8) (f310814 . 4) (f310814 . 0))
# expr=((vector-ref f310814 0) f310824 (cdr f310823))
# emit-tail-funcall
#    si   =-24
#    env  = ((f310823 . -20) (f310824 . -16) (f310823 . -12) (f310824 . -8) (f310814 . 4) (f310814 . 0))
#    expr = (funcall (vector-ref f310814 0) f310824 (cdr f310823))
# emit-expr (vector-ref f310814 0)
# emit-expr f310814
# emit-variable-ref
# env=((f310823 . -20) (f310824 . -16) (f310823 . -12) (f310824 . -8) (f310814 . 4) (f310814 . 0))
# var=f310814
    movl 2(%edi), %eax  # frame load f310814
=======
# env=((f37 . -20) (f36 . -16) (f37 . -12) (f36 . -8) (f27 . 4) (f27 . 0))
# expr=((vector-ref f27 0) f36 (cdr f37))
# emit-tail-funcall
#    si   =-24
#    env  = ((f37 . -20) (f36 . -16) (f37 . -12) (f36 . -8) (f27 . 4) (f27 . 0))
#    expr = (funcall (vector-ref f27 0) f36 (cdr f37))
# emit-expr (vector-ref f27 0)
# emit-expr f27
# emit-variable-ref
# env=((f37 . -20) (f36 . -16) (f37 . -12) (f36 . -8) (f27 . 4) (f27 . 0))
# var=f27
    movl 2(%edi), %eax  # frame load f27
>>>>>>> fix-implicit-begins
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_106
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_106:
    movl %eax, -24(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_107"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_107:
# check bounds on vector index
    movl -24(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_109
    cmp  $0,%eax
    jge _L_108
_L_109:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_108:
    movl -24(%esp), %esi
    movl -1(%eax,%esi), %eax
   movl %eax,  -24(%esp)  # stash funcall-oper in next closure slot
<<<<<<< HEAD
# emit-expr f310824
# emit-variable-ref
# env=((f310823 . -20) (f310824 . -16) (f310823 . -12) (f310824 . -8) (f310814 . 4) (f310814 . 0))
# var=f310824
    movl -16(%esp), %eax  # stack load f310824
# end emit-variable-ref
    mov %eax, -28(%esp)    # arg f310824
# emit-expr (cdr f310823)
# emit-expr f310823
# emit-variable-ref
# env=((f310823 . -20) (f310824 . -16) (f310823 . -12) (f310824 . -8) (f310814 . 4) (f310814 . 0))
# var=f310823
    movl -20(%esp), %eax  # stack load f310823
=======
# emit-expr f36
# emit-variable-ref
# env=((f37 . -20) (f36 . -16) (f37 . -12) (f36 . -8) (f27 . 4) (f27 . 0))
# var=f36
    movl -16(%esp), %eax  # stack load f36
# end emit-variable-ref
    mov %eax, -28(%esp)    # arg f36
# emit-expr (cdr f37)
# emit-expr f37
# emit-variable-ref
# env=((f37 . -20) (f36 . -16) (f37 . -12) (f36 . -8) (f27 . 4) (f27 . 0))
# var=f37
    movl -20(%esp), %eax  # stack load f37
>>>>>>> fix-implicit-begins
# end emit-variable-ref
# check the argument is a pair
    movl %eax,%ebx
    and $7, %bl
    cmp $1, %bl
    je _L_110
# invoke error handler eh_pair
    .extern mrc_eh$upair
    movl mrc_eh$upair, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $120,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_110:
    movl 3(%eax), %eax
<<<<<<< HEAD
    mov %eax, -32(%esp)    # arg (cdr f310823)
=======
    mov %eax, -32(%esp)    # arg (cdr f37)
>>>>>>> fix-implicit-begins
    movl -24(%esp), %edi   # load new closure to %edi
# emit-shift-args:  size=3   si=-24  delta=20
    mov -24(%esp), %ebx  # shift frame cell
    mov %ebx, -4(%esp)  # down to base
# emit-shift-args:  size=2   si=-28  delta=20
    mov -28(%esp), %ebx  # shift frame cell
    mov %ebx, -8(%esp)  # down to base
# emit-shift-args:  size=1   si=-32  delta=20
    mov -32(%esp), %ebx  # shift frame cell
    mov %ebx, -12(%esp)  # down to base
# emit-shift-args:  size=0   si=-36  delta=20
    movl $8,%eax   # save arg count
    jmp *-2(%edi)  # tail-funcall
_L_103:
_L_98:
    .align 4,0x90
_L_95:
    movl -4(%esp), %ebx
    movl -8(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin)
# emit-begin
#   expr=(begin)
#   env=((f27 . 0))
# emit-expr (begin (closure (f45) (f27) (let ((f45 f45)) ((vector-ref f27 0) f45 ((primitive-ref symbols))))))
# emit-begin
#   expr=(begin (closure (f45) (f27) (let ((f45 f45)) ((vector-ref f27 0) f45 ((primitive-ref symbols))))))
#   env=((f27 . 0))
# emit-expr (closure (f45) (f27) (let ((f45 f45)) ((vector-ref f27 0) f45 ((primitive-ref symbols)))))
# emit-closure
# si = -4
# env = ((f27 . 0))
# expr = (closure (f45) (f27) (let ((f45 f45)) ((vector-ref f27 0) f45 ((primitive-ref symbols)))))
    movl $_L_111, 0(%ebp)  # closure label
# emit-variable-ref
# env=((f27 . 0))
# var=f27
    movl 0(%esp), %eax  # stack load f27
# end emit-variable-ref
   movl  %eax, 4(%ebp)  # f27
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $8, %ebp     # bump ebp
    jmp _L_112            # jump around closure body
_L_111:
# check argument count
    cmp $4,%eax
    je _L_113
# invoke error handler eh_argcount
    .extern mrc_eh$uargcount
    movl mrc_eh$uargcount, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_113:
# emit-tail-expr
# si=-12
# env=((f45 . -8) (f27 . 4) (f27 . 0))
# expr=(let ((f45 f45)) ((vector-ref f27 0) f45 ((primitive-ref symbols))))
# emit-tail-let
#  si   = -12
#  env  = ((f45 . -8) (f27 . 4) (f27 . 0))
#  bindings = ((f45 f45))
#  body = ((vector-ref f27 0) f45 ((primitive-ref symbols)))
# emit-expr f45
# emit-variable-ref
# env=((f45 . -8) (f27 . 4) (f27 . 0))
# var=f45
    movl -8(%esp), %eax  # stack load f45
# end emit-variable-ref
    movl %eax, -12(%esp)  # stack save
# emit-tail-expr
# si=-16
# env=((f45 . -12) (f45 . -8) (f27 . 4) (f27 . 0))
# expr=((vector-ref f27 0) f45 ((primitive-ref symbols)))
# emit-tail-funcall
#    si   =-16
#    env  = ((f45 . -12) (f45 . -8) (f27 . 4) (f27 . 0))
#    expr = (funcall (vector-ref f27 0) f45 ((primitive-ref symbols)))
# emit-expr (vector-ref f27 0)
# emit-expr f27
# emit-variable-ref
# env=((f45 . -12) (f45 . -8) (f27 . 4) (f27 . 0))
# var=f27
    movl 2(%edi), %eax  # frame load f27
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_114
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_114:
    movl %eax, -16(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_115"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_115:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_117
    cmp  $0,%eax
    jge _L_116
_L_117:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_116:
    movl -16(%esp), %esi
    movl -1(%eax,%esi), %eax
   movl %eax,  -16(%esp)  # stash funcall-oper in next closure slot
# emit-expr f45
# emit-variable-ref
# env=((f45 . -12) (f45 . -8) (f27 . 4) (f27 . 0))
# var=f45
    movl -12(%esp), %eax  # stack load f45
# end emit-variable-ref
    mov %eax, -20(%esp)    # arg f45
# emit-expr ((primitive-ref symbols))
# funcall
#    si   =-24
#    env  = ((f45 . -12) (f45 . -8) (f27 . 4) (f27 . 0))
#    expr = (funcall (primitive-ref symbols))
# emit-expr (primitive-ref symbols)
    .extern mrc_symbols
    movl mrc_symbols,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_118"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_118":
   movl %eax,  -32(%esp)  # stash funcall-oper in closure slot
    movl -32(%esp), %edi   # load new closure to %edi
    add $-24, %esp   # adjust base
    movl $0,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $24, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    mov %eax, -24(%esp)    # arg ((primitive-ref symbols))
    movl -16(%esp), %edi   # load new closure to %edi
# emit-shift-args:  size=3   si=-16  delta=12
    mov -16(%esp), %ebx  # shift frame cell
    mov %ebx, -4(%esp)  # down to base
# emit-shift-args:  size=2   si=-20  delta=12
    mov -20(%esp), %ebx  # shift frame cell
    mov %ebx, -8(%esp)  # down to base
# emit-shift-args:  size=1   si=-24  delta=12
    mov -24(%esp), %ebx  # shift frame cell
    mov %ebx, -12(%esp)  # down to base
# emit-shift-args:  size=0   si=-28  delta=12
    movl $8,%eax   # save arg count
    jmp *-2(%edi)  # tail-funcall
    .align 4,0x90
_L_112:
# emit-expr (begin)
# emit-begin
#   expr=(begin)
#   env=((f27 . 0))
     movl %eax, mrc_string$m$gsymbol
# == explicit-begins  ==>
# (lambda (lst elt) (if (null? lst) (cons elt nil) (cons (car lst) (append1 (cdr lst) elt))))
# == eliminate-let*  ==>
# (lambda (lst elt) (if (null? lst) (cons elt nil) (cons (car lst) (append1 (cdr lst) elt))))
# == uniquify-variables  ==>
<<<<<<< HEAD
# (lambda (f310834 f310833) (if (null? f310834) (cons f310833 nil) (cons (car f310834) (append1 (cdr f310834) f310833))))
# == vectorize-letrec  ==>
# (lambda (f310834 f310833) (if (null? f310834) (cons f310833 nil) (cons (car f310834) (append1 (cdr f310834) f310833))))
# == eliminate-set!  ==>
# (lambda (f310834 f310833) (let ((f310834 f310834) (f310833 f310833)) (if (null? f310834) (cons f310833 nil) (cons (car f310834) (append1 (cdr f310834) f310833)))))
# == close-free-variables  ==>
# (closure (f310834 f310833) (nil) (let ((f310834 f310834) (f310833 f310833)) (if (null? f310834) (cons f310833 nil) (cons (car f310834) (append1 (cdr f310834) f310833)))))
# == eliminate-quote  ==>
# (closure (f310834 f310833) (nil) (let ((f310834 f310834) (f310833 f310833)) (if (null? f310834) (cons f310833 nil) (cons (car f310834) (append1 (cdr f310834) f310833)))))
# == eliminate-when/unless  ==>
# (closure (f310834 f310833) (nil) (let ((f310834 f310834) (f310833 f310833)) (if (null? f310834) (cons f310833 nil) (cons (car f310834) (append1 (cdr f310834) f310833)))))
# == eliminate-cond  ==>
# (closure (f310834 f310833) (nil) (let ((f310834 f310834) (f310833 f310833)) (if (null? f310834) (cons f310833 nil) (cons (car f310834) (append1 (cdr f310834) f310833)))))
# == external-symbols  ==>
# (closure (f310834 f310833) (nil) (let ((f310834 f310834) (f310833 f310833)) (if (null? f310834) (cons f310833 nil) (cons (car f310834) ((primitive-ref append1) (cdr f310834) f310833)))))
# emit-expr (closure (f310834 f310833) (nil) (let ((f310834 f310834) (f310833 f310833)) (if (null? f310834) (cons f310833 nil) (cons (car f310834) ((primitive-ref append1) (cdr f310834) f310833)))))
# emit-closure
# si = 0
# env = ()
# expr = (closure (f310834 f310833) (nil) (let ((f310834 f310834) (f310833 f310833)) (if (null? f310834) (cons f310833 nil) (cons (car f310834) ((primitive-ref append1) (cdr f310834) f310833)))))
    movl $_L_1883718, 0(%ebp)  # closure label
=======
# (lambda (f46 f47) (if (null? f46) (cons f47 nil) (cons (car f46) (append1 (cdr f46) f47))))
# == vectorize-letrec  ==>
# (lambda (f46 f47) (if (null? f46) (cons f47 nil) (cons (car f46) (append1 (cdr f46) f47))))
# == eliminate-set!  ==>
# (lambda (f46 f47) (let ((f46 f46) (f47 f47)) (if (null? f46) (cons f47 nil) (cons (car f46) (append1 (cdr f46) f47)))))
# == close-free-variables  ==>
# (closure (f46 f47) (nil) (let ((f46 f46) (f47 f47)) (if (null? f46) (cons f47 nil) (cons (car f46) (append1 (cdr f46) f47)))))
# == eliminate-quote  ==>
# (closure (f46 f47) (nil) (let ((f46 f46) (f47 f47)) (if (null? f46) (cons f47 nil) (cons (car f46) (append1 (cdr f46) f47)))))
# == eliminate-when/unless  ==>
# (closure (f46 f47) (nil) (let ((f46 f46) (f47 f47)) (if (null? f46) (cons f47 nil) (cons (car f46) (append1 (cdr f46) f47)))))
# == eliminate-cond  ==>
# (closure (f46 f47) (nil) (let ((f46 f46) (f47 f47)) (if (null? f46) (cons f47 nil) (cons (car f46) (append1 (cdr f46) f47)))))
# == external-symbols  ==>
# (closure (f46 f47) (nil) (let ((f46 f46) (f47 f47)) (if (null? f46) (cons f47 nil) (cons (car f46) ((primitive-ref append1) (cdr f46) f47)))))
# emit-expr (closure (f46 f47) (nil) (let ((f46 f46) (f47 f47)) (if (null? f46) (cons f47 nil) (cons (car f46) ((primitive-ref append1) (cdr f46) f47)))))
# emit-closure
# si = 0
# env = ()
# expr = (closure (f46 f47) (nil) (let ((f46 f46) (f47 f47)) (if (null? f46) (cons f47 nil) (cons (car f46) ((primitive-ref append1) (cdr f46) f47)))))
    movl $_L_119, 0(%ebp)  # closure label
>>>>>>> fix-implicit-begins
# WARNING: free var nil not defined in the environmnet
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $8, %ebp     # bump ebp
    jmp _L_120            # jump around closure body
_L_119:
# check argument count
    cmp $8,%eax
    je _L_121
# invoke error handler eh_argcount
    .extern mrc_eh$uargcount
    movl mrc_eh$uargcount, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_121:
# emit-tail-expr
# si=-16
<<<<<<< HEAD
# env=((f310833 . -12) (f310834 . -8) (nil . 4))
# expr=(let ((f310834 f310834) (f310833 f310833)) (if (null? f310834) (cons f310833 nil) (cons (car f310834) ((primitive-ref append1) (cdr f310834) f310833))))
# emit-tail-let
#  si   = -16
#  env  = ((f310833 . -12) (f310834 . -8) (nil . 4))
#  bindings = ((f310834 f310834) (f310833 f310833))
#  body = (if (null? f310834) (cons f310833 nil) (cons (car f310834) ((primitive-ref append1) (cdr f310834) f310833)))
# emit-expr f310834
# emit-variable-ref
# env=((f310833 . -12) (f310834 . -8) (nil . 4))
# var=f310834
    movl -8(%esp), %eax  # stack load f310834
# end emit-variable-ref
    movl %eax, -16(%esp)  # stack save
# emit-expr f310833
# emit-variable-ref
# env=((f310833 . -12) (f310834 . -8) (nil . 4))
# var=f310833
    movl -12(%esp), %eax  # stack load f310833
=======
# env=((f47 . -12) (f46 . -8) (nil . 4))
# expr=(let ((f46 f46) (f47 f47)) (if (null? f46) (cons f47 nil) (cons (car f46) ((primitive-ref append1) (cdr f46) f47))))
# emit-tail-let
#  si   = -16
#  env  = ((f47 . -12) (f46 . -8) (nil . 4))
#  bindings = ((f46 f46) (f47 f47))
#  body = (if (null? f46) (cons f47 nil) (cons (car f46) ((primitive-ref append1) (cdr f46) f47)))
# emit-expr f46
# emit-variable-ref
# env=((f47 . -12) (f46 . -8) (nil . 4))
# var=f46
    movl -8(%esp), %eax  # stack load f46
# end emit-variable-ref
    movl %eax, -16(%esp)  # stack save
# emit-expr f47
# emit-variable-ref
# env=((f47 . -12) (f46 . -8) (nil . 4))
# var=f47
    movl -12(%esp), %eax  # stack load f47
>>>>>>> fix-implicit-begins
# end emit-variable-ref
    movl %eax, -20(%esp)  # stack save
# emit-tail-expr
# si=-24
<<<<<<< HEAD
# env=((f310833 . -20) (f310834 . -16) (f310833 . -12) (f310834 . -8) (nil . 4))
# expr=(if (null? f310834) (cons f310833 nil) (cons (car f310834) ((primitive-ref append1) (cdr f310834) f310833)))
# emit-expr (null? f310834)
# emit-expr f310834
# emit-variable-ref
# env=((f310833 . -20) (f310834 . -16) (f310833 . -12) (f310834 . -8) (nil . 4))
# var=f310834
    movl -16(%esp), %eax  # stack load f310834
=======
# env=((f47 . -20) (f46 . -16) (f47 . -12) (f46 . -8) (nil . 4))
# expr=(if (null? f46) (cons f47 nil) (cons (car f46) ((primitive-ref append1) (cdr f46) f47)))
# emit-expr (null? f46)
# emit-expr f46
# emit-variable-ref
# env=((f47 . -20) (f46 . -16) (f47 . -12) (f46 . -8) (nil . 4))
# var=f46
    movl -16(%esp), %eax  # stack load f46
>>>>>>> fix-implicit-begins
# end emit-variable-ref
    cmp $63, %eax
    mov $0, %eax
    sete %al
    movzbl %al, %eax
    sal $6, %al
    or $47, %al
    cmp $47, %al
    je _L_122
# emit-tail-expr
# si=-24
<<<<<<< HEAD
# env=((f310833 . -20) (f310834 . -16) (f310833 . -12) (f310834 . -8) (nil . 4))
# expr=(cons f310833 nil)
# tail primcall
# cons arg1=f310833 arg2=nil
# emit-expr f310833
# emit-variable-ref
# env=((f310833 . -20) (f310834 . -16) (f310833 . -12) (f310834 . -8) (nil . 4))
# var=f310833
    movl -20(%esp), %eax  # stack load f310833
=======
# env=((f47 . -20) (f46 . -16) (f47 . -12) (f46 . -8) (nil . 4))
# expr=(cons f47 nil)
# tail primcall
# cons arg1=f47 arg2=nil
# emit-expr f47
# emit-variable-ref
# env=((f47 . -20) (f46 . -16) (f47 . -12) (f46 . -8) (nil . 4))
# var=f47
    movl -20(%esp), %eax  # stack load f47
>>>>>>> fix-implicit-begins
# end emit-variable-ref
    movl %eax, -24(%esp)
# emit-expr nil
# emit-variable-ref
<<<<<<< HEAD
# env=((f310833 . -20) (f310834 . -16) (f310833 . -12) (f310834 . -8) (nil . 4))
=======
# env=((f47 . -20) (f46 . -16) (f47 . -12) (f46 . -8) (nil . 4))
>>>>>>> fix-implicit-begins
# var=nil
    movl 2(%edi), %eax  # frame load nil
# end emit-variable-ref
    movl %eax, 4(%ebp)
    movl -24(%esp), %eax
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    or   $1, %al
    add  $8, %ebp
# cons end
<<<<<<< HEAD
#return from tail (cons f310833 nil)
=======
#return from tail (cons f47 nil)
>>>>>>> fix-implicit-begins
    ret
    jmp _L_123
_L_122:
# emit-tail-expr
# si=-24
<<<<<<< HEAD
# env=((f310833 . -20) (f310834 . -16) (f310833 . -12) (f310834 . -8) (nil . 4))
# expr=(cons (car f310834) ((primitive-ref append1) (cdr f310834) f310833))
# tail primcall
# cons arg1=(car f310834) arg2=((primitive-ref append1) (cdr f310834) f310833)
# emit-expr (car f310834)
# emit-expr f310834
# emit-variable-ref
# env=((f310833 . -20) (f310834 . -16) (f310833 . -12) (f310834 . -8) (nil . 4))
# var=f310834
    movl -16(%esp), %eax  # stack load f310834
=======
# env=((f47 . -20) (f46 . -16) (f47 . -12) (f46 . -8) (nil . 4))
# expr=(cons (car f46) ((primitive-ref append1) (cdr f46) f47))
# tail primcall
# cons arg1=(car f46) arg2=((primitive-ref append1) (cdr f46) f47)
# emit-expr (car f46)
# emit-expr f46
# emit-variable-ref
# env=((f47 . -20) (f46 . -16) (f47 . -12) (f46 . -8) (nil . 4))
# var=f46
    movl -16(%esp), %eax  # stack load f46
>>>>>>> fix-implicit-begins
# end emit-variable-ref
# check the argument is a pair
    movl %eax,%ebx
    and $7, %bl
    cmp $1, %bl
    je _L_124
# invoke error handler eh_pair
    .extern mrc_eh$upair
    movl mrc_eh$upair, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $116,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_124:
    movl -1(%eax), %eax
    movl %eax, -24(%esp)
<<<<<<< HEAD
# emit-expr ((primitive-ref append1) (cdr f310834) f310833)
# funcall
#    si   =-28
#    env  = ((f310833 . -20) (f310834 . -16) (f310833 . -12) (f310834 . -8) (nil . 4))
#    expr = (funcall (primitive-ref append1) (cdr f310834) f310833)
=======
# emit-expr ((primitive-ref append1) (cdr f46) f47)
# funcall
#    si   =-28
#    env  = ((f47 . -20) (f46 . -16) (f47 . -12) (f46 . -8) (nil . 4))
#    expr = (funcall (primitive-ref append1) (cdr f46) f47)
>>>>>>> fix-implicit-begins
# emit-expr (primitive-ref append1)
    .extern mrc_append1
    movl mrc_append1,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_125"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_125":
   movl %eax,  -36(%esp)  # stash funcall-oper in closure slot
<<<<<<< HEAD
# emit-expr (cdr f310834)
# emit-expr f310834
# emit-variable-ref
# env=((f310833 . -20) (f310834 . -16) (f310833 . -12) (f310834 . -8) (nil . 4))
# var=f310834
    movl -16(%esp), %eax  # stack load f310834
=======
# emit-expr (cdr f46)
# emit-expr f46
# emit-variable-ref
# env=((f47 . -20) (f46 . -16) (f47 . -12) (f46 . -8) (nil . 4))
# var=f46
    movl -16(%esp), %eax  # stack load f46
>>>>>>> fix-implicit-begins
# end emit-variable-ref
# check the argument is a pair
    movl %eax,%ebx
    and $7, %bl
    cmp $1, %bl
    je _L_126
# invoke error handler eh_pair
    .extern mrc_eh$upair
    movl mrc_eh$upair, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $120,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_126:
    movl 3(%eax), %eax
<<<<<<< HEAD
    mov %eax, -40(%esp)  # arg (cdr f310834)
# emit-expr f310833
# emit-variable-ref
# env=((f310833 . -20) (f310834 . -16) (f310833 . -12) (f310834 . -8) (nil . 4))
# var=f310833
    movl -20(%esp), %eax  # stack load f310833
# end emit-variable-ref
    mov %eax, -44(%esp)  # arg f310833
=======
    mov %eax, -40(%esp)  # arg (cdr f46)
# emit-expr f47
# emit-variable-ref
# env=((f47 . -20) (f46 . -16) (f47 . -12) (f46 . -8) (nil . 4))
# var=f47
    movl -20(%esp), %eax  # stack load f47
# end emit-variable-ref
    mov %eax, -44(%esp)  # arg f47
>>>>>>> fix-implicit-begins
    movl -36(%esp), %edi   # load new closure to %edi
    add $-28, %esp   # adjust base
    movl $8,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $28, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    movl %eax, 4(%ebp)
    movl -24(%esp), %eax
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    or   $1, %al
    add  $8, %ebp
# cons end
<<<<<<< HEAD
#return from tail (cons (car f310834) ((primitive-ref append1) (cdr f310834) f310833))
=======
#return from tail (cons (car f46) ((primitive-ref append1) (cdr f46) f47))
>>>>>>> fix-implicit-begins
    ret
_L_123:
    .align 4,0x90
_L_120:
     movl %eax, mrc_append1
# == explicit-begins  ==>
# (lambda (l k) (if (fx= k 0) (car l) (list-ref (cdr l) (fx- k 1))))
# == eliminate-let*  ==>
# (lambda (l k) (if (fx= k 0) (car l) (list-ref (cdr l) (fx- k 1))))
# == uniquify-variables  ==>
<<<<<<< HEAD
# (lambda (f310836 f310835) (if (fx= f310835 0) (car f310836) (list-ref (cdr f310836) (fx- f310835 1))))
# == vectorize-letrec  ==>
# (lambda (f310836 f310835) (if (fx= f310835 0) (car f310836) (list-ref (cdr f310836) (fx- f310835 1))))
# == eliminate-set!  ==>
# (lambda (f310836 f310835) (let ((f310836 f310836) (f310835 f310835)) (if (fx= f310835 0) (car f310836) (list-ref (cdr f310836) (fx- f310835 1)))))
# == close-free-variables  ==>
# (closure (f310836 f310835) () (let ((f310836 f310836) (f310835 f310835)) (if (fx= f310835 0) (car f310836) (list-ref (cdr f310836) (fx- f310835 1)))))
# == eliminate-quote  ==>
# (closure (f310836 f310835) () (let ((f310836 f310836) (f310835 f310835)) (if (fx= f310835 0) (car f310836) (list-ref (cdr f310836) (fx- f310835 1)))))
# == eliminate-when/unless  ==>
# (closure (f310836 f310835) () (let ((f310836 f310836) (f310835 f310835)) (if (fx= f310835 0) (car f310836) (list-ref (cdr f310836) (fx- f310835 1)))))
# == eliminate-cond  ==>
# (closure (f310836 f310835) () (let ((f310836 f310836) (f310835 f310835)) (if (fx= f310835 0) (car f310836) (list-ref (cdr f310836) (fx- f310835 1)))))
# == external-symbols  ==>
# (closure (f310836 f310835) () (let ((f310836 f310836) (f310835 f310835)) (if (fx= f310835 0) (car f310836) ((primitive-ref list-ref) (cdr f310836) (fx- f310835 1)))))
# emit-expr (closure (f310836 f310835) () (let ((f310836 f310836) (f310835 f310835)) (if (fx= f310835 0) (car f310836) ((primitive-ref list-ref) (cdr f310836) (fx- f310835 1)))))
# emit-closure
# si = 0
# env = ()
# expr = (closure (f310836 f310835) () (let ((f310836 f310836) (f310835 f310835)) (if (fx= f310835 0) (car f310836) ((primitive-ref list-ref) (cdr f310836) (fx- f310835 1)))))
    movl $_L_1883726, 0(%ebp)  # closure label
=======
# (lambda (f48 f49) (if (fx= f49 0) (car f48) (list-ref (cdr f48) (fx- f49 1))))
# == vectorize-letrec  ==>
# (lambda (f48 f49) (if (fx= f49 0) (car f48) (list-ref (cdr f48) (fx- f49 1))))
# == eliminate-set!  ==>
# (lambda (f48 f49) (let ((f48 f48) (f49 f49)) (if (fx= f49 0) (car f48) (list-ref (cdr f48) (fx- f49 1)))))
# == close-free-variables  ==>
# (closure (f48 f49) () (let ((f48 f48) (f49 f49)) (if (fx= f49 0) (car f48) (list-ref (cdr f48) (fx- f49 1)))))
# == eliminate-quote  ==>
# (closure (f48 f49) () (let ((f48 f48) (f49 f49)) (if (fx= f49 0) (car f48) (list-ref (cdr f48) (fx- f49 1)))))
# == eliminate-when/unless  ==>
# (closure (f48 f49) () (let ((f48 f48) (f49 f49)) (if (fx= f49 0) (car f48) (list-ref (cdr f48) (fx- f49 1)))))
# == eliminate-cond  ==>
# (closure (f48 f49) () (let ((f48 f48) (f49 f49)) (if (fx= f49 0) (car f48) (list-ref (cdr f48) (fx- f49 1)))))
# == external-symbols  ==>
# (closure (f48 f49) () (let ((f48 f48) (f49 f49)) (if (fx= f49 0) (car f48) ((primitive-ref list-ref) (cdr f48) (fx- f49 1)))))
# emit-expr (closure (f48 f49) () (let ((f48 f48) (f49 f49)) (if (fx= f49 0) (car f48) ((primitive-ref list-ref) (cdr f48) (fx- f49 1)))))
# emit-closure
# si = 0
# env = ()
# expr = (closure (f48 f49) () (let ((f48 f48) (f49 f49)) (if (fx= f49 0) (car f48) ((primitive-ref list-ref) (cdr f48) (fx- f49 1)))))
    movl $_L_127, 0(%ebp)  # closure label
>>>>>>> fix-implicit-begins
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $8, %ebp     # bump ebp
    jmp _L_128            # jump around closure body
_L_127:
# check argument count
    cmp $8,%eax
    je _L_129
# invoke error handler eh_argcount
    .extern mrc_eh$uargcount
    movl mrc_eh$uargcount, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_129:
# emit-tail-expr
# si=-16
<<<<<<< HEAD
# env=((f310835 . -12) (f310836 . -8))
# expr=(let ((f310836 f310836) (f310835 f310835)) (if (fx= f310835 0) (car f310836) ((primitive-ref list-ref) (cdr f310836) (fx- f310835 1))))
# emit-tail-let
#  si   = -16
#  env  = ((f310835 . -12) (f310836 . -8))
#  bindings = ((f310836 f310836) (f310835 f310835))
#  body = (if (fx= f310835 0) (car f310836) ((primitive-ref list-ref) (cdr f310836) (fx- f310835 1)))
# emit-expr f310836
# emit-variable-ref
# env=((f310835 . -12) (f310836 . -8))
# var=f310836
    movl -8(%esp), %eax  # stack load f310836
# end emit-variable-ref
    movl %eax, -16(%esp)  # stack save
# emit-expr f310835
# emit-variable-ref
# env=((f310835 . -12) (f310836 . -8))
# var=f310835
    movl -12(%esp), %eax  # stack load f310835
=======
# env=((f49 . -12) (f48 . -8))
# expr=(let ((f48 f48) (f49 f49)) (if (fx= f49 0) (car f48) ((primitive-ref list-ref) (cdr f48) (fx- f49 1))))
# emit-tail-let
#  si   = -16
#  env  = ((f49 . -12) (f48 . -8))
#  bindings = ((f48 f48) (f49 f49))
#  body = (if (fx= f49 0) (car f48) ((primitive-ref list-ref) (cdr f48) (fx- f49 1)))
# emit-expr f48
# emit-variable-ref
# env=((f49 . -12) (f48 . -8))
# var=f48
    movl -8(%esp), %eax  # stack load f48
# end emit-variable-ref
    movl %eax, -16(%esp)  # stack save
# emit-expr f49
# emit-variable-ref
# env=((f49 . -12) (f48 . -8))
# var=f49
    movl -12(%esp), %eax  # stack load f49
>>>>>>> fix-implicit-begins
# end emit-variable-ref
    movl %eax, -20(%esp)  # stack save
# emit-tail-expr
# si=-24
<<<<<<< HEAD
# env=((f310835 . -20) (f310836 . -16) (f310835 . -12) (f310836 . -8))
# expr=(if (fx= f310835 0) (car f310836) ((primitive-ref list-ref) (cdr f310836) (fx- f310835 1)))
# emit-expr (fx= f310835 0)
=======
# env=((f49 . -20) (f48 . -16) (f49 . -12) (f48 . -8))
# expr=(if (fx= f49 0) (car f48) ((primitive-ref list-ref) (cdr f48) (fx- f49 1)))
# emit-expr (fx= f49 0)
>>>>>>> fix-implicit-begins
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_132"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $68,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_132:
    movl %eax, -24(%esp)
<<<<<<< HEAD
# emit-expr f310835
# emit-variable-ref
# env=((f310835 . -20) (f310836 . -16) (f310835 . -12) (f310836 . -8))
# var=f310835
    movl -20(%esp), %eax  # stack load f310835
=======
# emit-expr f49
# emit-variable-ref
# env=((f49 . -20) (f48 . -16) (f49 . -12) (f48 . -8))
# var=f49
    movl -20(%esp), %eax  # stack load f49
>>>>>>> fix-implicit-begins
# end emit-variable-ref
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_133"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $68,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_133:
    cmp -24(%esp), %eax
    sete %al
    movzbl %al, %eax
    sal $6, %al
    or $47, %al
    cmp $47, %al
    je _L_130
# emit-tail-expr
# si=-24
<<<<<<< HEAD
# env=((f310835 . -20) (f310836 . -16) (f310835 . -12) (f310836 . -8))
# expr=(car f310836)
# tail primcall
# emit-expr f310836
# emit-variable-ref
# env=((f310835 . -20) (f310836 . -16) (f310835 . -12) (f310836 . -8))
# var=f310836
    movl -16(%esp), %eax  # stack load f310836
=======
# env=((f49 . -20) (f48 . -16) (f49 . -12) (f48 . -8))
# expr=(car f48)
# tail primcall
# emit-expr f48
# emit-variable-ref
# env=((f49 . -20) (f48 . -16) (f49 . -12) (f48 . -8))
# var=f48
    movl -16(%esp), %eax  # stack load f48
>>>>>>> fix-implicit-begins
# end emit-variable-ref
# check the argument is a pair
    movl %eax,%ebx
    and $7, %bl
    cmp $1, %bl
    je _L_134
# invoke error handler eh_pair
    .extern mrc_eh$upair
    movl mrc_eh$upair, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $116,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_134:
    movl -1(%eax), %eax
<<<<<<< HEAD
#return from tail (car f310836)
=======
#return from tail (car f48)
>>>>>>> fix-implicit-begins
    ret
    jmp _L_131
_L_130:
# emit-tail-expr
# si=-24
<<<<<<< HEAD
# env=((f310835 . -20) (f310836 . -16) (f310835 . -12) (f310836 . -8))
# expr=((primitive-ref list-ref) (cdr f310836) (fx- f310835 1))
# emit-tail-funcall
#    si   =-24
#    env  = ((f310835 . -20) (f310836 . -16) (f310835 . -12) (f310836 . -8))
#    expr = (funcall (primitive-ref list-ref) (cdr f310836) (fx- f310835 1))
=======
# env=((f49 . -20) (f48 . -16) (f49 . -12) (f48 . -8))
# expr=((primitive-ref list-ref) (cdr f48) (fx- f49 1))
# emit-tail-funcall
#    si   =-24
#    env  = ((f49 . -20) (f48 . -16) (f49 . -12) (f48 . -8))
#    expr = (funcall (primitive-ref list-ref) (cdr f48) (fx- f49 1))
>>>>>>> fix-implicit-begins
# emit-expr (primitive-ref list-ref)
    .extern mrc_list$mref
    movl mrc_list$mref,%eax
   movl %eax,  -24(%esp)  # stash funcall-oper in next closure slot
<<<<<<< HEAD
# emit-expr (cdr f310836)
# emit-expr f310836
# emit-variable-ref
# env=((f310835 . -20) (f310836 . -16) (f310835 . -12) (f310836 . -8))
# var=f310836
    movl -16(%esp), %eax  # stack load f310836
=======
# emit-expr (cdr f48)
# emit-expr f48
# emit-variable-ref
# env=((f49 . -20) (f48 . -16) (f49 . -12) (f48 . -8))
# var=f48
    movl -16(%esp), %eax  # stack load f48
>>>>>>> fix-implicit-begins
# end emit-variable-ref
# check the argument is a pair
    movl %eax,%ebx
    and $7, %bl
    cmp $1, %bl
    je _L_135
# invoke error handler eh_pair
    .extern mrc_eh$upair
    movl mrc_eh$upair, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $120,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_135:
    movl 3(%eax), %eax
<<<<<<< HEAD
    mov %eax, -28(%esp)    # arg (cdr f310836)
# emit-expr (fx- f310835 1)
=======
    mov %eax, -28(%esp)    # arg (cdr f48)
# emit-expr (fx- f49 1)
>>>>>>> fix-implicit-begins
# emit-expr 1
    movl $4, %eax     # immed 1
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_136"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $92,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_136:
    movl %eax, -32(%esp)
<<<<<<< HEAD
# emit-expr f310835
# emit-variable-ref
# env=((f310835 . -20) (f310836 . -16) (f310835 . -12) (f310836 . -8))
# var=f310835
    movl -20(%esp), %eax  # stack load f310835
=======
# emit-expr f49
# emit-variable-ref
# env=((f49 . -20) (f48 . -16) (f49 . -12) (f48 . -8))
# var=f49
    movl -20(%esp), %eax  # stack load f49
>>>>>>> fix-implicit-begins
# end emit-variable-ref
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_137"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $92,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_137:
    subl -32(%esp), %eax
<<<<<<< HEAD
    mov %eax, -32(%esp)    # arg (fx- f310835 1)
=======
    mov %eax, -32(%esp)    # arg (fx- f49 1)
>>>>>>> fix-implicit-begins
    movl -24(%esp), %edi   # load new closure to %edi
# emit-shift-args:  size=3   si=-24  delta=20
    mov -24(%esp), %ebx  # shift frame cell
    mov %ebx, -4(%esp)  # down to base
# emit-shift-args:  size=2   si=-28  delta=20
    mov -28(%esp), %ebx  # shift frame cell
    mov %ebx, -8(%esp)  # down to base
# emit-shift-args:  size=1   si=-32  delta=20
    mov -32(%esp), %ebx  # shift frame cell
    mov %ebx, -12(%esp)  # down to base
# emit-shift-args:  size=0   si=-36  delta=20
    movl $8,%eax   # save arg count
    jmp *-2(%edi)  # tail-funcall
_L_131:
    .align 4,0x90
_L_128:
     movl %eax, mrc_list$mref
# == explicit-begins  ==>
# (lambda (l) (if (null? l) 0 (fxadd1 (list-length (cdr l)))))
# == eliminate-let*  ==>
# (lambda (l) (if (null? l) 0 (fxadd1 (list-length (cdr l)))))
# == uniquify-variables  ==>
# (lambda (f50) (if (null? f50) 0 (fxadd1 (list-length (cdr f50)))))
# == vectorize-letrec  ==>
# (lambda (f50) (if (null? f50) 0 (fxadd1 (list-length (cdr f50)))))
# == eliminate-set!  ==>
# (lambda (f50) (let ((f50 f50)) (if (null? f50) 0 (fxadd1 (list-length (cdr f50))))))
# == close-free-variables  ==>
# (closure (f50) () (let ((f50 f50)) (if (null? f50) 0 (fxadd1 (list-length (cdr f50))))))
# == eliminate-quote  ==>
# (closure (f50) () (let ((f50 f50)) (if (null? f50) 0 (fxadd1 (list-length (cdr f50))))))
# == eliminate-when/unless  ==>
# (closure (f50) () (let ((f50 f50)) (if (null? f50) 0 (fxadd1 (list-length (cdr f50))))))
# == eliminate-cond  ==>
# (closure (f50) () (let ((f50 f50)) (if (null? f50) 0 (fxadd1 (list-length (cdr f50))))))
# == external-symbols  ==>
# (closure (f50) () (let ((f50 f50)) (if (null? f50) 0 (fxadd1 ((primitive-ref list-length) (cdr f50))))))
# emit-expr (closure (f50) () (let ((f50 f50)) (if (null? f50) 0 (fxadd1 ((primitive-ref list-length) (cdr f50))))))
# emit-closure
# si = 0
# env = ()
# expr = (closure (f50) () (let ((f50 f50)) (if (null? f50) 0 (fxadd1 ((primitive-ref list-length) (cdr f50))))))
    movl $_L_138, 0(%ebp)  # closure label
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $8, %ebp     # bump ebp
    jmp _L_139            # jump around closure body
_L_138:
# check argument count
    cmp $4,%eax
    je _L_140
# invoke error handler eh_argcount
    .extern mrc_eh$uargcount
    movl mrc_eh$uargcount, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_140:
# emit-tail-expr
# si=-12
# env=((f50 . -8))
# expr=(let ((f50 f50)) (if (null? f50) 0 (fxadd1 ((primitive-ref list-length) (cdr f50)))))
# emit-tail-let
#  si   = -12
#  env  = ((f50 . -8))
#  bindings = ((f50 f50))
#  body = (if (null? f50) 0 (fxadd1 ((primitive-ref list-length) (cdr f50))))
# emit-expr f50
# emit-variable-ref
# env=((f50 . -8))
# var=f50
    movl -8(%esp), %eax  # stack load f50
# end emit-variable-ref
    movl %eax, -12(%esp)  # stack save
# emit-tail-expr
# si=-16
# env=((f50 . -12) (f50 . -8))
# expr=(if (null? f50) 0 (fxadd1 ((primitive-ref list-length) (cdr f50))))
# emit-expr (null? f50)
# emit-expr f50
# emit-variable-ref
# env=((f50 . -12) (f50 . -8))
# var=f50
    movl -12(%esp), %eax  # stack load f50
# end emit-variable-ref
    cmp $63, %eax
    mov $0, %eax
    sete %al
    movzbl %al, %eax
    sal $6, %al
    or $47, %al
    cmp $47, %al
    je _L_141
# emit-tail-expr
# si=-16
# env=((f50 . -12) (f50 . -8))
# expr=0
    movl $0, %eax     # immed 0
    ret                  # immediate tail return
    jmp _L_142
_L_141:
# emit-tail-expr
# si=-16
# env=((f50 . -12) (f50 . -8))
# expr=(fxadd1 ((primitive-ref list-length) (cdr f50)))
# tail primcall
# emit-expr ((primitive-ref list-length) (cdr f50))
# funcall
#    si   =-16
#    env  = ((f50 . -12) (f50 . -8))
#    expr = (funcall (primitive-ref list-length) (cdr f50))
# emit-expr (primitive-ref list-length)
    .extern mrc_list$mlength
    movl mrc_list$mlength,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_143"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_143":
   movl %eax,  -24(%esp)  # stash funcall-oper in closure slot
# emit-expr (cdr f50)
# emit-expr f50
# emit-variable-ref
# env=((f50 . -12) (f50 . -8))
# var=f50
    movl -12(%esp), %eax  # stack load f50
# end emit-variable-ref
# check the argument is a pair
    movl %eax,%ebx
    and $7, %bl
    cmp $1, %bl
    je _L_144
# invoke error handler eh_pair
    .extern mrc_eh$upair
    movl mrc_eh$upair, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $120,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_144:
    movl 3(%eax), %eax
    mov %eax, -28(%esp)  # arg (cdr f50)
    movl -24(%esp), %edi   # load new closure to %edi
    add $-16, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $16, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_145"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $56,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_145:
     addl $4, %eax
#return from tail (fxadd1 ((primitive-ref list-length) (cdr f50)))
    ret
_L_142:
    .align 4,0x90
_L_139:
     movl %eax, mrc_list$mlength
# == explicit-begins  ==>
# (letrec ((f (lambda (l lrev) (if (null? l) lrev (f (cdr l) (cons (car l) lrev)))))) (lambda (l) (f l (quote ()))))
# == eliminate-let*  ==>
# (letrec ((f (lambda (l lrev) (if (null? l) lrev (f (cdr l) (cons (car l) lrev)))))) (lambda (l) (f l (quote ()))))
# == uniquify-variables  ==>
<<<<<<< HEAD
# (letrec ((f310838 (lambda (f310842 f310841) (if (null? f310842) f310841 (f310838 (cdr f310842) (cons (car f310842) f310841)))))) (lambda (f310844) (f310838 f310844 (quote ()))))
# == vectorize-letrec  ==>
# (let ((f310838 (make-vector 1))) (begin (begin (vector-set! f310838 0 (lambda (f310842 f310841) (if (null? f310842) f310841 ((vector-ref f310838 0) (cdr f310842) (cons (car f310842) f310841)))))) (lambda (f310844) ((vector-ref f310838 0) f310844 (quote ())))))
# == eliminate-set!  ==>
# (let ((f310838 (make-vector 1))) (begin (begin (vector-set! f310838 0 (lambda (f310842 f310841) (let ((f310842 f310842) (f310841 f310841)) (if (null? f310842) f310841 ((vector-ref f310838 0) (cdr f310842) (cons (car f310842) f310841))))))) (lambda (f310844) (let ((f310844 f310844)) ((vector-ref f310838 0) f310844 (quote ()))))))
# == close-free-variables  ==>
# (let ((f310838 (make-vector 1))) (begin (begin (vector-set! f310838 0 (closure (f310842 f310841) (f310838) (let ((f310842 f310842) (f310841 f310841)) (if (null? f310842) f310841 ((vector-ref f310838 0) (cdr f310842) (cons (car f310842) f310841))))))) (closure (f310844) (f310838) (let ((f310844 f310844)) ((vector-ref f310838 0) f310844 (quote ()))))))
# == eliminate-quote  ==>
# (let ((f310838 (make-vector 1))) (begin (begin (vector-set! f310838 0 (closure (f310842 f310841) (f310838) (let ((f310842 f310842) (f310841 f310841)) (if (null? f310842) f310841 ((vector-ref f310838 0) (cdr f310842) (cons (car f310842) f310841))))))) (closure (f310844) (f310838) (let ((f310844 f310844)) ((vector-ref f310838 0) f310844 ())))))
# == eliminate-when/unless  ==>
# (let ((f310838 (make-vector 1))) (begin (begin (vector-set! f310838 0 (closure (f310842 f310841) (f310838) (let ((f310842 f310842) (f310841 f310841)) (if (null? f310842) f310841 ((vector-ref f310838 0) (cdr f310842) (cons (car f310842) f310841))))))) (closure (f310844) (f310838) (let ((f310844 f310844)) ((vector-ref f310838 0) f310844 ())))))
# == eliminate-cond  ==>
# (let ((f310838 (make-vector 1))) (begin (begin (vector-set! f310838 0 (closure (f310842 f310841) (f310838) (let ((f310842 f310842) (f310841 f310841)) (if (null? f310842) f310841 ((vector-ref f310838 0) (cdr f310842) (cons (car f310842) f310841))))))) (closure (f310844) (f310838) (let ((f310844 f310844)) ((vector-ref f310838 0) f310844 ())))))
# == external-symbols  ==>
# (let ((f310838 (make-vector 1))) (begin (begin (vector-set! f310838 0 (closure (f310842 f310841) (f310838) (let ((f310842 f310842) (f310841 f310841)) (if (null? f310842) f310841 ((vector-ref f310838 0) (cdr f310842) (cons (car f310842) f310841))))))) (closure (f310844) (f310838) (let ((f310844 f310844)) ((vector-ref f310838 0) f310844 ())))))
# emit-expr (let ((f310838 (make-vector 1))) (begin (begin (vector-set! f310838 0 (closure (f310842 f310841) (f310838) (let ((f310842 f310842) (f310841 f310841)) (if (null? f310842) f310841 ((vector-ref f310838 0) (cdr f310842) (cons (car f310842) f310841))))))) (closure (f310844) (f310838) (let ((f310844 f310844)) ((vector-ref f310838 0) f310844 ())))))
# emit-let
#  si   = 0
#  env  = ()
#  bindings = ((f310838 (make-vector 1)))
#  body = (begin (begin (vector-set! f310838 0 (closure (f310842 f310841) (f310838) (let ((f310842 f310842) (f310841 f310841)) (if (null? f310842) f310841 ((vector-ref f310838 0) (cdr f310842) (cons (car f310842) f310841))))))) (closure (f310844) (f310838) (let ((f310844 f310844)) ((vector-ref f310838 0) f310844 ()))))
=======
# (letrec ((f51 (lambda (f54 f55) (if (null? f54) f55 (f51 (cdr f54) (cons (car f54) f55)))))) (lambda (f57) (f51 f57 (quote ()))))
# == vectorize-letrec  ==>
# (let ((f51 (make-vector 1))) (begin (begin (vector-set! f51 0 (lambda (f54 f55) (if (null? f54) f55 ((vector-ref f51 0) (cdr f54) (cons (car f54) f55)))))) (lambda (f57) ((vector-ref f51 0) f57 (quote ())))))
# == eliminate-set!  ==>
# (let ((f51 (make-vector 1))) (begin (begin (vector-set! f51 0 (lambda (f54 f55) (let ((f54 f54) (f55 f55)) (if (null? f54) f55 ((vector-ref f51 0) (cdr f54) (cons (car f54) f55))))))) (lambda (f57) (let ((f57 f57)) ((vector-ref f51 0) f57 (quote ()))))))
# == close-free-variables  ==>
# (let ((f51 (make-vector 1))) (begin (begin (vector-set! f51 0 (closure (f54 f55) (f51) (let ((f54 f54) (f55 f55)) (if (null? f54) f55 ((vector-ref f51 0) (cdr f54) (cons (car f54) f55))))))) (closure (f57) (f51) (let ((f57 f57)) ((vector-ref f51 0) f57 (quote ()))))))
# == eliminate-quote  ==>
# (let ((f51 (make-vector 1))) (begin (begin (vector-set! f51 0 (closure (f54 f55) (f51) (let ((f54 f54) (f55 f55)) (if (null? f54) f55 ((vector-ref f51 0) (cdr f54) (cons (car f54) f55))))))) (closure (f57) (f51) (let ((f57 f57)) ((vector-ref f51 0) f57 ())))))
# == eliminate-when/unless  ==>
# (let ((f51 (make-vector 1))) (begin (begin (vector-set! f51 0 (closure (f54 f55) (f51) (let ((f54 f54) (f55 f55)) (if (null? f54) f55 ((vector-ref f51 0) (cdr f54) (cons (car f54) f55))))))) (closure (f57) (f51) (let ((f57 f57)) ((vector-ref f51 0) f57 ())))))
# == eliminate-cond  ==>
# (let ((f51 (make-vector 1))) (begin (begin (vector-set! f51 0 (closure (f54 f55) (f51) (let ((f54 f54) (f55 f55)) (if (null? f54) f55 ((vector-ref f51 0) (cdr f54) (cons (car f54) f55))))))) (closure (f57) (f51) (let ((f57 f57)) ((vector-ref f51 0) f57 ())))))
# == external-symbols  ==>
# (let ((f51 (make-vector 1))) (begin (begin (vector-set! f51 0 (closure (f54 f55) (f51) (let ((f54 f54) (f55 f55)) (if (null? f54) f55 ((vector-ref f51 0) (cdr f54) (cons (car f54) f55))))))) (closure (f57) (f51) (let ((f57 f57)) ((vector-ref f51 0) f57 ())))))
# emit-expr (let ((f51 (make-vector 1))) (begin (begin (vector-set! f51 0 (closure (f54 f55) (f51) (let ((f54 f54) (f55 f55)) (if (null? f54) f55 ((vector-ref f51 0) (cdr f54) (cons (car f54) f55))))))) (closure (f57) (f51) (let ((f57 f57)) ((vector-ref f51 0) f57 ())))))
# emit-let
#  si   = 0
#  env  = ()
#  bindings = ((f51 (make-vector 1)))
#  body = (begin (begin (vector-set! f51 0 (closure (f54 f55) (f51) (let ((f54 f54) (f55 f55)) (if (null? f54) f55 ((vector-ref f51 0) (cdr f54) (cons (car f54) f55))))))) (closure (f57) (f51) (let ((f57 f57)) ((vector-ref f51 0) f57 ()))))
>>>>>>> fix-implicit-begins
# emit-expr (make-vector 1)
# make-vector 1
# emit-expr 1
    movl $4, %eax     # immed 1
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_146"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_146:
# check the argument is a fixnum >= 0
    cmp $0,%eax
    jge _L_147
# invoke error handler eh_length
    .extern mrc_eh$ulength
    movl mrc_eh$ulength, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_147:
    movl %eax, %esi
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    orl  $5, %eax
    addl $4, %esi
    addl $4, %esi
    andl $-8, %esi
    addl %esi, %ebp
    movl %eax, 0(%esp)  # stack save
<<<<<<< HEAD
# emit-expr (begin (begin (vector-set! f310838 0 (closure (f310842 f310841) (f310838) (let ((f310842 f310842) (f310841 f310841)) (if (null? f310842) f310841 ((vector-ref f310838 0) (cdr f310842) (cons (car f310842) f310841))))))) (closure (f310844) (f310838) (let ((f310844 f310844)) ((vector-ref f310838 0) f310844 ()))))
# emit-begin
#   expr=(begin (begin (vector-set! f310838 0 (closure (f310842 f310841) (f310838) (let ((f310842 f310842) (f310841 f310841)) (if (null? f310842) f310841 ((vector-ref f310838 0) (cdr f310842) (cons (car f310842) f310841))))))) (closure (f310844) (f310838) (let ((f310844 f310844)) ((vector-ref f310838 0) f310844 ()))))
#   env=((f310838 . 0))
# emit-expr (begin (vector-set! f310838 0 (closure (f310842 f310841) (f310838) (let ((f310842 f310842) (f310841 f310841)) (if (null? f310842) f310841 ((vector-ref f310838 0) (cdr f310842) (cons (car f310842) f310841)))))))
# emit-begin
#   expr=(begin (vector-set! f310838 0 (closure (f310842 f310841) (f310838) (let ((f310842 f310842) (f310841 f310841)) (if (null? f310842) f310841 ((vector-ref f310838 0) (cdr f310842) (cons (car f310842) f310841)))))))
#   env=((f310838 . 0))
# emit-expr (vector-set! f310838 0 (closure (f310842 f310841) (f310838) (let ((f310842 f310842) (f310841 f310841)) (if (null? f310842) f310841 ((vector-ref f310838 0) (cdr f310842) (cons (car f310842) f310841))))))
# emit-expr f310838
=======
# emit-expr (begin (begin (vector-set! f51 0 (closure (f54 f55) (f51) (let ((f54 f54) (f55 f55)) (if (null? f54) f55 ((vector-ref f51 0) (cdr f54) (cons (car f54) f55))))))) (closure (f57) (f51) (let ((f57 f57)) ((vector-ref f51 0) f57 ()))))
# emit-begin
#   expr=(begin (begin (vector-set! f51 0 (closure (f54 f55) (f51) (let ((f54 f54) (f55 f55)) (if (null? f54) f55 ((vector-ref f51 0) (cdr f54) (cons (car f54) f55))))))) (closure (f57) (f51) (let ((f57 f57)) ((vector-ref f51 0) f57 ()))))
#   env=((f51 . 0))
# emit-expr (begin (vector-set! f51 0 (closure (f54 f55) (f51) (let ((f54 f54) (f55 f55)) (if (null? f54) f55 ((vector-ref f51 0) (cdr f54) (cons (car f54) f55)))))))
# emit-begin
#   expr=(begin (vector-set! f51 0 (closure (f54 f55) (f51) (let ((f54 f54) (f55 f55)) (if (null? f54) f55 ((vector-ref f51 0) (cdr f54) (cons (car f54) f55)))))))
#   env=((f51 . 0))
# emit-expr (vector-set! f51 0 (closure (f54 f55) (f51) (let ((f54 f54) (f55 f55)) (if (null? f54) f55 ((vector-ref f51 0) (cdr f54) (cons (car f54) f55))))))
# emit-expr f51
>>>>>>> fix-implicit-begins
# emit-variable-ref
# env=((f51 . 0))
# var=f51
    movl 0(%esp), %eax  # stack load f51
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_148
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_148:
    movl %eax, -4(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_149"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_149:
# check bounds on vector index
    movl -4(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_151
    cmp  $0,%eax
    jge _L_150
_L_151:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_150:
    movl %eax, -8(%esp)
<<<<<<< HEAD
# emit-expr (closure (f310842 f310841) (f310838) (let ((f310842 f310842) (f310841 f310841)) (if (null? f310842) f310841 ((vector-ref f310838 0) (cdr f310842) (cons (car f310842) f310841)))))
# emit-closure
# si = -12
# env = ((f310838 . 0))
# expr = (closure (f310842 f310841) (f310838) (let ((f310842 f310842) (f310841 f310841)) (if (null? f310842) f310841 ((vector-ref f310838 0) (cdr f310842) (cons (car f310842) f310841)))))
    movl $_L_1883751, 0(%ebp)  # closure label
=======
# emit-expr (closure (f54 f55) (f51) (let ((f54 f54) (f55 f55)) (if (null? f54) f55 ((vector-ref f51 0) (cdr f54) (cons (car f54) f55)))))
# emit-closure
# si = -12
# env = ((f51 . 0))
# expr = (closure (f54 f55) (f51) (let ((f54 f54) (f55 f55)) (if (null? f54) f55 ((vector-ref f51 0) (cdr f54) (cons (car f54) f55)))))
    movl $_L_152, 0(%ebp)  # closure label
>>>>>>> fix-implicit-begins
# emit-variable-ref
# env=((f51 . 0))
# var=f51
    movl 0(%esp), %eax  # stack load f51
# end emit-variable-ref
   movl  %eax, 4(%ebp)  # f51
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $8, %ebp     # bump ebp
    jmp _L_153            # jump around closure body
_L_152:
# check argument count
    cmp $8,%eax
    je _L_154
# invoke error handler eh_argcount
    .extern mrc_eh$uargcount
    movl mrc_eh$uargcount, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_154:
# emit-tail-expr
# si=-16
<<<<<<< HEAD
# env=((f310841 . -12) (f310842 . -8) (f310838 . 4) (f310838 . 0))
# expr=(let ((f310842 f310842) (f310841 f310841)) (if (null? f310842) f310841 ((vector-ref f310838 0) (cdr f310842) (cons (car f310842) f310841))))
# emit-tail-let
#  si   = -16
#  env  = ((f310841 . -12) (f310842 . -8) (f310838 . 4) (f310838 . 0))
#  bindings = ((f310842 f310842) (f310841 f310841))
#  body = (if (null? f310842) f310841 ((vector-ref f310838 0) (cdr f310842) (cons (car f310842) f310841)))
# emit-expr f310842
# emit-variable-ref
# env=((f310841 . -12) (f310842 . -8) (f310838 . 4) (f310838 . 0))
# var=f310842
    movl -8(%esp), %eax  # stack load f310842
# end emit-variable-ref
    movl %eax, -16(%esp)  # stack save
# emit-expr f310841
# emit-variable-ref
# env=((f310841 . -12) (f310842 . -8) (f310838 . 4) (f310838 . 0))
# var=f310841
    movl -12(%esp), %eax  # stack load f310841
=======
# env=((f55 . -12) (f54 . -8) (f51 . 4) (f51 . 0))
# expr=(let ((f54 f54) (f55 f55)) (if (null? f54) f55 ((vector-ref f51 0) (cdr f54) (cons (car f54) f55))))
# emit-tail-let
#  si   = -16
#  env  = ((f55 . -12) (f54 . -8) (f51 . 4) (f51 . 0))
#  bindings = ((f54 f54) (f55 f55))
#  body = (if (null? f54) f55 ((vector-ref f51 0) (cdr f54) (cons (car f54) f55)))
# emit-expr f54
# emit-variable-ref
# env=((f55 . -12) (f54 . -8) (f51 . 4) (f51 . 0))
# var=f54
    movl -8(%esp), %eax  # stack load f54
# end emit-variable-ref
    movl %eax, -16(%esp)  # stack save
# emit-expr f55
# emit-variable-ref
# env=((f55 . -12) (f54 . -8) (f51 . 4) (f51 . 0))
# var=f55
    movl -12(%esp), %eax  # stack load f55
>>>>>>> fix-implicit-begins
# end emit-variable-ref
    movl %eax, -20(%esp)  # stack save
# emit-tail-expr
# si=-24
<<<<<<< HEAD
# env=((f310841 . -20) (f310842 . -16) (f310841 . -12) (f310842 . -8) (f310838 . 4) (f310838 . 0))
# expr=(if (null? f310842) f310841 ((vector-ref f310838 0) (cdr f310842) (cons (car f310842) f310841)))
# emit-expr (null? f310842)
# emit-expr f310842
# emit-variable-ref
# env=((f310841 . -20) (f310842 . -16) (f310841 . -12) (f310842 . -8) (f310838 . 4) (f310838 . 0))
# var=f310842
    movl -16(%esp), %eax  # stack load f310842
=======
# env=((f55 . -20) (f54 . -16) (f55 . -12) (f54 . -8) (f51 . 4) (f51 . 0))
# expr=(if (null? f54) f55 ((vector-ref f51 0) (cdr f54) (cons (car f54) f55)))
# emit-expr (null? f54)
# emit-expr f54
# emit-variable-ref
# env=((f55 . -20) (f54 . -16) (f55 . -12) (f54 . -8) (f51 . 4) (f51 . 0))
# var=f54
    movl -16(%esp), %eax  # stack load f54
>>>>>>> fix-implicit-begins
# end emit-variable-ref
    cmp $63, %eax
    mov $0, %eax
    sete %al
    movzbl %al, %eax
    sal $6, %al
    or $47, %al
    cmp $47, %al
    je _L_155
# emit-tail-expr
# si=-24
<<<<<<< HEAD
# env=((f310841 . -20) (f310842 . -16) (f310841 . -12) (f310842 . -8) (f310838 . 4) (f310838 . 0))
# expr=f310841
# emit-tail-variable-ref
# emit-variable-ref
# env=((f310841 . -20) (f310842 . -16) (f310841 . -12) (f310842 . -8) (f310838 . 4) (f310838 . 0))
# var=f310841
    movl -20(%esp), %eax  # stack load f310841
=======
# env=((f55 . -20) (f54 . -16) (f55 . -12) (f54 . -8) (f51 . 4) (f51 . 0))
# expr=f55
# emit-tail-variable-ref
# emit-variable-ref
# env=((f55 . -20) (f54 . -16) (f55 . -12) (f54 . -8) (f51 . 4) (f51 . 0))
# var=f55
    movl -20(%esp), %eax  # stack load f55
>>>>>>> fix-implicit-begins
# end emit-variable-ref
    ret
# end emit-tail-variable ref
    jmp _L_156
_L_155:
# emit-tail-expr
# si=-24
<<<<<<< HEAD
# env=((f310841 . -20) (f310842 . -16) (f310841 . -12) (f310842 . -8) (f310838 . 4) (f310838 . 0))
# expr=((vector-ref f310838 0) (cdr f310842) (cons (car f310842) f310841))
# emit-tail-funcall
#    si   =-24
#    env  = ((f310841 . -20) (f310842 . -16) (f310841 . -12) (f310842 . -8) (f310838 . 4) (f310838 . 0))
#    expr = (funcall (vector-ref f310838 0) (cdr f310842) (cons (car f310842) f310841))
# emit-expr (vector-ref f310838 0)
# emit-expr f310838
# emit-variable-ref
# env=((f310841 . -20) (f310842 . -16) (f310841 . -12) (f310842 . -8) (f310838 . 4) (f310838 . 0))
# var=f310838
    movl 2(%edi), %eax  # frame load f310838
=======
# env=((f55 . -20) (f54 . -16) (f55 . -12) (f54 . -8) (f51 . 4) (f51 . 0))
# expr=((vector-ref f51 0) (cdr f54) (cons (car f54) f55))
# emit-tail-funcall
#    si   =-24
#    env  = ((f55 . -20) (f54 . -16) (f55 . -12) (f54 . -8) (f51 . 4) (f51 . 0))
#    expr = (funcall (vector-ref f51 0) (cdr f54) (cons (car f54) f55))
# emit-expr (vector-ref f51 0)
# emit-expr f51
# emit-variable-ref
# env=((f55 . -20) (f54 . -16) (f55 . -12) (f54 . -8) (f51 . 4) (f51 . 0))
# var=f51
    movl 2(%edi), %eax  # frame load f51
>>>>>>> fix-implicit-begins
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_157
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_157:
    movl %eax, -24(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_158"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_158:
# check bounds on vector index
    movl -24(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_160
    cmp  $0,%eax
    jge _L_159
_L_160:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_159:
    movl -24(%esp), %esi
    movl -1(%eax,%esi), %eax
   movl %eax,  -24(%esp)  # stash funcall-oper in next closure slot
<<<<<<< HEAD
# emit-expr (cdr f310842)
# emit-expr f310842
# emit-variable-ref
# env=((f310841 . -20) (f310842 . -16) (f310841 . -12) (f310842 . -8) (f310838 . 4) (f310838 . 0))
# var=f310842
    movl -16(%esp), %eax  # stack load f310842
=======
# emit-expr (cdr f54)
# emit-expr f54
# emit-variable-ref
# env=((f55 . -20) (f54 . -16) (f55 . -12) (f54 . -8) (f51 . 4) (f51 . 0))
# var=f54
    movl -16(%esp), %eax  # stack load f54
>>>>>>> fix-implicit-begins
# end emit-variable-ref
# check the argument is a pair
    movl %eax,%ebx
    and $7, %bl
    cmp $1, %bl
    je _L_161
# invoke error handler eh_pair
    .extern mrc_eh$upair
    movl mrc_eh$upair, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $120,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_161:
    movl 3(%eax), %eax
<<<<<<< HEAD
    mov %eax, -28(%esp)    # arg (cdr f310842)
# emit-expr (cons (car f310842) f310841)
# cons arg1=(car f310842) arg2=f310841
# emit-expr (car f310842)
# emit-expr f310842
# emit-variable-ref
# env=((f310841 . -20) (f310842 . -16) (f310841 . -12) (f310842 . -8) (f310838 . 4) (f310838 . 0))
# var=f310842
    movl -16(%esp), %eax  # stack load f310842
=======
    mov %eax, -28(%esp)    # arg (cdr f54)
# emit-expr (cons (car f54) f55)
# cons arg1=(car f54) arg2=f55
# emit-expr (car f54)
# emit-expr f54
# emit-variable-ref
# env=((f55 . -20) (f54 . -16) (f55 . -12) (f54 . -8) (f51 . 4) (f51 . 0))
# var=f54
    movl -16(%esp), %eax  # stack load f54
>>>>>>> fix-implicit-begins
# end emit-variable-ref
# check the argument is a pair
    movl %eax,%ebx
    and $7, %bl
    cmp $1, %bl
    je _L_162
# invoke error handler eh_pair
    .extern mrc_eh$upair
    movl mrc_eh$upair, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $116,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_162:
    movl -1(%eax), %eax
    movl %eax, -32(%esp)
<<<<<<< HEAD
# emit-expr f310841
# emit-variable-ref
# env=((f310841 . -20) (f310842 . -16) (f310841 . -12) (f310842 . -8) (f310838 . 4) (f310838 . 0))
# var=f310841
    movl -20(%esp), %eax  # stack load f310841
=======
# emit-expr f55
# emit-variable-ref
# env=((f55 . -20) (f54 . -16) (f55 . -12) (f54 . -8) (f51 . 4) (f51 . 0))
# var=f55
    movl -20(%esp), %eax  # stack load f55
>>>>>>> fix-implicit-begins
# end emit-variable-ref
    movl %eax, 4(%ebp)
    movl -32(%esp), %eax
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    or   $1, %al
    add  $8, %ebp
# cons end
<<<<<<< HEAD
    mov %eax, -32(%esp)    # arg (cons (car f310842) f310841)
=======
    mov %eax, -32(%esp)    # arg (cons (car f54) f55)
>>>>>>> fix-implicit-begins
    movl -24(%esp), %edi   # load new closure to %edi
# emit-shift-args:  size=3   si=-24  delta=20
    mov -24(%esp), %ebx  # shift frame cell
    mov %ebx, -4(%esp)  # down to base
# emit-shift-args:  size=2   si=-28  delta=20
    mov -28(%esp), %ebx  # shift frame cell
    mov %ebx, -8(%esp)  # down to base
# emit-shift-args:  size=1   si=-32  delta=20
    mov -32(%esp), %ebx  # shift frame cell
    mov %ebx, -12(%esp)  # down to base
# emit-shift-args:  size=0   si=-36  delta=20
    movl $8,%eax   # save arg count
    jmp *-2(%edi)  # tail-funcall
_L_156:
    .align 4,0x90
_L_153:
    movl -4(%esp), %ebx
    movl -8(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin)
# emit-begin
#   expr=(begin)
#   env=((f51 . 0))
# emit-expr (begin (closure (f57) (f51) (let ((f57 f57)) ((vector-ref f51 0) f57 ()))))
# emit-begin
#   expr=(begin (closure (f57) (f51) (let ((f57 f57)) ((vector-ref f51 0) f57 ()))))
#   env=((f51 . 0))
# emit-expr (closure (f57) (f51) (let ((f57 f57)) ((vector-ref f51 0) f57 ())))
# emit-closure
# si = -4
# env = ((f51 . 0))
# expr = (closure (f57) (f51) (let ((f57 f57)) ((vector-ref f51 0) f57 ())))
    movl $_L_163, 0(%ebp)  # closure label
# emit-variable-ref
# env=((f51 . 0))
# var=f51
    movl 0(%esp), %eax  # stack load f51
# end emit-variable-ref
   movl  %eax, 4(%ebp)  # f51
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $8, %ebp     # bump ebp
    jmp _L_164            # jump around closure body
_L_163:
# check argument count
    cmp $4,%eax
    je _L_165
# invoke error handler eh_argcount
    .extern mrc_eh$uargcount
    movl mrc_eh$uargcount, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_165:
# emit-tail-expr
# si=-12
# env=((f57 . -8) (f51 . 4) (f51 . 0))
# expr=(let ((f57 f57)) ((vector-ref f51 0) f57 ()))
# emit-tail-let
#  si   = -12
#  env  = ((f57 . -8) (f51 . 4) (f51 . 0))
#  bindings = ((f57 f57))
#  body = ((vector-ref f51 0) f57 ())
# emit-expr f57
# emit-variable-ref
# env=((f57 . -8) (f51 . 4) (f51 . 0))
# var=f57
    movl -8(%esp), %eax  # stack load f57
# end emit-variable-ref
    movl %eax, -12(%esp)  # stack save
# emit-tail-expr
# si=-16
# env=((f57 . -12) (f57 . -8) (f51 . 4) (f51 . 0))
# expr=((vector-ref f51 0) f57 ())
# emit-tail-funcall
#    si   =-16
#    env  = ((f57 . -12) (f57 . -8) (f51 . 4) (f51 . 0))
#    expr = (funcall (vector-ref f51 0) f57 ())
# emit-expr (vector-ref f51 0)
# emit-expr f51
# emit-variable-ref
# env=((f57 . -12) (f57 . -8) (f51 . 4) (f51 . 0))
# var=f51
    movl 2(%edi), %eax  # frame load f51
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_166
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_166:
    movl %eax, -16(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_167"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_167:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_169
    cmp  $0,%eax
    jge _L_168
_L_169:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_168:
    movl -16(%esp), %esi
    movl -1(%eax,%esi), %eax
   movl %eax,  -16(%esp)  # stash funcall-oper in next closure slot
# emit-expr f57
# emit-variable-ref
# env=((f57 . -12) (f57 . -8) (f51 . 4) (f51 . 0))
# var=f57
    movl -12(%esp), %eax  # stack load f57
# end emit-variable-ref
    mov %eax, -20(%esp)    # arg f57
# emit-expr ()
    movl $63, %eax     # immed ()
    mov %eax, -24(%esp)    # arg ()
    movl -16(%esp), %edi   # load new closure to %edi
# emit-shift-args:  size=3   si=-16  delta=12
    mov -16(%esp), %ebx  # shift frame cell
    mov %ebx, -4(%esp)  # down to base
# emit-shift-args:  size=2   si=-20  delta=12
    mov -20(%esp), %ebx  # shift frame cell
    mov %ebx, -8(%esp)  # down to base
# emit-shift-args:  size=1   si=-24  delta=12
    mov -24(%esp), %ebx  # shift frame cell
    mov %ebx, -12(%esp)  # down to base
# emit-shift-args:  size=0   si=-28  delta=12
    movl $8,%eax   # save arg count
    jmp *-2(%edi)  # tail-funcall
    .align 4,0x90
_L_164:
# emit-expr (begin)
# emit-begin
#   expr=(begin)
#   env=((f51 . 0))
     movl %eax, mrc_reverse
# == explicit-begins  ==>
# (lambda args args)
# == eliminate-let*  ==>
# (lambda args args)
# == uniquify-variables  ==>
# (lambda f58 f58)
# == vectorize-letrec  ==>
# (lambda f58 f58)
# == eliminate-set!  ==>
# (lambda f58 (let () f58))
# == close-free-variables  ==>
# (closure f58 () (let () f58))
# == eliminate-quote  ==>
# (closure f58 () (let () f58))
# == eliminate-when/unless  ==>
# (closure f58 () (let () f58))
# == eliminate-cond  ==>
# (closure f58 () (let () f58))
# == external-symbols  ==>
# (closure f58 () (let () f58))
# emit-expr (closure f58 () (let () f58))
# emit-closure
# si = 0
# env = ()
# expr = (closure f58 () (let () f58))
    movl $_L_170, 0(%ebp)  # closure label
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $8, %ebp     # bump ebp
    jmp _L_171            # jump around closure body
_L_170:
# check argument count
    cmp $0,%eax
    jge _L_172
# invoke error handler eh_argcount_min
    .extern mrc_eh$uargcount$umin
    movl mrc_eh$uargcount$umin, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_172:
# emit-build-varargs-list
    movl $63, %esi       # args <- () 
    lea -4(%esp),%edi    # edi <- esp-4
    subl %eax, %edi      # edi <- esp-4-eax    addr of arg[K+N] on stack
_L_174:
    lea -4(%esp),%ebx    # addr of arg[K] on stack
    cmp %edi, %ebx       # while edi <> esp+(si+4)
    je _L_173
    movl (%edi),%ebx     # arg i -> car
    movl %ebx, 0(%ebp)
    movl %esi, 4(%ebp)  # esi -> cdr
    movl %ebp, %esi
    addl $1, %esi       # tag as pair
    addl $8,%ebp         # bump heap ptr
    addl $4,%edi         # move to next previous arg from the end
    jmp _L_174
_L_173:
    movl %esi, -8(%esp)  # set args
# emit-tail-expr
# si=-12
# env=((f58 . -8))
# expr=(let () f58)
# emit-tail-let
#  si   = -12
#  env  = ((f58 . -8))
#  bindings = ()
#  body = f58
# emit-tail-expr
# si=-12
# env=((f58 . -8))
# expr=f58
# emit-tail-variable-ref
# emit-variable-ref
# env=((f58 . -8))
# var=f58
    movl -8(%esp), %eax  # stack load f58
# end emit-variable-ref
    ret
# end emit-tail-variable ref
    .align 4,0x90
_L_171:
     movl %eax, mrc_list
# == explicit-begins  ==>
# (letrec ((fill-vector (lambda (v k args) (if (null? args) v (begin (vector-set! v k (car args)) (fill-vector v (fxadd1 k) (cdr args))))))) (lambda args (let ((v (make-vector (list-length args)))) (fill-vector v 0 args))))
# == eliminate-let*  ==>
# (letrec ((fill-vector (lambda (v k args) (if (null? args) v (begin (vector-set! v k (car args)) (fill-vector v (fxadd1 k) (cdr args))))))) (lambda args (let ((v (make-vector (list-length args)))) (fill-vector v 0 args))))
# == uniquify-variables  ==>
<<<<<<< HEAD
# (letrec ((f310846 (lambda (f310852 f310851 f310850) (if (null? f310850) f310852 (begin (vector-set! f310852 f310851 (car f310850)) (f310846 f310852 (fxadd1 f310851) (cdr f310850))))))) (lambda f310856 (let ((f310858 (make-vector (list-length f310856)))) (f310846 f310858 0 f310856))))
# == vectorize-letrec  ==>
# (let ((f310846 (make-vector 1))) (begin (begin (vector-set! f310846 0 (lambda (f310852 f310851 f310850) (if (null? f310850) f310852 (begin (vector-set! f310852 f310851 (car f310850)) ((vector-ref f310846 0) f310852 (fxadd1 f310851) (cdr f310850))))))) (lambda f310856 (let ((f310858 (make-vector (list-length f310856)))) ((vector-ref f310846 0) f310858 0 f310856)))))
# == eliminate-set!  ==>
# (let ((f310846 (make-vector 1))) (begin (begin (vector-set! f310846 0 (lambda (f310852 f310851 f310850) (let ((f310852 f310852) (f310851 f310851) (f310850 f310850)) (if (null? f310850) f310852 (begin (vector-set! f310852 f310851 (car f310850)) ((vector-ref f310846 0) f310852 (fxadd1 f310851) (cdr f310850)))))))) (lambda f310856 (let () (let ((f310858 (make-vector (list-length f310856)))) ((vector-ref f310846 0) f310858 0 f310856))))))
# == close-free-variables  ==>
# (let ((f310846 (make-vector 1))) (begin (begin (vector-set! f310846 0 (closure (f310852 f310851 f310850) (f310846) (let ((f310852 f310852) (f310851 f310851) (f310850 f310850)) (if (null? f310850) f310852 (begin (vector-set! f310852 f310851 (car f310850)) ((vector-ref f310846 0) f310852 (fxadd1 f310851) (cdr f310850)))))))) (closure f310856 (f310846) (let () (let ((f310858 (make-vector (list-length f310856)))) ((vector-ref f310846 0) f310858 0 f310856))))))
# == eliminate-quote  ==>
# (let ((f310846 (make-vector 1))) (begin (begin (vector-set! f310846 0 (closure (f310852 f310851 f310850) (f310846) (let ((f310852 f310852) (f310851 f310851) (f310850 f310850)) (if (null? f310850) f310852 (begin (vector-set! f310852 f310851 (car f310850)) ((vector-ref f310846 0) f310852 (fxadd1 f310851) (cdr f310850)))))))) (closure f310856 (f310846) (let () (let ((f310858 (make-vector (list-length f310856)))) ((vector-ref f310846 0) f310858 0 f310856))))))
# == eliminate-when/unless  ==>
# (let ((f310846 (make-vector 1))) (begin (begin (vector-set! f310846 0 (closure (f310852 f310851 f310850) (f310846) (let ((f310852 f310852) (f310851 f310851) (f310850 f310850)) (if (null? f310850) f310852 (begin (vector-set! f310852 f310851 (car f310850)) ((vector-ref f310846 0) f310852 (fxadd1 f310851) (cdr f310850)))))))) (closure f310856 (f310846) (let () (let ((f310858 (make-vector (list-length f310856)))) ((vector-ref f310846 0) f310858 0 f310856))))))
# == eliminate-cond  ==>
# (let ((f310846 (make-vector 1))) (begin (begin (vector-set! f310846 0 (closure (f310852 f310851 f310850) (f310846) (let ((f310852 f310852) (f310851 f310851) (f310850 f310850)) (if (null? f310850) f310852 (begin (vector-set! f310852 f310851 (car f310850)) ((vector-ref f310846 0) f310852 (fxadd1 f310851) (cdr f310850)))))))) (closure f310856 (f310846) (let () (let ((f310858 (make-vector (list-length f310856)))) ((vector-ref f310846 0) f310858 0 f310856))))))
# == external-symbols  ==>
# (let ((f310846 (make-vector 1))) (begin (begin (vector-set! f310846 0 (closure (f310852 f310851 f310850) (f310846) (let ((f310852 f310852) (f310851 f310851) (f310850 f310850)) (if (null? f310850) f310852 (begin (vector-set! f310852 f310851 (car f310850)) ((vector-ref f310846 0) f310852 (fxadd1 f310851) (cdr f310850)))))))) (closure f310856 (f310846) (let () (let ((f310858 (make-vector ((primitive-ref list-length) f310856)))) ((vector-ref f310846 0) f310858 0 f310856))))))
# emit-expr (let ((f310846 (make-vector 1))) (begin (begin (vector-set! f310846 0 (closure (f310852 f310851 f310850) (f310846) (let ((f310852 f310852) (f310851 f310851) (f310850 f310850)) (if (null? f310850) f310852 (begin (vector-set! f310852 f310851 (car f310850)) ((vector-ref f310846 0) f310852 (fxadd1 f310851) (cdr f310850)))))))) (closure f310856 (f310846) (let () (let ((f310858 (make-vector ((primitive-ref list-length) f310856)))) ((vector-ref f310846 0) f310858 0 f310856))))))
# emit-let
#  si   = 0
#  env  = ()
#  bindings = ((f310846 (make-vector 1)))
#  body = (begin (begin (vector-set! f310846 0 (closure (f310852 f310851 f310850) (f310846) (let ((f310852 f310852) (f310851 f310851) (f310850 f310850)) (if (null? f310850) f310852 (begin (vector-set! f310852 f310851 (car f310850)) ((vector-ref f310846 0) f310852 (fxadd1 f310851) (cdr f310850)))))))) (closure f310856 (f310846) (let () (let ((f310858 (make-vector ((primitive-ref list-length) f310856)))) ((vector-ref f310846 0) f310858 0 f310856)))))
=======
# (letrec ((f59 (lambda (f63 f64 f65) (if (null? f65) f63 (begin (vector-set! f63 f64 (car f65)) (f59 f63 (fxadd1 f64) (cdr f65))))))) (lambda f69 (let ((f71 (make-vector (list-length f69)))) (f59 f71 0 f69))))
# == vectorize-letrec  ==>
# (let ((f59 (make-vector 1))) (begin (begin (vector-set! f59 0 (lambda (f63 f64 f65) (if (null? f65) f63 (begin (vector-set! f63 f64 (car f65)) ((vector-ref f59 0) f63 (fxadd1 f64) (cdr f65))))))) (lambda f69 (let ((f71 (make-vector (list-length f69)))) ((vector-ref f59 0) f71 0 f69)))))
# == eliminate-set!  ==>
# (let ((f59 (make-vector 1))) (begin (begin (vector-set! f59 0 (lambda (f63 f64 f65) (let ((f63 f63) (f64 f64) (f65 f65)) (if (null? f65) f63 (begin (vector-set! f63 f64 (car f65)) ((vector-ref f59 0) f63 (fxadd1 f64) (cdr f65)))))))) (lambda f69 (let () (let ((f71 (make-vector (list-length f69)))) ((vector-ref f59 0) f71 0 f69))))))
# == close-free-variables  ==>
# (let ((f59 (make-vector 1))) (begin (begin (vector-set! f59 0 (closure (f63 f64 f65) (f59) (let ((f63 f63) (f64 f64) (f65 f65)) (if (null? f65) f63 (begin (vector-set! f63 f64 (car f65)) ((vector-ref f59 0) f63 (fxadd1 f64) (cdr f65)))))))) (closure f69 (f59) (let () (let ((f71 (make-vector (list-length f69)))) ((vector-ref f59 0) f71 0 f69))))))
# == eliminate-quote  ==>
# (let ((f59 (make-vector 1))) (begin (begin (vector-set! f59 0 (closure (f63 f64 f65) (f59) (let ((f63 f63) (f64 f64) (f65 f65)) (if (null? f65) f63 (begin (vector-set! f63 f64 (car f65)) ((vector-ref f59 0) f63 (fxadd1 f64) (cdr f65)))))))) (closure f69 (f59) (let () (let ((f71 (make-vector (list-length f69)))) ((vector-ref f59 0) f71 0 f69))))))
# == eliminate-when/unless  ==>
# (let ((f59 (make-vector 1))) (begin (begin (vector-set! f59 0 (closure (f63 f64 f65) (f59) (let ((f63 f63) (f64 f64) (f65 f65)) (if (null? f65) f63 (begin (vector-set! f63 f64 (car f65)) ((vector-ref f59 0) f63 (fxadd1 f64) (cdr f65)))))))) (closure f69 (f59) (let () (let ((f71 (make-vector (list-length f69)))) ((vector-ref f59 0) f71 0 f69))))))
# == eliminate-cond  ==>
# (let ((f59 (make-vector 1))) (begin (begin (vector-set! f59 0 (closure (f63 f64 f65) (f59) (let ((f63 f63) (f64 f64) (f65 f65)) (if (null? f65) f63 (begin (vector-set! f63 f64 (car f65)) ((vector-ref f59 0) f63 (fxadd1 f64) (cdr f65)))))))) (closure f69 (f59) (let () (let ((f71 (make-vector (list-length f69)))) ((vector-ref f59 0) f71 0 f69))))))
# == external-symbols  ==>
# (let ((f59 (make-vector 1))) (begin (begin (vector-set! f59 0 (closure (f63 f64 f65) (f59) (let ((f63 f63) (f64 f64) (f65 f65)) (if (null? f65) f63 (begin (vector-set! f63 f64 (car f65)) ((vector-ref f59 0) f63 (fxadd1 f64) (cdr f65)))))))) (closure f69 (f59) (let () (let ((f71 (make-vector ((primitive-ref list-length) f69)))) ((vector-ref f59 0) f71 0 f69))))))
# emit-expr (let ((f59 (make-vector 1))) (begin (begin (vector-set! f59 0 (closure (f63 f64 f65) (f59) (let ((f63 f63) (f64 f64) (f65 f65)) (if (null? f65) f63 (begin (vector-set! f63 f64 (car f65)) ((vector-ref f59 0) f63 (fxadd1 f64) (cdr f65)))))))) (closure f69 (f59) (let () (let ((f71 (make-vector ((primitive-ref list-length) f69)))) ((vector-ref f59 0) f71 0 f69))))))
# emit-let
#  si   = 0
#  env  = ()
#  bindings = ((f59 (make-vector 1)))
#  body = (begin (begin (vector-set! f59 0 (closure (f63 f64 f65) (f59) (let ((f63 f63) (f64 f64) (f65 f65)) (if (null? f65) f63 (begin (vector-set! f63 f64 (car f65)) ((vector-ref f59 0) f63 (fxadd1 f64) (cdr f65)))))))) (closure f69 (f59) (let () (let ((f71 (make-vector ((primitive-ref list-length) f69)))) ((vector-ref f59 0) f71 0 f69)))))
>>>>>>> fix-implicit-begins
# emit-expr (make-vector 1)
# make-vector 1
# emit-expr 1
    movl $4, %eax     # immed 1
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_175"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_175:
# check the argument is a fixnum >= 0
    cmp $0,%eax
    jge _L_176
# invoke error handler eh_length
    .extern mrc_eh$ulength
    movl mrc_eh$ulength, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_176:
    movl %eax, %esi
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    orl  $5, %eax
    addl $4, %esi
    addl $4, %esi
    andl $-8, %esi
    addl %esi, %ebp
    movl %eax, 0(%esp)  # stack save
<<<<<<< HEAD
# emit-expr (begin (begin (vector-set! f310846 0 (closure (f310852 f310851 f310850) (f310846) (let ((f310852 f310852) (f310851 f310851) (f310850 f310850)) (if (null? f310850) f310852 (begin (vector-set! f310852 f310851 (car f310850)) ((vector-ref f310846 0) f310852 (fxadd1 f310851) (cdr f310850)))))))) (closure f310856 (f310846) (let () (let ((f310858 (make-vector ((primitive-ref list-length) f310856)))) ((vector-ref f310846 0) f310858 0 f310856)))))
# emit-begin
#   expr=(begin (begin (vector-set! f310846 0 (closure (f310852 f310851 f310850) (f310846) (let ((f310852 f310852) (f310851 f310851) (f310850 f310850)) (if (null? f310850) f310852 (begin (vector-set! f310852 f310851 (car f310850)) ((vector-ref f310846 0) f310852 (fxadd1 f310851) (cdr f310850)))))))) (closure f310856 (f310846) (let () (let ((f310858 (make-vector ((primitive-ref list-length) f310856)))) ((vector-ref f310846 0) f310858 0 f310856)))))
#   env=((f310846 . 0))
# emit-expr (begin (vector-set! f310846 0 (closure (f310852 f310851 f310850) (f310846) (let ((f310852 f310852) (f310851 f310851) (f310850 f310850)) (if (null? f310850) f310852 (begin (vector-set! f310852 f310851 (car f310850)) ((vector-ref f310846 0) f310852 (fxadd1 f310851) (cdr f310850))))))))
# emit-begin
#   expr=(begin (vector-set! f310846 0 (closure (f310852 f310851 f310850) (f310846) (let ((f310852 f310852) (f310851 f310851) (f310850 f310850)) (if (null? f310850) f310852 (begin (vector-set! f310852 f310851 (car f310850)) ((vector-ref f310846 0) f310852 (fxadd1 f310851) (cdr f310850))))))))
#   env=((f310846 . 0))
# emit-expr (vector-set! f310846 0 (closure (f310852 f310851 f310850) (f310846) (let ((f310852 f310852) (f310851 f310851) (f310850 f310850)) (if (null? f310850) f310852 (begin (vector-set! f310852 f310851 (car f310850)) ((vector-ref f310846 0) f310852 (fxadd1 f310851) (cdr f310850)))))))
# emit-expr f310846
=======
# emit-expr (begin (begin (vector-set! f59 0 (closure (f63 f64 f65) (f59) (let ((f63 f63) (f64 f64) (f65 f65)) (if (null? f65) f63 (begin (vector-set! f63 f64 (car f65)) ((vector-ref f59 0) f63 (fxadd1 f64) (cdr f65)))))))) (closure f69 (f59) (let () (let ((f71 (make-vector ((primitive-ref list-length) f69)))) ((vector-ref f59 0) f71 0 f69)))))
# emit-begin
#   expr=(begin (begin (vector-set! f59 0 (closure (f63 f64 f65) (f59) (let ((f63 f63) (f64 f64) (f65 f65)) (if (null? f65) f63 (begin (vector-set! f63 f64 (car f65)) ((vector-ref f59 0) f63 (fxadd1 f64) (cdr f65)))))))) (closure f69 (f59) (let () (let ((f71 (make-vector ((primitive-ref list-length) f69)))) ((vector-ref f59 0) f71 0 f69)))))
#   env=((f59 . 0))
# emit-expr (begin (vector-set! f59 0 (closure (f63 f64 f65) (f59) (let ((f63 f63) (f64 f64) (f65 f65)) (if (null? f65) f63 (begin (vector-set! f63 f64 (car f65)) ((vector-ref f59 0) f63 (fxadd1 f64) (cdr f65))))))))
# emit-begin
#   expr=(begin (vector-set! f59 0 (closure (f63 f64 f65) (f59) (let ((f63 f63) (f64 f64) (f65 f65)) (if (null? f65) f63 (begin (vector-set! f63 f64 (car f65)) ((vector-ref f59 0) f63 (fxadd1 f64) (cdr f65))))))))
#   env=((f59 . 0))
# emit-expr (vector-set! f59 0 (closure (f63 f64 f65) (f59) (let ((f63 f63) (f64 f64) (f65 f65)) (if (null? f65) f63 (begin (vector-set! f63 f64 (car f65)) ((vector-ref f59 0) f63 (fxadd1 f64) (cdr f65)))))))
# emit-expr f59
>>>>>>> fix-implicit-begins
# emit-variable-ref
# env=((f59 . 0))
# var=f59
    movl 0(%esp), %eax  # stack load f59
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_177
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_177:
    movl %eax, -4(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_178"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_178:
# check bounds on vector index
    movl -4(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_180
    cmp  $0,%eax
    jge _L_179
_L_180:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_179:
    movl %eax, -8(%esp)
<<<<<<< HEAD
# emit-expr (closure (f310852 f310851 f310850) (f310846) (let ((f310852 f310852) (f310851 f310851) (f310850 f310850)) (if (null? f310850) f310852 (begin (vector-set! f310852 f310851 (car f310850)) ((vector-ref f310846 0) f310852 (fxadd1 f310851) (cdr f310850))))))
# emit-closure
# si = -12
# env = ((f310846 . 0))
# expr = (closure (f310852 f310851 f310850) (f310846) (let ((f310852 f310852) (f310851 f310851) (f310850 f310850)) (if (null? f310850) f310852 (begin (vector-set! f310852 f310851 (car f310850)) ((vector-ref f310846 0) f310852 (fxadd1 f310851) (cdr f310850))))))
    movl $_L_1883780, 0(%ebp)  # closure label
=======
# emit-expr (closure (f63 f64 f65) (f59) (let ((f63 f63) (f64 f64) (f65 f65)) (if (null? f65) f63 (begin (vector-set! f63 f64 (car f65)) ((vector-ref f59 0) f63 (fxadd1 f64) (cdr f65))))))
# emit-closure
# si = -12
# env = ((f59 . 0))
# expr = (closure (f63 f64 f65) (f59) (let ((f63 f63) (f64 f64) (f65 f65)) (if (null? f65) f63 (begin (vector-set! f63 f64 (car f65)) ((vector-ref f59 0) f63 (fxadd1 f64) (cdr f65))))))
    movl $_L_181, 0(%ebp)  # closure label
>>>>>>> fix-implicit-begins
# emit-variable-ref
# env=((f59 . 0))
# var=f59
    movl 0(%esp), %eax  # stack load f59
# end emit-variable-ref
   movl  %eax, 4(%ebp)  # f59
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $8, %ebp     # bump ebp
    jmp _L_182            # jump around closure body
_L_181:
# check argument count
    cmp $12,%eax
    je _L_183
# invoke error handler eh_argcount
    .extern mrc_eh$uargcount
    movl mrc_eh$uargcount, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_183:
# emit-tail-expr
# si=-20
<<<<<<< HEAD
# env=((f310850 . -16) (f310851 . -12) (f310852 . -8) (f310846 . 4) (f310846 . 0))
# expr=(let ((f310852 f310852) (f310851 f310851) (f310850 f310850)) (if (null? f310850) f310852 (begin (vector-set! f310852 f310851 (car f310850)) ((vector-ref f310846 0) f310852 (fxadd1 f310851) (cdr f310850)))))
# emit-tail-let
#  si   = -20
#  env  = ((f310850 . -16) (f310851 . -12) (f310852 . -8) (f310846 . 4) (f310846 . 0))
#  bindings = ((f310852 f310852) (f310851 f310851) (f310850 f310850))
#  body = (if (null? f310850) f310852 (begin (vector-set! f310852 f310851 (car f310850)) ((vector-ref f310846 0) f310852 (fxadd1 f310851) (cdr f310850))))
# emit-expr f310852
# emit-variable-ref
# env=((f310850 . -16) (f310851 . -12) (f310852 . -8) (f310846 . 4) (f310846 . 0))
# var=f310852
    movl -8(%esp), %eax  # stack load f310852
=======
# env=((f65 . -16) (f64 . -12) (f63 . -8) (f59 . 4) (f59 . 0))
# expr=(let ((f63 f63) (f64 f64) (f65 f65)) (if (null? f65) f63 (begin (vector-set! f63 f64 (car f65)) ((vector-ref f59 0) f63 (fxadd1 f64) (cdr f65)))))
# emit-tail-let
#  si   = -20
#  env  = ((f65 . -16) (f64 . -12) (f63 . -8) (f59 . 4) (f59 . 0))
#  bindings = ((f63 f63) (f64 f64) (f65 f65))
#  body = (if (null? f65) f63 (begin (vector-set! f63 f64 (car f65)) ((vector-ref f59 0) f63 (fxadd1 f64) (cdr f65))))
# emit-expr f63
# emit-variable-ref
# env=((f65 . -16) (f64 . -12) (f63 . -8) (f59 . 4) (f59 . 0))
# var=f63
    movl -8(%esp), %eax  # stack load f63
>>>>>>> fix-implicit-begins
# end emit-variable-ref
    movl %eax, -20(%esp)  # stack save
# emit-expr f64
# emit-variable-ref
<<<<<<< HEAD
# env=((f310850 . -16) (f310851 . -12) (f310852 . -8) (f310846 . 4) (f310846 . 0))
# var=f310851
    movl -12(%esp), %eax  # stack load f310851
# end emit-variable-ref
    movl %eax, -24(%esp)  # stack save
# emit-expr f310850
# emit-variable-ref
# env=((f310850 . -16) (f310851 . -12) (f310852 . -8) (f310846 . 4) (f310846 . 0))
# var=f310850
    movl -16(%esp), %eax  # stack load f310850
=======
# env=((f65 . -16) (f64 . -12) (f63 . -8) (f59 . 4) (f59 . 0))
# var=f64
    movl -12(%esp), %eax  # stack load f64
# end emit-variable-ref
    movl %eax, -24(%esp)  # stack save
# emit-expr f65
# emit-variable-ref
# env=((f65 . -16) (f64 . -12) (f63 . -8) (f59 . 4) (f59 . 0))
# var=f65
    movl -16(%esp), %eax  # stack load f65
>>>>>>> fix-implicit-begins
# end emit-variable-ref
    movl %eax, -28(%esp)  # stack save
# emit-tail-expr
# si=-32
<<<<<<< HEAD
# env=((f310850 . -28) (f310851 . -24) (f310852 . -20) (f310850 . -16) (f310851 . -12) (f310852 . -8) (f310846 . 4) (f310846 . 0))
# expr=(if (null? f310850) f310852 (begin (vector-set! f310852 f310851 (car f310850)) ((vector-ref f310846 0) f310852 (fxadd1 f310851) (cdr f310850))))
# emit-expr (null? f310850)
# emit-expr f310850
# emit-variable-ref
# env=((f310850 . -28) (f310851 . -24) (f310852 . -20) (f310850 . -16) (f310851 . -12) (f310852 . -8) (f310846 . 4) (f310846 . 0))
# var=f310850
    movl -28(%esp), %eax  # stack load f310850
=======
# env=((f65 . -28) (f64 . -24) (f63 . -20) (f65 . -16) (f64 . -12) (f63 . -8) (f59 . 4) (f59 . 0))
# expr=(if (null? f65) f63 (begin (vector-set! f63 f64 (car f65)) ((vector-ref f59 0) f63 (fxadd1 f64) (cdr f65))))
# emit-expr (null? f65)
# emit-expr f65
# emit-variable-ref
# env=((f65 . -28) (f64 . -24) (f63 . -20) (f65 . -16) (f64 . -12) (f63 . -8) (f59 . 4) (f59 . 0))
# var=f65
    movl -28(%esp), %eax  # stack load f65
>>>>>>> fix-implicit-begins
# end emit-variable-ref
    cmp $63, %eax
    mov $0, %eax
    sete %al
    movzbl %al, %eax
    sal $6, %al
    or $47, %al
    cmp $47, %al
    je _L_184
# emit-tail-expr
# si=-32
<<<<<<< HEAD
# env=((f310850 . -28) (f310851 . -24) (f310852 . -20) (f310850 . -16) (f310851 . -12) (f310852 . -8) (f310846 . 4) (f310846 . 0))
# expr=f310852
# emit-tail-variable-ref
# emit-variable-ref
# env=((f310850 . -28) (f310851 . -24) (f310852 . -20) (f310850 . -16) (f310851 . -12) (f310852 . -8) (f310846 . 4) (f310846 . 0))
# var=f310852
    movl -20(%esp), %eax  # stack load f310852
=======
# env=((f65 . -28) (f64 . -24) (f63 . -20) (f65 . -16) (f64 . -12) (f63 . -8) (f59 . 4) (f59 . 0))
# expr=f63
# emit-tail-variable-ref
# emit-variable-ref
# env=((f65 . -28) (f64 . -24) (f63 . -20) (f65 . -16) (f64 . -12) (f63 . -8) (f59 . 4) (f59 . 0))
# var=f63
    movl -20(%esp), %eax  # stack load f63
>>>>>>> fix-implicit-begins
# end emit-variable-ref
    ret
# end emit-tail-variable ref
    jmp _L_185
_L_184:
# emit-tail-expr
# si=-32
<<<<<<< HEAD
# env=((f310850 . -28) (f310851 . -24) (f310852 . -20) (f310850 . -16) (f310851 . -12) (f310852 . -8) (f310846 . 4) (f310846 . 0))
# expr=(begin (vector-set! f310852 f310851 (car f310850)) ((vector-ref f310846 0) f310852 (fxadd1 f310851) (cdr f310850)))
# tail-begin (begin (vector-set! f310852 f310851 (car f310850)) ((vector-ref f310846 0) f310852 (fxadd1 f310851) (cdr f310850)))
#   env=((f310850 . -28) (f310851 . -24) (f310852 . -20) (f310850 . -16) (f310851 . -12) (f310852 . -8) (f310846 . 4) (f310846 . 0))
# emit-expr (vector-set! f310852 f310851 (car f310850))
# emit-expr f310852
# emit-variable-ref
# env=((f310850 . -28) (f310851 . -24) (f310852 . -20) (f310850 . -16) (f310851 . -12) (f310852 . -8) (f310846 . 4) (f310846 . 0))
# var=f310852
    movl -20(%esp), %eax  # stack load f310852
=======
# env=((f65 . -28) (f64 . -24) (f63 . -20) (f65 . -16) (f64 . -12) (f63 . -8) (f59 . 4) (f59 . 0))
# expr=(begin (vector-set! f63 f64 (car f65)) ((vector-ref f59 0) f63 (fxadd1 f64) (cdr f65)))
# tail-begin (begin (vector-set! f63 f64 (car f65)) ((vector-ref f59 0) f63 (fxadd1 f64) (cdr f65)))
#   env=((f65 . -28) (f64 . -24) (f63 . -20) (f65 . -16) (f64 . -12) (f63 . -8) (f59 . 4) (f59 . 0))
# emit-expr (vector-set! f63 f64 (car f65))
# emit-expr f63
# emit-variable-ref
# env=((f65 . -28) (f64 . -24) (f63 . -20) (f65 . -16) (f64 . -12) (f63 . -8) (f59 . 4) (f59 . 0))
# var=f63
    movl -20(%esp), %eax  # stack load f63
>>>>>>> fix-implicit-begins
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_186
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_186:
    movl %eax, -32(%esp)
# emit-expr f64
# emit-variable-ref
<<<<<<< HEAD
# env=((f310850 . -28) (f310851 . -24) (f310852 . -20) (f310850 . -16) (f310851 . -12) (f310852 . -8) (f310846 . 4) (f310846 . 0))
# var=f310851
    movl -24(%esp), %eax  # stack load f310851
=======
# env=((f65 . -28) (f64 . -24) (f63 . -20) (f65 . -16) (f64 . -12) (f63 . -8) (f59 . 4) (f59 . 0))
# var=f64
    movl -24(%esp), %eax  # stack load f64
>>>>>>> fix-implicit-begins
# end emit-variable-ref
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_187"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_187:
# check bounds on vector index
    movl -32(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_189
    cmp  $0,%eax
    jge _L_188
_L_189:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_188:
    movl %eax, -36(%esp)
<<<<<<< HEAD
# emit-expr (car f310850)
# emit-expr f310850
# emit-variable-ref
# env=((f310850 . -28) (f310851 . -24) (f310852 . -20) (f310850 . -16) (f310851 . -12) (f310852 . -8) (f310846 . 4) (f310846 . 0))
# var=f310850
    movl -28(%esp), %eax  # stack load f310850
=======
# emit-expr (car f65)
# emit-expr f65
# emit-variable-ref
# env=((f65 . -28) (f64 . -24) (f63 . -20) (f65 . -16) (f64 . -12) (f63 . -8) (f59 . 4) (f59 . 0))
# var=f65
    movl -28(%esp), %eax  # stack load f65
>>>>>>> fix-implicit-begins
# end emit-variable-ref
# check the argument is a pair
    movl %eax,%ebx
    and $7, %bl
    cmp $1, %bl
    je _L_190
# invoke error handler eh_pair
    .extern mrc_eh$upair
    movl mrc_eh$upair, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $116,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_190:
    movl -1(%eax), %eax
    movl -32(%esp), %ebx
    movl -36(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-tail-expr
# si=-32
<<<<<<< HEAD
# env=((f310850 . -28) (f310851 . -24) (f310852 . -20) (f310850 . -16) (f310851 . -12) (f310852 . -8) (f310846 . 4) (f310846 . 0))
# expr=(begin ((vector-ref f310846 0) f310852 (fxadd1 f310851) (cdr f310850)))
# tail-begin (begin ((vector-ref f310846 0) f310852 (fxadd1 f310851) (cdr f310850)))
#   env=((f310850 . -28) (f310851 . -24) (f310852 . -20) (f310850 . -16) (f310851 . -12) (f310852 . -8) (f310846 . 4) (f310846 . 0))
# emit-tail-expr
# si=-32
# env=((f310850 . -28) (f310851 . -24) (f310852 . -20) (f310850 . -16) (f310851 . -12) (f310852 . -8) (f310846 . 4) (f310846 . 0))
# expr=((vector-ref f310846 0) f310852 (fxadd1 f310851) (cdr f310850))
# emit-tail-funcall
#    si   =-32
#    env  = ((f310850 . -28) (f310851 . -24) (f310852 . -20) (f310850 . -16) (f310851 . -12) (f310852 . -8) (f310846 . 4) (f310846 . 0))
#    expr = (funcall (vector-ref f310846 0) f310852 (fxadd1 f310851) (cdr f310850))
# emit-expr (vector-ref f310846 0)
# emit-expr f310846
# emit-variable-ref
# env=((f310850 . -28) (f310851 . -24) (f310852 . -20) (f310850 . -16) (f310851 . -12) (f310852 . -8) (f310846 . 4) (f310846 . 0))
# var=f310846
    movl 2(%edi), %eax  # frame load f310846
=======
# env=((f65 . -28) (f64 . -24) (f63 . -20) (f65 . -16) (f64 . -12) (f63 . -8) (f59 . 4) (f59 . 0))
# expr=(begin ((vector-ref f59 0) f63 (fxadd1 f64) (cdr f65)))
# tail-begin (begin ((vector-ref f59 0) f63 (fxadd1 f64) (cdr f65)))
#   env=((f65 . -28) (f64 . -24) (f63 . -20) (f65 . -16) (f64 . -12) (f63 . -8) (f59 . 4) (f59 . 0))
# emit-tail-expr
# si=-32
# env=((f65 . -28) (f64 . -24) (f63 . -20) (f65 . -16) (f64 . -12) (f63 . -8) (f59 . 4) (f59 . 0))
# expr=((vector-ref f59 0) f63 (fxadd1 f64) (cdr f65))
# emit-tail-funcall
#    si   =-32
#    env  = ((f65 . -28) (f64 . -24) (f63 . -20) (f65 . -16) (f64 . -12) (f63 . -8) (f59 . 4) (f59 . 0))
#    expr = (funcall (vector-ref f59 0) f63 (fxadd1 f64) (cdr f65))
# emit-expr (vector-ref f59 0)
# emit-expr f59
# emit-variable-ref
# env=((f65 . -28) (f64 . -24) (f63 . -20) (f65 . -16) (f64 . -12) (f63 . -8) (f59 . 4) (f59 . 0))
# var=f59
    movl 2(%edi), %eax  # frame load f59
>>>>>>> fix-implicit-begins
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_191
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_191:
    movl %eax, -32(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_192"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_192:
# check bounds on vector index
    movl -32(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_194
    cmp  $0,%eax
    jge _L_193
_L_194:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_193:
    movl -32(%esp), %esi
    movl -1(%eax,%esi), %eax
   movl %eax,  -32(%esp)  # stash funcall-oper in next closure slot
<<<<<<< HEAD
# emit-expr f310852
# emit-variable-ref
# env=((f310850 . -28) (f310851 . -24) (f310852 . -20) (f310850 . -16) (f310851 . -12) (f310852 . -8) (f310846 . 4) (f310846 . 0))
# var=f310852
    movl -20(%esp), %eax  # stack load f310852
# end emit-variable-ref
    mov %eax, -36(%esp)    # arg f310852
# emit-expr (fxadd1 f310851)
# emit-expr f310851
# emit-variable-ref
# env=((f310850 . -28) (f310851 . -24) (f310852 . -20) (f310850 . -16) (f310851 . -12) (f310852 . -8) (f310846 . 4) (f310846 . 0))
# var=f310851
    movl -24(%esp), %eax  # stack load f310851
=======
# emit-expr f63
# emit-variable-ref
# env=((f65 . -28) (f64 . -24) (f63 . -20) (f65 . -16) (f64 . -12) (f63 . -8) (f59 . 4) (f59 . 0))
# var=f63
    movl -20(%esp), %eax  # stack load f63
# end emit-variable-ref
    mov %eax, -36(%esp)    # arg f63
# emit-expr (fxadd1 f64)
# emit-expr f64
# emit-variable-ref
# env=((f65 . -28) (f64 . -24) (f63 . -20) (f65 . -16) (f64 . -12) (f63 . -8) (f59 . 4) (f59 . 0))
# var=f64
    movl -24(%esp), %eax  # stack load f64
>>>>>>> fix-implicit-begins
# end emit-variable-ref
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_195"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $56,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_195:
     addl $4, %eax
<<<<<<< HEAD
    mov %eax, -40(%esp)    # arg (fxadd1 f310851)
# emit-expr (cdr f310850)
# emit-expr f310850
# emit-variable-ref
# env=((f310850 . -28) (f310851 . -24) (f310852 . -20) (f310850 . -16) (f310851 . -12) (f310852 . -8) (f310846 . 4) (f310846 . 0))
# var=f310850
    movl -28(%esp), %eax  # stack load f310850
=======
    mov %eax, -40(%esp)    # arg (fxadd1 f64)
# emit-expr (cdr f65)
# emit-expr f65
# emit-variable-ref
# env=((f65 . -28) (f64 . -24) (f63 . -20) (f65 . -16) (f64 . -12) (f63 . -8) (f59 . 4) (f59 . 0))
# var=f65
    movl -28(%esp), %eax  # stack load f65
>>>>>>> fix-implicit-begins
# end emit-variable-ref
# check the argument is a pair
    movl %eax,%ebx
    and $7, %bl
    cmp $1, %bl
    je _L_196
# invoke error handler eh_pair
    .extern mrc_eh$upair
    movl mrc_eh$upair, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $120,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_196:
    movl 3(%eax), %eax
<<<<<<< HEAD
    mov %eax, -44(%esp)    # arg (cdr f310850)
=======
    mov %eax, -44(%esp)    # arg (cdr f65)
>>>>>>> fix-implicit-begins
    movl -32(%esp), %edi   # load new closure to %edi
# emit-shift-args:  size=4   si=-32  delta=28
    mov -32(%esp), %ebx  # shift frame cell
    mov %ebx, -4(%esp)  # down to base
# emit-shift-args:  size=3   si=-36  delta=28
    mov -36(%esp), %ebx  # shift frame cell
    mov %ebx, -8(%esp)  # down to base
# emit-shift-args:  size=2   si=-40  delta=28
    mov -40(%esp), %ebx  # shift frame cell
    mov %ebx, -12(%esp)  # down to base
# emit-shift-args:  size=1   si=-44  delta=28
    mov -44(%esp), %ebx  # shift frame cell
    mov %ebx, -16(%esp)  # down to base
# emit-shift-args:  size=0   si=-48  delta=28
    movl $12,%eax   # save arg count
    jmp *-2(%edi)  # tail-funcall
     ret   # return thru stack
_L_185:
    .align 4,0x90
_L_182:
    movl -4(%esp), %ebx
    movl -8(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin)
# emit-begin
#   expr=(begin)
#   env=((f59 . 0))
# emit-expr (begin (closure f69 (f59) (let () (let ((f71 (make-vector ((primitive-ref list-length) f69)))) ((vector-ref f59 0) f71 0 f69)))))
# emit-begin
#   expr=(begin (closure f69 (f59) (let () (let ((f71 (make-vector ((primitive-ref list-length) f69)))) ((vector-ref f59 0) f71 0 f69)))))
#   env=((f59 . 0))
# emit-expr (closure f69 (f59) (let () (let ((f71 (make-vector ((primitive-ref list-length) f69)))) ((vector-ref f59 0) f71 0 f69))))
# emit-closure
# si = -4
# env = ((f59 . 0))
# expr = (closure f69 (f59) (let () (let ((f71 (make-vector ((primitive-ref list-length) f69)))) ((vector-ref f59 0) f71 0 f69))))
    movl $_L_197, 0(%ebp)  # closure label
# emit-variable-ref
# env=((f59 . 0))
# var=f59
    movl 0(%esp), %eax  # stack load f59
# end emit-variable-ref
   movl  %eax, 4(%ebp)  # f59
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $8, %ebp     # bump ebp
    jmp _L_198            # jump around closure body
_L_197:
# check argument count
    cmp $0,%eax
    jge _L_199
# invoke error handler eh_argcount_min
    .extern mrc_eh$uargcount$umin
    movl mrc_eh$uargcount$umin, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_199:
# emit-build-varargs-list
    movl $63, %esi       # args <- () 
    lea -4(%esp),%edi    # edi <- esp-4
    subl %eax, %edi      # edi <- esp-4-eax    addr of arg[K+N] on stack
_L_201:
    lea -4(%esp),%ebx    # addr of arg[K] on stack
    cmp %edi, %ebx       # while edi <> esp+(si+4)
    je _L_200
    movl (%edi),%ebx     # arg i -> car
    movl %ebx, 0(%ebp)
    movl %esi, 4(%ebp)  # esi -> cdr
    movl %ebp, %esi
    addl $1, %esi       # tag as pair
    addl $8,%ebp         # bump heap ptr
    addl $4,%edi         # move to next previous arg from the end
    jmp _L_201
_L_200:
    movl %esi, -8(%esp)  # set args
# emit-tail-expr
# si=-12
# env=((f69 . -8) (f59 . 4) (f59 . 0))
# expr=(let () (let ((f71 (make-vector ((primitive-ref list-length) f69)))) ((vector-ref f59 0) f71 0 f69)))
# emit-tail-let
#  si   = -12
#  env  = ((f69 . -8) (f59 . 4) (f59 . 0))
#  bindings = ()
#  body = (let ((f71 (make-vector ((primitive-ref list-length) f69)))) ((vector-ref f59 0) f71 0 f69))
# emit-tail-expr
# si=-12
# env=((f69 . -8) (f59 . 4) (f59 . 0))
# expr=(let ((f71 (make-vector ((primitive-ref list-length) f69)))) ((vector-ref f59 0) f71 0 f69))
# emit-tail-let
#  si   = -12
#  env  = ((f69 . -8) (f59 . 4) (f59 . 0))
#  bindings = ((f71 (make-vector ((primitive-ref list-length) f69))))
#  body = ((vector-ref f59 0) f71 0 f69)
# emit-expr (make-vector ((primitive-ref list-length) f69))
# make-vector ((primitive-ref list-length) f69)
# emit-expr ((primitive-ref list-length) f69)
# funcall
#    si   =-12
#    env  = ((f69 . -8) (f59 . 4) (f59 . 0))
#    expr = (funcall (primitive-ref list-length) f69)
# emit-expr (primitive-ref list-length)
    .extern mrc_list$mlength
    movl mrc_list$mlength,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_202"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_202":
   movl %eax,  -20(%esp)  # stash funcall-oper in closure slot
# emit-expr f69
# emit-variable-ref
# env=((f69 . -8) (f59 . 4) (f59 . 0))
# var=f69
    movl -8(%esp), %eax  # stack load f69
# end emit-variable-ref
    mov %eax, -24(%esp)  # arg f69
    movl -20(%esp), %edi   # load new closure to %edi
    add $-12, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $12, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_203"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_203:
# check the argument is a fixnum >= 0
    cmp $0,%eax
    jge _L_204
# invoke error handler eh_length
    .extern mrc_eh$ulength
    movl mrc_eh$ulength, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_204:
    movl %eax, %esi
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    orl  $5, %eax
    addl $4, %esi
    addl $4, %esi
    andl $-8, %esi
    addl %esi, %ebp
    movl %eax, -12(%esp)  # stack save
# emit-tail-expr
# si=-16
# env=((f71 . -12) (f69 . -8) (f59 . 4) (f59 . 0))
# expr=((vector-ref f59 0) f71 0 f69)
# emit-tail-funcall
#    si   =-16
#    env  = ((f71 . -12) (f69 . -8) (f59 . 4) (f59 . 0))
#    expr = (funcall (vector-ref f59 0) f71 0 f69)
# emit-expr (vector-ref f59 0)
# emit-expr f59
# emit-variable-ref
# env=((f71 . -12) (f69 . -8) (f59 . 4) (f59 . 0))
# var=f59
    movl 2(%edi), %eax  # frame load f59
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_205
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_205:
    movl %eax, -16(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_206"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_206:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_208
    cmp  $0,%eax
    jge _L_207
_L_208:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_207:
    movl -16(%esp), %esi
    movl -1(%eax,%esi), %eax
   movl %eax,  -16(%esp)  # stash funcall-oper in next closure slot
# emit-expr f71
# emit-variable-ref
# env=((f71 . -12) (f69 . -8) (f59 . 4) (f59 . 0))
# var=f71
    movl -12(%esp), %eax  # stack load f71
# end emit-variable-ref
    mov %eax, -20(%esp)    # arg f71
# emit-expr 0
    movl $0, %eax     # immed 0
    mov %eax, -24(%esp)    # arg 0
# emit-expr f69
# emit-variable-ref
# env=((f71 . -12) (f69 . -8) (f59 . 4) (f59 . 0))
# var=f69
    movl -8(%esp), %eax  # stack load f69
# end emit-variable-ref
    mov %eax, -28(%esp)    # arg f69
    movl -16(%esp), %edi   # load new closure to %edi
# emit-shift-args:  size=4   si=-16  delta=12
    mov -16(%esp), %ebx  # shift frame cell
    mov %ebx, -4(%esp)  # down to base
# emit-shift-args:  size=3   si=-20  delta=12
    mov -20(%esp), %ebx  # shift frame cell
    mov %ebx, -8(%esp)  # down to base
# emit-shift-args:  size=2   si=-24  delta=12
    mov -24(%esp), %ebx  # shift frame cell
    mov %ebx, -12(%esp)  # down to base
# emit-shift-args:  size=1   si=-28  delta=12
    mov -28(%esp), %ebx  # shift frame cell
    mov %ebx, -16(%esp)  # down to base
# emit-shift-args:  size=0   si=-32  delta=12
    movl $12,%eax   # save arg count
    jmp *-2(%edi)  # tail-funcall
    .align 4,0x90
_L_198:
# emit-expr (begin)
# emit-begin
#   expr=(begin)
#   env=((f59 . 0))
     movl %eax, mrc_vector
# == explicit-begins  ==>
# (letrec ((fill-string (lambda (s k args) (if (null? args) s (begin (string-set! s k (car args)) (fill-string s (fxadd1 k) (cdr args))))))) (lambda args (let ((s (make-string (list-length args)))) (fill-string s 0 args))))
# == eliminate-let*  ==>
# (letrec ((fill-string (lambda (s k args) (if (null? args) s (begin (string-set! s k (car args)) (fill-string s (fxadd1 k) (cdr args))))))) (lambda args (let ((s (make-string (list-length args)))) (fill-string s 0 args))))
# == uniquify-variables  ==>
<<<<<<< HEAD
# (letrec ((f310859 (lambda (f310865 f310864 f310863) (if (null? f310863) f310865 (begin (string-set! f310865 f310864 (car f310863)) (f310859 f310865 (fxadd1 f310864) (cdr f310863))))))) (lambda f310869 (let ((f310871 (make-string (list-length f310869)))) (f310859 f310871 0 f310869))))
# == vectorize-letrec  ==>
# (let ((f310859 (make-vector 1))) (begin (begin (vector-set! f310859 0 (lambda (f310865 f310864 f310863) (if (null? f310863) f310865 (begin (string-set! f310865 f310864 (car f310863)) ((vector-ref f310859 0) f310865 (fxadd1 f310864) (cdr f310863))))))) (lambda f310869 (let ((f310871 (make-string (list-length f310869)))) ((vector-ref f310859 0) f310871 0 f310869)))))
# == eliminate-set!  ==>
# (let ((f310859 (make-vector 1))) (begin (begin (vector-set! f310859 0 (lambda (f310865 f310864 f310863) (let ((f310865 f310865) (f310864 f310864) (f310863 f310863)) (if (null? f310863) f310865 (begin (string-set! f310865 f310864 (car f310863)) ((vector-ref f310859 0) f310865 (fxadd1 f310864) (cdr f310863)))))))) (lambda f310869 (let () (let ((f310871 (make-string (list-length f310869)))) ((vector-ref f310859 0) f310871 0 f310869))))))
# == close-free-variables  ==>
# (let ((f310859 (make-vector 1))) (begin (begin (vector-set! f310859 0 (closure (f310865 f310864 f310863) (f310859) (let ((f310865 f310865) (f310864 f310864) (f310863 f310863)) (if (null? f310863) f310865 (begin (string-set! f310865 f310864 (car f310863)) ((vector-ref f310859 0) f310865 (fxadd1 f310864) (cdr f310863)))))))) (closure f310869 (f310859) (let () (let ((f310871 (make-string (list-length f310869)))) ((vector-ref f310859 0) f310871 0 f310869))))))
# == eliminate-quote  ==>
# (let ((f310859 (make-vector 1))) (begin (begin (vector-set! f310859 0 (closure (f310865 f310864 f310863) (f310859) (let ((f310865 f310865) (f310864 f310864) (f310863 f310863)) (if (null? f310863) f310865 (begin (string-set! f310865 f310864 (car f310863)) ((vector-ref f310859 0) f310865 (fxadd1 f310864) (cdr f310863)))))))) (closure f310869 (f310859) (let () (let ((f310871 (make-string (list-length f310869)))) ((vector-ref f310859 0) f310871 0 f310869))))))
# == eliminate-when/unless  ==>
# (let ((f310859 (make-vector 1))) (begin (begin (vector-set! f310859 0 (closure (f310865 f310864 f310863) (f310859) (let ((f310865 f310865) (f310864 f310864) (f310863 f310863)) (if (null? f310863) f310865 (begin (string-set! f310865 f310864 (car f310863)) ((vector-ref f310859 0) f310865 (fxadd1 f310864) (cdr f310863)))))))) (closure f310869 (f310859) (let () (let ((f310871 (make-string (list-length f310869)))) ((vector-ref f310859 0) f310871 0 f310869))))))
# == eliminate-cond  ==>
# (let ((f310859 (make-vector 1))) (begin (begin (vector-set! f310859 0 (closure (f310865 f310864 f310863) (f310859) (let ((f310865 f310865) (f310864 f310864) (f310863 f310863)) (if (null? f310863) f310865 (begin (string-set! f310865 f310864 (car f310863)) ((vector-ref f310859 0) f310865 (fxadd1 f310864) (cdr f310863)))))))) (closure f310869 (f310859) (let () (let ((f310871 (make-string (list-length f310869)))) ((vector-ref f310859 0) f310871 0 f310869))))))
# == external-symbols  ==>
# (let ((f310859 (make-vector 1))) (begin (begin (vector-set! f310859 0 (closure (f310865 f310864 f310863) (f310859) (let ((f310865 f310865) (f310864 f310864) (f310863 f310863)) (if (null? f310863) f310865 (begin (string-set! f310865 f310864 (car f310863)) ((vector-ref f310859 0) f310865 (fxadd1 f310864) (cdr f310863)))))))) (closure f310869 (f310859) (let () (let ((f310871 (make-string ((primitive-ref list-length) f310869)))) ((vector-ref f310859 0) f310871 0 f310869))))))
# emit-expr (let ((f310859 (make-vector 1))) (begin (begin (vector-set! f310859 0 (closure (f310865 f310864 f310863) (f310859) (let ((f310865 f310865) (f310864 f310864) (f310863 f310863)) (if (null? f310863) f310865 (begin (string-set! f310865 f310864 (car f310863)) ((vector-ref f310859 0) f310865 (fxadd1 f310864) (cdr f310863)))))))) (closure f310869 (f310859) (let () (let ((f310871 (make-string ((primitive-ref list-length) f310869)))) ((vector-ref f310859 0) f310871 0 f310869))))))
# emit-let
#  si   = 0
#  env  = ()
#  bindings = ((f310859 (make-vector 1)))
#  body = (begin (begin (vector-set! f310859 0 (closure (f310865 f310864 f310863) (f310859) (let ((f310865 f310865) (f310864 f310864) (f310863 f310863)) (if (null? f310863) f310865 (begin (string-set! f310865 f310864 (car f310863)) ((vector-ref f310859 0) f310865 (fxadd1 f310864) (cdr f310863)))))))) (closure f310869 (f310859) (let () (let ((f310871 (make-string ((primitive-ref list-length) f310869)))) ((vector-ref f310859 0) f310871 0 f310869)))))
=======
# (letrec ((f72 (lambda (f76 f77 f78) (if (null? f78) f76 (begin (string-set! f76 f77 (car f78)) (f72 f76 (fxadd1 f77) (cdr f78))))))) (lambda f82 (let ((f84 (make-string (list-length f82)))) (f72 f84 0 f82))))
# == vectorize-letrec  ==>
# (let ((f72 (make-vector 1))) (begin (begin (vector-set! f72 0 (lambda (f76 f77 f78) (if (null? f78) f76 (begin (string-set! f76 f77 (car f78)) ((vector-ref f72 0) f76 (fxadd1 f77) (cdr f78))))))) (lambda f82 (let ((f84 (make-string (list-length f82)))) ((vector-ref f72 0) f84 0 f82)))))
# == eliminate-set!  ==>
# (let ((f72 (make-vector 1))) (begin (begin (vector-set! f72 0 (lambda (f76 f77 f78) (let ((f76 f76) (f77 f77) (f78 f78)) (if (null? f78) f76 (begin (string-set! f76 f77 (car f78)) ((vector-ref f72 0) f76 (fxadd1 f77) (cdr f78)))))))) (lambda f82 (let () (let ((f84 (make-string (list-length f82)))) ((vector-ref f72 0) f84 0 f82))))))
# == close-free-variables  ==>
# (let ((f72 (make-vector 1))) (begin (begin (vector-set! f72 0 (closure (f76 f77 f78) (f72) (let ((f76 f76) (f77 f77) (f78 f78)) (if (null? f78) f76 (begin (string-set! f76 f77 (car f78)) ((vector-ref f72 0) f76 (fxadd1 f77) (cdr f78)))))))) (closure f82 (f72) (let () (let ((f84 (make-string (list-length f82)))) ((vector-ref f72 0) f84 0 f82))))))
# == eliminate-quote  ==>
# (let ((f72 (make-vector 1))) (begin (begin (vector-set! f72 0 (closure (f76 f77 f78) (f72) (let ((f76 f76) (f77 f77) (f78 f78)) (if (null? f78) f76 (begin (string-set! f76 f77 (car f78)) ((vector-ref f72 0) f76 (fxadd1 f77) (cdr f78)))))))) (closure f82 (f72) (let () (let ((f84 (make-string (list-length f82)))) ((vector-ref f72 0) f84 0 f82))))))
# == eliminate-when/unless  ==>
# (let ((f72 (make-vector 1))) (begin (begin (vector-set! f72 0 (closure (f76 f77 f78) (f72) (let ((f76 f76) (f77 f77) (f78 f78)) (if (null? f78) f76 (begin (string-set! f76 f77 (car f78)) ((vector-ref f72 0) f76 (fxadd1 f77) (cdr f78)))))))) (closure f82 (f72) (let () (let ((f84 (make-string (list-length f82)))) ((vector-ref f72 0) f84 0 f82))))))
# == eliminate-cond  ==>
# (let ((f72 (make-vector 1))) (begin (begin (vector-set! f72 0 (closure (f76 f77 f78) (f72) (let ((f76 f76) (f77 f77) (f78 f78)) (if (null? f78) f76 (begin (string-set! f76 f77 (car f78)) ((vector-ref f72 0) f76 (fxadd1 f77) (cdr f78)))))))) (closure f82 (f72) (let () (let ((f84 (make-string (list-length f82)))) ((vector-ref f72 0) f84 0 f82))))))
# == external-symbols  ==>
# (let ((f72 (make-vector 1))) (begin (begin (vector-set! f72 0 (closure (f76 f77 f78) (f72) (let ((f76 f76) (f77 f77) (f78 f78)) (if (null? f78) f76 (begin (string-set! f76 f77 (car f78)) ((vector-ref f72 0) f76 (fxadd1 f77) (cdr f78)))))))) (closure f82 (f72) (let () (let ((f84 (make-string ((primitive-ref list-length) f82)))) ((vector-ref f72 0) f84 0 f82))))))
# emit-expr (let ((f72 (make-vector 1))) (begin (begin (vector-set! f72 0 (closure (f76 f77 f78) (f72) (let ((f76 f76) (f77 f77) (f78 f78)) (if (null? f78) f76 (begin (string-set! f76 f77 (car f78)) ((vector-ref f72 0) f76 (fxadd1 f77) (cdr f78)))))))) (closure f82 (f72) (let () (let ((f84 (make-string ((primitive-ref list-length) f82)))) ((vector-ref f72 0) f84 0 f82))))))
# emit-let
#  si   = 0
#  env  = ()
#  bindings = ((f72 (make-vector 1)))
#  body = (begin (begin (vector-set! f72 0 (closure (f76 f77 f78) (f72) (let ((f76 f76) (f77 f77) (f78 f78)) (if (null? f78) f76 (begin (string-set! f76 f77 (car f78)) ((vector-ref f72 0) f76 (fxadd1 f77) (cdr f78)))))))) (closure f82 (f72) (let () (let ((f84 (make-string ((primitive-ref list-length) f82)))) ((vector-ref f72 0) f84 0 f82)))))
>>>>>>> fix-implicit-begins
# emit-expr (make-vector 1)
# make-vector 1
# emit-expr 1
    movl $4, %eax     # immed 1
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_209"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_209:
# check the argument is a fixnum >= 0
    cmp $0,%eax
    jge _L_210
# invoke error handler eh_length
    .extern mrc_eh$ulength
    movl mrc_eh$ulength, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_210:
    movl %eax, %esi
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    orl  $5, %eax
    addl $4, %esi
    addl $4, %esi
    andl $-8, %esi
    addl %esi, %ebp
    movl %eax, 0(%esp)  # stack save
<<<<<<< HEAD
# emit-expr (begin (begin (vector-set! f310859 0 (closure (f310865 f310864 f310863) (f310859) (let ((f310865 f310865) (f310864 f310864) (f310863 f310863)) (if (null? f310863) f310865 (begin (string-set! f310865 f310864 (car f310863)) ((vector-ref f310859 0) f310865 (fxadd1 f310864) (cdr f310863)))))))) (closure f310869 (f310859) (let () (let ((f310871 (make-string ((primitive-ref list-length) f310869)))) ((vector-ref f310859 0) f310871 0 f310869)))))
# emit-begin
#   expr=(begin (begin (vector-set! f310859 0 (closure (f310865 f310864 f310863) (f310859) (let ((f310865 f310865) (f310864 f310864) (f310863 f310863)) (if (null? f310863) f310865 (begin (string-set! f310865 f310864 (car f310863)) ((vector-ref f310859 0) f310865 (fxadd1 f310864) (cdr f310863)))))))) (closure f310869 (f310859) (let () (let ((f310871 (make-string ((primitive-ref list-length) f310869)))) ((vector-ref f310859 0) f310871 0 f310869)))))
#   env=((f310859 . 0))
# emit-expr (begin (vector-set! f310859 0 (closure (f310865 f310864 f310863) (f310859) (let ((f310865 f310865) (f310864 f310864) (f310863 f310863)) (if (null? f310863) f310865 (begin (string-set! f310865 f310864 (car f310863)) ((vector-ref f310859 0) f310865 (fxadd1 f310864) (cdr f310863))))))))
# emit-begin
#   expr=(begin (vector-set! f310859 0 (closure (f310865 f310864 f310863) (f310859) (let ((f310865 f310865) (f310864 f310864) (f310863 f310863)) (if (null? f310863) f310865 (begin (string-set! f310865 f310864 (car f310863)) ((vector-ref f310859 0) f310865 (fxadd1 f310864) (cdr f310863))))))))
#   env=((f310859 . 0))
# emit-expr (vector-set! f310859 0 (closure (f310865 f310864 f310863) (f310859) (let ((f310865 f310865) (f310864 f310864) (f310863 f310863)) (if (null? f310863) f310865 (begin (string-set! f310865 f310864 (car f310863)) ((vector-ref f310859 0) f310865 (fxadd1 f310864) (cdr f310863)))))))
# emit-expr f310859
=======
# emit-expr (begin (begin (vector-set! f72 0 (closure (f76 f77 f78) (f72) (let ((f76 f76) (f77 f77) (f78 f78)) (if (null? f78) f76 (begin (string-set! f76 f77 (car f78)) ((vector-ref f72 0) f76 (fxadd1 f77) (cdr f78)))))))) (closure f82 (f72) (let () (let ((f84 (make-string ((primitive-ref list-length) f82)))) ((vector-ref f72 0) f84 0 f82)))))
# emit-begin
#   expr=(begin (begin (vector-set! f72 0 (closure (f76 f77 f78) (f72) (let ((f76 f76) (f77 f77) (f78 f78)) (if (null? f78) f76 (begin (string-set! f76 f77 (car f78)) ((vector-ref f72 0) f76 (fxadd1 f77) (cdr f78)))))))) (closure f82 (f72) (let () (let ((f84 (make-string ((primitive-ref list-length) f82)))) ((vector-ref f72 0) f84 0 f82)))))
#   env=((f72 . 0))
# emit-expr (begin (vector-set! f72 0 (closure (f76 f77 f78) (f72) (let ((f76 f76) (f77 f77) (f78 f78)) (if (null? f78) f76 (begin (string-set! f76 f77 (car f78)) ((vector-ref f72 0) f76 (fxadd1 f77) (cdr f78))))))))
# emit-begin
#   expr=(begin (vector-set! f72 0 (closure (f76 f77 f78) (f72) (let ((f76 f76) (f77 f77) (f78 f78)) (if (null? f78) f76 (begin (string-set! f76 f77 (car f78)) ((vector-ref f72 0) f76 (fxadd1 f77) (cdr f78))))))))
#   env=((f72 . 0))
# emit-expr (vector-set! f72 0 (closure (f76 f77 f78) (f72) (let ((f76 f76) (f77 f77) (f78 f78)) (if (null? f78) f76 (begin (string-set! f76 f77 (car f78)) ((vector-ref f72 0) f76 (fxadd1 f77) (cdr f78)))))))
# emit-expr f72
>>>>>>> fix-implicit-begins
# emit-variable-ref
# env=((f72 . 0))
# var=f72
    movl 0(%esp), %eax  # stack load f72
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_211
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_211:
    movl %eax, -4(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_212"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_212:
# check bounds on vector index
    movl -4(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_214
    cmp  $0,%eax
    jge _L_213
_L_214:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_213:
    movl %eax, -8(%esp)
<<<<<<< HEAD
# emit-expr (closure (f310865 f310864 f310863) (f310859) (let ((f310865 f310865) (f310864 f310864) (f310863 f310863)) (if (null? f310863) f310865 (begin (string-set! f310865 f310864 (car f310863)) ((vector-ref f310859 0) f310865 (fxadd1 f310864) (cdr f310863))))))
# emit-closure
# si = -12
# env = ((f310859 . 0))
# expr = (closure (f310865 f310864 f310863) (f310859) (let ((f310865 f310865) (f310864 f310864) (f310863 f310863)) (if (null? f310863) f310865 (begin (string-set! f310865 f310864 (car f310863)) ((vector-ref f310859 0) f310865 (fxadd1 f310864) (cdr f310863))))))
    movl $_L_1883814, 0(%ebp)  # closure label
=======
# emit-expr (closure (f76 f77 f78) (f72) (let ((f76 f76) (f77 f77) (f78 f78)) (if (null? f78) f76 (begin (string-set! f76 f77 (car f78)) ((vector-ref f72 0) f76 (fxadd1 f77) (cdr f78))))))
# emit-closure
# si = -12
# env = ((f72 . 0))
# expr = (closure (f76 f77 f78) (f72) (let ((f76 f76) (f77 f77) (f78 f78)) (if (null? f78) f76 (begin (string-set! f76 f77 (car f78)) ((vector-ref f72 0) f76 (fxadd1 f77) (cdr f78))))))
    movl $_L_215, 0(%ebp)  # closure label
>>>>>>> fix-implicit-begins
# emit-variable-ref
# env=((f72 . 0))
# var=f72
    movl 0(%esp), %eax  # stack load f72
# end emit-variable-ref
   movl  %eax, 4(%ebp)  # f72
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $8, %ebp     # bump ebp
    jmp _L_216            # jump around closure body
_L_215:
# check argument count
    cmp $12,%eax
    je _L_217
# invoke error handler eh_argcount
    .extern mrc_eh$uargcount
    movl mrc_eh$uargcount, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_217:
# emit-tail-expr
# si=-20
<<<<<<< HEAD
# env=((f310863 . -16) (f310864 . -12) (f310865 . -8) (f310859 . 4) (f310859 . 0))
# expr=(let ((f310865 f310865) (f310864 f310864) (f310863 f310863)) (if (null? f310863) f310865 (begin (string-set! f310865 f310864 (car f310863)) ((vector-ref f310859 0) f310865 (fxadd1 f310864) (cdr f310863)))))
# emit-tail-let
#  si   = -20
#  env  = ((f310863 . -16) (f310864 . -12) (f310865 . -8) (f310859 . 4) (f310859 . 0))
#  bindings = ((f310865 f310865) (f310864 f310864) (f310863 f310863))
#  body = (if (null? f310863) f310865 (begin (string-set! f310865 f310864 (car f310863)) ((vector-ref f310859 0) f310865 (fxadd1 f310864) (cdr f310863))))
# emit-expr f310865
# emit-variable-ref
# env=((f310863 . -16) (f310864 . -12) (f310865 . -8) (f310859 . 4) (f310859 . 0))
# var=f310865
    movl -8(%esp), %eax  # stack load f310865
=======
# env=((f78 . -16) (f77 . -12) (f76 . -8) (f72 . 4) (f72 . 0))
# expr=(let ((f76 f76) (f77 f77) (f78 f78)) (if (null? f78) f76 (begin (string-set! f76 f77 (car f78)) ((vector-ref f72 0) f76 (fxadd1 f77) (cdr f78)))))
# emit-tail-let
#  si   = -20
#  env  = ((f78 . -16) (f77 . -12) (f76 . -8) (f72 . 4) (f72 . 0))
#  bindings = ((f76 f76) (f77 f77) (f78 f78))
#  body = (if (null? f78) f76 (begin (string-set! f76 f77 (car f78)) ((vector-ref f72 0) f76 (fxadd1 f77) (cdr f78))))
# emit-expr f76
# emit-variable-ref
# env=((f78 . -16) (f77 . -12) (f76 . -8) (f72 . 4) (f72 . 0))
# var=f76
    movl -8(%esp), %eax  # stack load f76
>>>>>>> fix-implicit-begins
# end emit-variable-ref
    movl %eax, -20(%esp)  # stack save
# emit-expr f77
# emit-variable-ref
<<<<<<< HEAD
# env=((f310863 . -16) (f310864 . -12) (f310865 . -8) (f310859 . 4) (f310859 . 0))
# var=f310864
    movl -12(%esp), %eax  # stack load f310864
# end emit-variable-ref
    movl %eax, -24(%esp)  # stack save
# emit-expr f310863
# emit-variable-ref
# env=((f310863 . -16) (f310864 . -12) (f310865 . -8) (f310859 . 4) (f310859 . 0))
# var=f310863
    movl -16(%esp), %eax  # stack load f310863
=======
# env=((f78 . -16) (f77 . -12) (f76 . -8) (f72 . 4) (f72 . 0))
# var=f77
    movl -12(%esp), %eax  # stack load f77
# end emit-variable-ref
    movl %eax, -24(%esp)  # stack save
# emit-expr f78
# emit-variable-ref
# env=((f78 . -16) (f77 . -12) (f76 . -8) (f72 . 4) (f72 . 0))
# var=f78
    movl -16(%esp), %eax  # stack load f78
>>>>>>> fix-implicit-begins
# end emit-variable-ref
    movl %eax, -28(%esp)  # stack save
# emit-tail-expr
# si=-32
<<<<<<< HEAD
# env=((f310863 . -28) (f310864 . -24) (f310865 . -20) (f310863 . -16) (f310864 . -12) (f310865 . -8) (f310859 . 4) (f310859 . 0))
# expr=(if (null? f310863) f310865 (begin (string-set! f310865 f310864 (car f310863)) ((vector-ref f310859 0) f310865 (fxadd1 f310864) (cdr f310863))))
# emit-expr (null? f310863)
# emit-expr f310863
# emit-variable-ref
# env=((f310863 . -28) (f310864 . -24) (f310865 . -20) (f310863 . -16) (f310864 . -12) (f310865 . -8) (f310859 . 4) (f310859 . 0))
# var=f310863
    movl -28(%esp), %eax  # stack load f310863
=======
# env=((f78 . -28) (f77 . -24) (f76 . -20) (f78 . -16) (f77 . -12) (f76 . -8) (f72 . 4) (f72 . 0))
# expr=(if (null? f78) f76 (begin (string-set! f76 f77 (car f78)) ((vector-ref f72 0) f76 (fxadd1 f77) (cdr f78))))
# emit-expr (null? f78)
# emit-expr f78
# emit-variable-ref
# env=((f78 . -28) (f77 . -24) (f76 . -20) (f78 . -16) (f77 . -12) (f76 . -8) (f72 . 4) (f72 . 0))
# var=f78
    movl -28(%esp), %eax  # stack load f78
>>>>>>> fix-implicit-begins
# end emit-variable-ref
    cmp $63, %eax
    mov $0, %eax
    sete %al
    movzbl %al, %eax
    sal $6, %al
    or $47, %al
    cmp $47, %al
    je _L_218
# emit-tail-expr
# si=-32
<<<<<<< HEAD
# env=((f310863 . -28) (f310864 . -24) (f310865 . -20) (f310863 . -16) (f310864 . -12) (f310865 . -8) (f310859 . 4) (f310859 . 0))
# expr=f310865
# emit-tail-variable-ref
# emit-variable-ref
# env=((f310863 . -28) (f310864 . -24) (f310865 . -20) (f310863 . -16) (f310864 . -12) (f310865 . -8) (f310859 . 4) (f310859 . 0))
# var=f310865
    movl -20(%esp), %eax  # stack load f310865
=======
# env=((f78 . -28) (f77 . -24) (f76 . -20) (f78 . -16) (f77 . -12) (f76 . -8) (f72 . 4) (f72 . 0))
# expr=f76
# emit-tail-variable-ref
# emit-variable-ref
# env=((f78 . -28) (f77 . -24) (f76 . -20) (f78 . -16) (f77 . -12) (f76 . -8) (f72 . 4) (f72 . 0))
# var=f76
    movl -20(%esp), %eax  # stack load f76
>>>>>>> fix-implicit-begins
# end emit-variable-ref
    ret
# end emit-tail-variable ref
    jmp _L_219
_L_218:
# emit-tail-expr
# si=-32
<<<<<<< HEAD
# env=((f310863 . -28) (f310864 . -24) (f310865 . -20) (f310863 . -16) (f310864 . -12) (f310865 . -8) (f310859 . 4) (f310859 . 0))
# expr=(begin (string-set! f310865 f310864 (car f310863)) ((vector-ref f310859 0) f310865 (fxadd1 f310864) (cdr f310863)))
# tail-begin (begin (string-set! f310865 f310864 (car f310863)) ((vector-ref f310859 0) f310865 (fxadd1 f310864) (cdr f310863)))
#   env=((f310863 . -28) (f310864 . -24) (f310865 . -20) (f310863 . -16) (f310864 . -12) (f310865 . -8) (f310859 . 4) (f310859 . 0))
# emit-expr (string-set! f310865 f310864 (car f310863))
# emit-expr f310865
# emit-variable-ref
# env=((f310863 . -28) (f310864 . -24) (f310865 . -20) (f310863 . -16) (f310864 . -12) (f310865 . -8) (f310859 . 4) (f310859 . 0))
# var=f310865
    movl -20(%esp), %eax  # stack load f310865
=======
# env=((f78 . -28) (f77 . -24) (f76 . -20) (f78 . -16) (f77 . -12) (f76 . -8) (f72 . 4) (f72 . 0))
# expr=(begin (string-set! f76 f77 (car f78)) ((vector-ref f72 0) f76 (fxadd1 f77) (cdr f78)))
# tail-begin (begin (string-set! f76 f77 (car f78)) ((vector-ref f72 0) f76 (fxadd1 f77) (cdr f78)))
#   env=((f78 . -28) (f77 . -24) (f76 . -20) (f78 . -16) (f77 . -12) (f76 . -8) (f72 . 4) (f72 . 0))
# emit-expr (string-set! f76 f77 (car f78))
# emit-expr f76
# emit-variable-ref
# env=((f78 . -28) (f77 . -24) (f76 . -20) (f78 . -16) (f77 . -12) (f76 . -8) (f72 . 4) (f72 . 0))
# var=f76
    movl -20(%esp), %eax  # stack load f76
>>>>>>> fix-implicit-begins
# end emit-variable-ref
# check the argument is a string
    movl %eax,%ebx
    and $7, %bl
    cmp $6, %bl
    je _L_220
# invoke error handler eh_string
    .extern mrc_eh$ustring
    movl mrc_eh$ustring, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $168,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_220:
    movl %eax, -32(%esp)
# emit-expr f77
# emit-variable-ref
<<<<<<< HEAD
# env=((f310863 . -28) (f310864 . -24) (f310865 . -20) (f310863 . -16) (f310864 . -12) (f310865 . -8) (f310859 . 4) (f310859 . 0))
# var=f310864
    movl -24(%esp), %eax  # stack load f310864
=======
# env=((f78 . -28) (f77 . -24) (f76 . -20) (f78 . -16) (f77 . -12) (f76 . -8) (f72 . 4) (f72 . 0))
# var=f77
    movl -24(%esp), %eax  # stack load f77
>>>>>>> fix-implicit-begins
# end emit-variable-ref
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_221"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $168,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_221:
# check bounds on string index
    movl -32(%esp), %ebx
    cmp  %eax,-6(%ebx) 
    jle _L_223
    cmp  $0,%eax
    jge _L_222
_L_223:
# invoke error handler eh_string_index
    .extern mrc_eh$ustring$uindex
    movl mrc_eh$ustring$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $168,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_222:
    movl %eax, -36(%esp)
<<<<<<< HEAD
# emit-expr (car f310863)
# emit-expr f310863
# emit-variable-ref
# env=((f310863 . -28) (f310864 . -24) (f310865 . -20) (f310863 . -16) (f310864 . -12) (f310865 . -8) (f310859 . 4) (f310859 . 0))
# var=f310863
    movl -28(%esp), %eax  # stack load f310863
=======
# emit-expr (car f78)
# emit-expr f78
# emit-variable-ref
# env=((f78 . -28) (f77 . -24) (f76 . -20) (f78 . -16) (f77 . -12) (f76 . -8) (f72 . 4) (f72 . 0))
# var=f78
    movl -28(%esp), %eax  # stack load f78
>>>>>>> fix-implicit-begins
# end emit-variable-ref
# check the argument is a pair
    movl %eax,%ebx
    and $7, %bl
    cmp $1, %bl
    je _L_224
# invoke error handler eh_pair
    .extern mrc_eh$upair
    movl mrc_eh$upair, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $116,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_224:
    movl -1(%eax), %eax
# check the argument is a char
    movl %eax,%ebx
    and $255, %bl
    cmp $15, %bl
    je "_L_225"
# invoke error handler eh_character
    .extern mrc_eh$ucharacter
    movl mrc_eh$ucharacter, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $168,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_225:
    movl -32(%esp), %ebx
    movl -36(%esp), %esi
    sar $2, %esi
    movb  %ah, -2(%ebx,%esi)
# emit-tail-expr
# si=-32
<<<<<<< HEAD
# env=((f310863 . -28) (f310864 . -24) (f310865 . -20) (f310863 . -16) (f310864 . -12) (f310865 . -8) (f310859 . 4) (f310859 . 0))
# expr=(begin ((vector-ref f310859 0) f310865 (fxadd1 f310864) (cdr f310863)))
# tail-begin (begin ((vector-ref f310859 0) f310865 (fxadd1 f310864) (cdr f310863)))
#   env=((f310863 . -28) (f310864 . -24) (f310865 . -20) (f310863 . -16) (f310864 . -12) (f310865 . -8) (f310859 . 4) (f310859 . 0))
# emit-tail-expr
# si=-32
# env=((f310863 . -28) (f310864 . -24) (f310865 . -20) (f310863 . -16) (f310864 . -12) (f310865 . -8) (f310859 . 4) (f310859 . 0))
# expr=((vector-ref f310859 0) f310865 (fxadd1 f310864) (cdr f310863))
# emit-tail-funcall
#    si   =-32
#    env  = ((f310863 . -28) (f310864 . -24) (f310865 . -20) (f310863 . -16) (f310864 . -12) (f310865 . -8) (f310859 . 4) (f310859 . 0))
#    expr = (funcall (vector-ref f310859 0) f310865 (fxadd1 f310864) (cdr f310863))
# emit-expr (vector-ref f310859 0)
# emit-expr f310859
# emit-variable-ref
# env=((f310863 . -28) (f310864 . -24) (f310865 . -20) (f310863 . -16) (f310864 . -12) (f310865 . -8) (f310859 . 4) (f310859 . 0))
# var=f310859
    movl 2(%edi), %eax  # frame load f310859
=======
# env=((f78 . -28) (f77 . -24) (f76 . -20) (f78 . -16) (f77 . -12) (f76 . -8) (f72 . 4) (f72 . 0))
# expr=(begin ((vector-ref f72 0) f76 (fxadd1 f77) (cdr f78)))
# tail-begin (begin ((vector-ref f72 0) f76 (fxadd1 f77) (cdr f78)))
#   env=((f78 . -28) (f77 . -24) (f76 . -20) (f78 . -16) (f77 . -12) (f76 . -8) (f72 . 4) (f72 . 0))
# emit-tail-expr
# si=-32
# env=((f78 . -28) (f77 . -24) (f76 . -20) (f78 . -16) (f77 . -12) (f76 . -8) (f72 . 4) (f72 . 0))
# expr=((vector-ref f72 0) f76 (fxadd1 f77) (cdr f78))
# emit-tail-funcall
#    si   =-32
#    env  = ((f78 . -28) (f77 . -24) (f76 . -20) (f78 . -16) (f77 . -12) (f76 . -8) (f72 . 4) (f72 . 0))
#    expr = (funcall (vector-ref f72 0) f76 (fxadd1 f77) (cdr f78))
# emit-expr (vector-ref f72 0)
# emit-expr f72
# emit-variable-ref
# env=((f78 . -28) (f77 . -24) (f76 . -20) (f78 . -16) (f77 . -12) (f76 . -8) (f72 . 4) (f72 . 0))
# var=f72
    movl 2(%edi), %eax  # frame load f72
>>>>>>> fix-implicit-begins
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_226
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_226:
    movl %eax, -32(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_227"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_227:
# check bounds on vector index
    movl -32(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_229
    cmp  $0,%eax
    jge _L_228
_L_229:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_228:
    movl -32(%esp), %esi
    movl -1(%eax,%esi), %eax
   movl %eax,  -32(%esp)  # stash funcall-oper in next closure slot
<<<<<<< HEAD
# emit-expr f310865
# emit-variable-ref
# env=((f310863 . -28) (f310864 . -24) (f310865 . -20) (f310863 . -16) (f310864 . -12) (f310865 . -8) (f310859 . 4) (f310859 . 0))
# var=f310865
    movl -20(%esp), %eax  # stack load f310865
# end emit-variable-ref
    mov %eax, -36(%esp)    # arg f310865
# emit-expr (fxadd1 f310864)
# emit-expr f310864
# emit-variable-ref
# env=((f310863 . -28) (f310864 . -24) (f310865 . -20) (f310863 . -16) (f310864 . -12) (f310865 . -8) (f310859 . 4) (f310859 . 0))
# var=f310864
    movl -24(%esp), %eax  # stack load f310864
=======
# emit-expr f76
# emit-variable-ref
# env=((f78 . -28) (f77 . -24) (f76 . -20) (f78 . -16) (f77 . -12) (f76 . -8) (f72 . 4) (f72 . 0))
# var=f76
    movl -20(%esp), %eax  # stack load f76
# end emit-variable-ref
    mov %eax, -36(%esp)    # arg f76
# emit-expr (fxadd1 f77)
# emit-expr f77
# emit-variable-ref
# env=((f78 . -28) (f77 . -24) (f76 . -20) (f78 . -16) (f77 . -12) (f76 . -8) (f72 . 4) (f72 . 0))
# var=f77
    movl -24(%esp), %eax  # stack load f77
>>>>>>> fix-implicit-begins
# end emit-variable-ref
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_230"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $56,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_230:
     addl $4, %eax
<<<<<<< HEAD
    mov %eax, -40(%esp)    # arg (fxadd1 f310864)
# emit-expr (cdr f310863)
# emit-expr f310863
# emit-variable-ref
# env=((f310863 . -28) (f310864 . -24) (f310865 . -20) (f310863 . -16) (f310864 . -12) (f310865 . -8) (f310859 . 4) (f310859 . 0))
# var=f310863
    movl -28(%esp), %eax  # stack load f310863
=======
    mov %eax, -40(%esp)    # arg (fxadd1 f77)
# emit-expr (cdr f78)
# emit-expr f78
# emit-variable-ref
# env=((f78 . -28) (f77 . -24) (f76 . -20) (f78 . -16) (f77 . -12) (f76 . -8) (f72 . 4) (f72 . 0))
# var=f78
    movl -28(%esp), %eax  # stack load f78
>>>>>>> fix-implicit-begins
# end emit-variable-ref
# check the argument is a pair
    movl %eax,%ebx
    and $7, %bl
    cmp $1, %bl
    je _L_231
# invoke error handler eh_pair
    .extern mrc_eh$upair
    movl mrc_eh$upair, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $120,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_231:
    movl 3(%eax), %eax
<<<<<<< HEAD
    mov %eax, -44(%esp)    # arg (cdr f310863)
=======
    mov %eax, -44(%esp)    # arg (cdr f78)
>>>>>>> fix-implicit-begins
    movl -32(%esp), %edi   # load new closure to %edi
# emit-shift-args:  size=4   si=-32  delta=28
    mov -32(%esp), %ebx  # shift frame cell
    mov %ebx, -4(%esp)  # down to base
# emit-shift-args:  size=3   si=-36  delta=28
    mov -36(%esp), %ebx  # shift frame cell
    mov %ebx, -8(%esp)  # down to base
# emit-shift-args:  size=2   si=-40  delta=28
    mov -40(%esp), %ebx  # shift frame cell
    mov %ebx, -12(%esp)  # down to base
# emit-shift-args:  size=1   si=-44  delta=28
    mov -44(%esp), %ebx  # shift frame cell
    mov %ebx, -16(%esp)  # down to base
# emit-shift-args:  size=0   si=-48  delta=28
    movl $12,%eax   # save arg count
    jmp *-2(%edi)  # tail-funcall
     ret   # return thru stack
_L_219:
    .align 4,0x90
_L_216:
    movl -4(%esp), %ebx
    movl -8(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin)
# emit-begin
#   expr=(begin)
#   env=((f72 . 0))
# emit-expr (begin (closure f82 (f72) (let () (let ((f84 (make-string ((primitive-ref list-length) f82)))) ((vector-ref f72 0) f84 0 f82)))))
# emit-begin
#   expr=(begin (closure f82 (f72) (let () (let ((f84 (make-string ((primitive-ref list-length) f82)))) ((vector-ref f72 0) f84 0 f82)))))
#   env=((f72 . 0))
# emit-expr (closure f82 (f72) (let () (let ((f84 (make-string ((primitive-ref list-length) f82)))) ((vector-ref f72 0) f84 0 f82))))
# emit-closure
# si = -4
# env = ((f72 . 0))
# expr = (closure f82 (f72) (let () (let ((f84 (make-string ((primitive-ref list-length) f82)))) ((vector-ref f72 0) f84 0 f82))))
    movl $_L_232, 0(%ebp)  # closure label
# emit-variable-ref
# env=((f72 . 0))
# var=f72
    movl 0(%esp), %eax  # stack load f72
# end emit-variable-ref
   movl  %eax, 4(%ebp)  # f72
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $8, %ebp     # bump ebp
    jmp _L_233            # jump around closure body
_L_232:
# check argument count
    cmp $0,%eax
    jge _L_234
# invoke error handler eh_argcount_min
    .extern mrc_eh$uargcount$umin
    movl mrc_eh$uargcount$umin, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_234:
# emit-build-varargs-list
    movl $63, %esi       # args <- () 
    lea -4(%esp),%edi    # edi <- esp-4
    subl %eax, %edi      # edi <- esp-4-eax    addr of arg[K+N] on stack
_L_236:
    lea -4(%esp),%ebx    # addr of arg[K] on stack
    cmp %edi, %ebx       # while edi <> esp+(si+4)
    je _L_235
    movl (%edi),%ebx     # arg i -> car
    movl %ebx, 0(%ebp)
    movl %esi, 4(%ebp)  # esi -> cdr
    movl %ebp, %esi
    addl $1, %esi       # tag as pair
    addl $8,%ebp         # bump heap ptr
    addl $4,%edi         # move to next previous arg from the end
    jmp _L_236
_L_235:
    movl %esi, -8(%esp)  # set args
# emit-tail-expr
# si=-12
# env=((f82 . -8) (f72 . 4) (f72 . 0))
# expr=(let () (let ((f84 (make-string ((primitive-ref list-length) f82)))) ((vector-ref f72 0) f84 0 f82)))
# emit-tail-let
#  si   = -12
#  env  = ((f82 . -8) (f72 . 4) (f72 . 0))
#  bindings = ()
#  body = (let ((f84 (make-string ((primitive-ref list-length) f82)))) ((vector-ref f72 0) f84 0 f82))
# emit-tail-expr
# si=-12
# env=((f82 . -8) (f72 . 4) (f72 . 0))
# expr=(let ((f84 (make-string ((primitive-ref list-length) f82)))) ((vector-ref f72 0) f84 0 f82))
# emit-tail-let
#  si   = -12
#  env  = ((f82 . -8) (f72 . 4) (f72 . 0))
#  bindings = ((f84 (make-string ((primitive-ref list-length) f82))))
#  body = ((vector-ref f72 0) f84 0 f82)
# emit-expr (make-string ((primitive-ref list-length) f82))
# make-string len=((primitive-ref list-length) f82)
# emit-expr ((primitive-ref list-length) f82)
# funcall
#    si   =-12
#    env  = ((f82 . -8) (f72 . 4) (f72 . 0))
#    expr = (funcall (primitive-ref list-length) f82)
# emit-expr (primitive-ref list-length)
    .extern mrc_list$mlength
    movl mrc_list$mlength,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_237"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_237":
   movl %eax,  -20(%esp)  # stash funcall-oper in closure slot
# emit-expr f82
# emit-variable-ref
# env=((f82 . -8) (f72 . 4) (f72 . 0))
# var=f82
    movl -8(%esp), %eax  # stack load f82
# end emit-variable-ref
    mov %eax, -24(%esp)  # arg f82
    movl -20(%esp), %edi   # load new closure to %edi
    add $-12, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $12, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_238"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $152,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_238:
# check the argument is a fixnum >= 0
    cmp $0,%eax
    jge _L_239
# invoke error handler eh_length
    .extern mrc_eh$ulength
    movl mrc_eh$ulength, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $152,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_239:
    movl %eax, %esi
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    orl $6, %eax
    sar $2, %esi
    add $4, %esi
    add $7, %esi
    andl $-8, %esi
    add  %esi, %ebp
# make-string end
    movl %eax, -12(%esp)  # stack save
# emit-tail-expr
# si=-16
# env=((f84 . -12) (f82 . -8) (f72 . 4) (f72 . 0))
# expr=((vector-ref f72 0) f84 0 f82)
# emit-tail-funcall
#    si   =-16
#    env  = ((f84 . -12) (f82 . -8) (f72 . 4) (f72 . 0))
#    expr = (funcall (vector-ref f72 0) f84 0 f82)
# emit-expr (vector-ref f72 0)
# emit-expr f72
# emit-variable-ref
# env=((f84 . -12) (f82 . -8) (f72 . 4) (f72 . 0))
# var=f72
    movl 2(%edi), %eax  # frame load f72
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_240
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_240:
    movl %eax, -16(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_241"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_241:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_243
    cmp  $0,%eax
    jge _L_242
_L_243:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_242:
    movl -16(%esp), %esi
    movl -1(%eax,%esi), %eax
   movl %eax,  -16(%esp)  # stash funcall-oper in next closure slot
# emit-expr f84
# emit-variable-ref
# env=((f84 . -12) (f82 . -8) (f72 . 4) (f72 . 0))
# var=f84
    movl -12(%esp), %eax  # stack load f84
# end emit-variable-ref
    mov %eax, -20(%esp)    # arg f84
# emit-expr 0
    movl $0, %eax     # immed 0
    mov %eax, -24(%esp)    # arg 0
# emit-expr f82
# emit-variable-ref
# env=((f84 . -12) (f82 . -8) (f72 . 4) (f72 . 0))
# var=f82
    movl -8(%esp), %eax  # stack load f82
# end emit-variable-ref
    mov %eax, -28(%esp)    # arg f82
    movl -16(%esp), %edi   # load new closure to %edi
# emit-shift-args:  size=4   si=-16  delta=12
    mov -16(%esp), %ebx  # shift frame cell
    mov %ebx, -4(%esp)  # down to base
# emit-shift-args:  size=3   si=-20  delta=12
    mov -20(%esp), %ebx  # shift frame cell
    mov %ebx, -8(%esp)  # down to base
# emit-shift-args:  size=2   si=-24  delta=12
    mov -24(%esp), %ebx  # shift frame cell
    mov %ebx, -12(%esp)  # down to base
# emit-shift-args:  size=1   si=-28  delta=12
    mov -28(%esp), %ebx  # shift frame cell
    mov %ebx, -16(%esp)  # down to base
# emit-shift-args:  size=0   si=-32  delta=12
    movl $12,%eax   # save arg count
    jmp *-2(%edi)  # tail-funcall
    .align 4,0x90
_L_233:
# emit-expr (begin)
# emit-begin
#   expr=(begin)
#   env=((f72 . 0))
     movl %eax, mrc_string
# == explicit-begins  ==>
# (letrec ((f (lambda (s i) (if (fx= i (string-length s)) (quote ()) (cons (string-ref s i) (f s (fxadd1 i))))))) (lambda (s) (f s 0)))
# == eliminate-let*  ==>
# (letrec ((f (lambda (s i) (if (fx= i (string-length s)) (quote ()) (cons (string-ref s i) (f s (fxadd1 i))))))) (lambda (s) (f s 0)))
# == uniquify-variables  ==>
<<<<<<< HEAD
# (letrec ((f310872 (lambda (f310876 f310875) (if (fx= f310875 (string-length f310876)) (quote ()) (cons (string-ref f310876 f310875) (f310872 f310876 (fxadd1 f310875))))))) (lambda (f310878) (f310872 f310878 0)))
# == vectorize-letrec  ==>
# (let ((f310872 (make-vector 1))) (begin (begin (vector-set! f310872 0 (lambda (f310876 f310875) (if (fx= f310875 (string-length f310876)) (quote ()) (cons (string-ref f310876 f310875) ((vector-ref f310872 0) f310876 (fxadd1 f310875))))))) (lambda (f310878) ((vector-ref f310872 0) f310878 0))))
# == eliminate-set!  ==>
# (let ((f310872 (make-vector 1))) (begin (begin (vector-set! f310872 0 (lambda (f310876 f310875) (let ((f310876 f310876) (f310875 f310875)) (if (fx= f310875 (string-length f310876)) (quote ()) (cons (string-ref f310876 f310875) ((vector-ref f310872 0) f310876 (fxadd1 f310875)))))))) (lambda (f310878) (let ((f310878 f310878)) ((vector-ref f310872 0) f310878 0)))))
# == close-free-variables  ==>
# (let ((f310872 (make-vector 1))) (begin (begin (vector-set! f310872 0 (closure (f310876 f310875) (f310872) (let ((f310876 f310876) (f310875 f310875)) (if (fx= f310875 (string-length f310876)) (quote ()) (cons (string-ref f310876 f310875) ((vector-ref f310872 0) f310876 (fxadd1 f310875)))))))) (closure (f310878) (f310872) (let ((f310878 f310878)) ((vector-ref f310872 0) f310878 0)))))
# == eliminate-quote  ==>
# (let ((f310872 (make-vector 1))) (begin (begin (vector-set! f310872 0 (closure (f310876 f310875) (f310872) (let ((f310876 f310876) (f310875 f310875)) (if (fx= f310875 (string-length f310876)) () (cons (string-ref f310876 f310875) ((vector-ref f310872 0) f310876 (fxadd1 f310875)))))))) (closure (f310878) (f310872) (let ((f310878 f310878)) ((vector-ref f310872 0) f310878 0)))))
# == eliminate-when/unless  ==>
# (let ((f310872 (make-vector 1))) (begin (begin (vector-set! f310872 0 (closure (f310876 f310875) (f310872) (let ((f310876 f310876) (f310875 f310875)) (if (fx= f310875 (string-length f310876)) () (cons (string-ref f310876 f310875) ((vector-ref f310872 0) f310876 (fxadd1 f310875)))))))) (closure (f310878) (f310872) (let ((f310878 f310878)) ((vector-ref f310872 0) f310878 0)))))
# == eliminate-cond  ==>
# (let ((f310872 (make-vector 1))) (begin (begin (vector-set! f310872 0 (closure (f310876 f310875) (f310872) (let ((f310876 f310876) (f310875 f310875)) (if (fx= f310875 (string-length f310876)) () (cons (string-ref f310876 f310875) ((vector-ref f310872 0) f310876 (fxadd1 f310875)))))))) (closure (f310878) (f310872) (let ((f310878 f310878)) ((vector-ref f310872 0) f310878 0)))))
# == external-symbols  ==>
# (let ((f310872 (make-vector 1))) (begin (begin (vector-set! f310872 0 (closure (f310876 f310875) (f310872) (let ((f310876 f310876) (f310875 f310875)) (if (fx= f310875 (string-length f310876)) () (cons (string-ref f310876 f310875) ((vector-ref f310872 0) f310876 (fxadd1 f310875)))))))) (closure (f310878) (f310872) (let ((f310878 f310878)) ((vector-ref f310872 0) f310878 0)))))
# emit-expr (let ((f310872 (make-vector 1))) (begin (begin (vector-set! f310872 0 (closure (f310876 f310875) (f310872) (let ((f310876 f310876) (f310875 f310875)) (if (fx= f310875 (string-length f310876)) () (cons (string-ref f310876 f310875) ((vector-ref f310872 0) f310876 (fxadd1 f310875)))))))) (closure (f310878) (f310872) (let ((f310878 f310878)) ((vector-ref f310872 0) f310878 0)))))
# emit-let
#  si   = 0
#  env  = ()
#  bindings = ((f310872 (make-vector 1)))
#  body = (begin (begin (vector-set! f310872 0 (closure (f310876 f310875) (f310872) (let ((f310876 f310876) (f310875 f310875)) (if (fx= f310875 (string-length f310876)) () (cons (string-ref f310876 f310875) ((vector-ref f310872 0) f310876 (fxadd1 f310875)))))))) (closure (f310878) (f310872) (let ((f310878 f310878)) ((vector-ref f310872 0) f310878 0))))
=======
# (letrec ((f85 (lambda (f88 f89) (if (fx= f89 (string-length f88)) (quote ()) (cons (string-ref f88 f89) (f85 f88 (fxadd1 f89))))))) (lambda (f91) (f85 f91 0)))
# == vectorize-letrec  ==>
# (let ((f85 (make-vector 1))) (begin (begin (vector-set! f85 0 (lambda (f88 f89) (if (fx= f89 (string-length f88)) (quote ()) (cons (string-ref f88 f89) ((vector-ref f85 0) f88 (fxadd1 f89))))))) (lambda (f91) ((vector-ref f85 0) f91 0))))
# == eliminate-set!  ==>
# (let ((f85 (make-vector 1))) (begin (begin (vector-set! f85 0 (lambda (f88 f89) (let ((f88 f88) (f89 f89)) (if (fx= f89 (string-length f88)) (quote ()) (cons (string-ref f88 f89) ((vector-ref f85 0) f88 (fxadd1 f89)))))))) (lambda (f91) (let ((f91 f91)) ((vector-ref f85 0) f91 0)))))
# == close-free-variables  ==>
# (let ((f85 (make-vector 1))) (begin (begin (vector-set! f85 0 (closure (f88 f89) (f85) (let ((f88 f88) (f89 f89)) (if (fx= f89 (string-length f88)) (quote ()) (cons (string-ref f88 f89) ((vector-ref f85 0) f88 (fxadd1 f89)))))))) (closure (f91) (f85) (let ((f91 f91)) ((vector-ref f85 0) f91 0)))))
# == eliminate-quote  ==>
# (let ((f85 (make-vector 1))) (begin (begin (vector-set! f85 0 (closure (f88 f89) (f85) (let ((f88 f88) (f89 f89)) (if (fx= f89 (string-length f88)) () (cons (string-ref f88 f89) ((vector-ref f85 0) f88 (fxadd1 f89)))))))) (closure (f91) (f85) (let ((f91 f91)) ((vector-ref f85 0) f91 0)))))
# == eliminate-when/unless  ==>
# (let ((f85 (make-vector 1))) (begin (begin (vector-set! f85 0 (closure (f88 f89) (f85) (let ((f88 f88) (f89 f89)) (if (fx= f89 (string-length f88)) () (cons (string-ref f88 f89) ((vector-ref f85 0) f88 (fxadd1 f89)))))))) (closure (f91) (f85) (let ((f91 f91)) ((vector-ref f85 0) f91 0)))))
# == eliminate-cond  ==>
# (let ((f85 (make-vector 1))) (begin (begin (vector-set! f85 0 (closure (f88 f89) (f85) (let ((f88 f88) (f89 f89)) (if (fx= f89 (string-length f88)) () (cons (string-ref f88 f89) ((vector-ref f85 0) f88 (fxadd1 f89)))))))) (closure (f91) (f85) (let ((f91 f91)) ((vector-ref f85 0) f91 0)))))
# == external-symbols  ==>
# (let ((f85 (make-vector 1))) (begin (begin (vector-set! f85 0 (closure (f88 f89) (f85) (let ((f88 f88) (f89 f89)) (if (fx= f89 (string-length f88)) () (cons (string-ref f88 f89) ((vector-ref f85 0) f88 (fxadd1 f89)))))))) (closure (f91) (f85) (let ((f91 f91)) ((vector-ref f85 0) f91 0)))))
# emit-expr (let ((f85 (make-vector 1))) (begin (begin (vector-set! f85 0 (closure (f88 f89) (f85) (let ((f88 f88) (f89 f89)) (if (fx= f89 (string-length f88)) () (cons (string-ref f88 f89) ((vector-ref f85 0) f88 (fxadd1 f89)))))))) (closure (f91) (f85) (let ((f91 f91)) ((vector-ref f85 0) f91 0)))))
# emit-let
#  si   = 0
#  env  = ()
#  bindings = ((f85 (make-vector 1)))
#  body = (begin (begin (vector-set! f85 0 (closure (f88 f89) (f85) (let ((f88 f88) (f89 f89)) (if (fx= f89 (string-length f88)) () (cons (string-ref f88 f89) ((vector-ref f85 0) f88 (fxadd1 f89)))))))) (closure (f91) (f85) (let ((f91 f91)) ((vector-ref f85 0) f91 0))))
>>>>>>> fix-implicit-begins
# emit-expr (make-vector 1)
# make-vector 1
# emit-expr 1
    movl $4, %eax     # immed 1
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_244"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_244:
# check the argument is a fixnum >= 0
    cmp $0,%eax
    jge _L_245
# invoke error handler eh_length
    .extern mrc_eh$ulength
    movl mrc_eh$ulength, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_245:
    movl %eax, %esi
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    orl  $5, %eax
    addl $4, %esi
    addl $4, %esi
    andl $-8, %esi
    addl %esi, %ebp
    movl %eax, 0(%esp)  # stack save
<<<<<<< HEAD
# emit-expr (begin (begin (vector-set! f310872 0 (closure (f310876 f310875) (f310872) (let ((f310876 f310876) (f310875 f310875)) (if (fx= f310875 (string-length f310876)) () (cons (string-ref f310876 f310875) ((vector-ref f310872 0) f310876 (fxadd1 f310875)))))))) (closure (f310878) (f310872) (let ((f310878 f310878)) ((vector-ref f310872 0) f310878 0))))
# emit-begin
#   expr=(begin (begin (vector-set! f310872 0 (closure (f310876 f310875) (f310872) (let ((f310876 f310876) (f310875 f310875)) (if (fx= f310875 (string-length f310876)) () (cons (string-ref f310876 f310875) ((vector-ref f310872 0) f310876 (fxadd1 f310875)))))))) (closure (f310878) (f310872) (let ((f310878 f310878)) ((vector-ref f310872 0) f310878 0))))
#   env=((f310872 . 0))
# emit-expr (begin (vector-set! f310872 0 (closure (f310876 f310875) (f310872) (let ((f310876 f310876) (f310875 f310875)) (if (fx= f310875 (string-length f310876)) () (cons (string-ref f310876 f310875) ((vector-ref f310872 0) f310876 (fxadd1 f310875))))))))
# emit-begin
#   expr=(begin (vector-set! f310872 0 (closure (f310876 f310875) (f310872) (let ((f310876 f310876) (f310875 f310875)) (if (fx= f310875 (string-length f310876)) () (cons (string-ref f310876 f310875) ((vector-ref f310872 0) f310876 (fxadd1 f310875))))))))
#   env=((f310872 . 0))
# emit-expr (vector-set! f310872 0 (closure (f310876 f310875) (f310872) (let ((f310876 f310876) (f310875 f310875)) (if (fx= f310875 (string-length f310876)) () (cons (string-ref f310876 f310875) ((vector-ref f310872 0) f310876 (fxadd1 f310875)))))))
# emit-expr f310872
=======
# emit-expr (begin (begin (vector-set! f85 0 (closure (f88 f89) (f85) (let ((f88 f88) (f89 f89)) (if (fx= f89 (string-length f88)) () (cons (string-ref f88 f89) ((vector-ref f85 0) f88 (fxadd1 f89)))))))) (closure (f91) (f85) (let ((f91 f91)) ((vector-ref f85 0) f91 0))))
# emit-begin
#   expr=(begin (begin (vector-set! f85 0 (closure (f88 f89) (f85) (let ((f88 f88) (f89 f89)) (if (fx= f89 (string-length f88)) () (cons (string-ref f88 f89) ((vector-ref f85 0) f88 (fxadd1 f89)))))))) (closure (f91) (f85) (let ((f91 f91)) ((vector-ref f85 0) f91 0))))
#   env=((f85 . 0))
# emit-expr (begin (vector-set! f85 0 (closure (f88 f89) (f85) (let ((f88 f88) (f89 f89)) (if (fx= f89 (string-length f88)) () (cons (string-ref f88 f89) ((vector-ref f85 0) f88 (fxadd1 f89))))))))
# emit-begin
#   expr=(begin (vector-set! f85 0 (closure (f88 f89) (f85) (let ((f88 f88) (f89 f89)) (if (fx= f89 (string-length f88)) () (cons (string-ref f88 f89) ((vector-ref f85 0) f88 (fxadd1 f89))))))))
#   env=((f85 . 0))
# emit-expr (vector-set! f85 0 (closure (f88 f89) (f85) (let ((f88 f88) (f89 f89)) (if (fx= f89 (string-length f88)) () (cons (string-ref f88 f89) ((vector-ref f85 0) f88 (fxadd1 f89)))))))
# emit-expr f85
>>>>>>> fix-implicit-begins
# emit-variable-ref
# env=((f85 . 0))
# var=f85
    movl 0(%esp), %eax  # stack load f85
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_246
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_246:
    movl %eax, -4(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_247"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_247:
# check bounds on vector index
    movl -4(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_249
    cmp  $0,%eax
    jge _L_248
_L_249:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_248:
    movl %eax, -8(%esp)
<<<<<<< HEAD
# emit-expr (closure (f310876 f310875) (f310872) (let ((f310876 f310876) (f310875 f310875)) (if (fx= f310875 (string-length f310876)) () (cons (string-ref f310876 f310875) ((vector-ref f310872 0) f310876 (fxadd1 f310875))))))
# emit-closure
# si = -12
# env = ((f310872 . 0))
# expr = (closure (f310876 f310875) (f310872) (let ((f310876 f310876) (f310875 f310875)) (if (fx= f310875 (string-length f310876)) () (cons (string-ref f310876 f310875) ((vector-ref f310872 0) f310876 (fxadd1 f310875))))))
    movl $_L_1883849, 0(%ebp)  # closure label
=======
# emit-expr (closure (f88 f89) (f85) (let ((f88 f88) (f89 f89)) (if (fx= f89 (string-length f88)) () (cons (string-ref f88 f89) ((vector-ref f85 0) f88 (fxadd1 f89))))))
# emit-closure
# si = -12
# env = ((f85 . 0))
# expr = (closure (f88 f89) (f85) (let ((f88 f88) (f89 f89)) (if (fx= f89 (string-length f88)) () (cons (string-ref f88 f89) ((vector-ref f85 0) f88 (fxadd1 f89))))))
    movl $_L_250, 0(%ebp)  # closure label
>>>>>>> fix-implicit-begins
# emit-variable-ref
# env=((f85 . 0))
# var=f85
    movl 0(%esp), %eax  # stack load f85
# end emit-variable-ref
   movl  %eax, 4(%ebp)  # f85
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $8, %ebp     # bump ebp
    jmp _L_251            # jump around closure body
_L_250:
# check argument count
    cmp $8,%eax
    je _L_252
# invoke error handler eh_argcount
    .extern mrc_eh$uargcount
    movl mrc_eh$uargcount, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_252:
# emit-tail-expr
# si=-16
<<<<<<< HEAD
# env=((f310875 . -12) (f310876 . -8) (f310872 . 4) (f310872 . 0))
# expr=(let ((f310876 f310876) (f310875 f310875)) (if (fx= f310875 (string-length f310876)) () (cons (string-ref f310876 f310875) ((vector-ref f310872 0) f310876 (fxadd1 f310875)))))
# emit-tail-let
#  si   = -16
#  env  = ((f310875 . -12) (f310876 . -8) (f310872 . 4) (f310872 . 0))
#  bindings = ((f310876 f310876) (f310875 f310875))
#  body = (if (fx= f310875 (string-length f310876)) () (cons (string-ref f310876 f310875) ((vector-ref f310872 0) f310876 (fxadd1 f310875))))
# emit-expr f310876
# emit-variable-ref
# env=((f310875 . -12) (f310876 . -8) (f310872 . 4) (f310872 . 0))
# var=f310876
    movl -8(%esp), %eax  # stack load f310876
# end emit-variable-ref
    movl %eax, -16(%esp)  # stack save
# emit-expr f310875
# emit-variable-ref
# env=((f310875 . -12) (f310876 . -8) (f310872 . 4) (f310872 . 0))
# var=f310875
    movl -12(%esp), %eax  # stack load f310875
=======
# env=((f89 . -12) (f88 . -8) (f85 . 4) (f85 . 0))
# expr=(let ((f88 f88) (f89 f89)) (if (fx= f89 (string-length f88)) () (cons (string-ref f88 f89) ((vector-ref f85 0) f88 (fxadd1 f89)))))
# emit-tail-let
#  si   = -16
#  env  = ((f89 . -12) (f88 . -8) (f85 . 4) (f85 . 0))
#  bindings = ((f88 f88) (f89 f89))
#  body = (if (fx= f89 (string-length f88)) () (cons (string-ref f88 f89) ((vector-ref f85 0) f88 (fxadd1 f89))))
# emit-expr f88
# emit-variable-ref
# env=((f89 . -12) (f88 . -8) (f85 . 4) (f85 . 0))
# var=f88
    movl -8(%esp), %eax  # stack load f88
# end emit-variable-ref
    movl %eax, -16(%esp)  # stack save
# emit-expr f89
# emit-variable-ref
# env=((f89 . -12) (f88 . -8) (f85 . 4) (f85 . 0))
# var=f89
    movl -12(%esp), %eax  # stack load f89
>>>>>>> fix-implicit-begins
# end emit-variable-ref
    movl %eax, -20(%esp)  # stack save
# emit-tail-expr
# si=-24
<<<<<<< HEAD
# env=((f310875 . -20) (f310876 . -16) (f310875 . -12) (f310876 . -8) (f310872 . 4) (f310872 . 0))
# expr=(if (fx= f310875 (string-length f310876)) () (cons (string-ref f310876 f310875) ((vector-ref f310872 0) f310876 (fxadd1 f310875))))
# emit-expr (fx= f310875 (string-length f310876))
# emit-expr (string-length f310876)
# emit-expr f310876
# emit-variable-ref
# env=((f310875 . -20) (f310876 . -16) (f310875 . -12) (f310876 . -8) (f310872 . 4) (f310872 . 0))
# var=f310876
    movl -16(%esp), %eax  # stack load f310876
=======
# env=((f89 . -20) (f88 . -16) (f89 . -12) (f88 . -8) (f85 . 4) (f85 . 0))
# expr=(if (fx= f89 (string-length f88)) () (cons (string-ref f88 f89) ((vector-ref f85 0) f88 (fxadd1 f89))))
# emit-expr (fx= f89 (string-length f88))
# emit-expr (string-length f88)
# emit-expr f88
# emit-variable-ref
# env=((f89 . -20) (f88 . -16) (f89 . -12) (f88 . -8) (f85 . 4) (f85 . 0))
# var=f88
    movl -16(%esp), %eax  # stack load f88
>>>>>>> fix-implicit-begins
# end emit-variable-ref
# check the argument is a string
    movl %eax,%ebx
    and $7, %bl
    cmp $6, %bl
    je _L_255
# invoke error handler eh_string
    .extern mrc_eh$ustring
    movl mrc_eh$ustring, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $160,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_255:
    movl -6(%eax), %eax
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_256"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $68,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_256:
    movl %eax, -24(%esp)
<<<<<<< HEAD
# emit-expr f310875
# emit-variable-ref
# env=((f310875 . -20) (f310876 . -16) (f310875 . -12) (f310876 . -8) (f310872 . 4) (f310872 . 0))
# var=f310875
    movl -20(%esp), %eax  # stack load f310875
=======
# emit-expr f89
# emit-variable-ref
# env=((f89 . -20) (f88 . -16) (f89 . -12) (f88 . -8) (f85 . 4) (f85 . 0))
# var=f89
    movl -20(%esp), %eax  # stack load f89
>>>>>>> fix-implicit-begins
# end emit-variable-ref
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_257"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $68,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_257:
    cmp -24(%esp), %eax
    sete %al
    movzbl %al, %eax
    sal $6, %al
    or $47, %al
    cmp $47, %al
    je _L_253
# emit-tail-expr
# si=-24
<<<<<<< HEAD
# env=((f310875 . -20) (f310876 . -16) (f310875 . -12) (f310876 . -8) (f310872 . 4) (f310872 . 0))
=======
# env=((f89 . -20) (f88 . -16) (f89 . -12) (f88 . -8) (f85 . 4) (f85 . 0))
>>>>>>> fix-implicit-begins
# expr=()
    movl $63, %eax     # immed ()
    ret                  # immediate tail return
    jmp _L_254
_L_253:
# emit-tail-expr
# si=-24
<<<<<<< HEAD
# env=((f310875 . -20) (f310876 . -16) (f310875 . -12) (f310876 . -8) (f310872 . 4) (f310872 . 0))
# expr=(cons (string-ref f310876 f310875) ((vector-ref f310872 0) f310876 (fxadd1 f310875)))
# tail primcall
# cons arg1=(string-ref f310876 f310875) arg2=((vector-ref f310872 0) f310876 (fxadd1 f310875))
# emit-expr (string-ref f310876 f310875)
# emit-expr f310876
# emit-variable-ref
# env=((f310875 . -20) (f310876 . -16) (f310875 . -12) (f310876 . -8) (f310872 . 4) (f310872 . 0))
# var=f310876
    movl -16(%esp), %eax  # stack load f310876
=======
# env=((f89 . -20) (f88 . -16) (f89 . -12) (f88 . -8) (f85 . 4) (f85 . 0))
# expr=(cons (string-ref f88 f89) ((vector-ref f85 0) f88 (fxadd1 f89)))
# tail primcall
# cons arg1=(string-ref f88 f89) arg2=((vector-ref f85 0) f88 (fxadd1 f89))
# emit-expr (string-ref f88 f89)
# emit-expr f88
# emit-variable-ref
# env=((f89 . -20) (f88 . -16) (f89 . -12) (f88 . -8) (f85 . 4) (f85 . 0))
# var=f88
    movl -16(%esp), %eax  # stack load f88
>>>>>>> fix-implicit-begins
# end emit-variable-ref
# check the argument is a string
    movl %eax,%ebx
    and $7, %bl
    cmp $6, %bl
    je _L_258
# invoke error handler eh_string
    .extern mrc_eh$ustring
    movl mrc_eh$ustring, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $164,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_258:
    movl %eax, -24(%esp)
<<<<<<< HEAD
# emit-expr f310875
# emit-variable-ref
# env=((f310875 . -20) (f310876 . -16) (f310875 . -12) (f310876 . -8) (f310872 . 4) (f310872 . 0))
# var=f310875
    movl -20(%esp), %eax  # stack load f310875
=======
# emit-expr f89
# emit-variable-ref
# env=((f89 . -20) (f88 . -16) (f89 . -12) (f88 . -8) (f85 . 4) (f85 . 0))
# var=f89
    movl -20(%esp), %eax  # stack load f89
>>>>>>> fix-implicit-begins
# end emit-variable-ref
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_259"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $164,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_259:
# check bounds on string index
    movl -24(%esp), %ebx
    cmp  %eax,-6(%ebx) 
    jle _L_261
    cmp  $0,%eax
    jge _L_260
_L_261:
# invoke error handler eh_string_index
    .extern mrc_eh$ustring$uindex
    movl mrc_eh$ustring$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $164,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_260:
    sar $2, %eax
    movl -24(%esp), %esi
    movl -2(%eax,%esi), %eax
    sal $8, %eax
    or  $15, %eax
    movl %eax, -24(%esp)
<<<<<<< HEAD
# emit-expr ((vector-ref f310872 0) f310876 (fxadd1 f310875))
# funcall
#    si   =-28
#    env  = ((f310875 . -20) (f310876 . -16) (f310875 . -12) (f310876 . -8) (f310872 . 4) (f310872 . 0))
#    expr = (funcall (vector-ref f310872 0) f310876 (fxadd1 f310875))
# emit-expr (vector-ref f310872 0)
# emit-expr f310872
# emit-variable-ref
# env=((f310875 . -20) (f310876 . -16) (f310875 . -12) (f310876 . -8) (f310872 . 4) (f310872 . 0))
# var=f310872
    movl 2(%edi), %eax  # frame load f310872
=======
# emit-expr ((vector-ref f85 0) f88 (fxadd1 f89))
# funcall
#    si   =-28
#    env  = ((f89 . -20) (f88 . -16) (f89 . -12) (f88 . -8) (f85 . 4) (f85 . 0))
#    expr = (funcall (vector-ref f85 0) f88 (fxadd1 f89))
# emit-expr (vector-ref f85 0)
# emit-expr f85
# emit-variable-ref
# env=((f89 . -20) (f88 . -16) (f89 . -12) (f88 . -8) (f85 . 4) (f85 . 0))
# var=f85
    movl 2(%edi), %eax  # frame load f85
>>>>>>> fix-implicit-begins
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_262
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_262:
    movl %eax, -36(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_263"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_263:
# check bounds on vector index
    movl -36(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_265
    cmp  $0,%eax
    jge _L_264
_L_265:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_264:
    movl -36(%esp), %esi
    movl -1(%eax,%esi), %eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_266"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_266":
   movl %eax,  -36(%esp)  # stash funcall-oper in closure slot
<<<<<<< HEAD
# emit-expr f310876
# emit-variable-ref
# env=((f310875 . -20) (f310876 . -16) (f310875 . -12) (f310876 . -8) (f310872 . 4) (f310872 . 0))
# var=f310876
    movl -16(%esp), %eax  # stack load f310876
# end emit-variable-ref
    mov %eax, -40(%esp)  # arg f310876
# emit-expr (fxadd1 f310875)
# emit-expr f310875
# emit-variable-ref
# env=((f310875 . -20) (f310876 . -16) (f310875 . -12) (f310876 . -8) (f310872 . 4) (f310872 . 0))
# var=f310875
    movl -20(%esp), %eax  # stack load f310875
=======
# emit-expr f88
# emit-variable-ref
# env=((f89 . -20) (f88 . -16) (f89 . -12) (f88 . -8) (f85 . 4) (f85 . 0))
# var=f88
    movl -16(%esp), %eax  # stack load f88
# end emit-variable-ref
    mov %eax, -40(%esp)  # arg f88
# emit-expr (fxadd1 f89)
# emit-expr f89
# emit-variable-ref
# env=((f89 . -20) (f88 . -16) (f89 . -12) (f88 . -8) (f85 . 4) (f85 . 0))
# var=f89
    movl -20(%esp), %eax  # stack load f89
>>>>>>> fix-implicit-begins
# end emit-variable-ref
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_267"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $56,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_267:
     addl $4, %eax
<<<<<<< HEAD
    mov %eax, -44(%esp)  # arg (fxadd1 f310875)
=======
    mov %eax, -44(%esp)  # arg (fxadd1 f89)
>>>>>>> fix-implicit-begins
    movl -36(%esp), %edi   # load new closure to %edi
    add $-28, %esp   # adjust base
    movl $8,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $28, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    movl %eax, 4(%ebp)
    movl -24(%esp), %eax
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    or   $1, %al
    add  $8, %ebp
# cons end
<<<<<<< HEAD
#return from tail (cons (string-ref f310876 f310875) ((vector-ref f310872 0) f310876 (fxadd1 f310875)))
=======
#return from tail (cons (string-ref f88 f89) ((vector-ref f85 0) f88 (fxadd1 f89)))
>>>>>>> fix-implicit-begins
    ret
_L_254:
    .align 4,0x90
_L_251:
    movl -4(%esp), %ebx
    movl -8(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin)
# emit-begin
#   expr=(begin)
#   env=((f85 . 0))
# emit-expr (begin (closure (f91) (f85) (let ((f91 f91)) ((vector-ref f85 0) f91 0))))
# emit-begin
#   expr=(begin (closure (f91) (f85) (let ((f91 f91)) ((vector-ref f85 0) f91 0))))
#   env=((f85 . 0))
# emit-expr (closure (f91) (f85) (let ((f91 f91)) ((vector-ref f85 0) f91 0)))
# emit-closure
# si = -4
# env = ((f85 . 0))
# expr = (closure (f91) (f85) (let ((f91 f91)) ((vector-ref f85 0) f91 0)))
    movl $_L_268, 0(%ebp)  # closure label
# emit-variable-ref
# env=((f85 . 0))
# var=f85
    movl 0(%esp), %eax  # stack load f85
# end emit-variable-ref
   movl  %eax, 4(%ebp)  # f85
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $8, %ebp     # bump ebp
    jmp _L_269            # jump around closure body
_L_268:
# check argument count
    cmp $4,%eax
    je _L_270
# invoke error handler eh_argcount
    .extern mrc_eh$uargcount
    movl mrc_eh$uargcount, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_270:
# emit-tail-expr
# si=-12
# env=((f91 . -8) (f85 . 4) (f85 . 0))
# expr=(let ((f91 f91)) ((vector-ref f85 0) f91 0))
# emit-tail-let
#  si   = -12
#  env  = ((f91 . -8) (f85 . 4) (f85 . 0))
#  bindings = ((f91 f91))
#  body = ((vector-ref f85 0) f91 0)
# emit-expr f91
# emit-variable-ref
# env=((f91 . -8) (f85 . 4) (f85 . 0))
# var=f91
    movl -8(%esp), %eax  # stack load f91
# end emit-variable-ref
    movl %eax, -12(%esp)  # stack save
# emit-tail-expr
# si=-16
# env=((f91 . -12) (f91 . -8) (f85 . 4) (f85 . 0))
# expr=((vector-ref f85 0) f91 0)
# emit-tail-funcall
#    si   =-16
#    env  = ((f91 . -12) (f91 . -8) (f85 . 4) (f85 . 0))
#    expr = (funcall (vector-ref f85 0) f91 0)
# emit-expr (vector-ref f85 0)
# emit-expr f85
# emit-variable-ref
# env=((f91 . -12) (f91 . -8) (f85 . 4) (f85 . 0))
# var=f85
    movl 2(%edi), %eax  # frame load f85
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_271
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_271:
    movl %eax, -16(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_272"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_272:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_274
    cmp  $0,%eax
    jge _L_273
_L_274:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_273:
    movl -16(%esp), %esi
    movl -1(%eax,%esi), %eax
   movl %eax,  -16(%esp)  # stash funcall-oper in next closure slot
# emit-expr f91
# emit-variable-ref
# env=((f91 . -12) (f91 . -8) (f85 . 4) (f85 . 0))
# var=f91
    movl -12(%esp), %eax  # stack load f91
# end emit-variable-ref
    mov %eax, -20(%esp)    # arg f91
# emit-expr 0
    movl $0, %eax     # immed 0
    mov %eax, -24(%esp)    # arg 0
    movl -16(%esp), %edi   # load new closure to %edi
# emit-shift-args:  size=3   si=-16  delta=12
    mov -16(%esp), %ebx  # shift frame cell
    mov %ebx, -4(%esp)  # down to base
# emit-shift-args:  size=2   si=-20  delta=12
    mov -20(%esp), %ebx  # shift frame cell
    mov %ebx, -8(%esp)  # down to base
# emit-shift-args:  size=1   si=-24  delta=12
    mov -24(%esp), %ebx  # shift frame cell
    mov %ebx, -12(%esp)  # down to base
# emit-shift-args:  size=0   si=-28  delta=12
    movl $8,%eax   # save arg count
    jmp *-2(%edi)  # tail-funcall
    .align 4,0x90
_L_269:
# emit-expr (begin)
# emit-begin
#   expr=(begin)
#   env=((f85 . 0))
     movl %eax, mrc_string$m$glist
# == explicit-begins  ==>
# (letrec ((f (lambda (i l) (cond ((fx< i 10) (cons i l)) (else (f (fxquotient i 10) (cons (fxremainder i 10) l))))))) (lambda (i) (f i (quote ()))))
# == eliminate-let*  ==>
# (letrec ((f (lambda (i l) (cond ((fx< i 10) (cons i l)) (else (f (fxquotient i 10) (cons (fxremainder i 10) l))))))) (lambda (i) (f i (quote ()))))
# == uniquify-variables  ==>
<<<<<<< HEAD
# (letrec ((f310879 (lambda (f310883 f310882) (cond ((fx< f310883 10) (cons f310883 f310882)) (else (f310879 (fxquotient f310883 10) (cons (fxremainder f310883 10) f310882))))))) (lambda (f310885) (f310879 f310885 (quote ()))))
# == vectorize-letrec  ==>
# (let ((f310879 (make-vector 1))) (begin (begin (vector-set! f310879 0 (lambda (f310883 f310882) (cond ((fx< f310883 10) (cons f310883 f310882)) (else ((vector-ref f310879 0) (fxquotient f310883 10) (cons (fxremainder f310883 10) f310882))))))) (lambda (f310885) ((vector-ref f310879 0) f310885 (quote ())))))
# == eliminate-set!  ==>
# (let ((f310879 (make-vector 1))) (begin (begin (vector-set! f310879 0 (lambda (f310883 f310882) (let ((f310883 f310883) (f310882 f310882)) (cond ((fx< f310883 10) (cons f310883 f310882)) (else ((vector-ref f310879 0) (fxquotient f310883 10) (cons (fxremainder f310883 10) f310882)))))))) (lambda (f310885) (let ((f310885 f310885)) ((vector-ref f310879 0) f310885 (quote ()))))))
# == close-free-variables  ==>
# (let ((f310879 (make-vector 1))) (begin (begin (vector-set! f310879 0 (closure (f310883 f310882) (f310879) (let ((f310883 f310883) (f310882 f310882)) (cond ((fx< f310883 10) (cons f310883 f310882)) (else ((vector-ref f310879 0) (fxquotient f310883 10) (cons (fxremainder f310883 10) f310882)))))))) (closure (f310885) (f310879) (let ((f310885 f310885)) ((vector-ref f310879 0) f310885 (quote ()))))))
# == eliminate-quote  ==>
# (let ((f310879 (make-vector 1))) (begin (begin (vector-set! f310879 0 (closure (f310883 f310882) (f310879) (let ((f310883 f310883) (f310882 f310882)) (cond ((fx< f310883 10) (cons f310883 f310882)) (else ((vector-ref f310879 0) (fxquotient f310883 10) (cons (fxremainder f310883 10) f310882)))))))) (closure (f310885) (f310879) (let ((f310885 f310885)) ((vector-ref f310879 0) f310885 ())))))
# == eliminate-when/unless  ==>
# (let ((f310879 (make-vector 1))) (begin (begin (vector-set! f310879 0 (closure (f310883 f310882) (f310879) (let ((f310883 f310883) (f310882 f310882)) (cond ((fx< f310883 10) (cons f310883 f310882)) (else ((vector-ref f310879 0) (fxquotient f310883 10) (cons (fxremainder f310883 10) f310882)))))))) (closure (f310885) (f310879) (let ((f310885 f310885)) ((vector-ref f310879 0) f310885 ())))))
# == eliminate-cond  ==>
# (let ((f310879 (make-vector 1))) (begin (begin (vector-set! f310879 0 (closure (f310883 f310882) (f310879) (let ((f310883 f310883) (f310882 f310882)) (if (fx< f310883 10) (cons f310883 f310882) ((vector-ref f310879 0) (fxquotient f310883 10) (cons (fxremainder f310883 10) f310882))))))) (closure (f310885) (f310879) (let ((f310885 f310885)) ((vector-ref f310879 0) f310885 ())))))
# == external-symbols  ==>
# (let ((f310879 (make-vector 1))) (begin (begin (vector-set! f310879 0 (closure (f310883 f310882) (f310879) (let ((f310883 f310883) (f310882 f310882)) (if (fx< f310883 10) (cons f310883 f310882) ((vector-ref f310879 0) (fxquotient f310883 10) (cons (fxremainder f310883 10) f310882))))))) (closure (f310885) (f310879) (let ((f310885 f310885)) ((vector-ref f310879 0) f310885 ())))))
# emit-expr (let ((f310879 (make-vector 1))) (begin (begin (vector-set! f310879 0 (closure (f310883 f310882) (f310879) (let ((f310883 f310883) (f310882 f310882)) (if (fx< f310883 10) (cons f310883 f310882) ((vector-ref f310879 0) (fxquotient f310883 10) (cons (fxremainder f310883 10) f310882))))))) (closure (f310885) (f310879) (let ((f310885 f310885)) ((vector-ref f310879 0) f310885 ())))))
# emit-let
#  si   = 0
#  env  = ()
#  bindings = ((f310879 (make-vector 1)))
#  body = (begin (begin (vector-set! f310879 0 (closure (f310883 f310882) (f310879) (let ((f310883 f310883) (f310882 f310882)) (if (fx< f310883 10) (cons f310883 f310882) ((vector-ref f310879 0) (fxquotient f310883 10) (cons (fxremainder f310883 10) f310882))))))) (closure (f310885) (f310879) (let ((f310885 f310885)) ((vector-ref f310879 0) f310885 ()))))
=======
# (letrec ((f92 (lambda (f95 f96) (cond ((fx< f95 10) (cons f95 f96)) (else (f92 (fxquotient f95 10) (cons (fxremainder f95 10) f96))))))) (lambda (f98) (f92 f98 (quote ()))))
# == vectorize-letrec  ==>
# (let ((f92 (make-vector 1))) (begin (begin (vector-set! f92 0 (lambda (f95 f96) (cond ((fx< f95 10) (cons f95 f96)) (else ((vector-ref f92 0) (fxquotient f95 10) (cons (fxremainder f95 10) f96))))))) (lambda (f98) ((vector-ref f92 0) f98 (quote ())))))
# == eliminate-set!  ==>
# (let ((f92 (make-vector 1))) (begin (begin (vector-set! f92 0 (lambda (f95 f96) (let ((f95 f95) (f96 f96)) (cond ((fx< f95 10) (cons f95 f96)) (else ((vector-ref f92 0) (fxquotient f95 10) (cons (fxremainder f95 10) f96)))))))) (lambda (f98) (let ((f98 f98)) ((vector-ref f92 0) f98 (quote ()))))))
# == close-free-variables  ==>
# (let ((f92 (make-vector 1))) (begin (begin (vector-set! f92 0 (closure (f95 f96) (f92) (let ((f95 f95) (f96 f96)) (cond ((fx< f95 10) (cons f95 f96)) (else ((vector-ref f92 0) (fxquotient f95 10) (cons (fxremainder f95 10) f96)))))))) (closure (f98) (f92) (let ((f98 f98)) ((vector-ref f92 0) f98 (quote ()))))))
# == eliminate-quote  ==>
# (let ((f92 (make-vector 1))) (begin (begin (vector-set! f92 0 (closure (f95 f96) (f92) (let ((f95 f95) (f96 f96)) (cond ((fx< f95 10) (cons f95 f96)) (else ((vector-ref f92 0) (fxquotient f95 10) (cons (fxremainder f95 10) f96)))))))) (closure (f98) (f92) (let ((f98 f98)) ((vector-ref f92 0) f98 ())))))
# == eliminate-when/unless  ==>
# (let ((f92 (make-vector 1))) (begin (begin (vector-set! f92 0 (closure (f95 f96) (f92) (let ((f95 f95) (f96 f96)) (cond ((fx< f95 10) (cons f95 f96)) (else ((vector-ref f92 0) (fxquotient f95 10) (cons (fxremainder f95 10) f96)))))))) (closure (f98) (f92) (let ((f98 f98)) ((vector-ref f92 0) f98 ())))))
# == eliminate-cond  ==>
# (let ((f92 (make-vector 1))) (begin (begin (vector-set! f92 0 (closure (f95 f96) (f92) (let ((f95 f95) (f96 f96)) (if (fx< f95 10) (begin (cons f95 f96)) (begin ((vector-ref f92 0) (fxquotient f95 10) (cons (fxremainder f95 10) f96)))))))) (closure (f98) (f92) (let ((f98 f98)) ((vector-ref f92 0) f98 ())))))
# == external-symbols  ==>
# (let ((f92 (make-vector 1))) (begin (begin (vector-set! f92 0 (closure (f95 f96) (f92) (let ((f95 f95) (f96 f96)) (if (fx< f95 10) (begin (cons f95 f96)) (begin ((vector-ref f92 0) (fxquotient f95 10) (cons (fxremainder f95 10) f96)))))))) (closure (f98) (f92) (let ((f98 f98)) ((vector-ref f92 0) f98 ())))))
# emit-expr (let ((f92 (make-vector 1))) (begin (begin (vector-set! f92 0 (closure (f95 f96) (f92) (let ((f95 f95) (f96 f96)) (if (fx< f95 10) (begin (cons f95 f96)) (begin ((vector-ref f92 0) (fxquotient f95 10) (cons (fxremainder f95 10) f96)))))))) (closure (f98) (f92) (let ((f98 f98)) ((vector-ref f92 0) f98 ())))))
# emit-let
#  si   = 0
#  env  = ()
#  bindings = ((f92 (make-vector 1)))
#  body = (begin (begin (vector-set! f92 0 (closure (f95 f96) (f92) (let ((f95 f95) (f96 f96)) (if (fx< f95 10) (begin (cons f95 f96)) (begin ((vector-ref f92 0) (fxquotient f95 10) (cons (fxremainder f95 10) f96)))))))) (closure (f98) (f92) (let ((f98 f98)) ((vector-ref f92 0) f98 ()))))
>>>>>>> fix-implicit-begins
# emit-expr (make-vector 1)
# make-vector 1
# emit-expr 1
    movl $4, %eax     # immed 1
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_275"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_275:
# check the argument is a fixnum >= 0
    cmp $0,%eax
    jge _L_276
# invoke error handler eh_length
    .extern mrc_eh$ulength
    movl mrc_eh$ulength, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_276:
    movl %eax, %esi
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    orl  $5, %eax
    addl $4, %esi
    addl $4, %esi
    andl $-8, %esi
    addl %esi, %ebp
    movl %eax, 0(%esp)  # stack save
<<<<<<< HEAD
# emit-expr (begin (begin (vector-set! f310879 0 (closure (f310883 f310882) (f310879) (let ((f310883 f310883) (f310882 f310882)) (if (fx< f310883 10) (cons f310883 f310882) ((vector-ref f310879 0) (fxquotient f310883 10) (cons (fxremainder f310883 10) f310882))))))) (closure (f310885) (f310879) (let ((f310885 f310885)) ((vector-ref f310879 0) f310885 ()))))
# emit-begin
#   expr=(begin (begin (vector-set! f310879 0 (closure (f310883 f310882) (f310879) (let ((f310883 f310883) (f310882 f310882)) (if (fx< f310883 10) (cons f310883 f310882) ((vector-ref f310879 0) (fxquotient f310883 10) (cons (fxremainder f310883 10) f310882))))))) (closure (f310885) (f310879) (let ((f310885 f310885)) ((vector-ref f310879 0) f310885 ()))))
#   env=((f310879 . 0))
# emit-expr (begin (vector-set! f310879 0 (closure (f310883 f310882) (f310879) (let ((f310883 f310883) (f310882 f310882)) (if (fx< f310883 10) (cons f310883 f310882) ((vector-ref f310879 0) (fxquotient f310883 10) (cons (fxremainder f310883 10) f310882)))))))
# emit-begin
#   expr=(begin (vector-set! f310879 0 (closure (f310883 f310882) (f310879) (let ((f310883 f310883) (f310882 f310882)) (if (fx< f310883 10) (cons f310883 f310882) ((vector-ref f310879 0) (fxquotient f310883 10) (cons (fxremainder f310883 10) f310882)))))))
#   env=((f310879 . 0))
# emit-expr (vector-set! f310879 0 (closure (f310883 f310882) (f310879) (let ((f310883 f310883) (f310882 f310882)) (if (fx< f310883 10) (cons f310883 f310882) ((vector-ref f310879 0) (fxquotient f310883 10) (cons (fxremainder f310883 10) f310882))))))
# emit-expr f310879
=======
# emit-expr (begin (begin (vector-set! f92 0 (closure (f95 f96) (f92) (let ((f95 f95) (f96 f96)) (if (fx< f95 10) (begin (cons f95 f96)) (begin ((vector-ref f92 0) (fxquotient f95 10) (cons (fxremainder f95 10) f96)))))))) (closure (f98) (f92) (let ((f98 f98)) ((vector-ref f92 0) f98 ()))))
# emit-begin
#   expr=(begin (begin (vector-set! f92 0 (closure (f95 f96) (f92) (let ((f95 f95) (f96 f96)) (if (fx< f95 10) (begin (cons f95 f96)) (begin ((vector-ref f92 0) (fxquotient f95 10) (cons (fxremainder f95 10) f96)))))))) (closure (f98) (f92) (let ((f98 f98)) ((vector-ref f92 0) f98 ()))))
#   env=((f92 . 0))
# emit-expr (begin (vector-set! f92 0 (closure (f95 f96) (f92) (let ((f95 f95) (f96 f96)) (if (fx< f95 10) (begin (cons f95 f96)) (begin ((vector-ref f92 0) (fxquotient f95 10) (cons (fxremainder f95 10) f96))))))))
# emit-begin
#   expr=(begin (vector-set! f92 0 (closure (f95 f96) (f92) (let ((f95 f95) (f96 f96)) (if (fx< f95 10) (begin (cons f95 f96)) (begin ((vector-ref f92 0) (fxquotient f95 10) (cons (fxremainder f95 10) f96))))))))
#   env=((f92 . 0))
# emit-expr (vector-set! f92 0 (closure (f95 f96) (f92) (let ((f95 f95) (f96 f96)) (if (fx< f95 10) (begin (cons f95 f96)) (begin ((vector-ref f92 0) (fxquotient f95 10) (cons (fxremainder f95 10) f96)))))))
# emit-expr f92
>>>>>>> fix-implicit-begins
# emit-variable-ref
# env=((f92 . 0))
# var=f92
    movl 0(%esp), %eax  # stack load f92
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_277
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_277:
    movl %eax, -4(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_278"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_278:
# check bounds on vector index
    movl -4(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_280
    cmp  $0,%eax
    jge _L_279
_L_280:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_279:
    movl %eax, -8(%esp)
<<<<<<< HEAD
# emit-expr (closure (f310883 f310882) (f310879) (let ((f310883 f310883) (f310882 f310882)) (if (fx< f310883 10) (cons f310883 f310882) ((vector-ref f310879 0) (fxquotient f310883 10) (cons (fxremainder f310883 10) f310882)))))
# emit-closure
# si = -12
# env = ((f310879 . 0))
# expr = (closure (f310883 f310882) (f310879) (let ((f310883 f310883) (f310882 f310882)) (if (fx< f310883 10) (cons f310883 f310882) ((vector-ref f310879 0) (fxquotient f310883 10) (cons (fxremainder f310883 10) f310882)))))
    movl $_L_1883880, 0(%ebp)  # closure label
=======
# emit-expr (closure (f95 f96) (f92) (let ((f95 f95) (f96 f96)) (if (fx< f95 10) (begin (cons f95 f96)) (begin ((vector-ref f92 0) (fxquotient f95 10) (cons (fxremainder f95 10) f96))))))
# emit-closure
# si = -12
# env = ((f92 . 0))
# expr = (closure (f95 f96) (f92) (let ((f95 f95) (f96 f96)) (if (fx< f95 10) (begin (cons f95 f96)) (begin ((vector-ref f92 0) (fxquotient f95 10) (cons (fxremainder f95 10) f96))))))
    movl $_L_281, 0(%ebp)  # closure label
>>>>>>> fix-implicit-begins
# emit-variable-ref
# env=((f92 . 0))
# var=f92
    movl 0(%esp), %eax  # stack load f92
# end emit-variable-ref
   movl  %eax, 4(%ebp)  # f92
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $8, %ebp     # bump ebp
    jmp _L_282            # jump around closure body
_L_281:
# check argument count
    cmp $8,%eax
    je _L_283
# invoke error handler eh_argcount
    .extern mrc_eh$uargcount
    movl mrc_eh$uargcount, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_283:
# emit-tail-expr
# si=-16
<<<<<<< HEAD
# env=((f310882 . -12) (f310883 . -8) (f310879 . 4) (f310879 . 0))
# expr=(let ((f310883 f310883) (f310882 f310882)) (if (fx< f310883 10) (cons f310883 f310882) ((vector-ref f310879 0) (fxquotient f310883 10) (cons (fxremainder f310883 10) f310882))))
# emit-tail-let
#  si   = -16
#  env  = ((f310882 . -12) (f310883 . -8) (f310879 . 4) (f310879 . 0))
#  bindings = ((f310883 f310883) (f310882 f310882))
#  body = (if (fx< f310883 10) (cons f310883 f310882) ((vector-ref f310879 0) (fxquotient f310883 10) (cons (fxremainder f310883 10) f310882)))
# emit-expr f310883
# emit-variable-ref
# env=((f310882 . -12) (f310883 . -8) (f310879 . 4) (f310879 . 0))
# var=f310883
    movl -8(%esp), %eax  # stack load f310883
# end emit-variable-ref
    movl %eax, -16(%esp)  # stack save
# emit-expr f310882
# emit-variable-ref
# env=((f310882 . -12) (f310883 . -8) (f310879 . 4) (f310879 . 0))
# var=f310882
    movl -12(%esp), %eax  # stack load f310882
=======
# env=((f96 . -12) (f95 . -8) (f92 . 4) (f92 . 0))
# expr=(let ((f95 f95) (f96 f96)) (if (fx< f95 10) (begin (cons f95 f96)) (begin ((vector-ref f92 0) (fxquotient f95 10) (cons (fxremainder f95 10) f96)))))
# emit-tail-let
#  si   = -16
#  env  = ((f96 . -12) (f95 . -8) (f92 . 4) (f92 . 0))
#  bindings = ((f95 f95) (f96 f96))
#  body = (if (fx< f95 10) (begin (cons f95 f96)) (begin ((vector-ref f92 0) (fxquotient f95 10) (cons (fxremainder f95 10) f96))))
# emit-expr f95
# emit-variable-ref
# env=((f96 . -12) (f95 . -8) (f92 . 4) (f92 . 0))
# var=f95
    movl -8(%esp), %eax  # stack load f95
# end emit-variable-ref
    movl %eax, -16(%esp)  # stack save
# emit-expr f96
# emit-variable-ref
# env=((f96 . -12) (f95 . -8) (f92 . 4) (f92 . 0))
# var=f96
    movl -12(%esp), %eax  # stack load f96
>>>>>>> fix-implicit-begins
# end emit-variable-ref
    movl %eax, -20(%esp)  # stack save
# emit-tail-expr
# si=-24
<<<<<<< HEAD
# env=((f310882 . -20) (f310883 . -16) (f310882 . -12) (f310883 . -8) (f310879 . 4) (f310879 . 0))
# expr=(if (fx< f310883 10) (cons f310883 f310882) ((vector-ref f310879 0) (fxquotient f310883 10) (cons (fxremainder f310883 10) f310882)))
# emit-expr (fx< f310883 10)
=======
# env=((f96 . -20) (f95 . -16) (f96 . -12) (f95 . -8) (f92 . 4) (f92 . 0))
# expr=(if (fx< f95 10) (begin (cons f95 f96)) (begin ((vector-ref f92 0) (fxquotient f95 10) (cons (fxremainder f95 10) f96))))
# emit-expr (fx< f95 10)
>>>>>>> fix-implicit-begins
# emit-expr 10
    movl $40, %eax     # immed 10
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_286"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $72,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_286:
    movl %eax, -24(%esp)
<<<<<<< HEAD
# emit-expr f310883
# emit-variable-ref
# env=((f310882 . -20) (f310883 . -16) (f310882 . -12) (f310883 . -8) (f310879 . 4) (f310879 . 0))
# var=f310883
    movl -16(%esp), %eax  # stack load f310883
=======
# emit-expr f95
# emit-variable-ref
# env=((f96 . -20) (f95 . -16) (f96 . -12) (f95 . -8) (f92 . 4) (f92 . 0))
# var=f95
    movl -16(%esp), %eax  # stack load f95
>>>>>>> fix-implicit-begins
# end emit-variable-ref
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_287"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $72,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_287:
    cmp -24(%esp), %eax
    setl %al
    movzbl %al, %eax
    sal $6, %al
    or $47, %al
    cmp $47, %al
    je _L_284
# emit-tail-expr
# si=-24
<<<<<<< HEAD
# env=((f310882 . -20) (f310883 . -16) (f310882 . -12) (f310883 . -8) (f310879 . 4) (f310879 . 0))
# expr=(cons f310883 f310882)
# tail primcall
# cons arg1=f310883 arg2=f310882
# emit-expr f310883
# emit-variable-ref
# env=((f310882 . -20) (f310883 . -16) (f310882 . -12) (f310883 . -8) (f310879 . 4) (f310879 . 0))
# var=f310883
    movl -16(%esp), %eax  # stack load f310883
# end emit-variable-ref
    movl %eax, -24(%esp)
# emit-expr f310882
# emit-variable-ref
# env=((f310882 . -20) (f310883 . -16) (f310882 . -12) (f310883 . -8) (f310879 . 4) (f310879 . 0))
# var=f310882
    movl -20(%esp), %eax  # stack load f310882
=======
# env=((f96 . -20) (f95 . -16) (f96 . -12) (f95 . -8) (f92 . 4) (f92 . 0))
# expr=(begin (cons f95 f96))
# tail-begin (begin (cons f95 f96))
#   env=((f96 . -20) (f95 . -16) (f96 . -12) (f95 . -8) (f92 . 4) (f92 . 0))
# emit-tail-expr
# si=-24
# env=((f96 . -20) (f95 . -16) (f96 . -12) (f95 . -8) (f92 . 4) (f92 . 0))
# expr=(cons f95 f96)
# tail primcall
# cons arg1=f95 arg2=f96
# emit-expr f95
# emit-variable-ref
# env=((f96 . -20) (f95 . -16) (f96 . -12) (f95 . -8) (f92 . 4) (f92 . 0))
# var=f95
    movl -16(%esp), %eax  # stack load f95
# end emit-variable-ref
    movl %eax, -24(%esp)
# emit-expr f96
# emit-variable-ref
# env=((f96 . -20) (f95 . -16) (f96 . -12) (f95 . -8) (f92 . 4) (f92 . 0))
# var=f96
    movl -20(%esp), %eax  # stack load f96
>>>>>>> fix-implicit-begins
# end emit-variable-ref
    movl %eax, 4(%ebp)
    movl -24(%esp), %eax
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    or   $1, %al
    add  $8, %ebp
# cons end
<<<<<<< HEAD
#return from tail (cons f310883 f310882)
=======
#return from tail (cons f95 f96)
>>>>>>> fix-implicit-begins
    ret
     ret   # return thru stack
    jmp _L_285
_L_284:
# emit-tail-expr
# si=-24
<<<<<<< HEAD
# env=((f310882 . -20) (f310883 . -16) (f310882 . -12) (f310883 . -8) (f310879 . 4) (f310879 . 0))
# expr=((vector-ref f310879 0) (fxquotient f310883 10) (cons (fxremainder f310883 10) f310882))
# emit-tail-funcall
#    si   =-24
#    env  = ((f310882 . -20) (f310883 . -16) (f310882 . -12) (f310883 . -8) (f310879 . 4) (f310879 . 0))
#    expr = (funcall (vector-ref f310879 0) (fxquotient f310883 10) (cons (fxremainder f310883 10) f310882))
# emit-expr (vector-ref f310879 0)
# emit-expr f310879
# emit-variable-ref
# env=((f310882 . -20) (f310883 . -16) (f310882 . -12) (f310883 . -8) (f310879 . 4) (f310879 . 0))
# var=f310879
    movl 2(%edi), %eax  # frame load f310879
=======
# env=((f96 . -20) (f95 . -16) (f96 . -12) (f95 . -8) (f92 . 4) (f92 . 0))
# expr=(begin ((vector-ref f92 0) (fxquotient f95 10) (cons (fxremainder f95 10) f96)))
# tail-begin (begin ((vector-ref f92 0) (fxquotient f95 10) (cons (fxremainder f95 10) f96)))
#   env=((f96 . -20) (f95 . -16) (f96 . -12) (f95 . -8) (f92 . 4) (f92 . 0))
# emit-tail-expr
# si=-24
# env=((f96 . -20) (f95 . -16) (f96 . -12) (f95 . -8) (f92 . 4) (f92 . 0))
# expr=((vector-ref f92 0) (fxquotient f95 10) (cons (fxremainder f95 10) f96))
# emit-tail-funcall
#    si   =-24
#    env  = ((f96 . -20) (f95 . -16) (f96 . -12) (f95 . -8) (f92 . 4) (f92 . 0))
#    expr = (funcall (vector-ref f92 0) (fxquotient f95 10) (cons (fxremainder f95 10) f96))
# emit-expr (vector-ref f92 0)
# emit-expr f92
# emit-variable-ref
# env=((f96 . -20) (f95 . -16) (f96 . -12) (f95 . -8) (f92 . 4) (f92 . 0))
# var=f92
    movl 2(%edi), %eax  # frame load f92
>>>>>>> fix-implicit-begins
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_288
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_288:
    movl %eax, -24(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_289"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_289:
# check bounds on vector index
    movl -24(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_291
    cmp  $0,%eax
    jge _L_290
_L_291:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_290:
    movl -24(%esp), %esi
    movl -1(%eax,%esi), %eax
   movl %eax,  -24(%esp)  # stash funcall-oper in next closure slot
<<<<<<< HEAD
# emit-expr (fxquotient f310883 10)
=======
# emit-expr (fxquotient f95 10)
>>>>>>> fix-implicit-begins
# emit-expr 10
    movl $40, %eax     # immed 10
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_293"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $100,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_293:
    movl %eax, -28(%esp)  # denominator
<<<<<<< HEAD
# emit-expr f310883
# emit-variable-ref
# env=((f310882 . -20) (f310883 . -16) (f310882 . -12) (f310883 . -8) (f310879 . 4) (f310879 . 0))
# var=f310883
    movl -16(%esp), %eax  # stack load f310883
=======
# emit-expr f95
# emit-variable-ref
# env=((f96 . -20) (f95 . -16) (f96 . -12) (f95 . -8) (f92 . 4) (f92 . 0))
# var=f95
    movl -16(%esp), %eax  # stack load f95
>>>>>>> fix-implicit-begins
# end emit-variable-ref
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_294"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $100,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_294:
    movl -28(%esp),%ebx   # ebx <- denominator
    xor %edx,%edx        # edx <- 0
    cmp $0,%eax
    jge _L_292
    not %edx
_L_292:
    idiv %ebx            # eax <- edx:eax/ebx
    sal $2,%eax          # eax <- eax*4 (since it was divided away)
<<<<<<< HEAD
    mov %eax, -28(%esp)    # arg (fxquotient f310883 10)
# emit-expr (cons (fxremainder f310883 10) f310882)
# cons arg1=(fxremainder f310883 10) arg2=f310882
# emit-expr (fxremainder f310883 10)
=======
    mov %eax, -28(%esp)    # arg (fxquotient f95 10)
# emit-expr (cons (fxremainder f95 10) f96)
# cons arg1=(fxremainder f95 10) arg2=f96
# emit-expr (fxremainder f95 10)
>>>>>>> fix-implicit-begins
# emit-expr 10
    movl $40, %eax     # immed 10
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_296"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $100,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_296:
    movl %eax, -32(%esp)  # denominator
<<<<<<< HEAD
# emit-expr f310883
# emit-variable-ref
# env=((f310882 . -20) (f310883 . -16) (f310882 . -12) (f310883 . -8) (f310879 . 4) (f310879 . 0))
# var=f310883
    movl -16(%esp), %eax  # stack load f310883
=======
# emit-expr f95
# emit-variable-ref
# env=((f96 . -20) (f95 . -16) (f96 . -12) (f95 . -8) (f92 . 4) (f92 . 0))
# var=f95
    movl -16(%esp), %eax  # stack load f95
>>>>>>> fix-implicit-begins
# end emit-variable-ref
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_297"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $100,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_297:
    movl -32(%esp),%ebx   # ebx <- denominator
    xor %edx,%edx        # edx <- 0
    cmp $0,%eax
    jge _L_295
    not %edx
_L_295:
    idiv %ebx            # edx <- edx:eax/ebx  remainder
    movl %edx,%eax
    movl %eax, -32(%esp)
<<<<<<< HEAD
# emit-expr f310882
# emit-variable-ref
# env=((f310882 . -20) (f310883 . -16) (f310882 . -12) (f310883 . -8) (f310879 . 4) (f310879 . 0))
# var=f310882
    movl -20(%esp), %eax  # stack load f310882
=======
# emit-expr f96
# emit-variable-ref
# env=((f96 . -20) (f95 . -16) (f96 . -12) (f95 . -8) (f92 . 4) (f92 . 0))
# var=f96
    movl -20(%esp), %eax  # stack load f96
>>>>>>> fix-implicit-begins
# end emit-variable-ref
    movl %eax, 4(%ebp)
    movl -32(%esp), %eax
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    or   $1, %al
    add  $8, %ebp
# cons end
<<<<<<< HEAD
    mov %eax, -32(%esp)    # arg (cons (fxremainder f310883 10) f310882)
=======
    mov %eax, -32(%esp)    # arg (cons (fxremainder f95 10) f96)
>>>>>>> fix-implicit-begins
    movl -24(%esp), %edi   # load new closure to %edi
# emit-shift-args:  size=3   si=-24  delta=20
    mov -24(%esp), %ebx  # shift frame cell
    mov %ebx, -4(%esp)  # down to base
# emit-shift-args:  size=2   si=-28  delta=20
    mov -28(%esp), %ebx  # shift frame cell
    mov %ebx, -8(%esp)  # down to base
# emit-shift-args:  size=1   si=-32  delta=20
    mov -32(%esp), %ebx  # shift frame cell
    mov %ebx, -12(%esp)  # down to base
# emit-shift-args:  size=0   si=-36  delta=20
    movl $8,%eax   # save arg count
    jmp *-2(%edi)  # tail-funcall
     ret   # return thru stack
_L_285:
    .align 4,0x90
_L_282:
    movl -4(%esp), %ebx
    movl -8(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin)
# emit-begin
#   expr=(begin)
#   env=((f92 . 0))
# emit-expr (begin (closure (f98) (f92) (let ((f98 f98)) ((vector-ref f92 0) f98 ()))))
# emit-begin
#   expr=(begin (closure (f98) (f92) (let ((f98 f98)) ((vector-ref f92 0) f98 ()))))
#   env=((f92 . 0))
# emit-expr (closure (f98) (f92) (let ((f98 f98)) ((vector-ref f92 0) f98 ())))
# emit-closure
# si = -4
# env = ((f92 . 0))
# expr = (closure (f98) (f92) (let ((f98 f98)) ((vector-ref f92 0) f98 ())))
    movl $_L_298, 0(%ebp)  # closure label
# emit-variable-ref
# env=((f92 . 0))
# var=f92
    movl 0(%esp), %eax  # stack load f92
# end emit-variable-ref
   movl  %eax, 4(%ebp)  # f92
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $8, %ebp     # bump ebp
    jmp _L_299            # jump around closure body
_L_298:
# check argument count
    cmp $4,%eax
    je _L_300
# invoke error handler eh_argcount
    .extern mrc_eh$uargcount
    movl mrc_eh$uargcount, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_300:
# emit-tail-expr
# si=-12
# env=((f98 . -8) (f92 . 4) (f92 . 0))
# expr=(let ((f98 f98)) ((vector-ref f92 0) f98 ()))
# emit-tail-let
#  si   = -12
#  env  = ((f98 . -8) (f92 . 4) (f92 . 0))
#  bindings = ((f98 f98))
#  body = ((vector-ref f92 0) f98 ())
# emit-expr f98
# emit-variable-ref
# env=((f98 . -8) (f92 . 4) (f92 . 0))
# var=f98
    movl -8(%esp), %eax  # stack load f98
# end emit-variable-ref
    movl %eax, -12(%esp)  # stack save
# emit-tail-expr
# si=-16
# env=((f98 . -12) (f98 . -8) (f92 . 4) (f92 . 0))
# expr=((vector-ref f92 0) f98 ())
# emit-tail-funcall
#    si   =-16
#    env  = ((f98 . -12) (f98 . -8) (f92 . 4) (f92 . 0))
#    expr = (funcall (vector-ref f92 0) f98 ())
# emit-expr (vector-ref f92 0)
# emit-expr f92
# emit-variable-ref
# env=((f98 . -12) (f98 . -8) (f92 . 4) (f92 . 0))
# var=f92
    movl 2(%edi), %eax  # frame load f92
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_301
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_301:
    movl %eax, -16(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_302"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_302:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_304
    cmp  $0,%eax
    jge _L_303
_L_304:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_303:
    movl -16(%esp), %esi
    movl -1(%eax,%esi), %eax
   movl %eax,  -16(%esp)  # stash funcall-oper in next closure slot
# emit-expr f98
# emit-variable-ref
# env=((f98 . -12) (f98 . -8) (f92 . 4) (f92 . 0))
# var=f98
    movl -12(%esp), %eax  # stack load f98
# end emit-variable-ref
    mov %eax, -20(%esp)    # arg f98
# emit-expr ()
    movl $63, %eax     # immed ()
    mov %eax, -24(%esp)    # arg ()
    movl -16(%esp), %edi   # load new closure to %edi
# emit-shift-args:  size=3   si=-16  delta=12
    mov -16(%esp), %ebx  # shift frame cell
    mov %ebx, -4(%esp)  # down to base
# emit-shift-args:  size=2   si=-20  delta=12
    mov -20(%esp), %ebx  # shift frame cell
    mov %ebx, -8(%esp)  # down to base
# emit-shift-args:  size=1   si=-24  delta=12
    mov -24(%esp), %ebx  # shift frame cell
    mov %ebx, -12(%esp)  # down to base
# emit-shift-args:  size=0   si=-28  delta=12
    movl $8,%eax   # save arg count
    jmp *-2(%edi)  # tail-funcall
    .align 4,0x90
_L_299:
# emit-expr (begin)
# emit-begin
#   expr=(begin)
#   env=((f92 . 0))
     movl %eax, mrc_integer$m$glist
# == explicit-begins  ==>
# (let* ((write-stderr (lambda (s) (foreign-call "s_write" 2 s (string-length s)))) (write-errmsg (lambda (sym emsg) (begin (write-stderr "error:") (write-stderr (symbol->string sym)) (write-stderr ": ") (write-stderr emsg) (write-stderr "\n"))))) (lambda (sym emsg) (begin (write-errmsg sym emsg) (foreign-call "s_exit" 1))))
# == eliminate-let*  ==>
# (let ((write-stderr (lambda (s) (foreign-call "s_write" 2 s (string-length s))))) (let ((write-errmsg (lambda (sym emsg) (begin (write-stderr "error:") (write-stderr (symbol->string sym)) (write-stderr ": ") (write-stderr emsg) (write-stderr "\n"))))) (lambda (sym emsg) (begin (write-errmsg sym emsg) (foreign-call "s_exit" 1)))))
# == uniquify-variables  ==>
<<<<<<< HEAD
# (let ((f310886 (lambda (f310887) (foreign-call "s_write" 2 f310887 (string-length f310887))))) (let ((f310895 (lambda (f310897 f310896) (begin (f310886 "error:") (f310886 (symbol->string f310897)) (f310886 ": ") (f310886 f310896) (f310886 "\n"))))) (lambda (f310901 f310900) (begin (f310895 f310901 f310900) (foreign-call "s_exit" 1)))))
# == vectorize-letrec  ==>
# (let ((f310886 (lambda (f310887) (foreign-call "s_write" 2 f310887 (string-length f310887))))) (let ((f310895 (lambda (f310897 f310896) (begin (f310886 "error:") (f310886 (symbol->string f310897)) (f310886 ": ") (f310886 f310896) (f310886 "\n"))))) (lambda (f310901 f310900) (begin (f310895 f310901 f310900) (foreign-call "s_exit" 1)))))
# == eliminate-set!  ==>
# (let ((f310886 (lambda (f310887) (let ((f310887 f310887)) (foreign-call "s_write" 2 f310887 (string-length f310887)))))) (let ((f310895 (lambda (f310897 f310896) (let ((f310897 f310897) (f310896 f310896)) (begin (f310886 "error:") (f310886 (symbol->string f310897)) (f310886 ": ") (f310886 f310896) (f310886 "\n")))))) (lambda (f310901 f310900) (let ((f310901 f310901) (f310900 f310900)) (begin (f310895 f310901 f310900) (foreign-call "s_exit" 1))))))
# == close-free-variables  ==>
# (let ((f310886 (closure (f310887) () (let ((f310887 f310887)) (foreign-call "s_write" 2 f310887 (string-length f310887)))))) (let ((f310895 (closure (f310897 f310896) (f310886 f310886 f310886 f310886 f310886) (let ((f310897 f310897) (f310896 f310896)) (begin (f310886 "error:") (f310886 (symbol->string f310897)) (f310886 ": ") (f310886 f310896) (f310886 "\n")))))) (closure (f310901 f310900) (f310895) (let ((f310901 f310901) (f310900 f310900)) (begin (f310895 f310901 f310900) (foreign-call "s_exit" 1))))))
# == eliminate-quote  ==>
# (let ((f310886 (closure (f310887) () (let ((f310887 f310887)) (foreign-call "s_write" 2 f310887 (string-length f310887)))))) (let ((f310895 (closure (f310897 f310896) (f310886 f310886 f310886 f310886 f310886) (let ((f310897 f310897) (f310896 f310896)) (begin (f310886 "error:") (f310886 (symbol->string f310897)) (f310886 ": ") (f310886 f310896) (f310886 "\n")))))) (closure (f310901 f310900) (f310895) (let ((f310901 f310901) (f310900 f310900)) (begin (f310895 f310901 f310900) (foreign-call "s_exit" 1))))))
# == eliminate-when/unless  ==>
# (let ((f310886 (closure (f310887) () (let ((f310887 f310887)) (foreign-call "s_write" 2 f310887 (string-length f310887)))))) (let ((f310895 (closure (f310897 f310896) (f310886 f310886 f310886 f310886 f310886) (let ((f310897 f310897) (f310896 f310896)) (begin (f310886 "error:") (f310886 (symbol->string f310897)) (f310886 ": ") (f310886 f310896) (f310886 "\n")))))) (closure (f310901 f310900) (f310895) (let ((f310901 f310901) (f310900 f310900)) (begin (f310895 f310901 f310900) (foreign-call "s_exit" 1))))))
# == eliminate-cond  ==>
# (let ((f310886 (closure (f310887) () (let ((f310887 f310887)) (foreign-call "s_write" 2 f310887 (string-length f310887)))))) (let ((f310895 (closure (f310897 f310896) (f310886 f310886 f310886 f310886 f310886) (let ((f310897 f310897) (f310896 f310896)) (begin (f310886 "error:") (f310886 (symbol->string f310897)) (f310886 ": ") (f310886 f310896) (f310886 "\n")))))) (closure (f310901 f310900) (f310895) (let ((f310901 f310901) (f310900 f310900)) (begin (f310895 f310901 f310900) (foreign-call "s_exit" 1))))))
# == external-symbols  ==>
# (let ((f310886 (closure (f310887) () (let ((f310887 f310887)) (foreign-call "s_write" 2 f310887 (string-length f310887)))))) (let ((f310895 (closure (f310897 f310896) (f310886 f310886 f310886 f310886 f310886) (let ((f310897 f310897) (f310896 f310896)) (begin (f310886 "error:") (f310886 (symbol->string f310897)) (f310886 ": ") (f310886 f310896) (f310886 "\n")))))) (closure (f310901 f310900) (f310895) (let ((f310901 f310901) (f310900 f310900)) (begin (f310895 f310901 f310900) (foreign-call "s_exit" 1))))))
# emit-expr (let ((f310886 (closure (f310887) () (let ((f310887 f310887)) (foreign-call "s_write" 2 f310887 (string-length f310887)))))) (let ((f310895 (closure (f310897 f310896) (f310886 f310886 f310886 f310886 f310886) (let ((f310897 f310897) (f310896 f310896)) (begin (f310886 "error:") (f310886 (symbol->string f310897)) (f310886 ": ") (f310886 f310896) (f310886 "\n")))))) (closure (f310901 f310900) (f310895) (let ((f310901 f310901) (f310900 f310900)) (begin (f310895 f310901 f310900) (foreign-call "s_exit" 1))))))
# emit-let
#  si   = 0
#  env  = ()
#  bindings = ((f310886 (closure (f310887) () (let ((f310887 f310887)) (foreign-call "s_write" 2 f310887 (string-length f310887))))))
#  body = (let ((f310895 (closure (f310897 f310896) (f310886 f310886 f310886 f310886 f310886) (let ((f310897 f310897) (f310896 f310896)) (begin (f310886 "error:") (f310886 (symbol->string f310897)) (f310886 ": ") (f310886 f310896) (f310886 "\n")))))) (closure (f310901 f310900) (f310895) (let ((f310901 f310901) (f310900 f310900)) (begin (f310895 f310901 f310900) (foreign-call "s_exit" 1)))))
# emit-expr (closure (f310887) () (let ((f310887 f310887)) (foreign-call "s_write" 2 f310887 (string-length f310887))))
=======
# (let ((f99 (lambda (f100) (foreign-call "s_write" 2 f100 (string-length f100))))) (let ((f108 (lambda (f109 f110) (begin (f99 "error:") (f99 (symbol->string f109)) (f99 ": ") (f99 f110) (f99 "\n"))))) (lambda (f113 f114) (begin (f108 f113 f114) (foreign-call "s_exit" 1)))))
# == vectorize-letrec  ==>
# (let ((f99 (lambda (f100) (foreign-call "s_write" 2 f100 (string-length f100))))) (let ((f108 (lambda (f109 f110) (begin (f99 "error:") (f99 (symbol->string f109)) (f99 ": ") (f99 f110) (f99 "\n"))))) (lambda (f113 f114) (begin (f108 f113 f114) (foreign-call "s_exit" 1)))))
# == eliminate-set!  ==>
# (let ((f99 (lambda (f100) (let ((f100 f100)) (foreign-call "s_write" 2 f100 (string-length f100)))))) (let ((f108 (lambda (f109 f110) (let ((f109 f109) (f110 f110)) (begin (f99 "error:") (f99 (symbol->string f109)) (f99 ": ") (f99 f110) (f99 "\n")))))) (lambda (f113 f114) (let ((f113 f113) (f114 f114)) (begin (f108 f113 f114) (foreign-call "s_exit" 1))))))
# == close-free-variables  ==>
# (let ((f99 (closure (f100) () (let ((f100 f100)) (foreign-call "s_write" 2 f100 (string-length f100)))))) (let ((f108 (closure (f109 f110) (f99 f99 f99 f99 f99) (let ((f109 f109) (f110 f110)) (begin (f99 "error:") (f99 (symbol->string f109)) (f99 ": ") (f99 f110) (f99 "\n")))))) (closure (f113 f114) (f108) (let ((f113 f113) (f114 f114)) (begin (f108 f113 f114) (foreign-call "s_exit" 1))))))
# == eliminate-quote  ==>
# (let ((f99 (closure (f100) () (let ((f100 f100)) (foreign-call "s_write" 2 f100 (string-length f100)))))) (let ((f108 (closure (f109 f110) (f99 f99 f99 f99 f99) (let ((f109 f109) (f110 f110)) (begin (f99 "error:") (f99 (symbol->string f109)) (f99 ": ") (f99 f110) (f99 "\n")))))) (closure (f113 f114) (f108) (let ((f113 f113) (f114 f114)) (begin (f108 f113 f114) (foreign-call "s_exit" 1))))))
# == eliminate-when/unless  ==>
# (let ((f99 (closure (f100) () (let ((f100 f100)) (foreign-call "s_write" 2 f100 (string-length f100)))))) (let ((f108 (closure (f109 f110) (f99 f99 f99 f99 f99) (let ((f109 f109) (f110 f110)) (begin (f99 "error:") (f99 (symbol->string f109)) (f99 ": ") (f99 f110) (f99 "\n")))))) (closure (f113 f114) (f108) (let ((f113 f113) (f114 f114)) (begin (f108 f113 f114) (foreign-call "s_exit" 1))))))
# == eliminate-cond  ==>
# (let ((f99 (closure (f100) () (let ((f100 f100)) (foreign-call "s_write" 2 f100 (string-length f100)))))) (let ((f108 (closure (f109 f110) (f99 f99 f99 f99 f99) (let ((f109 f109) (f110 f110)) (begin (f99 "error:") (f99 (symbol->string f109)) (f99 ": ") (f99 f110) (f99 "\n")))))) (closure (f113 f114) (f108) (let ((f113 f113) (f114 f114)) (begin (f108 f113 f114) (foreign-call "s_exit" 1))))))
# == external-symbols  ==>
# (let ((f99 (closure (f100) () (let ((f100 f100)) (foreign-call "s_write" 2 f100 (string-length f100)))))) (let ((f108 (closure (f109 f110) (f99 f99 f99 f99 f99) (let ((f109 f109) (f110 f110)) (begin (f99 "error:") (f99 (symbol->string f109)) (f99 ": ") (f99 f110) (f99 "\n")))))) (closure (f113 f114) (f108) (let ((f113 f113) (f114 f114)) (begin (f108 f113 f114) (foreign-call "s_exit" 1))))))
# emit-expr (let ((f99 (closure (f100) () (let ((f100 f100)) (foreign-call "s_write" 2 f100 (string-length f100)))))) (let ((f108 (closure (f109 f110) (f99 f99 f99 f99 f99) (let ((f109 f109) (f110 f110)) (begin (f99 "error:") (f99 (symbol->string f109)) (f99 ": ") (f99 f110) (f99 "\n")))))) (closure (f113 f114) (f108) (let ((f113 f113) (f114 f114)) (begin (f108 f113 f114) (foreign-call "s_exit" 1))))))
# emit-let
#  si   = 0
#  env  = ()
#  bindings = ((f99 (closure (f100) () (let ((f100 f100)) (foreign-call "s_write" 2 f100 (string-length f100))))))
#  body = (let ((f108 (closure (f109 f110) (f99 f99 f99 f99 f99) (let ((f109 f109) (f110 f110)) (begin (f99 "error:") (f99 (symbol->string f109)) (f99 ": ") (f99 f110) (f99 "\n")))))) (closure (f113 f114) (f108) (let ((f113 f113) (f114 f114)) (begin (f108 f113 f114) (foreign-call "s_exit" 1)))))
# emit-expr (closure (f100) () (let ((f100 f100)) (foreign-call "s_write" 2 f100 (string-length f100))))
>>>>>>> fix-implicit-begins
# emit-closure
# si = 0
# env = ()
# expr = (closure (f100) () (let ((f100 f100)) (foreign-call "s_write" 2 f100 (string-length f100))))
    movl $_L_305, 0(%ebp)  # closure label
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $8, %ebp     # bump ebp
    jmp _L_306            # jump around closure body
_L_305:
# check argument count
    cmp $4,%eax
    je _L_307
# invoke error handler eh_argcount
    .extern mrc_eh$uargcount
    movl mrc_eh$uargcount, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_307:
# emit-tail-expr
# si=-12
# env=((f100 . -8))
# expr=(let ((f100 f100)) (foreign-call "s_write" 2 f100 (string-length f100)))
# emit-tail-let
#  si   = -12
#  env  = ((f100 . -8))
#  bindings = ((f100 f100))
#  body = (foreign-call "s_write" 2 f100 (string-length f100))
# emit-expr f100
# emit-variable-ref
# env=((f100 . -8))
# var=f100
    movl -8(%esp), %eax  # stack load f100
# end emit-variable-ref
    movl %eax, -12(%esp)  # stack save
# emit-tail-expr
# si=-16
# env=((f100 . -12) (f100 . -8))
# expr=(foreign-call "s_write" 2 f100 (string-length f100))
    movl %ecx,-16(%esp)
    movl %esp,-20(%esp)
# emit-expr (string-length f100)
# emit-expr f100
# emit-variable-ref
# env=((f100 . -12) (f100 . -8))
# var=f100
    movl -12(%esp), %eax  # stack load f100
# end emit-variable-ref
# check the argument is a string
    movl %eax,%ebx
    and $7, %bl
    cmp $6, %bl
    je _L_308
# invoke error handler eh_string
    .extern mrc_eh$ustring
    movl mrc_eh$ustring, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $160,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_308:
    movl -6(%eax), %eax
    movl %eax, -24(%esp)
# emit-expr f100
# emit-variable-ref
# env=((f100 . -12) (f100 . -8))
# var=f100
    movl -12(%esp), %eax  # stack load f100
# end emit-variable-ref
    movl %eax, -28(%esp)
# emit-expr 2
    movl $8, %eax     # immed 2
    movl %eax, -32(%esp)
    leal -32(%esp),%edi
    movl %edi,%esi
    andl $-16,%esi
    movl 0(%edi),%eax
    movl %eax,0(%esi)
    movl 4(%edi),%eax
    movl %eax,4(%esi)
    movl 8(%edi),%eax
    movl %eax,8(%esi)
    movl 12(%edi),%eax
    movl %eax,12(%esi)
    movl %esi,%esp
    .extern _s_write
    call _s_write
    movl 12(%esi),%esp
    movl -16(%esp),%ecx
     ret
    .align 4,0x90
_L_306:
    movl %eax, 0(%esp)  # stack save
<<<<<<< HEAD
# emit-expr (let ((f310895 (closure (f310897 f310896) (f310886 f310886 f310886 f310886 f310886) (let ((f310897 f310897) (f310896 f310896)) (begin (f310886 "error:") (f310886 (symbol->string f310897)) (f310886 ": ") (f310886 f310896) (f310886 "\n")))))) (closure (f310901 f310900) (f310895) (let ((f310901 f310901) (f310900 f310900)) (begin (f310895 f310901 f310900) (foreign-call "s_exit" 1)))))
# emit-let
#  si   = -4
#  env  = ((f310886 . 0))
#  bindings = ((f310895 (closure (f310897 f310896) (f310886 f310886 f310886 f310886 f310886) (let ((f310897 f310897) (f310896 f310896)) (begin (f310886 "error:") (f310886 (symbol->string f310897)) (f310886 ": ") (f310886 f310896) (f310886 "\n"))))))
#  body = (closure (f310901 f310900) (f310895) (let ((f310901 f310901) (f310900 f310900)) (begin (f310895 f310901 f310900) (foreign-call "s_exit" 1))))
# emit-expr (closure (f310897 f310896) (f310886 f310886 f310886 f310886 f310886) (let ((f310897 f310897) (f310896 f310896)) (begin (f310886 "error:") (f310886 (symbol->string f310897)) (f310886 ": ") (f310886 f310896) (f310886 "\n"))))
# emit-closure
# si = -4
# env = ((f310886 . 0))
# expr = (closure (f310897 f310896) (f310886 f310886 f310886 f310886 f310886) (let ((f310897 f310897) (f310896 f310896)) (begin (f310886 "error:") (f310886 (symbol->string f310897)) (f310886 ": ") (f310886 f310896) (f310886 "\n"))))
    movl $_L_1883908, 0(%ebp)  # closure label
=======
# emit-expr (let ((f108 (closure (f109 f110) (f99 f99 f99 f99 f99) (let ((f109 f109) (f110 f110)) (begin (f99 "error:") (f99 (symbol->string f109)) (f99 ": ") (f99 f110) (f99 "\n")))))) (closure (f113 f114) (f108) (let ((f113 f113) (f114 f114)) (begin (f108 f113 f114) (foreign-call "s_exit" 1)))))
# emit-let
#  si   = -4
#  env  = ((f99 . 0))
#  bindings = ((f108 (closure (f109 f110) (f99 f99 f99 f99 f99) (let ((f109 f109) (f110 f110)) (begin (f99 "error:") (f99 (symbol->string f109)) (f99 ": ") (f99 f110) (f99 "\n"))))))
#  body = (closure (f113 f114) (f108) (let ((f113 f113) (f114 f114)) (begin (f108 f113 f114) (foreign-call "s_exit" 1))))
# emit-expr (closure (f109 f110) (f99 f99 f99 f99 f99) (let ((f109 f109) (f110 f110)) (begin (f99 "error:") (f99 (symbol->string f109)) (f99 ": ") (f99 f110) (f99 "\n"))))
# emit-closure
# si = -4
# env = ((f99 . 0))
# expr = (closure (f109 f110) (f99 f99 f99 f99 f99) (let ((f109 f109) (f110 f110)) (begin (f99 "error:") (f99 (symbol->string f109)) (f99 ": ") (f99 f110) (f99 "\n"))))
    movl $_L_309, 0(%ebp)  # closure label
>>>>>>> fix-implicit-begins
# emit-variable-ref
# env=((f99 . 0))
# var=f99
    movl 0(%esp), %eax  # stack load f99
# end emit-variable-ref
   movl  %eax, 4(%ebp)  # f99
# emit-variable-ref
# env=((f99 . 0))
# var=f99
    movl 0(%esp), %eax  # stack load f99
# end emit-variable-ref
   movl  %eax, 8(%ebp)  # f99
# emit-variable-ref
# env=((f99 . 0))
# var=f99
    movl 0(%esp), %eax  # stack load f99
# end emit-variable-ref
   movl  %eax, 12(%ebp)  # f99
# emit-variable-ref
# env=((f99 . 0))
# var=f99
    movl 0(%esp), %eax  # stack load f99
# end emit-variable-ref
   movl  %eax, 16(%ebp)  # f99
# emit-variable-ref
# env=((f99 . 0))
# var=f99
    movl 0(%esp), %eax  # stack load f99
# end emit-variable-ref
   movl  %eax, 20(%ebp)  # f99
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $24, %ebp     # bump ebp
    jmp _L_310            # jump around closure body
_L_309:
# check argument count
    cmp $8,%eax
    je _L_311
# invoke error handler eh_argcount
    .extern mrc_eh$uargcount
    movl mrc_eh$uargcount, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_311:
# emit-tail-expr
# si=-16
<<<<<<< HEAD
# env=((f310896 . -12) (f310897 . -8) (f310886 . 20) (f310886 . 16) (f310886 . 12) (f310886 . 8) (f310886 . 4) (f310886 . 0))
# expr=(let ((f310897 f310897) (f310896 f310896)) (begin (f310886 "error:") (f310886 (symbol->string f310897)) (f310886 ": ") (f310886 f310896) (f310886 "\n")))
# emit-tail-let
#  si   = -16
#  env  = ((f310896 . -12) (f310897 . -8) (f310886 . 20) (f310886 . 16) (f310886 . 12) (f310886 . 8) (f310886 . 4) (f310886 . 0))
#  bindings = ((f310897 f310897) (f310896 f310896))
#  body = (begin (f310886 "error:") (f310886 (symbol->string f310897)) (f310886 ": ") (f310886 f310896) (f310886 "\n"))
# emit-expr f310897
# emit-variable-ref
# env=((f310896 . -12) (f310897 . -8) (f310886 . 20) (f310886 . 16) (f310886 . 12) (f310886 . 8) (f310886 . 4) (f310886 . 0))
# var=f310897
    movl -8(%esp), %eax  # stack load f310897
# end emit-variable-ref
    movl %eax, -16(%esp)  # stack save
# emit-expr f310896
# emit-variable-ref
# env=((f310896 . -12) (f310897 . -8) (f310886 . 20) (f310886 . 16) (f310886 . 12) (f310886 . 8) (f310886 . 4) (f310886 . 0))
# var=f310896
    movl -12(%esp), %eax  # stack load f310896
=======
# env=((f110 . -12) (f109 . -8) (f99 . 20) (f99 . 16) (f99 . 12) (f99 . 8) (f99 . 4) (f99 . 0))
# expr=(let ((f109 f109) (f110 f110)) (begin (f99 "error:") (f99 (symbol->string f109)) (f99 ": ") (f99 f110) (f99 "\n")))
# emit-tail-let
#  si   = -16
#  env  = ((f110 . -12) (f109 . -8) (f99 . 20) (f99 . 16) (f99 . 12) (f99 . 8) (f99 . 4) (f99 . 0))
#  bindings = ((f109 f109) (f110 f110))
#  body = (begin (f99 "error:") (f99 (symbol->string f109)) (f99 ": ") (f99 f110) (f99 "\n"))
# emit-expr f109
# emit-variable-ref
# env=((f110 . -12) (f109 . -8) (f99 . 20) (f99 . 16) (f99 . 12) (f99 . 8) (f99 . 4) (f99 . 0))
# var=f109
    movl -8(%esp), %eax  # stack load f109
# end emit-variable-ref
    movl %eax, -16(%esp)  # stack save
# emit-expr f110
# emit-variable-ref
# env=((f110 . -12) (f109 . -8) (f99 . 20) (f99 . 16) (f99 . 12) (f99 . 8) (f99 . 4) (f99 . 0))
# var=f110
    movl -12(%esp), %eax  # stack load f110
>>>>>>> fix-implicit-begins
# end emit-variable-ref
    movl %eax, -20(%esp)  # stack save
# emit-tail-expr
# si=-24
<<<<<<< HEAD
# env=((f310896 . -20) (f310897 . -16) (f310896 . -12) (f310897 . -8) (f310886 . 20) (f310886 . 16) (f310886 . 12) (f310886 . 8) (f310886 . 4) (f310886 . 0))
# expr=(begin (f310886 "error:") (f310886 (symbol->string f310897)) (f310886 ": ") (f310886 f310896) (f310886 "\n"))
# tail-begin (begin (f310886 "error:") (f310886 (symbol->string f310897)) (f310886 ": ") (f310886 f310896) (f310886 "\n"))
#   env=((f310896 . -20) (f310897 . -16) (f310896 . -12) (f310897 . -8) (f310886 . 20) (f310886 . 16) (f310886 . 12) (f310886 . 8) (f310886 . 4) (f310886 . 0))
# emit-expr (f310886 "error:")
# funcall
#    si   =-24
#    env  = ((f310896 . -20) (f310897 . -16) (f310896 . -12) (f310897 . -8) (f310886 . 20) (f310886 . 16) (f310886 . 12) (f310886 . 8) (f310886 . 4) (f310886 . 0))
#    expr = (funcall f310886 "error:")
# emit-expr f310886
# emit-variable-ref
# env=((f310896 . -20) (f310897 . -16) (f310896 . -12) (f310897 . -8) (f310886 . 20) (f310886 . 16) (f310886 . 12) (f310886 . 8) (f310886 . 4) (f310886 . 0))
# var=f310886
    movl 18(%edi), %eax  # frame load f310886
=======
# env=((f110 . -20) (f109 . -16) (f110 . -12) (f109 . -8) (f99 . 20) (f99 . 16) (f99 . 12) (f99 . 8) (f99 . 4) (f99 . 0))
# expr=(begin (f99 "error:") (f99 (symbol->string f109)) (f99 ": ") (f99 f110) (f99 "\n"))
# tail-begin (begin (f99 "error:") (f99 (symbol->string f109)) (f99 ": ") (f99 f110) (f99 "\n"))
#   env=((f110 . -20) (f109 . -16) (f110 . -12) (f109 . -8) (f99 . 20) (f99 . 16) (f99 . 12) (f99 . 8) (f99 . 4) (f99 . 0))
# emit-expr (f99 "error:")
# funcall
#    si   =-24
#    env  = ((f110 . -20) (f109 . -16) (f110 . -12) (f109 . -8) (f99 . 20) (f99 . 16) (f99 . 12) (f99 . 8) (f99 . 4) (f99 . 0))
#    expr = (funcall f99 "error:")
# emit-expr f99
# emit-variable-ref
# env=((f110 . -20) (f109 . -16) (f110 . -12) (f109 . -8) (f99 . 20) (f99 . 16) (f99 . 12) (f99 . 8) (f99 . 4) (f99 . 0))
# var=f99
    movl 18(%edi), %eax  # frame load f99
>>>>>>> fix-implicit-begins
# end emit-variable-ref
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_312"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_312":
   movl %eax,  -32(%esp)  # stash funcall-oper in closure slot
# emit-expr "error:"
# string literal
    jmp _L_314
    .align 8,0x90
_L_313 :
    .int 24
    .ascii "error:"
_L_314:
    movl $_L_313, %eax
    orl $6, %eax
    mov %eax, -36(%esp)  # arg error:
    movl -32(%esp), %edi   # load new closure to %edi
    add $-24, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $24, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
# emit-tail-expr
# si=-24
<<<<<<< HEAD
# env=((f310896 . -20) (f310897 . -16) (f310896 . -12) (f310897 . -8) (f310886 . 20) (f310886 . 16) (f310886 . 12) (f310886 . 8) (f310886 . 4) (f310886 . 0))
# expr=(begin (f310886 (symbol->string f310897)) (f310886 ": ") (f310886 f310896) (f310886 "\n"))
# tail-begin (begin (f310886 (symbol->string f310897)) (f310886 ": ") (f310886 f310896) (f310886 "\n"))
#   env=((f310896 . -20) (f310897 . -16) (f310896 . -12) (f310897 . -8) (f310886 . 20) (f310886 . 16) (f310886 . 12) (f310886 . 8) (f310886 . 4) (f310886 . 0))
# emit-expr (f310886 (symbol->string f310897))
# funcall
#    si   =-24
#    env  = ((f310896 . -20) (f310897 . -16) (f310896 . -12) (f310897 . -8) (f310886 . 20) (f310886 . 16) (f310886 . 12) (f310886 . 8) (f310886 . 4) (f310886 . 0))
#    expr = (funcall f310886 (symbol->string f310897))
# emit-expr f310886
# emit-variable-ref
# env=((f310896 . -20) (f310897 . -16) (f310896 . -12) (f310897 . -8) (f310886 . 20) (f310886 . 16) (f310886 . 12) (f310886 . 8) (f310886 . 4) (f310886 . 0))
# var=f310886
    movl 18(%edi), %eax  # frame load f310886
=======
# env=((f110 . -20) (f109 . -16) (f110 . -12) (f109 . -8) (f99 . 20) (f99 . 16) (f99 . 12) (f99 . 8) (f99 . 4) (f99 . 0))
# expr=(begin (f99 (symbol->string f109)) (f99 ": ") (f99 f110) (f99 "\n"))
# tail-begin (begin (f99 (symbol->string f109)) (f99 ": ") (f99 f110) (f99 "\n"))
#   env=((f110 . -20) (f109 . -16) (f110 . -12) (f109 . -8) (f99 . 20) (f99 . 16) (f99 . 12) (f99 . 8) (f99 . 4) (f99 . 0))
# emit-expr (f99 (symbol->string f109))
# funcall
#    si   =-24
#    env  = ((f110 . -20) (f109 . -16) (f110 . -12) (f109 . -8) (f99 . 20) (f99 . 16) (f99 . 12) (f99 . 8) (f99 . 4) (f99 . 0))
#    expr = (funcall f99 (symbol->string f109))
# emit-expr f99
# emit-variable-ref
# env=((f110 . -20) (f109 . -16) (f110 . -12) (f109 . -8) (f99 . 20) (f99 . 16) (f99 . 12) (f99 . 8) (f99 . 4) (f99 . 0))
# var=f99
    movl 18(%edi), %eax  # frame load f99
>>>>>>> fix-implicit-begins
# end emit-variable-ref
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_315"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_315":
   movl %eax,  -32(%esp)  # stash funcall-oper in closure slot
<<<<<<< HEAD
# emit-expr (symbol->string f310897)
# symbol->string f310897
# emit-expr f310897
# emit-variable-ref
# env=((f310896 . -20) (f310897 . -16) (f310896 . -12) (f310897 . -8) (f310886 . 20) (f310886 . 16) (f310886 . 12) (f310886 . 8) (f310886 . 4) (f310886 . 0))
# var=f310897
    movl -16(%esp), %eax  # stack load f310897
# end emit-variable-ref
    movl -3(%eax), %eax
    mov %eax, -36(%esp)  # arg (symbol->string f310897)
=======
# emit-expr (symbol->string f109)
# symbol->string f109
# emit-expr f109
# emit-variable-ref
# env=((f110 . -20) (f109 . -16) (f110 . -12) (f109 . -8) (f99 . 20) (f99 . 16) (f99 . 12) (f99 . 8) (f99 . 4) (f99 . 0))
# var=f109
    movl -16(%esp), %eax  # stack load f109
# end emit-variable-ref
    movl -3(%eax), %eax
    mov %eax, -36(%esp)  # arg (symbol->string f109)
>>>>>>> fix-implicit-begins
    movl -32(%esp), %edi   # load new closure to %edi
    add $-24, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $24, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
# emit-tail-expr
# si=-24
<<<<<<< HEAD
# env=((f310896 . -20) (f310897 . -16) (f310896 . -12) (f310897 . -8) (f310886 . 20) (f310886 . 16) (f310886 . 12) (f310886 . 8) (f310886 . 4) (f310886 . 0))
# expr=(begin (f310886 ": ") (f310886 f310896) (f310886 "\n"))
# tail-begin (begin (f310886 ": ") (f310886 f310896) (f310886 "\n"))
#   env=((f310896 . -20) (f310897 . -16) (f310896 . -12) (f310897 . -8) (f310886 . 20) (f310886 . 16) (f310886 . 12) (f310886 . 8) (f310886 . 4) (f310886 . 0))
# emit-expr (f310886 ": ")
# funcall
#    si   =-24
#    env  = ((f310896 . -20) (f310897 . -16) (f310896 . -12) (f310897 . -8) (f310886 . 20) (f310886 . 16) (f310886 . 12) (f310886 . 8) (f310886 . 4) (f310886 . 0))
#    expr = (funcall f310886 ": ")
# emit-expr f310886
# emit-variable-ref
# env=((f310896 . -20) (f310897 . -16) (f310896 . -12) (f310897 . -8) (f310886 . 20) (f310886 . 16) (f310886 . 12) (f310886 . 8) (f310886 . 4) (f310886 . 0))
# var=f310886
    movl 18(%edi), %eax  # frame load f310886
=======
# env=((f110 . -20) (f109 . -16) (f110 . -12) (f109 . -8) (f99 . 20) (f99 . 16) (f99 . 12) (f99 . 8) (f99 . 4) (f99 . 0))
# expr=(begin (f99 ": ") (f99 f110) (f99 "\n"))
# tail-begin (begin (f99 ": ") (f99 f110) (f99 "\n"))
#   env=((f110 . -20) (f109 . -16) (f110 . -12) (f109 . -8) (f99 . 20) (f99 . 16) (f99 . 12) (f99 . 8) (f99 . 4) (f99 . 0))
# emit-expr (f99 ": ")
# funcall
#    si   =-24
#    env  = ((f110 . -20) (f109 . -16) (f110 . -12) (f109 . -8) (f99 . 20) (f99 . 16) (f99 . 12) (f99 . 8) (f99 . 4) (f99 . 0))
#    expr = (funcall f99 ": ")
# emit-expr f99
# emit-variable-ref
# env=((f110 . -20) (f109 . -16) (f110 . -12) (f109 . -8) (f99 . 20) (f99 . 16) (f99 . 12) (f99 . 8) (f99 . 4) (f99 . 0))
# var=f99
    movl 18(%edi), %eax  # frame load f99
>>>>>>> fix-implicit-begins
# end emit-variable-ref
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_316"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_316":
   movl %eax,  -32(%esp)  # stash funcall-oper in closure slot
# emit-expr ": "
# string literal
    jmp _L_318
    .align 8,0x90
_L_317 :
    .int 8
    .ascii ": "
_L_318:
    movl $_L_317, %eax
    orl $6, %eax
    mov %eax, -36(%esp)  # arg : 
    movl -32(%esp), %edi   # load new closure to %edi
    add $-24, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $24, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
# emit-tail-expr
# si=-24
<<<<<<< HEAD
# env=((f310896 . -20) (f310897 . -16) (f310896 . -12) (f310897 . -8) (f310886 . 20) (f310886 . 16) (f310886 . 12) (f310886 . 8) (f310886 . 4) (f310886 . 0))
# expr=(begin (f310886 f310896) (f310886 "\n"))
# tail-begin (begin (f310886 f310896) (f310886 "\n"))
#   env=((f310896 . -20) (f310897 . -16) (f310896 . -12) (f310897 . -8) (f310886 . 20) (f310886 . 16) (f310886 . 12) (f310886 . 8) (f310886 . 4) (f310886 . 0))
# emit-expr (f310886 f310896)
# funcall
#    si   =-24
#    env  = ((f310896 . -20) (f310897 . -16) (f310896 . -12) (f310897 . -8) (f310886 . 20) (f310886 . 16) (f310886 . 12) (f310886 . 8) (f310886 . 4) (f310886 . 0))
#    expr = (funcall f310886 f310896)
# emit-expr f310886
# emit-variable-ref
# env=((f310896 . -20) (f310897 . -16) (f310896 . -12) (f310897 . -8) (f310886 . 20) (f310886 . 16) (f310886 . 12) (f310886 . 8) (f310886 . 4) (f310886 . 0))
# var=f310886
    movl 18(%edi), %eax  # frame load f310886
=======
# env=((f110 . -20) (f109 . -16) (f110 . -12) (f109 . -8) (f99 . 20) (f99 . 16) (f99 . 12) (f99 . 8) (f99 . 4) (f99 . 0))
# expr=(begin (f99 f110) (f99 "\n"))
# tail-begin (begin (f99 f110) (f99 "\n"))
#   env=((f110 . -20) (f109 . -16) (f110 . -12) (f109 . -8) (f99 . 20) (f99 . 16) (f99 . 12) (f99 . 8) (f99 . 4) (f99 . 0))
# emit-expr (f99 f110)
# funcall
#    si   =-24
#    env  = ((f110 . -20) (f109 . -16) (f110 . -12) (f109 . -8) (f99 . 20) (f99 . 16) (f99 . 12) (f99 . 8) (f99 . 4) (f99 . 0))
#    expr = (funcall f99 f110)
# emit-expr f99
# emit-variable-ref
# env=((f110 . -20) (f109 . -16) (f110 . -12) (f109 . -8) (f99 . 20) (f99 . 16) (f99 . 12) (f99 . 8) (f99 . 4) (f99 . 0))
# var=f99
    movl 18(%edi), %eax  # frame load f99
>>>>>>> fix-implicit-begins
# end emit-variable-ref
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_319"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_319":
   movl %eax,  -32(%esp)  # stash funcall-oper in closure slot
<<<<<<< HEAD
# emit-expr f310896
# emit-variable-ref
# env=((f310896 . -20) (f310897 . -16) (f310896 . -12) (f310897 . -8) (f310886 . 20) (f310886 . 16) (f310886 . 12) (f310886 . 8) (f310886 . 4) (f310886 . 0))
# var=f310896
    movl -20(%esp), %eax  # stack load f310896
# end emit-variable-ref
    mov %eax, -36(%esp)  # arg f310896
=======
# emit-expr f110
# emit-variable-ref
# env=((f110 . -20) (f109 . -16) (f110 . -12) (f109 . -8) (f99 . 20) (f99 . 16) (f99 . 12) (f99 . 8) (f99 . 4) (f99 . 0))
# var=f110
    movl -20(%esp), %eax  # stack load f110
# end emit-variable-ref
    mov %eax, -36(%esp)  # arg f110
>>>>>>> fix-implicit-begins
    movl -32(%esp), %edi   # load new closure to %edi
    add $-24, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $24, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
# emit-tail-expr
# si=-24
<<<<<<< HEAD
# env=((f310896 . -20) (f310897 . -16) (f310896 . -12) (f310897 . -8) (f310886 . 20) (f310886 . 16) (f310886 . 12) (f310886 . 8) (f310886 . 4) (f310886 . 0))
# expr=(begin (f310886 "\n"))
# tail-begin (begin (f310886 "\n"))
#   env=((f310896 . -20) (f310897 . -16) (f310896 . -12) (f310897 . -8) (f310886 . 20) (f310886 . 16) (f310886 . 12) (f310886 . 8) (f310886 . 4) (f310886 . 0))
# emit-tail-expr
# si=-24
# env=((f310896 . -20) (f310897 . -16) (f310896 . -12) (f310897 . -8) (f310886 . 20) (f310886 . 16) (f310886 . 12) (f310886 . 8) (f310886 . 4) (f310886 . 0))
# expr=(f310886 "\n")
# emit-tail-funcall
#    si   =-24
#    env  = ((f310896 . -20) (f310897 . -16) (f310896 . -12) (f310897 . -8) (f310886 . 20) (f310886 . 16) (f310886 . 12) (f310886 . 8) (f310886 . 4) (f310886 . 0))
#    expr = (funcall f310886 "\n")
# emit-expr f310886
# emit-variable-ref
# env=((f310896 . -20) (f310897 . -16) (f310896 . -12) (f310897 . -8) (f310886 . 20) (f310886 . 16) (f310886 . 12) (f310886 . 8) (f310886 . 4) (f310886 . 0))
# var=f310886
    movl 18(%edi), %eax  # frame load f310886
=======
# env=((f110 . -20) (f109 . -16) (f110 . -12) (f109 . -8) (f99 . 20) (f99 . 16) (f99 . 12) (f99 . 8) (f99 . 4) (f99 . 0))
# expr=(begin (f99 "\n"))
# tail-begin (begin (f99 "\n"))
#   env=((f110 . -20) (f109 . -16) (f110 . -12) (f109 . -8) (f99 . 20) (f99 . 16) (f99 . 12) (f99 . 8) (f99 . 4) (f99 . 0))
# emit-tail-expr
# si=-24
# env=((f110 . -20) (f109 . -16) (f110 . -12) (f109 . -8) (f99 . 20) (f99 . 16) (f99 . 12) (f99 . 8) (f99 . 4) (f99 . 0))
# expr=(f99 "\n")
# emit-tail-funcall
#    si   =-24
#    env  = ((f110 . -20) (f109 . -16) (f110 . -12) (f109 . -8) (f99 . 20) (f99 . 16) (f99 . 12) (f99 . 8) (f99 . 4) (f99 . 0))
#    expr = (funcall f99 "\n")
# emit-expr f99
# emit-variable-ref
# env=((f110 . -20) (f109 . -16) (f110 . -12) (f109 . -8) (f99 . 20) (f99 . 16) (f99 . 12) (f99 . 8) (f99 . 4) (f99 . 0))
# var=f99
    movl 18(%edi), %eax  # frame load f99
>>>>>>> fix-implicit-begins
# end emit-variable-ref
   movl %eax,  -24(%esp)  # stash funcall-oper in next closure slot
# emit-expr "\n"
# string literal
    jmp _L_321
    .align 8,0x90
_L_320 :
    .int 4
    .ascii "\n"
_L_321:
    movl $_L_320, %eax
    orl $6, %eax
    mov %eax, -28(%esp)    # arg 

    movl -24(%esp), %edi   # load new closure to %edi
# emit-shift-args:  size=2   si=-24  delta=20
    mov -24(%esp), %ebx  # shift frame cell
    mov %ebx, -4(%esp)  # down to base
# emit-shift-args:  size=1   si=-28  delta=20
    mov -28(%esp), %ebx  # shift frame cell
    mov %ebx, -8(%esp)  # down to base
# emit-shift-args:  size=0   si=-32  delta=20
    movl $4,%eax   # save arg count
    jmp *-2(%edi)  # tail-funcall
     ret   # return thru stack
    .align 4,0x90
_L_310:
    movl %eax, -4(%esp)  # stack save
<<<<<<< HEAD
# emit-expr (closure (f310901 f310900) (f310895) (let ((f310901 f310901) (f310900 f310900)) (begin (f310895 f310901 f310900) (foreign-call "s_exit" 1))))
# emit-closure
# si = -8
# env = ((f310895 . -4) (f310886 . 0))
# expr = (closure (f310901 f310900) (f310895) (let ((f310901 f310901) (f310900 f310900)) (begin (f310895 f310901 f310900) (foreign-call "s_exit" 1))))
    movl $_L_1883921, 0(%ebp)  # closure label
=======
# emit-expr (closure (f113 f114) (f108) (let ((f113 f113) (f114 f114)) (begin (f108 f113 f114) (foreign-call "s_exit" 1))))
# emit-closure
# si = -8
# env = ((f108 . -4) (f99 . 0))
# expr = (closure (f113 f114) (f108) (let ((f113 f113) (f114 f114)) (begin (f108 f113 f114) (foreign-call "s_exit" 1))))
    movl $_L_322, 0(%ebp)  # closure label
>>>>>>> fix-implicit-begins
# emit-variable-ref
# env=((f108 . -4) (f99 . 0))
# var=f108
    movl -4(%esp), %eax  # stack load f108
# end emit-variable-ref
   movl  %eax, 4(%ebp)  # f108
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $8, %ebp     # bump ebp
    jmp _L_323            # jump around closure body
_L_322:
# check argument count
    cmp $8,%eax
    je _L_324
# invoke error handler eh_argcount
    .extern mrc_eh$uargcount
    movl mrc_eh$uargcount, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_324:
# emit-tail-expr
# si=-16
<<<<<<< HEAD
# env=((f310900 . -12) (f310901 . -8) (f310895 . 4) (f310895 . -4) (f310886 . 0))
# expr=(let ((f310901 f310901) (f310900 f310900)) (begin (f310895 f310901 f310900) (foreign-call "s_exit" 1)))
# emit-tail-let
#  si   = -16
#  env  = ((f310900 . -12) (f310901 . -8) (f310895 . 4) (f310895 . -4) (f310886 . 0))
#  bindings = ((f310901 f310901) (f310900 f310900))
#  body = (begin (f310895 f310901 f310900) (foreign-call "s_exit" 1))
# emit-expr f310901
# emit-variable-ref
# env=((f310900 . -12) (f310901 . -8) (f310895 . 4) (f310895 . -4) (f310886 . 0))
# var=f310901
    movl -8(%esp), %eax  # stack load f310901
# end emit-variable-ref
    movl %eax, -16(%esp)  # stack save
# emit-expr f310900
# emit-variable-ref
# env=((f310900 . -12) (f310901 . -8) (f310895 . 4) (f310895 . -4) (f310886 . 0))
# var=f310900
    movl -12(%esp), %eax  # stack load f310900
=======
# env=((f114 . -12) (f113 . -8) (f108 . 4) (f108 . -4) (f99 . 0))
# expr=(let ((f113 f113) (f114 f114)) (begin (f108 f113 f114) (foreign-call "s_exit" 1)))
# emit-tail-let
#  si   = -16
#  env  = ((f114 . -12) (f113 . -8) (f108 . 4) (f108 . -4) (f99 . 0))
#  bindings = ((f113 f113) (f114 f114))
#  body = (begin (f108 f113 f114) (foreign-call "s_exit" 1))
# emit-expr f113
# emit-variable-ref
# env=((f114 . -12) (f113 . -8) (f108 . 4) (f108 . -4) (f99 . 0))
# var=f113
    movl -8(%esp), %eax  # stack load f113
# end emit-variable-ref
    movl %eax, -16(%esp)  # stack save
# emit-expr f114
# emit-variable-ref
# env=((f114 . -12) (f113 . -8) (f108 . 4) (f108 . -4) (f99 . 0))
# var=f114
    movl -12(%esp), %eax  # stack load f114
>>>>>>> fix-implicit-begins
# end emit-variable-ref
    movl %eax, -20(%esp)  # stack save
# emit-tail-expr
# si=-24
<<<<<<< HEAD
# env=((f310900 . -20) (f310901 . -16) (f310900 . -12) (f310901 . -8) (f310895 . 4) (f310895 . -4) (f310886 . 0))
# expr=(begin (f310895 f310901 f310900) (foreign-call "s_exit" 1))
# tail-begin (begin (f310895 f310901 f310900) (foreign-call "s_exit" 1))
#   env=((f310900 . -20) (f310901 . -16) (f310900 . -12) (f310901 . -8) (f310895 . 4) (f310895 . -4) (f310886 . 0))
# emit-expr (f310895 f310901 f310900)
# funcall
#    si   =-24
#    env  = ((f310900 . -20) (f310901 . -16) (f310900 . -12) (f310901 . -8) (f310895 . 4) (f310895 . -4) (f310886 . 0))
#    expr = (funcall f310895 f310901 f310900)
# emit-expr f310895
# emit-variable-ref
# env=((f310900 . -20) (f310901 . -16) (f310900 . -12) (f310901 . -8) (f310895 . 4) (f310895 . -4) (f310886 . 0))
# var=f310895
    movl 2(%edi), %eax  # frame load f310895
=======
# env=((f114 . -20) (f113 . -16) (f114 . -12) (f113 . -8) (f108 . 4) (f108 . -4) (f99 . 0))
# expr=(begin (f108 f113 f114) (foreign-call "s_exit" 1))
# tail-begin (begin (f108 f113 f114) (foreign-call "s_exit" 1))
#   env=((f114 . -20) (f113 . -16) (f114 . -12) (f113 . -8) (f108 . 4) (f108 . -4) (f99 . 0))
# emit-expr (f108 f113 f114)
# funcall
#    si   =-24
#    env  = ((f114 . -20) (f113 . -16) (f114 . -12) (f113 . -8) (f108 . 4) (f108 . -4) (f99 . 0))
#    expr = (funcall f108 f113 f114)
# emit-expr f108
# emit-variable-ref
# env=((f114 . -20) (f113 . -16) (f114 . -12) (f113 . -8) (f108 . 4) (f108 . -4) (f99 . 0))
# var=f108
    movl 2(%edi), %eax  # frame load f108
>>>>>>> fix-implicit-begins
# end emit-variable-ref
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_325"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_325":
   movl %eax,  -32(%esp)  # stash funcall-oper in closure slot
<<<<<<< HEAD
# emit-expr f310901
# emit-variable-ref
# env=((f310900 . -20) (f310901 . -16) (f310900 . -12) (f310901 . -8) (f310895 . 4) (f310895 . -4) (f310886 . 0))
# var=f310901
    movl -16(%esp), %eax  # stack load f310901
# end emit-variable-ref
    mov %eax, -36(%esp)  # arg f310901
# emit-expr f310900
# emit-variable-ref
# env=((f310900 . -20) (f310901 . -16) (f310900 . -12) (f310901 . -8) (f310895 . 4) (f310895 . -4) (f310886 . 0))
# var=f310900
    movl -20(%esp), %eax  # stack load f310900
# end emit-variable-ref
    mov %eax, -40(%esp)  # arg f310900
=======
# emit-expr f113
# emit-variable-ref
# env=((f114 . -20) (f113 . -16) (f114 . -12) (f113 . -8) (f108 . 4) (f108 . -4) (f99 . 0))
# var=f113
    movl -16(%esp), %eax  # stack load f113
# end emit-variable-ref
    mov %eax, -36(%esp)  # arg f113
# emit-expr f114
# emit-variable-ref
# env=((f114 . -20) (f113 . -16) (f114 . -12) (f113 . -8) (f108 . 4) (f108 . -4) (f99 . 0))
# var=f114
    movl -20(%esp), %eax  # stack load f114
# end emit-variable-ref
    mov %eax, -40(%esp)  # arg f114
>>>>>>> fix-implicit-begins
    movl -32(%esp), %edi   # load new closure to %edi
    add $-24, %esp   # adjust base
    movl $8,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $24, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
# emit-tail-expr
# si=-24
<<<<<<< HEAD
# env=((f310900 . -20) (f310901 . -16) (f310900 . -12) (f310901 . -8) (f310895 . 4) (f310895 . -4) (f310886 . 0))
# expr=(begin (foreign-call "s_exit" 1))
# tail-begin (begin (foreign-call "s_exit" 1))
#   env=((f310900 . -20) (f310901 . -16) (f310900 . -12) (f310901 . -8) (f310895 . 4) (f310895 . -4) (f310886 . 0))
# emit-tail-expr
# si=-24
# env=((f310900 . -20) (f310901 . -16) (f310900 . -12) (f310901 . -8) (f310895 . 4) (f310895 . -4) (f310886 . 0))
=======
# env=((f114 . -20) (f113 . -16) (f114 . -12) (f113 . -8) (f108 . 4) (f108 . -4) (f99 . 0))
# expr=(begin (foreign-call "s_exit" 1))
# tail-begin (begin (foreign-call "s_exit" 1))
#   env=((f114 . -20) (f113 . -16) (f114 . -12) (f113 . -8) (f108 . 4) (f108 . -4) (f99 . 0))
# emit-tail-expr
# si=-24
# env=((f114 . -20) (f113 . -16) (f114 . -12) (f113 . -8) (f108 . 4) (f108 . -4) (f99 . 0))
>>>>>>> fix-implicit-begins
# expr=(foreign-call "s_exit" 1)
    movl %ecx,-24(%esp)
    movl %esp,-28(%esp)
# emit-expr 1
    movl $4, %eax     # immed 1
    movl %eax, -32(%esp)
    leal -32(%esp),%edi
    movl %edi,%esi
    andl $-16,%esi
    movl 0(%edi),%eax
    movl %eax,0(%esi)
    movl 4(%edi),%eax
    movl %eax,4(%esi)
    movl %esi,%esp
    .extern _s_exit
    call _s_exit
    movl 4(%esi),%esp
    movl -24(%esp),%ecx
     ret
     ret   # return thru stack
    .align 4,0x90
_L_323:
     movl %eax, mrc_error
# == explicit-begins  ==>
# (let ((p (quote ()))) (begin (set! p (cons (quote procedure?) p)) (set! p (cons (quote cdr) p)) (set! p (cons (quote car) p)) (set! p (cons (quote symbol-value) p)) (set! p (cons (quote symbol->string) p)) (set! p (cons (quote make-symbol) p)) (set! p (cons (quote symbol?) p)) (set! p (cons (quote string-set!) p)) (set! p (cons (quote string-ref) p)) (set! p (cons (quote string-length) p)) (set! p (cons (quote string?) p)) (set! p (cons (quote make-string) p)) (set! p (cons (quote vector-ref) p)) (set! p (cons (quote vector-set!) p)) (set! p (cons (quote vector-length) p)) (set! p (cons (quote make-vector) p)) (set! p (cons (quote vector?) p)) (set! p (cons (quote set-cdr!) p)) (set! p (cons (quote set-car!) p)) (set! p (cons (quote cdr) p)) (set! p (cons (quote car) p)) (set! p (cons (quote cons) p)) (set! p (cons (quote pair?) p)) (set! p (cons (quote fxremainder) p)) (set! p (cons (quote fxquotient) p)) (set! p (cons (quote fx*) p)) (set! p (cons (quote fx-) p)) (set! p (cons (quote fx+) p)) (set! p (cons (quote fx>=) p)) (set! p (cons (quote fx>) p)) (set! p (cons (quote fx<=) p)) (set! p (cons (quote fx<) p)) (set! p (cons (quote fx=) p)) (set! p (cons (quote fxzero?) p)) (set! p (cons (quote fxsub1) p)) (set! p (cons (quote fxadd1) p)) (set! p (cons (quote fxlogor) p)) (set! p (cons (quote fxlogand) p)) (set! p (cons (quote fxlognot) p)) (set! p (cons (quote char=?) p)) (set! p (cons (quote eq?) p)) (set! p (cons (quote not) p)) (set! p (cons (quote boolean?) p)) (set! p (cons (quote fixnum?) p)) (set! p (cons (quote char?) p)) (set! p (cons (quote eof-object) p)) (set! p (cons (quote eof-object?) p)) (set! p (cons (quote null?) p)) (set! p (cons (quote char->fixnum) p)) (set! p (cons (quote fixnum->char) p)) (lambda () p)))
# == eliminate-let*  ==>
# (let ((p (quote ()))) (begin (set! p (cons (quote procedure?) p)) (set! p (cons (quote cdr) p)) (set! p (cons (quote car) p)) (set! p (cons (quote symbol-value) p)) (set! p (cons (quote symbol->string) p)) (set! p (cons (quote make-symbol) p)) (set! p (cons (quote symbol?) p)) (set! p (cons (quote string-set!) p)) (set! p (cons (quote string-ref) p)) (set! p (cons (quote string-length) p)) (set! p (cons (quote string?) p)) (set! p (cons (quote make-string) p)) (set! p (cons (quote vector-ref) p)) (set! p (cons (quote vector-set!) p)) (set! p (cons (quote vector-length) p)) (set! p (cons (quote make-vector) p)) (set! p (cons (quote vector?) p)) (set! p (cons (quote set-cdr!) p)) (set! p (cons (quote set-car!) p)) (set! p (cons (quote cdr) p)) (set! p (cons (quote car) p)) (set! p (cons (quote cons) p)) (set! p (cons (quote pair?) p)) (set! p (cons (quote fxremainder) p)) (set! p (cons (quote fxquotient) p)) (set! p (cons (quote fx*) p)) (set! p (cons (quote fx-) p)) (set! p (cons (quote fx+) p)) (set! p (cons (quote fx>=) p)) (set! p (cons (quote fx>) p)) (set! p (cons (quote fx<=) p)) (set! p (cons (quote fx<) p)) (set! p (cons (quote fx=) p)) (set! p (cons (quote fxzero?) p)) (set! p (cons (quote fxsub1) p)) (set! p (cons (quote fxadd1) p)) (set! p (cons (quote fxlogor) p)) (set! p (cons (quote fxlogand) p)) (set! p (cons (quote fxlognot) p)) (set! p (cons (quote char=?) p)) (set! p (cons (quote eq?) p)) (set! p (cons (quote not) p)) (set! p (cons (quote boolean?) p)) (set! p (cons (quote fixnum?) p)) (set! p (cons (quote char?) p)) (set! p (cons (quote eof-object) p)) (set! p (cons (quote eof-object?) p)) (set! p (cons (quote null?) p)) (set! p (cons (quote char->fixnum) p)) (set! p (cons (quote fixnum->char) p)) (lambda () p)))
# == uniquify-variables  ==>
# (let ((f115 (quote ()))) (begin (set! f115 (cons (quote procedure?) f115)) (set! f115 (cons (quote cdr) f115)) (set! f115 (cons (quote car) f115)) (set! f115 (cons (quote symbol-value) f115)) (set! f115 (cons (quote symbol->string) f115)) (set! f115 (cons (quote make-symbol) f115)) (set! f115 (cons (quote symbol?) f115)) (set! f115 (cons (quote string-set!) f115)) (set! f115 (cons (quote string-ref) f115)) (set! f115 (cons (quote string-length) f115)) (set! f115 (cons (quote string?) f115)) (set! f115 (cons (quote make-string) f115)) (set! f115 (cons (quote vector-ref) f115)) (set! f115 (cons (quote vector-set!) f115)) (set! f115 (cons (quote vector-length) f115)) (set! f115 (cons (quote make-vector) f115)) (set! f115 (cons (quote vector?) f115)) (set! f115 (cons (quote set-cdr!) f115)) (set! f115 (cons (quote set-car!) f115)) (set! f115 (cons (quote cdr) f115)) (set! f115 (cons (quote car) f115)) (set! f115 (cons (quote cons) f115)) (set! f115 (cons (quote pair?) f115)) (set! f115 (cons (quote fxremainder) f115)) (set! f115 (cons (quote fxquotient) f115)) (set! f115 (cons (quote fx*) f115)) (set! f115 (cons (quote fx-) f115)) (set! f115 (cons (quote fx+) f115)) (set! f115 (cons (quote fx>=) f115)) (set! f115 (cons (quote fx>) f115)) (set! f115 (cons (quote fx<=) f115)) (set! f115 (cons (quote fx<) f115)) (set! f115 (cons (quote fx=) f115)) (set! f115 (cons (quote fxzero?) f115)) (set! f115 (cons (quote fxsub1) f115)) (set! f115 (cons (quote fxadd1) f115)) (set! f115 (cons (quote fxlogor) f115)) (set! f115 (cons (quote fxlogand) f115)) (set! f115 (cons (quote fxlognot) f115)) (set! f115 (cons (quote char=?) f115)) (set! f115 (cons (quote eq?) f115)) (set! f115 (cons (quote not) f115)) (set! f115 (cons (quote boolean?) f115)) (set! f115 (cons (quote fixnum?) f115)) (set! f115 (cons (quote char?) f115)) (set! f115 (cons (quote eof-object) f115)) (set! f115 (cons (quote eof-object?) f115)) (set! f115 (cons (quote null?) f115)) (set! f115 (cons (quote char->fixnum) f115)) (set! f115 (cons (quote fixnum->char) f115)) (lambda () f115)))
# == vectorize-letrec  ==>
# (let ((f115 (quote ()))) (begin (set! f115 (cons (quote procedure?) f115)) (set! f115 (cons (quote cdr) f115)) (set! f115 (cons (quote car) f115)) (set! f115 (cons (quote symbol-value) f115)) (set! f115 (cons (quote symbol->string) f115)) (set! f115 (cons (quote make-symbol) f115)) (set! f115 (cons (quote symbol?) f115)) (set! f115 (cons (quote string-set!) f115)) (set! f115 (cons (quote string-ref) f115)) (set! f115 (cons (quote string-length) f115)) (set! f115 (cons (quote string?) f115)) (set! f115 (cons (quote make-string) f115)) (set! f115 (cons (quote vector-ref) f115)) (set! f115 (cons (quote vector-set!) f115)) (set! f115 (cons (quote vector-length) f115)) (set! f115 (cons (quote make-vector) f115)) (set! f115 (cons (quote vector?) f115)) (set! f115 (cons (quote set-cdr!) f115)) (set! f115 (cons (quote set-car!) f115)) (set! f115 (cons (quote cdr) f115)) (set! f115 (cons (quote car) f115)) (set! f115 (cons (quote cons) f115)) (set! f115 (cons (quote pair?) f115)) (set! f115 (cons (quote fxremainder) f115)) (set! f115 (cons (quote fxquotient) f115)) (set! f115 (cons (quote fx*) f115)) (set! f115 (cons (quote fx-) f115)) (set! f115 (cons (quote fx+) f115)) (set! f115 (cons (quote fx>=) f115)) (set! f115 (cons (quote fx>) f115)) (set! f115 (cons (quote fx<=) f115)) (set! f115 (cons (quote fx<) f115)) (set! f115 (cons (quote fx=) f115)) (set! f115 (cons (quote fxzero?) f115)) (set! f115 (cons (quote fxsub1) f115)) (set! f115 (cons (quote fxadd1) f115)) (set! f115 (cons (quote fxlogor) f115)) (set! f115 (cons (quote fxlogand) f115)) (set! f115 (cons (quote fxlognot) f115)) (set! f115 (cons (quote char=?) f115)) (set! f115 (cons (quote eq?) f115)) (set! f115 (cons (quote not) f115)) (set! f115 (cons (quote boolean?) f115)) (set! f115 (cons (quote fixnum?) f115)) (set! f115 (cons (quote char?) f115)) (set! f115 (cons (quote eof-object) f115)) (set! f115 (cons (quote eof-object?) f115)) (set! f115 (cons (quote null?) f115)) (set! f115 (cons (quote char->fixnum) f115)) (set! f115 (cons (quote fixnum->char) f115)) (lambda () f115)))
# == eliminate-set!  ==>
# (let ((f115 (vector (quote ())))) (begin (vector-set! f115 0 (cons (quote procedure?) (vector-ref f115 0))) (vector-set! f115 0 (cons (quote cdr) (vector-ref f115 0))) (vector-set! f115 0 (cons (quote car) (vector-ref f115 0))) (vector-set! f115 0 (cons (quote symbol-value) (vector-ref f115 0))) (vector-set! f115 0 (cons (quote symbol->string) (vector-ref f115 0))) (vector-set! f115 0 (cons (quote make-symbol) (vector-ref f115 0))) (vector-set! f115 0 (cons (quote symbol?) (vector-ref f115 0))) (vector-set! f115 0 (cons (quote string-set!) (vector-ref f115 0))) (vector-set! f115 0 (cons (quote string-ref) (vector-ref f115 0))) (vector-set! f115 0 (cons (quote string-length) (vector-ref f115 0))) (vector-set! f115 0 (cons (quote string?) (vector-ref f115 0))) (vector-set! f115 0 (cons (quote make-string) (vector-ref f115 0))) (vector-set! f115 0 (cons (quote vector-ref) (vector-ref f115 0))) (vector-set! f115 0 (cons (quote vector-set!) (vector-ref f115 0))) (vector-set! f115 0 (cons (quote vector-length) (vector-ref f115 0))) (vector-set! f115 0 (cons (quote make-vector) (vector-ref f115 0))) (vector-set! f115 0 (cons (quote vector?) (vector-ref f115 0))) (vector-set! f115 0 (cons (quote set-cdr!) (vector-ref f115 0))) (vector-set! f115 0 (cons (quote set-car!) (vector-ref f115 0))) (vector-set! f115 0 (cons (quote cdr) (vector-ref f115 0))) (vector-set! f115 0 (cons (quote car) (vector-ref f115 0))) (vector-set! f115 0 (cons (quote cons) (vector-ref f115 0))) (vector-set! f115 0 (cons (quote pair?) (vector-ref f115 0))) (vector-set! f115 0 (cons (quote fxremainder) (vector-ref f115 0))) (vector-set! f115 0 (cons (quote fxquotient) (vector-ref f115 0))) (vector-set! f115 0 (cons (quote fx*) (vector-ref f115 0))) (vector-set! f115 0 (cons (quote fx-) (vector-ref f115 0))) (vector-set! f115 0 (cons (quote fx+) (vector-ref f115 0))) (vector-set! f115 0 (cons (quote fx>=) (vector-ref f115 0))) (vector-set! f115 0 (cons (quote fx>) (vector-ref f115 0))) (vector-set! f115 0 (cons (quote fx<=) (vector-ref f115 0))) (vector-set! f115 0 (cons (quote fx<) (vector-ref f115 0))) (vector-set! f115 0 (cons (quote fx=) (vector-ref f115 0))) (vector-set! f115 0 (cons (quote fxzero?) (vector-ref f115 0))) (vector-set! f115 0 (cons (quote fxsub1) (vector-ref f115 0))) (vector-set! f115 0 (cons (quote fxadd1) (vector-ref f115 0))) (vector-set! f115 0 (cons (quote fxlogor) (vector-ref f115 0))) (vector-set! f115 0 (cons (quote fxlogand) (vector-ref f115 0))) (vector-set! f115 0 (cons (quote fxlognot) (vector-ref f115 0))) (vector-set! f115 0 (cons (quote char=?) (vector-ref f115 0))) (vector-set! f115 0 (cons (quote eq?) (vector-ref f115 0))) (vector-set! f115 0 (cons (quote not) (vector-ref f115 0))) (vector-set! f115 0 (cons (quote boolean?) (vector-ref f115 0))) (vector-set! f115 0 (cons (quote fixnum?) (vector-ref f115 0))) (vector-set! f115 0 (cons (quote char?) (vector-ref f115 0))) (vector-set! f115 0 (cons (quote eof-object) (vector-ref f115 0))) (vector-set! f115 0 (cons (quote eof-object?) (vector-ref f115 0))) (vector-set! f115 0 (cons (quote null?) (vector-ref f115 0))) (vector-set! f115 0 (cons (quote char->fixnum) (vector-ref f115 0))) (vector-set! f115 0 (cons (quote fixnum->char) (vector-ref f115 0))) (lambda () (let () (vector-ref f115 0)))))
# == close-free-variables  ==>
# (let ((f115 (vector (quote ())))) (begin (vector-set! f115 0 (cons (quote procedure?) (vector-ref f115 0))) (vector-set! f115 0 (cons (quote cdr) (vector-ref f115 0))) (vector-set! f115 0 (cons (quote car) (vector-ref f115 0))) (vector-set! f115 0 (cons (quote symbol-value) (vector-ref f115 0))) (vector-set! f115 0 (cons (quote symbol->string) (vector-ref f115 0))) (vector-set! f115 0 (cons (quote make-symbol) (vector-ref f115 0))) (vector-set! f115 0 (cons (quote symbol?) (vector-ref f115 0))) (vector-set! f115 0 (cons (quote string-set!) (vector-ref f115 0))) (vector-set! f115 0 (cons (quote string-ref) (vector-ref f115 0))) (vector-set! f115 0 (cons (quote string-length) (vector-ref f115 0))) (vector-set! f115 0 (cons (quote string?) (vector-ref f115 0))) (vector-set! f115 0 (cons (quote make-string) (vector-ref f115 0))) (vector-set! f115 0 (cons (quote vector-ref) (vector-ref f115 0))) (vector-set! f115 0 (cons (quote vector-set!) (vector-ref f115 0))) (vector-set! f115 0 (cons (quote vector-length) (vector-ref f115 0))) (vector-set! f115 0 (cons (quote make-vector) (vector-ref f115 0))) (vector-set! f115 0 (cons (quote vector?) (vector-ref f115 0))) (vector-set! f115 0 (cons (quote set-cdr!) (vector-ref f115 0))) (vector-set! f115 0 (cons (quote set-car!) (vector-ref f115 0))) (vector-set! f115 0 (cons (quote cdr) (vector-ref f115 0))) (vector-set! f115 0 (cons (quote car) (vector-ref f115 0))) (vector-set! f115 0 (cons (quote cons) (vector-ref f115 0))) (vector-set! f115 0 (cons (quote pair?) (vector-ref f115 0))) (vector-set! f115 0 (cons (quote fxremainder) (vector-ref f115 0))) (vector-set! f115 0 (cons (quote fxquotient) (vector-ref f115 0))) (vector-set! f115 0 (cons (quote fx*) (vector-ref f115 0))) (vector-set! f115 0 (cons (quote fx-) (vector-ref f115 0))) (vector-set! f115 0 (cons (quote fx+) (vector-ref f115 0))) (vector-set! f115 0 (cons (quote fx>=) (vector-ref f115 0))) (vector-set! f115 0 (cons (quote fx>) (vector-ref f115 0))) (vector-set! f115 0 (cons (quote fx<=) (vector-ref f115 0))) (vector-set! f115 0 (cons (quote fx<) (vector-ref f115 0))) (vector-set! f115 0 (cons (quote fx=) (vector-ref f115 0))) (vector-set! f115 0 (cons (quote fxzero?) (vector-ref f115 0))) (vector-set! f115 0 (cons (quote fxsub1) (vector-ref f115 0))) (vector-set! f115 0 (cons (quote fxadd1) (vector-ref f115 0))) (vector-set! f115 0 (cons (quote fxlogor) (vector-ref f115 0))) (vector-set! f115 0 (cons (quote fxlogand) (vector-ref f115 0))) (vector-set! f115 0 (cons (quote fxlognot) (vector-ref f115 0))) (vector-set! f115 0 (cons (quote char=?) (vector-ref f115 0))) (vector-set! f115 0 (cons (quote eq?) (vector-ref f115 0))) (vector-set! f115 0 (cons (quote not) (vector-ref f115 0))) (vector-set! f115 0 (cons (quote boolean?) (vector-ref f115 0))) (vector-set! f115 0 (cons (quote fixnum?) (vector-ref f115 0))) (vector-set! f115 0 (cons (quote char?) (vector-ref f115 0))) (vector-set! f115 0 (cons (quote eof-object) (vector-ref f115 0))) (vector-set! f115 0 (cons (quote eof-object?) (vector-ref f115 0))) (vector-set! f115 0 (cons (quote null?) (vector-ref f115 0))) (vector-set! f115 0 (cons (quote char->fixnum) (vector-ref f115 0))) (vector-set! f115 0 (cons (quote fixnum->char) (vector-ref f115 0))) (closure () (f115) (let () (vector-ref f115 0)))))
# == eliminate-quote  ==>
# (let ((f115 (vector ()))) (begin (vector-set! f115 0 (cons (string->symbol "procedure?") (vector-ref f115 0))) (vector-set! f115 0 (cons (string->symbol "cdr") (vector-ref f115 0))) (vector-set! f115 0 (cons (string->symbol "car") (vector-ref f115 0))) (vector-set! f115 0 (cons (string->symbol "symbol-value") (vector-ref f115 0))) (vector-set! f115 0 (cons (string->symbol "symbol->string") (vector-ref f115 0))) (vector-set! f115 0 (cons (string->symbol "make-symbol") (vector-ref f115 0))) (vector-set! f115 0 (cons (string->symbol "symbol?") (vector-ref f115 0))) (vector-set! f115 0 (cons (string->symbol "string-set!") (vector-ref f115 0))) (vector-set! f115 0 (cons (string->symbol "string-ref") (vector-ref f115 0))) (vector-set! f115 0 (cons (string->symbol "string-length") (vector-ref f115 0))) (vector-set! f115 0 (cons (string->symbol "string?") (vector-ref f115 0))) (vector-set! f115 0 (cons (string->symbol "make-string") (vector-ref f115 0))) (vector-set! f115 0 (cons (string->symbol "vector-ref") (vector-ref f115 0))) (vector-set! f115 0 (cons (string->symbol "vector-set!") (vector-ref f115 0))) (vector-set! f115 0 (cons (string->symbol "vector-length") (vector-ref f115 0))) (vector-set! f115 0 (cons (string->symbol "make-vector") (vector-ref f115 0))) (vector-set! f115 0 (cons (string->symbol "vector?") (vector-ref f115 0))) (vector-set! f115 0 (cons (string->symbol "set-cdr!") (vector-ref f115 0))) (vector-set! f115 0 (cons (string->symbol "set-car!") (vector-ref f115 0))) (vector-set! f115 0 (cons (string->symbol "cdr") (vector-ref f115 0))) (vector-set! f115 0 (cons (string->symbol "car") (vector-ref f115 0))) (vector-set! f115 0 (cons (string->symbol "cons") (vector-ref f115 0))) (vector-set! f115 0 (cons (string->symbol "pair?") (vector-ref f115 0))) (vector-set! f115 0 (cons (string->symbol "fxremainder") (vector-ref f115 0))) (vector-set! f115 0 (cons (string->symbol "fxquotient") (vector-ref f115 0))) (vector-set! f115 0 (cons (string->symbol "fx*") (vector-ref f115 0))) (vector-set! f115 0 (cons (string->symbol "fx-") (vector-ref f115 0))) (vector-set! f115 0 (cons (string->symbol "fx+") (vector-ref f115 0))) (vector-set! f115 0 (cons (string->symbol "fx>=") (vector-ref f115 0))) (vector-set! f115 0 (cons (string->symbol "fx>") (vector-ref f115 0))) (vector-set! f115 0 (cons (string->symbol "fx<=") (vector-ref f115 0))) (vector-set! f115 0 (cons (string->symbol "fx<") (vector-ref f115 0))) (vector-set! f115 0 (cons (string->symbol "fx=") (vector-ref f115 0))) (vector-set! f115 0 (cons (string->symbol "fxzero?") (vector-ref f115 0))) (vector-set! f115 0 (cons (string->symbol "fxsub1") (vector-ref f115 0))) (vector-set! f115 0 (cons (string->symbol "fxadd1") (vector-ref f115 0))) (vector-set! f115 0 (cons (string->symbol "fxlogor") (vector-ref f115 0))) (vector-set! f115 0 (cons (string->symbol "fxlogand") (vector-ref f115 0))) (vector-set! f115 0 (cons (string->symbol "fxlognot") (vector-ref f115 0))) (vector-set! f115 0 (cons (string->symbol "char=?") (vector-ref f115 0))) (vector-set! f115 0 (cons (string->symbol "eq?") (vector-ref f115 0))) (vector-set! f115 0 (cons (string->symbol "not") (vector-ref f115 0))) (vector-set! f115 0 (cons (string->symbol "boolean?") (vector-ref f115 0))) (vector-set! f115 0 (cons (string->symbol "fixnum?") (vector-ref f115 0))) (vector-set! f115 0 (cons (string->symbol "char?") (vector-ref f115 0))) (vector-set! f115 0 (cons (string->symbol "eof-object") (vector-ref f115 0))) (vector-set! f115 0 (cons (string->symbol "eof-object?") (vector-ref f115 0))) (vector-set! f115 0 (cons (string->symbol "null?") (vector-ref f115 0))) (vector-set! f115 0 (cons (string->symbol "char->fixnum") (vector-ref f115 0))) (vector-set! f115 0 (cons (string->symbol "fixnum->char") (vector-ref f115 0))) (closure () (f115) (let () (vector-ref f115 0)))))
# == eliminate-when/unless  ==>
# (let ((f115 (vector ()))) (begin (vector-set! f115 0 (cons (string->symbol "procedure?") (vector-ref f115 0))) (vector-set! f115 0 (cons (string->symbol "cdr") (vector-ref f115 0))) (vector-set! f115 0 (cons (string->symbol "car") (vector-ref f115 0))) (vector-set! f115 0 (cons (string->symbol "symbol-value") (vector-ref f115 0))) (vector-set! f115 0 (cons (string->symbol "symbol->string") (vector-ref f115 0))) (vector-set! f115 0 (cons (string->symbol "make-symbol") (vector-ref f115 0))) (vector-set! f115 0 (cons (string->symbol "symbol?") (vector-ref f115 0))) (vector-set! f115 0 (cons (string->symbol "string-set!") (vector-ref f115 0))) (vector-set! f115 0 (cons (string->symbol "string-ref") (vector-ref f115 0))) (vector-set! f115 0 (cons (string->symbol "string-length") (vector-ref f115 0))) (vector-set! f115 0 (cons (string->symbol "string?") (vector-ref f115 0))) (vector-set! f115 0 (cons (string->symbol "make-string") (vector-ref f115 0))) (vector-set! f115 0 (cons (string->symbol "vector-ref") (vector-ref f115 0))) (vector-set! f115 0 (cons (string->symbol "vector-set!") (vector-ref f115 0))) (vector-set! f115 0 (cons (string->symbol "vector-length") (vector-ref f115 0))) (vector-set! f115 0 (cons (string->symbol "make-vector") (vector-ref f115 0))) (vector-set! f115 0 (cons (string->symbol "vector?") (vector-ref f115 0))) (vector-set! f115 0 (cons (string->symbol "set-cdr!") (vector-ref f115 0))) (vector-set! f115 0 (cons (string->symbol "set-car!") (vector-ref f115 0))) (vector-set! f115 0 (cons (string->symbol "cdr") (vector-ref f115 0))) (vector-set! f115 0 (cons (string->symbol "car") (vector-ref f115 0))) (vector-set! f115 0 (cons (string->symbol "cons") (vector-ref f115 0))) (vector-set! f115 0 (cons (string->symbol "pair?") (vector-ref f115 0))) (vector-set! f115 0 (cons (string->symbol "fxremainder") (vector-ref f115 0))) (vector-set! f115 0 (cons (string->symbol "fxquotient") (vector-ref f115 0))) (vector-set! f115 0 (cons (string->symbol "fx*") (vector-ref f115 0))) (vector-set! f115 0 (cons (string->symbol "fx-") (vector-ref f115 0))) (vector-set! f115 0 (cons (string->symbol "fx+") (vector-ref f115 0))) (vector-set! f115 0 (cons (string->symbol "fx>=") (vector-ref f115 0))) (vector-set! f115 0 (cons (string->symbol "fx>") (vector-ref f115 0))) (vector-set! f115 0 (cons (string->symbol "fx<=") (vector-ref f115 0))) (vector-set! f115 0 (cons (string->symbol "fx<") (vector-ref f115 0))) (vector-set! f115 0 (cons (string->symbol "fx=") (vector-ref f115 0))) (vector-set! f115 0 (cons (string->symbol "fxzero?") (vector-ref f115 0))) (vector-set! f115 0 (cons (string->symbol "fxsub1") (vector-ref f115 0))) (vector-set! f115 0 (cons (string->symbol "fxadd1") (vector-ref f115 0))) (vector-set! f115 0 (cons (string->symbol "fxlogor") (vector-ref f115 0))) (vector-set! f115 0 (cons (string->symbol "fxlogand") (vector-ref f115 0))) (vector-set! f115 0 (cons (string->symbol "fxlognot") (vector-ref f115 0))) (vector-set! f115 0 (cons (string->symbol "char=?") (vector-ref f115 0))) (vector-set! f115 0 (cons (string->symbol "eq?") (vector-ref f115 0))) (vector-set! f115 0 (cons (string->symbol "not") (vector-ref f115 0))) (vector-set! f115 0 (cons (string->symbol "boolean?") (vector-ref f115 0))) (vector-set! f115 0 (cons (string->symbol "fixnum?") (vector-ref f115 0))) (vector-set! f115 0 (cons (string->symbol "char?") (vector-ref f115 0))) (vector-set! f115 0 (cons (string->symbol "eof-object") (vector-ref f115 0))) (vector-set! f115 0 (cons (string->symbol "eof-object?") (vector-ref f115 0))) (vector-set! f115 0 (cons (string->symbol "null?") (vector-ref f115 0))) (vector-set! f115 0 (cons (string->symbol "char->fixnum") (vector-ref f115 0))) (vector-set! f115 0 (cons (string->symbol "fixnum->char") (vector-ref f115 0))) (closure () (f115) (let () (vector-ref f115 0)))))
# == eliminate-cond  ==>
# (let ((f115 (vector ()))) (begin (vector-set! f115 0 (cons (string->symbol "procedure?") (vector-ref f115 0))) (vector-set! f115 0 (cons (string->symbol "cdr") (vector-ref f115 0))) (vector-set! f115 0 (cons (string->symbol "car") (vector-ref f115 0))) (vector-set! f115 0 (cons (string->symbol "symbol-value") (vector-ref f115 0))) (vector-set! f115 0 (cons (string->symbol "symbol->string") (vector-ref f115 0))) (vector-set! f115 0 (cons (string->symbol "make-symbol") (vector-ref f115 0))) (vector-set! f115 0 (cons (string->symbol "symbol?") (vector-ref f115 0))) (vector-set! f115 0 (cons (string->symbol "string-set!") (vector-ref f115 0))) (vector-set! f115 0 (cons (string->symbol "string-ref") (vector-ref f115 0))) (vector-set! f115 0 (cons (string->symbol "string-length") (vector-ref f115 0))) (vector-set! f115 0 (cons (string->symbol "string?") (vector-ref f115 0))) (vector-set! f115 0 (cons (string->symbol "make-string") (vector-ref f115 0))) (vector-set! f115 0 (cons (string->symbol "vector-ref") (vector-ref f115 0))) (vector-set! f115 0 (cons (string->symbol "vector-set!") (vector-ref f115 0))) (vector-set! f115 0 (cons (string->symbol "vector-length") (vector-ref f115 0))) (vector-set! f115 0 (cons (string->symbol "make-vector") (vector-ref f115 0))) (vector-set! f115 0 (cons (string->symbol "vector?") (vector-ref f115 0))) (vector-set! f115 0 (cons (string->symbol "set-cdr!") (vector-ref f115 0))) (vector-set! f115 0 (cons (string->symbol "set-car!") (vector-ref f115 0))) (vector-set! f115 0 (cons (string->symbol "cdr") (vector-ref f115 0))) (vector-set! f115 0 (cons (string->symbol "car") (vector-ref f115 0))) (vector-set! f115 0 (cons (string->symbol "cons") (vector-ref f115 0))) (vector-set! f115 0 (cons (string->symbol "pair?") (vector-ref f115 0))) (vector-set! f115 0 (cons (string->symbol "fxremainder") (vector-ref f115 0))) (vector-set! f115 0 (cons (string->symbol "fxquotient") (vector-ref f115 0))) (vector-set! f115 0 (cons (string->symbol "fx*") (vector-ref f115 0))) (vector-set! f115 0 (cons (string->symbol "fx-") (vector-ref f115 0))) (vector-set! f115 0 (cons (string->symbol "fx+") (vector-ref f115 0))) (vector-set! f115 0 (cons (string->symbol "fx>=") (vector-ref f115 0))) (vector-set! f115 0 (cons (string->symbol "fx>") (vector-ref f115 0))) (vector-set! f115 0 (cons (string->symbol "fx<=") (vector-ref f115 0))) (vector-set! f115 0 (cons (string->symbol "fx<") (vector-ref f115 0))) (vector-set! f115 0 (cons (string->symbol "fx=") (vector-ref f115 0))) (vector-set! f115 0 (cons (string->symbol "fxzero?") (vector-ref f115 0))) (vector-set! f115 0 (cons (string->symbol "fxsub1") (vector-ref f115 0))) (vector-set! f115 0 (cons (string->symbol "fxadd1") (vector-ref f115 0))) (vector-set! f115 0 (cons (string->symbol "fxlogor") (vector-ref f115 0))) (vector-set! f115 0 (cons (string->symbol "fxlogand") (vector-ref f115 0))) (vector-set! f115 0 (cons (string->symbol "fxlognot") (vector-ref f115 0))) (vector-set! f115 0 (cons (string->symbol "char=?") (vector-ref f115 0))) (vector-set! f115 0 (cons (string->symbol "eq?") (vector-ref f115 0))) (vector-set! f115 0 (cons (string->symbol "not") (vector-ref f115 0))) (vector-set! f115 0 (cons (string->symbol "boolean?") (vector-ref f115 0))) (vector-set! f115 0 (cons (string->symbol "fixnum?") (vector-ref f115 0))) (vector-set! f115 0 (cons (string->symbol "char?") (vector-ref f115 0))) (vector-set! f115 0 (cons (string->symbol "eof-object") (vector-ref f115 0))) (vector-set! f115 0 (cons (string->symbol "eof-object?") (vector-ref f115 0))) (vector-set! f115 0 (cons (string->symbol "null?") (vector-ref f115 0))) (vector-set! f115 0 (cons (string->symbol "char->fixnum") (vector-ref f115 0))) (vector-set! f115 0 (cons (string->symbol "fixnum->char") (vector-ref f115 0))) (closure () (f115) (let () (vector-ref f115 0)))))
# == external-symbols  ==>
# (let ((f115 ((primitive-ref vector) ()))) (begin (vector-set! f115 0 (cons ((primitive-ref string->symbol) "procedure?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "cdr") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "car") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "symbol-value") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "symbol->string") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "make-symbol") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "symbol?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "string-set!") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "string-ref") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "string-length") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "string?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "make-string") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "vector-ref") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "vector-set!") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "vector-length") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "make-vector") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "vector?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "set-cdr!") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "set-car!") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "cdr") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "car") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "cons") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "pair?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fxremainder") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fxquotient") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fx*") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fx-") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fx+") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fx>=") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fx>") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fx<=") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fx<") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fx=") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "eof-object") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "eof-object?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f115 0))) (closure () (f115) (let () (vector-ref f115 0)))))
# emit-expr (let ((f115 ((primitive-ref vector) ()))) (begin (vector-set! f115 0 (cons ((primitive-ref string->symbol) "procedure?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "cdr") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "car") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "symbol-value") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "symbol->string") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "make-symbol") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "symbol?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "string-set!") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "string-ref") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "string-length") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "string?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "make-string") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "vector-ref") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "vector-set!") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "vector-length") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "make-vector") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "vector?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "set-cdr!") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "set-car!") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "cdr") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "car") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "cons") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "pair?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fxremainder") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fxquotient") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fx*") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fx-") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fx+") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fx>=") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fx>") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fx<=") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fx<") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fx=") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "eof-object") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "eof-object?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f115 0))) (closure () (f115) (let () (vector-ref f115 0)))))
# emit-let
#  si   = 0
#  env  = ()
#  bindings = ((f115 ((primitive-ref vector) ())))
#  body = (begin (vector-set! f115 0 (cons ((primitive-ref string->symbol) "procedure?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "cdr") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "car") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "symbol-value") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "symbol->string") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "make-symbol") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "symbol?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "string-set!") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "string-ref") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "string-length") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "string?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "make-string") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "vector-ref") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "vector-set!") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "vector-length") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "make-vector") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "vector?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "set-cdr!") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "set-car!") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "cdr") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "car") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "cons") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "pair?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fxremainder") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fxquotient") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fx*") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fx-") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fx+") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fx>=") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fx>") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fx<=") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fx<") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fx=") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "eof-object") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "eof-object?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f115 0))) (closure () (f115) (let () (vector-ref f115 0))))
# emit-expr ((primitive-ref vector) ())
# funcall
#    si   =0
#    env  = ()
#    expr = (funcall (primitive-ref vector) ())
# emit-expr (primitive-ref vector)
    .extern mrc_vector
    movl mrc_vector,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_326"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_326":
   movl %eax,  -8(%esp)  # stash funcall-oper in closure slot
# emit-expr ()
    movl $63, %eax     # immed ()
    mov %eax, -12(%esp)  # arg ()
    movl -8(%esp), %edi   # load new closure to %edi
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    movl -4(%esp), %edi   # restore closure frame ptr
    movl %eax, 0(%esp)  # stack save
# emit-expr (begin (vector-set! f115 0 (cons ((primitive-ref string->symbol) "procedure?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "cdr") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "car") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "symbol-value") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "symbol->string") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "make-symbol") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "symbol?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "string-set!") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "string-ref") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "string-length") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "string?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "make-string") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "vector-ref") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "vector-set!") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "vector-length") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "make-vector") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "vector?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "set-cdr!") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "set-car!") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "cdr") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "car") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "cons") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "pair?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fxremainder") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fxquotient") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fx*") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fx-") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fx+") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fx>=") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fx>") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fx<=") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fx<") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fx=") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "eof-object") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "eof-object?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f115 0))) (closure () (f115) (let () (vector-ref f115 0))))
# emit-begin
#   expr=(begin (vector-set! f115 0 (cons ((primitive-ref string->symbol) "procedure?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "cdr") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "car") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "symbol-value") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "symbol->string") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "make-symbol") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "symbol?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "string-set!") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "string-ref") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "string-length") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "string?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "make-string") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "vector-ref") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "vector-set!") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "vector-length") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "make-vector") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "vector?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "set-cdr!") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "set-car!") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "cdr") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "car") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "cons") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "pair?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fxremainder") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fxquotient") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fx*") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fx-") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fx+") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fx>=") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fx>") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fx<=") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fx<") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fx=") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "eof-object") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "eof-object?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f115 0))) (closure () (f115) (let () (vector-ref f115 0))))
#   env=((f115 . 0))
# emit-expr (vector-set! f115 0 (cons ((primitive-ref string->symbol) "procedure?") (vector-ref f115 0)))
# emit-expr f115
# emit-variable-ref
# env=((f115 . 0))
# var=f115
    movl 0(%esp), %eax  # stack load f115
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_327
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_327:
    movl %eax, -4(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_328"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_328:
# check bounds on vector index
    movl -4(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_330
    cmp  $0,%eax
    jge _L_329
_L_330:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_329:
    movl %eax, -8(%esp)
# emit-expr (cons ((primitive-ref string->symbol) "procedure?") (vector-ref f115 0))
# cons arg1=((primitive-ref string->symbol) "procedure?") arg2=(vector-ref f115 0)
# emit-expr ((primitive-ref string->symbol) "procedure?")
# funcall
#    si   =-12
#    env  = ((f115 . 0))
#    expr = (funcall (primitive-ref string->symbol) "procedure?")
# emit-expr (primitive-ref string->symbol)
    .extern mrc_string$m$gsymbol
    movl mrc_string$m$gsymbol,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_331"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_331":
   movl %eax,  -20(%esp)  # stash funcall-oper in closure slot
# emit-expr "procedure?"
# string literal
    jmp _L_333
    .align 8,0x90
_L_332 :
    .int 40
    .ascii "procedure?"
_L_333:
    movl $_L_332, %eax
    orl $6, %eax
    mov %eax, -24(%esp)  # arg procedure?
    movl -20(%esp), %edi   # load new closure to %edi
    add $-12, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $12, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    movl %eax, -12(%esp)
# emit-expr (vector-ref f115 0)
# emit-expr f115
# emit-variable-ref
# env=((f115 . 0))
# var=f115
    movl 0(%esp), %eax  # stack load f115
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_334
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_334:
    movl %eax, -16(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_335"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_335:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_337
    cmp  $0,%eax
    jge _L_336
_L_337:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_336:
    movl -16(%esp), %esi
    movl -1(%eax,%esi), %eax
    movl %eax, 4(%ebp)
    movl -12(%esp), %eax
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    or   $1, %al
    add  $8, %ebp
# cons end
    movl -4(%esp), %ebx
    movl -8(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin (vector-set! f115 0 (cons ((primitive-ref string->symbol) "cdr") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "car") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "symbol-value") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "symbol->string") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "make-symbol") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "symbol?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "string-set!") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "string-ref") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "string-length") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "string?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "make-string") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "vector-ref") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "vector-set!") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "vector-length") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "make-vector") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "vector?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "set-cdr!") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "set-car!") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "cdr") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "car") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "cons") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "pair?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fxremainder") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fxquotient") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fx*") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fx-") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fx+") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fx>=") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fx>") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fx<=") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fx<") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fx=") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "eof-object") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "eof-object?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f115 0))) (closure () (f115) (let () (vector-ref f115 0))))
# emit-begin
#   expr=(begin (vector-set! f115 0 (cons ((primitive-ref string->symbol) "cdr") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "car") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "symbol-value") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "symbol->string") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "make-symbol") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "symbol?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "string-set!") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "string-ref") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "string-length") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "string?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "make-string") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "vector-ref") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "vector-set!") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "vector-length") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "make-vector") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "vector?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "set-cdr!") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "set-car!") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "cdr") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "car") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "cons") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "pair?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fxremainder") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fxquotient") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fx*") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fx-") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fx+") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fx>=") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fx>") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fx<=") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fx<") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fx=") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "eof-object") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "eof-object?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f115 0))) (closure () (f115) (let () (vector-ref f115 0))))
#   env=((f115 . 0))
# emit-expr (vector-set! f115 0 (cons ((primitive-ref string->symbol) "cdr") (vector-ref f115 0)))
# emit-expr f115
# emit-variable-ref
# env=((f115 . 0))
# var=f115
    movl 0(%esp), %eax  # stack load f115
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_338
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_338:
    movl %eax, -4(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_339"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_339:
# check bounds on vector index
    movl -4(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_341
    cmp  $0,%eax
    jge _L_340
_L_341:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_340:
    movl %eax, -8(%esp)
# emit-expr (cons ((primitive-ref string->symbol) "cdr") (vector-ref f115 0))
# cons arg1=((primitive-ref string->symbol) "cdr") arg2=(vector-ref f115 0)
# emit-expr ((primitive-ref string->symbol) "cdr")
# funcall
#    si   =-12
#    env  = ((f115 . 0))
#    expr = (funcall (primitive-ref string->symbol) "cdr")
# emit-expr (primitive-ref string->symbol)
    .extern mrc_string$m$gsymbol
    movl mrc_string$m$gsymbol,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_342"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_342":
   movl %eax,  -20(%esp)  # stash funcall-oper in closure slot
# emit-expr "cdr"
# string literal
    jmp _L_344
    .align 8,0x90
_L_343 :
    .int 12
    .ascii "cdr"
_L_344:
    movl $_L_343, %eax
    orl $6, %eax
    mov %eax, -24(%esp)  # arg cdr
    movl -20(%esp), %edi   # load new closure to %edi
    add $-12, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $12, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    movl %eax, -12(%esp)
# emit-expr (vector-ref f115 0)
# emit-expr f115
# emit-variable-ref
# env=((f115 . 0))
# var=f115
    movl 0(%esp), %eax  # stack load f115
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_345
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_345:
    movl %eax, -16(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_346"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_346:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_348
    cmp  $0,%eax
    jge _L_347
_L_348:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_347:
    movl -16(%esp), %esi
    movl -1(%eax,%esi), %eax
    movl %eax, 4(%ebp)
    movl -12(%esp), %eax
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    or   $1, %al
    add  $8, %ebp
# cons end
    movl -4(%esp), %ebx
    movl -8(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin (vector-set! f115 0 (cons ((primitive-ref string->symbol) "car") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "symbol-value") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "symbol->string") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "make-symbol") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "symbol?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "string-set!") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "string-ref") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "string-length") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "string?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "make-string") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "vector-ref") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "vector-set!") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "vector-length") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "make-vector") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "vector?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "set-cdr!") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "set-car!") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "cdr") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "car") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "cons") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "pair?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fxremainder") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fxquotient") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fx*") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fx-") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fx+") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fx>=") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fx>") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fx<=") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fx<") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fx=") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "eof-object") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "eof-object?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f115 0))) (closure () (f115) (let () (vector-ref f115 0))))
# emit-begin
#   expr=(begin (vector-set! f115 0 (cons ((primitive-ref string->symbol) "car") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "symbol-value") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "symbol->string") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "make-symbol") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "symbol?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "string-set!") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "string-ref") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "string-length") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "string?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "make-string") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "vector-ref") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "vector-set!") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "vector-length") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "make-vector") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "vector?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "set-cdr!") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "set-car!") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "cdr") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "car") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "cons") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "pair?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fxremainder") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fxquotient") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fx*") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fx-") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fx+") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fx>=") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fx>") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fx<=") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fx<") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fx=") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "eof-object") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "eof-object?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f115 0))) (closure () (f115) (let () (vector-ref f115 0))))
#   env=((f115 . 0))
# emit-expr (vector-set! f115 0 (cons ((primitive-ref string->symbol) "car") (vector-ref f115 0)))
# emit-expr f115
# emit-variable-ref
# env=((f115 . 0))
# var=f115
    movl 0(%esp), %eax  # stack load f115
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_349
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_349:
    movl %eax, -4(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_350"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_350:
# check bounds on vector index
    movl -4(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_352
    cmp  $0,%eax
    jge _L_351
_L_352:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_351:
    movl %eax, -8(%esp)
# emit-expr (cons ((primitive-ref string->symbol) "car") (vector-ref f115 0))
# cons arg1=((primitive-ref string->symbol) "car") arg2=(vector-ref f115 0)
# emit-expr ((primitive-ref string->symbol) "car")
# funcall
#    si   =-12
#    env  = ((f115 . 0))
#    expr = (funcall (primitive-ref string->symbol) "car")
# emit-expr (primitive-ref string->symbol)
    .extern mrc_string$m$gsymbol
    movl mrc_string$m$gsymbol,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_353"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_353":
   movl %eax,  -20(%esp)  # stash funcall-oper in closure slot
# emit-expr "car"
# string literal
    jmp _L_355
    .align 8,0x90
_L_354 :
    .int 12
    .ascii "car"
_L_355:
    movl $_L_354, %eax
    orl $6, %eax
    mov %eax, -24(%esp)  # arg car
    movl -20(%esp), %edi   # load new closure to %edi
    add $-12, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $12, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    movl %eax, -12(%esp)
# emit-expr (vector-ref f115 0)
# emit-expr f115
# emit-variable-ref
# env=((f115 . 0))
# var=f115
    movl 0(%esp), %eax  # stack load f115
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_356
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_356:
    movl %eax, -16(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_357"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_357:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_359
    cmp  $0,%eax
    jge _L_358
_L_359:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_358:
    movl -16(%esp), %esi
    movl -1(%eax,%esi), %eax
    movl %eax, 4(%ebp)
    movl -12(%esp), %eax
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    or   $1, %al
    add  $8, %ebp
# cons end
    movl -4(%esp), %ebx
    movl -8(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin (vector-set! f115 0 (cons ((primitive-ref string->symbol) "symbol-value") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "symbol->string") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "make-symbol") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "symbol?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "string-set!") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "string-ref") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "string-length") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "string?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "make-string") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "vector-ref") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "vector-set!") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "vector-length") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "make-vector") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "vector?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "set-cdr!") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "set-car!") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "cdr") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "car") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "cons") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "pair?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fxremainder") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fxquotient") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fx*") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fx-") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fx+") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fx>=") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fx>") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fx<=") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fx<") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fx=") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "eof-object") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "eof-object?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f115 0))) (closure () (f115) (let () (vector-ref f115 0))))
# emit-begin
#   expr=(begin (vector-set! f115 0 (cons ((primitive-ref string->symbol) "symbol-value") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "symbol->string") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "make-symbol") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "symbol?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "string-set!") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "string-ref") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "string-length") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "string?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "make-string") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "vector-ref") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "vector-set!") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "vector-length") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "make-vector") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "vector?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "set-cdr!") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "set-car!") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "cdr") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "car") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "cons") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "pair?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fxremainder") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fxquotient") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fx*") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fx-") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fx+") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fx>=") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fx>") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fx<=") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fx<") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fx=") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "eof-object") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "eof-object?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f115 0))) (closure () (f115) (let () (vector-ref f115 0))))
#   env=((f115 . 0))
# emit-expr (vector-set! f115 0 (cons ((primitive-ref string->symbol) "symbol-value") (vector-ref f115 0)))
# emit-expr f115
# emit-variable-ref
# env=((f115 . 0))
# var=f115
    movl 0(%esp), %eax  # stack load f115
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_360
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_360:
    movl %eax, -4(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_361"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_361:
# check bounds on vector index
    movl -4(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_363
    cmp  $0,%eax
    jge _L_362
_L_363:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_362:
    movl %eax, -8(%esp)
# emit-expr (cons ((primitive-ref string->symbol) "symbol-value") (vector-ref f115 0))
# cons arg1=((primitive-ref string->symbol) "symbol-value") arg2=(vector-ref f115 0)
# emit-expr ((primitive-ref string->symbol) "symbol-value")
# funcall
#    si   =-12
#    env  = ((f115 . 0))
#    expr = (funcall (primitive-ref string->symbol) "symbol-value")
# emit-expr (primitive-ref string->symbol)
    .extern mrc_string$m$gsymbol
    movl mrc_string$m$gsymbol,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_364"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_364":
   movl %eax,  -20(%esp)  # stash funcall-oper in closure slot
# emit-expr "symbol-value"
# string literal
    jmp _L_366
    .align 8,0x90
_L_365 :
    .int 48
    .ascii "symbol-value"
_L_366:
    movl $_L_365, %eax
    orl $6, %eax
    mov %eax, -24(%esp)  # arg symbol-value
    movl -20(%esp), %edi   # load new closure to %edi
    add $-12, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $12, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    movl %eax, -12(%esp)
# emit-expr (vector-ref f115 0)
# emit-expr f115
# emit-variable-ref
# env=((f115 . 0))
# var=f115
    movl 0(%esp), %eax  # stack load f115
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_367
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_367:
    movl %eax, -16(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_368"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_368:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_370
    cmp  $0,%eax
    jge _L_369
_L_370:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_369:
    movl -16(%esp), %esi
    movl -1(%eax,%esi), %eax
    movl %eax, 4(%ebp)
    movl -12(%esp), %eax
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    or   $1, %al
    add  $8, %ebp
# cons end
    movl -4(%esp), %ebx
    movl -8(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin (vector-set! f115 0 (cons ((primitive-ref string->symbol) "symbol->string") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "make-symbol") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "symbol?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "string-set!") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "string-ref") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "string-length") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "string?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "make-string") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "vector-ref") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "vector-set!") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "vector-length") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "make-vector") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "vector?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "set-cdr!") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "set-car!") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "cdr") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "car") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "cons") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "pair?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fxremainder") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fxquotient") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fx*") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fx-") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fx+") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fx>=") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fx>") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fx<=") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fx<") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fx=") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "eof-object") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "eof-object?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f115 0))) (closure () (f115) (let () (vector-ref f115 0))))
# emit-begin
#   expr=(begin (vector-set! f115 0 (cons ((primitive-ref string->symbol) "symbol->string") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "make-symbol") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "symbol?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "string-set!") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "string-ref") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "string-length") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "string?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "make-string") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "vector-ref") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "vector-set!") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "vector-length") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "make-vector") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "vector?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "set-cdr!") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "set-car!") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "cdr") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "car") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "cons") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "pair?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fxremainder") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fxquotient") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fx*") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fx-") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fx+") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fx>=") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fx>") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fx<=") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fx<") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fx=") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "eof-object") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "eof-object?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f115 0))) (closure () (f115) (let () (vector-ref f115 0))))
#   env=((f115 . 0))
# emit-expr (vector-set! f115 0 (cons ((primitive-ref string->symbol) "symbol->string") (vector-ref f115 0)))
# emit-expr f115
# emit-variable-ref
# env=((f115 . 0))
# var=f115
    movl 0(%esp), %eax  # stack load f115
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_371
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_371:
    movl %eax, -4(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_372"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_372:
# check bounds on vector index
    movl -4(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_374
    cmp  $0,%eax
    jge _L_373
_L_374:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_373:
    movl %eax, -8(%esp)
# emit-expr (cons ((primitive-ref string->symbol) "symbol->string") (vector-ref f115 0))
# cons arg1=((primitive-ref string->symbol) "symbol->string") arg2=(vector-ref f115 0)
# emit-expr ((primitive-ref string->symbol) "symbol->string")
# funcall
#    si   =-12
#    env  = ((f115 . 0))
#    expr = (funcall (primitive-ref string->symbol) "symbol->string")
# emit-expr (primitive-ref string->symbol)
    .extern mrc_string$m$gsymbol
    movl mrc_string$m$gsymbol,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_375"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_375":
   movl %eax,  -20(%esp)  # stash funcall-oper in closure slot
# emit-expr "symbol->string"
# string literal
    jmp _L_377
    .align 8,0x90
_L_376 :
    .int 56
    .ascii "symbol->string"
_L_377:
    movl $_L_376, %eax
    orl $6, %eax
    mov %eax, -24(%esp)  # arg symbol->string
    movl -20(%esp), %edi   # load new closure to %edi
    add $-12, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $12, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    movl %eax, -12(%esp)
# emit-expr (vector-ref f115 0)
# emit-expr f115
# emit-variable-ref
# env=((f115 . 0))
# var=f115
    movl 0(%esp), %eax  # stack load f115
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_378
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_378:
    movl %eax, -16(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_379"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_379:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_381
    cmp  $0,%eax
    jge _L_380
_L_381:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_380:
    movl -16(%esp), %esi
    movl -1(%eax,%esi), %eax
    movl %eax, 4(%ebp)
    movl -12(%esp), %eax
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    or   $1, %al
    add  $8, %ebp
# cons end
    movl -4(%esp), %ebx
    movl -8(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin (vector-set! f115 0 (cons ((primitive-ref string->symbol) "make-symbol") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "symbol?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "string-set!") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "string-ref") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "string-length") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "string?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "make-string") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "vector-ref") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "vector-set!") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "vector-length") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "make-vector") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "vector?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "set-cdr!") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "set-car!") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "cdr") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "car") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "cons") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "pair?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fxremainder") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fxquotient") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fx*") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fx-") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fx+") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fx>=") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fx>") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fx<=") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fx<") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fx=") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "eof-object") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "eof-object?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f115 0))) (closure () (f115) (let () (vector-ref f115 0))))
# emit-begin
#   expr=(begin (vector-set! f115 0 (cons ((primitive-ref string->symbol) "make-symbol") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "symbol?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "string-set!") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "string-ref") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "string-length") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "string?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "make-string") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "vector-ref") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "vector-set!") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "vector-length") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "make-vector") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "vector?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "set-cdr!") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "set-car!") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "cdr") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "car") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "cons") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "pair?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fxremainder") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fxquotient") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fx*") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fx-") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fx+") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fx>=") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fx>") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fx<=") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fx<") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fx=") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "eof-object") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "eof-object?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f115 0))) (closure () (f115) (let () (vector-ref f115 0))))
#   env=((f115 . 0))
# emit-expr (vector-set! f115 0 (cons ((primitive-ref string->symbol) "make-symbol") (vector-ref f115 0)))
# emit-expr f115
# emit-variable-ref
# env=((f115 . 0))
# var=f115
    movl 0(%esp), %eax  # stack load f115
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_382
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_382:
    movl %eax, -4(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_383"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_383:
# check bounds on vector index
    movl -4(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_385
    cmp  $0,%eax
    jge _L_384
_L_385:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_384:
    movl %eax, -8(%esp)
# emit-expr (cons ((primitive-ref string->symbol) "make-symbol") (vector-ref f115 0))
# cons arg1=((primitive-ref string->symbol) "make-symbol") arg2=(vector-ref f115 0)
# emit-expr ((primitive-ref string->symbol) "make-symbol")
# funcall
#    si   =-12
#    env  = ((f115 . 0))
#    expr = (funcall (primitive-ref string->symbol) "make-symbol")
# emit-expr (primitive-ref string->symbol)
    .extern mrc_string$m$gsymbol
    movl mrc_string$m$gsymbol,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_386"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_386":
   movl %eax,  -20(%esp)  # stash funcall-oper in closure slot
# emit-expr "make-symbol"
# string literal
    jmp _L_388
    .align 8,0x90
_L_387 :
    .int 44
    .ascii "make-symbol"
_L_388:
    movl $_L_387, %eax
    orl $6, %eax
    mov %eax, -24(%esp)  # arg make-symbol
    movl -20(%esp), %edi   # load new closure to %edi
    add $-12, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $12, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    movl %eax, -12(%esp)
# emit-expr (vector-ref f115 0)
# emit-expr f115
# emit-variable-ref
# env=((f115 . 0))
# var=f115
    movl 0(%esp), %eax  # stack load f115
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_389
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_389:
    movl %eax, -16(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_390"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_390:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_392
    cmp  $0,%eax
    jge _L_391
_L_392:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_391:
    movl -16(%esp), %esi
    movl -1(%eax,%esi), %eax
    movl %eax, 4(%ebp)
    movl -12(%esp), %eax
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    or   $1, %al
    add  $8, %ebp
# cons end
    movl -4(%esp), %ebx
    movl -8(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin (vector-set! f115 0 (cons ((primitive-ref string->symbol) "symbol?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "string-set!") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "string-ref") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "string-length") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "string?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "make-string") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "vector-ref") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "vector-set!") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "vector-length") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "make-vector") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "vector?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "set-cdr!") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "set-car!") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "cdr") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "car") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "cons") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "pair?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fxremainder") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fxquotient") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fx*") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fx-") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fx+") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fx>=") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fx>") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fx<=") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fx<") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fx=") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "eof-object") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "eof-object?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f115 0))) (closure () (f115) (let () (vector-ref f115 0))))
# emit-begin
#   expr=(begin (vector-set! f115 0 (cons ((primitive-ref string->symbol) "symbol?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "string-set!") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "string-ref") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "string-length") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "string?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "make-string") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "vector-ref") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "vector-set!") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "vector-length") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "make-vector") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "vector?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "set-cdr!") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "set-car!") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "cdr") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "car") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "cons") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "pair?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fxremainder") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fxquotient") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fx*") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fx-") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fx+") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fx>=") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fx>") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fx<=") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fx<") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fx=") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "eof-object") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "eof-object?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f115 0))) (closure () (f115) (let () (vector-ref f115 0))))
#   env=((f115 . 0))
# emit-expr (vector-set! f115 0 (cons ((primitive-ref string->symbol) "symbol?") (vector-ref f115 0)))
# emit-expr f115
# emit-variable-ref
# env=((f115 . 0))
# var=f115
    movl 0(%esp), %eax  # stack load f115
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_393
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_393:
    movl %eax, -4(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_394"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_394:
# check bounds on vector index
    movl -4(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_396
    cmp  $0,%eax
    jge _L_395
_L_396:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_395:
    movl %eax, -8(%esp)
# emit-expr (cons ((primitive-ref string->symbol) "symbol?") (vector-ref f115 0))
# cons arg1=((primitive-ref string->symbol) "symbol?") arg2=(vector-ref f115 0)
# emit-expr ((primitive-ref string->symbol) "symbol?")
# funcall
#    si   =-12
#    env  = ((f115 . 0))
#    expr = (funcall (primitive-ref string->symbol) "symbol?")
# emit-expr (primitive-ref string->symbol)
    .extern mrc_string$m$gsymbol
    movl mrc_string$m$gsymbol,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_397"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_397":
   movl %eax,  -20(%esp)  # stash funcall-oper in closure slot
# emit-expr "symbol?"
# string literal
    jmp _L_399
    .align 8,0x90
_L_398 :
    .int 28
    .ascii "symbol?"
_L_399:
    movl $_L_398, %eax
    orl $6, %eax
    mov %eax, -24(%esp)  # arg symbol?
    movl -20(%esp), %edi   # load new closure to %edi
    add $-12, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $12, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    movl %eax, -12(%esp)
# emit-expr (vector-ref f115 0)
# emit-expr f115
# emit-variable-ref
# env=((f115 . 0))
# var=f115
    movl 0(%esp), %eax  # stack load f115
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_400
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_400:
    movl %eax, -16(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_401"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_401:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_403
    cmp  $0,%eax
    jge _L_402
_L_403:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_402:
    movl -16(%esp), %esi
    movl -1(%eax,%esi), %eax
    movl %eax, 4(%ebp)
    movl -12(%esp), %eax
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    or   $1, %al
    add  $8, %ebp
# cons end
    movl -4(%esp), %ebx
    movl -8(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin (vector-set! f115 0 (cons ((primitive-ref string->symbol) "string-set!") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "string-ref") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "string-length") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "string?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "make-string") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "vector-ref") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "vector-set!") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "vector-length") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "make-vector") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "vector?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "set-cdr!") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "set-car!") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "cdr") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "car") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "cons") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "pair?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fxremainder") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fxquotient") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fx*") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fx-") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fx+") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fx>=") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fx>") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fx<=") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fx<") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fx=") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "eof-object") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "eof-object?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f115 0))) (closure () (f115) (let () (vector-ref f115 0))))
# emit-begin
#   expr=(begin (vector-set! f115 0 (cons ((primitive-ref string->symbol) "string-set!") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "string-ref") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "string-length") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "string?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "make-string") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "vector-ref") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "vector-set!") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "vector-length") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "make-vector") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "vector?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "set-cdr!") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "set-car!") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "cdr") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "car") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "cons") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "pair?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fxremainder") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fxquotient") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fx*") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fx-") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fx+") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fx>=") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fx>") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fx<=") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fx<") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fx=") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "eof-object") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "eof-object?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f115 0))) (closure () (f115) (let () (vector-ref f115 0))))
#   env=((f115 . 0))
# emit-expr (vector-set! f115 0 (cons ((primitive-ref string->symbol) "string-set!") (vector-ref f115 0)))
# emit-expr f115
# emit-variable-ref
# env=((f115 . 0))
# var=f115
    movl 0(%esp), %eax  # stack load f115
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_404
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_404:
    movl %eax, -4(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_405"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_405:
# check bounds on vector index
    movl -4(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_407
    cmp  $0,%eax
    jge _L_406
_L_407:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_406:
    movl %eax, -8(%esp)
# emit-expr (cons ((primitive-ref string->symbol) "string-set!") (vector-ref f115 0))
# cons arg1=((primitive-ref string->symbol) "string-set!") arg2=(vector-ref f115 0)
# emit-expr ((primitive-ref string->symbol) "string-set!")
# funcall
#    si   =-12
#    env  = ((f115 . 0))
#    expr = (funcall (primitive-ref string->symbol) "string-set!")
# emit-expr (primitive-ref string->symbol)
    .extern mrc_string$m$gsymbol
    movl mrc_string$m$gsymbol,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_408"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_408":
   movl %eax,  -20(%esp)  # stash funcall-oper in closure slot
# emit-expr "string-set!"
# string literal
    jmp _L_410
    .align 8,0x90
_L_409 :
    .int 44
    .ascii "string-set!"
_L_410:
    movl $_L_409, %eax
    orl $6, %eax
    mov %eax, -24(%esp)  # arg string-set!
    movl -20(%esp), %edi   # load new closure to %edi
    add $-12, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $12, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    movl %eax, -12(%esp)
# emit-expr (vector-ref f115 0)
# emit-expr f115
# emit-variable-ref
# env=((f115 . 0))
# var=f115
    movl 0(%esp), %eax  # stack load f115
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_411
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_411:
    movl %eax, -16(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_412"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_412:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_414
    cmp  $0,%eax
    jge _L_413
_L_414:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_413:
    movl -16(%esp), %esi
    movl -1(%eax,%esi), %eax
    movl %eax, 4(%ebp)
    movl -12(%esp), %eax
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    or   $1, %al
    add  $8, %ebp
# cons end
    movl -4(%esp), %ebx
    movl -8(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin (vector-set! f115 0 (cons ((primitive-ref string->symbol) "string-ref") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "string-length") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "string?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "make-string") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "vector-ref") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "vector-set!") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "vector-length") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "make-vector") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "vector?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "set-cdr!") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "set-car!") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "cdr") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "car") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "cons") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "pair?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fxremainder") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fxquotient") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fx*") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fx-") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fx+") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fx>=") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fx>") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fx<=") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fx<") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fx=") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "eof-object") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "eof-object?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f115 0))) (closure () (f115) (let () (vector-ref f115 0))))
# emit-begin
#   expr=(begin (vector-set! f115 0 (cons ((primitive-ref string->symbol) "string-ref") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "string-length") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "string?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "make-string") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "vector-ref") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "vector-set!") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "vector-length") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "make-vector") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "vector?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "set-cdr!") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "set-car!") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "cdr") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "car") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "cons") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "pair?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fxremainder") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fxquotient") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fx*") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fx-") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fx+") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fx>=") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fx>") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fx<=") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fx<") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fx=") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "eof-object") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "eof-object?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f115 0))) (closure () (f115) (let () (vector-ref f115 0))))
#   env=((f115 . 0))
# emit-expr (vector-set! f115 0 (cons ((primitive-ref string->symbol) "string-ref") (vector-ref f115 0)))
# emit-expr f115
# emit-variable-ref
# env=((f115 . 0))
# var=f115
    movl 0(%esp), %eax  # stack load f115
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_415
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_415:
    movl %eax, -4(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_416"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_416:
# check bounds on vector index
    movl -4(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_418
    cmp  $0,%eax
    jge _L_417
_L_418:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_417:
    movl %eax, -8(%esp)
# emit-expr (cons ((primitive-ref string->symbol) "string-ref") (vector-ref f115 0))
# cons arg1=((primitive-ref string->symbol) "string-ref") arg2=(vector-ref f115 0)
# emit-expr ((primitive-ref string->symbol) "string-ref")
# funcall
#    si   =-12
#    env  = ((f115 . 0))
#    expr = (funcall (primitive-ref string->symbol) "string-ref")
# emit-expr (primitive-ref string->symbol)
    .extern mrc_string$m$gsymbol
    movl mrc_string$m$gsymbol,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_419"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_419":
   movl %eax,  -20(%esp)  # stash funcall-oper in closure slot
# emit-expr "string-ref"
# string literal
    jmp _L_421
    .align 8,0x90
_L_420 :
    .int 40
    .ascii "string-ref"
_L_421:
    movl $_L_420, %eax
    orl $6, %eax
    mov %eax, -24(%esp)  # arg string-ref
    movl -20(%esp), %edi   # load new closure to %edi
    add $-12, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $12, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    movl %eax, -12(%esp)
# emit-expr (vector-ref f115 0)
# emit-expr f115
# emit-variable-ref
# env=((f115 . 0))
# var=f115
    movl 0(%esp), %eax  # stack load f115
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_422
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_422:
    movl %eax, -16(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_423"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_423:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_425
    cmp  $0,%eax
    jge _L_424
_L_425:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_424:
    movl -16(%esp), %esi
    movl -1(%eax,%esi), %eax
    movl %eax, 4(%ebp)
    movl -12(%esp), %eax
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    or   $1, %al
    add  $8, %ebp
# cons end
    movl -4(%esp), %ebx
    movl -8(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin (vector-set! f115 0 (cons ((primitive-ref string->symbol) "string-length") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "string?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "make-string") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "vector-ref") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "vector-set!") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "vector-length") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "make-vector") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "vector?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "set-cdr!") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "set-car!") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "cdr") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "car") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "cons") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "pair?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fxremainder") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fxquotient") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fx*") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fx-") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fx+") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fx>=") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fx>") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fx<=") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fx<") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fx=") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "eof-object") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "eof-object?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f115 0))) (closure () (f115) (let () (vector-ref f115 0))))
# emit-begin
#   expr=(begin (vector-set! f115 0 (cons ((primitive-ref string->symbol) "string-length") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "string?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "make-string") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "vector-ref") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "vector-set!") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "vector-length") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "make-vector") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "vector?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "set-cdr!") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "set-car!") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "cdr") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "car") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "cons") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "pair?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fxremainder") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fxquotient") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fx*") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fx-") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fx+") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fx>=") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fx>") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fx<=") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fx<") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fx=") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "eof-object") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "eof-object?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f115 0))) (closure () (f115) (let () (vector-ref f115 0))))
#   env=((f115 . 0))
# emit-expr (vector-set! f115 0 (cons ((primitive-ref string->symbol) "string-length") (vector-ref f115 0)))
# emit-expr f115
# emit-variable-ref
# env=((f115 . 0))
# var=f115
    movl 0(%esp), %eax  # stack load f115
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_426
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_426:
    movl %eax, -4(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_427"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_427:
# check bounds on vector index
    movl -4(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_429
    cmp  $0,%eax
    jge _L_428
_L_429:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_428:
    movl %eax, -8(%esp)
# emit-expr (cons ((primitive-ref string->symbol) "string-length") (vector-ref f115 0))
# cons arg1=((primitive-ref string->symbol) "string-length") arg2=(vector-ref f115 0)
# emit-expr ((primitive-ref string->symbol) "string-length")
# funcall
#    si   =-12
#    env  = ((f115 . 0))
#    expr = (funcall (primitive-ref string->symbol) "string-length")
# emit-expr (primitive-ref string->symbol)
    .extern mrc_string$m$gsymbol
    movl mrc_string$m$gsymbol,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_430"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_430":
   movl %eax,  -20(%esp)  # stash funcall-oper in closure slot
# emit-expr "string-length"
# string literal
    jmp _L_432
    .align 8,0x90
_L_431 :
    .int 52
    .ascii "string-length"
_L_432:
    movl $_L_431, %eax
    orl $6, %eax
    mov %eax, -24(%esp)  # arg string-length
    movl -20(%esp), %edi   # load new closure to %edi
    add $-12, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $12, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    movl %eax, -12(%esp)
# emit-expr (vector-ref f115 0)
# emit-expr f115
# emit-variable-ref
# env=((f115 . 0))
# var=f115
    movl 0(%esp), %eax  # stack load f115
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_433
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_433:
    movl %eax, -16(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_434"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_434:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_436
    cmp  $0,%eax
    jge _L_435
_L_436:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_435:
    movl -16(%esp), %esi
    movl -1(%eax,%esi), %eax
    movl %eax, 4(%ebp)
    movl -12(%esp), %eax
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    or   $1, %al
    add  $8, %ebp
# cons end
    movl -4(%esp), %ebx
    movl -8(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin (vector-set! f115 0 (cons ((primitive-ref string->symbol) "string?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "make-string") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "vector-ref") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "vector-set!") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "vector-length") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "make-vector") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "vector?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "set-cdr!") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "set-car!") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "cdr") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "car") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "cons") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "pair?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fxremainder") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fxquotient") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fx*") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fx-") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fx+") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fx>=") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fx>") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fx<=") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fx<") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fx=") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "eof-object") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "eof-object?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f115 0))) (closure () (f115) (let () (vector-ref f115 0))))
# emit-begin
#   expr=(begin (vector-set! f115 0 (cons ((primitive-ref string->symbol) "string?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "make-string") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "vector-ref") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "vector-set!") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "vector-length") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "make-vector") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "vector?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "set-cdr!") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "set-car!") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "cdr") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "car") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "cons") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "pair?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fxremainder") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fxquotient") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fx*") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fx-") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fx+") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fx>=") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fx>") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fx<=") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fx<") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fx=") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "eof-object") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "eof-object?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f115 0))) (closure () (f115) (let () (vector-ref f115 0))))
#   env=((f115 . 0))
# emit-expr (vector-set! f115 0 (cons ((primitive-ref string->symbol) "string?") (vector-ref f115 0)))
# emit-expr f115
# emit-variable-ref
# env=((f115 . 0))
# var=f115
    movl 0(%esp), %eax  # stack load f115
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_437
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_437:
    movl %eax, -4(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_438"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_438:
# check bounds on vector index
    movl -4(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_440
    cmp  $0,%eax
    jge _L_439
_L_440:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_439:
    movl %eax, -8(%esp)
# emit-expr (cons ((primitive-ref string->symbol) "string?") (vector-ref f115 0))
# cons arg1=((primitive-ref string->symbol) "string?") arg2=(vector-ref f115 0)
# emit-expr ((primitive-ref string->symbol) "string?")
# funcall
#    si   =-12
#    env  = ((f115 . 0))
#    expr = (funcall (primitive-ref string->symbol) "string?")
# emit-expr (primitive-ref string->symbol)
    .extern mrc_string$m$gsymbol
    movl mrc_string$m$gsymbol,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_441"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_441":
   movl %eax,  -20(%esp)  # stash funcall-oper in closure slot
# emit-expr "string?"
# string literal
    jmp _L_443
    .align 8,0x90
_L_442 :
    .int 28
    .ascii "string?"
_L_443:
    movl $_L_442, %eax
    orl $6, %eax
    mov %eax, -24(%esp)  # arg string?
    movl -20(%esp), %edi   # load new closure to %edi
    add $-12, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $12, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    movl %eax, -12(%esp)
# emit-expr (vector-ref f115 0)
# emit-expr f115
# emit-variable-ref
# env=((f115 . 0))
# var=f115
    movl 0(%esp), %eax  # stack load f115
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_444
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_444:
    movl %eax, -16(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_445"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_445:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_447
    cmp  $0,%eax
    jge _L_446
_L_447:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_446:
    movl -16(%esp), %esi
    movl -1(%eax,%esi), %eax
    movl %eax, 4(%ebp)
    movl -12(%esp), %eax
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    or   $1, %al
    add  $8, %ebp
# cons end
    movl -4(%esp), %ebx
    movl -8(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin (vector-set! f115 0 (cons ((primitive-ref string->symbol) "make-string") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "vector-ref") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "vector-set!") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "vector-length") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "make-vector") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "vector?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "set-cdr!") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "set-car!") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "cdr") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "car") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "cons") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "pair?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fxremainder") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fxquotient") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fx*") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fx-") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fx+") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fx>=") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fx>") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fx<=") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fx<") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fx=") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "eof-object") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "eof-object?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f115 0))) (closure () (f115) (let () (vector-ref f115 0))))
# emit-begin
#   expr=(begin (vector-set! f115 0 (cons ((primitive-ref string->symbol) "make-string") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "vector-ref") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "vector-set!") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "vector-length") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "make-vector") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "vector?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "set-cdr!") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "set-car!") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "cdr") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "car") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "cons") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "pair?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fxremainder") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fxquotient") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fx*") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fx-") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fx+") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fx>=") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fx>") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fx<=") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fx<") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fx=") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "eof-object") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "eof-object?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f115 0))) (closure () (f115) (let () (vector-ref f115 0))))
#   env=((f115 . 0))
# emit-expr (vector-set! f115 0 (cons ((primitive-ref string->symbol) "make-string") (vector-ref f115 0)))
# emit-expr f115
# emit-variable-ref
# env=((f115 . 0))
# var=f115
    movl 0(%esp), %eax  # stack load f115
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_448
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_448:
    movl %eax, -4(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_449"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_449:
# check bounds on vector index
    movl -4(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_451
    cmp  $0,%eax
    jge _L_450
_L_451:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_450:
    movl %eax, -8(%esp)
# emit-expr (cons ((primitive-ref string->symbol) "make-string") (vector-ref f115 0))
# cons arg1=((primitive-ref string->symbol) "make-string") arg2=(vector-ref f115 0)
# emit-expr ((primitive-ref string->symbol) "make-string")
# funcall
#    si   =-12
#    env  = ((f115 . 0))
#    expr = (funcall (primitive-ref string->symbol) "make-string")
# emit-expr (primitive-ref string->symbol)
    .extern mrc_string$m$gsymbol
    movl mrc_string$m$gsymbol,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_452"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_452":
   movl %eax,  -20(%esp)  # stash funcall-oper in closure slot
# emit-expr "make-string"
# string literal
    jmp _L_454
    .align 8,0x90
_L_453 :
    .int 44
    .ascii "make-string"
_L_454:
    movl $_L_453, %eax
    orl $6, %eax
    mov %eax, -24(%esp)  # arg make-string
    movl -20(%esp), %edi   # load new closure to %edi
    add $-12, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $12, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    movl %eax, -12(%esp)
# emit-expr (vector-ref f115 0)
# emit-expr f115
# emit-variable-ref
# env=((f115 . 0))
# var=f115
    movl 0(%esp), %eax  # stack load f115
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_455
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_455:
    movl %eax, -16(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_456"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_456:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_458
    cmp  $0,%eax
    jge _L_457
_L_458:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_457:
    movl -16(%esp), %esi
    movl -1(%eax,%esi), %eax
    movl %eax, 4(%ebp)
    movl -12(%esp), %eax
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    or   $1, %al
    add  $8, %ebp
# cons end
    movl -4(%esp), %ebx
    movl -8(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin (vector-set! f115 0 (cons ((primitive-ref string->symbol) "vector-ref") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "vector-set!") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "vector-length") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "make-vector") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "vector?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "set-cdr!") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "set-car!") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "cdr") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "car") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "cons") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "pair?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fxremainder") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fxquotient") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fx*") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fx-") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fx+") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fx>=") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fx>") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fx<=") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fx<") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fx=") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "eof-object") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "eof-object?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f115 0))) (closure () (f115) (let () (vector-ref f115 0))))
# emit-begin
#   expr=(begin (vector-set! f115 0 (cons ((primitive-ref string->symbol) "vector-ref") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "vector-set!") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "vector-length") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "make-vector") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "vector?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "set-cdr!") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "set-car!") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "cdr") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "car") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "cons") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "pair?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fxremainder") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fxquotient") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fx*") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fx-") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fx+") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fx>=") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fx>") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fx<=") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fx<") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fx=") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "eof-object") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "eof-object?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f115 0))) (closure () (f115) (let () (vector-ref f115 0))))
#   env=((f115 . 0))
# emit-expr (vector-set! f115 0 (cons ((primitive-ref string->symbol) "vector-ref") (vector-ref f115 0)))
# emit-expr f115
# emit-variable-ref
# env=((f115 . 0))
# var=f115
    movl 0(%esp), %eax  # stack load f115
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_459
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_459:
    movl %eax, -4(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_460"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_460:
# check bounds on vector index
    movl -4(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_462
    cmp  $0,%eax
    jge _L_461
_L_462:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_461:
    movl %eax, -8(%esp)
# emit-expr (cons ((primitive-ref string->symbol) "vector-ref") (vector-ref f115 0))
# cons arg1=((primitive-ref string->symbol) "vector-ref") arg2=(vector-ref f115 0)
# emit-expr ((primitive-ref string->symbol) "vector-ref")
# funcall
#    si   =-12
#    env  = ((f115 . 0))
#    expr = (funcall (primitive-ref string->symbol) "vector-ref")
# emit-expr (primitive-ref string->symbol)
    .extern mrc_string$m$gsymbol
    movl mrc_string$m$gsymbol,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_463"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_463":
   movl %eax,  -20(%esp)  # stash funcall-oper in closure slot
# emit-expr "vector-ref"
# string literal
    jmp _L_465
    .align 8,0x90
_L_464 :
    .int 40
    .ascii "vector-ref"
_L_465:
    movl $_L_464, %eax
    orl $6, %eax
    mov %eax, -24(%esp)  # arg vector-ref
    movl -20(%esp), %edi   # load new closure to %edi
    add $-12, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $12, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    movl %eax, -12(%esp)
# emit-expr (vector-ref f115 0)
# emit-expr f115
# emit-variable-ref
# env=((f115 . 0))
# var=f115
    movl 0(%esp), %eax  # stack load f115
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_466
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_466:
    movl %eax, -16(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_467"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_467:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_469
    cmp  $0,%eax
    jge _L_468
_L_469:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_468:
    movl -16(%esp), %esi
    movl -1(%eax,%esi), %eax
    movl %eax, 4(%ebp)
    movl -12(%esp), %eax
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    or   $1, %al
    add  $8, %ebp
# cons end
    movl -4(%esp), %ebx
    movl -8(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin (vector-set! f115 0 (cons ((primitive-ref string->symbol) "vector-set!") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "vector-length") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "make-vector") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "vector?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "set-cdr!") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "set-car!") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "cdr") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "car") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "cons") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "pair?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fxremainder") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fxquotient") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fx*") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fx-") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fx+") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fx>=") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fx>") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fx<=") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fx<") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fx=") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "eof-object") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "eof-object?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f115 0))) (closure () (f115) (let () (vector-ref f115 0))))
# emit-begin
#   expr=(begin (vector-set! f115 0 (cons ((primitive-ref string->symbol) "vector-set!") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "vector-length") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "make-vector") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "vector?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "set-cdr!") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "set-car!") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "cdr") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "car") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "cons") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "pair?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fxremainder") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fxquotient") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fx*") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fx-") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fx+") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fx>=") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fx>") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fx<=") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fx<") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fx=") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "eof-object") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "eof-object?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f115 0))) (closure () (f115) (let () (vector-ref f115 0))))
#   env=((f115 . 0))
# emit-expr (vector-set! f115 0 (cons ((primitive-ref string->symbol) "vector-set!") (vector-ref f115 0)))
# emit-expr f115
# emit-variable-ref
# env=((f115 . 0))
# var=f115
    movl 0(%esp), %eax  # stack load f115
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_470
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_470:
    movl %eax, -4(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_471"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_471:
# check bounds on vector index
    movl -4(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_473
    cmp  $0,%eax
    jge _L_472
_L_473:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_472:
    movl %eax, -8(%esp)
# emit-expr (cons ((primitive-ref string->symbol) "vector-set!") (vector-ref f115 0))
# cons arg1=((primitive-ref string->symbol) "vector-set!") arg2=(vector-ref f115 0)
# emit-expr ((primitive-ref string->symbol) "vector-set!")
# funcall
#    si   =-12
#    env  = ((f115 . 0))
#    expr = (funcall (primitive-ref string->symbol) "vector-set!")
# emit-expr (primitive-ref string->symbol)
    .extern mrc_string$m$gsymbol
    movl mrc_string$m$gsymbol,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_474"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_474":
   movl %eax,  -20(%esp)  # stash funcall-oper in closure slot
# emit-expr "vector-set!"
# string literal
    jmp _L_476
    .align 8,0x90
_L_475 :
    .int 44
    .ascii "vector-set!"
_L_476:
    movl $_L_475, %eax
    orl $6, %eax
    mov %eax, -24(%esp)  # arg vector-set!
    movl -20(%esp), %edi   # load new closure to %edi
    add $-12, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $12, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    movl %eax, -12(%esp)
# emit-expr (vector-ref f115 0)
# emit-expr f115
# emit-variable-ref
# env=((f115 . 0))
# var=f115
    movl 0(%esp), %eax  # stack load f115
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_477
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_477:
    movl %eax, -16(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_478"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_478:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_480
    cmp  $0,%eax
    jge _L_479
_L_480:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_479:
    movl -16(%esp), %esi
    movl -1(%eax,%esi), %eax
    movl %eax, 4(%ebp)
    movl -12(%esp), %eax
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    or   $1, %al
    add  $8, %ebp
# cons end
    movl -4(%esp), %ebx
    movl -8(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin (vector-set! f115 0 (cons ((primitive-ref string->symbol) "vector-length") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "make-vector") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "vector?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "set-cdr!") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "set-car!") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "cdr") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "car") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "cons") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "pair?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fxremainder") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fxquotient") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fx*") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fx-") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fx+") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fx>=") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fx>") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fx<=") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fx<") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fx=") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "eof-object") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "eof-object?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f115 0))) (closure () (f115) (let () (vector-ref f115 0))))
# emit-begin
#   expr=(begin (vector-set! f115 0 (cons ((primitive-ref string->symbol) "vector-length") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "make-vector") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "vector?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "set-cdr!") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "set-car!") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "cdr") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "car") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "cons") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "pair?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fxremainder") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fxquotient") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fx*") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fx-") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fx+") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fx>=") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fx>") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fx<=") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fx<") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fx=") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "eof-object") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "eof-object?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f115 0))) (closure () (f115) (let () (vector-ref f115 0))))
#   env=((f115 . 0))
# emit-expr (vector-set! f115 0 (cons ((primitive-ref string->symbol) "vector-length") (vector-ref f115 0)))
# emit-expr f115
# emit-variable-ref
# env=((f115 . 0))
# var=f115
    movl 0(%esp), %eax  # stack load f115
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_481
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_481:
    movl %eax, -4(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_482"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_482:
# check bounds on vector index
    movl -4(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_484
    cmp  $0,%eax
    jge _L_483
_L_484:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_483:
    movl %eax, -8(%esp)
# emit-expr (cons ((primitive-ref string->symbol) "vector-length") (vector-ref f115 0))
# cons arg1=((primitive-ref string->symbol) "vector-length") arg2=(vector-ref f115 0)
# emit-expr ((primitive-ref string->symbol) "vector-length")
# funcall
#    si   =-12
#    env  = ((f115 . 0))
#    expr = (funcall (primitive-ref string->symbol) "vector-length")
# emit-expr (primitive-ref string->symbol)
    .extern mrc_string$m$gsymbol
    movl mrc_string$m$gsymbol,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_485"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_485":
   movl %eax,  -20(%esp)  # stash funcall-oper in closure slot
# emit-expr "vector-length"
# string literal
    jmp _L_487
    .align 8,0x90
_L_486 :
    .int 52
    .ascii "vector-length"
_L_487:
    movl $_L_486, %eax
    orl $6, %eax
    mov %eax, -24(%esp)  # arg vector-length
    movl -20(%esp), %edi   # load new closure to %edi
    add $-12, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $12, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    movl %eax, -12(%esp)
# emit-expr (vector-ref f115 0)
# emit-expr f115
# emit-variable-ref
# env=((f115 . 0))
# var=f115
    movl 0(%esp), %eax  # stack load f115
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_488
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_488:
    movl %eax, -16(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_489"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_489:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_491
    cmp  $0,%eax
    jge _L_490
_L_491:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_490:
    movl -16(%esp), %esi
    movl -1(%eax,%esi), %eax
    movl %eax, 4(%ebp)
    movl -12(%esp), %eax
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    or   $1, %al
    add  $8, %ebp
# cons end
    movl -4(%esp), %ebx
    movl -8(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin (vector-set! f115 0 (cons ((primitive-ref string->symbol) "make-vector") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "vector?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "set-cdr!") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "set-car!") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "cdr") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "car") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "cons") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "pair?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fxremainder") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fxquotient") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fx*") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fx-") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fx+") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fx>=") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fx>") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fx<=") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fx<") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fx=") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "eof-object") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "eof-object?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f115 0))) (closure () (f115) (let () (vector-ref f115 0))))
# emit-begin
#   expr=(begin (vector-set! f115 0 (cons ((primitive-ref string->symbol) "make-vector") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "vector?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "set-cdr!") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "set-car!") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "cdr") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "car") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "cons") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "pair?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fxremainder") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fxquotient") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fx*") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fx-") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fx+") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fx>=") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fx>") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fx<=") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fx<") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fx=") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "eof-object") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "eof-object?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f115 0))) (closure () (f115) (let () (vector-ref f115 0))))
#   env=((f115 . 0))
# emit-expr (vector-set! f115 0 (cons ((primitive-ref string->symbol) "make-vector") (vector-ref f115 0)))
# emit-expr f115
# emit-variable-ref
# env=((f115 . 0))
# var=f115
    movl 0(%esp), %eax  # stack load f115
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_492
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_492:
    movl %eax, -4(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_493"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_493:
# check bounds on vector index
    movl -4(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_495
    cmp  $0,%eax
    jge _L_494
_L_495:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_494:
    movl %eax, -8(%esp)
# emit-expr (cons ((primitive-ref string->symbol) "make-vector") (vector-ref f115 0))
# cons arg1=((primitive-ref string->symbol) "make-vector") arg2=(vector-ref f115 0)
# emit-expr ((primitive-ref string->symbol) "make-vector")
# funcall
#    si   =-12
#    env  = ((f115 . 0))
#    expr = (funcall (primitive-ref string->symbol) "make-vector")
# emit-expr (primitive-ref string->symbol)
    .extern mrc_string$m$gsymbol
    movl mrc_string$m$gsymbol,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_496"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_496":
   movl %eax,  -20(%esp)  # stash funcall-oper in closure slot
# emit-expr "make-vector"
# string literal
    jmp _L_498
    .align 8,0x90
_L_497 :
    .int 44
    .ascii "make-vector"
_L_498:
    movl $_L_497, %eax
    orl $6, %eax
    mov %eax, -24(%esp)  # arg make-vector
    movl -20(%esp), %edi   # load new closure to %edi
    add $-12, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $12, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    movl %eax, -12(%esp)
# emit-expr (vector-ref f115 0)
# emit-expr f115
# emit-variable-ref
# env=((f115 . 0))
# var=f115
    movl 0(%esp), %eax  # stack load f115
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_499
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_499:
    movl %eax, -16(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_500"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_500:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_502
    cmp  $0,%eax
    jge _L_501
_L_502:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_501:
    movl -16(%esp), %esi
    movl -1(%eax,%esi), %eax
    movl %eax, 4(%ebp)
    movl -12(%esp), %eax
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    or   $1, %al
    add  $8, %ebp
# cons end
    movl -4(%esp), %ebx
    movl -8(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin (vector-set! f115 0 (cons ((primitive-ref string->symbol) "vector?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "set-cdr!") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "set-car!") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "cdr") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "car") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "cons") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "pair?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fxremainder") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fxquotient") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fx*") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fx-") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fx+") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fx>=") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fx>") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fx<=") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fx<") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fx=") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "eof-object") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "eof-object?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f115 0))) (closure () (f115) (let () (vector-ref f115 0))))
# emit-begin
#   expr=(begin (vector-set! f115 0 (cons ((primitive-ref string->symbol) "vector?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "set-cdr!") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "set-car!") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "cdr") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "car") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "cons") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "pair?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fxremainder") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fxquotient") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fx*") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fx-") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fx+") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fx>=") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fx>") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fx<=") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fx<") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fx=") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "eof-object") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "eof-object?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f115 0))) (closure () (f115) (let () (vector-ref f115 0))))
#   env=((f115 . 0))
# emit-expr (vector-set! f115 0 (cons ((primitive-ref string->symbol) "vector?") (vector-ref f115 0)))
# emit-expr f115
# emit-variable-ref
# env=((f115 . 0))
# var=f115
    movl 0(%esp), %eax  # stack load f115
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_503
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_503:
    movl %eax, -4(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_504"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_504:
# check bounds on vector index
    movl -4(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_506
    cmp  $0,%eax
    jge _L_505
_L_506:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_505:
    movl %eax, -8(%esp)
# emit-expr (cons ((primitive-ref string->symbol) "vector?") (vector-ref f115 0))
# cons arg1=((primitive-ref string->symbol) "vector?") arg2=(vector-ref f115 0)
# emit-expr ((primitive-ref string->symbol) "vector?")
# funcall
#    si   =-12
#    env  = ((f115 . 0))
#    expr = (funcall (primitive-ref string->symbol) "vector?")
# emit-expr (primitive-ref string->symbol)
    .extern mrc_string$m$gsymbol
    movl mrc_string$m$gsymbol,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_507"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_507":
   movl %eax,  -20(%esp)  # stash funcall-oper in closure slot
# emit-expr "vector?"
# string literal
    jmp _L_509
    .align 8,0x90
_L_508 :
    .int 28
    .ascii "vector?"
_L_509:
    movl $_L_508, %eax
    orl $6, %eax
    mov %eax, -24(%esp)  # arg vector?
    movl -20(%esp), %edi   # load new closure to %edi
    add $-12, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $12, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    movl %eax, -12(%esp)
# emit-expr (vector-ref f115 0)
# emit-expr f115
# emit-variable-ref
# env=((f115 . 0))
# var=f115
    movl 0(%esp), %eax  # stack load f115
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_510
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_510:
    movl %eax, -16(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_511"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_511:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_513
    cmp  $0,%eax
    jge _L_512
_L_513:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_512:
    movl -16(%esp), %esi
    movl -1(%eax,%esi), %eax
    movl %eax, 4(%ebp)
    movl -12(%esp), %eax
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    or   $1, %al
    add  $8, %ebp
# cons end
    movl -4(%esp), %ebx
    movl -8(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin (vector-set! f115 0 (cons ((primitive-ref string->symbol) "set-cdr!") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "set-car!") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "cdr") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "car") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "cons") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "pair?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fxremainder") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fxquotient") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fx*") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fx-") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fx+") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fx>=") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fx>") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fx<=") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fx<") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fx=") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "eof-object") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "eof-object?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f115 0))) (closure () (f115) (let () (vector-ref f115 0))))
# emit-begin
#   expr=(begin (vector-set! f115 0 (cons ((primitive-ref string->symbol) "set-cdr!") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "set-car!") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "cdr") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "car") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "cons") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "pair?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fxremainder") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fxquotient") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fx*") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fx-") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fx+") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fx>=") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fx>") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fx<=") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fx<") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fx=") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "eof-object") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "eof-object?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f115 0))) (closure () (f115) (let () (vector-ref f115 0))))
#   env=((f115 . 0))
# emit-expr (vector-set! f115 0 (cons ((primitive-ref string->symbol) "set-cdr!") (vector-ref f115 0)))
# emit-expr f115
# emit-variable-ref
# env=((f115 . 0))
# var=f115
    movl 0(%esp), %eax  # stack load f115
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_514
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_514:
    movl %eax, -4(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_515"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_515:
# check bounds on vector index
    movl -4(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_517
    cmp  $0,%eax
    jge _L_516
_L_517:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_516:
    movl %eax, -8(%esp)
# emit-expr (cons ((primitive-ref string->symbol) "set-cdr!") (vector-ref f115 0))
# cons arg1=((primitive-ref string->symbol) "set-cdr!") arg2=(vector-ref f115 0)
# emit-expr ((primitive-ref string->symbol) "set-cdr!")
# funcall
#    si   =-12
#    env  = ((f115 . 0))
#    expr = (funcall (primitive-ref string->symbol) "set-cdr!")
# emit-expr (primitive-ref string->symbol)
    .extern mrc_string$m$gsymbol
    movl mrc_string$m$gsymbol,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_518"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_518":
   movl %eax,  -20(%esp)  # stash funcall-oper in closure slot
# emit-expr "set-cdr!"
# string literal
    jmp _L_520
    .align 8,0x90
_L_519 :
    .int 32
    .ascii "set-cdr!"
_L_520:
    movl $_L_519, %eax
    orl $6, %eax
    mov %eax, -24(%esp)  # arg set-cdr!
    movl -20(%esp), %edi   # load new closure to %edi
    add $-12, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $12, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    movl %eax, -12(%esp)
# emit-expr (vector-ref f115 0)
# emit-expr f115
# emit-variable-ref
# env=((f115 . 0))
# var=f115
    movl 0(%esp), %eax  # stack load f115
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_521
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_521:
    movl %eax, -16(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_522"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_522:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_524
    cmp  $0,%eax
    jge _L_523
_L_524:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_523:
    movl -16(%esp), %esi
    movl -1(%eax,%esi), %eax
    movl %eax, 4(%ebp)
    movl -12(%esp), %eax
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    or   $1, %al
    add  $8, %ebp
# cons end
    movl -4(%esp), %ebx
    movl -8(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin (vector-set! f115 0 (cons ((primitive-ref string->symbol) "set-car!") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "cdr") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "car") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "cons") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "pair?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fxremainder") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fxquotient") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fx*") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fx-") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fx+") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fx>=") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fx>") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fx<=") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fx<") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fx=") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "eof-object") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "eof-object?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f115 0))) (closure () (f115) (let () (vector-ref f115 0))))
# emit-begin
#   expr=(begin (vector-set! f115 0 (cons ((primitive-ref string->symbol) "set-car!") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "cdr") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "car") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "cons") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "pair?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fxremainder") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fxquotient") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fx*") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fx-") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fx+") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fx>=") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fx>") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fx<=") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fx<") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fx=") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "eof-object") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "eof-object?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f115 0))) (closure () (f115) (let () (vector-ref f115 0))))
#   env=((f115 . 0))
# emit-expr (vector-set! f115 0 (cons ((primitive-ref string->symbol) "set-car!") (vector-ref f115 0)))
# emit-expr f115
# emit-variable-ref
# env=((f115 . 0))
# var=f115
    movl 0(%esp), %eax  # stack load f115
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_525
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_525:
    movl %eax, -4(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_526"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_526:
# check bounds on vector index
    movl -4(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_528
    cmp  $0,%eax
    jge _L_527
_L_528:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_527:
    movl %eax, -8(%esp)
# emit-expr (cons ((primitive-ref string->symbol) "set-car!") (vector-ref f115 0))
# cons arg1=((primitive-ref string->symbol) "set-car!") arg2=(vector-ref f115 0)
# emit-expr ((primitive-ref string->symbol) "set-car!")
# funcall
#    si   =-12
#    env  = ((f115 . 0))
#    expr = (funcall (primitive-ref string->symbol) "set-car!")
# emit-expr (primitive-ref string->symbol)
    .extern mrc_string$m$gsymbol
    movl mrc_string$m$gsymbol,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_529"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_529":
   movl %eax,  -20(%esp)  # stash funcall-oper in closure slot
# emit-expr "set-car!"
# string literal
    jmp _L_531
    .align 8,0x90
_L_530 :
    .int 32
    .ascii "set-car!"
_L_531:
    movl $_L_530, %eax
    orl $6, %eax
    mov %eax, -24(%esp)  # arg set-car!
    movl -20(%esp), %edi   # load new closure to %edi
    add $-12, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $12, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    movl %eax, -12(%esp)
# emit-expr (vector-ref f115 0)
# emit-expr f115
# emit-variable-ref
# env=((f115 . 0))
# var=f115
    movl 0(%esp), %eax  # stack load f115
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_532
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_532:
    movl %eax, -16(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_533"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_533:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_535
    cmp  $0,%eax
    jge _L_534
_L_535:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_534:
    movl -16(%esp), %esi
    movl -1(%eax,%esi), %eax
    movl %eax, 4(%ebp)
    movl -12(%esp), %eax
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    or   $1, %al
    add  $8, %ebp
# cons end
    movl -4(%esp), %ebx
    movl -8(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin (vector-set! f115 0 (cons ((primitive-ref string->symbol) "cdr") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "car") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "cons") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "pair?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fxremainder") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fxquotient") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fx*") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fx-") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fx+") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fx>=") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fx>") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fx<=") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fx<") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fx=") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "eof-object") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "eof-object?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f115 0))) (closure () (f115) (let () (vector-ref f115 0))))
# emit-begin
#   expr=(begin (vector-set! f115 0 (cons ((primitive-ref string->symbol) "cdr") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "car") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "cons") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "pair?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fxremainder") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fxquotient") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fx*") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fx-") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fx+") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fx>=") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fx>") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fx<=") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fx<") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fx=") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "eof-object") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "eof-object?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f115 0))) (closure () (f115) (let () (vector-ref f115 0))))
#   env=((f115 . 0))
# emit-expr (vector-set! f115 0 (cons ((primitive-ref string->symbol) "cdr") (vector-ref f115 0)))
# emit-expr f115
# emit-variable-ref
# env=((f115 . 0))
# var=f115
    movl 0(%esp), %eax  # stack load f115
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_536
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_536:
    movl %eax, -4(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_537"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_537:
# check bounds on vector index
    movl -4(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_539
    cmp  $0,%eax
    jge _L_538
_L_539:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_538:
    movl %eax, -8(%esp)
# emit-expr (cons ((primitive-ref string->symbol) "cdr") (vector-ref f115 0))
# cons arg1=((primitive-ref string->symbol) "cdr") arg2=(vector-ref f115 0)
# emit-expr ((primitive-ref string->symbol) "cdr")
# funcall
#    si   =-12
#    env  = ((f115 . 0))
#    expr = (funcall (primitive-ref string->symbol) "cdr")
# emit-expr (primitive-ref string->symbol)
    .extern mrc_string$m$gsymbol
    movl mrc_string$m$gsymbol,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_540"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_540":
   movl %eax,  -20(%esp)  # stash funcall-oper in closure slot
# emit-expr "cdr"
# string literal
    jmp _L_542
    .align 8,0x90
_L_541 :
    .int 12
    .ascii "cdr"
_L_542:
    movl $_L_541, %eax
    orl $6, %eax
    mov %eax, -24(%esp)  # arg cdr
    movl -20(%esp), %edi   # load new closure to %edi
    add $-12, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $12, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    movl %eax, -12(%esp)
# emit-expr (vector-ref f115 0)
# emit-expr f115
# emit-variable-ref
# env=((f115 . 0))
# var=f115
    movl 0(%esp), %eax  # stack load f115
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_543
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_543:
    movl %eax, -16(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_544"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_544:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_546
    cmp  $0,%eax
    jge _L_545
_L_546:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_545:
    movl -16(%esp), %esi
    movl -1(%eax,%esi), %eax
    movl %eax, 4(%ebp)
    movl -12(%esp), %eax
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    or   $1, %al
    add  $8, %ebp
# cons end
    movl -4(%esp), %ebx
    movl -8(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin (vector-set! f115 0 (cons ((primitive-ref string->symbol) "car") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "cons") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "pair?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fxremainder") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fxquotient") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fx*") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fx-") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fx+") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fx>=") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fx>") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fx<=") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fx<") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fx=") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "eof-object") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "eof-object?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f115 0))) (closure () (f115) (let () (vector-ref f115 0))))
# emit-begin
#   expr=(begin (vector-set! f115 0 (cons ((primitive-ref string->symbol) "car") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "cons") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "pair?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fxremainder") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fxquotient") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fx*") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fx-") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fx+") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fx>=") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fx>") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fx<=") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fx<") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fx=") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "eof-object") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "eof-object?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f115 0))) (closure () (f115) (let () (vector-ref f115 0))))
#   env=((f115 . 0))
# emit-expr (vector-set! f115 0 (cons ((primitive-ref string->symbol) "car") (vector-ref f115 0)))
# emit-expr f115
# emit-variable-ref
# env=((f115 . 0))
# var=f115
    movl 0(%esp), %eax  # stack load f115
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_547
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_547:
    movl %eax, -4(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_548"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_548:
# check bounds on vector index
    movl -4(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_550
    cmp  $0,%eax
    jge _L_549
_L_550:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_549:
    movl %eax, -8(%esp)
# emit-expr (cons ((primitive-ref string->symbol) "car") (vector-ref f115 0))
# cons arg1=((primitive-ref string->symbol) "car") arg2=(vector-ref f115 0)
# emit-expr ((primitive-ref string->symbol) "car")
# funcall
#    si   =-12
#    env  = ((f115 . 0))
#    expr = (funcall (primitive-ref string->symbol) "car")
# emit-expr (primitive-ref string->symbol)
    .extern mrc_string$m$gsymbol
    movl mrc_string$m$gsymbol,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_551"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_551":
   movl %eax,  -20(%esp)  # stash funcall-oper in closure slot
# emit-expr "car"
# string literal
    jmp _L_553
    .align 8,0x90
_L_552 :
    .int 12
    .ascii "car"
_L_553:
    movl $_L_552, %eax
    orl $6, %eax
    mov %eax, -24(%esp)  # arg car
    movl -20(%esp), %edi   # load new closure to %edi
    add $-12, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $12, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    movl %eax, -12(%esp)
# emit-expr (vector-ref f115 0)
# emit-expr f115
# emit-variable-ref
# env=((f115 . 0))
# var=f115
    movl 0(%esp), %eax  # stack load f115
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_554
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_554:
    movl %eax, -16(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_555"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_555:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_557
    cmp  $0,%eax
    jge _L_556
_L_557:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_556:
    movl -16(%esp), %esi
    movl -1(%eax,%esi), %eax
    movl %eax, 4(%ebp)
    movl -12(%esp), %eax
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    or   $1, %al
    add  $8, %ebp
# cons end
    movl -4(%esp), %ebx
    movl -8(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin (vector-set! f115 0 (cons ((primitive-ref string->symbol) "cons") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "pair?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fxremainder") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fxquotient") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fx*") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fx-") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fx+") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fx>=") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fx>") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fx<=") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fx<") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fx=") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "eof-object") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "eof-object?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f115 0))) (closure () (f115) (let () (vector-ref f115 0))))
# emit-begin
#   expr=(begin (vector-set! f115 0 (cons ((primitive-ref string->symbol) "cons") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "pair?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fxremainder") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fxquotient") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fx*") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fx-") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fx+") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fx>=") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fx>") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fx<=") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fx<") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fx=") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "eof-object") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "eof-object?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f115 0))) (closure () (f115) (let () (vector-ref f115 0))))
#   env=((f115 . 0))
# emit-expr (vector-set! f115 0 (cons ((primitive-ref string->symbol) "cons") (vector-ref f115 0)))
# emit-expr f115
# emit-variable-ref
# env=((f115 . 0))
# var=f115
    movl 0(%esp), %eax  # stack load f115
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_558
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_558:
    movl %eax, -4(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_559"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_559:
# check bounds on vector index
    movl -4(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_561
    cmp  $0,%eax
    jge _L_560
_L_561:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_560:
    movl %eax, -8(%esp)
# emit-expr (cons ((primitive-ref string->symbol) "cons") (vector-ref f115 0))
# cons arg1=((primitive-ref string->symbol) "cons") arg2=(vector-ref f115 0)
# emit-expr ((primitive-ref string->symbol) "cons")
# funcall
#    si   =-12
#    env  = ((f115 . 0))
#    expr = (funcall (primitive-ref string->symbol) "cons")
# emit-expr (primitive-ref string->symbol)
    .extern mrc_string$m$gsymbol
    movl mrc_string$m$gsymbol,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_562"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_562":
   movl %eax,  -20(%esp)  # stash funcall-oper in closure slot
# emit-expr "cons"
# string literal
    jmp _L_564
    .align 8,0x90
_L_563 :
    .int 16
    .ascii "cons"
_L_564:
    movl $_L_563, %eax
    orl $6, %eax
    mov %eax, -24(%esp)  # arg cons
    movl -20(%esp), %edi   # load new closure to %edi
    add $-12, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $12, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    movl %eax, -12(%esp)
# emit-expr (vector-ref f115 0)
# emit-expr f115
# emit-variable-ref
# env=((f115 . 0))
# var=f115
    movl 0(%esp), %eax  # stack load f115
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_565
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_565:
    movl %eax, -16(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_566"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_566:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_568
    cmp  $0,%eax
    jge _L_567
_L_568:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_567:
    movl -16(%esp), %esi
    movl -1(%eax,%esi), %eax
    movl %eax, 4(%ebp)
    movl -12(%esp), %eax
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    or   $1, %al
    add  $8, %ebp
# cons end
    movl -4(%esp), %ebx
    movl -8(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin (vector-set! f115 0 (cons ((primitive-ref string->symbol) "pair?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fxremainder") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fxquotient") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fx*") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fx-") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fx+") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fx>=") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fx>") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fx<=") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fx<") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fx=") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "eof-object") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "eof-object?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f115 0))) (closure () (f115) (let () (vector-ref f115 0))))
# emit-begin
#   expr=(begin (vector-set! f115 0 (cons ((primitive-ref string->symbol) "pair?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fxremainder") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fxquotient") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fx*") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fx-") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fx+") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fx>=") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fx>") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fx<=") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fx<") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fx=") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "eof-object") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "eof-object?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f115 0))) (closure () (f115) (let () (vector-ref f115 0))))
#   env=((f115 . 0))
# emit-expr (vector-set! f115 0 (cons ((primitive-ref string->symbol) "pair?") (vector-ref f115 0)))
# emit-expr f115
# emit-variable-ref
# env=((f115 . 0))
# var=f115
    movl 0(%esp), %eax  # stack load f115
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_569
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_569:
    movl %eax, -4(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_570"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_570:
# check bounds on vector index
    movl -4(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_572
    cmp  $0,%eax
    jge _L_571
_L_572:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_571:
    movl %eax, -8(%esp)
# emit-expr (cons ((primitive-ref string->symbol) "pair?") (vector-ref f115 0))
# cons arg1=((primitive-ref string->symbol) "pair?") arg2=(vector-ref f115 0)
# emit-expr ((primitive-ref string->symbol) "pair?")
# funcall
#    si   =-12
#    env  = ((f115 . 0))
#    expr = (funcall (primitive-ref string->symbol) "pair?")
# emit-expr (primitive-ref string->symbol)
    .extern mrc_string$m$gsymbol
    movl mrc_string$m$gsymbol,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_573"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_573":
   movl %eax,  -20(%esp)  # stash funcall-oper in closure slot
# emit-expr "pair?"
# string literal
    jmp _L_575
    .align 8,0x90
_L_574 :
    .int 20
    .ascii "pair?"
_L_575:
    movl $_L_574, %eax
    orl $6, %eax
    mov %eax, -24(%esp)  # arg pair?
    movl -20(%esp), %edi   # load new closure to %edi
    add $-12, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $12, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    movl %eax, -12(%esp)
# emit-expr (vector-ref f115 0)
# emit-expr f115
# emit-variable-ref
# env=((f115 . 0))
# var=f115
    movl 0(%esp), %eax  # stack load f115
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_576
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_576:
    movl %eax, -16(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_577"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_577:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_579
    cmp  $0,%eax
    jge _L_578
_L_579:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_578:
    movl -16(%esp), %esi
    movl -1(%eax,%esi), %eax
    movl %eax, 4(%ebp)
    movl -12(%esp), %eax
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    or   $1, %al
    add  $8, %ebp
# cons end
    movl -4(%esp), %ebx
    movl -8(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fxremainder") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fxquotient") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fx*") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fx-") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fx+") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fx>=") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fx>") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fx<=") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fx<") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fx=") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "eof-object") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "eof-object?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f115 0))) (closure () (f115) (let () (vector-ref f115 0))))
# emit-begin
#   expr=(begin (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fxremainder") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fxquotient") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fx*") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fx-") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fx+") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fx>=") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fx>") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fx<=") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fx<") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fx=") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "eof-object") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "eof-object?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f115 0))) (closure () (f115) (let () (vector-ref f115 0))))
#   env=((f115 . 0))
# emit-expr (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fxremainder") (vector-ref f115 0)))
# emit-expr f115
# emit-variable-ref
# env=((f115 . 0))
# var=f115
    movl 0(%esp), %eax  # stack load f115
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_580
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_580:
    movl %eax, -4(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_581"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_581:
# check bounds on vector index
    movl -4(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_583
    cmp  $0,%eax
    jge _L_582
_L_583:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_582:
    movl %eax, -8(%esp)
# emit-expr (cons ((primitive-ref string->symbol) "fxremainder") (vector-ref f115 0))
# cons arg1=((primitive-ref string->symbol) "fxremainder") arg2=(vector-ref f115 0)
# emit-expr ((primitive-ref string->symbol) "fxremainder")
# funcall
#    si   =-12
#    env  = ((f115 . 0))
#    expr = (funcall (primitive-ref string->symbol) "fxremainder")
# emit-expr (primitive-ref string->symbol)
    .extern mrc_string$m$gsymbol
    movl mrc_string$m$gsymbol,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_584"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_584":
   movl %eax,  -20(%esp)  # stash funcall-oper in closure slot
# emit-expr "fxremainder"
# string literal
    jmp _L_586
    .align 8,0x90
_L_585 :
    .int 44
    .ascii "fxremainder"
_L_586:
    movl $_L_585, %eax
    orl $6, %eax
    mov %eax, -24(%esp)  # arg fxremainder
    movl -20(%esp), %edi   # load new closure to %edi
    add $-12, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $12, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    movl %eax, -12(%esp)
# emit-expr (vector-ref f115 0)
# emit-expr f115
# emit-variable-ref
# env=((f115 . 0))
# var=f115
    movl 0(%esp), %eax  # stack load f115
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_587
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_587:
    movl %eax, -16(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_588"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_588:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_590
    cmp  $0,%eax
    jge _L_589
_L_590:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_589:
    movl -16(%esp), %esi
    movl -1(%eax,%esi), %eax
    movl %eax, 4(%ebp)
    movl -12(%esp), %eax
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    or   $1, %al
    add  $8, %ebp
# cons end
    movl -4(%esp), %ebx
    movl -8(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fxquotient") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fx*") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fx-") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fx+") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fx>=") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fx>") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fx<=") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fx<") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fx=") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "eof-object") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "eof-object?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f115 0))) (closure () (f115) (let () (vector-ref f115 0))))
# emit-begin
#   expr=(begin (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fxquotient") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fx*") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fx-") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fx+") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fx>=") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fx>") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fx<=") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fx<") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fx=") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "eof-object") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "eof-object?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f115 0))) (closure () (f115) (let () (vector-ref f115 0))))
#   env=((f115 . 0))
# emit-expr (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fxquotient") (vector-ref f115 0)))
# emit-expr f115
# emit-variable-ref
# env=((f115 . 0))
# var=f115
    movl 0(%esp), %eax  # stack load f115
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_591
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_591:
    movl %eax, -4(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_592"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_592:
# check bounds on vector index
    movl -4(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_594
    cmp  $0,%eax
    jge _L_593
_L_594:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_593:
    movl %eax, -8(%esp)
# emit-expr (cons ((primitive-ref string->symbol) "fxquotient") (vector-ref f115 0))
# cons arg1=((primitive-ref string->symbol) "fxquotient") arg2=(vector-ref f115 0)
# emit-expr ((primitive-ref string->symbol) "fxquotient")
# funcall
#    si   =-12
#    env  = ((f115 . 0))
#    expr = (funcall (primitive-ref string->symbol) "fxquotient")
# emit-expr (primitive-ref string->symbol)
    .extern mrc_string$m$gsymbol
    movl mrc_string$m$gsymbol,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_595"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_595":
   movl %eax,  -20(%esp)  # stash funcall-oper in closure slot
# emit-expr "fxquotient"
# string literal
    jmp _L_597
    .align 8,0x90
_L_596 :
    .int 40
    .ascii "fxquotient"
_L_597:
    movl $_L_596, %eax
    orl $6, %eax
    mov %eax, -24(%esp)  # arg fxquotient
    movl -20(%esp), %edi   # load new closure to %edi
    add $-12, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $12, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    movl %eax, -12(%esp)
# emit-expr (vector-ref f115 0)
# emit-expr f115
# emit-variable-ref
# env=((f115 . 0))
# var=f115
    movl 0(%esp), %eax  # stack load f115
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_598
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_598:
    movl %eax, -16(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_599"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_599:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_601
    cmp  $0,%eax
    jge _L_600
_L_601:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_600:
    movl -16(%esp), %esi
    movl -1(%eax,%esi), %eax
    movl %eax, 4(%ebp)
    movl -12(%esp), %eax
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    or   $1, %al
    add  $8, %ebp
# cons end
    movl -4(%esp), %ebx
    movl -8(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fx*") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fx-") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fx+") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fx>=") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fx>") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fx<=") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fx<") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fx=") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "eof-object") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "eof-object?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f115 0))) (closure () (f115) (let () (vector-ref f115 0))))
# emit-begin
#   expr=(begin (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fx*") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fx-") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fx+") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fx>=") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fx>") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fx<=") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fx<") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fx=") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "eof-object") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "eof-object?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f115 0))) (closure () (f115) (let () (vector-ref f115 0))))
#   env=((f115 . 0))
# emit-expr (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fx*") (vector-ref f115 0)))
# emit-expr f115
# emit-variable-ref
# env=((f115 . 0))
# var=f115
    movl 0(%esp), %eax  # stack load f115
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_602
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_602:
    movl %eax, -4(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_603"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_603:
# check bounds on vector index
    movl -4(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_605
    cmp  $0,%eax
    jge _L_604
_L_605:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_604:
    movl %eax, -8(%esp)
# emit-expr (cons ((primitive-ref string->symbol) "fx*") (vector-ref f115 0))
# cons arg1=((primitive-ref string->symbol) "fx*") arg2=(vector-ref f115 0)
# emit-expr ((primitive-ref string->symbol) "fx*")
# funcall
#    si   =-12
#    env  = ((f115 . 0))
#    expr = (funcall (primitive-ref string->symbol) "fx*")
# emit-expr (primitive-ref string->symbol)
    .extern mrc_string$m$gsymbol
    movl mrc_string$m$gsymbol,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_606"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_606":
   movl %eax,  -20(%esp)  # stash funcall-oper in closure slot
# emit-expr "fx*"
# string literal
    jmp _L_608
    .align 8,0x90
_L_607 :
    .int 12
    .ascii "fx*"
_L_608:
    movl $_L_607, %eax
    orl $6, %eax
    mov %eax, -24(%esp)  # arg fx*
    movl -20(%esp), %edi   # load new closure to %edi
    add $-12, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $12, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    movl %eax, -12(%esp)
# emit-expr (vector-ref f115 0)
# emit-expr f115
# emit-variable-ref
# env=((f115 . 0))
# var=f115
    movl 0(%esp), %eax  # stack load f115
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_609
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_609:
    movl %eax, -16(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_610"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_610:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_612
    cmp  $0,%eax
    jge _L_611
_L_612:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_611:
    movl -16(%esp), %esi
    movl -1(%eax,%esi), %eax
    movl %eax, 4(%ebp)
    movl -12(%esp), %eax
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    or   $1, %al
    add  $8, %ebp
# cons end
    movl -4(%esp), %ebx
    movl -8(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fx-") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fx+") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fx>=") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fx>") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fx<=") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fx<") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fx=") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "eof-object") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "eof-object?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f115 0))) (closure () (f115) (let () (vector-ref f115 0))))
# emit-begin
#   expr=(begin (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fx-") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fx+") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fx>=") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fx>") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fx<=") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fx<") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fx=") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "eof-object") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "eof-object?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f115 0))) (closure () (f115) (let () (vector-ref f115 0))))
#   env=((f115 . 0))
# emit-expr (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fx-") (vector-ref f115 0)))
# emit-expr f115
# emit-variable-ref
# env=((f115 . 0))
# var=f115
    movl 0(%esp), %eax  # stack load f115
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_613
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_613:
    movl %eax, -4(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_614"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_614:
# check bounds on vector index
    movl -4(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_616
    cmp  $0,%eax
    jge _L_615
_L_616:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_615:
    movl %eax, -8(%esp)
# emit-expr (cons ((primitive-ref string->symbol) "fx-") (vector-ref f115 0))
# cons arg1=((primitive-ref string->symbol) "fx-") arg2=(vector-ref f115 0)
# emit-expr ((primitive-ref string->symbol) "fx-")
# funcall
#    si   =-12
#    env  = ((f115 . 0))
#    expr = (funcall (primitive-ref string->symbol) "fx-")
# emit-expr (primitive-ref string->symbol)
    .extern mrc_string$m$gsymbol
    movl mrc_string$m$gsymbol,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_617"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_617":
   movl %eax,  -20(%esp)  # stash funcall-oper in closure slot
# emit-expr "fx-"
# string literal
    jmp _L_619
    .align 8,0x90
_L_618 :
    .int 12
    .ascii "fx-"
_L_619:
    movl $_L_618, %eax
    orl $6, %eax
    mov %eax, -24(%esp)  # arg fx-
    movl -20(%esp), %edi   # load new closure to %edi
    add $-12, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $12, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    movl %eax, -12(%esp)
# emit-expr (vector-ref f115 0)
# emit-expr f115
# emit-variable-ref
# env=((f115 . 0))
# var=f115
    movl 0(%esp), %eax  # stack load f115
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_620
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_620:
    movl %eax, -16(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_621"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_621:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_623
    cmp  $0,%eax
    jge _L_622
_L_623:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_622:
    movl -16(%esp), %esi
    movl -1(%eax,%esi), %eax
    movl %eax, 4(%ebp)
    movl -12(%esp), %eax
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    or   $1, %al
    add  $8, %ebp
# cons end
    movl -4(%esp), %ebx
    movl -8(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fx+") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fx>=") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fx>") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fx<=") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fx<") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fx=") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "eof-object") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "eof-object?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f115 0))) (closure () (f115) (let () (vector-ref f115 0))))
# emit-begin
#   expr=(begin (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fx+") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fx>=") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fx>") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fx<=") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fx<") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fx=") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "eof-object") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "eof-object?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f115 0))) (closure () (f115) (let () (vector-ref f115 0))))
#   env=((f115 . 0))
# emit-expr (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fx+") (vector-ref f115 0)))
# emit-expr f115
# emit-variable-ref
# env=((f115 . 0))
# var=f115
    movl 0(%esp), %eax  # stack load f115
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_624
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_624:
    movl %eax, -4(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_625"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_625:
# check bounds on vector index
    movl -4(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_627
    cmp  $0,%eax
    jge _L_626
_L_627:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_626:
    movl %eax, -8(%esp)
# emit-expr (cons ((primitive-ref string->symbol) "fx+") (vector-ref f115 0))
# cons arg1=((primitive-ref string->symbol) "fx+") arg2=(vector-ref f115 0)
# emit-expr ((primitive-ref string->symbol) "fx+")
# funcall
#    si   =-12
#    env  = ((f115 . 0))
#    expr = (funcall (primitive-ref string->symbol) "fx+")
# emit-expr (primitive-ref string->symbol)
    .extern mrc_string$m$gsymbol
    movl mrc_string$m$gsymbol,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_628"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_628":
   movl %eax,  -20(%esp)  # stash funcall-oper in closure slot
# emit-expr "fx+"
# string literal
    jmp _L_630
    .align 8,0x90
_L_629 :
    .int 12
    .ascii "fx+"
_L_630:
    movl $_L_629, %eax
    orl $6, %eax
    mov %eax, -24(%esp)  # arg fx+
    movl -20(%esp), %edi   # load new closure to %edi
    add $-12, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $12, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    movl %eax, -12(%esp)
# emit-expr (vector-ref f115 0)
# emit-expr f115
# emit-variable-ref
# env=((f115 . 0))
# var=f115
    movl 0(%esp), %eax  # stack load f115
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_631
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_631:
    movl %eax, -16(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_632"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_632:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_634
    cmp  $0,%eax
    jge _L_633
_L_634:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_633:
    movl -16(%esp), %esi
    movl -1(%eax,%esi), %eax
    movl %eax, 4(%ebp)
    movl -12(%esp), %eax
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    or   $1, %al
    add  $8, %ebp
# cons end
    movl -4(%esp), %ebx
    movl -8(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fx>=") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fx>") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fx<=") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fx<") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fx=") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "eof-object") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "eof-object?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f115 0))) (closure () (f115) (let () (vector-ref f115 0))))
# emit-begin
#   expr=(begin (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fx>=") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fx>") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fx<=") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fx<") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fx=") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "eof-object") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "eof-object?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f115 0))) (closure () (f115) (let () (vector-ref f115 0))))
#   env=((f115 . 0))
# emit-expr (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fx>=") (vector-ref f115 0)))
# emit-expr f115
# emit-variable-ref
# env=((f115 . 0))
# var=f115
    movl 0(%esp), %eax  # stack load f115
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_635
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_635:
    movl %eax, -4(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_636"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_636:
# check bounds on vector index
    movl -4(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_638
    cmp  $0,%eax
    jge _L_637
_L_638:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_637:
    movl %eax, -8(%esp)
# emit-expr (cons ((primitive-ref string->symbol) "fx>=") (vector-ref f115 0))
# cons arg1=((primitive-ref string->symbol) "fx>=") arg2=(vector-ref f115 0)
# emit-expr ((primitive-ref string->symbol) "fx>=")
# funcall
#    si   =-12
#    env  = ((f115 . 0))
#    expr = (funcall (primitive-ref string->symbol) "fx>=")
# emit-expr (primitive-ref string->symbol)
    .extern mrc_string$m$gsymbol
    movl mrc_string$m$gsymbol,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_639"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_639":
   movl %eax,  -20(%esp)  # stash funcall-oper in closure slot
# emit-expr "fx>="
# string literal
    jmp _L_641
    .align 8,0x90
_L_640 :
    .int 16
    .ascii "fx>="
_L_641:
    movl $_L_640, %eax
    orl $6, %eax
    mov %eax, -24(%esp)  # arg fx>=
    movl -20(%esp), %edi   # load new closure to %edi
    add $-12, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $12, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    movl %eax, -12(%esp)
# emit-expr (vector-ref f115 0)
# emit-expr f115
# emit-variable-ref
# env=((f115 . 0))
# var=f115
    movl 0(%esp), %eax  # stack load f115
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_642
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_642:
    movl %eax, -16(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_643"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_643:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_645
    cmp  $0,%eax
    jge _L_644
_L_645:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_644:
    movl -16(%esp), %esi
    movl -1(%eax,%esi), %eax
    movl %eax, 4(%ebp)
    movl -12(%esp), %eax
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    or   $1, %al
    add  $8, %ebp
# cons end
    movl -4(%esp), %ebx
    movl -8(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fx>") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fx<=") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fx<") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fx=") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "eof-object") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "eof-object?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f115 0))) (closure () (f115) (let () (vector-ref f115 0))))
# emit-begin
#   expr=(begin (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fx>") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fx<=") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fx<") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fx=") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "eof-object") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "eof-object?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f115 0))) (closure () (f115) (let () (vector-ref f115 0))))
#   env=((f115 . 0))
# emit-expr (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fx>") (vector-ref f115 0)))
# emit-expr f115
# emit-variable-ref
# env=((f115 . 0))
# var=f115
    movl 0(%esp), %eax  # stack load f115
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_646
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_646:
    movl %eax, -4(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_647"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_647:
# check bounds on vector index
    movl -4(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_649
    cmp  $0,%eax
    jge _L_648
_L_649:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_648:
    movl %eax, -8(%esp)
# emit-expr (cons ((primitive-ref string->symbol) "fx>") (vector-ref f115 0))
# cons arg1=((primitive-ref string->symbol) "fx>") arg2=(vector-ref f115 0)
# emit-expr ((primitive-ref string->symbol) "fx>")
# funcall
#    si   =-12
#    env  = ((f115 . 0))
#    expr = (funcall (primitive-ref string->symbol) "fx>")
# emit-expr (primitive-ref string->symbol)
    .extern mrc_string$m$gsymbol
    movl mrc_string$m$gsymbol,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_650"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_650":
   movl %eax,  -20(%esp)  # stash funcall-oper in closure slot
# emit-expr "fx>"
# string literal
    jmp _L_652
    .align 8,0x90
_L_651 :
    .int 12
    .ascii "fx>"
_L_652:
    movl $_L_651, %eax
    orl $6, %eax
    mov %eax, -24(%esp)  # arg fx>
    movl -20(%esp), %edi   # load new closure to %edi
    add $-12, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $12, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    movl %eax, -12(%esp)
# emit-expr (vector-ref f115 0)
# emit-expr f115
# emit-variable-ref
# env=((f115 . 0))
# var=f115
    movl 0(%esp), %eax  # stack load f115
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_653
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_653:
    movl %eax, -16(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_654"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_654:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_656
    cmp  $0,%eax
    jge _L_655
_L_656:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_655:
    movl -16(%esp), %esi
    movl -1(%eax,%esi), %eax
    movl %eax, 4(%ebp)
    movl -12(%esp), %eax
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    or   $1, %al
    add  $8, %ebp
# cons end
    movl -4(%esp), %ebx
    movl -8(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fx<=") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fx<") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fx=") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "eof-object") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "eof-object?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f115 0))) (closure () (f115) (let () (vector-ref f115 0))))
# emit-begin
#   expr=(begin (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fx<=") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fx<") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fx=") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "eof-object") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "eof-object?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f115 0))) (closure () (f115) (let () (vector-ref f115 0))))
#   env=((f115 . 0))
# emit-expr (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fx<=") (vector-ref f115 0)))
# emit-expr f115
# emit-variable-ref
# env=((f115 . 0))
# var=f115
    movl 0(%esp), %eax  # stack load f115
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_657
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_657:
    movl %eax, -4(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_658"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_658:
# check bounds on vector index
    movl -4(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_660
    cmp  $0,%eax
    jge _L_659
_L_660:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_659:
    movl %eax, -8(%esp)
# emit-expr (cons ((primitive-ref string->symbol) "fx<=") (vector-ref f115 0))
# cons arg1=((primitive-ref string->symbol) "fx<=") arg2=(vector-ref f115 0)
# emit-expr ((primitive-ref string->symbol) "fx<=")
# funcall
#    si   =-12
#    env  = ((f115 . 0))
#    expr = (funcall (primitive-ref string->symbol) "fx<=")
# emit-expr (primitive-ref string->symbol)
    .extern mrc_string$m$gsymbol
    movl mrc_string$m$gsymbol,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_661"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_661":
   movl %eax,  -20(%esp)  # stash funcall-oper in closure slot
# emit-expr "fx<="
# string literal
    jmp _L_663
    .align 8,0x90
_L_662 :
    .int 16
    .ascii "fx<="
_L_663:
    movl $_L_662, %eax
    orl $6, %eax
    mov %eax, -24(%esp)  # arg fx<=
    movl -20(%esp), %edi   # load new closure to %edi
    add $-12, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $12, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    movl %eax, -12(%esp)
# emit-expr (vector-ref f115 0)
# emit-expr f115
# emit-variable-ref
# env=((f115 . 0))
# var=f115
    movl 0(%esp), %eax  # stack load f115
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_664
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_664:
    movl %eax, -16(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_665"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_665:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_667
    cmp  $0,%eax
    jge _L_666
_L_667:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_666:
    movl -16(%esp), %esi
    movl -1(%eax,%esi), %eax
    movl %eax, 4(%ebp)
    movl -12(%esp), %eax
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    or   $1, %al
    add  $8, %ebp
# cons end
    movl -4(%esp), %ebx
    movl -8(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fx<") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fx=") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "eof-object") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "eof-object?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f115 0))) (closure () (f115) (let () (vector-ref f115 0))))
# emit-begin
#   expr=(begin (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fx<") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fx=") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "eof-object") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "eof-object?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f115 0))) (closure () (f115) (let () (vector-ref f115 0))))
#   env=((f115 . 0))
# emit-expr (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fx<") (vector-ref f115 0)))
# emit-expr f115
# emit-variable-ref
# env=((f115 . 0))
# var=f115
    movl 0(%esp), %eax  # stack load f115
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_668
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_668:
    movl %eax, -4(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_669"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_669:
# check bounds on vector index
    movl -4(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_671
    cmp  $0,%eax
    jge _L_670
_L_671:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_670:
    movl %eax, -8(%esp)
# emit-expr (cons ((primitive-ref string->symbol) "fx<") (vector-ref f115 0))
# cons arg1=((primitive-ref string->symbol) "fx<") arg2=(vector-ref f115 0)
# emit-expr ((primitive-ref string->symbol) "fx<")
# funcall
#    si   =-12
#    env  = ((f115 . 0))
#    expr = (funcall (primitive-ref string->symbol) "fx<")
# emit-expr (primitive-ref string->symbol)
    .extern mrc_string$m$gsymbol
    movl mrc_string$m$gsymbol,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_672"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_672":
   movl %eax,  -20(%esp)  # stash funcall-oper in closure slot
# emit-expr "fx<"
# string literal
    jmp _L_674
    .align 8,0x90
_L_673 :
    .int 12
    .ascii "fx<"
_L_674:
    movl $_L_673, %eax
    orl $6, %eax
    mov %eax, -24(%esp)  # arg fx<
    movl -20(%esp), %edi   # load new closure to %edi
    add $-12, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $12, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    movl %eax, -12(%esp)
# emit-expr (vector-ref f115 0)
# emit-expr f115
# emit-variable-ref
# env=((f115 . 0))
# var=f115
    movl 0(%esp), %eax  # stack load f115
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_675
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_675:
    movl %eax, -16(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_676"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_676:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_678
    cmp  $0,%eax
    jge _L_677
_L_678:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_677:
    movl -16(%esp), %esi
    movl -1(%eax,%esi), %eax
    movl %eax, 4(%ebp)
    movl -12(%esp), %eax
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    or   $1, %al
    add  $8, %ebp
# cons end
    movl -4(%esp), %ebx
    movl -8(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fx=") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "eof-object") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "eof-object?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f115 0))) (closure () (f115) (let () (vector-ref f115 0))))
# emit-begin
#   expr=(begin (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fx=") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "eof-object") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "eof-object?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f115 0))) (closure () (f115) (let () (vector-ref f115 0))))
#   env=((f115 . 0))
# emit-expr (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fx=") (vector-ref f115 0)))
# emit-expr f115
# emit-variable-ref
# env=((f115 . 0))
# var=f115
    movl 0(%esp), %eax  # stack load f115
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_679
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_679:
    movl %eax, -4(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_680"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_680:
# check bounds on vector index
    movl -4(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_682
    cmp  $0,%eax
    jge _L_681
_L_682:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_681:
    movl %eax, -8(%esp)
# emit-expr (cons ((primitive-ref string->symbol) "fx=") (vector-ref f115 0))
# cons arg1=((primitive-ref string->symbol) "fx=") arg2=(vector-ref f115 0)
# emit-expr ((primitive-ref string->symbol) "fx=")
# funcall
#    si   =-12
#    env  = ((f115 . 0))
#    expr = (funcall (primitive-ref string->symbol) "fx=")
# emit-expr (primitive-ref string->symbol)
    .extern mrc_string$m$gsymbol
    movl mrc_string$m$gsymbol,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_683"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_683":
   movl %eax,  -20(%esp)  # stash funcall-oper in closure slot
# emit-expr "fx="
# string literal
    jmp _L_685
    .align 8,0x90
_L_684 :
    .int 12
    .ascii "fx="
_L_685:
    movl $_L_684, %eax
    orl $6, %eax
    mov %eax, -24(%esp)  # arg fx=
    movl -20(%esp), %edi   # load new closure to %edi
    add $-12, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $12, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    movl %eax, -12(%esp)
# emit-expr (vector-ref f115 0)
# emit-expr f115
# emit-variable-ref
# env=((f115 . 0))
# var=f115
    movl 0(%esp), %eax  # stack load f115
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_686
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_686:
    movl %eax, -16(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_687"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_687:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_689
    cmp  $0,%eax
    jge _L_688
_L_689:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_688:
    movl -16(%esp), %esi
    movl -1(%eax,%esi), %eax
    movl %eax, 4(%ebp)
    movl -12(%esp), %eax
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    or   $1, %al
    add  $8, %ebp
# cons end
    movl -4(%esp), %ebx
    movl -8(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "eof-object") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "eof-object?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f115 0))) (closure () (f115) (let () (vector-ref f115 0))))
# emit-begin
#   expr=(begin (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "eof-object") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "eof-object?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f115 0))) (closure () (f115) (let () (vector-ref f115 0))))
#   env=((f115 . 0))
# emit-expr (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f115 0)))
# emit-expr f115
# emit-variable-ref
# env=((f115 . 0))
# var=f115
    movl 0(%esp), %eax  # stack load f115
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_690
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_690:
    movl %eax, -4(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_691"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_691:
# check bounds on vector index
    movl -4(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_693
    cmp  $0,%eax
    jge _L_692
_L_693:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_692:
    movl %eax, -8(%esp)
# emit-expr (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f115 0))
# cons arg1=((primitive-ref string->symbol) "fxzero?") arg2=(vector-ref f115 0)
# emit-expr ((primitive-ref string->symbol) "fxzero?")
# funcall
#    si   =-12
#    env  = ((f115 . 0))
#    expr = (funcall (primitive-ref string->symbol) "fxzero?")
# emit-expr (primitive-ref string->symbol)
    .extern mrc_string$m$gsymbol
    movl mrc_string$m$gsymbol,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_694"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_694":
   movl %eax,  -20(%esp)  # stash funcall-oper in closure slot
# emit-expr "fxzero?"
# string literal
    jmp _L_696
    .align 8,0x90
_L_695 :
    .int 28
    .ascii "fxzero?"
_L_696:
    movl $_L_695, %eax
    orl $6, %eax
    mov %eax, -24(%esp)  # arg fxzero?
    movl -20(%esp), %edi   # load new closure to %edi
    add $-12, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $12, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    movl %eax, -12(%esp)
# emit-expr (vector-ref f115 0)
# emit-expr f115
# emit-variable-ref
# env=((f115 . 0))
# var=f115
    movl 0(%esp), %eax  # stack load f115
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_697
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_697:
    movl %eax, -16(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_698"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_698:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_700
    cmp  $0,%eax
    jge _L_699
_L_700:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_699:
    movl -16(%esp), %esi
    movl -1(%eax,%esi), %eax
    movl %eax, 4(%ebp)
    movl -12(%esp), %eax
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    or   $1, %al
    add  $8, %ebp
# cons end
    movl -4(%esp), %ebx
    movl -8(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "eof-object") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "eof-object?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f115 0))) (closure () (f115) (let () (vector-ref f115 0))))
# emit-begin
#   expr=(begin (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "eof-object") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "eof-object?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f115 0))) (closure () (f115) (let () (vector-ref f115 0))))
#   env=((f115 . 0))
# emit-expr (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f115 0)))
# emit-expr f115
# emit-variable-ref
# env=((f115 . 0))
# var=f115
    movl 0(%esp), %eax  # stack load f115
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_701
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_701:
    movl %eax, -4(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_702"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_702:
# check bounds on vector index
    movl -4(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_704
    cmp  $0,%eax
    jge _L_703
_L_704:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_703:
    movl %eax, -8(%esp)
# emit-expr (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f115 0))
# cons arg1=((primitive-ref string->symbol) "fxsub1") arg2=(vector-ref f115 0)
# emit-expr ((primitive-ref string->symbol) "fxsub1")
# funcall
#    si   =-12
#    env  = ((f115 . 0))
#    expr = (funcall (primitive-ref string->symbol) "fxsub1")
# emit-expr (primitive-ref string->symbol)
    .extern mrc_string$m$gsymbol
    movl mrc_string$m$gsymbol,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_705"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_705":
   movl %eax,  -20(%esp)  # stash funcall-oper in closure slot
# emit-expr "fxsub1"
# string literal
    jmp _L_707
    .align 8,0x90
_L_706 :
    .int 24
    .ascii "fxsub1"
_L_707:
    movl $_L_706, %eax
    orl $6, %eax
    mov %eax, -24(%esp)  # arg fxsub1
    movl -20(%esp), %edi   # load new closure to %edi
    add $-12, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $12, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    movl %eax, -12(%esp)
# emit-expr (vector-ref f115 0)
# emit-expr f115
# emit-variable-ref
# env=((f115 . 0))
# var=f115
    movl 0(%esp), %eax  # stack load f115
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_708
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_708:
    movl %eax, -16(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_709"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_709:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_711
    cmp  $0,%eax
    jge _L_710
_L_711:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_710:
    movl -16(%esp), %esi
    movl -1(%eax,%esi), %eax
    movl %eax, 4(%ebp)
    movl -12(%esp), %eax
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    or   $1, %al
    add  $8, %ebp
# cons end
    movl -4(%esp), %ebx
    movl -8(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "eof-object") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "eof-object?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f115 0))) (closure () (f115) (let () (vector-ref f115 0))))
# emit-begin
#   expr=(begin (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "eof-object") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "eof-object?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f115 0))) (closure () (f115) (let () (vector-ref f115 0))))
#   env=((f115 . 0))
# emit-expr (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f115 0)))
# emit-expr f115
# emit-variable-ref
# env=((f115 . 0))
# var=f115
    movl 0(%esp), %eax  # stack load f115
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_712
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_712:
    movl %eax, -4(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_713"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_713:
# check bounds on vector index
    movl -4(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_715
    cmp  $0,%eax
    jge _L_714
_L_715:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_714:
    movl %eax, -8(%esp)
# emit-expr (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f115 0))
# cons arg1=((primitive-ref string->symbol) "fxadd1") arg2=(vector-ref f115 0)
# emit-expr ((primitive-ref string->symbol) "fxadd1")
# funcall
#    si   =-12
#    env  = ((f115 . 0))
#    expr = (funcall (primitive-ref string->symbol) "fxadd1")
# emit-expr (primitive-ref string->symbol)
    .extern mrc_string$m$gsymbol
    movl mrc_string$m$gsymbol,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_716"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_716":
   movl %eax,  -20(%esp)  # stash funcall-oper in closure slot
# emit-expr "fxadd1"
# string literal
    jmp _L_718
    .align 8,0x90
_L_717 :
    .int 24
    .ascii "fxadd1"
_L_718:
    movl $_L_717, %eax
    orl $6, %eax
    mov %eax, -24(%esp)  # arg fxadd1
    movl -20(%esp), %edi   # load new closure to %edi
    add $-12, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $12, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    movl %eax, -12(%esp)
# emit-expr (vector-ref f115 0)
# emit-expr f115
# emit-variable-ref
# env=((f115 . 0))
# var=f115
    movl 0(%esp), %eax  # stack load f115
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_719
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_719:
    movl %eax, -16(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_720"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_720:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_722
    cmp  $0,%eax
    jge _L_721
_L_722:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_721:
    movl -16(%esp), %esi
    movl -1(%eax,%esi), %eax
    movl %eax, 4(%ebp)
    movl -12(%esp), %eax
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    or   $1, %al
    add  $8, %ebp
# cons end
    movl -4(%esp), %ebx
    movl -8(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "eof-object") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "eof-object?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f115 0))) (closure () (f115) (let () (vector-ref f115 0))))
# emit-begin
#   expr=(begin (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "eof-object") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "eof-object?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f115 0))) (closure () (f115) (let () (vector-ref f115 0))))
#   env=((f115 . 0))
# emit-expr (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f115 0)))
# emit-expr f115
# emit-variable-ref
# env=((f115 . 0))
# var=f115
    movl 0(%esp), %eax  # stack load f115
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_723
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_723:
    movl %eax, -4(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_724"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_724:
# check bounds on vector index
    movl -4(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_726
    cmp  $0,%eax
    jge _L_725
_L_726:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_725:
    movl %eax, -8(%esp)
# emit-expr (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f115 0))
# cons arg1=((primitive-ref string->symbol) "fxlogor") arg2=(vector-ref f115 0)
# emit-expr ((primitive-ref string->symbol) "fxlogor")
# funcall
#    si   =-12
#    env  = ((f115 . 0))
#    expr = (funcall (primitive-ref string->symbol) "fxlogor")
# emit-expr (primitive-ref string->symbol)
    .extern mrc_string$m$gsymbol
    movl mrc_string$m$gsymbol,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_727"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_727":
   movl %eax,  -20(%esp)  # stash funcall-oper in closure slot
# emit-expr "fxlogor"
# string literal
    jmp _L_729
    .align 8,0x90
_L_728 :
    .int 28
    .ascii "fxlogor"
_L_729:
    movl $_L_728, %eax
    orl $6, %eax
    mov %eax, -24(%esp)  # arg fxlogor
    movl -20(%esp), %edi   # load new closure to %edi
    add $-12, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $12, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    movl %eax, -12(%esp)
# emit-expr (vector-ref f115 0)
# emit-expr f115
# emit-variable-ref
# env=((f115 . 0))
# var=f115
    movl 0(%esp), %eax  # stack load f115
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_730
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_730:
    movl %eax, -16(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_731"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_731:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_733
    cmp  $0,%eax
    jge _L_732
_L_733:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_732:
    movl -16(%esp), %esi
    movl -1(%eax,%esi), %eax
    movl %eax, 4(%ebp)
    movl -12(%esp), %eax
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    or   $1, %al
    add  $8, %ebp
# cons end
    movl -4(%esp), %ebx
    movl -8(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "eof-object") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "eof-object?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f115 0))) (closure () (f115) (let () (vector-ref f115 0))))
# emit-begin
#   expr=(begin (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "eof-object") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "eof-object?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f115 0))) (closure () (f115) (let () (vector-ref f115 0))))
#   env=((f115 . 0))
# emit-expr (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f115 0)))
# emit-expr f115
# emit-variable-ref
# env=((f115 . 0))
# var=f115
    movl 0(%esp), %eax  # stack load f115
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_734
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_734:
    movl %eax, -4(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_735"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_735:
# check bounds on vector index
    movl -4(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_737
    cmp  $0,%eax
    jge _L_736
_L_737:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_736:
    movl %eax, -8(%esp)
# emit-expr (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f115 0))
# cons arg1=((primitive-ref string->symbol) "fxlogand") arg2=(vector-ref f115 0)
# emit-expr ((primitive-ref string->symbol) "fxlogand")
# funcall
#    si   =-12
#    env  = ((f115 . 0))
#    expr = (funcall (primitive-ref string->symbol) "fxlogand")
# emit-expr (primitive-ref string->symbol)
    .extern mrc_string$m$gsymbol
    movl mrc_string$m$gsymbol,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_738"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_738":
   movl %eax,  -20(%esp)  # stash funcall-oper in closure slot
# emit-expr "fxlogand"
# string literal
    jmp _L_740
    .align 8,0x90
_L_739 :
    .int 32
    .ascii "fxlogand"
_L_740:
    movl $_L_739, %eax
    orl $6, %eax
    mov %eax, -24(%esp)  # arg fxlogand
    movl -20(%esp), %edi   # load new closure to %edi
    add $-12, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $12, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    movl %eax, -12(%esp)
# emit-expr (vector-ref f115 0)
# emit-expr f115
# emit-variable-ref
# env=((f115 . 0))
# var=f115
    movl 0(%esp), %eax  # stack load f115
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_741
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_741:
    movl %eax, -16(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_742"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_742:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_744
    cmp  $0,%eax
    jge _L_743
_L_744:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_743:
    movl -16(%esp), %esi
    movl -1(%eax,%esi), %eax
    movl %eax, 4(%ebp)
    movl -12(%esp), %eax
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    or   $1, %al
    add  $8, %ebp
# cons end
    movl -4(%esp), %ebx
    movl -8(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "eof-object") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "eof-object?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f115 0))) (closure () (f115) (let () (vector-ref f115 0))))
# emit-begin
#   expr=(begin (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "eof-object") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "eof-object?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f115 0))) (closure () (f115) (let () (vector-ref f115 0))))
#   env=((f115 . 0))
# emit-expr (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f115 0)))
# emit-expr f115
# emit-variable-ref
# env=((f115 . 0))
# var=f115
    movl 0(%esp), %eax  # stack load f115
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_745
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_745:
    movl %eax, -4(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_746"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_746:
# check bounds on vector index
    movl -4(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_748
    cmp  $0,%eax
    jge _L_747
_L_748:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_747:
    movl %eax, -8(%esp)
# emit-expr (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f115 0))
# cons arg1=((primitive-ref string->symbol) "fxlognot") arg2=(vector-ref f115 0)
# emit-expr ((primitive-ref string->symbol) "fxlognot")
# funcall
#    si   =-12
#    env  = ((f115 . 0))
#    expr = (funcall (primitive-ref string->symbol) "fxlognot")
# emit-expr (primitive-ref string->symbol)
    .extern mrc_string$m$gsymbol
    movl mrc_string$m$gsymbol,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_749"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_749":
   movl %eax,  -20(%esp)  # stash funcall-oper in closure slot
# emit-expr "fxlognot"
# string literal
    jmp _L_751
    .align 8,0x90
_L_750 :
    .int 32
    .ascii "fxlognot"
_L_751:
    movl $_L_750, %eax
    orl $6, %eax
    mov %eax, -24(%esp)  # arg fxlognot
    movl -20(%esp), %edi   # load new closure to %edi
    add $-12, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $12, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    movl %eax, -12(%esp)
# emit-expr (vector-ref f115 0)
# emit-expr f115
# emit-variable-ref
# env=((f115 . 0))
# var=f115
    movl 0(%esp), %eax  # stack load f115
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_752
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_752:
    movl %eax, -16(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_753"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_753:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_755
    cmp  $0,%eax
    jge _L_754
_L_755:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_754:
    movl -16(%esp), %esi
    movl -1(%eax,%esi), %eax
    movl %eax, 4(%ebp)
    movl -12(%esp), %eax
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    or   $1, %al
    add  $8, %ebp
# cons end
    movl -4(%esp), %ebx
    movl -8(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin (vector-set! f115 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "eof-object") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "eof-object?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f115 0))) (closure () (f115) (let () (vector-ref f115 0))))
# emit-begin
#   expr=(begin (vector-set! f115 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "eof-object") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "eof-object?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f115 0))) (closure () (f115) (let () (vector-ref f115 0))))
#   env=((f115 . 0))
# emit-expr (vector-set! f115 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f115 0)))
# emit-expr f115
# emit-variable-ref
# env=((f115 . 0))
# var=f115
    movl 0(%esp), %eax  # stack load f115
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_756
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_756:
    movl %eax, -4(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_757"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_757:
# check bounds on vector index
    movl -4(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_759
    cmp  $0,%eax
    jge _L_758
_L_759:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_758:
    movl %eax, -8(%esp)
# emit-expr (cons ((primitive-ref string->symbol) "char=?") (vector-ref f115 0))
# cons arg1=((primitive-ref string->symbol) "char=?") arg2=(vector-ref f115 0)
# emit-expr ((primitive-ref string->symbol) "char=?")
# funcall
#    si   =-12
#    env  = ((f115 . 0))
#    expr = (funcall (primitive-ref string->symbol) "char=?")
# emit-expr (primitive-ref string->symbol)
    .extern mrc_string$m$gsymbol
    movl mrc_string$m$gsymbol,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_760"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_760":
   movl %eax,  -20(%esp)  # stash funcall-oper in closure slot
# emit-expr "char=?"
# string literal
    jmp _L_762
    .align 8,0x90
_L_761 :
    .int 24
    .ascii "char=?"
_L_762:
    movl $_L_761, %eax
    orl $6, %eax
    mov %eax, -24(%esp)  # arg char=?
    movl -20(%esp), %edi   # load new closure to %edi
    add $-12, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $12, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    movl %eax, -12(%esp)
# emit-expr (vector-ref f115 0)
# emit-expr f115
# emit-variable-ref
# env=((f115 . 0))
# var=f115
    movl 0(%esp), %eax  # stack load f115
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_763
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_763:
    movl %eax, -16(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_764"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_764:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_766
    cmp  $0,%eax
    jge _L_765
_L_766:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_765:
    movl -16(%esp), %esi
    movl -1(%eax,%esi), %eax
    movl %eax, 4(%ebp)
    movl -12(%esp), %eax
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    or   $1, %al
    add  $8, %ebp
# cons end
    movl -4(%esp), %ebx
    movl -8(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin (vector-set! f115 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "eof-object") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "eof-object?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f115 0))) (closure () (f115) (let () (vector-ref f115 0))))
# emit-begin
#   expr=(begin (vector-set! f115 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "eof-object") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "eof-object?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f115 0))) (closure () (f115) (let () (vector-ref f115 0))))
#   env=((f115 . 0))
# emit-expr (vector-set! f115 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f115 0)))
# emit-expr f115
# emit-variable-ref
# env=((f115 . 0))
# var=f115
    movl 0(%esp), %eax  # stack load f115
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_767
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_767:
    movl %eax, -4(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_768"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_768:
# check bounds on vector index
    movl -4(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_770
    cmp  $0,%eax
    jge _L_769
_L_770:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_769:
    movl %eax, -8(%esp)
# emit-expr (cons ((primitive-ref string->symbol) "eq?") (vector-ref f115 0))
# cons arg1=((primitive-ref string->symbol) "eq?") arg2=(vector-ref f115 0)
# emit-expr ((primitive-ref string->symbol) "eq?")
# funcall
#    si   =-12
#    env  = ((f115 . 0))
#    expr = (funcall (primitive-ref string->symbol) "eq?")
# emit-expr (primitive-ref string->symbol)
    .extern mrc_string$m$gsymbol
    movl mrc_string$m$gsymbol,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_771"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_771":
   movl %eax,  -20(%esp)  # stash funcall-oper in closure slot
# emit-expr "eq?"
# string literal
    jmp _L_773
    .align 8,0x90
_L_772 :
    .int 12
    .ascii "eq?"
_L_773:
    movl $_L_772, %eax
    orl $6, %eax
    mov %eax, -24(%esp)  # arg eq?
    movl -20(%esp), %edi   # load new closure to %edi
    add $-12, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $12, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    movl %eax, -12(%esp)
# emit-expr (vector-ref f115 0)
# emit-expr f115
# emit-variable-ref
# env=((f115 . 0))
# var=f115
    movl 0(%esp), %eax  # stack load f115
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_774
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_774:
    movl %eax, -16(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_775"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_775:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_777
    cmp  $0,%eax
    jge _L_776
_L_777:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_776:
    movl -16(%esp), %esi
    movl -1(%eax,%esi), %eax
    movl %eax, 4(%ebp)
    movl -12(%esp), %eax
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    or   $1, %al
    add  $8, %ebp
# cons end
    movl -4(%esp), %ebx
    movl -8(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin (vector-set! f115 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "eof-object") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "eof-object?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f115 0))) (closure () (f115) (let () (vector-ref f115 0))))
# emit-begin
#   expr=(begin (vector-set! f115 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "eof-object") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "eof-object?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f115 0))) (closure () (f115) (let () (vector-ref f115 0))))
#   env=((f115 . 0))
# emit-expr (vector-set! f115 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f115 0)))
# emit-expr f115
# emit-variable-ref
# env=((f115 . 0))
# var=f115
    movl 0(%esp), %eax  # stack load f115
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_778
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_778:
    movl %eax, -4(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_779"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_779:
# check bounds on vector index
    movl -4(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_781
    cmp  $0,%eax
    jge _L_780
_L_781:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_780:
    movl %eax, -8(%esp)
# emit-expr (cons ((primitive-ref string->symbol) "not") (vector-ref f115 0))
# cons arg1=((primitive-ref string->symbol) "not") arg2=(vector-ref f115 0)
# emit-expr ((primitive-ref string->symbol) "not")
# funcall
#    si   =-12
#    env  = ((f115 . 0))
#    expr = (funcall (primitive-ref string->symbol) "not")
# emit-expr (primitive-ref string->symbol)
    .extern mrc_string$m$gsymbol
    movl mrc_string$m$gsymbol,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_782"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_782":
   movl %eax,  -20(%esp)  # stash funcall-oper in closure slot
# emit-expr "not"
# string literal
    jmp _L_784
    .align 8,0x90
_L_783 :
    .int 12
    .ascii "not"
_L_784:
    movl $_L_783, %eax
    orl $6, %eax
    mov %eax, -24(%esp)  # arg not
    movl -20(%esp), %edi   # load new closure to %edi
    add $-12, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $12, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    movl %eax, -12(%esp)
# emit-expr (vector-ref f115 0)
# emit-expr f115
# emit-variable-ref
# env=((f115 . 0))
# var=f115
    movl 0(%esp), %eax  # stack load f115
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_785
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_785:
    movl %eax, -16(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_786"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_786:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_788
    cmp  $0,%eax
    jge _L_787
_L_788:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_787:
    movl -16(%esp), %esi
    movl -1(%eax,%esi), %eax
    movl %eax, 4(%ebp)
    movl -12(%esp), %eax
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    or   $1, %al
    add  $8, %ebp
# cons end
    movl -4(%esp), %ebx
    movl -8(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin (vector-set! f115 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "eof-object") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "eof-object?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f115 0))) (closure () (f115) (let () (vector-ref f115 0))))
# emit-begin
#   expr=(begin (vector-set! f115 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "eof-object") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "eof-object?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f115 0))) (closure () (f115) (let () (vector-ref f115 0))))
#   env=((f115 . 0))
# emit-expr (vector-set! f115 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f115 0)))
# emit-expr f115
# emit-variable-ref
# env=((f115 . 0))
# var=f115
    movl 0(%esp), %eax  # stack load f115
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_789
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_789:
    movl %eax, -4(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_790"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_790:
# check bounds on vector index
    movl -4(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_792
    cmp  $0,%eax
    jge _L_791
_L_792:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_791:
    movl %eax, -8(%esp)
# emit-expr (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f115 0))
# cons arg1=((primitive-ref string->symbol) "boolean?") arg2=(vector-ref f115 0)
# emit-expr ((primitive-ref string->symbol) "boolean?")
# funcall
#    si   =-12
#    env  = ((f115 . 0))
#    expr = (funcall (primitive-ref string->symbol) "boolean?")
# emit-expr (primitive-ref string->symbol)
    .extern mrc_string$m$gsymbol
    movl mrc_string$m$gsymbol,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_793"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_793":
   movl %eax,  -20(%esp)  # stash funcall-oper in closure slot
# emit-expr "boolean?"
# string literal
    jmp _L_795
    .align 8,0x90
_L_794 :
    .int 32
    .ascii "boolean?"
_L_795:
    movl $_L_794, %eax
    orl $6, %eax
    mov %eax, -24(%esp)  # arg boolean?
    movl -20(%esp), %edi   # load new closure to %edi
    add $-12, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $12, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    movl %eax, -12(%esp)
# emit-expr (vector-ref f115 0)
# emit-expr f115
# emit-variable-ref
# env=((f115 . 0))
# var=f115
    movl 0(%esp), %eax  # stack load f115
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_796
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_796:
    movl %eax, -16(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_797"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_797:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_799
    cmp  $0,%eax
    jge _L_798
_L_799:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_798:
    movl -16(%esp), %esi
    movl -1(%eax,%esi), %eax
    movl %eax, 4(%ebp)
    movl -12(%esp), %eax
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    or   $1, %al
    add  $8, %ebp
# cons end
    movl -4(%esp), %ebx
    movl -8(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "eof-object") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "eof-object?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f115 0))) (closure () (f115) (let () (vector-ref f115 0))))
# emit-begin
#   expr=(begin (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "eof-object") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "eof-object?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f115 0))) (closure () (f115) (let () (vector-ref f115 0))))
#   env=((f115 . 0))
# emit-expr (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f115 0)))
# emit-expr f115
# emit-variable-ref
# env=((f115 . 0))
# var=f115
    movl 0(%esp), %eax  # stack load f115
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_800
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_800:
    movl %eax, -4(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_801"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_801:
# check bounds on vector index
    movl -4(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_803
    cmp  $0,%eax
    jge _L_802
_L_803:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_802:
    movl %eax, -8(%esp)
# emit-expr (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f115 0))
# cons arg1=((primitive-ref string->symbol) "fixnum?") arg2=(vector-ref f115 0)
# emit-expr ((primitive-ref string->symbol) "fixnum?")
# funcall
#    si   =-12
#    env  = ((f115 . 0))
#    expr = (funcall (primitive-ref string->symbol) "fixnum?")
# emit-expr (primitive-ref string->symbol)
    .extern mrc_string$m$gsymbol
    movl mrc_string$m$gsymbol,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_804"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_804":
   movl %eax,  -20(%esp)  # stash funcall-oper in closure slot
# emit-expr "fixnum?"
# string literal
    jmp _L_806
    .align 8,0x90
_L_805 :
    .int 28
    .ascii "fixnum?"
_L_806:
    movl $_L_805, %eax
    orl $6, %eax
    mov %eax, -24(%esp)  # arg fixnum?
    movl -20(%esp), %edi   # load new closure to %edi
    add $-12, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $12, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    movl %eax, -12(%esp)
# emit-expr (vector-ref f115 0)
# emit-expr f115
# emit-variable-ref
# env=((f115 . 0))
# var=f115
    movl 0(%esp), %eax  # stack load f115
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_807
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_807:
    movl %eax, -16(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_808"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_808:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_810
    cmp  $0,%eax
    jge _L_809
_L_810:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_809:
    movl -16(%esp), %esi
    movl -1(%eax,%esi), %eax
    movl %eax, 4(%ebp)
    movl -12(%esp), %eax
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    or   $1, %al
    add  $8, %ebp
# cons end
    movl -4(%esp), %ebx
    movl -8(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin (vector-set! f115 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "eof-object") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "eof-object?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f115 0))) (closure () (f115) (let () (vector-ref f115 0))))
# emit-begin
#   expr=(begin (vector-set! f115 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "eof-object") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "eof-object?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f115 0))) (closure () (f115) (let () (vector-ref f115 0))))
#   env=((f115 . 0))
# emit-expr (vector-set! f115 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f115 0)))
# emit-expr f115
# emit-variable-ref
# env=((f115 . 0))
# var=f115
    movl 0(%esp), %eax  # stack load f115
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_811
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_811:
    movl %eax, -4(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_812"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_812:
# check bounds on vector index
    movl -4(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_814
    cmp  $0,%eax
    jge _L_813
_L_814:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_813:
    movl %eax, -8(%esp)
# emit-expr (cons ((primitive-ref string->symbol) "char?") (vector-ref f115 0))
# cons arg1=((primitive-ref string->symbol) "char?") arg2=(vector-ref f115 0)
# emit-expr ((primitive-ref string->symbol) "char?")
# funcall
#    si   =-12
#    env  = ((f115 . 0))
#    expr = (funcall (primitive-ref string->symbol) "char?")
# emit-expr (primitive-ref string->symbol)
    .extern mrc_string$m$gsymbol
    movl mrc_string$m$gsymbol,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_815"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_815":
   movl %eax,  -20(%esp)  # stash funcall-oper in closure slot
# emit-expr "char?"
# string literal
    jmp _L_817
    .align 8,0x90
_L_816 :
    .int 20
    .ascii "char?"
_L_817:
    movl $_L_816, %eax
    orl $6, %eax
    mov %eax, -24(%esp)  # arg char?
    movl -20(%esp), %edi   # load new closure to %edi
    add $-12, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $12, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    movl %eax, -12(%esp)
# emit-expr (vector-ref f115 0)
# emit-expr f115
# emit-variable-ref
# env=((f115 . 0))
# var=f115
    movl 0(%esp), %eax  # stack load f115
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_818
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_818:
    movl %eax, -16(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_819"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_819:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_821
    cmp  $0,%eax
    jge _L_820
_L_821:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_820:
    movl -16(%esp), %esi
    movl -1(%eax,%esi), %eax
    movl %eax, 4(%ebp)
    movl -12(%esp), %eax
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    or   $1, %al
    add  $8, %ebp
# cons end
    movl -4(%esp), %ebx
    movl -8(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin (vector-set! f115 0 (cons ((primitive-ref string->symbol) "eof-object") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "eof-object?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f115 0))) (closure () (f115) (let () (vector-ref f115 0))))
# emit-begin
#   expr=(begin (vector-set! f115 0 (cons ((primitive-ref string->symbol) "eof-object") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "eof-object?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f115 0))) (closure () (f115) (let () (vector-ref f115 0))))
#   env=((f115 . 0))
# emit-expr (vector-set! f115 0 (cons ((primitive-ref string->symbol) "eof-object") (vector-ref f115 0)))
# emit-expr f115
# emit-variable-ref
# env=((f115 . 0))
# var=f115
    movl 0(%esp), %eax  # stack load f115
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_822
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_822:
    movl %eax, -4(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_823"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_823:
# check bounds on vector index
    movl -4(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_825
    cmp  $0,%eax
    jge _L_824
_L_825:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_824:
    movl %eax, -8(%esp)
# emit-expr (cons ((primitive-ref string->symbol) "eof-object") (vector-ref f115 0))
# cons arg1=((primitive-ref string->symbol) "eof-object") arg2=(vector-ref f115 0)
# emit-expr ((primitive-ref string->symbol) "eof-object")
# funcall
#    si   =-12
#    env  = ((f115 . 0))
#    expr = (funcall (primitive-ref string->symbol) "eof-object")
# emit-expr (primitive-ref string->symbol)
    .extern mrc_string$m$gsymbol
    movl mrc_string$m$gsymbol,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_826"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_826":
   movl %eax,  -20(%esp)  # stash funcall-oper in closure slot
# emit-expr "eof-object"
# string literal
    jmp _L_828
    .align 8,0x90
_L_827 :
    .int 40
    .ascii "eof-object"
_L_828:
    movl $_L_827, %eax
    orl $6, %eax
    mov %eax, -24(%esp)  # arg eof-object
    movl -20(%esp), %edi   # load new closure to %edi
    add $-12, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $12, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    movl %eax, -12(%esp)
# emit-expr (vector-ref f115 0)
# emit-expr f115
# emit-variable-ref
# env=((f115 . 0))
# var=f115
    movl 0(%esp), %eax  # stack load f115
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_829
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_829:
    movl %eax, -16(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_830"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_830:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_832
    cmp  $0,%eax
    jge _L_831
_L_832:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_831:
    movl -16(%esp), %esi
    movl -1(%eax,%esi), %eax
    movl %eax, 4(%ebp)
    movl -12(%esp), %eax
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    or   $1, %al
    add  $8, %ebp
# cons end
    movl -4(%esp), %ebx
    movl -8(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin (vector-set! f115 0 (cons ((primitive-ref string->symbol) "eof-object?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f115 0))) (closure () (f115) (let () (vector-ref f115 0))))
# emit-begin
#   expr=(begin (vector-set! f115 0 (cons ((primitive-ref string->symbol) "eof-object?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f115 0))) (closure () (f115) (let () (vector-ref f115 0))))
#   env=((f115 . 0))
# emit-expr (vector-set! f115 0 (cons ((primitive-ref string->symbol) "eof-object?") (vector-ref f115 0)))
# emit-expr f115
# emit-variable-ref
# env=((f115 . 0))
# var=f115
    movl 0(%esp), %eax  # stack load f115
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_833
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_833:
    movl %eax, -4(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_834"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_834:
# check bounds on vector index
    movl -4(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_836
    cmp  $0,%eax
    jge _L_835
_L_836:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_835:
    movl %eax, -8(%esp)
# emit-expr (cons ((primitive-ref string->symbol) "eof-object?") (vector-ref f115 0))
# cons arg1=((primitive-ref string->symbol) "eof-object?") arg2=(vector-ref f115 0)
# emit-expr ((primitive-ref string->symbol) "eof-object?")
# funcall
#    si   =-12
#    env  = ((f115 . 0))
#    expr = (funcall (primitive-ref string->symbol) "eof-object?")
# emit-expr (primitive-ref string->symbol)
    .extern mrc_string$m$gsymbol
    movl mrc_string$m$gsymbol,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_837"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_837":
   movl %eax,  -20(%esp)  # stash funcall-oper in closure slot
# emit-expr "eof-object?"
# string literal
    jmp _L_839
    .align 8,0x90
_L_838 :
    .int 44
    .ascii "eof-object?"
_L_839:
    movl $_L_838, %eax
    orl $6, %eax
    mov %eax, -24(%esp)  # arg eof-object?
    movl -20(%esp), %edi   # load new closure to %edi
    add $-12, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $12, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    movl %eax, -12(%esp)
# emit-expr (vector-ref f115 0)
# emit-expr f115
# emit-variable-ref
# env=((f115 . 0))
# var=f115
    movl 0(%esp), %eax  # stack load f115
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_840
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_840:
    movl %eax, -16(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_841"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_841:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_843
    cmp  $0,%eax
    jge _L_842
_L_843:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_842:
    movl -16(%esp), %esi
    movl -1(%eax,%esi), %eax
    movl %eax, 4(%ebp)
    movl -12(%esp), %eax
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    or   $1, %al
    add  $8, %ebp
# cons end
    movl -4(%esp), %ebx
    movl -8(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin (vector-set! f115 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f115 0))) (closure () (f115) (let () (vector-ref f115 0))))
# emit-begin
#   expr=(begin (vector-set! f115 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f115 0))) (closure () (f115) (let () (vector-ref f115 0))))
#   env=((f115 . 0))
# emit-expr (vector-set! f115 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f115 0)))
# emit-expr f115
# emit-variable-ref
# env=((f115 . 0))
# var=f115
    movl 0(%esp), %eax  # stack load f115
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_844
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_844:
    movl %eax, -4(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_845"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_845:
# check bounds on vector index
    movl -4(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_847
    cmp  $0,%eax
    jge _L_846
_L_847:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_846:
    movl %eax, -8(%esp)
# emit-expr (cons ((primitive-ref string->symbol) "null?") (vector-ref f115 0))
# cons arg1=((primitive-ref string->symbol) "null?") arg2=(vector-ref f115 0)
# emit-expr ((primitive-ref string->symbol) "null?")
# funcall
#    si   =-12
#    env  = ((f115 . 0))
#    expr = (funcall (primitive-ref string->symbol) "null?")
# emit-expr (primitive-ref string->symbol)
    .extern mrc_string$m$gsymbol
    movl mrc_string$m$gsymbol,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_848"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_848":
   movl %eax,  -20(%esp)  # stash funcall-oper in closure slot
# emit-expr "null?"
# string literal
    jmp _L_850
    .align 8,0x90
_L_849 :
    .int 20
    .ascii "null?"
_L_850:
    movl $_L_849, %eax
    orl $6, %eax
    mov %eax, -24(%esp)  # arg null?
    movl -20(%esp), %edi   # load new closure to %edi
    add $-12, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $12, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    movl %eax, -12(%esp)
# emit-expr (vector-ref f115 0)
# emit-expr f115
# emit-variable-ref
# env=((f115 . 0))
# var=f115
    movl 0(%esp), %eax  # stack load f115
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_851
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_851:
    movl %eax, -16(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_852"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_852:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_854
    cmp  $0,%eax
    jge _L_853
_L_854:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_853:
    movl -16(%esp), %esi
    movl -1(%eax,%esi), %eax
    movl %eax, 4(%ebp)
    movl -12(%esp), %eax
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    or   $1, %al
    add  $8, %ebp
# cons end
    movl -4(%esp), %ebx
    movl -8(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin (vector-set! f115 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f115 0))) (closure () (f115) (let () (vector-ref f115 0))))
# emit-begin
#   expr=(begin (vector-set! f115 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f115 0))) (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f115 0))) (closure () (f115) (let () (vector-ref f115 0))))
#   env=((f115 . 0))
# emit-expr (vector-set! f115 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f115 0)))
# emit-expr f115
# emit-variable-ref
# env=((f115 . 0))
# var=f115
    movl 0(%esp), %eax  # stack load f115
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_855
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_855:
    movl %eax, -4(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_856"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_856:
# check bounds on vector index
    movl -4(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_858
    cmp  $0,%eax
    jge _L_857
_L_858:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_857:
    movl %eax, -8(%esp)
# emit-expr (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f115 0))
# cons arg1=((primitive-ref string->symbol) "char->fixnum") arg2=(vector-ref f115 0)
# emit-expr ((primitive-ref string->symbol) "char->fixnum")
# funcall
#    si   =-12
#    env  = ((f115 . 0))
#    expr = (funcall (primitive-ref string->symbol) "char->fixnum")
# emit-expr (primitive-ref string->symbol)
    .extern mrc_string$m$gsymbol
    movl mrc_string$m$gsymbol,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_859"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_859":
   movl %eax,  -20(%esp)  # stash funcall-oper in closure slot
# emit-expr "char->fixnum"
# string literal
    jmp _L_861
    .align 8,0x90
_L_860 :
    .int 48
    .ascii "char->fixnum"
_L_861:
    movl $_L_860, %eax
    orl $6, %eax
    mov %eax, -24(%esp)  # arg char->fixnum
    movl -20(%esp), %edi   # load new closure to %edi
    add $-12, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $12, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    movl %eax, -12(%esp)
# emit-expr (vector-ref f115 0)
# emit-expr f115
# emit-variable-ref
# env=((f115 . 0))
# var=f115
    movl 0(%esp), %eax  # stack load f115
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_862
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_862:
    movl %eax, -16(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_863"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_863:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_865
    cmp  $0,%eax
    jge _L_864
_L_865:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_864:
    movl -16(%esp), %esi
    movl -1(%eax,%esi), %eax
    movl %eax, 4(%ebp)
    movl -12(%esp), %eax
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    or   $1, %al
    add  $8, %ebp
# cons end
    movl -4(%esp), %ebx
    movl -8(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f115 0))) (closure () (f115) (let () (vector-ref f115 0))))
# emit-begin
#   expr=(begin (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f115 0))) (closure () (f115) (let () (vector-ref f115 0))))
#   env=((f115 . 0))
# emit-expr (vector-set! f115 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f115 0)))
# emit-expr f115
# emit-variable-ref
# env=((f115 . 0))
# var=f115
    movl 0(%esp), %eax  # stack load f115
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_866
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_866:
    movl %eax, -4(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_867"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_867:
# check bounds on vector index
    movl -4(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_869
    cmp  $0,%eax
    jge _L_868
_L_869:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_868:
    movl %eax, -8(%esp)
# emit-expr (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f115 0))
# cons arg1=((primitive-ref string->symbol) "fixnum->char") arg2=(vector-ref f115 0)
# emit-expr ((primitive-ref string->symbol) "fixnum->char")
# funcall
#    si   =-12
#    env  = ((f115 . 0))
#    expr = (funcall (primitive-ref string->symbol) "fixnum->char")
# emit-expr (primitive-ref string->symbol)
    .extern mrc_string$m$gsymbol
    movl mrc_string$m$gsymbol,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_870"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_870":
   movl %eax,  -20(%esp)  # stash funcall-oper in closure slot
# emit-expr "fixnum->char"
# string literal
    jmp _L_872
    .align 8,0x90
_L_871 :
    .int 48
    .ascii "fixnum->char"
_L_872:
    movl $_L_871, %eax
    orl $6, %eax
    mov %eax, -24(%esp)  # arg fixnum->char
    movl -20(%esp), %edi   # load new closure to %edi
    add $-12, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $12, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    movl %eax, -12(%esp)
# emit-expr (vector-ref f115 0)
# emit-expr f115
# emit-variable-ref
# env=((f115 . 0))
# var=f115
    movl 0(%esp), %eax  # stack load f115
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_873
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_873:
    movl %eax, -16(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_874"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_874:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_876
    cmp  $0,%eax
    jge _L_875
_L_876:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_875:
    movl -16(%esp), %esi
    movl -1(%eax,%esi), %eax
    movl %eax, 4(%ebp)
    movl -12(%esp), %eax
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    or   $1, %al
    add  $8, %ebp
# cons end
    movl -4(%esp), %ebx
    movl -8(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin (closure () (f115) (let () (vector-ref f115 0))))
# emit-begin
#   expr=(begin (closure () (f115) (let () (vector-ref f115 0))))
#   env=((f115 . 0))
# emit-expr (closure () (f115) (let () (vector-ref f115 0)))
# emit-closure
# si = -4
# env = ((f115 . 0))
# expr = (closure () (f115) (let () (vector-ref f115 0)))
    movl $_L_877, 0(%ebp)  # closure label
# emit-variable-ref
# env=((f115 . 0))
# var=f115
    movl 0(%esp), %eax  # stack load f115
# end emit-variable-ref
   movl  %eax, 4(%ebp)  # f115
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $8, %ebp     # bump ebp
    jmp _L_878            # jump around closure body
_L_877:
# check argument count
    cmp $0,%eax
    je _L_879
# invoke error handler eh_argcount
    .extern mrc_eh$uargcount
    movl mrc_eh$uargcount, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_879:
# emit-tail-expr
# si=-8
# env=((f115 . 4) (f115 . 0))
# expr=(let () (vector-ref f115 0))
# emit-tail-let
#  si   = -8
#  env  = ((f115 . 4) (f115 . 0))
#  bindings = ()
#  body = (vector-ref f115 0)
# emit-tail-expr
# si=-8
# env=((f115 . 4) (f115 . 0))
# expr=(vector-ref f115 0)
# tail primcall
# emit-expr f115
# emit-variable-ref
# env=((f115 . 4) (f115 . 0))
# var=f115
    movl 2(%edi), %eax  # frame load f115
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_880
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_880:
    movl %eax, -8(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_881"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_881:
# check bounds on vector index
    movl -8(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_883
    cmp  $0,%eax
    jge _L_882
_L_883:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_882:
    movl -8(%esp), %esi
    movl -1(%eax,%esi), %eax
#return from tail (vector-ref f115 0)
    ret
    .align 4,0x90
_L_878:
# emit-expr (begin)
# emit-begin
#   expr=(begin)
#   env=((f115 . 0))
     movl %eax, mrc_primitives
# == explicit-begins  ==>
# (lambda () (error (quote funcall) "arg 1 must be a procedure"))
# == eliminate-let*  ==>
# (lambda () (error (quote funcall) "arg 1 must be a procedure"))
# == uniquify-variables  ==>
# (lambda () (error (quote funcall) "arg 1 must be a procedure"))
# == vectorize-letrec  ==>
# (lambda () (error (quote funcall) "arg 1 must be a procedure"))
# == eliminate-set!  ==>
# (lambda () (let () (error (quote funcall) "arg 1 must be a procedure")))
# == close-free-variables  ==>
# (closure () (funcall) (let () (error (quote funcall) "arg 1 must be a procedure")))
# == eliminate-quote  ==>
# (closure () (funcall) (let () (error (string->symbol "funcall") "arg 1 must be a procedure")))
# == eliminate-when/unless  ==>
# (closure () (funcall) (let () (error (string->symbol "funcall") "arg 1 must be a procedure")))
# == eliminate-cond  ==>
# (closure () (funcall) (let () (error (string->symbol "funcall") "arg 1 must be a procedure")))
# == external-symbols  ==>
# (closure () (funcall) (let () ((primitive-ref error) ((primitive-ref string->symbol) "funcall") "arg 1 must be a procedure")))
# emit-expr (closure () (funcall) (let () ((primitive-ref error) ((primitive-ref string->symbol) "funcall") "arg 1 must be a procedure")))
# emit-closure
# si = 0
# env = ()
# expr = (closure () (funcall) (let () ((primitive-ref error) ((primitive-ref string->symbol) "funcall") "arg 1 must be a procedure")))
    movl $_L_884, 0(%ebp)  # closure label
# WARNING: free var funcall not defined in the environmnet
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $8, %ebp     # bump ebp
    jmp _L_885            # jump around closure body
_L_884:
# check argument count
    cmp $0,%eax
    je _L_886
# invoke error handler eh_argcount
    .extern mrc_eh$uargcount
    movl mrc_eh$uargcount, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_886:
# emit-tail-expr
# si=-8
# env=((funcall . 4))
# expr=(let () ((primitive-ref error) ((primitive-ref string->symbol) "funcall") "arg 1 must be a procedure"))
# emit-tail-let
#  si   = -8
#  env  = ((funcall . 4))
#  bindings = ()
#  body = ((primitive-ref error) ((primitive-ref string->symbol) "funcall") "arg 1 must be a procedure")
# emit-tail-expr
# si=-8
# env=((funcall . 4))
# expr=((primitive-ref error) ((primitive-ref string->symbol) "funcall") "arg 1 must be a procedure")
# emit-tail-funcall
#    si   =-8
#    env  = ((funcall . 4))
#    expr = (funcall (primitive-ref error) ((primitive-ref string->symbol) "funcall") "arg 1 must be a procedure")
# emit-expr (primitive-ref error)
    .extern mrc_error
    movl mrc_error,%eax
   movl %eax,  -8(%esp)  # stash funcall-oper in next closure slot
# emit-expr ((primitive-ref string->symbol) "funcall")
# funcall
#    si   =-12
#    env  = ((funcall . 4))
#    expr = (funcall (primitive-ref string->symbol) "funcall")
# emit-expr (primitive-ref string->symbol)
    .extern mrc_string$m$gsymbol
    movl mrc_string$m$gsymbol,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_887"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_887":
   movl %eax,  -20(%esp)  # stash funcall-oper in closure slot
# emit-expr "funcall"
# string literal
    jmp _L_889
    .align 8,0x90
_L_888 :
    .int 28
    .ascii "funcall"
_L_889:
    movl $_L_888, %eax
    orl $6, %eax
    mov %eax, -24(%esp)  # arg funcall
    movl -20(%esp), %edi   # load new closure to %edi
    add $-12, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $12, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    mov %eax, -12(%esp)    # arg ((primitive-ref string->symbol) funcall)
# emit-expr "arg 1 must be a procedure"
# string literal
    jmp _L_891
    .align 8,0x90
_L_890 :
    .int 100
    .ascii "arg 1 must be a procedure"
_L_891:
    movl $_L_890, %eax
    orl $6, %eax
    mov %eax, -16(%esp)    # arg arg 1 must be a procedure
    movl -8(%esp), %edi   # load new closure to %edi
# emit-shift-args:  size=3   si=-8  delta=4
    mov -8(%esp), %ebx  # shift frame cell
    mov %ebx, -4(%esp)  # down to base
# emit-shift-args:  size=2   si=-12  delta=4
    mov -12(%esp), %ebx  # shift frame cell
    mov %ebx, -8(%esp)  # down to base
# emit-shift-args:  size=1   si=-16  delta=4
    mov -16(%esp), %ebx  # shift frame cell
    mov %ebx, -12(%esp)  # down to base
# emit-shift-args:  size=0   si=-20  delta=4
    movl $8,%eax   # save arg count
    jmp *-2(%edi)  # tail-funcall
    .align 4,0x90
_L_885:
     movl %eax, mrc_eh$uprocedure
# == explicit-begins  ==>
# (lambda () (error (quote funcall) "wrong number of args"))
# == eliminate-let*  ==>
# (lambda () (error (quote funcall) "wrong number of args"))
# == uniquify-variables  ==>
# (lambda () (error (quote funcall) "wrong number of args"))
# == vectorize-letrec  ==>
# (lambda () (error (quote funcall) "wrong number of args"))
# == eliminate-set!  ==>
# (lambda () (let () (error (quote funcall) "wrong number of args")))
# == close-free-variables  ==>
# (closure () (funcall) (let () (error (quote funcall) "wrong number of args")))
# == eliminate-quote  ==>
# (closure () (funcall) (let () (error (string->symbol "funcall") "wrong number of args")))
# == eliminate-when/unless  ==>
# (closure () (funcall) (let () (error (string->symbol "funcall") "wrong number of args")))
# == eliminate-cond  ==>
# (closure () (funcall) (let () (error (string->symbol "funcall") "wrong number of args")))
# == external-symbols  ==>
# (closure () (funcall) (let () ((primitive-ref error) ((primitive-ref string->symbol) "funcall") "wrong number of args")))
# emit-expr (closure () (funcall) (let () ((primitive-ref error) ((primitive-ref string->symbol) "funcall") "wrong number of args")))
# emit-closure
# si = 0
# env = ()
# expr = (closure () (funcall) (let () ((primitive-ref error) ((primitive-ref string->symbol) "funcall") "wrong number of args")))
    movl $_L_892, 0(%ebp)  # closure label
# WARNING: free var funcall not defined in the environmnet
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $8, %ebp     # bump ebp
    jmp _L_893            # jump around closure body
_L_892:
# check argument count
    cmp $0,%eax
    je _L_894
# invoke error handler eh_argcount
    .extern mrc_eh$uargcount
    movl mrc_eh$uargcount, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_894:
# emit-tail-expr
# si=-8
# env=((funcall . 4))
# expr=(let () ((primitive-ref error) ((primitive-ref string->symbol) "funcall") "wrong number of args"))
# emit-tail-let
#  si   = -8
#  env  = ((funcall . 4))
#  bindings = ()
#  body = ((primitive-ref error) ((primitive-ref string->symbol) "funcall") "wrong number of args")
# emit-tail-expr
# si=-8
# env=((funcall . 4))
# expr=((primitive-ref error) ((primitive-ref string->symbol) "funcall") "wrong number of args")
# emit-tail-funcall
#    si   =-8
#    env  = ((funcall . 4))
#    expr = (funcall (primitive-ref error) ((primitive-ref string->symbol) "funcall") "wrong number of args")
# emit-expr (primitive-ref error)
    .extern mrc_error
    movl mrc_error,%eax
   movl %eax,  -8(%esp)  # stash funcall-oper in next closure slot
# emit-expr ((primitive-ref string->symbol) "funcall")
# funcall
#    si   =-12
#    env  = ((funcall . 4))
#    expr = (funcall (primitive-ref string->symbol) "funcall")
# emit-expr (primitive-ref string->symbol)
    .extern mrc_string$m$gsymbol
    movl mrc_string$m$gsymbol,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_895"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_895":
   movl %eax,  -20(%esp)  # stash funcall-oper in closure slot
# emit-expr "funcall"
# string literal
    jmp _L_897
    .align 8,0x90
_L_896 :
    .int 28
    .ascii "funcall"
_L_897:
    movl $_L_896, %eax
    orl $6, %eax
    mov %eax, -24(%esp)  # arg funcall
    movl -20(%esp), %edi   # load new closure to %edi
    add $-12, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $12, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    mov %eax, -12(%esp)    # arg ((primitive-ref string->symbol) funcall)
# emit-expr "wrong number of args"
# string literal
    jmp _L_899
    .align 8,0x90
_L_898 :
    .int 80
    .ascii "wrong number of args"
_L_899:
    movl $_L_898, %eax
    orl $6, %eax
    mov %eax, -16(%esp)    # arg wrong number of args
    movl -8(%esp), %edi   # load new closure to %edi
# emit-shift-args:  size=3   si=-8  delta=4
    mov -8(%esp), %ebx  # shift frame cell
    mov %ebx, -4(%esp)  # down to base
# emit-shift-args:  size=2   si=-12  delta=4
    mov -12(%esp), %ebx  # shift frame cell
    mov %ebx, -8(%esp)  # down to base
# emit-shift-args:  size=1   si=-16  delta=4
    mov -16(%esp), %ebx  # shift frame cell
    mov %ebx, -12(%esp)  # down to base
# emit-shift-args:  size=0   si=-20  delta=4
    movl $8,%eax   # save arg count
    jmp *-2(%edi)  # tail-funcall
    .align 4,0x90
_L_893:
     movl %eax, mrc_eh$uargcount
# == explicit-begins  ==>
# (lambda () (error (quote funcall) "too few args"))
# == eliminate-let*  ==>
# (lambda () (error (quote funcall) "too few args"))
# == uniquify-variables  ==>
# (lambda () (error (quote funcall) "too few args"))
# == vectorize-letrec  ==>
# (lambda () (error (quote funcall) "too few args"))
# == eliminate-set!  ==>
# (lambda () (let () (error (quote funcall) "too few args")))
# == close-free-variables  ==>
# (closure () (funcall) (let () (error (quote funcall) "too few args")))
# == eliminate-quote  ==>
# (closure () (funcall) (let () (error (string->symbol "funcall") "too few args")))
# == eliminate-when/unless  ==>
# (closure () (funcall) (let () (error (string->symbol "funcall") "too few args")))
# == eliminate-cond  ==>
# (closure () (funcall) (let () (error (string->symbol "funcall") "too few args")))
# == external-symbols  ==>
# (closure () (funcall) (let () ((primitive-ref error) ((primitive-ref string->symbol) "funcall") "too few args")))
# emit-expr (closure () (funcall) (let () ((primitive-ref error) ((primitive-ref string->symbol) "funcall") "too few args")))
# emit-closure
# si = 0
# env = ()
# expr = (closure () (funcall) (let () ((primitive-ref error) ((primitive-ref string->symbol) "funcall") "too few args")))
    movl $_L_900, 0(%ebp)  # closure label
# WARNING: free var funcall not defined in the environmnet
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $8, %ebp     # bump ebp
    jmp _L_901            # jump around closure body
_L_900:
# check argument count
    cmp $0,%eax
    je _L_902
# invoke error handler eh_argcount
    .extern mrc_eh$uargcount
    movl mrc_eh$uargcount, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_902:
# emit-tail-expr
# si=-8
# env=((funcall . 4))
# expr=(let () ((primitive-ref error) ((primitive-ref string->symbol) "funcall") "too few args"))
# emit-tail-let
#  si   = -8
#  env  = ((funcall . 4))
#  bindings = ()
#  body = ((primitive-ref error) ((primitive-ref string->symbol) "funcall") "too few args")
# emit-tail-expr
# si=-8
# env=((funcall . 4))
# expr=((primitive-ref error) ((primitive-ref string->symbol) "funcall") "too few args")
# emit-tail-funcall
#    si   =-8
#    env  = ((funcall . 4))
#    expr = (funcall (primitive-ref error) ((primitive-ref string->symbol) "funcall") "too few args")
# emit-expr (primitive-ref error)
    .extern mrc_error
    movl mrc_error,%eax
   movl %eax,  -8(%esp)  # stash funcall-oper in next closure slot
# emit-expr ((primitive-ref string->symbol) "funcall")
# funcall
#    si   =-12
#    env  = ((funcall . 4))
#    expr = (funcall (primitive-ref string->symbol) "funcall")
# emit-expr (primitive-ref string->symbol)
    .extern mrc_string$m$gsymbol
    movl mrc_string$m$gsymbol,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_903"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_903":
   movl %eax,  -20(%esp)  # stash funcall-oper in closure slot
# emit-expr "funcall"
# string literal
    jmp _L_905
    .align 8,0x90
_L_904 :
    .int 28
    .ascii "funcall"
_L_905:
    movl $_L_904, %eax
    orl $6, %eax
    mov %eax, -24(%esp)  # arg funcall
    movl -20(%esp), %edi   # load new closure to %edi
    add $-12, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $12, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    mov %eax, -12(%esp)    # arg ((primitive-ref string->symbol) funcall)
# emit-expr "too few args"
# string literal
    jmp _L_907
    .align 8,0x90
_L_906 :
    .int 48
    .ascii "too few args"
_L_907:
    movl $_L_906, %eax
    orl $6, %eax
    mov %eax, -16(%esp)    # arg too few args
    movl -8(%esp), %edi   # load new closure to %edi
# emit-shift-args:  size=3   si=-8  delta=4
    mov -8(%esp), %ebx  # shift frame cell
    mov %ebx, -4(%esp)  # down to base
# emit-shift-args:  size=2   si=-12  delta=4
    mov -12(%esp), %ebx  # shift frame cell
    mov %ebx, -8(%esp)  # down to base
# emit-shift-args:  size=1   si=-16  delta=4
    mov -16(%esp), %ebx  # shift frame cell
    mov %ebx, -12(%esp)  # down to base
# emit-shift-args:  size=0   si=-20  delta=4
    movl $8,%eax   # save arg count
    jmp *-2(%edi)  # tail-funcall
    .align 4,0x90
_L_901:
     movl %eax, mrc_eh$uargcount$umin
# == explicit-begins  ==>
# (lambda (i) (error (list-ref (primitives) i) "arg must be a fixnum"))
# == eliminate-let*  ==>
# (lambda (i) (error (list-ref (primitives) i) "arg must be a fixnum"))
# == uniquify-variables  ==>
# (lambda (f116) (error (list-ref (primitives) f116) "arg must be a fixnum"))
# == vectorize-letrec  ==>
# (lambda (f116) (error (list-ref (primitives) f116) "arg must be a fixnum"))
# == eliminate-set!  ==>
# (lambda (f116) (let ((f116 f116)) (error (list-ref (primitives) f116) "arg must be a fixnum")))
# == close-free-variables  ==>
# (closure (f116) () (let ((f116 f116)) (error (list-ref (primitives) f116) "arg must be a fixnum")))
# == eliminate-quote  ==>
# (closure (f116) () (let ((f116 f116)) (error (list-ref (primitives) f116) "arg must be a fixnum")))
# == eliminate-when/unless  ==>
# (closure (f116) () (let ((f116 f116)) (error (list-ref (primitives) f116) "arg must be a fixnum")))
# == eliminate-cond  ==>
# (closure (f116) () (let ((f116 f116)) (error (list-ref (primitives) f116) "arg must be a fixnum")))
# == external-symbols  ==>
# (closure (f116) () (let ((f116 f116)) ((primitive-ref error) ((primitive-ref list-ref) ((primitive-ref primitives)) f116) "arg must be a fixnum")))
# emit-expr (closure (f116) () (let ((f116 f116)) ((primitive-ref error) ((primitive-ref list-ref) ((primitive-ref primitives)) f116) "arg must be a fixnum")))
# emit-closure
# si = 0
# env = ()
# expr = (closure (f116) () (let ((f116 f116)) ((primitive-ref error) ((primitive-ref list-ref) ((primitive-ref primitives)) f116) "arg must be a fixnum")))
    movl $_L_908, 0(%ebp)  # closure label
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $8, %ebp     # bump ebp
    jmp _L_909            # jump around closure body
_L_908:
# check argument count
    cmp $4,%eax
    je _L_910
# invoke error handler eh_argcount
    .extern mrc_eh$uargcount
    movl mrc_eh$uargcount, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_910:
# emit-tail-expr
# si=-12
# env=((f116 . -8))
# expr=(let ((f116 f116)) ((primitive-ref error) ((primitive-ref list-ref) ((primitive-ref primitives)) f116) "arg must be a fixnum"))
# emit-tail-let
#  si   = -12
#  env  = ((f116 . -8))
#  bindings = ((f116 f116))
#  body = ((primitive-ref error) ((primitive-ref list-ref) ((primitive-ref primitives)) f116) "arg must be a fixnum")
# emit-expr f116
# emit-variable-ref
# env=((f116 . -8))
# var=f116
    movl -8(%esp), %eax  # stack load f116
# end emit-variable-ref
    movl %eax, -12(%esp)  # stack save
# emit-tail-expr
# si=-16
# env=((f116 . -12) (f116 . -8))
# expr=((primitive-ref error) ((primitive-ref list-ref) ((primitive-ref primitives)) f116) "arg must be a fixnum")
# emit-tail-funcall
#    si   =-16
#    env  = ((f116 . -12) (f116 . -8))
#    expr = (funcall (primitive-ref error) ((primitive-ref list-ref) ((primitive-ref primitives)) f116) "arg must be a fixnum")
# emit-expr (primitive-ref error)
    .extern mrc_error
    movl mrc_error,%eax
   movl %eax,  -16(%esp)  # stash funcall-oper in next closure slot
# emit-expr ((primitive-ref list-ref) ((primitive-ref primitives)) f116)
# funcall
#    si   =-20
#    env  = ((f116 . -12) (f116 . -8))
#    expr = (funcall (primitive-ref list-ref) ((primitive-ref primitives)) f116)
# emit-expr (primitive-ref list-ref)
    .extern mrc_list$mref
    movl mrc_list$mref,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_911"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_911":
   movl %eax,  -28(%esp)  # stash funcall-oper in closure slot
# emit-expr ((primitive-ref primitives))
# funcall
#    si   =-32
#    env  = ((f116 . -12) (f116 . -8))
#    expr = (funcall (primitive-ref primitives))
# emit-expr (primitive-ref primitives)
    .extern mrc_primitives
    movl mrc_primitives,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_912"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_912":
   movl %eax,  -40(%esp)  # stash funcall-oper in closure slot
    movl -40(%esp), %edi   # load new closure to %edi
    add $-32, %esp   # adjust base
    movl $0,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $32, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    mov %eax, -32(%esp)  # arg ((primitive-ref primitives))
# emit-expr f116
# emit-variable-ref
# env=((f116 . -12) (f116 . -8))
# var=f116
    movl -12(%esp), %eax  # stack load f116
# end emit-variable-ref
    mov %eax, -36(%esp)  # arg f116
    movl -28(%esp), %edi   # load new closure to %edi
    add $-20, %esp   # adjust base
    movl $8,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $20, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    mov %eax, -20(%esp)    # arg ((primitive-ref list-ref) ((primitive-ref primitives)) f116)
# emit-expr "arg must be a fixnum"
# string literal
    jmp _L_914
    .align 8,0x90
_L_913 :
    .int 80
    .ascii "arg must be a fixnum"
_L_914:
    movl $_L_913, %eax
    orl $6, %eax
    mov %eax, -24(%esp)    # arg arg must be a fixnum
    movl -16(%esp), %edi   # load new closure to %edi
# emit-shift-args:  size=3   si=-16  delta=12
    mov -16(%esp), %ebx  # shift frame cell
    mov %ebx, -4(%esp)  # down to base
# emit-shift-args:  size=2   si=-20  delta=12
    mov -20(%esp), %ebx  # shift frame cell
    mov %ebx, -8(%esp)  # down to base
# emit-shift-args:  size=1   si=-24  delta=12
    mov -24(%esp), %ebx  # shift frame cell
    mov %ebx, -12(%esp)  # down to base
# emit-shift-args:  size=0   si=-28  delta=12
    movl $8,%eax   # save arg count
    jmp *-2(%edi)  # tail-funcall
    .align 4,0x90
_L_909:
     movl %eax, mrc_eh$ufixnum
# == explicit-begins  ==>
# (lambda (i) (error (list-ref (primitives) i) "arg must be a string"))
# == eliminate-let*  ==>
# (lambda (i) (error (list-ref (primitives) i) "arg must be a string"))
# == uniquify-variables  ==>
# (lambda (f117) (error (list-ref (primitives) f117) "arg must be a string"))
# == vectorize-letrec  ==>
# (lambda (f117) (error (list-ref (primitives) f117) "arg must be a string"))
# == eliminate-set!  ==>
# (lambda (f117) (let ((f117 f117)) (error (list-ref (primitives) f117) "arg must be a string")))
# == close-free-variables  ==>
# (closure (f117) () (let ((f117 f117)) (error (list-ref (primitives) f117) "arg must be a string")))
# == eliminate-quote  ==>
# (closure (f117) () (let ((f117 f117)) (error (list-ref (primitives) f117) "arg must be a string")))
# == eliminate-when/unless  ==>
# (closure (f117) () (let ((f117 f117)) (error (list-ref (primitives) f117) "arg must be a string")))
# == eliminate-cond  ==>
# (closure (f117) () (let ((f117 f117)) (error (list-ref (primitives) f117) "arg must be a string")))
# == external-symbols  ==>
# (closure (f117) () (let ((f117 f117)) ((primitive-ref error) ((primitive-ref list-ref) ((primitive-ref primitives)) f117) "arg must be a string")))
# emit-expr (closure (f117) () (let ((f117 f117)) ((primitive-ref error) ((primitive-ref list-ref) ((primitive-ref primitives)) f117) "arg must be a string")))
# emit-closure
# si = 0
# env = ()
# expr = (closure (f117) () (let ((f117 f117)) ((primitive-ref error) ((primitive-ref list-ref) ((primitive-ref primitives)) f117) "arg must be a string")))
    movl $_L_915, 0(%ebp)  # closure label
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $8, %ebp     # bump ebp
    jmp _L_916            # jump around closure body
_L_915:
# check argument count
    cmp $4,%eax
    je _L_917
# invoke error handler eh_argcount
    .extern mrc_eh$uargcount
    movl mrc_eh$uargcount, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_917:
# emit-tail-expr
# si=-12
# env=((f117 . -8))
# expr=(let ((f117 f117)) ((primitive-ref error) ((primitive-ref list-ref) ((primitive-ref primitives)) f117) "arg must be a string"))
# emit-tail-let
#  si   = -12
#  env  = ((f117 . -8))
#  bindings = ((f117 f117))
#  body = ((primitive-ref error) ((primitive-ref list-ref) ((primitive-ref primitives)) f117) "arg must be a string")
# emit-expr f117
# emit-variable-ref
# env=((f117 . -8))
# var=f117
    movl -8(%esp), %eax  # stack load f117
# end emit-variable-ref
    movl %eax, -12(%esp)  # stack save
# emit-tail-expr
# si=-16
# env=((f117 . -12) (f117 . -8))
# expr=((primitive-ref error) ((primitive-ref list-ref) ((primitive-ref primitives)) f117) "arg must be a string")
# emit-tail-funcall
#    si   =-16
#    env  = ((f117 . -12) (f117 . -8))
#    expr = (funcall (primitive-ref error) ((primitive-ref list-ref) ((primitive-ref primitives)) f117) "arg must be a string")
# emit-expr (primitive-ref error)
    .extern mrc_error
    movl mrc_error,%eax
   movl %eax,  -16(%esp)  # stash funcall-oper in next closure slot
# emit-expr ((primitive-ref list-ref) ((primitive-ref primitives)) f117)
# funcall
#    si   =-20
#    env  = ((f117 . -12) (f117 . -8))
#    expr = (funcall (primitive-ref list-ref) ((primitive-ref primitives)) f117)
# emit-expr (primitive-ref list-ref)
    .extern mrc_list$mref
    movl mrc_list$mref,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_918"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_918":
   movl %eax,  -28(%esp)  # stash funcall-oper in closure slot
# emit-expr ((primitive-ref primitives))
# funcall
#    si   =-32
#    env  = ((f117 . -12) (f117 . -8))
#    expr = (funcall (primitive-ref primitives))
# emit-expr (primitive-ref primitives)
    .extern mrc_primitives
    movl mrc_primitives,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_919"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_919":
   movl %eax,  -40(%esp)  # stash funcall-oper in closure slot
    movl -40(%esp), %edi   # load new closure to %edi
    add $-32, %esp   # adjust base
    movl $0,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $32, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    mov %eax, -32(%esp)  # arg ((primitive-ref primitives))
# emit-expr f117
# emit-variable-ref
# env=((f117 . -12) (f117 . -8))
# var=f117
    movl -12(%esp), %eax  # stack load f117
# end emit-variable-ref
    mov %eax, -36(%esp)  # arg f117
    movl -28(%esp), %edi   # load new closure to %edi
    add $-20, %esp   # adjust base
    movl $8,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $20, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    mov %eax, -20(%esp)    # arg ((primitive-ref list-ref) ((primitive-ref primitives)) f117)
# emit-expr "arg must be a string"
# string literal
    jmp _L_921
    .align 8,0x90
_L_920 :
    .int 80
    .ascii "arg must be a string"
_L_921:
    movl $_L_920, %eax
    orl $6, %eax
    mov %eax, -24(%esp)    # arg arg must be a string
    movl -16(%esp), %edi   # load new closure to %edi
# emit-shift-args:  size=3   si=-16  delta=12
    mov -16(%esp), %ebx  # shift frame cell
    mov %ebx, -4(%esp)  # down to base
# emit-shift-args:  size=2   si=-20  delta=12
    mov -20(%esp), %ebx  # shift frame cell
    mov %ebx, -8(%esp)  # down to base
# emit-shift-args:  size=1   si=-24  delta=12
    mov -24(%esp), %ebx  # shift frame cell
    mov %ebx, -12(%esp)  # down to base
# emit-shift-args:  size=0   si=-28  delta=12
    movl $8,%eax   # save arg count
    jmp *-2(%edi)  # tail-funcall
    .align 4,0x90
_L_916:
     movl %eax, mrc_eh$ustring
# == explicit-begins  ==>
# (lambda (i) (error (list-ref (primitives) i) "arg must be a character"))
# == eliminate-let*  ==>
# (lambda (i) (error (list-ref (primitives) i) "arg must be a character"))
# == uniquify-variables  ==>
# (lambda (f118) (error (list-ref (primitives) f118) "arg must be a character"))
# == vectorize-letrec  ==>
# (lambda (f118) (error (list-ref (primitives) f118) "arg must be a character"))
# == eliminate-set!  ==>
# (lambda (f118) (let ((f118 f118)) (error (list-ref (primitives) f118) "arg must be a character")))
# == close-free-variables  ==>
# (closure (f118) () (let ((f118 f118)) (error (list-ref (primitives) f118) "arg must be a character")))
# == eliminate-quote  ==>
# (closure (f118) () (let ((f118 f118)) (error (list-ref (primitives) f118) "arg must be a character")))
# == eliminate-when/unless  ==>
# (closure (f118) () (let ((f118 f118)) (error (list-ref (primitives) f118) "arg must be a character")))
# == eliminate-cond  ==>
# (closure (f118) () (let ((f118 f118)) (error (list-ref (primitives) f118) "arg must be a character")))
# == external-symbols  ==>
# (closure (f118) () (let ((f118 f118)) ((primitive-ref error) ((primitive-ref list-ref) ((primitive-ref primitives)) f118) "arg must be a character")))
# emit-expr (closure (f118) () (let ((f118 f118)) ((primitive-ref error) ((primitive-ref list-ref) ((primitive-ref primitives)) f118) "arg must be a character")))
# emit-closure
# si = 0
# env = ()
# expr = (closure (f118) () (let ((f118 f118)) ((primitive-ref error) ((primitive-ref list-ref) ((primitive-ref primitives)) f118) "arg must be a character")))
    movl $_L_922, 0(%ebp)  # closure label
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $8, %ebp     # bump ebp
    jmp _L_923            # jump around closure body
_L_922:
# check argument count
    cmp $4,%eax
    je _L_924
# invoke error handler eh_argcount
    .extern mrc_eh$uargcount
    movl mrc_eh$uargcount, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_924:
# emit-tail-expr
# si=-12
# env=((f118 . -8))
# expr=(let ((f118 f118)) ((primitive-ref error) ((primitive-ref list-ref) ((primitive-ref primitives)) f118) "arg must be a character"))
# emit-tail-let
#  si   = -12
#  env  = ((f118 . -8))
#  bindings = ((f118 f118))
#  body = ((primitive-ref error) ((primitive-ref list-ref) ((primitive-ref primitives)) f118) "arg must be a character")
# emit-expr f118
# emit-variable-ref
# env=((f118 . -8))
# var=f118
    movl -8(%esp), %eax  # stack load f118
# end emit-variable-ref
    movl %eax, -12(%esp)  # stack save
# emit-tail-expr
# si=-16
# env=((f118 . -12) (f118 . -8))
# expr=((primitive-ref error) ((primitive-ref list-ref) ((primitive-ref primitives)) f118) "arg must be a character")
# emit-tail-funcall
#    si   =-16
#    env  = ((f118 . -12) (f118 . -8))
#    expr = (funcall (primitive-ref error) ((primitive-ref list-ref) ((primitive-ref primitives)) f118) "arg must be a character")
# emit-expr (primitive-ref error)
    .extern mrc_error
    movl mrc_error,%eax
   movl %eax,  -16(%esp)  # stash funcall-oper in next closure slot
# emit-expr ((primitive-ref list-ref) ((primitive-ref primitives)) f118)
# funcall
#    si   =-20
#    env  = ((f118 . -12) (f118 . -8))
#    expr = (funcall (primitive-ref list-ref) ((primitive-ref primitives)) f118)
# emit-expr (primitive-ref list-ref)
    .extern mrc_list$mref
    movl mrc_list$mref,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_925"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_925":
   movl %eax,  -28(%esp)  # stash funcall-oper in closure slot
# emit-expr ((primitive-ref primitives))
# funcall
#    si   =-32
#    env  = ((f118 . -12) (f118 . -8))
#    expr = (funcall (primitive-ref primitives))
# emit-expr (primitive-ref primitives)
    .extern mrc_primitives
    movl mrc_primitives,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_926"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_926":
   movl %eax,  -40(%esp)  # stash funcall-oper in closure slot
    movl -40(%esp), %edi   # load new closure to %edi
    add $-32, %esp   # adjust base
    movl $0,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $32, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    mov %eax, -32(%esp)  # arg ((primitive-ref primitives))
# emit-expr f118
# emit-variable-ref
# env=((f118 . -12) (f118 . -8))
# var=f118
    movl -12(%esp), %eax  # stack load f118
# end emit-variable-ref
    mov %eax, -36(%esp)  # arg f118
    movl -28(%esp), %edi   # load new closure to %edi
    add $-20, %esp   # adjust base
    movl $8,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $20, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    mov %eax, -20(%esp)    # arg ((primitive-ref list-ref) ((primitive-ref primitives)) f118)
# emit-expr "arg must be a character"
# string literal
    jmp _L_928
    .align 8,0x90
_L_927 :
    .int 92
    .ascii "arg must be a character"
_L_928:
    movl $_L_927, %eax
    orl $6, %eax
    mov %eax, -24(%esp)    # arg arg must be a character
    movl -16(%esp), %edi   # load new closure to %edi
# emit-shift-args:  size=3   si=-16  delta=12
    mov -16(%esp), %ebx  # shift frame cell
    mov %ebx, -4(%esp)  # down to base
# emit-shift-args:  size=2   si=-20  delta=12
    mov -20(%esp), %ebx  # shift frame cell
    mov %ebx, -8(%esp)  # down to base
# emit-shift-args:  size=1   si=-24  delta=12
    mov -24(%esp), %ebx  # shift frame cell
    mov %ebx, -12(%esp)  # down to base
# emit-shift-args:  size=0   si=-28  delta=12
    movl $8,%eax   # save arg count
    jmp *-2(%edi)  # tail-funcall
    .align 4,0x90
_L_923:
     movl %eax, mrc_eh$ucharacter
# == explicit-begins  ==>
# (lambda (i) (error (list-ref (primitives) i) "arg must be a pair"))
# == eliminate-let*  ==>
# (lambda (i) (error (list-ref (primitives) i) "arg must be a pair"))
# == uniquify-variables  ==>
# (lambda (f119) (error (list-ref (primitives) f119) "arg must be a pair"))
# == vectorize-letrec  ==>
# (lambda (f119) (error (list-ref (primitives) f119) "arg must be a pair"))
# == eliminate-set!  ==>
# (lambda (f119) (let ((f119 f119)) (error (list-ref (primitives) f119) "arg must be a pair")))
# == close-free-variables  ==>
# (closure (f119) () (let ((f119 f119)) (error (list-ref (primitives) f119) "arg must be a pair")))
# == eliminate-quote  ==>
# (closure (f119) () (let ((f119 f119)) (error (list-ref (primitives) f119) "arg must be a pair")))
# == eliminate-when/unless  ==>
# (closure (f119) () (let ((f119 f119)) (error (list-ref (primitives) f119) "arg must be a pair")))
# == eliminate-cond  ==>
# (closure (f119) () (let ((f119 f119)) (error (list-ref (primitives) f119) "arg must be a pair")))
# == external-symbols  ==>
# (closure (f119) () (let ((f119 f119)) ((primitive-ref error) ((primitive-ref list-ref) ((primitive-ref primitives)) f119) "arg must be a pair")))
# emit-expr (closure (f119) () (let ((f119 f119)) ((primitive-ref error) ((primitive-ref list-ref) ((primitive-ref primitives)) f119) "arg must be a pair")))
# emit-closure
# si = 0
# env = ()
# expr = (closure (f119) () (let ((f119 f119)) ((primitive-ref error) ((primitive-ref list-ref) ((primitive-ref primitives)) f119) "arg must be a pair")))
    movl $_L_929, 0(%ebp)  # closure label
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $8, %ebp     # bump ebp
    jmp _L_930            # jump around closure body
_L_929:
# check argument count
    cmp $4,%eax
    je _L_931
# invoke error handler eh_argcount
    .extern mrc_eh$uargcount
    movl mrc_eh$uargcount, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_931:
# emit-tail-expr
# si=-12
# env=((f119 . -8))
# expr=(let ((f119 f119)) ((primitive-ref error) ((primitive-ref list-ref) ((primitive-ref primitives)) f119) "arg must be a pair"))
# emit-tail-let
#  si   = -12
#  env  = ((f119 . -8))
#  bindings = ((f119 f119))
#  body = ((primitive-ref error) ((primitive-ref list-ref) ((primitive-ref primitives)) f119) "arg must be a pair")
# emit-expr f119
# emit-variable-ref
# env=((f119 . -8))
# var=f119
    movl -8(%esp), %eax  # stack load f119
# end emit-variable-ref
    movl %eax, -12(%esp)  # stack save
# emit-tail-expr
# si=-16
# env=((f119 . -12) (f119 . -8))
# expr=((primitive-ref error) ((primitive-ref list-ref) ((primitive-ref primitives)) f119) "arg must be a pair")
# emit-tail-funcall
#    si   =-16
#    env  = ((f119 . -12) (f119 . -8))
#    expr = (funcall (primitive-ref error) ((primitive-ref list-ref) ((primitive-ref primitives)) f119) "arg must be a pair")
# emit-expr (primitive-ref error)
    .extern mrc_error
    movl mrc_error,%eax
   movl %eax,  -16(%esp)  # stash funcall-oper in next closure slot
# emit-expr ((primitive-ref list-ref) ((primitive-ref primitives)) f119)
# funcall
#    si   =-20
#    env  = ((f119 . -12) (f119 . -8))
#    expr = (funcall (primitive-ref list-ref) ((primitive-ref primitives)) f119)
# emit-expr (primitive-ref list-ref)
    .extern mrc_list$mref
    movl mrc_list$mref,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_932"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_932":
   movl %eax,  -28(%esp)  # stash funcall-oper in closure slot
# emit-expr ((primitive-ref primitives))
# funcall
#    si   =-32
#    env  = ((f119 . -12) (f119 . -8))
#    expr = (funcall (primitive-ref primitives))
# emit-expr (primitive-ref primitives)
    .extern mrc_primitives
    movl mrc_primitives,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_933"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_933":
   movl %eax,  -40(%esp)  # stash funcall-oper in closure slot
    movl -40(%esp), %edi   # load new closure to %edi
    add $-32, %esp   # adjust base
    movl $0,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $32, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    mov %eax, -32(%esp)  # arg ((primitive-ref primitives))
# emit-expr f119
# emit-variable-ref
# env=((f119 . -12) (f119 . -8))
# var=f119
    movl -12(%esp), %eax  # stack load f119
# end emit-variable-ref
    mov %eax, -36(%esp)  # arg f119
    movl -28(%esp), %edi   # load new closure to %edi
    add $-20, %esp   # adjust base
    movl $8,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $20, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    mov %eax, -20(%esp)    # arg ((primitive-ref list-ref) ((primitive-ref primitives)) f119)
# emit-expr "arg must be a pair"
# string literal
    jmp _L_935
    .align 8,0x90
_L_934 :
    .int 72
    .ascii "arg must be a pair"
_L_935:
    movl $_L_934, %eax
    orl $6, %eax
    mov %eax, -24(%esp)    # arg arg must be a pair
    movl -16(%esp), %edi   # load new closure to %edi
# emit-shift-args:  size=3   si=-16  delta=12
    mov -16(%esp), %ebx  # shift frame cell
    mov %ebx, -4(%esp)  # down to base
# emit-shift-args:  size=2   si=-20  delta=12
    mov -20(%esp), %ebx  # shift frame cell
    mov %ebx, -8(%esp)  # down to base
# emit-shift-args:  size=1   si=-24  delta=12
    mov -24(%esp), %ebx  # shift frame cell
    mov %ebx, -12(%esp)  # down to base
# emit-shift-args:  size=0   si=-28  delta=12
    movl $8,%eax   # save arg count
    jmp *-2(%edi)  # tail-funcall
    .align 4,0x90
_L_930:
     movl %eax, mrc_eh$upair
# == explicit-begins  ==>
# (lambda (i) (error (list-ref (primitives) i) "arg must be a vector"))
# == eliminate-let*  ==>
# (lambda (i) (error (list-ref (primitives) i) "arg must be a vector"))
# == uniquify-variables  ==>
# (lambda (f120) (error (list-ref (primitives) f120) "arg must be a vector"))
# == vectorize-letrec  ==>
# (lambda (f120) (error (list-ref (primitives) f120) "arg must be a vector"))
# == eliminate-set!  ==>
# (lambda (f120) (let ((f120 f120)) (error (list-ref (primitives) f120) "arg must be a vector")))
# == close-free-variables  ==>
# (closure (f120) () (let ((f120 f120)) (error (list-ref (primitives) f120) "arg must be a vector")))
# == eliminate-quote  ==>
# (closure (f120) () (let ((f120 f120)) (error (list-ref (primitives) f120) "arg must be a vector")))
# == eliminate-when/unless  ==>
# (closure (f120) () (let ((f120 f120)) (error (list-ref (primitives) f120) "arg must be a vector")))
# == eliminate-cond  ==>
# (closure (f120) () (let ((f120 f120)) (error (list-ref (primitives) f120) "arg must be a vector")))
# == external-symbols  ==>
# (closure (f120) () (let ((f120 f120)) ((primitive-ref error) ((primitive-ref list-ref) ((primitive-ref primitives)) f120) "arg must be a vector")))
# emit-expr (closure (f120) () (let ((f120 f120)) ((primitive-ref error) ((primitive-ref list-ref) ((primitive-ref primitives)) f120) "arg must be a vector")))
# emit-closure
# si = 0
# env = ()
# expr = (closure (f120) () (let ((f120 f120)) ((primitive-ref error) ((primitive-ref list-ref) ((primitive-ref primitives)) f120) "arg must be a vector")))
    movl $_L_936, 0(%ebp)  # closure label
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $8, %ebp     # bump ebp
    jmp _L_937            # jump around closure body
_L_936:
# check argument count
    cmp $4,%eax
    je _L_938
# invoke error handler eh_argcount
    .extern mrc_eh$uargcount
    movl mrc_eh$uargcount, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_938:
# emit-tail-expr
# si=-12
# env=((f120 . -8))
# expr=(let ((f120 f120)) ((primitive-ref error) ((primitive-ref list-ref) ((primitive-ref primitives)) f120) "arg must be a vector"))
# emit-tail-let
#  si   = -12
#  env  = ((f120 . -8))
#  bindings = ((f120 f120))
#  body = ((primitive-ref error) ((primitive-ref list-ref) ((primitive-ref primitives)) f120) "arg must be a vector")
# emit-expr f120
# emit-variable-ref
# env=((f120 . -8))
# var=f120
    movl -8(%esp), %eax  # stack load f120
# end emit-variable-ref
    movl %eax, -12(%esp)  # stack save
# emit-tail-expr
# si=-16
# env=((f120 . -12) (f120 . -8))
# expr=((primitive-ref error) ((primitive-ref list-ref) ((primitive-ref primitives)) f120) "arg must be a vector")
# emit-tail-funcall
#    si   =-16
#    env  = ((f120 . -12) (f120 . -8))
#    expr = (funcall (primitive-ref error) ((primitive-ref list-ref) ((primitive-ref primitives)) f120) "arg must be a vector")
# emit-expr (primitive-ref error)
    .extern mrc_error
    movl mrc_error,%eax
   movl %eax,  -16(%esp)  # stash funcall-oper in next closure slot
# emit-expr ((primitive-ref list-ref) ((primitive-ref primitives)) f120)
# funcall
#    si   =-20
#    env  = ((f120 . -12) (f120 . -8))
#    expr = (funcall (primitive-ref list-ref) ((primitive-ref primitives)) f120)
# emit-expr (primitive-ref list-ref)
    .extern mrc_list$mref
    movl mrc_list$mref,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_939"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_939":
   movl %eax,  -28(%esp)  # stash funcall-oper in closure slot
# emit-expr ((primitive-ref primitives))
# funcall
#    si   =-32
#    env  = ((f120 . -12) (f120 . -8))
#    expr = (funcall (primitive-ref primitives))
# emit-expr (primitive-ref primitives)
    .extern mrc_primitives
    movl mrc_primitives,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_940"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_940":
   movl %eax,  -40(%esp)  # stash funcall-oper in closure slot
    movl -40(%esp), %edi   # load new closure to %edi
    add $-32, %esp   # adjust base
    movl $0,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $32, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    mov %eax, -32(%esp)  # arg ((primitive-ref primitives))
# emit-expr f120
# emit-variable-ref
# env=((f120 . -12) (f120 . -8))
# var=f120
    movl -12(%esp), %eax  # stack load f120
# end emit-variable-ref
    mov %eax, -36(%esp)  # arg f120
    movl -28(%esp), %edi   # load new closure to %edi
    add $-20, %esp   # adjust base
    movl $8,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $20, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    mov %eax, -20(%esp)    # arg ((primitive-ref list-ref) ((primitive-ref primitives)) f120)
# emit-expr "arg must be a vector"
# string literal
    jmp _L_942
    .align 8,0x90
_L_941 :
    .int 80
    .ascii "arg must be a vector"
_L_942:
    movl $_L_941, %eax
    orl $6, %eax
    mov %eax, -24(%esp)    # arg arg must be a vector
    movl -16(%esp), %edi   # load new closure to %edi
# emit-shift-args:  size=3   si=-16  delta=12
    mov -16(%esp), %ebx  # shift frame cell
    mov %ebx, -4(%esp)  # down to base
# emit-shift-args:  size=2   si=-20  delta=12
    mov -20(%esp), %ebx  # shift frame cell
    mov %ebx, -8(%esp)  # down to base
# emit-shift-args:  size=1   si=-24  delta=12
    mov -24(%esp), %ebx  # shift frame cell
    mov %ebx, -12(%esp)  # down to base
# emit-shift-args:  size=0   si=-28  delta=12
    movl $8,%eax   # save arg count
    jmp *-2(%edi)  # tail-funcall
    .align 4,0x90
_L_937:
     movl %eax, mrc_eh$uvector
# == explicit-begins  ==>
# (lambda (i) (error (list-ref (primitives) i) "length must be a fixnum >= 0"))
# == eliminate-let*  ==>
# (lambda (i) (error (list-ref (primitives) i) "length must be a fixnum >= 0"))
# == uniquify-variables  ==>
# (lambda (f121) (error (list-ref (primitives) f121) "length must be a fixnum >= 0"))
# == vectorize-letrec  ==>
# (lambda (f121) (error (list-ref (primitives) f121) "length must be a fixnum >= 0"))
# == eliminate-set!  ==>
# (lambda (f121) (let ((f121 f121)) (error (list-ref (primitives) f121) "length must be a fixnum >= 0")))
# == close-free-variables  ==>
# (closure (f121) () (let ((f121 f121)) (error (list-ref (primitives) f121) "length must be a fixnum >= 0")))
# == eliminate-quote  ==>
# (closure (f121) () (let ((f121 f121)) (error (list-ref (primitives) f121) "length must be a fixnum >= 0")))
# == eliminate-when/unless  ==>
# (closure (f121) () (let ((f121 f121)) (error (list-ref (primitives) f121) "length must be a fixnum >= 0")))
# == eliminate-cond  ==>
# (closure (f121) () (let ((f121 f121)) (error (list-ref (primitives) f121) "length must be a fixnum >= 0")))
# == external-symbols  ==>
# (closure (f121) () (let ((f121 f121)) ((primitive-ref error) ((primitive-ref list-ref) ((primitive-ref primitives)) f121) "length must be a fixnum >= 0")))
# emit-expr (closure (f121) () (let ((f121 f121)) ((primitive-ref error) ((primitive-ref list-ref) ((primitive-ref primitives)) f121) "length must be a fixnum >= 0")))
# emit-closure
# si = 0
# env = ()
# expr = (closure (f121) () (let ((f121 f121)) ((primitive-ref error) ((primitive-ref list-ref) ((primitive-ref primitives)) f121) "length must be a fixnum >= 0")))
    movl $_L_943, 0(%ebp)  # closure label
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $8, %ebp     # bump ebp
    jmp _L_944            # jump around closure body
_L_943:
# check argument count
    cmp $4,%eax
    je _L_945
# invoke error handler eh_argcount
    .extern mrc_eh$uargcount
    movl mrc_eh$uargcount, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_945:
# emit-tail-expr
# si=-12
# env=((f121 . -8))
# expr=(let ((f121 f121)) ((primitive-ref error) ((primitive-ref list-ref) ((primitive-ref primitives)) f121) "length must be a fixnum >= 0"))
# emit-tail-let
#  si   = -12
#  env  = ((f121 . -8))
#  bindings = ((f121 f121))
#  body = ((primitive-ref error) ((primitive-ref list-ref) ((primitive-ref primitives)) f121) "length must be a fixnum >= 0")
# emit-expr f121
# emit-variable-ref
# env=((f121 . -8))
# var=f121
    movl -8(%esp), %eax  # stack load f121
# end emit-variable-ref
    movl %eax, -12(%esp)  # stack save
# emit-tail-expr
# si=-16
# env=((f121 . -12) (f121 . -8))
# expr=((primitive-ref error) ((primitive-ref list-ref) ((primitive-ref primitives)) f121) "length must be a fixnum >= 0")
# emit-tail-funcall
#    si   =-16
#    env  = ((f121 . -12) (f121 . -8))
#    expr = (funcall (primitive-ref error) ((primitive-ref list-ref) ((primitive-ref primitives)) f121) "length must be a fixnum >= 0")
# emit-expr (primitive-ref error)
    .extern mrc_error
    movl mrc_error,%eax
   movl %eax,  -16(%esp)  # stash funcall-oper in next closure slot
# emit-expr ((primitive-ref list-ref) ((primitive-ref primitives)) f121)
# funcall
#    si   =-20
#    env  = ((f121 . -12) (f121 . -8))
#    expr = (funcall (primitive-ref list-ref) ((primitive-ref primitives)) f121)
# emit-expr (primitive-ref list-ref)
    .extern mrc_list$mref
    movl mrc_list$mref,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_946"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_946":
   movl %eax,  -28(%esp)  # stash funcall-oper in closure slot
# emit-expr ((primitive-ref primitives))
# funcall
#    si   =-32
#    env  = ((f121 . -12) (f121 . -8))
#    expr = (funcall (primitive-ref primitives))
# emit-expr (primitive-ref primitives)
    .extern mrc_primitives
    movl mrc_primitives,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_947"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_947":
   movl %eax,  -40(%esp)  # stash funcall-oper in closure slot
    movl -40(%esp), %edi   # load new closure to %edi
    add $-32, %esp   # adjust base
    movl $0,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $32, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    mov %eax, -32(%esp)  # arg ((primitive-ref primitives))
# emit-expr f121
# emit-variable-ref
# env=((f121 . -12) (f121 . -8))
# var=f121
    movl -12(%esp), %eax  # stack load f121
# end emit-variable-ref
    mov %eax, -36(%esp)  # arg f121
    movl -28(%esp), %edi   # load new closure to %edi
    add $-20, %esp   # adjust base
    movl $8,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $20, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    mov %eax, -20(%esp)    # arg ((primitive-ref list-ref) ((primitive-ref primitives)) f121)
# emit-expr "length must be a fixnum >= 0"
# string literal
    jmp _L_949
    .align 8,0x90
_L_948 :
    .int 112
    .ascii "length must be a fixnum >= 0"
_L_949:
    movl $_L_948, %eax
    orl $6, %eax
    mov %eax, -24(%esp)    # arg length must be a fixnum >= 0
    movl -16(%esp), %edi   # load new closure to %edi
# emit-shift-args:  size=3   si=-16  delta=12
    mov -16(%esp), %ebx  # shift frame cell
    mov %ebx, -4(%esp)  # down to base
# emit-shift-args:  size=2   si=-20  delta=12
    mov -20(%esp), %ebx  # shift frame cell
    mov %ebx, -8(%esp)  # down to base
# emit-shift-args:  size=1   si=-24  delta=12
    mov -24(%esp), %ebx  # shift frame cell
    mov %ebx, -12(%esp)  # down to base
# emit-shift-args:  size=0   si=-28  delta=12
    movl $8,%eax   # save arg count
    jmp *-2(%edi)  # tail-funcall
    .align 4,0x90
_L_944:
     movl %eax, mrc_eh$ulength
# == explicit-begins  ==>
# (lambda (i) (error (list-ref (primitives) i) "index out of bounds"))
# == eliminate-let*  ==>
# (lambda (i) (error (list-ref (primitives) i) "index out of bounds"))
# == uniquify-variables  ==>
# (lambda (f122) (error (list-ref (primitives) f122) "index out of bounds"))
# == vectorize-letrec  ==>
# (lambda (f122) (error (list-ref (primitives) f122) "index out of bounds"))
# == eliminate-set!  ==>
# (lambda (f122) (let ((f122 f122)) (error (list-ref (primitives) f122) "index out of bounds")))
# == close-free-variables  ==>
# (closure (f122) () (let ((f122 f122)) (error (list-ref (primitives) f122) "index out of bounds")))
# == eliminate-quote  ==>
# (closure (f122) () (let ((f122 f122)) (error (list-ref (primitives) f122) "index out of bounds")))
# == eliminate-when/unless  ==>
# (closure (f122) () (let ((f122 f122)) (error (list-ref (primitives) f122) "index out of bounds")))
# == eliminate-cond  ==>
# (closure (f122) () (let ((f122 f122)) (error (list-ref (primitives) f122) "index out of bounds")))
# == external-symbols  ==>
# (closure (f122) () (let ((f122 f122)) ((primitive-ref error) ((primitive-ref list-ref) ((primitive-ref primitives)) f122) "index out of bounds")))
# emit-expr (closure (f122) () (let ((f122 f122)) ((primitive-ref error) ((primitive-ref list-ref) ((primitive-ref primitives)) f122) "index out of bounds")))
# emit-closure
# si = 0
# env = ()
# expr = (closure (f122) () (let ((f122 f122)) ((primitive-ref error) ((primitive-ref list-ref) ((primitive-ref primitives)) f122) "index out of bounds")))
    movl $_L_950, 0(%ebp)  # closure label
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $8, %ebp     # bump ebp
    jmp _L_951            # jump around closure body
_L_950:
# check argument count
    cmp $4,%eax
    je _L_952
# invoke error handler eh_argcount
    .extern mrc_eh$uargcount
    movl mrc_eh$uargcount, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_952:
# emit-tail-expr
# si=-12
# env=((f122 . -8))
# expr=(let ((f122 f122)) ((primitive-ref error) ((primitive-ref list-ref) ((primitive-ref primitives)) f122) "index out of bounds"))
# emit-tail-let
#  si   = -12
#  env  = ((f122 . -8))
#  bindings = ((f122 f122))
#  body = ((primitive-ref error) ((primitive-ref list-ref) ((primitive-ref primitives)) f122) "index out of bounds")
# emit-expr f122
# emit-variable-ref
# env=((f122 . -8))
# var=f122
    movl -8(%esp), %eax  # stack load f122
# end emit-variable-ref
    movl %eax, -12(%esp)  # stack save
# emit-tail-expr
# si=-16
# env=((f122 . -12) (f122 . -8))
# expr=((primitive-ref error) ((primitive-ref list-ref) ((primitive-ref primitives)) f122) "index out of bounds")
# emit-tail-funcall
#    si   =-16
#    env  = ((f122 . -12) (f122 . -8))
#    expr = (funcall (primitive-ref error) ((primitive-ref list-ref) ((primitive-ref primitives)) f122) "index out of bounds")
# emit-expr (primitive-ref error)
    .extern mrc_error
    movl mrc_error,%eax
   movl %eax,  -16(%esp)  # stash funcall-oper in next closure slot
# emit-expr ((primitive-ref list-ref) ((primitive-ref primitives)) f122)
# funcall
#    si   =-20
#    env  = ((f122 . -12) (f122 . -8))
#    expr = (funcall (primitive-ref list-ref) ((primitive-ref primitives)) f122)
# emit-expr (primitive-ref list-ref)
    .extern mrc_list$mref
    movl mrc_list$mref,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_953"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_953":
   movl %eax,  -28(%esp)  # stash funcall-oper in closure slot
# emit-expr ((primitive-ref primitives))
# funcall
#    si   =-32
#    env  = ((f122 . -12) (f122 . -8))
#    expr = (funcall (primitive-ref primitives))
# emit-expr (primitive-ref primitives)
    .extern mrc_primitives
    movl mrc_primitives,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_954"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_954":
   movl %eax,  -40(%esp)  # stash funcall-oper in closure slot
    movl -40(%esp), %edi   # load new closure to %edi
    add $-32, %esp   # adjust base
    movl $0,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $32, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    mov %eax, -32(%esp)  # arg ((primitive-ref primitives))
# emit-expr f122
# emit-variable-ref
# env=((f122 . -12) (f122 . -8))
# var=f122
    movl -12(%esp), %eax  # stack load f122
# end emit-variable-ref
    mov %eax, -36(%esp)  # arg f122
    movl -28(%esp), %edi   # load new closure to %edi
    add $-20, %esp   # adjust base
    movl $8,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $20, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    mov %eax, -20(%esp)    # arg ((primitive-ref list-ref) ((primitive-ref primitives)) f122)
# emit-expr "index out of bounds"
# string literal
    jmp _L_956
    .align 8,0x90
_L_955 :
    .int 76
    .ascii "index out of bounds"
_L_956:
    movl $_L_955, %eax
    orl $6, %eax
    mov %eax, -24(%esp)    # arg index out of bounds
    movl -16(%esp), %edi   # load new closure to %edi
# emit-shift-args:  size=3   si=-16  delta=12
    mov -16(%esp), %ebx  # shift frame cell
    mov %ebx, -4(%esp)  # down to base
# emit-shift-args:  size=2   si=-20  delta=12
    mov -20(%esp), %ebx  # shift frame cell
    mov %ebx, -8(%esp)  # down to base
# emit-shift-args:  size=1   si=-24  delta=12
    mov -24(%esp), %ebx  # shift frame cell
    mov %ebx, -12(%esp)  # down to base
# emit-shift-args:  size=0   si=-28  delta=12
    movl $8,%eax   # save arg count
    jmp *-2(%edi)  # tail-funcall
    .align 4,0x90
_L_951:
     movl %eax, mrc_eh$uvector$uindex
# == explicit-begins  ==>
# (lambda (i) (error (list-ref (primitives) i) "index out of bounds"))
# == eliminate-let*  ==>
# (lambda (i) (error (list-ref (primitives) i) "index out of bounds"))
# == uniquify-variables  ==>
# (lambda (f123) (error (list-ref (primitives) f123) "index out of bounds"))
# == vectorize-letrec  ==>
# (lambda (f123) (error (list-ref (primitives) f123) "index out of bounds"))
# == eliminate-set!  ==>
# (lambda (f123) (let ((f123 f123)) (error (list-ref (primitives) f123) "index out of bounds")))
# == close-free-variables  ==>
# (closure (f123) () (let ((f123 f123)) (error (list-ref (primitives) f123) "index out of bounds")))
# == eliminate-quote  ==>
# (closure (f123) () (let ((f123 f123)) (error (list-ref (primitives) f123) "index out of bounds")))
# == eliminate-when/unless  ==>
# (closure (f123) () (let ((f123 f123)) (error (list-ref (primitives) f123) "index out of bounds")))
# == eliminate-cond  ==>
# (closure (f123) () (let ((f123 f123)) (error (list-ref (primitives) f123) "index out of bounds")))
# == external-symbols  ==>
# (closure (f123) () (let ((f123 f123)) ((primitive-ref error) ((primitive-ref list-ref) ((primitive-ref primitives)) f123) "index out of bounds")))
# emit-expr (closure (f123) () (let ((f123 f123)) ((primitive-ref error) ((primitive-ref list-ref) ((primitive-ref primitives)) f123) "index out of bounds")))
# emit-closure
# si = 0
# env = ()
# expr = (closure (f123) () (let ((f123 f123)) ((primitive-ref error) ((primitive-ref list-ref) ((primitive-ref primitives)) f123) "index out of bounds")))
    movl $_L_957, 0(%ebp)  # closure label
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $8, %ebp     # bump ebp
    jmp _L_958            # jump around closure body
_L_957:
# check argument count
    cmp $4,%eax
    je _L_959
# invoke error handler eh_argcount
    .extern mrc_eh$uargcount
    movl mrc_eh$uargcount, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_959:
# emit-tail-expr
# si=-12
# env=((f123 . -8))
# expr=(let ((f123 f123)) ((primitive-ref error) ((primitive-ref list-ref) ((primitive-ref primitives)) f123) "index out of bounds"))
# emit-tail-let
#  si   = -12
#  env  = ((f123 . -8))
#  bindings = ((f123 f123))
#  body = ((primitive-ref error) ((primitive-ref list-ref) ((primitive-ref primitives)) f123) "index out of bounds")
# emit-expr f123
# emit-variable-ref
# env=((f123 . -8))
# var=f123
    movl -8(%esp), %eax  # stack load f123
# end emit-variable-ref
    movl %eax, -12(%esp)  # stack save
# emit-tail-expr
# si=-16
# env=((f123 . -12) (f123 . -8))
# expr=((primitive-ref error) ((primitive-ref list-ref) ((primitive-ref primitives)) f123) "index out of bounds")
# emit-tail-funcall
#    si   =-16
#    env  = ((f123 . -12) (f123 . -8))
#    expr = (funcall (primitive-ref error) ((primitive-ref list-ref) ((primitive-ref primitives)) f123) "index out of bounds")
# emit-expr (primitive-ref error)
    .extern mrc_error
    movl mrc_error,%eax
   movl %eax,  -16(%esp)  # stash funcall-oper in next closure slot
# emit-expr ((primitive-ref list-ref) ((primitive-ref primitives)) f123)
# funcall
#    si   =-20
#    env  = ((f123 . -12) (f123 . -8))
#    expr = (funcall (primitive-ref list-ref) ((primitive-ref primitives)) f123)
# emit-expr (primitive-ref list-ref)
    .extern mrc_list$mref
    movl mrc_list$mref,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_960"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_960":
   movl %eax,  -28(%esp)  # stash funcall-oper in closure slot
# emit-expr ((primitive-ref primitives))
# funcall
#    si   =-32
#    env  = ((f123 . -12) (f123 . -8))
#    expr = (funcall (primitive-ref primitives))
# emit-expr (primitive-ref primitives)
    .extern mrc_primitives
    movl mrc_primitives,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_961"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_961":
   movl %eax,  -40(%esp)  # stash funcall-oper in closure slot
    movl -40(%esp), %edi   # load new closure to %edi
    add $-32, %esp   # adjust base
    movl $0,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $32, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    mov %eax, -32(%esp)  # arg ((primitive-ref primitives))
# emit-expr f123
# emit-variable-ref
# env=((f123 . -12) (f123 . -8))
# var=f123
    movl -12(%esp), %eax  # stack load f123
# end emit-variable-ref
    mov %eax, -36(%esp)  # arg f123
    movl -28(%esp), %edi   # load new closure to %edi
    add $-20, %esp   # adjust base
    movl $8,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $20, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    mov %eax, -20(%esp)    # arg ((primitive-ref list-ref) ((primitive-ref primitives)) f123)
# emit-expr "index out of bounds"
# string literal
    jmp _L_963
    .align 8,0x90
_L_962 :
    .int 76
    .ascii "index out of bounds"
_L_963:
    movl $_L_962, %eax
    orl $6, %eax
    mov %eax, -24(%esp)    # arg index out of bounds
    movl -16(%esp), %edi   # load new closure to %edi
# emit-shift-args:  size=3   si=-16  delta=12
    mov -16(%esp), %ebx  # shift frame cell
    mov %ebx, -4(%esp)  # down to base
# emit-shift-args:  size=2   si=-20  delta=12
    mov -20(%esp), %ebx  # shift frame cell
    mov %ebx, -8(%esp)  # down to base
# emit-shift-args:  size=1   si=-24  delta=12
    mov -24(%esp), %ebx  # shift frame cell
    mov %ebx, -12(%esp)  # down to base
# emit-shift-args:  size=0   si=-28  delta=12
    movl $8,%eax   # save arg count
    jmp *-2(%edi)  # tail-funcall
    .align 4,0x90
_L_958:
     movl %eax, mrc_eh$ustring$uindex
# == explicit-begins  ==>
# (lambda (z) (fxzero? z))
# == eliminate-let*  ==>
# (lambda (z) (fxzero? z))
# == uniquify-variables  ==>
# (lambda (f124) (fxzero? f124))
# == vectorize-letrec  ==>
# (lambda (f124) (fxzero? f124))
# == eliminate-set!  ==>
# (lambda (f124) (let ((f124 f124)) (fxzero? f124)))
# == close-free-variables  ==>
# (closure (f124) () (let ((f124 f124)) (fxzero? f124)))
# == eliminate-quote  ==>
# (closure (f124) () (let ((f124 f124)) (fxzero? f124)))
# == eliminate-when/unless  ==>
# (closure (f124) () (let ((f124 f124)) (fxzero? f124)))
# == eliminate-cond  ==>
# (closure (f124) () (let ((f124 f124)) (fxzero? f124)))
# == external-symbols  ==>
# (closure (f124) () (let ((f124 f124)) (fxzero? f124)))
# emit-expr (closure (f124) () (let ((f124 f124)) (fxzero? f124)))
# emit-closure
# si = 0
# env = ()
# expr = (closure (f124) () (let ((f124 f124)) (fxzero? f124)))
    movl $_L_964, 0(%ebp)  # closure label
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $8, %ebp     # bump ebp
    jmp _L_965            # jump around closure body
_L_964:
# check argument count
    cmp $4,%eax
    je _L_966
# invoke error handler eh_argcount
    .extern mrc_eh$uargcount
    movl mrc_eh$uargcount, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_966:
# emit-tail-expr
# si=-12
# env=((f124 . -8))
# expr=(let ((f124 f124)) (fxzero? f124))
# emit-tail-let
#  si   = -12
#  env  = ((f124 . -8))
#  bindings = ((f124 f124))
#  body = (fxzero? f124)
# emit-expr f124
# emit-variable-ref
# env=((f124 . -8))
# var=f124
    movl -8(%esp), %eax  # stack load f124
# end emit-variable-ref
    movl %eax, -12(%esp)  # stack save
# emit-tail-expr
# si=-16
# env=((f124 . -12) (f124 . -8))
# expr=(fxzero? f124)
# tail primcall
# emit-expr f124
# emit-variable-ref
# env=((f124 . -12) (f124 . -8))
# var=f124
    movl -12(%esp), %eax  # stack load f124
# end emit-variable-ref
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_967"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $64,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_967:
    cmp $0, %eax
    sete %al
    movzbl %al, %eax
    sal $6, %al
    or $47, %al
#return from tail (fxzero? f124)
    ret
    .align 4,0x90
_L_965:
     movl %eax, mrc_zero$q
# == explicit-begins  ==>
# (lambda (x) (fx> x 0))
# == eliminate-let*  ==>
# (lambda (x) (fx> x 0))
# == uniquify-variables  ==>
# (lambda (f125) (fx> f125 0))
# == vectorize-letrec  ==>
# (lambda (f125) (fx> f125 0))
# == eliminate-set!  ==>
# (lambda (f125) (let ((f125 f125)) (fx> f125 0)))
# == close-free-variables  ==>
# (closure (f125) () (let ((f125 f125)) (fx> f125 0)))
# == eliminate-quote  ==>
# (closure (f125) () (let ((f125 f125)) (fx> f125 0)))
# == eliminate-when/unless  ==>
# (closure (f125) () (let ((f125 f125)) (fx> f125 0)))
# == eliminate-cond  ==>
# (closure (f125) () (let ((f125 f125)) (fx> f125 0)))
# == external-symbols  ==>
# (closure (f125) () (let ((f125 f125)) (fx> f125 0)))
# emit-expr (closure (f125) () (let ((f125 f125)) (fx> f125 0)))
# emit-closure
# si = 0
# env = ()
# expr = (closure (f125) () (let ((f125 f125)) (fx> f125 0)))
    movl $_L_968, 0(%ebp)  # closure label
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $8, %ebp     # bump ebp
    jmp _L_969            # jump around closure body
_L_968:
# check argument count
    cmp $4,%eax
    je _L_970
# invoke error handler eh_argcount
    .extern mrc_eh$uargcount
    movl mrc_eh$uargcount, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_970:
# emit-tail-expr
# si=-12
# env=((f125 . -8))
# expr=(let ((f125 f125)) (fx> f125 0))
# emit-tail-let
#  si   = -12
#  env  = ((f125 . -8))
#  bindings = ((f125 f125))
#  body = (fx> f125 0)
# emit-expr f125
# emit-variable-ref
# env=((f125 . -8))
# var=f125
    movl -8(%esp), %eax  # stack load f125
# end emit-variable-ref
    movl %eax, -12(%esp)  # stack save
# emit-tail-expr
# si=-16
# env=((f125 . -12) (f125 . -8))
# expr=(fx> f125 0)
# tail primcall
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_971"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $80,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_971:
    movl %eax, -16(%esp)
# emit-expr f125
# emit-variable-ref
# env=((f125 . -12) (f125 . -8))
# var=f125
    movl -12(%esp), %eax  # stack load f125
# end emit-variable-ref
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_972"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $80,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_972:
    cmp -16(%esp), %eax
    setg %al
    movzbl %al, %eax
    sal $6, %al
    or $47, %al
#return from tail (fx> f125 0)
    ret
    .align 4,0x90
_L_969:
     movl %eax, mrc_positive$q
# == explicit-begins  ==>
# (lambda (x) (fx< x 0))
# == eliminate-let*  ==>
# (lambda (x) (fx< x 0))
# == uniquify-variables  ==>
# (lambda (f126) (fx< f126 0))
# == vectorize-letrec  ==>
# (lambda (f126) (fx< f126 0))
# == eliminate-set!  ==>
# (lambda (f126) (let ((f126 f126)) (fx< f126 0)))
# == close-free-variables  ==>
# (closure (f126) () (let ((f126 f126)) (fx< f126 0)))
# == eliminate-quote  ==>
# (closure (f126) () (let ((f126 f126)) (fx< f126 0)))
# == eliminate-when/unless  ==>
# (closure (f126) () (let ((f126 f126)) (fx< f126 0)))
# == eliminate-cond  ==>
# (closure (f126) () (let ((f126 f126)) (fx< f126 0)))
# == external-symbols  ==>
# (closure (f126) () (let ((f126 f126)) (fx< f126 0)))
# emit-expr (closure (f126) () (let ((f126 f126)) (fx< f126 0)))
# emit-closure
# si = 0
# env = ()
# expr = (closure (f126) () (let ((f126 f126)) (fx< f126 0)))
    movl $_L_973, 0(%ebp)  # closure label
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $8, %ebp     # bump ebp
    jmp _L_974            # jump around closure body
_L_973:
# check argument count
    cmp $4,%eax
    je _L_975
# invoke error handler eh_argcount
    .extern mrc_eh$uargcount
    movl mrc_eh$uargcount, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_975:
# emit-tail-expr
# si=-12
# env=((f126 . -8))
# expr=(let ((f126 f126)) (fx< f126 0))
# emit-tail-let
#  si   = -12
#  env  = ((f126 . -8))
#  bindings = ((f126 f126))
#  body = (fx< f126 0)
# emit-expr f126
# emit-variable-ref
# env=((f126 . -8))
# var=f126
    movl -8(%esp), %eax  # stack load f126
# end emit-variable-ref
    movl %eax, -12(%esp)  # stack save
# emit-tail-expr
# si=-16
# env=((f126 . -12) (f126 . -8))
# expr=(fx< f126 0)
# tail primcall
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_976"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $72,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_976:
    movl %eax, -16(%esp)
# emit-expr f126
# emit-variable-ref
# env=((f126 . -12) (f126 . -8))
# var=f126
    movl -12(%esp), %eax  # stack load f126
# end emit-variable-ref
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_977"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $72,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_977:
    cmp -16(%esp), %eax
    setl %al
    movzbl %al, %eax
    sal $6, %al
    or $47, %al
#return from tail (fx< f126 0)
    ret
    .align 4,0x90
_L_974:
     movl %eax, mrc_negative$q
# == explicit-begins  ==>
# (lambda (x) (fxzero? (fxremainder x 2)))
# == eliminate-let*  ==>
# (lambda (x) (fxzero? (fxremainder x 2)))
# == uniquify-variables  ==>
# (lambda (f127) (fxzero? (fxremainder f127 2)))
# == vectorize-letrec  ==>
# (lambda (f127) (fxzero? (fxremainder f127 2)))
# == eliminate-set!  ==>
# (lambda (f127) (let ((f127 f127)) (fxzero? (fxremainder f127 2))))
# == close-free-variables  ==>
# (closure (f127) () (let ((f127 f127)) (fxzero? (fxremainder f127 2))))
# == eliminate-quote  ==>
# (closure (f127) () (let ((f127 f127)) (fxzero? (fxremainder f127 2))))
# == eliminate-when/unless  ==>
# (closure (f127) () (let ((f127 f127)) (fxzero? (fxremainder f127 2))))
# == eliminate-cond  ==>
# (closure (f127) () (let ((f127 f127)) (fxzero? (fxremainder f127 2))))
# == external-symbols  ==>
# (closure (f127) () (let ((f127 f127)) (fxzero? (fxremainder f127 2))))
# emit-expr (closure (f127) () (let ((f127 f127)) (fxzero? (fxremainder f127 2))))
# emit-closure
# si = 0
# env = ()
# expr = (closure (f127) () (let ((f127 f127)) (fxzero? (fxremainder f127 2))))
    movl $_L_978, 0(%ebp)  # closure label
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $8, %ebp     # bump ebp
    jmp _L_979            # jump around closure body
_L_978:
# check argument count
    cmp $4,%eax
    je _L_980
# invoke error handler eh_argcount
    .extern mrc_eh$uargcount
    movl mrc_eh$uargcount, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_980:
# emit-tail-expr
# si=-12
# env=((f127 . -8))
# expr=(let ((f127 f127)) (fxzero? (fxremainder f127 2)))
# emit-tail-let
#  si   = -12
#  env  = ((f127 . -8))
#  bindings = ((f127 f127))
#  body = (fxzero? (fxremainder f127 2))
# emit-expr f127
# emit-variable-ref
# env=((f127 . -8))
# var=f127
    movl -8(%esp), %eax  # stack load f127
# end emit-variable-ref
    movl %eax, -12(%esp)  # stack save
# emit-tail-expr
# si=-16
# env=((f127 . -12) (f127 . -8))
# expr=(fxzero? (fxremainder f127 2))
# tail primcall
# emit-expr (fxremainder f127 2)
# emit-expr 2
    movl $8, %eax     # immed 2
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_982"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $100,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_982:
    movl %eax, -16(%esp)  # denominator
# emit-expr f127
# emit-variable-ref
# env=((f127 . -12) (f127 . -8))
# var=f127
    movl -12(%esp), %eax  # stack load f127
# end emit-variable-ref
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_983"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $100,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_983:
    movl -16(%esp),%ebx   # ebx <- denominator
    xor %edx,%edx        # edx <- 0
    cmp $0,%eax
    jge _L_981
    not %edx
_L_981:
    idiv %ebx            # edx <- edx:eax/ebx  remainder
    movl %edx,%eax
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_984"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $64,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_984:
    cmp $0, %eax
    sete %al
    movzbl %al, %eax
    sal $6, %al
    or $47, %al
#return from tail (fxzero? (fxremainder f127 2))
    ret
    .align 4,0x90
_L_979:
     movl %eax, mrc_even$q
# == explicit-begins  ==>
# (lambda (x) (not (even? x)))
# == eliminate-let*  ==>
# (lambda (x) (not (even? x)))
# == uniquify-variables  ==>
# (lambda (f128) (not (even? f128)))
# == vectorize-letrec  ==>
# (lambda (f128) (not (even? f128)))
# == eliminate-set!  ==>
# (lambda (f128) (let ((f128 f128)) (not (even? f128))))
# == close-free-variables  ==>
# (closure (f128) () (let ((f128 f128)) (not (even? f128))))
# == eliminate-quote  ==>
# (closure (f128) () (let ((f128 f128)) (not (even? f128))))
# == eliminate-when/unless  ==>
# (closure (f128) () (let ((f128 f128)) (not (even? f128))))
# == eliminate-cond  ==>
# (closure (f128) () (let ((f128 f128)) (not (even? f128))))
# == external-symbols  ==>
# (closure (f128) () (let ((f128 f128)) (not ((primitive-ref even?) f128))))
# emit-expr (closure (f128) () (let ((f128 f128)) (not ((primitive-ref even?) f128))))
# emit-closure
# si = 0
# env = ()
# expr = (closure (f128) () (let ((f128 f128)) (not ((primitive-ref even?) f128))))
    movl $_L_985, 0(%ebp)  # closure label
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $8, %ebp     # bump ebp
    jmp _L_986            # jump around closure body
_L_985:
# check argument count
    cmp $4,%eax
    je _L_987
# invoke error handler eh_argcount
    .extern mrc_eh$uargcount
    movl mrc_eh$uargcount, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_987:
# emit-tail-expr
# si=-12
# env=((f128 . -8))
# expr=(let ((f128 f128)) (not ((primitive-ref even?) f128)))
# emit-tail-let
#  si   = -12
#  env  = ((f128 . -8))
#  bindings = ((f128 f128))
#  body = (not ((primitive-ref even?) f128))
# emit-expr f128
# emit-variable-ref
# env=((f128 . -8))
# var=f128
    movl -8(%esp), %eax  # stack load f128
# end emit-variable-ref
    movl %eax, -12(%esp)  # stack save
# emit-tail-expr
# si=-16
# env=((f128 . -12) (f128 . -8))
# expr=(not ((primitive-ref even?) f128))
# tail primcall
# emit-expr ((primitive-ref even?) f128)
# funcall
#    si   =-16
#    env  = ((f128 . -12) (f128 . -8))
#    expr = (funcall (primitive-ref even?) f128)
# emit-expr (primitive-ref even?)
    .extern mrc_even$q
    movl mrc_even$q,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_988"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_988":
   movl %eax,  -24(%esp)  # stash funcall-oper in closure slot
# emit-expr f128
# emit-variable-ref
# env=((f128 . -12) (f128 . -8))
# var=f128
    movl -12(%esp), %eax  # stack load f128
# end emit-variable-ref
    mov %eax, -28(%esp)  # arg f128
    movl -24(%esp), %edi   # load new closure to %edi
    add $-16, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $16, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    cmp $47, %eax
    sete %al
    movzbl %al, %eax
    sal $6, %al
    or $47, %al
#return from tail (not ((primitive-ref even?) f128))
    ret
    .align 4,0x90
_L_986:
     movl %eax, mrc_odd$q
# == explicit-begins  ==>
# (lambda (f l) (if (null? l) (quote ()) (cons (f (car l)) (map f (cdr l)))))
# == eliminate-let*  ==>
# (lambda (f l) (if (null? l) (quote ()) (cons (f (car l)) (map f (cdr l)))))
# == uniquify-variables  ==>
<<<<<<< HEAD
# (lambda (f310917 f310916) (if (null? f310916) (quote ()) (cons (f310917 (car f310916)) (map f310917 (cdr f310916)))))
# == vectorize-letrec  ==>
# (lambda (f310917 f310916) (if (null? f310916) (quote ()) (cons (f310917 (car f310916)) (map f310917 (cdr f310916)))))
# == eliminate-set!  ==>
# (lambda (f310917 f310916) (let ((f310917 f310917) (f310916 f310916)) (if (null? f310916) (quote ()) (cons (f310917 (car f310916)) (map f310917 (cdr f310916))))))
# == close-free-variables  ==>
# (closure (f310917 f310916) () (let ((f310917 f310917) (f310916 f310916)) (if (null? f310916) (quote ()) (cons (f310917 (car f310916)) (map f310917 (cdr f310916))))))
# == eliminate-quote  ==>
# (closure (f310917 f310916) () (let ((f310917 f310917) (f310916 f310916)) (if (null? f310916) () (cons (f310917 (car f310916)) (map f310917 (cdr f310916))))))
# == eliminate-when/unless  ==>
# (closure (f310917 f310916) () (let ((f310917 f310917) (f310916 f310916)) (if (null? f310916) () (cons (f310917 (car f310916)) (map f310917 (cdr f310916))))))
# == eliminate-cond  ==>
# (closure (f310917 f310916) () (let ((f310917 f310917) (f310916 f310916)) (if (null? f310916) () (cons (f310917 (car f310916)) (map f310917 (cdr f310916))))))
# == external-symbols  ==>
# (closure (f310917 f310916) () (let ((f310917 f310917) (f310916 f310916)) (if (null? f310916) () (cons (f310917 (car f310916)) ((primitive-ref map) f310917 (cdr f310916))))))
# emit-expr (closure (f310917 f310916) () (let ((f310917 f310917) (f310916 f310916)) (if (null? f310916) () (cons (f310917 (car f310916)) ((primitive-ref map) f310917 (cdr f310916))))))
# emit-closure
# si = 0
# env = ()
# expr = (closure (f310917 f310916) () (let ((f310917 f310917) (f310916 f310916)) (if (null? f310916) () (cons (f310917 (car f310916)) ((primitive-ref map) f310917 (cdr f310916))))))
    movl $_L_1884588, 0(%ebp)  # closure label
=======
# (lambda (f129 f130) (if (null? f130) (quote ()) (cons (f129 (car f130)) (map f129 (cdr f130)))))
# == vectorize-letrec  ==>
# (lambda (f129 f130) (if (null? f130) (quote ()) (cons (f129 (car f130)) (map f129 (cdr f130)))))
# == eliminate-set!  ==>
# (lambda (f129 f130) (let ((f129 f129) (f130 f130)) (if (null? f130) (quote ()) (cons (f129 (car f130)) (map f129 (cdr f130))))))
# == close-free-variables  ==>
# (closure (f129 f130) () (let ((f129 f129) (f130 f130)) (if (null? f130) (quote ()) (cons (f129 (car f130)) (map f129 (cdr f130))))))
# == eliminate-quote  ==>
# (closure (f129 f130) () (let ((f129 f129) (f130 f130)) (if (null? f130) () (cons (f129 (car f130)) (map f129 (cdr f130))))))
# == eliminate-when/unless  ==>
# (closure (f129 f130) () (let ((f129 f129) (f130 f130)) (if (null? f130) () (cons (f129 (car f130)) (map f129 (cdr f130))))))
# == eliminate-cond  ==>
# (closure (f129 f130) () (let ((f129 f129) (f130 f130)) (if (null? f130) () (cons (f129 (car f130)) (map f129 (cdr f130))))))
# == external-symbols  ==>
# (closure (f129 f130) () (let ((f129 f129) (f130 f130)) (if (null? f130) () (cons (f129 (car f130)) ((primitive-ref map) f129 (cdr f130))))))
# emit-expr (closure (f129 f130) () (let ((f129 f129) (f130 f130)) (if (null? f130) () (cons (f129 (car f130)) ((primitive-ref map) f129 (cdr f130))))))
# emit-closure
# si = 0
# env = ()
# expr = (closure (f129 f130) () (let ((f129 f129) (f130 f130)) (if (null? f130) () (cons (f129 (car f130)) ((primitive-ref map) f129 (cdr f130))))))
    movl $_L_989, 0(%ebp)  # closure label
>>>>>>> fix-implicit-begins
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $8, %ebp     # bump ebp
    jmp _L_990            # jump around closure body
_L_989:
# check argument count
    cmp $8,%eax
    je _L_991
# invoke error handler eh_argcount
    .extern mrc_eh$uargcount
    movl mrc_eh$uargcount, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_991:
# emit-tail-expr
# si=-16
<<<<<<< HEAD
# env=((f310916 . -12) (f310917 . -8))
# expr=(let ((f310917 f310917) (f310916 f310916)) (if (null? f310916) () (cons (f310917 (car f310916)) ((primitive-ref map) f310917 (cdr f310916)))))
# emit-tail-let
#  si   = -16
#  env  = ((f310916 . -12) (f310917 . -8))
#  bindings = ((f310917 f310917) (f310916 f310916))
#  body = (if (null? f310916) () (cons (f310917 (car f310916)) ((primitive-ref map) f310917 (cdr f310916))))
# emit-expr f310917
# emit-variable-ref
# env=((f310916 . -12) (f310917 . -8))
# var=f310917
    movl -8(%esp), %eax  # stack load f310917
# end emit-variable-ref
    movl %eax, -16(%esp)  # stack save
# emit-expr f310916
# emit-variable-ref
# env=((f310916 . -12) (f310917 . -8))
# var=f310916
    movl -12(%esp), %eax  # stack load f310916
=======
# env=((f130 . -12) (f129 . -8))
# expr=(let ((f129 f129) (f130 f130)) (if (null? f130) () (cons (f129 (car f130)) ((primitive-ref map) f129 (cdr f130)))))
# emit-tail-let
#  si   = -16
#  env  = ((f130 . -12) (f129 . -8))
#  bindings = ((f129 f129) (f130 f130))
#  body = (if (null? f130) () (cons (f129 (car f130)) ((primitive-ref map) f129 (cdr f130))))
# emit-expr f129
# emit-variable-ref
# env=((f130 . -12) (f129 . -8))
# var=f129
    movl -8(%esp), %eax  # stack load f129
# end emit-variable-ref
    movl %eax, -16(%esp)  # stack save
# emit-expr f130
# emit-variable-ref
# env=((f130 . -12) (f129 . -8))
# var=f130
    movl -12(%esp), %eax  # stack load f130
>>>>>>> fix-implicit-begins
# end emit-variable-ref
    movl %eax, -20(%esp)  # stack save
# emit-tail-expr
# si=-24
<<<<<<< HEAD
# env=((f310916 . -20) (f310917 . -16) (f310916 . -12) (f310917 . -8))
# expr=(if (null? f310916) () (cons (f310917 (car f310916)) ((primitive-ref map) f310917 (cdr f310916))))
# emit-expr (null? f310916)
# emit-expr f310916
# emit-variable-ref
# env=((f310916 . -20) (f310917 . -16) (f310916 . -12) (f310917 . -8))
# var=f310916
    movl -20(%esp), %eax  # stack load f310916
=======
# env=((f130 . -20) (f129 . -16) (f130 . -12) (f129 . -8))
# expr=(if (null? f130) () (cons (f129 (car f130)) ((primitive-ref map) f129 (cdr f130))))
# emit-expr (null? f130)
# emit-expr f130
# emit-variable-ref
# env=((f130 . -20) (f129 . -16) (f130 . -12) (f129 . -8))
# var=f130
    movl -20(%esp), %eax  # stack load f130
>>>>>>> fix-implicit-begins
# end emit-variable-ref
    cmp $63, %eax
    mov $0, %eax
    sete %al
    movzbl %al, %eax
    sal $6, %al
    or $47, %al
    cmp $47, %al
    je _L_992
# emit-tail-expr
# si=-24
<<<<<<< HEAD
# env=((f310916 . -20) (f310917 . -16) (f310916 . -12) (f310917 . -8))
=======
# env=((f130 . -20) (f129 . -16) (f130 . -12) (f129 . -8))
>>>>>>> fix-implicit-begins
# expr=()
    movl $63, %eax     # immed ()
    ret                  # immediate tail return
    jmp _L_993
_L_992:
# emit-tail-expr
# si=-24
<<<<<<< HEAD
# env=((f310916 . -20) (f310917 . -16) (f310916 . -12) (f310917 . -8))
# expr=(cons (f310917 (car f310916)) ((primitive-ref map) f310917 (cdr f310916)))
# tail primcall
# cons arg1=(f310917 (car f310916)) arg2=((primitive-ref map) f310917 (cdr f310916))
# emit-expr (f310917 (car f310916))
# funcall
#    si   =-24
#    env  = ((f310916 . -20) (f310917 . -16) (f310916 . -12) (f310917 . -8))
#    expr = (funcall f310917 (car f310916))
# emit-expr f310917
# emit-variable-ref
# env=((f310916 . -20) (f310917 . -16) (f310916 . -12) (f310917 . -8))
# var=f310917
    movl -16(%esp), %eax  # stack load f310917
=======
# env=((f130 . -20) (f129 . -16) (f130 . -12) (f129 . -8))
# expr=(cons (f129 (car f130)) ((primitive-ref map) f129 (cdr f130)))
# tail primcall
# cons arg1=(f129 (car f130)) arg2=((primitive-ref map) f129 (cdr f130))
# emit-expr (f129 (car f130))
# funcall
#    si   =-24
#    env  = ((f130 . -20) (f129 . -16) (f130 . -12) (f129 . -8))
#    expr = (funcall f129 (car f130))
# emit-expr f129
# emit-variable-ref
# env=((f130 . -20) (f129 . -16) (f130 . -12) (f129 . -8))
# var=f129
    movl -16(%esp), %eax  # stack load f129
>>>>>>> fix-implicit-begins
# end emit-variable-ref
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_994"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_994":
   movl %eax,  -32(%esp)  # stash funcall-oper in closure slot
<<<<<<< HEAD
# emit-expr (car f310916)
# emit-expr f310916
# emit-variable-ref
# env=((f310916 . -20) (f310917 . -16) (f310916 . -12) (f310917 . -8))
# var=f310916
    movl -20(%esp), %eax  # stack load f310916
=======
# emit-expr (car f130)
# emit-expr f130
# emit-variable-ref
# env=((f130 . -20) (f129 . -16) (f130 . -12) (f129 . -8))
# var=f130
    movl -20(%esp), %eax  # stack load f130
>>>>>>> fix-implicit-begins
# end emit-variable-ref
# check the argument is a pair
    movl %eax,%ebx
    and $7, %bl
    cmp $1, %bl
    je _L_995
# invoke error handler eh_pair
    .extern mrc_eh$upair
    movl mrc_eh$upair, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $116,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_995:
    movl -1(%eax), %eax
<<<<<<< HEAD
    mov %eax, -36(%esp)  # arg (car f310916)
=======
    mov %eax, -36(%esp)  # arg (car f130)
>>>>>>> fix-implicit-begins
    movl -32(%esp), %edi   # load new closure to %edi
    add $-24, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $24, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    movl %eax, -24(%esp)
<<<<<<< HEAD
# emit-expr ((primitive-ref map) f310917 (cdr f310916))
# funcall
#    si   =-28
#    env  = ((f310916 . -20) (f310917 . -16) (f310916 . -12) (f310917 . -8))
#    expr = (funcall (primitive-ref map) f310917 (cdr f310916))
=======
# emit-expr ((primitive-ref map) f129 (cdr f130))
# funcall
#    si   =-28
#    env  = ((f130 . -20) (f129 . -16) (f130 . -12) (f129 . -8))
#    expr = (funcall (primitive-ref map) f129 (cdr f130))
>>>>>>> fix-implicit-begins
# emit-expr (primitive-ref map)
    .extern mrc_map
    movl mrc_map,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_996"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_996":
   movl %eax,  -36(%esp)  # stash funcall-oper in closure slot
<<<<<<< HEAD
# emit-expr f310917
# emit-variable-ref
# env=((f310916 . -20) (f310917 . -16) (f310916 . -12) (f310917 . -8))
# var=f310917
    movl -16(%esp), %eax  # stack load f310917
# end emit-variable-ref
    mov %eax, -40(%esp)  # arg f310917
# emit-expr (cdr f310916)
# emit-expr f310916
# emit-variable-ref
# env=((f310916 . -20) (f310917 . -16) (f310916 . -12) (f310917 . -8))
# var=f310916
    movl -20(%esp), %eax  # stack load f310916
=======
# emit-expr f129
# emit-variable-ref
# env=((f130 . -20) (f129 . -16) (f130 . -12) (f129 . -8))
# var=f129
    movl -16(%esp), %eax  # stack load f129
# end emit-variable-ref
    mov %eax, -40(%esp)  # arg f129
# emit-expr (cdr f130)
# emit-expr f130
# emit-variable-ref
# env=((f130 . -20) (f129 . -16) (f130 . -12) (f129 . -8))
# var=f130
    movl -20(%esp), %eax  # stack load f130
>>>>>>> fix-implicit-begins
# end emit-variable-ref
# check the argument is a pair
    movl %eax,%ebx
    and $7, %bl
    cmp $1, %bl
    je _L_997
# invoke error handler eh_pair
    .extern mrc_eh$upair
    movl mrc_eh$upair, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $120,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_997:
    movl 3(%eax), %eax
<<<<<<< HEAD
    mov %eax, -44(%esp)  # arg (cdr f310916)
=======
    mov %eax, -44(%esp)  # arg (cdr f130)
>>>>>>> fix-implicit-begins
    movl -36(%esp), %edi   # load new closure to %edi
    add $-28, %esp   # adjust base
    movl $8,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $28, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    movl %eax, 4(%ebp)
    movl -24(%esp), %eax
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    or   $1, %al
    add  $8, %ebp
# cons end
<<<<<<< HEAD
#return from tail (cons (f310917 (car f310916)) ((primitive-ref map) f310917 (cdr f310916)))
=======
#return from tail (cons (f129 (car f130)) ((primitive-ref map) f129 (cdr f130)))
>>>>>>> fix-implicit-begins
    ret
_L_993:
    .align 4,0x90
_L_990:
     movl %eax, mrc_map
# == explicit-begins  ==>
# (lambda (f l) (unless (null? l) (begin (f (car l)) (for-each f (cdr l)))))
# == eliminate-let*  ==>
# (lambda (f l) (unless (null? l) (begin (f (car l)) (for-each f (cdr l)))))
# == uniquify-variables  ==>
<<<<<<< HEAD
# (lambda (f310919 f310918) (unless (null? f310918) (begin (f310919 (car f310918)) (for-each f310919 (cdr f310918)))))
# == vectorize-letrec  ==>
# (lambda (f310919 f310918) (unless (null? f310918) (begin (f310919 (car f310918)) (for-each f310919 (cdr f310918)))))
# == eliminate-set!  ==>
# (lambda (f310919 f310918) (let ((f310919 f310919) (f310918 f310918)) (unless (null? f310918) (begin (f310919 (car f310918)) (for-each f310919 (cdr f310918))))))
# == close-free-variables  ==>
# (closure (f310919 f310918) () (let ((f310919 f310919) (f310918 f310918)) (unless (null? f310918) (begin (f310919 (car f310918)) (for-each f310919 (cdr f310918))))))
# == eliminate-quote  ==>
# (closure (f310919 f310918) () (let ((f310919 f310919) (f310918 f310918)) (unless (null? f310918) (begin (f310919 (car f310918)) (for-each f310919 (cdr f310918))))))
# == eliminate-when/unless  ==>
# (closure (f310919 f310918) () (let ((f310919 f310919) (f310918 f310918)) (if (not (null? f310918)) (begin (begin (f310919 (car f310918)) (for-each f310919 (cdr f310918)))) #f)))
# == eliminate-cond  ==>
# (closure (f310919 f310918) () (let ((f310919 f310919) (f310918 f310918)) (if (not (null? f310918)) (begin (begin (f310919 (car f310918)) (for-each f310919 (cdr f310918)))) #f)))
# == external-symbols  ==>
# (closure (f310919 f310918) () (let ((f310919 f310919) (f310918 f310918)) (if (not (null? f310918)) (begin (begin (f310919 (car f310918)) ((primitive-ref for-each) f310919 (cdr f310918)))) #f)))
# emit-expr (closure (f310919 f310918) () (let ((f310919 f310919) (f310918 f310918)) (if (not (null? f310918)) (begin (begin (f310919 (car f310918)) ((primitive-ref for-each) f310919 (cdr f310918)))) #f)))
# emit-closure
# si = 0
# env = ()
# expr = (closure (f310919 f310918) () (let ((f310919 f310919) (f310918 f310918)) (if (not (null? f310918)) (begin (begin (f310919 (car f310918)) ((primitive-ref for-each) f310919 (cdr f310918)))) #f)))
    movl $_L_1884597, 0(%ebp)  # closure label
=======
# (lambda (f131 f132) (unless (null? f132) (begin (f131 (car f132)) (for-each f131 (cdr f132)))))
# == vectorize-letrec  ==>
# (lambda (f131 f132) (unless (null? f132) (begin (f131 (car f132)) (for-each f131 (cdr f132)))))
# == eliminate-set!  ==>
# (lambda (f131 f132) (let ((f131 f131) (f132 f132)) (unless (null? f132) (begin (f131 (car f132)) (for-each f131 (cdr f132))))))
# == close-free-variables  ==>
# (closure (f131 f132) () (let ((f131 f131) (f132 f132)) (unless (null? f132) (begin (f131 (car f132)) (for-each f131 (cdr f132))))))
# == eliminate-quote  ==>
# (closure (f131 f132) () (let ((f131 f131) (f132 f132)) (unless (null? f132) (begin (f131 (car f132)) (for-each f131 (cdr f132))))))
# == eliminate-when/unless  ==>
# (closure (f131 f132) () (let ((f131 f131) (f132 f132)) (if (not (null? f132)) (begin (begin (f131 (car f132)) (for-each f131 (cdr f132)))) #f)))
# == eliminate-cond  ==>
# (closure (f131 f132) () (let ((f131 f131) (f132 f132)) (if (not (null? f132)) (begin (begin (f131 (car f132)) (for-each f131 (cdr f132)))) #f)))
# == external-symbols  ==>
# (closure (f131 f132) () (let ((f131 f131) (f132 f132)) (if (not (null? f132)) (begin (begin (f131 (car f132)) ((primitive-ref for-each) f131 (cdr f132)))) #f)))
# emit-expr (closure (f131 f132) () (let ((f131 f131) (f132 f132)) (if (not (null? f132)) (begin (begin (f131 (car f132)) ((primitive-ref for-each) f131 (cdr f132)))) #f)))
# emit-closure
# si = 0
# env = ()
# expr = (closure (f131 f132) () (let ((f131 f131) (f132 f132)) (if (not (null? f132)) (begin (begin (f131 (car f132)) ((primitive-ref for-each) f131 (cdr f132)))) #f)))
    movl $_L_998, 0(%ebp)  # closure label
>>>>>>> fix-implicit-begins
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $8, %ebp     # bump ebp
    jmp _L_999            # jump around closure body
_L_998:
# check argument count
    cmp $8,%eax
    je _L_1000
# invoke error handler eh_argcount
    .extern mrc_eh$uargcount
    movl mrc_eh$uargcount, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_1000:
# emit-tail-expr
# si=-16
<<<<<<< HEAD
# env=((f310918 . -12) (f310919 . -8))
# expr=(let ((f310919 f310919) (f310918 f310918)) (if (not (null? f310918)) (begin (begin (f310919 (car f310918)) ((primitive-ref for-each) f310919 (cdr f310918)))) #f))
# emit-tail-let
#  si   = -16
#  env  = ((f310918 . -12) (f310919 . -8))
#  bindings = ((f310919 f310919) (f310918 f310918))
#  body = (if (not (null? f310918)) (begin (begin (f310919 (car f310918)) ((primitive-ref for-each) f310919 (cdr f310918)))) #f)
# emit-expr f310919
# emit-variable-ref
# env=((f310918 . -12) (f310919 . -8))
# var=f310919
    movl -8(%esp), %eax  # stack load f310919
# end emit-variable-ref
    movl %eax, -16(%esp)  # stack save
# emit-expr f310918
# emit-variable-ref
# env=((f310918 . -12) (f310919 . -8))
# var=f310918
    movl -12(%esp), %eax  # stack load f310918
=======
# env=((f132 . -12) (f131 . -8))
# expr=(let ((f131 f131) (f132 f132)) (if (not (null? f132)) (begin (begin (f131 (car f132)) ((primitive-ref for-each) f131 (cdr f132)))) #f))
# emit-tail-let
#  si   = -16
#  env  = ((f132 . -12) (f131 . -8))
#  bindings = ((f131 f131) (f132 f132))
#  body = (if (not (null? f132)) (begin (begin (f131 (car f132)) ((primitive-ref for-each) f131 (cdr f132)))) #f)
# emit-expr f131
# emit-variable-ref
# env=((f132 . -12) (f131 . -8))
# var=f131
    movl -8(%esp), %eax  # stack load f131
# end emit-variable-ref
    movl %eax, -16(%esp)  # stack save
# emit-expr f132
# emit-variable-ref
# env=((f132 . -12) (f131 . -8))
# var=f132
    movl -12(%esp), %eax  # stack load f132
>>>>>>> fix-implicit-begins
# end emit-variable-ref
    movl %eax, -20(%esp)  # stack save
# emit-tail-expr
# si=-24
<<<<<<< HEAD
# env=((f310918 . -20) (f310919 . -16) (f310918 . -12) (f310919 . -8))
# expr=(if (not (null? f310918)) (begin (begin (f310919 (car f310918)) ((primitive-ref for-each) f310919 (cdr f310918)))) #f)
# emit-expr (not (null? f310918))
# emit-expr (null? f310918)
# emit-expr f310918
# emit-variable-ref
# env=((f310918 . -20) (f310919 . -16) (f310918 . -12) (f310919 . -8))
# var=f310918
    movl -20(%esp), %eax  # stack load f310918
=======
# env=((f132 . -20) (f131 . -16) (f132 . -12) (f131 . -8))
# expr=(if (not (null? f132)) (begin (begin (f131 (car f132)) ((primitive-ref for-each) f131 (cdr f132)))) #f)
# emit-expr (not (null? f132))
# emit-expr (null? f132)
# emit-expr f132
# emit-variable-ref
# env=((f132 . -20) (f131 . -16) (f132 . -12) (f131 . -8))
# var=f132
    movl -20(%esp), %eax  # stack load f132
>>>>>>> fix-implicit-begins
# end emit-variable-ref
    cmp $63, %eax
    mov $0, %eax
    sete %al
    movzbl %al, %eax
    sal $6, %al
    or $47, %al
    cmp $47, %eax
    sete %al
    movzbl %al, %eax
    sal $6, %al
    or $47, %al
    cmp $47, %al
    je _L_1001
# emit-tail-expr
# si=-24
<<<<<<< HEAD
# env=((f310918 . -20) (f310919 . -16) (f310918 . -12) (f310919 . -8))
# expr=(begin (begin (f310919 (car f310918)) ((primitive-ref for-each) f310919 (cdr f310918))))
# tail-begin (begin (begin (f310919 (car f310918)) ((primitive-ref for-each) f310919 (cdr f310918))))
#   env=((f310918 . -20) (f310919 . -16) (f310918 . -12) (f310919 . -8))
# emit-tail-expr
# si=-24
# env=((f310918 . -20) (f310919 . -16) (f310918 . -12) (f310919 . -8))
# expr=(begin (f310919 (car f310918)) ((primitive-ref for-each) f310919 (cdr f310918)))
# tail-begin (begin (f310919 (car f310918)) ((primitive-ref for-each) f310919 (cdr f310918)))
#   env=((f310918 . -20) (f310919 . -16) (f310918 . -12) (f310919 . -8))
# emit-expr (f310919 (car f310918))
# funcall
#    si   =-24
#    env  = ((f310918 . -20) (f310919 . -16) (f310918 . -12) (f310919 . -8))
#    expr = (funcall f310919 (car f310918))
# emit-expr f310919
# emit-variable-ref
# env=((f310918 . -20) (f310919 . -16) (f310918 . -12) (f310919 . -8))
# var=f310919
    movl -16(%esp), %eax  # stack load f310919
=======
# env=((f132 . -20) (f131 . -16) (f132 . -12) (f131 . -8))
# expr=(begin (begin (f131 (car f132)) ((primitive-ref for-each) f131 (cdr f132))))
# tail-begin (begin (begin (f131 (car f132)) ((primitive-ref for-each) f131 (cdr f132))))
#   env=((f132 . -20) (f131 . -16) (f132 . -12) (f131 . -8))
# emit-tail-expr
# si=-24
# env=((f132 . -20) (f131 . -16) (f132 . -12) (f131 . -8))
# expr=(begin (f131 (car f132)) ((primitive-ref for-each) f131 (cdr f132)))
# tail-begin (begin (f131 (car f132)) ((primitive-ref for-each) f131 (cdr f132)))
#   env=((f132 . -20) (f131 . -16) (f132 . -12) (f131 . -8))
# emit-expr (f131 (car f132))
# funcall
#    si   =-24
#    env  = ((f132 . -20) (f131 . -16) (f132 . -12) (f131 . -8))
#    expr = (funcall f131 (car f132))
# emit-expr f131
# emit-variable-ref
# env=((f132 . -20) (f131 . -16) (f132 . -12) (f131 . -8))
# var=f131
    movl -16(%esp), %eax  # stack load f131
>>>>>>> fix-implicit-begins
# end emit-variable-ref
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1003"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1003":
   movl %eax,  -32(%esp)  # stash funcall-oper in closure slot
<<<<<<< HEAD
# emit-expr (car f310918)
# emit-expr f310918
# emit-variable-ref
# env=((f310918 . -20) (f310919 . -16) (f310918 . -12) (f310919 . -8))
# var=f310918
    movl -20(%esp), %eax  # stack load f310918
=======
# emit-expr (car f132)
# emit-expr f132
# emit-variable-ref
# env=((f132 . -20) (f131 . -16) (f132 . -12) (f131 . -8))
# var=f132
    movl -20(%esp), %eax  # stack load f132
>>>>>>> fix-implicit-begins
# end emit-variable-ref
# check the argument is a pair
    movl %eax,%ebx
    and $7, %bl
    cmp $1, %bl
    je _L_1004
# invoke error handler eh_pair
    .extern mrc_eh$upair
    movl mrc_eh$upair, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $116,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1004:
    movl -1(%eax), %eax
<<<<<<< HEAD
    mov %eax, -36(%esp)  # arg (car f310918)
=======
    mov %eax, -36(%esp)  # arg (car f132)
>>>>>>> fix-implicit-begins
    movl -32(%esp), %edi   # load new closure to %edi
    add $-24, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $24, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
# emit-tail-expr
# si=-24
<<<<<<< HEAD
# env=((f310918 . -20) (f310919 . -16) (f310918 . -12) (f310919 . -8))
# expr=(begin ((primitive-ref for-each) f310919 (cdr f310918)))
# tail-begin (begin ((primitive-ref for-each) f310919 (cdr f310918)))
#   env=((f310918 . -20) (f310919 . -16) (f310918 . -12) (f310919 . -8))
# emit-tail-expr
# si=-24
# env=((f310918 . -20) (f310919 . -16) (f310918 . -12) (f310919 . -8))
# expr=((primitive-ref for-each) f310919 (cdr f310918))
# emit-tail-funcall
#    si   =-24
#    env  = ((f310918 . -20) (f310919 . -16) (f310918 . -12) (f310919 . -8))
#    expr = (funcall (primitive-ref for-each) f310919 (cdr f310918))
=======
# env=((f132 . -20) (f131 . -16) (f132 . -12) (f131 . -8))
# expr=(begin ((primitive-ref for-each) f131 (cdr f132)))
# tail-begin (begin ((primitive-ref for-each) f131 (cdr f132)))
#   env=((f132 . -20) (f131 . -16) (f132 . -12) (f131 . -8))
# emit-tail-expr
# si=-24
# env=((f132 . -20) (f131 . -16) (f132 . -12) (f131 . -8))
# expr=((primitive-ref for-each) f131 (cdr f132))
# emit-tail-funcall
#    si   =-24
#    env  = ((f132 . -20) (f131 . -16) (f132 . -12) (f131 . -8))
#    expr = (funcall (primitive-ref for-each) f131 (cdr f132))
>>>>>>> fix-implicit-begins
# emit-expr (primitive-ref for-each)
    .extern mrc_for$meach
    movl mrc_for$meach,%eax
   movl %eax,  -24(%esp)  # stash funcall-oper in next closure slot
<<<<<<< HEAD
# emit-expr f310919
# emit-variable-ref
# env=((f310918 . -20) (f310919 . -16) (f310918 . -12) (f310919 . -8))
# var=f310919
    movl -16(%esp), %eax  # stack load f310919
# end emit-variable-ref
    mov %eax, -28(%esp)    # arg f310919
# emit-expr (cdr f310918)
# emit-expr f310918
# emit-variable-ref
# env=((f310918 . -20) (f310919 . -16) (f310918 . -12) (f310919 . -8))
# var=f310918
    movl -20(%esp), %eax  # stack load f310918
=======
# emit-expr f131
# emit-variable-ref
# env=((f132 . -20) (f131 . -16) (f132 . -12) (f131 . -8))
# var=f131
    movl -16(%esp), %eax  # stack load f131
# end emit-variable-ref
    mov %eax, -28(%esp)    # arg f131
# emit-expr (cdr f132)
# emit-expr f132
# emit-variable-ref
# env=((f132 . -20) (f131 . -16) (f132 . -12) (f131 . -8))
# var=f132
    movl -20(%esp), %eax  # stack load f132
>>>>>>> fix-implicit-begins
# end emit-variable-ref
# check the argument is a pair
    movl %eax,%ebx
    and $7, %bl
    cmp $1, %bl
    je _L_1005
# invoke error handler eh_pair
    .extern mrc_eh$upair
    movl mrc_eh$upair, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $120,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1005:
    movl 3(%eax), %eax
<<<<<<< HEAD
    mov %eax, -32(%esp)    # arg (cdr f310918)
=======
    mov %eax, -32(%esp)    # arg (cdr f132)
>>>>>>> fix-implicit-begins
    movl -24(%esp), %edi   # load new closure to %edi
# emit-shift-args:  size=3   si=-24  delta=20
    mov -24(%esp), %ebx  # shift frame cell
    mov %ebx, -4(%esp)  # down to base
# emit-shift-args:  size=2   si=-28  delta=20
    mov -28(%esp), %ebx  # shift frame cell
    mov %ebx, -8(%esp)  # down to base
# emit-shift-args:  size=1   si=-32  delta=20
    mov -32(%esp), %ebx  # shift frame cell
    mov %ebx, -12(%esp)  # down to base
# emit-shift-args:  size=0   si=-36  delta=20
    movl $8,%eax   # save arg count
    jmp *-2(%edi)  # tail-funcall
     ret   # return thru stack
     ret   # return thru stack
    jmp _L_1002
_L_1001:
# emit-tail-expr
# si=-24
<<<<<<< HEAD
# env=((f310918 . -20) (f310919 . -16) (f310918 . -12) (f310919 . -8))
=======
# env=((f132 . -20) (f131 . -16) (f132 . -12) (f131 . -8))
>>>>>>> fix-implicit-begins
# expr=#f
    movl $47, %eax     # immed #f
    ret                  # immediate tail return
_L_1002:
    .align 4,0x90
_L_999:
     movl %eax, mrc_for$meach
# == explicit-begins  ==>
# (let ((p (make-vector 6)) (sz 1024)) (begin (vector-set! p 0 (quote output-port)) (vector-set! p 1 "/dev/stdout") (vector-set! p 2 1) (vector-set! p 3 (make-string sz)) (vector-set! p 4 0) (vector-set! p 5 sz) p))
# == eliminate-let*  ==>
# (let ((p (make-vector 6)) (sz 1024)) (begin (vector-set! p 0 (quote output-port)) (vector-set! p 1 "/dev/stdout") (vector-set! p 2 1) (vector-set! p 3 (make-string sz)) (vector-set! p 4 0) (vector-set! p 5 sz) p))
# == uniquify-variables  ==>
# (let ((f134 (make-vector 6)) (f133 1024)) (begin (vector-set! f134 0 (quote output-port)) (vector-set! f134 1 "/dev/stdout") (vector-set! f134 2 1) (vector-set! f134 3 (make-string f133)) (vector-set! f134 4 0) (vector-set! f134 5 f133) f134))
# == vectorize-letrec  ==>
# (let ((f134 (make-vector 6)) (f133 1024)) (begin (vector-set! f134 0 (quote output-port)) (vector-set! f134 1 "/dev/stdout") (vector-set! f134 2 1) (vector-set! f134 3 (make-string f133)) (vector-set! f134 4 0) (vector-set! f134 5 f133) f134))
# == eliminate-set!  ==>
# (let ((f134 (make-vector 6)) (f133 1024)) (begin (vector-set! f134 0 (quote output-port)) (vector-set! f134 1 "/dev/stdout") (vector-set! f134 2 1) (vector-set! f134 3 (make-string f133)) (vector-set! f134 4 0) (vector-set! f134 5 f133) f134))
# == close-free-variables  ==>
# (let ((f134 (make-vector 6)) (f133 1024)) (begin (vector-set! f134 0 (quote output-port)) (vector-set! f134 1 "/dev/stdout") (vector-set! f134 2 1) (vector-set! f134 3 (make-string f133)) (vector-set! f134 4 0) (vector-set! f134 5 f133) f134))
# == eliminate-quote  ==>
# (let ((f134 (make-vector 6)) (f133 1024)) (begin (vector-set! f134 0 (string->symbol "output-port")) (vector-set! f134 1 "/dev/stdout") (vector-set! f134 2 1) (vector-set! f134 3 (make-string f133)) (vector-set! f134 4 0) (vector-set! f134 5 f133) f134))
# == eliminate-when/unless  ==>
# (let ((f134 (make-vector 6)) (f133 1024)) (begin (vector-set! f134 0 (string->symbol "output-port")) (vector-set! f134 1 "/dev/stdout") (vector-set! f134 2 1) (vector-set! f134 3 (make-string f133)) (vector-set! f134 4 0) (vector-set! f134 5 f133) f134))
# == eliminate-cond  ==>
# (let ((f134 (make-vector 6)) (f133 1024)) (begin (vector-set! f134 0 (string->symbol "output-port")) (vector-set! f134 1 "/dev/stdout") (vector-set! f134 2 1) (vector-set! f134 3 (make-string f133)) (vector-set! f134 4 0) (vector-set! f134 5 f133) f134))
# == external-symbols  ==>
# (let ((f134 (make-vector 6)) (f133 1024)) (begin (vector-set! f134 0 ((primitive-ref string->symbol) "output-port")) (vector-set! f134 1 "/dev/stdout") (vector-set! f134 2 1) (vector-set! f134 3 (make-string f133)) (vector-set! f134 4 0) (vector-set! f134 5 f133) f134))
# emit-expr (let ((f134 (make-vector 6)) (f133 1024)) (begin (vector-set! f134 0 ((primitive-ref string->symbol) "output-port")) (vector-set! f134 1 "/dev/stdout") (vector-set! f134 2 1) (vector-set! f134 3 (make-string f133)) (vector-set! f134 4 0) (vector-set! f134 5 f133) f134))
# emit-let
#  si   = 0
#  env  = ()
#  bindings = ((f134 (make-vector 6)) (f133 1024))
#  body = (begin (vector-set! f134 0 ((primitive-ref string->symbol) "output-port")) (vector-set! f134 1 "/dev/stdout") (vector-set! f134 2 1) (vector-set! f134 3 (make-string f133)) (vector-set! f134 4 0) (vector-set! f134 5 f133) f134)
# emit-expr (make-vector 6)
# make-vector 6
# emit-expr 6
    movl $24, %eax     # immed 6
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1006"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1006:
# check the argument is a fixnum >= 0
    cmp $0,%eax
    jge _L_1007
# invoke error handler eh_length
    .extern mrc_eh$ulength
    movl mrc_eh$ulength, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1007:
    movl %eax, %esi
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    orl  $5, %eax
    addl $4, %esi
    addl $4, %esi
    andl $-8, %esi
    addl %esi, %ebp
    movl %eax, 0(%esp)  # stack save
# emit-expr 1024
    movl $4096, %eax     # immed 1024
    movl %eax, -4(%esp)  # stack save
# emit-expr (begin (vector-set! f134 0 ((primitive-ref string->symbol) "output-port")) (vector-set! f134 1 "/dev/stdout") (vector-set! f134 2 1) (vector-set! f134 3 (make-string f133)) (vector-set! f134 4 0) (vector-set! f134 5 f133) f134)
# emit-begin
#   expr=(begin (vector-set! f134 0 ((primitive-ref string->symbol) "output-port")) (vector-set! f134 1 "/dev/stdout") (vector-set! f134 2 1) (vector-set! f134 3 (make-string f133)) (vector-set! f134 4 0) (vector-set! f134 5 f133) f134)
#   env=((f133 . -4) (f134 . 0))
# emit-expr (vector-set! f134 0 ((primitive-ref string->symbol) "output-port"))
# emit-expr f134
# emit-variable-ref
# env=((f133 . -4) (f134 . 0))
# var=f134
    movl 0(%esp), %eax  # stack load f134
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1008
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1008:
    movl %eax, -8(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1009"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1009:
# check bounds on vector index
    movl -8(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1011
    cmp  $0,%eax
    jge _L_1010
_L_1011:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1010:
    movl %eax, -12(%esp)
# emit-expr ((primitive-ref string->symbol) "output-port")
# funcall
#    si   =-16
#    env  = ((f133 . -4) (f134 . 0))
#    expr = (funcall (primitive-ref string->symbol) "output-port")
# emit-expr (primitive-ref string->symbol)
    .extern mrc_string$m$gsymbol
    movl mrc_string$m$gsymbol,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1012"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1012":
   movl %eax,  -24(%esp)  # stash funcall-oper in closure slot
# emit-expr "output-port"
# string literal
    jmp _L_1014
    .align 8,0x90
_L_1013 :
    .int 44
    .ascii "output-port"
_L_1014:
    movl $_L_1013, %eax
    orl $6, %eax
    mov %eax, -28(%esp)  # arg output-port
    movl -24(%esp), %edi   # load new closure to %edi
    add $-16, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $16, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    movl -8(%esp), %ebx
    movl -12(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin (vector-set! f134 1 "/dev/stdout") (vector-set! f134 2 1) (vector-set! f134 3 (make-string f133)) (vector-set! f134 4 0) (vector-set! f134 5 f133) f134)
# emit-begin
#   expr=(begin (vector-set! f134 1 "/dev/stdout") (vector-set! f134 2 1) (vector-set! f134 3 (make-string f133)) (vector-set! f134 4 0) (vector-set! f134 5 f133) f134)
#   env=((f133 . -4) (f134 . 0))
# emit-expr (vector-set! f134 1 "/dev/stdout")
# emit-expr f134
# emit-variable-ref
# env=((f133 . -4) (f134 . 0))
# var=f134
    movl 0(%esp), %eax  # stack load f134
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1015
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1015:
    movl %eax, -8(%esp)
# emit-expr 1
    movl $4, %eax     # immed 1
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1016"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1016:
# check bounds on vector index
    movl -8(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1018
    cmp  $0,%eax
    jge _L_1017
_L_1018:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1017:
    movl %eax, -12(%esp)
# emit-expr "/dev/stdout"
# string literal
    jmp _L_1020
    .align 8,0x90
_L_1019 :
    .int 44
    .ascii "/dev/stdout"
_L_1020:
    movl $_L_1019, %eax
    orl $6, %eax
    movl -8(%esp), %ebx
    movl -12(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin (vector-set! f134 2 1) (vector-set! f134 3 (make-string f133)) (vector-set! f134 4 0) (vector-set! f134 5 f133) f134)
# emit-begin
#   expr=(begin (vector-set! f134 2 1) (vector-set! f134 3 (make-string f133)) (vector-set! f134 4 0) (vector-set! f134 5 f133) f134)
#   env=((f133 . -4) (f134 . 0))
# emit-expr (vector-set! f134 2 1)
# emit-expr f134
# emit-variable-ref
# env=((f133 . -4) (f134 . 0))
# var=f134
    movl 0(%esp), %eax  # stack load f134
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1021
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1021:
    movl %eax, -8(%esp)
# emit-expr 2
    movl $8, %eax     # immed 2
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1022"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1022:
# check bounds on vector index
    movl -8(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1024
    cmp  $0,%eax
    jge _L_1023
_L_1024:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1023:
    movl %eax, -12(%esp)
# emit-expr 1
    movl $4, %eax     # immed 1
    movl -8(%esp), %ebx
    movl -12(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin (vector-set! f134 3 (make-string f133)) (vector-set! f134 4 0) (vector-set! f134 5 f133) f134)
# emit-begin
#   expr=(begin (vector-set! f134 3 (make-string f133)) (vector-set! f134 4 0) (vector-set! f134 5 f133) f134)
#   env=((f133 . -4) (f134 . 0))
# emit-expr (vector-set! f134 3 (make-string f133))
# emit-expr f134
# emit-variable-ref
# env=((f133 . -4) (f134 . 0))
# var=f134
    movl 0(%esp), %eax  # stack load f134
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1025
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1025:
    movl %eax, -8(%esp)
# emit-expr 3
    movl $12, %eax     # immed 3
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1026"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1026:
# check bounds on vector index
    movl -8(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1028
    cmp  $0,%eax
    jge _L_1027
_L_1028:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1027:
    movl %eax, -12(%esp)
# emit-expr (make-string f133)
# make-string len=f133
# emit-expr f133
# emit-variable-ref
# env=((f133 . -4) (f134 . 0))
# var=f133
    movl -4(%esp), %eax  # stack load f133
# end emit-variable-ref
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1029"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $152,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1029:
# check the argument is a fixnum >= 0
    cmp $0,%eax
    jge _L_1030
# invoke error handler eh_length
    .extern mrc_eh$ulength
    movl mrc_eh$ulength, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $152,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1030:
    movl %eax, %esi
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    orl $6, %eax
    sar $2, %esi
    add $4, %esi
    add $7, %esi
    andl $-8, %esi
    add  %esi, %ebp
# make-string end
    movl -8(%esp), %ebx
    movl -12(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin (vector-set! f134 4 0) (vector-set! f134 5 f133) f134)
# emit-begin
#   expr=(begin (vector-set! f134 4 0) (vector-set! f134 5 f133) f134)
#   env=((f133 . -4) (f134 . 0))
# emit-expr (vector-set! f134 4 0)
# emit-expr f134
# emit-variable-ref
# env=((f133 . -4) (f134 . 0))
# var=f134
    movl 0(%esp), %eax  # stack load f134
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1031
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1031:
    movl %eax, -8(%esp)
# emit-expr 4
    movl $16, %eax     # immed 4
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1032"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1032:
# check bounds on vector index
    movl -8(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1034
    cmp  $0,%eax
    jge _L_1033
_L_1034:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1033:
    movl %eax, -12(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
    movl -8(%esp), %ebx
    movl -12(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin (vector-set! f134 5 f133) f134)
# emit-begin
#   expr=(begin (vector-set! f134 5 f133) f134)
#   env=((f133 . -4) (f134 . 0))
# emit-expr (vector-set! f134 5 f133)
# emit-expr f134
# emit-variable-ref
# env=((f133 . -4) (f134 . 0))
# var=f134
    movl 0(%esp), %eax  # stack load f134
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1035
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1035:
    movl %eax, -8(%esp)
# emit-expr 5
    movl $20, %eax     # immed 5
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1036"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1036:
# check bounds on vector index
    movl -8(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1038
    cmp  $0,%eax
    jge _L_1037
_L_1038:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1037:
    movl %eax, -12(%esp)
# emit-expr f133
# emit-variable-ref
# env=((f133 . -4) (f134 . 0))
# var=f133
    movl -4(%esp), %eax  # stack load f133
# end emit-variable-ref
    movl -8(%esp), %ebx
    movl -12(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin f134)
# emit-begin
#   expr=(begin f134)
#   env=((f133 . -4) (f134 . 0))
# emit-expr f134
# emit-variable-ref
# env=((f133 . -4) (f134 . 0))
# var=f134
    movl 0(%esp), %eax  # stack load f134
# end emit-variable-ref
# emit-expr (begin)
# emit-begin
#   expr=(begin)
#   env=((f133 . -4) (f134 . 0))
     movl %eax, mrc_standard$mout
# == explicit-begins  ==>
# (let ((current-out standard-out)) (lambda () current-out))
# == eliminate-let*  ==>
# (let ((current-out standard-out)) (lambda () current-out))
# == uniquify-variables  ==>
# (let ((f135 standard-out)) (lambda () f135))
# == vectorize-letrec  ==>
# (let ((f135 standard-out)) (lambda () f135))
# == eliminate-set!  ==>
# (let ((f135 standard-out)) (lambda () (let () f135)))
# == close-free-variables  ==>
# (let ((f135 standard-out)) (closure () (f135) (let () f135)))
# == eliminate-quote  ==>
# (let ((f135 standard-out)) (closure () (f135) (let () f135)))
# == eliminate-when/unless  ==>
# (let ((f135 standard-out)) (closure () (f135) (let () f135)))
# == eliminate-cond  ==>
# (let ((f135 standard-out)) (closure () (f135) (let () f135)))
# == external-symbols  ==>
# (let ((f135 (primitive-ref standard-out))) (closure () (f135) (let () f135)))
# emit-expr (let ((f135 (primitive-ref standard-out))) (closure () (f135) (let () f135)))
# emit-let
#  si   = 0
#  env  = ()
#  bindings = ((f135 (primitive-ref standard-out)))
#  body = (closure () (f135) (let () f135))
# emit-expr (primitive-ref standard-out)
    .extern mrc_standard$mout
    movl mrc_standard$mout,%eax
    movl %eax, 0(%esp)  # stack save
# emit-expr (closure () (f135) (let () f135))
# emit-closure
# si = -4
# env = ((f135 . 0))
# expr = (closure () (f135) (let () f135))
    movl $_L_1039, 0(%ebp)  # closure label
# emit-variable-ref
# env=((f135 . 0))
# var=f135
    movl 0(%esp), %eax  # stack load f135
# end emit-variable-ref
   movl  %eax, 4(%ebp)  # f135
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $8, %ebp     # bump ebp
    jmp _L_1040            # jump around closure body
_L_1039:
# check argument count
    cmp $0,%eax
    je _L_1041
# invoke error handler eh_argcount
    .extern mrc_eh$uargcount
    movl mrc_eh$uargcount, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_1041:
# emit-tail-expr
# si=-8
# env=((f135 . 4) (f135 . 0))
# expr=(let () f135)
# emit-tail-let
#  si   = -8
#  env  = ((f135 . 4) (f135 . 0))
#  bindings = ()
#  body = f135
# emit-tail-expr
# si=-8
# env=((f135 . 4) (f135 . 0))
# expr=f135
# emit-tail-variable-ref
# emit-variable-ref
# env=((f135 . 4) (f135 . 0))
# var=f135
    movl 2(%edi), %eax  # frame load f135
# end emit-variable-ref
    ret
# end emit-tail-variable ref
    .align 4,0x90
_L_1040:
     movl %eax, mrc_current$moutput$mport
# == explicit-begins  ==>
# (let ((current-in standard-in)) (lambda () current-in))
# == eliminate-let*  ==>
# (let ((current-in standard-in)) (lambda () current-in))
# == uniquify-variables  ==>
# (let ((f136 standard-in)) (lambda () f136))
# == vectorize-letrec  ==>
# (let ((f136 standard-in)) (lambda () f136))
# == eliminate-set!  ==>
# (let ((f136 standard-in)) (lambda () (let () f136)))
# == close-free-variables  ==>
# (let ((f136 standard-in)) (closure () (f136) (let () f136)))
# == eliminate-quote  ==>
# (let ((f136 standard-in)) (closure () (f136) (let () f136)))
# == eliminate-when/unless  ==>
# (let ((f136 standard-in)) (closure () (f136) (let () f136)))
# == eliminate-cond  ==>
# (let ((f136 standard-in)) (closure () (f136) (let () f136)))
# == external-symbols  ==>
# (let ((f136 (primitive-ref standard-in))) (closure () (f136) (let () f136)))
# emit-expr (let ((f136 (primitive-ref standard-in))) (closure () (f136) (let () f136)))
# emit-let
#  si   = 0
#  env  = ()
#  bindings = ((f136 (primitive-ref standard-in)))
#  body = (closure () (f136) (let () f136))
# emit-expr (primitive-ref standard-in)
    .extern mrc_standard$min
    movl mrc_standard$min,%eax
    movl %eax, 0(%esp)  # stack save
# emit-expr (closure () (f136) (let () f136))
# emit-closure
# si = -4
# env = ((f136 . 0))
# expr = (closure () (f136) (let () f136))
    movl $_L_1042, 0(%ebp)  # closure label
# emit-variable-ref
# env=((f136 . 0))
# var=f136
    movl 0(%esp), %eax  # stack load f136
# end emit-variable-ref
   movl  %eax, 4(%ebp)  # f136
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $8, %ebp     # bump ebp
    jmp _L_1043            # jump around closure body
_L_1042:
# check argument count
    cmp $0,%eax
    je _L_1044
# invoke error handler eh_argcount
    .extern mrc_eh$uargcount
    movl mrc_eh$uargcount, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_1044:
# emit-tail-expr
# si=-8
# env=((f136 . 4) (f136 . 0))
# expr=(let () f136)
# emit-tail-let
#  si   = -8
#  env  = ((f136 . 4) (f136 . 0))
#  bindings = ()
#  body = f136
# emit-tail-expr
# si=-8
# env=((f136 . 4) (f136 . 0))
# expr=f136
# emit-tail-variable-ref
# emit-variable-ref
# env=((f136 . 4) (f136 . 0))
# var=f136
    movl 2(%edi), %eax  # frame load f136
# end emit-variable-ref
    ret
# end emit-tail-variable ref
    .align 4,0x90
_L_1043:
     movl %eax, mrc_current$minput$mport
# == explicit-begins  ==>
# (lambda (p) (vector-ref p 0))
# == eliminate-let*  ==>
# (lambda (p) (vector-ref p 0))
# == uniquify-variables  ==>
# (lambda (f137) (vector-ref f137 0))
# == vectorize-letrec  ==>
# (lambda (f137) (vector-ref f137 0))
# == eliminate-set!  ==>
# (lambda (f137) (let ((f137 f137)) (vector-ref f137 0)))
# == close-free-variables  ==>
# (closure (f137) () (let ((f137 f137)) (vector-ref f137 0)))
# == eliminate-quote  ==>
# (closure (f137) () (let ((f137 f137)) (vector-ref f137 0)))
# == eliminate-when/unless  ==>
# (closure (f137) () (let ((f137 f137)) (vector-ref f137 0)))
# == eliminate-cond  ==>
# (closure (f137) () (let ((f137 f137)) (vector-ref f137 0)))
# == external-symbols  ==>
# (closure (f137) () (let ((f137 f137)) (vector-ref f137 0)))
# emit-expr (closure (f137) () (let ((f137 f137)) (vector-ref f137 0)))
# emit-closure
# si = 0
# env = ()
# expr = (closure (f137) () (let ((f137 f137)) (vector-ref f137 0)))
    movl $_L_1045, 0(%ebp)  # closure label
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $8, %ebp     # bump ebp
    jmp _L_1046            # jump around closure body
_L_1045:
# check argument count
    cmp $4,%eax
    je _L_1047
# invoke error handler eh_argcount
    .extern mrc_eh$uargcount
    movl mrc_eh$uargcount, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_1047:
# emit-tail-expr
# si=-12
# env=((f137 . -8))
# expr=(let ((f137 f137)) (vector-ref f137 0))
# emit-tail-let
#  si   = -12
#  env  = ((f137 . -8))
#  bindings = ((f137 f137))
#  body = (vector-ref f137 0)
# emit-expr f137
# emit-variable-ref
# env=((f137 . -8))
# var=f137
    movl -8(%esp), %eax  # stack load f137
# end emit-variable-ref
    movl %eax, -12(%esp)  # stack save
# emit-tail-expr
# si=-16
# env=((f137 . -12) (f137 . -8))
# expr=(vector-ref f137 0)
# tail primcall
# emit-expr f137
# emit-variable-ref
# env=((f137 . -12) (f137 . -8))
# var=f137
    movl -12(%esp), %eax  # stack load f137
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1048
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1048:
    movl %eax, -16(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1049"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1049:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1051
    cmp  $0,%eax
    jge _L_1050
_L_1051:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1050:
    movl -16(%esp), %esi
    movl -1(%eax,%esi), %eax
#return from tail (vector-ref f137 0)
    ret
    .align 4,0x90
_L_1046:
     movl %eax, mrc_port$mkind
# == explicit-begins  ==>
# (lambda (p) (vector-ref p 1))
# == eliminate-let*  ==>
# (lambda (p) (vector-ref p 1))
# == uniquify-variables  ==>
# (lambda (f138) (vector-ref f138 1))
# == vectorize-letrec  ==>
# (lambda (f138) (vector-ref f138 1))
# == eliminate-set!  ==>
# (lambda (f138) (let ((f138 f138)) (vector-ref f138 1)))
# == close-free-variables  ==>
# (closure (f138) () (let ((f138 f138)) (vector-ref f138 1)))
# == eliminate-quote  ==>
# (closure (f138) () (let ((f138 f138)) (vector-ref f138 1)))
# == eliminate-when/unless  ==>
# (closure (f138) () (let ((f138 f138)) (vector-ref f138 1)))
# == eliminate-cond  ==>
# (closure (f138) () (let ((f138 f138)) (vector-ref f138 1)))
# == external-symbols  ==>
# (closure (f138) () (let ((f138 f138)) (vector-ref f138 1)))
# emit-expr (closure (f138) () (let ((f138 f138)) (vector-ref f138 1)))
# emit-closure
# si = 0
# env = ()
# expr = (closure (f138) () (let ((f138 f138)) (vector-ref f138 1)))
    movl $_L_1052, 0(%ebp)  # closure label
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $8, %ebp     # bump ebp
    jmp _L_1053            # jump around closure body
_L_1052:
# check argument count
    cmp $4,%eax
    je _L_1054
# invoke error handler eh_argcount
    .extern mrc_eh$uargcount
    movl mrc_eh$uargcount, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_1054:
# emit-tail-expr
# si=-12
# env=((f138 . -8))
# expr=(let ((f138 f138)) (vector-ref f138 1))
# emit-tail-let
#  si   = -12
#  env  = ((f138 . -8))
#  bindings = ((f138 f138))
#  body = (vector-ref f138 1)
# emit-expr f138
# emit-variable-ref
# env=((f138 . -8))
# var=f138
    movl -8(%esp), %eax  # stack load f138
# end emit-variable-ref
    movl %eax, -12(%esp)  # stack save
# emit-tail-expr
# si=-16
# env=((f138 . -12) (f138 . -8))
# expr=(vector-ref f138 1)
# tail primcall
# emit-expr f138
# emit-variable-ref
# env=((f138 . -12) (f138 . -8))
# var=f138
    movl -12(%esp), %eax  # stack load f138
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1055
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1055:
    movl %eax, -16(%esp)
# emit-expr 1
    movl $4, %eax     # immed 1
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1056"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1056:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1058
    cmp  $0,%eax
    jge _L_1057
_L_1058:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1057:
    movl -16(%esp), %esi
    movl -1(%eax,%esi), %eax
#return from tail (vector-ref f138 1)
    ret
    .align 4,0x90
_L_1053:
     movl %eax, mrc_port$mpath
# == explicit-begins  ==>
# (lambda (p) (vector-ref p 2))
# == eliminate-let*  ==>
# (lambda (p) (vector-ref p 2))
# == uniquify-variables  ==>
# (lambda (f139) (vector-ref f139 2))
# == vectorize-letrec  ==>
# (lambda (f139) (vector-ref f139 2))
# == eliminate-set!  ==>
# (lambda (f139) (let ((f139 f139)) (vector-ref f139 2)))
# == close-free-variables  ==>
# (closure (f139) () (let ((f139 f139)) (vector-ref f139 2)))
# == eliminate-quote  ==>
# (closure (f139) () (let ((f139 f139)) (vector-ref f139 2)))
# == eliminate-when/unless  ==>
# (closure (f139) () (let ((f139 f139)) (vector-ref f139 2)))
# == eliminate-cond  ==>
# (closure (f139) () (let ((f139 f139)) (vector-ref f139 2)))
# == external-symbols  ==>
# (closure (f139) () (let ((f139 f139)) (vector-ref f139 2)))
# emit-expr (closure (f139) () (let ((f139 f139)) (vector-ref f139 2)))
# emit-closure
# si = 0
# env = ()
# expr = (closure (f139) () (let ((f139 f139)) (vector-ref f139 2)))
    movl $_L_1059, 0(%ebp)  # closure label
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $8, %ebp     # bump ebp
    jmp _L_1060            # jump around closure body
_L_1059:
# check argument count
    cmp $4,%eax
    je _L_1061
# invoke error handler eh_argcount
    .extern mrc_eh$uargcount
    movl mrc_eh$uargcount, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_1061:
# emit-tail-expr
# si=-12
# env=((f139 . -8))
# expr=(let ((f139 f139)) (vector-ref f139 2))
# emit-tail-let
#  si   = -12
#  env  = ((f139 . -8))
#  bindings = ((f139 f139))
#  body = (vector-ref f139 2)
# emit-expr f139
# emit-variable-ref
# env=((f139 . -8))
# var=f139
    movl -8(%esp), %eax  # stack load f139
# end emit-variable-ref
    movl %eax, -12(%esp)  # stack save
# emit-tail-expr
# si=-16
# env=((f139 . -12) (f139 . -8))
# expr=(vector-ref f139 2)
# tail primcall
# emit-expr f139
# emit-variable-ref
# env=((f139 . -12) (f139 . -8))
# var=f139
    movl -12(%esp), %eax  # stack load f139
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1062
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1062:
    movl %eax, -16(%esp)
# emit-expr 2
    movl $8, %eax     # immed 2
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1063"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1063:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1065
    cmp  $0,%eax
    jge _L_1064
_L_1065:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1064:
    movl -16(%esp), %esi
    movl -1(%eax,%esi), %eax
#return from tail (vector-ref f139 2)
    ret
    .align 4,0x90
_L_1060:
     movl %eax, mrc_port$mfd
# == explicit-begins  ==>
# (lambda (p) (vector-ref p 3))
# == eliminate-let*  ==>
# (lambda (p) (vector-ref p 3))
# == uniquify-variables  ==>
# (lambda (f140) (vector-ref f140 3))
# == vectorize-letrec  ==>
# (lambda (f140) (vector-ref f140 3))
# == eliminate-set!  ==>
# (lambda (f140) (let ((f140 f140)) (vector-ref f140 3)))
# == close-free-variables  ==>
# (closure (f140) () (let ((f140 f140)) (vector-ref f140 3)))
# == eliminate-quote  ==>
# (closure (f140) () (let ((f140 f140)) (vector-ref f140 3)))
# == eliminate-when/unless  ==>
# (closure (f140) () (let ((f140 f140)) (vector-ref f140 3)))
# == eliminate-cond  ==>
# (closure (f140) () (let ((f140 f140)) (vector-ref f140 3)))
# == external-symbols  ==>
# (closure (f140) () (let ((f140 f140)) (vector-ref f140 3)))
# emit-expr (closure (f140) () (let ((f140 f140)) (vector-ref f140 3)))
# emit-closure
# si = 0
# env = ()
# expr = (closure (f140) () (let ((f140 f140)) (vector-ref f140 3)))
    movl $_L_1066, 0(%ebp)  # closure label
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $8, %ebp     # bump ebp
    jmp _L_1067            # jump around closure body
_L_1066:
# check argument count
    cmp $4,%eax
    je _L_1068
# invoke error handler eh_argcount
    .extern mrc_eh$uargcount
    movl mrc_eh$uargcount, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_1068:
# emit-tail-expr
# si=-12
# env=((f140 . -8))
# expr=(let ((f140 f140)) (vector-ref f140 3))
# emit-tail-let
#  si   = -12
#  env  = ((f140 . -8))
#  bindings = ((f140 f140))
#  body = (vector-ref f140 3)
# emit-expr f140
# emit-variable-ref
# env=((f140 . -8))
# var=f140
    movl -8(%esp), %eax  # stack load f140
# end emit-variable-ref
    movl %eax, -12(%esp)  # stack save
# emit-tail-expr
# si=-16
# env=((f140 . -12) (f140 . -8))
# expr=(vector-ref f140 3)
# tail primcall
# emit-expr f140
# emit-variable-ref
# env=((f140 . -12) (f140 . -8))
# var=f140
    movl -12(%esp), %eax  # stack load f140
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1069
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1069:
    movl %eax, -16(%esp)
# emit-expr 3
    movl $12, %eax     # immed 3
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1070"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1070:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1072
    cmp  $0,%eax
    jge _L_1071
_L_1072:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1071:
    movl -16(%esp), %esi
    movl -1(%eax,%esi), %eax
#return from tail (vector-ref f140 3)
    ret
    .align 4,0x90
_L_1067:
     movl %eax, mrc_port$mbuf
# == explicit-begins  ==>
# (lambda (p) (vector-ref p 4))
# == eliminate-let*  ==>
# (lambda (p) (vector-ref p 4))
# == uniquify-variables  ==>
# (lambda (f141) (vector-ref f141 4))
# == vectorize-letrec  ==>
# (lambda (f141) (vector-ref f141 4))
# == eliminate-set!  ==>
# (lambda (f141) (let ((f141 f141)) (vector-ref f141 4)))
# == close-free-variables  ==>
# (closure (f141) () (let ((f141 f141)) (vector-ref f141 4)))
# == eliminate-quote  ==>
# (closure (f141) () (let ((f141 f141)) (vector-ref f141 4)))
# == eliminate-when/unless  ==>
# (closure (f141) () (let ((f141 f141)) (vector-ref f141 4)))
# == eliminate-cond  ==>
# (closure (f141) () (let ((f141 f141)) (vector-ref f141 4)))
# == external-symbols  ==>
# (closure (f141) () (let ((f141 f141)) (vector-ref f141 4)))
# emit-expr (closure (f141) () (let ((f141 f141)) (vector-ref f141 4)))
# emit-closure
# si = 0
# env = ()
# expr = (closure (f141) () (let ((f141 f141)) (vector-ref f141 4)))
    movl $_L_1073, 0(%ebp)  # closure label
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $8, %ebp     # bump ebp
    jmp _L_1074            # jump around closure body
_L_1073:
# check argument count
    cmp $4,%eax
    je _L_1075
# invoke error handler eh_argcount
    .extern mrc_eh$uargcount
    movl mrc_eh$uargcount, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_1075:
# emit-tail-expr
# si=-12
# env=((f141 . -8))
# expr=(let ((f141 f141)) (vector-ref f141 4))
# emit-tail-let
#  si   = -12
#  env  = ((f141 . -8))
#  bindings = ((f141 f141))
#  body = (vector-ref f141 4)
# emit-expr f141
# emit-variable-ref
# env=((f141 . -8))
# var=f141
    movl -8(%esp), %eax  # stack load f141
# end emit-variable-ref
    movl %eax, -12(%esp)  # stack save
# emit-tail-expr
# si=-16
# env=((f141 . -12) (f141 . -8))
# expr=(vector-ref f141 4)
# tail primcall
# emit-expr f141
# emit-variable-ref
# env=((f141 . -12) (f141 . -8))
# var=f141
    movl -12(%esp), %eax  # stack load f141
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1076
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1076:
    movl %eax, -16(%esp)
# emit-expr 4
    movl $16, %eax     # immed 4
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1077"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1077:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1079
    cmp  $0,%eax
    jge _L_1078
_L_1079:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1078:
    movl -16(%esp), %esi
    movl -1(%eax,%esi), %eax
#return from tail (vector-ref f141 4)
    ret
    .align 4,0x90
_L_1074:
     movl %eax, mrc_port$mndx
# == explicit-begins  ==>
# (lambda (p) (vector-set! p 4 (fxadd1 (vector-ref p 4))))
# == eliminate-let*  ==>
# (lambda (p) (vector-set! p 4 (fxadd1 (vector-ref p 4))))
# == uniquify-variables  ==>
# (lambda (f142) (vector-set! f142 4 (fxadd1 (vector-ref f142 4))))
# == vectorize-letrec  ==>
# (lambda (f142) (vector-set! f142 4 (fxadd1 (vector-ref f142 4))))
# == eliminate-set!  ==>
# (lambda (f142) (let ((f142 f142)) (vector-set! f142 4 (fxadd1 (vector-ref f142 4)))))
# == close-free-variables  ==>
# (closure (f142) () (let ((f142 f142)) (vector-set! f142 4 (fxadd1 (vector-ref f142 4)))))
# == eliminate-quote  ==>
# (closure (f142) () (let ((f142 f142)) (vector-set! f142 4 (fxadd1 (vector-ref f142 4)))))
# == eliminate-when/unless  ==>
# (closure (f142) () (let ((f142 f142)) (vector-set! f142 4 (fxadd1 (vector-ref f142 4)))))
# == eliminate-cond  ==>
# (closure (f142) () (let ((f142 f142)) (vector-set! f142 4 (fxadd1 (vector-ref f142 4)))))
# == external-symbols  ==>
# (closure (f142) () (let ((f142 f142)) (vector-set! f142 4 (fxadd1 (vector-ref f142 4)))))
# emit-expr (closure (f142) () (let ((f142 f142)) (vector-set! f142 4 (fxadd1 (vector-ref f142 4)))))
# emit-closure
# si = 0
# env = ()
# expr = (closure (f142) () (let ((f142 f142)) (vector-set! f142 4 (fxadd1 (vector-ref f142 4)))))
    movl $_L_1080, 0(%ebp)  # closure label
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $8, %ebp     # bump ebp
    jmp _L_1081            # jump around closure body
_L_1080:
# check argument count
    cmp $4,%eax
    je _L_1082
# invoke error handler eh_argcount
    .extern mrc_eh$uargcount
    movl mrc_eh$uargcount, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_1082:
# emit-tail-expr
# si=-12
# env=((f142 . -8))
# expr=(let ((f142 f142)) (vector-set! f142 4 (fxadd1 (vector-ref f142 4))))
# emit-tail-let
#  si   = -12
#  env  = ((f142 . -8))
#  bindings = ((f142 f142))
#  body = (vector-set! f142 4 (fxadd1 (vector-ref f142 4)))
# emit-expr f142
# emit-variable-ref
# env=((f142 . -8))
# var=f142
    movl -8(%esp), %eax  # stack load f142
# end emit-variable-ref
    movl %eax, -12(%esp)  # stack save
# emit-tail-expr
# si=-16
# env=((f142 . -12) (f142 . -8))
# expr=(vector-set! f142 4 (fxadd1 (vector-ref f142 4)))
# tail primcall
# emit-expr f142
# emit-variable-ref
# env=((f142 . -12) (f142 . -8))
# var=f142
    movl -12(%esp), %eax  # stack load f142
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1083
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1083:
    movl %eax, -16(%esp)
# emit-expr 4
    movl $16, %eax     # immed 4
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1084"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1084:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1086
    cmp  $0,%eax
    jge _L_1085
_L_1086:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1085:
    movl %eax, -20(%esp)
# emit-expr (fxadd1 (vector-ref f142 4))
# emit-expr (vector-ref f142 4)
# emit-expr f142
# emit-variable-ref
# env=((f142 . -12) (f142 . -8))
# var=f142
    movl -12(%esp), %eax  # stack load f142
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1087
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1087:
    movl %eax, -24(%esp)
# emit-expr 4
    movl $16, %eax     # immed 4
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1088"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1088:
# check bounds on vector index
    movl -24(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1090
    cmp  $0,%eax
    jge _L_1089
_L_1090:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1089:
    movl -24(%esp), %esi
    movl -1(%eax,%esi), %eax
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1091"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $56,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1091:
     addl $4, %eax
    movl -16(%esp), %ebx
    movl -20(%esp), %esi
    movl %eax, -1(%ebx,%esi)
#return from tail (vector-set! f142 4 (fxadd1 (vector-ref f142 4)))
    ret
    .align 4,0x90
_L_1081:
     movl %eax, mrc_port$mndx$madd1
# == explicit-begins  ==>
# (lambda (p) (vector-set! p 4 0))
# == eliminate-let*  ==>
# (lambda (p) (vector-set! p 4 0))
# == uniquify-variables  ==>
# (lambda (f143) (vector-set! f143 4 0))
# == vectorize-letrec  ==>
# (lambda (f143) (vector-set! f143 4 0))
# == eliminate-set!  ==>
# (lambda (f143) (let ((f143 f143)) (vector-set! f143 4 0)))
# == close-free-variables  ==>
# (closure (f143) () (let ((f143 f143)) (vector-set! f143 4 0)))
# == eliminate-quote  ==>
# (closure (f143) () (let ((f143 f143)) (vector-set! f143 4 0)))
# == eliminate-when/unless  ==>
# (closure (f143) () (let ((f143 f143)) (vector-set! f143 4 0)))
# == eliminate-cond  ==>
# (closure (f143) () (let ((f143 f143)) (vector-set! f143 4 0)))
# == external-symbols  ==>
# (closure (f143) () (let ((f143 f143)) (vector-set! f143 4 0)))
# emit-expr (closure (f143) () (let ((f143 f143)) (vector-set! f143 4 0)))
# emit-closure
# si = 0
# env = ()
# expr = (closure (f143) () (let ((f143 f143)) (vector-set! f143 4 0)))
    movl $_L_1092, 0(%ebp)  # closure label
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $8, %ebp     # bump ebp
    jmp _L_1093            # jump around closure body
_L_1092:
# check argument count
    cmp $4,%eax
    je _L_1094
# invoke error handler eh_argcount
    .extern mrc_eh$uargcount
    movl mrc_eh$uargcount, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_1094:
# emit-tail-expr
# si=-12
# env=((f143 . -8))
# expr=(let ((f143 f143)) (vector-set! f143 4 0))
# emit-tail-let
#  si   = -12
#  env  = ((f143 . -8))
#  bindings = ((f143 f143))
#  body = (vector-set! f143 4 0)
# emit-expr f143
# emit-variable-ref
# env=((f143 . -8))
# var=f143
    movl -8(%esp), %eax  # stack load f143
# end emit-variable-ref
    movl %eax, -12(%esp)  # stack save
# emit-tail-expr
# si=-16
# env=((f143 . -12) (f143 . -8))
# expr=(vector-set! f143 4 0)
# tail primcall
# emit-expr f143
# emit-variable-ref
# env=((f143 . -12) (f143 . -8))
# var=f143
    movl -12(%esp), %eax  # stack load f143
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1095
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1095:
    movl %eax, -16(%esp)
# emit-expr 4
    movl $16, %eax     # immed 4
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1096"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1096:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1098
    cmp  $0,%eax
    jge _L_1097
_L_1098:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1097:
    movl %eax, -20(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
    movl -16(%esp), %ebx
    movl -20(%esp), %esi
    movl %eax, -1(%ebx,%esi)
#return from tail (vector-set! f143 4 0)
    ret
    .align 4,0x90
_L_1093:
     movl %eax, mrc_port$mndx$mreset
# == explicit-begins  ==>
# (lambda (p) (vector-ref p 5))
# == eliminate-let*  ==>
# (lambda (p) (vector-ref p 5))
# == uniquify-variables  ==>
# (lambda (f144) (vector-ref f144 5))
# == vectorize-letrec  ==>
# (lambda (f144) (vector-ref f144 5))
# == eliminate-set!  ==>
# (lambda (f144) (let ((f144 f144)) (vector-ref f144 5)))
# == close-free-variables  ==>
# (closure (f144) () (let ((f144 f144)) (vector-ref f144 5)))
# == eliminate-quote  ==>
# (closure (f144) () (let ((f144 f144)) (vector-ref f144 5)))
# == eliminate-when/unless  ==>
# (closure (f144) () (let ((f144 f144)) (vector-ref f144 5)))
# == eliminate-cond  ==>
# (closure (f144) () (let ((f144 f144)) (vector-ref f144 5)))
# == external-symbols  ==>
# (closure (f144) () (let ((f144 f144)) (vector-ref f144 5)))
# emit-expr (closure (f144) () (let ((f144 f144)) (vector-ref f144 5)))
# emit-closure
# si = 0
# env = ()
# expr = (closure (f144) () (let ((f144 f144)) (vector-ref f144 5)))
    movl $_L_1099, 0(%ebp)  # closure label
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $8, %ebp     # bump ebp
    jmp _L_1100            # jump around closure body
_L_1099:
# check argument count
    cmp $4,%eax
    je _L_1101
# invoke error handler eh_argcount
    .extern mrc_eh$uargcount
    movl mrc_eh$uargcount, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_1101:
# emit-tail-expr
# si=-12
# env=((f144 . -8))
# expr=(let ((f144 f144)) (vector-ref f144 5))
# emit-tail-let
#  si   = -12
#  env  = ((f144 . -8))
#  bindings = ((f144 f144))
#  body = (vector-ref f144 5)
# emit-expr f144
# emit-variable-ref
# env=((f144 . -8))
# var=f144
    movl -8(%esp), %eax  # stack load f144
# end emit-variable-ref
    movl %eax, -12(%esp)  # stack save
# emit-tail-expr
# si=-16
# env=((f144 . -12) (f144 . -8))
# expr=(vector-ref f144 5)
# tail primcall
# emit-expr f144
# emit-variable-ref
# env=((f144 . -12) (f144 . -8))
# var=f144
    movl -12(%esp), %eax  # stack load f144
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1102
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1102:
    movl %eax, -16(%esp)
# emit-expr 5
    movl $20, %eax     # immed 5
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1103"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1103:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1105
    cmp  $0,%eax
    jge _L_1104
_L_1105:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1104:
    movl -16(%esp), %esi
    movl -1(%eax,%esi), %eax
#return from tail (vector-ref f144 5)
    ret
    .align 4,0x90
_L_1100:
     movl %eax, mrc_port$msize
# == explicit-begins  ==>
# (lambda (ch . args) (let ((p (if (null? args) (current-output-port) (car args)))) (begin (when (fx= (port-ndx p) (port-size p)) (flush-output-port p)) (string-set! (port-buf p) (port-ndx p) ch) (port-ndx-add1 p))))
# == eliminate-let*  ==>
# (lambda (ch . args) (let ((p (if (null? args) (current-output-port) (car args)))) (begin (when (fx= (port-ndx p) (port-size p)) (flush-output-port p)) (string-set! (port-buf p) (port-ndx p) ch) (port-ndx-add1 p))))
# == uniquify-variables  ==>
<<<<<<< HEAD
# (lambda (f310933 . f310932) (let ((f310935 (if (null? f310932) (current-output-port) (car f310932)))) (begin (when (fx= (port-ndx f310935) (port-size f310935)) (flush-output-port f310935)) (string-set! (port-buf f310935) (port-ndx f310935) f310933) (port-ndx-add1 f310935))))
# == vectorize-letrec  ==>
# (lambda (f310933 . f310932) (let ((f310935 (if (null? f310932) (current-output-port) (car f310932)))) (begin (when (fx= (port-ndx f310935) (port-size f310935)) (flush-output-port f310935)) (string-set! (port-buf f310935) (port-ndx f310935) f310933) (port-ndx-add1 f310935))))
# == eliminate-set!  ==>
# (lambda (f310933 . f310932) (let ((f310933 f310933)) (let ((f310935 (if (null? f310932) (current-output-port) (car f310932)))) (begin (when (fx= (port-ndx f310935) (port-size f310935)) (flush-output-port f310935)) (string-set! (port-buf f310935) (port-ndx f310935) f310933) (port-ndx-add1 f310935)))))
# == close-free-variables  ==>
# (closure (f310933 . f310932) () (let ((f310933 f310933)) (let ((f310935 (if (null? f310932) (current-output-port) (car f310932)))) (begin (when (fx= (port-ndx f310935) (port-size f310935)) (flush-output-port f310935)) (string-set! (port-buf f310935) (port-ndx f310935) f310933) (port-ndx-add1 f310935)))))
# == eliminate-quote  ==>
# (closure (f310933 . f310932) () (let ((f310933 f310933)) (let ((f310935 (if (null? f310932) (current-output-port) (car f310932)))) (begin (when (fx= (port-ndx f310935) (port-size f310935)) (flush-output-port f310935)) (string-set! (port-buf f310935) (port-ndx f310935) f310933) (port-ndx-add1 f310935)))))
# == eliminate-when/unless  ==>
# (closure (f310933 . f310932) () (let ((f310933 f310933)) (let ((f310935 (if (null? f310932) (current-output-port) (car f310932)))) (begin (if (fx= (port-ndx f310935) (port-size f310935)) (begin (flush-output-port f310935)) #f) (string-set! (port-buf f310935) (port-ndx f310935) f310933) (port-ndx-add1 f310935)))))
# == eliminate-cond  ==>
# (closure (f310933 . f310932) () (let ((f310933 f310933)) (let ((f310935 (if (null? f310932) (current-output-port) (car f310932)))) (begin (if (fx= (port-ndx f310935) (port-size f310935)) (begin (flush-output-port f310935)) #f) (string-set! (port-buf f310935) (port-ndx f310935) f310933) (port-ndx-add1 f310935)))))
# == external-symbols  ==>
# (closure (f310933 . f310932) () (let ((f310933 f310933)) (let ((f310935 (if (null? f310932) ((primitive-ref current-output-port)) (car f310932)))) (begin (if (fx= ((primitive-ref port-ndx) f310935) ((primitive-ref port-size) f310935)) (begin ((primitive-ref flush-output-port) f310935)) #f) (string-set! ((primitive-ref port-buf) f310935) ((primitive-ref port-ndx) f310935) f310933) ((primitive-ref port-ndx-add1) f310935)))))
# emit-expr (closure (f310933 . f310932) () (let ((f310933 f310933)) (let ((f310935 (if (null? f310932) ((primitive-ref current-output-port)) (car f310932)))) (begin (if (fx= ((primitive-ref port-ndx) f310935) ((primitive-ref port-size) f310935)) (begin ((primitive-ref flush-output-port) f310935)) #f) (string-set! ((primitive-ref port-buf) f310935) ((primitive-ref port-ndx) f310935) f310933) ((primitive-ref port-ndx-add1) f310935)))))
# emit-closure
# si = 0
# env = ()
# expr = (closure (f310933 . f310932) () (let ((f310933 f310933)) (let ((f310935 (if (null? f310932) ((primitive-ref current-output-port)) (car f310932)))) (begin (if (fx= ((primitive-ref port-ndx) f310935) ((primitive-ref port-size) f310935)) (begin ((primitive-ref flush-output-port) f310935)) #f) (string-set! ((primitive-ref port-buf) f310935) ((primitive-ref port-ndx) f310935) f310933) ((primitive-ref port-ndx-add1) f310935)))))
    movl $_L_1884705, 0(%ebp)  # closure label
=======
# (lambda (f145 . f146) (let ((f148 (if (null? f146) (current-output-port) (car f146)))) (begin (when (fx= (port-ndx f148) (port-size f148)) (flush-output-port f148)) (string-set! (port-buf f148) (port-ndx f148) f145) (port-ndx-add1 f148))))
# == vectorize-letrec  ==>
# (lambda (f145 . f146) (let ((f148 (if (null? f146) (current-output-port) (car f146)))) (begin (when (fx= (port-ndx f148) (port-size f148)) (flush-output-port f148)) (string-set! (port-buf f148) (port-ndx f148) f145) (port-ndx-add1 f148))))
# == eliminate-set!  ==>
# (lambda (f145 . f146) (let ((f145 f145)) (let ((f148 (if (null? f146) (current-output-port) (car f146)))) (begin (when (fx= (port-ndx f148) (port-size f148)) (flush-output-port f148)) (string-set! (port-buf f148) (port-ndx f148) f145) (port-ndx-add1 f148)))))
# == close-free-variables  ==>
# (closure (f145 . f146) () (let ((f145 f145)) (let ((f148 (if (null? f146) (current-output-port) (car f146)))) (begin (when (fx= (port-ndx f148) (port-size f148)) (flush-output-port f148)) (string-set! (port-buf f148) (port-ndx f148) f145) (port-ndx-add1 f148)))))
# == eliminate-quote  ==>
# (closure (f145 . f146) () (let ((f145 f145)) (let ((f148 (if (null? f146) (current-output-port) (car f146)))) (begin (when (fx= (port-ndx f148) (port-size f148)) (flush-output-port f148)) (string-set! (port-buf f148) (port-ndx f148) f145) (port-ndx-add1 f148)))))
# == eliminate-when/unless  ==>
# (closure (f145 . f146) () (let ((f145 f145)) (let ((f148 (if (null? f146) (current-output-port) (car f146)))) (begin (if (fx= (port-ndx f148) (port-size f148)) (begin (flush-output-port f148)) #f) (string-set! (port-buf f148) (port-ndx f148) f145) (port-ndx-add1 f148)))))
# == eliminate-cond  ==>
# (closure (f145 . f146) () (let ((f145 f145)) (let ((f148 (if (null? f146) (current-output-port) (car f146)))) (begin (if (fx= (port-ndx f148) (port-size f148)) (begin (flush-output-port f148)) #f) (string-set! (port-buf f148) (port-ndx f148) f145) (port-ndx-add1 f148)))))
# == external-symbols  ==>
# (closure (f145 . f146) () (let ((f145 f145)) (let ((f148 (if (null? f146) ((primitive-ref current-output-port)) (car f146)))) (begin (if (fx= ((primitive-ref port-ndx) f148) ((primitive-ref port-size) f148)) (begin ((primitive-ref flush-output-port) f148)) #f) (string-set! ((primitive-ref port-buf) f148) ((primitive-ref port-ndx) f148) f145) ((primitive-ref port-ndx-add1) f148)))))
# emit-expr (closure (f145 . f146) () (let ((f145 f145)) (let ((f148 (if (null? f146) ((primitive-ref current-output-port)) (car f146)))) (begin (if (fx= ((primitive-ref port-ndx) f148) ((primitive-ref port-size) f148)) (begin ((primitive-ref flush-output-port) f148)) #f) (string-set! ((primitive-ref port-buf) f148) ((primitive-ref port-ndx) f148) f145) ((primitive-ref port-ndx-add1) f148)))))
# emit-closure
# si = 0
# env = ()
# expr = (closure (f145 . f146) () (let ((f145 f145)) (let ((f148 (if (null? f146) ((primitive-ref current-output-port)) (car f146)))) (begin (if (fx= ((primitive-ref port-ndx) f148) ((primitive-ref port-size) f148)) (begin ((primitive-ref flush-output-port) f148)) #f) (string-set! ((primitive-ref port-buf) f148) ((primitive-ref port-ndx) f148) f145) ((primitive-ref port-ndx-add1) f148)))))
    movl $_L_1106, 0(%ebp)  # closure label
>>>>>>> fix-implicit-begins
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $8, %ebp     # bump ebp
    jmp _L_1107            # jump around closure body
_L_1106:
# check argument count
    cmp $4,%eax
    jge _L_1108
# invoke error handler eh_argcount_min
    .extern mrc_eh$uargcount$umin
    movl mrc_eh$uargcount$umin, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_1108:
# emit-build-varargs-list
    movl $63, %esi       # args <- () 
    lea -4(%esp),%edi    # edi <- esp-4
    subl %eax, %edi      # edi <- esp-4-eax    addr of arg[K+N] on stack
_L_1110:
    lea -8(%esp),%ebx    # addr of arg[K] on stack
    cmp %edi, %ebx       # while edi <> esp+(si+4)
    je _L_1109
    movl (%edi),%ebx     # arg i -> car
    movl %ebx, 0(%ebp)
    movl %esi, 4(%ebp)  # esi -> cdr
    movl %ebp, %esi
    addl $1, %esi       # tag as pair
    addl $8,%ebp         # bump heap ptr
    addl $4,%edi         # move to next previous arg from the end
    jmp _L_1110
_L_1109:
    movl %esi, -12(%esp)  # set args
# emit-tail-expr
# si=-16
<<<<<<< HEAD
# env=((f310932 . -12) (f310933 . -8))
# expr=(let ((f310933 f310933)) (let ((f310935 (if (null? f310932) ((primitive-ref current-output-port)) (car f310932)))) (begin (if (fx= ((primitive-ref port-ndx) f310935) ((primitive-ref port-size) f310935)) (begin ((primitive-ref flush-output-port) f310935)) #f) (string-set! ((primitive-ref port-buf) f310935) ((primitive-ref port-ndx) f310935) f310933) ((primitive-ref port-ndx-add1) f310935))))
# emit-tail-let
#  si   = -16
#  env  = ((f310932 . -12) (f310933 . -8))
#  bindings = ((f310933 f310933))
#  body = (let ((f310935 (if (null? f310932) ((primitive-ref current-output-port)) (car f310932)))) (begin (if (fx= ((primitive-ref port-ndx) f310935) ((primitive-ref port-size) f310935)) (begin ((primitive-ref flush-output-port) f310935)) #f) (string-set! ((primitive-ref port-buf) f310935) ((primitive-ref port-ndx) f310935) f310933) ((primitive-ref port-ndx-add1) f310935)))
# emit-expr f310933
# emit-variable-ref
# env=((f310932 . -12) (f310933 . -8))
# var=f310933
    movl -8(%esp), %eax  # stack load f310933
=======
# env=((f146 . -12) (f145 . -8))
# expr=(let ((f145 f145)) (let ((f148 (if (null? f146) ((primitive-ref current-output-port)) (car f146)))) (begin (if (fx= ((primitive-ref port-ndx) f148) ((primitive-ref port-size) f148)) (begin ((primitive-ref flush-output-port) f148)) #f) (string-set! ((primitive-ref port-buf) f148) ((primitive-ref port-ndx) f148) f145) ((primitive-ref port-ndx-add1) f148))))
# emit-tail-let
#  si   = -16
#  env  = ((f146 . -12) (f145 . -8))
#  bindings = ((f145 f145))
#  body = (let ((f148 (if (null? f146) ((primitive-ref current-output-port)) (car f146)))) (begin (if (fx= ((primitive-ref port-ndx) f148) ((primitive-ref port-size) f148)) (begin ((primitive-ref flush-output-port) f148)) #f) (string-set! ((primitive-ref port-buf) f148) ((primitive-ref port-ndx) f148) f145) ((primitive-ref port-ndx-add1) f148)))
# emit-expr f145
# emit-variable-ref
# env=((f146 . -12) (f145 . -8))
# var=f145
    movl -8(%esp), %eax  # stack load f145
>>>>>>> fix-implicit-begins
# end emit-variable-ref
    movl %eax, -16(%esp)  # stack save
# emit-tail-expr
# si=-20
<<<<<<< HEAD
# env=((f310933 . -16) (f310932 . -12) (f310933 . -8))
# expr=(let ((f310935 (if (null? f310932) ((primitive-ref current-output-port)) (car f310932)))) (begin (if (fx= ((primitive-ref port-ndx) f310935) ((primitive-ref port-size) f310935)) (begin ((primitive-ref flush-output-port) f310935)) #f) (string-set! ((primitive-ref port-buf) f310935) ((primitive-ref port-ndx) f310935) f310933) ((primitive-ref port-ndx-add1) f310935)))
# emit-tail-let
#  si   = -20
#  env  = ((f310933 . -16) (f310932 . -12) (f310933 . -8))
#  bindings = ((f310935 (if (null? f310932) ((primitive-ref current-output-port)) (car f310932))))
#  body = (begin (if (fx= ((primitive-ref port-ndx) f310935) ((primitive-ref port-size) f310935)) (begin ((primitive-ref flush-output-port) f310935)) #f) (string-set! ((primitive-ref port-buf) f310935) ((primitive-ref port-ndx) f310935) f310933) ((primitive-ref port-ndx-add1) f310935))
# emit-expr (if (null? f310932) ((primitive-ref current-output-port)) (car f310932))
# emit-expr (null? f310932)
# emit-expr f310932
# emit-variable-ref
# env=((f310933 . -16) (f310932 . -12) (f310933 . -8))
# var=f310932
    movl -12(%esp), %eax  # stack load f310932
=======
# env=((f145 . -16) (f146 . -12) (f145 . -8))
# expr=(let ((f148 (if (null? f146) ((primitive-ref current-output-port)) (car f146)))) (begin (if (fx= ((primitive-ref port-ndx) f148) ((primitive-ref port-size) f148)) (begin ((primitive-ref flush-output-port) f148)) #f) (string-set! ((primitive-ref port-buf) f148) ((primitive-ref port-ndx) f148) f145) ((primitive-ref port-ndx-add1) f148)))
# emit-tail-let
#  si   = -20
#  env  = ((f145 . -16) (f146 . -12) (f145 . -8))
#  bindings = ((f148 (if (null? f146) ((primitive-ref current-output-port)) (car f146))))
#  body = (begin (if (fx= ((primitive-ref port-ndx) f148) ((primitive-ref port-size) f148)) (begin ((primitive-ref flush-output-port) f148)) #f) (string-set! ((primitive-ref port-buf) f148) ((primitive-ref port-ndx) f148) f145) ((primitive-ref port-ndx-add1) f148))
# emit-expr (if (null? f146) ((primitive-ref current-output-port)) (car f146))
# emit-expr (null? f146)
# emit-expr f146
# emit-variable-ref
# env=((f145 . -16) (f146 . -12) (f145 . -8))
# var=f146
    movl -12(%esp), %eax  # stack load f146
>>>>>>> fix-implicit-begins
# end emit-variable-ref
    cmp $63, %eax
    mov $0, %eax
    sete %al
    movzbl %al, %eax
    sal $6, %al
    or $47, %al
    cmp $47, %al
    je _L_1111
# emit-expr ((primitive-ref current-output-port))
# funcall
#    si   =-20
<<<<<<< HEAD
#    env  = ((f310933 . -16) (f310932 . -12) (f310933 . -8))
=======
#    env  = ((f145 . -16) (f146 . -12) (f145 . -8))
>>>>>>> fix-implicit-begins
#    expr = (funcall (primitive-ref current-output-port))
# emit-expr (primitive-ref current-output-port)
    .extern mrc_current$moutput$mport
    movl mrc_current$moutput$mport,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1113"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1113":
   movl %eax,  -28(%esp)  # stash funcall-oper in closure slot
    movl -28(%esp), %edi   # load new closure to %edi
    add $-20, %esp   # adjust base
    movl $0,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $20, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
<<<<<<< HEAD
    jmp _L_1884711
_L_1884710:
# emit-expr (car f310932)
# emit-expr f310932
# emit-variable-ref
# env=((f310933 . -16) (f310932 . -12) (f310933 . -8))
# var=f310932
    movl -12(%esp), %eax  # stack load f310932
=======
    jmp _L_1112
_L_1111:
# emit-expr (car f146)
# emit-expr f146
# emit-variable-ref
# env=((f145 . -16) (f146 . -12) (f145 . -8))
# var=f146
    movl -12(%esp), %eax  # stack load f146
>>>>>>> fix-implicit-begins
# end emit-variable-ref
# check the argument is a pair
    movl %eax,%ebx
    and $7, %bl
    cmp $1, %bl
    je _L_1114
# invoke error handler eh_pair
    .extern mrc_eh$upair
    movl mrc_eh$upair, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $116,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1114:
    movl -1(%eax), %eax
_L_1112:
    movl %eax, -20(%esp)  # stack save
# emit-tail-expr
# si=-24
<<<<<<< HEAD
# env=((f310935 . -20) (f310933 . -16) (f310932 . -12) (f310933 . -8))
# expr=(begin (if (fx= ((primitive-ref port-ndx) f310935) ((primitive-ref port-size) f310935)) (begin ((primitive-ref flush-output-port) f310935)) #f) (string-set! ((primitive-ref port-buf) f310935) ((primitive-ref port-ndx) f310935) f310933) ((primitive-ref port-ndx-add1) f310935))
# tail-begin (begin (if (fx= ((primitive-ref port-ndx) f310935) ((primitive-ref port-size) f310935)) (begin ((primitive-ref flush-output-port) f310935)) #f) (string-set! ((primitive-ref port-buf) f310935) ((primitive-ref port-ndx) f310935) f310933) ((primitive-ref port-ndx-add1) f310935))
#   env=((f310935 . -20) (f310933 . -16) (f310932 . -12) (f310933 . -8))
# emit-expr (if (fx= ((primitive-ref port-ndx) f310935) ((primitive-ref port-size) f310935)) (begin ((primitive-ref flush-output-port) f310935)) #f)
# emit-expr (fx= ((primitive-ref port-ndx) f310935) ((primitive-ref port-size) f310935))
# emit-expr ((primitive-ref port-size) f310935)
# funcall
#    si   =-24
#    env  = ((f310935 . -20) (f310933 . -16) (f310932 . -12) (f310933 . -8))
#    expr = (funcall (primitive-ref port-size) f310935)
=======
# env=((f148 . -20) (f145 . -16) (f146 . -12) (f145 . -8))
# expr=(begin (if (fx= ((primitive-ref port-ndx) f148) ((primitive-ref port-size) f148)) (begin ((primitive-ref flush-output-port) f148)) #f) (string-set! ((primitive-ref port-buf) f148) ((primitive-ref port-ndx) f148) f145) ((primitive-ref port-ndx-add1) f148))
# tail-begin (begin (if (fx= ((primitive-ref port-ndx) f148) ((primitive-ref port-size) f148)) (begin ((primitive-ref flush-output-port) f148)) #f) (string-set! ((primitive-ref port-buf) f148) ((primitive-ref port-ndx) f148) f145) ((primitive-ref port-ndx-add1) f148))
#   env=((f148 . -20) (f145 . -16) (f146 . -12) (f145 . -8))
# emit-expr (if (fx= ((primitive-ref port-ndx) f148) ((primitive-ref port-size) f148)) (begin ((primitive-ref flush-output-port) f148)) #f)
# emit-expr (fx= ((primitive-ref port-ndx) f148) ((primitive-ref port-size) f148))
# emit-expr ((primitive-ref port-size) f148)
# funcall
#    si   =-24
#    env  = ((f148 . -20) (f145 . -16) (f146 . -12) (f145 . -8))
#    expr = (funcall (primitive-ref port-size) f148)
>>>>>>> fix-implicit-begins
# emit-expr (primitive-ref port-size)
    .extern mrc_port$msize
    movl mrc_port$msize,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1117"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1117":
   movl %eax,  -32(%esp)  # stash funcall-oper in closure slot
# emit-expr f148
# emit-variable-ref
<<<<<<< HEAD
# env=((f310935 . -20) (f310933 . -16) (f310932 . -12) (f310933 . -8))
# var=f310935
    movl -20(%esp), %eax  # stack load f310935
=======
# env=((f148 . -20) (f145 . -16) (f146 . -12) (f145 . -8))
# var=f148
    movl -20(%esp), %eax  # stack load f148
>>>>>>> fix-implicit-begins
# end emit-variable-ref
    mov %eax, -36(%esp)  # arg f148
    movl -32(%esp), %edi   # load new closure to %edi
    add $-24, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $24, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1118"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $68,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1118:
    movl %eax, -24(%esp)
# emit-expr ((primitive-ref port-ndx) f148)
# funcall
#    si   =-28
<<<<<<< HEAD
#    env  = ((f310935 . -20) (f310933 . -16) (f310932 . -12) (f310933 . -8))
#    expr = (funcall (primitive-ref port-ndx) f310935)
=======
#    env  = ((f148 . -20) (f145 . -16) (f146 . -12) (f145 . -8))
#    expr = (funcall (primitive-ref port-ndx) f148)
>>>>>>> fix-implicit-begins
# emit-expr (primitive-ref port-ndx)
    .extern mrc_port$mndx
    movl mrc_port$mndx,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1119"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1119":
   movl %eax,  -36(%esp)  # stash funcall-oper in closure slot
# emit-expr f148
# emit-variable-ref
<<<<<<< HEAD
# env=((f310935 . -20) (f310933 . -16) (f310932 . -12) (f310933 . -8))
# var=f310935
    movl -20(%esp), %eax  # stack load f310935
=======
# env=((f148 . -20) (f145 . -16) (f146 . -12) (f145 . -8))
# var=f148
    movl -20(%esp), %eax  # stack load f148
>>>>>>> fix-implicit-begins
# end emit-variable-ref
    mov %eax, -40(%esp)  # arg f148
    movl -36(%esp), %edi   # load new closure to %edi
    add $-28, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $28, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1120"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $68,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1120:
    cmp -24(%esp), %eax
    sete %al
    movzbl %al, %eax
    sal $6, %al
    or $47, %al
    cmp $47, %al
    je _L_1115
# emit-expr (begin ((primitive-ref flush-output-port) f148))
# emit-begin
<<<<<<< HEAD
#   expr=(begin ((primitive-ref flush-output-port) f310935))
#   env=((f310935 . -20) (f310933 . -16) (f310932 . -12) (f310933 . -8))
# emit-expr ((primitive-ref flush-output-port) f310935)
# funcall
#    si   =-24
#    env  = ((f310935 . -20) (f310933 . -16) (f310932 . -12) (f310933 . -8))
#    expr = (funcall (primitive-ref flush-output-port) f310935)
=======
#   expr=(begin ((primitive-ref flush-output-port) f148))
#   env=((f148 . -20) (f145 . -16) (f146 . -12) (f145 . -8))
# emit-expr ((primitive-ref flush-output-port) f148)
# funcall
#    si   =-24
#    env  = ((f148 . -20) (f145 . -16) (f146 . -12) (f145 . -8))
#    expr = (funcall (primitive-ref flush-output-port) f148)
>>>>>>> fix-implicit-begins
# emit-expr (primitive-ref flush-output-port)
    .extern mrc_flush$moutput$mport
    movl mrc_flush$moutput$mport,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1121"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1121":
   movl %eax,  -32(%esp)  # stash funcall-oper in closure slot
# emit-expr f148
# emit-variable-ref
<<<<<<< HEAD
# env=((f310935 . -20) (f310933 . -16) (f310932 . -12) (f310933 . -8))
# var=f310935
    movl -20(%esp), %eax  # stack load f310935
=======
# env=((f148 . -20) (f145 . -16) (f146 . -12) (f145 . -8))
# var=f148
    movl -20(%esp), %eax  # stack load f148
>>>>>>> fix-implicit-begins
# end emit-variable-ref
    mov %eax, -36(%esp)  # arg f148
    movl -32(%esp), %edi   # load new closure to %edi
    add $-24, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $24, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
# emit-expr (begin)
# emit-begin
#   expr=(begin)
<<<<<<< HEAD
#   env=((f310935 . -20) (f310933 . -16) (f310932 . -12) (f310933 . -8))
    jmp _L_1884715
_L_1884714:
=======
#   env=((f148 . -20) (f145 . -16) (f146 . -12) (f145 . -8))
    jmp _L_1116
_L_1115:
>>>>>>> fix-implicit-begins
# emit-expr #f
    movl $47, %eax     # immed #f
_L_1116:
# emit-tail-expr
# si=-24
<<<<<<< HEAD
# env=((f310935 . -20) (f310933 . -16) (f310932 . -12) (f310933 . -8))
# expr=(begin (string-set! ((primitive-ref port-buf) f310935) ((primitive-ref port-ndx) f310935) f310933) ((primitive-ref port-ndx-add1) f310935))
# tail-begin (begin (string-set! ((primitive-ref port-buf) f310935) ((primitive-ref port-ndx) f310935) f310933) ((primitive-ref port-ndx-add1) f310935))
#   env=((f310935 . -20) (f310933 . -16) (f310932 . -12) (f310933 . -8))
# emit-expr (string-set! ((primitive-ref port-buf) f310935) ((primitive-ref port-ndx) f310935) f310933)
# emit-expr ((primitive-ref port-buf) f310935)
# funcall
#    si   =-24
#    env  = ((f310935 . -20) (f310933 . -16) (f310932 . -12) (f310933 . -8))
#    expr = (funcall (primitive-ref port-buf) f310935)
=======
# env=((f148 . -20) (f145 . -16) (f146 . -12) (f145 . -8))
# expr=(begin (string-set! ((primitive-ref port-buf) f148) ((primitive-ref port-ndx) f148) f145) ((primitive-ref port-ndx-add1) f148))
# tail-begin (begin (string-set! ((primitive-ref port-buf) f148) ((primitive-ref port-ndx) f148) f145) ((primitive-ref port-ndx-add1) f148))
#   env=((f148 . -20) (f145 . -16) (f146 . -12) (f145 . -8))
# emit-expr (string-set! ((primitive-ref port-buf) f148) ((primitive-ref port-ndx) f148) f145)
# emit-expr ((primitive-ref port-buf) f148)
# funcall
#    si   =-24
#    env  = ((f148 . -20) (f145 . -16) (f146 . -12) (f145 . -8))
#    expr = (funcall (primitive-ref port-buf) f148)
>>>>>>> fix-implicit-begins
# emit-expr (primitive-ref port-buf)
    .extern mrc_port$mbuf
    movl mrc_port$mbuf,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1122"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1122":
   movl %eax,  -32(%esp)  # stash funcall-oper in closure slot
# emit-expr f148
# emit-variable-ref
<<<<<<< HEAD
# env=((f310935 . -20) (f310933 . -16) (f310932 . -12) (f310933 . -8))
# var=f310935
    movl -20(%esp), %eax  # stack load f310935
=======
# env=((f148 . -20) (f145 . -16) (f146 . -12) (f145 . -8))
# var=f148
    movl -20(%esp), %eax  # stack load f148
>>>>>>> fix-implicit-begins
# end emit-variable-ref
    mov %eax, -36(%esp)  # arg f148
    movl -32(%esp), %edi   # load new closure to %edi
    add $-24, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $24, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
# check the argument is a string
    movl %eax,%ebx
    and $7, %bl
    cmp $6, %bl
    je _L_1123
# invoke error handler eh_string
    .extern mrc_eh$ustring
    movl mrc_eh$ustring, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $168,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1123:
    movl %eax, -24(%esp)
# emit-expr ((primitive-ref port-ndx) f148)
# funcall
<<<<<<< HEAD
#    si   =-24
#    env  = ((f310935 . -20) (f310933 . -16) (f310932 . -12) (f310933 . -8))
#    expr = (funcall (primitive-ref port-ndx) f310935)
=======
#    si   =-28
#    env  = ((f148 . -20) (f145 . -16) (f146 . -12) (f145 . -8))
#    expr = (funcall (primitive-ref port-ndx) f148)
>>>>>>> fix-implicit-begins
# emit-expr (primitive-ref port-ndx)
    .extern mrc_port$mndx
    movl mrc_port$mndx,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1124"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1124":
   movl %eax,  -36(%esp)  # stash funcall-oper in closure slot
# emit-expr f148
# emit-variable-ref
<<<<<<< HEAD
# env=((f310935 . -20) (f310933 . -16) (f310932 . -12) (f310933 . -8))
# var=f310935
    movl -20(%esp), %eax  # stack load f310935
=======
# env=((f148 . -20) (f145 . -16) (f146 . -12) (f145 . -8))
# var=f148
    movl -20(%esp), %eax  # stack load f148
>>>>>>> fix-implicit-begins
# end emit-variable-ref
    mov %eax, -40(%esp)  # arg f148
    movl -36(%esp), %edi   # load new closure to %edi
    add $-28, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $28, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1125"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $168,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1125:
# check bounds on string index
    movl -24(%esp), %ebx
    cmp  %eax,-6(%ebx) 
    jle _L_1127
    cmp  $0,%eax
    jge _L_1126
_L_1127:
# invoke error handler eh_string_index
    .extern mrc_eh$ustring$uindex
    movl mrc_eh$ustring$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $168,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1126:
    movl %eax, -28(%esp)
<<<<<<< HEAD
# emit-expr f310933
# emit-variable-ref
# env=((f310935 . -20) (f310933 . -16) (f310932 . -12) (f310933 . -8))
# var=f310933
    movl -16(%esp), %eax  # stack load f310933
=======
# emit-expr f145
# emit-variable-ref
# env=((f148 . -20) (f145 . -16) (f146 . -12) (f145 . -8))
# var=f145
    movl -16(%esp), %eax  # stack load f145
>>>>>>> fix-implicit-begins
# end emit-variable-ref
# check the argument is a char
    movl %eax,%ebx
    and $255, %bl
    cmp $15, %bl
    je "_L_1128"
# invoke error handler eh_character
    .extern mrc_eh$ucharacter
    movl mrc_eh$ucharacter, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $168,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1128:
    movl -24(%esp), %ebx
    movl -28(%esp), %esi
    sar $2, %esi
    movb  %ah, -2(%ebx,%esi)
# emit-tail-expr
# si=-24
<<<<<<< HEAD
# env=((f310935 . -20) (f310933 . -16) (f310932 . -12) (f310933 . -8))
# expr=(begin ((primitive-ref port-ndx-add1) f310935))
# tail-begin (begin ((primitive-ref port-ndx-add1) f310935))
#   env=((f310935 . -20) (f310933 . -16) (f310932 . -12) (f310933 . -8))
# emit-tail-expr
# si=-24
# env=((f310935 . -20) (f310933 . -16) (f310932 . -12) (f310933 . -8))
# expr=((primitive-ref port-ndx-add1) f310935)
# emit-tail-funcall
#    si   =-24
#    env  = ((f310935 . -20) (f310933 . -16) (f310932 . -12) (f310933 . -8))
#    expr = (funcall (primitive-ref port-ndx-add1) f310935)
=======
# env=((f148 . -20) (f145 . -16) (f146 . -12) (f145 . -8))
# expr=(begin ((primitive-ref port-ndx-add1) f148))
# tail-begin (begin ((primitive-ref port-ndx-add1) f148))
#   env=((f148 . -20) (f145 . -16) (f146 . -12) (f145 . -8))
# emit-tail-expr
# si=-24
# env=((f148 . -20) (f145 . -16) (f146 . -12) (f145 . -8))
# expr=((primitive-ref port-ndx-add1) f148)
# emit-tail-funcall
#    si   =-24
#    env  = ((f148 . -20) (f145 . -16) (f146 . -12) (f145 . -8))
#    expr = (funcall (primitive-ref port-ndx-add1) f148)
>>>>>>> fix-implicit-begins
# emit-expr (primitive-ref port-ndx-add1)
    .extern mrc_port$mndx$madd1
    movl mrc_port$mndx$madd1,%eax
   movl %eax,  -24(%esp)  # stash funcall-oper in next closure slot
# emit-expr f148
# emit-variable-ref
<<<<<<< HEAD
# env=((f310935 . -20) (f310933 . -16) (f310932 . -12) (f310933 . -8))
# var=f310935
    movl -20(%esp), %eax  # stack load f310935
=======
# env=((f148 . -20) (f145 . -16) (f146 . -12) (f145 . -8))
# var=f148
    movl -20(%esp), %eax  # stack load f148
>>>>>>> fix-implicit-begins
# end emit-variable-ref
    mov %eax, -28(%esp)    # arg f148
    movl -24(%esp), %edi   # load new closure to %edi
# emit-shift-args:  size=2   si=-24  delta=20
    mov -24(%esp), %ebx  # shift frame cell
    mov %ebx, -4(%esp)  # down to base
# emit-shift-args:  size=1   si=-28  delta=20
    mov -28(%esp), %ebx  # shift frame cell
    mov %ebx, -8(%esp)  # down to base
# emit-shift-args:  size=0   si=-32  delta=20
    movl $4,%eax   # save arg count
    jmp *-2(%edi)  # tail-funcall
     ret   # return thru stack
    .align 4,0x90
_L_1107:
     movl %eax, mrc_write$mchar
# == explicit-begins  ==>
# (lambda args (let ((p (if (null? args) (current-output-port) (car args)))) (begin (foreign-call "s_write" (port-fd p) (port-buf p) (port-ndx p)) (port-ndx-reset p))))
# == eliminate-let*  ==>
# (lambda args (let ((p (if (null? args) (current-output-port) (car args)))) (begin (foreign-call "s_write" (port-fd p) (port-buf p) (port-ndx p)) (port-ndx-reset p))))
# == uniquify-variables  ==>
# (lambda f149 (let ((f151 (if (null? f149) (current-output-port) (car f149)))) (begin (foreign-call "s_write" (port-fd f151) (port-buf f151) (port-ndx f151)) (port-ndx-reset f151))))
# == vectorize-letrec  ==>
# (lambda f149 (let ((f151 (if (null? f149) (current-output-port) (car f149)))) (begin (foreign-call "s_write" (port-fd f151) (port-buf f151) (port-ndx f151)) (port-ndx-reset f151))))
# == eliminate-set!  ==>
# (lambda f149 (let () (let ((f151 (if (null? f149) (current-output-port) (car f149)))) (begin (foreign-call "s_write" (port-fd f151) (port-buf f151) (port-ndx f151)) (port-ndx-reset f151)))))
# == close-free-variables  ==>
# (closure f149 () (let () (let ((f151 (if (null? f149) (current-output-port) (car f149)))) (begin (foreign-call "s_write" (port-fd f151) (port-buf f151) (port-ndx f151)) (port-ndx-reset f151)))))
# == eliminate-quote  ==>
# (closure f149 () (let () (let ((f151 (if (null? f149) (current-output-port) (car f149)))) (begin (foreign-call "s_write" (port-fd f151) (port-buf f151) (port-ndx f151)) (port-ndx-reset f151)))))
# == eliminate-when/unless  ==>
# (closure f149 () (let () (let ((f151 (if (null? f149) (current-output-port) (car f149)))) (begin (foreign-call "s_write" (port-fd f151) (port-buf f151) (port-ndx f151)) (port-ndx-reset f151)))))
# == eliminate-cond  ==>
# (closure f149 () (let () (let ((f151 (if (null? f149) (current-output-port) (car f149)))) (begin (foreign-call "s_write" (port-fd f151) (port-buf f151) (port-ndx f151)) (port-ndx-reset f151)))))
# == external-symbols  ==>
# (closure f149 () (let () (let ((f151 (if (null? f149) ((primitive-ref current-output-port)) (car f149)))) (begin (foreign-call "s_write" ((primitive-ref port-fd) f151) ((primitive-ref port-buf) f151) ((primitive-ref port-ndx) f151)) ((primitive-ref port-ndx-reset) f151)))))
# emit-expr (closure f149 () (let () (let ((f151 (if (null? f149) ((primitive-ref current-output-port)) (car f149)))) (begin (foreign-call "s_write" ((primitive-ref port-fd) f151) ((primitive-ref port-buf) f151) ((primitive-ref port-ndx) f151)) ((primitive-ref port-ndx-reset) f151)))))
# emit-closure
# si = 0
# env = ()
# expr = (closure f149 () (let () (let ((f151 (if (null? f149) ((primitive-ref current-output-port)) (car f149)))) (begin (foreign-call "s_write" ((primitive-ref port-fd) f151) ((primitive-ref port-buf) f151) ((primitive-ref port-ndx) f151)) ((primitive-ref port-ndx-reset) f151)))))
    movl $_L_1129, 0(%ebp)  # closure label
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $8, %ebp     # bump ebp
    jmp _L_1130            # jump around closure body
_L_1129:
# check argument count
    cmp $0,%eax
    jge _L_1131
# invoke error handler eh_argcount_min
    .extern mrc_eh$uargcount$umin
    movl mrc_eh$uargcount$umin, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_1131:
# emit-build-varargs-list
    movl $63, %esi       # args <- () 
    lea -4(%esp),%edi    # edi <- esp-4
    subl %eax, %edi      # edi <- esp-4-eax    addr of arg[K+N] on stack
_L_1133:
    lea -4(%esp),%ebx    # addr of arg[K] on stack
    cmp %edi, %ebx       # while edi <> esp+(si+4)
    je _L_1132
    movl (%edi),%ebx     # arg i -> car
    movl %ebx, 0(%ebp)
    movl %esi, 4(%ebp)  # esi -> cdr
    movl %ebp, %esi
    addl $1, %esi       # tag as pair
    addl $8,%ebp         # bump heap ptr
    addl $4,%edi         # move to next previous arg from the end
    jmp _L_1133
_L_1132:
    movl %esi, -8(%esp)  # set args
# emit-tail-expr
# si=-12
# env=((f149 . -8))
# expr=(let () (let ((f151 (if (null? f149) ((primitive-ref current-output-port)) (car f149)))) (begin (foreign-call "s_write" ((primitive-ref port-fd) f151) ((primitive-ref port-buf) f151) ((primitive-ref port-ndx) f151)) ((primitive-ref port-ndx-reset) f151))))
# emit-tail-let
#  si   = -12
#  env  = ((f149 . -8))
#  bindings = ()
#  body = (let ((f151 (if (null? f149) ((primitive-ref current-output-port)) (car f149)))) (begin (foreign-call "s_write" ((primitive-ref port-fd) f151) ((primitive-ref port-buf) f151) ((primitive-ref port-ndx) f151)) ((primitive-ref port-ndx-reset) f151)))
# emit-tail-expr
# si=-12
# env=((f149 . -8))
# expr=(let ((f151 (if (null? f149) ((primitive-ref current-output-port)) (car f149)))) (begin (foreign-call "s_write" ((primitive-ref port-fd) f151) ((primitive-ref port-buf) f151) ((primitive-ref port-ndx) f151)) ((primitive-ref port-ndx-reset) f151)))
# emit-tail-let
#  si   = -12
#  env  = ((f149 . -8))
#  bindings = ((f151 (if (null? f149) ((primitive-ref current-output-port)) (car f149))))
#  body = (begin (foreign-call "s_write" ((primitive-ref port-fd) f151) ((primitive-ref port-buf) f151) ((primitive-ref port-ndx) f151)) ((primitive-ref port-ndx-reset) f151))
# emit-expr (if (null? f149) ((primitive-ref current-output-port)) (car f149))
# emit-expr (null? f149)
# emit-expr f149
# emit-variable-ref
# env=((f149 . -8))
# var=f149
    movl -8(%esp), %eax  # stack load f149
# end emit-variable-ref
    cmp $63, %eax
    mov $0, %eax
    sete %al
    movzbl %al, %eax
    sal $6, %al
    or $47, %al
    cmp $47, %al
    je _L_1134
# emit-expr ((primitive-ref current-output-port))
# funcall
#    si   =-12
#    env  = ((f149 . -8))
#    expr = (funcall (primitive-ref current-output-port))
# emit-expr (primitive-ref current-output-port)
    .extern mrc_current$moutput$mport
    movl mrc_current$moutput$mport,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1136"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1136":
   movl %eax,  -20(%esp)  # stash funcall-oper in closure slot
    movl -20(%esp), %edi   # load new closure to %edi
    add $-12, %esp   # adjust base
    movl $0,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $12, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    jmp _L_1135
_L_1134:
# emit-expr (car f149)
# emit-expr f149
# emit-variable-ref
# env=((f149 . -8))
# var=f149
    movl -8(%esp), %eax  # stack load f149
# end emit-variable-ref
# check the argument is a pair
    movl %eax,%ebx
    and $7, %bl
    cmp $1, %bl
    je _L_1137
# invoke error handler eh_pair
    .extern mrc_eh$upair
    movl mrc_eh$upair, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $116,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1137:
    movl -1(%eax), %eax
_L_1135:
    movl %eax, -12(%esp)  # stack save
# emit-tail-expr
# si=-16
# env=((f151 . -12) (f149 . -8))
# expr=(begin (foreign-call "s_write" ((primitive-ref port-fd) f151) ((primitive-ref port-buf) f151) ((primitive-ref port-ndx) f151)) ((primitive-ref port-ndx-reset) f151))
# tail-begin (begin (foreign-call "s_write" ((primitive-ref port-fd) f151) ((primitive-ref port-buf) f151) ((primitive-ref port-ndx) f151)) ((primitive-ref port-ndx-reset) f151))
#   env=((f151 . -12) (f149 . -8))
# emit-expr (foreign-call "s_write" ((primitive-ref port-fd) f151) ((primitive-ref port-buf) f151) ((primitive-ref port-ndx) f151))
    movl %ecx,-16(%esp)
    movl %esp,-20(%esp)
# emit-expr ((primitive-ref port-ndx) f151)
# funcall
#    si   =-24
#    env  = ((f151 . -12) (f149 . -8))
#    expr = (funcall (primitive-ref port-ndx) f151)
# emit-expr (primitive-ref port-ndx)
    .extern mrc_port$mndx
    movl mrc_port$mndx,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1138"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1138":
   movl %eax,  -32(%esp)  # stash funcall-oper in closure slot
# emit-expr f151
# emit-variable-ref
# env=((f151 . -12) (f149 . -8))
# var=f151
    movl -12(%esp), %eax  # stack load f151
# end emit-variable-ref
    mov %eax, -36(%esp)  # arg f151
    movl -32(%esp), %edi   # load new closure to %edi
    add $-24, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $24, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    movl %eax, -24(%esp)
# emit-expr ((primitive-ref port-buf) f151)
# funcall
#    si   =-28
#    env  = ((f151 . -12) (f149 . -8))
#    expr = (funcall (primitive-ref port-buf) f151)
# emit-expr (primitive-ref port-buf)
    .extern mrc_port$mbuf
    movl mrc_port$mbuf,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1139"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1139":
   movl %eax,  -36(%esp)  # stash funcall-oper in closure slot
# emit-expr f151
# emit-variable-ref
# env=((f151 . -12) (f149 . -8))
# var=f151
    movl -12(%esp), %eax  # stack load f151
# end emit-variable-ref
    mov %eax, -40(%esp)  # arg f151
    movl -36(%esp), %edi   # load new closure to %edi
    add $-28, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $28, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    movl %eax, -28(%esp)
# emit-expr ((primitive-ref port-fd) f151)
# funcall
#    si   =-32
#    env  = ((f151 . -12) (f149 . -8))
#    expr = (funcall (primitive-ref port-fd) f151)
# emit-expr (primitive-ref port-fd)
    .extern mrc_port$mfd
    movl mrc_port$mfd,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1140"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1140":
   movl %eax,  -40(%esp)  # stash funcall-oper in closure slot
# emit-expr f151
# emit-variable-ref
# env=((f151 . -12) (f149 . -8))
# var=f151
    movl -12(%esp), %eax  # stack load f151
# end emit-variable-ref
    mov %eax, -44(%esp)  # arg f151
    movl -40(%esp), %edi   # load new closure to %edi
    add $-32, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $32, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    movl %eax, -32(%esp)
    leal -32(%esp),%edi
    movl %edi,%esi
    andl $-16,%esi
    movl 0(%edi),%eax
    movl %eax,0(%esi)
    movl 4(%edi),%eax
    movl %eax,4(%esi)
    movl 8(%edi),%eax
    movl %eax,8(%esi)
    movl 12(%edi),%eax
    movl %eax,12(%esi)
    movl %esi,%esp
    .extern _s_write
    call _s_write
    movl 12(%esi),%esp
    movl -16(%esp),%ecx
# emit-tail-expr
# si=-16
# env=((f151 . -12) (f149 . -8))
# expr=(begin ((primitive-ref port-ndx-reset) f151))
# tail-begin (begin ((primitive-ref port-ndx-reset) f151))
#   env=((f151 . -12) (f149 . -8))
# emit-tail-expr
# si=-16
# env=((f151 . -12) (f149 . -8))
# expr=((primitive-ref port-ndx-reset) f151)
# emit-tail-funcall
#    si   =-16
#    env  = ((f151 . -12) (f149 . -8))
#    expr = (funcall (primitive-ref port-ndx-reset) f151)
# emit-expr (primitive-ref port-ndx-reset)
    .extern mrc_port$mndx$mreset
    movl mrc_port$mndx$mreset,%eax
   movl %eax,  -16(%esp)  # stash funcall-oper in next closure slot
# emit-expr f151
# emit-variable-ref
# env=((f151 . -12) (f149 . -8))
# var=f151
    movl -12(%esp), %eax  # stack load f151
# end emit-variable-ref
    mov %eax, -20(%esp)    # arg f151
    movl -16(%esp), %edi   # load new closure to %edi
# emit-shift-args:  size=2   si=-16  delta=12
    mov -16(%esp), %ebx  # shift frame cell
    mov %ebx, -4(%esp)  # down to base
# emit-shift-args:  size=1   si=-20  delta=12
    mov -20(%esp), %ebx  # shift frame cell
    mov %ebx, -8(%esp)  # down to base
# emit-shift-args:  size=0   si=-24  delta=12
    movl $4,%eax   # save arg count
    jmp *-2(%edi)  # tail-funcall
     ret   # return thru stack
    .align 4,0x90
_L_1130:
     movl %eax, mrc_flush$moutput$mport
# == explicit-begins  ==>
# (lambda () (begin (flush-output-port) (foreign-call "s_exit")))
# == eliminate-let*  ==>
# (lambda () (begin (flush-output-port) (foreign-call "s_exit")))
# == uniquify-variables  ==>
# (lambda () (begin (flush-output-port) (foreign-call "s_exit")))
# == vectorize-letrec  ==>
# (lambda () (begin (flush-output-port) (foreign-call "s_exit")))
# == eliminate-set!  ==>
# (lambda () (let () (begin (flush-output-port) (foreign-call "s_exit"))))
# == close-free-variables  ==>
# (closure () () (let () (begin (flush-output-port) (foreign-call "s_exit"))))
# == eliminate-quote  ==>
# (closure () () (let () (begin (flush-output-port) (foreign-call "s_exit"))))
# == eliminate-when/unless  ==>
# (closure () () (let () (begin (flush-output-port) (foreign-call "s_exit"))))
# == eliminate-cond  ==>
# (closure () () (let () (begin (flush-output-port) (foreign-call "s_exit"))))
# == external-symbols  ==>
# (closure () () (let () (begin ((primitive-ref flush-output-port)) (foreign-call "s_exit"))))
# emit-expr (closure () () (let () (begin ((primitive-ref flush-output-port)) (foreign-call "s_exit"))))
# emit-closure
# si = 0
# env = ()
# expr = (closure () () (let () (begin ((primitive-ref flush-output-port)) (foreign-call "s_exit"))))
    movl $_L_1141, 0(%ebp)  # closure label
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $8, %ebp     # bump ebp
    jmp _L_1142            # jump around closure body
_L_1141:
# check argument count
    cmp $0,%eax
    je _L_1143
# invoke error handler eh_argcount
    .extern mrc_eh$uargcount
    movl mrc_eh$uargcount, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_1143:
# emit-tail-expr
# si=-8
# env=()
# expr=(let () (begin ((primitive-ref flush-output-port)) (foreign-call "s_exit")))
# emit-tail-let
#  si   = -8
#  env  = ()
#  bindings = ()
#  body = (begin ((primitive-ref flush-output-port)) (foreign-call "s_exit"))
# emit-tail-expr
# si=-8
# env=()
# expr=(begin ((primitive-ref flush-output-port)) (foreign-call "s_exit"))
# tail-begin (begin ((primitive-ref flush-output-port)) (foreign-call "s_exit"))
#   env=()
# emit-expr ((primitive-ref flush-output-port))
# funcall
#    si   =-8
#    env  = ()
#    expr = (funcall (primitive-ref flush-output-port))
# emit-expr (primitive-ref flush-output-port)
    .extern mrc_flush$moutput$mport
    movl mrc_flush$moutput$mport,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1144"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1144":
   movl %eax,  -16(%esp)  # stash funcall-oper in closure slot
    movl -16(%esp), %edi   # load new closure to %edi
    add $-8, %esp   # adjust base
    movl $0,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $8, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
# emit-tail-expr
# si=-8
# env=()
# expr=(begin (foreign-call "s_exit"))
# tail-begin (begin (foreign-call "s_exit"))
#   env=()
# emit-tail-expr
# si=-8
# env=()
# expr=(foreign-call "s_exit")
    movl %ecx,-8(%esp)
    movl %esp,-12(%esp)
    leal -12(%esp),%edi
    movl %edi,%esi
    andl $-16,%esi
    movl 0(%edi),%eax
    movl %eax,0(%esi)
    movl %esi,%esp
    .extern _s_exit
    call _s_exit
    movl 0(%esi),%esp
    movl -8(%esp),%ecx
     ret
     ret   # return thru stack
    .align 4,0x90
_L_1142:
     movl %eax, mrc_exit
# == explicit-begins  ==>
# (lambda (filename) (begin (unless (string? filename) (error (quote open-output-file) "filename must be a string")) (let ((fd (foreign-call "s_open_for_write" filename))) (begin (when (negative? fd) (error (quote open-output-file) "open failed")) (let ((p (make-vector 6)) (sz 1024)) (begin (vector-set! p 0 (quote output-port)) (vector-set! p 1 filename) (vector-set! p 2 fd) (vector-set! p 3 (make-string sz)) (vector-set! p 4 0) (vector-set! p 5 sz) p))))))
# == eliminate-let*  ==>
# (lambda (filename) (begin (unless (string? filename) (error (quote open-output-file) "filename must be a string")) (let ((fd (foreign-call "s_open_for_write" filename))) (begin (when (negative? fd) (error (quote open-output-file) "open failed")) (let ((p (make-vector 6)) (sz 1024)) (begin (vector-set! p 0 (quote output-port)) (vector-set! p 1 filename) (vector-set! p 2 fd) (vector-set! p 3 (make-string sz)) (vector-set! p 4 0) (vector-set! p 5 sz) p))))))
# == uniquify-variables  ==>
# (lambda (f152) (begin (unless (string? f152) (error (quote open-output-file) "filename must be a string")) (let ((f158 (foreign-call "s_open_for_write" f152))) (begin (when (negative? f158) (error (quote open-output-file) "open failed")) (let ((f162 (make-vector 6)) (f161 1024)) (begin (vector-set! f162 0 (quote output-port)) (vector-set! f162 1 f152) (vector-set! f162 2 f158) (vector-set! f162 3 (make-string f161)) (vector-set! f162 4 0) (vector-set! f162 5 f161) f162))))))
# == vectorize-letrec  ==>
# (lambda (f152) (begin (unless (string? f152) (error (quote open-output-file) "filename must be a string")) (let ((f158 (foreign-call "s_open_for_write" f152))) (begin (when (negative? f158) (error (quote open-output-file) "open failed")) (let ((f162 (make-vector 6)) (f161 1024)) (begin (vector-set! f162 0 (quote output-port)) (vector-set! f162 1 f152) (vector-set! f162 2 f158) (vector-set! f162 3 (make-string f161)) (vector-set! f162 4 0) (vector-set! f162 5 f161) f162))))))
# == eliminate-set!  ==>
# (lambda (f152) (let ((f152 f152)) (begin (unless (string? f152) (error (quote open-output-file) "filename must be a string")) (let ((f158 (foreign-call "s_open_for_write" f152))) (begin (when (negative? f158) (error (quote open-output-file) "open failed")) (let ((f162 (make-vector 6)) (f161 1024)) (begin (vector-set! f162 0 (quote output-port)) (vector-set! f162 1 f152) (vector-set! f162 2 f158) (vector-set! f162 3 (make-string f161)) (vector-set! f162 4 0) (vector-set! f162 5 f161) f162)))))))
# == close-free-variables  ==>
# (closure (f152) (output-port) (let ((f152 f152)) (begin (unless (string? f152) (error (quote open-output-file) "filename must be a string")) (let ((f158 (foreign-call "s_open_for_write" f152))) (begin (when (negative? f158) (error (quote open-output-file) "open failed")) (let ((f162 (make-vector 6)) (f161 1024)) (begin (vector-set! f162 0 (quote output-port)) (vector-set! f162 1 f152) (vector-set! f162 2 f158) (vector-set! f162 3 (make-string f161)) (vector-set! f162 4 0) (vector-set! f162 5 f161) f162)))))))
# == eliminate-quote  ==>
# (closure (f152) (output-port) (let ((f152 f152)) (begin (unless (string? f152) (error (string->symbol "open-output-file") "filename must be a string")) (let ((f158 (foreign-call "s_open_for_write" f152))) (begin (when (negative? f158) (error (string->symbol "open-output-file") "open failed")) (let ((f162 (make-vector 6)) (f161 1024)) (begin (vector-set! f162 0 (string->symbol "output-port")) (vector-set! f162 1 f152) (vector-set! f162 2 f158) (vector-set! f162 3 (make-string f161)) (vector-set! f162 4 0) (vector-set! f162 5 f161) f162)))))))
# == eliminate-when/unless  ==>
# (closure (f152) (output-port) (let ((f152 f152)) (begin (if (not (string? f152)) (begin (error (string->symbol "open-output-file") "filename must be a string")) #f) (let ((f158 (foreign-call "s_open_for_write" f152))) (begin (if (negative? f158) (begin (error (string->symbol "open-output-file") "open failed")) #f) (let ((f162 (make-vector 6)) (f161 1024)) (begin (vector-set! f162 0 (string->symbol "output-port")) (vector-set! f162 1 f152) (vector-set! f162 2 f158) (vector-set! f162 3 (make-string f161)) (vector-set! f162 4 0) (vector-set! f162 5 f161) f162)))))))
# == eliminate-cond  ==>
# (closure (f152) (output-port) (let ((f152 f152)) (begin (if (not (string? f152)) (begin (error (string->symbol "open-output-file") "filename must be a string")) #f) (let ((f158 (foreign-call "s_open_for_write" f152))) (begin (if (negative? f158) (begin (error (string->symbol "open-output-file") "open failed")) #f) (let ((f162 (make-vector 6)) (f161 1024)) (begin (vector-set! f162 0 (string->symbol "output-port")) (vector-set! f162 1 f152) (vector-set! f162 2 f158) (vector-set! f162 3 (make-string f161)) (vector-set! f162 4 0) (vector-set! f162 5 f161) f162)))))))
# == external-symbols  ==>
# (closure (f152) (output-port) (let ((f152 f152)) (begin (if (not (string? f152)) (begin ((primitive-ref error) ((primitive-ref string->symbol) "open-output-file") "filename must be a string")) #f) (let ((f158 (foreign-call "s_open_for_write" f152))) (begin (if ((primitive-ref negative?) f158) (begin ((primitive-ref error) ((primitive-ref string->symbol) "open-output-file") "open failed")) #f) (let ((f162 (make-vector 6)) (f161 1024)) (begin (vector-set! f162 0 ((primitive-ref string->symbol) "output-port")) (vector-set! f162 1 f152) (vector-set! f162 2 f158) (vector-set! f162 3 (make-string f161)) (vector-set! f162 4 0) (vector-set! f162 5 f161) f162)))))))
# emit-expr (closure (f152) (output-port) (let ((f152 f152)) (begin (if (not (string? f152)) (begin ((primitive-ref error) ((primitive-ref string->symbol) "open-output-file") "filename must be a string")) #f) (let ((f158 (foreign-call "s_open_for_write" f152))) (begin (if ((primitive-ref negative?) f158) (begin ((primitive-ref error) ((primitive-ref string->symbol) "open-output-file") "open failed")) #f) (let ((f162 (make-vector 6)) (f161 1024)) (begin (vector-set! f162 0 ((primitive-ref string->symbol) "output-port")) (vector-set! f162 1 f152) (vector-set! f162 2 f158) (vector-set! f162 3 (make-string f161)) (vector-set! f162 4 0) (vector-set! f162 5 f161) f162)))))))
# emit-closure
# si = 0
# env = ()
# expr = (closure (f152) (output-port) (let ((f152 f152)) (begin (if (not (string? f152)) (begin ((primitive-ref error) ((primitive-ref string->symbol) "open-output-file") "filename must be a string")) #f) (let ((f158 (foreign-call "s_open_for_write" f152))) (begin (if ((primitive-ref negative?) f158) (begin ((primitive-ref error) ((primitive-ref string->symbol) "open-output-file") "open failed")) #f) (let ((f162 (make-vector 6)) (f161 1024)) (begin (vector-set! f162 0 ((primitive-ref string->symbol) "output-port")) (vector-set! f162 1 f152) (vector-set! f162 2 f158) (vector-set! f162 3 (make-string f161)) (vector-set! f162 4 0) (vector-set! f162 5 f161) f162)))))))
    movl $_L_1145, 0(%ebp)  # closure label
# WARNING: free var output-port not defined in the environmnet
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $8, %ebp     # bump ebp
    jmp _L_1146            # jump around closure body
_L_1145:
# check argument count
    cmp $4,%eax
    je _L_1147
# invoke error handler eh_argcount
    .extern mrc_eh$uargcount
    movl mrc_eh$uargcount, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_1147:
# emit-tail-expr
# si=-12
# env=((f152 . -8) (output-port . 4))
# expr=(let ((f152 f152)) (begin (if (not (string? f152)) (begin ((primitive-ref error) ((primitive-ref string->symbol) "open-output-file") "filename must be a string")) #f) (let ((f158 (foreign-call "s_open_for_write" f152))) (begin (if ((primitive-ref negative?) f158) (begin ((primitive-ref error) ((primitive-ref string->symbol) "open-output-file") "open failed")) #f) (let ((f162 (make-vector 6)) (f161 1024)) (begin (vector-set! f162 0 ((primitive-ref string->symbol) "output-port")) (vector-set! f162 1 f152) (vector-set! f162 2 f158) (vector-set! f162 3 (make-string f161)) (vector-set! f162 4 0) (vector-set! f162 5 f161) f162))))))
# emit-tail-let
#  si   = -12
#  env  = ((f152 . -8) (output-port . 4))
#  bindings = ((f152 f152))
#  body = (begin (if (not (string? f152)) (begin ((primitive-ref error) ((primitive-ref string->symbol) "open-output-file") "filename must be a string")) #f) (let ((f158 (foreign-call "s_open_for_write" f152))) (begin (if ((primitive-ref negative?) f158) (begin ((primitive-ref error) ((primitive-ref string->symbol) "open-output-file") "open failed")) #f) (let ((f162 (make-vector 6)) (f161 1024)) (begin (vector-set! f162 0 ((primitive-ref string->symbol) "output-port")) (vector-set! f162 1 f152) (vector-set! f162 2 f158) (vector-set! f162 3 (make-string f161)) (vector-set! f162 4 0) (vector-set! f162 5 f161) f162)))))
# emit-expr f152
# emit-variable-ref
# env=((f152 . -8) (output-port . 4))
# var=f152
    movl -8(%esp), %eax  # stack load f152
# end emit-variable-ref
    movl %eax, -12(%esp)  # stack save
# emit-tail-expr
# si=-16
# env=((f152 . -12) (f152 . -8) (output-port . 4))
# expr=(begin (if (not (string? f152)) (begin ((primitive-ref error) ((primitive-ref string->symbol) "open-output-file") "filename must be a string")) #f) (let ((f158 (foreign-call "s_open_for_write" f152))) (begin (if ((primitive-ref negative?) f158) (begin ((primitive-ref error) ((primitive-ref string->symbol) "open-output-file") "open failed")) #f) (let ((f162 (make-vector 6)) (f161 1024)) (begin (vector-set! f162 0 ((primitive-ref string->symbol) "output-port")) (vector-set! f162 1 f152) (vector-set! f162 2 f158) (vector-set! f162 3 (make-string f161)) (vector-set! f162 4 0) (vector-set! f162 5 f161) f162)))))
# tail-begin (begin (if (not (string? f152)) (begin ((primitive-ref error) ((primitive-ref string->symbol) "open-output-file") "filename must be a string")) #f) (let ((f158 (foreign-call "s_open_for_write" f152))) (begin (if ((primitive-ref negative?) f158) (begin ((primitive-ref error) ((primitive-ref string->symbol) "open-output-file") "open failed")) #f) (let ((f162 (make-vector 6)) (f161 1024)) (begin (vector-set! f162 0 ((primitive-ref string->symbol) "output-port")) (vector-set! f162 1 f152) (vector-set! f162 2 f158) (vector-set! f162 3 (make-string f161)) (vector-set! f162 4 0) (vector-set! f162 5 f161) f162)))))
#   env=((f152 . -12) (f152 . -8) (output-port . 4))
# emit-expr (if (not (string? f152)) (begin ((primitive-ref error) ((primitive-ref string->symbol) "open-output-file") "filename must be a string")) #f)
# emit-expr (not (string? f152))
# emit-expr (string? f152)
# emit-expr f152
# emit-variable-ref
# env=((f152 . -12) (f152 . -8) (output-port . 4))
# var=f152
    movl -12(%esp), %eax  # stack load f152
# end emit-variable-ref
    and $7, %al
    cmp $6, %al
    sete %al
    movzbl %al, %eax
    sal $6, %al
    or $47, %al
    cmp $47, %eax
    sete %al
    movzbl %al, %eax
    sal $6, %al
    or $47, %al
    cmp $47, %al
    je _L_1148
# emit-expr (begin ((primitive-ref error) ((primitive-ref string->symbol) "open-output-file") "filename must be a string"))
# emit-begin
#   expr=(begin ((primitive-ref error) ((primitive-ref string->symbol) "open-output-file") "filename must be a string"))
#   env=((f152 . -12) (f152 . -8) (output-port . 4))
# emit-expr ((primitive-ref error) ((primitive-ref string->symbol) "open-output-file") "filename must be a string")
# funcall
#    si   =-16
#    env  = ((f152 . -12) (f152 . -8) (output-port . 4))
#    expr = (funcall (primitive-ref error) ((primitive-ref string->symbol) "open-output-file") "filename must be a string")
# emit-expr (primitive-ref error)
    .extern mrc_error
    movl mrc_error,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1150"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1150":
   movl %eax,  -24(%esp)  # stash funcall-oper in closure slot
# emit-expr ((primitive-ref string->symbol) "open-output-file")
# funcall
#    si   =-28
#    env  = ((f152 . -12) (f152 . -8) (output-port . 4))
#    expr = (funcall (primitive-ref string->symbol) "open-output-file")
# emit-expr (primitive-ref string->symbol)
    .extern mrc_string$m$gsymbol
    movl mrc_string$m$gsymbol,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1151"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1151":
   movl %eax,  -36(%esp)  # stash funcall-oper in closure slot
# emit-expr "open-output-file"
# string literal
    jmp _L_1153
    .align 8,0x90
_L_1152 :
    .int 64
    .ascii "open-output-file"
_L_1153:
    movl $_L_1152, %eax
    orl $6, %eax
    mov %eax, -40(%esp)  # arg open-output-file
    movl -36(%esp), %edi   # load new closure to %edi
    add $-28, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $28, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    mov %eax, -28(%esp)  # arg ((primitive-ref string->symbol) open-output-file)
# emit-expr "filename must be a string"
# string literal
    jmp _L_1155
    .align 8,0x90
_L_1154 :
    .int 100
    .ascii "filename must be a string"
_L_1155:
    movl $_L_1154, %eax
    orl $6, %eax
    mov %eax, -32(%esp)  # arg filename must be a string
    movl -24(%esp), %edi   # load new closure to %edi
    add $-16, %esp   # adjust base
    movl $8,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $16, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
# emit-expr (begin)
# emit-begin
#   expr=(begin)
#   env=((f152 . -12) (f152 . -8) (output-port . 4))
    jmp _L_1149
_L_1148:
# emit-expr #f
    movl $47, %eax     # immed #f
_L_1149:
# emit-tail-expr
# si=-16
# env=((f152 . -12) (f152 . -8) (output-port . 4))
# expr=(begin (let ((f158 (foreign-call "s_open_for_write" f152))) (begin (if ((primitive-ref negative?) f158) (begin ((primitive-ref error) ((primitive-ref string->symbol) "open-output-file") "open failed")) #f) (let ((f162 (make-vector 6)) (f161 1024)) (begin (vector-set! f162 0 ((primitive-ref string->symbol) "output-port")) (vector-set! f162 1 f152) (vector-set! f162 2 f158) (vector-set! f162 3 (make-string f161)) (vector-set! f162 4 0) (vector-set! f162 5 f161) f162)))))
# tail-begin (begin (let ((f158 (foreign-call "s_open_for_write" f152))) (begin (if ((primitive-ref negative?) f158) (begin ((primitive-ref error) ((primitive-ref string->symbol) "open-output-file") "open failed")) #f) (let ((f162 (make-vector 6)) (f161 1024)) (begin (vector-set! f162 0 ((primitive-ref string->symbol) "output-port")) (vector-set! f162 1 f152) (vector-set! f162 2 f158) (vector-set! f162 3 (make-string f161)) (vector-set! f162 4 0) (vector-set! f162 5 f161) f162)))))
#   env=((f152 . -12) (f152 . -8) (output-port . 4))
# emit-tail-expr
# si=-16
# env=((f152 . -12) (f152 . -8) (output-port . 4))
# expr=(let ((f158 (foreign-call "s_open_for_write" f152))) (begin (if ((primitive-ref negative?) f158) (begin ((primitive-ref error) ((primitive-ref string->symbol) "open-output-file") "open failed")) #f) (let ((f162 (make-vector 6)) (f161 1024)) (begin (vector-set! f162 0 ((primitive-ref string->symbol) "output-port")) (vector-set! f162 1 f152) (vector-set! f162 2 f158) (vector-set! f162 3 (make-string f161)) (vector-set! f162 4 0) (vector-set! f162 5 f161) f162))))
# emit-tail-let
#  si   = -16
#  env  = ((f152 . -12) (f152 . -8) (output-port . 4))
#  bindings = ((f158 (foreign-call "s_open_for_write" f152)))
#  body = (begin (if ((primitive-ref negative?) f158) (begin ((primitive-ref error) ((primitive-ref string->symbol) "open-output-file") "open failed")) #f) (let ((f162 (make-vector 6)) (f161 1024)) (begin (vector-set! f162 0 ((primitive-ref string->symbol) "output-port")) (vector-set! f162 1 f152) (vector-set! f162 2 f158) (vector-set! f162 3 (make-string f161)) (vector-set! f162 4 0) (vector-set! f162 5 f161) f162)))
# emit-expr (foreign-call "s_open_for_write" f152)
    movl %ecx,-16(%esp)
    movl %esp,-20(%esp)
# emit-expr f152
# emit-variable-ref
# env=((f152 . -12) (f152 . -8) (output-port . 4))
# var=f152
    movl -12(%esp), %eax  # stack load f152
# end emit-variable-ref
    movl %eax, -24(%esp)
    leal -24(%esp),%edi
    movl %edi,%esi
    andl $-16,%esi
    movl 0(%edi),%eax
    movl %eax,0(%esi)
    movl 4(%edi),%eax
    movl %eax,4(%esi)
    movl %esi,%esp
    .extern _s_open_for_write
    call _s_open_for_write
    movl 4(%esi),%esp
    movl -16(%esp),%ecx
    movl %eax, -16(%esp)  # stack save
# emit-tail-expr
# si=-20
# env=((f158 . -16) (f152 . -12) (f152 . -8) (output-port . 4))
# expr=(begin (if ((primitive-ref negative?) f158) (begin ((primitive-ref error) ((primitive-ref string->symbol) "open-output-file") "open failed")) #f) (let ((f162 (make-vector 6)) (f161 1024)) (begin (vector-set! f162 0 ((primitive-ref string->symbol) "output-port")) (vector-set! f162 1 f152) (vector-set! f162 2 f158) (vector-set! f162 3 (make-string f161)) (vector-set! f162 4 0) (vector-set! f162 5 f161) f162)))
# tail-begin (begin (if ((primitive-ref negative?) f158) (begin ((primitive-ref error) ((primitive-ref string->symbol) "open-output-file") "open failed")) #f) (let ((f162 (make-vector 6)) (f161 1024)) (begin (vector-set! f162 0 ((primitive-ref string->symbol) "output-port")) (vector-set! f162 1 f152) (vector-set! f162 2 f158) (vector-set! f162 3 (make-string f161)) (vector-set! f162 4 0) (vector-set! f162 5 f161) f162)))
#   env=((f158 . -16) (f152 . -12) (f152 . -8) (output-port . 4))
# emit-expr (if ((primitive-ref negative?) f158) (begin ((primitive-ref error) ((primitive-ref string->symbol) "open-output-file") "open failed")) #f)
# emit-expr ((primitive-ref negative?) f158)
# funcall
#    si   =-20
#    env  = ((f158 . -16) (f152 . -12) (f152 . -8) (output-port . 4))
#    expr = (funcall (primitive-ref negative?) f158)
# emit-expr (primitive-ref negative?)
    .extern mrc_negative$q
    movl mrc_negative$q,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1158"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1158":
   movl %eax,  -28(%esp)  # stash funcall-oper in closure slot
# emit-expr f158
# emit-variable-ref
# env=((f158 . -16) (f152 . -12) (f152 . -8) (output-port . 4))
# var=f158
    movl -16(%esp), %eax  # stack load f158
# end emit-variable-ref
    mov %eax, -32(%esp)  # arg f158
    movl -28(%esp), %edi   # load new closure to %edi
    add $-20, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $20, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    cmp $47, %al
    je _L_1156
# emit-expr (begin ((primitive-ref error) ((primitive-ref string->symbol) "open-output-file") "open failed"))
# emit-begin
#   expr=(begin ((primitive-ref error) ((primitive-ref string->symbol) "open-output-file") "open failed"))
#   env=((f158 . -16) (f152 . -12) (f152 . -8) (output-port . 4))
# emit-expr ((primitive-ref error) ((primitive-ref string->symbol) "open-output-file") "open failed")
# funcall
#    si   =-20
#    env  = ((f158 . -16) (f152 . -12) (f152 . -8) (output-port . 4))
#    expr = (funcall (primitive-ref error) ((primitive-ref string->symbol) "open-output-file") "open failed")
# emit-expr (primitive-ref error)
    .extern mrc_error
    movl mrc_error,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1159"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1159":
   movl %eax,  -28(%esp)  # stash funcall-oper in closure slot
# emit-expr ((primitive-ref string->symbol) "open-output-file")
# funcall
#    si   =-32
#    env  = ((f158 . -16) (f152 . -12) (f152 . -8) (output-port . 4))
#    expr = (funcall (primitive-ref string->symbol) "open-output-file")
# emit-expr (primitive-ref string->symbol)
    .extern mrc_string$m$gsymbol
    movl mrc_string$m$gsymbol,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1160"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1160":
   movl %eax,  -40(%esp)  # stash funcall-oper in closure slot
# emit-expr "open-output-file"
# string literal
    jmp _L_1162
    .align 8,0x90
_L_1161 :
    .int 64
    .ascii "open-output-file"
_L_1162:
    movl $_L_1161, %eax
    orl $6, %eax
    mov %eax, -44(%esp)  # arg open-output-file
    movl -40(%esp), %edi   # load new closure to %edi
    add $-32, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $32, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    mov %eax, -32(%esp)  # arg ((primitive-ref string->symbol) open-output-file)
# emit-expr "open failed"
# string literal
    jmp _L_1164
    .align 8,0x90
_L_1163 :
    .int 44
    .ascii "open failed"
_L_1164:
    movl $_L_1163, %eax
    orl $6, %eax
    mov %eax, -36(%esp)  # arg open failed
    movl -28(%esp), %edi   # load new closure to %edi
    add $-20, %esp   # adjust base
    movl $8,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $20, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
# emit-expr (begin)
# emit-begin
#   expr=(begin)
#   env=((f158 . -16) (f152 . -12) (f152 . -8) (output-port . 4))
    jmp _L_1157
_L_1156:
# emit-expr #f
    movl $47, %eax     # immed #f
_L_1157:
# emit-tail-expr
# si=-20
# env=((f158 . -16) (f152 . -12) (f152 . -8) (output-port . 4))
# expr=(begin (let ((f162 (make-vector 6)) (f161 1024)) (begin (vector-set! f162 0 ((primitive-ref string->symbol) "output-port")) (vector-set! f162 1 f152) (vector-set! f162 2 f158) (vector-set! f162 3 (make-string f161)) (vector-set! f162 4 0) (vector-set! f162 5 f161) f162)))
# tail-begin (begin (let ((f162 (make-vector 6)) (f161 1024)) (begin (vector-set! f162 0 ((primitive-ref string->symbol) "output-port")) (vector-set! f162 1 f152) (vector-set! f162 2 f158) (vector-set! f162 3 (make-string f161)) (vector-set! f162 4 0) (vector-set! f162 5 f161) f162)))
#   env=((f158 . -16) (f152 . -12) (f152 . -8) (output-port . 4))
# emit-tail-expr
# si=-20
# env=((f158 . -16) (f152 . -12) (f152 . -8) (output-port . 4))
# expr=(let ((f162 (make-vector 6)) (f161 1024)) (begin (vector-set! f162 0 ((primitive-ref string->symbol) "output-port")) (vector-set! f162 1 f152) (vector-set! f162 2 f158) (vector-set! f162 3 (make-string f161)) (vector-set! f162 4 0) (vector-set! f162 5 f161) f162))
# emit-tail-let
#  si   = -20
#  env  = ((f158 . -16) (f152 . -12) (f152 . -8) (output-port . 4))
#  bindings = ((f162 (make-vector 6)) (f161 1024))
#  body = (begin (vector-set! f162 0 ((primitive-ref string->symbol) "output-port")) (vector-set! f162 1 f152) (vector-set! f162 2 f158) (vector-set! f162 3 (make-string f161)) (vector-set! f162 4 0) (vector-set! f162 5 f161) f162)
# emit-expr (make-vector 6)
# make-vector 6
# emit-expr 6
    movl $24, %eax     # immed 6
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1165"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1165:
# check the argument is a fixnum >= 0
    cmp $0,%eax
    jge _L_1166
# invoke error handler eh_length
    .extern mrc_eh$ulength
    movl mrc_eh$ulength, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1166:
    movl %eax, %esi
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    orl  $5, %eax
    addl $4, %esi
    addl $4, %esi
    andl $-8, %esi
    addl %esi, %ebp
    movl %eax, -20(%esp)  # stack save
# emit-expr 1024
    movl $4096, %eax     # immed 1024
    movl %eax, -24(%esp)  # stack save
# emit-tail-expr
# si=-28
# env=((f161 . -24) (f162 . -20) (f158 . -16) (f152 . -12) (f152 . -8) (output-port . 4))
# expr=(begin (vector-set! f162 0 ((primitive-ref string->symbol) "output-port")) (vector-set! f162 1 f152) (vector-set! f162 2 f158) (vector-set! f162 3 (make-string f161)) (vector-set! f162 4 0) (vector-set! f162 5 f161) f162)
# tail-begin (begin (vector-set! f162 0 ((primitive-ref string->symbol) "output-port")) (vector-set! f162 1 f152) (vector-set! f162 2 f158) (vector-set! f162 3 (make-string f161)) (vector-set! f162 4 0) (vector-set! f162 5 f161) f162)
#   env=((f161 . -24) (f162 . -20) (f158 . -16) (f152 . -12) (f152 . -8) (output-port . 4))
# emit-expr (vector-set! f162 0 ((primitive-ref string->symbol) "output-port"))
# emit-expr f162
# emit-variable-ref
# env=((f161 . -24) (f162 . -20) (f158 . -16) (f152 . -12) (f152 . -8) (output-port . 4))
# var=f162
    movl -20(%esp), %eax  # stack load f162
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1167
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1167:
    movl %eax, -28(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1168"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1168:
# check bounds on vector index
    movl -28(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1170
    cmp  $0,%eax
    jge _L_1169
_L_1170:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1169:
    movl %eax, -32(%esp)
# emit-expr ((primitive-ref string->symbol) "output-port")
# funcall
#    si   =-36
#    env  = ((f161 . -24) (f162 . -20) (f158 . -16) (f152 . -12) (f152 . -8) (output-port . 4))
#    expr = (funcall (primitive-ref string->symbol) "output-port")
# emit-expr (primitive-ref string->symbol)
    .extern mrc_string$m$gsymbol
    movl mrc_string$m$gsymbol,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1171"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1171":
   movl %eax,  -44(%esp)  # stash funcall-oper in closure slot
# emit-expr "output-port"
# string literal
    jmp _L_1173
    .align 8,0x90
_L_1172 :
    .int 44
    .ascii "output-port"
_L_1173:
    movl $_L_1172, %eax
    orl $6, %eax
    mov %eax, -48(%esp)  # arg output-port
    movl -44(%esp), %edi   # load new closure to %edi
    add $-36, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $36, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    movl -28(%esp), %ebx
    movl -32(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-tail-expr
# si=-28
# env=((f161 . -24) (f162 . -20) (f158 . -16) (f152 . -12) (f152 . -8) (output-port . 4))
# expr=(begin (vector-set! f162 1 f152) (vector-set! f162 2 f158) (vector-set! f162 3 (make-string f161)) (vector-set! f162 4 0) (vector-set! f162 5 f161) f162)
# tail-begin (begin (vector-set! f162 1 f152) (vector-set! f162 2 f158) (vector-set! f162 3 (make-string f161)) (vector-set! f162 4 0) (vector-set! f162 5 f161) f162)
#   env=((f161 . -24) (f162 . -20) (f158 . -16) (f152 . -12) (f152 . -8) (output-port . 4))
# emit-expr (vector-set! f162 1 f152)
# emit-expr f162
# emit-variable-ref
# env=((f161 . -24) (f162 . -20) (f158 . -16) (f152 . -12) (f152 . -8) (output-port . 4))
# var=f162
    movl -20(%esp), %eax  # stack load f162
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1174
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1174:
    movl %eax, -28(%esp)
# emit-expr 1
    movl $4, %eax     # immed 1
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1175"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1175:
# check bounds on vector index
    movl -28(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1177
    cmp  $0,%eax
    jge _L_1176
_L_1177:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1176:
    movl %eax, -32(%esp)
# emit-expr f152
# emit-variable-ref
# env=((f161 . -24) (f162 . -20) (f158 . -16) (f152 . -12) (f152 . -8) (output-port . 4))
# var=f152
    movl -12(%esp), %eax  # stack load f152
# end emit-variable-ref
    movl -28(%esp), %ebx
    movl -32(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-tail-expr
# si=-28
# env=((f161 . -24) (f162 . -20) (f158 . -16) (f152 . -12) (f152 . -8) (output-port . 4))
# expr=(begin (vector-set! f162 2 f158) (vector-set! f162 3 (make-string f161)) (vector-set! f162 4 0) (vector-set! f162 5 f161) f162)
# tail-begin (begin (vector-set! f162 2 f158) (vector-set! f162 3 (make-string f161)) (vector-set! f162 4 0) (vector-set! f162 5 f161) f162)
#   env=((f161 . -24) (f162 . -20) (f158 . -16) (f152 . -12) (f152 . -8) (output-port . 4))
# emit-expr (vector-set! f162 2 f158)
# emit-expr f162
# emit-variable-ref
# env=((f161 . -24) (f162 . -20) (f158 . -16) (f152 . -12) (f152 . -8) (output-port . 4))
# var=f162
    movl -20(%esp), %eax  # stack load f162
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1178
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1178:
    movl %eax, -28(%esp)
# emit-expr 2
    movl $8, %eax     # immed 2
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1179"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1179:
# check bounds on vector index
    movl -28(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1181
    cmp  $0,%eax
    jge _L_1180
_L_1181:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1180:
    movl %eax, -32(%esp)
# emit-expr f158
# emit-variable-ref
# env=((f161 . -24) (f162 . -20) (f158 . -16) (f152 . -12) (f152 . -8) (output-port . 4))
# var=f158
    movl -16(%esp), %eax  # stack load f158
# end emit-variable-ref
    movl -28(%esp), %ebx
    movl -32(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-tail-expr
# si=-28
# env=((f161 . -24) (f162 . -20) (f158 . -16) (f152 . -12) (f152 . -8) (output-port . 4))
# expr=(begin (vector-set! f162 3 (make-string f161)) (vector-set! f162 4 0) (vector-set! f162 5 f161) f162)
# tail-begin (begin (vector-set! f162 3 (make-string f161)) (vector-set! f162 4 0) (vector-set! f162 5 f161) f162)
#   env=((f161 . -24) (f162 . -20) (f158 . -16) (f152 . -12) (f152 . -8) (output-port . 4))
# emit-expr (vector-set! f162 3 (make-string f161))
# emit-expr f162
# emit-variable-ref
# env=((f161 . -24) (f162 . -20) (f158 . -16) (f152 . -12) (f152 . -8) (output-port . 4))
# var=f162
    movl -20(%esp), %eax  # stack load f162
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1182
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1182:
    movl %eax, -28(%esp)
# emit-expr 3
    movl $12, %eax     # immed 3
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1183"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1183:
# check bounds on vector index
    movl -28(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1185
    cmp  $0,%eax
    jge _L_1184
_L_1185:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1184:
    movl %eax, -32(%esp)
# emit-expr (make-string f161)
# make-string len=f161
# emit-expr f161
# emit-variable-ref
# env=((f161 . -24) (f162 . -20) (f158 . -16) (f152 . -12) (f152 . -8) (output-port . 4))
# var=f161
    movl -24(%esp), %eax  # stack load f161
# end emit-variable-ref
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1186"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $152,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1186:
# check the argument is a fixnum >= 0
    cmp $0,%eax
    jge _L_1187
# invoke error handler eh_length
    .extern mrc_eh$ulength
    movl mrc_eh$ulength, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $152,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1187:
    movl %eax, %esi
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    orl $6, %eax
    sar $2, %esi
    add $4, %esi
    add $7, %esi
    andl $-8, %esi
    add  %esi, %ebp
# make-string end
    movl -28(%esp), %ebx
    movl -32(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-tail-expr
# si=-28
# env=((f161 . -24) (f162 . -20) (f158 . -16) (f152 . -12) (f152 . -8) (output-port . 4))
# expr=(begin (vector-set! f162 4 0) (vector-set! f162 5 f161) f162)
# tail-begin (begin (vector-set! f162 4 0) (vector-set! f162 5 f161) f162)
#   env=((f161 . -24) (f162 . -20) (f158 . -16) (f152 . -12) (f152 . -8) (output-port . 4))
# emit-expr (vector-set! f162 4 0)
# emit-expr f162
# emit-variable-ref
# env=((f161 . -24) (f162 . -20) (f158 . -16) (f152 . -12) (f152 . -8) (output-port . 4))
# var=f162
    movl -20(%esp), %eax  # stack load f162
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1188
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1188:
    movl %eax, -28(%esp)
# emit-expr 4
    movl $16, %eax     # immed 4
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1189"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1189:
# check bounds on vector index
    movl -28(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1191
    cmp  $0,%eax
    jge _L_1190
_L_1191:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1190:
    movl %eax, -32(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
    movl -28(%esp), %ebx
    movl -32(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-tail-expr
# si=-28
# env=((f161 . -24) (f162 . -20) (f158 . -16) (f152 . -12) (f152 . -8) (output-port . 4))
# expr=(begin (vector-set! f162 5 f161) f162)
# tail-begin (begin (vector-set! f162 5 f161) f162)
#   env=((f161 . -24) (f162 . -20) (f158 . -16) (f152 . -12) (f152 . -8) (output-port . 4))
# emit-expr (vector-set! f162 5 f161)
# emit-expr f162
# emit-variable-ref
# env=((f161 . -24) (f162 . -20) (f158 . -16) (f152 . -12) (f152 . -8) (output-port . 4))
# var=f162
    movl -20(%esp), %eax  # stack load f162
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1192
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1192:
    movl %eax, -28(%esp)
# emit-expr 5
    movl $20, %eax     # immed 5
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1193"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1193:
# check bounds on vector index
    movl -28(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1195
    cmp  $0,%eax
    jge _L_1194
_L_1195:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1194:
    movl %eax, -32(%esp)
# emit-expr f161
# emit-variable-ref
# env=((f161 . -24) (f162 . -20) (f158 . -16) (f152 . -12) (f152 . -8) (output-port . 4))
# var=f161
    movl -24(%esp), %eax  # stack load f161
# end emit-variable-ref
    movl -28(%esp), %ebx
    movl -32(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-tail-expr
# si=-28
# env=((f161 . -24) (f162 . -20) (f158 . -16) (f152 . -12) (f152 . -8) (output-port . 4))
# expr=(begin f162)
# tail-begin (begin f162)
#   env=((f161 . -24) (f162 . -20) (f158 . -16) (f152 . -12) (f152 . -8) (output-port . 4))
# emit-tail-expr
# si=-28
# env=((f161 . -24) (f162 . -20) (f158 . -16) (f152 . -12) (f152 . -8) (output-port . 4))
# expr=f162
# emit-tail-variable-ref
# emit-variable-ref
# env=((f161 . -24) (f162 . -20) (f158 . -16) (f152 . -12) (f152 . -8) (output-port . 4))
# var=f162
    movl -20(%esp), %eax  # stack load f162
# end emit-variable-ref
    ret
# end emit-tail-variable ref
     ret   # return thru stack
     ret   # return thru stack
     ret   # return thru stack
    .align 4,0x90
_L_1146:
     movl %eax, mrc_open$moutput$mfile
# == explicit-begins  ==>
# (lambda (p) (foreign-call "s_close" (port-fd p)))
# == eliminate-let*  ==>
# (lambda (p) (foreign-call "s_close" (port-fd p)))
# == uniquify-variables  ==>
# (lambda (f163) (foreign-call "s_close" (port-fd f163)))
# == vectorize-letrec  ==>
# (lambda (f163) (foreign-call "s_close" (port-fd f163)))
# == eliminate-set!  ==>
# (lambda (f163) (let ((f163 f163)) (foreign-call "s_close" (port-fd f163))))
# == close-free-variables  ==>
# (closure (f163) () (let ((f163 f163)) (foreign-call "s_close" (port-fd f163))))
# == eliminate-quote  ==>
# (closure (f163) () (let ((f163 f163)) (foreign-call "s_close" (port-fd f163))))
# == eliminate-when/unless  ==>
# (closure (f163) () (let ((f163 f163)) (foreign-call "s_close" (port-fd f163))))
# == eliminate-cond  ==>
# (closure (f163) () (let ((f163 f163)) (foreign-call "s_close" (port-fd f163))))
# == external-symbols  ==>
# (closure (f163) () (let ((f163 f163)) (foreign-call "s_close" ((primitive-ref port-fd) f163))))
# emit-expr (closure (f163) () (let ((f163 f163)) (foreign-call "s_close" ((primitive-ref port-fd) f163))))
# emit-closure
# si = 0
# env = ()
# expr = (closure (f163) () (let ((f163 f163)) (foreign-call "s_close" ((primitive-ref port-fd) f163))))
    movl $_L_1196, 0(%ebp)  # closure label
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $8, %ebp     # bump ebp
    jmp _L_1197            # jump around closure body
_L_1196:
# check argument count
    cmp $4,%eax
    je _L_1198
# invoke error handler eh_argcount
    .extern mrc_eh$uargcount
    movl mrc_eh$uargcount, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_1198:
# emit-tail-expr
# si=-12
# env=((f163 . -8))
# expr=(let ((f163 f163)) (foreign-call "s_close" ((primitive-ref port-fd) f163)))
# emit-tail-let
#  si   = -12
#  env  = ((f163 . -8))
#  bindings = ((f163 f163))
#  body = (foreign-call "s_close" ((primitive-ref port-fd) f163))
# emit-expr f163
# emit-variable-ref
# env=((f163 . -8))
# var=f163
    movl -8(%esp), %eax  # stack load f163
# end emit-variable-ref
    movl %eax, -12(%esp)  # stack save
# emit-tail-expr
# si=-16
# env=((f163 . -12) (f163 . -8))
# expr=(foreign-call "s_close" ((primitive-ref port-fd) f163))
    movl %ecx,-16(%esp)
    movl %esp,-20(%esp)
# emit-expr ((primitive-ref port-fd) f163)
# funcall
#    si   =-24
#    env  = ((f163 . -12) (f163 . -8))
#    expr = (funcall (primitive-ref port-fd) f163)
# emit-expr (primitive-ref port-fd)
    .extern mrc_port$mfd
    movl mrc_port$mfd,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1199"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1199":
   movl %eax,  -32(%esp)  # stash funcall-oper in closure slot
# emit-expr f163
# emit-variable-ref
# env=((f163 . -12) (f163 . -8))
# var=f163
    movl -12(%esp), %eax  # stack load f163
# end emit-variable-ref
    mov %eax, -36(%esp)  # arg f163
    movl -32(%esp), %edi   # load new closure to %edi
    add $-24, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $24, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    movl %eax, -24(%esp)
    leal -24(%esp),%edi
    movl %edi,%esi
    andl $-16,%esi
    movl 0(%edi),%eax
    movl %eax,0(%esi)
    movl 4(%edi),%eax
    movl %eax,4(%esi)
    movl %esi,%esp
    .extern _s_close
    call _s_close
    movl 4(%esi),%esp
    movl -16(%esp),%ecx
     ret
    .align 4,0x90
_L_1197:
     movl %eax, mrc_close$minput$mport
# == explicit-begins  ==>
# (lambda (p) (begin (flush-output-port p) (foreign-call "s_close" (port-fd p))))
# == eliminate-let*  ==>
# (lambda (p) (begin (flush-output-port p) (foreign-call "s_close" (port-fd p))))
# == uniquify-variables  ==>
# (lambda (f164) (begin (flush-output-port f164) (foreign-call "s_close" (port-fd f164))))
# == vectorize-letrec  ==>
# (lambda (f164) (begin (flush-output-port f164) (foreign-call "s_close" (port-fd f164))))
# == eliminate-set!  ==>
# (lambda (f164) (let ((f164 f164)) (begin (flush-output-port f164) (foreign-call "s_close" (port-fd f164)))))
# == close-free-variables  ==>
# (closure (f164) () (let ((f164 f164)) (begin (flush-output-port f164) (foreign-call "s_close" (port-fd f164)))))
# == eliminate-quote  ==>
# (closure (f164) () (let ((f164 f164)) (begin (flush-output-port f164) (foreign-call "s_close" (port-fd f164)))))
# == eliminate-when/unless  ==>
# (closure (f164) () (let ((f164 f164)) (begin (flush-output-port f164) (foreign-call "s_close" (port-fd f164)))))
# == eliminate-cond  ==>
# (closure (f164) () (let ((f164 f164)) (begin (flush-output-port f164) (foreign-call "s_close" (port-fd f164)))))
# == external-symbols  ==>
# (closure (f164) () (let ((f164 f164)) (begin ((primitive-ref flush-output-port) f164) (foreign-call "s_close" ((primitive-ref port-fd) f164)))))
# emit-expr (closure (f164) () (let ((f164 f164)) (begin ((primitive-ref flush-output-port) f164) (foreign-call "s_close" ((primitive-ref port-fd) f164)))))
# emit-closure
# si = 0
# env = ()
# expr = (closure (f164) () (let ((f164 f164)) (begin ((primitive-ref flush-output-port) f164) (foreign-call "s_close" ((primitive-ref port-fd) f164)))))
    movl $_L_1200, 0(%ebp)  # closure label
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $8, %ebp     # bump ebp
    jmp _L_1201            # jump around closure body
_L_1200:
# check argument count
    cmp $4,%eax
    je _L_1202
# invoke error handler eh_argcount
    .extern mrc_eh$uargcount
    movl mrc_eh$uargcount, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_1202:
# emit-tail-expr
# si=-12
# env=((f164 . -8))
# expr=(let ((f164 f164)) (begin ((primitive-ref flush-output-port) f164) (foreign-call "s_close" ((primitive-ref port-fd) f164))))
# emit-tail-let
#  si   = -12
#  env  = ((f164 . -8))
#  bindings = ((f164 f164))
#  body = (begin ((primitive-ref flush-output-port) f164) (foreign-call "s_close" ((primitive-ref port-fd) f164)))
# emit-expr f164
# emit-variable-ref
# env=((f164 . -8))
# var=f164
    movl -8(%esp), %eax  # stack load f164
# end emit-variable-ref
    movl %eax, -12(%esp)  # stack save
# emit-tail-expr
# si=-16
# env=((f164 . -12) (f164 . -8))
# expr=(begin ((primitive-ref flush-output-port) f164) (foreign-call "s_close" ((primitive-ref port-fd) f164)))
# tail-begin (begin ((primitive-ref flush-output-port) f164) (foreign-call "s_close" ((primitive-ref port-fd) f164)))
#   env=((f164 . -12) (f164 . -8))
# emit-expr ((primitive-ref flush-output-port) f164)
# funcall
#    si   =-16
#    env  = ((f164 . -12) (f164 . -8))
#    expr = (funcall (primitive-ref flush-output-port) f164)
# emit-expr (primitive-ref flush-output-port)
    .extern mrc_flush$moutput$mport
    movl mrc_flush$moutput$mport,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1203"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1203":
   movl %eax,  -24(%esp)  # stash funcall-oper in closure slot
# emit-expr f164
# emit-variable-ref
# env=((f164 . -12) (f164 . -8))
# var=f164
    movl -12(%esp), %eax  # stack load f164
# end emit-variable-ref
    mov %eax, -28(%esp)  # arg f164
    movl -24(%esp), %edi   # load new closure to %edi
    add $-16, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $16, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
# emit-tail-expr
# si=-16
# env=((f164 . -12) (f164 . -8))
# expr=(begin (foreign-call "s_close" ((primitive-ref port-fd) f164)))
# tail-begin (begin (foreign-call "s_close" ((primitive-ref port-fd) f164)))
#   env=((f164 . -12) (f164 . -8))
# emit-tail-expr
# si=-16
# env=((f164 . -12) (f164 . -8))
# expr=(foreign-call "s_close" ((primitive-ref port-fd) f164))
    movl %ecx,-16(%esp)
    movl %esp,-20(%esp)
# emit-expr ((primitive-ref port-fd) f164)
# funcall
#    si   =-24
#    env  = ((f164 . -12) (f164 . -8))
#    expr = (funcall (primitive-ref port-fd) f164)
# emit-expr (primitive-ref port-fd)
    .extern mrc_port$mfd
    movl mrc_port$mfd,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1204"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1204":
   movl %eax,  -32(%esp)  # stash funcall-oper in closure slot
# emit-expr f164
# emit-variable-ref
# env=((f164 . -12) (f164 . -8))
# var=f164
    movl -12(%esp), %eax  # stack load f164
# end emit-variable-ref
    mov %eax, -36(%esp)  # arg f164
    movl -32(%esp), %edi   # load new closure to %edi
    add $-24, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $24, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    movl %eax, -24(%esp)
    leal -24(%esp),%edi
    movl %edi,%esi
    andl $-16,%esi
    movl 0(%edi),%eax
    movl %eax,0(%esi)
    movl 4(%edi),%eax
    movl %eax,4(%esi)
    movl %esi,%esp
    .extern _s_close
    call _s_close
    movl 4(%esi),%esp
    movl -16(%esp),%ecx
     ret
     ret   # return thru stack
    .align 4,0x90
_L_1201:
     movl %eax, mrc_close$moutput$mport
# == explicit-begins  ==>
# (letrec ((print-boolean (lambda (expr p) (begin (write-char #\# p) (if expr (write-char #\t p) (write-char #\f p))))) (print-null (lambda (p) (begin (write-char #\( p) (write-char #\) p)))) (print-char (lambda (expr p) (begin (write-char #\# p) (write-char #\\ p) (write-char expr p)))) (print-fixnum (lambda (i p) (if (negative? i) (begin (write-char #\- p) (print-fixnum (fx* -1 i) p)) (map (lambda (x) (write-char (fixnum->char (fx+ (char->fixnum #\0) x)) p)) (integer->list i))))) (print-string (lambda (s p) (begin (write-char #\" p) (for-each (lambda (c) (write-char c p)) (string->list s)) (write-char #\" p)))) (print-string-alpha (lambda (s p) (for-each (lambda (c) (write-char c p)) (string->list s)))) (print-pair (lambda (pr p) (begin (write-char #\( p) (print-pairs pr p) (write-char #\) p)))) (print-pairs (lambda (pr p) (begin (write (car pr) p) (cond ((null? (cdr pr)) #t) ((pair? (cdr pr)) (begin (write-char #\space p) (print-pairs (cdr pr) p))) (else (begin (write-char #\space p) (write-char #\. p) (write-char #\space p) (write (cdr pr) p)))))))) (lambda (expr p alpha) (cond ((boolean? expr) (print-boolean expr p)) ((null? expr) (print-null p)) ((char? expr) (if alpha (write-char expr p) (print-char expr p))) ((fixnum? expr) (print-fixnum expr p)) ((string? expr) (if alpha (print-string-alpha expr p) (print-string expr p))) ((pair? expr) (print-pair expr p)) (else (error (quote write) "unrecognized expression")))))
# == eliminate-let*  ==>
# (letrec ((print-boolean (lambda (expr p) (begin (write-char #\# p) (if expr (write-char #\t p) (write-char #\f p))))) (print-null (lambda (p) (begin (write-char #\( p) (write-char #\) p)))) (print-char (lambda (expr p) (begin (write-char #\# p) (write-char #\\ p) (write-char expr p)))) (print-fixnum (lambda (i p) (if (negative? i) (begin (write-char #\- p) (print-fixnum (fx* -1 i) p)) (map (lambda (x) (write-char (fixnum->char (fx+ (char->fixnum #\0) x)) p)) (integer->list i))))) (print-string (lambda (s p) (begin (write-char #\" p) (for-each (lambda (c) (write-char c p)) (string->list s)) (write-char #\" p)))) (print-string-alpha (lambda (s p) (for-each (lambda (c) (write-char c p)) (string->list s)))) (print-pair (lambda (pr p) (begin (write-char #\( p) (print-pairs pr p) (write-char #\) p)))) (print-pairs (lambda (pr p) (begin (write (car pr) p) (cond ((null? (cdr pr)) #t) ((pair? (cdr pr)) (begin (write-char #\space p) (print-pairs (cdr pr) p))) (else (begin (write-char #\space p) (write-char #\. p) (write-char #\space p) (write (cdr pr) p)))))))) (lambda (expr p alpha) (cond ((boolean? expr) (print-boolean expr p)) ((null? expr) (print-null p)) ((char? expr) (if alpha (write-char expr p) (print-char expr p))) ((fixnum? expr) (print-fixnum expr p)) ((string? expr) (if alpha (print-string-alpha expr p) (print-string expr p))) ((pair? expr) (print-pair expr p)) (else (error (quote write) "unrecognized expression")))))
# == uniquify-variables  ==>
<<<<<<< HEAD
# (letrec ((f310959 (lambda (f311001 f311000) (begin (write-char #\# f311000) (if f311001 (write-char #\t f311000) (write-char #\f f311000))))) (f310958 (lambda (f310999) (begin (write-char #\( f310999) (write-char #\) f310999)))) (f310957 (lambda (f310998 f310997) (begin (write-char #\# f310997) (write-char #\\ f310997) (write-char f310998 f310997)))) (f310956 (lambda (f310994 f310993) (if (negative? f310994) (begin (write-char #\- f310993) (f310956 (fx* -1 f310994) f310993)) (map (lambda (f310996) (write-char (fixnum->char (fx+ (char->fixnum #\0) f310996)) f310993)) (integer->list f310994))))) (f310955 (lambda (f310990 f310989) (begin (write-char #\" f310989) (for-each (lambda (f310992) (write-char f310992 f310989)) (string->list f310990)) (write-char #\" f310989)))) (f310954 (lambda (f310986 f310985) (for-each (lambda (f310988) (write-char f310988 f310985)) (string->list f310986)))) (f310953 (lambda (f310984 f310983) (begin (write-char #\( f310983) (f310952 f310984 f310983) (write-char #\) f310983)))) (f310952 (lambda (f310982 f310981) (begin (write (car f310982) f310981) (cond ((null? (cdr f310982)) #t) ((pair? (cdr f310982)) (begin (write-char #\space f310981) (f310952 (cdr f310982) f310981))) (else (begin (write-char #\space f310981) (write-char #\. f310981) (write-char #\space f310981) (write (cdr f310982) f310981)))))))) (lambda (f311007 f311006 f311005) (cond ((boolean? f311007) (f310959 f311007 f311006)) ((null? f311007) (f310958 f311006)) ((char? f311007) (if f311005 (write-char f311007 f311006) (f310957 f311007 f311006))) ((fixnum? f311007) (f310956 f311007 f311006)) ((string? f311007) (if f311005 (f310954 f311007 f311006) (f310955 f311007 f311006))) ((pair? f311007) (f310953 f311007 f311006)) (else (error (quote write) "unrecognized expression")))))
# == vectorize-letrec  ==>
# (let ((f310959 (make-vector 1)) (f310958 (make-vector 1)) (f310957 (make-vector 1)) (f310956 (make-vector 1)) (f310955 (make-vector 1)) (f310954 (make-vector 1)) (f310953 (make-vector 1)) (f310952 (make-vector 1))) (begin (begin (vector-set! f310959 0 (lambda (f311001 f311000) (begin (write-char #\# f311000) (if f311001 (write-char #\t f311000) (write-char #\f f311000))))) (vector-set! f310958 0 (lambda (f310999) (begin (write-char #\( f310999) (write-char #\) f310999)))) (vector-set! f310957 0 (lambda (f310998 f310997) (begin (write-char #\# f310997) (write-char #\\ f310997) (write-char f310998 f310997)))) (vector-set! f310956 0 (lambda (f310994 f310993) (if (negative? f310994) (begin (write-char #\- f310993) ((vector-ref f310956 0) (fx* -1 f310994) f310993)) (map (lambda (f310996) (write-char (fixnum->char (fx+ (char->fixnum #\0) f310996)) f310993)) (integer->list f310994))))) (vector-set! f310955 0 (lambda (f310990 f310989) (begin (write-char #\" f310989) (for-each (lambda (f310992) (write-char f310992 f310989)) (string->list f310990)) (write-char #\" f310989)))) (vector-set! f310954 0 (lambda (f310986 f310985) (for-each (lambda (f310988) (write-char f310988 f310985)) (string->list f310986)))) (vector-set! f310953 0 (lambda (f310984 f310983) (begin (write-char #\( f310983) ((vector-ref f310952 0) f310984 f310983) (write-char #\) f310983)))) (vector-set! f310952 0 (lambda (f310982 f310981) (begin (write (car f310982) f310981) (cond ((null? (cdr f310982)) #t) ((pair? (cdr f310982)) (begin (write-char #\space f310981) ((vector-ref f310952 0) (cdr f310982) f310981))) (else (begin (write-char #\space f310981) (write-char #\. f310981) (write-char #\space f310981) (write (cdr f310982) f310981)))))))) (lambda (f311007 f311006 f311005) (cond ((boolean? f311007) ((vector-ref f310959 0) f311007 f311006)) ((null? f311007) ((vector-ref f310958 0) f311006)) ((char? f311007) (if f311005 (write-char f311007 f311006) ((vector-ref f310957 0) f311007 f311006))) ((fixnum? f311007) ((vector-ref f310956 0) f311007 f311006)) ((string? f311007) (if f311005 ((vector-ref f310954 0) f311007 f311006) ((vector-ref f310955 0) f311007 f311006))) ((pair? f311007) ((vector-ref f310953 0) f311007 f311006)) (else (error (quote write) "unrecognized expression"))))))
# == eliminate-set!  ==>
# (let ((f310959 (make-vector 1)) (f310958 (make-vector 1)) (f310957 (make-vector 1)) (f310956 (make-vector 1)) (f310955 (make-vector 1)) (f310954 (make-vector 1)) (f310953 (make-vector 1)) (f310952 (make-vector 1))) (begin (begin (vector-set! f310959 0 (lambda (f311001 f311000) (let ((f311001 f311001) (f311000 f311000)) (begin (write-char #\# f311000) (if f311001 (write-char #\t f311000) (write-char #\f f311000)))))) (vector-set! f310958 0 (lambda (f310999) (let ((f310999 f310999)) (begin (write-char #\( f310999) (write-char #\) f310999))))) (vector-set! f310957 0 (lambda (f310998 f310997) (let ((f310998 f310998) (f310997 f310997)) (begin (write-char #\# f310997) (write-char #\\ f310997) (write-char f310998 f310997))))) (vector-set! f310956 0 (lambda (f310994 f310993) (let ((f310994 f310994) (f310993 f310993)) (if (negative? f310994) (begin (write-char #\- f310993) ((vector-ref f310956 0) (fx* -1 f310994) f310993)) (map (lambda (f310996) (let ((f310996 f310996)) (write-char (fixnum->char (fx+ (char->fixnum #\0) f310996)) f310993))) (integer->list f310994)))))) (vector-set! f310955 0 (lambda (f310990 f310989) (let ((f310990 f310990) (f310989 f310989)) (begin (write-char #\" f310989) (for-each (lambda (f310992) (let ((f310992 f310992)) (write-char f310992 f310989))) (string->list f310990)) (write-char #\" f310989))))) (vector-set! f310954 0 (lambda (f310986 f310985) (let ((f310986 f310986) (f310985 f310985)) (for-each (lambda (f310988) (let ((f310988 f310988)) (write-char f310988 f310985))) (string->list f310986))))) (vector-set! f310953 0 (lambda (f310984 f310983) (let ((f310984 f310984) (f310983 f310983)) (begin (write-char #\( f310983) ((vector-ref f310952 0) f310984 f310983) (write-char #\) f310983))))) (vector-set! f310952 0 (lambda (f310982 f310981) (let ((f310982 f310982) (f310981 f310981)) (begin (write (car f310982) f310981) (cond ((null? (cdr f310982)) #t) ((pair? (cdr f310982)) (begin (write-char #\space f310981) ((vector-ref f310952 0) (cdr f310982) f310981))) (else (begin (write-char #\space f310981) (write-char #\. f310981) (write-char #\space f310981) (write (cdr f310982) f310981))))))))) (lambda (f311007 f311006 f311005) (let ((f311007 f311007) (f311006 f311006) (f311005 f311005)) (cond ((boolean? f311007) ((vector-ref f310959 0) f311007 f311006)) ((null? f311007) ((vector-ref f310958 0) f311006)) ((char? f311007) (if f311005 (write-char f311007 f311006) ((vector-ref f310957 0) f311007 f311006))) ((fixnum? f311007) ((vector-ref f310956 0) f311007 f311006)) ((string? f311007) (if f311005 ((vector-ref f310954 0) f311007 f311006) ((vector-ref f310955 0) f311007 f311006))) ((pair? f311007) ((vector-ref f310953 0) f311007 f311006)) (else (error (quote write) "unrecognized expression")))))))
# == close-free-variables  ==>
# (let ((f310959 (make-vector 1)) (f310958 (make-vector 1)) (f310957 (make-vector 1)) (f310956 (make-vector 1)) (f310955 (make-vector 1)) (f310954 (make-vector 1)) (f310953 (make-vector 1)) (f310952 (make-vector 1))) (begin (begin (vector-set! f310959 0 (closure (f311001 f311000) () (let ((f311001 f311001) (f311000 f311000)) (begin (write-char #\# f311000) (if f311001 (write-char #\t f311000) (write-char #\f f311000)))))) (vector-set! f310958 0 (closure (f310999) () (let ((f310999 f310999)) (begin (write-char #\( f310999) (write-char #\) f310999))))) (vector-set! f310957 0 (closure (f310998 f310997) () (let ((f310998 f310998) (f310997 f310997)) (begin (write-char #\# f310997) (write-char #\\ f310997) (write-char f310998 f310997))))) (vector-set! f310956 0 (closure (f310994 f310993) (f310956) (let ((f310994 f310994) (f310993 f310993)) (if (negative? f310994) (begin (write-char #\- f310993) ((vector-ref f310956 0) (fx* -1 f310994) f310993)) (map (closure (f310996) (f310993) (let ((f310996 f310996)) (write-char (fixnum->char (fx+ (char->fixnum #\0) f310996)) f310993))) (integer->list f310994)))))) (vector-set! f310955 0 (closure (f310990 f310989) () (let ((f310990 f310990) (f310989 f310989)) (begin (write-char #\" f310989) (for-each (closure (f310992) (f310989) (let ((f310992 f310992)) (write-char f310992 f310989))) (string->list f310990)) (write-char #\" f310989))))) (vector-set! f310954 0 (closure (f310986 f310985) () (let ((f310986 f310986) (f310985 f310985)) (for-each (closure (f310988) (f310985) (let ((f310988 f310988)) (write-char f310988 f310985))) (string->list f310986))))) (vector-set! f310953 0 (closure (f310984 f310983) (f310952) (let ((f310984 f310984) (f310983 f310983)) (begin (write-char #\( f310983) ((vector-ref f310952 0) f310984 f310983) (write-char #\) f310983))))) (vector-set! f310952 0 (closure (f310982 f310981) (f310952) (let ((f310982 f310982) (f310981 f310981)) (begin (write (car f310982) f310981) (cond ((null? (cdr f310982)) #t) ((pair? (cdr f310982)) (begin (write-char #\space f310981) ((vector-ref f310952 0) (cdr f310982) f310981))) (else (begin (write-char #\space f310981) (write-char #\. f310981) (write-char #\space f310981) (write (cdr f310982) f310981))))))))) (closure (f311007 f311006 f311005) (f310959 f310958 f310957 f310956 f310954 f310955 f310953) (let ((f311007 f311007) (f311006 f311006) (f311005 f311005)) (cond ((boolean? f311007) ((vector-ref f310959 0) f311007 f311006)) ((null? f311007) ((vector-ref f310958 0) f311006)) ((char? f311007) (if f311005 (write-char f311007 f311006) ((vector-ref f310957 0) f311007 f311006))) ((fixnum? f311007) ((vector-ref f310956 0) f311007 f311006)) ((string? f311007) (if f311005 ((vector-ref f310954 0) f311007 f311006) ((vector-ref f310955 0) f311007 f311006))) ((pair? f311007) ((vector-ref f310953 0) f311007 f311006)) (else (error (quote write) "unrecognized expression")))))))
# == eliminate-quote  ==>
# (let ((f310959 (make-vector 1)) (f310958 (make-vector 1)) (f310957 (make-vector 1)) (f310956 (make-vector 1)) (f310955 (make-vector 1)) (f310954 (make-vector 1)) (f310953 (make-vector 1)) (f310952 (make-vector 1))) (begin (begin (vector-set! f310959 0 (closure (f311001 f311000) () (let ((f311001 f311001) (f311000 f311000)) (begin (write-char #\# f311000) (if f311001 (write-char #\t f311000) (write-char #\f f311000)))))) (vector-set! f310958 0 (closure (f310999) () (let ((f310999 f310999)) (begin (write-char #\( f310999) (write-char #\) f310999))))) (vector-set! f310957 0 (closure (f310998 f310997) () (let ((f310998 f310998) (f310997 f310997)) (begin (write-char #\# f310997) (write-char #\\ f310997) (write-char f310998 f310997))))) (vector-set! f310956 0 (closure (f310994 f310993) (f310956) (let ((f310994 f310994) (f310993 f310993)) (if (negative? f310994) (begin (write-char #\- f310993) ((vector-ref f310956 0) (fx* -1 f310994) f310993)) (map (closure (f310996) (f310993) (let ((f310996 f310996)) (write-char (fixnum->char (fx+ (char->fixnum #\0) f310996)) f310993))) (integer->list f310994)))))) (vector-set! f310955 0 (closure (f310990 f310989) () (let ((f310990 f310990) (f310989 f310989)) (begin (write-char #\" f310989) (for-each (closure (f310992) (f310989) (let ((f310992 f310992)) (write-char f310992 f310989))) (string->list f310990)) (write-char #\" f310989))))) (vector-set! f310954 0 (closure (f310986 f310985) () (let ((f310986 f310986) (f310985 f310985)) (for-each (closure (f310988) (f310985) (let ((f310988 f310988)) (write-char f310988 f310985))) (string->list f310986))))) (vector-set! f310953 0 (closure (f310984 f310983) (f310952) (let ((f310984 f310984) (f310983 f310983)) (begin (write-char #\( f310983) ((vector-ref f310952 0) f310984 f310983) (write-char #\) f310983))))) (vector-set! f310952 0 (closure (f310982 f310981) (f310952) (let ((f310982 f310982) (f310981 f310981)) (begin (write (car f310982) f310981) (cond ((null? (cdr f310982)) #t) ((pair? (cdr f310982)) (begin (write-char #\space f310981) ((vector-ref f310952 0) (cdr f310982) f310981))) (else (begin (write-char #\space f310981) (write-char #\. f310981) (write-char #\space f310981) (write (cdr f310982) f310981))))))))) (closure (f311007 f311006 f311005) (f310959 f310958 f310957 f310956 f310954 f310955 f310953) (let ((f311007 f311007) (f311006 f311006) (f311005 f311005)) (cond ((boolean? f311007) ((vector-ref f310959 0) f311007 f311006)) ((null? f311007) ((vector-ref f310958 0) f311006)) ((char? f311007) (if f311005 (write-char f311007 f311006) ((vector-ref f310957 0) f311007 f311006))) ((fixnum? f311007) ((vector-ref f310956 0) f311007 f311006)) ((string? f311007) (if f311005 ((vector-ref f310954 0) f311007 f311006) ((vector-ref f310955 0) f311007 f311006))) ((pair? f311007) ((vector-ref f310953 0) f311007 f311006)) (else (error (string->symbol "write") "unrecognized expression")))))))
# == eliminate-when/unless  ==>
# (let ((f310959 (make-vector 1)) (f310958 (make-vector 1)) (f310957 (make-vector 1)) (f310956 (make-vector 1)) (f310955 (make-vector 1)) (f310954 (make-vector 1)) (f310953 (make-vector 1)) (f310952 (make-vector 1))) (begin (begin (vector-set! f310959 0 (closure (f311001 f311000) () (let ((f311001 f311001) (f311000 f311000)) (begin (write-char #\# f311000) (if f311001 (write-char #\t f311000) (write-char #\f f311000)))))) (vector-set! f310958 0 (closure (f310999) () (let ((f310999 f310999)) (begin (write-char #\( f310999) (write-char #\) f310999))))) (vector-set! f310957 0 (closure (f310998 f310997) () (let ((f310998 f310998) (f310997 f310997)) (begin (write-char #\# f310997) (write-char #\\ f310997) (write-char f310998 f310997))))) (vector-set! f310956 0 (closure (f310994 f310993) (f310956) (let ((f310994 f310994) (f310993 f310993)) (if (negative? f310994) (begin (write-char #\- f310993) ((vector-ref f310956 0) (fx* -1 f310994) f310993)) (map (closure (f310996) (f310993) (let ((f310996 f310996)) (write-char (fixnum->char (fx+ (char->fixnum #\0) f310996)) f310993))) (integer->list f310994)))))) (vector-set! f310955 0 (closure (f310990 f310989) () (let ((f310990 f310990) (f310989 f310989)) (begin (write-char #\" f310989) (for-each (closure (f310992) (f310989) (let ((f310992 f310992)) (write-char f310992 f310989))) (string->list f310990)) (write-char #\" f310989))))) (vector-set! f310954 0 (closure (f310986 f310985) () (let ((f310986 f310986) (f310985 f310985)) (for-each (closure (f310988) (f310985) (let ((f310988 f310988)) (write-char f310988 f310985))) (string->list f310986))))) (vector-set! f310953 0 (closure (f310984 f310983) (f310952) (let ((f310984 f310984) (f310983 f310983)) (begin (write-char #\( f310983) ((vector-ref f310952 0) f310984 f310983) (write-char #\) f310983))))) (vector-set! f310952 0 (closure (f310982 f310981) (f310952) (let ((f310982 f310982) (f310981 f310981)) (begin (write (car f310982) f310981) (cond ((null? (cdr f310982)) #t) ((pair? (cdr f310982)) (begin (write-char #\space f310981) ((vector-ref f310952 0) (cdr f310982) f310981))) (else (begin (write-char #\space f310981) (write-char #\. f310981) (write-char #\space f310981) (write (cdr f310982) f310981))))))))) (closure (f311007 f311006 f311005) (f310959 f310958 f310957 f310956 f310954 f310955 f310953) (let ((f311007 f311007) (f311006 f311006) (f311005 f311005)) (cond ((boolean? f311007) ((vector-ref f310959 0) f311007 f311006)) ((null? f311007) ((vector-ref f310958 0) f311006)) ((char? f311007) (if f311005 (write-char f311007 f311006) ((vector-ref f310957 0) f311007 f311006))) ((fixnum? f311007) ((vector-ref f310956 0) f311007 f311006)) ((string? f311007) (if f311005 ((vector-ref f310954 0) f311007 f311006) ((vector-ref f310955 0) f311007 f311006))) ((pair? f311007) ((vector-ref f310953 0) f311007 f311006)) (else (error (string->symbol "write") "unrecognized expression")))))))
# == eliminate-cond  ==>
# (let ((f310959 (make-vector 1)) (f310958 (make-vector 1)) (f310957 (make-vector 1)) (f310956 (make-vector 1)) (f310955 (make-vector 1)) (f310954 (make-vector 1)) (f310953 (make-vector 1)) (f310952 (make-vector 1))) (begin (begin (vector-set! f310959 0 (closure (f311001 f311000) () (let ((f311001 f311001) (f311000 f311000)) (begin (write-char #\# f311000) (if f311001 (write-char #\t f311000) (write-char #\f f311000)))))) (vector-set! f310958 0 (closure (f310999) () (let ((f310999 f310999)) (begin (write-char #\( f310999) (write-char #\) f310999))))) (vector-set! f310957 0 (closure (f310998 f310997) () (let ((f310998 f310998) (f310997 f310997)) (begin (write-char #\# f310997) (write-char #\\ f310997) (write-char f310998 f310997))))) (vector-set! f310956 0 (closure (f310994 f310993) (f310956) (let ((f310994 f310994) (f310993 f310993)) (if (negative? f310994) (begin (write-char #\- f310993) ((vector-ref f310956 0) (fx* -1 f310994) f310993)) (map (closure (f310996) (f310993) (let ((f310996 f310996)) (write-char (fixnum->char (fx+ (char->fixnum #\0) f310996)) f310993))) (integer->list f310994)))))) (vector-set! f310955 0 (closure (f310990 f310989) () (let ((f310990 f310990) (f310989 f310989)) (begin (write-char #\" f310989) (for-each (closure (f310992) (f310989) (let ((f310992 f310992)) (write-char f310992 f310989))) (string->list f310990)) (write-char #\" f310989))))) (vector-set! f310954 0 (closure (f310986 f310985) () (let ((f310986 f310986) (f310985 f310985)) (for-each (closure (f310988) (f310985) (let ((f310988 f310988)) (write-char f310988 f310985))) (string->list f310986))))) (vector-set! f310953 0 (closure (f310984 f310983) (f310952) (let ((f310984 f310984) (f310983 f310983)) (begin (write-char #\( f310983) ((vector-ref f310952 0) f310984 f310983) (write-char #\) f310983))))) (vector-set! f310952 0 (closure (f310982 f310981) (f310952) (let ((f310982 f310982) (f310981 f310981)) (begin (write (car f310982) f310981) (if (null? (cdr f310982)) #t (if (pair? (cdr f310982)) (begin (write-char #\space f310981) ((vector-ref f310952 0) (cdr f310982) f310981)) (begin (write-char #\space f310981) (write-char #\. f310981) (write-char #\space f310981) (write (cdr f310982) f310981))))))))) (closure (f311007 f311006 f311005) (f310959 f310958 f310957 f310956 f310954 f310955 f310953) (let ((f311007 f311007) (f311006 f311006) (f311005 f311005)) (if (boolean? f311007) ((vector-ref f310959 0) f311007 f311006) (if (null? f311007) ((vector-ref f310958 0) f311006) (if (char? f311007) (if f311005 (write-char f311007 f311006) ((vector-ref f310957 0) f311007 f311006)) (if (fixnum? f311007) ((vector-ref f310956 0) f311007 f311006) (if (string? f311007) (if f311005 ((vector-ref f310954 0) f311007 f311006) ((vector-ref f310955 0) f311007 f311006)) (if (pair? f311007) ((vector-ref f310953 0) f311007 f311006) (error (string->symbol "write") "unrecognized expression")))))))))))
# == external-symbols  ==>
# (let ((f310959 (make-vector 1)) (f310958 (make-vector 1)) (f310957 (make-vector 1)) (f310956 (make-vector 1)) (f310955 (make-vector 1)) (f310954 (make-vector 1)) (f310953 (make-vector 1)) (f310952 (make-vector 1))) (begin (begin (vector-set! f310959 0 (closure (f311001 f311000) () (let ((f311001 f311001) (f311000 f311000)) (begin ((primitive-ref write-char) #\# f311000) (if f311001 ((primitive-ref write-char) #\t f311000) ((primitive-ref write-char) #\f f311000)))))) (vector-set! f310958 0 (closure (f310999) () (let ((f310999 f310999)) (begin ((primitive-ref write-char) #\( f310999) ((primitive-ref write-char) #\) f310999))))) (vector-set! f310957 0 (closure (f310998 f310997) () (let ((f310998 f310998) (f310997 f310997)) (begin ((primitive-ref write-char) #\# f310997) ((primitive-ref write-char) #\\ f310997) ((primitive-ref write-char) f310998 f310997))))) (vector-set! f310956 0 (closure (f310994 f310993) (f310956) (let ((f310994 f310994) (f310993 f310993)) (if ((primitive-ref negative?) f310994) (begin ((primitive-ref write-char) #\- f310993) ((vector-ref f310956 0) (fx* -1 f310994) f310993)) ((primitive-ref map) (closure (f310996) (f310993) (let ((f310996 f310996)) ((primitive-ref write-char) (fixnum->char (fx+ (char->fixnum #\0) f310996)) f310993))) ((primitive-ref integer->list) f310994)))))) (vector-set! f310955 0 (closure (f310990 f310989) () (let ((f310990 f310990) (f310989 f310989)) (begin ((primitive-ref write-char) #\" f310989) ((primitive-ref for-each) (closure (f310992) (f310989) (let ((f310992 f310992)) ((primitive-ref write-char) f310992 f310989))) ((primitive-ref string->list) f310990)) ((primitive-ref write-char) #\" f310989))))) (vector-set! f310954 0 (closure (f310986 f310985) () (let ((f310986 f310986) (f310985 f310985)) ((primitive-ref for-each) (closure (f310988) (f310985) (let ((f310988 f310988)) ((primitive-ref write-char) f310988 f310985))) ((primitive-ref string->list) f310986))))) (vector-set! f310953 0 (closure (f310984 f310983) (f310952) (let ((f310984 f310984) (f310983 f310983)) (begin ((primitive-ref write-char) #\( f310983) ((vector-ref f310952 0) f310984 f310983) ((primitive-ref write-char) #\) f310983))))) (vector-set! f310952 0 (closure (f310982 f310981) (f310952) (let ((f310982 f310982) (f310981 f310981)) (begin ((primitive-ref write) (car f310982) f310981) (if (null? (cdr f310982)) #t (if (pair? (cdr f310982)) (begin ((primitive-ref write-char) #\space f310981) ((vector-ref f310952 0) (cdr f310982) f310981)) (begin ((primitive-ref write-char) #\space f310981) ((primitive-ref write-char) #\. f310981) ((primitive-ref write-char) #\space f310981) ((primitive-ref write) (cdr f310982) f310981))))))))) (closure (f311007 f311006 f311005) (f310959 f310958 f310957 f310956 f310954 f310955 f310953) (let ((f311007 f311007) (f311006 f311006) (f311005 f311005)) (if (boolean? f311007) ((vector-ref f310959 0) f311007 f311006) (if (null? f311007) ((vector-ref f310958 0) f311006) (if (char? f311007) (if f311005 ((primitive-ref write-char) f311007 f311006) ((vector-ref f310957 0) f311007 f311006)) (if (fixnum? f311007) ((vector-ref f310956 0) f311007 f311006) (if (string? f311007) (if f311005 ((vector-ref f310954 0) f311007 f311006) ((vector-ref f310955 0) f311007 f311006)) (if (pair? f311007) ((vector-ref f310953 0) f311007 f311006) ((primitive-ref error) ((primitive-ref string->symbol) "write") "unrecognized expression")))))))))))
# emit-expr (let ((f310959 (make-vector 1)) (f310958 (make-vector 1)) (f310957 (make-vector 1)) (f310956 (make-vector 1)) (f310955 (make-vector 1)) (f310954 (make-vector 1)) (f310953 (make-vector 1)) (f310952 (make-vector 1))) (begin (begin (vector-set! f310959 0 (closure (f311001 f311000) () (let ((f311001 f311001) (f311000 f311000)) (begin ((primitive-ref write-char) #\# f311000) (if f311001 ((primitive-ref write-char) #\t f311000) ((primitive-ref write-char) #\f f311000)))))) (vector-set! f310958 0 (closure (f310999) () (let ((f310999 f310999)) (begin ((primitive-ref write-char) #\( f310999) ((primitive-ref write-char) #\) f310999))))) (vector-set! f310957 0 (closure (f310998 f310997) () (let ((f310998 f310998) (f310997 f310997)) (begin ((primitive-ref write-char) #\# f310997) ((primitive-ref write-char) #\\ f310997) ((primitive-ref write-char) f310998 f310997))))) (vector-set! f310956 0 (closure (f310994 f310993) (f310956) (let ((f310994 f310994) (f310993 f310993)) (if ((primitive-ref negative?) f310994) (begin ((primitive-ref write-char) #\- f310993) ((vector-ref f310956 0) (fx* -1 f310994) f310993)) ((primitive-ref map) (closure (f310996) (f310993) (let ((f310996 f310996)) ((primitive-ref write-char) (fixnum->char (fx+ (char->fixnum #\0) f310996)) f310993))) ((primitive-ref integer->list) f310994)))))) (vector-set! f310955 0 (closure (f310990 f310989) () (let ((f310990 f310990) (f310989 f310989)) (begin ((primitive-ref write-char) #\" f310989) ((primitive-ref for-each) (closure (f310992) (f310989) (let ((f310992 f310992)) ((primitive-ref write-char) f310992 f310989))) ((primitive-ref string->list) f310990)) ((primitive-ref write-char) #\" f310989))))) (vector-set! f310954 0 (closure (f310986 f310985) () (let ((f310986 f310986) (f310985 f310985)) ((primitive-ref for-each) (closure (f310988) (f310985) (let ((f310988 f310988)) ((primitive-ref write-char) f310988 f310985))) ((primitive-ref string->list) f310986))))) (vector-set! f310953 0 (closure (f310984 f310983) (f310952) (let ((f310984 f310984) (f310983 f310983)) (begin ((primitive-ref write-char) #\( f310983) ((vector-ref f310952 0) f310984 f310983) ((primitive-ref write-char) #\) f310983))))) (vector-set! f310952 0 (closure (f310982 f310981) (f310952) (let ((f310982 f310982) (f310981 f310981)) (begin ((primitive-ref write) (car f310982) f310981) (if (null? (cdr f310982)) #t (if (pair? (cdr f310982)) (begin ((primitive-ref write-char) #\space f310981) ((vector-ref f310952 0) (cdr f310982) f310981)) (begin ((primitive-ref write-char) #\space f310981) ((primitive-ref write-char) #\. f310981) ((primitive-ref write-char) #\space f310981) ((primitive-ref write) (cdr f310982) f310981))))))))) (closure (f311007 f311006 f311005) (f310959 f310958 f310957 f310956 f310954 f310955 f310953) (let ((f311007 f311007) (f311006 f311006) (f311005 f311005)) (if (boolean? f311007) ((vector-ref f310959 0) f311007 f311006) (if (null? f311007) ((vector-ref f310958 0) f311006) (if (char? f311007) (if f311005 ((primitive-ref write-char) f311007 f311006) ((vector-ref f310957 0) f311007 f311006)) (if (fixnum? f311007) ((vector-ref f310956 0) f311007 f311006) (if (string? f311007) (if f311005 ((vector-ref f310954 0) f311007 f311006) ((vector-ref f310955 0) f311007 f311006)) (if (pair? f311007) ((vector-ref f310953 0) f311007 f311006) ((primitive-ref error) ((primitive-ref string->symbol) "write") "unrecognized expression")))))))))))
# emit-let
#  si   = 0
#  env  = ()
#  bindings = ((f310959 (make-vector 1)) (f310958 (make-vector 1)) (f310957 (make-vector 1)) (f310956 (make-vector 1)) (f310955 (make-vector 1)) (f310954 (make-vector 1)) (f310953 (make-vector 1)) (f310952 (make-vector 1)))
#  body = (begin (begin (vector-set! f310959 0 (closure (f311001 f311000) () (let ((f311001 f311001) (f311000 f311000)) (begin ((primitive-ref write-char) #\# f311000) (if f311001 ((primitive-ref write-char) #\t f311000) ((primitive-ref write-char) #\f f311000)))))) (vector-set! f310958 0 (closure (f310999) () (let ((f310999 f310999)) (begin ((primitive-ref write-char) #\( f310999) ((primitive-ref write-char) #\) f310999))))) (vector-set! f310957 0 (closure (f310998 f310997) () (let ((f310998 f310998) (f310997 f310997)) (begin ((primitive-ref write-char) #\# f310997) ((primitive-ref write-char) #\\ f310997) ((primitive-ref write-char) f310998 f310997))))) (vector-set! f310956 0 (closure (f310994 f310993) (f310956) (let ((f310994 f310994) (f310993 f310993)) (if ((primitive-ref negative?) f310994) (begin ((primitive-ref write-char) #\- f310993) ((vector-ref f310956 0) (fx* -1 f310994) f310993)) ((primitive-ref map) (closure (f310996) (f310993) (let ((f310996 f310996)) ((primitive-ref write-char) (fixnum->char (fx+ (char->fixnum #\0) f310996)) f310993))) ((primitive-ref integer->list) f310994)))))) (vector-set! f310955 0 (closure (f310990 f310989) () (let ((f310990 f310990) (f310989 f310989)) (begin ((primitive-ref write-char) #\" f310989) ((primitive-ref for-each) (closure (f310992) (f310989) (let ((f310992 f310992)) ((primitive-ref write-char) f310992 f310989))) ((primitive-ref string->list) f310990)) ((primitive-ref write-char) #\" f310989))))) (vector-set! f310954 0 (closure (f310986 f310985) () (let ((f310986 f310986) (f310985 f310985)) ((primitive-ref for-each) (closure (f310988) (f310985) (let ((f310988 f310988)) ((primitive-ref write-char) f310988 f310985))) ((primitive-ref string->list) f310986))))) (vector-set! f310953 0 (closure (f310984 f310983) (f310952) (let ((f310984 f310984) (f310983 f310983)) (begin ((primitive-ref write-char) #\( f310983) ((vector-ref f310952 0) f310984 f310983) ((primitive-ref write-char) #\) f310983))))) (vector-set! f310952 0 (closure (f310982 f310981) (f310952) (let ((f310982 f310982) (f310981 f310981)) (begin ((primitive-ref write) (car f310982) f310981) (if (null? (cdr f310982)) #t (if (pair? (cdr f310982)) (begin ((primitive-ref write-char) #\space f310981) ((vector-ref f310952 0) (cdr f310982) f310981)) (begin ((primitive-ref write-char) #\space f310981) ((primitive-ref write-char) #\. f310981) ((primitive-ref write-char) #\space f310981) ((primitive-ref write) (cdr f310982) f310981))))))))) (closure (f311007 f311006 f311005) (f310959 f310958 f310957 f310956 f310954 f310955 f310953) (let ((f311007 f311007) (f311006 f311006) (f311005 f311005)) (if (boolean? f311007) ((vector-ref f310959 0) f311007 f311006) (if (null? f311007) ((vector-ref f310958 0) f311006) (if (char? f311007) (if f311005 ((primitive-ref write-char) f311007 f311006) ((vector-ref f310957 0) f311007 f311006)) (if (fixnum? f311007) ((vector-ref f310956 0) f311007 f311006) (if (string? f311007) (if f311005 ((vector-ref f310954 0) f311007 f311006) ((vector-ref f310955 0) f311007 f311006)) (if (pair? f311007) ((vector-ref f310953 0) f311007 f311006) ((primitive-ref error) ((primitive-ref string->symbol) "write") "unrecognized expression"))))))))))
=======
# (letrec ((f172 (lambda (f213 f214) (begin (write-char #\# f214) (if f213 (write-char #\t f214) (write-char #\f f214))))) (f171 (lambda (f212) (begin (write-char #\( f212) (write-char #\) f212)))) (f170 (lambda (f210 f211) (begin (write-char #\# f211) (write-char #\\ f211) (write-char f210 f211)))) (f169 (lambda (f206 f207) (if (negative? f206) (begin (write-char #\- f207) (f169 (fx* -1 f206) f207)) (map (lambda (f209) (write-char (fixnum->char (fx+ (char->fixnum #\0) f209)) f207)) (integer->list f206))))) (f168 (lambda (f202 f203) (begin (write-char #\" f203) (for-each (lambda (f205) (write-char f205 f203)) (string->list f202)) (write-char #\" f203)))) (f167 (lambda (f198 f199) (for-each (lambda (f201) (write-char f201 f199)) (string->list f198)))) (f166 (lambda (f196 f197) (begin (write-char #\( f197) (f165 f196 f197) (write-char #\) f197)))) (f165 (lambda (f194 f195) (begin (write (car f194) f195) (cond ((null? (cdr f194)) #t) ((pair? (cdr f194)) (begin (write-char #\space f195) (f165 (cdr f194) f195))) (else (begin (write-char #\space f195) (write-char #\. f195) (write-char #\space f195) (write (cdr f194) f195)))))))) (lambda (f218 f219 f220) (cond ((boolean? f218) (f172 f218 f219)) ((null? f218) (f171 f219)) ((char? f218) (if f220 (write-char f218 f219) (f170 f218 f219))) ((fixnum? f218) (f169 f218 f219)) ((string? f218) (if f220 (f167 f218 f219) (f168 f218 f219))) ((pair? f218) (f166 f218 f219)) (else (error (quote write) "unrecognized expression")))))
# == vectorize-letrec  ==>
# (let ((f172 (make-vector 1)) (f171 (make-vector 1)) (f170 (make-vector 1)) (f169 (make-vector 1)) (f168 (make-vector 1)) (f167 (make-vector 1)) (f166 (make-vector 1)) (f165 (make-vector 1))) (begin (begin (vector-set! f172 0 (lambda (f213 f214) (begin (write-char #\# f214) (if f213 (write-char #\t f214) (write-char #\f f214))))) (vector-set! f171 0 (lambda (f212) (begin (write-char #\( f212) (write-char #\) f212)))) (vector-set! f170 0 (lambda (f210 f211) (begin (write-char #\# f211) (write-char #\\ f211) (write-char f210 f211)))) (vector-set! f169 0 (lambda (f206 f207) (if (negative? f206) (begin (write-char #\- f207) ((vector-ref f169 0) (fx* -1 f206) f207)) (map (lambda (f209) (write-char (fixnum->char (fx+ (char->fixnum #\0) f209)) f207)) (integer->list f206))))) (vector-set! f168 0 (lambda (f202 f203) (begin (write-char #\" f203) (for-each (lambda (f205) (write-char f205 f203)) (string->list f202)) (write-char #\" f203)))) (vector-set! f167 0 (lambda (f198 f199) (for-each (lambda (f201) (write-char f201 f199)) (string->list f198)))) (vector-set! f166 0 (lambda (f196 f197) (begin (write-char #\( f197) ((vector-ref f165 0) f196 f197) (write-char #\) f197)))) (vector-set! f165 0 (lambda (f194 f195) (begin (write (car f194) f195) (cond ((null? (cdr f194)) #t) ((pair? (cdr f194)) (begin (write-char #\space f195) ((vector-ref f165 0) (cdr f194) f195))) (else (begin (write-char #\space f195) (write-char #\. f195) (write-char #\space f195) (write (cdr f194) f195)))))))) (lambda (f218 f219 f220) (cond ((boolean? f218) ((vector-ref f172 0) f218 f219)) ((null? f218) ((vector-ref f171 0) f219)) ((char? f218) (if f220 (write-char f218 f219) ((vector-ref f170 0) f218 f219))) ((fixnum? f218) ((vector-ref f169 0) f218 f219)) ((string? f218) (if f220 ((vector-ref f167 0) f218 f219) ((vector-ref f168 0) f218 f219))) ((pair? f218) ((vector-ref f166 0) f218 f219)) (else (error (quote write) "unrecognized expression"))))))
# == eliminate-set!  ==>
# (let ((f172 (make-vector 1)) (f171 (make-vector 1)) (f170 (make-vector 1)) (f169 (make-vector 1)) (f168 (make-vector 1)) (f167 (make-vector 1)) (f166 (make-vector 1)) (f165 (make-vector 1))) (begin (begin (vector-set! f172 0 (lambda (f213 f214) (let ((f213 f213) (f214 f214)) (begin (write-char #\# f214) (if f213 (write-char #\t f214) (write-char #\f f214)))))) (vector-set! f171 0 (lambda (f212) (let ((f212 f212)) (begin (write-char #\( f212) (write-char #\) f212))))) (vector-set! f170 0 (lambda (f210 f211) (let ((f210 f210) (f211 f211)) (begin (write-char #\# f211) (write-char #\\ f211) (write-char f210 f211))))) (vector-set! f169 0 (lambda (f206 f207) (let ((f206 f206) (f207 f207)) (if (negative? f206) (begin (write-char #\- f207) ((vector-ref f169 0) (fx* -1 f206) f207)) (map (lambda (f209) (let ((f209 f209)) (write-char (fixnum->char (fx+ (char->fixnum #\0) f209)) f207))) (integer->list f206)))))) (vector-set! f168 0 (lambda (f202 f203) (let ((f202 f202) (f203 f203)) (begin (write-char #\" f203) (for-each (lambda (f205) (let ((f205 f205)) (write-char f205 f203))) (string->list f202)) (write-char #\" f203))))) (vector-set! f167 0 (lambda (f198 f199) (let ((f198 f198) (f199 f199)) (for-each (lambda (f201) (let ((f201 f201)) (write-char f201 f199))) (string->list f198))))) (vector-set! f166 0 (lambda (f196 f197) (let ((f196 f196) (f197 f197)) (begin (write-char #\( f197) ((vector-ref f165 0) f196 f197) (write-char #\) f197))))) (vector-set! f165 0 (lambda (f194 f195) (let ((f194 f194) (f195 f195)) (begin (write (car f194) f195) (cond ((null? (cdr f194)) #t) ((pair? (cdr f194)) (begin (write-char #\space f195) ((vector-ref f165 0) (cdr f194) f195))) (else (begin (write-char #\space f195) (write-char #\. f195) (write-char #\space f195) (write (cdr f194) f195))))))))) (lambda (f218 f219 f220) (let ((f218 f218) (f219 f219) (f220 f220)) (cond ((boolean? f218) ((vector-ref f172 0) f218 f219)) ((null? f218) ((vector-ref f171 0) f219)) ((char? f218) (if f220 (write-char f218 f219) ((vector-ref f170 0) f218 f219))) ((fixnum? f218) ((vector-ref f169 0) f218 f219)) ((string? f218) (if f220 ((vector-ref f167 0) f218 f219) ((vector-ref f168 0) f218 f219))) ((pair? f218) ((vector-ref f166 0) f218 f219)) (else (error (quote write) "unrecognized expression")))))))
# == close-free-variables  ==>
# (let ((f172 (make-vector 1)) (f171 (make-vector 1)) (f170 (make-vector 1)) (f169 (make-vector 1)) (f168 (make-vector 1)) (f167 (make-vector 1)) (f166 (make-vector 1)) (f165 (make-vector 1))) (begin (begin (vector-set! f172 0 (closure (f213 f214) () (let ((f213 f213) (f214 f214)) (begin (write-char #\# f214) (if f213 (write-char #\t f214) (write-char #\f f214)))))) (vector-set! f171 0 (closure (f212) () (let ((f212 f212)) (begin (write-char #\( f212) (write-char #\) f212))))) (vector-set! f170 0 (closure (f210 f211) () (let ((f210 f210) (f211 f211)) (begin (write-char #\# f211) (write-char #\\ f211) (write-char f210 f211))))) (vector-set! f169 0 (closure (f206 f207) (f169) (let ((f206 f206) (f207 f207)) (if (negative? f206) (begin (write-char #\- f207) ((vector-ref f169 0) (fx* -1 f206) f207)) (map (closure (f209) (f207) (let ((f209 f209)) (write-char (fixnum->char (fx+ (char->fixnum #\0) f209)) f207))) (integer->list f206)))))) (vector-set! f168 0 (closure (f202 f203) () (let ((f202 f202) (f203 f203)) (begin (write-char #\" f203) (for-each (closure (f205) (f203) (let ((f205 f205)) (write-char f205 f203))) (string->list f202)) (write-char #\" f203))))) (vector-set! f167 0 (closure (f198 f199) () (let ((f198 f198) (f199 f199)) (for-each (closure (f201) (f199) (let ((f201 f201)) (write-char f201 f199))) (string->list f198))))) (vector-set! f166 0 (closure (f196 f197) (f165) (let ((f196 f196) (f197 f197)) (begin (write-char #\( f197) ((vector-ref f165 0) f196 f197) (write-char #\) f197))))) (vector-set! f165 0 (closure (f194 f195) (f165) (let ((f194 f194) (f195 f195)) (begin (write (car f194) f195) (cond ((null? (cdr f194)) #t) ((pair? (cdr f194)) (begin (write-char #\space f195) ((vector-ref f165 0) (cdr f194) f195))) (else (begin (write-char #\space f195) (write-char #\. f195) (write-char #\space f195) (write (cdr f194) f195))))))))) (closure (f218 f219 f220) (f172 f171 f170 f169 f167 f168 f166) (let ((f218 f218) (f219 f219) (f220 f220)) (cond ((boolean? f218) ((vector-ref f172 0) f218 f219)) ((null? f218) ((vector-ref f171 0) f219)) ((char? f218) (if f220 (write-char f218 f219) ((vector-ref f170 0) f218 f219))) ((fixnum? f218) ((vector-ref f169 0) f218 f219)) ((string? f218) (if f220 ((vector-ref f167 0) f218 f219) ((vector-ref f168 0) f218 f219))) ((pair? f218) ((vector-ref f166 0) f218 f219)) (else (error (quote write) "unrecognized expression")))))))
# == eliminate-quote  ==>
# (let ((f172 (make-vector 1)) (f171 (make-vector 1)) (f170 (make-vector 1)) (f169 (make-vector 1)) (f168 (make-vector 1)) (f167 (make-vector 1)) (f166 (make-vector 1)) (f165 (make-vector 1))) (begin (begin (vector-set! f172 0 (closure (f213 f214) () (let ((f213 f213) (f214 f214)) (begin (write-char #\# f214) (if f213 (write-char #\t f214) (write-char #\f f214)))))) (vector-set! f171 0 (closure (f212) () (let ((f212 f212)) (begin (write-char #\( f212) (write-char #\) f212))))) (vector-set! f170 0 (closure (f210 f211) () (let ((f210 f210) (f211 f211)) (begin (write-char #\# f211) (write-char #\\ f211) (write-char f210 f211))))) (vector-set! f169 0 (closure (f206 f207) (f169) (let ((f206 f206) (f207 f207)) (if (negative? f206) (begin (write-char #\- f207) ((vector-ref f169 0) (fx* -1 f206) f207)) (map (closure (f209) (f207) (let ((f209 f209)) (write-char (fixnum->char (fx+ (char->fixnum #\0) f209)) f207))) (integer->list f206)))))) (vector-set! f168 0 (closure (f202 f203) () (let ((f202 f202) (f203 f203)) (begin (write-char #\" f203) (for-each (closure (f205) (f203) (let ((f205 f205)) (write-char f205 f203))) (string->list f202)) (write-char #\" f203))))) (vector-set! f167 0 (closure (f198 f199) () (let ((f198 f198) (f199 f199)) (for-each (closure (f201) (f199) (let ((f201 f201)) (write-char f201 f199))) (string->list f198))))) (vector-set! f166 0 (closure (f196 f197) (f165) (let ((f196 f196) (f197 f197)) (begin (write-char #\( f197) ((vector-ref f165 0) f196 f197) (write-char #\) f197))))) (vector-set! f165 0 (closure (f194 f195) (f165) (let ((f194 f194) (f195 f195)) (begin (write (car f194) f195) (cond ((null? (cdr f194)) #t) ((pair? (cdr f194)) (begin (write-char #\space f195) ((vector-ref f165 0) (cdr f194) f195))) (else (begin (write-char #\space f195) (write-char #\. f195) (write-char #\space f195) (write (cdr f194) f195))))))))) (closure (f218 f219 f220) (f172 f171 f170 f169 f167 f168 f166) (let ((f218 f218) (f219 f219) (f220 f220)) (cond ((boolean? f218) ((vector-ref f172 0) f218 f219)) ((null? f218) ((vector-ref f171 0) f219)) ((char? f218) (if f220 (write-char f218 f219) ((vector-ref f170 0) f218 f219))) ((fixnum? f218) ((vector-ref f169 0) f218 f219)) ((string? f218) (if f220 ((vector-ref f167 0) f218 f219) ((vector-ref f168 0) f218 f219))) ((pair? f218) ((vector-ref f166 0) f218 f219)) (else (error (string->symbol "write") "unrecognized expression")))))))
# == eliminate-when/unless  ==>
# (let ((f172 (make-vector 1)) (f171 (make-vector 1)) (f170 (make-vector 1)) (f169 (make-vector 1)) (f168 (make-vector 1)) (f167 (make-vector 1)) (f166 (make-vector 1)) (f165 (make-vector 1))) (begin (begin (vector-set! f172 0 (closure (f213 f214) () (let ((f213 f213) (f214 f214)) (begin (write-char #\# f214) (if f213 (write-char #\t f214) (write-char #\f f214)))))) (vector-set! f171 0 (closure (f212) () (let ((f212 f212)) (begin (write-char #\( f212) (write-char #\) f212))))) (vector-set! f170 0 (closure (f210 f211) () (let ((f210 f210) (f211 f211)) (begin (write-char #\# f211) (write-char #\\ f211) (write-char f210 f211))))) (vector-set! f169 0 (closure (f206 f207) (f169) (let ((f206 f206) (f207 f207)) (if (negative? f206) (begin (write-char #\- f207) ((vector-ref f169 0) (fx* -1 f206) f207)) (map (closure (f209) (f207) (let ((f209 f209)) (write-char (fixnum->char (fx+ (char->fixnum #\0) f209)) f207))) (integer->list f206)))))) (vector-set! f168 0 (closure (f202 f203) () (let ((f202 f202) (f203 f203)) (begin (write-char #\" f203) (for-each (closure (f205) (f203) (let ((f205 f205)) (write-char f205 f203))) (string->list f202)) (write-char #\" f203))))) (vector-set! f167 0 (closure (f198 f199) () (let ((f198 f198) (f199 f199)) (for-each (closure (f201) (f199) (let ((f201 f201)) (write-char f201 f199))) (string->list f198))))) (vector-set! f166 0 (closure (f196 f197) (f165) (let ((f196 f196) (f197 f197)) (begin (write-char #\( f197) ((vector-ref f165 0) f196 f197) (write-char #\) f197))))) (vector-set! f165 0 (closure (f194 f195) (f165) (let ((f194 f194) (f195 f195)) (begin (write (car f194) f195) (cond ((null? (cdr f194)) #t) ((pair? (cdr f194)) (begin (write-char #\space f195) ((vector-ref f165 0) (cdr f194) f195))) (else (begin (write-char #\space f195) (write-char #\. f195) (write-char #\space f195) (write (cdr f194) f195))))))))) (closure (f218 f219 f220) (f172 f171 f170 f169 f167 f168 f166) (let ((f218 f218) (f219 f219) (f220 f220)) (cond ((boolean? f218) ((vector-ref f172 0) f218 f219)) ((null? f218) ((vector-ref f171 0) f219)) ((char? f218) (if f220 (write-char f218 f219) ((vector-ref f170 0) f218 f219))) ((fixnum? f218) ((vector-ref f169 0) f218 f219)) ((string? f218) (if f220 ((vector-ref f167 0) f218 f219) ((vector-ref f168 0) f218 f219))) ((pair? f218) ((vector-ref f166 0) f218 f219)) (else (error (string->symbol "write") "unrecognized expression")))))))
# == eliminate-cond  ==>
# (let ((f172 (make-vector 1)) (f171 (make-vector 1)) (f170 (make-vector 1)) (f169 (make-vector 1)) (f168 (make-vector 1)) (f167 (make-vector 1)) (f166 (make-vector 1)) (f165 (make-vector 1))) (begin (begin (vector-set! f172 0 (closure (f213 f214) () (let ((f213 f213) (f214 f214)) (begin (write-char #\# f214) (if f213 (write-char #\t f214) (write-char #\f f214)))))) (vector-set! f171 0 (closure (f212) () (let ((f212 f212)) (begin (write-char #\( f212) (write-char #\) f212))))) (vector-set! f170 0 (closure (f210 f211) () (let ((f210 f210) (f211 f211)) (begin (write-char #\# f211) (write-char #\\ f211) (write-char f210 f211))))) (vector-set! f169 0 (closure (f206 f207) (f169) (let ((f206 f206) (f207 f207)) (if (negative? f206) (begin (write-char #\- f207) ((vector-ref f169 0) (fx* -1 f206) f207)) (map (closure (f209) (f207) (let ((f209 f209)) (write-char (fixnum->char (fx+ (char->fixnum #\0) f209)) f207))) (integer->list f206)))))) (vector-set! f168 0 (closure (f202 f203) () (let ((f202 f202) (f203 f203)) (begin (write-char #\" f203) (for-each (closure (f205) (f203) (let ((f205 f205)) (write-char f205 f203))) (string->list f202)) (write-char #\" f203))))) (vector-set! f167 0 (closure (f198 f199) () (let ((f198 f198) (f199 f199)) (for-each (closure (f201) (f199) (let ((f201 f201)) (write-char f201 f199))) (string->list f198))))) (vector-set! f166 0 (closure (f196 f197) (f165) (let ((f196 f196) (f197 f197)) (begin (write-char #\( f197) ((vector-ref f165 0) f196 f197) (write-char #\) f197))))) (vector-set! f165 0 (closure (f194 f195) (f165) (let ((f194 f194) (f195 f195)) (begin (write (car f194) f195) (if (null? (cdr f194)) (begin #t) (if (pair? (cdr f194)) (begin (begin (write-char #\space f195) ((vector-ref f165 0) (cdr f194) f195))) (begin (begin (write-char #\space f195) (write-char #\. f195) (write-char #\space f195) (write (cdr f194) f195)))))))))) (closure (f218 f219 f220) (f172 f171 f170 f169 f167 f168 f166) (let ((f218 f218) (f219 f219) (f220 f220)) (if (boolean? f218) (begin ((vector-ref f172 0) f218 f219)) (if (null? f218) (begin ((vector-ref f171 0) f219)) (if (char? f218) (begin (if f220 (write-char f218 f219) ((vector-ref f170 0) f218 f219))) (if (fixnum? f218) (begin ((vector-ref f169 0) f218 f219)) (if (string? f218) (begin (if f220 ((vector-ref f167 0) f218 f219) ((vector-ref f168 0) f218 f219))) (if (pair? f218) (begin ((vector-ref f166 0) f218 f219)) (begin (error (string->symbol "write") "unrecognized expression"))))))))))))
# == external-symbols  ==>
# (let ((f172 (make-vector 1)) (f171 (make-vector 1)) (f170 (make-vector 1)) (f169 (make-vector 1)) (f168 (make-vector 1)) (f167 (make-vector 1)) (f166 (make-vector 1)) (f165 (make-vector 1))) (begin (begin (vector-set! f172 0 (closure (f213 f214) () (let ((f213 f213) (f214 f214)) (begin ((primitive-ref write-char) #\# f214) (if f213 ((primitive-ref write-char) #\t f214) ((primitive-ref write-char) #\f f214)))))) (vector-set! f171 0 (closure (f212) () (let ((f212 f212)) (begin ((primitive-ref write-char) #\( f212) ((primitive-ref write-char) #\) f212))))) (vector-set! f170 0 (closure (f210 f211) () (let ((f210 f210) (f211 f211)) (begin ((primitive-ref write-char) #\# f211) ((primitive-ref write-char) #\\ f211) ((primitive-ref write-char) f210 f211))))) (vector-set! f169 0 (closure (f206 f207) (f169) (let ((f206 f206) (f207 f207)) (if ((primitive-ref negative?) f206) (begin ((primitive-ref write-char) #\- f207) ((vector-ref f169 0) (fx* -1 f206) f207)) ((primitive-ref map) (closure (f209) (f207) (let ((f209 f209)) ((primitive-ref write-char) (fixnum->char (fx+ (char->fixnum #\0) f209)) f207))) ((primitive-ref integer->list) f206)))))) (vector-set! f168 0 (closure (f202 f203) () (let ((f202 f202) (f203 f203)) (begin ((primitive-ref write-char) #\" f203) ((primitive-ref for-each) (closure (f205) (f203) (let ((f205 f205)) ((primitive-ref write-char) f205 f203))) ((primitive-ref string->list) f202)) ((primitive-ref write-char) #\" f203))))) (vector-set! f167 0 (closure (f198 f199) () (let ((f198 f198) (f199 f199)) ((primitive-ref for-each) (closure (f201) (f199) (let ((f201 f201)) ((primitive-ref write-char) f201 f199))) ((primitive-ref string->list) f198))))) (vector-set! f166 0 (closure (f196 f197) (f165) (let ((f196 f196) (f197 f197)) (begin ((primitive-ref write-char) #\( f197) ((vector-ref f165 0) f196 f197) ((primitive-ref write-char) #\) f197))))) (vector-set! f165 0 (closure (f194 f195) (f165) (let ((f194 f194) (f195 f195)) (begin ((primitive-ref write) (car f194) f195) (if (null? (cdr f194)) (begin #t) (if (pair? (cdr f194)) (begin (begin ((primitive-ref write-char) #\space f195) ((vector-ref f165 0) (cdr f194) f195))) (begin (begin ((primitive-ref write-char) #\space f195) ((primitive-ref write-char) #\. f195) ((primitive-ref write-char) #\space f195) ((primitive-ref write) (cdr f194) f195)))))))))) (closure (f218 f219 f220) (f172 f171 f170 f169 f167 f168 f166) (let ((f218 f218) (f219 f219) (f220 f220)) (if (boolean? f218) (begin ((vector-ref f172 0) f218 f219)) (if (null? f218) (begin ((vector-ref f171 0) f219)) (if (char? f218) (begin (if f220 ((primitive-ref write-char) f218 f219) ((vector-ref f170 0) f218 f219))) (if (fixnum? f218) (begin ((vector-ref f169 0) f218 f219)) (if (string? f218) (begin (if f220 ((vector-ref f167 0) f218 f219) ((vector-ref f168 0) f218 f219))) (if (pair? f218) (begin ((vector-ref f166 0) f218 f219)) (begin ((primitive-ref error) ((primitive-ref string->symbol) "write") "unrecognized expression"))))))))))))
# emit-expr (let ((f172 (make-vector 1)) (f171 (make-vector 1)) (f170 (make-vector 1)) (f169 (make-vector 1)) (f168 (make-vector 1)) (f167 (make-vector 1)) (f166 (make-vector 1)) (f165 (make-vector 1))) (begin (begin (vector-set! f172 0 (closure (f213 f214) () (let ((f213 f213) (f214 f214)) (begin ((primitive-ref write-char) #\# f214) (if f213 ((primitive-ref write-char) #\t f214) ((primitive-ref write-char) #\f f214)))))) (vector-set! f171 0 (closure (f212) () (let ((f212 f212)) (begin ((primitive-ref write-char) #\( f212) ((primitive-ref write-char) #\) f212))))) (vector-set! f170 0 (closure (f210 f211) () (let ((f210 f210) (f211 f211)) (begin ((primitive-ref write-char) #\# f211) ((primitive-ref write-char) #\\ f211) ((primitive-ref write-char) f210 f211))))) (vector-set! f169 0 (closure (f206 f207) (f169) (let ((f206 f206) (f207 f207)) (if ((primitive-ref negative?) f206) (begin ((primitive-ref write-char) #\- f207) ((vector-ref f169 0) (fx* -1 f206) f207)) ((primitive-ref map) (closure (f209) (f207) (let ((f209 f209)) ((primitive-ref write-char) (fixnum->char (fx+ (char->fixnum #\0) f209)) f207))) ((primitive-ref integer->list) f206)))))) (vector-set! f168 0 (closure (f202 f203) () (let ((f202 f202) (f203 f203)) (begin ((primitive-ref write-char) #\" f203) ((primitive-ref for-each) (closure (f205) (f203) (let ((f205 f205)) ((primitive-ref write-char) f205 f203))) ((primitive-ref string->list) f202)) ((primitive-ref write-char) #\" f203))))) (vector-set! f167 0 (closure (f198 f199) () (let ((f198 f198) (f199 f199)) ((primitive-ref for-each) (closure (f201) (f199) (let ((f201 f201)) ((primitive-ref write-char) f201 f199))) ((primitive-ref string->list) f198))))) (vector-set! f166 0 (closure (f196 f197) (f165) (let ((f196 f196) (f197 f197)) (begin ((primitive-ref write-char) #\( f197) ((vector-ref f165 0) f196 f197) ((primitive-ref write-char) #\) f197))))) (vector-set! f165 0 (closure (f194 f195) (f165) (let ((f194 f194) (f195 f195)) (begin ((primitive-ref write) (car f194) f195) (if (null? (cdr f194)) (begin #t) (if (pair? (cdr f194)) (begin (begin ((primitive-ref write-char) #\space f195) ((vector-ref f165 0) (cdr f194) f195))) (begin (begin ((primitive-ref write-char) #\space f195) ((primitive-ref write-char) #\. f195) ((primitive-ref write-char) #\space f195) ((primitive-ref write) (cdr f194) f195)))))))))) (closure (f218 f219 f220) (f172 f171 f170 f169 f167 f168 f166) (let ((f218 f218) (f219 f219) (f220 f220)) (if (boolean? f218) (begin ((vector-ref f172 0) f218 f219)) (if (null? f218) (begin ((vector-ref f171 0) f219)) (if (char? f218) (begin (if f220 ((primitive-ref write-char) f218 f219) ((vector-ref f170 0) f218 f219))) (if (fixnum? f218) (begin ((vector-ref f169 0) f218 f219)) (if (string? f218) (begin (if f220 ((vector-ref f167 0) f218 f219) ((vector-ref f168 0) f218 f219))) (if (pair? f218) (begin ((vector-ref f166 0) f218 f219)) (begin ((primitive-ref error) ((primitive-ref string->symbol) "write") "unrecognized expression"))))))))))))
# emit-let
#  si   = 0
#  env  = ()
#  bindings = ((f172 (make-vector 1)) (f171 (make-vector 1)) (f170 (make-vector 1)) (f169 (make-vector 1)) (f168 (make-vector 1)) (f167 (make-vector 1)) (f166 (make-vector 1)) (f165 (make-vector 1)))
#  body = (begin (begin (vector-set! f172 0 (closure (f213 f214) () (let ((f213 f213) (f214 f214)) (begin ((primitive-ref write-char) #\# f214) (if f213 ((primitive-ref write-char) #\t f214) ((primitive-ref write-char) #\f f214)))))) (vector-set! f171 0 (closure (f212) () (let ((f212 f212)) (begin ((primitive-ref write-char) #\( f212) ((primitive-ref write-char) #\) f212))))) (vector-set! f170 0 (closure (f210 f211) () (let ((f210 f210) (f211 f211)) (begin ((primitive-ref write-char) #\# f211) ((primitive-ref write-char) #\\ f211) ((primitive-ref write-char) f210 f211))))) (vector-set! f169 0 (closure (f206 f207) (f169) (let ((f206 f206) (f207 f207)) (if ((primitive-ref negative?) f206) (begin ((primitive-ref write-char) #\- f207) ((vector-ref f169 0) (fx* -1 f206) f207)) ((primitive-ref map) (closure (f209) (f207) (let ((f209 f209)) ((primitive-ref write-char) (fixnum->char (fx+ (char->fixnum #\0) f209)) f207))) ((primitive-ref integer->list) f206)))))) (vector-set! f168 0 (closure (f202 f203) () (let ((f202 f202) (f203 f203)) (begin ((primitive-ref write-char) #\" f203) ((primitive-ref for-each) (closure (f205) (f203) (let ((f205 f205)) ((primitive-ref write-char) f205 f203))) ((primitive-ref string->list) f202)) ((primitive-ref write-char) #\" f203))))) (vector-set! f167 0 (closure (f198 f199) () (let ((f198 f198) (f199 f199)) ((primitive-ref for-each) (closure (f201) (f199) (let ((f201 f201)) ((primitive-ref write-char) f201 f199))) ((primitive-ref string->list) f198))))) (vector-set! f166 0 (closure (f196 f197) (f165) (let ((f196 f196) (f197 f197)) (begin ((primitive-ref write-char) #\( f197) ((vector-ref f165 0) f196 f197) ((primitive-ref write-char) #\) f197))))) (vector-set! f165 0 (closure (f194 f195) (f165) (let ((f194 f194) (f195 f195)) (begin ((primitive-ref write) (car f194) f195) (if (null? (cdr f194)) (begin #t) (if (pair? (cdr f194)) (begin (begin ((primitive-ref write-char) #\space f195) ((vector-ref f165 0) (cdr f194) f195))) (begin (begin ((primitive-ref write-char) #\space f195) ((primitive-ref write-char) #\. f195) ((primitive-ref write-char) #\space f195) ((primitive-ref write) (cdr f194) f195)))))))))) (closure (f218 f219 f220) (f172 f171 f170 f169 f167 f168 f166) (let ((f218 f218) (f219 f219) (f220 f220)) (if (boolean? f218) (begin ((vector-ref f172 0) f218 f219)) (if (null? f218) (begin ((vector-ref f171 0) f219)) (if (char? f218) (begin (if f220 ((primitive-ref write-char) f218 f219) ((vector-ref f170 0) f218 f219))) (if (fixnum? f218) (begin ((vector-ref f169 0) f218 f219)) (if (string? f218) (begin (if f220 ((vector-ref f167 0) f218 f219) ((vector-ref f168 0) f218 f219))) (if (pair? f218) (begin ((vector-ref f166 0) f218 f219)) (begin ((primitive-ref error) ((primitive-ref string->symbol) "write") "unrecognized expression")))))))))))
>>>>>>> fix-implicit-begins
# emit-expr (make-vector 1)
# make-vector 1
# emit-expr 1
    movl $4, %eax     # immed 1
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1205"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1205:
# check the argument is a fixnum >= 0
    cmp $0,%eax
    jge _L_1206
# invoke error handler eh_length
    .extern mrc_eh$ulength
    movl mrc_eh$ulength, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1206:
    movl %eax, %esi
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    orl  $5, %eax
    addl $4, %esi
    addl $4, %esi
    andl $-8, %esi
    addl %esi, %ebp
    movl %eax, 0(%esp)  # stack save
# emit-expr (make-vector 1)
# make-vector 1
# emit-expr 1
    movl $4, %eax     # immed 1
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1207"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1207:
# check the argument is a fixnum >= 0
    cmp $0,%eax
    jge _L_1208
# invoke error handler eh_length
    .extern mrc_eh$ulength
    movl mrc_eh$ulength, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1208:
    movl %eax, %esi
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    orl  $5, %eax
    addl $4, %esi
    addl $4, %esi
    andl $-8, %esi
    addl %esi, %ebp
    movl %eax, -4(%esp)  # stack save
# emit-expr (make-vector 1)
# make-vector 1
# emit-expr 1
    movl $4, %eax     # immed 1
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1209"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1209:
# check the argument is a fixnum >= 0
    cmp $0,%eax
    jge _L_1210
# invoke error handler eh_length
    .extern mrc_eh$ulength
    movl mrc_eh$ulength, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1210:
    movl %eax, %esi
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    orl  $5, %eax
    addl $4, %esi
    addl $4, %esi
    andl $-8, %esi
    addl %esi, %ebp
    movl %eax, -8(%esp)  # stack save
# emit-expr (make-vector 1)
# make-vector 1
# emit-expr 1
    movl $4, %eax     # immed 1
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1211"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1211:
# check the argument is a fixnum >= 0
    cmp $0,%eax
    jge _L_1212
# invoke error handler eh_length
    .extern mrc_eh$ulength
    movl mrc_eh$ulength, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1212:
    movl %eax, %esi
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    orl  $5, %eax
    addl $4, %esi
    addl $4, %esi
    andl $-8, %esi
    addl %esi, %ebp
    movl %eax, -12(%esp)  # stack save
# emit-expr (make-vector 1)
# make-vector 1
# emit-expr 1
    movl $4, %eax     # immed 1
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1213"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1213:
# check the argument is a fixnum >= 0
    cmp $0,%eax
    jge _L_1214
# invoke error handler eh_length
    .extern mrc_eh$ulength
    movl mrc_eh$ulength, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1214:
    movl %eax, %esi
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    orl  $5, %eax
    addl $4, %esi
    addl $4, %esi
    andl $-8, %esi
    addl %esi, %ebp
    movl %eax, -16(%esp)  # stack save
# emit-expr (make-vector 1)
# make-vector 1
# emit-expr 1
    movl $4, %eax     # immed 1
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1215"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1215:
# check the argument is a fixnum >= 0
    cmp $0,%eax
    jge _L_1216
# invoke error handler eh_length
    .extern mrc_eh$ulength
    movl mrc_eh$ulength, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1216:
    movl %eax, %esi
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    orl  $5, %eax
    addl $4, %esi
    addl $4, %esi
    andl $-8, %esi
    addl %esi, %ebp
    movl %eax, -20(%esp)  # stack save
# emit-expr (make-vector 1)
# make-vector 1
# emit-expr 1
    movl $4, %eax     # immed 1
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1217"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1217:
# check the argument is a fixnum >= 0
    cmp $0,%eax
    jge _L_1218
# invoke error handler eh_length
    .extern mrc_eh$ulength
    movl mrc_eh$ulength, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1218:
    movl %eax, %esi
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    orl  $5, %eax
    addl $4, %esi
    addl $4, %esi
    andl $-8, %esi
    addl %esi, %ebp
    movl %eax, -24(%esp)  # stack save
# emit-expr (make-vector 1)
# make-vector 1
# emit-expr 1
    movl $4, %eax     # immed 1
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1219"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1219:
# check the argument is a fixnum >= 0
    cmp $0,%eax
    jge _L_1220
# invoke error handler eh_length
    .extern mrc_eh$ulength
    movl mrc_eh$ulength, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1220:
    movl %eax, %esi
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    orl  $5, %eax
    addl $4, %esi
    addl $4, %esi
    andl $-8, %esi
    addl %esi, %ebp
    movl %eax, -28(%esp)  # stack save
<<<<<<< HEAD
# emit-expr (begin (begin (vector-set! f310959 0 (closure (f311001 f311000) () (let ((f311001 f311001) (f311000 f311000)) (begin ((primitive-ref write-char) #\# f311000) (if f311001 ((primitive-ref write-char) #\t f311000) ((primitive-ref write-char) #\f f311000)))))) (vector-set! f310958 0 (closure (f310999) () (let ((f310999 f310999)) (begin ((primitive-ref write-char) #\( f310999) ((primitive-ref write-char) #\) f310999))))) (vector-set! f310957 0 (closure (f310998 f310997) () (let ((f310998 f310998) (f310997 f310997)) (begin ((primitive-ref write-char) #\# f310997) ((primitive-ref write-char) #\\ f310997) ((primitive-ref write-char) f310998 f310997))))) (vector-set! f310956 0 (closure (f310994 f310993) (f310956) (let ((f310994 f310994) (f310993 f310993)) (if ((primitive-ref negative?) f310994) (begin ((primitive-ref write-char) #\- f310993) ((vector-ref f310956 0) (fx* -1 f310994) f310993)) ((primitive-ref map) (closure (f310996) (f310993) (let ((f310996 f310996)) ((primitive-ref write-char) (fixnum->char (fx+ (char->fixnum #\0) f310996)) f310993))) ((primitive-ref integer->list) f310994)))))) (vector-set! f310955 0 (closure (f310990 f310989) () (let ((f310990 f310990) (f310989 f310989)) (begin ((primitive-ref write-char) #\" f310989) ((primitive-ref for-each) (closure (f310992) (f310989) (let ((f310992 f310992)) ((primitive-ref write-char) f310992 f310989))) ((primitive-ref string->list) f310990)) ((primitive-ref write-char) #\" f310989))))) (vector-set! f310954 0 (closure (f310986 f310985) () (let ((f310986 f310986) (f310985 f310985)) ((primitive-ref for-each) (closure (f310988) (f310985) (let ((f310988 f310988)) ((primitive-ref write-char) f310988 f310985))) ((primitive-ref string->list) f310986))))) (vector-set! f310953 0 (closure (f310984 f310983) (f310952) (let ((f310984 f310984) (f310983 f310983)) (begin ((primitive-ref write-char) #\( f310983) ((vector-ref f310952 0) f310984 f310983) ((primitive-ref write-char) #\) f310983))))) (vector-set! f310952 0 (closure (f310982 f310981) (f310952) (let ((f310982 f310982) (f310981 f310981)) (begin ((primitive-ref write) (car f310982) f310981) (if (null? (cdr f310982)) #t (if (pair? (cdr f310982)) (begin ((primitive-ref write-char) #\space f310981) ((vector-ref f310952 0) (cdr f310982) f310981)) (begin ((primitive-ref write-char) #\space f310981) ((primitive-ref write-char) #\. f310981) ((primitive-ref write-char) #\space f310981) ((primitive-ref write) (cdr f310982) f310981))))))))) (closure (f311007 f311006 f311005) (f310959 f310958 f310957 f310956 f310954 f310955 f310953) (let ((f311007 f311007) (f311006 f311006) (f311005 f311005)) (if (boolean? f311007) ((vector-ref f310959 0) f311007 f311006) (if (null? f311007) ((vector-ref f310958 0) f311006) (if (char? f311007) (if f311005 ((primitive-ref write-char) f311007 f311006) ((vector-ref f310957 0) f311007 f311006)) (if (fixnum? f311007) ((vector-ref f310956 0) f311007 f311006) (if (string? f311007) (if f311005 ((vector-ref f310954 0) f311007 f311006) ((vector-ref f310955 0) f311007 f311006)) (if (pair? f311007) ((vector-ref f310953 0) f311007 f311006) ((primitive-ref error) ((primitive-ref string->symbol) "write") "unrecognized expression"))))))))))
# emit-begin
#   expr=(begin (begin (vector-set! f310959 0 (closure (f311001 f311000) () (let ((f311001 f311001) (f311000 f311000)) (begin ((primitive-ref write-char) #\# f311000) (if f311001 ((primitive-ref write-char) #\t f311000) ((primitive-ref write-char) #\f f311000)))))) (vector-set! f310958 0 (closure (f310999) () (let ((f310999 f310999)) (begin ((primitive-ref write-char) #\( f310999) ((primitive-ref write-char) #\) f310999))))) (vector-set! f310957 0 (closure (f310998 f310997) () (let ((f310998 f310998) (f310997 f310997)) (begin ((primitive-ref write-char) #\# f310997) ((primitive-ref write-char) #\\ f310997) ((primitive-ref write-char) f310998 f310997))))) (vector-set! f310956 0 (closure (f310994 f310993) (f310956) (let ((f310994 f310994) (f310993 f310993)) (if ((primitive-ref negative?) f310994) (begin ((primitive-ref write-char) #\- f310993) ((vector-ref f310956 0) (fx* -1 f310994) f310993)) ((primitive-ref map) (closure (f310996) (f310993) (let ((f310996 f310996)) ((primitive-ref write-char) (fixnum->char (fx+ (char->fixnum #\0) f310996)) f310993))) ((primitive-ref integer->list) f310994)))))) (vector-set! f310955 0 (closure (f310990 f310989) () (let ((f310990 f310990) (f310989 f310989)) (begin ((primitive-ref write-char) #\" f310989) ((primitive-ref for-each) (closure (f310992) (f310989) (let ((f310992 f310992)) ((primitive-ref write-char) f310992 f310989))) ((primitive-ref string->list) f310990)) ((primitive-ref write-char) #\" f310989))))) (vector-set! f310954 0 (closure (f310986 f310985) () (let ((f310986 f310986) (f310985 f310985)) ((primitive-ref for-each) (closure (f310988) (f310985) (let ((f310988 f310988)) ((primitive-ref write-char) f310988 f310985))) ((primitive-ref string->list) f310986))))) (vector-set! f310953 0 (closure (f310984 f310983) (f310952) (let ((f310984 f310984) (f310983 f310983)) (begin ((primitive-ref write-char) #\( f310983) ((vector-ref f310952 0) f310984 f310983) ((primitive-ref write-char) #\) f310983))))) (vector-set! f310952 0 (closure (f310982 f310981) (f310952) (let ((f310982 f310982) (f310981 f310981)) (begin ((primitive-ref write) (car f310982) f310981) (if (null? (cdr f310982)) #t (if (pair? (cdr f310982)) (begin ((primitive-ref write-char) #\space f310981) ((vector-ref f310952 0) (cdr f310982) f310981)) (begin ((primitive-ref write-char) #\space f310981) ((primitive-ref write-char) #\. f310981) ((primitive-ref write-char) #\space f310981) ((primitive-ref write) (cdr f310982) f310981))))))))) (closure (f311007 f311006 f311005) (f310959 f310958 f310957 f310956 f310954 f310955 f310953) (let ((f311007 f311007) (f311006 f311006) (f311005 f311005)) (if (boolean? f311007) ((vector-ref f310959 0) f311007 f311006) (if (null? f311007) ((vector-ref f310958 0) f311006) (if (char? f311007) (if f311005 ((primitive-ref write-char) f311007 f311006) ((vector-ref f310957 0) f311007 f311006)) (if (fixnum? f311007) ((vector-ref f310956 0) f311007 f311006) (if (string? f311007) (if f311005 ((vector-ref f310954 0) f311007 f311006) ((vector-ref f310955 0) f311007 f311006)) (if (pair? f311007) ((vector-ref f310953 0) f311007 f311006) ((primitive-ref error) ((primitive-ref string->symbol) "write") "unrecognized expression"))))))))))
#   env=((f310952 . -28) (f310953 . -24) (f310954 . -20) (f310955 . -16) (f310956 . -12) (f310957 . -8) (f310958 . -4) (f310959 . 0))
# emit-expr (begin (vector-set! f310959 0 (closure (f311001 f311000) () (let ((f311001 f311001) (f311000 f311000)) (begin ((primitive-ref write-char) #\# f311000) (if f311001 ((primitive-ref write-char) #\t f311000) ((primitive-ref write-char) #\f f311000)))))) (vector-set! f310958 0 (closure (f310999) () (let ((f310999 f310999)) (begin ((primitive-ref write-char) #\( f310999) ((primitive-ref write-char) #\) f310999))))) (vector-set! f310957 0 (closure (f310998 f310997) () (let ((f310998 f310998) (f310997 f310997)) (begin ((primitive-ref write-char) #\# f310997) ((primitive-ref write-char) #\\ f310997) ((primitive-ref write-char) f310998 f310997))))) (vector-set! f310956 0 (closure (f310994 f310993) (f310956) (let ((f310994 f310994) (f310993 f310993)) (if ((primitive-ref negative?) f310994) (begin ((primitive-ref write-char) #\- f310993) ((vector-ref f310956 0) (fx* -1 f310994) f310993)) ((primitive-ref map) (closure (f310996) (f310993) (let ((f310996 f310996)) ((primitive-ref write-char) (fixnum->char (fx+ (char->fixnum #\0) f310996)) f310993))) ((primitive-ref integer->list) f310994)))))) (vector-set! f310955 0 (closure (f310990 f310989) () (let ((f310990 f310990) (f310989 f310989)) (begin ((primitive-ref write-char) #\" f310989) ((primitive-ref for-each) (closure (f310992) (f310989) (let ((f310992 f310992)) ((primitive-ref write-char) f310992 f310989))) ((primitive-ref string->list) f310990)) ((primitive-ref write-char) #\" f310989))))) (vector-set! f310954 0 (closure (f310986 f310985) () (let ((f310986 f310986) (f310985 f310985)) ((primitive-ref for-each) (closure (f310988) (f310985) (let ((f310988 f310988)) ((primitive-ref write-char) f310988 f310985))) ((primitive-ref string->list) f310986))))) (vector-set! f310953 0 (closure (f310984 f310983) (f310952) (let ((f310984 f310984) (f310983 f310983)) (begin ((primitive-ref write-char) #\( f310983) ((vector-ref f310952 0) f310984 f310983) ((primitive-ref write-char) #\) f310983))))) (vector-set! f310952 0 (closure (f310982 f310981) (f310952) (let ((f310982 f310982) (f310981 f310981)) (begin ((primitive-ref write) (car f310982) f310981) (if (null? (cdr f310982)) #t (if (pair? (cdr f310982)) (begin ((primitive-ref write-char) #\space f310981) ((vector-ref f310952 0) (cdr f310982) f310981)) (begin ((primitive-ref write-char) #\space f310981) ((primitive-ref write-char) #\. f310981) ((primitive-ref write-char) #\space f310981) ((primitive-ref write) (cdr f310982) f310981)))))))))
# emit-begin
#   expr=(begin (vector-set! f310959 0 (closure (f311001 f311000) () (let ((f311001 f311001) (f311000 f311000)) (begin ((primitive-ref write-char) #\# f311000) (if f311001 ((primitive-ref write-char) #\t f311000) ((primitive-ref write-char) #\f f311000)))))) (vector-set! f310958 0 (closure (f310999) () (let ((f310999 f310999)) (begin ((primitive-ref write-char) #\( f310999) ((primitive-ref write-char) #\) f310999))))) (vector-set! f310957 0 (closure (f310998 f310997) () (let ((f310998 f310998) (f310997 f310997)) (begin ((primitive-ref write-char) #\# f310997) ((primitive-ref write-char) #\\ f310997) ((primitive-ref write-char) f310998 f310997))))) (vector-set! f310956 0 (closure (f310994 f310993) (f310956) (let ((f310994 f310994) (f310993 f310993)) (if ((primitive-ref negative?) f310994) (begin ((primitive-ref write-char) #\- f310993) ((vector-ref f310956 0) (fx* -1 f310994) f310993)) ((primitive-ref map) (closure (f310996) (f310993) (let ((f310996 f310996)) ((primitive-ref write-char) (fixnum->char (fx+ (char->fixnum #\0) f310996)) f310993))) ((primitive-ref integer->list) f310994)))))) (vector-set! f310955 0 (closure (f310990 f310989) () (let ((f310990 f310990) (f310989 f310989)) (begin ((primitive-ref write-char) #\" f310989) ((primitive-ref for-each) (closure (f310992) (f310989) (let ((f310992 f310992)) ((primitive-ref write-char) f310992 f310989))) ((primitive-ref string->list) f310990)) ((primitive-ref write-char) #\" f310989))))) (vector-set! f310954 0 (closure (f310986 f310985) () (let ((f310986 f310986) (f310985 f310985)) ((primitive-ref for-each) (closure (f310988) (f310985) (let ((f310988 f310988)) ((primitive-ref write-char) f310988 f310985))) ((primitive-ref string->list) f310986))))) (vector-set! f310953 0 (closure (f310984 f310983) (f310952) (let ((f310984 f310984) (f310983 f310983)) (begin ((primitive-ref write-char) #\( f310983) ((vector-ref f310952 0) f310984 f310983) ((primitive-ref write-char) #\) f310983))))) (vector-set! f310952 0 (closure (f310982 f310981) (f310952) (let ((f310982 f310982) (f310981 f310981)) (begin ((primitive-ref write) (car f310982) f310981) (if (null? (cdr f310982)) #t (if (pair? (cdr f310982)) (begin ((primitive-ref write-char) #\space f310981) ((vector-ref f310952 0) (cdr f310982) f310981)) (begin ((primitive-ref write-char) #\space f310981) ((primitive-ref write-char) #\. f310981) ((primitive-ref write-char) #\space f310981) ((primitive-ref write) (cdr f310982) f310981)))))))))
#   env=((f310952 . -28) (f310953 . -24) (f310954 . -20) (f310955 . -16) (f310956 . -12) (f310957 . -8) (f310958 . -4) (f310959 . 0))
# emit-expr (vector-set! f310959 0 (closure (f311001 f311000) () (let ((f311001 f311001) (f311000 f311000)) (begin ((primitive-ref write-char) #\# f311000) (if f311001 ((primitive-ref write-char) #\t f311000) ((primitive-ref write-char) #\f f311000))))))
# emit-expr f310959
=======
# emit-expr (begin (begin (vector-set! f172 0 (closure (f213 f214) () (let ((f213 f213) (f214 f214)) (begin ((primitive-ref write-char) #\# f214) (if f213 ((primitive-ref write-char) #\t f214) ((primitive-ref write-char) #\f f214)))))) (vector-set! f171 0 (closure (f212) () (let ((f212 f212)) (begin ((primitive-ref write-char) #\( f212) ((primitive-ref write-char) #\) f212))))) (vector-set! f170 0 (closure (f210 f211) () (let ((f210 f210) (f211 f211)) (begin ((primitive-ref write-char) #\# f211) ((primitive-ref write-char) #\\ f211) ((primitive-ref write-char) f210 f211))))) (vector-set! f169 0 (closure (f206 f207) (f169) (let ((f206 f206) (f207 f207)) (if ((primitive-ref negative?) f206) (begin ((primitive-ref write-char) #\- f207) ((vector-ref f169 0) (fx* -1 f206) f207)) ((primitive-ref map) (closure (f209) (f207) (let ((f209 f209)) ((primitive-ref write-char) (fixnum->char (fx+ (char->fixnum #\0) f209)) f207))) ((primitive-ref integer->list) f206)))))) (vector-set! f168 0 (closure (f202 f203) () (let ((f202 f202) (f203 f203)) (begin ((primitive-ref write-char) #\" f203) ((primitive-ref for-each) (closure (f205) (f203) (let ((f205 f205)) ((primitive-ref write-char) f205 f203))) ((primitive-ref string->list) f202)) ((primitive-ref write-char) #\" f203))))) (vector-set! f167 0 (closure (f198 f199) () (let ((f198 f198) (f199 f199)) ((primitive-ref for-each) (closure (f201) (f199) (let ((f201 f201)) ((primitive-ref write-char) f201 f199))) ((primitive-ref string->list) f198))))) (vector-set! f166 0 (closure (f196 f197) (f165) (let ((f196 f196) (f197 f197)) (begin ((primitive-ref write-char) #\( f197) ((vector-ref f165 0) f196 f197) ((primitive-ref write-char) #\) f197))))) (vector-set! f165 0 (closure (f194 f195) (f165) (let ((f194 f194) (f195 f195)) (begin ((primitive-ref write) (car f194) f195) (if (null? (cdr f194)) (begin #t) (if (pair? (cdr f194)) (begin (begin ((primitive-ref write-char) #\space f195) ((vector-ref f165 0) (cdr f194) f195))) (begin (begin ((primitive-ref write-char) #\space f195) ((primitive-ref write-char) #\. f195) ((primitive-ref write-char) #\space f195) ((primitive-ref write) (cdr f194) f195)))))))))) (closure (f218 f219 f220) (f172 f171 f170 f169 f167 f168 f166) (let ((f218 f218) (f219 f219) (f220 f220)) (if (boolean? f218) (begin ((vector-ref f172 0) f218 f219)) (if (null? f218) (begin ((vector-ref f171 0) f219)) (if (char? f218) (begin (if f220 ((primitive-ref write-char) f218 f219) ((vector-ref f170 0) f218 f219))) (if (fixnum? f218) (begin ((vector-ref f169 0) f218 f219)) (if (string? f218) (begin (if f220 ((vector-ref f167 0) f218 f219) ((vector-ref f168 0) f218 f219))) (if (pair? f218) (begin ((vector-ref f166 0) f218 f219)) (begin ((primitive-ref error) ((primitive-ref string->symbol) "write") "unrecognized expression")))))))))))
# emit-begin
#   expr=(begin (begin (vector-set! f172 0 (closure (f213 f214) () (let ((f213 f213) (f214 f214)) (begin ((primitive-ref write-char) #\# f214) (if f213 ((primitive-ref write-char) #\t f214) ((primitive-ref write-char) #\f f214)))))) (vector-set! f171 0 (closure (f212) () (let ((f212 f212)) (begin ((primitive-ref write-char) #\( f212) ((primitive-ref write-char) #\) f212))))) (vector-set! f170 0 (closure (f210 f211) () (let ((f210 f210) (f211 f211)) (begin ((primitive-ref write-char) #\# f211) ((primitive-ref write-char) #\\ f211) ((primitive-ref write-char) f210 f211))))) (vector-set! f169 0 (closure (f206 f207) (f169) (let ((f206 f206) (f207 f207)) (if ((primitive-ref negative?) f206) (begin ((primitive-ref write-char) #\- f207) ((vector-ref f169 0) (fx* -1 f206) f207)) ((primitive-ref map) (closure (f209) (f207) (let ((f209 f209)) ((primitive-ref write-char) (fixnum->char (fx+ (char->fixnum #\0) f209)) f207))) ((primitive-ref integer->list) f206)))))) (vector-set! f168 0 (closure (f202 f203) () (let ((f202 f202) (f203 f203)) (begin ((primitive-ref write-char) #\" f203) ((primitive-ref for-each) (closure (f205) (f203) (let ((f205 f205)) ((primitive-ref write-char) f205 f203))) ((primitive-ref string->list) f202)) ((primitive-ref write-char) #\" f203))))) (vector-set! f167 0 (closure (f198 f199) () (let ((f198 f198) (f199 f199)) ((primitive-ref for-each) (closure (f201) (f199) (let ((f201 f201)) ((primitive-ref write-char) f201 f199))) ((primitive-ref string->list) f198))))) (vector-set! f166 0 (closure (f196 f197) (f165) (let ((f196 f196) (f197 f197)) (begin ((primitive-ref write-char) #\( f197) ((vector-ref f165 0) f196 f197) ((primitive-ref write-char) #\) f197))))) (vector-set! f165 0 (closure (f194 f195) (f165) (let ((f194 f194) (f195 f195)) (begin ((primitive-ref write) (car f194) f195) (if (null? (cdr f194)) (begin #t) (if (pair? (cdr f194)) (begin (begin ((primitive-ref write-char) #\space f195) ((vector-ref f165 0) (cdr f194) f195))) (begin (begin ((primitive-ref write-char) #\space f195) ((primitive-ref write-char) #\. f195) ((primitive-ref write-char) #\space f195) ((primitive-ref write) (cdr f194) f195)))))))))) (closure (f218 f219 f220) (f172 f171 f170 f169 f167 f168 f166) (let ((f218 f218) (f219 f219) (f220 f220)) (if (boolean? f218) (begin ((vector-ref f172 0) f218 f219)) (if (null? f218) (begin ((vector-ref f171 0) f219)) (if (char? f218) (begin (if f220 ((primitive-ref write-char) f218 f219) ((vector-ref f170 0) f218 f219))) (if (fixnum? f218) (begin ((vector-ref f169 0) f218 f219)) (if (string? f218) (begin (if f220 ((vector-ref f167 0) f218 f219) ((vector-ref f168 0) f218 f219))) (if (pair? f218) (begin ((vector-ref f166 0) f218 f219)) (begin ((primitive-ref error) ((primitive-ref string->symbol) "write") "unrecognized expression")))))))))))
#   env=((f165 . -28) (f166 . -24) (f167 . -20) (f168 . -16) (f169 . -12) (f170 . -8) (f171 . -4) (f172 . 0))
# emit-expr (begin (vector-set! f172 0 (closure (f213 f214) () (let ((f213 f213) (f214 f214)) (begin ((primitive-ref write-char) #\# f214) (if f213 ((primitive-ref write-char) #\t f214) ((primitive-ref write-char) #\f f214)))))) (vector-set! f171 0 (closure (f212) () (let ((f212 f212)) (begin ((primitive-ref write-char) #\( f212) ((primitive-ref write-char) #\) f212))))) (vector-set! f170 0 (closure (f210 f211) () (let ((f210 f210) (f211 f211)) (begin ((primitive-ref write-char) #\# f211) ((primitive-ref write-char) #\\ f211) ((primitive-ref write-char) f210 f211))))) (vector-set! f169 0 (closure (f206 f207) (f169) (let ((f206 f206) (f207 f207)) (if ((primitive-ref negative?) f206) (begin ((primitive-ref write-char) #\- f207) ((vector-ref f169 0) (fx* -1 f206) f207)) ((primitive-ref map) (closure (f209) (f207) (let ((f209 f209)) ((primitive-ref write-char) (fixnum->char (fx+ (char->fixnum #\0) f209)) f207))) ((primitive-ref integer->list) f206)))))) (vector-set! f168 0 (closure (f202 f203) () (let ((f202 f202) (f203 f203)) (begin ((primitive-ref write-char) #\" f203) ((primitive-ref for-each) (closure (f205) (f203) (let ((f205 f205)) ((primitive-ref write-char) f205 f203))) ((primitive-ref string->list) f202)) ((primitive-ref write-char) #\" f203))))) (vector-set! f167 0 (closure (f198 f199) () (let ((f198 f198) (f199 f199)) ((primitive-ref for-each) (closure (f201) (f199) (let ((f201 f201)) ((primitive-ref write-char) f201 f199))) ((primitive-ref string->list) f198))))) (vector-set! f166 0 (closure (f196 f197) (f165) (let ((f196 f196) (f197 f197)) (begin ((primitive-ref write-char) #\( f197) ((vector-ref f165 0) f196 f197) ((primitive-ref write-char) #\) f197))))) (vector-set! f165 0 (closure (f194 f195) (f165) (let ((f194 f194) (f195 f195)) (begin ((primitive-ref write) (car f194) f195) (if (null? (cdr f194)) (begin #t) (if (pair? (cdr f194)) (begin (begin ((primitive-ref write-char) #\space f195) ((vector-ref f165 0) (cdr f194) f195))) (begin (begin ((primitive-ref write-char) #\space f195) ((primitive-ref write-char) #\. f195) ((primitive-ref write-char) #\space f195) ((primitive-ref write) (cdr f194) f195))))))))))
# emit-begin
#   expr=(begin (vector-set! f172 0 (closure (f213 f214) () (let ((f213 f213) (f214 f214)) (begin ((primitive-ref write-char) #\# f214) (if f213 ((primitive-ref write-char) #\t f214) ((primitive-ref write-char) #\f f214)))))) (vector-set! f171 0 (closure (f212) () (let ((f212 f212)) (begin ((primitive-ref write-char) #\( f212) ((primitive-ref write-char) #\) f212))))) (vector-set! f170 0 (closure (f210 f211) () (let ((f210 f210) (f211 f211)) (begin ((primitive-ref write-char) #\# f211) ((primitive-ref write-char) #\\ f211) ((primitive-ref write-char) f210 f211))))) (vector-set! f169 0 (closure (f206 f207) (f169) (let ((f206 f206) (f207 f207)) (if ((primitive-ref negative?) f206) (begin ((primitive-ref write-char) #\- f207) ((vector-ref f169 0) (fx* -1 f206) f207)) ((primitive-ref map) (closure (f209) (f207) (let ((f209 f209)) ((primitive-ref write-char) (fixnum->char (fx+ (char->fixnum #\0) f209)) f207))) ((primitive-ref integer->list) f206)))))) (vector-set! f168 0 (closure (f202 f203) () (let ((f202 f202) (f203 f203)) (begin ((primitive-ref write-char) #\" f203) ((primitive-ref for-each) (closure (f205) (f203) (let ((f205 f205)) ((primitive-ref write-char) f205 f203))) ((primitive-ref string->list) f202)) ((primitive-ref write-char) #\" f203))))) (vector-set! f167 0 (closure (f198 f199) () (let ((f198 f198) (f199 f199)) ((primitive-ref for-each) (closure (f201) (f199) (let ((f201 f201)) ((primitive-ref write-char) f201 f199))) ((primitive-ref string->list) f198))))) (vector-set! f166 0 (closure (f196 f197) (f165) (let ((f196 f196) (f197 f197)) (begin ((primitive-ref write-char) #\( f197) ((vector-ref f165 0) f196 f197) ((primitive-ref write-char) #\) f197))))) (vector-set! f165 0 (closure (f194 f195) (f165) (let ((f194 f194) (f195 f195)) (begin ((primitive-ref write) (car f194) f195) (if (null? (cdr f194)) (begin #t) (if (pair? (cdr f194)) (begin (begin ((primitive-ref write-char) #\space f195) ((vector-ref f165 0) (cdr f194) f195))) (begin (begin ((primitive-ref write-char) #\space f195) ((primitive-ref write-char) #\. f195) ((primitive-ref write-char) #\space f195) ((primitive-ref write) (cdr f194) f195))))))))))
#   env=((f165 . -28) (f166 . -24) (f167 . -20) (f168 . -16) (f169 . -12) (f170 . -8) (f171 . -4) (f172 . 0))
# emit-expr (vector-set! f172 0 (closure (f213 f214) () (let ((f213 f213) (f214 f214)) (begin ((primitive-ref write-char) #\# f214) (if f213 ((primitive-ref write-char) #\t f214) ((primitive-ref write-char) #\f f214))))))
# emit-expr f172
>>>>>>> fix-implicit-begins
# emit-variable-ref
# env=((f165 . -28) (f166 . -24) (f167 . -20) (f168 . -16) (f169 . -12) (f170 . -8) (f171 . -4) (f172 . 0))
# var=f172
    movl 0(%esp), %eax  # stack load f172
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1221
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1221:
    movl %eax, -32(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1222"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1222:
# check bounds on vector index
    movl -32(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1224
    cmp  $0,%eax
    jge _L_1223
_L_1224:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1223:
    movl %eax, -36(%esp)
<<<<<<< HEAD
# emit-expr (closure (f311001 f311000) () (let ((f311001 f311001) (f311000 f311000)) (begin ((primitive-ref write-char) #\# f311000) (if f311001 ((primitive-ref write-char) #\t f311000) ((primitive-ref write-char) #\f f311000)))))
# emit-closure
# si = -40
# env = ((f310952 . -28) (f310953 . -24) (f310954 . -20) (f310955 . -16) (f310956 . -12) (f310957 . -8) (f310958 . -4) (f310959 . 0))
# expr = (closure (f311001 f311000) () (let ((f311001 f311001) (f311000 f311000)) (begin ((primitive-ref write-char) #\# f311000) (if f311001 ((primitive-ref write-char) #\t f311000) ((primitive-ref write-char) #\f f311000)))))
    movl $_L_1884824, 0(%ebp)  # closure label
=======
# emit-expr (closure (f213 f214) () (let ((f213 f213) (f214 f214)) (begin ((primitive-ref write-char) #\# f214) (if f213 ((primitive-ref write-char) #\t f214) ((primitive-ref write-char) #\f f214)))))
# emit-closure
# si = -40
# env = ((f165 . -28) (f166 . -24) (f167 . -20) (f168 . -16) (f169 . -12) (f170 . -8) (f171 . -4) (f172 . 0))
# expr = (closure (f213 f214) () (let ((f213 f213) (f214 f214)) (begin ((primitive-ref write-char) #\# f214) (if f213 ((primitive-ref write-char) #\t f214) ((primitive-ref write-char) #\f f214)))))
    movl $_L_1225, 0(%ebp)  # closure label
>>>>>>> fix-implicit-begins
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $8, %ebp     # bump ebp
    jmp _L_1226            # jump around closure body
_L_1225:
# check argument count
    cmp $8,%eax
    je _L_1227
# invoke error handler eh_argcount
    .extern mrc_eh$uargcount
    movl mrc_eh$uargcount, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_1227:
# emit-tail-expr
# si=-16
<<<<<<< HEAD
# env=((f311000 . -12) (f311001 . -8) (f310952 . -28) (f310953 . -24) (f310954 . -20) (f310955 . -16) (f310956 . -12) (f310957 . -8) (f310958 . -4) (f310959 . 0))
# expr=(let ((f311001 f311001) (f311000 f311000)) (begin ((primitive-ref write-char) #\# f311000) (if f311001 ((primitive-ref write-char) #\t f311000) ((primitive-ref write-char) #\f f311000))))
# emit-tail-let
#  si   = -16
#  env  = ((f311000 . -12) (f311001 . -8) (f310952 . -28) (f310953 . -24) (f310954 . -20) (f310955 . -16) (f310956 . -12) (f310957 . -8) (f310958 . -4) (f310959 . 0))
#  bindings = ((f311001 f311001) (f311000 f311000))
#  body = (begin ((primitive-ref write-char) #\# f311000) (if f311001 ((primitive-ref write-char) #\t f311000) ((primitive-ref write-char) #\f f311000)))
# emit-expr f311001
# emit-variable-ref
# env=((f311000 . -12) (f311001 . -8) (f310952 . -28) (f310953 . -24) (f310954 . -20) (f310955 . -16) (f310956 . -12) (f310957 . -8) (f310958 . -4) (f310959 . 0))
# var=f311001
    movl -8(%esp), %eax  # stack load f311001
# end emit-variable-ref
    movl %eax, -16(%esp)  # stack save
# emit-expr f311000
# emit-variable-ref
# env=((f311000 . -12) (f311001 . -8) (f310952 . -28) (f310953 . -24) (f310954 . -20) (f310955 . -16) (f310956 . -12) (f310957 . -8) (f310958 . -4) (f310959 . 0))
# var=f311000
    movl -12(%esp), %eax  # stack load f311000
=======
# env=((f214 . -12) (f213 . -8) (f165 . -28) (f166 . -24) (f167 . -20) (f168 . -16) (f169 . -12) (f170 . -8) (f171 . -4) (f172 . 0))
# expr=(let ((f213 f213) (f214 f214)) (begin ((primitive-ref write-char) #\# f214) (if f213 ((primitive-ref write-char) #\t f214) ((primitive-ref write-char) #\f f214))))
# emit-tail-let
#  si   = -16
#  env  = ((f214 . -12) (f213 . -8) (f165 . -28) (f166 . -24) (f167 . -20) (f168 . -16) (f169 . -12) (f170 . -8) (f171 . -4) (f172 . 0))
#  bindings = ((f213 f213) (f214 f214))
#  body = (begin ((primitive-ref write-char) #\# f214) (if f213 ((primitive-ref write-char) #\t f214) ((primitive-ref write-char) #\f f214)))
# emit-expr f213
# emit-variable-ref
# env=((f214 . -12) (f213 . -8) (f165 . -28) (f166 . -24) (f167 . -20) (f168 . -16) (f169 . -12) (f170 . -8) (f171 . -4) (f172 . 0))
# var=f213
    movl -8(%esp), %eax  # stack load f213
# end emit-variable-ref
    movl %eax, -16(%esp)  # stack save
# emit-expr f214
# emit-variable-ref
# env=((f214 . -12) (f213 . -8) (f165 . -28) (f166 . -24) (f167 . -20) (f168 . -16) (f169 . -12) (f170 . -8) (f171 . -4) (f172 . 0))
# var=f214
    movl -12(%esp), %eax  # stack load f214
>>>>>>> fix-implicit-begins
# end emit-variable-ref
    movl %eax, -20(%esp)  # stack save
# emit-tail-expr
# si=-24
<<<<<<< HEAD
# env=((f311000 . -20) (f311001 . -16) (f311000 . -12) (f311001 . -8) (f310952 . -28) (f310953 . -24) (f310954 . -20) (f310955 . -16) (f310956 . -12) (f310957 . -8) (f310958 . -4) (f310959 . 0))
# expr=(begin ((primitive-ref write-char) #\# f311000) (if f311001 ((primitive-ref write-char) #\t f311000) ((primitive-ref write-char) #\f f311000)))
# tail-begin (begin ((primitive-ref write-char) #\# f311000) (if f311001 ((primitive-ref write-char) #\t f311000) ((primitive-ref write-char) #\f f311000)))
#   env=((f311000 . -20) (f311001 . -16) (f311000 . -12) (f311001 . -8) (f310952 . -28) (f310953 . -24) (f310954 . -20) (f310955 . -16) (f310956 . -12) (f310957 . -8) (f310958 . -4) (f310959 . 0))
# emit-expr ((primitive-ref write-char) #\# f311000)
# funcall
#    si   =-24
#    env  = ((f311000 . -20) (f311001 . -16) (f311000 . -12) (f311001 . -8) (f310952 . -28) (f310953 . -24) (f310954 . -20) (f310955 . -16) (f310956 . -12) (f310957 . -8) (f310958 . -4) (f310959 . 0))
#    expr = (funcall (primitive-ref write-char) #\# f311000)
=======
# env=((f214 . -20) (f213 . -16) (f214 . -12) (f213 . -8) (f165 . -28) (f166 . -24) (f167 . -20) (f168 . -16) (f169 . -12) (f170 . -8) (f171 . -4) (f172 . 0))
# expr=(begin ((primitive-ref write-char) #\# f214) (if f213 ((primitive-ref write-char) #\t f214) ((primitive-ref write-char) #\f f214)))
# tail-begin (begin ((primitive-ref write-char) #\# f214) (if f213 ((primitive-ref write-char) #\t f214) ((primitive-ref write-char) #\f f214)))
#   env=((f214 . -20) (f213 . -16) (f214 . -12) (f213 . -8) (f165 . -28) (f166 . -24) (f167 . -20) (f168 . -16) (f169 . -12) (f170 . -8) (f171 . -4) (f172 . 0))
# emit-expr ((primitive-ref write-char) #\# f214)
# funcall
#    si   =-24
#    env  = ((f214 . -20) (f213 . -16) (f214 . -12) (f213 . -8) (f165 . -28) (f166 . -24) (f167 . -20) (f168 . -16) (f169 . -12) (f170 . -8) (f171 . -4) (f172 . 0))
#    expr = (funcall (primitive-ref write-char) #\# f214)
>>>>>>> fix-implicit-begins
# emit-expr (primitive-ref write-char)
    .extern mrc_write$mchar
    movl mrc_write$mchar,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1228"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1228":
   movl %eax,  -32(%esp)  # stash funcall-oper in closure slot
# emit-expr #\#
    movl $8975, %eax     # immed #\#
    mov %eax, -36(%esp)  # arg #
<<<<<<< HEAD
# emit-expr f311000
# emit-variable-ref
# env=((f311000 . -20) (f311001 . -16) (f311000 . -12) (f311001 . -8) (f310952 . -28) (f310953 . -24) (f310954 . -20) (f310955 . -16) (f310956 . -12) (f310957 . -8) (f310958 . -4) (f310959 . 0))
# var=f311000
    movl -20(%esp), %eax  # stack load f311000
# end emit-variable-ref
    mov %eax, -40(%esp)  # arg f311000
=======
# emit-expr f214
# emit-variable-ref
# env=((f214 . -20) (f213 . -16) (f214 . -12) (f213 . -8) (f165 . -28) (f166 . -24) (f167 . -20) (f168 . -16) (f169 . -12) (f170 . -8) (f171 . -4) (f172 . 0))
# var=f214
    movl -20(%esp), %eax  # stack load f214
# end emit-variable-ref
    mov %eax, -40(%esp)  # arg f214
>>>>>>> fix-implicit-begins
    movl -32(%esp), %edi   # load new closure to %edi
    add $-24, %esp   # adjust base
    movl $8,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $24, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
# emit-tail-expr
# si=-24
<<<<<<< HEAD
# env=((f311000 . -20) (f311001 . -16) (f311000 . -12) (f311001 . -8) (f310952 . -28) (f310953 . -24) (f310954 . -20) (f310955 . -16) (f310956 . -12) (f310957 . -8) (f310958 . -4) (f310959 . 0))
# expr=(begin (if f311001 ((primitive-ref write-char) #\t f311000) ((primitive-ref write-char) #\f f311000)))
# tail-begin (begin (if f311001 ((primitive-ref write-char) #\t f311000) ((primitive-ref write-char) #\f f311000)))
#   env=((f311000 . -20) (f311001 . -16) (f311000 . -12) (f311001 . -8) (f310952 . -28) (f310953 . -24) (f310954 . -20) (f310955 . -16) (f310956 . -12) (f310957 . -8) (f310958 . -4) (f310959 . 0))
# emit-tail-expr
# si=-24
# env=((f311000 . -20) (f311001 . -16) (f311000 . -12) (f311001 . -8) (f310952 . -28) (f310953 . -24) (f310954 . -20) (f310955 . -16) (f310956 . -12) (f310957 . -8) (f310958 . -4) (f310959 . 0))
# expr=(if f311001 ((primitive-ref write-char) #\t f311000) ((primitive-ref write-char) #\f f311000))
# emit-expr f311001
# emit-variable-ref
# env=((f311000 . -20) (f311001 . -16) (f311000 . -12) (f311001 . -8) (f310952 . -28) (f310953 . -24) (f310954 . -20) (f310955 . -16) (f310956 . -12) (f310957 . -8) (f310958 . -4) (f310959 . 0))
# var=f311001
    movl -16(%esp), %eax  # stack load f311001
=======
# env=((f214 . -20) (f213 . -16) (f214 . -12) (f213 . -8) (f165 . -28) (f166 . -24) (f167 . -20) (f168 . -16) (f169 . -12) (f170 . -8) (f171 . -4) (f172 . 0))
# expr=(begin (if f213 ((primitive-ref write-char) #\t f214) ((primitive-ref write-char) #\f f214)))
# tail-begin (begin (if f213 ((primitive-ref write-char) #\t f214) ((primitive-ref write-char) #\f f214)))
#   env=((f214 . -20) (f213 . -16) (f214 . -12) (f213 . -8) (f165 . -28) (f166 . -24) (f167 . -20) (f168 . -16) (f169 . -12) (f170 . -8) (f171 . -4) (f172 . 0))
# emit-tail-expr
# si=-24
# env=((f214 . -20) (f213 . -16) (f214 . -12) (f213 . -8) (f165 . -28) (f166 . -24) (f167 . -20) (f168 . -16) (f169 . -12) (f170 . -8) (f171 . -4) (f172 . 0))
# expr=(if f213 ((primitive-ref write-char) #\t f214) ((primitive-ref write-char) #\f f214))
# emit-expr f213
# emit-variable-ref
# env=((f214 . -20) (f213 . -16) (f214 . -12) (f213 . -8) (f165 . -28) (f166 . -24) (f167 . -20) (f168 . -16) (f169 . -12) (f170 . -8) (f171 . -4) (f172 . 0))
# var=f213
    movl -16(%esp), %eax  # stack load f213
>>>>>>> fix-implicit-begins
# end emit-variable-ref
    cmp $47, %al
    je _L_1229
# emit-tail-expr
# si=-24
<<<<<<< HEAD
# env=((f311000 . -20) (f311001 . -16) (f311000 . -12) (f311001 . -8) (f310952 . -28) (f310953 . -24) (f310954 . -20) (f310955 . -16) (f310956 . -12) (f310957 . -8) (f310958 . -4) (f310959 . 0))
# expr=((primitive-ref write-char) #\t f311000)
# emit-tail-funcall
#    si   =-24
#    env  = ((f311000 . -20) (f311001 . -16) (f311000 . -12) (f311001 . -8) (f310952 . -28) (f310953 . -24) (f310954 . -20) (f310955 . -16) (f310956 . -12) (f310957 . -8) (f310958 . -4) (f310959 . 0))
#    expr = (funcall (primitive-ref write-char) #\t f311000)
=======
# env=((f214 . -20) (f213 . -16) (f214 . -12) (f213 . -8) (f165 . -28) (f166 . -24) (f167 . -20) (f168 . -16) (f169 . -12) (f170 . -8) (f171 . -4) (f172 . 0))
# expr=((primitive-ref write-char) #\t f214)
# emit-tail-funcall
#    si   =-24
#    env  = ((f214 . -20) (f213 . -16) (f214 . -12) (f213 . -8) (f165 . -28) (f166 . -24) (f167 . -20) (f168 . -16) (f169 . -12) (f170 . -8) (f171 . -4) (f172 . 0))
#    expr = (funcall (primitive-ref write-char) #\t f214)
>>>>>>> fix-implicit-begins
# emit-expr (primitive-ref write-char)
    .extern mrc_write$mchar
    movl mrc_write$mchar,%eax
   movl %eax,  -24(%esp)  # stash funcall-oper in next closure slot
# emit-expr #\t
    movl $29711, %eax     # immed #\t
    mov %eax, -28(%esp)    # arg t
<<<<<<< HEAD
# emit-expr f311000
# emit-variable-ref
# env=((f311000 . -20) (f311001 . -16) (f311000 . -12) (f311001 . -8) (f310952 . -28) (f310953 . -24) (f310954 . -20) (f310955 . -16) (f310956 . -12) (f310957 . -8) (f310958 . -4) (f310959 . 0))
# var=f311000
    movl -20(%esp), %eax  # stack load f311000
# end emit-variable-ref
    mov %eax, -32(%esp)    # arg f311000
=======
# emit-expr f214
# emit-variable-ref
# env=((f214 . -20) (f213 . -16) (f214 . -12) (f213 . -8) (f165 . -28) (f166 . -24) (f167 . -20) (f168 . -16) (f169 . -12) (f170 . -8) (f171 . -4) (f172 . 0))
# var=f214
    movl -20(%esp), %eax  # stack load f214
# end emit-variable-ref
    mov %eax, -32(%esp)    # arg f214
>>>>>>> fix-implicit-begins
    movl -24(%esp), %edi   # load new closure to %edi
# emit-shift-args:  size=3   si=-24  delta=20
    mov -24(%esp), %ebx  # shift frame cell
    mov %ebx, -4(%esp)  # down to base
# emit-shift-args:  size=2   si=-28  delta=20
    mov -28(%esp), %ebx  # shift frame cell
    mov %ebx, -8(%esp)  # down to base
# emit-shift-args:  size=1   si=-32  delta=20
    mov -32(%esp), %ebx  # shift frame cell
    mov %ebx, -12(%esp)  # down to base
# emit-shift-args:  size=0   si=-36  delta=20
    movl $8,%eax   # save arg count
    jmp *-2(%edi)  # tail-funcall
    jmp _L_1230
_L_1229:
# emit-tail-expr
# si=-24
<<<<<<< HEAD
# env=((f311000 . -20) (f311001 . -16) (f311000 . -12) (f311001 . -8) (f310952 . -28) (f310953 . -24) (f310954 . -20) (f310955 . -16) (f310956 . -12) (f310957 . -8) (f310958 . -4) (f310959 . 0))
# expr=((primitive-ref write-char) #\f f311000)
# emit-tail-funcall
#    si   =-24
#    env  = ((f311000 . -20) (f311001 . -16) (f311000 . -12) (f311001 . -8) (f310952 . -28) (f310953 . -24) (f310954 . -20) (f310955 . -16) (f310956 . -12) (f310957 . -8) (f310958 . -4) (f310959 . 0))
#    expr = (funcall (primitive-ref write-char) #\f f311000)
=======
# env=((f214 . -20) (f213 . -16) (f214 . -12) (f213 . -8) (f165 . -28) (f166 . -24) (f167 . -20) (f168 . -16) (f169 . -12) (f170 . -8) (f171 . -4) (f172 . 0))
# expr=((primitive-ref write-char) #\f f214)
# emit-tail-funcall
#    si   =-24
#    env  = ((f214 . -20) (f213 . -16) (f214 . -12) (f213 . -8) (f165 . -28) (f166 . -24) (f167 . -20) (f168 . -16) (f169 . -12) (f170 . -8) (f171 . -4) (f172 . 0))
#    expr = (funcall (primitive-ref write-char) #\f f214)
>>>>>>> fix-implicit-begins
# emit-expr (primitive-ref write-char)
    .extern mrc_write$mchar
    movl mrc_write$mchar,%eax
   movl %eax,  -24(%esp)  # stash funcall-oper in next closure slot
# emit-expr #\f
    movl $26127, %eax     # immed #\f
    mov %eax, -28(%esp)    # arg f
<<<<<<< HEAD
# emit-expr f311000
# emit-variable-ref
# env=((f311000 . -20) (f311001 . -16) (f311000 . -12) (f311001 . -8) (f310952 . -28) (f310953 . -24) (f310954 . -20) (f310955 . -16) (f310956 . -12) (f310957 . -8) (f310958 . -4) (f310959 . 0))
# var=f311000
    movl -20(%esp), %eax  # stack load f311000
# end emit-variable-ref
    mov %eax, -32(%esp)    # arg f311000
=======
# emit-expr f214
# emit-variable-ref
# env=((f214 . -20) (f213 . -16) (f214 . -12) (f213 . -8) (f165 . -28) (f166 . -24) (f167 . -20) (f168 . -16) (f169 . -12) (f170 . -8) (f171 . -4) (f172 . 0))
# var=f214
    movl -20(%esp), %eax  # stack load f214
# end emit-variable-ref
    mov %eax, -32(%esp)    # arg f214
>>>>>>> fix-implicit-begins
    movl -24(%esp), %edi   # load new closure to %edi
# emit-shift-args:  size=3   si=-24  delta=20
    mov -24(%esp), %ebx  # shift frame cell
    mov %ebx, -4(%esp)  # down to base
# emit-shift-args:  size=2   si=-28  delta=20
    mov -28(%esp), %ebx  # shift frame cell
    mov %ebx, -8(%esp)  # down to base
# emit-shift-args:  size=1   si=-32  delta=20
    mov -32(%esp), %ebx  # shift frame cell
    mov %ebx, -12(%esp)  # down to base
# emit-shift-args:  size=0   si=-36  delta=20
    movl $8,%eax   # save arg count
    jmp *-2(%edi)  # tail-funcall
_L_1230:
     ret   # return thru stack
    .align 4,0x90
_L_1226:
    movl -32(%esp), %ebx
    movl -36(%esp), %esi
    movl %eax, -1(%ebx,%esi)
<<<<<<< HEAD
# emit-expr (begin (vector-set! f310958 0 (closure (f310999) () (let ((f310999 f310999)) (begin ((primitive-ref write-char) #\( f310999) ((primitive-ref write-char) #\) f310999))))) (vector-set! f310957 0 (closure (f310998 f310997) () (let ((f310998 f310998) (f310997 f310997)) (begin ((primitive-ref write-char) #\# f310997) ((primitive-ref write-char) #\\ f310997) ((primitive-ref write-char) f310998 f310997))))) (vector-set! f310956 0 (closure (f310994 f310993) (f310956) (let ((f310994 f310994) (f310993 f310993)) (if ((primitive-ref negative?) f310994) (begin ((primitive-ref write-char) #\- f310993) ((vector-ref f310956 0) (fx* -1 f310994) f310993)) ((primitive-ref map) (closure (f310996) (f310993) (let ((f310996 f310996)) ((primitive-ref write-char) (fixnum->char (fx+ (char->fixnum #\0) f310996)) f310993))) ((primitive-ref integer->list) f310994)))))) (vector-set! f310955 0 (closure (f310990 f310989) () (let ((f310990 f310990) (f310989 f310989)) (begin ((primitive-ref write-char) #\" f310989) ((primitive-ref for-each) (closure (f310992) (f310989) (let ((f310992 f310992)) ((primitive-ref write-char) f310992 f310989))) ((primitive-ref string->list) f310990)) ((primitive-ref write-char) #\" f310989))))) (vector-set! f310954 0 (closure (f310986 f310985) () (let ((f310986 f310986) (f310985 f310985)) ((primitive-ref for-each) (closure (f310988) (f310985) (let ((f310988 f310988)) ((primitive-ref write-char) f310988 f310985))) ((primitive-ref string->list) f310986))))) (vector-set! f310953 0 (closure (f310984 f310983) (f310952) (let ((f310984 f310984) (f310983 f310983)) (begin ((primitive-ref write-char) #\( f310983) ((vector-ref f310952 0) f310984 f310983) ((primitive-ref write-char) #\) f310983))))) (vector-set! f310952 0 (closure (f310982 f310981) (f310952) (let ((f310982 f310982) (f310981 f310981)) (begin ((primitive-ref write) (car f310982) f310981) (if (null? (cdr f310982)) #t (if (pair? (cdr f310982)) (begin ((primitive-ref write-char) #\space f310981) ((vector-ref f310952 0) (cdr f310982) f310981)) (begin ((primitive-ref write-char) #\space f310981) ((primitive-ref write-char) #\. f310981) ((primitive-ref write-char) #\space f310981) ((primitive-ref write) (cdr f310982) f310981)))))))))
# emit-begin
#   expr=(begin (vector-set! f310958 0 (closure (f310999) () (let ((f310999 f310999)) (begin ((primitive-ref write-char) #\( f310999) ((primitive-ref write-char) #\) f310999))))) (vector-set! f310957 0 (closure (f310998 f310997) () (let ((f310998 f310998) (f310997 f310997)) (begin ((primitive-ref write-char) #\# f310997) ((primitive-ref write-char) #\\ f310997) ((primitive-ref write-char) f310998 f310997))))) (vector-set! f310956 0 (closure (f310994 f310993) (f310956) (let ((f310994 f310994) (f310993 f310993)) (if ((primitive-ref negative?) f310994) (begin ((primitive-ref write-char) #\- f310993) ((vector-ref f310956 0) (fx* -1 f310994) f310993)) ((primitive-ref map) (closure (f310996) (f310993) (let ((f310996 f310996)) ((primitive-ref write-char) (fixnum->char (fx+ (char->fixnum #\0) f310996)) f310993))) ((primitive-ref integer->list) f310994)))))) (vector-set! f310955 0 (closure (f310990 f310989) () (let ((f310990 f310990) (f310989 f310989)) (begin ((primitive-ref write-char) #\" f310989) ((primitive-ref for-each) (closure (f310992) (f310989) (let ((f310992 f310992)) ((primitive-ref write-char) f310992 f310989))) ((primitive-ref string->list) f310990)) ((primitive-ref write-char) #\" f310989))))) (vector-set! f310954 0 (closure (f310986 f310985) () (let ((f310986 f310986) (f310985 f310985)) ((primitive-ref for-each) (closure (f310988) (f310985) (let ((f310988 f310988)) ((primitive-ref write-char) f310988 f310985))) ((primitive-ref string->list) f310986))))) (vector-set! f310953 0 (closure (f310984 f310983) (f310952) (let ((f310984 f310984) (f310983 f310983)) (begin ((primitive-ref write-char) #\( f310983) ((vector-ref f310952 0) f310984 f310983) ((primitive-ref write-char) #\) f310983))))) (vector-set! f310952 0 (closure (f310982 f310981) (f310952) (let ((f310982 f310982) (f310981 f310981)) (begin ((primitive-ref write) (car f310982) f310981) (if (null? (cdr f310982)) #t (if (pair? (cdr f310982)) (begin ((primitive-ref write-char) #\space f310981) ((vector-ref f310952 0) (cdr f310982) f310981)) (begin ((primitive-ref write-char) #\space f310981) ((primitive-ref write-char) #\. f310981) ((primitive-ref write-char) #\space f310981) ((primitive-ref write) (cdr f310982) f310981)))))))))
#   env=((f310952 . -28) (f310953 . -24) (f310954 . -20) (f310955 . -16) (f310956 . -12) (f310957 . -8) (f310958 . -4) (f310959 . 0))
# emit-expr (vector-set! f310958 0 (closure (f310999) () (let ((f310999 f310999)) (begin ((primitive-ref write-char) #\( f310999) ((primitive-ref write-char) #\) f310999)))))
# emit-expr f310958
=======
# emit-expr (begin (vector-set! f171 0 (closure (f212) () (let ((f212 f212)) (begin ((primitive-ref write-char) #\( f212) ((primitive-ref write-char) #\) f212))))) (vector-set! f170 0 (closure (f210 f211) () (let ((f210 f210) (f211 f211)) (begin ((primitive-ref write-char) #\# f211) ((primitive-ref write-char) #\\ f211) ((primitive-ref write-char) f210 f211))))) (vector-set! f169 0 (closure (f206 f207) (f169) (let ((f206 f206) (f207 f207)) (if ((primitive-ref negative?) f206) (begin ((primitive-ref write-char) #\- f207) ((vector-ref f169 0) (fx* -1 f206) f207)) ((primitive-ref map) (closure (f209) (f207) (let ((f209 f209)) ((primitive-ref write-char) (fixnum->char (fx+ (char->fixnum #\0) f209)) f207))) ((primitive-ref integer->list) f206)))))) (vector-set! f168 0 (closure (f202 f203) () (let ((f202 f202) (f203 f203)) (begin ((primitive-ref write-char) #\" f203) ((primitive-ref for-each) (closure (f205) (f203) (let ((f205 f205)) ((primitive-ref write-char) f205 f203))) ((primitive-ref string->list) f202)) ((primitive-ref write-char) #\" f203))))) (vector-set! f167 0 (closure (f198 f199) () (let ((f198 f198) (f199 f199)) ((primitive-ref for-each) (closure (f201) (f199) (let ((f201 f201)) ((primitive-ref write-char) f201 f199))) ((primitive-ref string->list) f198))))) (vector-set! f166 0 (closure (f196 f197) (f165) (let ((f196 f196) (f197 f197)) (begin ((primitive-ref write-char) #\( f197) ((vector-ref f165 0) f196 f197) ((primitive-ref write-char) #\) f197))))) (vector-set! f165 0 (closure (f194 f195) (f165) (let ((f194 f194) (f195 f195)) (begin ((primitive-ref write) (car f194) f195) (if (null? (cdr f194)) (begin #t) (if (pair? (cdr f194)) (begin (begin ((primitive-ref write-char) #\space f195) ((vector-ref f165 0) (cdr f194) f195))) (begin (begin ((primitive-ref write-char) #\space f195) ((primitive-ref write-char) #\. f195) ((primitive-ref write-char) #\space f195) ((primitive-ref write) (cdr f194) f195))))))))))
# emit-begin
#   expr=(begin (vector-set! f171 0 (closure (f212) () (let ((f212 f212)) (begin ((primitive-ref write-char) #\( f212) ((primitive-ref write-char) #\) f212))))) (vector-set! f170 0 (closure (f210 f211) () (let ((f210 f210) (f211 f211)) (begin ((primitive-ref write-char) #\# f211) ((primitive-ref write-char) #\\ f211) ((primitive-ref write-char) f210 f211))))) (vector-set! f169 0 (closure (f206 f207) (f169) (let ((f206 f206) (f207 f207)) (if ((primitive-ref negative?) f206) (begin ((primitive-ref write-char) #\- f207) ((vector-ref f169 0) (fx* -1 f206) f207)) ((primitive-ref map) (closure (f209) (f207) (let ((f209 f209)) ((primitive-ref write-char) (fixnum->char (fx+ (char->fixnum #\0) f209)) f207))) ((primitive-ref integer->list) f206)))))) (vector-set! f168 0 (closure (f202 f203) () (let ((f202 f202) (f203 f203)) (begin ((primitive-ref write-char) #\" f203) ((primitive-ref for-each) (closure (f205) (f203) (let ((f205 f205)) ((primitive-ref write-char) f205 f203))) ((primitive-ref string->list) f202)) ((primitive-ref write-char) #\" f203))))) (vector-set! f167 0 (closure (f198 f199) () (let ((f198 f198) (f199 f199)) ((primitive-ref for-each) (closure (f201) (f199) (let ((f201 f201)) ((primitive-ref write-char) f201 f199))) ((primitive-ref string->list) f198))))) (vector-set! f166 0 (closure (f196 f197) (f165) (let ((f196 f196) (f197 f197)) (begin ((primitive-ref write-char) #\( f197) ((vector-ref f165 0) f196 f197) ((primitive-ref write-char) #\) f197))))) (vector-set! f165 0 (closure (f194 f195) (f165) (let ((f194 f194) (f195 f195)) (begin ((primitive-ref write) (car f194) f195) (if (null? (cdr f194)) (begin #t) (if (pair? (cdr f194)) (begin (begin ((primitive-ref write-char) #\space f195) ((vector-ref f165 0) (cdr f194) f195))) (begin (begin ((primitive-ref write-char) #\space f195) ((primitive-ref write-char) #\. f195) ((primitive-ref write-char) #\space f195) ((primitive-ref write) (cdr f194) f195))))))))))
#   env=((f165 . -28) (f166 . -24) (f167 . -20) (f168 . -16) (f169 . -12) (f170 . -8) (f171 . -4) (f172 . 0))
# emit-expr (vector-set! f171 0 (closure (f212) () (let ((f212 f212)) (begin ((primitive-ref write-char) #\( f212) ((primitive-ref write-char) #\) f212)))))
# emit-expr f171
>>>>>>> fix-implicit-begins
# emit-variable-ref
# env=((f165 . -28) (f166 . -24) (f167 . -20) (f168 . -16) (f169 . -12) (f170 . -8) (f171 . -4) (f172 . 0))
# var=f171
    movl -4(%esp), %eax  # stack load f171
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1231
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1231:
    movl %eax, -32(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1232"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1232:
# check bounds on vector index
    movl -32(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1234
    cmp  $0,%eax
    jge _L_1233
_L_1234:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1233:
    movl %eax, -36(%esp)
# emit-expr (closure (f212) () (let ((f212 f212)) (begin ((primitive-ref write-char) #\( f212) ((primitive-ref write-char) #\) f212))))
# emit-closure
# si = -40
# env = ((f165 . -28) (f166 . -24) (f167 . -20) (f168 . -16) (f169 . -12) (f170 . -8) (f171 . -4) (f172 . 0))
# expr = (closure (f212) () (let ((f212 f212)) (begin ((primitive-ref write-char) #\( f212) ((primitive-ref write-char) #\) f212))))
    movl $_L_1235, 0(%ebp)  # closure label
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $8, %ebp     # bump ebp
    jmp _L_1236            # jump around closure body
_L_1235:
# check argument count
    cmp $4,%eax
    je _L_1237
# invoke error handler eh_argcount
    .extern mrc_eh$uargcount
    movl mrc_eh$uargcount, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_1237:
# emit-tail-expr
# si=-12
# env=((f212 . -8) (f165 . -28) (f166 . -24) (f167 . -20) (f168 . -16) (f169 . -12) (f170 . -8) (f171 . -4) (f172 . 0))
# expr=(let ((f212 f212)) (begin ((primitive-ref write-char) #\( f212) ((primitive-ref write-char) #\) f212)))
# emit-tail-let
#  si   = -12
#  env  = ((f212 . -8) (f165 . -28) (f166 . -24) (f167 . -20) (f168 . -16) (f169 . -12) (f170 . -8) (f171 . -4) (f172 . 0))
#  bindings = ((f212 f212))
#  body = (begin ((primitive-ref write-char) #\( f212) ((primitive-ref write-char) #\) f212))
# emit-expr f212
# emit-variable-ref
# env=((f212 . -8) (f165 . -28) (f166 . -24) (f167 . -20) (f168 . -16) (f169 . -12) (f170 . -8) (f171 . -4) (f172 . 0))
# var=f212
    movl -8(%esp), %eax  # stack load f212
# end emit-variable-ref
    movl %eax, -12(%esp)  # stack save
# emit-tail-expr
# si=-16
# env=((f212 . -12) (f212 . -8) (f165 . -28) (f166 . -24) (f167 . -20) (f168 . -16) (f169 . -12) (f170 . -8) (f171 . -4) (f172 . 0))
# expr=(begin ((primitive-ref write-char) #\( f212) ((primitive-ref write-char) #\) f212))
# tail-begin (begin ((primitive-ref write-char) #\( f212) ((primitive-ref write-char) #\) f212))
#   env=((f212 . -12) (f212 . -8) (f165 . -28) (f166 . -24) (f167 . -20) (f168 . -16) (f169 . -12) (f170 . -8) (f171 . -4) (f172 . 0))
# emit-expr ((primitive-ref write-char) #\( f212)
# funcall
#    si   =-16
#    env  = ((f212 . -12) (f212 . -8) (f165 . -28) (f166 . -24) (f167 . -20) (f168 . -16) (f169 . -12) (f170 . -8) (f171 . -4) (f172 . 0))
#    expr = (funcall (primitive-ref write-char) #\( f212)
# emit-expr (primitive-ref write-char)
    .extern mrc_write$mchar
    movl mrc_write$mchar,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1238"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1238":
   movl %eax,  -24(%esp)  # stash funcall-oper in closure slot
# emit-expr #\(
    movl $10255, %eax     # immed #\(
    mov %eax, -28(%esp)  # arg (
# emit-expr f212
# emit-variable-ref
# env=((f212 . -12) (f212 . -8) (f165 . -28) (f166 . -24) (f167 . -20) (f168 . -16) (f169 . -12) (f170 . -8) (f171 . -4) (f172 . 0))
# var=f212
    movl -12(%esp), %eax  # stack load f212
# end emit-variable-ref
    mov %eax, -32(%esp)  # arg f212
    movl -24(%esp), %edi   # load new closure to %edi
    add $-16, %esp   # adjust base
    movl $8,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $16, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
# emit-tail-expr
# si=-16
# env=((f212 . -12) (f212 . -8) (f165 . -28) (f166 . -24) (f167 . -20) (f168 . -16) (f169 . -12) (f170 . -8) (f171 . -4) (f172 . 0))
# expr=(begin ((primitive-ref write-char) #\) f212))
# tail-begin (begin ((primitive-ref write-char) #\) f212))
#   env=((f212 . -12) (f212 . -8) (f165 . -28) (f166 . -24) (f167 . -20) (f168 . -16) (f169 . -12) (f170 . -8) (f171 . -4) (f172 . 0))
# emit-tail-expr
# si=-16
# env=((f212 . -12) (f212 . -8) (f165 . -28) (f166 . -24) (f167 . -20) (f168 . -16) (f169 . -12) (f170 . -8) (f171 . -4) (f172 . 0))
# expr=((primitive-ref write-char) #\) f212)
# emit-tail-funcall
#    si   =-16
#    env  = ((f212 . -12) (f212 . -8) (f165 . -28) (f166 . -24) (f167 . -20) (f168 . -16) (f169 . -12) (f170 . -8) (f171 . -4) (f172 . 0))
#    expr = (funcall (primitive-ref write-char) #\) f212)
# emit-expr (primitive-ref write-char)
    .extern mrc_write$mchar
    movl mrc_write$mchar,%eax
   movl %eax,  -16(%esp)  # stash funcall-oper in next closure slot
# emit-expr #\)
    movl $10511, %eax     # immed #\)
    mov %eax, -20(%esp)    # arg )
# emit-expr f212
# emit-variable-ref
# env=((f212 . -12) (f212 . -8) (f165 . -28) (f166 . -24) (f167 . -20) (f168 . -16) (f169 . -12) (f170 . -8) (f171 . -4) (f172 . 0))
# var=f212
    movl -12(%esp), %eax  # stack load f212
# end emit-variable-ref
    mov %eax, -24(%esp)    # arg f212
    movl -16(%esp), %edi   # load new closure to %edi
# emit-shift-args:  size=3   si=-16  delta=12
    mov -16(%esp), %ebx  # shift frame cell
    mov %ebx, -4(%esp)  # down to base
# emit-shift-args:  size=2   si=-20  delta=12
    mov -20(%esp), %ebx  # shift frame cell
    mov %ebx, -8(%esp)  # down to base
# emit-shift-args:  size=1   si=-24  delta=12
    mov -24(%esp), %ebx  # shift frame cell
    mov %ebx, -12(%esp)  # down to base
# emit-shift-args:  size=0   si=-28  delta=12
    movl $8,%eax   # save arg count
    jmp *-2(%edi)  # tail-funcall
     ret   # return thru stack
    .align 4,0x90
_L_1236:
    movl -32(%esp), %ebx
    movl -36(%esp), %esi
    movl %eax, -1(%ebx,%esi)
<<<<<<< HEAD
# emit-expr (begin (vector-set! f310957 0 (closure (f310998 f310997) () (let ((f310998 f310998) (f310997 f310997)) (begin ((primitive-ref write-char) #\# f310997) ((primitive-ref write-char) #\\ f310997) ((primitive-ref write-char) f310998 f310997))))) (vector-set! f310956 0 (closure (f310994 f310993) (f310956) (let ((f310994 f310994) (f310993 f310993)) (if ((primitive-ref negative?) f310994) (begin ((primitive-ref write-char) #\- f310993) ((vector-ref f310956 0) (fx* -1 f310994) f310993)) ((primitive-ref map) (closure (f310996) (f310993) (let ((f310996 f310996)) ((primitive-ref write-char) (fixnum->char (fx+ (char->fixnum #\0) f310996)) f310993))) ((primitive-ref integer->list) f310994)))))) (vector-set! f310955 0 (closure (f310990 f310989) () (let ((f310990 f310990) (f310989 f310989)) (begin ((primitive-ref write-char) #\" f310989) ((primitive-ref for-each) (closure (f310992) (f310989) (let ((f310992 f310992)) ((primitive-ref write-char) f310992 f310989))) ((primitive-ref string->list) f310990)) ((primitive-ref write-char) #\" f310989))))) (vector-set! f310954 0 (closure (f310986 f310985) () (let ((f310986 f310986) (f310985 f310985)) ((primitive-ref for-each) (closure (f310988) (f310985) (let ((f310988 f310988)) ((primitive-ref write-char) f310988 f310985))) ((primitive-ref string->list) f310986))))) (vector-set! f310953 0 (closure (f310984 f310983) (f310952) (let ((f310984 f310984) (f310983 f310983)) (begin ((primitive-ref write-char) #\( f310983) ((vector-ref f310952 0) f310984 f310983) ((primitive-ref write-char) #\) f310983))))) (vector-set! f310952 0 (closure (f310982 f310981) (f310952) (let ((f310982 f310982) (f310981 f310981)) (begin ((primitive-ref write) (car f310982) f310981) (if (null? (cdr f310982)) #t (if (pair? (cdr f310982)) (begin ((primitive-ref write-char) #\space f310981) ((vector-ref f310952 0) (cdr f310982) f310981)) (begin ((primitive-ref write-char) #\space f310981) ((primitive-ref write-char) #\. f310981) ((primitive-ref write-char) #\space f310981) ((primitive-ref write) (cdr f310982) f310981)))))))))
# emit-begin
#   expr=(begin (vector-set! f310957 0 (closure (f310998 f310997) () (let ((f310998 f310998) (f310997 f310997)) (begin ((primitive-ref write-char) #\# f310997) ((primitive-ref write-char) #\\ f310997) ((primitive-ref write-char) f310998 f310997))))) (vector-set! f310956 0 (closure (f310994 f310993) (f310956) (let ((f310994 f310994) (f310993 f310993)) (if ((primitive-ref negative?) f310994) (begin ((primitive-ref write-char) #\- f310993) ((vector-ref f310956 0) (fx* -1 f310994) f310993)) ((primitive-ref map) (closure (f310996) (f310993) (let ((f310996 f310996)) ((primitive-ref write-char) (fixnum->char (fx+ (char->fixnum #\0) f310996)) f310993))) ((primitive-ref integer->list) f310994)))))) (vector-set! f310955 0 (closure (f310990 f310989) () (let ((f310990 f310990) (f310989 f310989)) (begin ((primitive-ref write-char) #\" f310989) ((primitive-ref for-each) (closure (f310992) (f310989) (let ((f310992 f310992)) ((primitive-ref write-char) f310992 f310989))) ((primitive-ref string->list) f310990)) ((primitive-ref write-char) #\" f310989))))) (vector-set! f310954 0 (closure (f310986 f310985) () (let ((f310986 f310986) (f310985 f310985)) ((primitive-ref for-each) (closure (f310988) (f310985) (let ((f310988 f310988)) ((primitive-ref write-char) f310988 f310985))) ((primitive-ref string->list) f310986))))) (vector-set! f310953 0 (closure (f310984 f310983) (f310952) (let ((f310984 f310984) (f310983 f310983)) (begin ((primitive-ref write-char) #\( f310983) ((vector-ref f310952 0) f310984 f310983) ((primitive-ref write-char) #\) f310983))))) (vector-set! f310952 0 (closure (f310982 f310981) (f310952) (let ((f310982 f310982) (f310981 f310981)) (begin ((primitive-ref write) (car f310982) f310981) (if (null? (cdr f310982)) #t (if (pair? (cdr f310982)) (begin ((primitive-ref write-char) #\space f310981) ((vector-ref f310952 0) (cdr f310982) f310981)) (begin ((primitive-ref write-char) #\space f310981) ((primitive-ref write-char) #\. f310981) ((primitive-ref write-char) #\space f310981) ((primitive-ref write) (cdr f310982) f310981)))))))))
#   env=((f310952 . -28) (f310953 . -24) (f310954 . -20) (f310955 . -16) (f310956 . -12) (f310957 . -8) (f310958 . -4) (f310959 . 0))
# emit-expr (vector-set! f310957 0 (closure (f310998 f310997) () (let ((f310998 f310998) (f310997 f310997)) (begin ((primitive-ref write-char) #\# f310997) ((primitive-ref write-char) #\\ f310997) ((primitive-ref write-char) f310998 f310997)))))
# emit-expr f310957
=======
# emit-expr (begin (vector-set! f170 0 (closure (f210 f211) () (let ((f210 f210) (f211 f211)) (begin ((primitive-ref write-char) #\# f211) ((primitive-ref write-char) #\\ f211) ((primitive-ref write-char) f210 f211))))) (vector-set! f169 0 (closure (f206 f207) (f169) (let ((f206 f206) (f207 f207)) (if ((primitive-ref negative?) f206) (begin ((primitive-ref write-char) #\- f207) ((vector-ref f169 0) (fx* -1 f206) f207)) ((primitive-ref map) (closure (f209) (f207) (let ((f209 f209)) ((primitive-ref write-char) (fixnum->char (fx+ (char->fixnum #\0) f209)) f207))) ((primitive-ref integer->list) f206)))))) (vector-set! f168 0 (closure (f202 f203) () (let ((f202 f202) (f203 f203)) (begin ((primitive-ref write-char) #\" f203) ((primitive-ref for-each) (closure (f205) (f203) (let ((f205 f205)) ((primitive-ref write-char) f205 f203))) ((primitive-ref string->list) f202)) ((primitive-ref write-char) #\" f203))))) (vector-set! f167 0 (closure (f198 f199) () (let ((f198 f198) (f199 f199)) ((primitive-ref for-each) (closure (f201) (f199) (let ((f201 f201)) ((primitive-ref write-char) f201 f199))) ((primitive-ref string->list) f198))))) (vector-set! f166 0 (closure (f196 f197) (f165) (let ((f196 f196) (f197 f197)) (begin ((primitive-ref write-char) #\( f197) ((vector-ref f165 0) f196 f197) ((primitive-ref write-char) #\) f197))))) (vector-set! f165 0 (closure (f194 f195) (f165) (let ((f194 f194) (f195 f195)) (begin ((primitive-ref write) (car f194) f195) (if (null? (cdr f194)) (begin #t) (if (pair? (cdr f194)) (begin (begin ((primitive-ref write-char) #\space f195) ((vector-ref f165 0) (cdr f194) f195))) (begin (begin ((primitive-ref write-char) #\space f195) ((primitive-ref write-char) #\. f195) ((primitive-ref write-char) #\space f195) ((primitive-ref write) (cdr f194) f195))))))))))
# emit-begin
#   expr=(begin (vector-set! f170 0 (closure (f210 f211) () (let ((f210 f210) (f211 f211)) (begin ((primitive-ref write-char) #\# f211) ((primitive-ref write-char) #\\ f211) ((primitive-ref write-char) f210 f211))))) (vector-set! f169 0 (closure (f206 f207) (f169) (let ((f206 f206) (f207 f207)) (if ((primitive-ref negative?) f206) (begin ((primitive-ref write-char) #\- f207) ((vector-ref f169 0) (fx* -1 f206) f207)) ((primitive-ref map) (closure (f209) (f207) (let ((f209 f209)) ((primitive-ref write-char) (fixnum->char (fx+ (char->fixnum #\0) f209)) f207))) ((primitive-ref integer->list) f206)))))) (vector-set! f168 0 (closure (f202 f203) () (let ((f202 f202) (f203 f203)) (begin ((primitive-ref write-char) #\" f203) ((primitive-ref for-each) (closure (f205) (f203) (let ((f205 f205)) ((primitive-ref write-char) f205 f203))) ((primitive-ref string->list) f202)) ((primitive-ref write-char) #\" f203))))) (vector-set! f167 0 (closure (f198 f199) () (let ((f198 f198) (f199 f199)) ((primitive-ref for-each) (closure (f201) (f199) (let ((f201 f201)) ((primitive-ref write-char) f201 f199))) ((primitive-ref string->list) f198))))) (vector-set! f166 0 (closure (f196 f197) (f165) (let ((f196 f196) (f197 f197)) (begin ((primitive-ref write-char) #\( f197) ((vector-ref f165 0) f196 f197) ((primitive-ref write-char) #\) f197))))) (vector-set! f165 0 (closure (f194 f195) (f165) (let ((f194 f194) (f195 f195)) (begin ((primitive-ref write) (car f194) f195) (if (null? (cdr f194)) (begin #t) (if (pair? (cdr f194)) (begin (begin ((primitive-ref write-char) #\space f195) ((vector-ref f165 0) (cdr f194) f195))) (begin (begin ((primitive-ref write-char) #\space f195) ((primitive-ref write-char) #\. f195) ((primitive-ref write-char) #\space f195) ((primitive-ref write) (cdr f194) f195))))))))))
#   env=((f165 . -28) (f166 . -24) (f167 . -20) (f168 . -16) (f169 . -12) (f170 . -8) (f171 . -4) (f172 . 0))
# emit-expr (vector-set! f170 0 (closure (f210 f211) () (let ((f210 f210) (f211 f211)) (begin ((primitive-ref write-char) #\# f211) ((primitive-ref write-char) #\\ f211) ((primitive-ref write-char) f210 f211)))))
# emit-expr f170
>>>>>>> fix-implicit-begins
# emit-variable-ref
# env=((f165 . -28) (f166 . -24) (f167 . -20) (f168 . -16) (f169 . -12) (f170 . -8) (f171 . -4) (f172 . 0))
# var=f170
    movl -8(%esp), %eax  # stack load f170
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1239
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1239:
    movl %eax, -32(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1240"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1240:
# check bounds on vector index
    movl -32(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1242
    cmp  $0,%eax
    jge _L_1241
_L_1242:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1241:
    movl %eax, -36(%esp)
<<<<<<< HEAD
# emit-expr (closure (f310998 f310997) () (let ((f310998 f310998) (f310997 f310997)) (begin ((primitive-ref write-char) #\# f310997) ((primitive-ref write-char) #\\ f310997) ((primitive-ref write-char) f310998 f310997))))
# emit-closure
# si = -40
# env = ((f310952 . -28) (f310953 . -24) (f310954 . -20) (f310955 . -16) (f310956 . -12) (f310957 . -8) (f310958 . -4) (f310959 . 0))
# expr = (closure (f310998 f310997) () (let ((f310998 f310998) (f310997 f310997)) (begin ((primitive-ref write-char) #\# f310997) ((primitive-ref write-char) #\\ f310997) ((primitive-ref write-char) f310998 f310997))))
    movl $_L_1884842, 0(%ebp)  # closure label
=======
# emit-expr (closure (f210 f211) () (let ((f210 f210) (f211 f211)) (begin ((primitive-ref write-char) #\# f211) ((primitive-ref write-char) #\\ f211) ((primitive-ref write-char) f210 f211))))
# emit-closure
# si = -40
# env = ((f165 . -28) (f166 . -24) (f167 . -20) (f168 . -16) (f169 . -12) (f170 . -8) (f171 . -4) (f172 . 0))
# expr = (closure (f210 f211) () (let ((f210 f210) (f211 f211)) (begin ((primitive-ref write-char) #\# f211) ((primitive-ref write-char) #\\ f211) ((primitive-ref write-char) f210 f211))))
    movl $_L_1243, 0(%ebp)  # closure label
>>>>>>> fix-implicit-begins
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $8, %ebp     # bump ebp
    jmp _L_1244            # jump around closure body
_L_1243:
# check argument count
    cmp $8,%eax
    je _L_1245
# invoke error handler eh_argcount
    .extern mrc_eh$uargcount
    movl mrc_eh$uargcount, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_1245:
# emit-tail-expr
# si=-16
<<<<<<< HEAD
# env=((f310997 . -12) (f310998 . -8) (f310952 . -28) (f310953 . -24) (f310954 . -20) (f310955 . -16) (f310956 . -12) (f310957 . -8) (f310958 . -4) (f310959 . 0))
# expr=(let ((f310998 f310998) (f310997 f310997)) (begin ((primitive-ref write-char) #\# f310997) ((primitive-ref write-char) #\\ f310997) ((primitive-ref write-char) f310998 f310997)))
# emit-tail-let
#  si   = -16
#  env  = ((f310997 . -12) (f310998 . -8) (f310952 . -28) (f310953 . -24) (f310954 . -20) (f310955 . -16) (f310956 . -12) (f310957 . -8) (f310958 . -4) (f310959 . 0))
#  bindings = ((f310998 f310998) (f310997 f310997))
#  body = (begin ((primitive-ref write-char) #\# f310997) ((primitive-ref write-char) #\\ f310997) ((primitive-ref write-char) f310998 f310997))
# emit-expr f310998
# emit-variable-ref
# env=((f310997 . -12) (f310998 . -8) (f310952 . -28) (f310953 . -24) (f310954 . -20) (f310955 . -16) (f310956 . -12) (f310957 . -8) (f310958 . -4) (f310959 . 0))
# var=f310998
    movl -8(%esp), %eax  # stack load f310998
# end emit-variable-ref
    movl %eax, -16(%esp)  # stack save
# emit-expr f310997
# emit-variable-ref
# env=((f310997 . -12) (f310998 . -8) (f310952 . -28) (f310953 . -24) (f310954 . -20) (f310955 . -16) (f310956 . -12) (f310957 . -8) (f310958 . -4) (f310959 . 0))
# var=f310997
    movl -12(%esp), %eax  # stack load f310997
=======
# env=((f211 . -12) (f210 . -8) (f165 . -28) (f166 . -24) (f167 . -20) (f168 . -16) (f169 . -12) (f170 . -8) (f171 . -4) (f172 . 0))
# expr=(let ((f210 f210) (f211 f211)) (begin ((primitive-ref write-char) #\# f211) ((primitive-ref write-char) #\\ f211) ((primitive-ref write-char) f210 f211)))
# emit-tail-let
#  si   = -16
#  env  = ((f211 . -12) (f210 . -8) (f165 . -28) (f166 . -24) (f167 . -20) (f168 . -16) (f169 . -12) (f170 . -8) (f171 . -4) (f172 . 0))
#  bindings = ((f210 f210) (f211 f211))
#  body = (begin ((primitive-ref write-char) #\# f211) ((primitive-ref write-char) #\\ f211) ((primitive-ref write-char) f210 f211))
# emit-expr f210
# emit-variable-ref
# env=((f211 . -12) (f210 . -8) (f165 . -28) (f166 . -24) (f167 . -20) (f168 . -16) (f169 . -12) (f170 . -8) (f171 . -4) (f172 . 0))
# var=f210
    movl -8(%esp), %eax  # stack load f210
# end emit-variable-ref
    movl %eax, -16(%esp)  # stack save
# emit-expr f211
# emit-variable-ref
# env=((f211 . -12) (f210 . -8) (f165 . -28) (f166 . -24) (f167 . -20) (f168 . -16) (f169 . -12) (f170 . -8) (f171 . -4) (f172 . 0))
# var=f211
    movl -12(%esp), %eax  # stack load f211
>>>>>>> fix-implicit-begins
# end emit-variable-ref
    movl %eax, -20(%esp)  # stack save
# emit-tail-expr
# si=-24
<<<<<<< HEAD
# env=((f310997 . -20) (f310998 . -16) (f310997 . -12) (f310998 . -8) (f310952 . -28) (f310953 . -24) (f310954 . -20) (f310955 . -16) (f310956 . -12) (f310957 . -8) (f310958 . -4) (f310959 . 0))
# expr=(begin ((primitive-ref write-char) #\# f310997) ((primitive-ref write-char) #\\ f310997) ((primitive-ref write-char) f310998 f310997))
# tail-begin (begin ((primitive-ref write-char) #\# f310997) ((primitive-ref write-char) #\\ f310997) ((primitive-ref write-char) f310998 f310997))
#   env=((f310997 . -20) (f310998 . -16) (f310997 . -12) (f310998 . -8) (f310952 . -28) (f310953 . -24) (f310954 . -20) (f310955 . -16) (f310956 . -12) (f310957 . -8) (f310958 . -4) (f310959 . 0))
# emit-expr ((primitive-ref write-char) #\# f310997)
# funcall
#    si   =-24
#    env  = ((f310997 . -20) (f310998 . -16) (f310997 . -12) (f310998 . -8) (f310952 . -28) (f310953 . -24) (f310954 . -20) (f310955 . -16) (f310956 . -12) (f310957 . -8) (f310958 . -4) (f310959 . 0))
#    expr = (funcall (primitive-ref write-char) #\# f310997)
=======
# env=((f211 . -20) (f210 . -16) (f211 . -12) (f210 . -8) (f165 . -28) (f166 . -24) (f167 . -20) (f168 . -16) (f169 . -12) (f170 . -8) (f171 . -4) (f172 . 0))
# expr=(begin ((primitive-ref write-char) #\# f211) ((primitive-ref write-char) #\\ f211) ((primitive-ref write-char) f210 f211))
# tail-begin (begin ((primitive-ref write-char) #\# f211) ((primitive-ref write-char) #\\ f211) ((primitive-ref write-char) f210 f211))
#   env=((f211 . -20) (f210 . -16) (f211 . -12) (f210 . -8) (f165 . -28) (f166 . -24) (f167 . -20) (f168 . -16) (f169 . -12) (f170 . -8) (f171 . -4) (f172 . 0))
# emit-expr ((primitive-ref write-char) #\# f211)
# funcall
#    si   =-24
#    env  = ((f211 . -20) (f210 . -16) (f211 . -12) (f210 . -8) (f165 . -28) (f166 . -24) (f167 . -20) (f168 . -16) (f169 . -12) (f170 . -8) (f171 . -4) (f172 . 0))
#    expr = (funcall (primitive-ref write-char) #\# f211)
>>>>>>> fix-implicit-begins
# emit-expr (primitive-ref write-char)
    .extern mrc_write$mchar
    movl mrc_write$mchar,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1246"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1246":
   movl %eax,  -32(%esp)  # stash funcall-oper in closure slot
# emit-expr #\#
    movl $8975, %eax     # immed #\#
    mov %eax, -36(%esp)  # arg #
<<<<<<< HEAD
# emit-expr f310997
# emit-variable-ref
# env=((f310997 . -20) (f310998 . -16) (f310997 . -12) (f310998 . -8) (f310952 . -28) (f310953 . -24) (f310954 . -20) (f310955 . -16) (f310956 . -12) (f310957 . -8) (f310958 . -4) (f310959 . 0))
# var=f310997
    movl -20(%esp), %eax  # stack load f310997
# end emit-variable-ref
    mov %eax, -40(%esp)  # arg f310997
=======
# emit-expr f211
# emit-variable-ref
# env=((f211 . -20) (f210 . -16) (f211 . -12) (f210 . -8) (f165 . -28) (f166 . -24) (f167 . -20) (f168 . -16) (f169 . -12) (f170 . -8) (f171 . -4) (f172 . 0))
# var=f211
    movl -20(%esp), %eax  # stack load f211
# end emit-variable-ref
    mov %eax, -40(%esp)  # arg f211
>>>>>>> fix-implicit-begins
    movl -32(%esp), %edi   # load new closure to %edi
    add $-24, %esp   # adjust base
    movl $8,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $24, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
# emit-tail-expr
# si=-24
<<<<<<< HEAD
# env=((f310997 . -20) (f310998 . -16) (f310997 . -12) (f310998 . -8) (f310952 . -28) (f310953 . -24) (f310954 . -20) (f310955 . -16) (f310956 . -12) (f310957 . -8) (f310958 . -4) (f310959 . 0))
# expr=(begin ((primitive-ref write-char) #\\ f310997) ((primitive-ref write-char) f310998 f310997))
# tail-begin (begin ((primitive-ref write-char) #\\ f310997) ((primitive-ref write-char) f310998 f310997))
#   env=((f310997 . -20) (f310998 . -16) (f310997 . -12) (f310998 . -8) (f310952 . -28) (f310953 . -24) (f310954 . -20) (f310955 . -16) (f310956 . -12) (f310957 . -8) (f310958 . -4) (f310959 . 0))
# emit-expr ((primitive-ref write-char) #\\ f310997)
# funcall
#    si   =-24
#    env  = ((f310997 . -20) (f310998 . -16) (f310997 . -12) (f310998 . -8) (f310952 . -28) (f310953 . -24) (f310954 . -20) (f310955 . -16) (f310956 . -12) (f310957 . -8) (f310958 . -4) (f310959 . 0))
#    expr = (funcall (primitive-ref write-char) #\\ f310997)
=======
# env=((f211 . -20) (f210 . -16) (f211 . -12) (f210 . -8) (f165 . -28) (f166 . -24) (f167 . -20) (f168 . -16) (f169 . -12) (f170 . -8) (f171 . -4) (f172 . 0))
# expr=(begin ((primitive-ref write-char) #\\ f211) ((primitive-ref write-char) f210 f211))
# tail-begin (begin ((primitive-ref write-char) #\\ f211) ((primitive-ref write-char) f210 f211))
#   env=((f211 . -20) (f210 . -16) (f211 . -12) (f210 . -8) (f165 . -28) (f166 . -24) (f167 . -20) (f168 . -16) (f169 . -12) (f170 . -8) (f171 . -4) (f172 . 0))
# emit-expr ((primitive-ref write-char) #\\ f211)
# funcall
#    si   =-24
#    env  = ((f211 . -20) (f210 . -16) (f211 . -12) (f210 . -8) (f165 . -28) (f166 . -24) (f167 . -20) (f168 . -16) (f169 . -12) (f170 . -8) (f171 . -4) (f172 . 0))
#    expr = (funcall (primitive-ref write-char) #\\ f211)
>>>>>>> fix-implicit-begins
# emit-expr (primitive-ref write-char)
    .extern mrc_write$mchar
    movl mrc_write$mchar,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1247"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1247":
   movl %eax,  -32(%esp)  # stash funcall-oper in closure slot
# emit-expr #\\
    movl $23567, %eax     # immed #\\
    mov %eax, -36(%esp)  # arg \
<<<<<<< HEAD
# emit-expr f310997
# emit-variable-ref
# env=((f310997 . -20) (f310998 . -16) (f310997 . -12) (f310998 . -8) (f310952 . -28) (f310953 . -24) (f310954 . -20) (f310955 . -16) (f310956 . -12) (f310957 . -8) (f310958 . -4) (f310959 . 0))
# var=f310997
    movl -20(%esp), %eax  # stack load f310997
# end emit-variable-ref
    mov %eax, -40(%esp)  # arg f310997
=======
# emit-expr f211
# emit-variable-ref
# env=((f211 . -20) (f210 . -16) (f211 . -12) (f210 . -8) (f165 . -28) (f166 . -24) (f167 . -20) (f168 . -16) (f169 . -12) (f170 . -8) (f171 . -4) (f172 . 0))
# var=f211
    movl -20(%esp), %eax  # stack load f211
# end emit-variable-ref
    mov %eax, -40(%esp)  # arg f211
>>>>>>> fix-implicit-begins
    movl -32(%esp), %edi   # load new closure to %edi
    add $-24, %esp   # adjust base
    movl $8,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $24, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
# emit-tail-expr
# si=-24
<<<<<<< HEAD
# env=((f310997 . -20) (f310998 . -16) (f310997 . -12) (f310998 . -8) (f310952 . -28) (f310953 . -24) (f310954 . -20) (f310955 . -16) (f310956 . -12) (f310957 . -8) (f310958 . -4) (f310959 . 0))
# expr=(begin ((primitive-ref write-char) f310998 f310997))
# tail-begin (begin ((primitive-ref write-char) f310998 f310997))
#   env=((f310997 . -20) (f310998 . -16) (f310997 . -12) (f310998 . -8) (f310952 . -28) (f310953 . -24) (f310954 . -20) (f310955 . -16) (f310956 . -12) (f310957 . -8) (f310958 . -4) (f310959 . 0))
# emit-tail-expr
# si=-24
# env=((f310997 . -20) (f310998 . -16) (f310997 . -12) (f310998 . -8) (f310952 . -28) (f310953 . -24) (f310954 . -20) (f310955 . -16) (f310956 . -12) (f310957 . -8) (f310958 . -4) (f310959 . 0))
# expr=((primitive-ref write-char) f310998 f310997)
# emit-tail-funcall
#    si   =-24
#    env  = ((f310997 . -20) (f310998 . -16) (f310997 . -12) (f310998 . -8) (f310952 . -28) (f310953 . -24) (f310954 . -20) (f310955 . -16) (f310956 . -12) (f310957 . -8) (f310958 . -4) (f310959 . 0))
#    expr = (funcall (primitive-ref write-char) f310998 f310997)
=======
# env=((f211 . -20) (f210 . -16) (f211 . -12) (f210 . -8) (f165 . -28) (f166 . -24) (f167 . -20) (f168 . -16) (f169 . -12) (f170 . -8) (f171 . -4) (f172 . 0))
# expr=(begin ((primitive-ref write-char) f210 f211))
# tail-begin (begin ((primitive-ref write-char) f210 f211))
#   env=((f211 . -20) (f210 . -16) (f211 . -12) (f210 . -8) (f165 . -28) (f166 . -24) (f167 . -20) (f168 . -16) (f169 . -12) (f170 . -8) (f171 . -4) (f172 . 0))
# emit-tail-expr
# si=-24
# env=((f211 . -20) (f210 . -16) (f211 . -12) (f210 . -8) (f165 . -28) (f166 . -24) (f167 . -20) (f168 . -16) (f169 . -12) (f170 . -8) (f171 . -4) (f172 . 0))
# expr=((primitive-ref write-char) f210 f211)
# emit-tail-funcall
#    si   =-24
#    env  = ((f211 . -20) (f210 . -16) (f211 . -12) (f210 . -8) (f165 . -28) (f166 . -24) (f167 . -20) (f168 . -16) (f169 . -12) (f170 . -8) (f171 . -4) (f172 . 0))
#    expr = (funcall (primitive-ref write-char) f210 f211)
>>>>>>> fix-implicit-begins
# emit-expr (primitive-ref write-char)
    .extern mrc_write$mchar
    movl mrc_write$mchar,%eax
   movl %eax,  -24(%esp)  # stash funcall-oper in next closure slot
<<<<<<< HEAD
# emit-expr f310998
# emit-variable-ref
# env=((f310997 . -20) (f310998 . -16) (f310997 . -12) (f310998 . -8) (f310952 . -28) (f310953 . -24) (f310954 . -20) (f310955 . -16) (f310956 . -12) (f310957 . -8) (f310958 . -4) (f310959 . 0))
# var=f310998
    movl -16(%esp), %eax  # stack load f310998
# end emit-variable-ref
    mov %eax, -28(%esp)    # arg f310998
# emit-expr f310997
# emit-variable-ref
# env=((f310997 . -20) (f310998 . -16) (f310997 . -12) (f310998 . -8) (f310952 . -28) (f310953 . -24) (f310954 . -20) (f310955 . -16) (f310956 . -12) (f310957 . -8) (f310958 . -4) (f310959 . 0))
# var=f310997
    movl -20(%esp), %eax  # stack load f310997
# end emit-variable-ref
    mov %eax, -32(%esp)    # arg f310997
=======
# emit-expr f210
# emit-variable-ref
# env=((f211 . -20) (f210 . -16) (f211 . -12) (f210 . -8) (f165 . -28) (f166 . -24) (f167 . -20) (f168 . -16) (f169 . -12) (f170 . -8) (f171 . -4) (f172 . 0))
# var=f210
    movl -16(%esp), %eax  # stack load f210
# end emit-variable-ref
    mov %eax, -28(%esp)    # arg f210
# emit-expr f211
# emit-variable-ref
# env=((f211 . -20) (f210 . -16) (f211 . -12) (f210 . -8) (f165 . -28) (f166 . -24) (f167 . -20) (f168 . -16) (f169 . -12) (f170 . -8) (f171 . -4) (f172 . 0))
# var=f211
    movl -20(%esp), %eax  # stack load f211
# end emit-variable-ref
    mov %eax, -32(%esp)    # arg f211
>>>>>>> fix-implicit-begins
    movl -24(%esp), %edi   # load new closure to %edi
# emit-shift-args:  size=3   si=-24  delta=20
    mov -24(%esp), %ebx  # shift frame cell
    mov %ebx, -4(%esp)  # down to base
# emit-shift-args:  size=2   si=-28  delta=20
    mov -28(%esp), %ebx  # shift frame cell
    mov %ebx, -8(%esp)  # down to base
# emit-shift-args:  size=1   si=-32  delta=20
    mov -32(%esp), %ebx  # shift frame cell
    mov %ebx, -12(%esp)  # down to base
# emit-shift-args:  size=0   si=-36  delta=20
    movl $8,%eax   # save arg count
    jmp *-2(%edi)  # tail-funcall
     ret   # return thru stack
    .align 4,0x90
_L_1244:
    movl -32(%esp), %ebx
    movl -36(%esp), %esi
    movl %eax, -1(%ebx,%esi)
<<<<<<< HEAD
# emit-expr (begin (vector-set! f310956 0 (closure (f310994 f310993) (f310956) (let ((f310994 f310994) (f310993 f310993)) (if ((primitive-ref negative?) f310994) (begin ((primitive-ref write-char) #\- f310993) ((vector-ref f310956 0) (fx* -1 f310994) f310993)) ((primitive-ref map) (closure (f310996) (f310993) (let ((f310996 f310996)) ((primitive-ref write-char) (fixnum->char (fx+ (char->fixnum #\0) f310996)) f310993))) ((primitive-ref integer->list) f310994)))))) (vector-set! f310955 0 (closure (f310990 f310989) () (let ((f310990 f310990) (f310989 f310989)) (begin ((primitive-ref write-char) #\" f310989) ((primitive-ref for-each) (closure (f310992) (f310989) (let ((f310992 f310992)) ((primitive-ref write-char) f310992 f310989))) ((primitive-ref string->list) f310990)) ((primitive-ref write-char) #\" f310989))))) (vector-set! f310954 0 (closure (f310986 f310985) () (let ((f310986 f310986) (f310985 f310985)) ((primitive-ref for-each) (closure (f310988) (f310985) (let ((f310988 f310988)) ((primitive-ref write-char) f310988 f310985))) ((primitive-ref string->list) f310986))))) (vector-set! f310953 0 (closure (f310984 f310983) (f310952) (let ((f310984 f310984) (f310983 f310983)) (begin ((primitive-ref write-char) #\( f310983) ((vector-ref f310952 0) f310984 f310983) ((primitive-ref write-char) #\) f310983))))) (vector-set! f310952 0 (closure (f310982 f310981) (f310952) (let ((f310982 f310982) (f310981 f310981)) (begin ((primitive-ref write) (car f310982) f310981) (if (null? (cdr f310982)) #t (if (pair? (cdr f310982)) (begin ((primitive-ref write-char) #\space f310981) ((vector-ref f310952 0) (cdr f310982) f310981)) (begin ((primitive-ref write-char) #\space f310981) ((primitive-ref write-char) #\. f310981) ((primitive-ref write-char) #\space f310981) ((primitive-ref write) (cdr f310982) f310981)))))))))
# emit-begin
#   expr=(begin (vector-set! f310956 0 (closure (f310994 f310993) (f310956) (let ((f310994 f310994) (f310993 f310993)) (if ((primitive-ref negative?) f310994) (begin ((primitive-ref write-char) #\- f310993) ((vector-ref f310956 0) (fx* -1 f310994) f310993)) ((primitive-ref map) (closure (f310996) (f310993) (let ((f310996 f310996)) ((primitive-ref write-char) (fixnum->char (fx+ (char->fixnum #\0) f310996)) f310993))) ((primitive-ref integer->list) f310994)))))) (vector-set! f310955 0 (closure (f310990 f310989) () (let ((f310990 f310990) (f310989 f310989)) (begin ((primitive-ref write-char) #\" f310989) ((primitive-ref for-each) (closure (f310992) (f310989) (let ((f310992 f310992)) ((primitive-ref write-char) f310992 f310989))) ((primitive-ref string->list) f310990)) ((primitive-ref write-char) #\" f310989))))) (vector-set! f310954 0 (closure (f310986 f310985) () (let ((f310986 f310986) (f310985 f310985)) ((primitive-ref for-each) (closure (f310988) (f310985) (let ((f310988 f310988)) ((primitive-ref write-char) f310988 f310985))) ((primitive-ref string->list) f310986))))) (vector-set! f310953 0 (closure (f310984 f310983) (f310952) (let ((f310984 f310984) (f310983 f310983)) (begin ((primitive-ref write-char) #\( f310983) ((vector-ref f310952 0) f310984 f310983) ((primitive-ref write-char) #\) f310983))))) (vector-set! f310952 0 (closure (f310982 f310981) (f310952) (let ((f310982 f310982) (f310981 f310981)) (begin ((primitive-ref write) (car f310982) f310981) (if (null? (cdr f310982)) #t (if (pair? (cdr f310982)) (begin ((primitive-ref write-char) #\space f310981) ((vector-ref f310952 0) (cdr f310982) f310981)) (begin ((primitive-ref write-char) #\space f310981) ((primitive-ref write-char) #\. f310981) ((primitive-ref write-char) #\space f310981) ((primitive-ref write) (cdr f310982) f310981)))))))))
#   env=((f310952 . -28) (f310953 . -24) (f310954 . -20) (f310955 . -16) (f310956 . -12) (f310957 . -8) (f310958 . -4) (f310959 . 0))
# emit-expr (vector-set! f310956 0 (closure (f310994 f310993) (f310956) (let ((f310994 f310994) (f310993 f310993)) (if ((primitive-ref negative?) f310994) (begin ((primitive-ref write-char) #\- f310993) ((vector-ref f310956 0) (fx* -1 f310994) f310993)) ((primitive-ref map) (closure (f310996) (f310993) (let ((f310996 f310996)) ((primitive-ref write-char) (fixnum->char (fx+ (char->fixnum #\0) f310996)) f310993))) ((primitive-ref integer->list) f310994))))))
# emit-expr f310956
=======
# emit-expr (begin (vector-set! f169 0 (closure (f206 f207) (f169) (let ((f206 f206) (f207 f207)) (if ((primitive-ref negative?) f206) (begin ((primitive-ref write-char) #\- f207) ((vector-ref f169 0) (fx* -1 f206) f207)) ((primitive-ref map) (closure (f209) (f207) (let ((f209 f209)) ((primitive-ref write-char) (fixnum->char (fx+ (char->fixnum #\0) f209)) f207))) ((primitive-ref integer->list) f206)))))) (vector-set! f168 0 (closure (f202 f203) () (let ((f202 f202) (f203 f203)) (begin ((primitive-ref write-char) #\" f203) ((primitive-ref for-each) (closure (f205) (f203) (let ((f205 f205)) ((primitive-ref write-char) f205 f203))) ((primitive-ref string->list) f202)) ((primitive-ref write-char) #\" f203))))) (vector-set! f167 0 (closure (f198 f199) () (let ((f198 f198) (f199 f199)) ((primitive-ref for-each) (closure (f201) (f199) (let ((f201 f201)) ((primitive-ref write-char) f201 f199))) ((primitive-ref string->list) f198))))) (vector-set! f166 0 (closure (f196 f197) (f165) (let ((f196 f196) (f197 f197)) (begin ((primitive-ref write-char) #\( f197) ((vector-ref f165 0) f196 f197) ((primitive-ref write-char) #\) f197))))) (vector-set! f165 0 (closure (f194 f195) (f165) (let ((f194 f194) (f195 f195)) (begin ((primitive-ref write) (car f194) f195) (if (null? (cdr f194)) (begin #t) (if (pair? (cdr f194)) (begin (begin ((primitive-ref write-char) #\space f195) ((vector-ref f165 0) (cdr f194) f195))) (begin (begin ((primitive-ref write-char) #\space f195) ((primitive-ref write-char) #\. f195) ((primitive-ref write-char) #\space f195) ((primitive-ref write) (cdr f194) f195))))))))))
# emit-begin
#   expr=(begin (vector-set! f169 0 (closure (f206 f207) (f169) (let ((f206 f206) (f207 f207)) (if ((primitive-ref negative?) f206) (begin ((primitive-ref write-char) #\- f207) ((vector-ref f169 0) (fx* -1 f206) f207)) ((primitive-ref map) (closure (f209) (f207) (let ((f209 f209)) ((primitive-ref write-char) (fixnum->char (fx+ (char->fixnum #\0) f209)) f207))) ((primitive-ref integer->list) f206)))))) (vector-set! f168 0 (closure (f202 f203) () (let ((f202 f202) (f203 f203)) (begin ((primitive-ref write-char) #\" f203) ((primitive-ref for-each) (closure (f205) (f203) (let ((f205 f205)) ((primitive-ref write-char) f205 f203))) ((primitive-ref string->list) f202)) ((primitive-ref write-char) #\" f203))))) (vector-set! f167 0 (closure (f198 f199) () (let ((f198 f198) (f199 f199)) ((primitive-ref for-each) (closure (f201) (f199) (let ((f201 f201)) ((primitive-ref write-char) f201 f199))) ((primitive-ref string->list) f198))))) (vector-set! f166 0 (closure (f196 f197) (f165) (let ((f196 f196) (f197 f197)) (begin ((primitive-ref write-char) #\( f197) ((vector-ref f165 0) f196 f197) ((primitive-ref write-char) #\) f197))))) (vector-set! f165 0 (closure (f194 f195) (f165) (let ((f194 f194) (f195 f195)) (begin ((primitive-ref write) (car f194) f195) (if (null? (cdr f194)) (begin #t) (if (pair? (cdr f194)) (begin (begin ((primitive-ref write-char) #\space f195) ((vector-ref f165 0) (cdr f194) f195))) (begin (begin ((primitive-ref write-char) #\space f195) ((primitive-ref write-char) #\. f195) ((primitive-ref write-char) #\space f195) ((primitive-ref write) (cdr f194) f195))))))))))
#   env=((f165 . -28) (f166 . -24) (f167 . -20) (f168 . -16) (f169 . -12) (f170 . -8) (f171 . -4) (f172 . 0))
# emit-expr (vector-set! f169 0 (closure (f206 f207) (f169) (let ((f206 f206) (f207 f207)) (if ((primitive-ref negative?) f206) (begin ((primitive-ref write-char) #\- f207) ((vector-ref f169 0) (fx* -1 f206) f207)) ((primitive-ref map) (closure (f209) (f207) (let ((f209 f209)) ((primitive-ref write-char) (fixnum->char (fx+ (char->fixnum #\0) f209)) f207))) ((primitive-ref integer->list) f206))))))
# emit-expr f169
>>>>>>> fix-implicit-begins
# emit-variable-ref
# env=((f165 . -28) (f166 . -24) (f167 . -20) (f168 . -16) (f169 . -12) (f170 . -8) (f171 . -4) (f172 . 0))
# var=f169
    movl -12(%esp), %eax  # stack load f169
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1248
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1248:
    movl %eax, -32(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1249"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1249:
# check bounds on vector index
    movl -32(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1251
    cmp  $0,%eax
    jge _L_1250
_L_1251:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1250:
    movl %eax, -36(%esp)
<<<<<<< HEAD
# emit-expr (closure (f310994 f310993) (f310956) (let ((f310994 f310994) (f310993 f310993)) (if ((primitive-ref negative?) f310994) (begin ((primitive-ref write-char) #\- f310993) ((vector-ref f310956 0) (fx* -1 f310994) f310993)) ((primitive-ref map) (closure (f310996) (f310993) (let ((f310996 f310996)) ((primitive-ref write-char) (fixnum->char (fx+ (char->fixnum #\0) f310996)) f310993))) ((primitive-ref integer->list) f310994)))))
# emit-closure
# si = -40
# env = ((f310952 . -28) (f310953 . -24) (f310954 . -20) (f310955 . -16) (f310956 . -12) (f310957 . -8) (f310958 . -4) (f310959 . 0))
# expr = (closure (f310994 f310993) (f310956) (let ((f310994 f310994) (f310993 f310993)) (if ((primitive-ref negative?) f310994) (begin ((primitive-ref write-char) #\- f310993) ((vector-ref f310956 0) (fx* -1 f310994) f310993)) ((primitive-ref map) (closure (f310996) (f310993) (let ((f310996 f310996)) ((primitive-ref write-char) (fixnum->char (fx+ (char->fixnum #\0) f310996)) f310993))) ((primitive-ref integer->list) f310994)))))
    movl $_L_1884851, 0(%ebp)  # closure label
=======
# emit-expr (closure (f206 f207) (f169) (let ((f206 f206) (f207 f207)) (if ((primitive-ref negative?) f206) (begin ((primitive-ref write-char) #\- f207) ((vector-ref f169 0) (fx* -1 f206) f207)) ((primitive-ref map) (closure (f209) (f207) (let ((f209 f209)) ((primitive-ref write-char) (fixnum->char (fx+ (char->fixnum #\0) f209)) f207))) ((primitive-ref integer->list) f206)))))
# emit-closure
# si = -40
# env = ((f165 . -28) (f166 . -24) (f167 . -20) (f168 . -16) (f169 . -12) (f170 . -8) (f171 . -4) (f172 . 0))
# expr = (closure (f206 f207) (f169) (let ((f206 f206) (f207 f207)) (if ((primitive-ref negative?) f206) (begin ((primitive-ref write-char) #\- f207) ((vector-ref f169 0) (fx* -1 f206) f207)) ((primitive-ref map) (closure (f209) (f207) (let ((f209 f209)) ((primitive-ref write-char) (fixnum->char (fx+ (char->fixnum #\0) f209)) f207))) ((primitive-ref integer->list) f206)))))
    movl $_L_1252, 0(%ebp)  # closure label
>>>>>>> fix-implicit-begins
# emit-variable-ref
# env=((f165 . -28) (f166 . -24) (f167 . -20) (f168 . -16) (f169 . -12) (f170 . -8) (f171 . -4) (f172 . 0))
# var=f169
    movl -12(%esp), %eax  # stack load f169
# end emit-variable-ref
   movl  %eax, 4(%ebp)  # f169
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $8, %ebp     # bump ebp
    jmp _L_1253            # jump around closure body
_L_1252:
# check argument count
    cmp $8,%eax
    je _L_1254
# invoke error handler eh_argcount
    .extern mrc_eh$uargcount
    movl mrc_eh$uargcount, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_1254:
# emit-tail-expr
# si=-16
<<<<<<< HEAD
# env=((f310993 . -12) (f310994 . -8) (f310956 . 4) (f310952 . -28) (f310953 . -24) (f310954 . -20) (f310955 . -16) (f310956 . -12) (f310957 . -8) (f310958 . -4) (f310959 . 0))
# expr=(let ((f310994 f310994) (f310993 f310993)) (if ((primitive-ref negative?) f310994) (begin ((primitive-ref write-char) #\- f310993) ((vector-ref f310956 0) (fx* -1 f310994) f310993)) ((primitive-ref map) (closure (f310996) (f310993) (let ((f310996 f310996)) ((primitive-ref write-char) (fixnum->char (fx+ (char->fixnum #\0) f310996)) f310993))) ((primitive-ref integer->list) f310994))))
# emit-tail-let
#  si   = -16
#  env  = ((f310993 . -12) (f310994 . -8) (f310956 . 4) (f310952 . -28) (f310953 . -24) (f310954 . -20) (f310955 . -16) (f310956 . -12) (f310957 . -8) (f310958 . -4) (f310959 . 0))
#  bindings = ((f310994 f310994) (f310993 f310993))
#  body = (if ((primitive-ref negative?) f310994) (begin ((primitive-ref write-char) #\- f310993) ((vector-ref f310956 0) (fx* -1 f310994) f310993)) ((primitive-ref map) (closure (f310996) (f310993) (let ((f310996 f310996)) ((primitive-ref write-char) (fixnum->char (fx+ (char->fixnum #\0) f310996)) f310993))) ((primitive-ref integer->list) f310994)))
# emit-expr f310994
# emit-variable-ref
# env=((f310993 . -12) (f310994 . -8) (f310956 . 4) (f310952 . -28) (f310953 . -24) (f310954 . -20) (f310955 . -16) (f310956 . -12) (f310957 . -8) (f310958 . -4) (f310959 . 0))
# var=f310994
    movl -8(%esp), %eax  # stack load f310994
# end emit-variable-ref
    movl %eax, -16(%esp)  # stack save
# emit-expr f310993
# emit-variable-ref
# env=((f310993 . -12) (f310994 . -8) (f310956 . 4) (f310952 . -28) (f310953 . -24) (f310954 . -20) (f310955 . -16) (f310956 . -12) (f310957 . -8) (f310958 . -4) (f310959 . 0))
# var=f310993
    movl -12(%esp), %eax  # stack load f310993
=======
# env=((f207 . -12) (f206 . -8) (f169 . 4) (f165 . -28) (f166 . -24) (f167 . -20) (f168 . -16) (f169 . -12) (f170 . -8) (f171 . -4) (f172 . 0))
# expr=(let ((f206 f206) (f207 f207)) (if ((primitive-ref negative?) f206) (begin ((primitive-ref write-char) #\- f207) ((vector-ref f169 0) (fx* -1 f206) f207)) ((primitive-ref map) (closure (f209) (f207) (let ((f209 f209)) ((primitive-ref write-char) (fixnum->char (fx+ (char->fixnum #\0) f209)) f207))) ((primitive-ref integer->list) f206))))
# emit-tail-let
#  si   = -16
#  env  = ((f207 . -12) (f206 . -8) (f169 . 4) (f165 . -28) (f166 . -24) (f167 . -20) (f168 . -16) (f169 . -12) (f170 . -8) (f171 . -4) (f172 . 0))
#  bindings = ((f206 f206) (f207 f207))
#  body = (if ((primitive-ref negative?) f206) (begin ((primitive-ref write-char) #\- f207) ((vector-ref f169 0) (fx* -1 f206) f207)) ((primitive-ref map) (closure (f209) (f207) (let ((f209 f209)) ((primitive-ref write-char) (fixnum->char (fx+ (char->fixnum #\0) f209)) f207))) ((primitive-ref integer->list) f206)))
# emit-expr f206
# emit-variable-ref
# env=((f207 . -12) (f206 . -8) (f169 . 4) (f165 . -28) (f166 . -24) (f167 . -20) (f168 . -16) (f169 . -12) (f170 . -8) (f171 . -4) (f172 . 0))
# var=f206
    movl -8(%esp), %eax  # stack load f206
# end emit-variable-ref
    movl %eax, -16(%esp)  # stack save
# emit-expr f207
# emit-variable-ref
# env=((f207 . -12) (f206 . -8) (f169 . 4) (f165 . -28) (f166 . -24) (f167 . -20) (f168 . -16) (f169 . -12) (f170 . -8) (f171 . -4) (f172 . 0))
# var=f207
    movl -12(%esp), %eax  # stack load f207
>>>>>>> fix-implicit-begins
# end emit-variable-ref
    movl %eax, -20(%esp)  # stack save
# emit-tail-expr
# si=-24
<<<<<<< HEAD
# env=((f310993 . -20) (f310994 . -16) (f310993 . -12) (f310994 . -8) (f310956 . 4) (f310952 . -28) (f310953 . -24) (f310954 . -20) (f310955 . -16) (f310956 . -12) (f310957 . -8) (f310958 . -4) (f310959 . 0))
# expr=(if ((primitive-ref negative?) f310994) (begin ((primitive-ref write-char) #\- f310993) ((vector-ref f310956 0) (fx* -1 f310994) f310993)) ((primitive-ref map) (closure (f310996) (f310993) (let ((f310996 f310996)) ((primitive-ref write-char) (fixnum->char (fx+ (char->fixnum #\0) f310996)) f310993))) ((primitive-ref integer->list) f310994)))
# emit-expr ((primitive-ref negative?) f310994)
# funcall
#    si   =-24
#    env  = ((f310993 . -20) (f310994 . -16) (f310993 . -12) (f310994 . -8) (f310956 . 4) (f310952 . -28) (f310953 . -24) (f310954 . -20) (f310955 . -16) (f310956 . -12) (f310957 . -8) (f310958 . -4) (f310959 . 0))
#    expr = (funcall (primitive-ref negative?) f310994)
=======
# env=((f207 . -20) (f206 . -16) (f207 . -12) (f206 . -8) (f169 . 4) (f165 . -28) (f166 . -24) (f167 . -20) (f168 . -16) (f169 . -12) (f170 . -8) (f171 . -4) (f172 . 0))
# expr=(if ((primitive-ref negative?) f206) (begin ((primitive-ref write-char) #\- f207) ((vector-ref f169 0) (fx* -1 f206) f207)) ((primitive-ref map) (closure (f209) (f207) (let ((f209 f209)) ((primitive-ref write-char) (fixnum->char (fx+ (char->fixnum #\0) f209)) f207))) ((primitive-ref integer->list) f206)))
# emit-expr ((primitive-ref negative?) f206)
# funcall
#    si   =-24
#    env  = ((f207 . -20) (f206 . -16) (f207 . -12) (f206 . -8) (f169 . 4) (f165 . -28) (f166 . -24) (f167 . -20) (f168 . -16) (f169 . -12) (f170 . -8) (f171 . -4) (f172 . 0))
#    expr = (funcall (primitive-ref negative?) f206)
>>>>>>> fix-implicit-begins
# emit-expr (primitive-ref negative?)
    .extern mrc_negative$q
    movl mrc_negative$q,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1257"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1257":
   movl %eax,  -32(%esp)  # stash funcall-oper in closure slot
<<<<<<< HEAD
# emit-expr f310994
# emit-variable-ref
# env=((f310993 . -20) (f310994 . -16) (f310993 . -12) (f310994 . -8) (f310956 . 4) (f310952 . -28) (f310953 . -24) (f310954 . -20) (f310955 . -16) (f310956 . -12) (f310957 . -8) (f310958 . -4) (f310959 . 0))
# var=f310994
    movl -16(%esp), %eax  # stack load f310994
# end emit-variable-ref
    mov %eax, -36(%esp)  # arg f310994
=======
# emit-expr f206
# emit-variable-ref
# env=((f207 . -20) (f206 . -16) (f207 . -12) (f206 . -8) (f169 . 4) (f165 . -28) (f166 . -24) (f167 . -20) (f168 . -16) (f169 . -12) (f170 . -8) (f171 . -4) (f172 . 0))
# var=f206
    movl -16(%esp), %eax  # stack load f206
# end emit-variable-ref
    mov %eax, -36(%esp)  # arg f206
>>>>>>> fix-implicit-begins
    movl -32(%esp), %edi   # load new closure to %edi
    add $-24, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $24, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    cmp $47, %al
    je _L_1255
# emit-tail-expr
# si=-24
<<<<<<< HEAD
# env=((f310993 . -20) (f310994 . -16) (f310993 . -12) (f310994 . -8) (f310956 . 4) (f310952 . -28) (f310953 . -24) (f310954 . -20) (f310955 . -16) (f310956 . -12) (f310957 . -8) (f310958 . -4) (f310959 . 0))
# expr=(begin ((primitive-ref write-char) #\- f310993) ((vector-ref f310956 0) (fx* -1 f310994) f310993))
# tail-begin (begin ((primitive-ref write-char) #\- f310993) ((vector-ref f310956 0) (fx* -1 f310994) f310993))
#   env=((f310993 . -20) (f310994 . -16) (f310993 . -12) (f310994 . -8) (f310956 . 4) (f310952 . -28) (f310953 . -24) (f310954 . -20) (f310955 . -16) (f310956 . -12) (f310957 . -8) (f310958 . -4) (f310959 . 0))
# emit-expr ((primitive-ref write-char) #\- f310993)
# funcall
#    si   =-24
#    env  = ((f310993 . -20) (f310994 . -16) (f310993 . -12) (f310994 . -8) (f310956 . 4) (f310952 . -28) (f310953 . -24) (f310954 . -20) (f310955 . -16) (f310956 . -12) (f310957 . -8) (f310958 . -4) (f310959 . 0))
#    expr = (funcall (primitive-ref write-char) #\- f310993)
=======
# env=((f207 . -20) (f206 . -16) (f207 . -12) (f206 . -8) (f169 . 4) (f165 . -28) (f166 . -24) (f167 . -20) (f168 . -16) (f169 . -12) (f170 . -8) (f171 . -4) (f172 . 0))
# expr=(begin ((primitive-ref write-char) #\- f207) ((vector-ref f169 0) (fx* -1 f206) f207))
# tail-begin (begin ((primitive-ref write-char) #\- f207) ((vector-ref f169 0) (fx* -1 f206) f207))
#   env=((f207 . -20) (f206 . -16) (f207 . -12) (f206 . -8) (f169 . 4) (f165 . -28) (f166 . -24) (f167 . -20) (f168 . -16) (f169 . -12) (f170 . -8) (f171 . -4) (f172 . 0))
# emit-expr ((primitive-ref write-char) #\- f207)
# funcall
#    si   =-24
#    env  = ((f207 . -20) (f206 . -16) (f207 . -12) (f206 . -8) (f169 . 4) (f165 . -28) (f166 . -24) (f167 . -20) (f168 . -16) (f169 . -12) (f170 . -8) (f171 . -4) (f172 . 0))
#    expr = (funcall (primitive-ref write-char) #\- f207)
>>>>>>> fix-implicit-begins
# emit-expr (primitive-ref write-char)
    .extern mrc_write$mchar
    movl mrc_write$mchar,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1258"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1258":
   movl %eax,  -32(%esp)  # stash funcall-oper in closure slot
# emit-expr #\-
    movl $11535, %eax     # immed #\-
    mov %eax, -36(%esp)  # arg -
<<<<<<< HEAD
# emit-expr f310993
# emit-variable-ref
# env=((f310993 . -20) (f310994 . -16) (f310993 . -12) (f310994 . -8) (f310956 . 4) (f310952 . -28) (f310953 . -24) (f310954 . -20) (f310955 . -16) (f310956 . -12) (f310957 . -8) (f310958 . -4) (f310959 . 0))
# var=f310993
    movl -20(%esp), %eax  # stack load f310993
# end emit-variable-ref
    mov %eax, -40(%esp)  # arg f310993
=======
# emit-expr f207
# emit-variable-ref
# env=((f207 . -20) (f206 . -16) (f207 . -12) (f206 . -8) (f169 . 4) (f165 . -28) (f166 . -24) (f167 . -20) (f168 . -16) (f169 . -12) (f170 . -8) (f171 . -4) (f172 . 0))
# var=f207
    movl -20(%esp), %eax  # stack load f207
# end emit-variable-ref
    mov %eax, -40(%esp)  # arg f207
>>>>>>> fix-implicit-begins
    movl -32(%esp), %edi   # load new closure to %edi
    add $-24, %esp   # adjust base
    movl $8,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $24, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
# emit-tail-expr
# si=-24
<<<<<<< HEAD
# env=((f310993 . -20) (f310994 . -16) (f310993 . -12) (f310994 . -8) (f310956 . 4) (f310952 . -28) (f310953 . -24) (f310954 . -20) (f310955 . -16) (f310956 . -12) (f310957 . -8) (f310958 . -4) (f310959 . 0))
# expr=(begin ((vector-ref f310956 0) (fx* -1 f310994) f310993))
# tail-begin (begin ((vector-ref f310956 0) (fx* -1 f310994) f310993))
#   env=((f310993 . -20) (f310994 . -16) (f310993 . -12) (f310994 . -8) (f310956 . 4) (f310952 . -28) (f310953 . -24) (f310954 . -20) (f310955 . -16) (f310956 . -12) (f310957 . -8) (f310958 . -4) (f310959 . 0))
# emit-tail-expr
# si=-24
# env=((f310993 . -20) (f310994 . -16) (f310993 . -12) (f310994 . -8) (f310956 . 4) (f310952 . -28) (f310953 . -24) (f310954 . -20) (f310955 . -16) (f310956 . -12) (f310957 . -8) (f310958 . -4) (f310959 . 0))
# expr=((vector-ref f310956 0) (fx* -1 f310994) f310993)
# emit-tail-funcall
#    si   =-24
#    env  = ((f310993 . -20) (f310994 . -16) (f310993 . -12) (f310994 . -8) (f310956 . 4) (f310952 . -28) (f310953 . -24) (f310954 . -20) (f310955 . -16) (f310956 . -12) (f310957 . -8) (f310958 . -4) (f310959 . 0))
#    expr = (funcall (vector-ref f310956 0) (fx* -1 f310994) f310993)
# emit-expr (vector-ref f310956 0)
# emit-expr f310956
# emit-variable-ref
# env=((f310993 . -20) (f310994 . -16) (f310993 . -12) (f310994 . -8) (f310956 . 4) (f310952 . -28) (f310953 . -24) (f310954 . -20) (f310955 . -16) (f310956 . -12) (f310957 . -8) (f310958 . -4) (f310959 . 0))
# var=f310956
    movl 2(%edi), %eax  # frame load f310956
=======
# env=((f207 . -20) (f206 . -16) (f207 . -12) (f206 . -8) (f169 . 4) (f165 . -28) (f166 . -24) (f167 . -20) (f168 . -16) (f169 . -12) (f170 . -8) (f171 . -4) (f172 . 0))
# expr=(begin ((vector-ref f169 0) (fx* -1 f206) f207))
# tail-begin (begin ((vector-ref f169 0) (fx* -1 f206) f207))
#   env=((f207 . -20) (f206 . -16) (f207 . -12) (f206 . -8) (f169 . 4) (f165 . -28) (f166 . -24) (f167 . -20) (f168 . -16) (f169 . -12) (f170 . -8) (f171 . -4) (f172 . 0))
# emit-tail-expr
# si=-24
# env=((f207 . -20) (f206 . -16) (f207 . -12) (f206 . -8) (f169 . 4) (f165 . -28) (f166 . -24) (f167 . -20) (f168 . -16) (f169 . -12) (f170 . -8) (f171 . -4) (f172 . 0))
# expr=((vector-ref f169 0) (fx* -1 f206) f207)
# emit-tail-funcall
#    si   =-24
#    env  = ((f207 . -20) (f206 . -16) (f207 . -12) (f206 . -8) (f169 . 4) (f165 . -28) (f166 . -24) (f167 . -20) (f168 . -16) (f169 . -12) (f170 . -8) (f171 . -4) (f172 . 0))
#    expr = (funcall (vector-ref f169 0) (fx* -1 f206) f207)
# emit-expr (vector-ref f169 0)
# emit-expr f169
# emit-variable-ref
# env=((f207 . -20) (f206 . -16) (f207 . -12) (f206 . -8) (f169 . 4) (f165 . -28) (f166 . -24) (f167 . -20) (f168 . -16) (f169 . -12) (f170 . -8) (f171 . -4) (f172 . 0))
# var=f169
    movl 2(%edi), %eax  # frame load f169
>>>>>>> fix-implicit-begins
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1259
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1259:
    movl %eax, -24(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1260"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1260:
# check bounds on vector index
    movl -24(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1262
    cmp  $0,%eax
    jge _L_1261
_L_1262:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1261:
    movl -24(%esp), %esi
    movl -1(%eax,%esi), %eax
   movl %eax,  -24(%esp)  # stash funcall-oper in next closure slot
<<<<<<< HEAD
# emit-expr (fx* -1 f310994)
# emit-expr f310994
# emit-variable-ref
# env=((f310993 . -20) (f310994 . -16) (f310993 . -12) (f310994 . -8) (f310956 . 4) (f310952 . -28) (f310953 . -24) (f310954 . -20) (f310955 . -16) (f310956 . -12) (f310957 . -8) (f310958 . -4) (f310959 . 0))
# var=f310994
    movl -16(%esp), %eax  # stack load f310994
=======
# emit-expr (fx* -1 f206)
# emit-expr f206
# emit-variable-ref
# env=((f207 . -20) (f206 . -16) (f207 . -12) (f206 . -8) (f169 . 4) (f165 . -28) (f166 . -24) (f167 . -20) (f168 . -16) (f169 . -12) (f170 . -8) (f171 . -4) (f172 . 0))
# var=f206
    movl -16(%esp), %eax  # stack load f206
>>>>>>> fix-implicit-begins
# end emit-variable-ref
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1263"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $96,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1263:
    sar $2, %eax
    movl %eax, -28(%esp)
# emit-expr -1
    movl $-4, %eax     # immed -1
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1264"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $96,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1264:
    imul -28(%esp), %eax
<<<<<<< HEAD
    mov %eax, -28(%esp)    # arg (fx* -1 f310994)
# emit-expr f310993
# emit-variable-ref
# env=((f310993 . -20) (f310994 . -16) (f310993 . -12) (f310994 . -8) (f310956 . 4) (f310952 . -28) (f310953 . -24) (f310954 . -20) (f310955 . -16) (f310956 . -12) (f310957 . -8) (f310958 . -4) (f310959 . 0))
# var=f310993
    movl -20(%esp), %eax  # stack load f310993
# end emit-variable-ref
    mov %eax, -32(%esp)    # arg f310993
=======
    mov %eax, -28(%esp)    # arg (fx* -1 f206)
# emit-expr f207
# emit-variable-ref
# env=((f207 . -20) (f206 . -16) (f207 . -12) (f206 . -8) (f169 . 4) (f165 . -28) (f166 . -24) (f167 . -20) (f168 . -16) (f169 . -12) (f170 . -8) (f171 . -4) (f172 . 0))
# var=f207
    movl -20(%esp), %eax  # stack load f207
# end emit-variable-ref
    mov %eax, -32(%esp)    # arg f207
>>>>>>> fix-implicit-begins
    movl -24(%esp), %edi   # load new closure to %edi
# emit-shift-args:  size=3   si=-24  delta=20
    mov -24(%esp), %ebx  # shift frame cell
    mov %ebx, -4(%esp)  # down to base
# emit-shift-args:  size=2   si=-28  delta=20
    mov -28(%esp), %ebx  # shift frame cell
    mov %ebx, -8(%esp)  # down to base
# emit-shift-args:  size=1   si=-32  delta=20
    mov -32(%esp), %ebx  # shift frame cell
    mov %ebx, -12(%esp)  # down to base
# emit-shift-args:  size=0   si=-36  delta=20
    movl $8,%eax   # save arg count
    jmp *-2(%edi)  # tail-funcall
     ret   # return thru stack
    jmp _L_1256
_L_1255:
# emit-tail-expr
# si=-24
<<<<<<< HEAD
# env=((f310993 . -20) (f310994 . -16) (f310993 . -12) (f310994 . -8) (f310956 . 4) (f310952 . -28) (f310953 . -24) (f310954 . -20) (f310955 . -16) (f310956 . -12) (f310957 . -8) (f310958 . -4) (f310959 . 0))
# expr=((primitive-ref map) (closure (f310996) (f310993) (let ((f310996 f310996)) ((primitive-ref write-char) (fixnum->char (fx+ (char->fixnum #\0) f310996)) f310993))) ((primitive-ref integer->list) f310994))
# emit-tail-funcall
#    si   =-24
#    env  = ((f310993 . -20) (f310994 . -16) (f310993 . -12) (f310994 . -8) (f310956 . 4) (f310952 . -28) (f310953 . -24) (f310954 . -20) (f310955 . -16) (f310956 . -12) (f310957 . -8) (f310958 . -4) (f310959 . 0))
#    expr = (funcall (primitive-ref map) (closure (f310996) (f310993) (let ((f310996 f310996)) ((primitive-ref write-char) (fixnum->char (fx+ (char->fixnum #\0) f310996)) f310993))) ((primitive-ref integer->list) f310994))
=======
# env=((f207 . -20) (f206 . -16) (f207 . -12) (f206 . -8) (f169 . 4) (f165 . -28) (f166 . -24) (f167 . -20) (f168 . -16) (f169 . -12) (f170 . -8) (f171 . -4) (f172 . 0))
# expr=((primitive-ref map) (closure (f209) (f207) (let ((f209 f209)) ((primitive-ref write-char) (fixnum->char (fx+ (char->fixnum #\0) f209)) f207))) ((primitive-ref integer->list) f206))
# emit-tail-funcall
#    si   =-24
#    env  = ((f207 . -20) (f206 . -16) (f207 . -12) (f206 . -8) (f169 . 4) (f165 . -28) (f166 . -24) (f167 . -20) (f168 . -16) (f169 . -12) (f170 . -8) (f171 . -4) (f172 . 0))
#    expr = (funcall (primitive-ref map) (closure (f209) (f207) (let ((f209 f209)) ((primitive-ref write-char) (fixnum->char (fx+ (char->fixnum #\0) f209)) f207))) ((primitive-ref integer->list) f206))
>>>>>>> fix-implicit-begins
# emit-expr (primitive-ref map)
    .extern mrc_map
    movl mrc_map,%eax
   movl %eax,  -24(%esp)  # stash funcall-oper in next closure slot
<<<<<<< HEAD
# emit-expr (closure (f310996) (f310993) (let ((f310996 f310996)) ((primitive-ref write-char) (fixnum->char (fx+ (char->fixnum #\0) f310996)) f310993)))
# emit-closure
# si = -28
# env = ((f310993 . -20) (f310994 . -16) (f310993 . -12) (f310994 . -8) (f310956 . 4) (f310952 . -28) (f310953 . -24) (f310954 . -20) (f310955 . -16) (f310956 . -12) (f310957 . -8) (f310958 . -4) (f310959 . 0))
# expr = (closure (f310996) (f310993) (let ((f310996 f310996)) ((primitive-ref write-char) (fixnum->char (fx+ (char->fixnum #\0) f310996)) f310993)))
    movl $_L_1884864, 0(%ebp)  # closure label
# emit-variable-ref
# env=((f310993 . -20) (f310994 . -16) (f310993 . -12) (f310994 . -8) (f310956 . 4) (f310952 . -28) (f310953 . -24) (f310954 . -20) (f310955 . -16) (f310956 . -12) (f310957 . -8) (f310958 . -4) (f310959 . 0))
# var=f310993
    movl -20(%esp), %eax  # stack load f310993
# end emit-variable-ref
   movl  %eax, 4(%ebp)  # f310993
=======
# emit-expr (closure (f209) (f207) (let ((f209 f209)) ((primitive-ref write-char) (fixnum->char (fx+ (char->fixnum #\0) f209)) f207)))
# emit-closure
# si = -28
# env = ((f207 . -20) (f206 . -16) (f207 . -12) (f206 . -8) (f169 . 4) (f165 . -28) (f166 . -24) (f167 . -20) (f168 . -16) (f169 . -12) (f170 . -8) (f171 . -4) (f172 . 0))
# expr = (closure (f209) (f207) (let ((f209 f209)) ((primitive-ref write-char) (fixnum->char (fx+ (char->fixnum #\0) f209)) f207)))
    movl $_L_1265, 0(%ebp)  # closure label
# emit-variable-ref
# env=((f207 . -20) (f206 . -16) (f207 . -12) (f206 . -8) (f169 . 4) (f165 . -28) (f166 . -24) (f167 . -20) (f168 . -16) (f169 . -12) (f170 . -8) (f171 . -4) (f172 . 0))
# var=f207
    movl -20(%esp), %eax  # stack load f207
# end emit-variable-ref
   movl  %eax, 4(%ebp)  # f207
>>>>>>> fix-implicit-begins
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $8, %ebp     # bump ebp
    jmp _L_1266            # jump around closure body
_L_1265:
# check argument count
    cmp $4,%eax
    je _L_1267
# invoke error handler eh_argcount
    .extern mrc_eh$uargcount
    movl mrc_eh$uargcount, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_1267:
# emit-tail-expr
# si=-12
<<<<<<< HEAD
# env=((f310996 . -8) (f310993 . 4) (f310993 . -20) (f310994 . -16) (f310993 . -12) (f310994 . -8) (f310956 . 4) (f310952 . -28) (f310953 . -24) (f310954 . -20) (f310955 . -16) (f310956 . -12) (f310957 . -8) (f310958 . -4) (f310959 . 0))
# expr=(let ((f310996 f310996)) ((primitive-ref write-char) (fixnum->char (fx+ (char->fixnum #\0) f310996)) f310993))
# emit-tail-let
#  si   = -12
#  env  = ((f310996 . -8) (f310993 . 4) (f310993 . -20) (f310994 . -16) (f310993 . -12) (f310994 . -8) (f310956 . 4) (f310952 . -28) (f310953 . -24) (f310954 . -20) (f310955 . -16) (f310956 . -12) (f310957 . -8) (f310958 . -4) (f310959 . 0))
#  bindings = ((f310996 f310996))
#  body = ((primitive-ref write-char) (fixnum->char (fx+ (char->fixnum #\0) f310996)) f310993)
# emit-expr f310996
# emit-variable-ref
# env=((f310996 . -8) (f310993 . 4) (f310993 . -20) (f310994 . -16) (f310993 . -12) (f310994 . -8) (f310956 . 4) (f310952 . -28) (f310953 . -24) (f310954 . -20) (f310955 . -16) (f310956 . -12) (f310957 . -8) (f310958 . -4) (f310959 . 0))
# var=f310996
    movl -8(%esp), %eax  # stack load f310996
=======
# env=((f209 . -8) (f207 . 4) (f207 . -20) (f206 . -16) (f207 . -12) (f206 . -8) (f169 . 4) (f165 . -28) (f166 . -24) (f167 . -20) (f168 . -16) (f169 . -12) (f170 . -8) (f171 . -4) (f172 . 0))
# expr=(let ((f209 f209)) ((primitive-ref write-char) (fixnum->char (fx+ (char->fixnum #\0) f209)) f207))
# emit-tail-let
#  si   = -12
#  env  = ((f209 . -8) (f207 . 4) (f207 . -20) (f206 . -16) (f207 . -12) (f206 . -8) (f169 . 4) (f165 . -28) (f166 . -24) (f167 . -20) (f168 . -16) (f169 . -12) (f170 . -8) (f171 . -4) (f172 . 0))
#  bindings = ((f209 f209))
#  body = ((primitive-ref write-char) (fixnum->char (fx+ (char->fixnum #\0) f209)) f207)
# emit-expr f209
# emit-variable-ref
# env=((f209 . -8) (f207 . 4) (f207 . -20) (f206 . -16) (f207 . -12) (f206 . -8) (f169 . 4) (f165 . -28) (f166 . -24) (f167 . -20) (f168 . -16) (f169 . -12) (f170 . -8) (f171 . -4) (f172 . 0))
# var=f209
    movl -8(%esp), %eax  # stack load f209
>>>>>>> fix-implicit-begins
# end emit-variable-ref
    movl %eax, -12(%esp)  # stack save
# emit-tail-expr
# si=-16
<<<<<<< HEAD
# env=((f310996 . -12) (f310996 . -8) (f310993 . 4) (f310993 . -20) (f310994 . -16) (f310993 . -12) (f310994 . -8) (f310956 . 4) (f310952 . -28) (f310953 . -24) (f310954 . -20) (f310955 . -16) (f310956 . -12) (f310957 . -8) (f310958 . -4) (f310959 . 0))
# expr=((primitive-ref write-char) (fixnum->char (fx+ (char->fixnum #\0) f310996)) f310993)
# emit-tail-funcall
#    si   =-16
#    env  = ((f310996 . -12) (f310996 . -8) (f310993 . 4) (f310993 . -20) (f310994 . -16) (f310993 . -12) (f310994 . -8) (f310956 . 4) (f310952 . -28) (f310953 . -24) (f310954 . -20) (f310955 . -16) (f310956 . -12) (f310957 . -8) (f310958 . -4) (f310959 . 0))
#    expr = (funcall (primitive-ref write-char) (fixnum->char (fx+ (char->fixnum #\0) f310996)) f310993)
=======
# env=((f209 . -12) (f209 . -8) (f207 . 4) (f207 . -20) (f206 . -16) (f207 . -12) (f206 . -8) (f169 . 4) (f165 . -28) (f166 . -24) (f167 . -20) (f168 . -16) (f169 . -12) (f170 . -8) (f171 . -4) (f172 . 0))
# expr=((primitive-ref write-char) (fixnum->char (fx+ (char->fixnum #\0) f209)) f207)
# emit-tail-funcall
#    si   =-16
#    env  = ((f209 . -12) (f209 . -8) (f207 . 4) (f207 . -20) (f206 . -16) (f207 . -12) (f206 . -8) (f169 . 4) (f165 . -28) (f166 . -24) (f167 . -20) (f168 . -16) (f169 . -12) (f170 . -8) (f171 . -4) (f172 . 0))
#    expr = (funcall (primitive-ref write-char) (fixnum->char (fx+ (char->fixnum #\0) f209)) f207)
>>>>>>> fix-implicit-begins
# emit-expr (primitive-ref write-char)
    .extern mrc_write$mchar
    movl mrc_write$mchar,%eax
   movl %eax,  -16(%esp)  # stash funcall-oper in next closure slot
# emit-expr (fixnum->char (fx+ (char->fixnum #\0) f209))
# emit-expr (fx+ (char->fixnum #\0) f209)
# emit-expr f209
# emit-variable-ref
<<<<<<< HEAD
# env=((f310996 . -12) (f310996 . -8) (f310993 . 4) (f310993 . -20) (f310994 . -16) (f310993 . -12) (f310994 . -8) (f310956 . 4) (f310952 . -28) (f310953 . -24) (f310954 . -20) (f310955 . -16) (f310956 . -12) (f310957 . -8) (f310958 . -4) (f310959 . 0))
# var=f310996
    movl -12(%esp), %eax  # stack load f310996
=======
# env=((f209 . -12) (f209 . -8) (f207 . 4) (f207 . -20) (f206 . -16) (f207 . -12) (f206 . -8) (f169 . 4) (f165 . -28) (f166 . -24) (f167 . -20) (f168 . -16) (f169 . -12) (f170 . -8) (f171 . -4) (f172 . 0))
# var=f209
    movl -12(%esp), %eax  # stack load f209
>>>>>>> fix-implicit-begins
# end emit-variable-ref
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1268"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $88,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1268:
    movl %eax, -20(%esp)  # fx+ push arg1
# emit-expr (char->fixnum #\0)
# emit-expr #\0
    movl $12303, %eax     # immed #\0
# check the argument is a char
    movl %eax,%ebx
    and $255, %bl
    cmp $15, %bl
    je "_L_1269"
# invoke error handler eh_character
    .extern mrc_eh$ucharacter
    movl mrc_eh$ucharacter, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $4,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1269:
   shrl $8, %eax
   shll $2, %eax
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1270"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $88,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1270:
    addl -20(%esp), %eax  # fx+ arg1 arg2
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1271"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $0,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1271:
    shll $6, %eax
    orl $15, %eax
<<<<<<< HEAD
    mov %eax, -20(%esp)    # arg (fixnum->char (fx+ (char->fixnum 0) f310996))
# emit-expr f310993
# emit-variable-ref
# env=((f310996 . -12) (f310996 . -8) (f310993 . 4) (f310993 . -20) (f310994 . -16) (f310993 . -12) (f310994 . -8) (f310956 . 4) (f310952 . -28) (f310953 . -24) (f310954 . -20) (f310955 . -16) (f310956 . -12) (f310957 . -8) (f310958 . -4) (f310959 . 0))
# var=f310993
    movl 2(%edi), %eax  # frame load f310993
# end emit-variable-ref
    mov %eax, -24(%esp)    # arg f310993
=======
    mov %eax, -20(%esp)    # arg (fixnum->char (fx+ (char->fixnum 0) f209))
# emit-expr f207
# emit-variable-ref
# env=((f209 . -12) (f209 . -8) (f207 . 4) (f207 . -20) (f206 . -16) (f207 . -12) (f206 . -8) (f169 . 4) (f165 . -28) (f166 . -24) (f167 . -20) (f168 . -16) (f169 . -12) (f170 . -8) (f171 . -4) (f172 . 0))
# var=f207
    movl 2(%edi), %eax  # frame load f207
# end emit-variable-ref
    mov %eax, -24(%esp)    # arg f207
>>>>>>> fix-implicit-begins
    movl -16(%esp), %edi   # load new closure to %edi
# emit-shift-args:  size=3   si=-16  delta=12
    mov -16(%esp), %ebx  # shift frame cell
    mov %ebx, -4(%esp)  # down to base
# emit-shift-args:  size=2   si=-20  delta=12
    mov -20(%esp), %ebx  # shift frame cell
    mov %ebx, -8(%esp)  # down to base
# emit-shift-args:  size=1   si=-24  delta=12
    mov -24(%esp), %ebx  # shift frame cell
    mov %ebx, -12(%esp)  # down to base
# emit-shift-args:  size=0   si=-28  delta=12
    movl $8,%eax   # save arg count
    jmp *-2(%edi)  # tail-funcall
    .align 4,0x90
<<<<<<< HEAD
_L_1884865:
    mov %eax, -28(%esp)    # arg (closure (f310996) (f310993) (let ((f310996 f310996)) ((primitive-ref write-char) (fixnum->char (fx+ (char->fixnum 0) f310996)) f310993)))
# emit-expr ((primitive-ref integer->list) f310994)
# funcall
#    si   =-32
#    env  = ((f310993 . -20) (f310994 . -16) (f310993 . -12) (f310994 . -8) (f310956 . 4) (f310952 . -28) (f310953 . -24) (f310954 . -20) (f310955 . -16) (f310956 . -12) (f310957 . -8) (f310958 . -4) (f310959 . 0))
#    expr = (funcall (primitive-ref integer->list) f310994)
=======
_L_1266:
    mov %eax, -28(%esp)    # arg (closure (f209) (f207) (let ((f209 f209)) ((primitive-ref write-char) (fixnum->char (fx+ (char->fixnum 0) f209)) f207)))
# emit-expr ((primitive-ref integer->list) f206)
# funcall
#    si   =-32
#    env  = ((f207 . -20) (f206 . -16) (f207 . -12) (f206 . -8) (f169 . 4) (f165 . -28) (f166 . -24) (f167 . -20) (f168 . -16) (f169 . -12) (f170 . -8) (f171 . -4) (f172 . 0))
#    expr = (funcall (primitive-ref integer->list) f206)
>>>>>>> fix-implicit-begins
# emit-expr (primitive-ref integer->list)
    .extern mrc_integer$m$glist
    movl mrc_integer$m$glist,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1272"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1272":
   movl %eax,  -40(%esp)  # stash funcall-oper in closure slot
<<<<<<< HEAD
# emit-expr f310994
# emit-variable-ref
# env=((f310993 . -20) (f310994 . -16) (f310993 . -12) (f310994 . -8) (f310956 . 4) (f310952 . -28) (f310953 . -24) (f310954 . -20) (f310955 . -16) (f310956 . -12) (f310957 . -8) (f310958 . -4) (f310959 . 0))
# var=f310994
    movl -16(%esp), %eax  # stack load f310994
# end emit-variable-ref
    mov %eax, -44(%esp)  # arg f310994
=======
# emit-expr f206
# emit-variable-ref
# env=((f207 . -20) (f206 . -16) (f207 . -12) (f206 . -8) (f169 . 4) (f165 . -28) (f166 . -24) (f167 . -20) (f168 . -16) (f169 . -12) (f170 . -8) (f171 . -4) (f172 . 0))
# var=f206
    movl -16(%esp), %eax  # stack load f206
# end emit-variable-ref
    mov %eax, -44(%esp)  # arg f206
>>>>>>> fix-implicit-begins
    movl -40(%esp), %edi   # load new closure to %edi
    add $-32, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $32, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
<<<<<<< HEAD
    mov %eax, -32(%esp)    # arg ((primitive-ref integer->list) f310994)
=======
    mov %eax, -32(%esp)    # arg ((primitive-ref integer->list) f206)
>>>>>>> fix-implicit-begins
    movl -24(%esp), %edi   # load new closure to %edi
# emit-shift-args:  size=3   si=-24  delta=20
    mov -24(%esp), %ebx  # shift frame cell
    mov %ebx, -4(%esp)  # down to base
# emit-shift-args:  size=2   si=-28  delta=20
    mov -28(%esp), %ebx  # shift frame cell
    mov %ebx, -8(%esp)  # down to base
# emit-shift-args:  size=1   si=-32  delta=20
    mov -32(%esp), %ebx  # shift frame cell
    mov %ebx, -12(%esp)  # down to base
# emit-shift-args:  size=0   si=-36  delta=20
    movl $8,%eax   # save arg count
    jmp *-2(%edi)  # tail-funcall
_L_1256:
    .align 4,0x90
_L_1253:
    movl -32(%esp), %ebx
    movl -36(%esp), %esi
    movl %eax, -1(%ebx,%esi)
<<<<<<< HEAD
# emit-expr (begin (vector-set! f310955 0 (closure (f310990 f310989) () (let ((f310990 f310990) (f310989 f310989)) (begin ((primitive-ref write-char) #\" f310989) ((primitive-ref for-each) (closure (f310992) (f310989) (let ((f310992 f310992)) ((primitive-ref write-char) f310992 f310989))) ((primitive-ref string->list) f310990)) ((primitive-ref write-char) #\" f310989))))) (vector-set! f310954 0 (closure (f310986 f310985) () (let ((f310986 f310986) (f310985 f310985)) ((primitive-ref for-each) (closure (f310988) (f310985) (let ((f310988 f310988)) ((primitive-ref write-char) f310988 f310985))) ((primitive-ref string->list) f310986))))) (vector-set! f310953 0 (closure (f310984 f310983) (f310952) (let ((f310984 f310984) (f310983 f310983)) (begin ((primitive-ref write-char) #\( f310983) ((vector-ref f310952 0) f310984 f310983) ((primitive-ref write-char) #\) f310983))))) (vector-set! f310952 0 (closure (f310982 f310981) (f310952) (let ((f310982 f310982) (f310981 f310981)) (begin ((primitive-ref write) (car f310982) f310981) (if (null? (cdr f310982)) #t (if (pair? (cdr f310982)) (begin ((primitive-ref write-char) #\space f310981) ((vector-ref f310952 0) (cdr f310982) f310981)) (begin ((primitive-ref write-char) #\space f310981) ((primitive-ref write-char) #\. f310981) ((primitive-ref write-char) #\space f310981) ((primitive-ref write) (cdr f310982) f310981)))))))))
# emit-begin
#   expr=(begin (vector-set! f310955 0 (closure (f310990 f310989) () (let ((f310990 f310990) (f310989 f310989)) (begin ((primitive-ref write-char) #\" f310989) ((primitive-ref for-each) (closure (f310992) (f310989) (let ((f310992 f310992)) ((primitive-ref write-char) f310992 f310989))) ((primitive-ref string->list) f310990)) ((primitive-ref write-char) #\" f310989))))) (vector-set! f310954 0 (closure (f310986 f310985) () (let ((f310986 f310986) (f310985 f310985)) ((primitive-ref for-each) (closure (f310988) (f310985) (let ((f310988 f310988)) ((primitive-ref write-char) f310988 f310985))) ((primitive-ref string->list) f310986))))) (vector-set! f310953 0 (closure (f310984 f310983) (f310952) (let ((f310984 f310984) (f310983 f310983)) (begin ((primitive-ref write-char) #\( f310983) ((vector-ref f310952 0) f310984 f310983) ((primitive-ref write-char) #\) f310983))))) (vector-set! f310952 0 (closure (f310982 f310981) (f310952) (let ((f310982 f310982) (f310981 f310981)) (begin ((primitive-ref write) (car f310982) f310981) (if (null? (cdr f310982)) #t (if (pair? (cdr f310982)) (begin ((primitive-ref write-char) #\space f310981) ((vector-ref f310952 0) (cdr f310982) f310981)) (begin ((primitive-ref write-char) #\space f310981) ((primitive-ref write-char) #\. f310981) ((primitive-ref write-char) #\space f310981) ((primitive-ref write) (cdr f310982) f310981)))))))))
#   env=((f310952 . -28) (f310953 . -24) (f310954 . -20) (f310955 . -16) (f310956 . -12) (f310957 . -8) (f310958 . -4) (f310959 . 0))
# emit-expr (vector-set! f310955 0 (closure (f310990 f310989) () (let ((f310990 f310990) (f310989 f310989)) (begin ((primitive-ref write-char) #\" f310989) ((primitive-ref for-each) (closure (f310992) (f310989) (let ((f310992 f310992)) ((primitive-ref write-char) f310992 f310989))) ((primitive-ref string->list) f310990)) ((primitive-ref write-char) #\" f310989)))))
# emit-expr f310955
=======
# emit-expr (begin (vector-set! f168 0 (closure (f202 f203) () (let ((f202 f202) (f203 f203)) (begin ((primitive-ref write-char) #\" f203) ((primitive-ref for-each) (closure (f205) (f203) (let ((f205 f205)) ((primitive-ref write-char) f205 f203))) ((primitive-ref string->list) f202)) ((primitive-ref write-char) #\" f203))))) (vector-set! f167 0 (closure (f198 f199) () (let ((f198 f198) (f199 f199)) ((primitive-ref for-each) (closure (f201) (f199) (let ((f201 f201)) ((primitive-ref write-char) f201 f199))) ((primitive-ref string->list) f198))))) (vector-set! f166 0 (closure (f196 f197) (f165) (let ((f196 f196) (f197 f197)) (begin ((primitive-ref write-char) #\( f197) ((vector-ref f165 0) f196 f197) ((primitive-ref write-char) #\) f197))))) (vector-set! f165 0 (closure (f194 f195) (f165) (let ((f194 f194) (f195 f195)) (begin ((primitive-ref write) (car f194) f195) (if (null? (cdr f194)) (begin #t) (if (pair? (cdr f194)) (begin (begin ((primitive-ref write-char) #\space f195) ((vector-ref f165 0) (cdr f194) f195))) (begin (begin ((primitive-ref write-char) #\space f195) ((primitive-ref write-char) #\. f195) ((primitive-ref write-char) #\space f195) ((primitive-ref write) (cdr f194) f195))))))))))
# emit-begin
#   expr=(begin (vector-set! f168 0 (closure (f202 f203) () (let ((f202 f202) (f203 f203)) (begin ((primitive-ref write-char) #\" f203) ((primitive-ref for-each) (closure (f205) (f203) (let ((f205 f205)) ((primitive-ref write-char) f205 f203))) ((primitive-ref string->list) f202)) ((primitive-ref write-char) #\" f203))))) (vector-set! f167 0 (closure (f198 f199) () (let ((f198 f198) (f199 f199)) ((primitive-ref for-each) (closure (f201) (f199) (let ((f201 f201)) ((primitive-ref write-char) f201 f199))) ((primitive-ref string->list) f198))))) (vector-set! f166 0 (closure (f196 f197) (f165) (let ((f196 f196) (f197 f197)) (begin ((primitive-ref write-char) #\( f197) ((vector-ref f165 0) f196 f197) ((primitive-ref write-char) #\) f197))))) (vector-set! f165 0 (closure (f194 f195) (f165) (let ((f194 f194) (f195 f195)) (begin ((primitive-ref write) (car f194) f195) (if (null? (cdr f194)) (begin #t) (if (pair? (cdr f194)) (begin (begin ((primitive-ref write-char) #\space f195) ((vector-ref f165 0) (cdr f194) f195))) (begin (begin ((primitive-ref write-char) #\space f195) ((primitive-ref write-char) #\. f195) ((primitive-ref write-char) #\space f195) ((primitive-ref write) (cdr f194) f195))))))))))
#   env=((f165 . -28) (f166 . -24) (f167 . -20) (f168 . -16) (f169 . -12) (f170 . -8) (f171 . -4) (f172 . 0))
# emit-expr (vector-set! f168 0 (closure (f202 f203) () (let ((f202 f202) (f203 f203)) (begin ((primitive-ref write-char) #\" f203) ((primitive-ref for-each) (closure (f205) (f203) (let ((f205 f205)) ((primitive-ref write-char) f205 f203))) ((primitive-ref string->list) f202)) ((primitive-ref write-char) #\" f203)))))
# emit-expr f168
>>>>>>> fix-implicit-begins
# emit-variable-ref
# env=((f165 . -28) (f166 . -24) (f167 . -20) (f168 . -16) (f169 . -12) (f170 . -8) (f171 . -4) (f172 . 0))
# var=f168
    movl -16(%esp), %eax  # stack load f168
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1273
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1273:
    movl %eax, -32(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1274"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1274:
# check bounds on vector index
    movl -32(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1276
    cmp  $0,%eax
    jge _L_1275
_L_1276:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1275:
    movl %eax, -36(%esp)
<<<<<<< HEAD
# emit-expr (closure (f310990 f310989) () (let ((f310990 f310990) (f310989 f310989)) (begin ((primitive-ref write-char) #\" f310989) ((primitive-ref for-each) (closure (f310992) (f310989) (let ((f310992 f310992)) ((primitive-ref write-char) f310992 f310989))) ((primitive-ref string->list) f310990)) ((primitive-ref write-char) #\" f310989))))
# emit-closure
# si = -40
# env = ((f310952 . -28) (f310953 . -24) (f310954 . -20) (f310955 . -16) (f310956 . -12) (f310957 . -8) (f310958 . -4) (f310959 . 0))
# expr = (closure (f310990 f310989) () (let ((f310990 f310990) (f310989 f310989)) (begin ((primitive-ref write-char) #\" f310989) ((primitive-ref for-each) (closure (f310992) (f310989) (let ((f310992 f310992)) ((primitive-ref write-char) f310992 f310989))) ((primitive-ref string->list) f310990)) ((primitive-ref write-char) #\" f310989))))
    movl $_L_1884876, 0(%ebp)  # closure label
=======
# emit-expr (closure (f202 f203) () (let ((f202 f202) (f203 f203)) (begin ((primitive-ref write-char) #\" f203) ((primitive-ref for-each) (closure (f205) (f203) (let ((f205 f205)) ((primitive-ref write-char) f205 f203))) ((primitive-ref string->list) f202)) ((primitive-ref write-char) #\" f203))))
# emit-closure
# si = -40
# env = ((f165 . -28) (f166 . -24) (f167 . -20) (f168 . -16) (f169 . -12) (f170 . -8) (f171 . -4) (f172 . 0))
# expr = (closure (f202 f203) () (let ((f202 f202) (f203 f203)) (begin ((primitive-ref write-char) #\" f203) ((primitive-ref for-each) (closure (f205) (f203) (let ((f205 f205)) ((primitive-ref write-char) f205 f203))) ((primitive-ref string->list) f202)) ((primitive-ref write-char) #\" f203))))
    movl $_L_1277, 0(%ebp)  # closure label
>>>>>>> fix-implicit-begins
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $8, %ebp     # bump ebp
    jmp _L_1278            # jump around closure body
_L_1277:
# check argument count
    cmp $8,%eax
    je _L_1279
# invoke error handler eh_argcount
    .extern mrc_eh$uargcount
    movl mrc_eh$uargcount, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_1279:
# emit-tail-expr
# si=-16
<<<<<<< HEAD
# env=((f310989 . -12) (f310990 . -8) (f310952 . -28) (f310953 . -24) (f310954 . -20) (f310955 . -16) (f310956 . -12) (f310957 . -8) (f310958 . -4) (f310959 . 0))
# expr=(let ((f310990 f310990) (f310989 f310989)) (begin ((primitive-ref write-char) #\" f310989) ((primitive-ref for-each) (closure (f310992) (f310989) (let ((f310992 f310992)) ((primitive-ref write-char) f310992 f310989))) ((primitive-ref string->list) f310990)) ((primitive-ref write-char) #\" f310989)))
# emit-tail-let
#  si   = -16
#  env  = ((f310989 . -12) (f310990 . -8) (f310952 . -28) (f310953 . -24) (f310954 . -20) (f310955 . -16) (f310956 . -12) (f310957 . -8) (f310958 . -4) (f310959 . 0))
#  bindings = ((f310990 f310990) (f310989 f310989))
#  body = (begin ((primitive-ref write-char) #\" f310989) ((primitive-ref for-each) (closure (f310992) (f310989) (let ((f310992 f310992)) ((primitive-ref write-char) f310992 f310989))) ((primitive-ref string->list) f310990)) ((primitive-ref write-char) #\" f310989))
# emit-expr f310990
# emit-variable-ref
# env=((f310989 . -12) (f310990 . -8) (f310952 . -28) (f310953 . -24) (f310954 . -20) (f310955 . -16) (f310956 . -12) (f310957 . -8) (f310958 . -4) (f310959 . 0))
# var=f310990
    movl -8(%esp), %eax  # stack load f310990
# end emit-variable-ref
    movl %eax, -16(%esp)  # stack save
# emit-expr f310989
# emit-variable-ref
# env=((f310989 . -12) (f310990 . -8) (f310952 . -28) (f310953 . -24) (f310954 . -20) (f310955 . -16) (f310956 . -12) (f310957 . -8) (f310958 . -4) (f310959 . 0))
# var=f310989
    movl -12(%esp), %eax  # stack load f310989
=======
# env=((f203 . -12) (f202 . -8) (f165 . -28) (f166 . -24) (f167 . -20) (f168 . -16) (f169 . -12) (f170 . -8) (f171 . -4) (f172 . 0))
# expr=(let ((f202 f202) (f203 f203)) (begin ((primitive-ref write-char) #\" f203) ((primitive-ref for-each) (closure (f205) (f203) (let ((f205 f205)) ((primitive-ref write-char) f205 f203))) ((primitive-ref string->list) f202)) ((primitive-ref write-char) #\" f203)))
# emit-tail-let
#  si   = -16
#  env  = ((f203 . -12) (f202 . -8) (f165 . -28) (f166 . -24) (f167 . -20) (f168 . -16) (f169 . -12) (f170 . -8) (f171 . -4) (f172 . 0))
#  bindings = ((f202 f202) (f203 f203))
#  body = (begin ((primitive-ref write-char) #\" f203) ((primitive-ref for-each) (closure (f205) (f203) (let ((f205 f205)) ((primitive-ref write-char) f205 f203))) ((primitive-ref string->list) f202)) ((primitive-ref write-char) #\" f203))
# emit-expr f202
# emit-variable-ref
# env=((f203 . -12) (f202 . -8) (f165 . -28) (f166 . -24) (f167 . -20) (f168 . -16) (f169 . -12) (f170 . -8) (f171 . -4) (f172 . 0))
# var=f202
    movl -8(%esp), %eax  # stack load f202
# end emit-variable-ref
    movl %eax, -16(%esp)  # stack save
# emit-expr f203
# emit-variable-ref
# env=((f203 . -12) (f202 . -8) (f165 . -28) (f166 . -24) (f167 . -20) (f168 . -16) (f169 . -12) (f170 . -8) (f171 . -4) (f172 . 0))
# var=f203
    movl -12(%esp), %eax  # stack load f203
>>>>>>> fix-implicit-begins
# end emit-variable-ref
    movl %eax, -20(%esp)  # stack save
# emit-tail-expr
# si=-24
<<<<<<< HEAD
# env=((f310989 . -20) (f310990 . -16) (f310989 . -12) (f310990 . -8) (f310952 . -28) (f310953 . -24) (f310954 . -20) (f310955 . -16) (f310956 . -12) (f310957 . -8) (f310958 . -4) (f310959 . 0))
# expr=(begin ((primitive-ref write-char) #\" f310989) ((primitive-ref for-each) (closure (f310992) (f310989) (let ((f310992 f310992)) ((primitive-ref write-char) f310992 f310989))) ((primitive-ref string->list) f310990)) ((primitive-ref write-char) #\" f310989))
# tail-begin (begin ((primitive-ref write-char) #\" f310989) ((primitive-ref for-each) (closure (f310992) (f310989) (let ((f310992 f310992)) ((primitive-ref write-char) f310992 f310989))) ((primitive-ref string->list) f310990)) ((primitive-ref write-char) #\" f310989))
#   env=((f310989 . -20) (f310990 . -16) (f310989 . -12) (f310990 . -8) (f310952 . -28) (f310953 . -24) (f310954 . -20) (f310955 . -16) (f310956 . -12) (f310957 . -8) (f310958 . -4) (f310959 . 0))
# emit-expr ((primitive-ref write-char) #\" f310989)
# funcall
#    si   =-24
#    env  = ((f310989 . -20) (f310990 . -16) (f310989 . -12) (f310990 . -8) (f310952 . -28) (f310953 . -24) (f310954 . -20) (f310955 . -16) (f310956 . -12) (f310957 . -8) (f310958 . -4) (f310959 . 0))
#    expr = (funcall (primitive-ref write-char) #\" f310989)
=======
# env=((f203 . -20) (f202 . -16) (f203 . -12) (f202 . -8) (f165 . -28) (f166 . -24) (f167 . -20) (f168 . -16) (f169 . -12) (f170 . -8) (f171 . -4) (f172 . 0))
# expr=(begin ((primitive-ref write-char) #\" f203) ((primitive-ref for-each) (closure (f205) (f203) (let ((f205 f205)) ((primitive-ref write-char) f205 f203))) ((primitive-ref string->list) f202)) ((primitive-ref write-char) #\" f203))
# tail-begin (begin ((primitive-ref write-char) #\" f203) ((primitive-ref for-each) (closure (f205) (f203) (let ((f205 f205)) ((primitive-ref write-char) f205 f203))) ((primitive-ref string->list) f202)) ((primitive-ref write-char) #\" f203))
#   env=((f203 . -20) (f202 . -16) (f203 . -12) (f202 . -8) (f165 . -28) (f166 . -24) (f167 . -20) (f168 . -16) (f169 . -12) (f170 . -8) (f171 . -4) (f172 . 0))
# emit-expr ((primitive-ref write-char) #\" f203)
# funcall
#    si   =-24
#    env  = ((f203 . -20) (f202 . -16) (f203 . -12) (f202 . -8) (f165 . -28) (f166 . -24) (f167 . -20) (f168 . -16) (f169 . -12) (f170 . -8) (f171 . -4) (f172 . 0))
#    expr = (funcall (primitive-ref write-char) #\" f203)
>>>>>>> fix-implicit-begins
# emit-expr (primitive-ref write-char)
    .extern mrc_write$mchar
    movl mrc_write$mchar,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1280"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1280":
   movl %eax,  -32(%esp)  # stash funcall-oper in closure slot
# emit-expr #\"
    movl $8719, %eax     # immed #\"
    mov %eax, -36(%esp)  # arg "
<<<<<<< HEAD
# emit-expr f310989
# emit-variable-ref
# env=((f310989 . -20) (f310990 . -16) (f310989 . -12) (f310990 . -8) (f310952 . -28) (f310953 . -24) (f310954 . -20) (f310955 . -16) (f310956 . -12) (f310957 . -8) (f310958 . -4) (f310959 . 0))
# var=f310989
    movl -20(%esp), %eax  # stack load f310989
# end emit-variable-ref
    mov %eax, -40(%esp)  # arg f310989
=======
# emit-expr f203
# emit-variable-ref
# env=((f203 . -20) (f202 . -16) (f203 . -12) (f202 . -8) (f165 . -28) (f166 . -24) (f167 . -20) (f168 . -16) (f169 . -12) (f170 . -8) (f171 . -4) (f172 . 0))
# var=f203
    movl -20(%esp), %eax  # stack load f203
# end emit-variable-ref
    mov %eax, -40(%esp)  # arg f203
>>>>>>> fix-implicit-begins
    movl -32(%esp), %edi   # load new closure to %edi
    add $-24, %esp   # adjust base
    movl $8,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $24, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
# emit-tail-expr
# si=-24
<<<<<<< HEAD
# env=((f310989 . -20) (f310990 . -16) (f310989 . -12) (f310990 . -8) (f310952 . -28) (f310953 . -24) (f310954 . -20) (f310955 . -16) (f310956 . -12) (f310957 . -8) (f310958 . -4) (f310959 . 0))
# expr=(begin ((primitive-ref for-each) (closure (f310992) (f310989) (let ((f310992 f310992)) ((primitive-ref write-char) f310992 f310989))) ((primitive-ref string->list) f310990)) ((primitive-ref write-char) #\" f310989))
# tail-begin (begin ((primitive-ref for-each) (closure (f310992) (f310989) (let ((f310992 f310992)) ((primitive-ref write-char) f310992 f310989))) ((primitive-ref string->list) f310990)) ((primitive-ref write-char) #\" f310989))
#   env=((f310989 . -20) (f310990 . -16) (f310989 . -12) (f310990 . -8) (f310952 . -28) (f310953 . -24) (f310954 . -20) (f310955 . -16) (f310956 . -12) (f310957 . -8) (f310958 . -4) (f310959 . 0))
# emit-expr ((primitive-ref for-each) (closure (f310992) (f310989) (let ((f310992 f310992)) ((primitive-ref write-char) f310992 f310989))) ((primitive-ref string->list) f310990))
# funcall
#    si   =-24
#    env  = ((f310989 . -20) (f310990 . -16) (f310989 . -12) (f310990 . -8) (f310952 . -28) (f310953 . -24) (f310954 . -20) (f310955 . -16) (f310956 . -12) (f310957 . -8) (f310958 . -4) (f310959 . 0))
#    expr = (funcall (primitive-ref for-each) (closure (f310992) (f310989) (let ((f310992 f310992)) ((primitive-ref write-char) f310992 f310989))) ((primitive-ref string->list) f310990))
=======
# env=((f203 . -20) (f202 . -16) (f203 . -12) (f202 . -8) (f165 . -28) (f166 . -24) (f167 . -20) (f168 . -16) (f169 . -12) (f170 . -8) (f171 . -4) (f172 . 0))
# expr=(begin ((primitive-ref for-each) (closure (f205) (f203) (let ((f205 f205)) ((primitive-ref write-char) f205 f203))) ((primitive-ref string->list) f202)) ((primitive-ref write-char) #\" f203))
# tail-begin (begin ((primitive-ref for-each) (closure (f205) (f203) (let ((f205 f205)) ((primitive-ref write-char) f205 f203))) ((primitive-ref string->list) f202)) ((primitive-ref write-char) #\" f203))
#   env=((f203 . -20) (f202 . -16) (f203 . -12) (f202 . -8) (f165 . -28) (f166 . -24) (f167 . -20) (f168 . -16) (f169 . -12) (f170 . -8) (f171 . -4) (f172 . 0))
# emit-expr ((primitive-ref for-each) (closure (f205) (f203) (let ((f205 f205)) ((primitive-ref write-char) f205 f203))) ((primitive-ref string->list) f202))
# funcall
#    si   =-24
#    env  = ((f203 . -20) (f202 . -16) (f203 . -12) (f202 . -8) (f165 . -28) (f166 . -24) (f167 . -20) (f168 . -16) (f169 . -12) (f170 . -8) (f171 . -4) (f172 . 0))
#    expr = (funcall (primitive-ref for-each) (closure (f205) (f203) (let ((f205 f205)) ((primitive-ref write-char) f205 f203))) ((primitive-ref string->list) f202))
>>>>>>> fix-implicit-begins
# emit-expr (primitive-ref for-each)
    .extern mrc_for$meach
    movl mrc_for$meach,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1281"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1281":
   movl %eax,  -32(%esp)  # stash funcall-oper in closure slot
<<<<<<< HEAD
# emit-expr (closure (f310992) (f310989) (let ((f310992 f310992)) ((primitive-ref write-char) f310992 f310989)))
# emit-closure
# si = -36
# env = ((f310989 . -20) (f310990 . -16) (f310989 . -12) (f310990 . -8) (f310952 . -28) (f310953 . -24) (f310954 . -20) (f310955 . -16) (f310956 . -12) (f310957 . -8) (f310958 . -4) (f310959 . 0))
# expr = (closure (f310992) (f310989) (let ((f310992 f310992)) ((primitive-ref write-char) f310992 f310989)))
    movl $_L_1884881, 0(%ebp)  # closure label
# emit-variable-ref
# env=((f310989 . -20) (f310990 . -16) (f310989 . -12) (f310990 . -8) (f310952 . -28) (f310953 . -24) (f310954 . -20) (f310955 . -16) (f310956 . -12) (f310957 . -8) (f310958 . -4) (f310959 . 0))
# var=f310989
    movl -20(%esp), %eax  # stack load f310989
# end emit-variable-ref
   movl  %eax, 4(%ebp)  # f310989
=======
# emit-expr (closure (f205) (f203) (let ((f205 f205)) ((primitive-ref write-char) f205 f203)))
# emit-closure
# si = -36
# env = ((f203 . -20) (f202 . -16) (f203 . -12) (f202 . -8) (f165 . -28) (f166 . -24) (f167 . -20) (f168 . -16) (f169 . -12) (f170 . -8) (f171 . -4) (f172 . 0))
# expr = (closure (f205) (f203) (let ((f205 f205)) ((primitive-ref write-char) f205 f203)))
    movl $_L_1282, 0(%ebp)  # closure label
# emit-variable-ref
# env=((f203 . -20) (f202 . -16) (f203 . -12) (f202 . -8) (f165 . -28) (f166 . -24) (f167 . -20) (f168 . -16) (f169 . -12) (f170 . -8) (f171 . -4) (f172 . 0))
# var=f203
    movl -20(%esp), %eax  # stack load f203
# end emit-variable-ref
   movl  %eax, 4(%ebp)  # f203
>>>>>>> fix-implicit-begins
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $8, %ebp     # bump ebp
    jmp _L_1283            # jump around closure body
_L_1282:
# check argument count
    cmp $4,%eax
    je _L_1284
# invoke error handler eh_argcount
    .extern mrc_eh$uargcount
    movl mrc_eh$uargcount, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_1284:
# emit-tail-expr
# si=-12
<<<<<<< HEAD
# env=((f310992 . -8) (f310989 . 4) (f310989 . -20) (f310990 . -16) (f310989 . -12) (f310990 . -8) (f310952 . -28) (f310953 . -24) (f310954 . -20) (f310955 . -16) (f310956 . -12) (f310957 . -8) (f310958 . -4) (f310959 . 0))
# expr=(let ((f310992 f310992)) ((primitive-ref write-char) f310992 f310989))
# emit-tail-let
#  si   = -12
#  env  = ((f310992 . -8) (f310989 . 4) (f310989 . -20) (f310990 . -16) (f310989 . -12) (f310990 . -8) (f310952 . -28) (f310953 . -24) (f310954 . -20) (f310955 . -16) (f310956 . -12) (f310957 . -8) (f310958 . -4) (f310959 . 0))
#  bindings = ((f310992 f310992))
#  body = ((primitive-ref write-char) f310992 f310989)
# emit-expr f310992
# emit-variable-ref
# env=((f310992 . -8) (f310989 . 4) (f310989 . -20) (f310990 . -16) (f310989 . -12) (f310990 . -8) (f310952 . -28) (f310953 . -24) (f310954 . -20) (f310955 . -16) (f310956 . -12) (f310957 . -8) (f310958 . -4) (f310959 . 0))
# var=f310992
    movl -8(%esp), %eax  # stack load f310992
=======
# env=((f205 . -8) (f203 . 4) (f203 . -20) (f202 . -16) (f203 . -12) (f202 . -8) (f165 . -28) (f166 . -24) (f167 . -20) (f168 . -16) (f169 . -12) (f170 . -8) (f171 . -4) (f172 . 0))
# expr=(let ((f205 f205)) ((primitive-ref write-char) f205 f203))
# emit-tail-let
#  si   = -12
#  env  = ((f205 . -8) (f203 . 4) (f203 . -20) (f202 . -16) (f203 . -12) (f202 . -8) (f165 . -28) (f166 . -24) (f167 . -20) (f168 . -16) (f169 . -12) (f170 . -8) (f171 . -4) (f172 . 0))
#  bindings = ((f205 f205))
#  body = ((primitive-ref write-char) f205 f203)
# emit-expr f205
# emit-variable-ref
# env=((f205 . -8) (f203 . 4) (f203 . -20) (f202 . -16) (f203 . -12) (f202 . -8) (f165 . -28) (f166 . -24) (f167 . -20) (f168 . -16) (f169 . -12) (f170 . -8) (f171 . -4) (f172 . 0))
# var=f205
    movl -8(%esp), %eax  # stack load f205
>>>>>>> fix-implicit-begins
# end emit-variable-ref
    movl %eax, -12(%esp)  # stack save
# emit-tail-expr
# si=-16
<<<<<<< HEAD
# env=((f310992 . -12) (f310992 . -8) (f310989 . 4) (f310989 . -20) (f310990 . -16) (f310989 . -12) (f310990 . -8) (f310952 . -28) (f310953 . -24) (f310954 . -20) (f310955 . -16) (f310956 . -12) (f310957 . -8) (f310958 . -4) (f310959 . 0))
# expr=((primitive-ref write-char) f310992 f310989)
# emit-tail-funcall
#    si   =-16
#    env  = ((f310992 . -12) (f310992 . -8) (f310989 . 4) (f310989 . -20) (f310990 . -16) (f310989 . -12) (f310990 . -8) (f310952 . -28) (f310953 . -24) (f310954 . -20) (f310955 . -16) (f310956 . -12) (f310957 . -8) (f310958 . -4) (f310959 . 0))
#    expr = (funcall (primitive-ref write-char) f310992 f310989)
=======
# env=((f205 . -12) (f205 . -8) (f203 . 4) (f203 . -20) (f202 . -16) (f203 . -12) (f202 . -8) (f165 . -28) (f166 . -24) (f167 . -20) (f168 . -16) (f169 . -12) (f170 . -8) (f171 . -4) (f172 . 0))
# expr=((primitive-ref write-char) f205 f203)
# emit-tail-funcall
#    si   =-16
#    env  = ((f205 . -12) (f205 . -8) (f203 . 4) (f203 . -20) (f202 . -16) (f203 . -12) (f202 . -8) (f165 . -28) (f166 . -24) (f167 . -20) (f168 . -16) (f169 . -12) (f170 . -8) (f171 . -4) (f172 . 0))
#    expr = (funcall (primitive-ref write-char) f205 f203)
>>>>>>> fix-implicit-begins
# emit-expr (primitive-ref write-char)
    .extern mrc_write$mchar
    movl mrc_write$mchar,%eax
   movl %eax,  -16(%esp)  # stash funcall-oper in next closure slot
# emit-expr f205
# emit-variable-ref
<<<<<<< HEAD
# env=((f310992 . -12) (f310992 . -8) (f310989 . 4) (f310989 . -20) (f310990 . -16) (f310989 . -12) (f310990 . -8) (f310952 . -28) (f310953 . -24) (f310954 . -20) (f310955 . -16) (f310956 . -12) (f310957 . -8) (f310958 . -4) (f310959 . 0))
# var=f310992
    movl -12(%esp), %eax  # stack load f310992
# end emit-variable-ref
    mov %eax, -20(%esp)    # arg f310992
# emit-expr f310989
# emit-variable-ref
# env=((f310992 . -12) (f310992 . -8) (f310989 . 4) (f310989 . -20) (f310990 . -16) (f310989 . -12) (f310990 . -8) (f310952 . -28) (f310953 . -24) (f310954 . -20) (f310955 . -16) (f310956 . -12) (f310957 . -8) (f310958 . -4) (f310959 . 0))
# var=f310989
    movl 2(%edi), %eax  # frame load f310989
# end emit-variable-ref
    mov %eax, -24(%esp)    # arg f310989
=======
# env=((f205 . -12) (f205 . -8) (f203 . 4) (f203 . -20) (f202 . -16) (f203 . -12) (f202 . -8) (f165 . -28) (f166 . -24) (f167 . -20) (f168 . -16) (f169 . -12) (f170 . -8) (f171 . -4) (f172 . 0))
# var=f205
    movl -12(%esp), %eax  # stack load f205
# end emit-variable-ref
    mov %eax, -20(%esp)    # arg f205
# emit-expr f203
# emit-variable-ref
# env=((f205 . -12) (f205 . -8) (f203 . 4) (f203 . -20) (f202 . -16) (f203 . -12) (f202 . -8) (f165 . -28) (f166 . -24) (f167 . -20) (f168 . -16) (f169 . -12) (f170 . -8) (f171 . -4) (f172 . 0))
# var=f203
    movl 2(%edi), %eax  # frame load f203
# end emit-variable-ref
    mov %eax, -24(%esp)    # arg f203
>>>>>>> fix-implicit-begins
    movl -16(%esp), %edi   # load new closure to %edi
# emit-shift-args:  size=3   si=-16  delta=12
    mov -16(%esp), %ebx  # shift frame cell
    mov %ebx, -4(%esp)  # down to base
# emit-shift-args:  size=2   si=-20  delta=12
    mov -20(%esp), %ebx  # shift frame cell
    mov %ebx, -8(%esp)  # down to base
# emit-shift-args:  size=1   si=-24  delta=12
    mov -24(%esp), %ebx  # shift frame cell
    mov %ebx, -12(%esp)  # down to base
# emit-shift-args:  size=0   si=-28  delta=12
    movl $8,%eax   # save arg count
    jmp *-2(%edi)  # tail-funcall
    .align 4,0x90
<<<<<<< HEAD
_L_1884882:
    mov %eax, -36(%esp)  # arg (closure (f310992) (f310989) (let ((f310992 f310992)) ((primitive-ref write-char) f310992 f310989)))
# emit-expr ((primitive-ref string->list) f310990)
# funcall
#    si   =-40
#    env  = ((f310989 . -20) (f310990 . -16) (f310989 . -12) (f310990 . -8) (f310952 . -28) (f310953 . -24) (f310954 . -20) (f310955 . -16) (f310956 . -12) (f310957 . -8) (f310958 . -4) (f310959 . 0))
#    expr = (funcall (primitive-ref string->list) f310990)
=======
_L_1283:
    mov %eax, -36(%esp)  # arg (closure (f205) (f203) (let ((f205 f205)) ((primitive-ref write-char) f205 f203)))
# emit-expr ((primitive-ref string->list) f202)
# funcall
#    si   =-40
#    env  = ((f203 . -20) (f202 . -16) (f203 . -12) (f202 . -8) (f165 . -28) (f166 . -24) (f167 . -20) (f168 . -16) (f169 . -12) (f170 . -8) (f171 . -4) (f172 . 0))
#    expr = (funcall (primitive-ref string->list) f202)
>>>>>>> fix-implicit-begins
# emit-expr (primitive-ref string->list)
    .extern mrc_string$m$glist
    movl mrc_string$m$glist,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1285"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1285":
   movl %eax,  -48(%esp)  # stash funcall-oper in closure slot
<<<<<<< HEAD
# emit-expr f310990
# emit-variable-ref
# env=((f310989 . -20) (f310990 . -16) (f310989 . -12) (f310990 . -8) (f310952 . -28) (f310953 . -24) (f310954 . -20) (f310955 . -16) (f310956 . -12) (f310957 . -8) (f310958 . -4) (f310959 . 0))
# var=f310990
    movl -16(%esp), %eax  # stack load f310990
# end emit-variable-ref
    mov %eax, -52(%esp)  # arg f310990
=======
# emit-expr f202
# emit-variable-ref
# env=((f203 . -20) (f202 . -16) (f203 . -12) (f202 . -8) (f165 . -28) (f166 . -24) (f167 . -20) (f168 . -16) (f169 . -12) (f170 . -8) (f171 . -4) (f172 . 0))
# var=f202
    movl -16(%esp), %eax  # stack load f202
# end emit-variable-ref
    mov %eax, -52(%esp)  # arg f202
>>>>>>> fix-implicit-begins
    movl -48(%esp), %edi   # load new closure to %edi
    add $-40, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $40, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
<<<<<<< HEAD
    mov %eax, -40(%esp)  # arg ((primitive-ref string->list) f310990)
=======
    mov %eax, -40(%esp)  # arg ((primitive-ref string->list) f202)
>>>>>>> fix-implicit-begins
    movl -32(%esp), %edi   # load new closure to %edi
    add $-24, %esp   # adjust base
    movl $8,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $24, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
# emit-tail-expr
# si=-24
<<<<<<< HEAD
# env=((f310989 . -20) (f310990 . -16) (f310989 . -12) (f310990 . -8) (f310952 . -28) (f310953 . -24) (f310954 . -20) (f310955 . -16) (f310956 . -12) (f310957 . -8) (f310958 . -4) (f310959 . 0))
# expr=(begin ((primitive-ref write-char) #\" f310989))
# tail-begin (begin ((primitive-ref write-char) #\" f310989))
#   env=((f310989 . -20) (f310990 . -16) (f310989 . -12) (f310990 . -8) (f310952 . -28) (f310953 . -24) (f310954 . -20) (f310955 . -16) (f310956 . -12) (f310957 . -8) (f310958 . -4) (f310959 . 0))
# emit-tail-expr
# si=-24
# env=((f310989 . -20) (f310990 . -16) (f310989 . -12) (f310990 . -8) (f310952 . -28) (f310953 . -24) (f310954 . -20) (f310955 . -16) (f310956 . -12) (f310957 . -8) (f310958 . -4) (f310959 . 0))
# expr=((primitive-ref write-char) #\" f310989)
# emit-tail-funcall
#    si   =-24
#    env  = ((f310989 . -20) (f310990 . -16) (f310989 . -12) (f310990 . -8) (f310952 . -28) (f310953 . -24) (f310954 . -20) (f310955 . -16) (f310956 . -12) (f310957 . -8) (f310958 . -4) (f310959 . 0))
#    expr = (funcall (primitive-ref write-char) #\" f310989)
=======
# env=((f203 . -20) (f202 . -16) (f203 . -12) (f202 . -8) (f165 . -28) (f166 . -24) (f167 . -20) (f168 . -16) (f169 . -12) (f170 . -8) (f171 . -4) (f172 . 0))
# expr=(begin ((primitive-ref write-char) #\" f203))
# tail-begin (begin ((primitive-ref write-char) #\" f203))
#   env=((f203 . -20) (f202 . -16) (f203 . -12) (f202 . -8) (f165 . -28) (f166 . -24) (f167 . -20) (f168 . -16) (f169 . -12) (f170 . -8) (f171 . -4) (f172 . 0))
# emit-tail-expr
# si=-24
# env=((f203 . -20) (f202 . -16) (f203 . -12) (f202 . -8) (f165 . -28) (f166 . -24) (f167 . -20) (f168 . -16) (f169 . -12) (f170 . -8) (f171 . -4) (f172 . 0))
# expr=((primitive-ref write-char) #\" f203)
# emit-tail-funcall
#    si   =-24
#    env  = ((f203 . -20) (f202 . -16) (f203 . -12) (f202 . -8) (f165 . -28) (f166 . -24) (f167 . -20) (f168 . -16) (f169 . -12) (f170 . -8) (f171 . -4) (f172 . 0))
#    expr = (funcall (primitive-ref write-char) #\" f203)
>>>>>>> fix-implicit-begins
# emit-expr (primitive-ref write-char)
    .extern mrc_write$mchar
    movl mrc_write$mchar,%eax
   movl %eax,  -24(%esp)  # stash funcall-oper in next closure slot
# emit-expr #\"
    movl $8719, %eax     # immed #\"
    mov %eax, -28(%esp)    # arg "
<<<<<<< HEAD
# emit-expr f310989
# emit-variable-ref
# env=((f310989 . -20) (f310990 . -16) (f310989 . -12) (f310990 . -8) (f310952 . -28) (f310953 . -24) (f310954 . -20) (f310955 . -16) (f310956 . -12) (f310957 . -8) (f310958 . -4) (f310959 . 0))
# var=f310989
    movl -20(%esp), %eax  # stack load f310989
# end emit-variable-ref
    mov %eax, -32(%esp)    # arg f310989
=======
# emit-expr f203
# emit-variable-ref
# env=((f203 . -20) (f202 . -16) (f203 . -12) (f202 . -8) (f165 . -28) (f166 . -24) (f167 . -20) (f168 . -16) (f169 . -12) (f170 . -8) (f171 . -4) (f172 . 0))
# var=f203
    movl -20(%esp), %eax  # stack load f203
# end emit-variable-ref
    mov %eax, -32(%esp)    # arg f203
>>>>>>> fix-implicit-begins
    movl -24(%esp), %edi   # load new closure to %edi
# emit-shift-args:  size=3   si=-24  delta=20
    mov -24(%esp), %ebx  # shift frame cell
    mov %ebx, -4(%esp)  # down to base
# emit-shift-args:  size=2   si=-28  delta=20
    mov -28(%esp), %ebx  # shift frame cell
    mov %ebx, -8(%esp)  # down to base
# emit-shift-args:  size=1   si=-32  delta=20
    mov -32(%esp), %ebx  # shift frame cell
    mov %ebx, -12(%esp)  # down to base
# emit-shift-args:  size=0   si=-36  delta=20
    movl $8,%eax   # save arg count
    jmp *-2(%edi)  # tail-funcall
     ret   # return thru stack
    .align 4,0x90
_L_1278:
    movl -32(%esp), %ebx
    movl -36(%esp), %esi
    movl %eax, -1(%ebx,%esi)
<<<<<<< HEAD
# emit-expr (begin (vector-set! f310954 0 (closure (f310986 f310985) () (let ((f310986 f310986) (f310985 f310985)) ((primitive-ref for-each) (closure (f310988) (f310985) (let ((f310988 f310988)) ((primitive-ref write-char) f310988 f310985))) ((primitive-ref string->list) f310986))))) (vector-set! f310953 0 (closure (f310984 f310983) (f310952) (let ((f310984 f310984) (f310983 f310983)) (begin ((primitive-ref write-char) #\( f310983) ((vector-ref f310952 0) f310984 f310983) ((primitive-ref write-char) #\) f310983))))) (vector-set! f310952 0 (closure (f310982 f310981) (f310952) (let ((f310982 f310982) (f310981 f310981)) (begin ((primitive-ref write) (car f310982) f310981) (if (null? (cdr f310982)) #t (if (pair? (cdr f310982)) (begin ((primitive-ref write-char) #\space f310981) ((vector-ref f310952 0) (cdr f310982) f310981)) (begin ((primitive-ref write-char) #\space f310981) ((primitive-ref write-char) #\. f310981) ((primitive-ref write-char) #\space f310981) ((primitive-ref write) (cdr f310982) f310981)))))))))
# emit-begin
#   expr=(begin (vector-set! f310954 0 (closure (f310986 f310985) () (let ((f310986 f310986) (f310985 f310985)) ((primitive-ref for-each) (closure (f310988) (f310985) (let ((f310988 f310988)) ((primitive-ref write-char) f310988 f310985))) ((primitive-ref string->list) f310986))))) (vector-set! f310953 0 (closure (f310984 f310983) (f310952) (let ((f310984 f310984) (f310983 f310983)) (begin ((primitive-ref write-char) #\( f310983) ((vector-ref f310952 0) f310984 f310983) ((primitive-ref write-char) #\) f310983))))) (vector-set! f310952 0 (closure (f310982 f310981) (f310952) (let ((f310982 f310982) (f310981 f310981)) (begin ((primitive-ref write) (car f310982) f310981) (if (null? (cdr f310982)) #t (if (pair? (cdr f310982)) (begin ((primitive-ref write-char) #\space f310981) ((vector-ref f310952 0) (cdr f310982) f310981)) (begin ((primitive-ref write-char) #\space f310981) ((primitive-ref write-char) #\. f310981) ((primitive-ref write-char) #\space f310981) ((primitive-ref write) (cdr f310982) f310981)))))))))
#   env=((f310952 . -28) (f310953 . -24) (f310954 . -20) (f310955 . -16) (f310956 . -12) (f310957 . -8) (f310958 . -4) (f310959 . 0))
# emit-expr (vector-set! f310954 0 (closure (f310986 f310985) () (let ((f310986 f310986) (f310985 f310985)) ((primitive-ref for-each) (closure (f310988) (f310985) (let ((f310988 f310988)) ((primitive-ref write-char) f310988 f310985))) ((primitive-ref string->list) f310986)))))
# emit-expr f310954
=======
# emit-expr (begin (vector-set! f167 0 (closure (f198 f199) () (let ((f198 f198) (f199 f199)) ((primitive-ref for-each) (closure (f201) (f199) (let ((f201 f201)) ((primitive-ref write-char) f201 f199))) ((primitive-ref string->list) f198))))) (vector-set! f166 0 (closure (f196 f197) (f165) (let ((f196 f196) (f197 f197)) (begin ((primitive-ref write-char) #\( f197) ((vector-ref f165 0) f196 f197) ((primitive-ref write-char) #\) f197))))) (vector-set! f165 0 (closure (f194 f195) (f165) (let ((f194 f194) (f195 f195)) (begin ((primitive-ref write) (car f194) f195) (if (null? (cdr f194)) (begin #t) (if (pair? (cdr f194)) (begin (begin ((primitive-ref write-char) #\space f195) ((vector-ref f165 0) (cdr f194) f195))) (begin (begin ((primitive-ref write-char) #\space f195) ((primitive-ref write-char) #\. f195) ((primitive-ref write-char) #\space f195) ((primitive-ref write) (cdr f194) f195))))))))))
# emit-begin
#   expr=(begin (vector-set! f167 0 (closure (f198 f199) () (let ((f198 f198) (f199 f199)) ((primitive-ref for-each) (closure (f201) (f199) (let ((f201 f201)) ((primitive-ref write-char) f201 f199))) ((primitive-ref string->list) f198))))) (vector-set! f166 0 (closure (f196 f197) (f165) (let ((f196 f196) (f197 f197)) (begin ((primitive-ref write-char) #\( f197) ((vector-ref f165 0) f196 f197) ((primitive-ref write-char) #\) f197))))) (vector-set! f165 0 (closure (f194 f195) (f165) (let ((f194 f194) (f195 f195)) (begin ((primitive-ref write) (car f194) f195) (if (null? (cdr f194)) (begin #t) (if (pair? (cdr f194)) (begin (begin ((primitive-ref write-char) #\space f195) ((vector-ref f165 0) (cdr f194) f195))) (begin (begin ((primitive-ref write-char) #\space f195) ((primitive-ref write-char) #\. f195) ((primitive-ref write-char) #\space f195) ((primitive-ref write) (cdr f194) f195))))))))))
#   env=((f165 . -28) (f166 . -24) (f167 . -20) (f168 . -16) (f169 . -12) (f170 . -8) (f171 . -4) (f172 . 0))
# emit-expr (vector-set! f167 0 (closure (f198 f199) () (let ((f198 f198) (f199 f199)) ((primitive-ref for-each) (closure (f201) (f199) (let ((f201 f201)) ((primitive-ref write-char) f201 f199))) ((primitive-ref string->list) f198)))))
# emit-expr f167
>>>>>>> fix-implicit-begins
# emit-variable-ref
# env=((f165 . -28) (f166 . -24) (f167 . -20) (f168 . -16) (f169 . -12) (f170 . -8) (f171 . -4) (f172 . 0))
# var=f167
    movl -20(%esp), %eax  # stack load f167
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1286
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1286:
    movl %eax, -32(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1287"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1287:
# check bounds on vector index
    movl -32(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1289
    cmp  $0,%eax
    jge _L_1288
_L_1289:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1288:
    movl %eax, -36(%esp)
<<<<<<< HEAD
# emit-expr (closure (f310986 f310985) () (let ((f310986 f310986) (f310985 f310985)) ((primitive-ref for-each) (closure (f310988) (f310985) (let ((f310988 f310988)) ((primitive-ref write-char) f310988 f310985))) ((primitive-ref string->list) f310986))))
# emit-closure
# si = -40
# env = ((f310952 . -28) (f310953 . -24) (f310954 . -20) (f310955 . -16) (f310956 . -12) (f310957 . -8) (f310958 . -4) (f310959 . 0))
# expr = (closure (f310986 f310985) () (let ((f310986 f310986) (f310985 f310985)) ((primitive-ref for-each) (closure (f310988) (f310985) (let ((f310988 f310988)) ((primitive-ref write-char) f310988 f310985))) ((primitive-ref string->list) f310986))))
    movl $_L_1884889, 0(%ebp)  # closure label
=======
# emit-expr (closure (f198 f199) () (let ((f198 f198) (f199 f199)) ((primitive-ref for-each) (closure (f201) (f199) (let ((f201 f201)) ((primitive-ref write-char) f201 f199))) ((primitive-ref string->list) f198))))
# emit-closure
# si = -40
# env = ((f165 . -28) (f166 . -24) (f167 . -20) (f168 . -16) (f169 . -12) (f170 . -8) (f171 . -4) (f172 . 0))
# expr = (closure (f198 f199) () (let ((f198 f198) (f199 f199)) ((primitive-ref for-each) (closure (f201) (f199) (let ((f201 f201)) ((primitive-ref write-char) f201 f199))) ((primitive-ref string->list) f198))))
    movl $_L_1290, 0(%ebp)  # closure label
>>>>>>> fix-implicit-begins
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $8, %ebp     # bump ebp
    jmp _L_1291            # jump around closure body
_L_1290:
# check argument count
    cmp $8,%eax
    je _L_1292
# invoke error handler eh_argcount
    .extern mrc_eh$uargcount
    movl mrc_eh$uargcount, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_1292:
# emit-tail-expr
# si=-16
<<<<<<< HEAD
# env=((f310985 . -12) (f310986 . -8) (f310952 . -28) (f310953 . -24) (f310954 . -20) (f310955 . -16) (f310956 . -12) (f310957 . -8) (f310958 . -4) (f310959 . 0))
# expr=(let ((f310986 f310986) (f310985 f310985)) ((primitive-ref for-each) (closure (f310988) (f310985) (let ((f310988 f310988)) ((primitive-ref write-char) f310988 f310985))) ((primitive-ref string->list) f310986)))
# emit-tail-let
#  si   = -16
#  env  = ((f310985 . -12) (f310986 . -8) (f310952 . -28) (f310953 . -24) (f310954 . -20) (f310955 . -16) (f310956 . -12) (f310957 . -8) (f310958 . -4) (f310959 . 0))
#  bindings = ((f310986 f310986) (f310985 f310985))
#  body = ((primitive-ref for-each) (closure (f310988) (f310985) (let ((f310988 f310988)) ((primitive-ref write-char) f310988 f310985))) ((primitive-ref string->list) f310986))
# emit-expr f310986
# emit-variable-ref
# env=((f310985 . -12) (f310986 . -8) (f310952 . -28) (f310953 . -24) (f310954 . -20) (f310955 . -16) (f310956 . -12) (f310957 . -8) (f310958 . -4) (f310959 . 0))
# var=f310986
    movl -8(%esp), %eax  # stack load f310986
# end emit-variable-ref
    movl %eax, -16(%esp)  # stack save
# emit-expr f310985
# emit-variable-ref
# env=((f310985 . -12) (f310986 . -8) (f310952 . -28) (f310953 . -24) (f310954 . -20) (f310955 . -16) (f310956 . -12) (f310957 . -8) (f310958 . -4) (f310959 . 0))
# var=f310985
    movl -12(%esp), %eax  # stack load f310985
=======
# env=((f199 . -12) (f198 . -8) (f165 . -28) (f166 . -24) (f167 . -20) (f168 . -16) (f169 . -12) (f170 . -8) (f171 . -4) (f172 . 0))
# expr=(let ((f198 f198) (f199 f199)) ((primitive-ref for-each) (closure (f201) (f199) (let ((f201 f201)) ((primitive-ref write-char) f201 f199))) ((primitive-ref string->list) f198)))
# emit-tail-let
#  si   = -16
#  env  = ((f199 . -12) (f198 . -8) (f165 . -28) (f166 . -24) (f167 . -20) (f168 . -16) (f169 . -12) (f170 . -8) (f171 . -4) (f172 . 0))
#  bindings = ((f198 f198) (f199 f199))
#  body = ((primitive-ref for-each) (closure (f201) (f199) (let ((f201 f201)) ((primitive-ref write-char) f201 f199))) ((primitive-ref string->list) f198))
# emit-expr f198
# emit-variable-ref
# env=((f199 . -12) (f198 . -8) (f165 . -28) (f166 . -24) (f167 . -20) (f168 . -16) (f169 . -12) (f170 . -8) (f171 . -4) (f172 . 0))
# var=f198
    movl -8(%esp), %eax  # stack load f198
# end emit-variable-ref
    movl %eax, -16(%esp)  # stack save
# emit-expr f199
# emit-variable-ref
# env=((f199 . -12) (f198 . -8) (f165 . -28) (f166 . -24) (f167 . -20) (f168 . -16) (f169 . -12) (f170 . -8) (f171 . -4) (f172 . 0))
# var=f199
    movl -12(%esp), %eax  # stack load f199
>>>>>>> fix-implicit-begins
# end emit-variable-ref
    movl %eax, -20(%esp)  # stack save
# emit-tail-expr
# si=-24
<<<<<<< HEAD
# env=((f310985 . -20) (f310986 . -16) (f310985 . -12) (f310986 . -8) (f310952 . -28) (f310953 . -24) (f310954 . -20) (f310955 . -16) (f310956 . -12) (f310957 . -8) (f310958 . -4) (f310959 . 0))
# expr=((primitive-ref for-each) (closure (f310988) (f310985) (let ((f310988 f310988)) ((primitive-ref write-char) f310988 f310985))) ((primitive-ref string->list) f310986))
# emit-tail-funcall
#    si   =-24
#    env  = ((f310985 . -20) (f310986 . -16) (f310985 . -12) (f310986 . -8) (f310952 . -28) (f310953 . -24) (f310954 . -20) (f310955 . -16) (f310956 . -12) (f310957 . -8) (f310958 . -4) (f310959 . 0))
#    expr = (funcall (primitive-ref for-each) (closure (f310988) (f310985) (let ((f310988 f310988)) ((primitive-ref write-char) f310988 f310985))) ((primitive-ref string->list) f310986))
=======
# env=((f199 . -20) (f198 . -16) (f199 . -12) (f198 . -8) (f165 . -28) (f166 . -24) (f167 . -20) (f168 . -16) (f169 . -12) (f170 . -8) (f171 . -4) (f172 . 0))
# expr=((primitive-ref for-each) (closure (f201) (f199) (let ((f201 f201)) ((primitive-ref write-char) f201 f199))) ((primitive-ref string->list) f198))
# emit-tail-funcall
#    si   =-24
#    env  = ((f199 . -20) (f198 . -16) (f199 . -12) (f198 . -8) (f165 . -28) (f166 . -24) (f167 . -20) (f168 . -16) (f169 . -12) (f170 . -8) (f171 . -4) (f172 . 0))
#    expr = (funcall (primitive-ref for-each) (closure (f201) (f199) (let ((f201 f201)) ((primitive-ref write-char) f201 f199))) ((primitive-ref string->list) f198))
>>>>>>> fix-implicit-begins
# emit-expr (primitive-ref for-each)
    .extern mrc_for$meach
    movl mrc_for$meach,%eax
   movl %eax,  -24(%esp)  # stash funcall-oper in next closure slot
<<<<<<< HEAD
# emit-expr (closure (f310988) (f310985) (let ((f310988 f310988)) ((primitive-ref write-char) f310988 f310985)))
# emit-closure
# si = -28
# env = ((f310985 . -20) (f310986 . -16) (f310985 . -12) (f310986 . -8) (f310952 . -28) (f310953 . -24) (f310954 . -20) (f310955 . -16) (f310956 . -12) (f310957 . -8) (f310958 . -4) (f310959 . 0))
# expr = (closure (f310988) (f310985) (let ((f310988 f310988)) ((primitive-ref write-char) f310988 f310985)))
    movl $_L_1884892, 0(%ebp)  # closure label
# emit-variable-ref
# env=((f310985 . -20) (f310986 . -16) (f310985 . -12) (f310986 . -8) (f310952 . -28) (f310953 . -24) (f310954 . -20) (f310955 . -16) (f310956 . -12) (f310957 . -8) (f310958 . -4) (f310959 . 0))
# var=f310985
    movl -20(%esp), %eax  # stack load f310985
# end emit-variable-ref
   movl  %eax, 4(%ebp)  # f310985
=======
# emit-expr (closure (f201) (f199) (let ((f201 f201)) ((primitive-ref write-char) f201 f199)))
# emit-closure
# si = -28
# env = ((f199 . -20) (f198 . -16) (f199 . -12) (f198 . -8) (f165 . -28) (f166 . -24) (f167 . -20) (f168 . -16) (f169 . -12) (f170 . -8) (f171 . -4) (f172 . 0))
# expr = (closure (f201) (f199) (let ((f201 f201)) ((primitive-ref write-char) f201 f199)))
    movl $_L_1293, 0(%ebp)  # closure label
# emit-variable-ref
# env=((f199 . -20) (f198 . -16) (f199 . -12) (f198 . -8) (f165 . -28) (f166 . -24) (f167 . -20) (f168 . -16) (f169 . -12) (f170 . -8) (f171 . -4) (f172 . 0))
# var=f199
    movl -20(%esp), %eax  # stack load f199
# end emit-variable-ref
   movl  %eax, 4(%ebp)  # f199
>>>>>>> fix-implicit-begins
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $8, %ebp     # bump ebp
    jmp _L_1294            # jump around closure body
_L_1293:
# check argument count
    cmp $4,%eax
    je _L_1295
# invoke error handler eh_argcount
    .extern mrc_eh$uargcount
    movl mrc_eh$uargcount, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_1295:
# emit-tail-expr
# si=-12
<<<<<<< HEAD
# env=((f310988 . -8) (f310985 . 4) (f310985 . -20) (f310986 . -16) (f310985 . -12) (f310986 . -8) (f310952 . -28) (f310953 . -24) (f310954 . -20) (f310955 . -16) (f310956 . -12) (f310957 . -8) (f310958 . -4) (f310959 . 0))
# expr=(let ((f310988 f310988)) ((primitive-ref write-char) f310988 f310985))
# emit-tail-let
#  si   = -12
#  env  = ((f310988 . -8) (f310985 . 4) (f310985 . -20) (f310986 . -16) (f310985 . -12) (f310986 . -8) (f310952 . -28) (f310953 . -24) (f310954 . -20) (f310955 . -16) (f310956 . -12) (f310957 . -8) (f310958 . -4) (f310959 . 0))
#  bindings = ((f310988 f310988))
#  body = ((primitive-ref write-char) f310988 f310985)
# emit-expr f310988
# emit-variable-ref
# env=((f310988 . -8) (f310985 . 4) (f310985 . -20) (f310986 . -16) (f310985 . -12) (f310986 . -8) (f310952 . -28) (f310953 . -24) (f310954 . -20) (f310955 . -16) (f310956 . -12) (f310957 . -8) (f310958 . -4) (f310959 . 0))
# var=f310988
    movl -8(%esp), %eax  # stack load f310988
=======
# env=((f201 . -8) (f199 . 4) (f199 . -20) (f198 . -16) (f199 . -12) (f198 . -8) (f165 . -28) (f166 . -24) (f167 . -20) (f168 . -16) (f169 . -12) (f170 . -8) (f171 . -4) (f172 . 0))
# expr=(let ((f201 f201)) ((primitive-ref write-char) f201 f199))
# emit-tail-let
#  si   = -12
#  env  = ((f201 . -8) (f199 . 4) (f199 . -20) (f198 . -16) (f199 . -12) (f198 . -8) (f165 . -28) (f166 . -24) (f167 . -20) (f168 . -16) (f169 . -12) (f170 . -8) (f171 . -4) (f172 . 0))
#  bindings = ((f201 f201))
#  body = ((primitive-ref write-char) f201 f199)
# emit-expr f201
# emit-variable-ref
# env=((f201 . -8) (f199 . 4) (f199 . -20) (f198 . -16) (f199 . -12) (f198 . -8) (f165 . -28) (f166 . -24) (f167 . -20) (f168 . -16) (f169 . -12) (f170 . -8) (f171 . -4) (f172 . 0))
# var=f201
    movl -8(%esp), %eax  # stack load f201
>>>>>>> fix-implicit-begins
# end emit-variable-ref
    movl %eax, -12(%esp)  # stack save
# emit-tail-expr
# si=-16
<<<<<<< HEAD
# env=((f310988 . -12) (f310988 . -8) (f310985 . 4) (f310985 . -20) (f310986 . -16) (f310985 . -12) (f310986 . -8) (f310952 . -28) (f310953 . -24) (f310954 . -20) (f310955 . -16) (f310956 . -12) (f310957 . -8) (f310958 . -4) (f310959 . 0))
# expr=((primitive-ref write-char) f310988 f310985)
# emit-tail-funcall
#    si   =-16
#    env  = ((f310988 . -12) (f310988 . -8) (f310985 . 4) (f310985 . -20) (f310986 . -16) (f310985 . -12) (f310986 . -8) (f310952 . -28) (f310953 . -24) (f310954 . -20) (f310955 . -16) (f310956 . -12) (f310957 . -8) (f310958 . -4) (f310959 . 0))
#    expr = (funcall (primitive-ref write-char) f310988 f310985)
=======
# env=((f201 . -12) (f201 . -8) (f199 . 4) (f199 . -20) (f198 . -16) (f199 . -12) (f198 . -8) (f165 . -28) (f166 . -24) (f167 . -20) (f168 . -16) (f169 . -12) (f170 . -8) (f171 . -4) (f172 . 0))
# expr=((primitive-ref write-char) f201 f199)
# emit-tail-funcall
#    si   =-16
#    env  = ((f201 . -12) (f201 . -8) (f199 . 4) (f199 . -20) (f198 . -16) (f199 . -12) (f198 . -8) (f165 . -28) (f166 . -24) (f167 . -20) (f168 . -16) (f169 . -12) (f170 . -8) (f171 . -4) (f172 . 0))
#    expr = (funcall (primitive-ref write-char) f201 f199)
>>>>>>> fix-implicit-begins
# emit-expr (primitive-ref write-char)
    .extern mrc_write$mchar
    movl mrc_write$mchar,%eax
   movl %eax,  -16(%esp)  # stash funcall-oper in next closure slot
# emit-expr f201
# emit-variable-ref
<<<<<<< HEAD
# env=((f310988 . -12) (f310988 . -8) (f310985 . 4) (f310985 . -20) (f310986 . -16) (f310985 . -12) (f310986 . -8) (f310952 . -28) (f310953 . -24) (f310954 . -20) (f310955 . -16) (f310956 . -12) (f310957 . -8) (f310958 . -4) (f310959 . 0))
# var=f310988
    movl -12(%esp), %eax  # stack load f310988
# end emit-variable-ref
    mov %eax, -20(%esp)    # arg f310988
# emit-expr f310985
# emit-variable-ref
# env=((f310988 . -12) (f310988 . -8) (f310985 . 4) (f310985 . -20) (f310986 . -16) (f310985 . -12) (f310986 . -8) (f310952 . -28) (f310953 . -24) (f310954 . -20) (f310955 . -16) (f310956 . -12) (f310957 . -8) (f310958 . -4) (f310959 . 0))
# var=f310985
    movl 2(%edi), %eax  # frame load f310985
# end emit-variable-ref
    mov %eax, -24(%esp)    # arg f310985
=======
# env=((f201 . -12) (f201 . -8) (f199 . 4) (f199 . -20) (f198 . -16) (f199 . -12) (f198 . -8) (f165 . -28) (f166 . -24) (f167 . -20) (f168 . -16) (f169 . -12) (f170 . -8) (f171 . -4) (f172 . 0))
# var=f201
    movl -12(%esp), %eax  # stack load f201
# end emit-variable-ref
    mov %eax, -20(%esp)    # arg f201
# emit-expr f199
# emit-variable-ref
# env=((f201 . -12) (f201 . -8) (f199 . 4) (f199 . -20) (f198 . -16) (f199 . -12) (f198 . -8) (f165 . -28) (f166 . -24) (f167 . -20) (f168 . -16) (f169 . -12) (f170 . -8) (f171 . -4) (f172 . 0))
# var=f199
    movl 2(%edi), %eax  # frame load f199
# end emit-variable-ref
    mov %eax, -24(%esp)    # arg f199
>>>>>>> fix-implicit-begins
    movl -16(%esp), %edi   # load new closure to %edi
# emit-shift-args:  size=3   si=-16  delta=12
    mov -16(%esp), %ebx  # shift frame cell
    mov %ebx, -4(%esp)  # down to base
# emit-shift-args:  size=2   si=-20  delta=12
    mov -20(%esp), %ebx  # shift frame cell
    mov %ebx, -8(%esp)  # down to base
# emit-shift-args:  size=1   si=-24  delta=12
    mov -24(%esp), %ebx  # shift frame cell
    mov %ebx, -12(%esp)  # down to base
# emit-shift-args:  size=0   si=-28  delta=12
    movl $8,%eax   # save arg count
    jmp *-2(%edi)  # tail-funcall
    .align 4,0x90
<<<<<<< HEAD
_L_1884893:
    mov %eax, -28(%esp)    # arg (closure (f310988) (f310985) (let ((f310988 f310988)) ((primitive-ref write-char) f310988 f310985)))
# emit-expr ((primitive-ref string->list) f310986)
# funcall
#    si   =-32
#    env  = ((f310985 . -20) (f310986 . -16) (f310985 . -12) (f310986 . -8) (f310952 . -28) (f310953 . -24) (f310954 . -20) (f310955 . -16) (f310956 . -12) (f310957 . -8) (f310958 . -4) (f310959 . 0))
#    expr = (funcall (primitive-ref string->list) f310986)
=======
_L_1294:
    mov %eax, -28(%esp)    # arg (closure (f201) (f199) (let ((f201 f201)) ((primitive-ref write-char) f201 f199)))
# emit-expr ((primitive-ref string->list) f198)
# funcall
#    si   =-32
#    env  = ((f199 . -20) (f198 . -16) (f199 . -12) (f198 . -8) (f165 . -28) (f166 . -24) (f167 . -20) (f168 . -16) (f169 . -12) (f170 . -8) (f171 . -4) (f172 . 0))
#    expr = (funcall (primitive-ref string->list) f198)
>>>>>>> fix-implicit-begins
# emit-expr (primitive-ref string->list)
    .extern mrc_string$m$glist
    movl mrc_string$m$glist,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1296"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1296":
   movl %eax,  -40(%esp)  # stash funcall-oper in closure slot
<<<<<<< HEAD
# emit-expr f310986
# emit-variable-ref
# env=((f310985 . -20) (f310986 . -16) (f310985 . -12) (f310986 . -8) (f310952 . -28) (f310953 . -24) (f310954 . -20) (f310955 . -16) (f310956 . -12) (f310957 . -8) (f310958 . -4) (f310959 . 0))
# var=f310986
    movl -16(%esp), %eax  # stack load f310986
# end emit-variable-ref
    mov %eax, -44(%esp)  # arg f310986
=======
# emit-expr f198
# emit-variable-ref
# env=((f199 . -20) (f198 . -16) (f199 . -12) (f198 . -8) (f165 . -28) (f166 . -24) (f167 . -20) (f168 . -16) (f169 . -12) (f170 . -8) (f171 . -4) (f172 . 0))
# var=f198
    movl -16(%esp), %eax  # stack load f198
# end emit-variable-ref
    mov %eax, -44(%esp)  # arg f198
>>>>>>> fix-implicit-begins
    movl -40(%esp), %edi   # load new closure to %edi
    add $-32, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $32, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
<<<<<<< HEAD
    mov %eax, -32(%esp)    # arg ((primitive-ref string->list) f310986)
=======
    mov %eax, -32(%esp)    # arg ((primitive-ref string->list) f198)
>>>>>>> fix-implicit-begins
    movl -24(%esp), %edi   # load new closure to %edi
# emit-shift-args:  size=3   si=-24  delta=20
    mov -24(%esp), %ebx  # shift frame cell
    mov %ebx, -4(%esp)  # down to base
# emit-shift-args:  size=2   si=-28  delta=20
    mov -28(%esp), %ebx  # shift frame cell
    mov %ebx, -8(%esp)  # down to base
# emit-shift-args:  size=1   si=-32  delta=20
    mov -32(%esp), %ebx  # shift frame cell
    mov %ebx, -12(%esp)  # down to base
# emit-shift-args:  size=0   si=-36  delta=20
    movl $8,%eax   # save arg count
    jmp *-2(%edi)  # tail-funcall
    .align 4,0x90
_L_1291:
    movl -32(%esp), %ebx
    movl -36(%esp), %esi
    movl %eax, -1(%ebx,%esi)
<<<<<<< HEAD
# emit-expr (begin (vector-set! f310953 0 (closure (f310984 f310983) (f310952) (let ((f310984 f310984) (f310983 f310983)) (begin ((primitive-ref write-char) #\( f310983) ((vector-ref f310952 0) f310984 f310983) ((primitive-ref write-char) #\) f310983))))) (vector-set! f310952 0 (closure (f310982 f310981) (f310952) (let ((f310982 f310982) (f310981 f310981)) (begin ((primitive-ref write) (car f310982) f310981) (if (null? (cdr f310982)) #t (if (pair? (cdr f310982)) (begin ((primitive-ref write-char) #\space f310981) ((vector-ref f310952 0) (cdr f310982) f310981)) (begin ((primitive-ref write-char) #\space f310981) ((primitive-ref write-char) #\. f310981) ((primitive-ref write-char) #\space f310981) ((primitive-ref write) (cdr f310982) f310981)))))))))
# emit-begin
#   expr=(begin (vector-set! f310953 0 (closure (f310984 f310983) (f310952) (let ((f310984 f310984) (f310983 f310983)) (begin ((primitive-ref write-char) #\( f310983) ((vector-ref f310952 0) f310984 f310983) ((primitive-ref write-char) #\) f310983))))) (vector-set! f310952 0 (closure (f310982 f310981) (f310952) (let ((f310982 f310982) (f310981 f310981)) (begin ((primitive-ref write) (car f310982) f310981) (if (null? (cdr f310982)) #t (if (pair? (cdr f310982)) (begin ((primitive-ref write-char) #\space f310981) ((vector-ref f310952 0) (cdr f310982) f310981)) (begin ((primitive-ref write-char) #\space f310981) ((primitive-ref write-char) #\. f310981) ((primitive-ref write-char) #\space f310981) ((primitive-ref write) (cdr f310982) f310981)))))))))
#   env=((f310952 . -28) (f310953 . -24) (f310954 . -20) (f310955 . -16) (f310956 . -12) (f310957 . -8) (f310958 . -4) (f310959 . 0))
# emit-expr (vector-set! f310953 0 (closure (f310984 f310983) (f310952) (let ((f310984 f310984) (f310983 f310983)) (begin ((primitive-ref write-char) #\( f310983) ((vector-ref f310952 0) f310984 f310983) ((primitive-ref write-char) #\) f310983)))))
# emit-expr f310953
=======
# emit-expr (begin (vector-set! f166 0 (closure (f196 f197) (f165) (let ((f196 f196) (f197 f197)) (begin ((primitive-ref write-char) #\( f197) ((vector-ref f165 0) f196 f197) ((primitive-ref write-char) #\) f197))))) (vector-set! f165 0 (closure (f194 f195) (f165) (let ((f194 f194) (f195 f195)) (begin ((primitive-ref write) (car f194) f195) (if (null? (cdr f194)) (begin #t) (if (pair? (cdr f194)) (begin (begin ((primitive-ref write-char) #\space f195) ((vector-ref f165 0) (cdr f194) f195))) (begin (begin ((primitive-ref write-char) #\space f195) ((primitive-ref write-char) #\. f195) ((primitive-ref write-char) #\space f195) ((primitive-ref write) (cdr f194) f195))))))))))
# emit-begin
#   expr=(begin (vector-set! f166 0 (closure (f196 f197) (f165) (let ((f196 f196) (f197 f197)) (begin ((primitive-ref write-char) #\( f197) ((vector-ref f165 0) f196 f197) ((primitive-ref write-char) #\) f197))))) (vector-set! f165 0 (closure (f194 f195) (f165) (let ((f194 f194) (f195 f195)) (begin ((primitive-ref write) (car f194) f195) (if (null? (cdr f194)) (begin #t) (if (pair? (cdr f194)) (begin (begin ((primitive-ref write-char) #\space f195) ((vector-ref f165 0) (cdr f194) f195))) (begin (begin ((primitive-ref write-char) #\space f195) ((primitive-ref write-char) #\. f195) ((primitive-ref write-char) #\space f195) ((primitive-ref write) (cdr f194) f195))))))))))
#   env=((f165 . -28) (f166 . -24) (f167 . -20) (f168 . -16) (f169 . -12) (f170 . -8) (f171 . -4) (f172 . 0))
# emit-expr (vector-set! f166 0 (closure (f196 f197) (f165) (let ((f196 f196) (f197 f197)) (begin ((primitive-ref write-char) #\( f197) ((vector-ref f165 0) f196 f197) ((primitive-ref write-char) #\) f197)))))
# emit-expr f166
>>>>>>> fix-implicit-begins
# emit-variable-ref
# env=((f165 . -28) (f166 . -24) (f167 . -20) (f168 . -16) (f169 . -12) (f170 . -8) (f171 . -4) (f172 . 0))
# var=f166
    movl -24(%esp), %eax  # stack load f166
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1297
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1297:
    movl %eax, -32(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1298"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1298:
# check bounds on vector index
    movl -32(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1300
    cmp  $0,%eax
    jge _L_1299
_L_1300:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1299:
    movl %eax, -36(%esp)
<<<<<<< HEAD
# emit-expr (closure (f310984 f310983) (f310952) (let ((f310984 f310984) (f310983 f310983)) (begin ((primitive-ref write-char) #\( f310983) ((vector-ref f310952 0) f310984 f310983) ((primitive-ref write-char) #\) f310983))))
# emit-closure
# si = -40
# env = ((f310952 . -28) (f310953 . -24) (f310954 . -20) (f310955 . -16) (f310956 . -12) (f310957 . -8) (f310958 . -4) (f310959 . 0))
# expr = (closure (f310984 f310983) (f310952) (let ((f310984 f310984) (f310983 f310983)) (begin ((primitive-ref write-char) #\( f310983) ((vector-ref f310952 0) f310984 f310983) ((primitive-ref write-char) #\) f310983))))
    movl $_L_1884900, 0(%ebp)  # closure label
=======
# emit-expr (closure (f196 f197) (f165) (let ((f196 f196) (f197 f197)) (begin ((primitive-ref write-char) #\( f197) ((vector-ref f165 0) f196 f197) ((primitive-ref write-char) #\) f197))))
# emit-closure
# si = -40
# env = ((f165 . -28) (f166 . -24) (f167 . -20) (f168 . -16) (f169 . -12) (f170 . -8) (f171 . -4) (f172 . 0))
# expr = (closure (f196 f197) (f165) (let ((f196 f196) (f197 f197)) (begin ((primitive-ref write-char) #\( f197) ((vector-ref f165 0) f196 f197) ((primitive-ref write-char) #\) f197))))
    movl $_L_1301, 0(%ebp)  # closure label
>>>>>>> fix-implicit-begins
# emit-variable-ref
# env=((f165 . -28) (f166 . -24) (f167 . -20) (f168 . -16) (f169 . -12) (f170 . -8) (f171 . -4) (f172 . 0))
# var=f165
    movl -28(%esp), %eax  # stack load f165
# end emit-variable-ref
   movl  %eax, 4(%ebp)  # f165
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $8, %ebp     # bump ebp
    jmp _L_1302            # jump around closure body
_L_1301:
# check argument count
    cmp $8,%eax
    je _L_1303
# invoke error handler eh_argcount
    .extern mrc_eh$uargcount
    movl mrc_eh$uargcount, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_1303:
# emit-tail-expr
# si=-16
<<<<<<< HEAD
# env=((f310983 . -12) (f310984 . -8) (f310952 . 4) (f310952 . -28) (f310953 . -24) (f310954 . -20) (f310955 . -16) (f310956 . -12) (f310957 . -8) (f310958 . -4) (f310959 . 0))
# expr=(let ((f310984 f310984) (f310983 f310983)) (begin ((primitive-ref write-char) #\( f310983) ((vector-ref f310952 0) f310984 f310983) ((primitive-ref write-char) #\) f310983)))
# emit-tail-let
#  si   = -16
#  env  = ((f310983 . -12) (f310984 . -8) (f310952 . 4) (f310952 . -28) (f310953 . -24) (f310954 . -20) (f310955 . -16) (f310956 . -12) (f310957 . -8) (f310958 . -4) (f310959 . 0))
#  bindings = ((f310984 f310984) (f310983 f310983))
#  body = (begin ((primitive-ref write-char) #\( f310983) ((vector-ref f310952 0) f310984 f310983) ((primitive-ref write-char) #\) f310983))
# emit-expr f310984
# emit-variable-ref
# env=((f310983 . -12) (f310984 . -8) (f310952 . 4) (f310952 . -28) (f310953 . -24) (f310954 . -20) (f310955 . -16) (f310956 . -12) (f310957 . -8) (f310958 . -4) (f310959 . 0))
# var=f310984
    movl -8(%esp), %eax  # stack load f310984
# end emit-variable-ref
    movl %eax, -16(%esp)  # stack save
# emit-expr f310983
# emit-variable-ref
# env=((f310983 . -12) (f310984 . -8) (f310952 . 4) (f310952 . -28) (f310953 . -24) (f310954 . -20) (f310955 . -16) (f310956 . -12) (f310957 . -8) (f310958 . -4) (f310959 . 0))
# var=f310983
    movl -12(%esp), %eax  # stack load f310983
=======
# env=((f197 . -12) (f196 . -8) (f165 . 4) (f165 . -28) (f166 . -24) (f167 . -20) (f168 . -16) (f169 . -12) (f170 . -8) (f171 . -4) (f172 . 0))
# expr=(let ((f196 f196) (f197 f197)) (begin ((primitive-ref write-char) #\( f197) ((vector-ref f165 0) f196 f197) ((primitive-ref write-char) #\) f197)))
# emit-tail-let
#  si   = -16
#  env  = ((f197 . -12) (f196 . -8) (f165 . 4) (f165 . -28) (f166 . -24) (f167 . -20) (f168 . -16) (f169 . -12) (f170 . -8) (f171 . -4) (f172 . 0))
#  bindings = ((f196 f196) (f197 f197))
#  body = (begin ((primitive-ref write-char) #\( f197) ((vector-ref f165 0) f196 f197) ((primitive-ref write-char) #\) f197))
# emit-expr f196
# emit-variable-ref
# env=((f197 . -12) (f196 . -8) (f165 . 4) (f165 . -28) (f166 . -24) (f167 . -20) (f168 . -16) (f169 . -12) (f170 . -8) (f171 . -4) (f172 . 0))
# var=f196
    movl -8(%esp), %eax  # stack load f196
# end emit-variable-ref
    movl %eax, -16(%esp)  # stack save
# emit-expr f197
# emit-variable-ref
# env=((f197 . -12) (f196 . -8) (f165 . 4) (f165 . -28) (f166 . -24) (f167 . -20) (f168 . -16) (f169 . -12) (f170 . -8) (f171 . -4) (f172 . 0))
# var=f197
    movl -12(%esp), %eax  # stack load f197
>>>>>>> fix-implicit-begins
# end emit-variable-ref
    movl %eax, -20(%esp)  # stack save
# emit-tail-expr
# si=-24
<<<<<<< HEAD
# env=((f310983 . -20) (f310984 . -16) (f310983 . -12) (f310984 . -8) (f310952 . 4) (f310952 . -28) (f310953 . -24) (f310954 . -20) (f310955 . -16) (f310956 . -12) (f310957 . -8) (f310958 . -4) (f310959 . 0))
# expr=(begin ((primitive-ref write-char) #\( f310983) ((vector-ref f310952 0) f310984 f310983) ((primitive-ref write-char) #\) f310983))
# tail-begin (begin ((primitive-ref write-char) #\( f310983) ((vector-ref f310952 0) f310984 f310983) ((primitive-ref write-char) #\) f310983))
#   env=((f310983 . -20) (f310984 . -16) (f310983 . -12) (f310984 . -8) (f310952 . 4) (f310952 . -28) (f310953 . -24) (f310954 . -20) (f310955 . -16) (f310956 . -12) (f310957 . -8) (f310958 . -4) (f310959 . 0))
# emit-expr ((primitive-ref write-char) #\( f310983)
# funcall
#    si   =-24
#    env  = ((f310983 . -20) (f310984 . -16) (f310983 . -12) (f310984 . -8) (f310952 . 4) (f310952 . -28) (f310953 . -24) (f310954 . -20) (f310955 . -16) (f310956 . -12) (f310957 . -8) (f310958 . -4) (f310959 . 0))
#    expr = (funcall (primitive-ref write-char) #\( f310983)
=======
# env=((f197 . -20) (f196 . -16) (f197 . -12) (f196 . -8) (f165 . 4) (f165 . -28) (f166 . -24) (f167 . -20) (f168 . -16) (f169 . -12) (f170 . -8) (f171 . -4) (f172 . 0))
# expr=(begin ((primitive-ref write-char) #\( f197) ((vector-ref f165 0) f196 f197) ((primitive-ref write-char) #\) f197))
# tail-begin (begin ((primitive-ref write-char) #\( f197) ((vector-ref f165 0) f196 f197) ((primitive-ref write-char) #\) f197))
#   env=((f197 . -20) (f196 . -16) (f197 . -12) (f196 . -8) (f165 . 4) (f165 . -28) (f166 . -24) (f167 . -20) (f168 . -16) (f169 . -12) (f170 . -8) (f171 . -4) (f172 . 0))
# emit-expr ((primitive-ref write-char) #\( f197)
# funcall
#    si   =-24
#    env  = ((f197 . -20) (f196 . -16) (f197 . -12) (f196 . -8) (f165 . 4) (f165 . -28) (f166 . -24) (f167 . -20) (f168 . -16) (f169 . -12) (f170 . -8) (f171 . -4) (f172 . 0))
#    expr = (funcall (primitive-ref write-char) #\( f197)
>>>>>>> fix-implicit-begins
# emit-expr (primitive-ref write-char)
    .extern mrc_write$mchar
    movl mrc_write$mchar,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1304"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1304":
   movl %eax,  -32(%esp)  # stash funcall-oper in closure slot
# emit-expr #\(
    movl $10255, %eax     # immed #\(
    mov %eax, -36(%esp)  # arg (
<<<<<<< HEAD
# emit-expr f310983
# emit-variable-ref
# env=((f310983 . -20) (f310984 . -16) (f310983 . -12) (f310984 . -8) (f310952 . 4) (f310952 . -28) (f310953 . -24) (f310954 . -20) (f310955 . -16) (f310956 . -12) (f310957 . -8) (f310958 . -4) (f310959 . 0))
# var=f310983
    movl -20(%esp), %eax  # stack load f310983
# end emit-variable-ref
    mov %eax, -40(%esp)  # arg f310983
=======
# emit-expr f197
# emit-variable-ref
# env=((f197 . -20) (f196 . -16) (f197 . -12) (f196 . -8) (f165 . 4) (f165 . -28) (f166 . -24) (f167 . -20) (f168 . -16) (f169 . -12) (f170 . -8) (f171 . -4) (f172 . 0))
# var=f197
    movl -20(%esp), %eax  # stack load f197
# end emit-variable-ref
    mov %eax, -40(%esp)  # arg f197
>>>>>>> fix-implicit-begins
    movl -32(%esp), %edi   # load new closure to %edi
    add $-24, %esp   # adjust base
    movl $8,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $24, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
# emit-tail-expr
# si=-24
<<<<<<< HEAD
# env=((f310983 . -20) (f310984 . -16) (f310983 . -12) (f310984 . -8) (f310952 . 4) (f310952 . -28) (f310953 . -24) (f310954 . -20) (f310955 . -16) (f310956 . -12) (f310957 . -8) (f310958 . -4) (f310959 . 0))
# expr=(begin ((vector-ref f310952 0) f310984 f310983) ((primitive-ref write-char) #\) f310983))
# tail-begin (begin ((vector-ref f310952 0) f310984 f310983) ((primitive-ref write-char) #\) f310983))
#   env=((f310983 . -20) (f310984 . -16) (f310983 . -12) (f310984 . -8) (f310952 . 4) (f310952 . -28) (f310953 . -24) (f310954 . -20) (f310955 . -16) (f310956 . -12) (f310957 . -8) (f310958 . -4) (f310959 . 0))
# emit-expr ((vector-ref f310952 0) f310984 f310983)
# funcall
#    si   =-24
#    env  = ((f310983 . -20) (f310984 . -16) (f310983 . -12) (f310984 . -8) (f310952 . 4) (f310952 . -28) (f310953 . -24) (f310954 . -20) (f310955 . -16) (f310956 . -12) (f310957 . -8) (f310958 . -4) (f310959 . 0))
#    expr = (funcall (vector-ref f310952 0) f310984 f310983)
# emit-expr (vector-ref f310952 0)
# emit-expr f310952
# emit-variable-ref
# env=((f310983 . -20) (f310984 . -16) (f310983 . -12) (f310984 . -8) (f310952 . 4) (f310952 . -28) (f310953 . -24) (f310954 . -20) (f310955 . -16) (f310956 . -12) (f310957 . -8) (f310958 . -4) (f310959 . 0))
# var=f310952
    movl 2(%edi), %eax  # frame load f310952
=======
# env=((f197 . -20) (f196 . -16) (f197 . -12) (f196 . -8) (f165 . 4) (f165 . -28) (f166 . -24) (f167 . -20) (f168 . -16) (f169 . -12) (f170 . -8) (f171 . -4) (f172 . 0))
# expr=(begin ((vector-ref f165 0) f196 f197) ((primitive-ref write-char) #\) f197))
# tail-begin (begin ((vector-ref f165 0) f196 f197) ((primitive-ref write-char) #\) f197))
#   env=((f197 . -20) (f196 . -16) (f197 . -12) (f196 . -8) (f165 . 4) (f165 . -28) (f166 . -24) (f167 . -20) (f168 . -16) (f169 . -12) (f170 . -8) (f171 . -4) (f172 . 0))
# emit-expr ((vector-ref f165 0) f196 f197)
# funcall
#    si   =-24
#    env  = ((f197 . -20) (f196 . -16) (f197 . -12) (f196 . -8) (f165 . 4) (f165 . -28) (f166 . -24) (f167 . -20) (f168 . -16) (f169 . -12) (f170 . -8) (f171 . -4) (f172 . 0))
#    expr = (funcall (vector-ref f165 0) f196 f197)
# emit-expr (vector-ref f165 0)
# emit-expr f165
# emit-variable-ref
# env=((f197 . -20) (f196 . -16) (f197 . -12) (f196 . -8) (f165 . 4) (f165 . -28) (f166 . -24) (f167 . -20) (f168 . -16) (f169 . -12) (f170 . -8) (f171 . -4) (f172 . 0))
# var=f165
    movl 2(%edi), %eax  # frame load f165
>>>>>>> fix-implicit-begins
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1305
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1305:
    movl %eax, -32(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1306"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1306:
# check bounds on vector index
    movl -32(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1308
    cmp  $0,%eax
    jge _L_1307
_L_1308:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1307:
    movl -32(%esp), %esi
    movl -1(%eax,%esi), %eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1309"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1309":
   movl %eax,  -32(%esp)  # stash funcall-oper in closure slot
<<<<<<< HEAD
# emit-expr f310984
# emit-variable-ref
# env=((f310983 . -20) (f310984 . -16) (f310983 . -12) (f310984 . -8) (f310952 . 4) (f310952 . -28) (f310953 . -24) (f310954 . -20) (f310955 . -16) (f310956 . -12) (f310957 . -8) (f310958 . -4) (f310959 . 0))
# var=f310984
    movl -16(%esp), %eax  # stack load f310984
# end emit-variable-ref
    mov %eax, -36(%esp)  # arg f310984
# emit-expr f310983
# emit-variable-ref
# env=((f310983 . -20) (f310984 . -16) (f310983 . -12) (f310984 . -8) (f310952 . 4) (f310952 . -28) (f310953 . -24) (f310954 . -20) (f310955 . -16) (f310956 . -12) (f310957 . -8) (f310958 . -4) (f310959 . 0))
# var=f310983
    movl -20(%esp), %eax  # stack load f310983
# end emit-variable-ref
    mov %eax, -40(%esp)  # arg f310983
=======
# emit-expr f196
# emit-variable-ref
# env=((f197 . -20) (f196 . -16) (f197 . -12) (f196 . -8) (f165 . 4) (f165 . -28) (f166 . -24) (f167 . -20) (f168 . -16) (f169 . -12) (f170 . -8) (f171 . -4) (f172 . 0))
# var=f196
    movl -16(%esp), %eax  # stack load f196
# end emit-variable-ref
    mov %eax, -36(%esp)  # arg f196
# emit-expr f197
# emit-variable-ref
# env=((f197 . -20) (f196 . -16) (f197 . -12) (f196 . -8) (f165 . 4) (f165 . -28) (f166 . -24) (f167 . -20) (f168 . -16) (f169 . -12) (f170 . -8) (f171 . -4) (f172 . 0))
# var=f197
    movl -20(%esp), %eax  # stack load f197
# end emit-variable-ref
    mov %eax, -40(%esp)  # arg f197
>>>>>>> fix-implicit-begins
    movl -32(%esp), %edi   # load new closure to %edi
    add $-24, %esp   # adjust base
    movl $8,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $24, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
# emit-tail-expr
# si=-24
<<<<<<< HEAD
# env=((f310983 . -20) (f310984 . -16) (f310983 . -12) (f310984 . -8) (f310952 . 4) (f310952 . -28) (f310953 . -24) (f310954 . -20) (f310955 . -16) (f310956 . -12) (f310957 . -8) (f310958 . -4) (f310959 . 0))
# expr=(begin ((primitive-ref write-char) #\) f310983))
# tail-begin (begin ((primitive-ref write-char) #\) f310983))
#   env=((f310983 . -20) (f310984 . -16) (f310983 . -12) (f310984 . -8) (f310952 . 4) (f310952 . -28) (f310953 . -24) (f310954 . -20) (f310955 . -16) (f310956 . -12) (f310957 . -8) (f310958 . -4) (f310959 . 0))
# emit-tail-expr
# si=-24
# env=((f310983 . -20) (f310984 . -16) (f310983 . -12) (f310984 . -8) (f310952 . 4) (f310952 . -28) (f310953 . -24) (f310954 . -20) (f310955 . -16) (f310956 . -12) (f310957 . -8) (f310958 . -4) (f310959 . 0))
# expr=((primitive-ref write-char) #\) f310983)
# emit-tail-funcall
#    si   =-24
#    env  = ((f310983 . -20) (f310984 . -16) (f310983 . -12) (f310984 . -8) (f310952 . 4) (f310952 . -28) (f310953 . -24) (f310954 . -20) (f310955 . -16) (f310956 . -12) (f310957 . -8) (f310958 . -4) (f310959 . 0))
#    expr = (funcall (primitive-ref write-char) #\) f310983)
=======
# env=((f197 . -20) (f196 . -16) (f197 . -12) (f196 . -8) (f165 . 4) (f165 . -28) (f166 . -24) (f167 . -20) (f168 . -16) (f169 . -12) (f170 . -8) (f171 . -4) (f172 . 0))
# expr=(begin ((primitive-ref write-char) #\) f197))
# tail-begin (begin ((primitive-ref write-char) #\) f197))
#   env=((f197 . -20) (f196 . -16) (f197 . -12) (f196 . -8) (f165 . 4) (f165 . -28) (f166 . -24) (f167 . -20) (f168 . -16) (f169 . -12) (f170 . -8) (f171 . -4) (f172 . 0))
# emit-tail-expr
# si=-24
# env=((f197 . -20) (f196 . -16) (f197 . -12) (f196 . -8) (f165 . 4) (f165 . -28) (f166 . -24) (f167 . -20) (f168 . -16) (f169 . -12) (f170 . -8) (f171 . -4) (f172 . 0))
# expr=((primitive-ref write-char) #\) f197)
# emit-tail-funcall
#    si   =-24
#    env  = ((f197 . -20) (f196 . -16) (f197 . -12) (f196 . -8) (f165 . 4) (f165 . -28) (f166 . -24) (f167 . -20) (f168 . -16) (f169 . -12) (f170 . -8) (f171 . -4) (f172 . 0))
#    expr = (funcall (primitive-ref write-char) #\) f197)
>>>>>>> fix-implicit-begins
# emit-expr (primitive-ref write-char)
    .extern mrc_write$mchar
    movl mrc_write$mchar,%eax
   movl %eax,  -24(%esp)  # stash funcall-oper in next closure slot
# emit-expr #\)
    movl $10511, %eax     # immed #\)
    mov %eax, -28(%esp)    # arg )
<<<<<<< HEAD
# emit-expr f310983
# emit-variable-ref
# env=((f310983 . -20) (f310984 . -16) (f310983 . -12) (f310984 . -8) (f310952 . 4) (f310952 . -28) (f310953 . -24) (f310954 . -20) (f310955 . -16) (f310956 . -12) (f310957 . -8) (f310958 . -4) (f310959 . 0))
# var=f310983
    movl -20(%esp), %eax  # stack load f310983
# end emit-variable-ref
    mov %eax, -32(%esp)    # arg f310983
=======
# emit-expr f197
# emit-variable-ref
# env=((f197 . -20) (f196 . -16) (f197 . -12) (f196 . -8) (f165 . 4) (f165 . -28) (f166 . -24) (f167 . -20) (f168 . -16) (f169 . -12) (f170 . -8) (f171 . -4) (f172 . 0))
# var=f197
    movl -20(%esp), %eax  # stack load f197
# end emit-variable-ref
    mov %eax, -32(%esp)    # arg f197
>>>>>>> fix-implicit-begins
    movl -24(%esp), %edi   # load new closure to %edi
# emit-shift-args:  size=3   si=-24  delta=20
    mov -24(%esp), %ebx  # shift frame cell
    mov %ebx, -4(%esp)  # down to base
# emit-shift-args:  size=2   si=-28  delta=20
    mov -28(%esp), %ebx  # shift frame cell
    mov %ebx, -8(%esp)  # down to base
# emit-shift-args:  size=1   si=-32  delta=20
    mov -32(%esp), %ebx  # shift frame cell
    mov %ebx, -12(%esp)  # down to base
# emit-shift-args:  size=0   si=-36  delta=20
    movl $8,%eax   # save arg count
    jmp *-2(%edi)  # tail-funcall
     ret   # return thru stack
    .align 4,0x90
_L_1302:
    movl -32(%esp), %ebx
    movl -36(%esp), %esi
    movl %eax, -1(%ebx,%esi)
<<<<<<< HEAD
# emit-expr (begin (vector-set! f310952 0 (closure (f310982 f310981) (f310952) (let ((f310982 f310982) (f310981 f310981)) (begin ((primitive-ref write) (car f310982) f310981) (if (null? (cdr f310982)) #t (if (pair? (cdr f310982)) (begin ((primitive-ref write-char) #\space f310981) ((vector-ref f310952 0) (cdr f310982) f310981)) (begin ((primitive-ref write-char) #\space f310981) ((primitive-ref write-char) #\. f310981) ((primitive-ref write-char) #\space f310981) ((primitive-ref write) (cdr f310982) f310981)))))))))
# emit-begin
#   expr=(begin (vector-set! f310952 0 (closure (f310982 f310981) (f310952) (let ((f310982 f310982) (f310981 f310981)) (begin ((primitive-ref write) (car f310982) f310981) (if (null? (cdr f310982)) #t (if (pair? (cdr f310982)) (begin ((primitive-ref write-char) #\space f310981) ((vector-ref f310952 0) (cdr f310982) f310981)) (begin ((primitive-ref write-char) #\space f310981) ((primitive-ref write-char) #\. f310981) ((primitive-ref write-char) #\space f310981) ((primitive-ref write) (cdr f310982) f310981)))))))))
#   env=((f310952 . -28) (f310953 . -24) (f310954 . -20) (f310955 . -16) (f310956 . -12) (f310957 . -8) (f310958 . -4) (f310959 . 0))
# emit-expr (vector-set! f310952 0 (closure (f310982 f310981) (f310952) (let ((f310982 f310982) (f310981 f310981)) (begin ((primitive-ref write) (car f310982) f310981) (if (null? (cdr f310982)) #t (if (pair? (cdr f310982)) (begin ((primitive-ref write-char) #\space f310981) ((vector-ref f310952 0) (cdr f310982) f310981)) (begin ((primitive-ref write-char) #\space f310981) ((primitive-ref write-char) #\. f310981) ((primitive-ref write-char) #\space f310981) ((primitive-ref write) (cdr f310982) f310981))))))))
# emit-expr f310952
=======
# emit-expr (begin (vector-set! f165 0 (closure (f194 f195) (f165) (let ((f194 f194) (f195 f195)) (begin ((primitive-ref write) (car f194) f195) (if (null? (cdr f194)) (begin #t) (if (pair? (cdr f194)) (begin (begin ((primitive-ref write-char) #\space f195) ((vector-ref f165 0) (cdr f194) f195))) (begin (begin ((primitive-ref write-char) #\space f195) ((primitive-ref write-char) #\. f195) ((primitive-ref write-char) #\space f195) ((primitive-ref write) (cdr f194) f195))))))))))
# emit-begin
#   expr=(begin (vector-set! f165 0 (closure (f194 f195) (f165) (let ((f194 f194) (f195 f195)) (begin ((primitive-ref write) (car f194) f195) (if (null? (cdr f194)) (begin #t) (if (pair? (cdr f194)) (begin (begin ((primitive-ref write-char) #\space f195) ((vector-ref f165 0) (cdr f194) f195))) (begin (begin ((primitive-ref write-char) #\space f195) ((primitive-ref write-char) #\. f195) ((primitive-ref write-char) #\space f195) ((primitive-ref write) (cdr f194) f195))))))))))
#   env=((f165 . -28) (f166 . -24) (f167 . -20) (f168 . -16) (f169 . -12) (f170 . -8) (f171 . -4) (f172 . 0))
# emit-expr (vector-set! f165 0 (closure (f194 f195) (f165) (let ((f194 f194) (f195 f195)) (begin ((primitive-ref write) (car f194) f195) (if (null? (cdr f194)) (begin #t) (if (pair? (cdr f194)) (begin (begin ((primitive-ref write-char) #\space f195) ((vector-ref f165 0) (cdr f194) f195))) (begin (begin ((primitive-ref write-char) #\space f195) ((primitive-ref write-char) #\. f195) ((primitive-ref write-char) #\space f195) ((primitive-ref write) (cdr f194) f195)))))))))
# emit-expr f165
>>>>>>> fix-implicit-begins
# emit-variable-ref
# env=((f165 . -28) (f166 . -24) (f167 . -20) (f168 . -16) (f169 . -12) (f170 . -8) (f171 . -4) (f172 . 0))
# var=f165
    movl -28(%esp), %eax  # stack load f165
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1310
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1310:
    movl %eax, -32(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1311"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1311:
# check bounds on vector index
    movl -32(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1313
    cmp  $0,%eax
    jge _L_1312
_L_1313:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1312:
    movl %eax, -36(%esp)
<<<<<<< HEAD
# emit-expr (closure (f310982 f310981) (f310952) (let ((f310982 f310982) (f310981 f310981)) (begin ((primitive-ref write) (car f310982) f310981) (if (null? (cdr f310982)) #t (if (pair? (cdr f310982)) (begin ((primitive-ref write-char) #\space f310981) ((vector-ref f310952 0) (cdr f310982) f310981)) (begin ((primitive-ref write-char) #\space f310981) ((primitive-ref write-char) #\. f310981) ((primitive-ref write-char) #\space f310981) ((primitive-ref write) (cdr f310982) f310981)))))))
# emit-closure
# si = -40
# env = ((f310952 . -28) (f310953 . -24) (f310954 . -20) (f310955 . -16) (f310956 . -12) (f310957 . -8) (f310958 . -4) (f310959 . 0))
# expr = (closure (f310982 f310981) (f310952) (let ((f310982 f310982) (f310981 f310981)) (begin ((primitive-ref write) (car f310982) f310981) (if (null? (cdr f310982)) #t (if (pair? (cdr f310982)) (begin ((primitive-ref write-char) #\space f310981) ((vector-ref f310952 0) (cdr f310982) f310981)) (begin ((primitive-ref write-char) #\space f310981) ((primitive-ref write-char) #\. f310981) ((primitive-ref write-char) #\space f310981) ((primitive-ref write) (cdr f310982) f310981)))))))
    movl $_L_1884913, 0(%ebp)  # closure label
=======
# emit-expr (closure (f194 f195) (f165) (let ((f194 f194) (f195 f195)) (begin ((primitive-ref write) (car f194) f195) (if (null? (cdr f194)) (begin #t) (if (pair? (cdr f194)) (begin (begin ((primitive-ref write-char) #\space f195) ((vector-ref f165 0) (cdr f194) f195))) (begin (begin ((primitive-ref write-char) #\space f195) ((primitive-ref write-char) #\. f195) ((primitive-ref write-char) #\space f195) ((primitive-ref write) (cdr f194) f195))))))))
# emit-closure
# si = -40
# env = ((f165 . -28) (f166 . -24) (f167 . -20) (f168 . -16) (f169 . -12) (f170 . -8) (f171 . -4) (f172 . 0))
# expr = (closure (f194 f195) (f165) (let ((f194 f194) (f195 f195)) (begin ((primitive-ref write) (car f194) f195) (if (null? (cdr f194)) (begin #t) (if (pair? (cdr f194)) (begin (begin ((primitive-ref write-char) #\space f195) ((vector-ref f165 0) (cdr f194) f195))) (begin (begin ((primitive-ref write-char) #\space f195) ((primitive-ref write-char) #\. f195) ((primitive-ref write-char) #\space f195) ((primitive-ref write) (cdr f194) f195))))))))
    movl $_L_1314, 0(%ebp)  # closure label
>>>>>>> fix-implicit-begins
# emit-variable-ref
# env=((f165 . -28) (f166 . -24) (f167 . -20) (f168 . -16) (f169 . -12) (f170 . -8) (f171 . -4) (f172 . 0))
# var=f165
    movl -28(%esp), %eax  # stack load f165
# end emit-variable-ref
   movl  %eax, 4(%ebp)  # f165
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $8, %ebp     # bump ebp
    jmp _L_1315            # jump around closure body
_L_1314:
# check argument count
    cmp $8,%eax
    je _L_1316
# invoke error handler eh_argcount
    .extern mrc_eh$uargcount
    movl mrc_eh$uargcount, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_1316:
# emit-tail-expr
# si=-16
<<<<<<< HEAD
# env=((f310981 . -12) (f310982 . -8) (f310952 . 4) (f310952 . -28) (f310953 . -24) (f310954 . -20) (f310955 . -16) (f310956 . -12) (f310957 . -8) (f310958 . -4) (f310959 . 0))
# expr=(let ((f310982 f310982) (f310981 f310981)) (begin ((primitive-ref write) (car f310982) f310981) (if (null? (cdr f310982)) #t (if (pair? (cdr f310982)) (begin ((primitive-ref write-char) #\space f310981) ((vector-ref f310952 0) (cdr f310982) f310981)) (begin ((primitive-ref write-char) #\space f310981) ((primitive-ref write-char) #\. f310981) ((primitive-ref write-char) #\space f310981) ((primitive-ref write) (cdr f310982) f310981))))))
# emit-tail-let
#  si   = -16
#  env  = ((f310981 . -12) (f310982 . -8) (f310952 . 4) (f310952 . -28) (f310953 . -24) (f310954 . -20) (f310955 . -16) (f310956 . -12) (f310957 . -8) (f310958 . -4) (f310959 . 0))
#  bindings = ((f310982 f310982) (f310981 f310981))
#  body = (begin ((primitive-ref write) (car f310982) f310981) (if (null? (cdr f310982)) #t (if (pair? (cdr f310982)) (begin ((primitive-ref write-char) #\space f310981) ((vector-ref f310952 0) (cdr f310982) f310981)) (begin ((primitive-ref write-char) #\space f310981) ((primitive-ref write-char) #\. f310981) ((primitive-ref write-char) #\space f310981) ((primitive-ref write) (cdr f310982) f310981)))))
# emit-expr f310982
# emit-variable-ref
# env=((f310981 . -12) (f310982 . -8) (f310952 . 4) (f310952 . -28) (f310953 . -24) (f310954 . -20) (f310955 . -16) (f310956 . -12) (f310957 . -8) (f310958 . -4) (f310959 . 0))
# var=f310982
    movl -8(%esp), %eax  # stack load f310982
# end emit-variable-ref
    movl %eax, -16(%esp)  # stack save
# emit-expr f310981
# emit-variable-ref
# env=((f310981 . -12) (f310982 . -8) (f310952 . 4) (f310952 . -28) (f310953 . -24) (f310954 . -20) (f310955 . -16) (f310956 . -12) (f310957 . -8) (f310958 . -4) (f310959 . 0))
# var=f310981
    movl -12(%esp), %eax  # stack load f310981
=======
# env=((f195 . -12) (f194 . -8) (f165 . 4) (f165 . -28) (f166 . -24) (f167 . -20) (f168 . -16) (f169 . -12) (f170 . -8) (f171 . -4) (f172 . 0))
# expr=(let ((f194 f194) (f195 f195)) (begin ((primitive-ref write) (car f194) f195) (if (null? (cdr f194)) (begin #t) (if (pair? (cdr f194)) (begin (begin ((primitive-ref write-char) #\space f195) ((vector-ref f165 0) (cdr f194) f195))) (begin (begin ((primitive-ref write-char) #\space f195) ((primitive-ref write-char) #\. f195) ((primitive-ref write-char) #\space f195) ((primitive-ref write) (cdr f194) f195)))))))
# emit-tail-let
#  si   = -16
#  env  = ((f195 . -12) (f194 . -8) (f165 . 4) (f165 . -28) (f166 . -24) (f167 . -20) (f168 . -16) (f169 . -12) (f170 . -8) (f171 . -4) (f172 . 0))
#  bindings = ((f194 f194) (f195 f195))
#  body = (begin ((primitive-ref write) (car f194) f195) (if (null? (cdr f194)) (begin #t) (if (pair? (cdr f194)) (begin (begin ((primitive-ref write-char) #\space f195) ((vector-ref f165 0) (cdr f194) f195))) (begin (begin ((primitive-ref write-char) #\space f195) ((primitive-ref write-char) #\. f195) ((primitive-ref write-char) #\space f195) ((primitive-ref write) (cdr f194) f195))))))
# emit-expr f194
# emit-variable-ref
# env=((f195 . -12) (f194 . -8) (f165 . 4) (f165 . -28) (f166 . -24) (f167 . -20) (f168 . -16) (f169 . -12) (f170 . -8) (f171 . -4) (f172 . 0))
# var=f194
    movl -8(%esp), %eax  # stack load f194
# end emit-variable-ref
    movl %eax, -16(%esp)  # stack save
# emit-expr f195
# emit-variable-ref
# env=((f195 . -12) (f194 . -8) (f165 . 4) (f165 . -28) (f166 . -24) (f167 . -20) (f168 . -16) (f169 . -12) (f170 . -8) (f171 . -4) (f172 . 0))
# var=f195
    movl -12(%esp), %eax  # stack load f195
>>>>>>> fix-implicit-begins
# end emit-variable-ref
    movl %eax, -20(%esp)  # stack save
# emit-tail-expr
# si=-24
<<<<<<< HEAD
# env=((f310981 . -20) (f310982 . -16) (f310981 . -12) (f310982 . -8) (f310952 . 4) (f310952 . -28) (f310953 . -24) (f310954 . -20) (f310955 . -16) (f310956 . -12) (f310957 . -8) (f310958 . -4) (f310959 . 0))
# expr=(begin ((primitive-ref write) (car f310982) f310981) (if (null? (cdr f310982)) #t (if (pair? (cdr f310982)) (begin ((primitive-ref write-char) #\space f310981) ((vector-ref f310952 0) (cdr f310982) f310981)) (begin ((primitive-ref write-char) #\space f310981) ((primitive-ref write-char) #\. f310981) ((primitive-ref write-char) #\space f310981) ((primitive-ref write) (cdr f310982) f310981)))))
# tail-begin (begin ((primitive-ref write) (car f310982) f310981) (if (null? (cdr f310982)) #t (if (pair? (cdr f310982)) (begin ((primitive-ref write-char) #\space f310981) ((vector-ref f310952 0) (cdr f310982) f310981)) (begin ((primitive-ref write-char) #\space f310981) ((primitive-ref write-char) #\. f310981) ((primitive-ref write-char) #\space f310981) ((primitive-ref write) (cdr f310982) f310981)))))
#   env=((f310981 . -20) (f310982 . -16) (f310981 . -12) (f310982 . -8) (f310952 . 4) (f310952 . -28) (f310953 . -24) (f310954 . -20) (f310955 . -16) (f310956 . -12) (f310957 . -8) (f310958 . -4) (f310959 . 0))
# emit-expr ((primitive-ref write) (car f310982) f310981)
# funcall
#    si   =-24
#    env  = ((f310981 . -20) (f310982 . -16) (f310981 . -12) (f310982 . -8) (f310952 . 4) (f310952 . -28) (f310953 . -24) (f310954 . -20) (f310955 . -16) (f310956 . -12) (f310957 . -8) (f310958 . -4) (f310959 . 0))
#    expr = (funcall (primitive-ref write) (car f310982) f310981)
=======
# env=((f195 . -20) (f194 . -16) (f195 . -12) (f194 . -8) (f165 . 4) (f165 . -28) (f166 . -24) (f167 . -20) (f168 . -16) (f169 . -12) (f170 . -8) (f171 . -4) (f172 . 0))
# expr=(begin ((primitive-ref write) (car f194) f195) (if (null? (cdr f194)) (begin #t) (if (pair? (cdr f194)) (begin (begin ((primitive-ref write-char) #\space f195) ((vector-ref f165 0) (cdr f194) f195))) (begin (begin ((primitive-ref write-char) #\space f195) ((primitive-ref write-char) #\. f195) ((primitive-ref write-char) #\space f195) ((primitive-ref write) (cdr f194) f195))))))
# tail-begin (begin ((primitive-ref write) (car f194) f195) (if (null? (cdr f194)) (begin #t) (if (pair? (cdr f194)) (begin (begin ((primitive-ref write-char) #\space f195) ((vector-ref f165 0) (cdr f194) f195))) (begin (begin ((primitive-ref write-char) #\space f195) ((primitive-ref write-char) #\. f195) ((primitive-ref write-char) #\space f195) ((primitive-ref write) (cdr f194) f195))))))
#   env=((f195 . -20) (f194 . -16) (f195 . -12) (f194 . -8) (f165 . 4) (f165 . -28) (f166 . -24) (f167 . -20) (f168 . -16) (f169 . -12) (f170 . -8) (f171 . -4) (f172 . 0))
# emit-expr ((primitive-ref write) (car f194) f195)
# funcall
#    si   =-24
#    env  = ((f195 . -20) (f194 . -16) (f195 . -12) (f194 . -8) (f165 . 4) (f165 . -28) (f166 . -24) (f167 . -20) (f168 . -16) (f169 . -12) (f170 . -8) (f171 . -4) (f172 . 0))
#    expr = (funcall (primitive-ref write) (car f194) f195)
>>>>>>> fix-implicit-begins
# emit-expr (primitive-ref write)
    .extern mrc_write
    movl mrc_write,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1317"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1317":
   movl %eax,  -32(%esp)  # stash funcall-oper in closure slot
<<<<<<< HEAD
# emit-expr (car f310982)
# emit-expr f310982
# emit-variable-ref
# env=((f310981 . -20) (f310982 . -16) (f310981 . -12) (f310982 . -8) (f310952 . 4) (f310952 . -28) (f310953 . -24) (f310954 . -20) (f310955 . -16) (f310956 . -12) (f310957 . -8) (f310958 . -4) (f310959 . 0))
# var=f310982
    movl -16(%esp), %eax  # stack load f310982
=======
# emit-expr (car f194)
# emit-expr f194
# emit-variable-ref
# env=((f195 . -20) (f194 . -16) (f195 . -12) (f194 . -8) (f165 . 4) (f165 . -28) (f166 . -24) (f167 . -20) (f168 . -16) (f169 . -12) (f170 . -8) (f171 . -4) (f172 . 0))
# var=f194
    movl -16(%esp), %eax  # stack load f194
>>>>>>> fix-implicit-begins
# end emit-variable-ref
# check the argument is a pair
    movl %eax,%ebx
    and $7, %bl
    cmp $1, %bl
    je _L_1318
# invoke error handler eh_pair
    .extern mrc_eh$upair
    movl mrc_eh$upair, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $116,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1318:
    movl -1(%eax), %eax
<<<<<<< HEAD
    mov %eax, -36(%esp)  # arg (car f310982)
# emit-expr f310981
# emit-variable-ref
# env=((f310981 . -20) (f310982 . -16) (f310981 . -12) (f310982 . -8) (f310952 . 4) (f310952 . -28) (f310953 . -24) (f310954 . -20) (f310955 . -16) (f310956 . -12) (f310957 . -8) (f310958 . -4) (f310959 . 0))
# var=f310981
    movl -20(%esp), %eax  # stack load f310981
# end emit-variable-ref
    mov %eax, -40(%esp)  # arg f310981
=======
    mov %eax, -36(%esp)  # arg (car f194)
# emit-expr f195
# emit-variable-ref
# env=((f195 . -20) (f194 . -16) (f195 . -12) (f194 . -8) (f165 . 4) (f165 . -28) (f166 . -24) (f167 . -20) (f168 . -16) (f169 . -12) (f170 . -8) (f171 . -4) (f172 . 0))
# var=f195
    movl -20(%esp), %eax  # stack load f195
# end emit-variable-ref
    mov %eax, -40(%esp)  # arg f195
>>>>>>> fix-implicit-begins
    movl -32(%esp), %edi   # load new closure to %edi
    add $-24, %esp   # adjust base
    movl $8,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $24, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
# emit-tail-expr
# si=-24
<<<<<<< HEAD
# env=((f310981 . -20) (f310982 . -16) (f310981 . -12) (f310982 . -8) (f310952 . 4) (f310952 . -28) (f310953 . -24) (f310954 . -20) (f310955 . -16) (f310956 . -12) (f310957 . -8) (f310958 . -4) (f310959 . 0))
# expr=(begin (if (null? (cdr f310982)) #t (if (pair? (cdr f310982)) (begin ((primitive-ref write-char) #\space f310981) ((vector-ref f310952 0) (cdr f310982) f310981)) (begin ((primitive-ref write-char) #\space f310981) ((primitive-ref write-char) #\. f310981) ((primitive-ref write-char) #\space f310981) ((primitive-ref write) (cdr f310982) f310981)))))
# tail-begin (begin (if (null? (cdr f310982)) #t (if (pair? (cdr f310982)) (begin ((primitive-ref write-char) #\space f310981) ((vector-ref f310952 0) (cdr f310982) f310981)) (begin ((primitive-ref write-char) #\space f310981) ((primitive-ref write-char) #\. f310981) ((primitive-ref write-char) #\space f310981) ((primitive-ref write) (cdr f310982) f310981)))))
#   env=((f310981 . -20) (f310982 . -16) (f310981 . -12) (f310982 . -8) (f310952 . 4) (f310952 . -28) (f310953 . -24) (f310954 . -20) (f310955 . -16) (f310956 . -12) (f310957 . -8) (f310958 . -4) (f310959 . 0))
# emit-tail-expr
# si=-24
# env=((f310981 . -20) (f310982 . -16) (f310981 . -12) (f310982 . -8) (f310952 . 4) (f310952 . -28) (f310953 . -24) (f310954 . -20) (f310955 . -16) (f310956 . -12) (f310957 . -8) (f310958 . -4) (f310959 . 0))
# expr=(if (null? (cdr f310982)) #t (if (pair? (cdr f310982)) (begin ((primitive-ref write-char) #\space f310981) ((vector-ref f310952 0) (cdr f310982) f310981)) (begin ((primitive-ref write-char) #\space f310981) ((primitive-ref write-char) #\. f310981) ((primitive-ref write-char) #\space f310981) ((primitive-ref write) (cdr f310982) f310981))))
# emit-expr (null? (cdr f310982))
# emit-expr (cdr f310982)
# emit-expr f310982
# emit-variable-ref
# env=((f310981 . -20) (f310982 . -16) (f310981 . -12) (f310982 . -8) (f310952 . 4) (f310952 . -28) (f310953 . -24) (f310954 . -20) (f310955 . -16) (f310956 . -12) (f310957 . -8) (f310958 . -4) (f310959 . 0))
# var=f310982
    movl -16(%esp), %eax  # stack load f310982
=======
# env=((f195 . -20) (f194 . -16) (f195 . -12) (f194 . -8) (f165 . 4) (f165 . -28) (f166 . -24) (f167 . -20) (f168 . -16) (f169 . -12) (f170 . -8) (f171 . -4) (f172 . 0))
# expr=(begin (if (null? (cdr f194)) (begin #t) (if (pair? (cdr f194)) (begin (begin ((primitive-ref write-char) #\space f195) ((vector-ref f165 0) (cdr f194) f195))) (begin (begin ((primitive-ref write-char) #\space f195) ((primitive-ref write-char) #\. f195) ((primitive-ref write-char) #\space f195) ((primitive-ref write) (cdr f194) f195))))))
# tail-begin (begin (if (null? (cdr f194)) (begin #t) (if (pair? (cdr f194)) (begin (begin ((primitive-ref write-char) #\space f195) ((vector-ref f165 0) (cdr f194) f195))) (begin (begin ((primitive-ref write-char) #\space f195) ((primitive-ref write-char) #\. f195) ((primitive-ref write-char) #\space f195) ((primitive-ref write) (cdr f194) f195))))))
#   env=((f195 . -20) (f194 . -16) (f195 . -12) (f194 . -8) (f165 . 4) (f165 . -28) (f166 . -24) (f167 . -20) (f168 . -16) (f169 . -12) (f170 . -8) (f171 . -4) (f172 . 0))
# emit-tail-expr
# si=-24
# env=((f195 . -20) (f194 . -16) (f195 . -12) (f194 . -8) (f165 . 4) (f165 . -28) (f166 . -24) (f167 . -20) (f168 . -16) (f169 . -12) (f170 . -8) (f171 . -4) (f172 . 0))
# expr=(if (null? (cdr f194)) (begin #t) (if (pair? (cdr f194)) (begin (begin ((primitive-ref write-char) #\space f195) ((vector-ref f165 0) (cdr f194) f195))) (begin (begin ((primitive-ref write-char) #\space f195) ((primitive-ref write-char) #\. f195) ((primitive-ref write-char) #\space f195) ((primitive-ref write) (cdr f194) f195)))))
# emit-expr (null? (cdr f194))
# emit-expr (cdr f194)
# emit-expr f194
# emit-variable-ref
# env=((f195 . -20) (f194 . -16) (f195 . -12) (f194 . -8) (f165 . 4) (f165 . -28) (f166 . -24) (f167 . -20) (f168 . -16) (f169 . -12) (f170 . -8) (f171 . -4) (f172 . 0))
# var=f194
    movl -16(%esp), %eax  # stack load f194
>>>>>>> fix-implicit-begins
# end emit-variable-ref
# check the argument is a pair
    movl %eax,%ebx
    and $7, %bl
    cmp $1, %bl
    je _L_1321
# invoke error handler eh_pair
    .extern mrc_eh$upair
    movl mrc_eh$upair, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $120,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1321:
    movl 3(%eax), %eax
    cmp $63, %eax
    mov $0, %eax
    sete %al
    movzbl %al, %eax
    sal $6, %al
    or $47, %al
    cmp $47, %al
    je _L_1319
# emit-tail-expr
# si=-24
<<<<<<< HEAD
# env=((f310981 . -20) (f310982 . -16) (f310981 . -12) (f310982 . -8) (f310952 . 4) (f310952 . -28) (f310953 . -24) (f310954 . -20) (f310955 . -16) (f310956 . -12) (f310957 . -8) (f310958 . -4) (f310959 . 0))
=======
# env=((f195 . -20) (f194 . -16) (f195 . -12) (f194 . -8) (f165 . 4) (f165 . -28) (f166 . -24) (f167 . -20) (f168 . -16) (f169 . -12) (f170 . -8) (f171 . -4) (f172 . 0))
# expr=(begin #t)
# tail-begin (begin #t)
#   env=((f195 . -20) (f194 . -16) (f195 . -12) (f194 . -8) (f165 . 4) (f165 . -28) (f166 . -24) (f167 . -20) (f168 . -16) (f169 . -12) (f170 . -8) (f171 . -4) (f172 . 0))
# emit-tail-expr
# si=-24
# env=((f195 . -20) (f194 . -16) (f195 . -12) (f194 . -8) (f165 . 4) (f165 . -28) (f166 . -24) (f167 . -20) (f168 . -16) (f169 . -12) (f170 . -8) (f171 . -4) (f172 . 0))
>>>>>>> fix-implicit-begins
# expr=#t
    movl $111, %eax     # immed #t
    ret                  # immediate tail return
     ret   # return thru stack
    jmp _L_1320
_L_1319:
# emit-tail-expr
# si=-24
<<<<<<< HEAD
# env=((f310981 . -20) (f310982 . -16) (f310981 . -12) (f310982 . -8) (f310952 . 4) (f310952 . -28) (f310953 . -24) (f310954 . -20) (f310955 . -16) (f310956 . -12) (f310957 . -8) (f310958 . -4) (f310959 . 0))
# expr=(if (pair? (cdr f310982)) (begin ((primitive-ref write-char) #\space f310981) ((vector-ref f310952 0) (cdr f310982) f310981)) (begin ((primitive-ref write-char) #\space f310981) ((primitive-ref write-char) #\. f310981) ((primitive-ref write-char) #\space f310981) ((primitive-ref write) (cdr f310982) f310981)))
# emit-expr (pair? (cdr f310982))
# emit-expr (cdr f310982)
# emit-expr f310982
# emit-variable-ref
# env=((f310981 . -20) (f310982 . -16) (f310981 . -12) (f310982 . -8) (f310952 . 4) (f310952 . -28) (f310953 . -24) (f310954 . -20) (f310955 . -16) (f310956 . -12) (f310957 . -8) (f310958 . -4) (f310959 . 0))
# var=f310982
    movl -16(%esp), %eax  # stack load f310982
=======
# env=((f195 . -20) (f194 . -16) (f195 . -12) (f194 . -8) (f165 . 4) (f165 . -28) (f166 . -24) (f167 . -20) (f168 . -16) (f169 . -12) (f170 . -8) (f171 . -4) (f172 . 0))
# expr=(if (pair? (cdr f194)) (begin (begin ((primitive-ref write-char) #\space f195) ((vector-ref f165 0) (cdr f194) f195))) (begin (begin ((primitive-ref write-char) #\space f195) ((primitive-ref write-char) #\. f195) ((primitive-ref write-char) #\space f195) ((primitive-ref write) (cdr f194) f195))))
# emit-expr (pair? (cdr f194))
# emit-expr (cdr f194)
# emit-expr f194
# emit-variable-ref
# env=((f195 . -20) (f194 . -16) (f195 . -12) (f194 . -8) (f165 . 4) (f165 . -28) (f166 . -24) (f167 . -20) (f168 . -16) (f169 . -12) (f170 . -8) (f171 . -4) (f172 . 0))
# var=f194
    movl -16(%esp), %eax  # stack load f194
>>>>>>> fix-implicit-begins
# end emit-variable-ref
# check the argument is a pair
    movl %eax,%ebx
    and $7, %bl
    cmp $1, %bl
    je _L_1324
# invoke error handler eh_pair
    .extern mrc_eh$upair
    movl mrc_eh$upair, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $120,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1324:
    movl 3(%eax), %eax
    and $7, %al
    cmp $1, %al
    sete %al
    movzbl %al, %eax
    sal $6, %al
    or $47, %al
    cmp $47, %al
    je _L_1322
# emit-tail-expr
# si=-24
<<<<<<< HEAD
# env=((f310981 . -20) (f310982 . -16) (f310981 . -12) (f310982 . -8) (f310952 . 4) (f310952 . -28) (f310953 . -24) (f310954 . -20) (f310955 . -16) (f310956 . -12) (f310957 . -8) (f310958 . -4) (f310959 . 0))
# expr=(begin ((primitive-ref write-char) #\space f310981) ((vector-ref f310952 0) (cdr f310982) f310981))
# tail-begin (begin ((primitive-ref write-char) #\space f310981) ((vector-ref f310952 0) (cdr f310982) f310981))
#   env=((f310981 . -20) (f310982 . -16) (f310981 . -12) (f310982 . -8) (f310952 . 4) (f310952 . -28) (f310953 . -24) (f310954 . -20) (f310955 . -16) (f310956 . -12) (f310957 . -8) (f310958 . -4) (f310959 . 0))
# emit-expr ((primitive-ref write-char) #\space f310981)
# funcall
#    si   =-24
#    env  = ((f310981 . -20) (f310982 . -16) (f310981 . -12) (f310982 . -8) (f310952 . 4) (f310952 . -28) (f310953 . -24) (f310954 . -20) (f310955 . -16) (f310956 . -12) (f310957 . -8) (f310958 . -4) (f310959 . 0))
#    expr = (funcall (primitive-ref write-char) #\space f310981)
=======
# env=((f195 . -20) (f194 . -16) (f195 . -12) (f194 . -8) (f165 . 4) (f165 . -28) (f166 . -24) (f167 . -20) (f168 . -16) (f169 . -12) (f170 . -8) (f171 . -4) (f172 . 0))
# expr=(begin (begin ((primitive-ref write-char) #\space f195) ((vector-ref f165 0) (cdr f194) f195)))
# tail-begin (begin (begin ((primitive-ref write-char) #\space f195) ((vector-ref f165 0) (cdr f194) f195)))
#   env=((f195 . -20) (f194 . -16) (f195 . -12) (f194 . -8) (f165 . 4) (f165 . -28) (f166 . -24) (f167 . -20) (f168 . -16) (f169 . -12) (f170 . -8) (f171 . -4) (f172 . 0))
# emit-tail-expr
# si=-24
# env=((f195 . -20) (f194 . -16) (f195 . -12) (f194 . -8) (f165 . 4) (f165 . -28) (f166 . -24) (f167 . -20) (f168 . -16) (f169 . -12) (f170 . -8) (f171 . -4) (f172 . 0))
# expr=(begin ((primitive-ref write-char) #\space f195) ((vector-ref f165 0) (cdr f194) f195))
# tail-begin (begin ((primitive-ref write-char) #\space f195) ((vector-ref f165 0) (cdr f194) f195))
#   env=((f195 . -20) (f194 . -16) (f195 . -12) (f194 . -8) (f165 . 4) (f165 . -28) (f166 . -24) (f167 . -20) (f168 . -16) (f169 . -12) (f170 . -8) (f171 . -4) (f172 . 0))
# emit-expr ((primitive-ref write-char) #\space f195)
# funcall
#    si   =-24
#    env  = ((f195 . -20) (f194 . -16) (f195 . -12) (f194 . -8) (f165 . 4) (f165 . -28) (f166 . -24) (f167 . -20) (f168 . -16) (f169 . -12) (f170 . -8) (f171 . -4) (f172 . 0))
#    expr = (funcall (primitive-ref write-char) #\space f195)
>>>>>>> fix-implicit-begins
# emit-expr (primitive-ref write-char)
    .extern mrc_write$mchar
    movl mrc_write$mchar,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1325"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1325":
   movl %eax,  -32(%esp)  # stash funcall-oper in closure slot
# emit-expr #\space
    movl $8207, %eax     # immed #\space
    mov %eax, -36(%esp)  # arg  
<<<<<<< HEAD
# emit-expr f310981
# emit-variable-ref
# env=((f310981 . -20) (f310982 . -16) (f310981 . -12) (f310982 . -8) (f310952 . 4) (f310952 . -28) (f310953 . -24) (f310954 . -20) (f310955 . -16) (f310956 . -12) (f310957 . -8) (f310958 . -4) (f310959 . 0))
# var=f310981
    movl -20(%esp), %eax  # stack load f310981
# end emit-variable-ref
    mov %eax, -40(%esp)  # arg f310981
=======
# emit-expr f195
# emit-variable-ref
# env=((f195 . -20) (f194 . -16) (f195 . -12) (f194 . -8) (f165 . 4) (f165 . -28) (f166 . -24) (f167 . -20) (f168 . -16) (f169 . -12) (f170 . -8) (f171 . -4) (f172 . 0))
# var=f195
    movl -20(%esp), %eax  # stack load f195
# end emit-variable-ref
    mov %eax, -40(%esp)  # arg f195
>>>>>>> fix-implicit-begins
    movl -32(%esp), %edi   # load new closure to %edi
    add $-24, %esp   # adjust base
    movl $8,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $24, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
# emit-tail-expr
# si=-24
<<<<<<< HEAD
# env=((f310981 . -20) (f310982 . -16) (f310981 . -12) (f310982 . -8) (f310952 . 4) (f310952 . -28) (f310953 . -24) (f310954 . -20) (f310955 . -16) (f310956 . -12) (f310957 . -8) (f310958 . -4) (f310959 . 0))
# expr=(begin ((vector-ref f310952 0) (cdr f310982) f310981))
# tail-begin (begin ((vector-ref f310952 0) (cdr f310982) f310981))
#   env=((f310981 . -20) (f310982 . -16) (f310981 . -12) (f310982 . -8) (f310952 . 4) (f310952 . -28) (f310953 . -24) (f310954 . -20) (f310955 . -16) (f310956 . -12) (f310957 . -8) (f310958 . -4) (f310959 . 0))
# emit-tail-expr
# si=-24
# env=((f310981 . -20) (f310982 . -16) (f310981 . -12) (f310982 . -8) (f310952 . 4) (f310952 . -28) (f310953 . -24) (f310954 . -20) (f310955 . -16) (f310956 . -12) (f310957 . -8) (f310958 . -4) (f310959 . 0))
# expr=((vector-ref f310952 0) (cdr f310982) f310981)
# emit-tail-funcall
#    si   =-24
#    env  = ((f310981 . -20) (f310982 . -16) (f310981 . -12) (f310982 . -8) (f310952 . 4) (f310952 . -28) (f310953 . -24) (f310954 . -20) (f310955 . -16) (f310956 . -12) (f310957 . -8) (f310958 . -4) (f310959 . 0))
#    expr = (funcall (vector-ref f310952 0) (cdr f310982) f310981)
# emit-expr (vector-ref f310952 0)
# emit-expr f310952
# emit-variable-ref
# env=((f310981 . -20) (f310982 . -16) (f310981 . -12) (f310982 . -8) (f310952 . 4) (f310952 . -28) (f310953 . -24) (f310954 . -20) (f310955 . -16) (f310956 . -12) (f310957 . -8) (f310958 . -4) (f310959 . 0))
# var=f310952
    movl 2(%edi), %eax  # frame load f310952
=======
# env=((f195 . -20) (f194 . -16) (f195 . -12) (f194 . -8) (f165 . 4) (f165 . -28) (f166 . -24) (f167 . -20) (f168 . -16) (f169 . -12) (f170 . -8) (f171 . -4) (f172 . 0))
# expr=(begin ((vector-ref f165 0) (cdr f194) f195))
# tail-begin (begin ((vector-ref f165 0) (cdr f194) f195))
#   env=((f195 . -20) (f194 . -16) (f195 . -12) (f194 . -8) (f165 . 4) (f165 . -28) (f166 . -24) (f167 . -20) (f168 . -16) (f169 . -12) (f170 . -8) (f171 . -4) (f172 . 0))
# emit-tail-expr
# si=-24
# env=((f195 . -20) (f194 . -16) (f195 . -12) (f194 . -8) (f165 . 4) (f165 . -28) (f166 . -24) (f167 . -20) (f168 . -16) (f169 . -12) (f170 . -8) (f171 . -4) (f172 . 0))
# expr=((vector-ref f165 0) (cdr f194) f195)
# emit-tail-funcall
#    si   =-24
#    env  = ((f195 . -20) (f194 . -16) (f195 . -12) (f194 . -8) (f165 . 4) (f165 . -28) (f166 . -24) (f167 . -20) (f168 . -16) (f169 . -12) (f170 . -8) (f171 . -4) (f172 . 0))
#    expr = (funcall (vector-ref f165 0) (cdr f194) f195)
# emit-expr (vector-ref f165 0)
# emit-expr f165
# emit-variable-ref
# env=((f195 . -20) (f194 . -16) (f195 . -12) (f194 . -8) (f165 . 4) (f165 . -28) (f166 . -24) (f167 . -20) (f168 . -16) (f169 . -12) (f170 . -8) (f171 . -4) (f172 . 0))
# var=f165
    movl 2(%edi), %eax  # frame load f165
>>>>>>> fix-implicit-begins
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1326
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1326:
    movl %eax, -24(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1327"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1327:
# check bounds on vector index
    movl -24(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1329
    cmp  $0,%eax
    jge _L_1328
_L_1329:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1328:
    movl -24(%esp), %esi
    movl -1(%eax,%esi), %eax
   movl %eax,  -24(%esp)  # stash funcall-oper in next closure slot
<<<<<<< HEAD
# emit-expr (cdr f310982)
# emit-expr f310982
# emit-variable-ref
# env=((f310981 . -20) (f310982 . -16) (f310981 . -12) (f310982 . -8) (f310952 . 4) (f310952 . -28) (f310953 . -24) (f310954 . -20) (f310955 . -16) (f310956 . -12) (f310957 . -8) (f310958 . -4) (f310959 . 0))
# var=f310982
    movl -16(%esp), %eax  # stack load f310982
=======
# emit-expr (cdr f194)
# emit-expr f194
# emit-variable-ref
# env=((f195 . -20) (f194 . -16) (f195 . -12) (f194 . -8) (f165 . 4) (f165 . -28) (f166 . -24) (f167 . -20) (f168 . -16) (f169 . -12) (f170 . -8) (f171 . -4) (f172 . 0))
# var=f194
    movl -16(%esp), %eax  # stack load f194
>>>>>>> fix-implicit-begins
# end emit-variable-ref
# check the argument is a pair
    movl %eax,%ebx
    and $7, %bl
    cmp $1, %bl
    je _L_1330
# invoke error handler eh_pair
    .extern mrc_eh$upair
    movl mrc_eh$upair, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $120,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1330:
    movl 3(%eax), %eax
<<<<<<< HEAD
    mov %eax, -28(%esp)    # arg (cdr f310982)
# emit-expr f310981
# emit-variable-ref
# env=((f310981 . -20) (f310982 . -16) (f310981 . -12) (f310982 . -8) (f310952 . 4) (f310952 . -28) (f310953 . -24) (f310954 . -20) (f310955 . -16) (f310956 . -12) (f310957 . -8) (f310958 . -4) (f310959 . 0))
# var=f310981
    movl -20(%esp), %eax  # stack load f310981
# end emit-variable-ref
    mov %eax, -32(%esp)    # arg f310981
=======
    mov %eax, -28(%esp)    # arg (cdr f194)
# emit-expr f195
# emit-variable-ref
# env=((f195 . -20) (f194 . -16) (f195 . -12) (f194 . -8) (f165 . 4) (f165 . -28) (f166 . -24) (f167 . -20) (f168 . -16) (f169 . -12) (f170 . -8) (f171 . -4) (f172 . 0))
# var=f195
    movl -20(%esp), %eax  # stack load f195
# end emit-variable-ref
    mov %eax, -32(%esp)    # arg f195
>>>>>>> fix-implicit-begins
    movl -24(%esp), %edi   # load new closure to %edi
# emit-shift-args:  size=3   si=-24  delta=20
    mov -24(%esp), %ebx  # shift frame cell
    mov %ebx, -4(%esp)  # down to base
# emit-shift-args:  size=2   si=-28  delta=20
    mov -28(%esp), %ebx  # shift frame cell
    mov %ebx, -8(%esp)  # down to base
# emit-shift-args:  size=1   si=-32  delta=20
    mov -32(%esp), %ebx  # shift frame cell
    mov %ebx, -12(%esp)  # down to base
# emit-shift-args:  size=0   si=-36  delta=20
    movl $8,%eax   # save arg count
    jmp *-2(%edi)  # tail-funcall
     ret   # return thru stack
     ret   # return thru stack
    jmp _L_1323
_L_1322:
# emit-tail-expr
# si=-24
# env=((f195 . -20) (f194 . -16) (f195 . -12) (f194 . -8) (f165 . 4) (f165 . -28) (f166 . -24) (f167 . -20) (f168 . -16) (f169 . -12) (f170 . -8) (f171 . -4) (f172 . 0))
# expr=(begin (begin ((primitive-ref write-char) #\space f195) ((primitive-ref write-char) #\. f195) ((primitive-ref write-char) #\space f195) ((primitive-ref write) (cdr f194) f195)))
# tail-begin (begin (begin ((primitive-ref write-char) #\space f195) ((primitive-ref write-char) #\. f195) ((primitive-ref write-char) #\space f195) ((primitive-ref write) (cdr f194) f195)))
#   env=((f195 . -20) (f194 . -16) (f195 . -12) (f194 . -8) (f165 . 4) (f165 . -28) (f166 . -24) (f167 . -20) (f168 . -16) (f169 . -12) (f170 . -8) (f171 . -4) (f172 . 0))
# emit-tail-expr
# si=-24
<<<<<<< HEAD
# env=((f310981 . -20) (f310982 . -16) (f310981 . -12) (f310982 . -8) (f310952 . 4) (f310952 . -28) (f310953 . -24) (f310954 . -20) (f310955 . -16) (f310956 . -12) (f310957 . -8) (f310958 . -4) (f310959 . 0))
# expr=(begin ((primitive-ref write-char) #\space f310981) ((primitive-ref write-char) #\. f310981) ((primitive-ref write-char) #\space f310981) ((primitive-ref write) (cdr f310982) f310981))
# tail-begin (begin ((primitive-ref write-char) #\space f310981) ((primitive-ref write-char) #\. f310981) ((primitive-ref write-char) #\space f310981) ((primitive-ref write) (cdr f310982) f310981))
#   env=((f310981 . -20) (f310982 . -16) (f310981 . -12) (f310982 . -8) (f310952 . 4) (f310952 . -28) (f310953 . -24) (f310954 . -20) (f310955 . -16) (f310956 . -12) (f310957 . -8) (f310958 . -4) (f310959 . 0))
# emit-expr ((primitive-ref write-char) #\space f310981)
# funcall
#    si   =-24
#    env  = ((f310981 . -20) (f310982 . -16) (f310981 . -12) (f310982 . -8) (f310952 . 4) (f310952 . -28) (f310953 . -24) (f310954 . -20) (f310955 . -16) (f310956 . -12) (f310957 . -8) (f310958 . -4) (f310959 . 0))
#    expr = (funcall (primitive-ref write-char) #\space f310981)
=======
# env=((f195 . -20) (f194 . -16) (f195 . -12) (f194 . -8) (f165 . 4) (f165 . -28) (f166 . -24) (f167 . -20) (f168 . -16) (f169 . -12) (f170 . -8) (f171 . -4) (f172 . 0))
# expr=(begin ((primitive-ref write-char) #\space f195) ((primitive-ref write-char) #\. f195) ((primitive-ref write-char) #\space f195) ((primitive-ref write) (cdr f194) f195))
# tail-begin (begin ((primitive-ref write-char) #\space f195) ((primitive-ref write-char) #\. f195) ((primitive-ref write-char) #\space f195) ((primitive-ref write) (cdr f194) f195))
#   env=((f195 . -20) (f194 . -16) (f195 . -12) (f194 . -8) (f165 . 4) (f165 . -28) (f166 . -24) (f167 . -20) (f168 . -16) (f169 . -12) (f170 . -8) (f171 . -4) (f172 . 0))
# emit-expr ((primitive-ref write-char) #\space f195)
# funcall
#    si   =-24
#    env  = ((f195 . -20) (f194 . -16) (f195 . -12) (f194 . -8) (f165 . 4) (f165 . -28) (f166 . -24) (f167 . -20) (f168 . -16) (f169 . -12) (f170 . -8) (f171 . -4) (f172 . 0))
#    expr = (funcall (primitive-ref write-char) #\space f195)
>>>>>>> fix-implicit-begins
# emit-expr (primitive-ref write-char)
    .extern mrc_write$mchar
    movl mrc_write$mchar,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1331"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1331":
   movl %eax,  -32(%esp)  # stash funcall-oper in closure slot
# emit-expr #\space
    movl $8207, %eax     # immed #\space
    mov %eax, -36(%esp)  # arg  
<<<<<<< HEAD
# emit-expr f310981
# emit-variable-ref
# env=((f310981 . -20) (f310982 . -16) (f310981 . -12) (f310982 . -8) (f310952 . 4) (f310952 . -28) (f310953 . -24) (f310954 . -20) (f310955 . -16) (f310956 . -12) (f310957 . -8) (f310958 . -4) (f310959 . 0))
# var=f310981
    movl -20(%esp), %eax  # stack load f310981
# end emit-variable-ref
    mov %eax, -40(%esp)  # arg f310981
=======
# emit-expr f195
# emit-variable-ref
# env=((f195 . -20) (f194 . -16) (f195 . -12) (f194 . -8) (f165 . 4) (f165 . -28) (f166 . -24) (f167 . -20) (f168 . -16) (f169 . -12) (f170 . -8) (f171 . -4) (f172 . 0))
# var=f195
    movl -20(%esp), %eax  # stack load f195
# end emit-variable-ref
    mov %eax, -40(%esp)  # arg f195
>>>>>>> fix-implicit-begins
    movl -32(%esp), %edi   # load new closure to %edi
    add $-24, %esp   # adjust base
    movl $8,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $24, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
# emit-tail-expr
# si=-24
<<<<<<< HEAD
# env=((f310981 . -20) (f310982 . -16) (f310981 . -12) (f310982 . -8) (f310952 . 4) (f310952 . -28) (f310953 . -24) (f310954 . -20) (f310955 . -16) (f310956 . -12) (f310957 . -8) (f310958 . -4) (f310959 . 0))
# expr=(begin ((primitive-ref write-char) #\. f310981) ((primitive-ref write-char) #\space f310981) ((primitive-ref write) (cdr f310982) f310981))
# tail-begin (begin ((primitive-ref write-char) #\. f310981) ((primitive-ref write-char) #\space f310981) ((primitive-ref write) (cdr f310982) f310981))
#   env=((f310981 . -20) (f310982 . -16) (f310981 . -12) (f310982 . -8) (f310952 . 4) (f310952 . -28) (f310953 . -24) (f310954 . -20) (f310955 . -16) (f310956 . -12) (f310957 . -8) (f310958 . -4) (f310959 . 0))
# emit-expr ((primitive-ref write-char) #\. f310981)
# funcall
#    si   =-24
#    env  = ((f310981 . -20) (f310982 . -16) (f310981 . -12) (f310982 . -8) (f310952 . 4) (f310952 . -28) (f310953 . -24) (f310954 . -20) (f310955 . -16) (f310956 . -12) (f310957 . -8) (f310958 . -4) (f310959 . 0))
#    expr = (funcall (primitive-ref write-char) #\. f310981)
=======
# env=((f195 . -20) (f194 . -16) (f195 . -12) (f194 . -8) (f165 . 4) (f165 . -28) (f166 . -24) (f167 . -20) (f168 . -16) (f169 . -12) (f170 . -8) (f171 . -4) (f172 . 0))
# expr=(begin ((primitive-ref write-char) #\. f195) ((primitive-ref write-char) #\space f195) ((primitive-ref write) (cdr f194) f195))
# tail-begin (begin ((primitive-ref write-char) #\. f195) ((primitive-ref write-char) #\space f195) ((primitive-ref write) (cdr f194) f195))
#   env=((f195 . -20) (f194 . -16) (f195 . -12) (f194 . -8) (f165 . 4) (f165 . -28) (f166 . -24) (f167 . -20) (f168 . -16) (f169 . -12) (f170 . -8) (f171 . -4) (f172 . 0))
# emit-expr ((primitive-ref write-char) #\. f195)
# funcall
#    si   =-24
#    env  = ((f195 . -20) (f194 . -16) (f195 . -12) (f194 . -8) (f165 . 4) (f165 . -28) (f166 . -24) (f167 . -20) (f168 . -16) (f169 . -12) (f170 . -8) (f171 . -4) (f172 . 0))
#    expr = (funcall (primitive-ref write-char) #\. f195)
>>>>>>> fix-implicit-begins
# emit-expr (primitive-ref write-char)
    .extern mrc_write$mchar
    movl mrc_write$mchar,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1332"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1332":
   movl %eax,  -32(%esp)  # stash funcall-oper in closure slot
# emit-expr #\.
    movl $11791, %eax     # immed #\.
    mov %eax, -36(%esp)  # arg .
<<<<<<< HEAD
# emit-expr f310981
# emit-variable-ref
# env=((f310981 . -20) (f310982 . -16) (f310981 . -12) (f310982 . -8) (f310952 . 4) (f310952 . -28) (f310953 . -24) (f310954 . -20) (f310955 . -16) (f310956 . -12) (f310957 . -8) (f310958 . -4) (f310959 . 0))
# var=f310981
    movl -20(%esp), %eax  # stack load f310981
# end emit-variable-ref
    mov %eax, -40(%esp)  # arg f310981
=======
# emit-expr f195
# emit-variable-ref
# env=((f195 . -20) (f194 . -16) (f195 . -12) (f194 . -8) (f165 . 4) (f165 . -28) (f166 . -24) (f167 . -20) (f168 . -16) (f169 . -12) (f170 . -8) (f171 . -4) (f172 . 0))
# var=f195
    movl -20(%esp), %eax  # stack load f195
# end emit-variable-ref
    mov %eax, -40(%esp)  # arg f195
>>>>>>> fix-implicit-begins
    movl -32(%esp), %edi   # load new closure to %edi
    add $-24, %esp   # adjust base
    movl $8,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $24, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
# emit-tail-expr
# si=-24
<<<<<<< HEAD
# env=((f310981 . -20) (f310982 . -16) (f310981 . -12) (f310982 . -8) (f310952 . 4) (f310952 . -28) (f310953 . -24) (f310954 . -20) (f310955 . -16) (f310956 . -12) (f310957 . -8) (f310958 . -4) (f310959 . 0))
# expr=(begin ((primitive-ref write-char) #\space f310981) ((primitive-ref write) (cdr f310982) f310981))
# tail-begin (begin ((primitive-ref write-char) #\space f310981) ((primitive-ref write) (cdr f310982) f310981))
#   env=((f310981 . -20) (f310982 . -16) (f310981 . -12) (f310982 . -8) (f310952 . 4) (f310952 . -28) (f310953 . -24) (f310954 . -20) (f310955 . -16) (f310956 . -12) (f310957 . -8) (f310958 . -4) (f310959 . 0))
# emit-expr ((primitive-ref write-char) #\space f310981)
# funcall
#    si   =-24
#    env  = ((f310981 . -20) (f310982 . -16) (f310981 . -12) (f310982 . -8) (f310952 . 4) (f310952 . -28) (f310953 . -24) (f310954 . -20) (f310955 . -16) (f310956 . -12) (f310957 . -8) (f310958 . -4) (f310959 . 0))
#    expr = (funcall (primitive-ref write-char) #\space f310981)
=======
# env=((f195 . -20) (f194 . -16) (f195 . -12) (f194 . -8) (f165 . 4) (f165 . -28) (f166 . -24) (f167 . -20) (f168 . -16) (f169 . -12) (f170 . -8) (f171 . -4) (f172 . 0))
# expr=(begin ((primitive-ref write-char) #\space f195) ((primitive-ref write) (cdr f194) f195))
# tail-begin (begin ((primitive-ref write-char) #\space f195) ((primitive-ref write) (cdr f194) f195))
#   env=((f195 . -20) (f194 . -16) (f195 . -12) (f194 . -8) (f165 . 4) (f165 . -28) (f166 . -24) (f167 . -20) (f168 . -16) (f169 . -12) (f170 . -8) (f171 . -4) (f172 . 0))
# emit-expr ((primitive-ref write-char) #\space f195)
# funcall
#    si   =-24
#    env  = ((f195 . -20) (f194 . -16) (f195 . -12) (f194 . -8) (f165 . 4) (f165 . -28) (f166 . -24) (f167 . -20) (f168 . -16) (f169 . -12) (f170 . -8) (f171 . -4) (f172 . 0))
#    expr = (funcall (primitive-ref write-char) #\space f195)
>>>>>>> fix-implicit-begins
# emit-expr (primitive-ref write-char)
    .extern mrc_write$mchar
    movl mrc_write$mchar,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1333"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1333":
   movl %eax,  -32(%esp)  # stash funcall-oper in closure slot
# emit-expr #\space
    movl $8207, %eax     # immed #\space
    mov %eax, -36(%esp)  # arg  
<<<<<<< HEAD
# emit-expr f310981
# emit-variable-ref
# env=((f310981 . -20) (f310982 . -16) (f310981 . -12) (f310982 . -8) (f310952 . 4) (f310952 . -28) (f310953 . -24) (f310954 . -20) (f310955 . -16) (f310956 . -12) (f310957 . -8) (f310958 . -4) (f310959 . 0))
# var=f310981
    movl -20(%esp), %eax  # stack load f310981
# end emit-variable-ref
    mov %eax, -40(%esp)  # arg f310981
=======
# emit-expr f195
# emit-variable-ref
# env=((f195 . -20) (f194 . -16) (f195 . -12) (f194 . -8) (f165 . 4) (f165 . -28) (f166 . -24) (f167 . -20) (f168 . -16) (f169 . -12) (f170 . -8) (f171 . -4) (f172 . 0))
# var=f195
    movl -20(%esp), %eax  # stack load f195
# end emit-variable-ref
    mov %eax, -40(%esp)  # arg f195
>>>>>>> fix-implicit-begins
    movl -32(%esp), %edi   # load new closure to %edi
    add $-24, %esp   # adjust base
    movl $8,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $24, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
# emit-tail-expr
# si=-24
<<<<<<< HEAD
# env=((f310981 . -20) (f310982 . -16) (f310981 . -12) (f310982 . -8) (f310952 . 4) (f310952 . -28) (f310953 . -24) (f310954 . -20) (f310955 . -16) (f310956 . -12) (f310957 . -8) (f310958 . -4) (f310959 . 0))
# expr=(begin ((primitive-ref write) (cdr f310982) f310981))
# tail-begin (begin ((primitive-ref write) (cdr f310982) f310981))
#   env=((f310981 . -20) (f310982 . -16) (f310981 . -12) (f310982 . -8) (f310952 . 4) (f310952 . -28) (f310953 . -24) (f310954 . -20) (f310955 . -16) (f310956 . -12) (f310957 . -8) (f310958 . -4) (f310959 . 0))
# emit-tail-expr
# si=-24
# env=((f310981 . -20) (f310982 . -16) (f310981 . -12) (f310982 . -8) (f310952 . 4) (f310952 . -28) (f310953 . -24) (f310954 . -20) (f310955 . -16) (f310956 . -12) (f310957 . -8) (f310958 . -4) (f310959 . 0))
# expr=((primitive-ref write) (cdr f310982) f310981)
# emit-tail-funcall
#    si   =-24
#    env  = ((f310981 . -20) (f310982 . -16) (f310981 . -12) (f310982 . -8) (f310952 . 4) (f310952 . -28) (f310953 . -24) (f310954 . -20) (f310955 . -16) (f310956 . -12) (f310957 . -8) (f310958 . -4) (f310959 . 0))
#    expr = (funcall (primitive-ref write) (cdr f310982) f310981)
=======
# env=((f195 . -20) (f194 . -16) (f195 . -12) (f194 . -8) (f165 . 4) (f165 . -28) (f166 . -24) (f167 . -20) (f168 . -16) (f169 . -12) (f170 . -8) (f171 . -4) (f172 . 0))
# expr=(begin ((primitive-ref write) (cdr f194) f195))
# tail-begin (begin ((primitive-ref write) (cdr f194) f195))
#   env=((f195 . -20) (f194 . -16) (f195 . -12) (f194 . -8) (f165 . 4) (f165 . -28) (f166 . -24) (f167 . -20) (f168 . -16) (f169 . -12) (f170 . -8) (f171 . -4) (f172 . 0))
# emit-tail-expr
# si=-24
# env=((f195 . -20) (f194 . -16) (f195 . -12) (f194 . -8) (f165 . 4) (f165 . -28) (f166 . -24) (f167 . -20) (f168 . -16) (f169 . -12) (f170 . -8) (f171 . -4) (f172 . 0))
# expr=((primitive-ref write) (cdr f194) f195)
# emit-tail-funcall
#    si   =-24
#    env  = ((f195 . -20) (f194 . -16) (f195 . -12) (f194 . -8) (f165 . 4) (f165 . -28) (f166 . -24) (f167 . -20) (f168 . -16) (f169 . -12) (f170 . -8) (f171 . -4) (f172 . 0))
#    expr = (funcall (primitive-ref write) (cdr f194) f195)
>>>>>>> fix-implicit-begins
# emit-expr (primitive-ref write)
    .extern mrc_write
    movl mrc_write,%eax
   movl %eax,  -24(%esp)  # stash funcall-oper in next closure slot
<<<<<<< HEAD
# emit-expr (cdr f310982)
# emit-expr f310982
# emit-variable-ref
# env=((f310981 . -20) (f310982 . -16) (f310981 . -12) (f310982 . -8) (f310952 . 4) (f310952 . -28) (f310953 . -24) (f310954 . -20) (f310955 . -16) (f310956 . -12) (f310957 . -8) (f310958 . -4) (f310959 . 0))
# var=f310982
    movl -16(%esp), %eax  # stack load f310982
=======
# emit-expr (cdr f194)
# emit-expr f194
# emit-variable-ref
# env=((f195 . -20) (f194 . -16) (f195 . -12) (f194 . -8) (f165 . 4) (f165 . -28) (f166 . -24) (f167 . -20) (f168 . -16) (f169 . -12) (f170 . -8) (f171 . -4) (f172 . 0))
# var=f194
    movl -16(%esp), %eax  # stack load f194
>>>>>>> fix-implicit-begins
# end emit-variable-ref
# check the argument is a pair
    movl %eax,%ebx
    and $7, %bl
    cmp $1, %bl
    je _L_1334
# invoke error handler eh_pair
    .extern mrc_eh$upair
    movl mrc_eh$upair, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $120,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1334:
    movl 3(%eax), %eax
<<<<<<< HEAD
    mov %eax, -28(%esp)    # arg (cdr f310982)
# emit-expr f310981
# emit-variable-ref
# env=((f310981 . -20) (f310982 . -16) (f310981 . -12) (f310982 . -8) (f310952 . 4) (f310952 . -28) (f310953 . -24) (f310954 . -20) (f310955 . -16) (f310956 . -12) (f310957 . -8) (f310958 . -4) (f310959 . 0))
# var=f310981
    movl -20(%esp), %eax  # stack load f310981
# end emit-variable-ref
    mov %eax, -32(%esp)    # arg f310981
=======
    mov %eax, -28(%esp)    # arg (cdr f194)
# emit-expr f195
# emit-variable-ref
# env=((f195 . -20) (f194 . -16) (f195 . -12) (f194 . -8) (f165 . 4) (f165 . -28) (f166 . -24) (f167 . -20) (f168 . -16) (f169 . -12) (f170 . -8) (f171 . -4) (f172 . 0))
# var=f195
    movl -20(%esp), %eax  # stack load f195
# end emit-variable-ref
    mov %eax, -32(%esp)    # arg f195
>>>>>>> fix-implicit-begins
    movl -24(%esp), %edi   # load new closure to %edi
# emit-shift-args:  size=3   si=-24  delta=20
    mov -24(%esp), %ebx  # shift frame cell
    mov %ebx, -4(%esp)  # down to base
# emit-shift-args:  size=2   si=-28  delta=20
    mov -28(%esp), %ebx  # shift frame cell
    mov %ebx, -8(%esp)  # down to base
# emit-shift-args:  size=1   si=-32  delta=20
    mov -32(%esp), %ebx  # shift frame cell
    mov %ebx, -12(%esp)  # down to base
# emit-shift-args:  size=0   si=-36  delta=20
    movl $8,%eax   # save arg count
    jmp *-2(%edi)  # tail-funcall
     ret   # return thru stack
     ret   # return thru stack
_L_1323:
_L_1320:
     ret   # return thru stack
    .align 4,0x90
_L_1315:
    movl -32(%esp), %ebx
    movl -36(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin)
# emit-begin
#   expr=(begin)
<<<<<<< HEAD
#   env=((f310952 . -28) (f310953 . -24) (f310954 . -20) (f310955 . -16) (f310956 . -12) (f310957 . -8) (f310958 . -4) (f310959 . 0))
# emit-expr (begin (closure (f311007 f311006 f311005) (f310959 f310958 f310957 f310956 f310954 f310955 f310953) (let ((f311007 f311007) (f311006 f311006) (f311005 f311005)) (if (boolean? f311007) ((vector-ref f310959 0) f311007 f311006) (if (null? f311007) ((vector-ref f310958 0) f311006) (if (char? f311007) (if f311005 ((primitive-ref write-char) f311007 f311006) ((vector-ref f310957 0) f311007 f311006)) (if (fixnum? f311007) ((vector-ref f310956 0) f311007 f311006) (if (string? f311007) (if f311005 ((vector-ref f310954 0) f311007 f311006) ((vector-ref f310955 0) f311007 f311006)) (if (pair? f311007) ((vector-ref f310953 0) f311007 f311006) ((primitive-ref error) ((primitive-ref string->symbol) "write") "unrecognized expression"))))))))))
# emit-begin
#   expr=(begin (closure (f311007 f311006 f311005) (f310959 f310958 f310957 f310956 f310954 f310955 f310953) (let ((f311007 f311007) (f311006 f311006) (f311005 f311005)) (if (boolean? f311007) ((vector-ref f310959 0) f311007 f311006) (if (null? f311007) ((vector-ref f310958 0) f311006) (if (char? f311007) (if f311005 ((primitive-ref write-char) f311007 f311006) ((vector-ref f310957 0) f311007 f311006)) (if (fixnum? f311007) ((vector-ref f310956 0) f311007 f311006) (if (string? f311007) (if f311005 ((vector-ref f310954 0) f311007 f311006) ((vector-ref f310955 0) f311007 f311006)) (if (pair? f311007) ((vector-ref f310953 0) f311007 f311006) ((primitive-ref error) ((primitive-ref string->symbol) "write") "unrecognized expression"))))))))))
#   env=((f310952 . -28) (f310953 . -24) (f310954 . -20) (f310955 . -16) (f310956 . -12) (f310957 . -8) (f310958 . -4) (f310959 . 0))
# emit-expr (closure (f311007 f311006 f311005) (f310959 f310958 f310957 f310956 f310954 f310955 f310953) (let ((f311007 f311007) (f311006 f311006) (f311005 f311005)) (if (boolean? f311007) ((vector-ref f310959 0) f311007 f311006) (if (null? f311007) ((vector-ref f310958 0) f311006) (if (char? f311007) (if f311005 ((primitive-ref write-char) f311007 f311006) ((vector-ref f310957 0) f311007 f311006)) (if (fixnum? f311007) ((vector-ref f310956 0) f311007 f311006) (if (string? f311007) (if f311005 ((vector-ref f310954 0) f311007 f311006) ((vector-ref f310955 0) f311007 f311006)) (if (pair? f311007) ((vector-ref f310953 0) f311007 f311006) ((primitive-ref error) ((primitive-ref string->symbol) "write") "unrecognized expression")))))))))
# emit-closure
# si = -32
# env = ((f310952 . -28) (f310953 . -24) (f310954 . -20) (f310955 . -16) (f310956 . -12) (f310957 . -8) (f310958 . -4) (f310959 . 0))
# expr = (closure (f311007 f311006 f311005) (f310959 f310958 f310957 f310956 f310954 f310955 f310953) (let ((f311007 f311007) (f311006 f311006) (f311005 f311005)) (if (boolean? f311007) ((vector-ref f310959 0) f311007 f311006) (if (null? f311007) ((vector-ref f310958 0) f311006) (if (char? f311007) (if f311005 ((primitive-ref write-char) f311007 f311006) ((vector-ref f310957 0) f311007 f311006)) (if (fixnum? f311007) ((vector-ref f310956 0) f311007 f311006) (if (string? f311007) (if f311005 ((vector-ref f310954 0) f311007 f311006) ((vector-ref f310955 0) f311007 f311006)) (if (pair? f311007) ((vector-ref f310953 0) f311007 f311006) ((primitive-ref error) ((primitive-ref string->symbol) "write") "unrecognized expression")))))))))
    movl $_L_1884934, 0(%ebp)  # closure label
=======
#   env=((f165 . -28) (f166 . -24) (f167 . -20) (f168 . -16) (f169 . -12) (f170 . -8) (f171 . -4) (f172 . 0))
# emit-expr (begin (closure (f218 f219 f220) (f172 f171 f170 f169 f167 f168 f166) (let ((f218 f218) (f219 f219) (f220 f220)) (if (boolean? f218) (begin ((vector-ref f172 0) f218 f219)) (if (null? f218) (begin ((vector-ref f171 0) f219)) (if (char? f218) (begin (if f220 ((primitive-ref write-char) f218 f219) ((vector-ref f170 0) f218 f219))) (if (fixnum? f218) (begin ((vector-ref f169 0) f218 f219)) (if (string? f218) (begin (if f220 ((vector-ref f167 0) f218 f219) ((vector-ref f168 0) f218 f219))) (if (pair? f218) (begin ((vector-ref f166 0) f218 f219)) (begin ((primitive-ref error) ((primitive-ref string->symbol) "write") "unrecognized expression")))))))))))
# emit-begin
#   expr=(begin (closure (f218 f219 f220) (f172 f171 f170 f169 f167 f168 f166) (let ((f218 f218) (f219 f219) (f220 f220)) (if (boolean? f218) (begin ((vector-ref f172 0) f218 f219)) (if (null? f218) (begin ((vector-ref f171 0) f219)) (if (char? f218) (begin (if f220 ((primitive-ref write-char) f218 f219) ((vector-ref f170 0) f218 f219))) (if (fixnum? f218) (begin ((vector-ref f169 0) f218 f219)) (if (string? f218) (begin (if f220 ((vector-ref f167 0) f218 f219) ((vector-ref f168 0) f218 f219))) (if (pair? f218) (begin ((vector-ref f166 0) f218 f219)) (begin ((primitive-ref error) ((primitive-ref string->symbol) "write") "unrecognized expression")))))))))))
#   env=((f165 . -28) (f166 . -24) (f167 . -20) (f168 . -16) (f169 . -12) (f170 . -8) (f171 . -4) (f172 . 0))
# emit-expr (closure (f218 f219 f220) (f172 f171 f170 f169 f167 f168 f166) (let ((f218 f218) (f219 f219) (f220 f220)) (if (boolean? f218) (begin ((vector-ref f172 0) f218 f219)) (if (null? f218) (begin ((vector-ref f171 0) f219)) (if (char? f218) (begin (if f220 ((primitive-ref write-char) f218 f219) ((vector-ref f170 0) f218 f219))) (if (fixnum? f218) (begin ((vector-ref f169 0) f218 f219)) (if (string? f218) (begin (if f220 ((vector-ref f167 0) f218 f219) ((vector-ref f168 0) f218 f219))) (if (pair? f218) (begin ((vector-ref f166 0) f218 f219)) (begin ((primitive-ref error) ((primitive-ref string->symbol) "write") "unrecognized expression"))))))))))
# emit-closure
# si = -32
# env = ((f165 . -28) (f166 . -24) (f167 . -20) (f168 . -16) (f169 . -12) (f170 . -8) (f171 . -4) (f172 . 0))
# expr = (closure (f218 f219 f220) (f172 f171 f170 f169 f167 f168 f166) (let ((f218 f218) (f219 f219) (f220 f220)) (if (boolean? f218) (begin ((vector-ref f172 0) f218 f219)) (if (null? f218) (begin ((vector-ref f171 0) f219)) (if (char? f218) (begin (if f220 ((primitive-ref write-char) f218 f219) ((vector-ref f170 0) f218 f219))) (if (fixnum? f218) (begin ((vector-ref f169 0) f218 f219)) (if (string? f218) (begin (if f220 ((vector-ref f167 0) f218 f219) ((vector-ref f168 0) f218 f219))) (if (pair? f218) (begin ((vector-ref f166 0) f218 f219)) (begin ((primitive-ref error) ((primitive-ref string->symbol) "write") "unrecognized expression"))))))))))
    movl $_L_1335, 0(%ebp)  # closure label
>>>>>>> fix-implicit-begins
# emit-variable-ref
# env=((f165 . -28) (f166 . -24) (f167 . -20) (f168 . -16) (f169 . -12) (f170 . -8) (f171 . -4) (f172 . 0))
# var=f172
    movl 0(%esp), %eax  # stack load f172
# end emit-variable-ref
   movl  %eax, 4(%ebp)  # f172
# emit-variable-ref
# env=((f165 . -28) (f166 . -24) (f167 . -20) (f168 . -16) (f169 . -12) (f170 . -8) (f171 . -4) (f172 . 0))
# var=f171
    movl -4(%esp), %eax  # stack load f171
# end emit-variable-ref
   movl  %eax, 8(%ebp)  # f171
# emit-variable-ref
# env=((f165 . -28) (f166 . -24) (f167 . -20) (f168 . -16) (f169 . -12) (f170 . -8) (f171 . -4) (f172 . 0))
# var=f170
    movl -8(%esp), %eax  # stack load f170
# end emit-variable-ref
   movl  %eax, 12(%ebp)  # f170
# emit-variable-ref
# env=((f165 . -28) (f166 . -24) (f167 . -20) (f168 . -16) (f169 . -12) (f170 . -8) (f171 . -4) (f172 . 0))
# var=f169
    movl -12(%esp), %eax  # stack load f169
# end emit-variable-ref
   movl  %eax, 16(%ebp)  # f169
# emit-variable-ref
# env=((f165 . -28) (f166 . -24) (f167 . -20) (f168 . -16) (f169 . -12) (f170 . -8) (f171 . -4) (f172 . 0))
# var=f167
    movl -20(%esp), %eax  # stack load f167
# end emit-variable-ref
   movl  %eax, 20(%ebp)  # f167
# emit-variable-ref
# env=((f165 . -28) (f166 . -24) (f167 . -20) (f168 . -16) (f169 . -12) (f170 . -8) (f171 . -4) (f172 . 0))
# var=f168
    movl -16(%esp), %eax  # stack load f168
# end emit-variable-ref
   movl  %eax, 24(%ebp)  # f168
# emit-variable-ref
# env=((f165 . -28) (f166 . -24) (f167 . -20) (f168 . -16) (f169 . -12) (f170 . -8) (f171 . -4) (f172 . 0))
# var=f166
    movl -24(%esp), %eax  # stack load f166
# end emit-variable-ref
   movl  %eax, 28(%ebp)  # f166
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $32, %ebp     # bump ebp
    jmp _L_1336            # jump around closure body
_L_1335:
# check argument count
    cmp $12,%eax
    je _L_1337
# invoke error handler eh_argcount
    .extern mrc_eh$uargcount
    movl mrc_eh$uargcount, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_1337:
# emit-tail-expr
# si=-20
<<<<<<< HEAD
# env=((f311005 . -16) (f311006 . -12) (f311007 . -8) (f310953 . 28) (f310955 . 24) (f310954 . 20) (f310956 . 16) (f310957 . 12) (f310958 . 8) (f310959 . 4) (f310952 . -28) (f310953 . -24) (f310954 . -20) (f310955 . -16) (f310956 . -12) (f310957 . -8) (f310958 . -4) (f310959 . 0))
# expr=(let ((f311007 f311007) (f311006 f311006) (f311005 f311005)) (if (boolean? f311007) ((vector-ref f310959 0) f311007 f311006) (if (null? f311007) ((vector-ref f310958 0) f311006) (if (char? f311007) (if f311005 ((primitive-ref write-char) f311007 f311006) ((vector-ref f310957 0) f311007 f311006)) (if (fixnum? f311007) ((vector-ref f310956 0) f311007 f311006) (if (string? f311007) (if f311005 ((vector-ref f310954 0) f311007 f311006) ((vector-ref f310955 0) f311007 f311006)) (if (pair? f311007) ((vector-ref f310953 0) f311007 f311006) ((primitive-ref error) ((primitive-ref string->symbol) "write") "unrecognized expression"))))))))
# emit-tail-let
#  si   = -20
#  env  = ((f311005 . -16) (f311006 . -12) (f311007 . -8) (f310953 . 28) (f310955 . 24) (f310954 . 20) (f310956 . 16) (f310957 . 12) (f310958 . 8) (f310959 . 4) (f310952 . -28) (f310953 . -24) (f310954 . -20) (f310955 . -16) (f310956 . -12) (f310957 . -8) (f310958 . -4) (f310959 . 0))
#  bindings = ((f311007 f311007) (f311006 f311006) (f311005 f311005))
#  body = (if (boolean? f311007) ((vector-ref f310959 0) f311007 f311006) (if (null? f311007) ((vector-ref f310958 0) f311006) (if (char? f311007) (if f311005 ((primitive-ref write-char) f311007 f311006) ((vector-ref f310957 0) f311007 f311006)) (if (fixnum? f311007) ((vector-ref f310956 0) f311007 f311006) (if (string? f311007) (if f311005 ((vector-ref f310954 0) f311007 f311006) ((vector-ref f310955 0) f311007 f311006)) (if (pair? f311007) ((vector-ref f310953 0) f311007 f311006) ((primitive-ref error) ((primitive-ref string->symbol) "write") "unrecognized expression")))))))
# emit-expr f311007
# emit-variable-ref
# env=((f311005 . -16) (f311006 . -12) (f311007 . -8) (f310953 . 28) (f310955 . 24) (f310954 . 20) (f310956 . 16) (f310957 . 12) (f310958 . 8) (f310959 . 4) (f310952 . -28) (f310953 . -24) (f310954 . -20) (f310955 . -16) (f310956 . -12) (f310957 . -8) (f310958 . -4) (f310959 . 0))
# var=f311007
    movl -8(%esp), %eax  # stack load f311007
=======
# env=((f220 . -16) (f219 . -12) (f218 . -8) (f166 . 28) (f168 . 24) (f167 . 20) (f169 . 16) (f170 . 12) (f171 . 8) (f172 . 4) (f165 . -28) (f166 . -24) (f167 . -20) (f168 . -16) (f169 . -12) (f170 . -8) (f171 . -4) (f172 . 0))
# expr=(let ((f218 f218) (f219 f219) (f220 f220)) (if (boolean? f218) (begin ((vector-ref f172 0) f218 f219)) (if (null? f218) (begin ((vector-ref f171 0) f219)) (if (char? f218) (begin (if f220 ((primitive-ref write-char) f218 f219) ((vector-ref f170 0) f218 f219))) (if (fixnum? f218) (begin ((vector-ref f169 0) f218 f219)) (if (string? f218) (begin (if f220 ((vector-ref f167 0) f218 f219) ((vector-ref f168 0) f218 f219))) (if (pair? f218) (begin ((vector-ref f166 0) f218 f219)) (begin ((primitive-ref error) ((primitive-ref string->symbol) "write") "unrecognized expression")))))))))
# emit-tail-let
#  si   = -20
#  env  = ((f220 . -16) (f219 . -12) (f218 . -8) (f166 . 28) (f168 . 24) (f167 . 20) (f169 . 16) (f170 . 12) (f171 . 8) (f172 . 4) (f165 . -28) (f166 . -24) (f167 . -20) (f168 . -16) (f169 . -12) (f170 . -8) (f171 . -4) (f172 . 0))
#  bindings = ((f218 f218) (f219 f219) (f220 f220))
#  body = (if (boolean? f218) (begin ((vector-ref f172 0) f218 f219)) (if (null? f218) (begin ((vector-ref f171 0) f219)) (if (char? f218) (begin (if f220 ((primitive-ref write-char) f218 f219) ((vector-ref f170 0) f218 f219))) (if (fixnum? f218) (begin ((vector-ref f169 0) f218 f219)) (if (string? f218) (begin (if f220 ((vector-ref f167 0) f218 f219) ((vector-ref f168 0) f218 f219))) (if (pair? f218) (begin ((vector-ref f166 0) f218 f219)) (begin ((primitive-ref error) ((primitive-ref string->symbol) "write") "unrecognized expression"))))))))
# emit-expr f218
# emit-variable-ref
# env=((f220 . -16) (f219 . -12) (f218 . -8) (f166 . 28) (f168 . 24) (f167 . 20) (f169 . 16) (f170 . 12) (f171 . 8) (f172 . 4) (f165 . -28) (f166 . -24) (f167 . -20) (f168 . -16) (f169 . -12) (f170 . -8) (f171 . -4) (f172 . 0))
# var=f218
    movl -8(%esp), %eax  # stack load f218
>>>>>>> fix-implicit-begins
# end emit-variable-ref
    movl %eax, -20(%esp)  # stack save
# emit-expr f219
# emit-variable-ref
<<<<<<< HEAD
# env=((f311005 . -16) (f311006 . -12) (f311007 . -8) (f310953 . 28) (f310955 . 24) (f310954 . 20) (f310956 . 16) (f310957 . 12) (f310958 . 8) (f310959 . 4) (f310952 . -28) (f310953 . -24) (f310954 . -20) (f310955 . -16) (f310956 . -12) (f310957 . -8) (f310958 . -4) (f310959 . 0))
# var=f311006
    movl -12(%esp), %eax  # stack load f311006
# end emit-variable-ref
    movl %eax, -24(%esp)  # stack save
# emit-expr f311005
# emit-variable-ref
# env=((f311005 . -16) (f311006 . -12) (f311007 . -8) (f310953 . 28) (f310955 . 24) (f310954 . 20) (f310956 . 16) (f310957 . 12) (f310958 . 8) (f310959 . 4) (f310952 . -28) (f310953 . -24) (f310954 . -20) (f310955 . -16) (f310956 . -12) (f310957 . -8) (f310958 . -4) (f310959 . 0))
# var=f311005
    movl -16(%esp), %eax  # stack load f311005
=======
# env=((f220 . -16) (f219 . -12) (f218 . -8) (f166 . 28) (f168 . 24) (f167 . 20) (f169 . 16) (f170 . 12) (f171 . 8) (f172 . 4) (f165 . -28) (f166 . -24) (f167 . -20) (f168 . -16) (f169 . -12) (f170 . -8) (f171 . -4) (f172 . 0))
# var=f219
    movl -12(%esp), %eax  # stack load f219
# end emit-variable-ref
    movl %eax, -24(%esp)  # stack save
# emit-expr f220
# emit-variable-ref
# env=((f220 . -16) (f219 . -12) (f218 . -8) (f166 . 28) (f168 . 24) (f167 . 20) (f169 . 16) (f170 . 12) (f171 . 8) (f172 . 4) (f165 . -28) (f166 . -24) (f167 . -20) (f168 . -16) (f169 . -12) (f170 . -8) (f171 . -4) (f172 . 0))
# var=f220
    movl -16(%esp), %eax  # stack load f220
>>>>>>> fix-implicit-begins
# end emit-variable-ref
    movl %eax, -28(%esp)  # stack save
# emit-tail-expr
# si=-32
<<<<<<< HEAD
# env=((f311005 . -28) (f311006 . -24) (f311007 . -20) (f311005 . -16) (f311006 . -12) (f311007 . -8) (f310953 . 28) (f310955 . 24) (f310954 . 20) (f310956 . 16) (f310957 . 12) (f310958 . 8) (f310959 . 4) (f310952 . -28) (f310953 . -24) (f310954 . -20) (f310955 . -16) (f310956 . -12) (f310957 . -8) (f310958 . -4) (f310959 . 0))
# expr=(if (boolean? f311007) ((vector-ref f310959 0) f311007 f311006) (if (null? f311007) ((vector-ref f310958 0) f311006) (if (char? f311007) (if f311005 ((primitive-ref write-char) f311007 f311006) ((vector-ref f310957 0) f311007 f311006)) (if (fixnum? f311007) ((vector-ref f310956 0) f311007 f311006) (if (string? f311007) (if f311005 ((vector-ref f310954 0) f311007 f311006) ((vector-ref f310955 0) f311007 f311006)) (if (pair? f311007) ((vector-ref f310953 0) f311007 f311006) ((primitive-ref error) ((primitive-ref string->symbol) "write") "unrecognized expression")))))))
# emit-expr (boolean? f311007)
# emit-expr f311007
# emit-variable-ref
# env=((f311005 . -28) (f311006 . -24) (f311007 . -20) (f311005 . -16) (f311006 . -12) (f311007 . -8) (f310953 . 28) (f310955 . 24) (f310954 . 20) (f310956 . 16) (f310957 . 12) (f310958 . 8) (f310959 . 4) (f310952 . -28) (f310953 . -24) (f310954 . -20) (f310955 . -16) (f310956 . -12) (f310957 . -8) (f310958 . -4) (f310959 . 0))
# var=f311007
    movl -20(%esp), %eax  # stack load f311007
=======
# env=((f220 . -28) (f219 . -24) (f218 . -20) (f220 . -16) (f219 . -12) (f218 . -8) (f166 . 28) (f168 . 24) (f167 . 20) (f169 . 16) (f170 . 12) (f171 . 8) (f172 . 4) (f165 . -28) (f166 . -24) (f167 . -20) (f168 . -16) (f169 . -12) (f170 . -8) (f171 . -4) (f172 . 0))
# expr=(if (boolean? f218) (begin ((vector-ref f172 0) f218 f219)) (if (null? f218) (begin ((vector-ref f171 0) f219)) (if (char? f218) (begin (if f220 ((primitive-ref write-char) f218 f219) ((vector-ref f170 0) f218 f219))) (if (fixnum? f218) (begin ((vector-ref f169 0) f218 f219)) (if (string? f218) (begin (if f220 ((vector-ref f167 0) f218 f219) ((vector-ref f168 0) f218 f219))) (if (pair? f218) (begin ((vector-ref f166 0) f218 f219)) (begin ((primitive-ref error) ((primitive-ref string->symbol) "write") "unrecognized expression"))))))))
# emit-expr (boolean? f218)
# emit-expr f218
# emit-variable-ref
# env=((f220 . -28) (f219 . -24) (f218 . -20) (f220 . -16) (f219 . -12) (f218 . -8) (f166 . 28) (f168 . 24) (f167 . 20) (f169 . 16) (f170 . 12) (f171 . 8) (f172 . 4) (f165 . -28) (f166 . -24) (f167 . -20) (f168 . -16) (f169 . -12) (f170 . -8) (f171 . -4) (f172 . 0))
# var=f218
    movl -20(%esp), %eax  # stack load f218
>>>>>>> fix-implicit-begins
# end emit-variable-ref
    and $191, %eax
    cmp $47, %eax
    sete %al
    movzbl %al, %eax
    sal $6, %al
    or $47, %al
    cmp $47, %al
    je _L_1338
# emit-tail-expr
# si=-32
# env=((f220 . -28) (f219 . -24) (f218 . -20) (f220 . -16) (f219 . -12) (f218 . -8) (f166 . 28) (f168 . 24) (f167 . 20) (f169 . 16) (f170 . 12) (f171 . 8) (f172 . 4) (f165 . -28) (f166 . -24) (f167 . -20) (f168 . -16) (f169 . -12) (f170 . -8) (f171 . -4) (f172 . 0))
# expr=(begin ((vector-ref f172 0) f218 f219))
# tail-begin (begin ((vector-ref f172 0) f218 f219))
#   env=((f220 . -28) (f219 . -24) (f218 . -20) (f220 . -16) (f219 . -12) (f218 . -8) (f166 . 28) (f168 . 24) (f167 . 20) (f169 . 16) (f170 . 12) (f171 . 8) (f172 . 4) (f165 . -28) (f166 . -24) (f167 . -20) (f168 . -16) (f169 . -12) (f170 . -8) (f171 . -4) (f172 . 0))
# emit-tail-expr
# si=-32
<<<<<<< HEAD
# env=((f311005 . -28) (f311006 . -24) (f311007 . -20) (f311005 . -16) (f311006 . -12) (f311007 . -8) (f310953 . 28) (f310955 . 24) (f310954 . 20) (f310956 . 16) (f310957 . 12) (f310958 . 8) (f310959 . 4) (f310952 . -28) (f310953 . -24) (f310954 . -20) (f310955 . -16) (f310956 . -12) (f310957 . -8) (f310958 . -4) (f310959 . 0))
# expr=((vector-ref f310959 0) f311007 f311006)
# emit-tail-funcall
#    si   =-32
#    env  = ((f311005 . -28) (f311006 . -24) (f311007 . -20) (f311005 . -16) (f311006 . -12) (f311007 . -8) (f310953 . 28) (f310955 . 24) (f310954 . 20) (f310956 . 16) (f310957 . 12) (f310958 . 8) (f310959 . 4) (f310952 . -28) (f310953 . -24) (f310954 . -20) (f310955 . -16) (f310956 . -12) (f310957 . -8) (f310958 . -4) (f310959 . 0))
#    expr = (funcall (vector-ref f310959 0) f311007 f311006)
# emit-expr (vector-ref f310959 0)
# emit-expr f310959
# emit-variable-ref
# env=((f311005 . -28) (f311006 . -24) (f311007 . -20) (f311005 . -16) (f311006 . -12) (f311007 . -8) (f310953 . 28) (f310955 . 24) (f310954 . 20) (f310956 . 16) (f310957 . 12) (f310958 . 8) (f310959 . 4) (f310952 . -28) (f310953 . -24) (f310954 . -20) (f310955 . -16) (f310956 . -12) (f310957 . -8) (f310958 . -4) (f310959 . 0))
# var=f310959
    movl 2(%edi), %eax  # frame load f310959
=======
# env=((f220 . -28) (f219 . -24) (f218 . -20) (f220 . -16) (f219 . -12) (f218 . -8) (f166 . 28) (f168 . 24) (f167 . 20) (f169 . 16) (f170 . 12) (f171 . 8) (f172 . 4) (f165 . -28) (f166 . -24) (f167 . -20) (f168 . -16) (f169 . -12) (f170 . -8) (f171 . -4) (f172 . 0))
# expr=((vector-ref f172 0) f218 f219)
# emit-tail-funcall
#    si   =-32
#    env  = ((f220 . -28) (f219 . -24) (f218 . -20) (f220 . -16) (f219 . -12) (f218 . -8) (f166 . 28) (f168 . 24) (f167 . 20) (f169 . 16) (f170 . 12) (f171 . 8) (f172 . 4) (f165 . -28) (f166 . -24) (f167 . -20) (f168 . -16) (f169 . -12) (f170 . -8) (f171 . -4) (f172 . 0))
#    expr = (funcall (vector-ref f172 0) f218 f219)
# emit-expr (vector-ref f172 0)
# emit-expr f172
# emit-variable-ref
# env=((f220 . -28) (f219 . -24) (f218 . -20) (f220 . -16) (f219 . -12) (f218 . -8) (f166 . 28) (f168 . 24) (f167 . 20) (f169 . 16) (f170 . 12) (f171 . 8) (f172 . 4) (f165 . -28) (f166 . -24) (f167 . -20) (f168 . -16) (f169 . -12) (f170 . -8) (f171 . -4) (f172 . 0))
# var=f172
    movl 2(%edi), %eax  # frame load f172
>>>>>>> fix-implicit-begins
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1340
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1340:
    movl %eax, -32(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1341"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1341:
# check bounds on vector index
    movl -32(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1343
    cmp  $0,%eax
    jge _L_1342
_L_1343:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1342:
    movl -32(%esp), %esi
    movl -1(%eax,%esi), %eax
   movl %eax,  -32(%esp)  # stash funcall-oper in next closure slot
<<<<<<< HEAD
# emit-expr f311007
# emit-variable-ref
# env=((f311005 . -28) (f311006 . -24) (f311007 . -20) (f311005 . -16) (f311006 . -12) (f311007 . -8) (f310953 . 28) (f310955 . 24) (f310954 . 20) (f310956 . 16) (f310957 . 12) (f310958 . 8) (f310959 . 4) (f310952 . -28) (f310953 . -24) (f310954 . -20) (f310955 . -16) (f310956 . -12) (f310957 . -8) (f310958 . -4) (f310959 . 0))
# var=f311007
    movl -20(%esp), %eax  # stack load f311007
# end emit-variable-ref
    mov %eax, -36(%esp)    # arg f311007
# emit-expr f311006
# emit-variable-ref
# env=((f311005 . -28) (f311006 . -24) (f311007 . -20) (f311005 . -16) (f311006 . -12) (f311007 . -8) (f310953 . 28) (f310955 . 24) (f310954 . 20) (f310956 . 16) (f310957 . 12) (f310958 . 8) (f310959 . 4) (f310952 . -28) (f310953 . -24) (f310954 . -20) (f310955 . -16) (f310956 . -12) (f310957 . -8) (f310958 . -4) (f310959 . 0))
# var=f311006
    movl -24(%esp), %eax  # stack load f311006
=======
# emit-expr f218
# emit-variable-ref
# env=((f220 . -28) (f219 . -24) (f218 . -20) (f220 . -16) (f219 . -12) (f218 . -8) (f166 . 28) (f168 . 24) (f167 . 20) (f169 . 16) (f170 . 12) (f171 . 8) (f172 . 4) (f165 . -28) (f166 . -24) (f167 . -20) (f168 . -16) (f169 . -12) (f170 . -8) (f171 . -4) (f172 . 0))
# var=f218
    movl -20(%esp), %eax  # stack load f218
# end emit-variable-ref
    mov %eax, -36(%esp)    # arg f218
# emit-expr f219
# emit-variable-ref
# env=((f220 . -28) (f219 . -24) (f218 . -20) (f220 . -16) (f219 . -12) (f218 . -8) (f166 . 28) (f168 . 24) (f167 . 20) (f169 . 16) (f170 . 12) (f171 . 8) (f172 . 4) (f165 . -28) (f166 . -24) (f167 . -20) (f168 . -16) (f169 . -12) (f170 . -8) (f171 . -4) (f172 . 0))
# var=f219
    movl -24(%esp), %eax  # stack load f219
>>>>>>> fix-implicit-begins
# end emit-variable-ref
    mov %eax, -40(%esp)    # arg f219
    movl -32(%esp), %edi   # load new closure to %edi
# emit-shift-args:  size=3   si=-32  delta=28
    mov -32(%esp), %ebx  # shift frame cell
    mov %ebx, -4(%esp)  # down to base
# emit-shift-args:  size=2   si=-36  delta=28
    mov -36(%esp), %ebx  # shift frame cell
    mov %ebx, -8(%esp)  # down to base
# emit-shift-args:  size=1   si=-40  delta=28
    mov -40(%esp), %ebx  # shift frame cell
    mov %ebx, -12(%esp)  # down to base
# emit-shift-args:  size=0   si=-44  delta=28
    movl $8,%eax   # save arg count
    jmp *-2(%edi)  # tail-funcall
     ret   # return thru stack
    jmp _L_1339
_L_1338:
# emit-tail-expr
# si=-32
<<<<<<< HEAD
# env=((f311005 . -28) (f311006 . -24) (f311007 . -20) (f311005 . -16) (f311006 . -12) (f311007 . -8) (f310953 . 28) (f310955 . 24) (f310954 . 20) (f310956 . 16) (f310957 . 12) (f310958 . 8) (f310959 . 4) (f310952 . -28) (f310953 . -24) (f310954 . -20) (f310955 . -16) (f310956 . -12) (f310957 . -8) (f310958 . -4) (f310959 . 0))
# expr=(if (null? f311007) ((vector-ref f310958 0) f311006) (if (char? f311007) (if f311005 ((primitive-ref write-char) f311007 f311006) ((vector-ref f310957 0) f311007 f311006)) (if (fixnum? f311007) ((vector-ref f310956 0) f311007 f311006) (if (string? f311007) (if f311005 ((vector-ref f310954 0) f311007 f311006) ((vector-ref f310955 0) f311007 f311006)) (if (pair? f311007) ((vector-ref f310953 0) f311007 f311006) ((primitive-ref error) ((primitive-ref string->symbol) "write") "unrecognized expression"))))))
# emit-expr (null? f311007)
# emit-expr f311007
# emit-variable-ref
# env=((f311005 . -28) (f311006 . -24) (f311007 . -20) (f311005 . -16) (f311006 . -12) (f311007 . -8) (f310953 . 28) (f310955 . 24) (f310954 . 20) (f310956 . 16) (f310957 . 12) (f310958 . 8) (f310959 . 4) (f310952 . -28) (f310953 . -24) (f310954 . -20) (f310955 . -16) (f310956 . -12) (f310957 . -8) (f310958 . -4) (f310959 . 0))
# var=f311007
    movl -20(%esp), %eax  # stack load f311007
=======
# env=((f220 . -28) (f219 . -24) (f218 . -20) (f220 . -16) (f219 . -12) (f218 . -8) (f166 . 28) (f168 . 24) (f167 . 20) (f169 . 16) (f170 . 12) (f171 . 8) (f172 . 4) (f165 . -28) (f166 . -24) (f167 . -20) (f168 . -16) (f169 . -12) (f170 . -8) (f171 . -4) (f172 . 0))
# expr=(if (null? f218) (begin ((vector-ref f171 0) f219)) (if (char? f218) (begin (if f220 ((primitive-ref write-char) f218 f219) ((vector-ref f170 0) f218 f219))) (if (fixnum? f218) (begin ((vector-ref f169 0) f218 f219)) (if (string? f218) (begin (if f220 ((vector-ref f167 0) f218 f219) ((vector-ref f168 0) f218 f219))) (if (pair? f218) (begin ((vector-ref f166 0) f218 f219)) (begin ((primitive-ref error) ((primitive-ref string->symbol) "write") "unrecognized expression")))))))
# emit-expr (null? f218)
# emit-expr f218
# emit-variable-ref
# env=((f220 . -28) (f219 . -24) (f218 . -20) (f220 . -16) (f219 . -12) (f218 . -8) (f166 . 28) (f168 . 24) (f167 . 20) (f169 . 16) (f170 . 12) (f171 . 8) (f172 . 4) (f165 . -28) (f166 . -24) (f167 . -20) (f168 . -16) (f169 . -12) (f170 . -8) (f171 . -4) (f172 . 0))
# var=f218
    movl -20(%esp), %eax  # stack load f218
>>>>>>> fix-implicit-begins
# end emit-variable-ref
    cmp $63, %eax
    mov $0, %eax
    sete %al
    movzbl %al, %eax
    sal $6, %al
    or $47, %al
    cmp $47, %al
    je _L_1344
# emit-tail-expr
# si=-32
# env=((f220 . -28) (f219 . -24) (f218 . -20) (f220 . -16) (f219 . -12) (f218 . -8) (f166 . 28) (f168 . 24) (f167 . 20) (f169 . 16) (f170 . 12) (f171 . 8) (f172 . 4) (f165 . -28) (f166 . -24) (f167 . -20) (f168 . -16) (f169 . -12) (f170 . -8) (f171 . -4) (f172 . 0))
# expr=(begin ((vector-ref f171 0) f219))
# tail-begin (begin ((vector-ref f171 0) f219))
#   env=((f220 . -28) (f219 . -24) (f218 . -20) (f220 . -16) (f219 . -12) (f218 . -8) (f166 . 28) (f168 . 24) (f167 . 20) (f169 . 16) (f170 . 12) (f171 . 8) (f172 . 4) (f165 . -28) (f166 . -24) (f167 . -20) (f168 . -16) (f169 . -12) (f170 . -8) (f171 . -4) (f172 . 0))
# emit-tail-expr
# si=-32
<<<<<<< HEAD
# env=((f311005 . -28) (f311006 . -24) (f311007 . -20) (f311005 . -16) (f311006 . -12) (f311007 . -8) (f310953 . 28) (f310955 . 24) (f310954 . 20) (f310956 . 16) (f310957 . 12) (f310958 . 8) (f310959 . 4) (f310952 . -28) (f310953 . -24) (f310954 . -20) (f310955 . -16) (f310956 . -12) (f310957 . -8) (f310958 . -4) (f310959 . 0))
# expr=((vector-ref f310958 0) f311006)
# emit-tail-funcall
#    si   =-32
#    env  = ((f311005 . -28) (f311006 . -24) (f311007 . -20) (f311005 . -16) (f311006 . -12) (f311007 . -8) (f310953 . 28) (f310955 . 24) (f310954 . 20) (f310956 . 16) (f310957 . 12) (f310958 . 8) (f310959 . 4) (f310952 . -28) (f310953 . -24) (f310954 . -20) (f310955 . -16) (f310956 . -12) (f310957 . -8) (f310958 . -4) (f310959 . 0))
#    expr = (funcall (vector-ref f310958 0) f311006)
# emit-expr (vector-ref f310958 0)
# emit-expr f310958
# emit-variable-ref
# env=((f311005 . -28) (f311006 . -24) (f311007 . -20) (f311005 . -16) (f311006 . -12) (f311007 . -8) (f310953 . 28) (f310955 . 24) (f310954 . 20) (f310956 . 16) (f310957 . 12) (f310958 . 8) (f310959 . 4) (f310952 . -28) (f310953 . -24) (f310954 . -20) (f310955 . -16) (f310956 . -12) (f310957 . -8) (f310958 . -4) (f310959 . 0))
# var=f310958
    movl 6(%edi), %eax  # frame load f310958
=======
# env=((f220 . -28) (f219 . -24) (f218 . -20) (f220 . -16) (f219 . -12) (f218 . -8) (f166 . 28) (f168 . 24) (f167 . 20) (f169 . 16) (f170 . 12) (f171 . 8) (f172 . 4) (f165 . -28) (f166 . -24) (f167 . -20) (f168 . -16) (f169 . -12) (f170 . -8) (f171 . -4) (f172 . 0))
# expr=((vector-ref f171 0) f219)
# emit-tail-funcall
#    si   =-32
#    env  = ((f220 . -28) (f219 . -24) (f218 . -20) (f220 . -16) (f219 . -12) (f218 . -8) (f166 . 28) (f168 . 24) (f167 . 20) (f169 . 16) (f170 . 12) (f171 . 8) (f172 . 4) (f165 . -28) (f166 . -24) (f167 . -20) (f168 . -16) (f169 . -12) (f170 . -8) (f171 . -4) (f172 . 0))
#    expr = (funcall (vector-ref f171 0) f219)
# emit-expr (vector-ref f171 0)
# emit-expr f171
# emit-variable-ref
# env=((f220 . -28) (f219 . -24) (f218 . -20) (f220 . -16) (f219 . -12) (f218 . -8) (f166 . 28) (f168 . 24) (f167 . 20) (f169 . 16) (f170 . 12) (f171 . 8) (f172 . 4) (f165 . -28) (f166 . -24) (f167 . -20) (f168 . -16) (f169 . -12) (f170 . -8) (f171 . -4) (f172 . 0))
# var=f171
    movl 6(%edi), %eax  # frame load f171
>>>>>>> fix-implicit-begins
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1346
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1346:
    movl %eax, -32(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1347"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1347:
# check bounds on vector index
    movl -32(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1349
    cmp  $0,%eax
    jge _L_1348
_L_1349:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1348:
    movl -32(%esp), %esi
    movl -1(%eax,%esi), %eax
   movl %eax,  -32(%esp)  # stash funcall-oper in next closure slot
# emit-expr f219
# emit-variable-ref
<<<<<<< HEAD
# env=((f311005 . -28) (f311006 . -24) (f311007 . -20) (f311005 . -16) (f311006 . -12) (f311007 . -8) (f310953 . 28) (f310955 . 24) (f310954 . 20) (f310956 . 16) (f310957 . 12) (f310958 . 8) (f310959 . 4) (f310952 . -28) (f310953 . -24) (f310954 . -20) (f310955 . -16) (f310956 . -12) (f310957 . -8) (f310958 . -4) (f310959 . 0))
# var=f311006
    movl -24(%esp), %eax  # stack load f311006
=======
# env=((f220 . -28) (f219 . -24) (f218 . -20) (f220 . -16) (f219 . -12) (f218 . -8) (f166 . 28) (f168 . 24) (f167 . 20) (f169 . 16) (f170 . 12) (f171 . 8) (f172 . 4) (f165 . -28) (f166 . -24) (f167 . -20) (f168 . -16) (f169 . -12) (f170 . -8) (f171 . -4) (f172 . 0))
# var=f219
    movl -24(%esp), %eax  # stack load f219
>>>>>>> fix-implicit-begins
# end emit-variable-ref
    mov %eax, -36(%esp)    # arg f219
    movl -32(%esp), %edi   # load new closure to %edi
# emit-shift-args:  size=2   si=-32  delta=28
    mov -32(%esp), %ebx  # shift frame cell
    mov %ebx, -4(%esp)  # down to base
# emit-shift-args:  size=1   si=-36  delta=28
    mov -36(%esp), %ebx  # shift frame cell
    mov %ebx, -8(%esp)  # down to base
# emit-shift-args:  size=0   si=-40  delta=28
    movl $4,%eax   # save arg count
    jmp *-2(%edi)  # tail-funcall
     ret   # return thru stack
    jmp _L_1345
_L_1344:
# emit-tail-expr
# si=-32
<<<<<<< HEAD
# env=((f311005 . -28) (f311006 . -24) (f311007 . -20) (f311005 . -16) (f311006 . -12) (f311007 . -8) (f310953 . 28) (f310955 . 24) (f310954 . 20) (f310956 . 16) (f310957 . 12) (f310958 . 8) (f310959 . 4) (f310952 . -28) (f310953 . -24) (f310954 . -20) (f310955 . -16) (f310956 . -12) (f310957 . -8) (f310958 . -4) (f310959 . 0))
# expr=(if (char? f311007) (if f311005 ((primitive-ref write-char) f311007 f311006) ((vector-ref f310957 0) f311007 f311006)) (if (fixnum? f311007) ((vector-ref f310956 0) f311007 f311006) (if (string? f311007) (if f311005 ((vector-ref f310954 0) f311007 f311006) ((vector-ref f310955 0) f311007 f311006)) (if (pair? f311007) ((vector-ref f310953 0) f311007 f311006) ((primitive-ref error) ((primitive-ref string->symbol) "write") "unrecognized expression")))))
# emit-expr (char? f311007)
# emit-expr f311007
# emit-variable-ref
# env=((f311005 . -28) (f311006 . -24) (f311007 . -20) (f311005 . -16) (f311006 . -12) (f311007 . -8) (f310953 . 28) (f310955 . 24) (f310954 . 20) (f310956 . 16) (f310957 . 12) (f310958 . 8) (f310959 . 4) (f310952 . -28) (f310953 . -24) (f310954 . -20) (f310955 . -16) (f310956 . -12) (f310957 . -8) (f310958 . -4) (f310959 . 0))
# var=f311007
    movl -20(%esp), %eax  # stack load f311007
=======
# env=((f220 . -28) (f219 . -24) (f218 . -20) (f220 . -16) (f219 . -12) (f218 . -8) (f166 . 28) (f168 . 24) (f167 . 20) (f169 . 16) (f170 . 12) (f171 . 8) (f172 . 4) (f165 . -28) (f166 . -24) (f167 . -20) (f168 . -16) (f169 . -12) (f170 . -8) (f171 . -4) (f172 . 0))
# expr=(if (char? f218) (begin (if f220 ((primitive-ref write-char) f218 f219) ((vector-ref f170 0) f218 f219))) (if (fixnum? f218) (begin ((vector-ref f169 0) f218 f219)) (if (string? f218) (begin (if f220 ((vector-ref f167 0) f218 f219) ((vector-ref f168 0) f218 f219))) (if (pair? f218) (begin ((vector-ref f166 0) f218 f219)) (begin ((primitive-ref error) ((primitive-ref string->symbol) "write") "unrecognized expression"))))))
# emit-expr (char? f218)
# emit-expr f218
# emit-variable-ref
# env=((f220 . -28) (f219 . -24) (f218 . -20) (f220 . -16) (f219 . -12) (f218 . -8) (f166 . 28) (f168 . 24) (f167 . 20) (f169 . 16) (f170 . 12) (f171 . 8) (f172 . 4) (f165 . -28) (f166 . -24) (f167 . -20) (f168 . -16) (f169 . -12) (f170 . -8) (f171 . -4) (f172 . 0))
# var=f218
    movl -20(%esp), %eax  # stack load f218
>>>>>>> fix-implicit-begins
# end emit-variable-ref
    and $255, %eax
    cmp $15, %eax
    sete %al
    movzbl %al, %eax
    sal $6, %al
    or $47, %al
    cmp $47, %al
    je _L_1350
# emit-tail-expr
# si=-32
# env=((f220 . -28) (f219 . -24) (f218 . -20) (f220 . -16) (f219 . -12) (f218 . -8) (f166 . 28) (f168 . 24) (f167 . 20) (f169 . 16) (f170 . 12) (f171 . 8) (f172 . 4) (f165 . -28) (f166 . -24) (f167 . -20) (f168 . -16) (f169 . -12) (f170 . -8) (f171 . -4) (f172 . 0))
# expr=(begin (if f220 ((primitive-ref write-char) f218 f219) ((vector-ref f170 0) f218 f219)))
# tail-begin (begin (if f220 ((primitive-ref write-char) f218 f219) ((vector-ref f170 0) f218 f219)))
#   env=((f220 . -28) (f219 . -24) (f218 . -20) (f220 . -16) (f219 . -12) (f218 . -8) (f166 . 28) (f168 . 24) (f167 . 20) (f169 . 16) (f170 . 12) (f171 . 8) (f172 . 4) (f165 . -28) (f166 . -24) (f167 . -20) (f168 . -16) (f169 . -12) (f170 . -8) (f171 . -4) (f172 . 0))
# emit-tail-expr
# si=-32
<<<<<<< HEAD
# env=((f311005 . -28) (f311006 . -24) (f311007 . -20) (f311005 . -16) (f311006 . -12) (f311007 . -8) (f310953 . 28) (f310955 . 24) (f310954 . 20) (f310956 . 16) (f310957 . 12) (f310958 . 8) (f310959 . 4) (f310952 . -28) (f310953 . -24) (f310954 . -20) (f310955 . -16) (f310956 . -12) (f310957 . -8) (f310958 . -4) (f310959 . 0))
# expr=(if f311005 ((primitive-ref write-char) f311007 f311006) ((vector-ref f310957 0) f311007 f311006))
# emit-expr f311005
# emit-variable-ref
# env=((f311005 . -28) (f311006 . -24) (f311007 . -20) (f311005 . -16) (f311006 . -12) (f311007 . -8) (f310953 . 28) (f310955 . 24) (f310954 . 20) (f310956 . 16) (f310957 . 12) (f310958 . 8) (f310959 . 4) (f310952 . -28) (f310953 . -24) (f310954 . -20) (f310955 . -16) (f310956 . -12) (f310957 . -8) (f310958 . -4) (f310959 . 0))
# var=f311005
    movl -28(%esp), %eax  # stack load f311005
=======
# env=((f220 . -28) (f219 . -24) (f218 . -20) (f220 . -16) (f219 . -12) (f218 . -8) (f166 . 28) (f168 . 24) (f167 . 20) (f169 . 16) (f170 . 12) (f171 . 8) (f172 . 4) (f165 . -28) (f166 . -24) (f167 . -20) (f168 . -16) (f169 . -12) (f170 . -8) (f171 . -4) (f172 . 0))
# expr=(if f220 ((primitive-ref write-char) f218 f219) ((vector-ref f170 0) f218 f219))
# emit-expr f220
# emit-variable-ref
# env=((f220 . -28) (f219 . -24) (f218 . -20) (f220 . -16) (f219 . -12) (f218 . -8) (f166 . 28) (f168 . 24) (f167 . 20) (f169 . 16) (f170 . 12) (f171 . 8) (f172 . 4) (f165 . -28) (f166 . -24) (f167 . -20) (f168 . -16) (f169 . -12) (f170 . -8) (f171 . -4) (f172 . 0))
# var=f220
    movl -28(%esp), %eax  # stack load f220
>>>>>>> fix-implicit-begins
# end emit-variable-ref
    cmp $47, %al
    je _L_1352
# emit-tail-expr
# si=-32
<<<<<<< HEAD
# env=((f311005 . -28) (f311006 . -24) (f311007 . -20) (f311005 . -16) (f311006 . -12) (f311007 . -8) (f310953 . 28) (f310955 . 24) (f310954 . 20) (f310956 . 16) (f310957 . 12) (f310958 . 8) (f310959 . 4) (f310952 . -28) (f310953 . -24) (f310954 . -20) (f310955 . -16) (f310956 . -12) (f310957 . -8) (f310958 . -4) (f310959 . 0))
# expr=((primitive-ref write-char) f311007 f311006)
# emit-tail-funcall
#    si   =-32
#    env  = ((f311005 . -28) (f311006 . -24) (f311007 . -20) (f311005 . -16) (f311006 . -12) (f311007 . -8) (f310953 . 28) (f310955 . 24) (f310954 . 20) (f310956 . 16) (f310957 . 12) (f310958 . 8) (f310959 . 4) (f310952 . -28) (f310953 . -24) (f310954 . -20) (f310955 . -16) (f310956 . -12) (f310957 . -8) (f310958 . -4) (f310959 . 0))
#    expr = (funcall (primitive-ref write-char) f311007 f311006)
=======
# env=((f220 . -28) (f219 . -24) (f218 . -20) (f220 . -16) (f219 . -12) (f218 . -8) (f166 . 28) (f168 . 24) (f167 . 20) (f169 . 16) (f170 . 12) (f171 . 8) (f172 . 4) (f165 . -28) (f166 . -24) (f167 . -20) (f168 . -16) (f169 . -12) (f170 . -8) (f171 . -4) (f172 . 0))
# expr=((primitive-ref write-char) f218 f219)
# emit-tail-funcall
#    si   =-32
#    env  = ((f220 . -28) (f219 . -24) (f218 . -20) (f220 . -16) (f219 . -12) (f218 . -8) (f166 . 28) (f168 . 24) (f167 . 20) (f169 . 16) (f170 . 12) (f171 . 8) (f172 . 4) (f165 . -28) (f166 . -24) (f167 . -20) (f168 . -16) (f169 . -12) (f170 . -8) (f171 . -4) (f172 . 0))
#    expr = (funcall (primitive-ref write-char) f218 f219)
>>>>>>> fix-implicit-begins
# emit-expr (primitive-ref write-char)
    .extern mrc_write$mchar
    movl mrc_write$mchar,%eax
   movl %eax,  -32(%esp)  # stash funcall-oper in next closure slot
<<<<<<< HEAD
# emit-expr f311007
# emit-variable-ref
# env=((f311005 . -28) (f311006 . -24) (f311007 . -20) (f311005 . -16) (f311006 . -12) (f311007 . -8) (f310953 . 28) (f310955 . 24) (f310954 . 20) (f310956 . 16) (f310957 . 12) (f310958 . 8) (f310959 . 4) (f310952 . -28) (f310953 . -24) (f310954 . -20) (f310955 . -16) (f310956 . -12) (f310957 . -8) (f310958 . -4) (f310959 . 0))
# var=f311007
    movl -20(%esp), %eax  # stack load f311007
# end emit-variable-ref
    mov %eax, -36(%esp)    # arg f311007
# emit-expr f311006
# emit-variable-ref
# env=((f311005 . -28) (f311006 . -24) (f311007 . -20) (f311005 . -16) (f311006 . -12) (f311007 . -8) (f310953 . 28) (f310955 . 24) (f310954 . 20) (f310956 . 16) (f310957 . 12) (f310958 . 8) (f310959 . 4) (f310952 . -28) (f310953 . -24) (f310954 . -20) (f310955 . -16) (f310956 . -12) (f310957 . -8) (f310958 . -4) (f310959 . 0))
# var=f311006
    movl -24(%esp), %eax  # stack load f311006
=======
# emit-expr f218
# emit-variable-ref
# env=((f220 . -28) (f219 . -24) (f218 . -20) (f220 . -16) (f219 . -12) (f218 . -8) (f166 . 28) (f168 . 24) (f167 . 20) (f169 . 16) (f170 . 12) (f171 . 8) (f172 . 4) (f165 . -28) (f166 . -24) (f167 . -20) (f168 . -16) (f169 . -12) (f170 . -8) (f171 . -4) (f172 . 0))
# var=f218
    movl -20(%esp), %eax  # stack load f218
# end emit-variable-ref
    mov %eax, -36(%esp)    # arg f218
# emit-expr f219
# emit-variable-ref
# env=((f220 . -28) (f219 . -24) (f218 . -20) (f220 . -16) (f219 . -12) (f218 . -8) (f166 . 28) (f168 . 24) (f167 . 20) (f169 . 16) (f170 . 12) (f171 . 8) (f172 . 4) (f165 . -28) (f166 . -24) (f167 . -20) (f168 . -16) (f169 . -12) (f170 . -8) (f171 . -4) (f172 . 0))
# var=f219
    movl -24(%esp), %eax  # stack load f219
>>>>>>> fix-implicit-begins
# end emit-variable-ref
    mov %eax, -40(%esp)    # arg f219
    movl -32(%esp), %edi   # load new closure to %edi
# emit-shift-args:  size=3   si=-32  delta=28
    mov -32(%esp), %ebx  # shift frame cell
    mov %ebx, -4(%esp)  # down to base
# emit-shift-args:  size=2   si=-36  delta=28
    mov -36(%esp), %ebx  # shift frame cell
    mov %ebx, -8(%esp)  # down to base
# emit-shift-args:  size=1   si=-40  delta=28
    mov -40(%esp), %ebx  # shift frame cell
    mov %ebx, -12(%esp)  # down to base
# emit-shift-args:  size=0   si=-44  delta=28
    movl $8,%eax   # save arg count
    jmp *-2(%edi)  # tail-funcall
    jmp _L_1353
_L_1352:
# emit-tail-expr
# si=-32
<<<<<<< HEAD
# env=((f311005 . -28) (f311006 . -24) (f311007 . -20) (f311005 . -16) (f311006 . -12) (f311007 . -8) (f310953 . 28) (f310955 . 24) (f310954 . 20) (f310956 . 16) (f310957 . 12) (f310958 . 8) (f310959 . 4) (f310952 . -28) (f310953 . -24) (f310954 . -20) (f310955 . -16) (f310956 . -12) (f310957 . -8) (f310958 . -4) (f310959 . 0))
# expr=((vector-ref f310957 0) f311007 f311006)
# emit-tail-funcall
#    si   =-32
#    env  = ((f311005 . -28) (f311006 . -24) (f311007 . -20) (f311005 . -16) (f311006 . -12) (f311007 . -8) (f310953 . 28) (f310955 . 24) (f310954 . 20) (f310956 . 16) (f310957 . 12) (f310958 . 8) (f310959 . 4) (f310952 . -28) (f310953 . -24) (f310954 . -20) (f310955 . -16) (f310956 . -12) (f310957 . -8) (f310958 . -4) (f310959 . 0))
#    expr = (funcall (vector-ref f310957 0) f311007 f311006)
# emit-expr (vector-ref f310957 0)
# emit-expr f310957
# emit-variable-ref
# env=((f311005 . -28) (f311006 . -24) (f311007 . -20) (f311005 . -16) (f311006 . -12) (f311007 . -8) (f310953 . 28) (f310955 . 24) (f310954 . 20) (f310956 . 16) (f310957 . 12) (f310958 . 8) (f310959 . 4) (f310952 . -28) (f310953 . -24) (f310954 . -20) (f310955 . -16) (f310956 . -12) (f310957 . -8) (f310958 . -4) (f310959 . 0))
# var=f310957
    movl 10(%edi), %eax  # frame load f310957
=======
# env=((f220 . -28) (f219 . -24) (f218 . -20) (f220 . -16) (f219 . -12) (f218 . -8) (f166 . 28) (f168 . 24) (f167 . 20) (f169 . 16) (f170 . 12) (f171 . 8) (f172 . 4) (f165 . -28) (f166 . -24) (f167 . -20) (f168 . -16) (f169 . -12) (f170 . -8) (f171 . -4) (f172 . 0))
# expr=((vector-ref f170 0) f218 f219)
# emit-tail-funcall
#    si   =-32
#    env  = ((f220 . -28) (f219 . -24) (f218 . -20) (f220 . -16) (f219 . -12) (f218 . -8) (f166 . 28) (f168 . 24) (f167 . 20) (f169 . 16) (f170 . 12) (f171 . 8) (f172 . 4) (f165 . -28) (f166 . -24) (f167 . -20) (f168 . -16) (f169 . -12) (f170 . -8) (f171 . -4) (f172 . 0))
#    expr = (funcall (vector-ref f170 0) f218 f219)
# emit-expr (vector-ref f170 0)
# emit-expr f170
# emit-variable-ref
# env=((f220 . -28) (f219 . -24) (f218 . -20) (f220 . -16) (f219 . -12) (f218 . -8) (f166 . 28) (f168 . 24) (f167 . 20) (f169 . 16) (f170 . 12) (f171 . 8) (f172 . 4) (f165 . -28) (f166 . -24) (f167 . -20) (f168 . -16) (f169 . -12) (f170 . -8) (f171 . -4) (f172 . 0))
# var=f170
    movl 10(%edi), %eax  # frame load f170
>>>>>>> fix-implicit-begins
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1354
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1354:
    movl %eax, -32(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1355"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1355:
# check bounds on vector index
    movl -32(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1357
    cmp  $0,%eax
    jge _L_1356
_L_1357:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1356:
    movl -32(%esp), %esi
    movl -1(%eax,%esi), %eax
   movl %eax,  -32(%esp)  # stash funcall-oper in next closure slot
<<<<<<< HEAD
# emit-expr f311007
# emit-variable-ref
# env=((f311005 . -28) (f311006 . -24) (f311007 . -20) (f311005 . -16) (f311006 . -12) (f311007 . -8) (f310953 . 28) (f310955 . 24) (f310954 . 20) (f310956 . 16) (f310957 . 12) (f310958 . 8) (f310959 . 4) (f310952 . -28) (f310953 . -24) (f310954 . -20) (f310955 . -16) (f310956 . -12) (f310957 . -8) (f310958 . -4) (f310959 . 0))
# var=f311007
    movl -20(%esp), %eax  # stack load f311007
# end emit-variable-ref
    mov %eax, -36(%esp)    # arg f311007
# emit-expr f311006
# emit-variable-ref
# env=((f311005 . -28) (f311006 . -24) (f311007 . -20) (f311005 . -16) (f311006 . -12) (f311007 . -8) (f310953 . 28) (f310955 . 24) (f310954 . 20) (f310956 . 16) (f310957 . 12) (f310958 . 8) (f310959 . 4) (f310952 . -28) (f310953 . -24) (f310954 . -20) (f310955 . -16) (f310956 . -12) (f310957 . -8) (f310958 . -4) (f310959 . 0))
# var=f311006
    movl -24(%esp), %eax  # stack load f311006
=======
# emit-expr f218
# emit-variable-ref
# env=((f220 . -28) (f219 . -24) (f218 . -20) (f220 . -16) (f219 . -12) (f218 . -8) (f166 . 28) (f168 . 24) (f167 . 20) (f169 . 16) (f170 . 12) (f171 . 8) (f172 . 4) (f165 . -28) (f166 . -24) (f167 . -20) (f168 . -16) (f169 . -12) (f170 . -8) (f171 . -4) (f172 . 0))
# var=f218
    movl -20(%esp), %eax  # stack load f218
# end emit-variable-ref
    mov %eax, -36(%esp)    # arg f218
# emit-expr f219
# emit-variable-ref
# env=((f220 . -28) (f219 . -24) (f218 . -20) (f220 . -16) (f219 . -12) (f218 . -8) (f166 . 28) (f168 . 24) (f167 . 20) (f169 . 16) (f170 . 12) (f171 . 8) (f172 . 4) (f165 . -28) (f166 . -24) (f167 . -20) (f168 . -16) (f169 . -12) (f170 . -8) (f171 . -4) (f172 . 0))
# var=f219
    movl -24(%esp), %eax  # stack load f219
>>>>>>> fix-implicit-begins
# end emit-variable-ref
    mov %eax, -40(%esp)    # arg f219
    movl -32(%esp), %edi   # load new closure to %edi
# emit-shift-args:  size=3   si=-32  delta=28
    mov -32(%esp), %ebx  # shift frame cell
    mov %ebx, -4(%esp)  # down to base
# emit-shift-args:  size=2   si=-36  delta=28
    mov -36(%esp), %ebx  # shift frame cell
    mov %ebx, -8(%esp)  # down to base
# emit-shift-args:  size=1   si=-40  delta=28
    mov -40(%esp), %ebx  # shift frame cell
    mov %ebx, -12(%esp)  # down to base
# emit-shift-args:  size=0   si=-44  delta=28
    movl $8,%eax   # save arg count
    jmp *-2(%edi)  # tail-funcall
_L_1353:
     ret   # return thru stack
    jmp _L_1351
_L_1350:
# emit-tail-expr
# si=-32
<<<<<<< HEAD
# env=((f311005 . -28) (f311006 . -24) (f311007 . -20) (f311005 . -16) (f311006 . -12) (f311007 . -8) (f310953 . 28) (f310955 . 24) (f310954 . 20) (f310956 . 16) (f310957 . 12) (f310958 . 8) (f310959 . 4) (f310952 . -28) (f310953 . -24) (f310954 . -20) (f310955 . -16) (f310956 . -12) (f310957 . -8) (f310958 . -4) (f310959 . 0))
# expr=(if (fixnum? f311007) ((vector-ref f310956 0) f311007 f311006) (if (string? f311007) (if f311005 ((vector-ref f310954 0) f311007 f311006) ((vector-ref f310955 0) f311007 f311006)) (if (pair? f311007) ((vector-ref f310953 0) f311007 f311006) ((primitive-ref error) ((primitive-ref string->symbol) "write") "unrecognized expression"))))
# emit-expr (fixnum? f311007)
# emit-expr f311007
# emit-variable-ref
# env=((f311005 . -28) (f311006 . -24) (f311007 . -20) (f311005 . -16) (f311006 . -12) (f311007 . -8) (f310953 . 28) (f310955 . 24) (f310954 . 20) (f310956 . 16) (f310957 . 12) (f310958 . 8) (f310959 . 4) (f310952 . -28) (f310953 . -24) (f310954 . -20) (f310955 . -16) (f310956 . -12) (f310957 . -8) (f310958 . -4) (f310959 . 0))
# var=f311007
    movl -20(%esp), %eax  # stack load f311007
=======
# env=((f220 . -28) (f219 . -24) (f218 . -20) (f220 . -16) (f219 . -12) (f218 . -8) (f166 . 28) (f168 . 24) (f167 . 20) (f169 . 16) (f170 . 12) (f171 . 8) (f172 . 4) (f165 . -28) (f166 . -24) (f167 . -20) (f168 . -16) (f169 . -12) (f170 . -8) (f171 . -4) (f172 . 0))
# expr=(if (fixnum? f218) (begin ((vector-ref f169 0) f218 f219)) (if (string? f218) (begin (if f220 ((vector-ref f167 0) f218 f219) ((vector-ref f168 0) f218 f219))) (if (pair? f218) (begin ((vector-ref f166 0) f218 f219)) (begin ((primitive-ref error) ((primitive-ref string->symbol) "write") "unrecognized expression")))))
# emit-expr (fixnum? f218)
# emit-expr f218
# emit-variable-ref
# env=((f220 . -28) (f219 . -24) (f218 . -20) (f220 . -16) (f219 . -12) (f218 . -8) (f166 . 28) (f168 . 24) (f167 . 20) (f169 . 16) (f170 . 12) (f171 . 8) (f172 . 4) (f165 . -28) (f166 . -24) (f167 . -20) (f168 . -16) (f169 . -12) (f170 . -8) (f171 . -4) (f172 . 0))
# var=f218
    movl -20(%esp), %eax  # stack load f218
>>>>>>> fix-implicit-begins
# end emit-variable-ref
    and $3, %al
    cmp $0, %al
    sete %al
    movzbl %al, %eax
    sal $6, %al
    or $47, %al
    cmp $47, %al
    je _L_1358
# emit-tail-expr
# si=-32
# env=((f220 . -28) (f219 . -24) (f218 . -20) (f220 . -16) (f219 . -12) (f218 . -8) (f166 . 28) (f168 . 24) (f167 . 20) (f169 . 16) (f170 . 12) (f171 . 8) (f172 . 4) (f165 . -28) (f166 . -24) (f167 . -20) (f168 . -16) (f169 . -12) (f170 . -8) (f171 . -4) (f172 . 0))
# expr=(begin ((vector-ref f169 0) f218 f219))
# tail-begin (begin ((vector-ref f169 0) f218 f219))
#   env=((f220 . -28) (f219 . -24) (f218 . -20) (f220 . -16) (f219 . -12) (f218 . -8) (f166 . 28) (f168 . 24) (f167 . 20) (f169 . 16) (f170 . 12) (f171 . 8) (f172 . 4) (f165 . -28) (f166 . -24) (f167 . -20) (f168 . -16) (f169 . -12) (f170 . -8) (f171 . -4) (f172 . 0))
# emit-tail-expr
# si=-32
<<<<<<< HEAD
# env=((f311005 . -28) (f311006 . -24) (f311007 . -20) (f311005 . -16) (f311006 . -12) (f311007 . -8) (f310953 . 28) (f310955 . 24) (f310954 . 20) (f310956 . 16) (f310957 . 12) (f310958 . 8) (f310959 . 4) (f310952 . -28) (f310953 . -24) (f310954 . -20) (f310955 . -16) (f310956 . -12) (f310957 . -8) (f310958 . -4) (f310959 . 0))
# expr=((vector-ref f310956 0) f311007 f311006)
# emit-tail-funcall
#    si   =-32
#    env  = ((f311005 . -28) (f311006 . -24) (f311007 . -20) (f311005 . -16) (f311006 . -12) (f311007 . -8) (f310953 . 28) (f310955 . 24) (f310954 . 20) (f310956 . 16) (f310957 . 12) (f310958 . 8) (f310959 . 4) (f310952 . -28) (f310953 . -24) (f310954 . -20) (f310955 . -16) (f310956 . -12) (f310957 . -8) (f310958 . -4) (f310959 . 0))
#    expr = (funcall (vector-ref f310956 0) f311007 f311006)
# emit-expr (vector-ref f310956 0)
# emit-expr f310956
# emit-variable-ref
# env=((f311005 . -28) (f311006 . -24) (f311007 . -20) (f311005 . -16) (f311006 . -12) (f311007 . -8) (f310953 . 28) (f310955 . 24) (f310954 . 20) (f310956 . 16) (f310957 . 12) (f310958 . 8) (f310959 . 4) (f310952 . -28) (f310953 . -24) (f310954 . -20) (f310955 . -16) (f310956 . -12) (f310957 . -8) (f310958 . -4) (f310959 . 0))
# var=f310956
    movl 14(%edi), %eax  # frame load f310956
=======
# env=((f220 . -28) (f219 . -24) (f218 . -20) (f220 . -16) (f219 . -12) (f218 . -8) (f166 . 28) (f168 . 24) (f167 . 20) (f169 . 16) (f170 . 12) (f171 . 8) (f172 . 4) (f165 . -28) (f166 . -24) (f167 . -20) (f168 . -16) (f169 . -12) (f170 . -8) (f171 . -4) (f172 . 0))
# expr=((vector-ref f169 0) f218 f219)
# emit-tail-funcall
#    si   =-32
#    env  = ((f220 . -28) (f219 . -24) (f218 . -20) (f220 . -16) (f219 . -12) (f218 . -8) (f166 . 28) (f168 . 24) (f167 . 20) (f169 . 16) (f170 . 12) (f171 . 8) (f172 . 4) (f165 . -28) (f166 . -24) (f167 . -20) (f168 . -16) (f169 . -12) (f170 . -8) (f171 . -4) (f172 . 0))
#    expr = (funcall (vector-ref f169 0) f218 f219)
# emit-expr (vector-ref f169 0)
# emit-expr f169
# emit-variable-ref
# env=((f220 . -28) (f219 . -24) (f218 . -20) (f220 . -16) (f219 . -12) (f218 . -8) (f166 . 28) (f168 . 24) (f167 . 20) (f169 . 16) (f170 . 12) (f171 . 8) (f172 . 4) (f165 . -28) (f166 . -24) (f167 . -20) (f168 . -16) (f169 . -12) (f170 . -8) (f171 . -4) (f172 . 0))
# var=f169
    movl 14(%edi), %eax  # frame load f169
>>>>>>> fix-implicit-begins
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1360
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1360:
    movl %eax, -32(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1361"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1361:
# check bounds on vector index
    movl -32(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1363
    cmp  $0,%eax
    jge _L_1362
_L_1363:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1362:
    movl -32(%esp), %esi
    movl -1(%eax,%esi), %eax
   movl %eax,  -32(%esp)  # stash funcall-oper in next closure slot
<<<<<<< HEAD
# emit-expr f311007
# emit-variable-ref
# env=((f311005 . -28) (f311006 . -24) (f311007 . -20) (f311005 . -16) (f311006 . -12) (f311007 . -8) (f310953 . 28) (f310955 . 24) (f310954 . 20) (f310956 . 16) (f310957 . 12) (f310958 . 8) (f310959 . 4) (f310952 . -28) (f310953 . -24) (f310954 . -20) (f310955 . -16) (f310956 . -12) (f310957 . -8) (f310958 . -4) (f310959 . 0))
# var=f311007
    movl -20(%esp), %eax  # stack load f311007
# end emit-variable-ref
    mov %eax, -36(%esp)    # arg f311007
# emit-expr f311006
# emit-variable-ref
# env=((f311005 . -28) (f311006 . -24) (f311007 . -20) (f311005 . -16) (f311006 . -12) (f311007 . -8) (f310953 . 28) (f310955 . 24) (f310954 . 20) (f310956 . 16) (f310957 . 12) (f310958 . 8) (f310959 . 4) (f310952 . -28) (f310953 . -24) (f310954 . -20) (f310955 . -16) (f310956 . -12) (f310957 . -8) (f310958 . -4) (f310959 . 0))
# var=f311006
    movl -24(%esp), %eax  # stack load f311006
=======
# emit-expr f218
# emit-variable-ref
# env=((f220 . -28) (f219 . -24) (f218 . -20) (f220 . -16) (f219 . -12) (f218 . -8) (f166 . 28) (f168 . 24) (f167 . 20) (f169 . 16) (f170 . 12) (f171 . 8) (f172 . 4) (f165 . -28) (f166 . -24) (f167 . -20) (f168 . -16) (f169 . -12) (f170 . -8) (f171 . -4) (f172 . 0))
# var=f218
    movl -20(%esp), %eax  # stack load f218
# end emit-variable-ref
    mov %eax, -36(%esp)    # arg f218
# emit-expr f219
# emit-variable-ref
# env=((f220 . -28) (f219 . -24) (f218 . -20) (f220 . -16) (f219 . -12) (f218 . -8) (f166 . 28) (f168 . 24) (f167 . 20) (f169 . 16) (f170 . 12) (f171 . 8) (f172 . 4) (f165 . -28) (f166 . -24) (f167 . -20) (f168 . -16) (f169 . -12) (f170 . -8) (f171 . -4) (f172 . 0))
# var=f219
    movl -24(%esp), %eax  # stack load f219
>>>>>>> fix-implicit-begins
# end emit-variable-ref
    mov %eax, -40(%esp)    # arg f219
    movl -32(%esp), %edi   # load new closure to %edi
# emit-shift-args:  size=3   si=-32  delta=28
    mov -32(%esp), %ebx  # shift frame cell
    mov %ebx, -4(%esp)  # down to base
# emit-shift-args:  size=2   si=-36  delta=28
    mov -36(%esp), %ebx  # shift frame cell
    mov %ebx, -8(%esp)  # down to base
# emit-shift-args:  size=1   si=-40  delta=28
    mov -40(%esp), %ebx  # shift frame cell
    mov %ebx, -12(%esp)  # down to base
# emit-shift-args:  size=0   si=-44  delta=28
    movl $8,%eax   # save arg count
    jmp *-2(%edi)  # tail-funcall
     ret   # return thru stack
    jmp _L_1359
_L_1358:
# emit-tail-expr
# si=-32
<<<<<<< HEAD
# env=((f311005 . -28) (f311006 . -24) (f311007 . -20) (f311005 . -16) (f311006 . -12) (f311007 . -8) (f310953 . 28) (f310955 . 24) (f310954 . 20) (f310956 . 16) (f310957 . 12) (f310958 . 8) (f310959 . 4) (f310952 . -28) (f310953 . -24) (f310954 . -20) (f310955 . -16) (f310956 . -12) (f310957 . -8) (f310958 . -4) (f310959 . 0))
# expr=(if (string? f311007) (if f311005 ((vector-ref f310954 0) f311007 f311006) ((vector-ref f310955 0) f311007 f311006)) (if (pair? f311007) ((vector-ref f310953 0) f311007 f311006) ((primitive-ref error) ((primitive-ref string->symbol) "write") "unrecognized expression")))
# emit-expr (string? f311007)
# emit-expr f311007
# emit-variable-ref
# env=((f311005 . -28) (f311006 . -24) (f311007 . -20) (f311005 . -16) (f311006 . -12) (f311007 . -8) (f310953 . 28) (f310955 . 24) (f310954 . 20) (f310956 . 16) (f310957 . 12) (f310958 . 8) (f310959 . 4) (f310952 . -28) (f310953 . -24) (f310954 . -20) (f310955 . -16) (f310956 . -12) (f310957 . -8) (f310958 . -4) (f310959 . 0))
# var=f311007
    movl -20(%esp), %eax  # stack load f311007
=======
# env=((f220 . -28) (f219 . -24) (f218 . -20) (f220 . -16) (f219 . -12) (f218 . -8) (f166 . 28) (f168 . 24) (f167 . 20) (f169 . 16) (f170 . 12) (f171 . 8) (f172 . 4) (f165 . -28) (f166 . -24) (f167 . -20) (f168 . -16) (f169 . -12) (f170 . -8) (f171 . -4) (f172 . 0))
# expr=(if (string? f218) (begin (if f220 ((vector-ref f167 0) f218 f219) ((vector-ref f168 0) f218 f219))) (if (pair? f218) (begin ((vector-ref f166 0) f218 f219)) (begin ((primitive-ref error) ((primitive-ref string->symbol) "write") "unrecognized expression"))))
# emit-expr (string? f218)
# emit-expr f218
# emit-variable-ref
# env=((f220 . -28) (f219 . -24) (f218 . -20) (f220 . -16) (f219 . -12) (f218 . -8) (f166 . 28) (f168 . 24) (f167 . 20) (f169 . 16) (f170 . 12) (f171 . 8) (f172 . 4) (f165 . -28) (f166 . -24) (f167 . -20) (f168 . -16) (f169 . -12) (f170 . -8) (f171 . -4) (f172 . 0))
# var=f218
    movl -20(%esp), %eax  # stack load f218
>>>>>>> fix-implicit-begins
# end emit-variable-ref
    and $7, %al
    cmp $6, %al
    sete %al
    movzbl %al, %eax
    sal $6, %al
    or $47, %al
    cmp $47, %al
    je _L_1364
# emit-tail-expr
# si=-32
# env=((f220 . -28) (f219 . -24) (f218 . -20) (f220 . -16) (f219 . -12) (f218 . -8) (f166 . 28) (f168 . 24) (f167 . 20) (f169 . 16) (f170 . 12) (f171 . 8) (f172 . 4) (f165 . -28) (f166 . -24) (f167 . -20) (f168 . -16) (f169 . -12) (f170 . -8) (f171 . -4) (f172 . 0))
# expr=(begin (if f220 ((vector-ref f167 0) f218 f219) ((vector-ref f168 0) f218 f219)))
# tail-begin (begin (if f220 ((vector-ref f167 0) f218 f219) ((vector-ref f168 0) f218 f219)))
#   env=((f220 . -28) (f219 . -24) (f218 . -20) (f220 . -16) (f219 . -12) (f218 . -8) (f166 . 28) (f168 . 24) (f167 . 20) (f169 . 16) (f170 . 12) (f171 . 8) (f172 . 4) (f165 . -28) (f166 . -24) (f167 . -20) (f168 . -16) (f169 . -12) (f170 . -8) (f171 . -4) (f172 . 0))
# emit-tail-expr
# si=-32
<<<<<<< HEAD
# env=((f311005 . -28) (f311006 . -24) (f311007 . -20) (f311005 . -16) (f311006 . -12) (f311007 . -8) (f310953 . 28) (f310955 . 24) (f310954 . 20) (f310956 . 16) (f310957 . 12) (f310958 . 8) (f310959 . 4) (f310952 . -28) (f310953 . -24) (f310954 . -20) (f310955 . -16) (f310956 . -12) (f310957 . -8) (f310958 . -4) (f310959 . 0))
# expr=(if f311005 ((vector-ref f310954 0) f311007 f311006) ((vector-ref f310955 0) f311007 f311006))
# emit-expr f311005
# emit-variable-ref
# env=((f311005 . -28) (f311006 . -24) (f311007 . -20) (f311005 . -16) (f311006 . -12) (f311007 . -8) (f310953 . 28) (f310955 . 24) (f310954 . 20) (f310956 . 16) (f310957 . 12) (f310958 . 8) (f310959 . 4) (f310952 . -28) (f310953 . -24) (f310954 . -20) (f310955 . -16) (f310956 . -12) (f310957 . -8) (f310958 . -4) (f310959 . 0))
# var=f311005
    movl -28(%esp), %eax  # stack load f311005
=======
# env=((f220 . -28) (f219 . -24) (f218 . -20) (f220 . -16) (f219 . -12) (f218 . -8) (f166 . 28) (f168 . 24) (f167 . 20) (f169 . 16) (f170 . 12) (f171 . 8) (f172 . 4) (f165 . -28) (f166 . -24) (f167 . -20) (f168 . -16) (f169 . -12) (f170 . -8) (f171 . -4) (f172 . 0))
# expr=(if f220 ((vector-ref f167 0) f218 f219) ((vector-ref f168 0) f218 f219))
# emit-expr f220
# emit-variable-ref
# env=((f220 . -28) (f219 . -24) (f218 . -20) (f220 . -16) (f219 . -12) (f218 . -8) (f166 . 28) (f168 . 24) (f167 . 20) (f169 . 16) (f170 . 12) (f171 . 8) (f172 . 4) (f165 . -28) (f166 . -24) (f167 . -20) (f168 . -16) (f169 . -12) (f170 . -8) (f171 . -4) (f172 . 0))
# var=f220
    movl -28(%esp), %eax  # stack load f220
>>>>>>> fix-implicit-begins
# end emit-variable-ref
    cmp $47, %al
    je _L_1366
# emit-tail-expr
# si=-32
<<<<<<< HEAD
# env=((f311005 . -28) (f311006 . -24) (f311007 . -20) (f311005 . -16) (f311006 . -12) (f311007 . -8) (f310953 . 28) (f310955 . 24) (f310954 . 20) (f310956 . 16) (f310957 . 12) (f310958 . 8) (f310959 . 4) (f310952 . -28) (f310953 . -24) (f310954 . -20) (f310955 . -16) (f310956 . -12) (f310957 . -8) (f310958 . -4) (f310959 . 0))
# expr=((vector-ref f310954 0) f311007 f311006)
# emit-tail-funcall
#    si   =-32
#    env  = ((f311005 . -28) (f311006 . -24) (f311007 . -20) (f311005 . -16) (f311006 . -12) (f311007 . -8) (f310953 . 28) (f310955 . 24) (f310954 . 20) (f310956 . 16) (f310957 . 12) (f310958 . 8) (f310959 . 4) (f310952 . -28) (f310953 . -24) (f310954 . -20) (f310955 . -16) (f310956 . -12) (f310957 . -8) (f310958 . -4) (f310959 . 0))
#    expr = (funcall (vector-ref f310954 0) f311007 f311006)
# emit-expr (vector-ref f310954 0)
# emit-expr f310954
# emit-variable-ref
# env=((f311005 . -28) (f311006 . -24) (f311007 . -20) (f311005 . -16) (f311006 . -12) (f311007 . -8) (f310953 . 28) (f310955 . 24) (f310954 . 20) (f310956 . 16) (f310957 . 12) (f310958 . 8) (f310959 . 4) (f310952 . -28) (f310953 . -24) (f310954 . -20) (f310955 . -16) (f310956 . -12) (f310957 . -8) (f310958 . -4) (f310959 . 0))
# var=f310954
    movl 18(%edi), %eax  # frame load f310954
=======
# env=((f220 . -28) (f219 . -24) (f218 . -20) (f220 . -16) (f219 . -12) (f218 . -8) (f166 . 28) (f168 . 24) (f167 . 20) (f169 . 16) (f170 . 12) (f171 . 8) (f172 . 4) (f165 . -28) (f166 . -24) (f167 . -20) (f168 . -16) (f169 . -12) (f170 . -8) (f171 . -4) (f172 . 0))
# expr=((vector-ref f167 0) f218 f219)
# emit-tail-funcall
#    si   =-32
#    env  = ((f220 . -28) (f219 . -24) (f218 . -20) (f220 . -16) (f219 . -12) (f218 . -8) (f166 . 28) (f168 . 24) (f167 . 20) (f169 . 16) (f170 . 12) (f171 . 8) (f172 . 4) (f165 . -28) (f166 . -24) (f167 . -20) (f168 . -16) (f169 . -12) (f170 . -8) (f171 . -4) (f172 . 0))
#    expr = (funcall (vector-ref f167 0) f218 f219)
# emit-expr (vector-ref f167 0)
# emit-expr f167
# emit-variable-ref
# env=((f220 . -28) (f219 . -24) (f218 . -20) (f220 . -16) (f219 . -12) (f218 . -8) (f166 . 28) (f168 . 24) (f167 . 20) (f169 . 16) (f170 . 12) (f171 . 8) (f172 . 4) (f165 . -28) (f166 . -24) (f167 . -20) (f168 . -16) (f169 . -12) (f170 . -8) (f171 . -4) (f172 . 0))
# var=f167
    movl 18(%edi), %eax  # frame load f167
>>>>>>> fix-implicit-begins
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1368
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1368:
    movl %eax, -32(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1369"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1369:
# check bounds on vector index
    movl -32(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1371
    cmp  $0,%eax
    jge _L_1370
_L_1371:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1370:
    movl -32(%esp), %esi
    movl -1(%eax,%esi), %eax
   movl %eax,  -32(%esp)  # stash funcall-oper in next closure slot
<<<<<<< HEAD
# emit-expr f311007
# emit-variable-ref
# env=((f311005 . -28) (f311006 . -24) (f311007 . -20) (f311005 . -16) (f311006 . -12) (f311007 . -8) (f310953 . 28) (f310955 . 24) (f310954 . 20) (f310956 . 16) (f310957 . 12) (f310958 . 8) (f310959 . 4) (f310952 . -28) (f310953 . -24) (f310954 . -20) (f310955 . -16) (f310956 . -12) (f310957 . -8) (f310958 . -4) (f310959 . 0))
# var=f311007
    movl -20(%esp), %eax  # stack load f311007
# end emit-variable-ref
    mov %eax, -36(%esp)    # arg f311007
# emit-expr f311006
# emit-variable-ref
# env=((f311005 . -28) (f311006 . -24) (f311007 . -20) (f311005 . -16) (f311006 . -12) (f311007 . -8) (f310953 . 28) (f310955 . 24) (f310954 . 20) (f310956 . 16) (f310957 . 12) (f310958 . 8) (f310959 . 4) (f310952 . -28) (f310953 . -24) (f310954 . -20) (f310955 . -16) (f310956 . -12) (f310957 . -8) (f310958 . -4) (f310959 . 0))
# var=f311006
    movl -24(%esp), %eax  # stack load f311006
=======
# emit-expr f218
# emit-variable-ref
# env=((f220 . -28) (f219 . -24) (f218 . -20) (f220 . -16) (f219 . -12) (f218 . -8) (f166 . 28) (f168 . 24) (f167 . 20) (f169 . 16) (f170 . 12) (f171 . 8) (f172 . 4) (f165 . -28) (f166 . -24) (f167 . -20) (f168 . -16) (f169 . -12) (f170 . -8) (f171 . -4) (f172 . 0))
# var=f218
    movl -20(%esp), %eax  # stack load f218
# end emit-variable-ref
    mov %eax, -36(%esp)    # arg f218
# emit-expr f219
# emit-variable-ref
# env=((f220 . -28) (f219 . -24) (f218 . -20) (f220 . -16) (f219 . -12) (f218 . -8) (f166 . 28) (f168 . 24) (f167 . 20) (f169 . 16) (f170 . 12) (f171 . 8) (f172 . 4) (f165 . -28) (f166 . -24) (f167 . -20) (f168 . -16) (f169 . -12) (f170 . -8) (f171 . -4) (f172 . 0))
# var=f219
    movl -24(%esp), %eax  # stack load f219
>>>>>>> fix-implicit-begins
# end emit-variable-ref
    mov %eax, -40(%esp)    # arg f219
    movl -32(%esp), %edi   # load new closure to %edi
# emit-shift-args:  size=3   si=-32  delta=28
    mov -32(%esp), %ebx  # shift frame cell
    mov %ebx, -4(%esp)  # down to base
# emit-shift-args:  size=2   si=-36  delta=28
    mov -36(%esp), %ebx  # shift frame cell
    mov %ebx, -8(%esp)  # down to base
# emit-shift-args:  size=1   si=-40  delta=28
    mov -40(%esp), %ebx  # shift frame cell
    mov %ebx, -12(%esp)  # down to base
# emit-shift-args:  size=0   si=-44  delta=28
    movl $8,%eax   # save arg count
    jmp *-2(%edi)  # tail-funcall
    jmp _L_1367
_L_1366:
# emit-tail-expr
# si=-32
<<<<<<< HEAD
# env=((f311005 . -28) (f311006 . -24) (f311007 . -20) (f311005 . -16) (f311006 . -12) (f311007 . -8) (f310953 . 28) (f310955 . 24) (f310954 . 20) (f310956 . 16) (f310957 . 12) (f310958 . 8) (f310959 . 4) (f310952 . -28) (f310953 . -24) (f310954 . -20) (f310955 . -16) (f310956 . -12) (f310957 . -8) (f310958 . -4) (f310959 . 0))
# expr=((vector-ref f310955 0) f311007 f311006)
# emit-tail-funcall
#    si   =-32
#    env  = ((f311005 . -28) (f311006 . -24) (f311007 . -20) (f311005 . -16) (f311006 . -12) (f311007 . -8) (f310953 . 28) (f310955 . 24) (f310954 . 20) (f310956 . 16) (f310957 . 12) (f310958 . 8) (f310959 . 4) (f310952 . -28) (f310953 . -24) (f310954 . -20) (f310955 . -16) (f310956 . -12) (f310957 . -8) (f310958 . -4) (f310959 . 0))
#    expr = (funcall (vector-ref f310955 0) f311007 f311006)
# emit-expr (vector-ref f310955 0)
# emit-expr f310955
# emit-variable-ref
# env=((f311005 . -28) (f311006 . -24) (f311007 . -20) (f311005 . -16) (f311006 . -12) (f311007 . -8) (f310953 . 28) (f310955 . 24) (f310954 . 20) (f310956 . 16) (f310957 . 12) (f310958 . 8) (f310959 . 4) (f310952 . -28) (f310953 . -24) (f310954 . -20) (f310955 . -16) (f310956 . -12) (f310957 . -8) (f310958 . -4) (f310959 . 0))
# var=f310955
    movl 22(%edi), %eax  # frame load f310955
=======
# env=((f220 . -28) (f219 . -24) (f218 . -20) (f220 . -16) (f219 . -12) (f218 . -8) (f166 . 28) (f168 . 24) (f167 . 20) (f169 . 16) (f170 . 12) (f171 . 8) (f172 . 4) (f165 . -28) (f166 . -24) (f167 . -20) (f168 . -16) (f169 . -12) (f170 . -8) (f171 . -4) (f172 . 0))
# expr=((vector-ref f168 0) f218 f219)
# emit-tail-funcall
#    si   =-32
#    env  = ((f220 . -28) (f219 . -24) (f218 . -20) (f220 . -16) (f219 . -12) (f218 . -8) (f166 . 28) (f168 . 24) (f167 . 20) (f169 . 16) (f170 . 12) (f171 . 8) (f172 . 4) (f165 . -28) (f166 . -24) (f167 . -20) (f168 . -16) (f169 . -12) (f170 . -8) (f171 . -4) (f172 . 0))
#    expr = (funcall (vector-ref f168 0) f218 f219)
# emit-expr (vector-ref f168 0)
# emit-expr f168
# emit-variable-ref
# env=((f220 . -28) (f219 . -24) (f218 . -20) (f220 . -16) (f219 . -12) (f218 . -8) (f166 . 28) (f168 . 24) (f167 . 20) (f169 . 16) (f170 . 12) (f171 . 8) (f172 . 4) (f165 . -28) (f166 . -24) (f167 . -20) (f168 . -16) (f169 . -12) (f170 . -8) (f171 . -4) (f172 . 0))
# var=f168
    movl 22(%edi), %eax  # frame load f168
>>>>>>> fix-implicit-begins
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1372
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1372:
    movl %eax, -32(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1373"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1373:
# check bounds on vector index
    movl -32(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1375
    cmp  $0,%eax
    jge _L_1374
_L_1375:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1374:
    movl -32(%esp), %esi
    movl -1(%eax,%esi), %eax
   movl %eax,  -32(%esp)  # stash funcall-oper in next closure slot
<<<<<<< HEAD
# emit-expr f311007
# emit-variable-ref
# env=((f311005 . -28) (f311006 . -24) (f311007 . -20) (f311005 . -16) (f311006 . -12) (f311007 . -8) (f310953 . 28) (f310955 . 24) (f310954 . 20) (f310956 . 16) (f310957 . 12) (f310958 . 8) (f310959 . 4) (f310952 . -28) (f310953 . -24) (f310954 . -20) (f310955 . -16) (f310956 . -12) (f310957 . -8) (f310958 . -4) (f310959 . 0))
# var=f311007
    movl -20(%esp), %eax  # stack load f311007
# end emit-variable-ref
    mov %eax, -36(%esp)    # arg f311007
# emit-expr f311006
# emit-variable-ref
# env=((f311005 . -28) (f311006 . -24) (f311007 . -20) (f311005 . -16) (f311006 . -12) (f311007 . -8) (f310953 . 28) (f310955 . 24) (f310954 . 20) (f310956 . 16) (f310957 . 12) (f310958 . 8) (f310959 . 4) (f310952 . -28) (f310953 . -24) (f310954 . -20) (f310955 . -16) (f310956 . -12) (f310957 . -8) (f310958 . -4) (f310959 . 0))
# var=f311006
    movl -24(%esp), %eax  # stack load f311006
=======
# emit-expr f218
# emit-variable-ref
# env=((f220 . -28) (f219 . -24) (f218 . -20) (f220 . -16) (f219 . -12) (f218 . -8) (f166 . 28) (f168 . 24) (f167 . 20) (f169 . 16) (f170 . 12) (f171 . 8) (f172 . 4) (f165 . -28) (f166 . -24) (f167 . -20) (f168 . -16) (f169 . -12) (f170 . -8) (f171 . -4) (f172 . 0))
# var=f218
    movl -20(%esp), %eax  # stack load f218
# end emit-variable-ref
    mov %eax, -36(%esp)    # arg f218
# emit-expr f219
# emit-variable-ref
# env=((f220 . -28) (f219 . -24) (f218 . -20) (f220 . -16) (f219 . -12) (f218 . -8) (f166 . 28) (f168 . 24) (f167 . 20) (f169 . 16) (f170 . 12) (f171 . 8) (f172 . 4) (f165 . -28) (f166 . -24) (f167 . -20) (f168 . -16) (f169 . -12) (f170 . -8) (f171 . -4) (f172 . 0))
# var=f219
    movl -24(%esp), %eax  # stack load f219
>>>>>>> fix-implicit-begins
# end emit-variable-ref
    mov %eax, -40(%esp)    # arg f219
    movl -32(%esp), %edi   # load new closure to %edi
# emit-shift-args:  size=3   si=-32  delta=28
    mov -32(%esp), %ebx  # shift frame cell
    mov %ebx, -4(%esp)  # down to base
# emit-shift-args:  size=2   si=-36  delta=28
    mov -36(%esp), %ebx  # shift frame cell
    mov %ebx, -8(%esp)  # down to base
# emit-shift-args:  size=1   si=-40  delta=28
    mov -40(%esp), %ebx  # shift frame cell
    mov %ebx, -12(%esp)  # down to base
# emit-shift-args:  size=0   si=-44  delta=28
    movl $8,%eax   # save arg count
    jmp *-2(%edi)  # tail-funcall
_L_1367:
     ret   # return thru stack
    jmp _L_1365
_L_1364:
# emit-tail-expr
# si=-32
<<<<<<< HEAD
# env=((f311005 . -28) (f311006 . -24) (f311007 . -20) (f311005 . -16) (f311006 . -12) (f311007 . -8) (f310953 . 28) (f310955 . 24) (f310954 . 20) (f310956 . 16) (f310957 . 12) (f310958 . 8) (f310959 . 4) (f310952 . -28) (f310953 . -24) (f310954 . -20) (f310955 . -16) (f310956 . -12) (f310957 . -8) (f310958 . -4) (f310959 . 0))
# expr=(if (pair? f311007) ((vector-ref f310953 0) f311007 f311006) ((primitive-ref error) ((primitive-ref string->symbol) "write") "unrecognized expression"))
# emit-expr (pair? f311007)
# emit-expr f311007
# emit-variable-ref
# env=((f311005 . -28) (f311006 . -24) (f311007 . -20) (f311005 . -16) (f311006 . -12) (f311007 . -8) (f310953 . 28) (f310955 . 24) (f310954 . 20) (f310956 . 16) (f310957 . 12) (f310958 . 8) (f310959 . 4) (f310952 . -28) (f310953 . -24) (f310954 . -20) (f310955 . -16) (f310956 . -12) (f310957 . -8) (f310958 . -4) (f310959 . 0))
# var=f311007
    movl -20(%esp), %eax  # stack load f311007
=======
# env=((f220 . -28) (f219 . -24) (f218 . -20) (f220 . -16) (f219 . -12) (f218 . -8) (f166 . 28) (f168 . 24) (f167 . 20) (f169 . 16) (f170 . 12) (f171 . 8) (f172 . 4) (f165 . -28) (f166 . -24) (f167 . -20) (f168 . -16) (f169 . -12) (f170 . -8) (f171 . -4) (f172 . 0))
# expr=(if (pair? f218) (begin ((vector-ref f166 0) f218 f219)) (begin ((primitive-ref error) ((primitive-ref string->symbol) "write") "unrecognized expression")))
# emit-expr (pair? f218)
# emit-expr f218
# emit-variable-ref
# env=((f220 . -28) (f219 . -24) (f218 . -20) (f220 . -16) (f219 . -12) (f218 . -8) (f166 . 28) (f168 . 24) (f167 . 20) (f169 . 16) (f170 . 12) (f171 . 8) (f172 . 4) (f165 . -28) (f166 . -24) (f167 . -20) (f168 . -16) (f169 . -12) (f170 . -8) (f171 . -4) (f172 . 0))
# var=f218
    movl -20(%esp), %eax  # stack load f218
>>>>>>> fix-implicit-begins
# end emit-variable-ref
    and $7, %al
    cmp $1, %al
    sete %al
    movzbl %al, %eax
    sal $6, %al
    or $47, %al
    cmp $47, %al
    je _L_1376
# emit-tail-expr
# si=-32
# env=((f220 . -28) (f219 . -24) (f218 . -20) (f220 . -16) (f219 . -12) (f218 . -8) (f166 . 28) (f168 . 24) (f167 . 20) (f169 . 16) (f170 . 12) (f171 . 8) (f172 . 4) (f165 . -28) (f166 . -24) (f167 . -20) (f168 . -16) (f169 . -12) (f170 . -8) (f171 . -4) (f172 . 0))
# expr=(begin ((vector-ref f166 0) f218 f219))
# tail-begin (begin ((vector-ref f166 0) f218 f219))
#   env=((f220 . -28) (f219 . -24) (f218 . -20) (f220 . -16) (f219 . -12) (f218 . -8) (f166 . 28) (f168 . 24) (f167 . 20) (f169 . 16) (f170 . 12) (f171 . 8) (f172 . 4) (f165 . -28) (f166 . -24) (f167 . -20) (f168 . -16) (f169 . -12) (f170 . -8) (f171 . -4) (f172 . 0))
# emit-tail-expr
# si=-32
<<<<<<< HEAD
# env=((f311005 . -28) (f311006 . -24) (f311007 . -20) (f311005 . -16) (f311006 . -12) (f311007 . -8) (f310953 . 28) (f310955 . 24) (f310954 . 20) (f310956 . 16) (f310957 . 12) (f310958 . 8) (f310959 . 4) (f310952 . -28) (f310953 . -24) (f310954 . -20) (f310955 . -16) (f310956 . -12) (f310957 . -8) (f310958 . -4) (f310959 . 0))
# expr=((vector-ref f310953 0) f311007 f311006)
# emit-tail-funcall
#    si   =-32
#    env  = ((f311005 . -28) (f311006 . -24) (f311007 . -20) (f311005 . -16) (f311006 . -12) (f311007 . -8) (f310953 . 28) (f310955 . 24) (f310954 . 20) (f310956 . 16) (f310957 . 12) (f310958 . 8) (f310959 . 4) (f310952 . -28) (f310953 . -24) (f310954 . -20) (f310955 . -16) (f310956 . -12) (f310957 . -8) (f310958 . -4) (f310959 . 0))
#    expr = (funcall (vector-ref f310953 0) f311007 f311006)
# emit-expr (vector-ref f310953 0)
# emit-expr f310953
# emit-variable-ref
# env=((f311005 . -28) (f311006 . -24) (f311007 . -20) (f311005 . -16) (f311006 . -12) (f311007 . -8) (f310953 . 28) (f310955 . 24) (f310954 . 20) (f310956 . 16) (f310957 . 12) (f310958 . 8) (f310959 . 4) (f310952 . -28) (f310953 . -24) (f310954 . -20) (f310955 . -16) (f310956 . -12) (f310957 . -8) (f310958 . -4) (f310959 . 0))
# var=f310953
    movl 26(%edi), %eax  # frame load f310953
=======
# env=((f220 . -28) (f219 . -24) (f218 . -20) (f220 . -16) (f219 . -12) (f218 . -8) (f166 . 28) (f168 . 24) (f167 . 20) (f169 . 16) (f170 . 12) (f171 . 8) (f172 . 4) (f165 . -28) (f166 . -24) (f167 . -20) (f168 . -16) (f169 . -12) (f170 . -8) (f171 . -4) (f172 . 0))
# expr=((vector-ref f166 0) f218 f219)
# emit-tail-funcall
#    si   =-32
#    env  = ((f220 . -28) (f219 . -24) (f218 . -20) (f220 . -16) (f219 . -12) (f218 . -8) (f166 . 28) (f168 . 24) (f167 . 20) (f169 . 16) (f170 . 12) (f171 . 8) (f172 . 4) (f165 . -28) (f166 . -24) (f167 . -20) (f168 . -16) (f169 . -12) (f170 . -8) (f171 . -4) (f172 . 0))
#    expr = (funcall (vector-ref f166 0) f218 f219)
# emit-expr (vector-ref f166 0)
# emit-expr f166
# emit-variable-ref
# env=((f220 . -28) (f219 . -24) (f218 . -20) (f220 . -16) (f219 . -12) (f218 . -8) (f166 . 28) (f168 . 24) (f167 . 20) (f169 . 16) (f170 . 12) (f171 . 8) (f172 . 4) (f165 . -28) (f166 . -24) (f167 . -20) (f168 . -16) (f169 . -12) (f170 . -8) (f171 . -4) (f172 . 0))
# var=f166
    movl 26(%edi), %eax  # frame load f166
>>>>>>> fix-implicit-begins
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1378
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1378:
    movl %eax, -32(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1379"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1379:
# check bounds on vector index
    movl -32(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1381
    cmp  $0,%eax
    jge _L_1380
_L_1381:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1380:
    movl -32(%esp), %esi
    movl -1(%eax,%esi), %eax
   movl %eax,  -32(%esp)  # stash funcall-oper in next closure slot
<<<<<<< HEAD
# emit-expr f311007
# emit-variable-ref
# env=((f311005 . -28) (f311006 . -24) (f311007 . -20) (f311005 . -16) (f311006 . -12) (f311007 . -8) (f310953 . 28) (f310955 . 24) (f310954 . 20) (f310956 . 16) (f310957 . 12) (f310958 . 8) (f310959 . 4) (f310952 . -28) (f310953 . -24) (f310954 . -20) (f310955 . -16) (f310956 . -12) (f310957 . -8) (f310958 . -4) (f310959 . 0))
# var=f311007
    movl -20(%esp), %eax  # stack load f311007
# end emit-variable-ref
    mov %eax, -36(%esp)    # arg f311007
# emit-expr f311006
# emit-variable-ref
# env=((f311005 . -28) (f311006 . -24) (f311007 . -20) (f311005 . -16) (f311006 . -12) (f311007 . -8) (f310953 . 28) (f310955 . 24) (f310954 . 20) (f310956 . 16) (f310957 . 12) (f310958 . 8) (f310959 . 4) (f310952 . -28) (f310953 . -24) (f310954 . -20) (f310955 . -16) (f310956 . -12) (f310957 . -8) (f310958 . -4) (f310959 . 0))
# var=f311006
    movl -24(%esp), %eax  # stack load f311006
=======
# emit-expr f218
# emit-variable-ref
# env=((f220 . -28) (f219 . -24) (f218 . -20) (f220 . -16) (f219 . -12) (f218 . -8) (f166 . 28) (f168 . 24) (f167 . 20) (f169 . 16) (f170 . 12) (f171 . 8) (f172 . 4) (f165 . -28) (f166 . -24) (f167 . -20) (f168 . -16) (f169 . -12) (f170 . -8) (f171 . -4) (f172 . 0))
# var=f218
    movl -20(%esp), %eax  # stack load f218
# end emit-variable-ref
    mov %eax, -36(%esp)    # arg f218
# emit-expr f219
# emit-variable-ref
# env=((f220 . -28) (f219 . -24) (f218 . -20) (f220 . -16) (f219 . -12) (f218 . -8) (f166 . 28) (f168 . 24) (f167 . 20) (f169 . 16) (f170 . 12) (f171 . 8) (f172 . 4) (f165 . -28) (f166 . -24) (f167 . -20) (f168 . -16) (f169 . -12) (f170 . -8) (f171 . -4) (f172 . 0))
# var=f219
    movl -24(%esp), %eax  # stack load f219
>>>>>>> fix-implicit-begins
# end emit-variable-ref
    mov %eax, -40(%esp)    # arg f219
    movl -32(%esp), %edi   # load new closure to %edi
# emit-shift-args:  size=3   si=-32  delta=28
    mov -32(%esp), %ebx  # shift frame cell
    mov %ebx, -4(%esp)  # down to base
# emit-shift-args:  size=2   si=-36  delta=28
    mov -36(%esp), %ebx  # shift frame cell
    mov %ebx, -8(%esp)  # down to base
# emit-shift-args:  size=1   si=-40  delta=28
    mov -40(%esp), %ebx  # shift frame cell
    mov %ebx, -12(%esp)  # down to base
# emit-shift-args:  size=0   si=-44  delta=28
    movl $8,%eax   # save arg count
    jmp *-2(%edi)  # tail-funcall
     ret   # return thru stack
    jmp _L_1377
_L_1376:
# emit-tail-expr
# si=-32
<<<<<<< HEAD
# env=((f311005 . -28) (f311006 . -24) (f311007 . -20) (f311005 . -16) (f311006 . -12) (f311007 . -8) (f310953 . 28) (f310955 . 24) (f310954 . 20) (f310956 . 16) (f310957 . 12) (f310958 . 8) (f310959 . 4) (f310952 . -28) (f310953 . -24) (f310954 . -20) (f310955 . -16) (f310956 . -12) (f310957 . -8) (f310958 . -4) (f310959 . 0))
# expr=((primitive-ref error) ((primitive-ref string->symbol) "write") "unrecognized expression")
# emit-tail-funcall
#    si   =-32
#    env  = ((f311005 . -28) (f311006 . -24) (f311007 . -20) (f311005 . -16) (f311006 . -12) (f311007 . -8) (f310953 . 28) (f310955 . 24) (f310954 . 20) (f310956 . 16) (f310957 . 12) (f310958 . 8) (f310959 . 4) (f310952 . -28) (f310953 . -24) (f310954 . -20) (f310955 . -16) (f310956 . -12) (f310957 . -8) (f310958 . -4) (f310959 . 0))
=======
# env=((f220 . -28) (f219 . -24) (f218 . -20) (f220 . -16) (f219 . -12) (f218 . -8) (f166 . 28) (f168 . 24) (f167 . 20) (f169 . 16) (f170 . 12) (f171 . 8) (f172 . 4) (f165 . -28) (f166 . -24) (f167 . -20) (f168 . -16) (f169 . -12) (f170 . -8) (f171 . -4) (f172 . 0))
# expr=(begin ((primitive-ref error) ((primitive-ref string->symbol) "write") "unrecognized expression"))
# tail-begin (begin ((primitive-ref error) ((primitive-ref string->symbol) "write") "unrecognized expression"))
#   env=((f220 . -28) (f219 . -24) (f218 . -20) (f220 . -16) (f219 . -12) (f218 . -8) (f166 . 28) (f168 . 24) (f167 . 20) (f169 . 16) (f170 . 12) (f171 . 8) (f172 . 4) (f165 . -28) (f166 . -24) (f167 . -20) (f168 . -16) (f169 . -12) (f170 . -8) (f171 . -4) (f172 . 0))
# emit-tail-expr
# si=-32
# env=((f220 . -28) (f219 . -24) (f218 . -20) (f220 . -16) (f219 . -12) (f218 . -8) (f166 . 28) (f168 . 24) (f167 . 20) (f169 . 16) (f170 . 12) (f171 . 8) (f172 . 4) (f165 . -28) (f166 . -24) (f167 . -20) (f168 . -16) (f169 . -12) (f170 . -8) (f171 . -4) (f172 . 0))
# expr=((primitive-ref error) ((primitive-ref string->symbol) "write") "unrecognized expression")
# emit-tail-funcall
#    si   =-32
#    env  = ((f220 . -28) (f219 . -24) (f218 . -20) (f220 . -16) (f219 . -12) (f218 . -8) (f166 . 28) (f168 . 24) (f167 . 20) (f169 . 16) (f170 . 12) (f171 . 8) (f172 . 4) (f165 . -28) (f166 . -24) (f167 . -20) (f168 . -16) (f169 . -12) (f170 . -8) (f171 . -4) (f172 . 0))
>>>>>>> fix-implicit-begins
#    expr = (funcall (primitive-ref error) ((primitive-ref string->symbol) "write") "unrecognized expression")
# emit-expr (primitive-ref error)
    .extern mrc_error
    movl mrc_error,%eax
   movl %eax,  -32(%esp)  # stash funcall-oper in next closure slot
# emit-expr ((primitive-ref string->symbol) "write")
# funcall
#    si   =-36
<<<<<<< HEAD
#    env  = ((f311005 . -28) (f311006 . -24) (f311007 . -20) (f311005 . -16) (f311006 . -12) (f311007 . -8) (f310953 . 28) (f310955 . 24) (f310954 . 20) (f310956 . 16) (f310957 . 12) (f310958 . 8) (f310959 . 4) (f310952 . -28) (f310953 . -24) (f310954 . -20) (f310955 . -16) (f310956 . -12) (f310957 . -8) (f310958 . -4) (f310959 . 0))
=======
#    env  = ((f220 . -28) (f219 . -24) (f218 . -20) (f220 . -16) (f219 . -12) (f218 . -8) (f166 . 28) (f168 . 24) (f167 . 20) (f169 . 16) (f170 . 12) (f171 . 8) (f172 . 4) (f165 . -28) (f166 . -24) (f167 . -20) (f168 . -16) (f169 . -12) (f170 . -8) (f171 . -4) (f172 . 0))
>>>>>>> fix-implicit-begins
#    expr = (funcall (primitive-ref string->symbol) "write")
# emit-expr (primitive-ref string->symbol)
    .extern mrc_string$m$gsymbol
    movl mrc_string$m$gsymbol,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1382"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1382":
   movl %eax,  -44(%esp)  # stash funcall-oper in closure slot
# emit-expr "write"
# string literal
    jmp _L_1384
    .align 8,0x90
_L_1383 :
    .int 20
    .ascii "write"
_L_1384:
    movl $_L_1383, %eax
    orl $6, %eax
    mov %eax, -48(%esp)  # arg write
    movl -44(%esp), %edi   # load new closure to %edi
    add $-36, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $36, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    mov %eax, -36(%esp)    # arg ((primitive-ref string->symbol) write)
# emit-expr "unrecognized expression"
# string literal
    jmp _L_1386
    .align 8,0x90
_L_1385 :
    .int 92
    .ascii "unrecognized expression"
_L_1386:
    movl $_L_1385, %eax
    orl $6, %eax
    mov %eax, -40(%esp)    # arg unrecognized expression
    movl -32(%esp), %edi   # load new closure to %edi
# emit-shift-args:  size=3   si=-32  delta=28
    mov -32(%esp), %ebx  # shift frame cell
    mov %ebx, -4(%esp)  # down to base
# emit-shift-args:  size=2   si=-36  delta=28
    mov -36(%esp), %ebx  # shift frame cell
    mov %ebx, -8(%esp)  # down to base
# emit-shift-args:  size=1   si=-40  delta=28
    mov -40(%esp), %ebx  # shift frame cell
    mov %ebx, -12(%esp)  # down to base
# emit-shift-args:  size=0   si=-44  delta=28
    movl $8,%eax   # save arg count
    jmp *-2(%edi)  # tail-funcall
     ret   # return thru stack
_L_1377:
_L_1365:
_L_1359:
_L_1351:
_L_1345:
_L_1339:
    .align 4,0x90
_L_1336:
# emit-expr (begin)
# emit-begin
#   expr=(begin)
#   env=((f165 . -28) (f166 . -24) (f167 . -20) (f168 . -16) (f169 . -12) (f170 . -8) (f171 . -4) (f172 . 0))
     movl %eax, mrc_base$mwrite
# == explicit-begins  ==>
# (lambda (expr . args) (let ((p (if (null? args) (current-output-port) (car args)))) (base-write expr p #f)))
# == eliminate-let*  ==>
# (lambda (expr . args) (let ((p (if (null? args) (current-output-port) (car args)))) (base-write expr p #f)))
# == uniquify-variables  ==>
<<<<<<< HEAD
# (lambda (f311009 . f311008) (let ((f311011 (if (null? f311008) (current-output-port) (car f311008)))) (base-write f311009 f311011 #f)))
# == vectorize-letrec  ==>
# (lambda (f311009 . f311008) (let ((f311011 (if (null? f311008) (current-output-port) (car f311008)))) (base-write f311009 f311011 #f)))
# == eliminate-set!  ==>
# (lambda (f311009 . f311008) (let ((f311009 f311009)) (let ((f311011 (if (null? f311008) (current-output-port) (car f311008)))) (base-write f311009 f311011 #f))))
# == close-free-variables  ==>
# (closure (f311009 . f311008) () (let ((f311009 f311009)) (let ((f311011 (if (null? f311008) (current-output-port) (car f311008)))) (base-write f311009 f311011 #f))))
# == eliminate-quote  ==>
# (closure (f311009 . f311008) () (let ((f311009 f311009)) (let ((f311011 (if (null? f311008) (current-output-port) (car f311008)))) (base-write f311009 f311011 #f))))
# == eliminate-when/unless  ==>
# (closure (f311009 . f311008) () (let ((f311009 f311009)) (let ((f311011 (if (null? f311008) (current-output-port) (car f311008)))) (base-write f311009 f311011 #f))))
# == eliminate-cond  ==>
# (closure (f311009 . f311008) () (let ((f311009 f311009)) (let ((f311011 (if (null? f311008) (current-output-port) (car f311008)))) (base-write f311009 f311011 #f))))
# == external-symbols  ==>
# (closure (f311009 . f311008) () (let ((f311009 f311009)) (let ((f311011 (if (null? f311008) ((primitive-ref current-output-port)) (car f311008)))) ((primitive-ref base-write) f311009 f311011 #f))))
# emit-expr (closure (f311009 . f311008) () (let ((f311009 f311009)) (let ((f311011 (if (null? f311008) ((primitive-ref current-output-port)) (car f311008)))) ((primitive-ref base-write) f311009 f311011 #f))))
# emit-closure
# si = 0
# env = ()
# expr = (closure (f311009 . f311008) () (let ((f311009 f311009)) (let ((f311011 (if (null? f311008) ((primitive-ref current-output-port)) (car f311008)))) ((primitive-ref base-write) f311009 f311011 #f))))
    movl $_L_1884986, 0(%ebp)  # closure label
=======
# (lambda (f221 . f222) (let ((f224 (if (null? f222) (current-output-port) (car f222)))) (base-write f221 f224 #f)))
# == vectorize-letrec  ==>
# (lambda (f221 . f222) (let ((f224 (if (null? f222) (current-output-port) (car f222)))) (base-write f221 f224 #f)))
# == eliminate-set!  ==>
# (lambda (f221 . f222) (let ((f221 f221)) (let ((f224 (if (null? f222) (current-output-port) (car f222)))) (base-write f221 f224 #f))))
# == close-free-variables  ==>
# (closure (f221 . f222) () (let ((f221 f221)) (let ((f224 (if (null? f222) (current-output-port) (car f222)))) (base-write f221 f224 #f))))
# == eliminate-quote  ==>
# (closure (f221 . f222) () (let ((f221 f221)) (let ((f224 (if (null? f222) (current-output-port) (car f222)))) (base-write f221 f224 #f))))
# == eliminate-when/unless  ==>
# (closure (f221 . f222) () (let ((f221 f221)) (let ((f224 (if (null? f222) (current-output-port) (car f222)))) (base-write f221 f224 #f))))
# == eliminate-cond  ==>
# (closure (f221 . f222) () (let ((f221 f221)) (let ((f224 (if (null? f222) (current-output-port) (car f222)))) (base-write f221 f224 #f))))
# == external-symbols  ==>
# (closure (f221 . f222) () (let ((f221 f221)) (let ((f224 (if (null? f222) ((primitive-ref current-output-port)) (car f222)))) ((primitive-ref base-write) f221 f224 #f))))
# emit-expr (closure (f221 . f222) () (let ((f221 f221)) (let ((f224 (if (null? f222) ((primitive-ref current-output-port)) (car f222)))) ((primitive-ref base-write) f221 f224 #f))))
# emit-closure
# si = 0
# env = ()
# expr = (closure (f221 . f222) () (let ((f221 f221)) (let ((f224 (if (null? f222) ((primitive-ref current-output-port)) (car f222)))) ((primitive-ref base-write) f221 f224 #f))))
    movl $_L_1387, 0(%ebp)  # closure label
>>>>>>> fix-implicit-begins
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $8, %ebp     # bump ebp
    jmp _L_1388            # jump around closure body
_L_1387:
# check argument count
    cmp $4,%eax
    jge _L_1389
# invoke error handler eh_argcount_min
    .extern mrc_eh$uargcount$umin
    movl mrc_eh$uargcount$umin, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_1389:
# emit-build-varargs-list
    movl $63, %esi       # args <- () 
    lea -4(%esp),%edi    # edi <- esp-4
    subl %eax, %edi      # edi <- esp-4-eax    addr of arg[K+N] on stack
_L_1391:
    lea -8(%esp),%ebx    # addr of arg[K] on stack
    cmp %edi, %ebx       # while edi <> esp+(si+4)
    je _L_1390
    movl (%edi),%ebx     # arg i -> car
    movl %ebx, 0(%ebp)
    movl %esi, 4(%ebp)  # esi -> cdr
    movl %ebp, %esi
    addl $1, %esi       # tag as pair
    addl $8,%ebp         # bump heap ptr
    addl $4,%edi         # move to next previous arg from the end
    jmp _L_1391
_L_1390:
    movl %esi, -12(%esp)  # set args
# emit-tail-expr
# si=-16
<<<<<<< HEAD
# env=((f311008 . -12) (f311009 . -8))
# expr=(let ((f311009 f311009)) (let ((f311011 (if (null? f311008) ((primitive-ref current-output-port)) (car f311008)))) ((primitive-ref base-write) f311009 f311011 #f)))
# emit-tail-let
#  si   = -16
#  env  = ((f311008 . -12) (f311009 . -8))
#  bindings = ((f311009 f311009))
#  body = (let ((f311011 (if (null? f311008) ((primitive-ref current-output-port)) (car f311008)))) ((primitive-ref base-write) f311009 f311011 #f))
# emit-expr f311009
# emit-variable-ref
# env=((f311008 . -12) (f311009 . -8))
# var=f311009
    movl -8(%esp), %eax  # stack load f311009
=======
# env=((f222 . -12) (f221 . -8))
# expr=(let ((f221 f221)) (let ((f224 (if (null? f222) ((primitive-ref current-output-port)) (car f222)))) ((primitive-ref base-write) f221 f224 #f)))
# emit-tail-let
#  si   = -16
#  env  = ((f222 . -12) (f221 . -8))
#  bindings = ((f221 f221))
#  body = (let ((f224 (if (null? f222) ((primitive-ref current-output-port)) (car f222)))) ((primitive-ref base-write) f221 f224 #f))
# emit-expr f221
# emit-variable-ref
# env=((f222 . -12) (f221 . -8))
# var=f221
    movl -8(%esp), %eax  # stack load f221
>>>>>>> fix-implicit-begins
# end emit-variable-ref
    movl %eax, -16(%esp)  # stack save
# emit-tail-expr
# si=-20
<<<<<<< HEAD
# env=((f311009 . -16) (f311008 . -12) (f311009 . -8))
# expr=(let ((f311011 (if (null? f311008) ((primitive-ref current-output-port)) (car f311008)))) ((primitive-ref base-write) f311009 f311011 #f))
# emit-tail-let
#  si   = -20
#  env  = ((f311009 . -16) (f311008 . -12) (f311009 . -8))
#  bindings = ((f311011 (if (null? f311008) ((primitive-ref current-output-port)) (car f311008))))
#  body = ((primitive-ref base-write) f311009 f311011 #f)
# emit-expr (if (null? f311008) ((primitive-ref current-output-port)) (car f311008))
# emit-expr (null? f311008)
# emit-expr f311008
# emit-variable-ref
# env=((f311009 . -16) (f311008 . -12) (f311009 . -8))
# var=f311008
    movl -12(%esp), %eax  # stack load f311008
=======
# env=((f221 . -16) (f222 . -12) (f221 . -8))
# expr=(let ((f224 (if (null? f222) ((primitive-ref current-output-port)) (car f222)))) ((primitive-ref base-write) f221 f224 #f))
# emit-tail-let
#  si   = -20
#  env  = ((f221 . -16) (f222 . -12) (f221 . -8))
#  bindings = ((f224 (if (null? f222) ((primitive-ref current-output-port)) (car f222))))
#  body = ((primitive-ref base-write) f221 f224 #f)
# emit-expr (if (null? f222) ((primitive-ref current-output-port)) (car f222))
# emit-expr (null? f222)
# emit-expr f222
# emit-variable-ref
# env=((f221 . -16) (f222 . -12) (f221 . -8))
# var=f222
    movl -12(%esp), %eax  # stack load f222
>>>>>>> fix-implicit-begins
# end emit-variable-ref
    cmp $63, %eax
    mov $0, %eax
    sete %al
    movzbl %al, %eax
    sal $6, %al
    or $47, %al
    cmp $47, %al
    je _L_1392
# emit-expr ((primitive-ref current-output-port))
# funcall
#    si   =-20
<<<<<<< HEAD
#    env  = ((f311009 . -16) (f311008 . -12) (f311009 . -8))
=======
#    env  = ((f221 . -16) (f222 . -12) (f221 . -8))
>>>>>>> fix-implicit-begins
#    expr = (funcall (primitive-ref current-output-port))
# emit-expr (primitive-ref current-output-port)
    .extern mrc_current$moutput$mport
    movl mrc_current$moutput$mport,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1394"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1394":
   movl %eax,  -28(%esp)  # stash funcall-oper in closure slot
    movl -28(%esp), %edi   # load new closure to %edi
    add $-20, %esp   # adjust base
    movl $0,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $20, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
<<<<<<< HEAD
    jmp _L_1884992
_L_1884991:
# emit-expr (car f311008)
# emit-expr f311008
# emit-variable-ref
# env=((f311009 . -16) (f311008 . -12) (f311009 . -8))
# var=f311008
    movl -12(%esp), %eax  # stack load f311008
=======
    jmp _L_1393
_L_1392:
# emit-expr (car f222)
# emit-expr f222
# emit-variable-ref
# env=((f221 . -16) (f222 . -12) (f221 . -8))
# var=f222
    movl -12(%esp), %eax  # stack load f222
>>>>>>> fix-implicit-begins
# end emit-variable-ref
# check the argument is a pair
    movl %eax,%ebx
    and $7, %bl
    cmp $1, %bl
    je _L_1395
# invoke error handler eh_pair
    .extern mrc_eh$upair
    movl mrc_eh$upair, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $116,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1395:
    movl -1(%eax), %eax
_L_1393:
    movl %eax, -20(%esp)  # stack save
# emit-tail-expr
# si=-24
<<<<<<< HEAD
# env=((f311011 . -20) (f311009 . -16) (f311008 . -12) (f311009 . -8))
# expr=((primitive-ref base-write) f311009 f311011 #f)
# emit-tail-funcall
#    si   =-24
#    env  = ((f311011 . -20) (f311009 . -16) (f311008 . -12) (f311009 . -8))
#    expr = (funcall (primitive-ref base-write) f311009 f311011 #f)
=======
# env=((f224 . -20) (f221 . -16) (f222 . -12) (f221 . -8))
# expr=((primitive-ref base-write) f221 f224 #f)
# emit-tail-funcall
#    si   =-24
#    env  = ((f224 . -20) (f221 . -16) (f222 . -12) (f221 . -8))
#    expr = (funcall (primitive-ref base-write) f221 f224 #f)
>>>>>>> fix-implicit-begins
# emit-expr (primitive-ref base-write)
    .extern mrc_base$mwrite
    movl mrc_base$mwrite,%eax
   movl %eax,  -24(%esp)  # stash funcall-oper in next closure slot
<<<<<<< HEAD
# emit-expr f311009
# emit-variable-ref
# env=((f311011 . -20) (f311009 . -16) (f311008 . -12) (f311009 . -8))
# var=f311009
    movl -16(%esp), %eax  # stack load f311009
# end emit-variable-ref
    mov %eax, -28(%esp)    # arg f311009
# emit-expr f311011
# emit-variable-ref
# env=((f311011 . -20) (f311009 . -16) (f311008 . -12) (f311009 . -8))
# var=f311011
    movl -20(%esp), %eax  # stack load f311011
=======
# emit-expr f221
# emit-variable-ref
# env=((f224 . -20) (f221 . -16) (f222 . -12) (f221 . -8))
# var=f221
    movl -16(%esp), %eax  # stack load f221
# end emit-variable-ref
    mov %eax, -28(%esp)    # arg f221
# emit-expr f224
# emit-variable-ref
# env=((f224 . -20) (f221 . -16) (f222 . -12) (f221 . -8))
# var=f224
    movl -20(%esp), %eax  # stack load f224
>>>>>>> fix-implicit-begins
# end emit-variable-ref
    mov %eax, -32(%esp)    # arg f224
# emit-expr #f
    movl $47, %eax     # immed #f
    mov %eax, -36(%esp)    # arg #f
    movl -24(%esp), %edi   # load new closure to %edi
# emit-shift-args:  size=4   si=-24  delta=20
    mov -24(%esp), %ebx  # shift frame cell
    mov %ebx, -4(%esp)  # down to base
# emit-shift-args:  size=3   si=-28  delta=20
    mov -28(%esp), %ebx  # shift frame cell
    mov %ebx, -8(%esp)  # down to base
# emit-shift-args:  size=2   si=-32  delta=20
    mov -32(%esp), %ebx  # shift frame cell
    mov %ebx, -12(%esp)  # down to base
# emit-shift-args:  size=1   si=-36  delta=20
    mov -36(%esp), %ebx  # shift frame cell
    mov %ebx, -16(%esp)  # down to base
# emit-shift-args:  size=0   si=-40  delta=20
    movl $12,%eax   # save arg count
    jmp *-2(%edi)  # tail-funcall
    .align 4,0x90
_L_1388:
     movl %eax, mrc_write
# == explicit-begins  ==>
# (lambda (expr . args) (let ((p (if (null? args) (current-output-port) (car args)))) (base-write expr p #t)))
# == eliminate-let*  ==>
# (lambda (expr . args) (let ((p (if (null? args) (current-output-port) (car args)))) (base-write expr p #t)))
# == uniquify-variables  ==>
<<<<<<< HEAD
# (lambda (f311013 . f311012) (let ((f311015 (if (null? f311012) (current-output-port) (car f311012)))) (base-write f311013 f311015 #t)))
# == vectorize-letrec  ==>
# (lambda (f311013 . f311012) (let ((f311015 (if (null? f311012) (current-output-port) (car f311012)))) (base-write f311013 f311015 #t)))
# == eliminate-set!  ==>
# (lambda (f311013 . f311012) (let ((f311013 f311013)) (let ((f311015 (if (null? f311012) (current-output-port) (car f311012)))) (base-write f311013 f311015 #t))))
# == close-free-variables  ==>
# (closure (f311013 . f311012) () (let ((f311013 f311013)) (let ((f311015 (if (null? f311012) (current-output-port) (car f311012)))) (base-write f311013 f311015 #t))))
# == eliminate-quote  ==>
# (closure (f311013 . f311012) () (let ((f311013 f311013)) (let ((f311015 (if (null? f311012) (current-output-port) (car f311012)))) (base-write f311013 f311015 #t))))
# == eliminate-when/unless  ==>
# (closure (f311013 . f311012) () (let ((f311013 f311013)) (let ((f311015 (if (null? f311012) (current-output-port) (car f311012)))) (base-write f311013 f311015 #t))))
# == eliminate-cond  ==>
# (closure (f311013 . f311012) () (let ((f311013 f311013)) (let ((f311015 (if (null? f311012) (current-output-port) (car f311012)))) (base-write f311013 f311015 #t))))
# == external-symbols  ==>
# (closure (f311013 . f311012) () (let ((f311013 f311013)) (let ((f311015 (if (null? f311012) ((primitive-ref current-output-port)) (car f311012)))) ((primitive-ref base-write) f311013 f311015 #t))))
# emit-expr (closure (f311013 . f311012) () (let ((f311013 f311013)) (let ((f311015 (if (null? f311012) ((primitive-ref current-output-port)) (car f311012)))) ((primitive-ref base-write) f311013 f311015 #t))))
# emit-closure
# si = 0
# env = ()
# expr = (closure (f311013 . f311012) () (let ((f311013 f311013)) (let ((f311015 (if (null? f311012) ((primitive-ref current-output-port)) (car f311012)))) ((primitive-ref base-write) f311013 f311015 #t))))
    movl $_L_1884995, 0(%ebp)  # closure label
=======
# (lambda (f225 . f226) (let ((f228 (if (null? f226) (current-output-port) (car f226)))) (base-write f225 f228 #t)))
# == vectorize-letrec  ==>
# (lambda (f225 . f226) (let ((f228 (if (null? f226) (current-output-port) (car f226)))) (base-write f225 f228 #t)))
# == eliminate-set!  ==>
# (lambda (f225 . f226) (let ((f225 f225)) (let ((f228 (if (null? f226) (current-output-port) (car f226)))) (base-write f225 f228 #t))))
# == close-free-variables  ==>
# (closure (f225 . f226) () (let ((f225 f225)) (let ((f228 (if (null? f226) (current-output-port) (car f226)))) (base-write f225 f228 #t))))
# == eliminate-quote  ==>
# (closure (f225 . f226) () (let ((f225 f225)) (let ((f228 (if (null? f226) (current-output-port) (car f226)))) (base-write f225 f228 #t))))
# == eliminate-when/unless  ==>
# (closure (f225 . f226) () (let ((f225 f225)) (let ((f228 (if (null? f226) (current-output-port) (car f226)))) (base-write f225 f228 #t))))
# == eliminate-cond  ==>
# (closure (f225 . f226) () (let ((f225 f225)) (let ((f228 (if (null? f226) (current-output-port) (car f226)))) (base-write f225 f228 #t))))
# == external-symbols  ==>
# (closure (f225 . f226) () (let ((f225 f225)) (let ((f228 (if (null? f226) ((primitive-ref current-output-port)) (car f226)))) ((primitive-ref base-write) f225 f228 #t))))
# emit-expr (closure (f225 . f226) () (let ((f225 f225)) (let ((f228 (if (null? f226) ((primitive-ref current-output-port)) (car f226)))) ((primitive-ref base-write) f225 f228 #t))))
# emit-closure
# si = 0
# env = ()
# expr = (closure (f225 . f226) () (let ((f225 f225)) (let ((f228 (if (null? f226) ((primitive-ref current-output-port)) (car f226)))) ((primitive-ref base-write) f225 f228 #t))))
    movl $_L_1396, 0(%ebp)  # closure label
>>>>>>> fix-implicit-begins
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $8, %ebp     # bump ebp
    jmp _L_1397            # jump around closure body
_L_1396:
# check argument count
    cmp $4,%eax
    jge _L_1398
# invoke error handler eh_argcount_min
    .extern mrc_eh$uargcount$umin
    movl mrc_eh$uargcount$umin, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_1398:
# emit-build-varargs-list
    movl $63, %esi       # args <- () 
    lea -4(%esp),%edi    # edi <- esp-4
    subl %eax, %edi      # edi <- esp-4-eax    addr of arg[K+N] on stack
_L_1400:
    lea -8(%esp),%ebx    # addr of arg[K] on stack
    cmp %edi, %ebx       # while edi <> esp+(si+4)
    je _L_1399
    movl (%edi),%ebx     # arg i -> car
    movl %ebx, 0(%ebp)
    movl %esi, 4(%ebp)  # esi -> cdr
    movl %ebp, %esi
    addl $1, %esi       # tag as pair
    addl $8,%ebp         # bump heap ptr
    addl $4,%edi         # move to next previous arg from the end
    jmp _L_1400
_L_1399:
    movl %esi, -12(%esp)  # set args
# emit-tail-expr
# si=-16
<<<<<<< HEAD
# env=((f311012 . -12) (f311013 . -8))
# expr=(let ((f311013 f311013)) (let ((f311015 (if (null? f311012) ((primitive-ref current-output-port)) (car f311012)))) ((primitive-ref base-write) f311013 f311015 #t)))
# emit-tail-let
#  si   = -16
#  env  = ((f311012 . -12) (f311013 . -8))
#  bindings = ((f311013 f311013))
#  body = (let ((f311015 (if (null? f311012) ((primitive-ref current-output-port)) (car f311012)))) ((primitive-ref base-write) f311013 f311015 #t))
# emit-expr f311013
# emit-variable-ref
# env=((f311012 . -12) (f311013 . -8))
# var=f311013
    movl -8(%esp), %eax  # stack load f311013
=======
# env=((f226 . -12) (f225 . -8))
# expr=(let ((f225 f225)) (let ((f228 (if (null? f226) ((primitive-ref current-output-port)) (car f226)))) ((primitive-ref base-write) f225 f228 #t)))
# emit-tail-let
#  si   = -16
#  env  = ((f226 . -12) (f225 . -8))
#  bindings = ((f225 f225))
#  body = (let ((f228 (if (null? f226) ((primitive-ref current-output-port)) (car f226)))) ((primitive-ref base-write) f225 f228 #t))
# emit-expr f225
# emit-variable-ref
# env=((f226 . -12) (f225 . -8))
# var=f225
    movl -8(%esp), %eax  # stack load f225
>>>>>>> fix-implicit-begins
# end emit-variable-ref
    movl %eax, -16(%esp)  # stack save
# emit-tail-expr
# si=-20
<<<<<<< HEAD
# env=((f311013 . -16) (f311012 . -12) (f311013 . -8))
# expr=(let ((f311015 (if (null? f311012) ((primitive-ref current-output-port)) (car f311012)))) ((primitive-ref base-write) f311013 f311015 #t))
# emit-tail-let
#  si   = -20
#  env  = ((f311013 . -16) (f311012 . -12) (f311013 . -8))
#  bindings = ((f311015 (if (null? f311012) ((primitive-ref current-output-port)) (car f311012))))
#  body = ((primitive-ref base-write) f311013 f311015 #t)
# emit-expr (if (null? f311012) ((primitive-ref current-output-port)) (car f311012))
# emit-expr (null? f311012)
# emit-expr f311012
# emit-variable-ref
# env=((f311013 . -16) (f311012 . -12) (f311013 . -8))
# var=f311012
    movl -12(%esp), %eax  # stack load f311012
=======
# env=((f225 . -16) (f226 . -12) (f225 . -8))
# expr=(let ((f228 (if (null? f226) ((primitive-ref current-output-port)) (car f226)))) ((primitive-ref base-write) f225 f228 #t))
# emit-tail-let
#  si   = -20
#  env  = ((f225 . -16) (f226 . -12) (f225 . -8))
#  bindings = ((f228 (if (null? f226) ((primitive-ref current-output-port)) (car f226))))
#  body = ((primitive-ref base-write) f225 f228 #t)
# emit-expr (if (null? f226) ((primitive-ref current-output-port)) (car f226))
# emit-expr (null? f226)
# emit-expr f226
# emit-variable-ref
# env=((f225 . -16) (f226 . -12) (f225 . -8))
# var=f226
    movl -12(%esp), %eax  # stack load f226
>>>>>>> fix-implicit-begins
# end emit-variable-ref
    cmp $63, %eax
    mov $0, %eax
    sete %al
    movzbl %al, %eax
    sal $6, %al
    or $47, %al
    cmp $47, %al
    je _L_1401
# emit-expr ((primitive-ref current-output-port))
# funcall
#    si   =-20
<<<<<<< HEAD
#    env  = ((f311013 . -16) (f311012 . -12) (f311013 . -8))
=======
#    env  = ((f225 . -16) (f226 . -12) (f225 . -8))
>>>>>>> fix-implicit-begins
#    expr = (funcall (primitive-ref current-output-port))
# emit-expr (primitive-ref current-output-port)
    .extern mrc_current$moutput$mport
    movl mrc_current$moutput$mport,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1403"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1403":
   movl %eax,  -28(%esp)  # stash funcall-oper in closure slot
    movl -28(%esp), %edi   # load new closure to %edi
    add $-20, %esp   # adjust base
    movl $0,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $20, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
<<<<<<< HEAD
    jmp _L_1885001
_L_1885000:
# emit-expr (car f311012)
# emit-expr f311012
# emit-variable-ref
# env=((f311013 . -16) (f311012 . -12) (f311013 . -8))
# var=f311012
    movl -12(%esp), %eax  # stack load f311012
=======
    jmp _L_1402
_L_1401:
# emit-expr (car f226)
# emit-expr f226
# emit-variable-ref
# env=((f225 . -16) (f226 . -12) (f225 . -8))
# var=f226
    movl -12(%esp), %eax  # stack load f226
>>>>>>> fix-implicit-begins
# end emit-variable-ref
# check the argument is a pair
    movl %eax,%ebx
    and $7, %bl
    cmp $1, %bl
    je _L_1404
# invoke error handler eh_pair
    .extern mrc_eh$upair
    movl mrc_eh$upair, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $116,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1404:
    movl -1(%eax), %eax
_L_1402:
    movl %eax, -20(%esp)  # stack save
# emit-tail-expr
# si=-24
<<<<<<< HEAD
# env=((f311015 . -20) (f311013 . -16) (f311012 . -12) (f311013 . -8))
# expr=((primitive-ref base-write) f311013 f311015 #t)
# emit-tail-funcall
#    si   =-24
#    env  = ((f311015 . -20) (f311013 . -16) (f311012 . -12) (f311013 . -8))
#    expr = (funcall (primitive-ref base-write) f311013 f311015 #t)
=======
# env=((f228 . -20) (f225 . -16) (f226 . -12) (f225 . -8))
# expr=((primitive-ref base-write) f225 f228 #t)
# emit-tail-funcall
#    si   =-24
#    env  = ((f228 . -20) (f225 . -16) (f226 . -12) (f225 . -8))
#    expr = (funcall (primitive-ref base-write) f225 f228 #t)
>>>>>>> fix-implicit-begins
# emit-expr (primitive-ref base-write)
    .extern mrc_base$mwrite
    movl mrc_base$mwrite,%eax
   movl %eax,  -24(%esp)  # stash funcall-oper in next closure slot
<<<<<<< HEAD
# emit-expr f311013
# emit-variable-ref
# env=((f311015 . -20) (f311013 . -16) (f311012 . -12) (f311013 . -8))
# var=f311013
    movl -16(%esp), %eax  # stack load f311013
# end emit-variable-ref
    mov %eax, -28(%esp)    # arg f311013
# emit-expr f311015
# emit-variable-ref
# env=((f311015 . -20) (f311013 . -16) (f311012 . -12) (f311013 . -8))
# var=f311015
    movl -20(%esp), %eax  # stack load f311015
=======
# emit-expr f225
# emit-variable-ref
# env=((f228 . -20) (f225 . -16) (f226 . -12) (f225 . -8))
# var=f225
    movl -16(%esp), %eax  # stack load f225
# end emit-variable-ref
    mov %eax, -28(%esp)    # arg f225
# emit-expr f228
# emit-variable-ref
# env=((f228 . -20) (f225 . -16) (f226 . -12) (f225 . -8))
# var=f228
    movl -20(%esp), %eax  # stack load f228
>>>>>>> fix-implicit-begins
# end emit-variable-ref
    mov %eax, -32(%esp)    # arg f228
# emit-expr #t
    movl $111, %eax     # immed #t
    mov %eax, -36(%esp)    # arg #t
    movl -24(%esp), %edi   # load new closure to %edi
# emit-shift-args:  size=4   si=-24  delta=20
    mov -24(%esp), %ebx  # shift frame cell
    mov %ebx, -4(%esp)  # down to base
# emit-shift-args:  size=3   si=-28  delta=20
    mov -28(%esp), %ebx  # shift frame cell
    mov %ebx, -8(%esp)  # down to base
# emit-shift-args:  size=2   si=-32  delta=20
    mov -32(%esp), %ebx  # shift frame cell
    mov %ebx, -12(%esp)  # down to base
# emit-shift-args:  size=1   si=-36  delta=20
    mov -36(%esp), %ebx  # shift frame cell
    mov %ebx, -16(%esp)  # down to base
# emit-shift-args:  size=0   si=-40  delta=20
    movl $12,%eax   # save arg count
    jmp *-2(%edi)  # tail-funcall
    .align 4,0x90
_L_1397:
     movl %eax, mrc_display
# == explicit-begins  ==>
# (lambda (i) (fixnum->char i))
# == eliminate-let*  ==>
# (lambda (i) (fixnum->char i))
# == uniquify-variables  ==>
# (lambda (f229) (fixnum->char f229))
# == vectorize-letrec  ==>
# (lambda (f229) (fixnum->char f229))
# == eliminate-set!  ==>
# (lambda (f229) (let ((f229 f229)) (fixnum->char f229)))
# == close-free-variables  ==>
# (closure (f229) () (let ((f229 f229)) (fixnum->char f229)))
# == eliminate-quote  ==>
# (closure (f229) () (let ((f229 f229)) (fixnum->char f229)))
# == eliminate-when/unless  ==>
# (closure (f229) () (let ((f229 f229)) (fixnum->char f229)))
# == eliminate-cond  ==>
# (closure (f229) () (let ((f229 f229)) (fixnum->char f229)))
# == external-symbols  ==>
# (closure (f229) () (let ((f229 f229)) (fixnum->char f229)))
# emit-expr (closure (f229) () (let ((f229 f229)) (fixnum->char f229)))
# emit-closure
# si = 0
# env = ()
# expr = (closure (f229) () (let ((f229 f229)) (fixnum->char f229)))
    movl $_L_1405, 0(%ebp)  # closure label
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $8, %ebp     # bump ebp
    jmp _L_1406            # jump around closure body
_L_1405:
# check argument count
    cmp $4,%eax
    je _L_1407
# invoke error handler eh_argcount
    .extern mrc_eh$uargcount
    movl mrc_eh$uargcount, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_1407:
# emit-tail-expr
# si=-12
# env=((f229 . -8))
# expr=(let ((f229 f229)) (fixnum->char f229))
# emit-tail-let
#  si   = -12
#  env  = ((f229 . -8))
#  bindings = ((f229 f229))
#  body = (fixnum->char f229)
# emit-expr f229
# emit-variable-ref
# env=((f229 . -8))
# var=f229
    movl -8(%esp), %eax  # stack load f229
# end emit-variable-ref
    movl %eax, -12(%esp)  # stack save
# emit-tail-expr
# si=-16
# env=((f229 . -12) (f229 . -8))
# expr=(fixnum->char f229)
# tail primcall
# emit-expr f229
# emit-variable-ref
# env=((f229 . -12) (f229 . -8))
# var=f229
    movl -12(%esp), %eax  # stack load f229
# end emit-variable-ref
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1408"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $0,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1408:
    shll $6, %eax
    orl $15, %eax
#return from tail (fixnum->char f229)
    ret
    .align 4,0x90
_L_1406:
     movl %eax, mrc_integer$m$gchar
# == explicit-begins  ==>
# (let* ((p (make-vector 8)) (sz 1024)) (begin (vector-set! p 0 (quote input-port)) (vector-set! p 1 "/dev/stdin") (vector-set! p 2 0) (vector-set! p 3 (make-string sz)) (vector-set! p 4 0) (vector-set! p 5 sz) (vector-set! p 6 #f) (vector-set! p 7 -1) p))
# == eliminate-let*  ==>
# (let ((p (make-vector 8))) (let ((sz 1024)) (begin (vector-set! p 0 (quote input-port)) (vector-set! p 1 "/dev/stdin") (vector-set! p 2 0) (vector-set! p 3 (make-string sz)) (vector-set! p 4 0) (vector-set! p 5 sz) (vector-set! p 6 #f) (vector-set! p 7 -1) p)))
# == uniquify-variables  ==>
# (let ((f230 (make-vector 8))) (let ((f232 1024)) (begin (vector-set! f230 0 (quote input-port)) (vector-set! f230 1 "/dev/stdin") (vector-set! f230 2 0) (vector-set! f230 3 (make-string f232)) (vector-set! f230 4 0) (vector-set! f230 5 f232) (vector-set! f230 6 #f) (vector-set! f230 7 -1) f230)))
# == vectorize-letrec  ==>
# (let ((f230 (make-vector 8))) (let ((f232 1024)) (begin (vector-set! f230 0 (quote input-port)) (vector-set! f230 1 "/dev/stdin") (vector-set! f230 2 0) (vector-set! f230 3 (make-string f232)) (vector-set! f230 4 0) (vector-set! f230 5 f232) (vector-set! f230 6 #f) (vector-set! f230 7 -1) f230)))
# == eliminate-set!  ==>
# (let ((f230 (make-vector 8))) (let ((f232 1024)) (begin (vector-set! f230 0 (quote input-port)) (vector-set! f230 1 "/dev/stdin") (vector-set! f230 2 0) (vector-set! f230 3 (make-string f232)) (vector-set! f230 4 0) (vector-set! f230 5 f232) (vector-set! f230 6 #f) (vector-set! f230 7 -1) f230)))
# == close-free-variables  ==>
# (let ((f230 (make-vector 8))) (let ((f232 1024)) (begin (vector-set! f230 0 (quote input-port)) (vector-set! f230 1 "/dev/stdin") (vector-set! f230 2 0) (vector-set! f230 3 (make-string f232)) (vector-set! f230 4 0) (vector-set! f230 5 f232) (vector-set! f230 6 #f) (vector-set! f230 7 -1) f230)))
# == eliminate-quote  ==>
# (let ((f230 (make-vector 8))) (let ((f232 1024)) (begin (vector-set! f230 0 (string->symbol "input-port")) (vector-set! f230 1 "/dev/stdin") (vector-set! f230 2 0) (vector-set! f230 3 (make-string f232)) (vector-set! f230 4 0) (vector-set! f230 5 f232) (vector-set! f230 6 #f) (vector-set! f230 7 -1) f230)))
# == eliminate-when/unless  ==>
# (let ((f230 (make-vector 8))) (let ((f232 1024)) (begin (vector-set! f230 0 (string->symbol "input-port")) (vector-set! f230 1 "/dev/stdin") (vector-set! f230 2 0) (vector-set! f230 3 (make-string f232)) (vector-set! f230 4 0) (vector-set! f230 5 f232) (vector-set! f230 6 #f) (vector-set! f230 7 -1) f230)))
# == eliminate-cond  ==>
# (let ((f230 (make-vector 8))) (let ((f232 1024)) (begin (vector-set! f230 0 (string->symbol "input-port")) (vector-set! f230 1 "/dev/stdin") (vector-set! f230 2 0) (vector-set! f230 3 (make-string f232)) (vector-set! f230 4 0) (vector-set! f230 5 f232) (vector-set! f230 6 #f) (vector-set! f230 7 -1) f230)))
# == external-symbols  ==>
# (let ((f230 (make-vector 8))) (let ((f232 1024)) (begin (vector-set! f230 0 ((primitive-ref string->symbol) "input-port")) (vector-set! f230 1 "/dev/stdin") (vector-set! f230 2 0) (vector-set! f230 3 (make-string f232)) (vector-set! f230 4 0) (vector-set! f230 5 f232) (vector-set! f230 6 #f) (vector-set! f230 7 -1) f230)))
# emit-expr (let ((f230 (make-vector 8))) (let ((f232 1024)) (begin (vector-set! f230 0 ((primitive-ref string->symbol) "input-port")) (vector-set! f230 1 "/dev/stdin") (vector-set! f230 2 0) (vector-set! f230 3 (make-string f232)) (vector-set! f230 4 0) (vector-set! f230 5 f232) (vector-set! f230 6 #f) (vector-set! f230 7 -1) f230)))
# emit-let
#  si   = 0
#  env  = ()
#  bindings = ((f230 (make-vector 8)))
#  body = (let ((f232 1024)) (begin (vector-set! f230 0 ((primitive-ref string->symbol) "input-port")) (vector-set! f230 1 "/dev/stdin") (vector-set! f230 2 0) (vector-set! f230 3 (make-string f232)) (vector-set! f230 4 0) (vector-set! f230 5 f232) (vector-set! f230 6 #f) (vector-set! f230 7 -1) f230))
# emit-expr (make-vector 8)
# make-vector 8
# emit-expr 8
    movl $32, %eax     # immed 8
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1409"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1409:
# check the argument is a fixnum >= 0
    cmp $0,%eax
    jge _L_1410
# invoke error handler eh_length
    .extern mrc_eh$ulength
    movl mrc_eh$ulength, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1410:
    movl %eax, %esi
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    orl  $5, %eax
    addl $4, %esi
    addl $4, %esi
    andl $-8, %esi
    addl %esi, %ebp
    movl %eax, 0(%esp)  # stack save
# emit-expr (let ((f232 1024)) (begin (vector-set! f230 0 ((primitive-ref string->symbol) "input-port")) (vector-set! f230 1 "/dev/stdin") (vector-set! f230 2 0) (vector-set! f230 3 (make-string f232)) (vector-set! f230 4 0) (vector-set! f230 5 f232) (vector-set! f230 6 #f) (vector-set! f230 7 -1) f230))
# emit-let
#  si   = -4
#  env  = ((f230 . 0))
#  bindings = ((f232 1024))
#  body = (begin (vector-set! f230 0 ((primitive-ref string->symbol) "input-port")) (vector-set! f230 1 "/dev/stdin") (vector-set! f230 2 0) (vector-set! f230 3 (make-string f232)) (vector-set! f230 4 0) (vector-set! f230 5 f232) (vector-set! f230 6 #f) (vector-set! f230 7 -1) f230)
# emit-expr 1024
    movl $4096, %eax     # immed 1024
    movl %eax, -4(%esp)  # stack save
# emit-expr (begin (vector-set! f230 0 ((primitive-ref string->symbol) "input-port")) (vector-set! f230 1 "/dev/stdin") (vector-set! f230 2 0) (vector-set! f230 3 (make-string f232)) (vector-set! f230 4 0) (vector-set! f230 5 f232) (vector-set! f230 6 #f) (vector-set! f230 7 -1) f230)
# emit-begin
#   expr=(begin (vector-set! f230 0 ((primitive-ref string->symbol) "input-port")) (vector-set! f230 1 "/dev/stdin") (vector-set! f230 2 0) (vector-set! f230 3 (make-string f232)) (vector-set! f230 4 0) (vector-set! f230 5 f232) (vector-set! f230 6 #f) (vector-set! f230 7 -1) f230)
#   env=((f232 . -4) (f230 . 0))
# emit-expr (vector-set! f230 0 ((primitive-ref string->symbol) "input-port"))
# emit-expr f230
# emit-variable-ref
# env=((f232 . -4) (f230 . 0))
# var=f230
    movl 0(%esp), %eax  # stack load f230
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1411
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1411:
    movl %eax, -8(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1412"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1412:
# check bounds on vector index
    movl -8(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1414
    cmp  $0,%eax
    jge _L_1413
_L_1414:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1413:
    movl %eax, -12(%esp)
# emit-expr ((primitive-ref string->symbol) "input-port")
# funcall
#    si   =-16
#    env  = ((f232 . -4) (f230 . 0))
#    expr = (funcall (primitive-ref string->symbol) "input-port")
# emit-expr (primitive-ref string->symbol)
    .extern mrc_string$m$gsymbol
    movl mrc_string$m$gsymbol,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1415"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1415":
   movl %eax,  -24(%esp)  # stash funcall-oper in closure slot
# emit-expr "input-port"
# string literal
    jmp _L_1417
    .align 8,0x90
_L_1416 :
    .int 40
    .ascii "input-port"
_L_1417:
    movl $_L_1416, %eax
    orl $6, %eax
    mov %eax, -28(%esp)  # arg input-port
    movl -24(%esp), %edi   # load new closure to %edi
    add $-16, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $16, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    movl -8(%esp), %ebx
    movl -12(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin (vector-set! f230 1 "/dev/stdin") (vector-set! f230 2 0) (vector-set! f230 3 (make-string f232)) (vector-set! f230 4 0) (vector-set! f230 5 f232) (vector-set! f230 6 #f) (vector-set! f230 7 -1) f230)
# emit-begin
#   expr=(begin (vector-set! f230 1 "/dev/stdin") (vector-set! f230 2 0) (vector-set! f230 3 (make-string f232)) (vector-set! f230 4 0) (vector-set! f230 5 f232) (vector-set! f230 6 #f) (vector-set! f230 7 -1) f230)
#   env=((f232 . -4) (f230 . 0))
# emit-expr (vector-set! f230 1 "/dev/stdin")
# emit-expr f230
# emit-variable-ref
# env=((f232 . -4) (f230 . 0))
# var=f230
    movl 0(%esp), %eax  # stack load f230
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1418
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1418:
    movl %eax, -8(%esp)
# emit-expr 1
    movl $4, %eax     # immed 1
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1419"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1419:
# check bounds on vector index
    movl -8(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1421
    cmp  $0,%eax
    jge _L_1420
_L_1421:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1420:
    movl %eax, -12(%esp)
# emit-expr "/dev/stdin"
# string literal
    jmp _L_1423
    .align 8,0x90
_L_1422 :
    .int 40
    .ascii "/dev/stdin"
_L_1423:
    movl $_L_1422, %eax
    orl $6, %eax
    movl -8(%esp), %ebx
    movl -12(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin (vector-set! f230 2 0) (vector-set! f230 3 (make-string f232)) (vector-set! f230 4 0) (vector-set! f230 5 f232) (vector-set! f230 6 #f) (vector-set! f230 7 -1) f230)
# emit-begin
#   expr=(begin (vector-set! f230 2 0) (vector-set! f230 3 (make-string f232)) (vector-set! f230 4 0) (vector-set! f230 5 f232) (vector-set! f230 6 #f) (vector-set! f230 7 -1) f230)
#   env=((f232 . -4) (f230 . 0))
# emit-expr (vector-set! f230 2 0)
# emit-expr f230
# emit-variable-ref
# env=((f232 . -4) (f230 . 0))
# var=f230
    movl 0(%esp), %eax  # stack load f230
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1424
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1424:
    movl %eax, -8(%esp)
# emit-expr 2
    movl $8, %eax     # immed 2
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1425"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1425:
# check bounds on vector index
    movl -8(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1427
    cmp  $0,%eax
    jge _L_1426
_L_1427:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1426:
    movl %eax, -12(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
    movl -8(%esp), %ebx
    movl -12(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin (vector-set! f230 3 (make-string f232)) (vector-set! f230 4 0) (vector-set! f230 5 f232) (vector-set! f230 6 #f) (vector-set! f230 7 -1) f230)
# emit-begin
#   expr=(begin (vector-set! f230 3 (make-string f232)) (vector-set! f230 4 0) (vector-set! f230 5 f232) (vector-set! f230 6 #f) (vector-set! f230 7 -1) f230)
#   env=((f232 . -4) (f230 . 0))
# emit-expr (vector-set! f230 3 (make-string f232))
# emit-expr f230
# emit-variable-ref
# env=((f232 . -4) (f230 . 0))
# var=f230
    movl 0(%esp), %eax  # stack load f230
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1428
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1428:
    movl %eax, -8(%esp)
# emit-expr 3
    movl $12, %eax     # immed 3
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1429"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1429:
# check bounds on vector index
    movl -8(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1431
    cmp  $0,%eax
    jge _L_1430
_L_1431:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1430:
    movl %eax, -12(%esp)
# emit-expr (make-string f232)
# make-string len=f232
# emit-expr f232
# emit-variable-ref
# env=((f232 . -4) (f230 . 0))
# var=f232
    movl -4(%esp), %eax  # stack load f232
# end emit-variable-ref
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1432"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $152,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1432:
# check the argument is a fixnum >= 0
    cmp $0,%eax
    jge _L_1433
# invoke error handler eh_length
    .extern mrc_eh$ulength
    movl mrc_eh$ulength, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $152,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1433:
    movl %eax, %esi
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    orl $6, %eax
    sar $2, %esi
    add $4, %esi
    add $7, %esi
    andl $-8, %esi
    add  %esi, %ebp
# make-string end
    movl -8(%esp), %ebx
    movl -12(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin (vector-set! f230 4 0) (vector-set! f230 5 f232) (vector-set! f230 6 #f) (vector-set! f230 7 -1) f230)
# emit-begin
#   expr=(begin (vector-set! f230 4 0) (vector-set! f230 5 f232) (vector-set! f230 6 #f) (vector-set! f230 7 -1) f230)
#   env=((f232 . -4) (f230 . 0))
# emit-expr (vector-set! f230 4 0)
# emit-expr f230
# emit-variable-ref
# env=((f232 . -4) (f230 . 0))
# var=f230
    movl 0(%esp), %eax  # stack load f230
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1434
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1434:
    movl %eax, -8(%esp)
# emit-expr 4
    movl $16, %eax     # immed 4
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1435"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1435:
# check bounds on vector index
    movl -8(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1437
    cmp  $0,%eax
    jge _L_1436
_L_1437:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1436:
    movl %eax, -12(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
    movl -8(%esp), %ebx
    movl -12(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin (vector-set! f230 5 f232) (vector-set! f230 6 #f) (vector-set! f230 7 -1) f230)
# emit-begin
#   expr=(begin (vector-set! f230 5 f232) (vector-set! f230 6 #f) (vector-set! f230 7 -1) f230)
#   env=((f232 . -4) (f230 . 0))
# emit-expr (vector-set! f230 5 f232)
# emit-expr f230
# emit-variable-ref
# env=((f232 . -4) (f230 . 0))
# var=f230
    movl 0(%esp), %eax  # stack load f230
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1438
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1438:
    movl %eax, -8(%esp)
# emit-expr 5
    movl $20, %eax     # immed 5
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1439"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1439:
# check bounds on vector index
    movl -8(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1441
    cmp  $0,%eax
    jge _L_1440
_L_1441:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1440:
    movl %eax, -12(%esp)
# emit-expr f232
# emit-variable-ref
# env=((f232 . -4) (f230 . 0))
# var=f232
    movl -4(%esp), %eax  # stack load f232
# end emit-variable-ref
    movl -8(%esp), %ebx
    movl -12(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin (vector-set! f230 6 #f) (vector-set! f230 7 -1) f230)
# emit-begin
#   expr=(begin (vector-set! f230 6 #f) (vector-set! f230 7 -1) f230)
#   env=((f232 . -4) (f230 . 0))
# emit-expr (vector-set! f230 6 #f)
# emit-expr f230
# emit-variable-ref
# env=((f232 . -4) (f230 . 0))
# var=f230
    movl 0(%esp), %eax  # stack load f230
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1442
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1442:
    movl %eax, -8(%esp)
# emit-expr 6
    movl $24, %eax     # immed 6
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1443"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1443:
# check bounds on vector index
    movl -8(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1445
    cmp  $0,%eax
    jge _L_1444
_L_1445:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1444:
    movl %eax, -12(%esp)
# emit-expr #f
    movl $47, %eax     # immed #f
    movl -8(%esp), %ebx
    movl -12(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin (vector-set! f230 7 -1) f230)
# emit-begin
#   expr=(begin (vector-set! f230 7 -1) f230)
#   env=((f232 . -4) (f230 . 0))
# emit-expr (vector-set! f230 7 -1)
# emit-expr f230
# emit-variable-ref
# env=((f232 . -4) (f230 . 0))
# var=f230
    movl 0(%esp), %eax  # stack load f230
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1446
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1446:
    movl %eax, -8(%esp)
# emit-expr 7
    movl $28, %eax     # immed 7
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1447"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1447:
# check bounds on vector index
    movl -8(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1449
    cmp  $0,%eax
    jge _L_1448
_L_1449:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1448:
    movl %eax, -12(%esp)
# emit-expr -1
    movl $-4, %eax     # immed -1
    movl -8(%esp), %ebx
    movl -12(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin f230)
# emit-begin
#   expr=(begin f230)
#   env=((f232 . -4) (f230 . 0))
# emit-expr f230
# emit-variable-ref
# env=((f232 . -4) (f230 . 0))
# var=f230
    movl 0(%esp), %eax  # stack load f230
# end emit-variable-ref
# emit-expr (begin)
# emit-begin
#   expr=(begin)
#   env=((f232 . -4) (f230 . 0))
     movl %eax, mrc_standard$min
# == explicit-begins  ==>
# (lambda (p) (vector-ref p 6))
# == eliminate-let*  ==>
# (lambda (p) (vector-ref p 6))
# == uniquify-variables  ==>
# (lambda (f233) (vector-ref f233 6))
# == vectorize-letrec  ==>
# (lambda (f233) (vector-ref f233 6))
# == eliminate-set!  ==>
# (lambda (f233) (let ((f233 f233)) (vector-ref f233 6)))
# == close-free-variables  ==>
# (closure (f233) () (let ((f233 f233)) (vector-ref f233 6)))
# == eliminate-quote  ==>
# (closure (f233) () (let ((f233 f233)) (vector-ref f233 6)))
# == eliminate-when/unless  ==>
# (closure (f233) () (let ((f233 f233)) (vector-ref f233 6)))
# == eliminate-cond  ==>
# (closure (f233) () (let ((f233 f233)) (vector-ref f233 6)))
# == external-symbols  ==>
# (closure (f233) () (let ((f233 f233)) (vector-ref f233 6)))
# emit-expr (closure (f233) () (let ((f233 f233)) (vector-ref f233 6)))
# emit-closure
# si = 0
# env = ()
# expr = (closure (f233) () (let ((f233 f233)) (vector-ref f233 6)))
    movl $_L_1450, 0(%ebp)  # closure label
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $8, %ebp     # bump ebp
    jmp _L_1451            # jump around closure body
_L_1450:
# check argument count
    cmp $4,%eax
    je _L_1452
# invoke error handler eh_argcount
    .extern mrc_eh$uargcount
    movl mrc_eh$uargcount, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_1452:
# emit-tail-expr
# si=-12
# env=((f233 . -8))
# expr=(let ((f233 f233)) (vector-ref f233 6))
# emit-tail-let
#  si   = -12
#  env  = ((f233 . -8))
#  bindings = ((f233 f233))
#  body = (vector-ref f233 6)
# emit-expr f233
# emit-variable-ref
# env=((f233 . -8))
# var=f233
    movl -8(%esp), %eax  # stack load f233
# end emit-variable-ref
    movl %eax, -12(%esp)  # stack save
# emit-tail-expr
# si=-16
# env=((f233 . -12) (f233 . -8))
# expr=(vector-ref f233 6)
# tail primcall
# emit-expr f233
# emit-variable-ref
# env=((f233 . -12) (f233 . -8))
# var=f233
    movl -12(%esp), %eax  # stack load f233
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1453
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1453:
    movl %eax, -16(%esp)
# emit-expr 6
    movl $24, %eax     # immed 6
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1454"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1454:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1456
    cmp  $0,%eax
    jge _L_1455
_L_1456:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1455:
    movl -16(%esp), %esi
    movl -1(%eax,%esi), %eax
#return from tail (vector-ref f233 6)
    ret
    .align 4,0x90
_L_1451:
     movl %eax, mrc_port$munread
# == explicit-begins  ==>
# (lambda (p) (vector-set! p 6 #f))
# == eliminate-let*  ==>
# (lambda (p) (vector-set! p 6 #f))
# == uniquify-variables  ==>
# (lambda (f234) (vector-set! f234 6 #f))
# == vectorize-letrec  ==>
# (lambda (f234) (vector-set! f234 6 #f))
# == eliminate-set!  ==>
# (lambda (f234) (let ((f234 f234)) (vector-set! f234 6 #f)))
# == close-free-variables  ==>
# (closure (f234) () (let ((f234 f234)) (vector-set! f234 6 #f)))
# == eliminate-quote  ==>
# (closure (f234) () (let ((f234 f234)) (vector-set! f234 6 #f)))
# == eliminate-when/unless  ==>
# (closure (f234) () (let ((f234 f234)) (vector-set! f234 6 #f)))
# == eliminate-cond  ==>
# (closure (f234) () (let ((f234 f234)) (vector-set! f234 6 #f)))
# == external-symbols  ==>
# (closure (f234) () (let ((f234 f234)) (vector-set! f234 6 #f)))
# emit-expr (closure (f234) () (let ((f234 f234)) (vector-set! f234 6 #f)))
# emit-closure
# si = 0
# env = ()
# expr = (closure (f234) () (let ((f234 f234)) (vector-set! f234 6 #f)))
    movl $_L_1457, 0(%ebp)  # closure label
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $8, %ebp     # bump ebp
    jmp _L_1458            # jump around closure body
_L_1457:
# check argument count
    cmp $4,%eax
    je _L_1459
# invoke error handler eh_argcount
    .extern mrc_eh$uargcount
    movl mrc_eh$uargcount, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_1459:
# emit-tail-expr
# si=-12
# env=((f234 . -8))
# expr=(let ((f234 f234)) (vector-set! f234 6 #f))
# emit-tail-let
#  si   = -12
#  env  = ((f234 . -8))
#  bindings = ((f234 f234))
#  body = (vector-set! f234 6 #f)
# emit-expr f234
# emit-variable-ref
# env=((f234 . -8))
# var=f234
    movl -8(%esp), %eax  # stack load f234
# end emit-variable-ref
    movl %eax, -12(%esp)  # stack save
# emit-tail-expr
# si=-16
# env=((f234 . -12) (f234 . -8))
# expr=(vector-set! f234 6 #f)
# tail primcall
# emit-expr f234
# emit-variable-ref
# env=((f234 . -12) (f234 . -8))
# var=f234
    movl -12(%esp), %eax  # stack load f234
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1460
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1460:
    movl %eax, -16(%esp)
# emit-expr 6
    movl $24, %eax     # immed 6
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1461"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1461:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1463
    cmp  $0,%eax
    jge _L_1462
_L_1463:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1462:
    movl %eax, -20(%esp)
# emit-expr #f
    movl $47, %eax     # immed #f
    movl -16(%esp), %ebx
    movl -20(%esp), %esi
    movl %eax, -1(%ebx,%esi)
#return from tail (vector-set! f234 6 #f)
    ret
    .align 4,0x90
_L_1458:
     movl %eax, mrc_port$munread$mclear
# == explicit-begins  ==>
# (lambda (p x) (vector-set! p 6 x))
# == eliminate-let*  ==>
# (lambda (p x) (vector-set! p 6 x))
# == uniquify-variables  ==>
<<<<<<< HEAD
# (lambda (f311023 f311022) (vector-set! f311023 6 f311022))
# == vectorize-letrec  ==>
# (lambda (f311023 f311022) (vector-set! f311023 6 f311022))
# == eliminate-set!  ==>
# (lambda (f311023 f311022) (let ((f311023 f311023) (f311022 f311022)) (vector-set! f311023 6 f311022)))
# == close-free-variables  ==>
# (closure (f311023 f311022) () (let ((f311023 f311023) (f311022 f311022)) (vector-set! f311023 6 f311022)))
# == eliminate-quote  ==>
# (closure (f311023 f311022) () (let ((f311023 f311023) (f311022 f311022)) (vector-set! f311023 6 f311022)))
# == eliminate-when/unless  ==>
# (closure (f311023 f311022) () (let ((f311023 f311023) (f311022 f311022)) (vector-set! f311023 6 f311022)))
# == eliminate-cond  ==>
# (closure (f311023 f311022) () (let ((f311023 f311023) (f311022 f311022)) (vector-set! f311023 6 f311022)))
# == external-symbols  ==>
# (closure (f311023 f311022) () (let ((f311023 f311023) (f311022 f311022)) (vector-set! f311023 6 f311022)))
# emit-expr (closure (f311023 f311022) () (let ((f311023 f311023) (f311022 f311022)) (vector-set! f311023 6 f311022)))
# emit-closure
# si = 0
# env = ()
# expr = (closure (f311023 f311022) () (let ((f311023 f311023) (f311022 f311022)) (vector-set! f311023 6 f311022)))
    movl $_L_1885063, 0(%ebp)  # closure label
=======
# (lambda (f235 f236) (vector-set! f235 6 f236))
# == vectorize-letrec  ==>
# (lambda (f235 f236) (vector-set! f235 6 f236))
# == eliminate-set!  ==>
# (lambda (f235 f236) (let ((f235 f235) (f236 f236)) (vector-set! f235 6 f236)))
# == close-free-variables  ==>
# (closure (f235 f236) () (let ((f235 f235) (f236 f236)) (vector-set! f235 6 f236)))
# == eliminate-quote  ==>
# (closure (f235 f236) () (let ((f235 f235) (f236 f236)) (vector-set! f235 6 f236)))
# == eliminate-when/unless  ==>
# (closure (f235 f236) () (let ((f235 f235) (f236 f236)) (vector-set! f235 6 f236)))
# == eliminate-cond  ==>
# (closure (f235 f236) () (let ((f235 f235) (f236 f236)) (vector-set! f235 6 f236)))
# == external-symbols  ==>
# (closure (f235 f236) () (let ((f235 f235) (f236 f236)) (vector-set! f235 6 f236)))
# emit-expr (closure (f235 f236) () (let ((f235 f235) (f236 f236)) (vector-set! f235 6 f236)))
# emit-closure
# si = 0
# env = ()
# expr = (closure (f235 f236) () (let ((f235 f235) (f236 f236)) (vector-set! f235 6 f236)))
    movl $_L_1464, 0(%ebp)  # closure label
>>>>>>> fix-implicit-begins
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $8, %ebp     # bump ebp
    jmp _L_1465            # jump around closure body
_L_1464:
# check argument count
    cmp $8,%eax
    je _L_1466
# invoke error handler eh_argcount
    .extern mrc_eh$uargcount
    movl mrc_eh$uargcount, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_1466:
# emit-tail-expr
# si=-16
<<<<<<< HEAD
# env=((f311022 . -12) (f311023 . -8))
# expr=(let ((f311023 f311023) (f311022 f311022)) (vector-set! f311023 6 f311022))
# emit-tail-let
#  si   = -16
#  env  = ((f311022 . -12) (f311023 . -8))
#  bindings = ((f311023 f311023) (f311022 f311022))
#  body = (vector-set! f311023 6 f311022)
# emit-expr f311023
# emit-variable-ref
# env=((f311022 . -12) (f311023 . -8))
# var=f311023
    movl -8(%esp), %eax  # stack load f311023
# end emit-variable-ref
    movl %eax, -16(%esp)  # stack save
# emit-expr f311022
# emit-variable-ref
# env=((f311022 . -12) (f311023 . -8))
# var=f311022
    movl -12(%esp), %eax  # stack load f311022
=======
# env=((f236 . -12) (f235 . -8))
# expr=(let ((f235 f235) (f236 f236)) (vector-set! f235 6 f236))
# emit-tail-let
#  si   = -16
#  env  = ((f236 . -12) (f235 . -8))
#  bindings = ((f235 f235) (f236 f236))
#  body = (vector-set! f235 6 f236)
# emit-expr f235
# emit-variable-ref
# env=((f236 . -12) (f235 . -8))
# var=f235
    movl -8(%esp), %eax  # stack load f235
# end emit-variable-ref
    movl %eax, -16(%esp)  # stack save
# emit-expr f236
# emit-variable-ref
# env=((f236 . -12) (f235 . -8))
# var=f236
    movl -12(%esp), %eax  # stack load f236
>>>>>>> fix-implicit-begins
# end emit-variable-ref
    movl %eax, -20(%esp)  # stack save
# emit-tail-expr
# si=-24
<<<<<<< HEAD
# env=((f311022 . -20) (f311023 . -16) (f311022 . -12) (f311023 . -8))
# expr=(vector-set! f311023 6 f311022)
# tail primcall
# emit-expr f311023
# emit-variable-ref
# env=((f311022 . -20) (f311023 . -16) (f311022 . -12) (f311023 . -8))
# var=f311023
    movl -16(%esp), %eax  # stack load f311023
=======
# env=((f236 . -20) (f235 . -16) (f236 . -12) (f235 . -8))
# expr=(vector-set! f235 6 f236)
# tail primcall
# emit-expr f235
# emit-variable-ref
# env=((f236 . -20) (f235 . -16) (f236 . -12) (f235 . -8))
# var=f235
    movl -16(%esp), %eax  # stack load f235
>>>>>>> fix-implicit-begins
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1467
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1467:
    movl %eax, -24(%esp)
# emit-expr 6
    movl $24, %eax     # immed 6
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1468"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1468:
# check bounds on vector index
    movl -24(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1470
    cmp  $0,%eax
    jge _L_1469
_L_1470:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1469:
    movl %eax, -28(%esp)
<<<<<<< HEAD
# emit-expr f311022
# emit-variable-ref
# env=((f311022 . -20) (f311023 . -16) (f311022 . -12) (f311023 . -8))
# var=f311022
    movl -20(%esp), %eax  # stack load f311022
=======
# emit-expr f236
# emit-variable-ref
# env=((f236 . -20) (f235 . -16) (f236 . -12) (f235 . -8))
# var=f236
    movl -20(%esp), %eax  # stack load f236
>>>>>>> fix-implicit-begins
# end emit-variable-ref
    movl -24(%esp), %ebx
    movl -28(%esp), %esi
    movl %eax, -1(%ebx,%esi)
<<<<<<< HEAD
#return from tail (vector-set! f311023 6 f311022)
=======
#return from tail (vector-set! f235 6 f236)
>>>>>>> fix-implicit-begins
    ret
    .align 4,0x90
_L_1465:
     movl %eax, mrc_port$munread$mset$b
# == explicit-begins  ==>
# (lambda (p) (vector-ref p 7))
# == eliminate-let*  ==>
# (lambda (p) (vector-ref p 7))
# == uniquify-variables  ==>
# (lambda (f237) (vector-ref f237 7))
# == vectorize-letrec  ==>
# (lambda (f237) (vector-ref f237 7))
# == eliminate-set!  ==>
# (lambda (f237) (let ((f237 f237)) (vector-ref f237 7)))
# == close-free-variables  ==>
# (closure (f237) () (let ((f237 f237)) (vector-ref f237 7)))
# == eliminate-quote  ==>
# (closure (f237) () (let ((f237 f237)) (vector-ref f237 7)))
# == eliminate-when/unless  ==>
# (closure (f237) () (let ((f237 f237)) (vector-ref f237 7)))
# == eliminate-cond  ==>
# (closure (f237) () (let ((f237 f237)) (vector-ref f237 7)))
# == external-symbols  ==>
# (closure (f237) () (let ((f237 f237)) (vector-ref f237 7)))
# emit-expr (closure (f237) () (let ((f237 f237)) (vector-ref f237 7)))
# emit-closure
# si = 0
# env = ()
# expr = (closure (f237) () (let ((f237 f237)) (vector-ref f237 7)))
    movl $_L_1471, 0(%ebp)  # closure label
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $8, %ebp     # bump ebp
    jmp _L_1472            # jump around closure body
_L_1471:
# check argument count
    cmp $4,%eax
    je _L_1473
# invoke error handler eh_argcount
    .extern mrc_eh$uargcount
    movl mrc_eh$uargcount, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_1473:
# emit-tail-expr
# si=-12
# env=((f237 . -8))
# expr=(let ((f237 f237)) (vector-ref f237 7))
# emit-tail-let
#  si   = -12
#  env  = ((f237 . -8))
#  bindings = ((f237 f237))
#  body = (vector-ref f237 7)
# emit-expr f237
# emit-variable-ref
# env=((f237 . -8))
# var=f237
    movl -8(%esp), %eax  # stack load f237
# end emit-variable-ref
    movl %eax, -12(%esp)  # stack save
# emit-tail-expr
# si=-16
# env=((f237 . -12) (f237 . -8))
# expr=(vector-ref f237 7)
# tail primcall
# emit-expr f237
# emit-variable-ref
# env=((f237 . -12) (f237 . -8))
# var=f237
    movl -12(%esp), %eax  # stack load f237
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1474
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1474:
    movl %eax, -16(%esp)
# emit-expr 7
    movl $28, %eax     # immed 7
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1475"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1475:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1477
    cmp  $0,%eax
    jge _L_1476
_L_1477:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1476:
    movl -16(%esp), %esi
    movl -1(%eax,%esi), %eax
#return from tail (vector-ref f237 7)
    ret
    .align 4,0x90
_L_1472:
     movl %eax, mrc_port$mlast
# == explicit-begins  ==>
# (lambda (p i) (vector-set! p 7 i))
# == eliminate-let*  ==>
# (lambda (p i) (vector-set! p 7 i))
# == uniquify-variables  ==>
<<<<<<< HEAD
# (lambda (f311026 f311025) (vector-set! f311026 7 f311025))
# == vectorize-letrec  ==>
# (lambda (f311026 f311025) (vector-set! f311026 7 f311025))
# == eliminate-set!  ==>
# (lambda (f311026 f311025) (let ((f311026 f311026) (f311025 f311025)) (vector-set! f311026 7 f311025)))
# == close-free-variables  ==>
# (closure (f311026 f311025) () (let ((f311026 f311026) (f311025 f311025)) (vector-set! f311026 7 f311025)))
# == eliminate-quote  ==>
# (closure (f311026 f311025) () (let ((f311026 f311026) (f311025 f311025)) (vector-set! f311026 7 f311025)))
# == eliminate-when/unless  ==>
# (closure (f311026 f311025) () (let ((f311026 f311026) (f311025 f311025)) (vector-set! f311026 7 f311025)))
# == eliminate-cond  ==>
# (closure (f311026 f311025) () (let ((f311026 f311026) (f311025 f311025)) (vector-set! f311026 7 f311025)))
# == external-symbols  ==>
# (closure (f311026 f311025) () (let ((f311026 f311026) (f311025 f311025)) (vector-set! f311026 7 f311025)))
# emit-expr (closure (f311026 f311025) () (let ((f311026 f311026) (f311025 f311025)) (vector-set! f311026 7 f311025)))
# emit-closure
# si = 0
# env = ()
# expr = (closure (f311026 f311025) () (let ((f311026 f311026) (f311025 f311025)) (vector-set! f311026 7 f311025)))
    movl $_L_1885077, 0(%ebp)  # closure label
=======
# (lambda (f238 f239) (vector-set! f238 7 f239))
# == vectorize-letrec  ==>
# (lambda (f238 f239) (vector-set! f238 7 f239))
# == eliminate-set!  ==>
# (lambda (f238 f239) (let ((f238 f238) (f239 f239)) (vector-set! f238 7 f239)))
# == close-free-variables  ==>
# (closure (f238 f239) () (let ((f238 f238) (f239 f239)) (vector-set! f238 7 f239)))
# == eliminate-quote  ==>
# (closure (f238 f239) () (let ((f238 f238) (f239 f239)) (vector-set! f238 7 f239)))
# == eliminate-when/unless  ==>
# (closure (f238 f239) () (let ((f238 f238) (f239 f239)) (vector-set! f238 7 f239)))
# == eliminate-cond  ==>
# (closure (f238 f239) () (let ((f238 f238) (f239 f239)) (vector-set! f238 7 f239)))
# == external-symbols  ==>
# (closure (f238 f239) () (let ((f238 f238) (f239 f239)) (vector-set! f238 7 f239)))
# emit-expr (closure (f238 f239) () (let ((f238 f238) (f239 f239)) (vector-set! f238 7 f239)))
# emit-closure
# si = 0
# env = ()
# expr = (closure (f238 f239) () (let ((f238 f238) (f239 f239)) (vector-set! f238 7 f239)))
    movl $_L_1478, 0(%ebp)  # closure label
>>>>>>> fix-implicit-begins
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $8, %ebp     # bump ebp
    jmp _L_1479            # jump around closure body
_L_1478:
# check argument count
    cmp $8,%eax
    je _L_1480
# invoke error handler eh_argcount
    .extern mrc_eh$uargcount
    movl mrc_eh$uargcount, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_1480:
# emit-tail-expr
# si=-16
<<<<<<< HEAD
# env=((f311025 . -12) (f311026 . -8))
# expr=(let ((f311026 f311026) (f311025 f311025)) (vector-set! f311026 7 f311025))
# emit-tail-let
#  si   = -16
#  env  = ((f311025 . -12) (f311026 . -8))
#  bindings = ((f311026 f311026) (f311025 f311025))
#  body = (vector-set! f311026 7 f311025)
# emit-expr f311026
# emit-variable-ref
# env=((f311025 . -12) (f311026 . -8))
# var=f311026
    movl -8(%esp), %eax  # stack load f311026
# end emit-variable-ref
    movl %eax, -16(%esp)  # stack save
# emit-expr f311025
# emit-variable-ref
# env=((f311025 . -12) (f311026 . -8))
# var=f311025
    movl -12(%esp), %eax  # stack load f311025
=======
# env=((f239 . -12) (f238 . -8))
# expr=(let ((f238 f238) (f239 f239)) (vector-set! f238 7 f239))
# emit-tail-let
#  si   = -16
#  env  = ((f239 . -12) (f238 . -8))
#  bindings = ((f238 f238) (f239 f239))
#  body = (vector-set! f238 7 f239)
# emit-expr f238
# emit-variable-ref
# env=((f239 . -12) (f238 . -8))
# var=f238
    movl -8(%esp), %eax  # stack load f238
# end emit-variable-ref
    movl %eax, -16(%esp)  # stack save
# emit-expr f239
# emit-variable-ref
# env=((f239 . -12) (f238 . -8))
# var=f239
    movl -12(%esp), %eax  # stack load f239
>>>>>>> fix-implicit-begins
# end emit-variable-ref
    movl %eax, -20(%esp)  # stack save
# emit-tail-expr
# si=-24
<<<<<<< HEAD
# env=((f311025 . -20) (f311026 . -16) (f311025 . -12) (f311026 . -8))
# expr=(vector-set! f311026 7 f311025)
# tail primcall
# emit-expr f311026
# emit-variable-ref
# env=((f311025 . -20) (f311026 . -16) (f311025 . -12) (f311026 . -8))
# var=f311026
    movl -16(%esp), %eax  # stack load f311026
=======
# env=((f239 . -20) (f238 . -16) (f239 . -12) (f238 . -8))
# expr=(vector-set! f238 7 f239)
# tail primcall
# emit-expr f238
# emit-variable-ref
# env=((f239 . -20) (f238 . -16) (f239 . -12) (f238 . -8))
# var=f238
    movl -16(%esp), %eax  # stack load f238
>>>>>>> fix-implicit-begins
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1481
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1481:
    movl %eax, -24(%esp)
# emit-expr 7
    movl $28, %eax     # immed 7
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1482"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1482:
# check bounds on vector index
    movl -24(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1484
    cmp  $0,%eax
    jge _L_1483
_L_1484:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1483:
    movl %eax, -28(%esp)
<<<<<<< HEAD
# emit-expr f311025
# emit-variable-ref
# env=((f311025 . -20) (f311026 . -16) (f311025 . -12) (f311026 . -8))
# var=f311025
    movl -20(%esp), %eax  # stack load f311025
=======
# emit-expr f239
# emit-variable-ref
# env=((f239 . -20) (f238 . -16) (f239 . -12) (f238 . -8))
# var=f239
    movl -20(%esp), %eax  # stack load f239
>>>>>>> fix-implicit-begins
# end emit-variable-ref
    movl -24(%esp), %ebx
    movl -28(%esp), %esi
    movl %eax, -1(%ebx,%esi)
<<<<<<< HEAD
#return from tail (vector-set! f311026 7 f311025)
=======
#return from tail (vector-set! f238 7 f239)
>>>>>>> fix-implicit-begins
    ret
    .align 4,0x90
_L_1479:
     movl %eax, mrc_port$mlast$mset$b
# == explicit-begins  ==>
# (lambda (p) (and (vector? p) (and (fx= (vector-length p) 8) (eq? (port-kind p) (quote input-port)))))
# == eliminate-let*  ==>
# (lambda (p) (and (vector? p) (and (fx= (vector-length p) 8) (eq? (port-kind p) (quote input-port)))))
# == uniquify-variables  ==>
# (lambda (f240) (and (vector? f240) (and (fx= (vector-length f240) 8) (eq? (port-kind f240) (quote input-port)))))
# == vectorize-letrec  ==>
# (lambda (f240) (and (vector? f240) (and (fx= (vector-length f240) 8) (eq? (port-kind f240) (quote input-port)))))
# == eliminate-set!  ==>
# (lambda (f240) (let ((f240 f240)) (and (vector? f240) (and (fx= (vector-length f240) 8) (eq? (port-kind f240) (quote input-port))))))
# == close-free-variables  ==>
# (closure (f240) (and and input-port) (let ((f240 f240)) (and (vector? f240) (and (fx= (vector-length f240) 8) (eq? (port-kind f240) (quote input-port))))))
# == eliminate-quote  ==>
# (closure (f240) (and and input-port) (let ((f240 f240)) (and (vector? f240) (and (fx= (vector-length f240) 8) (eq? (port-kind f240) (string->symbol "input-port"))))))
# == eliminate-when/unless  ==>
# (closure (f240) (and and input-port) (let ((f240 f240)) (and (vector? f240) (and (fx= (vector-length f240) 8) (eq? (port-kind f240) (string->symbol "input-port"))))))
# == eliminate-cond  ==>
# (closure (f240) (and and input-port) (let ((f240 f240)) (and (vector? f240) (and (fx= (vector-length f240) 8) (eq? (port-kind f240) (string->symbol "input-port"))))))
# == external-symbols  ==>
# (closure (f240) (and and input-port) (let ((f240 f240)) (and (vector? f240) (and (fx= (vector-length f240) 8) (eq? ((primitive-ref port-kind) f240) ((primitive-ref string->symbol) "input-port"))))))
# emit-expr (closure (f240) (and and input-port) (let ((f240 f240)) (and (vector? f240) (and (fx= (vector-length f240) 8) (eq? ((primitive-ref port-kind) f240) ((primitive-ref string->symbol) "input-port"))))))
# emit-closure
# si = 0
# env = ()
# expr = (closure (f240) (and and input-port) (let ((f240 f240)) (and (vector? f240) (and (fx= (vector-length f240) 8) (eq? ((primitive-ref port-kind) f240) ((primitive-ref string->symbol) "input-port"))))))
    movl $_L_1485, 0(%ebp)  # closure label
# WARNING: free var and not defined in the environmnet
# WARNING: free var and not defined in the environmnet
# WARNING: free var input-port not defined in the environmnet
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $16, %ebp     # bump ebp
    jmp _L_1486            # jump around closure body
_L_1485:
# check argument count
    cmp $4,%eax
    je _L_1487
# invoke error handler eh_argcount
    .extern mrc_eh$uargcount
    movl mrc_eh$uargcount, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_1487:
# emit-tail-expr
# si=-12
# env=((f240 . -8) (input-port . 12) (and . 8) (and . 4))
# expr=(let ((f240 f240)) (and (vector? f240) (and (fx= (vector-length f240) 8) (eq? ((primitive-ref port-kind) f240) ((primitive-ref string->symbol) "input-port")))))
# emit-tail-let
#  si   = -12
#  env  = ((f240 . -8) (input-port . 12) (and . 8) (and . 4))
#  bindings = ((f240 f240))
#  body = (and (vector? f240) (and (fx= (vector-length f240) 8) (eq? ((primitive-ref port-kind) f240) ((primitive-ref string->symbol) "input-port"))))
# emit-expr f240
# emit-variable-ref
# env=((f240 . -8) (input-port . 12) (and . 8) (and . 4))
# var=f240
    movl -8(%esp), %eax  # stack load f240
# end emit-variable-ref
    movl %eax, -12(%esp)  # stack save
# emit-tail-expr
# si=-16
# env=((f240 . -12) (f240 . -8) (input-port . 12) (and . 8) (and . 4))
# expr=(and (vector? f240) (and (fx= (vector-length f240) 8) (eq? ((primitive-ref port-kind) f240) ((primitive-ref string->symbol) "input-port"))))
# emit-tail-expr
# si=-16
# env=((f240 . -12) (f240 . -8) (input-port . 12) (and . 8) (and . 4))
# expr=(if (vector? f240) (and (and (fx= (vector-length f240) 8) (eq? ((primitive-ref port-kind) f240) ((primitive-ref string->symbol) "input-port")))) #f)
# emit-expr (vector? f240)
# emit-expr f240
# emit-variable-ref
# env=((f240 . -12) (f240 . -8) (input-port . 12) (and . 8) (and . 4))
# var=f240
    movl -12(%esp), %eax  # stack load f240
# end emit-variable-ref
    and $7, %al
    cmp $5, %al
    sete %al
    movzbl %al, %eax
    sal $6, %al
    or $47, %al
    cmp $47, %al
    je _L_1488
# emit-tail-expr
# si=-16
# env=((f240 . -12) (f240 . -8) (input-port . 12) (and . 8) (and . 4))
# expr=(and (and (fx= (vector-length f240) 8) (eq? ((primitive-ref port-kind) f240) ((primitive-ref string->symbol) "input-port"))))
# emit-tail-expr
# si=-16
# env=((f240 . -12) (f240 . -8) (input-port . 12) (and . 8) (and . 4))
# expr=(and (fx= (vector-length f240) 8) (eq? ((primitive-ref port-kind) f240) ((primitive-ref string->symbol) "input-port")))
# emit-tail-expr
# si=-16
# env=((f240 . -12) (f240 . -8) (input-port . 12) (and . 8) (and . 4))
# expr=(if (fx= (vector-length f240) 8) (and (eq? ((primitive-ref port-kind) f240) ((primitive-ref string->symbol) "input-port"))) #f)
# emit-expr (fx= (vector-length f240) 8)
# emit-expr 8
    movl $32, %eax     # immed 8
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1492"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $68,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1492:
    movl %eax, -16(%esp)
# emit-expr (vector-length f240)
# emit-expr f240
# emit-variable-ref
# env=((f240 . -12) (f240 . -8) (input-port . 12) (and . 8) (and . 4))
# var=f240
    movl -12(%esp), %eax  # stack load f240
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1493
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1493:
andl $-8, %eax
movl 0(%eax), %eax
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1494"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $68,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1494:
    cmp -16(%esp), %eax
    sete %al
    movzbl %al, %eax
    sal $6, %al
    or $47, %al
    cmp $47, %al
    je _L_1490
# emit-tail-expr
# si=-16
# env=((f240 . -12) (f240 . -8) (input-port . 12) (and . 8) (and . 4))
# expr=(and (eq? ((primitive-ref port-kind) f240) ((primitive-ref string->symbol) "input-port")))
# emit-tail-expr
# si=-16
# env=((f240 . -12) (f240 . -8) (input-port . 12) (and . 8) (and . 4))
# expr=(eq? ((primitive-ref port-kind) f240) ((primitive-ref string->symbol) "input-port"))
# tail primcall
# eq? arg1=((primitive-ref port-kind) f240) arg2=((primitive-ref string->symbol) "input-port")
# emit-expr ((primitive-ref port-kind) f240)
# funcall
#    si   =-16
#    env  = ((f240 . -12) (f240 . -8) (input-port . 12) (and . 8) (and . 4))
#    expr = (funcall (primitive-ref port-kind) f240)
# emit-expr (primitive-ref port-kind)
    .extern mrc_port$mkind
    movl mrc_port$mkind,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1495"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1495":
   movl %eax,  -24(%esp)  # stash funcall-oper in closure slot
# emit-expr f240
# emit-variable-ref
# env=((f240 . -12) (f240 . -8) (input-port . 12) (and . 8) (and . 4))
# var=f240
    movl -12(%esp), %eax  # stack load f240
# end emit-variable-ref
    mov %eax, -28(%esp)  # arg f240
    movl -24(%esp), %edi   # load new closure to %edi
    add $-16, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $16, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    movl %eax, -16(%esp)
# emit-expr ((primitive-ref string->symbol) "input-port")
# funcall
#    si   =-20
#    env  = ((f240 . -12) (f240 . -8) (input-port . 12) (and . 8) (and . 4))
#    expr = (funcall (primitive-ref string->symbol) "input-port")
# emit-expr (primitive-ref string->symbol)
    .extern mrc_string$m$gsymbol
    movl mrc_string$m$gsymbol,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1496"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1496":
   movl %eax,  -28(%esp)  # stash funcall-oper in closure slot
# emit-expr "input-port"
# string literal
    jmp _L_1498
    .align 8,0x90
_L_1497 :
    .int 40
    .ascii "input-port"
_L_1498:
    movl $_L_1497, %eax
    orl $6, %eax
    mov %eax, -32(%esp)  # arg input-port
    movl -28(%esp), %edi   # load new closure to %edi
    add $-20, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $20, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    cmp %eax, -16(%esp)
    sete %al
    movzbl %al, %eax
    sal $6, %al
    or $47, %al
#return from tail (eq? ((primitive-ref port-kind) f240) ((primitive-ref string->symbol) input-port))
    ret
    jmp _L_1491
_L_1490:
# emit-tail-expr
# si=-16
# env=((f240 . -12) (f240 . -8) (input-port . 12) (and . 8) (and . 4))
# expr=#f
    movl $47, %eax     # immed #f
    ret                  # immediate tail return
_L_1491:
    jmp _L_1489
_L_1488:
# emit-tail-expr
# si=-16
# env=((f240 . -12) (f240 . -8) (input-port . 12) (and . 8) (and . 4))
# expr=#f
    movl $47, %eax     # immed #f
    ret                  # immediate tail return
_L_1489:
    .align 4,0x90
_L_1486:
     movl %eax, mrc_input$mport$q
# == explicit-begins  ==>
# (lambda (p) (and (vector? p) (and (fx= (vector-length p) 6) (eq? (port-kind p) (quote output-port)))))
# == eliminate-let*  ==>
# (lambda (p) (and (vector? p) (and (fx= (vector-length p) 6) (eq? (port-kind p) (quote output-port)))))
# == uniquify-variables  ==>
# (lambda (f241) (and (vector? f241) (and (fx= (vector-length f241) 6) (eq? (port-kind f241) (quote output-port)))))
# == vectorize-letrec  ==>
# (lambda (f241) (and (vector? f241) (and (fx= (vector-length f241) 6) (eq? (port-kind f241) (quote output-port)))))
# == eliminate-set!  ==>
# (lambda (f241) (let ((f241 f241)) (and (vector? f241) (and (fx= (vector-length f241) 6) (eq? (port-kind f241) (quote output-port))))))
# == close-free-variables  ==>
# (closure (f241) (and and output-port) (let ((f241 f241)) (and (vector? f241) (and (fx= (vector-length f241) 6) (eq? (port-kind f241) (quote output-port))))))
# == eliminate-quote  ==>
# (closure (f241) (and and output-port) (let ((f241 f241)) (and (vector? f241) (and (fx= (vector-length f241) 6) (eq? (port-kind f241) (string->symbol "output-port"))))))
# == eliminate-when/unless  ==>
# (closure (f241) (and and output-port) (let ((f241 f241)) (and (vector? f241) (and (fx= (vector-length f241) 6) (eq? (port-kind f241) (string->symbol "output-port"))))))
# == eliminate-cond  ==>
# (closure (f241) (and and output-port) (let ((f241 f241)) (and (vector? f241) (and (fx= (vector-length f241) 6) (eq? (port-kind f241) (string->symbol "output-port"))))))
# == external-symbols  ==>
# (closure (f241) (and and output-port) (let ((f241 f241)) (and (vector? f241) (and (fx= (vector-length f241) 6) (eq? ((primitive-ref port-kind) f241) ((primitive-ref string->symbol) "output-port"))))))
# emit-expr (closure (f241) (and and output-port) (let ((f241 f241)) (and (vector? f241) (and (fx= (vector-length f241) 6) (eq? ((primitive-ref port-kind) f241) ((primitive-ref string->symbol) "output-port"))))))
# emit-closure
# si = 0
# env = ()
# expr = (closure (f241) (and and output-port) (let ((f241 f241)) (and (vector? f241) (and (fx= (vector-length f241) 6) (eq? ((primitive-ref port-kind) f241) ((primitive-ref string->symbol) "output-port"))))))
    movl $_L_1499, 0(%ebp)  # closure label
# WARNING: free var and not defined in the environmnet
# WARNING: free var and not defined in the environmnet
# WARNING: free var output-port not defined in the environmnet
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $16, %ebp     # bump ebp
    jmp _L_1500            # jump around closure body
_L_1499:
# check argument count
    cmp $4,%eax
    je _L_1501
# invoke error handler eh_argcount
    .extern mrc_eh$uargcount
    movl mrc_eh$uargcount, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_1501:
# emit-tail-expr
# si=-12
# env=((f241 . -8) (output-port . 12) (and . 8) (and . 4))
# expr=(let ((f241 f241)) (and (vector? f241) (and (fx= (vector-length f241) 6) (eq? ((primitive-ref port-kind) f241) ((primitive-ref string->symbol) "output-port")))))
# emit-tail-let
#  si   = -12
#  env  = ((f241 . -8) (output-port . 12) (and . 8) (and . 4))
#  bindings = ((f241 f241))
#  body = (and (vector? f241) (and (fx= (vector-length f241) 6) (eq? ((primitive-ref port-kind) f241) ((primitive-ref string->symbol) "output-port"))))
# emit-expr f241
# emit-variable-ref
# env=((f241 . -8) (output-port . 12) (and . 8) (and . 4))
# var=f241
    movl -8(%esp), %eax  # stack load f241
# end emit-variable-ref
    movl %eax, -12(%esp)  # stack save
# emit-tail-expr
# si=-16
# env=((f241 . -12) (f241 . -8) (output-port . 12) (and . 8) (and . 4))
# expr=(and (vector? f241) (and (fx= (vector-length f241) 6) (eq? ((primitive-ref port-kind) f241) ((primitive-ref string->symbol) "output-port"))))
# emit-tail-expr
# si=-16
# env=((f241 . -12) (f241 . -8) (output-port . 12) (and . 8) (and . 4))
# expr=(if (vector? f241) (and (and (fx= (vector-length f241) 6) (eq? ((primitive-ref port-kind) f241) ((primitive-ref string->symbol) "output-port")))) #f)
# emit-expr (vector? f241)
# emit-expr f241
# emit-variable-ref
# env=((f241 . -12) (f241 . -8) (output-port . 12) (and . 8) (and . 4))
# var=f241
    movl -12(%esp), %eax  # stack load f241
# end emit-variable-ref
    and $7, %al
    cmp $5, %al
    sete %al
    movzbl %al, %eax
    sal $6, %al
    or $47, %al
    cmp $47, %al
    je _L_1502
# emit-tail-expr
# si=-16
# env=((f241 . -12) (f241 . -8) (output-port . 12) (and . 8) (and . 4))
# expr=(and (and (fx= (vector-length f241) 6) (eq? ((primitive-ref port-kind) f241) ((primitive-ref string->symbol) "output-port"))))
# emit-tail-expr
# si=-16
# env=((f241 . -12) (f241 . -8) (output-port . 12) (and . 8) (and . 4))
# expr=(and (fx= (vector-length f241) 6) (eq? ((primitive-ref port-kind) f241) ((primitive-ref string->symbol) "output-port")))
# emit-tail-expr
# si=-16
# env=((f241 . -12) (f241 . -8) (output-port . 12) (and . 8) (and . 4))
# expr=(if (fx= (vector-length f241) 6) (and (eq? ((primitive-ref port-kind) f241) ((primitive-ref string->symbol) "output-port"))) #f)
# emit-expr (fx= (vector-length f241) 6)
# emit-expr 6
    movl $24, %eax     # immed 6
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1506"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $68,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1506:
    movl %eax, -16(%esp)
# emit-expr (vector-length f241)
# emit-expr f241
# emit-variable-ref
# env=((f241 . -12) (f241 . -8) (output-port . 12) (and . 8) (and . 4))
# var=f241
    movl -12(%esp), %eax  # stack load f241
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1507
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1507:
andl $-8, %eax
movl 0(%eax), %eax
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1508"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $68,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1508:
    cmp -16(%esp), %eax
    sete %al
    movzbl %al, %eax
    sal $6, %al
    or $47, %al
    cmp $47, %al
    je _L_1504
# emit-tail-expr
# si=-16
# env=((f241 . -12) (f241 . -8) (output-port . 12) (and . 8) (and . 4))
# expr=(and (eq? ((primitive-ref port-kind) f241) ((primitive-ref string->symbol) "output-port")))
# emit-tail-expr
# si=-16
# env=((f241 . -12) (f241 . -8) (output-port . 12) (and . 8) (and . 4))
# expr=(eq? ((primitive-ref port-kind) f241) ((primitive-ref string->symbol) "output-port"))
# tail primcall
# eq? arg1=((primitive-ref port-kind) f241) arg2=((primitive-ref string->symbol) "output-port")
# emit-expr ((primitive-ref port-kind) f241)
# funcall
#    si   =-16
#    env  = ((f241 . -12) (f241 . -8) (output-port . 12) (and . 8) (and . 4))
#    expr = (funcall (primitive-ref port-kind) f241)
# emit-expr (primitive-ref port-kind)
    .extern mrc_port$mkind
    movl mrc_port$mkind,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1509"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1509":
   movl %eax,  -24(%esp)  # stash funcall-oper in closure slot
# emit-expr f241
# emit-variable-ref
# env=((f241 . -12) (f241 . -8) (output-port . 12) (and . 8) (and . 4))
# var=f241
    movl -12(%esp), %eax  # stack load f241
# end emit-variable-ref
    mov %eax, -28(%esp)  # arg f241
    movl -24(%esp), %edi   # load new closure to %edi
    add $-16, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $16, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    movl %eax, -16(%esp)
# emit-expr ((primitive-ref string->symbol) "output-port")
# funcall
#    si   =-20
#    env  = ((f241 . -12) (f241 . -8) (output-port . 12) (and . 8) (and . 4))
#    expr = (funcall (primitive-ref string->symbol) "output-port")
# emit-expr (primitive-ref string->symbol)
    .extern mrc_string$m$gsymbol
    movl mrc_string$m$gsymbol,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1510"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1510":
   movl %eax,  -28(%esp)  # stash funcall-oper in closure slot
# emit-expr "output-port"
# string literal
    jmp _L_1512
    .align 8,0x90
_L_1511 :
    .int 44
    .ascii "output-port"
_L_1512:
    movl $_L_1511, %eax
    orl $6, %eax
    mov %eax, -32(%esp)  # arg output-port
    movl -28(%esp), %edi   # load new closure to %edi
    add $-20, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $20, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    cmp %eax, -16(%esp)
    sete %al
    movzbl %al, %eax
    sal $6, %al
    or $47, %al
#return from tail (eq? ((primitive-ref port-kind) f241) ((primitive-ref string->symbol) output-port))
    ret
    jmp _L_1505
_L_1504:
# emit-tail-expr
# si=-16
# env=((f241 . -12) (f241 . -8) (output-port . 12) (and . 8) (and . 4))
# expr=#f
    movl $47, %eax     # immed #f
    ret                  # immediate tail return
_L_1505:
    jmp _L_1503
_L_1502:
# emit-tail-expr
# si=-16
# env=((f241 . -12) (f241 . -8) (output-port . 12) (and . 8) (and . 4))
# expr=#f
    movl $47, %eax     # immed #f
    ret                  # immediate tail return
_L_1503:
    .align 4,0x90
_L_1500:
     movl %eax, mrc_output$mport$q
# == explicit-begins  ==>
# (lambda (filename) (begin (unless (string? filename) (error (quote open-input-file) "filename must be a string")) (let ((fd (foreign-call "s_open_for_read" filename))) (begin (when (negative? fd) (error (quote open-input-file) "open failed")) (let ((p (make-vector 8)) (sz 1024)) (begin (vector-set! p 0 (quote input-port)) (vector-set! p 1 filename) (vector-set! p 2 fd) (vector-set! p 3 (make-string sz)) (vector-set! p 4 0) (vector-set! p 5 sz) (vector-set! p 6 #f) (vector-set! p 7 0) p))))))
# == eliminate-let*  ==>
# (lambda (filename) (begin (unless (string? filename) (error (quote open-input-file) "filename must be a string")) (let ((fd (foreign-call "s_open_for_read" filename))) (begin (when (negative? fd) (error (quote open-input-file) "open failed")) (let ((p (make-vector 8)) (sz 1024)) (begin (vector-set! p 0 (quote input-port)) (vector-set! p 1 filename) (vector-set! p 2 fd) (vector-set! p 3 (make-string sz)) (vector-set! p 4 0) (vector-set! p 5 sz) (vector-set! p 6 #f) (vector-set! p 7 0) p))))))
# == uniquify-variables  ==>
# (lambda (f242) (begin (unless (string? f242) (error (quote open-input-file) "filename must be a string")) (let ((f248 (foreign-call "s_open_for_read" f242))) (begin (when (negative? f248) (error (quote open-input-file) "open failed")) (let ((f252 (make-vector 8)) (f251 1024)) (begin (vector-set! f252 0 (quote input-port)) (vector-set! f252 1 f242) (vector-set! f252 2 f248) (vector-set! f252 3 (make-string f251)) (vector-set! f252 4 0) (vector-set! f252 5 f251) (vector-set! f252 6 #f) (vector-set! f252 7 0) f252))))))
# == vectorize-letrec  ==>
# (lambda (f242) (begin (unless (string? f242) (error (quote open-input-file) "filename must be a string")) (let ((f248 (foreign-call "s_open_for_read" f242))) (begin (when (negative? f248) (error (quote open-input-file) "open failed")) (let ((f252 (make-vector 8)) (f251 1024)) (begin (vector-set! f252 0 (quote input-port)) (vector-set! f252 1 f242) (vector-set! f252 2 f248) (vector-set! f252 3 (make-string f251)) (vector-set! f252 4 0) (vector-set! f252 5 f251) (vector-set! f252 6 #f) (vector-set! f252 7 0) f252))))))
# == eliminate-set!  ==>
# (lambda (f242) (let ((f242 f242)) (begin (unless (string? f242) (error (quote open-input-file) "filename must be a string")) (let ((f248 (foreign-call "s_open_for_read" f242))) (begin (when (negative? f248) (error (quote open-input-file) "open failed")) (let ((f252 (make-vector 8)) (f251 1024)) (begin (vector-set! f252 0 (quote input-port)) (vector-set! f252 1 f242) (vector-set! f252 2 f248) (vector-set! f252 3 (make-string f251)) (vector-set! f252 4 0) (vector-set! f252 5 f251) (vector-set! f252 6 #f) (vector-set! f252 7 0) f252)))))))
# == close-free-variables  ==>
# (closure (f242) (input-port) (let ((f242 f242)) (begin (unless (string? f242) (error (quote open-input-file) "filename must be a string")) (let ((f248 (foreign-call "s_open_for_read" f242))) (begin (when (negative? f248) (error (quote open-input-file) "open failed")) (let ((f252 (make-vector 8)) (f251 1024)) (begin (vector-set! f252 0 (quote input-port)) (vector-set! f252 1 f242) (vector-set! f252 2 f248) (vector-set! f252 3 (make-string f251)) (vector-set! f252 4 0) (vector-set! f252 5 f251) (vector-set! f252 6 #f) (vector-set! f252 7 0) f252)))))))
# == eliminate-quote  ==>
# (closure (f242) (input-port) (let ((f242 f242)) (begin (unless (string? f242) (error (string->symbol "open-input-file") "filename must be a string")) (let ((f248 (foreign-call "s_open_for_read" f242))) (begin (when (negative? f248) (error (string->symbol "open-input-file") "open failed")) (let ((f252 (make-vector 8)) (f251 1024)) (begin (vector-set! f252 0 (string->symbol "input-port")) (vector-set! f252 1 f242) (vector-set! f252 2 f248) (vector-set! f252 3 (make-string f251)) (vector-set! f252 4 0) (vector-set! f252 5 f251) (vector-set! f252 6 #f) (vector-set! f252 7 0) f252)))))))
# == eliminate-when/unless  ==>
# (closure (f242) (input-port) (let ((f242 f242)) (begin (if (not (string? f242)) (begin (error (string->symbol "open-input-file") "filename must be a string")) #f) (let ((f248 (foreign-call "s_open_for_read" f242))) (begin (if (negative? f248) (begin (error (string->symbol "open-input-file") "open failed")) #f) (let ((f252 (make-vector 8)) (f251 1024)) (begin (vector-set! f252 0 (string->symbol "input-port")) (vector-set! f252 1 f242) (vector-set! f252 2 f248) (vector-set! f252 3 (make-string f251)) (vector-set! f252 4 0) (vector-set! f252 5 f251) (vector-set! f252 6 #f) (vector-set! f252 7 0) f252)))))))
# == eliminate-cond  ==>
# (closure (f242) (input-port) (let ((f242 f242)) (begin (if (not (string? f242)) (begin (error (string->symbol "open-input-file") "filename must be a string")) #f) (let ((f248 (foreign-call "s_open_for_read" f242))) (begin (if (negative? f248) (begin (error (string->symbol "open-input-file") "open failed")) #f) (let ((f252 (make-vector 8)) (f251 1024)) (begin (vector-set! f252 0 (string->symbol "input-port")) (vector-set! f252 1 f242) (vector-set! f252 2 f248) (vector-set! f252 3 (make-string f251)) (vector-set! f252 4 0) (vector-set! f252 5 f251) (vector-set! f252 6 #f) (vector-set! f252 7 0) f252)))))))
# == external-symbols  ==>
# (closure (f242) (input-port) (let ((f242 f242)) (begin (if (not (string? f242)) (begin ((primitive-ref error) ((primitive-ref string->symbol) "open-input-file") "filename must be a string")) #f) (let ((f248 (foreign-call "s_open_for_read" f242))) (begin (if ((primitive-ref negative?) f248) (begin ((primitive-ref error) ((primitive-ref string->symbol) "open-input-file") "open failed")) #f) (let ((f252 (make-vector 8)) (f251 1024)) (begin (vector-set! f252 0 ((primitive-ref string->symbol) "input-port")) (vector-set! f252 1 f242) (vector-set! f252 2 f248) (vector-set! f252 3 (make-string f251)) (vector-set! f252 4 0) (vector-set! f252 5 f251) (vector-set! f252 6 #f) (vector-set! f252 7 0) f252)))))))
# emit-expr (closure (f242) (input-port) (let ((f242 f242)) (begin (if (not (string? f242)) (begin ((primitive-ref error) ((primitive-ref string->symbol) "open-input-file") "filename must be a string")) #f) (let ((f248 (foreign-call "s_open_for_read" f242))) (begin (if ((primitive-ref negative?) f248) (begin ((primitive-ref error) ((primitive-ref string->symbol) "open-input-file") "open failed")) #f) (let ((f252 (make-vector 8)) (f251 1024)) (begin (vector-set! f252 0 ((primitive-ref string->symbol) "input-port")) (vector-set! f252 1 f242) (vector-set! f252 2 f248) (vector-set! f252 3 (make-string f251)) (vector-set! f252 4 0) (vector-set! f252 5 f251) (vector-set! f252 6 #f) (vector-set! f252 7 0) f252)))))))
# emit-closure
# si = 0
# env = ()
# expr = (closure (f242) (input-port) (let ((f242 f242)) (begin (if (not (string? f242)) (begin ((primitive-ref error) ((primitive-ref string->symbol) "open-input-file") "filename must be a string")) #f) (let ((f248 (foreign-call "s_open_for_read" f242))) (begin (if ((primitive-ref negative?) f248) (begin ((primitive-ref error) ((primitive-ref string->symbol) "open-input-file") "open failed")) #f) (let ((f252 (make-vector 8)) (f251 1024)) (begin (vector-set! f252 0 ((primitive-ref string->symbol) "input-port")) (vector-set! f252 1 f242) (vector-set! f252 2 f248) (vector-set! f252 3 (make-string f251)) (vector-set! f252 4 0) (vector-set! f252 5 f251) (vector-set! f252 6 #f) (vector-set! f252 7 0) f252)))))))
    movl $_L_1513, 0(%ebp)  # closure label
# WARNING: free var input-port not defined in the environmnet
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $8, %ebp     # bump ebp
    jmp _L_1514            # jump around closure body
_L_1513:
# check argument count
    cmp $4,%eax
    je _L_1515
# invoke error handler eh_argcount
    .extern mrc_eh$uargcount
    movl mrc_eh$uargcount, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_1515:
# emit-tail-expr
# si=-12
# env=((f242 . -8) (input-port . 4))
# expr=(let ((f242 f242)) (begin (if (not (string? f242)) (begin ((primitive-ref error) ((primitive-ref string->symbol) "open-input-file") "filename must be a string")) #f) (let ((f248 (foreign-call "s_open_for_read" f242))) (begin (if ((primitive-ref negative?) f248) (begin ((primitive-ref error) ((primitive-ref string->symbol) "open-input-file") "open failed")) #f) (let ((f252 (make-vector 8)) (f251 1024)) (begin (vector-set! f252 0 ((primitive-ref string->symbol) "input-port")) (vector-set! f252 1 f242) (vector-set! f252 2 f248) (vector-set! f252 3 (make-string f251)) (vector-set! f252 4 0) (vector-set! f252 5 f251) (vector-set! f252 6 #f) (vector-set! f252 7 0) f252))))))
# emit-tail-let
#  si   = -12
#  env  = ((f242 . -8) (input-port . 4))
#  bindings = ((f242 f242))
#  body = (begin (if (not (string? f242)) (begin ((primitive-ref error) ((primitive-ref string->symbol) "open-input-file") "filename must be a string")) #f) (let ((f248 (foreign-call "s_open_for_read" f242))) (begin (if ((primitive-ref negative?) f248) (begin ((primitive-ref error) ((primitive-ref string->symbol) "open-input-file") "open failed")) #f) (let ((f252 (make-vector 8)) (f251 1024)) (begin (vector-set! f252 0 ((primitive-ref string->symbol) "input-port")) (vector-set! f252 1 f242) (vector-set! f252 2 f248) (vector-set! f252 3 (make-string f251)) (vector-set! f252 4 0) (vector-set! f252 5 f251) (vector-set! f252 6 #f) (vector-set! f252 7 0) f252)))))
# emit-expr f242
# emit-variable-ref
# env=((f242 . -8) (input-port . 4))
# var=f242
    movl -8(%esp), %eax  # stack load f242
# end emit-variable-ref
    movl %eax, -12(%esp)  # stack save
# emit-tail-expr
# si=-16
# env=((f242 . -12) (f242 . -8) (input-port . 4))
# expr=(begin (if (not (string? f242)) (begin ((primitive-ref error) ((primitive-ref string->symbol) "open-input-file") "filename must be a string")) #f) (let ((f248 (foreign-call "s_open_for_read" f242))) (begin (if ((primitive-ref negative?) f248) (begin ((primitive-ref error) ((primitive-ref string->symbol) "open-input-file") "open failed")) #f) (let ((f252 (make-vector 8)) (f251 1024)) (begin (vector-set! f252 0 ((primitive-ref string->symbol) "input-port")) (vector-set! f252 1 f242) (vector-set! f252 2 f248) (vector-set! f252 3 (make-string f251)) (vector-set! f252 4 0) (vector-set! f252 5 f251) (vector-set! f252 6 #f) (vector-set! f252 7 0) f252)))))
# tail-begin (begin (if (not (string? f242)) (begin ((primitive-ref error) ((primitive-ref string->symbol) "open-input-file") "filename must be a string")) #f) (let ((f248 (foreign-call "s_open_for_read" f242))) (begin (if ((primitive-ref negative?) f248) (begin ((primitive-ref error) ((primitive-ref string->symbol) "open-input-file") "open failed")) #f) (let ((f252 (make-vector 8)) (f251 1024)) (begin (vector-set! f252 0 ((primitive-ref string->symbol) "input-port")) (vector-set! f252 1 f242) (vector-set! f252 2 f248) (vector-set! f252 3 (make-string f251)) (vector-set! f252 4 0) (vector-set! f252 5 f251) (vector-set! f252 6 #f) (vector-set! f252 7 0) f252)))))
#   env=((f242 . -12) (f242 . -8) (input-port . 4))
# emit-expr (if (not (string? f242)) (begin ((primitive-ref error) ((primitive-ref string->symbol) "open-input-file") "filename must be a string")) #f)
# emit-expr (not (string? f242))
# emit-expr (string? f242)
# emit-expr f242
# emit-variable-ref
# env=((f242 . -12) (f242 . -8) (input-port . 4))
# var=f242
    movl -12(%esp), %eax  # stack load f242
# end emit-variable-ref
    and $7, %al
    cmp $6, %al
    sete %al
    movzbl %al, %eax
    sal $6, %al
    or $47, %al
    cmp $47, %eax
    sete %al
    movzbl %al, %eax
    sal $6, %al
    or $47, %al
    cmp $47, %al
    je _L_1516
# emit-expr (begin ((primitive-ref error) ((primitive-ref string->symbol) "open-input-file") "filename must be a string"))
# emit-begin
#   expr=(begin ((primitive-ref error) ((primitive-ref string->symbol) "open-input-file") "filename must be a string"))
#   env=((f242 . -12) (f242 . -8) (input-port . 4))
# emit-expr ((primitive-ref error) ((primitive-ref string->symbol) "open-input-file") "filename must be a string")
# funcall
#    si   =-16
#    env  = ((f242 . -12) (f242 . -8) (input-port . 4))
#    expr = (funcall (primitive-ref error) ((primitive-ref string->symbol) "open-input-file") "filename must be a string")
# emit-expr (primitive-ref error)
    .extern mrc_error
    movl mrc_error,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1518"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1518":
   movl %eax,  -24(%esp)  # stash funcall-oper in closure slot
# emit-expr ((primitive-ref string->symbol) "open-input-file")
# funcall
#    si   =-28
#    env  = ((f242 . -12) (f242 . -8) (input-port . 4))
#    expr = (funcall (primitive-ref string->symbol) "open-input-file")
# emit-expr (primitive-ref string->symbol)
    .extern mrc_string$m$gsymbol
    movl mrc_string$m$gsymbol,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1519"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1519":
   movl %eax,  -36(%esp)  # stash funcall-oper in closure slot
# emit-expr "open-input-file"
# string literal
    jmp _L_1521
    .align 8,0x90
_L_1520 :
    .int 60
    .ascii "open-input-file"
_L_1521:
    movl $_L_1520, %eax
    orl $6, %eax
    mov %eax, -40(%esp)  # arg open-input-file
    movl -36(%esp), %edi   # load new closure to %edi
    add $-28, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $28, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    mov %eax, -28(%esp)  # arg ((primitive-ref string->symbol) open-input-file)
# emit-expr "filename must be a string"
# string literal
    jmp _L_1523
    .align 8,0x90
_L_1522 :
    .int 100
    .ascii "filename must be a string"
_L_1523:
    movl $_L_1522, %eax
    orl $6, %eax
    mov %eax, -32(%esp)  # arg filename must be a string
    movl -24(%esp), %edi   # load new closure to %edi
    add $-16, %esp   # adjust base
    movl $8,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $16, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
# emit-expr (begin)
# emit-begin
#   expr=(begin)
#   env=((f242 . -12) (f242 . -8) (input-port . 4))
    jmp _L_1517
_L_1516:
# emit-expr #f
    movl $47, %eax     # immed #f
_L_1517:
# emit-tail-expr
# si=-16
# env=((f242 . -12) (f242 . -8) (input-port . 4))
# expr=(begin (let ((f248 (foreign-call "s_open_for_read" f242))) (begin (if ((primitive-ref negative?) f248) (begin ((primitive-ref error) ((primitive-ref string->symbol) "open-input-file") "open failed")) #f) (let ((f252 (make-vector 8)) (f251 1024)) (begin (vector-set! f252 0 ((primitive-ref string->symbol) "input-port")) (vector-set! f252 1 f242) (vector-set! f252 2 f248) (vector-set! f252 3 (make-string f251)) (vector-set! f252 4 0) (vector-set! f252 5 f251) (vector-set! f252 6 #f) (vector-set! f252 7 0) f252)))))
# tail-begin (begin (let ((f248 (foreign-call "s_open_for_read" f242))) (begin (if ((primitive-ref negative?) f248) (begin ((primitive-ref error) ((primitive-ref string->symbol) "open-input-file") "open failed")) #f) (let ((f252 (make-vector 8)) (f251 1024)) (begin (vector-set! f252 0 ((primitive-ref string->symbol) "input-port")) (vector-set! f252 1 f242) (vector-set! f252 2 f248) (vector-set! f252 3 (make-string f251)) (vector-set! f252 4 0) (vector-set! f252 5 f251) (vector-set! f252 6 #f) (vector-set! f252 7 0) f252)))))
#   env=((f242 . -12) (f242 . -8) (input-port . 4))
# emit-tail-expr
# si=-16
# env=((f242 . -12) (f242 . -8) (input-port . 4))
# expr=(let ((f248 (foreign-call "s_open_for_read" f242))) (begin (if ((primitive-ref negative?) f248) (begin ((primitive-ref error) ((primitive-ref string->symbol) "open-input-file") "open failed")) #f) (let ((f252 (make-vector 8)) (f251 1024)) (begin (vector-set! f252 0 ((primitive-ref string->symbol) "input-port")) (vector-set! f252 1 f242) (vector-set! f252 2 f248) (vector-set! f252 3 (make-string f251)) (vector-set! f252 4 0) (vector-set! f252 5 f251) (vector-set! f252 6 #f) (vector-set! f252 7 0) f252))))
# emit-tail-let
#  si   = -16
#  env  = ((f242 . -12) (f242 . -8) (input-port . 4))
#  bindings = ((f248 (foreign-call "s_open_for_read" f242)))
#  body = (begin (if ((primitive-ref negative?) f248) (begin ((primitive-ref error) ((primitive-ref string->symbol) "open-input-file") "open failed")) #f) (let ((f252 (make-vector 8)) (f251 1024)) (begin (vector-set! f252 0 ((primitive-ref string->symbol) "input-port")) (vector-set! f252 1 f242) (vector-set! f252 2 f248) (vector-set! f252 3 (make-string f251)) (vector-set! f252 4 0) (vector-set! f252 5 f251) (vector-set! f252 6 #f) (vector-set! f252 7 0) f252)))
# emit-expr (foreign-call "s_open_for_read" f242)
    movl %ecx,-16(%esp)
    movl %esp,-20(%esp)
# emit-expr f242
# emit-variable-ref
# env=((f242 . -12) (f242 . -8) (input-port . 4))
# var=f242
    movl -12(%esp), %eax  # stack load f242
# end emit-variable-ref
    movl %eax, -24(%esp)
    leal -24(%esp),%edi
    movl %edi,%esi
    andl $-16,%esi
    movl 0(%edi),%eax
    movl %eax,0(%esi)
    movl 4(%edi),%eax
    movl %eax,4(%esi)
    movl %esi,%esp
    .extern _s_open_for_read
    call _s_open_for_read
    movl 4(%esi),%esp
    movl -16(%esp),%ecx
    movl %eax, -16(%esp)  # stack save
# emit-tail-expr
# si=-20
# env=((f248 . -16) (f242 . -12) (f242 . -8) (input-port . 4))
# expr=(begin (if ((primitive-ref negative?) f248) (begin ((primitive-ref error) ((primitive-ref string->symbol) "open-input-file") "open failed")) #f) (let ((f252 (make-vector 8)) (f251 1024)) (begin (vector-set! f252 0 ((primitive-ref string->symbol) "input-port")) (vector-set! f252 1 f242) (vector-set! f252 2 f248) (vector-set! f252 3 (make-string f251)) (vector-set! f252 4 0) (vector-set! f252 5 f251) (vector-set! f252 6 #f) (vector-set! f252 7 0) f252)))
# tail-begin (begin (if ((primitive-ref negative?) f248) (begin ((primitive-ref error) ((primitive-ref string->symbol) "open-input-file") "open failed")) #f) (let ((f252 (make-vector 8)) (f251 1024)) (begin (vector-set! f252 0 ((primitive-ref string->symbol) "input-port")) (vector-set! f252 1 f242) (vector-set! f252 2 f248) (vector-set! f252 3 (make-string f251)) (vector-set! f252 4 0) (vector-set! f252 5 f251) (vector-set! f252 6 #f) (vector-set! f252 7 0) f252)))
#   env=((f248 . -16) (f242 . -12) (f242 . -8) (input-port . 4))
# emit-expr (if ((primitive-ref negative?) f248) (begin ((primitive-ref error) ((primitive-ref string->symbol) "open-input-file") "open failed")) #f)
# emit-expr ((primitive-ref negative?) f248)
# funcall
#    si   =-20
#    env  = ((f248 . -16) (f242 . -12) (f242 . -8) (input-port . 4))
#    expr = (funcall (primitive-ref negative?) f248)
# emit-expr (primitive-ref negative?)
    .extern mrc_negative$q
    movl mrc_negative$q,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1526"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1526":
   movl %eax,  -28(%esp)  # stash funcall-oper in closure slot
# emit-expr f248
# emit-variable-ref
# env=((f248 . -16) (f242 . -12) (f242 . -8) (input-port . 4))
# var=f248
    movl -16(%esp), %eax  # stack load f248
# end emit-variable-ref
    mov %eax, -32(%esp)  # arg f248
    movl -28(%esp), %edi   # load new closure to %edi
    add $-20, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $20, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    cmp $47, %al
    je _L_1524
# emit-expr (begin ((primitive-ref error) ((primitive-ref string->symbol) "open-input-file") "open failed"))
# emit-begin
#   expr=(begin ((primitive-ref error) ((primitive-ref string->symbol) "open-input-file") "open failed"))
#   env=((f248 . -16) (f242 . -12) (f242 . -8) (input-port . 4))
# emit-expr ((primitive-ref error) ((primitive-ref string->symbol) "open-input-file") "open failed")
# funcall
#    si   =-20
#    env  = ((f248 . -16) (f242 . -12) (f242 . -8) (input-port . 4))
#    expr = (funcall (primitive-ref error) ((primitive-ref string->symbol) "open-input-file") "open failed")
# emit-expr (primitive-ref error)
    .extern mrc_error
    movl mrc_error,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1527"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1527":
   movl %eax,  -28(%esp)  # stash funcall-oper in closure slot
# emit-expr ((primitive-ref string->symbol) "open-input-file")
# funcall
#    si   =-32
#    env  = ((f248 . -16) (f242 . -12) (f242 . -8) (input-port . 4))
#    expr = (funcall (primitive-ref string->symbol) "open-input-file")
# emit-expr (primitive-ref string->symbol)
    .extern mrc_string$m$gsymbol
    movl mrc_string$m$gsymbol,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1528"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1528":
   movl %eax,  -40(%esp)  # stash funcall-oper in closure slot
# emit-expr "open-input-file"
# string literal
    jmp _L_1530
    .align 8,0x90
_L_1529 :
    .int 60
    .ascii "open-input-file"
_L_1530:
    movl $_L_1529, %eax
    orl $6, %eax
    mov %eax, -44(%esp)  # arg open-input-file
    movl -40(%esp), %edi   # load new closure to %edi
    add $-32, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $32, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    mov %eax, -32(%esp)  # arg ((primitive-ref string->symbol) open-input-file)
# emit-expr "open failed"
# string literal
    jmp _L_1532
    .align 8,0x90
_L_1531 :
    .int 44
    .ascii "open failed"
_L_1532:
    movl $_L_1531, %eax
    orl $6, %eax
    mov %eax, -36(%esp)  # arg open failed
    movl -28(%esp), %edi   # load new closure to %edi
    add $-20, %esp   # adjust base
    movl $8,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $20, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
# emit-expr (begin)
# emit-begin
#   expr=(begin)
#   env=((f248 . -16) (f242 . -12) (f242 . -8) (input-port . 4))
    jmp _L_1525
_L_1524:
# emit-expr #f
    movl $47, %eax     # immed #f
_L_1525:
# emit-tail-expr
# si=-20
# env=((f248 . -16) (f242 . -12) (f242 . -8) (input-port . 4))
# expr=(begin (let ((f252 (make-vector 8)) (f251 1024)) (begin (vector-set! f252 0 ((primitive-ref string->symbol) "input-port")) (vector-set! f252 1 f242) (vector-set! f252 2 f248) (vector-set! f252 3 (make-string f251)) (vector-set! f252 4 0) (vector-set! f252 5 f251) (vector-set! f252 6 #f) (vector-set! f252 7 0) f252)))
# tail-begin (begin (let ((f252 (make-vector 8)) (f251 1024)) (begin (vector-set! f252 0 ((primitive-ref string->symbol) "input-port")) (vector-set! f252 1 f242) (vector-set! f252 2 f248) (vector-set! f252 3 (make-string f251)) (vector-set! f252 4 0) (vector-set! f252 5 f251) (vector-set! f252 6 #f) (vector-set! f252 7 0) f252)))
#   env=((f248 . -16) (f242 . -12) (f242 . -8) (input-port . 4))
# emit-tail-expr
# si=-20
# env=((f248 . -16) (f242 . -12) (f242 . -8) (input-port . 4))
# expr=(let ((f252 (make-vector 8)) (f251 1024)) (begin (vector-set! f252 0 ((primitive-ref string->symbol) "input-port")) (vector-set! f252 1 f242) (vector-set! f252 2 f248) (vector-set! f252 3 (make-string f251)) (vector-set! f252 4 0) (vector-set! f252 5 f251) (vector-set! f252 6 #f) (vector-set! f252 7 0) f252))
# emit-tail-let
#  si   = -20
#  env  = ((f248 . -16) (f242 . -12) (f242 . -8) (input-port . 4))
#  bindings = ((f252 (make-vector 8)) (f251 1024))
#  body = (begin (vector-set! f252 0 ((primitive-ref string->symbol) "input-port")) (vector-set! f252 1 f242) (vector-set! f252 2 f248) (vector-set! f252 3 (make-string f251)) (vector-set! f252 4 0) (vector-set! f252 5 f251) (vector-set! f252 6 #f) (vector-set! f252 7 0) f252)
# emit-expr (make-vector 8)
# make-vector 8
# emit-expr 8
    movl $32, %eax     # immed 8
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1533"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1533:
# check the argument is a fixnum >= 0
    cmp $0,%eax
    jge _L_1534
# invoke error handler eh_length
    .extern mrc_eh$ulength
    movl mrc_eh$ulength, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1534:
    movl %eax, %esi
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    orl  $5, %eax
    addl $4, %esi
    addl $4, %esi
    andl $-8, %esi
    addl %esi, %ebp
    movl %eax, -20(%esp)  # stack save
# emit-expr 1024
    movl $4096, %eax     # immed 1024
    movl %eax, -24(%esp)  # stack save
# emit-tail-expr
# si=-28
# env=((f251 . -24) (f252 . -20) (f248 . -16) (f242 . -12) (f242 . -8) (input-port . 4))
# expr=(begin (vector-set! f252 0 ((primitive-ref string->symbol) "input-port")) (vector-set! f252 1 f242) (vector-set! f252 2 f248) (vector-set! f252 3 (make-string f251)) (vector-set! f252 4 0) (vector-set! f252 5 f251) (vector-set! f252 6 #f) (vector-set! f252 7 0) f252)
# tail-begin (begin (vector-set! f252 0 ((primitive-ref string->symbol) "input-port")) (vector-set! f252 1 f242) (vector-set! f252 2 f248) (vector-set! f252 3 (make-string f251)) (vector-set! f252 4 0) (vector-set! f252 5 f251) (vector-set! f252 6 #f) (vector-set! f252 7 0) f252)
#   env=((f251 . -24) (f252 . -20) (f248 . -16) (f242 . -12) (f242 . -8) (input-port . 4))
# emit-expr (vector-set! f252 0 ((primitive-ref string->symbol) "input-port"))
# emit-expr f252
# emit-variable-ref
# env=((f251 . -24) (f252 . -20) (f248 . -16) (f242 . -12) (f242 . -8) (input-port . 4))
# var=f252
    movl -20(%esp), %eax  # stack load f252
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1535
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1535:
    movl %eax, -28(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1536"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1536:
# check bounds on vector index
    movl -28(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1538
    cmp  $0,%eax
    jge _L_1537
_L_1538:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1537:
    movl %eax, -32(%esp)
# emit-expr ((primitive-ref string->symbol) "input-port")
# funcall
#    si   =-36
#    env  = ((f251 . -24) (f252 . -20) (f248 . -16) (f242 . -12) (f242 . -8) (input-port . 4))
#    expr = (funcall (primitive-ref string->symbol) "input-port")
# emit-expr (primitive-ref string->symbol)
    .extern mrc_string$m$gsymbol
    movl mrc_string$m$gsymbol,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1539"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1539":
   movl %eax,  -44(%esp)  # stash funcall-oper in closure slot
# emit-expr "input-port"
# string literal
    jmp _L_1541
    .align 8,0x90
_L_1540 :
    .int 40
    .ascii "input-port"
_L_1541:
    movl $_L_1540, %eax
    orl $6, %eax
    mov %eax, -48(%esp)  # arg input-port
    movl -44(%esp), %edi   # load new closure to %edi
    add $-36, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $36, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    movl -28(%esp), %ebx
    movl -32(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-tail-expr
# si=-28
# env=((f251 . -24) (f252 . -20) (f248 . -16) (f242 . -12) (f242 . -8) (input-port . 4))
# expr=(begin (vector-set! f252 1 f242) (vector-set! f252 2 f248) (vector-set! f252 3 (make-string f251)) (vector-set! f252 4 0) (vector-set! f252 5 f251) (vector-set! f252 6 #f) (vector-set! f252 7 0) f252)
# tail-begin (begin (vector-set! f252 1 f242) (vector-set! f252 2 f248) (vector-set! f252 3 (make-string f251)) (vector-set! f252 4 0) (vector-set! f252 5 f251) (vector-set! f252 6 #f) (vector-set! f252 7 0) f252)
#   env=((f251 . -24) (f252 . -20) (f248 . -16) (f242 . -12) (f242 . -8) (input-port . 4))
# emit-expr (vector-set! f252 1 f242)
# emit-expr f252
# emit-variable-ref
# env=((f251 . -24) (f252 . -20) (f248 . -16) (f242 . -12) (f242 . -8) (input-port . 4))
# var=f252
    movl -20(%esp), %eax  # stack load f252
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1542
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1542:
    movl %eax, -28(%esp)
# emit-expr 1
    movl $4, %eax     # immed 1
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1543"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1543:
# check bounds on vector index
    movl -28(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1545
    cmp  $0,%eax
    jge _L_1544
_L_1545:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1544:
    movl %eax, -32(%esp)
# emit-expr f242
# emit-variable-ref
# env=((f251 . -24) (f252 . -20) (f248 . -16) (f242 . -12) (f242 . -8) (input-port . 4))
# var=f242
    movl -12(%esp), %eax  # stack load f242
# end emit-variable-ref
    movl -28(%esp), %ebx
    movl -32(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-tail-expr
# si=-28
# env=((f251 . -24) (f252 . -20) (f248 . -16) (f242 . -12) (f242 . -8) (input-port . 4))
# expr=(begin (vector-set! f252 2 f248) (vector-set! f252 3 (make-string f251)) (vector-set! f252 4 0) (vector-set! f252 5 f251) (vector-set! f252 6 #f) (vector-set! f252 7 0) f252)
# tail-begin (begin (vector-set! f252 2 f248) (vector-set! f252 3 (make-string f251)) (vector-set! f252 4 0) (vector-set! f252 5 f251) (vector-set! f252 6 #f) (vector-set! f252 7 0) f252)
#   env=((f251 . -24) (f252 . -20) (f248 . -16) (f242 . -12) (f242 . -8) (input-port . 4))
# emit-expr (vector-set! f252 2 f248)
# emit-expr f252
# emit-variable-ref
# env=((f251 . -24) (f252 . -20) (f248 . -16) (f242 . -12) (f242 . -8) (input-port . 4))
# var=f252
    movl -20(%esp), %eax  # stack load f252
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1546
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1546:
    movl %eax, -28(%esp)
# emit-expr 2
    movl $8, %eax     # immed 2
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1547"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1547:
# check bounds on vector index
    movl -28(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1549
    cmp  $0,%eax
    jge _L_1548
_L_1549:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1548:
    movl %eax, -32(%esp)
# emit-expr f248
# emit-variable-ref
# env=((f251 . -24) (f252 . -20) (f248 . -16) (f242 . -12) (f242 . -8) (input-port . 4))
# var=f248
    movl -16(%esp), %eax  # stack load f248
# end emit-variable-ref
    movl -28(%esp), %ebx
    movl -32(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-tail-expr
# si=-28
# env=((f251 . -24) (f252 . -20) (f248 . -16) (f242 . -12) (f242 . -8) (input-port . 4))
# expr=(begin (vector-set! f252 3 (make-string f251)) (vector-set! f252 4 0) (vector-set! f252 5 f251) (vector-set! f252 6 #f) (vector-set! f252 7 0) f252)
# tail-begin (begin (vector-set! f252 3 (make-string f251)) (vector-set! f252 4 0) (vector-set! f252 5 f251) (vector-set! f252 6 #f) (vector-set! f252 7 0) f252)
#   env=((f251 . -24) (f252 . -20) (f248 . -16) (f242 . -12) (f242 . -8) (input-port . 4))
# emit-expr (vector-set! f252 3 (make-string f251))
# emit-expr f252
# emit-variable-ref
# env=((f251 . -24) (f252 . -20) (f248 . -16) (f242 . -12) (f242 . -8) (input-port . 4))
# var=f252
    movl -20(%esp), %eax  # stack load f252
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1550
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1550:
    movl %eax, -28(%esp)
# emit-expr 3
    movl $12, %eax     # immed 3
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1551"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1551:
# check bounds on vector index
    movl -28(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1553
    cmp  $0,%eax
    jge _L_1552
_L_1553:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1552:
    movl %eax, -32(%esp)
# emit-expr (make-string f251)
# make-string len=f251
# emit-expr f251
# emit-variable-ref
# env=((f251 . -24) (f252 . -20) (f248 . -16) (f242 . -12) (f242 . -8) (input-port . 4))
# var=f251
    movl -24(%esp), %eax  # stack load f251
# end emit-variable-ref
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1554"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $152,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1554:
# check the argument is a fixnum >= 0
    cmp $0,%eax
    jge _L_1555
# invoke error handler eh_length
    .extern mrc_eh$ulength
    movl mrc_eh$ulength, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $152,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1555:
    movl %eax, %esi
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    orl $6, %eax
    sar $2, %esi
    add $4, %esi
    add $7, %esi
    andl $-8, %esi
    add  %esi, %ebp
# make-string end
    movl -28(%esp), %ebx
    movl -32(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-tail-expr
# si=-28
# env=((f251 . -24) (f252 . -20) (f248 . -16) (f242 . -12) (f242 . -8) (input-port . 4))
# expr=(begin (vector-set! f252 4 0) (vector-set! f252 5 f251) (vector-set! f252 6 #f) (vector-set! f252 7 0) f252)
# tail-begin (begin (vector-set! f252 4 0) (vector-set! f252 5 f251) (vector-set! f252 6 #f) (vector-set! f252 7 0) f252)
#   env=((f251 . -24) (f252 . -20) (f248 . -16) (f242 . -12) (f242 . -8) (input-port . 4))
# emit-expr (vector-set! f252 4 0)
# emit-expr f252
# emit-variable-ref
# env=((f251 . -24) (f252 . -20) (f248 . -16) (f242 . -12) (f242 . -8) (input-port . 4))
# var=f252
    movl -20(%esp), %eax  # stack load f252
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1556
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1556:
    movl %eax, -28(%esp)
# emit-expr 4
    movl $16, %eax     # immed 4
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1557"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1557:
# check bounds on vector index
    movl -28(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1559
    cmp  $0,%eax
    jge _L_1558
_L_1559:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1558:
    movl %eax, -32(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
    movl -28(%esp), %ebx
    movl -32(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-tail-expr
# si=-28
# env=((f251 . -24) (f252 . -20) (f248 . -16) (f242 . -12) (f242 . -8) (input-port . 4))
# expr=(begin (vector-set! f252 5 f251) (vector-set! f252 6 #f) (vector-set! f252 7 0) f252)
# tail-begin (begin (vector-set! f252 5 f251) (vector-set! f252 6 #f) (vector-set! f252 7 0) f252)
#   env=((f251 . -24) (f252 . -20) (f248 . -16) (f242 . -12) (f242 . -8) (input-port . 4))
# emit-expr (vector-set! f252 5 f251)
# emit-expr f252
# emit-variable-ref
# env=((f251 . -24) (f252 . -20) (f248 . -16) (f242 . -12) (f242 . -8) (input-port . 4))
# var=f252
    movl -20(%esp), %eax  # stack load f252
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1560
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1560:
    movl %eax, -28(%esp)
# emit-expr 5
    movl $20, %eax     # immed 5
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1561"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1561:
# check bounds on vector index
    movl -28(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1563
    cmp  $0,%eax
    jge _L_1562
_L_1563:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1562:
    movl %eax, -32(%esp)
# emit-expr f251
# emit-variable-ref
# env=((f251 . -24) (f252 . -20) (f248 . -16) (f242 . -12) (f242 . -8) (input-port . 4))
# var=f251
    movl -24(%esp), %eax  # stack load f251
# end emit-variable-ref
    movl -28(%esp), %ebx
    movl -32(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-tail-expr
# si=-28
# env=((f251 . -24) (f252 . -20) (f248 . -16) (f242 . -12) (f242 . -8) (input-port . 4))
# expr=(begin (vector-set! f252 6 #f) (vector-set! f252 7 0) f252)
# tail-begin (begin (vector-set! f252 6 #f) (vector-set! f252 7 0) f252)
#   env=((f251 . -24) (f252 . -20) (f248 . -16) (f242 . -12) (f242 . -8) (input-port . 4))
# emit-expr (vector-set! f252 6 #f)
# emit-expr f252
# emit-variable-ref
# env=((f251 . -24) (f252 . -20) (f248 . -16) (f242 . -12) (f242 . -8) (input-port . 4))
# var=f252
    movl -20(%esp), %eax  # stack load f252
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1564
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1564:
    movl %eax, -28(%esp)
# emit-expr 6
    movl $24, %eax     # immed 6
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1565"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1565:
# check bounds on vector index
    movl -28(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1567
    cmp  $0,%eax
    jge _L_1566
_L_1567:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1566:
    movl %eax, -32(%esp)
# emit-expr #f
    movl $47, %eax     # immed #f
    movl -28(%esp), %ebx
    movl -32(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-tail-expr
# si=-28
# env=((f251 . -24) (f252 . -20) (f248 . -16) (f242 . -12) (f242 . -8) (input-port . 4))
# expr=(begin (vector-set! f252 7 0) f252)
# tail-begin (begin (vector-set! f252 7 0) f252)
#   env=((f251 . -24) (f252 . -20) (f248 . -16) (f242 . -12) (f242 . -8) (input-port . 4))
# emit-expr (vector-set! f252 7 0)
# emit-expr f252
# emit-variable-ref
# env=((f251 . -24) (f252 . -20) (f248 . -16) (f242 . -12) (f242 . -8) (input-port . 4))
# var=f252
    movl -20(%esp), %eax  # stack load f252
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1568
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1568:
    movl %eax, -28(%esp)
# emit-expr 7
    movl $28, %eax     # immed 7
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1569"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1569:
# check bounds on vector index
    movl -28(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1571
    cmp  $0,%eax
    jge _L_1570
_L_1571:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1570:
    movl %eax, -32(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
    movl -28(%esp), %ebx
    movl -32(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-tail-expr
# si=-28
# env=((f251 . -24) (f252 . -20) (f248 . -16) (f242 . -12) (f242 . -8) (input-port . 4))
# expr=(begin f252)
# tail-begin (begin f252)
#   env=((f251 . -24) (f252 . -20) (f248 . -16) (f242 . -12) (f242 . -8) (input-port . 4))
# emit-tail-expr
# si=-28
# env=((f251 . -24) (f252 . -20) (f248 . -16) (f242 . -12) (f242 . -8) (input-port . 4))
# expr=f252
# emit-tail-variable-ref
# emit-variable-ref
# env=((f251 . -24) (f252 . -20) (f248 . -16) (f242 . -12) (f242 . -8) (input-port . 4))
# var=f252
    movl -20(%esp), %eax  # stack load f252
# end emit-variable-ref
    ret
# end emit-tail-variable ref
     ret   # return thru stack
     ret   # return thru stack
     ret   # return thru stack
    .align 4,0x90
_L_1514:
     movl %eax, mrc_open$minput$mfile
# == explicit-begins  ==>
# (lambda args (let ((p (if (null? args) (current-input-port) (car args)))) (cond ((port-unread p) (let ((ch (port-unread p))) (begin (unless (eof-object? (port-unread p)) (port-unread-clear p)) ch))) (else (begin (when (fx= (port-last p) (port-ndx p)) (fill-input-buffer p)) (if (port-unread p) (port-unread p) (let ((ch (string-ref (port-buf p) (port-ndx p)))) (begin (port-ndx-add1 p) ch))))))))
# == eliminate-let*  ==>
# (lambda args (let ((p (if (null? args) (current-input-port) (car args)))) (cond ((port-unread p) (let ((ch (port-unread p))) (begin (unless (eof-object? (port-unread p)) (port-unread-clear p)) ch))) (else (begin (when (fx= (port-last p) (port-ndx p)) (fill-input-buffer p)) (if (port-unread p) (port-unread p) (let ((ch (string-ref (port-buf p) (port-ndx p)))) (begin (port-ndx-add1 p) ch))))))))
# == uniquify-variables  ==>
<<<<<<< HEAD
# (lambda f311040 (let ((f311046 (if (null? f311040) (current-input-port) (car f311040)))) (cond ((port-unread f311046) (let ((f311050 (port-unread f311046))) (begin (unless (eof-object? (port-unread f311046)) (port-unread-clear f311046)) f311050))) (else (begin (when (fx= (port-last f311046) (port-ndx f311046)) (fill-input-buffer f311046)) (if (port-unread f311046) (port-unread f311046) (let ((f311049 (string-ref (port-buf f311046) (port-ndx f311046)))) (begin (port-ndx-add1 f311046) f311049))))))))
# == vectorize-letrec  ==>
# (lambda f311040 (let ((f311046 (if (null? f311040) (current-input-port) (car f311040)))) (cond ((port-unread f311046) (let ((f311050 (port-unread f311046))) (begin (unless (eof-object? (port-unread f311046)) (port-unread-clear f311046)) f311050))) (else (begin (when (fx= (port-last f311046) (port-ndx f311046)) (fill-input-buffer f311046)) (if (port-unread f311046) (port-unread f311046) (let ((f311049 (string-ref (port-buf f311046) (port-ndx f311046)))) (begin (port-ndx-add1 f311046) f311049))))))))
# == eliminate-set!  ==>
# (lambda f311040 (let () (let ((f311046 (if (null? f311040) (current-input-port) (car f311040)))) (cond ((port-unread f311046) (let ((f311050 (port-unread f311046))) (begin (unless (eof-object? (port-unread f311046)) (port-unread-clear f311046)) f311050))) (else (begin (when (fx= (port-last f311046) (port-ndx f311046)) (fill-input-buffer f311046)) (if (port-unread f311046) (port-unread f311046) (let ((f311049 (string-ref (port-buf f311046) (port-ndx f311046)))) (begin (port-ndx-add1 f311046) f311049)))))))))
# == close-free-variables  ==>
# (closure f311040 () (let () (let ((f311046 (if (null? f311040) (current-input-port) (car f311040)))) (cond ((port-unread f311046) (let ((f311050 (port-unread f311046))) (begin (unless (eof-object? (port-unread f311046)) (port-unread-clear f311046)) f311050))) (else (begin (when (fx= (port-last f311046) (port-ndx f311046)) (fill-input-buffer f311046)) (if (port-unread f311046) (port-unread f311046) (let ((f311049 (string-ref (port-buf f311046) (port-ndx f311046)))) (begin (port-ndx-add1 f311046) f311049)))))))))
# == eliminate-quote  ==>
# (closure f311040 () (let () (let ((f311046 (if (null? f311040) (current-input-port) (car f311040)))) (cond ((port-unread f311046) (let ((f311050 (port-unread f311046))) (begin (unless (eof-object? (port-unread f311046)) (port-unread-clear f311046)) f311050))) (else (begin (when (fx= (port-last f311046) (port-ndx f311046)) (fill-input-buffer f311046)) (if (port-unread f311046) (port-unread f311046) (let ((f311049 (string-ref (port-buf f311046) (port-ndx f311046)))) (begin (port-ndx-add1 f311046) f311049)))))))))
# == eliminate-when/unless  ==>
# (closure f311040 () (let () (let ((f311046 (if (null? f311040) (current-input-port) (car f311040)))) (cond ((port-unread f311046) (let ((f311050 (port-unread f311046))) (begin (if (not (eof-object? (port-unread f311046))) (begin (port-unread-clear f311046)) #f) f311050))) (else (begin (if (fx= (port-last f311046) (port-ndx f311046)) (begin (fill-input-buffer f311046)) #f) (if (port-unread f311046) (port-unread f311046) (let ((f311049 (string-ref (port-buf f311046) (port-ndx f311046)))) (begin (port-ndx-add1 f311046) f311049)))))))))
# == eliminate-cond  ==>
# (closure f311040 () (let () (let ((f311046 (if (null? f311040) (current-input-port) (car f311040)))) (if (port-unread f311046) (let ((f311050 (port-unread f311046))) (begin (if (not (eof-object? (port-unread f311046))) (begin (port-unread-clear f311046)) #f) f311050)) (begin (if (fx= (port-last f311046) (port-ndx f311046)) (begin (fill-input-buffer f311046)) #f) (if (port-unread f311046) (port-unread f311046) (let ((f311049 (string-ref (port-buf f311046) (port-ndx f311046)))) (begin (port-ndx-add1 f311046) f311049))))))))
# == external-symbols  ==>
# (closure f311040 () (let () (let ((f311046 (if (null? f311040) ((primitive-ref current-input-port)) (car f311040)))) (if ((primitive-ref port-unread) f311046) (let ((f311050 ((primitive-ref port-unread) f311046))) (begin (if (not (eof-object? ((primitive-ref port-unread) f311046))) (begin ((primitive-ref port-unread-clear) f311046)) #f) f311050)) (begin (if (fx= ((primitive-ref port-last) f311046) ((primitive-ref port-ndx) f311046)) (begin ((primitive-ref fill-input-buffer) f311046)) #f) (if ((primitive-ref port-unread) f311046) ((primitive-ref port-unread) f311046) (let ((f311049 (string-ref ((primitive-ref port-buf) f311046) ((primitive-ref port-ndx) f311046)))) (begin ((primitive-ref port-ndx-add1) f311046) f311049))))))))
# emit-expr (closure f311040 () (let () (let ((f311046 (if (null? f311040) ((primitive-ref current-input-port)) (car f311040)))) (if ((primitive-ref port-unread) f311046) (let ((f311050 ((primitive-ref port-unread) f311046))) (begin (if (not (eof-object? ((primitive-ref port-unread) f311046))) (begin ((primitive-ref port-unread-clear) f311046)) #f) f311050)) (begin (if (fx= ((primitive-ref port-last) f311046) ((primitive-ref port-ndx) f311046)) (begin ((primitive-ref fill-input-buffer) f311046)) #f) (if ((primitive-ref port-unread) f311046) ((primitive-ref port-unread) f311046) (let ((f311049 (string-ref ((primitive-ref port-buf) f311046) ((primitive-ref port-ndx) f311046)))) (begin ((primitive-ref port-ndx-add1) f311046) f311049))))))))
# emit-closure
# si = 0
# env = ()
# expr = (closure f311040 () (let () (let ((f311046 (if (null? f311040) ((primitive-ref current-input-port)) (car f311040)))) (if ((primitive-ref port-unread) f311046) (let ((f311050 ((primitive-ref port-unread) f311046))) (begin (if (not (eof-object? ((primitive-ref port-unread) f311046))) (begin ((primitive-ref port-unread-clear) f311046)) #f) f311050)) (begin (if (fx= ((primitive-ref port-last) f311046) ((primitive-ref port-ndx) f311046)) (begin ((primitive-ref fill-input-buffer) f311046)) #f) (if ((primitive-ref port-unread) f311046) ((primitive-ref port-unread) f311046) (let ((f311049 (string-ref ((primitive-ref port-buf) f311046) ((primitive-ref port-ndx) f311046)))) (begin ((primitive-ref port-ndx-add1) f311046) f311049))))))))
    movl $_L_1885171, 0(%ebp)  # closure label
=======
# (lambda f253 (let ((f259 (if (null? f253) (current-input-port) (car f253)))) (cond ((port-unread f259) (let ((f262 (port-unread f259))) (begin (unless (eof-object? (port-unread f259)) (port-unread-clear f259)) f262))) (else (begin (when (fx= (port-last f259) (port-ndx f259)) (fill-input-buffer f259)) (if (port-unread f259) (port-unread f259) (let ((f263 (string-ref (port-buf f259) (port-ndx f259)))) (begin (port-ndx-add1 f259) f263))))))))
# == vectorize-letrec  ==>
# (lambda f253 (let ((f259 (if (null? f253) (current-input-port) (car f253)))) (cond ((port-unread f259) (let ((f262 (port-unread f259))) (begin (unless (eof-object? (port-unread f259)) (port-unread-clear f259)) f262))) (else (begin (when (fx= (port-last f259) (port-ndx f259)) (fill-input-buffer f259)) (if (port-unread f259) (port-unread f259) (let ((f263 (string-ref (port-buf f259) (port-ndx f259)))) (begin (port-ndx-add1 f259) f263))))))))
# == eliminate-set!  ==>
# (lambda f253 (let () (let ((f259 (if (null? f253) (current-input-port) (car f253)))) (cond ((port-unread f259) (let ((f262 (port-unread f259))) (begin (unless (eof-object? (port-unread f259)) (port-unread-clear f259)) f262))) (else (begin (when (fx= (port-last f259) (port-ndx f259)) (fill-input-buffer f259)) (if (port-unread f259) (port-unread f259) (let ((f263 (string-ref (port-buf f259) (port-ndx f259)))) (begin (port-ndx-add1 f259) f263)))))))))
# == close-free-variables  ==>
# (closure f253 () (let () (let ((f259 (if (null? f253) (current-input-port) (car f253)))) (cond ((port-unread f259) (let ((f262 (port-unread f259))) (begin (unless (eof-object? (port-unread f259)) (port-unread-clear f259)) f262))) (else (begin (when (fx= (port-last f259) (port-ndx f259)) (fill-input-buffer f259)) (if (port-unread f259) (port-unread f259) (let ((f263 (string-ref (port-buf f259) (port-ndx f259)))) (begin (port-ndx-add1 f259) f263)))))))))
# == eliminate-quote  ==>
# (closure f253 () (let () (let ((f259 (if (null? f253) (current-input-port) (car f253)))) (cond ((port-unread f259) (let ((f262 (port-unread f259))) (begin (unless (eof-object? (port-unread f259)) (port-unread-clear f259)) f262))) (else (begin (when (fx= (port-last f259) (port-ndx f259)) (fill-input-buffer f259)) (if (port-unread f259) (port-unread f259) (let ((f263 (string-ref (port-buf f259) (port-ndx f259)))) (begin (port-ndx-add1 f259) f263)))))))))
# == eliminate-when/unless  ==>
# (closure f253 () (let () (let ((f259 (if (null? f253) (current-input-port) (car f253)))) (cond ((port-unread f259) (let ((f262 (port-unread f259))) (begin (if (not (eof-object? (port-unread f259))) (begin (port-unread-clear f259)) #f) f262))) (else (begin (if (fx= (port-last f259) (port-ndx f259)) (begin (fill-input-buffer f259)) #f) (if (port-unread f259) (port-unread f259) (let ((f263 (string-ref (port-buf f259) (port-ndx f259)))) (begin (port-ndx-add1 f259) f263)))))))))
# == eliminate-cond  ==>
# (closure f253 () (let () (let ((f259 (if (null? f253) (current-input-port) (car f253)))) (if (port-unread f259) (begin (let ((f262 (port-unread f259))) (begin (if (not (eof-object? (port-unread f259))) (begin (port-unread-clear f259)) #f) f262))) (begin (begin (if (fx= (port-last f259) (port-ndx f259)) (begin (fill-input-buffer f259)) #f) (if (port-unread f259) (port-unread f259) (let ((f263 (string-ref (port-buf f259) (port-ndx f259)))) (begin (port-ndx-add1 f259) f263)))))))))
# == external-symbols  ==>
# (closure f253 () (let () (let ((f259 (if (null? f253) ((primitive-ref current-input-port)) (car f253)))) (if ((primitive-ref port-unread) f259) (begin (let ((f262 ((primitive-ref port-unread) f259))) (begin (if (not (eof-object? ((primitive-ref port-unread) f259))) (begin ((primitive-ref port-unread-clear) f259)) #f) f262))) (begin (begin (if (fx= ((primitive-ref port-last) f259) ((primitive-ref port-ndx) f259)) (begin ((primitive-ref fill-input-buffer) f259)) #f) (if ((primitive-ref port-unread) f259) ((primitive-ref port-unread) f259) (let ((f263 (string-ref ((primitive-ref port-buf) f259) ((primitive-ref port-ndx) f259)))) (begin ((primitive-ref port-ndx-add1) f259) f263)))))))))
# emit-expr (closure f253 () (let () (let ((f259 (if (null? f253) ((primitive-ref current-input-port)) (car f253)))) (if ((primitive-ref port-unread) f259) (begin (let ((f262 ((primitive-ref port-unread) f259))) (begin (if (not (eof-object? ((primitive-ref port-unread) f259))) (begin ((primitive-ref port-unread-clear) f259)) #f) f262))) (begin (begin (if (fx= ((primitive-ref port-last) f259) ((primitive-ref port-ndx) f259)) (begin ((primitive-ref fill-input-buffer) f259)) #f) (if ((primitive-ref port-unread) f259) ((primitive-ref port-unread) f259) (let ((f263 (string-ref ((primitive-ref port-buf) f259) ((primitive-ref port-ndx) f259)))) (begin ((primitive-ref port-ndx-add1) f259) f263)))))))))
# emit-closure
# si = 0
# env = ()
# expr = (closure f253 () (let () (let ((f259 (if (null? f253) ((primitive-ref current-input-port)) (car f253)))) (if ((primitive-ref port-unread) f259) (begin (let ((f262 ((primitive-ref port-unread) f259))) (begin (if (not (eof-object? ((primitive-ref port-unread) f259))) (begin ((primitive-ref port-unread-clear) f259)) #f) f262))) (begin (begin (if (fx= ((primitive-ref port-last) f259) ((primitive-ref port-ndx) f259)) (begin ((primitive-ref fill-input-buffer) f259)) #f) (if ((primitive-ref port-unread) f259) ((primitive-ref port-unread) f259) (let ((f263 (string-ref ((primitive-ref port-buf) f259) ((primitive-ref port-ndx) f259)))) (begin ((primitive-ref port-ndx-add1) f259) f263)))))))))
    movl $_L_1572, 0(%ebp)  # closure label
>>>>>>> fix-implicit-begins
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $8, %ebp     # bump ebp
    jmp _L_1573            # jump around closure body
_L_1572:
# check argument count
    cmp $0,%eax
    jge _L_1574
# invoke error handler eh_argcount_min
    .extern mrc_eh$uargcount$umin
    movl mrc_eh$uargcount$umin, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_1574:
# emit-build-varargs-list
    movl $63, %esi       # args <- () 
    lea -4(%esp),%edi    # edi <- esp-4
    subl %eax, %edi      # edi <- esp-4-eax    addr of arg[K+N] on stack
_L_1576:
    lea -4(%esp),%ebx    # addr of arg[K] on stack
    cmp %edi, %ebx       # while edi <> esp+(si+4)
    je _L_1575
    movl (%edi),%ebx     # arg i -> car
    movl %ebx, 0(%ebp)
    movl %esi, 4(%ebp)  # esi -> cdr
    movl %ebp, %esi
    addl $1, %esi       # tag as pair
    addl $8,%ebp         # bump heap ptr
    addl $4,%edi         # move to next previous arg from the end
    jmp _L_1576
_L_1575:
    movl %esi, -8(%esp)  # set args
# emit-tail-expr
# si=-12
<<<<<<< HEAD
# env=((f311040 . -8))
# expr=(let () (let ((f311046 (if (null? f311040) ((primitive-ref current-input-port)) (car f311040)))) (if ((primitive-ref port-unread) f311046) (let ((f311050 ((primitive-ref port-unread) f311046))) (begin (if (not (eof-object? ((primitive-ref port-unread) f311046))) (begin ((primitive-ref port-unread-clear) f311046)) #f) f311050)) (begin (if (fx= ((primitive-ref port-last) f311046) ((primitive-ref port-ndx) f311046)) (begin ((primitive-ref fill-input-buffer) f311046)) #f) (if ((primitive-ref port-unread) f311046) ((primitive-ref port-unread) f311046) (let ((f311049 (string-ref ((primitive-ref port-buf) f311046) ((primitive-ref port-ndx) f311046)))) (begin ((primitive-ref port-ndx-add1) f311046) f311049)))))))
=======
# env=((f253 . -8))
# expr=(let () (let ((f259 (if (null? f253) ((primitive-ref current-input-port)) (car f253)))) (if ((primitive-ref port-unread) f259) (begin (let ((f262 ((primitive-ref port-unread) f259))) (begin (if (not (eof-object? ((primitive-ref port-unread) f259))) (begin ((primitive-ref port-unread-clear) f259)) #f) f262))) (begin (begin (if (fx= ((primitive-ref port-last) f259) ((primitive-ref port-ndx) f259)) (begin ((primitive-ref fill-input-buffer) f259)) #f) (if ((primitive-ref port-unread) f259) ((primitive-ref port-unread) f259) (let ((f263 (string-ref ((primitive-ref port-buf) f259) ((primitive-ref port-ndx) f259)))) (begin ((primitive-ref port-ndx-add1) f259) f263))))))))
>>>>>>> fix-implicit-begins
# emit-tail-let
#  si   = -12
#  env  = ((f253 . -8))
#  bindings = ()
<<<<<<< HEAD
#  body = (let ((f311046 (if (null? f311040) ((primitive-ref current-input-port)) (car f311040)))) (if ((primitive-ref port-unread) f311046) (let ((f311050 ((primitive-ref port-unread) f311046))) (begin (if (not (eof-object? ((primitive-ref port-unread) f311046))) (begin ((primitive-ref port-unread-clear) f311046)) #f) f311050)) (begin (if (fx= ((primitive-ref port-last) f311046) ((primitive-ref port-ndx) f311046)) (begin ((primitive-ref fill-input-buffer) f311046)) #f) (if ((primitive-ref port-unread) f311046) ((primitive-ref port-unread) f311046) (let ((f311049 (string-ref ((primitive-ref port-buf) f311046) ((primitive-ref port-ndx) f311046)))) (begin ((primitive-ref port-ndx-add1) f311046) f311049))))))
# emit-tail-expr
# si=-12
# env=((f311040 . -8))
# expr=(let ((f311046 (if (null? f311040) ((primitive-ref current-input-port)) (car f311040)))) (if ((primitive-ref port-unread) f311046) (let ((f311050 ((primitive-ref port-unread) f311046))) (begin (if (not (eof-object? ((primitive-ref port-unread) f311046))) (begin ((primitive-ref port-unread-clear) f311046)) #f) f311050)) (begin (if (fx= ((primitive-ref port-last) f311046) ((primitive-ref port-ndx) f311046)) (begin ((primitive-ref fill-input-buffer) f311046)) #f) (if ((primitive-ref port-unread) f311046) ((primitive-ref port-unread) f311046) (let ((f311049 (string-ref ((primitive-ref port-buf) f311046) ((primitive-ref port-ndx) f311046)))) (begin ((primitive-ref port-ndx-add1) f311046) f311049))))))
# emit-tail-let
#  si   = -12
#  env  = ((f311040 . -8))
#  bindings = ((f311046 (if (null? f311040) ((primitive-ref current-input-port)) (car f311040))))
#  body = (if ((primitive-ref port-unread) f311046) (let ((f311050 ((primitive-ref port-unread) f311046))) (begin (if (not (eof-object? ((primitive-ref port-unread) f311046))) (begin ((primitive-ref port-unread-clear) f311046)) #f) f311050)) (begin (if (fx= ((primitive-ref port-last) f311046) ((primitive-ref port-ndx) f311046)) (begin ((primitive-ref fill-input-buffer) f311046)) #f) (if ((primitive-ref port-unread) f311046) ((primitive-ref port-unread) f311046) (let ((f311049 (string-ref ((primitive-ref port-buf) f311046) ((primitive-ref port-ndx) f311046)))) (begin ((primitive-ref port-ndx-add1) f311046) f311049)))))
# emit-expr (if (null? f311040) ((primitive-ref current-input-port)) (car f311040))
# emit-expr (null? f311040)
# emit-expr f311040
=======
#  body = (let ((f259 (if (null? f253) ((primitive-ref current-input-port)) (car f253)))) (if ((primitive-ref port-unread) f259) (begin (let ((f262 ((primitive-ref port-unread) f259))) (begin (if (not (eof-object? ((primitive-ref port-unread) f259))) (begin ((primitive-ref port-unread-clear) f259)) #f) f262))) (begin (begin (if (fx= ((primitive-ref port-last) f259) ((primitive-ref port-ndx) f259)) (begin ((primitive-ref fill-input-buffer) f259)) #f) (if ((primitive-ref port-unread) f259) ((primitive-ref port-unread) f259) (let ((f263 (string-ref ((primitive-ref port-buf) f259) ((primitive-ref port-ndx) f259)))) (begin ((primitive-ref port-ndx-add1) f259) f263)))))))
# emit-tail-expr
# si=-12
# env=((f253 . -8))
# expr=(let ((f259 (if (null? f253) ((primitive-ref current-input-port)) (car f253)))) (if ((primitive-ref port-unread) f259) (begin (let ((f262 ((primitive-ref port-unread) f259))) (begin (if (not (eof-object? ((primitive-ref port-unread) f259))) (begin ((primitive-ref port-unread-clear) f259)) #f) f262))) (begin (begin (if (fx= ((primitive-ref port-last) f259) ((primitive-ref port-ndx) f259)) (begin ((primitive-ref fill-input-buffer) f259)) #f) (if ((primitive-ref port-unread) f259) ((primitive-ref port-unread) f259) (let ((f263 (string-ref ((primitive-ref port-buf) f259) ((primitive-ref port-ndx) f259)))) (begin ((primitive-ref port-ndx-add1) f259) f263)))))))
# emit-tail-let
#  si   = -12
#  env  = ((f253 . -8))
#  bindings = ((f259 (if (null? f253) ((primitive-ref current-input-port)) (car f253))))
#  body = (if ((primitive-ref port-unread) f259) (begin (let ((f262 ((primitive-ref port-unread) f259))) (begin (if (not (eof-object? ((primitive-ref port-unread) f259))) (begin ((primitive-ref port-unread-clear) f259)) #f) f262))) (begin (begin (if (fx= ((primitive-ref port-last) f259) ((primitive-ref port-ndx) f259)) (begin ((primitive-ref fill-input-buffer) f259)) #f) (if ((primitive-ref port-unread) f259) ((primitive-ref port-unread) f259) (let ((f263 (string-ref ((primitive-ref port-buf) f259) ((primitive-ref port-ndx) f259)))) (begin ((primitive-ref port-ndx-add1) f259) f263))))))
# emit-expr (if (null? f253) ((primitive-ref current-input-port)) (car f253))
# emit-expr (null? f253)
# emit-expr f253
>>>>>>> fix-implicit-begins
# emit-variable-ref
# env=((f253 . -8))
# var=f253
    movl -8(%esp), %eax  # stack load f253
# end emit-variable-ref
    cmp $63, %eax
    mov $0, %eax
    sete %al
    movzbl %al, %eax
    sal $6, %al
    or $47, %al
    cmp $47, %al
    je _L_1577
# emit-expr ((primitive-ref current-input-port))
# funcall
#    si   =-12
#    env  = ((f253 . -8))
#    expr = (funcall (primitive-ref current-input-port))
# emit-expr (primitive-ref current-input-port)
    .extern mrc_current$minput$mport
    movl mrc_current$minput$mport,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1579"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1579":
   movl %eax,  -20(%esp)  # stash funcall-oper in closure slot
    movl -20(%esp), %edi   # load new closure to %edi
    add $-12, %esp   # adjust base
    movl $0,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $12, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    jmp _L_1578
_L_1577:
# emit-expr (car f253)
# emit-expr f253
# emit-variable-ref
# env=((f253 . -8))
# var=f253
    movl -8(%esp), %eax  # stack load f253
# end emit-variable-ref
# check the argument is a pair
    movl %eax,%ebx
    and $7, %bl
    cmp $1, %bl
    je _L_1580
# invoke error handler eh_pair
    .extern mrc_eh$upair
    movl mrc_eh$upair, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $116,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1580:
    movl -1(%eax), %eax
_L_1578:
    movl %eax, -12(%esp)  # stack save
# emit-tail-expr
# si=-16
<<<<<<< HEAD
# env=((f311046 . -12) (f311040 . -8))
# expr=(if ((primitive-ref port-unread) f311046) (let ((f311050 ((primitive-ref port-unread) f311046))) (begin (if (not (eof-object? ((primitive-ref port-unread) f311046))) (begin ((primitive-ref port-unread-clear) f311046)) #f) f311050)) (begin (if (fx= ((primitive-ref port-last) f311046) ((primitive-ref port-ndx) f311046)) (begin ((primitive-ref fill-input-buffer) f311046)) #f) (if ((primitive-ref port-unread) f311046) ((primitive-ref port-unread) f311046) (let ((f311049 (string-ref ((primitive-ref port-buf) f311046) ((primitive-ref port-ndx) f311046)))) (begin ((primitive-ref port-ndx-add1) f311046) f311049)))))
# emit-expr ((primitive-ref port-unread) f311046)
=======
# env=((f259 . -12) (f253 . -8))
# expr=(if ((primitive-ref port-unread) f259) (begin (let ((f262 ((primitive-ref port-unread) f259))) (begin (if (not (eof-object? ((primitive-ref port-unread) f259))) (begin ((primitive-ref port-unread-clear) f259)) #f) f262))) (begin (begin (if (fx= ((primitive-ref port-last) f259) ((primitive-ref port-ndx) f259)) (begin ((primitive-ref fill-input-buffer) f259)) #f) (if ((primitive-ref port-unread) f259) ((primitive-ref port-unread) f259) (let ((f263 (string-ref ((primitive-ref port-buf) f259) ((primitive-ref port-ndx) f259)))) (begin ((primitive-ref port-ndx-add1) f259) f263))))))
# emit-expr ((primitive-ref port-unread) f259)
>>>>>>> fix-implicit-begins
# funcall
#    si   =-16
#    env  = ((f259 . -12) (f253 . -8))
#    expr = (funcall (primitive-ref port-unread) f259)
# emit-expr (primitive-ref port-unread)
    .extern mrc_port$munread
    movl mrc_port$munread,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1583"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1583":
   movl %eax,  -24(%esp)  # stash funcall-oper in closure slot
# emit-expr f259
# emit-variable-ref
# env=((f259 . -12) (f253 . -8))
# var=f259
    movl -12(%esp), %eax  # stack load f259
# end emit-variable-ref
    mov %eax, -28(%esp)  # arg f259
    movl -24(%esp), %edi   # load new closure to %edi
    add $-16, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $16, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    cmp $47, %al
    je _L_1581
# emit-tail-expr
# si=-16
<<<<<<< HEAD
# env=((f311046 . -12) (f311040 . -8))
# expr=(let ((f311050 ((primitive-ref port-unread) f311046))) (begin (if (not (eof-object? ((primitive-ref port-unread) f311046))) (begin ((primitive-ref port-unread-clear) f311046)) #f) f311050))
# emit-tail-let
#  si   = -16
#  env  = ((f311046 . -12) (f311040 . -8))
#  bindings = ((f311050 ((primitive-ref port-unread) f311046)))
#  body = (begin (if (not (eof-object? ((primitive-ref port-unread) f311046))) (begin ((primitive-ref port-unread-clear) f311046)) #f) f311050)
# emit-expr ((primitive-ref port-unread) f311046)
=======
# env=((f259 . -12) (f253 . -8))
# expr=(begin (let ((f262 ((primitive-ref port-unread) f259))) (begin (if (not (eof-object? ((primitive-ref port-unread) f259))) (begin ((primitive-ref port-unread-clear) f259)) #f) f262)))
# tail-begin (begin (let ((f262 ((primitive-ref port-unread) f259))) (begin (if (not (eof-object? ((primitive-ref port-unread) f259))) (begin ((primitive-ref port-unread-clear) f259)) #f) f262)))
#   env=((f259 . -12) (f253 . -8))
# emit-tail-expr
# si=-16
# env=((f259 . -12) (f253 . -8))
# expr=(let ((f262 ((primitive-ref port-unread) f259))) (begin (if (not (eof-object? ((primitive-ref port-unread) f259))) (begin ((primitive-ref port-unread-clear) f259)) #f) f262))
# emit-tail-let
#  si   = -16
#  env  = ((f259 . -12) (f253 . -8))
#  bindings = ((f262 ((primitive-ref port-unread) f259)))
#  body = (begin (if (not (eof-object? ((primitive-ref port-unread) f259))) (begin ((primitive-ref port-unread-clear) f259)) #f) f262)
# emit-expr ((primitive-ref port-unread) f259)
>>>>>>> fix-implicit-begins
# funcall
#    si   =-16
#    env  = ((f259 . -12) (f253 . -8))
#    expr = (funcall (primitive-ref port-unread) f259)
# emit-expr (primitive-ref port-unread)
    .extern mrc_port$munread
    movl mrc_port$munread,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1584"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1584":
   movl %eax,  -24(%esp)  # stash funcall-oper in closure slot
# emit-expr f259
# emit-variable-ref
# env=((f259 . -12) (f253 . -8))
# var=f259
    movl -12(%esp), %eax  # stack load f259
# end emit-variable-ref
    mov %eax, -28(%esp)  # arg f259
    movl -24(%esp), %edi   # load new closure to %edi
    add $-16, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $16, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    movl %eax, -16(%esp)  # stack save
# emit-tail-expr
# si=-20
<<<<<<< HEAD
# env=((f311050 . -16) (f311046 . -12) (f311040 . -8))
# expr=(begin (if (not (eof-object? ((primitive-ref port-unread) f311046))) (begin ((primitive-ref port-unread-clear) f311046)) #f) f311050)
# tail-begin (begin (if (not (eof-object? ((primitive-ref port-unread) f311046))) (begin ((primitive-ref port-unread-clear) f311046)) #f) f311050)
#   env=((f311050 . -16) (f311046 . -12) (f311040 . -8))
# emit-expr (if (not (eof-object? ((primitive-ref port-unread) f311046))) (begin ((primitive-ref port-unread-clear) f311046)) #f)
# emit-expr (not (eof-object? ((primitive-ref port-unread) f311046)))
# emit-expr (eof-object? ((primitive-ref port-unread) f311046))
# emit-expr ((primitive-ref port-unread) f311046)
# funcall
#    si   =-20
#    env  = ((f311050 . -16) (f311046 . -12) (f311040 . -8))
#    expr = (funcall (primitive-ref port-unread) f311046)
=======
# env=((f262 . -16) (f259 . -12) (f253 . -8))
# expr=(begin (if (not (eof-object? ((primitive-ref port-unread) f259))) (begin ((primitive-ref port-unread-clear) f259)) #f) f262)
# tail-begin (begin (if (not (eof-object? ((primitive-ref port-unread) f259))) (begin ((primitive-ref port-unread-clear) f259)) #f) f262)
#   env=((f262 . -16) (f259 . -12) (f253 . -8))
# emit-expr (if (not (eof-object? ((primitive-ref port-unread) f259))) (begin ((primitive-ref port-unread-clear) f259)) #f)
# emit-expr (not (eof-object? ((primitive-ref port-unread) f259)))
# emit-expr (eof-object? ((primitive-ref port-unread) f259))
# emit-expr ((primitive-ref port-unread) f259)
# funcall
#    si   =-20
#    env  = ((f262 . -16) (f259 . -12) (f253 . -8))
#    expr = (funcall (primitive-ref port-unread) f259)
>>>>>>> fix-implicit-begins
# emit-expr (primitive-ref port-unread)
    .extern mrc_port$munread
    movl mrc_port$munread,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1587"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1587":
   movl %eax,  -28(%esp)  # stash funcall-oper in closure slot
# emit-expr f259
# emit-variable-ref
<<<<<<< HEAD
# env=((f311050 . -16) (f311046 . -12) (f311040 . -8))
# var=f311046
    movl -12(%esp), %eax  # stack load f311046
=======
# env=((f262 . -16) (f259 . -12) (f253 . -8))
# var=f259
    movl -12(%esp), %eax  # stack load f259
>>>>>>> fix-implicit-begins
# end emit-variable-ref
    mov %eax, -32(%esp)  # arg f259
    movl -28(%esp), %edi   # load new closure to %edi
    add $-20, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $20, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    cmp $95, %eax
    mov $0, %eax
    sete %al
    movzbl %al, %eax
    sal $6, %al
    or $47, %al
    cmp $47, %eax
    sete %al
    movzbl %al, %eax
    sal $6, %al
    or $47, %al
    cmp $47, %al
    je _L_1585
# emit-expr (begin ((primitive-ref port-unread-clear) f259))
# emit-begin
<<<<<<< HEAD
#   expr=(begin ((primitive-ref port-unread-clear) f311046))
#   env=((f311050 . -16) (f311046 . -12) (f311040 . -8))
# emit-expr ((primitive-ref port-unread-clear) f311046)
# funcall
#    si   =-20
#    env  = ((f311050 . -16) (f311046 . -12) (f311040 . -8))
#    expr = (funcall (primitive-ref port-unread-clear) f311046)
=======
#   expr=(begin ((primitive-ref port-unread-clear) f259))
#   env=((f262 . -16) (f259 . -12) (f253 . -8))
# emit-expr ((primitive-ref port-unread-clear) f259)
# funcall
#    si   =-20
#    env  = ((f262 . -16) (f259 . -12) (f253 . -8))
#    expr = (funcall (primitive-ref port-unread-clear) f259)
>>>>>>> fix-implicit-begins
# emit-expr (primitive-ref port-unread-clear)
    .extern mrc_port$munread$mclear
    movl mrc_port$munread$mclear,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1588"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1588":
   movl %eax,  -28(%esp)  # stash funcall-oper in closure slot
# emit-expr f259
# emit-variable-ref
<<<<<<< HEAD
# env=((f311050 . -16) (f311046 . -12) (f311040 . -8))
# var=f311046
    movl -12(%esp), %eax  # stack load f311046
=======
# env=((f262 . -16) (f259 . -12) (f253 . -8))
# var=f259
    movl -12(%esp), %eax  # stack load f259
>>>>>>> fix-implicit-begins
# end emit-variable-ref
    mov %eax, -32(%esp)  # arg f259
    movl -28(%esp), %edi   # load new closure to %edi
    add $-20, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $20, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
# emit-expr (begin)
# emit-begin
#   expr=(begin)
<<<<<<< HEAD
#   env=((f311050 . -16) (f311046 . -12) (f311040 . -8))
    jmp _L_1885185
_L_1885184:
=======
#   env=((f262 . -16) (f259 . -12) (f253 . -8))
    jmp _L_1586
_L_1585:
>>>>>>> fix-implicit-begins
# emit-expr #f
    movl $47, %eax     # immed #f
_L_1586:
# emit-tail-expr
# si=-20
<<<<<<< HEAD
# env=((f311050 . -16) (f311046 . -12) (f311040 . -8))
# expr=(begin f311050)
# tail-begin (begin f311050)
#   env=((f311050 . -16) (f311046 . -12) (f311040 . -8))
# emit-tail-expr
# si=-20
# env=((f311050 . -16) (f311046 . -12) (f311040 . -8))
# expr=f311050
# emit-tail-variable-ref
# emit-variable-ref
# env=((f311050 . -16) (f311046 . -12) (f311040 . -8))
# var=f311050
    movl -16(%esp), %eax  # stack load f311050
=======
# env=((f262 . -16) (f259 . -12) (f253 . -8))
# expr=(begin f262)
# tail-begin (begin f262)
#   env=((f262 . -16) (f259 . -12) (f253 . -8))
# emit-tail-expr
# si=-20
# env=((f262 . -16) (f259 . -12) (f253 . -8))
# expr=f262
# emit-tail-variable-ref
# emit-variable-ref
# env=((f262 . -16) (f259 . -12) (f253 . -8))
# var=f262
    movl -16(%esp), %eax  # stack load f262
>>>>>>> fix-implicit-begins
# end emit-variable-ref
    ret
# end emit-tail-variable ref
     ret   # return thru stack
     ret   # return thru stack
    jmp _L_1582
_L_1581:
# emit-tail-expr
# si=-16
<<<<<<< HEAD
# env=((f311046 . -12) (f311040 . -8))
# expr=(begin (if (fx= ((primitive-ref port-last) f311046) ((primitive-ref port-ndx) f311046)) (begin ((primitive-ref fill-input-buffer) f311046)) #f) (if ((primitive-ref port-unread) f311046) ((primitive-ref port-unread) f311046) (let ((f311049 (string-ref ((primitive-ref port-buf) f311046) ((primitive-ref port-ndx) f311046)))) (begin ((primitive-ref port-ndx-add1) f311046) f311049))))
# tail-begin (begin (if (fx= ((primitive-ref port-last) f311046) ((primitive-ref port-ndx) f311046)) (begin ((primitive-ref fill-input-buffer) f311046)) #f) (if ((primitive-ref port-unread) f311046) ((primitive-ref port-unread) f311046) (let ((f311049 (string-ref ((primitive-ref port-buf) f311046) ((primitive-ref port-ndx) f311046)))) (begin ((primitive-ref port-ndx-add1) f311046) f311049))))
#   env=((f311046 . -12) (f311040 . -8))
# emit-expr (if (fx= ((primitive-ref port-last) f311046) ((primitive-ref port-ndx) f311046)) (begin ((primitive-ref fill-input-buffer) f311046)) #f)
# emit-expr (fx= ((primitive-ref port-last) f311046) ((primitive-ref port-ndx) f311046))
# emit-expr ((primitive-ref port-ndx) f311046)
=======
# env=((f259 . -12) (f253 . -8))
# expr=(begin (begin (if (fx= ((primitive-ref port-last) f259) ((primitive-ref port-ndx) f259)) (begin ((primitive-ref fill-input-buffer) f259)) #f) (if ((primitive-ref port-unread) f259) ((primitive-ref port-unread) f259) (let ((f263 (string-ref ((primitive-ref port-buf) f259) ((primitive-ref port-ndx) f259)))) (begin ((primitive-ref port-ndx-add1) f259) f263)))))
# tail-begin (begin (begin (if (fx= ((primitive-ref port-last) f259) ((primitive-ref port-ndx) f259)) (begin ((primitive-ref fill-input-buffer) f259)) #f) (if ((primitive-ref port-unread) f259) ((primitive-ref port-unread) f259) (let ((f263 (string-ref ((primitive-ref port-buf) f259) ((primitive-ref port-ndx) f259)))) (begin ((primitive-ref port-ndx-add1) f259) f263)))))
#   env=((f259 . -12) (f253 . -8))
# emit-tail-expr
# si=-16
# env=((f259 . -12) (f253 . -8))
# expr=(begin (if (fx= ((primitive-ref port-last) f259) ((primitive-ref port-ndx) f259)) (begin ((primitive-ref fill-input-buffer) f259)) #f) (if ((primitive-ref port-unread) f259) ((primitive-ref port-unread) f259) (let ((f263 (string-ref ((primitive-ref port-buf) f259) ((primitive-ref port-ndx) f259)))) (begin ((primitive-ref port-ndx-add1) f259) f263))))
# tail-begin (begin (if (fx= ((primitive-ref port-last) f259) ((primitive-ref port-ndx) f259)) (begin ((primitive-ref fill-input-buffer) f259)) #f) (if ((primitive-ref port-unread) f259) ((primitive-ref port-unread) f259) (let ((f263 (string-ref ((primitive-ref port-buf) f259) ((primitive-ref port-ndx) f259)))) (begin ((primitive-ref port-ndx-add1) f259) f263))))
#   env=((f259 . -12) (f253 . -8))
# emit-expr (if (fx= ((primitive-ref port-last) f259) ((primitive-ref port-ndx) f259)) (begin ((primitive-ref fill-input-buffer) f259)) #f)
# emit-expr (fx= ((primitive-ref port-last) f259) ((primitive-ref port-ndx) f259))
# emit-expr ((primitive-ref port-ndx) f259)
>>>>>>> fix-implicit-begins
# funcall
#    si   =-16
#    env  = ((f259 . -12) (f253 . -8))
#    expr = (funcall (primitive-ref port-ndx) f259)
# emit-expr (primitive-ref port-ndx)
    .extern mrc_port$mndx
    movl mrc_port$mndx,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1591"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1591":
   movl %eax,  -24(%esp)  # stash funcall-oper in closure slot
# emit-expr f259
# emit-variable-ref
# env=((f259 . -12) (f253 . -8))
# var=f259
    movl -12(%esp), %eax  # stack load f259
# end emit-variable-ref
    mov %eax, -28(%esp)  # arg f259
    movl -24(%esp), %edi   # load new closure to %edi
    add $-16, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $16, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1592"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $68,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1592:
    movl %eax, -16(%esp)
# emit-expr ((primitive-ref port-last) f259)
# funcall
#    si   =-20
#    env  = ((f259 . -12) (f253 . -8))
#    expr = (funcall (primitive-ref port-last) f259)
# emit-expr (primitive-ref port-last)
    .extern mrc_port$mlast
    movl mrc_port$mlast,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1593"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1593":
   movl %eax,  -28(%esp)  # stash funcall-oper in closure slot
# emit-expr f259
# emit-variable-ref
# env=((f259 . -12) (f253 . -8))
# var=f259
    movl -12(%esp), %eax  # stack load f259
# end emit-variable-ref
    mov %eax, -32(%esp)  # arg f259
    movl -28(%esp), %edi   # load new closure to %edi
    add $-20, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $20, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1594"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $68,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1594:
    cmp -16(%esp), %eax
    sete %al
    movzbl %al, %eax
    sal $6, %al
    or $47, %al
    cmp $47, %al
    je _L_1589
# emit-expr (begin ((primitive-ref fill-input-buffer) f259))
# emit-begin
#   expr=(begin ((primitive-ref fill-input-buffer) f259))
#   env=((f259 . -12) (f253 . -8))
# emit-expr ((primitive-ref fill-input-buffer) f259)
# funcall
#    si   =-16
#    env  = ((f259 . -12) (f253 . -8))
#    expr = (funcall (primitive-ref fill-input-buffer) f259)
# emit-expr (primitive-ref fill-input-buffer)
    .extern mrc_fill$minput$mbuffer
    movl mrc_fill$minput$mbuffer,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1595"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1595":
   movl %eax,  -24(%esp)  # stash funcall-oper in closure slot
# emit-expr f259
# emit-variable-ref
# env=((f259 . -12) (f253 . -8))
# var=f259
    movl -12(%esp), %eax  # stack load f259
# end emit-variable-ref
    mov %eax, -28(%esp)  # arg f259
    movl -24(%esp), %edi   # load new closure to %edi
    add $-16, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $16, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
# emit-expr (begin)
# emit-begin
#   expr=(begin)
#   env=((f259 . -12) (f253 . -8))
    jmp _L_1590
_L_1589:
# emit-expr #f
    movl $47, %eax     # immed #f
_L_1590:
# emit-tail-expr
# si=-16
<<<<<<< HEAD
# env=((f311046 . -12) (f311040 . -8))
# expr=(begin (if ((primitive-ref port-unread) f311046) ((primitive-ref port-unread) f311046) (let ((f311049 (string-ref ((primitive-ref port-buf) f311046) ((primitive-ref port-ndx) f311046)))) (begin ((primitive-ref port-ndx-add1) f311046) f311049))))
# tail-begin (begin (if ((primitive-ref port-unread) f311046) ((primitive-ref port-unread) f311046) (let ((f311049 (string-ref ((primitive-ref port-buf) f311046) ((primitive-ref port-ndx) f311046)))) (begin ((primitive-ref port-ndx-add1) f311046) f311049))))
#   env=((f311046 . -12) (f311040 . -8))
# emit-tail-expr
# si=-16
# env=((f311046 . -12) (f311040 . -8))
# expr=(if ((primitive-ref port-unread) f311046) ((primitive-ref port-unread) f311046) (let ((f311049 (string-ref ((primitive-ref port-buf) f311046) ((primitive-ref port-ndx) f311046)))) (begin ((primitive-ref port-ndx-add1) f311046) f311049)))
# emit-expr ((primitive-ref port-unread) f311046)
=======
# env=((f259 . -12) (f253 . -8))
# expr=(begin (if ((primitive-ref port-unread) f259) ((primitive-ref port-unread) f259) (let ((f263 (string-ref ((primitive-ref port-buf) f259) ((primitive-ref port-ndx) f259)))) (begin ((primitive-ref port-ndx-add1) f259) f263))))
# tail-begin (begin (if ((primitive-ref port-unread) f259) ((primitive-ref port-unread) f259) (let ((f263 (string-ref ((primitive-ref port-buf) f259) ((primitive-ref port-ndx) f259)))) (begin ((primitive-ref port-ndx-add1) f259) f263))))
#   env=((f259 . -12) (f253 . -8))
# emit-tail-expr
# si=-16
# env=((f259 . -12) (f253 . -8))
# expr=(if ((primitive-ref port-unread) f259) ((primitive-ref port-unread) f259) (let ((f263 (string-ref ((primitive-ref port-buf) f259) ((primitive-ref port-ndx) f259)))) (begin ((primitive-ref port-ndx-add1) f259) f263)))
# emit-expr ((primitive-ref port-unread) f259)
>>>>>>> fix-implicit-begins
# funcall
#    si   =-16
#    env  = ((f259 . -12) (f253 . -8))
#    expr = (funcall (primitive-ref port-unread) f259)
# emit-expr (primitive-ref port-unread)
    .extern mrc_port$munread
    movl mrc_port$munread,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1598"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1598":
   movl %eax,  -24(%esp)  # stash funcall-oper in closure slot
# emit-expr f259
# emit-variable-ref
# env=((f259 . -12) (f253 . -8))
# var=f259
    movl -12(%esp), %eax  # stack load f259
# end emit-variable-ref
    mov %eax, -28(%esp)  # arg f259
    movl -24(%esp), %edi   # load new closure to %edi
    add $-16, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $16, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    cmp $47, %al
    je _L_1596
# emit-tail-expr
# si=-16
# env=((f259 . -12) (f253 . -8))
# expr=((primitive-ref port-unread) f259)
# emit-tail-funcall
#    si   =-16
#    env  = ((f259 . -12) (f253 . -8))
#    expr = (funcall (primitive-ref port-unread) f259)
# emit-expr (primitive-ref port-unread)
    .extern mrc_port$munread
    movl mrc_port$munread,%eax
   movl %eax,  -16(%esp)  # stash funcall-oper in next closure slot
# emit-expr f259
# emit-variable-ref
# env=((f259 . -12) (f253 . -8))
# var=f259
    movl -12(%esp), %eax  # stack load f259
# end emit-variable-ref
    mov %eax, -20(%esp)    # arg f259
    movl -16(%esp), %edi   # load new closure to %edi
# emit-shift-args:  size=2   si=-16  delta=12
    mov -16(%esp), %ebx  # shift frame cell
    mov %ebx, -4(%esp)  # down to base
# emit-shift-args:  size=1   si=-20  delta=12
    mov -20(%esp), %ebx  # shift frame cell
    mov %ebx, -8(%esp)  # down to base
# emit-shift-args:  size=0   si=-24  delta=12
    movl $4,%eax   # save arg count
    jmp *-2(%edi)  # tail-funcall
    jmp _L_1597
_L_1596:
# emit-tail-expr
# si=-16
<<<<<<< HEAD
# env=((f311046 . -12) (f311040 . -8))
# expr=(let ((f311049 (string-ref ((primitive-ref port-buf) f311046) ((primitive-ref port-ndx) f311046)))) (begin ((primitive-ref port-ndx-add1) f311046) f311049))
# emit-tail-let
#  si   = -16
#  env  = ((f311046 . -12) (f311040 . -8))
#  bindings = ((f311049 (string-ref ((primitive-ref port-buf) f311046) ((primitive-ref port-ndx) f311046))))
#  body = (begin ((primitive-ref port-ndx-add1) f311046) f311049)
# emit-expr (string-ref ((primitive-ref port-buf) f311046) ((primitive-ref port-ndx) f311046))
# emit-expr ((primitive-ref port-buf) f311046)
=======
# env=((f259 . -12) (f253 . -8))
# expr=(let ((f263 (string-ref ((primitive-ref port-buf) f259) ((primitive-ref port-ndx) f259)))) (begin ((primitive-ref port-ndx-add1) f259) f263))
# emit-tail-let
#  si   = -16
#  env  = ((f259 . -12) (f253 . -8))
#  bindings = ((f263 (string-ref ((primitive-ref port-buf) f259) ((primitive-ref port-ndx) f259))))
#  body = (begin ((primitive-ref port-ndx-add1) f259) f263)
# emit-expr (string-ref ((primitive-ref port-buf) f259) ((primitive-ref port-ndx) f259))
# emit-expr ((primitive-ref port-buf) f259)
>>>>>>> fix-implicit-begins
# funcall
#    si   =-16
#    env  = ((f259 . -12) (f253 . -8))
#    expr = (funcall (primitive-ref port-buf) f259)
# emit-expr (primitive-ref port-buf)
    .extern mrc_port$mbuf
    movl mrc_port$mbuf,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1599"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1599":
   movl %eax,  -24(%esp)  # stash funcall-oper in closure slot
# emit-expr f259
# emit-variable-ref
# env=((f259 . -12) (f253 . -8))
# var=f259
    movl -12(%esp), %eax  # stack load f259
# end emit-variable-ref
    mov %eax, -28(%esp)  # arg f259
    movl -24(%esp), %edi   # load new closure to %edi
    add $-16, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $16, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
# check the argument is a string
    movl %eax,%ebx
    and $7, %bl
    cmp $6, %bl
    je _L_1600
# invoke error handler eh_string
    .extern mrc_eh$ustring
    movl mrc_eh$ustring, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $164,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1600:
    movl %eax, -16(%esp)
# emit-expr ((primitive-ref port-ndx) f259)
# funcall
#    si   =-16
#    env  = ((f259 . -12) (f253 . -8))
#    expr = (funcall (primitive-ref port-ndx) f259)
# emit-expr (primitive-ref port-ndx)
    .extern mrc_port$mndx
    movl mrc_port$mndx,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1601"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1601":
   movl %eax,  -24(%esp)  # stash funcall-oper in closure slot
# emit-expr f259
# emit-variable-ref
# env=((f259 . -12) (f253 . -8))
# var=f259
    movl -12(%esp), %eax  # stack load f259
# end emit-variable-ref
    mov %eax, -28(%esp)  # arg f259
    movl -24(%esp), %edi   # load new closure to %edi
    add $-16, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $16, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1602"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $164,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1602:
# check bounds on string index
    movl -16(%esp), %ebx
    cmp  %eax,-6(%ebx) 
    jle _L_1604
    cmp  $0,%eax
    jge _L_1603
_L_1604:
# invoke error handler eh_string_index
    .extern mrc_eh$ustring$uindex
    movl mrc_eh$ustring$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $164,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1603:
    sar $2, %eax
    movl -16(%esp), %esi
    movl -2(%eax,%esi), %eax
    sal $8, %eax
    or  $15, %eax
    movl %eax, -16(%esp)  # stack save
# emit-tail-expr
# si=-20
<<<<<<< HEAD
# env=((f311049 . -16) (f311046 . -12) (f311040 . -8))
# expr=(begin ((primitive-ref port-ndx-add1) f311046) f311049)
# tail-begin (begin ((primitive-ref port-ndx-add1) f311046) f311049)
#   env=((f311049 . -16) (f311046 . -12) (f311040 . -8))
# emit-expr ((primitive-ref port-ndx-add1) f311046)
# funcall
#    si   =-20
#    env  = ((f311049 . -16) (f311046 . -12) (f311040 . -8))
#    expr = (funcall (primitive-ref port-ndx-add1) f311046)
=======
# env=((f263 . -16) (f259 . -12) (f253 . -8))
# expr=(begin ((primitive-ref port-ndx-add1) f259) f263)
# tail-begin (begin ((primitive-ref port-ndx-add1) f259) f263)
#   env=((f263 . -16) (f259 . -12) (f253 . -8))
# emit-expr ((primitive-ref port-ndx-add1) f259)
# funcall
#    si   =-20
#    env  = ((f263 . -16) (f259 . -12) (f253 . -8))
#    expr = (funcall (primitive-ref port-ndx-add1) f259)
>>>>>>> fix-implicit-begins
# emit-expr (primitive-ref port-ndx-add1)
    .extern mrc_port$mndx$madd1
    movl mrc_port$mndx$madd1,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1605"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1605":
   movl %eax,  -28(%esp)  # stash funcall-oper in closure slot
# emit-expr f259
# emit-variable-ref
<<<<<<< HEAD
# env=((f311049 . -16) (f311046 . -12) (f311040 . -8))
# var=f311046
    movl -12(%esp), %eax  # stack load f311046
=======
# env=((f263 . -16) (f259 . -12) (f253 . -8))
# var=f259
    movl -12(%esp), %eax  # stack load f259
>>>>>>> fix-implicit-begins
# end emit-variable-ref
    mov %eax, -32(%esp)  # arg f259
    movl -28(%esp), %edi   # load new closure to %edi
    add $-20, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $20, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
# emit-tail-expr
# si=-20
<<<<<<< HEAD
# env=((f311049 . -16) (f311046 . -12) (f311040 . -8))
# expr=(begin f311049)
# tail-begin (begin f311049)
#   env=((f311049 . -16) (f311046 . -12) (f311040 . -8))
# emit-tail-expr
# si=-20
# env=((f311049 . -16) (f311046 . -12) (f311040 . -8))
# expr=f311049
# emit-tail-variable-ref
# emit-variable-ref
# env=((f311049 . -16) (f311046 . -12) (f311040 . -8))
# var=f311049
    movl -16(%esp), %eax  # stack load f311049
=======
# env=((f263 . -16) (f259 . -12) (f253 . -8))
# expr=(begin f263)
# tail-begin (begin f263)
#   env=((f263 . -16) (f259 . -12) (f253 . -8))
# emit-tail-expr
# si=-20
# env=((f263 . -16) (f259 . -12) (f253 . -8))
# expr=f263
# emit-tail-variable-ref
# emit-variable-ref
# env=((f263 . -16) (f259 . -12) (f253 . -8))
# var=f263
    movl -16(%esp), %eax  # stack load f263
>>>>>>> fix-implicit-begins
# end emit-variable-ref
    ret
# end emit-tail-variable ref
     ret   # return thru stack
_L_1597:
     ret   # return thru stack
     ret   # return thru stack
_L_1582:
    .align 4,0x90
_L_1573:
     movl %eax, mrc_read$mchar
# == explicit-begins  ==>
# (lambda (p) (let ((nbytes (foreign-call "s_read" (port-fd p) (port-buf p) (port-size p)))) (begin (port-ndx-reset p) (port-last-set! p nbytes) (when (fxzero? nbytes) (port-unread-set! p (eof-object))))))
# == eliminate-let*  ==>
# (lambda (p) (let ((nbytes (foreign-call "s_read" (port-fd p) (port-buf p) (port-size p)))) (begin (port-ndx-reset p) (port-last-set! p nbytes) (when (fxzero? nbytes) (port-unread-set! p (eof-object))))))
# == uniquify-variables  ==>
# (lambda (f264) (let ((f266 (foreign-call "s_read" (port-fd f264) (port-buf f264) (port-size f264)))) (begin (port-ndx-reset f264) (port-last-set! f264 f266) (when (fxzero? f266) (port-unread-set! f264 (eof-object))))))
# == vectorize-letrec  ==>
# (lambda (f264) (let ((f266 (foreign-call "s_read" (port-fd f264) (port-buf f264) (port-size f264)))) (begin (port-ndx-reset f264) (port-last-set! f264 f266) (when (fxzero? f266) (port-unread-set! f264 (eof-object))))))
# == eliminate-set!  ==>
# (lambda (f264) (let ((f264 f264)) (let ((f266 (foreign-call "s_read" (port-fd f264) (port-buf f264) (port-size f264)))) (begin (port-ndx-reset f264) (port-last-set! f264 f266) (when (fxzero? f266) (port-unread-set! f264 (eof-object)))))))
# == close-free-variables  ==>
# (closure (f264) () (let ((f264 f264)) (let ((f266 (foreign-call "s_read" (port-fd f264) (port-buf f264) (port-size f264)))) (begin (port-ndx-reset f264) (port-last-set! f264 f266) (when (fxzero? f266) (port-unread-set! f264 (eof-object)))))))
# == eliminate-quote  ==>
# (closure (f264) () (let ((f264 f264)) (let ((f266 (foreign-call "s_read" (port-fd f264) (port-buf f264) (port-size f264)))) (begin (port-ndx-reset f264) (port-last-set! f264 f266) (when (fxzero? f266) (port-unread-set! f264 (eof-object)))))))
# == eliminate-when/unless  ==>
# (closure (f264) () (let ((f264 f264)) (let ((f266 (foreign-call "s_read" (port-fd f264) (port-buf f264) (port-size f264)))) (begin (port-ndx-reset f264) (port-last-set! f264 f266) (if (fxzero? f266) (begin (port-unread-set! f264 (eof-object))) #f)))))
# == eliminate-cond  ==>
# (closure (f264) () (let ((f264 f264)) (let ((f266 (foreign-call "s_read" (port-fd f264) (port-buf f264) (port-size f264)))) (begin (port-ndx-reset f264) (port-last-set! f264 f266) (if (fxzero? f266) (begin (port-unread-set! f264 (eof-object))) #f)))))
# == external-symbols  ==>
# (closure (f264) () (let ((f264 f264)) (let ((f266 (foreign-call "s_read" ((primitive-ref port-fd) f264) ((primitive-ref port-buf) f264) ((primitive-ref port-size) f264)))) (begin ((primitive-ref port-ndx-reset) f264) ((primitive-ref port-last-set!) f264 f266) (if (fxzero? f266) (begin ((primitive-ref port-unread-set!) f264 (eof-object))) #f)))))
# emit-expr (closure (f264) () (let ((f264 f264)) (let ((f266 (foreign-call "s_read" ((primitive-ref port-fd) f264) ((primitive-ref port-buf) f264) ((primitive-ref port-size) f264)))) (begin ((primitive-ref port-ndx-reset) f264) ((primitive-ref port-last-set!) f264 f266) (if (fxzero? f266) (begin ((primitive-ref port-unread-set!) f264 (eof-object))) #f)))))
# emit-closure
# si = 0
# env = ()
# expr = (closure (f264) () (let ((f264 f264)) (let ((f266 (foreign-call "s_read" ((primitive-ref port-fd) f264) ((primitive-ref port-buf) f264) ((primitive-ref port-size) f264)))) (begin ((primitive-ref port-ndx-reset) f264) ((primitive-ref port-last-set!) f264 f266) (if (fxzero? f266) (begin ((primitive-ref port-unread-set!) f264 (eof-object))) #f)))))
    movl $_L_1606, 0(%ebp)  # closure label
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $8, %ebp     # bump ebp
    jmp _L_1607            # jump around closure body
_L_1606:
# check argument count
    cmp $4,%eax
    je _L_1608
# invoke error handler eh_argcount
    .extern mrc_eh$uargcount
    movl mrc_eh$uargcount, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_1608:
# emit-tail-expr
# si=-12
# env=((f264 . -8))
# expr=(let ((f264 f264)) (let ((f266 (foreign-call "s_read" ((primitive-ref port-fd) f264) ((primitive-ref port-buf) f264) ((primitive-ref port-size) f264)))) (begin ((primitive-ref port-ndx-reset) f264) ((primitive-ref port-last-set!) f264 f266) (if (fxzero? f266) (begin ((primitive-ref port-unread-set!) f264 (eof-object))) #f))))
# emit-tail-let
#  si   = -12
#  env  = ((f264 . -8))
#  bindings = ((f264 f264))
#  body = (let ((f266 (foreign-call "s_read" ((primitive-ref port-fd) f264) ((primitive-ref port-buf) f264) ((primitive-ref port-size) f264)))) (begin ((primitive-ref port-ndx-reset) f264) ((primitive-ref port-last-set!) f264 f266) (if (fxzero? f266) (begin ((primitive-ref port-unread-set!) f264 (eof-object))) #f)))
# emit-expr f264
# emit-variable-ref
# env=((f264 . -8))
# var=f264
    movl -8(%esp), %eax  # stack load f264
# end emit-variable-ref
    movl %eax, -12(%esp)  # stack save
# emit-tail-expr
# si=-16
# env=((f264 . -12) (f264 . -8))
# expr=(let ((f266 (foreign-call "s_read" ((primitive-ref port-fd) f264) ((primitive-ref port-buf) f264) ((primitive-ref port-size) f264)))) (begin ((primitive-ref port-ndx-reset) f264) ((primitive-ref port-last-set!) f264 f266) (if (fxzero? f266) (begin ((primitive-ref port-unread-set!) f264 (eof-object))) #f)))
# emit-tail-let
#  si   = -16
#  env  = ((f264 . -12) (f264 . -8))
#  bindings = ((f266 (foreign-call "s_read" ((primitive-ref port-fd) f264) ((primitive-ref port-buf) f264) ((primitive-ref port-size) f264))))
#  body = (begin ((primitive-ref port-ndx-reset) f264) ((primitive-ref port-last-set!) f264 f266) (if (fxzero? f266) (begin ((primitive-ref port-unread-set!) f264 (eof-object))) #f))
# emit-expr (foreign-call "s_read" ((primitive-ref port-fd) f264) ((primitive-ref port-buf) f264) ((primitive-ref port-size) f264))
    movl %ecx,-16(%esp)
    movl %esp,-20(%esp)
# emit-expr ((primitive-ref port-size) f264)
# funcall
#    si   =-24
#    env  = ((f264 . -12) (f264 . -8))
#    expr = (funcall (primitive-ref port-size) f264)
# emit-expr (primitive-ref port-size)
    .extern mrc_port$msize
    movl mrc_port$msize,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1609"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1609":
   movl %eax,  -32(%esp)  # stash funcall-oper in closure slot
# emit-expr f264
# emit-variable-ref
# env=((f264 . -12) (f264 . -8))
# var=f264
    movl -12(%esp), %eax  # stack load f264
# end emit-variable-ref
    mov %eax, -36(%esp)  # arg f264
    movl -32(%esp), %edi   # load new closure to %edi
    add $-24, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $24, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    movl %eax, -24(%esp)
# emit-expr ((primitive-ref port-buf) f264)
# funcall
#    si   =-28
#    env  = ((f264 . -12) (f264 . -8))
#    expr = (funcall (primitive-ref port-buf) f264)
# emit-expr (primitive-ref port-buf)
    .extern mrc_port$mbuf
    movl mrc_port$mbuf,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1610"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1610":
   movl %eax,  -36(%esp)  # stash funcall-oper in closure slot
# emit-expr f264
# emit-variable-ref
# env=((f264 . -12) (f264 . -8))
# var=f264
    movl -12(%esp), %eax  # stack load f264
# end emit-variable-ref
    mov %eax, -40(%esp)  # arg f264
    movl -36(%esp), %edi   # load new closure to %edi
    add $-28, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $28, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    movl %eax, -28(%esp)
# emit-expr ((primitive-ref port-fd) f264)
# funcall
#    si   =-32
#    env  = ((f264 . -12) (f264 . -8))
#    expr = (funcall (primitive-ref port-fd) f264)
# emit-expr (primitive-ref port-fd)
    .extern mrc_port$mfd
    movl mrc_port$mfd,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1611"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1611":
   movl %eax,  -40(%esp)  # stash funcall-oper in closure slot
# emit-expr f264
# emit-variable-ref
# env=((f264 . -12) (f264 . -8))
# var=f264
    movl -12(%esp), %eax  # stack load f264
# end emit-variable-ref
    mov %eax, -44(%esp)  # arg f264
    movl -40(%esp), %edi   # load new closure to %edi
    add $-32, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $32, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    movl %eax, -32(%esp)
    leal -32(%esp),%edi
    movl %edi,%esi
    andl $-16,%esi
    movl 0(%edi),%eax
    movl %eax,0(%esi)
    movl 4(%edi),%eax
    movl %eax,4(%esi)
    movl 8(%edi),%eax
    movl %eax,8(%esi)
    movl 12(%edi),%eax
    movl %eax,12(%esi)
    movl %esi,%esp
    .extern _s_read
    call _s_read
    movl 12(%esi),%esp
    movl -16(%esp),%ecx
    movl %eax, -16(%esp)  # stack save
# emit-tail-expr
# si=-20
# env=((f266 . -16) (f264 . -12) (f264 . -8))
# expr=(begin ((primitive-ref port-ndx-reset) f264) ((primitive-ref port-last-set!) f264 f266) (if (fxzero? f266) (begin ((primitive-ref port-unread-set!) f264 (eof-object))) #f))
# tail-begin (begin ((primitive-ref port-ndx-reset) f264) ((primitive-ref port-last-set!) f264 f266) (if (fxzero? f266) (begin ((primitive-ref port-unread-set!) f264 (eof-object))) #f))
#   env=((f266 . -16) (f264 . -12) (f264 . -8))
# emit-expr ((primitive-ref port-ndx-reset) f264)
# funcall
#    si   =-20
#    env  = ((f266 . -16) (f264 . -12) (f264 . -8))
#    expr = (funcall (primitive-ref port-ndx-reset) f264)
# emit-expr (primitive-ref port-ndx-reset)
    .extern mrc_port$mndx$mreset
    movl mrc_port$mndx$mreset,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1612"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1612":
   movl %eax,  -28(%esp)  # stash funcall-oper in closure slot
# emit-expr f264
# emit-variable-ref
# env=((f266 . -16) (f264 . -12) (f264 . -8))
# var=f264
    movl -12(%esp), %eax  # stack load f264
# end emit-variable-ref
    mov %eax, -32(%esp)  # arg f264
    movl -28(%esp), %edi   # load new closure to %edi
    add $-20, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $20, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
# emit-tail-expr
# si=-20
# env=((f266 . -16) (f264 . -12) (f264 . -8))
# expr=(begin ((primitive-ref port-last-set!) f264 f266) (if (fxzero? f266) (begin ((primitive-ref port-unread-set!) f264 (eof-object))) #f))
# tail-begin (begin ((primitive-ref port-last-set!) f264 f266) (if (fxzero? f266) (begin ((primitive-ref port-unread-set!) f264 (eof-object))) #f))
#   env=((f266 . -16) (f264 . -12) (f264 . -8))
# emit-expr ((primitive-ref port-last-set!) f264 f266)
# funcall
#    si   =-20
#    env  = ((f266 . -16) (f264 . -12) (f264 . -8))
#    expr = (funcall (primitive-ref port-last-set!) f264 f266)
# emit-expr (primitive-ref port-last-set!)
    .extern mrc_port$mlast$mset$b
    movl mrc_port$mlast$mset$b,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1613"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1613":
   movl %eax,  -28(%esp)  # stash funcall-oper in closure slot
# emit-expr f264
# emit-variable-ref
# env=((f266 . -16) (f264 . -12) (f264 . -8))
# var=f264
    movl -12(%esp), %eax  # stack load f264
# end emit-variable-ref
    mov %eax, -32(%esp)  # arg f264
# emit-expr f266
# emit-variable-ref
# env=((f266 . -16) (f264 . -12) (f264 . -8))
# var=f266
    movl -16(%esp), %eax  # stack load f266
# end emit-variable-ref
    mov %eax, -36(%esp)  # arg f266
    movl -28(%esp), %edi   # load new closure to %edi
    add $-20, %esp   # adjust base
    movl $8,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $20, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
# emit-tail-expr
# si=-20
# env=((f266 . -16) (f264 . -12) (f264 . -8))
# expr=(begin (if (fxzero? f266) (begin ((primitive-ref port-unread-set!) f264 (eof-object))) #f))
# tail-begin (begin (if (fxzero? f266) (begin ((primitive-ref port-unread-set!) f264 (eof-object))) #f))
#   env=((f266 . -16) (f264 . -12) (f264 . -8))
# emit-tail-expr
# si=-20
# env=((f266 . -16) (f264 . -12) (f264 . -8))
# expr=(if (fxzero? f266) (begin ((primitive-ref port-unread-set!) f264 (eof-object))) #f)
# emit-expr (fxzero? f266)
# emit-expr f266
# emit-variable-ref
# env=((f266 . -16) (f264 . -12) (f264 . -8))
# var=f266
    movl -16(%esp), %eax  # stack load f266
# end emit-variable-ref
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1616"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $64,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1616:
    cmp $0, %eax
    sete %al
    movzbl %al, %eax
    sal $6, %al
    or $47, %al
    cmp $47, %al
    je _L_1614
# emit-tail-expr
# si=-20
# env=((f266 . -16) (f264 . -12) (f264 . -8))
# expr=(begin ((primitive-ref port-unread-set!) f264 (eof-object)))
# tail-begin (begin ((primitive-ref port-unread-set!) f264 (eof-object)))
#   env=((f266 . -16) (f264 . -12) (f264 . -8))
# emit-tail-expr
# si=-20
# env=((f266 . -16) (f264 . -12) (f264 . -8))
# expr=((primitive-ref port-unread-set!) f264 (eof-object))
# emit-tail-funcall
#    si   =-20
#    env  = ((f266 . -16) (f264 . -12) (f264 . -8))
#    expr = (funcall (primitive-ref port-unread-set!) f264 (eof-object))
# emit-expr (primitive-ref port-unread-set!)
    .extern mrc_port$munread$mset$b
    movl mrc_port$munread$mset$b,%eax
   movl %eax,  -20(%esp)  # stash funcall-oper in next closure slot
# emit-expr f264
# emit-variable-ref
# env=((f266 . -16) (f264 . -12) (f264 . -8))
# var=f264
    movl -12(%esp), %eax  # stack load f264
# end emit-variable-ref
    mov %eax, -24(%esp)    # arg f264
# emit-expr (eof-object)
    movl $95,%eax
    mov %eax, -28(%esp)    # arg (eof-object)
    movl -20(%esp), %edi   # load new closure to %edi
# emit-shift-args:  size=3   si=-20  delta=16
    mov -20(%esp), %ebx  # shift frame cell
    mov %ebx, -4(%esp)  # down to base
# emit-shift-args:  size=2   si=-24  delta=16
    mov -24(%esp), %ebx  # shift frame cell
    mov %ebx, -8(%esp)  # down to base
# emit-shift-args:  size=1   si=-28  delta=16
    mov -28(%esp), %ebx  # shift frame cell
    mov %ebx, -12(%esp)  # down to base
# emit-shift-args:  size=0   si=-32  delta=16
    movl $8,%eax   # save arg count
    jmp *-2(%edi)  # tail-funcall
     ret   # return thru stack
    jmp _L_1615
_L_1614:
# emit-tail-expr
# si=-20
# env=((f266 . -16) (f264 . -12) (f264 . -8))
# expr=#f
    movl $47, %eax     # immed #f
    ret                  # immediate tail return
_L_1615:
     ret   # return thru stack
    .align 4,0x90
_L_1607:
     movl %eax, mrc_fill$minput$mbuffer
# == explicit-begins  ==>
# (quote TBD)
# == eliminate-let*  ==>
# (quote TBD)
# == uniquify-variables  ==>
# (quote TBD)
# == vectorize-letrec  ==>
# (quote TBD)
# == eliminate-set!  ==>
# (quote TBD)
# == close-free-variables  ==>
# (quote TBD)
# == eliminate-quote  ==>
# (string->symbol "TBD")
# == eliminate-when/unless  ==>
# (string->symbol "TBD")
# == eliminate-cond  ==>
# (string->symbol "TBD")
# == external-symbols  ==>
# ((primitive-ref string->symbol) "TBD")
# emit-expr ((primitive-ref string->symbol) "TBD")
# funcall
#    si   =0
#    env  = ()
#    expr = (funcall (primitive-ref string->symbol) "TBD")
# emit-expr (primitive-ref string->symbol)
    .extern mrc_string$m$gsymbol
    movl mrc_string$m$gsymbol,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1617"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1617":
   movl %eax,  -8(%esp)  # stash funcall-oper in closure slot
# emit-expr "TBD"
# string literal
    jmp _L_1619
    .align 8,0x90
_L_1618 :
    .int 12
    .ascii "TBD"
_L_1619:
    movl $_L_1618, %eax
    orl $6, %eax
    mov %eax, -12(%esp)  # arg TBD
    movl -8(%esp), %edi   # load new closure to %edi
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    movl -4(%esp), %edi   # restore closure frame ptr
     movl %eax, mrc_unread$mchar
# emit-expr (begin #t)
# emit-begin
#   expr=(begin #t)
#   env=()
# emit-expr #t
    movl $111, %eax     # immed #t
# emit-expr (begin)
# emit-begin
#   expr=(begin)
#   env=()
    .extern base_init_callback
    jmp base_init_callback
