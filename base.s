     .data
     .global "mrc_symbols"
     .align 8
mrc_symbols:
     .int 0xFF
     .global "mrc_string$e$q"
     .align 8
mrc_string$e$q:
     .int 0xFF
     .global "mrc_string$m$gsymbol"
     .align 8
mrc_string$m$gsymbol:
     .int 0xFF
     .global "mrc_append1"
     .align 8
mrc_append1:
     .int 0xFF
     .global "mrc_list$mref"
     .align 8
mrc_list$mref:
     .int 0xFF
     .global "mrc_list$mlength"
     .align 8
mrc_list$mlength:
     .int 0xFF
     .global "mrc_reverse"
     .align 8
mrc_reverse:
     .int 0xFF
     .global "mrc_list"
     .align 8
mrc_list:
     .int 0xFF
     .global "mrc_vector"
     .align 8
mrc_vector:
     .int 0xFF
     .global "mrc_string"
     .align 8
mrc_string:
     .int 0xFF
     .global "mrc_string$m$glist"
     .align 8
mrc_string$m$glist:
     .int 0xFF
     .global "mrc_integer$m$glist"
     .align 8
mrc_integer$m$glist:
     .int 0xFF
     .global "mrc_error"
     .align 8
mrc_error:
     .int 0xFF
     .global "mrc_primitives"
     .align 8
mrc_primitives:
     .int 0xFF
     .global "mrc_eh$uprocedure"
     .align 8
mrc_eh$uprocedure:
     .int 0xFF
     .global "mrc_eh$uargcount"
     .align 8
mrc_eh$uargcount:
     .int 0xFF
     .global "mrc_eh$uargcount$umin"
     .align 8
mrc_eh$uargcount$umin:
     .int 0xFF
     .global "mrc_eh$ufixnum"
     .align 8
mrc_eh$ufixnum:
     .int 0xFF
     .global "mrc_eh$ustring"
     .align 8
mrc_eh$ustring:
     .int 0xFF
     .global "mrc_eh$ucharacter"
     .align 8
mrc_eh$ucharacter:
     .int 0xFF
     .global "mrc_eh$upair"
     .align 8
mrc_eh$upair:
     .int 0xFF
     .global "mrc_eh$uvector"
     .align 8
mrc_eh$uvector:
     .int 0xFF
     .global "mrc_eh$ulength"
     .align 8
mrc_eh$ulength:
     .int 0xFF
     .global "mrc_eh$uvector$uindex"
     .align 8
mrc_eh$uvector$uindex:
     .int 0xFF
     .global "mrc_eh$ustring$uindex"
     .align 8
mrc_eh$ustring$uindex:
     .int 0xFF
     .global "mrc_zero$q"
     .align 8
mrc_zero$q:
     .int 0xFF
     .global "mrc_positive$q"
     .align 8
mrc_positive$q:
     .int 0xFF
     .global "mrc_negative$q"
     .align 8
mrc_negative$q:
     .int 0xFF
     .global "mrc_even$q"
     .align 8
mrc_even$q:
     .int 0xFF
     .global "mrc_odd$q"
     .align 8
mrc_odd$q:
     .int 0xFF
     .global "mrc_map"
     .align 8
mrc_map:
     .int 0xFF
     .global "mrc_for$meach"
     .align 8
mrc_for$meach:
     .int 0xFF
     .global "mrc_standard$mout"
     .align 8
mrc_standard$mout:
     .int 0xFF
     .global "mrc_current$moutput$mport"
     .align 8
mrc_current$moutput$mport:
     .int 0xFF
     .global "mrc_current$minput$mport"
     .align 8
mrc_current$minput$mport:
     .int 0xFF
     .global "mrc_port$mkind"
     .align 8
mrc_port$mkind:
     .int 0xFF
     .global "mrc_port$mpath"
     .align 8
mrc_port$mpath:
     .int 0xFF
     .global "mrc_port$mfd"
     .align 8
mrc_port$mfd:
     .int 0xFF
     .global "mrc_port$mbuf"
     .align 8
mrc_port$mbuf:
     .int 0xFF
     .global "mrc_port$mndx"
     .align 8
mrc_port$mndx:
     .int 0xFF
     .global "mrc_port$mndx$madd1"
     .align 8
mrc_port$mndx$madd1:
     .int 0xFF
     .global "mrc_port$mndx$mreset"
     .align 8
mrc_port$mndx$mreset:
     .int 0xFF
     .global "mrc_port$msize"
     .align 8
mrc_port$msize:
     .int 0xFF
     .global "mrc_write$mchar"
     .align 8
mrc_write$mchar:
     .int 0xFF
     .global "mrc_flush$moutput$mport"
     .align 8
mrc_flush$moutput$mport:
     .int 0xFF
     .global "mrc_exit"
     .align 8
mrc_exit:
     .int 0xFF
     .global "mrc_open$moutput$mfile"
     .align 8
mrc_open$moutput$mfile:
     .int 0xFF
     .global "mrc_close$minput$mport"
     .align 8
mrc_close$minput$mport:
     .int 0xFF
     .global "mrc_close$moutput$mport"
     .align 8
mrc_close$moutput$mport:
     .int 0xFF
     .global "mrc_base$mwrite"
     .align 8
mrc_base$mwrite:
     .int 0xFF
     .global "mrc_write"
     .align 8
mrc_write:
     .int 0xFF
     .global "mrc_display"
     .align 8
mrc_display:
     .int 0xFF
     .global "mrc_integer$m$gchar"
     .align 8
mrc_integer$m$gchar:
     .int 0xFF
     .global "mrc_standard$min"
     .align 8
mrc_standard$min:
     .int 0xFF
     .global "mrc_port$munread"
     .align 8
mrc_port$munread:
     .int 0xFF
     .global "mrc_port$munread$mclear"
     .align 8
mrc_port$munread$mclear:
     .int 0xFF
     .global "mrc_port$munread$mset$b"
     .align 8
mrc_port$munread$mset$b:
     .int 0xFF
     .global "mrc_port$mlast"
     .align 8
mrc_port$mlast:
     .int 0xFF
     .global "mrc_port$mlast$mset$b"
     .align 8
mrc_port$mlast$mset$b:
     .int 0xFF
     .global "mrc_input$mport$q"
     .align 8
mrc_input$mport$q:
     .int 0xFF
     .global "mrc_output$mport$q"
     .align 8
mrc_output$mport$q:
     .int 0xFF
     .global "mrc_open$minput$mfile"
     .align 8
mrc_open$minput$mfile:
     .int 0xFF
     .global "mrc_read$mchar"
     .align 8
mrc_read$mchar:
     .int 0xFF
     .global "mrc_fill$minput$mbuffer"
     .align 8
mrc_fill$minput$mbuffer:
     .int 0xFF
     .global "mrc_unread$mchar"
     .align 8
mrc_unread$mchar:
     .int 0xFF
     .text
     .global base_init
     .align 4
base_init:
# == explicit-begins  ==>
# (let ((interned-symbols (cons (make-symbol "nil" ()) ()))) (lambda () interned-symbols))
# == elim-local-defines  ==>
# (let ((interned-symbols (cons (make-symbol "nil" ()) ()))) (lambda () interned-symbols))
# == eliminate-let*  ==>
# (let ((interned-symbols (cons (make-symbol "nil" ()) ()))) (lambda () interned-symbols))
# == uniquify-variables  ==>
# (let ((f0 (cons (make-symbol "nil" ()) ()))) (lambda () f0))
# == vectorize-letrec  ==>
# (let ((f0 (cons (make-symbol "nil" ()) ()))) (lambda () f0))
# == eliminate-set!  ==>
# (let ((f0 (cons (make-symbol "nil" ()) ()))) (lambda () (let () f0)))
# == close-free-variables  ==>
# (let ((f0 (cons (make-symbol "nil" ()) ()))) (closure () (f0) (let () f0)))
# == eliminate-quote  ==>
# (let ((f0 (cons (make-symbol "nil" ()) ()))) (closure () (f0) (let () f0)))
# == eliminate-when/unless  ==>
# (let ((f0 (cons (make-symbol "nil" ()) ()))) (closure () (f0) (let () f0)))
# == eliminate-cond  ==>
# (let ((f0 (cons (make-symbol "nil" ()) ()))) (closure () (f0) (let () f0)))
# == external-symbols  ==>
# (let ((f0 (cons (make-symbol "nil" ()) ()))) (closure () (f0) (let () f0)))
# emit-expr (let ((f0 (cons (make-symbol "nil" ()) ()))) (closure () (f0) (let () f0)))
# emit-let
#  si   = 0
#  env  = ()
#  bindings = ((f0 (cons (make-symbol "nil" ()) ())))
#  body = (closure () (f0) (let () f0))
# emit-expr (cons (make-symbol "nil" ()) ())
# cons arg1=(make-symbol "nil" ()) arg2=()
# emit-expr (make-symbol "nil" ())
# make-symbol arg1="nil" arg2=()
# emit-expr "nil"
# string literal
    jmp _L_1
    .align 8,0x90
_L_0 :
    .int 12
    .ascii "nil"
_L_1:
    movl $_L_0, %eax
    orl $6, %eax
    movl %eax, 0(%esp)
# emit-expr ()
    movl $63, %eax     # immed ()
    movl %eax, 4(%ebp)
    movl 0(%esp), %eax
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    orl  $3, %eax
    add  $8, %ebp
# make-symbol end
    movl %eax, 0(%esp)
# emit-expr ()
    movl $63, %eax     # immed ()
    movl %eax, 4(%ebp)
    movl 0(%esp), %eax
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    or   $1, %al
    add  $8, %ebp
# cons end
    movl %eax, 0(%esp)  # stack save
# emit-expr (closure () (f0) (let () f0))
# emit-closure
# si = -4
# env = ((f0 . 0))
# expr = (closure () (f0) (let () f0))
    movl $_L_2, 0(%ebp)  # closure label
# emit-variable-ref
# env=((f0 . 0))
# var=f0
    movl 0(%esp), %eax  # stack load f0
# end emit-variable-ref
   movl  %eax, 4(%ebp)  # f0
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $8, %ebp     # bump ebp
    jmp _L_3            # jump around closure body
_L_2:
# check argument count
    cmp $0,%eax
    je _L_4
# invoke error handler eh_argcount
    .extern mrc_eh$uargcount
    movl mrc_eh$uargcount, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_4:
# emit-tail-expr
# si=-8
# env=((f0 . 4) (f0 . 0))
# expr=(let () f0)
# emit-tail-let
#  si   = -8
#  env  = ((f0 . 4) (f0 . 0))
#  bindings = ()
#  body = f0
# emit-tail-expr
# si=-8
# env=((f0 . 4) (f0 . 0))
# expr=f0
# emit-tail-variable-ref
# emit-variable-ref
# env=((f0 . 4) (f0 . 0))
# var=f0
    movl 2(%edi), %eax  # frame load f0
# end emit-variable-ref
    ret
# end emit-tail-variable ref
    .align 4,0x90
_L_3:
     movl %eax, mrc_symbols
# == explicit-begins  ==>
# (letrec ((slen= (lambda (s1 s2) (fx= (string-length s1) (string-length s2)))) (si= (lambda (s1 s2 i) (char=? (string-ref s1 i) (string-ref s2 i)))) (si<n= (lambda (s1 s2 i n) (if (fx= i n) #t (if (si= s1 s2 i) (si<n= s1 s2 (fx+ i 1) n) #f)))) (ss= (lambda (s1 s2) (if (slen= s1 s2) (si<n= s1 s2 0 (string-length s1)) #f)))) ss=)
# == elim-local-defines  ==>
# (letrec ((slen= (lambda (s1 s2) (fx= (string-length s1) (string-length s2)))) (si= (lambda (s1 s2 i) (char=? (string-ref s1 i) (string-ref s2 i)))) (si<n= (lambda (s1 s2 i n) (if (fx= i n) #t (if (si= s1 s2 i) (si<n= s1 s2 (fx+ i 1) n) #f)))) (ss= (lambda (s1 s2) (if (slen= s1 s2) (si<n= s1 s2 0 (string-length s1)) #f)))) ss=)
# == eliminate-let*  ==>
# (letrec ((slen= (lambda (s1 s2) (fx= (string-length s1) (string-length s2)))) (si= (lambda (s1 s2 i) (char=? (string-ref s1 i) (string-ref s2 i)))) (si<n= (lambda (s1 s2 i n) (if (fx= i n) #t (if (si= s1 s2 i) (si<n= s1 s2 (fx+ i 1) n) #f)))) (ss= (lambda (s1 s2) (if (slen= s1 s2) (si<n= s1 s2 0 (string-length s1)) #f)))) ss=)
# == uniquify-variables  ==>
# (letrec ((f4 (lambda (f25 f26) (fx= (string-length f25) (string-length f26)))) (f3 (lambda (f22 f23 f24) (char=? (string-ref f22 f24) (string-ref f23 f24)))) (f2 (lambda (f18 f19 f20 f21) (if (fx= f20 f21) #t (if (f3 f18 f19 f20) (f2 f18 f19 (fx+ f20 1) f21) #f)))) (f1 (lambda (f16 f17) (if (f4 f16 f17) (f2 f16 f17 0 (string-length f16)) #f)))) f1)
# == vectorize-letrec  ==>
# (let ((f4 (make-vector 1)) (f3 (make-vector 1)) (f2 (make-vector 1)) (f1 (make-vector 1))) (begin (begin (vector-set! f4 0 (lambda (f25 f26) (fx= (string-length f25) (string-length f26)))) (vector-set! f3 0 (lambda (f22 f23 f24) (char=? (string-ref f22 f24) (string-ref f23 f24)))) (vector-set! f2 0 (lambda (f18 f19 f20 f21) (if (fx= f20 f21) #t (if ((vector-ref f3 0) f18 f19 f20) ((vector-ref f2 0) f18 f19 (fx+ f20 1) f21) #f)))) (vector-set! f1 0 (lambda (f16 f17) (if ((vector-ref f4 0) f16 f17) ((vector-ref f2 0) f16 f17 0 (string-length f16)) #f)))) (vector-ref f1 0)))
# == eliminate-set!  ==>
# (let ((f4 (make-vector 1)) (f3 (make-vector 1)) (f2 (make-vector 1)) (f1 (make-vector 1))) (begin (begin (vector-set! f4 0 (lambda (f25 f26) (let ((f25 f25) (f26 f26)) (fx= (string-length f25) (string-length f26))))) (vector-set! f3 0 (lambda (f22 f23 f24) (let ((f22 f22) (f23 f23) (f24 f24)) (char=? (string-ref f22 f24) (string-ref f23 f24))))) (vector-set! f2 0 (lambda (f18 f19 f20 f21) (let ((f18 f18) (f19 f19) (f20 f20) (f21 f21)) (if (fx= f20 f21) #t (if ((vector-ref f3 0) f18 f19 f20) ((vector-ref f2 0) f18 f19 (fx+ f20 1) f21) #f))))) (vector-set! f1 0 (lambda (f16 f17) (let ((f16 f16) (f17 f17)) (if ((vector-ref f4 0) f16 f17) ((vector-ref f2 0) f16 f17 0 (string-length f16)) #f))))) (vector-ref f1 0)))
# == close-free-variables  ==>
# (let ((f4 (make-vector 1)) (f3 (make-vector 1)) (f2 (make-vector 1)) (f1 (make-vector 1))) (begin (begin (vector-set! f4 0 (closure (f25 f26) () (let ((f25 f25) (f26 f26)) (fx= (string-length f25) (string-length f26))))) (vector-set! f3 0 (closure (f22 f23 f24) () (let ((f22 f22) (f23 f23) (f24 f24)) (char=? (string-ref f22 f24) (string-ref f23 f24))))) (vector-set! f2 0 (closure (f18 f19 f20 f21) (f3 f2) (let ((f18 f18) (f19 f19) (f20 f20) (f21 f21)) (if (fx= f20 f21) #t (if ((vector-ref f3 0) f18 f19 f20) ((vector-ref f2 0) f18 f19 (fx+ f20 1) f21) #f))))) (vector-set! f1 0 (closure (f16 f17) (f4 f2) (let ((f16 f16) (f17 f17)) (if ((vector-ref f4 0) f16 f17) ((vector-ref f2 0) f16 f17 0 (string-length f16)) #f))))) (vector-ref f1 0)))
# == eliminate-quote  ==>
# (let ((f4 (make-vector 1)) (f3 (make-vector 1)) (f2 (make-vector 1)) (f1 (make-vector 1))) (begin (begin (vector-set! f4 0 (closure (f25 f26) () (let ((f25 f25) (f26 f26)) (fx= (string-length f25) (string-length f26))))) (vector-set! f3 0 (closure (f22 f23 f24) () (let ((f22 f22) (f23 f23) (f24 f24)) (char=? (string-ref f22 f24) (string-ref f23 f24))))) (vector-set! f2 0 (closure (f18 f19 f20 f21) (f3 f2) (let ((f18 f18) (f19 f19) (f20 f20) (f21 f21)) (if (fx= f20 f21) #t (if ((vector-ref f3 0) f18 f19 f20) ((vector-ref f2 0) f18 f19 (fx+ f20 1) f21) #f))))) (vector-set! f1 0 (closure (f16 f17) (f4 f2) (let ((f16 f16) (f17 f17)) (if ((vector-ref f4 0) f16 f17) ((vector-ref f2 0) f16 f17 0 (string-length f16)) #f))))) (vector-ref f1 0)))
# == eliminate-when/unless  ==>
# (let ((f4 (make-vector 1)) (f3 (make-vector 1)) (f2 (make-vector 1)) (f1 (make-vector 1))) (begin (begin (vector-set! f4 0 (closure (f25 f26) () (let ((f25 f25) (f26 f26)) (fx= (string-length f25) (string-length f26))))) (vector-set! f3 0 (closure (f22 f23 f24) () (let ((f22 f22) (f23 f23) (f24 f24)) (char=? (string-ref f22 f24) (string-ref f23 f24))))) (vector-set! f2 0 (closure (f18 f19 f20 f21) (f3 f2) (let ((f18 f18) (f19 f19) (f20 f20) (f21 f21)) (if (fx= f20 f21) #t (if ((vector-ref f3 0) f18 f19 f20) ((vector-ref f2 0) f18 f19 (fx+ f20 1) f21) #f))))) (vector-set! f1 0 (closure (f16 f17) (f4 f2) (let ((f16 f16) (f17 f17)) (if ((vector-ref f4 0) f16 f17) ((vector-ref f2 0) f16 f17 0 (string-length f16)) #f))))) (vector-ref f1 0)))
# == eliminate-cond  ==>
# (let ((f4 (make-vector 1)) (f3 (make-vector 1)) (f2 (make-vector 1)) (f1 (make-vector 1))) (begin (begin (vector-set! f4 0 (closure (f25 f26) () (let ((f25 f25) (f26 f26)) (fx= (string-length f25) (string-length f26))))) (vector-set! f3 0 (closure (f22 f23 f24) () (let ((f22 f22) (f23 f23) (f24 f24)) (char=? (string-ref f22 f24) (string-ref f23 f24))))) (vector-set! f2 0 (closure (f18 f19 f20 f21) (f3 f2) (let ((f18 f18) (f19 f19) (f20 f20) (f21 f21)) (if (fx= f20 f21) #t (if ((vector-ref f3 0) f18 f19 f20) ((vector-ref f2 0) f18 f19 (fx+ f20 1) f21) #f))))) (vector-set! f1 0 (closure (f16 f17) (f4 f2) (let ((f16 f16) (f17 f17)) (if ((vector-ref f4 0) f16 f17) ((vector-ref f2 0) f16 f17 0 (string-length f16)) #f))))) (vector-ref f1 0)))
# == external-symbols  ==>
# (let ((f4 (make-vector 1)) (f3 (make-vector 1)) (f2 (make-vector 1)) (f1 (make-vector 1))) (begin (begin (vector-set! f4 0 (closure (f25 f26) () (let ((f25 f25) (f26 f26)) (fx= (string-length f25) (string-length f26))))) (vector-set! f3 0 (closure (f22 f23 f24) () (let ((f22 f22) (f23 f23) (f24 f24)) (char=? (string-ref f22 f24) (string-ref f23 f24))))) (vector-set! f2 0 (closure (f18 f19 f20 f21) (f3 f2) (let ((f18 f18) (f19 f19) (f20 f20) (f21 f21)) (if (fx= f20 f21) #t (if ((vector-ref f3 0) f18 f19 f20) ((vector-ref f2 0) f18 f19 (fx+ f20 1) f21) #f))))) (vector-set! f1 0 (closure (f16 f17) (f4 f2) (let ((f16 f16) (f17 f17)) (if ((vector-ref f4 0) f16 f17) ((vector-ref f2 0) f16 f17 0 (string-length f16)) #f))))) (vector-ref f1 0)))
# emit-expr (let ((f4 (make-vector 1)) (f3 (make-vector 1)) (f2 (make-vector 1)) (f1 (make-vector 1))) (begin (begin (vector-set! f4 0 (closure (f25 f26) () (let ((f25 f25) (f26 f26)) (fx= (string-length f25) (string-length f26))))) (vector-set! f3 0 (closure (f22 f23 f24) () (let ((f22 f22) (f23 f23) (f24 f24)) (char=? (string-ref f22 f24) (string-ref f23 f24))))) (vector-set! f2 0 (closure (f18 f19 f20 f21) (f3 f2) (let ((f18 f18) (f19 f19) (f20 f20) (f21 f21)) (if (fx= f20 f21) #t (if ((vector-ref f3 0) f18 f19 f20) ((vector-ref f2 0) f18 f19 (fx+ f20 1) f21) #f))))) (vector-set! f1 0 (closure (f16 f17) (f4 f2) (let ((f16 f16) (f17 f17)) (if ((vector-ref f4 0) f16 f17) ((vector-ref f2 0) f16 f17 0 (string-length f16)) #f))))) (vector-ref f1 0)))
# emit-let
#  si   = 0
#  env  = ()
#  bindings = ((f4 (make-vector 1)) (f3 (make-vector 1)) (f2 (make-vector 1)) (f1 (make-vector 1)))
#  body = (begin (begin (vector-set! f4 0 (closure (f25 f26) () (let ((f25 f25) (f26 f26)) (fx= (string-length f25) (string-length f26))))) (vector-set! f3 0 (closure (f22 f23 f24) () (let ((f22 f22) (f23 f23) (f24 f24)) (char=? (string-ref f22 f24) (string-ref f23 f24))))) (vector-set! f2 0 (closure (f18 f19 f20 f21) (f3 f2) (let ((f18 f18) (f19 f19) (f20 f20) (f21 f21)) (if (fx= f20 f21) #t (if ((vector-ref f3 0) f18 f19 f20) ((vector-ref f2 0) f18 f19 (fx+ f20 1) f21) #f))))) (vector-set! f1 0 (closure (f16 f17) (f4 f2) (let ((f16 f16) (f17 f17)) (if ((vector-ref f4 0) f16 f17) ((vector-ref f2 0) f16 f17 0 (string-length f16)) #f))))) (vector-ref f1 0))
# emit-expr (make-vector 1)
# make-vector 1
# emit-expr 1
    movl $4, %eax     # immed 1
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_5"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
"_L_5":
# check the argument is a fixnum >= 0
    cmp $0,%eax
    jge _L_6
# invoke error handler eh_length
    .extern mrc_eh$ulength
    movl mrc_eh$ulength, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_6:
    movl %eax, %esi
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    orl  $5, %eax
    addl $4, %esi
    addl $4, %esi
    andl $-8, %esi
    addl %esi, %ebp
    movl %eax, 0(%esp)  # stack save
# emit-expr (make-vector 1)
# make-vector 1
# emit-expr 1
    movl $4, %eax     # immed 1
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_7"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
"_L_7":
# check the argument is a fixnum >= 0
    cmp $0,%eax
    jge _L_8
# invoke error handler eh_length
    .extern mrc_eh$ulength
    movl mrc_eh$ulength, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_8:
    movl %eax, %esi
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    orl  $5, %eax
    addl $4, %esi
    addl $4, %esi
    andl $-8, %esi
    addl %esi, %ebp
    movl %eax, -4(%esp)  # stack save
# emit-expr (make-vector 1)
# make-vector 1
# emit-expr 1
    movl $4, %eax     # immed 1
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_9"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
"_L_9":
# check the argument is a fixnum >= 0
    cmp $0,%eax
    jge _L_10
# invoke error handler eh_length
    .extern mrc_eh$ulength
    movl mrc_eh$ulength, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_10:
    movl %eax, %esi
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    orl  $5, %eax
    addl $4, %esi
    addl $4, %esi
    andl $-8, %esi
    addl %esi, %ebp
    movl %eax, -8(%esp)  # stack save
# emit-expr (make-vector 1)
# make-vector 1
# emit-expr 1
    movl $4, %eax     # immed 1
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_11"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
"_L_11":
# check the argument is a fixnum >= 0
    cmp $0,%eax
    jge _L_12
# invoke error handler eh_length
    .extern mrc_eh$ulength
    movl mrc_eh$ulength, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_12:
    movl %eax, %esi
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    orl  $5, %eax
    addl $4, %esi
    addl $4, %esi
    andl $-8, %esi
    addl %esi, %ebp
    movl %eax, -12(%esp)  # stack save
# emit-expr (begin (begin (vector-set! f4 0 (closure (f25 f26) () (let ((f25 f25) (f26 f26)) (fx= (string-length f25) (string-length f26))))) (vector-set! f3 0 (closure (f22 f23 f24) () (let ((f22 f22) (f23 f23) (f24 f24)) (char=? (string-ref f22 f24) (string-ref f23 f24))))) (vector-set! f2 0 (closure (f18 f19 f20 f21) (f3 f2) (let ((f18 f18) (f19 f19) (f20 f20) (f21 f21)) (if (fx= f20 f21) #t (if ((vector-ref f3 0) f18 f19 f20) ((vector-ref f2 0) f18 f19 (fx+ f20 1) f21) #f))))) (vector-set! f1 0 (closure (f16 f17) (f4 f2) (let ((f16 f16) (f17 f17)) (if ((vector-ref f4 0) f16 f17) ((vector-ref f2 0) f16 f17 0 (string-length f16)) #f))))) (vector-ref f1 0))
# emit-begin
#   expr=(begin (begin (vector-set! f4 0 (closure (f25 f26) () (let ((f25 f25) (f26 f26)) (fx= (string-length f25) (string-length f26))))) (vector-set! f3 0 (closure (f22 f23 f24) () (let ((f22 f22) (f23 f23) (f24 f24)) (char=? (string-ref f22 f24) (string-ref f23 f24))))) (vector-set! f2 0 (closure (f18 f19 f20 f21) (f3 f2) (let ((f18 f18) (f19 f19) (f20 f20) (f21 f21)) (if (fx= f20 f21) #t (if ((vector-ref f3 0) f18 f19 f20) ((vector-ref f2 0) f18 f19 (fx+ f20 1) f21) #f))))) (vector-set! f1 0 (closure (f16 f17) (f4 f2) (let ((f16 f16) (f17 f17)) (if ((vector-ref f4 0) f16 f17) ((vector-ref f2 0) f16 f17 0 (string-length f16)) #f))))) (vector-ref f1 0))
#   env=((f1 . -12) (f2 . -8) (f3 . -4) (f4 . 0))
# emit-expr (begin (vector-set! f4 0 (closure (f25 f26) () (let ((f25 f25) (f26 f26)) (fx= (string-length f25) (string-length f26))))) (vector-set! f3 0 (closure (f22 f23 f24) () (let ((f22 f22) (f23 f23) (f24 f24)) (char=? (string-ref f22 f24) (string-ref f23 f24))))) (vector-set! f2 0 (closure (f18 f19 f20 f21) (f3 f2) (let ((f18 f18) (f19 f19) (f20 f20) (f21 f21)) (if (fx= f20 f21) #t (if ((vector-ref f3 0) f18 f19 f20) ((vector-ref f2 0) f18 f19 (fx+ f20 1) f21) #f))))) (vector-set! f1 0 (closure (f16 f17) (f4 f2) (let ((f16 f16) (f17 f17)) (if ((vector-ref f4 0) f16 f17) ((vector-ref f2 0) f16 f17 0 (string-length f16)) #f)))))
# emit-begin
#   expr=(begin (vector-set! f4 0 (closure (f25 f26) () (let ((f25 f25) (f26 f26)) (fx= (string-length f25) (string-length f26))))) (vector-set! f3 0 (closure (f22 f23 f24) () (let ((f22 f22) (f23 f23) (f24 f24)) (char=? (string-ref f22 f24) (string-ref f23 f24))))) (vector-set! f2 0 (closure (f18 f19 f20 f21) (f3 f2) (let ((f18 f18) (f19 f19) (f20 f20) (f21 f21)) (if (fx= f20 f21) #t (if ((vector-ref f3 0) f18 f19 f20) ((vector-ref f2 0) f18 f19 (fx+ f20 1) f21) #f))))) (vector-set! f1 0 (closure (f16 f17) (f4 f2) (let ((f16 f16) (f17 f17)) (if ((vector-ref f4 0) f16 f17) ((vector-ref f2 0) f16 f17 0 (string-length f16)) #f)))))
#   env=((f1 . -12) (f2 . -8) (f3 . -4) (f4 . 0))
# emit-expr (vector-set! f4 0 (closure (f25 f26) () (let ((f25 f25) (f26 f26)) (fx= (string-length f25) (string-length f26)))))
# emit-expr f4
# emit-variable-ref
# env=((f1 . -12) (f2 . -8) (f3 . -4) (f4 . 0))
# var=f4
    movl 0(%esp), %eax  # stack load f4
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_13
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_13:
    movl %eax, -16(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_14"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
"_L_14":
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_16
    cmp  $0,%eax
    jge _L_15
_L_16:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_15:
    movl %eax, -20(%esp)
# emit-expr (closure (f25 f26) () (let ((f25 f25) (f26 f26)) (fx= (string-length f25) (string-length f26))))
# emit-closure
# si = -24
# env = ((f1 . -12) (f2 . -8) (f3 . -4) (f4 . 0))
# expr = (closure (f25 f26) () (let ((f25 f25) (f26 f26)) (fx= (string-length f25) (string-length f26))))
    movl $_L_17, 0(%ebp)  # closure label
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $8, %ebp     # bump ebp
    jmp _L_18            # jump around closure body
_L_17:
# check argument count
    cmp $8,%eax
    je _L_19
# invoke error handler eh_argcount
    .extern mrc_eh$uargcount
    movl mrc_eh$uargcount, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_19:
# emit-tail-expr
# si=-16
# env=((f26 . -12) (f25 . -8) (f1 . -12) (f2 . -8) (f3 . -4) (f4 . 0))
# expr=(let ((f25 f25) (f26 f26)) (fx= (string-length f25) (string-length f26)))
# emit-tail-let
#  si   = -16
#  env  = ((f26 . -12) (f25 . -8) (f1 . -12) (f2 . -8) (f3 . -4) (f4 . 0))
#  bindings = ((f25 f25) (f26 f26))
#  body = (fx= (string-length f25) (string-length f26))
# emit-expr f25
# emit-variable-ref
# env=((f26 . -12) (f25 . -8) (f1 . -12) (f2 . -8) (f3 . -4) (f4 . 0))
# var=f25
    movl -8(%esp), %eax  # stack load f25
# end emit-variable-ref
    movl %eax, -16(%esp)  # stack save
# emit-expr f26
# emit-variable-ref
# env=((f26 . -12) (f25 . -8) (f1 . -12) (f2 . -8) (f3 . -4) (f4 . 0))
# var=f26
    movl -12(%esp), %eax  # stack load f26
# end emit-variable-ref
    movl %eax, -20(%esp)  # stack save
# emit-tail-expr
# si=-24
# env=((f26 . -20) (f25 . -16) (f26 . -12) (f25 . -8) (f1 . -12) (f2 . -8) (f3 . -4) (f4 . 0))
# expr=(fx= (string-length f25) (string-length f26))
# tail primcall
# emit-expr (string-length f26)
# emit-expr f26
# emit-variable-ref
# env=((f26 . -20) (f25 . -16) (f26 . -12) (f25 . -8) (f1 . -12) (f2 . -8) (f3 . -4) (f4 . 0))
# var=f26
    movl -20(%esp), %eax  # stack load f26
# end emit-variable-ref
# check the argument is a string
    movl %eax,%ebx
    and $7, %bl
    cmp $6, %bl
    je _L_20
# invoke error handler eh_string
    .extern mrc_eh$ustring
    movl mrc_eh$ustring, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $160,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_20:
    movl -6(%eax), %eax
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_21"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $68,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
"_L_21":
    movl %eax, -24(%esp)
# emit-expr (string-length f25)
# emit-expr f25
# emit-variable-ref
# env=((f26 . -20) (f25 . -16) (f26 . -12) (f25 . -8) (f1 . -12) (f2 . -8) (f3 . -4) (f4 . 0))
# var=f25
    movl -16(%esp), %eax  # stack load f25
# end emit-variable-ref
# check the argument is a string
    movl %eax,%ebx
    and $7, %bl
    cmp $6, %bl
    je _L_22
# invoke error handler eh_string
    .extern mrc_eh$ustring
    movl mrc_eh$ustring, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $160,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_22:
    movl -6(%eax), %eax
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_23"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $68,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
"_L_23":
    cmp -24(%esp), %eax
    sete %al
    movzbl %al, %eax
    sal $6, %al
    or $47, %al
#return from tail (fx= (string-length f25) (string-length f26))
    ret
    .align 4,0x90
_L_18:
    movl -16(%esp), %ebx
    movl -20(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin (vector-set! f3 0 (closure (f22 f23 f24) () (let ((f22 f22) (f23 f23) (f24 f24)) (char=? (string-ref f22 f24) (string-ref f23 f24))))) (vector-set! f2 0 (closure (f18 f19 f20 f21) (f3 f2) (let ((f18 f18) (f19 f19) (f20 f20) (f21 f21)) (if (fx= f20 f21) #t (if ((vector-ref f3 0) f18 f19 f20) ((vector-ref f2 0) f18 f19 (fx+ f20 1) f21) #f))))) (vector-set! f1 0 (closure (f16 f17) (f4 f2) (let ((f16 f16) (f17 f17)) (if ((vector-ref f4 0) f16 f17) ((vector-ref f2 0) f16 f17 0 (string-length f16)) #f)))))
# emit-begin
#   expr=(begin (vector-set! f3 0 (closure (f22 f23 f24) () (let ((f22 f22) (f23 f23) (f24 f24)) (char=? (string-ref f22 f24) (string-ref f23 f24))))) (vector-set! f2 0 (closure (f18 f19 f20 f21) (f3 f2) (let ((f18 f18) (f19 f19) (f20 f20) (f21 f21)) (if (fx= f20 f21) #t (if ((vector-ref f3 0) f18 f19 f20) ((vector-ref f2 0) f18 f19 (fx+ f20 1) f21) #f))))) (vector-set! f1 0 (closure (f16 f17) (f4 f2) (let ((f16 f16) (f17 f17)) (if ((vector-ref f4 0) f16 f17) ((vector-ref f2 0) f16 f17 0 (string-length f16)) #f)))))
#   env=((f1 . -12) (f2 . -8) (f3 . -4) (f4 . 0))
# emit-expr (vector-set! f3 0 (closure (f22 f23 f24) () (let ((f22 f22) (f23 f23) (f24 f24)) (char=? (string-ref f22 f24) (string-ref f23 f24)))))
# emit-expr f3
# emit-variable-ref
# env=((f1 . -12) (f2 . -8) (f3 . -4) (f4 . 0))
# var=f3
    movl -4(%esp), %eax  # stack load f3
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_24
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_24:
    movl %eax, -16(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_25"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
"_L_25":
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_27
    cmp  $0,%eax
    jge _L_26
_L_27:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_26:
    movl %eax, -20(%esp)
# emit-expr (closure (f22 f23 f24) () (let ((f22 f22) (f23 f23) (f24 f24)) (char=? (string-ref f22 f24) (string-ref f23 f24))))
# emit-closure
# si = -24
# env = ((f1 . -12) (f2 . -8) (f3 . -4) (f4 . 0))
# expr = (closure (f22 f23 f24) () (let ((f22 f22) (f23 f23) (f24 f24)) (char=? (string-ref f22 f24) (string-ref f23 f24))))
    movl $_L_28, 0(%ebp)  # closure label
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $8, %ebp     # bump ebp
    jmp _L_29            # jump around closure body
_L_28:
# check argument count
    cmp $12,%eax
    je _L_30
# invoke error handler eh_argcount
    .extern mrc_eh$uargcount
    movl mrc_eh$uargcount, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_30:
# emit-tail-expr
# si=-20
# env=((f24 . -16) (f23 . -12) (f22 . -8) (f1 . -12) (f2 . -8) (f3 . -4) (f4 . 0))
# expr=(let ((f22 f22) (f23 f23) (f24 f24)) (char=? (string-ref f22 f24) (string-ref f23 f24)))
# emit-tail-let
#  si   = -20
#  env  = ((f24 . -16) (f23 . -12) (f22 . -8) (f1 . -12) (f2 . -8) (f3 . -4) (f4 . 0))
#  bindings = ((f22 f22) (f23 f23) (f24 f24))
#  body = (char=? (string-ref f22 f24) (string-ref f23 f24))
# emit-expr f22
# emit-variable-ref
# env=((f24 . -16) (f23 . -12) (f22 . -8) (f1 . -12) (f2 . -8) (f3 . -4) (f4 . 0))
# var=f22
    movl -8(%esp), %eax  # stack load f22
# end emit-variable-ref
    movl %eax, -20(%esp)  # stack save
# emit-expr f23
# emit-variable-ref
# env=((f24 . -16) (f23 . -12) (f22 . -8) (f1 . -12) (f2 . -8) (f3 . -4) (f4 . 0))
# var=f23
    movl -12(%esp), %eax  # stack load f23
# end emit-variable-ref
    movl %eax, -24(%esp)  # stack save
# emit-expr f24
# emit-variable-ref
# env=((f24 . -16) (f23 . -12) (f22 . -8) (f1 . -12) (f2 . -8) (f3 . -4) (f4 . 0))
# var=f24
    movl -16(%esp), %eax  # stack load f24
# end emit-variable-ref
    movl %eax, -28(%esp)  # stack save
# emit-tail-expr
# si=-32
# env=((f24 . -28) (f23 . -24) (f22 . -20) (f24 . -16) (f23 . -12) (f22 . -8) (f1 . -12) (f2 . -8) (f3 . -4) (f4 . 0))
# expr=(char=? (string-ref f22 f24) (string-ref f23 f24))
# tail primcall
# char= c1=(string-ref f22 f24) c2=(string-ref f23 f24)
# emit-expr (string-ref f22 f24)
# emit-expr f22
# emit-variable-ref
# env=((f24 . -28) (f23 . -24) (f22 . -20) (f24 . -16) (f23 . -12) (f22 . -8) (f1 . -12) (f2 . -8) (f3 . -4) (f4 . 0))
# var=f22
    movl -20(%esp), %eax  # stack load f22
# end emit-variable-ref
# check the argument is a string
    movl %eax,%ebx
    and $7, %bl
    cmp $6, %bl
    je _L_31
# invoke error handler eh_string
    .extern mrc_eh$ustring
    movl mrc_eh$ustring, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $164,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_31:
    movl %eax, -32(%esp)
# emit-expr f24
# emit-variable-ref
# env=((f24 . -28) (f23 . -24) (f22 . -20) (f24 . -16) (f23 . -12) (f22 . -8) (f1 . -12) (f2 . -8) (f3 . -4) (f4 . 0))
# var=f24
    movl -28(%esp), %eax  # stack load f24
# end emit-variable-ref
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_32"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $164,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
"_L_32":
# check bounds on string index
    movl -32(%esp), %ebx
    cmp  %eax,-6(%ebx) 
    jle _L_34
    cmp  $0,%eax
    jge _L_33
_L_34:
# invoke error handler eh_string_index
    .extern mrc_eh$ustring$uindex
    movl mrc_eh$ustring$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $164,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_33:
    sar $2, %eax
    movl -32(%esp), %esi
    movl -2(%eax,%esi), %eax
    sal $8, %eax
    or  $15, %eax
# check the argument is a char
    movl %eax,%ebx
    and $255, %bl
    cmp $15, %bl
    je "_L_35"
# invoke error handler eh_character
    .extern mrc_eh$ucharacter
    movl mrc_eh$ucharacter, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $40,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
"_L_35":
    movb %ah, -32(%esp)
# emit-expr (string-ref f23 f24)
# emit-expr f23
# emit-variable-ref
# env=((f24 . -28) (f23 . -24) (f22 . -20) (f24 . -16) (f23 . -12) (f22 . -8) (f1 . -12) (f2 . -8) (f3 . -4) (f4 . 0))
# var=f23
    movl -24(%esp), %eax  # stack load f23
# end emit-variable-ref
# check the argument is a string
    movl %eax,%ebx
    and $7, %bl
    cmp $6, %bl
    je _L_36
# invoke error handler eh_string
    .extern mrc_eh$ustring
    movl mrc_eh$ustring, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $164,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_36:
    movl %eax, -36(%esp)
# emit-expr f24
# emit-variable-ref
# env=((f24 . -28) (f23 . -24) (f22 . -20) (f24 . -16) (f23 . -12) (f22 . -8) (f1 . -12) (f2 . -8) (f3 . -4) (f4 . 0))
# var=f24
    movl -28(%esp), %eax  # stack load f24
# end emit-variable-ref
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_37"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $164,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
"_L_37":
# check bounds on string index
    movl -36(%esp), %ebx
    cmp  %eax,-6(%ebx) 
    jle _L_39
    cmp  $0,%eax
    jge _L_38
_L_39:
# invoke error handler eh_string_index
    .extern mrc_eh$ustring$uindex
    movl mrc_eh$ustring$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $164,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_38:
    sar $2, %eax
    movl -36(%esp), %esi
    movl -2(%eax,%esi), %eax
    sal $8, %eax
    or  $15, %eax
# check the argument is a char
    movl %eax,%ebx
    and $255, %bl
    cmp $15, %bl
    je "_L_40"
# invoke error handler eh_character
    .extern mrc_eh$ucharacter
    movl mrc_eh$ucharacter, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $40,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
"_L_40":
    cmp %ah, -32(%esp)
    sete %al
    movzbl %al, %eax
    sal $6, %al
    or $47, %al
#return from tail (char=? (string-ref f22 f24) (string-ref f23 f24))
    ret
    .align 4,0x90
_L_29:
    movl -16(%esp), %ebx
    movl -20(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin (vector-set! f2 0 (closure (f18 f19 f20 f21) (f3 f2) (let ((f18 f18) (f19 f19) (f20 f20) (f21 f21)) (if (fx= f20 f21) #t (if ((vector-ref f3 0) f18 f19 f20) ((vector-ref f2 0) f18 f19 (fx+ f20 1) f21) #f))))) (vector-set! f1 0 (closure (f16 f17) (f4 f2) (let ((f16 f16) (f17 f17)) (if ((vector-ref f4 0) f16 f17) ((vector-ref f2 0) f16 f17 0 (string-length f16)) #f)))))
# emit-begin
#   expr=(begin (vector-set! f2 0 (closure (f18 f19 f20 f21) (f3 f2) (let ((f18 f18) (f19 f19) (f20 f20) (f21 f21)) (if (fx= f20 f21) #t (if ((vector-ref f3 0) f18 f19 f20) ((vector-ref f2 0) f18 f19 (fx+ f20 1) f21) #f))))) (vector-set! f1 0 (closure (f16 f17) (f4 f2) (let ((f16 f16) (f17 f17)) (if ((vector-ref f4 0) f16 f17) ((vector-ref f2 0) f16 f17 0 (string-length f16)) #f)))))
#   env=((f1 . -12) (f2 . -8) (f3 . -4) (f4 . 0))
# emit-expr (vector-set! f2 0 (closure (f18 f19 f20 f21) (f3 f2) (let ((f18 f18) (f19 f19) (f20 f20) (f21 f21)) (if (fx= f20 f21) #t (if ((vector-ref f3 0) f18 f19 f20) ((vector-ref f2 0) f18 f19 (fx+ f20 1) f21) #f)))))
# emit-expr f2
# emit-variable-ref
# env=((f1 . -12) (f2 . -8) (f3 . -4) (f4 . 0))
# var=f2
    movl -8(%esp), %eax  # stack load f2
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_41
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_41:
    movl %eax, -16(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_42"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
"_L_42":
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_44
    cmp  $0,%eax
    jge _L_43
_L_44:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_43:
    movl %eax, -20(%esp)
# emit-expr (closure (f18 f19 f20 f21) (f3 f2) (let ((f18 f18) (f19 f19) (f20 f20) (f21 f21)) (if (fx= f20 f21) #t (if ((vector-ref f3 0) f18 f19 f20) ((vector-ref f2 0) f18 f19 (fx+ f20 1) f21) #f))))
# emit-closure
# si = -24
# env = ((f1 . -12) (f2 . -8) (f3 . -4) (f4 . 0))
# expr = (closure (f18 f19 f20 f21) (f3 f2) (let ((f18 f18) (f19 f19) (f20 f20) (f21 f21)) (if (fx= f20 f21) #t (if ((vector-ref f3 0) f18 f19 f20) ((vector-ref f2 0) f18 f19 (fx+ f20 1) f21) #f))))
    movl $_L_45, 0(%ebp)  # closure label
# emit-variable-ref
# env=((f1 . -12) (f2 . -8) (f3 . -4) (f4 . 0))
# var=f3
    movl -4(%esp), %eax  # stack load f3
# end emit-variable-ref
   movl  %eax, 4(%ebp)  # f3
# emit-variable-ref
# env=((f1 . -12) (f2 . -8) (f3 . -4) (f4 . 0))
# var=f2
    movl -8(%esp), %eax  # stack load f2
# end emit-variable-ref
   movl  %eax, 8(%ebp)  # f2
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $16, %ebp     # bump ebp
    jmp _L_46            # jump around closure body
_L_45:
# check argument count
    cmp $16,%eax
    je _L_47
# invoke error handler eh_argcount
    .extern mrc_eh$uargcount
    movl mrc_eh$uargcount, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_47:
# emit-tail-expr
# si=-24
# env=((f21 . -20) (f20 . -16) (f19 . -12) (f18 . -8) (f2 . 8) (f3 . 4) (f1 . -12) (f2 . -8) (f3 . -4) (f4 . 0))
# expr=(let ((f18 f18) (f19 f19) (f20 f20) (f21 f21)) (if (fx= f20 f21) #t (if ((vector-ref f3 0) f18 f19 f20) ((vector-ref f2 0) f18 f19 (fx+ f20 1) f21) #f)))
# emit-tail-let
#  si   = -24
#  env  = ((f21 . -20) (f20 . -16) (f19 . -12) (f18 . -8) (f2 . 8) (f3 . 4) (f1 . -12) (f2 . -8) (f3 . -4) (f4 . 0))
#  bindings = ((f18 f18) (f19 f19) (f20 f20) (f21 f21))
#  body = (if (fx= f20 f21) #t (if ((vector-ref f3 0) f18 f19 f20) ((vector-ref f2 0) f18 f19 (fx+ f20 1) f21) #f))
# emit-expr f18
# emit-variable-ref
# env=((f21 . -20) (f20 . -16) (f19 . -12) (f18 . -8) (f2 . 8) (f3 . 4) (f1 . -12) (f2 . -8) (f3 . -4) (f4 . 0))
# var=f18
    movl -8(%esp), %eax  # stack load f18
# end emit-variable-ref
    movl %eax, -24(%esp)  # stack save
# emit-expr f19
# emit-variable-ref
# env=((f21 . -20) (f20 . -16) (f19 . -12) (f18 . -8) (f2 . 8) (f3 . 4) (f1 . -12) (f2 . -8) (f3 . -4) (f4 . 0))
# var=f19
    movl -12(%esp), %eax  # stack load f19
# end emit-variable-ref
    movl %eax, -28(%esp)  # stack save
# emit-expr f20
# emit-variable-ref
# env=((f21 . -20) (f20 . -16) (f19 . -12) (f18 . -8) (f2 . 8) (f3 . 4) (f1 . -12) (f2 . -8) (f3 . -4) (f4 . 0))
# var=f20
    movl -16(%esp), %eax  # stack load f20
# end emit-variable-ref
    movl %eax, -32(%esp)  # stack save
# emit-expr f21
# emit-variable-ref
# env=((f21 . -20) (f20 . -16) (f19 . -12) (f18 . -8) (f2 . 8) (f3 . 4) (f1 . -12) (f2 . -8) (f3 . -4) (f4 . 0))
# var=f21
    movl -20(%esp), %eax  # stack load f21
# end emit-variable-ref
    movl %eax, -36(%esp)  # stack save
# emit-tail-expr
# si=-40
# env=((f21 . -36) (f20 . -32) (f19 . -28) (f18 . -24) (f21 . -20) (f20 . -16) (f19 . -12) (f18 . -8) (f2 . 8) (f3 . 4) (f1 . -12) (f2 . -8) (f3 . -4) (f4 . 0))
# expr=(if (fx= f20 f21) #t (if ((vector-ref f3 0) f18 f19 f20) ((vector-ref f2 0) f18 f19 (fx+ f20 1) f21) #f))
# emit-expr (fx= f20 f21)
# emit-expr f21
# emit-variable-ref
# env=((f21 . -36) (f20 . -32) (f19 . -28) (f18 . -24) (f21 . -20) (f20 . -16) (f19 . -12) (f18 . -8) (f2 . 8) (f3 . 4) (f1 . -12) (f2 . -8) (f3 . -4) (f4 . 0))
# var=f21
    movl -36(%esp), %eax  # stack load f21
# end emit-variable-ref
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_50"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $68,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
"_L_50":
    movl %eax, -40(%esp)
# emit-expr f20
# emit-variable-ref
# env=((f21 . -36) (f20 . -32) (f19 . -28) (f18 . -24) (f21 . -20) (f20 . -16) (f19 . -12) (f18 . -8) (f2 . 8) (f3 . 4) (f1 . -12) (f2 . -8) (f3 . -4) (f4 . 0))
# var=f20
    movl -32(%esp), %eax  # stack load f20
# end emit-variable-ref
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_51"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $68,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
"_L_51":
    cmp -40(%esp), %eax
    sete %al
    movzbl %al, %eax
    sal $6, %al
    or $47, %al
    cmp $47, %al
    je _L_48
# emit-tail-expr
# si=-40
# env=((f21 . -36) (f20 . -32) (f19 . -28) (f18 . -24) (f21 . -20) (f20 . -16) (f19 . -12) (f18 . -8) (f2 . 8) (f3 . 4) (f1 . -12) (f2 . -8) (f3 . -4) (f4 . 0))
# expr=#t
    movl $111, %eax     # immed #t
    ret                  # immediate tail return
    jmp _L_49
_L_48:
# emit-tail-expr
# si=-40
# env=((f21 . -36) (f20 . -32) (f19 . -28) (f18 . -24) (f21 . -20) (f20 . -16) (f19 . -12) (f18 . -8) (f2 . 8) (f3 . 4) (f1 . -12) (f2 . -8) (f3 . -4) (f4 . 0))
# expr=(if ((vector-ref f3 0) f18 f19 f20) ((vector-ref f2 0) f18 f19 (fx+ f20 1) f21) #f)
# emit-expr ((vector-ref f3 0) f18 f19 f20)
# funcall
#    si   =-40
#    env  = ((f21 . -36) (f20 . -32) (f19 . -28) (f18 . -24) (f21 . -20) (f20 . -16) (f19 . -12) (f18 . -8) (f2 . 8) (f3 . 4) (f1 . -12) (f2 . -8) (f3 . -4) (f4 . 0))
#    expr = (funcall (vector-ref f3 0) f18 f19 f20)
# emit-expr (vector-ref f3 0)
# emit-expr f3
# emit-variable-ref
# env=((f21 . -36) (f20 . -32) (f19 . -28) (f18 . -24) (f21 . -20) (f20 . -16) (f19 . -12) (f18 . -8) (f2 . 8) (f3 . 4) (f1 . -12) (f2 . -8) (f3 . -4) (f4 . 0))
# var=f3
    movl 2(%edi), %eax  # frame load f3
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_54
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_54:
    movl %eax, -48(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_55"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
"_L_55":
# check bounds on vector index
    movl -48(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_57
    cmp  $0,%eax
    jge _L_56
_L_57:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_56:
    movl -48(%esp), %esi
    movl -1(%eax,%esi), %eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je _L_58
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
_L_58:
   movl %eax,  -48(%esp)  # stash funcall-oper in closure slot
# emit-expr f18
# emit-variable-ref
# env=((f21 . -36) (f20 . -32) (f19 . -28) (f18 . -24) (f21 . -20) (f20 . -16) (f19 . -12) (f18 . -8) (f2 . 8) (f3 . 4) (f1 . -12) (f2 . -8) (f3 . -4) (f4 . 0))
# var=f18
    movl -24(%esp), %eax  # stack load f18
# end emit-variable-ref
    mov %eax, -52(%esp)  # arg f18
# emit-expr f19
# emit-variable-ref
# env=((f21 . -36) (f20 . -32) (f19 . -28) (f18 . -24) (f21 . -20) (f20 . -16) (f19 . -12) (f18 . -8) (f2 . 8) (f3 . 4) (f1 . -12) (f2 . -8) (f3 . -4) (f4 . 0))
# var=f19
    movl -28(%esp), %eax  # stack load f19
# end emit-variable-ref
    mov %eax, -56(%esp)  # arg f19
# emit-expr f20
# emit-variable-ref
# env=((f21 . -36) (f20 . -32) (f19 . -28) (f18 . -24) (f21 . -20) (f20 . -16) (f19 . -12) (f18 . -8) (f2 . 8) (f3 . 4) (f1 . -12) (f2 . -8) (f3 . -4) (f4 . 0))
# var=f20
    movl -32(%esp), %eax  # stack load f20
# end emit-variable-ref
    mov %eax, -60(%esp)  # arg f20
    movl -48(%esp), %edi   # load new closure to %edi
    add $-40, %esp   # adjust base
    movl $12,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $40, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    cmp $47, %al
    je _L_52
# emit-tail-expr
# si=-40
# env=((f21 . -36) (f20 . -32) (f19 . -28) (f18 . -24) (f21 . -20) (f20 . -16) (f19 . -12) (f18 . -8) (f2 . 8) (f3 . 4) (f1 . -12) (f2 . -8) (f3 . -4) (f4 . 0))
# expr=((vector-ref f2 0) f18 f19 (fx+ f20 1) f21)
# emit-tail-funcall
#    si   =-40
#    env  = ((f21 . -36) (f20 . -32) (f19 . -28) (f18 . -24) (f21 . -20) (f20 . -16) (f19 . -12) (f18 . -8) (f2 . 8) (f3 . 4) (f1 . -12) (f2 . -8) (f3 . -4) (f4 . 0))
#    expr = (funcall (vector-ref f2 0) f18 f19 (fx+ f20 1) f21)
# emit-expr (vector-ref f2 0)
# emit-expr f2
# emit-variable-ref
# env=((f21 . -36) (f20 . -32) (f19 . -28) (f18 . -24) (f21 . -20) (f20 . -16) (f19 . -12) (f18 . -8) (f2 . 8) (f3 . 4) (f1 . -12) (f2 . -8) (f3 . -4) (f4 . 0))
# var=f2
    movl 6(%edi), %eax  # frame load f2
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_59
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_59:
    movl %eax, -40(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_60"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
"_L_60":
# check bounds on vector index
    movl -40(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_62
    cmp  $0,%eax
    jge _L_61
_L_62:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_61:
    movl -40(%esp), %esi
    movl -1(%eax,%esi), %eax
   movl %eax,  -40(%esp)  # stash funcall-oper in next closure slot
# emit-expr f18
# emit-variable-ref
# env=((f21 . -36) (f20 . -32) (f19 . -28) (f18 . -24) (f21 . -20) (f20 . -16) (f19 . -12) (f18 . -8) (f2 . 8) (f3 . 4) (f1 . -12) (f2 . -8) (f3 . -4) (f4 . 0))
# var=f18
    movl -24(%esp), %eax  # stack load f18
# end emit-variable-ref
    mov %eax, -44(%esp)    # arg
# emit-expr f19
# emit-variable-ref
# env=((f21 . -36) (f20 . -32) (f19 . -28) (f18 . -24) (f21 . -20) (f20 . -16) (f19 . -12) (f18 . -8) (f2 . 8) (f3 . 4) (f1 . -12) (f2 . -8) (f3 . -4) (f4 . 0))
# var=f19
    movl -28(%esp), %eax  # stack load f19
# end emit-variable-ref
    mov %eax, -48(%esp)    # arg
# emit-expr (fx+ f20 1)
# emit-expr 1
    movl $4, %eax     # immed 1
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_63"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $88,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
"_L_63":
    movl %eax, -52(%esp)  # fx+ push arg1
# emit-expr f20
# emit-variable-ref
# env=((f21 . -36) (f20 . -32) (f19 . -28) (f18 . -24) (f21 . -20) (f20 . -16) (f19 . -12) (f18 . -8) (f2 . 8) (f3 . 4) (f1 . -12) (f2 . -8) (f3 . -4) (f4 . 0))
# var=f20
    movl -32(%esp), %eax  # stack load f20
# end emit-variable-ref
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_64"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $88,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
"_L_64":
    addl -52(%esp), %eax  # fx+ arg1 arg2
    mov %eax, -52(%esp)    # arg
# emit-expr f21
# emit-variable-ref
# env=((f21 . -36) (f20 . -32) (f19 . -28) (f18 . -24) (f21 . -20) (f20 . -16) (f19 . -12) (f18 . -8) (f2 . 8) (f3 . 4) (f1 . -12) (f2 . -8) (f3 . -4) (f4 . 0))
# var=f21
    movl -36(%esp), %eax  # stack load f21
# end emit-variable-ref
    mov %eax, -56(%esp)    # arg
    movl -40(%esp), %edi   # load new closure to %edi
# emit-shift-args:  size=5   si=-40  delta=36
    mov -40(%esp), %ebx  # shift frame cell
    mov %ebx, -4(%esp)  # down to base
# emit-shift-args:  size=4   si=-44  delta=36
    mov -44(%esp), %ebx  # shift frame cell
    mov %ebx, -8(%esp)  # down to base
# emit-shift-args:  size=3   si=-48  delta=36
    mov -48(%esp), %ebx  # shift frame cell
    mov %ebx, -12(%esp)  # down to base
# emit-shift-args:  size=2   si=-52  delta=36
    mov -52(%esp), %ebx  # shift frame cell
    mov %ebx, -16(%esp)  # down to base
# emit-shift-args:  size=1   si=-56  delta=36
    mov -56(%esp), %ebx  # shift frame cell
    mov %ebx, -20(%esp)  # down to base
# emit-shift-args:  size=0   si=-60  delta=36
    movl $16,%eax   # save arg count
    jmp *-2(%edi)  # tail-funcall
    jmp _L_53
_L_52:
# emit-tail-expr
# si=-40
# env=((f21 . -36) (f20 . -32) (f19 . -28) (f18 . -24) (f21 . -20) (f20 . -16) (f19 . -12) (f18 . -8) (f2 . 8) (f3 . 4) (f1 . -12) (f2 . -8) (f3 . -4) (f4 . 0))
# expr=#f
    movl $47, %eax     # immed #f
    ret                  # immediate tail return
_L_53:
_L_49:
    .align 4,0x90
_L_46:
    movl -16(%esp), %ebx
    movl -20(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin (vector-set! f1 0 (closure (f16 f17) (f4 f2) (let ((f16 f16) (f17 f17)) (if ((vector-ref f4 0) f16 f17) ((vector-ref f2 0) f16 f17 0 (string-length f16)) #f)))))
# emit-begin
#   expr=(begin (vector-set! f1 0 (closure (f16 f17) (f4 f2) (let ((f16 f16) (f17 f17)) (if ((vector-ref f4 0) f16 f17) ((vector-ref f2 0) f16 f17 0 (string-length f16)) #f)))))
#   env=((f1 . -12) (f2 . -8) (f3 . -4) (f4 . 0))
# emit-expr (vector-set! f1 0 (closure (f16 f17) (f4 f2) (let ((f16 f16) (f17 f17)) (if ((vector-ref f4 0) f16 f17) ((vector-ref f2 0) f16 f17 0 (string-length f16)) #f))))
# emit-expr f1
# emit-variable-ref
# env=((f1 . -12) (f2 . -8) (f3 . -4) (f4 . 0))
# var=f1
    movl -12(%esp), %eax  # stack load f1
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_65
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_65:
    movl %eax, -16(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_66"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
"_L_66":
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_68
    cmp  $0,%eax
    jge _L_67
_L_68:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_67:
    movl %eax, -20(%esp)
# emit-expr (closure (f16 f17) (f4 f2) (let ((f16 f16) (f17 f17)) (if ((vector-ref f4 0) f16 f17) ((vector-ref f2 0) f16 f17 0 (string-length f16)) #f)))
# emit-closure
# si = -24
# env = ((f1 . -12) (f2 . -8) (f3 . -4) (f4 . 0))
# expr = (closure (f16 f17) (f4 f2) (let ((f16 f16) (f17 f17)) (if ((vector-ref f4 0) f16 f17) ((vector-ref f2 0) f16 f17 0 (string-length f16)) #f)))
    movl $_L_69, 0(%ebp)  # closure label
# emit-variable-ref
# env=((f1 . -12) (f2 . -8) (f3 . -4) (f4 . 0))
# var=f4
    movl 0(%esp), %eax  # stack load f4
# end emit-variable-ref
   movl  %eax, 4(%ebp)  # f4
# emit-variable-ref
# env=((f1 . -12) (f2 . -8) (f3 . -4) (f4 . 0))
# var=f2
    movl -8(%esp), %eax  # stack load f2
# end emit-variable-ref
   movl  %eax, 8(%ebp)  # f2
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $16, %ebp     # bump ebp
    jmp _L_70            # jump around closure body
_L_69:
# check argument count
    cmp $8,%eax
    je _L_71
# invoke error handler eh_argcount
    .extern mrc_eh$uargcount
    movl mrc_eh$uargcount, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_71:
# emit-tail-expr
# si=-16
# env=((f17 . -12) (f16 . -8) (f2 . 8) (f4 . 4) (f1 . -12) (f2 . -8) (f3 . -4) (f4 . 0))
# expr=(let ((f16 f16) (f17 f17)) (if ((vector-ref f4 0) f16 f17) ((vector-ref f2 0) f16 f17 0 (string-length f16)) #f))
# emit-tail-let
#  si   = -16
#  env  = ((f17 . -12) (f16 . -8) (f2 . 8) (f4 . 4) (f1 . -12) (f2 . -8) (f3 . -4) (f4 . 0))
#  bindings = ((f16 f16) (f17 f17))
#  body = (if ((vector-ref f4 0) f16 f17) ((vector-ref f2 0) f16 f17 0 (string-length f16)) #f)
# emit-expr f16
# emit-variable-ref
# env=((f17 . -12) (f16 . -8) (f2 . 8) (f4 . 4) (f1 . -12) (f2 . -8) (f3 . -4) (f4 . 0))
# var=f16
    movl -8(%esp), %eax  # stack load f16
# end emit-variable-ref
    movl %eax, -16(%esp)  # stack save
# emit-expr f17
# emit-variable-ref
# env=((f17 . -12) (f16 . -8) (f2 . 8) (f4 . 4) (f1 . -12) (f2 . -8) (f3 . -4) (f4 . 0))
# var=f17
    movl -12(%esp), %eax  # stack load f17
# end emit-variable-ref
    movl %eax, -20(%esp)  # stack save
# emit-tail-expr
# si=-24
# env=((f17 . -20) (f16 . -16) (f17 . -12) (f16 . -8) (f2 . 8) (f4 . 4) (f1 . -12) (f2 . -8) (f3 . -4) (f4 . 0))
# expr=(if ((vector-ref f4 0) f16 f17) ((vector-ref f2 0) f16 f17 0 (string-length f16)) #f)
# emit-expr ((vector-ref f4 0) f16 f17)
# funcall
#    si   =-24
#    env  = ((f17 . -20) (f16 . -16) (f17 . -12) (f16 . -8) (f2 . 8) (f4 . 4) (f1 . -12) (f2 . -8) (f3 . -4) (f4 . 0))
#    expr = (funcall (vector-ref f4 0) f16 f17)
# emit-expr (vector-ref f4 0)
# emit-expr f4
# emit-variable-ref
# env=((f17 . -20) (f16 . -16) (f17 . -12) (f16 . -8) (f2 . 8) (f4 . 4) (f1 . -12) (f2 . -8) (f3 . -4) (f4 . 0))
# var=f4
    movl 2(%edi), %eax  # frame load f4
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_74
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_74:
    movl %eax, -32(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_75"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
"_L_75":
# check bounds on vector index
    movl -32(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_77
    cmp  $0,%eax
    jge _L_76
_L_77:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_76:
    movl -32(%esp), %esi
    movl -1(%eax,%esi), %eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je _L_78
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
_L_78:
   movl %eax,  -32(%esp)  # stash funcall-oper in closure slot
# emit-expr f16
# emit-variable-ref
# env=((f17 . -20) (f16 . -16) (f17 . -12) (f16 . -8) (f2 . 8) (f4 . 4) (f1 . -12) (f2 . -8) (f3 . -4) (f4 . 0))
# var=f16
    movl -16(%esp), %eax  # stack load f16
# end emit-variable-ref
    mov %eax, -36(%esp)  # arg f16
# emit-expr f17
# emit-variable-ref
# env=((f17 . -20) (f16 . -16) (f17 . -12) (f16 . -8) (f2 . 8) (f4 . 4) (f1 . -12) (f2 . -8) (f3 . -4) (f4 . 0))
# var=f17
    movl -20(%esp), %eax  # stack load f17
# end emit-variable-ref
    mov %eax, -40(%esp)  # arg f17
    movl -32(%esp), %edi   # load new closure to %edi
    add $-24, %esp   # adjust base
    movl $8,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $24, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    cmp $47, %al
    je _L_72
# emit-tail-expr
# si=-24
# env=((f17 . -20) (f16 . -16) (f17 . -12) (f16 . -8) (f2 . 8) (f4 . 4) (f1 . -12) (f2 . -8) (f3 . -4) (f4 . 0))
# expr=((vector-ref f2 0) f16 f17 0 (string-length f16))
# emit-tail-funcall
#    si   =-24
#    env  = ((f17 . -20) (f16 . -16) (f17 . -12) (f16 . -8) (f2 . 8) (f4 . 4) (f1 . -12) (f2 . -8) (f3 . -4) (f4 . 0))
#    expr = (funcall (vector-ref f2 0) f16 f17 0 (string-length f16))
# emit-expr (vector-ref f2 0)
# emit-expr f2
# emit-variable-ref
# env=((f17 . -20) (f16 . -16) (f17 . -12) (f16 . -8) (f2 . 8) (f4 . 4) (f1 . -12) (f2 . -8) (f3 . -4) (f4 . 0))
# var=f2
    movl 6(%edi), %eax  # frame load f2
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_79
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_79:
    movl %eax, -24(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_80"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
"_L_80":
# check bounds on vector index
    movl -24(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_82
    cmp  $0,%eax
    jge _L_81
_L_82:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_81:
    movl -24(%esp), %esi
    movl -1(%eax,%esi), %eax
   movl %eax,  -24(%esp)  # stash funcall-oper in next closure slot
# emit-expr f16
# emit-variable-ref
# env=((f17 . -20) (f16 . -16) (f17 . -12) (f16 . -8) (f2 . 8) (f4 . 4) (f1 . -12) (f2 . -8) (f3 . -4) (f4 . 0))
# var=f16
    movl -16(%esp), %eax  # stack load f16
# end emit-variable-ref
    mov %eax, -28(%esp)    # arg
# emit-expr f17
# emit-variable-ref
# env=((f17 . -20) (f16 . -16) (f17 . -12) (f16 . -8) (f2 . 8) (f4 . 4) (f1 . -12) (f2 . -8) (f3 . -4) (f4 . 0))
# var=f17
    movl -20(%esp), %eax  # stack load f17
# end emit-variable-ref
    mov %eax, -32(%esp)    # arg
# emit-expr 0
    movl $0, %eax     # immed 0
    mov %eax, -36(%esp)    # arg
# emit-expr (string-length f16)
# emit-expr f16
# emit-variable-ref
# env=((f17 . -20) (f16 . -16) (f17 . -12) (f16 . -8) (f2 . 8) (f4 . 4) (f1 . -12) (f2 . -8) (f3 . -4) (f4 . 0))
# var=f16
    movl -16(%esp), %eax  # stack load f16
# end emit-variable-ref
# check the argument is a string
    movl %eax,%ebx
    and $7, %bl
    cmp $6, %bl
    je _L_83
# invoke error handler eh_string
    .extern mrc_eh$ustring
    movl mrc_eh$ustring, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $160,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_83:
    movl -6(%eax), %eax
    mov %eax, -40(%esp)    # arg
    movl -24(%esp), %edi   # load new closure to %edi
# emit-shift-args:  size=5   si=-24  delta=20
    mov -24(%esp), %ebx  # shift frame cell
    mov %ebx, -4(%esp)  # down to base
# emit-shift-args:  size=4   si=-28  delta=20
    mov -28(%esp), %ebx  # shift frame cell
    mov %ebx, -8(%esp)  # down to base
# emit-shift-args:  size=3   si=-32  delta=20
    mov -32(%esp), %ebx  # shift frame cell
    mov %ebx, -12(%esp)  # down to base
# emit-shift-args:  size=2   si=-36  delta=20
    mov -36(%esp), %ebx  # shift frame cell
    mov %ebx, -16(%esp)  # down to base
# emit-shift-args:  size=1   si=-40  delta=20
    mov -40(%esp), %ebx  # shift frame cell
    mov %ebx, -20(%esp)  # down to base
# emit-shift-args:  size=0   si=-44  delta=20
    movl $16,%eax   # save arg count
    jmp *-2(%edi)  # tail-funcall
    jmp _L_73
_L_72:
# emit-tail-expr
# si=-24
# env=((f17 . -20) (f16 . -16) (f17 . -12) (f16 . -8) (f2 . 8) (f4 . 4) (f1 . -12) (f2 . -8) (f3 . -4) (f4 . 0))
# expr=#f
    movl $47, %eax     # immed #f
    ret                  # immediate tail return
_L_73:
    .align 4,0x90
_L_70:
    movl -16(%esp), %ebx
    movl -20(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin)
# emit-begin
#   expr=(begin)
#   env=((f1 . -12) (f2 . -8) (f3 . -4) (f4 . 0))
# emit-expr (begin (vector-ref f1 0))
# emit-begin
#   expr=(begin (vector-ref f1 0))
#   env=((f1 . -12) (f2 . -8) (f3 . -4) (f4 . 0))
# emit-expr (vector-ref f1 0)
# emit-expr f1
# emit-variable-ref
# env=((f1 . -12) (f2 . -8) (f3 . -4) (f4 . 0))
# var=f1
    movl -12(%esp), %eax  # stack load f1
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_84
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_84:
    movl %eax, -16(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_85"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
"_L_85":
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_87
    cmp  $0,%eax
    jge _L_86
_L_87:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_86:
    movl -16(%esp), %esi
    movl -1(%eax,%esi), %eax
# emit-expr (begin)
# emit-begin
#   expr=(begin)
#   env=((f1 . -12) (f2 . -8) (f3 . -4) (f4 . 0))
     movl %eax, mrc_string$e$q
# == explicit-begins  ==>
# (letrec ((str->sym (lambda (str symlist) (if (string=? str (symbol->string (car symlist))) (car symlist) (if (null? (cdr symlist)) (let* ((new-sym (make-symbol str #f)) (new-cdr (cons new-sym ()))) (begin (set-cdr! symlist new-cdr) new-sym)) (str->sym str (cdr symlist))))))) (lambda (str) (str->sym str (symbols))))
# == elim-local-defines  ==>
# (letrec ((str->sym (lambda (str symlist) (if (string=? str (symbol->string (car symlist))) (car symlist) (if (null? (cdr symlist)) (let* ((new-sym (make-symbol str #f)) (new-cdr (cons new-sym ()))) (letrec (set-cdr! symlist new-cdr) new-sym)) (str->sym str (cdr symlist))))))) (lambda (str) (str->sym str (symbols))))
# == eliminate-let*  ==>
# (letrec ((str->sym (lambda (str symlist) (if (string=? str (symbol->string (car symlist))) (car symlist) (if (null? (cdr symlist)) (let ((new-sym (make-symbol str #f))) (let ((new-cdr (cons new-sym ()))) (letrec (set-cdr! symlist new-cdr) new-sym))) (str->sym str (cdr symlist))))))) (lambda (str) (str->sym str (symbols))))
# == uniquify-variables  ==>
