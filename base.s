     .data
     .global "mrc_symbols"
     .align 8
mrc_symbols:
     .int 0xFF
     .global "mrc_string$e$q"
     .align 8
mrc_string$e$q:
     .int 0xFF
     .global "mrc_string$m$gsymbol"
     .align 8
mrc_string$m$gsymbol:
     .int 0xFF
     .global "mrc_append1"
     .align 8
mrc_append1:
     .int 0xFF
     .global "mrc_list$mref"
     .align 8
mrc_list$mref:
     .int 0xFF
     .global "mrc_list$mlength"
     .align 8
mrc_list$mlength:
     .int 0xFF
     .global "mrc_reverse"
     .align 8
mrc_reverse:
     .int 0xFF
     .global "mrc_vector"
     .align 8
mrc_vector:
     .int 0xFF
     .global "mrc_string"
     .align 8
mrc_string:
     .int 0xFF
     .global "mrc_string$m$glist"
     .align 8
mrc_string$m$glist:
     .int 0xFF
     .global "mrc_integer$m$glist"
     .align 8
mrc_integer$m$glist:
     .int 0xFF
     .global "mrc_error"
     .align 8
mrc_error:
     .int 0xFF
     .global "mrc_primitives"
     .align 8
mrc_primitives:
     .int 0xFF
     .global "mrc_eh$uprocedure"
     .align 8
mrc_eh$uprocedure:
     .int 0xFF
     .global "mrc_eh$uargcount"
     .align 8
mrc_eh$uargcount:
     .int 0xFF
     .global "mrc_eh$uargcount$umin"
     .align 8
mrc_eh$uargcount$umin:
     .int 0xFF
     .global "mrc_eh$ufixnum"
     .align 8
mrc_eh$ufixnum:
     .int 0xFF
     .global "mrc_eh$ustring"
     .align 8
mrc_eh$ustring:
     .int 0xFF
     .global "mrc_eh$ucharacter"
     .align 8
mrc_eh$ucharacter:
     .int 0xFF
     .global "mrc_eh$upair"
     .align 8
mrc_eh$upair:
     .int 0xFF
     .global "mrc_eh$uvector"
     .align 8
mrc_eh$uvector:
     .int 0xFF
     .global "mrc_eh$ulength"
     .align 8
mrc_eh$ulength:
     .int 0xFF
     .global "mrc_eh$uvector$uindex"
     .align 8
mrc_eh$uvector$uindex:
     .int 0xFF
     .global "mrc_eh$ustring$uindex"
     .align 8
mrc_eh$ustring$uindex:
     .int 0xFF
     .global "mrc_zero$q"
     .align 8
mrc_zero$q:
     .int 0xFF
     .global "mrc_positive$q"
     .align 8
mrc_positive$q:
     .int 0xFF
     .global "mrc_negative$q"
     .align 8
mrc_negative$q:
     .int 0xFF
     .global "mrc_even$q"
     .align 8
mrc_even$q:
     .int 0xFF
     .global "mrc_odd$q"
     .align 8
mrc_odd$q:
     .int 0xFF
     .global "mrc_map"
     .align 8
mrc_map:
     .int 0xFF
     .global "mrc_for$meach"
     .align 8
mrc_for$meach:
     .int 0xFF
     .global "mrc_standard$mout"
     .align 8
mrc_standard$mout:
     .int 0xFF
     .global "mrc_current$moutput$mport"
     .align 8
mrc_current$moutput$mport:
     .int 0xFF
     .global "mrc_port$mkind"
     .align 8
mrc_port$mkind:
     .int 0xFF
     .global "mrc_port$mpath"
     .align 8
mrc_port$mpath:
     .int 0xFF
     .global "mrc_port$mfd"
     .align 8
mrc_port$mfd:
     .int 0xFF
     .global "mrc_port$mbuf"
     .align 8
mrc_port$mbuf:
     .int 0xFF
     .global "mrc_port$mndx"
     .align 8
mrc_port$mndx:
     .int 0xFF
     .global "mrc_port$mndx$madd1"
     .align 8
mrc_port$mndx$madd1:
     .int 0xFF
     .global "mrc_port$mndx$mreset"
     .align 8
mrc_port$mndx$mreset:
     .int 0xFF
     .global "mrc_port$msize"
     .align 8
mrc_port$msize:
     .int 0xFF
     .global "mrc_write$mchar"
     .align 8
mrc_write$mchar:
     .int 0xFF
     .global "mrc_flush$moutput$mport"
     .align 8
mrc_flush$moutput$mport:
     .int 0xFF
     .global "mrc_exit"
     .align 8
mrc_exit:
     .int 0xFF
     .global "mrc_output$mport$q"
     .align 8
mrc_output$mport$q:
     .int 0xFF
     .global "mrc_open$moutput$mfile"
     .align 8
mrc_open$moutput$mfile:
     .int 0xFF
     .global "mrc_close$moutput$mport"
     .align 8
mrc_close$moutput$mport:
     .int 0xFF
     .global "mrc_base$mwrite"
     .align 8
mrc_base$mwrite:
     .int 0xFF
     .global "mrc_write"
     .align 8
mrc_write:
     .int 0xFF
     .global "mrc_display"
     .align 8
mrc_display:
     .int 0xFF
     .global "mrc_integer$m$gchar"
     .align 8
mrc_integer$m$gchar:
     .int 0xFF
     .text
     .global base_init
     .align 4
base_init:
# == explicit-begins  ==>
# (let ((interned-symbols (cons (make-symbol "nil" ()) ()))) (lambda () interned-symbols))
# == eliminate-let*  ==>
# (let ((interned-symbols (cons (make-symbol "nil" ()) ()))) (lambda () interned-symbols))
# == uniquify-variables  ==>
# (let ((f259391 (cons (make-symbol "nil" ()) ()))) (lambda () f259391))
# == vectorize-letrec  ==>
# (let ((f259391 (cons (make-symbol "nil" ()) ()))) (lambda () f259391))
# == eliminate-set!  ==>
# (let ((f259391 (cons (make-symbol "nil" ()) ()))) (lambda () (let () f259391)))
# == close-free-variables  ==>
# (let ((f259391 (cons (make-symbol "nil" ()) ()))) (closure () (f259391) (let () f259391)))
# == eliminate-quote  ==>
# (let ((f259391 (cons (make-symbol "nil" ()) ()))) (closure () (f259391) (let () f259391)))
# == eliminate-when/unless  ==>
# (let ((f259391 (cons (make-symbol "nil" ()) ()))) (closure () (f259391) (let () f259391)))
# == eliminate-cond  ==>
# (let ((f259391 (cons (make-symbol "nil" ()) ()))) (closure () (f259391) (let () f259391)))
# == external-symbols  ==>
# (let ((f259391 (cons (make-symbol "nil" ()) ()))) (closure () (f259391) (let () f259391)))
# emit-expr (let ((f259391 (cons (make-symbol "nil" ()) ()))) (closure () (f259391) (let () f259391)))
# emit-let
#  si   = 0
#  env  = ()
#  bindings = ((f259391 (cons (make-symbol "nil" ()) ())))
#  body = (closure () (f259391) (let () f259391))
# emit-expr (cons (make-symbol "nil" ()) ())
# cons arg1=(make-symbol "nil" ()) arg2=()
# emit-expr (make-symbol "nil" ())
# make-symbol arg1="nil" arg2=()
# emit-expr "nil"
# string literal
    jmp _L_1576055
    .align 8,0x90
_L_1576054 :
    .int 12
    .ascii "nil"
_L_1576055:
    movl $_L_1576054, %eax
    orl $6, %eax
    movl %eax, 0(%esp)
# emit-expr ()
    movl $63, %eax     # immed ()
    movl %eax, 4(%ebp)
    movl 0(%esp), %eax
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    orl  $3, %eax
    add  $8, %ebp
# make-symbol end
    movl %eax, 0(%esp)
# emit-expr ()
    movl $63, %eax     # immed ()
    movl %eax, 4(%ebp)
    movl 0(%esp), %eax
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    or   $1, %al
    add  $8, %ebp
# cons end
    movl %eax, 0(%esp)  # stack save
# emit-expr (closure () (f259391) (let () f259391))
# emit-closure
# si = -4
# env = ((f259391 . 0))
# expr = (closure () (f259391) (let () f259391))
    movl $_L_1576056, 0(%ebp)  # closure label
# emit-variable-ref
# env=((f259391 . 0))
# var=f259391
    movl 0(%esp), %eax  # stack load f259391
# end emit-variable-ref
   movl  %eax, 4(%ebp)  # f259391
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $8, %ebp     # bump ebp
    jmp _L_1576057            # jump around closure body
_L_1576056:
# check argument count
    cmp $0,%eax
    je _L_1576058
# invoke error handler eh_argcount
    .extern mrc_eh$uargcount
    movl mrc_eh$uargcount, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_1576058:
# emit-tail-expr
# si=-8
# env=((f259391 . 4) (f259391 . 0))
# expr=(let () f259391)
# emit-tail-let
#  si   = -8
#  env  = ((f259391 . 4) (f259391 . 0))
#  bindings = ()
#  body = f259391
# emit-tail-expr
# si=-8
# env=((f259391 . 4) (f259391 . 0))
# expr=f259391
# emit-tail-variable-ref
# emit-variable-ref
# env=((f259391 . 4) (f259391 . 0))
# var=f259391
    movl 2(%edi), %eax  # frame load f259391
# end emit-variable-ref
    ret
# end emit-tail-variable ref
    .align 4,0x90
_L_1576057:
     movl %eax, mrc_symbols
# == explicit-begins  ==>
# (letrec ((slen= (lambda (s1 s2) (fx= (string-length s1) (string-length s2)))) (si= (lambda (s1 s2 i) (char=? (string-ref s1 i) (string-ref s2 i)))) (si<n= (lambda (s1 s2 i n) (if (fx= i n) #t (if (si= s1 s2 i) (si<n= s1 s2 (fx+ i 1) n) #f)))) (ss= (lambda (s1 s2) (if (slen= s1 s2) (si<n= s1 s2 0 (string-length s1)) #f)))) ss=)
# == eliminate-let*  ==>
# (letrec ((slen= (lambda (s1 s2) (fx= (string-length s1) (string-length s2)))) (si= (lambda (s1 s2 i) (char=? (string-ref s1 i) (string-ref s2 i)))) (si<n= (lambda (s1 s2 i n) (if (fx= i n) #t (if (si= s1 s2 i) (si<n= s1 s2 (fx+ i 1) n) #f)))) (ss= (lambda (s1 s2) (if (slen= s1 s2) (si<n= s1 s2 0 (string-length s1)) #f)))) ss=)
# == uniquify-variables  ==>
# (letrec ((f259395 (lambda (f259416 f259417) (fx= (string-length f259416) (string-length f259417)))) (f259394 (lambda (f259413 f259414 f259415) (char=? (string-ref f259413 f259415) (string-ref f259414 f259415)))) (f259393 (lambda (f259409 f259410 f259411 f259412) (if (fx= f259411 f259412) #t (if (f259394 f259409 f259410 f259411) (f259393 f259409 f259410 (fx+ f259411 1) f259412) #f)))) (f259392 (lambda (f259407 f259408) (if (f259395 f259407 f259408) (f259393 f259407 f259408 0 (string-length f259407)) #f)))) f259392)
# == vectorize-letrec  ==>
# (let ((f259395 (make-vector 1)) (f259394 (make-vector 1)) (f259393 (make-vector 1)) (f259392 (make-vector 1))) (begin (begin (vector-set! f259395 0 (lambda (f259416 f259417) (fx= (string-length f259416) (string-length f259417)))) (vector-set! f259394 0 (lambda (f259413 f259414 f259415) (char=? (string-ref f259413 f259415) (string-ref f259414 f259415)))) (vector-set! f259393 0 (lambda (f259409 f259410 f259411 f259412) (if (fx= f259411 f259412) #t (if ((vector-ref f259394 0) f259409 f259410 f259411) ((vector-ref f259393 0) f259409 f259410 (fx+ f259411 1) f259412) #f)))) (vector-set! f259392 0 (lambda (f259407 f259408) (if ((vector-ref f259395 0) f259407 f259408) ((vector-ref f259393 0) f259407 f259408 0 (string-length f259407)) #f)))) (vector-ref f259392 0)))
# == eliminate-set!  ==>
# (let ((f259395 (make-vector 1)) (f259394 (make-vector 1)) (f259393 (make-vector 1)) (f259392 (make-vector 1))) (begin (begin (vector-set! f259395 0 (lambda (f259416 f259417) (let ((f259416 f259416) (f259417 f259417)) (fx= (string-length f259416) (string-length f259417))))) (vector-set! f259394 0 (lambda (f259413 f259414 f259415) (let ((f259413 f259413) (f259414 f259414) (f259415 f259415)) (char=? (string-ref f259413 f259415) (string-ref f259414 f259415))))) (vector-set! f259393 0 (lambda (f259409 f259410 f259411 f259412) (let ((f259409 f259409) (f259410 f259410) (f259411 f259411) (f259412 f259412)) (if (fx= f259411 f259412) #t (if ((vector-ref f259394 0) f259409 f259410 f259411) ((vector-ref f259393 0) f259409 f259410 (fx+ f259411 1) f259412) #f))))) (vector-set! f259392 0 (lambda (f259407 f259408) (let ((f259407 f259407) (f259408 f259408)) (if ((vector-ref f259395 0) f259407 f259408) ((vector-ref f259393 0) f259407 f259408 0 (string-length f259407)) #f))))) (vector-ref f259392 0)))
# == close-free-variables  ==>
# (let ((f259395 (make-vector 1)) (f259394 (make-vector 1)) (f259393 (make-vector 1)) (f259392 (make-vector 1))) (begin (begin (vector-set! f259395 0 (closure (f259416 f259417) () (let ((f259416 f259416) (f259417 f259417)) (fx= (string-length f259416) (string-length f259417))))) (vector-set! f259394 0 (closure (f259413 f259414 f259415) () (let ((f259413 f259413) (f259414 f259414) (f259415 f259415)) (char=? (string-ref f259413 f259415) (string-ref f259414 f259415))))) (vector-set! f259393 0 (closure (f259409 f259410 f259411 f259412) (f259394 f259393) (let ((f259409 f259409) (f259410 f259410) (f259411 f259411) (f259412 f259412)) (if (fx= f259411 f259412) #t (if ((vector-ref f259394 0) f259409 f259410 f259411) ((vector-ref f259393 0) f259409 f259410 (fx+ f259411 1) f259412) #f))))) (vector-set! f259392 0 (closure (f259407 f259408) (f259395 f259393) (let ((f259407 f259407) (f259408 f259408)) (if ((vector-ref f259395 0) f259407 f259408) ((vector-ref f259393 0) f259407 f259408 0 (string-length f259407)) #f))))) (vector-ref f259392 0)))
# == eliminate-quote  ==>
# (let ((f259395 (make-vector 1)) (f259394 (make-vector 1)) (f259393 (make-vector 1)) (f259392 (make-vector 1))) (begin (begin (vector-set! f259395 0 (closure (f259416 f259417) () (let ((f259416 f259416) (f259417 f259417)) (fx= (string-length f259416) (string-length f259417))))) (vector-set! f259394 0 (closure (f259413 f259414 f259415) () (let ((f259413 f259413) (f259414 f259414) (f259415 f259415)) (char=? (string-ref f259413 f259415) (string-ref f259414 f259415))))) (vector-set! f259393 0 (closure (f259409 f259410 f259411 f259412) (f259394 f259393) (let ((f259409 f259409) (f259410 f259410) (f259411 f259411) (f259412 f259412)) (if (fx= f259411 f259412) #t (if ((vector-ref f259394 0) f259409 f259410 f259411) ((vector-ref f259393 0) f259409 f259410 (fx+ f259411 1) f259412) #f))))) (vector-set! f259392 0 (closure (f259407 f259408) (f259395 f259393) (let ((f259407 f259407) (f259408 f259408)) (if ((vector-ref f259395 0) f259407 f259408) ((vector-ref f259393 0) f259407 f259408 0 (string-length f259407)) #f))))) (vector-ref f259392 0)))
# == eliminate-when/unless  ==>
# (let ((f259395 (make-vector 1)) (f259394 (make-vector 1)) (f259393 (make-vector 1)) (f259392 (make-vector 1))) (begin (begin (vector-set! f259395 0 (closure (f259416 f259417) () (let ((f259416 f259416) (f259417 f259417)) (fx= (string-length f259416) (string-length f259417))))) (vector-set! f259394 0 (closure (f259413 f259414 f259415) () (let ((f259413 f259413) (f259414 f259414) (f259415 f259415)) (char=? (string-ref f259413 f259415) (string-ref f259414 f259415))))) (vector-set! f259393 0 (closure (f259409 f259410 f259411 f259412) (f259394 f259393) (let ((f259409 f259409) (f259410 f259410) (f259411 f259411) (f259412 f259412)) (if (fx= f259411 f259412) #t (if ((vector-ref f259394 0) f259409 f259410 f259411) ((vector-ref f259393 0) f259409 f259410 (fx+ f259411 1) f259412) #f))))) (vector-set! f259392 0 (closure (f259407 f259408) (f259395 f259393) (let ((f259407 f259407) (f259408 f259408)) (if ((vector-ref f259395 0) f259407 f259408) ((vector-ref f259393 0) f259407 f259408 0 (string-length f259407)) #f))))) (vector-ref f259392 0)))
# == eliminate-cond  ==>
# (let ((f259395 (make-vector 1)) (f259394 (make-vector 1)) (f259393 (make-vector 1)) (f259392 (make-vector 1))) (begin (begin (vector-set! f259395 0 (closure (f259416 f259417) () (let ((f259416 f259416) (f259417 f259417)) (fx= (string-length f259416) (string-length f259417))))) (vector-set! f259394 0 (closure (f259413 f259414 f259415) () (let ((f259413 f259413) (f259414 f259414) (f259415 f259415)) (char=? (string-ref f259413 f259415) (string-ref f259414 f259415))))) (vector-set! f259393 0 (closure (f259409 f259410 f259411 f259412) (f259394 f259393) (let ((f259409 f259409) (f259410 f259410) (f259411 f259411) (f259412 f259412)) (if (fx= f259411 f259412) #t (if ((vector-ref f259394 0) f259409 f259410 f259411) ((vector-ref f259393 0) f259409 f259410 (fx+ f259411 1) f259412) #f))))) (vector-set! f259392 0 (closure (f259407 f259408) (f259395 f259393) (let ((f259407 f259407) (f259408 f259408)) (if ((vector-ref f259395 0) f259407 f259408) ((vector-ref f259393 0) f259407 f259408 0 (string-length f259407)) #f))))) (vector-ref f259392 0)))
# == external-symbols  ==>
# (let ((f259395 (make-vector 1)) (f259394 (make-vector 1)) (f259393 (make-vector 1)) (f259392 (make-vector 1))) (begin (begin (vector-set! f259395 0 (closure (f259416 f259417) () (let ((f259416 f259416) (f259417 f259417)) (fx= (string-length f259416) (string-length f259417))))) (vector-set! f259394 0 (closure (f259413 f259414 f259415) () (let ((f259413 f259413) (f259414 f259414) (f259415 f259415)) (char=? (string-ref f259413 f259415) (string-ref f259414 f259415))))) (vector-set! f259393 0 (closure (f259409 f259410 f259411 f259412) (f259394 f259393) (let ((f259409 f259409) (f259410 f259410) (f259411 f259411) (f259412 f259412)) (if (fx= f259411 f259412) #t (if ((vector-ref f259394 0) f259409 f259410 f259411) ((vector-ref f259393 0) f259409 f259410 (fx+ f259411 1) f259412) #f))))) (vector-set! f259392 0 (closure (f259407 f259408) (f259395 f259393) (let ((f259407 f259407) (f259408 f259408)) (if ((vector-ref f259395 0) f259407 f259408) ((vector-ref f259393 0) f259407 f259408 0 (string-length f259407)) #f))))) (vector-ref f259392 0)))
# emit-expr (let ((f259395 (make-vector 1)) (f259394 (make-vector 1)) (f259393 (make-vector 1)) (f259392 (make-vector 1))) (begin (begin (vector-set! f259395 0 (closure (f259416 f259417) () (let ((f259416 f259416) (f259417 f259417)) (fx= (string-length f259416) (string-length f259417))))) (vector-set! f259394 0 (closure (f259413 f259414 f259415) () (let ((f259413 f259413) (f259414 f259414) (f259415 f259415)) (char=? (string-ref f259413 f259415) (string-ref f259414 f259415))))) (vector-set! f259393 0 (closure (f259409 f259410 f259411 f259412) (f259394 f259393) (let ((f259409 f259409) (f259410 f259410) (f259411 f259411) (f259412 f259412)) (if (fx= f259411 f259412) #t (if ((vector-ref f259394 0) f259409 f259410 f259411) ((vector-ref f259393 0) f259409 f259410 (fx+ f259411 1) f259412) #f))))) (vector-set! f259392 0 (closure (f259407 f259408) (f259395 f259393) (let ((f259407 f259407) (f259408 f259408)) (if ((vector-ref f259395 0) f259407 f259408) ((vector-ref f259393 0) f259407 f259408 0 (string-length f259407)) #f))))) (vector-ref f259392 0)))
# emit-let
#  si   = 0
#  env  = ()
#  bindings = ((f259395 (make-vector 1)) (f259394 (make-vector 1)) (f259393 (make-vector 1)) (f259392 (make-vector 1)))
#  body = (begin (begin (vector-set! f259395 0 (closure (f259416 f259417) () (let ((f259416 f259416) (f259417 f259417)) (fx= (string-length f259416) (string-length f259417))))) (vector-set! f259394 0 (closure (f259413 f259414 f259415) () (let ((f259413 f259413) (f259414 f259414) (f259415 f259415)) (char=? (string-ref f259413 f259415) (string-ref f259414 f259415))))) (vector-set! f259393 0 (closure (f259409 f259410 f259411 f259412) (f259394 f259393) (let ((f259409 f259409) (f259410 f259410) (f259411 f259411) (f259412 f259412)) (if (fx= f259411 f259412) #t (if ((vector-ref f259394 0) f259409 f259410 f259411) ((vector-ref f259393 0) f259409 f259410 (fx+ f259411 1) f259412) #f))))) (vector-set! f259392 0 (closure (f259407 f259408) (f259395 f259393) (let ((f259407 f259407) (f259408 f259408)) (if ((vector-ref f259395 0) f259407 f259408) ((vector-ref f259393 0) f259407 f259408 0 (string-length f259407)) #f))))) (vector-ref f259392 0))
# emit-expr (make-vector 1)
# make-vector 1
# emit-expr 1
    movl $4, %eax     # immed 1
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1576059"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $128,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1576059:
# check the argument is a fixnum >= 0
    cmp $0,%eax
    jge _L_1576060
# invoke error handler eh_length
    .extern mrc_eh$ulength
    movl mrc_eh$ulength, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $128,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1576060:
    movl %eax, %esi
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    orl  $5, %eax
    addl $4, %esi
    addl $4, %esi
    andl $-8, %esi
    addl %esi, %ebp
    movl %eax, 0(%esp)  # stack save
# emit-expr (make-vector 1)
# make-vector 1
# emit-expr 1
    movl $4, %eax     # immed 1
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1576061"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $128,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1576061:
# check the argument is a fixnum >= 0
    cmp $0,%eax
    jge _L_1576062
# invoke error handler eh_length
    .extern mrc_eh$ulength
    movl mrc_eh$ulength, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $128,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1576062:
    movl %eax, %esi
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    orl  $5, %eax
    addl $4, %esi
    addl $4, %esi
    andl $-8, %esi
    addl %esi, %ebp
    movl %eax, -4(%esp)  # stack save
# emit-expr (make-vector 1)
# make-vector 1
# emit-expr 1
    movl $4, %eax     # immed 1
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1576063"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $128,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1576063:
# check the argument is a fixnum >= 0
    cmp $0,%eax
    jge _L_1576064
# invoke error handler eh_length
    .extern mrc_eh$ulength
    movl mrc_eh$ulength, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $128,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1576064:
    movl %eax, %esi
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    orl  $5, %eax
    addl $4, %esi
    addl $4, %esi
    andl $-8, %esi
    addl %esi, %ebp
    movl %eax, -8(%esp)  # stack save
# emit-expr (make-vector 1)
# make-vector 1
# emit-expr 1
    movl $4, %eax     # immed 1
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1576065"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $128,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1576065:
# check the argument is a fixnum >= 0
    cmp $0,%eax
    jge _L_1576066
# invoke error handler eh_length
    .extern mrc_eh$ulength
    movl mrc_eh$ulength, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $128,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1576066:
    movl %eax, %esi
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    orl  $5, %eax
    addl $4, %esi
    addl $4, %esi
    andl $-8, %esi
    addl %esi, %ebp
    movl %eax, -12(%esp)  # stack save
# emit-expr (begin (begin (vector-set! f259395 0 (closure (f259416 f259417) () (let ((f259416 f259416) (f259417 f259417)) (fx= (string-length f259416) (string-length f259417))))) (vector-set! f259394 0 (closure (f259413 f259414 f259415) () (let ((f259413 f259413) (f259414 f259414) (f259415 f259415)) (char=? (string-ref f259413 f259415) (string-ref f259414 f259415))))) (vector-set! f259393 0 (closure (f259409 f259410 f259411 f259412) (f259394 f259393) (let ((f259409 f259409) (f259410 f259410) (f259411 f259411) (f259412 f259412)) (if (fx= f259411 f259412) #t (if ((vector-ref f259394 0) f259409 f259410 f259411) ((vector-ref f259393 0) f259409 f259410 (fx+ f259411 1) f259412) #f))))) (vector-set! f259392 0 (closure (f259407 f259408) (f259395 f259393) (let ((f259407 f259407) (f259408 f259408)) (if ((vector-ref f259395 0) f259407 f259408) ((vector-ref f259393 0) f259407 f259408 0 (string-length f259407)) #f))))) (vector-ref f259392 0))
# emit-begin
#   expr=(begin (begin (vector-set! f259395 0 (closure (f259416 f259417) () (let ((f259416 f259416) (f259417 f259417)) (fx= (string-length f259416) (string-length f259417))))) (vector-set! f259394 0 (closure (f259413 f259414 f259415) () (let ((f259413 f259413) (f259414 f259414) (f259415 f259415)) (char=? (string-ref f259413 f259415) (string-ref f259414 f259415))))) (vector-set! f259393 0 (closure (f259409 f259410 f259411 f259412) (f259394 f259393) (let ((f259409 f259409) (f259410 f259410) (f259411 f259411) (f259412 f259412)) (if (fx= f259411 f259412) #t (if ((vector-ref f259394 0) f259409 f259410 f259411) ((vector-ref f259393 0) f259409 f259410 (fx+ f259411 1) f259412) #f))))) (vector-set! f259392 0 (closure (f259407 f259408) (f259395 f259393) (let ((f259407 f259407) (f259408 f259408)) (if ((vector-ref f259395 0) f259407 f259408) ((vector-ref f259393 0) f259407 f259408 0 (string-length f259407)) #f))))) (vector-ref f259392 0))
#   env=((f259392 . -12) (f259393 . -8) (f259394 . -4) (f259395 . 0))
# emit-expr (begin (vector-set! f259395 0 (closure (f259416 f259417) () (let ((f259416 f259416) (f259417 f259417)) (fx= (string-length f259416) (string-length f259417))))) (vector-set! f259394 0 (closure (f259413 f259414 f259415) () (let ((f259413 f259413) (f259414 f259414) (f259415 f259415)) (char=? (string-ref f259413 f259415) (string-ref f259414 f259415))))) (vector-set! f259393 0 (closure (f259409 f259410 f259411 f259412) (f259394 f259393) (let ((f259409 f259409) (f259410 f259410) (f259411 f259411) (f259412 f259412)) (if (fx= f259411 f259412) #t (if ((vector-ref f259394 0) f259409 f259410 f259411) ((vector-ref f259393 0) f259409 f259410 (fx+ f259411 1) f259412) #f))))) (vector-set! f259392 0 (closure (f259407 f259408) (f259395 f259393) (let ((f259407 f259407) (f259408 f259408)) (if ((vector-ref f259395 0) f259407 f259408) ((vector-ref f259393 0) f259407 f259408 0 (string-length f259407)) #f)))))
# emit-begin
#   expr=(begin (vector-set! f259395 0 (closure (f259416 f259417) () (let ((f259416 f259416) (f259417 f259417)) (fx= (string-length f259416) (string-length f259417))))) (vector-set! f259394 0 (closure (f259413 f259414 f259415) () (let ((f259413 f259413) (f259414 f259414) (f259415 f259415)) (char=? (string-ref f259413 f259415) (string-ref f259414 f259415))))) (vector-set! f259393 0 (closure (f259409 f259410 f259411 f259412) (f259394 f259393) (let ((f259409 f259409) (f259410 f259410) (f259411 f259411) (f259412 f259412)) (if (fx= f259411 f259412) #t (if ((vector-ref f259394 0) f259409 f259410 f259411) ((vector-ref f259393 0) f259409 f259410 (fx+ f259411 1) f259412) #f))))) (vector-set! f259392 0 (closure (f259407 f259408) (f259395 f259393) (let ((f259407 f259407) (f259408 f259408)) (if ((vector-ref f259395 0) f259407 f259408) ((vector-ref f259393 0) f259407 f259408 0 (string-length f259407)) #f)))))
#   env=((f259392 . -12) (f259393 . -8) (f259394 . -4) (f259395 . 0))
# emit-expr (vector-set! f259395 0 (closure (f259416 f259417) () (let ((f259416 f259416) (f259417 f259417)) (fx= (string-length f259416) (string-length f259417)))))
# emit-expr f259395
# emit-variable-ref
# env=((f259392 . -12) (f259393 . -8) (f259394 . -4) (f259395 . 0))
# var=f259395
    movl 0(%esp), %eax  # stack load f259395
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1576067
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1576067:
    movl %eax, -16(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1576068"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1576068:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1576070
    cmp  $0,%eax
    jge _L_1576069
_L_1576070:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1576069:
    movl %eax, -20(%esp)
# emit-expr (closure (f259416 f259417) () (let ((f259416 f259416) (f259417 f259417)) (fx= (string-length f259416) (string-length f259417))))
# emit-closure
# si = -24
# env = ((f259392 . -12) (f259393 . -8) (f259394 . -4) (f259395 . 0))
# expr = (closure (f259416 f259417) () (let ((f259416 f259416) (f259417 f259417)) (fx= (string-length f259416) (string-length f259417))))
    movl $_L_1576071, 0(%ebp)  # closure label
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $8, %ebp     # bump ebp
    jmp _L_1576072            # jump around closure body
_L_1576071:
# check argument count
    cmp $8,%eax
    je _L_1576073
# invoke error handler eh_argcount
    .extern mrc_eh$uargcount
    movl mrc_eh$uargcount, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_1576073:
# emit-tail-expr
# si=-16
# env=((f259417 . -12) (f259416 . -8) (f259392 . -12) (f259393 . -8) (f259394 . -4) (f259395 . 0))
# expr=(let ((f259416 f259416) (f259417 f259417)) (fx= (string-length f259416) (string-length f259417)))
# emit-tail-let
#  si   = -16
#  env  = ((f259417 . -12) (f259416 . -8) (f259392 . -12) (f259393 . -8) (f259394 . -4) (f259395 . 0))
#  bindings = ((f259416 f259416) (f259417 f259417))
#  body = (fx= (string-length f259416) (string-length f259417))
# emit-expr f259416
# emit-variable-ref
# env=((f259417 . -12) (f259416 . -8) (f259392 . -12) (f259393 . -8) (f259394 . -4) (f259395 . 0))
# var=f259416
    movl -8(%esp), %eax  # stack load f259416
# end emit-variable-ref
    movl %eax, -16(%esp)  # stack save
# emit-expr f259417
# emit-variable-ref
# env=((f259417 . -12) (f259416 . -8) (f259392 . -12) (f259393 . -8) (f259394 . -4) (f259395 . 0))
# var=f259417
    movl -12(%esp), %eax  # stack load f259417
# end emit-variable-ref
    movl %eax, -20(%esp)  # stack save
# emit-tail-expr
# si=-24
# env=((f259417 . -20) (f259416 . -16) (f259417 . -12) (f259416 . -8) (f259392 . -12) (f259393 . -8) (f259394 . -4) (f259395 . 0))
# expr=(fx= (string-length f259416) (string-length f259417))
# tail primcall
# emit-expr (string-length f259417)
# emit-expr f259417
# emit-variable-ref
# env=((f259417 . -20) (f259416 . -16) (f259417 . -12) (f259416 . -8) (f259392 . -12) (f259393 . -8) (f259394 . -4) (f259395 . 0))
# var=f259417
    movl -20(%esp), %eax  # stack load f259417
# end emit-variable-ref
# check the argument is a string
    movl %eax,%ebx
    and $7, %bl
    cmp $6, %bl
    je _L_1576074
# invoke error handler eh_string
    .extern mrc_eh$ustring
    movl mrc_eh$ustring, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $152,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1576074:
    movl -6(%eax), %eax
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1576075"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $60,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1576075:
    movl %eax, -24(%esp)
# emit-expr (string-length f259416)
# emit-expr f259416
# emit-variable-ref
# env=((f259417 . -20) (f259416 . -16) (f259417 . -12) (f259416 . -8) (f259392 . -12) (f259393 . -8) (f259394 . -4) (f259395 . 0))
# var=f259416
    movl -16(%esp), %eax  # stack load f259416
# end emit-variable-ref
# check the argument is a string
    movl %eax,%ebx
    and $7, %bl
    cmp $6, %bl
    je _L_1576076
# invoke error handler eh_string
    .extern mrc_eh$ustring
    movl mrc_eh$ustring, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $152,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1576076:
    movl -6(%eax), %eax
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1576077"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $60,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1576077:
    cmp -24(%esp), %eax
    sete %al
    movzbl %al, %eax
    sal $6, %al
    or $47, %al
#return from tail (fx= (string-length f259416) (string-length f259417))
    ret
    .align 4,0x90
_L_1576072:
    movl -16(%esp), %ebx
    movl -20(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin (vector-set! f259394 0 (closure (f259413 f259414 f259415) () (let ((f259413 f259413) (f259414 f259414) (f259415 f259415)) (char=? (string-ref f259413 f259415) (string-ref f259414 f259415))))) (vector-set! f259393 0 (closure (f259409 f259410 f259411 f259412) (f259394 f259393) (let ((f259409 f259409) (f259410 f259410) (f259411 f259411) (f259412 f259412)) (if (fx= f259411 f259412) #t (if ((vector-ref f259394 0) f259409 f259410 f259411) ((vector-ref f259393 0) f259409 f259410 (fx+ f259411 1) f259412) #f))))) (vector-set! f259392 0 (closure (f259407 f259408) (f259395 f259393) (let ((f259407 f259407) (f259408 f259408)) (if ((vector-ref f259395 0) f259407 f259408) ((vector-ref f259393 0) f259407 f259408 0 (string-length f259407)) #f)))))
# emit-begin
#   expr=(begin (vector-set! f259394 0 (closure (f259413 f259414 f259415) () (let ((f259413 f259413) (f259414 f259414) (f259415 f259415)) (char=? (string-ref f259413 f259415) (string-ref f259414 f259415))))) (vector-set! f259393 0 (closure (f259409 f259410 f259411 f259412) (f259394 f259393) (let ((f259409 f259409) (f259410 f259410) (f259411 f259411) (f259412 f259412)) (if (fx= f259411 f259412) #t (if ((vector-ref f259394 0) f259409 f259410 f259411) ((vector-ref f259393 0) f259409 f259410 (fx+ f259411 1) f259412) #f))))) (vector-set! f259392 0 (closure (f259407 f259408) (f259395 f259393) (let ((f259407 f259407) (f259408 f259408)) (if ((vector-ref f259395 0) f259407 f259408) ((vector-ref f259393 0) f259407 f259408 0 (string-length f259407)) #f)))))
#   env=((f259392 . -12) (f259393 . -8) (f259394 . -4) (f259395 . 0))
# emit-expr (vector-set! f259394 0 (closure (f259413 f259414 f259415) () (let ((f259413 f259413) (f259414 f259414) (f259415 f259415)) (char=? (string-ref f259413 f259415) (string-ref f259414 f259415)))))
# emit-expr f259394
# emit-variable-ref
# env=((f259392 . -12) (f259393 . -8) (f259394 . -4) (f259395 . 0))
# var=f259394
    movl -4(%esp), %eax  # stack load f259394
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1576078
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1576078:
    movl %eax, -16(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1576079"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1576079:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1576081
    cmp  $0,%eax
    jge _L_1576080
_L_1576081:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1576080:
    movl %eax, -20(%esp)
# emit-expr (closure (f259413 f259414 f259415) () (let ((f259413 f259413) (f259414 f259414) (f259415 f259415)) (char=? (string-ref f259413 f259415) (string-ref f259414 f259415))))
# emit-closure
# si = -24
# env = ((f259392 . -12) (f259393 . -8) (f259394 . -4) (f259395 . 0))
# expr = (closure (f259413 f259414 f259415) () (let ((f259413 f259413) (f259414 f259414) (f259415 f259415)) (char=? (string-ref f259413 f259415) (string-ref f259414 f259415))))
    movl $_L_1576082, 0(%ebp)  # closure label
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $8, %ebp     # bump ebp
    jmp _L_1576083            # jump around closure body
_L_1576082:
# check argument count
    cmp $12,%eax
    je _L_1576084
# invoke error handler eh_argcount
    .extern mrc_eh$uargcount
    movl mrc_eh$uargcount, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_1576084:
# emit-tail-expr
# si=-20
# env=((f259415 . -16) (f259414 . -12) (f259413 . -8) (f259392 . -12) (f259393 . -8) (f259394 . -4) (f259395 . 0))
# expr=(let ((f259413 f259413) (f259414 f259414) (f259415 f259415)) (char=? (string-ref f259413 f259415) (string-ref f259414 f259415)))
# emit-tail-let
#  si   = -20
#  env  = ((f259415 . -16) (f259414 . -12) (f259413 . -8) (f259392 . -12) (f259393 . -8) (f259394 . -4) (f259395 . 0))
#  bindings = ((f259413 f259413) (f259414 f259414) (f259415 f259415))
#  body = (char=? (string-ref f259413 f259415) (string-ref f259414 f259415))
# emit-expr f259413
# emit-variable-ref
# env=((f259415 . -16) (f259414 . -12) (f259413 . -8) (f259392 . -12) (f259393 . -8) (f259394 . -4) (f259395 . 0))
# var=f259413
    movl -8(%esp), %eax  # stack load f259413
# end emit-variable-ref
    movl %eax, -20(%esp)  # stack save
# emit-expr f259414
# emit-variable-ref
# env=((f259415 . -16) (f259414 . -12) (f259413 . -8) (f259392 . -12) (f259393 . -8) (f259394 . -4) (f259395 . 0))
# var=f259414
    movl -12(%esp), %eax  # stack load f259414
# end emit-variable-ref
    movl %eax, -24(%esp)  # stack save
# emit-expr f259415
# emit-variable-ref
# env=((f259415 . -16) (f259414 . -12) (f259413 . -8) (f259392 . -12) (f259393 . -8) (f259394 . -4) (f259395 . 0))
# var=f259415
    movl -16(%esp), %eax  # stack load f259415
# end emit-variable-ref
    movl %eax, -28(%esp)  # stack save
# emit-tail-expr
# si=-32
# env=((f259415 . -28) (f259414 . -24) (f259413 . -20) (f259415 . -16) (f259414 . -12) (f259413 . -8) (f259392 . -12) (f259393 . -8) (f259394 . -4) (f259395 . 0))
# expr=(char=? (string-ref f259413 f259415) (string-ref f259414 f259415))
# tail primcall
# char= c1=(string-ref f259413 f259415) c2=(string-ref f259414 f259415)
# emit-expr (string-ref f259413 f259415)
# emit-expr f259413
# emit-variable-ref
# env=((f259415 . -28) (f259414 . -24) (f259413 . -20) (f259415 . -16) (f259414 . -12) (f259413 . -8) (f259392 . -12) (f259393 . -8) (f259394 . -4) (f259395 . 0))
# var=f259413
    movl -20(%esp), %eax  # stack load f259413
# end emit-variable-ref
# check the argument is a string
    movl %eax,%ebx
    and $7, %bl
    cmp $6, %bl
    je _L_1576085
# invoke error handler eh_string
    .extern mrc_eh$ustring
    movl mrc_eh$ustring, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $156,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1576085:
    movl %eax, -32(%esp)
# emit-expr f259415
# emit-variable-ref
# env=((f259415 . -28) (f259414 . -24) (f259413 . -20) (f259415 . -16) (f259414 . -12) (f259413 . -8) (f259392 . -12) (f259393 . -8) (f259394 . -4) (f259395 . 0))
# var=f259415
    movl -28(%esp), %eax  # stack load f259415
# end emit-variable-ref
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1576086"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $156,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1576086:
# check bounds on string index
    movl -32(%esp), %ebx
    cmp  %eax,-6(%ebx) 
    jle _L_1576088
    cmp  $0,%eax
    jge _L_1576087
_L_1576088:
# invoke error handler eh_string_index
    .extern mrc_eh$ustring$uindex
    movl mrc_eh$ustring$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $156,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1576087:
    sar $2, %eax
    movl -32(%esp), %esi
    movl -2(%eax,%esi), %eax
    sal $8, %eax
    or  $15, %eax
# check the argument is a char
    movl %eax,%ebx
    and $255, %bl
    cmp $15, %bl
    je "_L_1576089"
# invoke error handler eh_character
    .extern mrc_eh$ucharacter
    movl mrc_eh$ucharacter, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $32,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1576089:
    movb %ah, -32(%esp)
# emit-expr (string-ref f259414 f259415)
# emit-expr f259414
# emit-variable-ref
# env=((f259415 . -28) (f259414 . -24) (f259413 . -20) (f259415 . -16) (f259414 . -12) (f259413 . -8) (f259392 . -12) (f259393 . -8) (f259394 . -4) (f259395 . 0))
# var=f259414
    movl -24(%esp), %eax  # stack load f259414
# end emit-variable-ref
# check the argument is a string
    movl %eax,%ebx
    and $7, %bl
    cmp $6, %bl
    je _L_1576090
# invoke error handler eh_string
    .extern mrc_eh$ustring
    movl mrc_eh$ustring, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $156,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1576090:
    movl %eax, -36(%esp)
# emit-expr f259415
# emit-variable-ref
# env=((f259415 . -28) (f259414 . -24) (f259413 . -20) (f259415 . -16) (f259414 . -12) (f259413 . -8) (f259392 . -12) (f259393 . -8) (f259394 . -4) (f259395 . 0))
# var=f259415
    movl -28(%esp), %eax  # stack load f259415
# end emit-variable-ref
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1576091"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $156,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1576091:
# check bounds on string index
    movl -36(%esp), %ebx
    cmp  %eax,-6(%ebx) 
    jle _L_1576093
    cmp  $0,%eax
    jge _L_1576092
_L_1576093:
# invoke error handler eh_string_index
    .extern mrc_eh$ustring$uindex
    movl mrc_eh$ustring$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $156,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1576092:
    sar $2, %eax
    movl -36(%esp), %esi
    movl -2(%eax,%esi), %eax
    sal $8, %eax
    or  $15, %eax
# check the argument is a char
    movl %eax,%ebx
    and $255, %bl
    cmp $15, %bl
    je "_L_1576094"
# invoke error handler eh_character
    .extern mrc_eh$ucharacter
    movl mrc_eh$ucharacter, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $32,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1576094:
    cmp %ah, -32(%esp)
    sete %al
    movzbl %al, %eax
    sal $6, %al
    or $47, %al
#return from tail (char=? (string-ref f259413 f259415) (string-ref f259414 f259415))
    ret
    .align 4,0x90
_L_1576083:
    movl -16(%esp), %ebx
    movl -20(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin (vector-set! f259393 0 (closure (f259409 f259410 f259411 f259412) (f259394 f259393) (let ((f259409 f259409) (f259410 f259410) (f259411 f259411) (f259412 f259412)) (if (fx= f259411 f259412) #t (if ((vector-ref f259394 0) f259409 f259410 f259411) ((vector-ref f259393 0) f259409 f259410 (fx+ f259411 1) f259412) #f))))) (vector-set! f259392 0 (closure (f259407 f259408) (f259395 f259393) (let ((f259407 f259407) (f259408 f259408)) (if ((vector-ref f259395 0) f259407 f259408) ((vector-ref f259393 0) f259407 f259408 0 (string-length f259407)) #f)))))
# emit-begin
#   expr=(begin (vector-set! f259393 0 (closure (f259409 f259410 f259411 f259412) (f259394 f259393) (let ((f259409 f259409) (f259410 f259410) (f259411 f259411) (f259412 f259412)) (if (fx= f259411 f259412) #t (if ((vector-ref f259394 0) f259409 f259410 f259411) ((vector-ref f259393 0) f259409 f259410 (fx+ f259411 1) f259412) #f))))) (vector-set! f259392 0 (closure (f259407 f259408) (f259395 f259393) (let ((f259407 f259407) (f259408 f259408)) (if ((vector-ref f259395 0) f259407 f259408) ((vector-ref f259393 0) f259407 f259408 0 (string-length f259407)) #f)))))
#   env=((f259392 . -12) (f259393 . -8) (f259394 . -4) (f259395 . 0))
# emit-expr (vector-set! f259393 0 (closure (f259409 f259410 f259411 f259412) (f259394 f259393) (let ((f259409 f259409) (f259410 f259410) (f259411 f259411) (f259412 f259412)) (if (fx= f259411 f259412) #t (if ((vector-ref f259394 0) f259409 f259410 f259411) ((vector-ref f259393 0) f259409 f259410 (fx+ f259411 1) f259412) #f)))))
# emit-expr f259393
# emit-variable-ref
# env=((f259392 . -12) (f259393 . -8) (f259394 . -4) (f259395 . 0))
# var=f259393
    movl -8(%esp), %eax  # stack load f259393
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1576095
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1576095:
    movl %eax, -16(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1576096"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1576096:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1576098
    cmp  $0,%eax
    jge _L_1576097
_L_1576098:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1576097:
    movl %eax, -20(%esp)
# emit-expr (closure (f259409 f259410 f259411 f259412) (f259394 f259393) (let ((f259409 f259409) (f259410 f259410) (f259411 f259411) (f259412 f259412)) (if (fx= f259411 f259412) #t (if ((vector-ref f259394 0) f259409 f259410 f259411) ((vector-ref f259393 0) f259409 f259410 (fx+ f259411 1) f259412) #f))))
# emit-closure
# si = -24
# env = ((f259392 . -12) (f259393 . -8) (f259394 . -4) (f259395 . 0))
# expr = (closure (f259409 f259410 f259411 f259412) (f259394 f259393) (let ((f259409 f259409) (f259410 f259410) (f259411 f259411) (f259412 f259412)) (if (fx= f259411 f259412) #t (if ((vector-ref f259394 0) f259409 f259410 f259411) ((vector-ref f259393 0) f259409 f259410 (fx+ f259411 1) f259412) #f))))
    movl $_L_1576099, 0(%ebp)  # closure label
# emit-variable-ref
# env=((f259392 . -12) (f259393 . -8) (f259394 . -4) (f259395 . 0))
# var=f259394
    movl -4(%esp), %eax  # stack load f259394
# end emit-variable-ref
   movl  %eax, 4(%ebp)  # f259394
# emit-variable-ref
# env=((f259392 . -12) (f259393 . -8) (f259394 . -4) (f259395 . 0))
# var=f259393
    movl -8(%esp), %eax  # stack load f259393
# end emit-variable-ref
   movl  %eax, 8(%ebp)  # f259393
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $16, %ebp     # bump ebp
    jmp _L_1576100            # jump around closure body
_L_1576099:
# check argument count
    cmp $16,%eax
    je _L_1576101
# invoke error handler eh_argcount
    .extern mrc_eh$uargcount
    movl mrc_eh$uargcount, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_1576101:
# emit-tail-expr
# si=-24
# env=((f259412 . -20) (f259411 . -16) (f259410 . -12) (f259409 . -8) (f259393 . 8) (f259394 . 4) (f259392 . -12) (f259393 . -8) (f259394 . -4) (f259395 . 0))
# expr=(let ((f259409 f259409) (f259410 f259410) (f259411 f259411) (f259412 f259412)) (if (fx= f259411 f259412) #t (if ((vector-ref f259394 0) f259409 f259410 f259411) ((vector-ref f259393 0) f259409 f259410 (fx+ f259411 1) f259412) #f)))
# emit-tail-let
#  si   = -24
#  env  = ((f259412 . -20) (f259411 . -16) (f259410 . -12) (f259409 . -8) (f259393 . 8) (f259394 . 4) (f259392 . -12) (f259393 . -8) (f259394 . -4) (f259395 . 0))
#  bindings = ((f259409 f259409) (f259410 f259410) (f259411 f259411) (f259412 f259412))
#  body = (if (fx= f259411 f259412) #t (if ((vector-ref f259394 0) f259409 f259410 f259411) ((vector-ref f259393 0) f259409 f259410 (fx+ f259411 1) f259412) #f))
# emit-expr f259409
# emit-variable-ref
# env=((f259412 . -20) (f259411 . -16) (f259410 . -12) (f259409 . -8) (f259393 . 8) (f259394 . 4) (f259392 . -12) (f259393 . -8) (f259394 . -4) (f259395 . 0))
# var=f259409
    movl -8(%esp), %eax  # stack load f259409
# end emit-variable-ref
    movl %eax, -24(%esp)  # stack save
# emit-expr f259410
# emit-variable-ref
# env=((f259412 . -20) (f259411 . -16) (f259410 . -12) (f259409 . -8) (f259393 . 8) (f259394 . 4) (f259392 . -12) (f259393 . -8) (f259394 . -4) (f259395 . 0))
# var=f259410
    movl -12(%esp), %eax  # stack load f259410
# end emit-variable-ref
    movl %eax, -28(%esp)  # stack save
# emit-expr f259411
# emit-variable-ref
# env=((f259412 . -20) (f259411 . -16) (f259410 . -12) (f259409 . -8) (f259393 . 8) (f259394 . 4) (f259392 . -12) (f259393 . -8) (f259394 . -4) (f259395 . 0))
# var=f259411
    movl -16(%esp), %eax  # stack load f259411
# end emit-variable-ref
    movl %eax, -32(%esp)  # stack save
# emit-expr f259412
# emit-variable-ref
# env=((f259412 . -20) (f259411 . -16) (f259410 . -12) (f259409 . -8) (f259393 . 8) (f259394 . 4) (f259392 . -12) (f259393 . -8) (f259394 . -4) (f259395 . 0))
# var=f259412
    movl -20(%esp), %eax  # stack load f259412
# end emit-variable-ref
    movl %eax, -36(%esp)  # stack save
# emit-tail-expr
# si=-40
# env=((f259412 . -36) (f259411 . -32) (f259410 . -28) (f259409 . -24) (f259412 . -20) (f259411 . -16) (f259410 . -12) (f259409 . -8) (f259393 . 8) (f259394 . 4) (f259392 . -12) (f259393 . -8) (f259394 . -4) (f259395 . 0))
# expr=(if (fx= f259411 f259412) #t (if ((vector-ref f259394 0) f259409 f259410 f259411) ((vector-ref f259393 0) f259409 f259410 (fx+ f259411 1) f259412) #f))
# emit-expr (fx= f259411 f259412)
# emit-expr f259412
# emit-variable-ref
# env=((f259412 . -36) (f259411 . -32) (f259410 . -28) (f259409 . -24) (f259412 . -20) (f259411 . -16) (f259410 . -12) (f259409 . -8) (f259393 . 8) (f259394 . 4) (f259392 . -12) (f259393 . -8) (f259394 . -4) (f259395 . 0))
# var=f259412
    movl -36(%esp), %eax  # stack load f259412
# end emit-variable-ref
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1576104"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $60,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1576104:
    movl %eax, -40(%esp)
# emit-expr f259411
# emit-variable-ref
# env=((f259412 . -36) (f259411 . -32) (f259410 . -28) (f259409 . -24) (f259412 . -20) (f259411 . -16) (f259410 . -12) (f259409 . -8) (f259393 . 8) (f259394 . 4) (f259392 . -12) (f259393 . -8) (f259394 . -4) (f259395 . 0))
# var=f259411
    movl -32(%esp), %eax  # stack load f259411
# end emit-variable-ref
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1576105"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $60,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1576105:
    cmp -40(%esp), %eax
    sete %al
    movzbl %al, %eax
    sal $6, %al
    or $47, %al
    cmp $47, %al
    je _L_1576102
# emit-tail-expr
# si=-40
# env=((f259412 . -36) (f259411 . -32) (f259410 . -28) (f259409 . -24) (f259412 . -20) (f259411 . -16) (f259410 . -12) (f259409 . -8) (f259393 . 8) (f259394 . 4) (f259392 . -12) (f259393 . -8) (f259394 . -4) (f259395 . 0))
# expr=#t
    movl $111, %eax     # immed #t
    ret                  # immediate tail return
    jmp _L_1576103
_L_1576102:
# emit-tail-expr
# si=-40
# env=((f259412 . -36) (f259411 . -32) (f259410 . -28) (f259409 . -24) (f259412 . -20) (f259411 . -16) (f259410 . -12) (f259409 . -8) (f259393 . 8) (f259394 . 4) (f259392 . -12) (f259393 . -8) (f259394 . -4) (f259395 . 0))
# expr=(if ((vector-ref f259394 0) f259409 f259410 f259411) ((vector-ref f259393 0) f259409 f259410 (fx+ f259411 1) f259412) #f)
# emit-expr ((vector-ref f259394 0) f259409 f259410 f259411)
# funcall
#    si   =-40
#    env  = ((f259412 . -36) (f259411 . -32) (f259410 . -28) (f259409 . -24) (f259412 . -20) (f259411 . -16) (f259410 . -12) (f259409 . -8) (f259393 . 8) (f259394 . 4) (f259392 . -12) (f259393 . -8) (f259394 . -4) (f259395 . 0))
#    expr = (funcall (vector-ref f259394 0) f259409 f259410 f259411)
# emit-expr (vector-ref f259394 0)
# emit-expr f259394
# emit-variable-ref
# env=((f259412 . -36) (f259411 . -32) (f259410 . -28) (f259409 . -24) (f259412 . -20) (f259411 . -16) (f259410 . -12) (f259409 . -8) (f259393 . 8) (f259394 . 4) (f259392 . -12) (f259393 . -8) (f259394 . -4) (f259395 . 0))
# var=f259394
    movl 2(%edi), %eax  # frame load f259394
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1576108
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1576108:
    movl %eax, -48(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1576109"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1576109:
# check bounds on vector index
    movl -48(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1576111
    cmp  $0,%eax
    jge _L_1576110
_L_1576111:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1576110:
    movl -48(%esp), %esi
    movl -1(%eax,%esi), %eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1576112"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1576112":
   movl %eax,  -48(%esp)  # stash funcall-oper in closure slot
# emit-expr f259409
# emit-variable-ref
# env=((f259412 . -36) (f259411 . -32) (f259410 . -28) (f259409 . -24) (f259412 . -20) (f259411 . -16) (f259410 . -12) (f259409 . -8) (f259393 . 8) (f259394 . 4) (f259392 . -12) (f259393 . -8) (f259394 . -4) (f259395 . 0))
# var=f259409
    movl -24(%esp), %eax  # stack load f259409
# end emit-variable-ref
    mov %eax, -52(%esp)  # arg f259409
# emit-expr f259410
# emit-variable-ref
# env=((f259412 . -36) (f259411 . -32) (f259410 . -28) (f259409 . -24) (f259412 . -20) (f259411 . -16) (f259410 . -12) (f259409 . -8) (f259393 . 8) (f259394 . 4) (f259392 . -12) (f259393 . -8) (f259394 . -4) (f259395 . 0))
# var=f259410
    movl -28(%esp), %eax  # stack load f259410
# end emit-variable-ref
    mov %eax, -56(%esp)  # arg f259410
# emit-expr f259411
# emit-variable-ref
# env=((f259412 . -36) (f259411 . -32) (f259410 . -28) (f259409 . -24) (f259412 . -20) (f259411 . -16) (f259410 . -12) (f259409 . -8) (f259393 . 8) (f259394 . 4) (f259392 . -12) (f259393 . -8) (f259394 . -4) (f259395 . 0))
# var=f259411
    movl -32(%esp), %eax  # stack load f259411
# end emit-variable-ref
    mov %eax, -60(%esp)  # arg f259411
    movl -48(%esp), %edi   # load new closure to %edi
    add $-40, %esp   # adjust base
    movl $12,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $40, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    cmp $47, %al
    je _L_1576106
# emit-tail-expr
# si=-40
# env=((f259412 . -36) (f259411 . -32) (f259410 . -28) (f259409 . -24) (f259412 . -20) (f259411 . -16) (f259410 . -12) (f259409 . -8) (f259393 . 8) (f259394 . 4) (f259392 . -12) (f259393 . -8) (f259394 . -4) (f259395 . 0))
# expr=((vector-ref f259393 0) f259409 f259410 (fx+ f259411 1) f259412)
# emit-tail-funcall
#    si   =-40
#    env  = ((f259412 . -36) (f259411 . -32) (f259410 . -28) (f259409 . -24) (f259412 . -20) (f259411 . -16) (f259410 . -12) (f259409 . -8) (f259393 . 8) (f259394 . 4) (f259392 . -12) (f259393 . -8) (f259394 . -4) (f259395 . 0))
#    expr = (funcall (vector-ref f259393 0) f259409 f259410 (fx+ f259411 1) f259412)
# emit-expr (vector-ref f259393 0)
# emit-expr f259393
# emit-variable-ref
# env=((f259412 . -36) (f259411 . -32) (f259410 . -28) (f259409 . -24) (f259412 . -20) (f259411 . -16) (f259410 . -12) (f259409 . -8) (f259393 . 8) (f259394 . 4) (f259392 . -12) (f259393 . -8) (f259394 . -4) (f259395 . 0))
# var=f259393
    movl 6(%edi), %eax  # frame load f259393
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1576113
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1576113:
    movl %eax, -40(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1576114"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1576114:
# check bounds on vector index
    movl -40(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1576116
    cmp  $0,%eax
    jge _L_1576115
_L_1576116:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1576115:
    movl -40(%esp), %esi
    movl -1(%eax,%esi), %eax
   movl %eax,  -40(%esp)  # stash funcall-oper in next closure slot
# emit-expr f259409
# emit-variable-ref
# env=((f259412 . -36) (f259411 . -32) (f259410 . -28) (f259409 . -24) (f259412 . -20) (f259411 . -16) (f259410 . -12) (f259409 . -8) (f259393 . 8) (f259394 . 4) (f259392 . -12) (f259393 . -8) (f259394 . -4) (f259395 . 0))
# var=f259409
    movl -24(%esp), %eax  # stack load f259409
# end emit-variable-ref
    mov %eax, -44(%esp)    # arg f259409
# emit-expr f259410
# emit-variable-ref
# env=((f259412 . -36) (f259411 . -32) (f259410 . -28) (f259409 . -24) (f259412 . -20) (f259411 . -16) (f259410 . -12) (f259409 . -8) (f259393 . 8) (f259394 . 4) (f259392 . -12) (f259393 . -8) (f259394 . -4) (f259395 . 0))
# var=f259410
    movl -28(%esp), %eax  # stack load f259410
# end emit-variable-ref
    mov %eax, -48(%esp)    # arg f259410
# emit-expr (fx+ f259411 1)
# emit-expr 1
    movl $4, %eax     # immed 1
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1576117"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $80,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1576117:
    movl %eax, -52(%esp)  # fx+ push arg1
# emit-expr f259411
# emit-variable-ref
# env=((f259412 . -36) (f259411 . -32) (f259410 . -28) (f259409 . -24) (f259412 . -20) (f259411 . -16) (f259410 . -12) (f259409 . -8) (f259393 . 8) (f259394 . 4) (f259392 . -12) (f259393 . -8) (f259394 . -4) (f259395 . 0))
# var=f259411
    movl -32(%esp), %eax  # stack load f259411
# end emit-variable-ref
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1576118"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $80,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1576118:
    addl -52(%esp), %eax  # fx+ arg1 arg2
    mov %eax, -52(%esp)    # arg (fx+ f259411 1)
# emit-expr f259412
# emit-variable-ref
# env=((f259412 . -36) (f259411 . -32) (f259410 . -28) (f259409 . -24) (f259412 . -20) (f259411 . -16) (f259410 . -12) (f259409 . -8) (f259393 . 8) (f259394 . 4) (f259392 . -12) (f259393 . -8) (f259394 . -4) (f259395 . 0))
# var=f259412
    movl -36(%esp), %eax  # stack load f259412
# end emit-variable-ref
    mov %eax, -56(%esp)    # arg f259412
    movl -40(%esp), %edi   # load new closure to %edi
# emit-shift-args:  size=5   si=-40  delta=36
    mov -40(%esp), %ebx  # shift frame cell
    mov %ebx, -4(%esp)  # down to base
# emit-shift-args:  size=4   si=-44  delta=36
    mov -44(%esp), %ebx  # shift frame cell
    mov %ebx, -8(%esp)  # down to base
# emit-shift-args:  size=3   si=-48  delta=36
    mov -48(%esp), %ebx  # shift frame cell
    mov %ebx, -12(%esp)  # down to base
# emit-shift-args:  size=2   si=-52  delta=36
    mov -52(%esp), %ebx  # shift frame cell
    mov %ebx, -16(%esp)  # down to base
# emit-shift-args:  size=1   si=-56  delta=36
    mov -56(%esp), %ebx  # shift frame cell
    mov %ebx, -20(%esp)  # down to base
# emit-shift-args:  size=0   si=-60  delta=36
    movl $16,%eax   # save arg count
    jmp *-2(%edi)  # tail-funcall
    jmp _L_1576107
_L_1576106:
# emit-tail-expr
# si=-40
# env=((f259412 . -36) (f259411 . -32) (f259410 . -28) (f259409 . -24) (f259412 . -20) (f259411 . -16) (f259410 . -12) (f259409 . -8) (f259393 . 8) (f259394 . 4) (f259392 . -12) (f259393 . -8) (f259394 . -4) (f259395 . 0))
# expr=#f
    movl $47, %eax     # immed #f
    ret                  # immediate tail return
_L_1576107:
_L_1576103:
    .align 4,0x90
_L_1576100:
    movl -16(%esp), %ebx
    movl -20(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin (vector-set! f259392 0 (closure (f259407 f259408) (f259395 f259393) (let ((f259407 f259407) (f259408 f259408)) (if ((vector-ref f259395 0) f259407 f259408) ((vector-ref f259393 0) f259407 f259408 0 (string-length f259407)) #f)))))
# emit-begin
#   expr=(begin (vector-set! f259392 0 (closure (f259407 f259408) (f259395 f259393) (let ((f259407 f259407) (f259408 f259408)) (if ((vector-ref f259395 0) f259407 f259408) ((vector-ref f259393 0) f259407 f259408 0 (string-length f259407)) #f)))))
#   env=((f259392 . -12) (f259393 . -8) (f259394 . -4) (f259395 . 0))
# emit-expr (vector-set! f259392 0 (closure (f259407 f259408) (f259395 f259393) (let ((f259407 f259407) (f259408 f259408)) (if ((vector-ref f259395 0) f259407 f259408) ((vector-ref f259393 0) f259407 f259408 0 (string-length f259407)) #f))))
# emit-expr f259392
# emit-variable-ref
# env=((f259392 . -12) (f259393 . -8) (f259394 . -4) (f259395 . 0))
# var=f259392
    movl -12(%esp), %eax  # stack load f259392
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1576119
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1576119:
    movl %eax, -16(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1576120"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1576120:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1576122
    cmp  $0,%eax
    jge _L_1576121
_L_1576122:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1576121:
    movl %eax, -20(%esp)
# emit-expr (closure (f259407 f259408) (f259395 f259393) (let ((f259407 f259407) (f259408 f259408)) (if ((vector-ref f259395 0) f259407 f259408) ((vector-ref f259393 0) f259407 f259408 0 (string-length f259407)) #f)))
# emit-closure
# si = -24
# env = ((f259392 . -12) (f259393 . -8) (f259394 . -4) (f259395 . 0))
# expr = (closure (f259407 f259408) (f259395 f259393) (let ((f259407 f259407) (f259408 f259408)) (if ((vector-ref f259395 0) f259407 f259408) ((vector-ref f259393 0) f259407 f259408 0 (string-length f259407)) #f)))
    movl $_L_1576123, 0(%ebp)  # closure label
# emit-variable-ref
# env=((f259392 . -12) (f259393 . -8) (f259394 . -4) (f259395 . 0))
# var=f259395
    movl 0(%esp), %eax  # stack load f259395
# end emit-variable-ref
   movl  %eax, 4(%ebp)  # f259395
# emit-variable-ref
# env=((f259392 . -12) (f259393 . -8) (f259394 . -4) (f259395 . 0))
# var=f259393
    movl -8(%esp), %eax  # stack load f259393
# end emit-variable-ref
   movl  %eax, 8(%ebp)  # f259393
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $16, %ebp     # bump ebp
    jmp _L_1576124            # jump around closure body
_L_1576123:
# check argument count
    cmp $8,%eax
    je _L_1576125
# invoke error handler eh_argcount
    .extern mrc_eh$uargcount
    movl mrc_eh$uargcount, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_1576125:
# emit-tail-expr
# si=-16
# env=((f259408 . -12) (f259407 . -8) (f259393 . 8) (f259395 . 4) (f259392 . -12) (f259393 . -8) (f259394 . -4) (f259395 . 0))
# expr=(let ((f259407 f259407) (f259408 f259408)) (if ((vector-ref f259395 0) f259407 f259408) ((vector-ref f259393 0) f259407 f259408 0 (string-length f259407)) #f))
# emit-tail-let
#  si   = -16
#  env  = ((f259408 . -12) (f259407 . -8) (f259393 . 8) (f259395 . 4) (f259392 . -12) (f259393 . -8) (f259394 . -4) (f259395 . 0))
#  bindings = ((f259407 f259407) (f259408 f259408))
#  body = (if ((vector-ref f259395 0) f259407 f259408) ((vector-ref f259393 0) f259407 f259408 0 (string-length f259407)) #f)
# emit-expr f259407
# emit-variable-ref
# env=((f259408 . -12) (f259407 . -8) (f259393 . 8) (f259395 . 4) (f259392 . -12) (f259393 . -8) (f259394 . -4) (f259395 . 0))
# var=f259407
    movl -8(%esp), %eax  # stack load f259407
# end emit-variable-ref
    movl %eax, -16(%esp)  # stack save
# emit-expr f259408
# emit-variable-ref
# env=((f259408 . -12) (f259407 . -8) (f259393 . 8) (f259395 . 4) (f259392 . -12) (f259393 . -8) (f259394 . -4) (f259395 . 0))
# var=f259408
    movl -12(%esp), %eax  # stack load f259408
# end emit-variable-ref
    movl %eax, -20(%esp)  # stack save
# emit-tail-expr
# si=-24
# env=((f259408 . -20) (f259407 . -16) (f259408 . -12) (f259407 . -8) (f259393 . 8) (f259395 . 4) (f259392 . -12) (f259393 . -8) (f259394 . -4) (f259395 . 0))
# expr=(if ((vector-ref f259395 0) f259407 f259408) ((vector-ref f259393 0) f259407 f259408 0 (string-length f259407)) #f)
# emit-expr ((vector-ref f259395 0) f259407 f259408)
# funcall
#    si   =-24
#    env  = ((f259408 . -20) (f259407 . -16) (f259408 . -12) (f259407 . -8) (f259393 . 8) (f259395 . 4) (f259392 . -12) (f259393 . -8) (f259394 . -4) (f259395 . 0))
#    expr = (funcall (vector-ref f259395 0) f259407 f259408)
# emit-expr (vector-ref f259395 0)
# emit-expr f259395
# emit-variable-ref
# env=((f259408 . -20) (f259407 . -16) (f259408 . -12) (f259407 . -8) (f259393 . 8) (f259395 . 4) (f259392 . -12) (f259393 . -8) (f259394 . -4) (f259395 . 0))
# var=f259395
    movl 2(%edi), %eax  # frame load f259395
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1576128
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1576128:
    movl %eax, -32(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1576129"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1576129:
# check bounds on vector index
    movl -32(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1576131
    cmp  $0,%eax
    jge _L_1576130
_L_1576131:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1576130:
    movl -32(%esp), %esi
    movl -1(%eax,%esi), %eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1576132"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1576132":
   movl %eax,  -32(%esp)  # stash funcall-oper in closure slot
# emit-expr f259407
# emit-variable-ref
# env=((f259408 . -20) (f259407 . -16) (f259408 . -12) (f259407 . -8) (f259393 . 8) (f259395 . 4) (f259392 . -12) (f259393 . -8) (f259394 . -4) (f259395 . 0))
# var=f259407
    movl -16(%esp), %eax  # stack load f259407
# end emit-variable-ref
    mov %eax, -36(%esp)  # arg f259407
# emit-expr f259408
# emit-variable-ref
# env=((f259408 . -20) (f259407 . -16) (f259408 . -12) (f259407 . -8) (f259393 . 8) (f259395 . 4) (f259392 . -12) (f259393 . -8) (f259394 . -4) (f259395 . 0))
# var=f259408
    movl -20(%esp), %eax  # stack load f259408
# end emit-variable-ref
    mov %eax, -40(%esp)  # arg f259408
    movl -32(%esp), %edi   # load new closure to %edi
    add $-24, %esp   # adjust base
    movl $8,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $24, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    cmp $47, %al
    je _L_1576126
# emit-tail-expr
# si=-24
# env=((f259408 . -20) (f259407 . -16) (f259408 . -12) (f259407 . -8) (f259393 . 8) (f259395 . 4) (f259392 . -12) (f259393 . -8) (f259394 . -4) (f259395 . 0))
# expr=((vector-ref f259393 0) f259407 f259408 0 (string-length f259407))
# emit-tail-funcall
#    si   =-24
#    env  = ((f259408 . -20) (f259407 . -16) (f259408 . -12) (f259407 . -8) (f259393 . 8) (f259395 . 4) (f259392 . -12) (f259393 . -8) (f259394 . -4) (f259395 . 0))
#    expr = (funcall (vector-ref f259393 0) f259407 f259408 0 (string-length f259407))
# emit-expr (vector-ref f259393 0)
# emit-expr f259393
# emit-variable-ref
# env=((f259408 . -20) (f259407 . -16) (f259408 . -12) (f259407 . -8) (f259393 . 8) (f259395 . 4) (f259392 . -12) (f259393 . -8) (f259394 . -4) (f259395 . 0))
# var=f259393
    movl 6(%edi), %eax  # frame load f259393
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1576133
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1576133:
    movl %eax, -24(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1576134"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1576134:
# check bounds on vector index
    movl -24(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1576136
    cmp  $0,%eax
    jge _L_1576135
_L_1576136:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1576135:
    movl -24(%esp), %esi
    movl -1(%eax,%esi), %eax
   movl %eax,  -24(%esp)  # stash funcall-oper in next closure slot
# emit-expr f259407
# emit-variable-ref
# env=((f259408 . -20) (f259407 . -16) (f259408 . -12) (f259407 . -8) (f259393 . 8) (f259395 . 4) (f259392 . -12) (f259393 . -8) (f259394 . -4) (f259395 . 0))
# var=f259407
    movl -16(%esp), %eax  # stack load f259407
# end emit-variable-ref
    mov %eax, -28(%esp)    # arg f259407
# emit-expr f259408
# emit-variable-ref
# env=((f259408 . -20) (f259407 . -16) (f259408 . -12) (f259407 . -8) (f259393 . 8) (f259395 . 4) (f259392 . -12) (f259393 . -8) (f259394 . -4) (f259395 . 0))
# var=f259408
    movl -20(%esp), %eax  # stack load f259408
# end emit-variable-ref
    mov %eax, -32(%esp)    # arg f259408
# emit-expr 0
    movl $0, %eax     # immed 0
    mov %eax, -36(%esp)    # arg 0
# emit-expr (string-length f259407)
# emit-expr f259407
# emit-variable-ref
# env=((f259408 . -20) (f259407 . -16) (f259408 . -12) (f259407 . -8) (f259393 . 8) (f259395 . 4) (f259392 . -12) (f259393 . -8) (f259394 . -4) (f259395 . 0))
# var=f259407
    movl -16(%esp), %eax  # stack load f259407
# end emit-variable-ref
# check the argument is a string
    movl %eax,%ebx
    and $7, %bl
    cmp $6, %bl
    je _L_1576137
# invoke error handler eh_string
    .extern mrc_eh$ustring
    movl mrc_eh$ustring, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $152,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1576137:
    movl -6(%eax), %eax
    mov %eax, -40(%esp)    # arg (string-length f259407)
    movl -24(%esp), %edi   # load new closure to %edi
# emit-shift-args:  size=5   si=-24  delta=20
    mov -24(%esp), %ebx  # shift frame cell
    mov %ebx, -4(%esp)  # down to base
# emit-shift-args:  size=4   si=-28  delta=20
    mov -28(%esp), %ebx  # shift frame cell
    mov %ebx, -8(%esp)  # down to base
# emit-shift-args:  size=3   si=-32  delta=20
    mov -32(%esp), %ebx  # shift frame cell
    mov %ebx, -12(%esp)  # down to base
# emit-shift-args:  size=2   si=-36  delta=20
    mov -36(%esp), %ebx  # shift frame cell
    mov %ebx, -16(%esp)  # down to base
# emit-shift-args:  size=1   si=-40  delta=20
    mov -40(%esp), %ebx  # shift frame cell
    mov %ebx, -20(%esp)  # down to base
# emit-shift-args:  size=0   si=-44  delta=20
    movl $16,%eax   # save arg count
    jmp *-2(%edi)  # tail-funcall
    jmp _L_1576127
_L_1576126:
# emit-tail-expr
# si=-24
# env=((f259408 . -20) (f259407 . -16) (f259408 . -12) (f259407 . -8) (f259393 . 8) (f259395 . 4) (f259392 . -12) (f259393 . -8) (f259394 . -4) (f259395 . 0))
# expr=#f
    movl $47, %eax     # immed #f
    ret                  # immediate tail return
_L_1576127:
    .align 4,0x90
_L_1576124:
    movl -16(%esp), %ebx
    movl -20(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin)
# emit-begin
#   expr=(begin)
#   env=((f259392 . -12) (f259393 . -8) (f259394 . -4) (f259395 . 0))
# emit-expr (begin (vector-ref f259392 0))
# emit-begin
#   expr=(begin (vector-ref f259392 0))
#   env=((f259392 . -12) (f259393 . -8) (f259394 . -4) (f259395 . 0))
# emit-expr (vector-ref f259392 0)
# emit-expr f259392
# emit-variable-ref
# env=((f259392 . -12) (f259393 . -8) (f259394 . -4) (f259395 . 0))
# var=f259392
    movl -12(%esp), %eax  # stack load f259392
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1576138
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1576138:
    movl %eax, -16(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1576139"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1576139:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1576141
    cmp  $0,%eax
    jge _L_1576140
_L_1576141:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1576140:
    movl -16(%esp), %esi
    movl -1(%eax,%esi), %eax
# emit-expr (begin)
# emit-begin
#   expr=(begin)
#   env=((f259392 . -12) (f259393 . -8) (f259394 . -4) (f259395 . 0))
     movl %eax, mrc_string$e$q
# == explicit-begins  ==>
# (letrec ((str->sym (lambda (str symlist) (if (string=? str (symbol->string (car symlist))) (car symlist) (if (null? (cdr symlist)) (let* ((new-sym (make-symbol str #f)) (new-cdr (cons new-sym ()))) (begin (set-cdr! symlist new-cdr) new-sym)) (str->sym str (cdr symlist))))))) (lambda (str) (str->sym str (symbols))))
# == eliminate-let*  ==>
# (letrec ((str->sym (lambda (str symlist) (if (string=? str (symbol->string (car symlist))) (car symlist) (if (null? (cdr symlist)) (let ((new-sym (make-symbol str #f))) (let ((new-cdr (cons new-sym ()))) (begin (set-cdr! symlist new-cdr) new-sym))) (str->sym str (cdr symlist))))))) (lambda (str) (str->sym str (symbols))))
# == uniquify-variables  ==>
# (letrec ((f259418 (lambda (f259427 f259428) (if (string=? f259427 (symbol->string (car f259428))) (car f259428) (if (null? (cdr f259428)) (let ((f259432 (make-symbol f259427 #f))) (let ((f259434 (cons f259432 ()))) (begin (set-cdr! f259428 f259434) f259432))) (f259418 f259427 (cdr f259428))))))) (lambda (f259436) (f259418 f259436 (symbols))))
# == vectorize-letrec  ==>
# (let ((f259418 (make-vector 1))) (begin (begin (vector-set! f259418 0 (lambda (f259427 f259428) (if (string=? f259427 (symbol->string (car f259428))) (car f259428) (if (null? (cdr f259428)) (let ((f259432 (make-symbol f259427 #f))) (let ((f259434 (cons f259432 ()))) (begin (set-cdr! f259428 f259434) f259432))) ((vector-ref f259418 0) f259427 (cdr f259428))))))) (lambda (f259436) ((vector-ref f259418 0) f259436 (symbols)))))
# == eliminate-set!  ==>
# (let ((f259418 (make-vector 1))) (begin (begin (vector-set! f259418 0 (lambda (f259427 f259428) (let ((f259427 f259427) (f259428 f259428)) (if (string=? f259427 (symbol->string (car f259428))) (car f259428) (if (null? (cdr f259428)) (let ((f259432 (make-symbol f259427 #f))) (let ((f259434 (cons f259432 ()))) (begin (set-cdr! f259428 f259434) f259432))) ((vector-ref f259418 0) f259427 (cdr f259428)))))))) (lambda (f259436) (let ((f259436 f259436)) ((vector-ref f259418 0) f259436 (symbols))))))
# == close-free-variables  ==>
# (let ((f259418 (make-vector 1))) (begin (begin (vector-set! f259418 0 (closure (f259427 f259428) (string=? f259418) (let ((f259427 f259427) (f259428 f259428)) (if (string=? f259427 (symbol->string (car f259428))) (car f259428) (if (null? (cdr f259428)) (let ((f259432 (make-symbol f259427 #f))) (let ((f259434 (cons f259432 ()))) (begin (set-cdr! f259428 f259434) f259432))) ((vector-ref f259418 0) f259427 (cdr f259428)))))))) (closure (f259436) (f259418 symbols) (let ((f259436 f259436)) ((vector-ref f259418 0) f259436 (symbols))))))
# == eliminate-quote  ==>
# (let ((f259418 (make-vector 1))) (begin (begin (vector-set! f259418 0 (closure (f259427 f259428) (string=? f259418) (let ((f259427 f259427) (f259428 f259428)) (if (string=? f259427 (symbol->string (car f259428))) (car f259428) (if (null? (cdr f259428)) (let ((f259432 (make-symbol f259427 #f))) (let ((f259434 (cons f259432 ()))) (begin (set-cdr! f259428 f259434) f259432))) ((vector-ref f259418 0) f259427 (cdr f259428)))))))) (closure (f259436) (f259418 symbols) (let ((f259436 f259436)) ((vector-ref f259418 0) f259436 (symbols))))))
# == eliminate-when/unless  ==>
# (let ((f259418 (make-vector 1))) (begin (begin (vector-set! f259418 0 (closure (f259427 f259428) (string=? f259418) (let ((f259427 f259427) (f259428 f259428)) (if (string=? f259427 (symbol->string (car f259428))) (car f259428) (if (null? (cdr f259428)) (let ((f259432 (make-symbol f259427 #f))) (let ((f259434 (cons f259432 ()))) (begin (set-cdr! f259428 f259434) f259432))) ((vector-ref f259418 0) f259427 (cdr f259428)))))))) (closure (f259436) (f259418 symbols) (let ((f259436 f259436)) ((vector-ref f259418 0) f259436 (symbols))))))
# == eliminate-cond  ==>
# (let ((f259418 (make-vector 1))) (begin (begin (vector-set! f259418 0 (closure (f259427 f259428) (string=? f259418) (let ((f259427 f259427) (f259428 f259428)) (if (string=? f259427 (symbol->string (car f259428))) (car f259428) (if (null? (cdr f259428)) (let ((f259432 (make-symbol f259427 #f))) (let ((f259434 (cons f259432 ()))) (begin (set-cdr! f259428 f259434) f259432))) ((vector-ref f259418 0) f259427 (cdr f259428)))))))) (closure (f259436) (f259418 symbols) (let ((f259436 f259436)) ((vector-ref f259418 0) f259436 (symbols))))))
# == external-symbols  ==>
# (let ((f259418 (make-vector 1))) (begin (begin (vector-set! f259418 0 (closure (f259427 f259428) ((primitive-ref string=?) f259418) (let ((f259427 f259427) (f259428 f259428)) (if ((primitive-ref string=?) f259427 (symbol->string (car f259428))) (car f259428) (if (null? (cdr f259428)) (let ((f259432 (make-symbol f259427 #f))) (let ((f259434 (cons f259432 ()))) (begin (set-cdr! f259428 f259434) f259432))) ((vector-ref f259418 0) f259427 (cdr f259428)))))))) (closure (f259436) (f259418 (primitive-ref symbols)) (let ((f259436 f259436)) ((vector-ref f259418 0) f259436 ((primitive-ref symbols)))))))
# emit-expr (let ((f259418 (make-vector 1))) (begin (begin (vector-set! f259418 0 (closure (f259427 f259428) ((primitive-ref string=?) f259418) (let ((f259427 f259427) (f259428 f259428)) (if ((primitive-ref string=?) f259427 (symbol->string (car f259428))) (car f259428) (if (null? (cdr f259428)) (let ((f259432 (make-symbol f259427 #f))) (let ((f259434 (cons f259432 ()))) (begin (set-cdr! f259428 f259434) f259432))) ((vector-ref f259418 0) f259427 (cdr f259428)))))))) (closure (f259436) (f259418 (primitive-ref symbols)) (let ((f259436 f259436)) ((vector-ref f259418 0) f259436 ((primitive-ref symbols)))))))
# emit-let
#  si   = 0
#  env  = ()
#  bindings = ((f259418 (make-vector 1)))
#  body = (begin (begin (vector-set! f259418 0 (closure (f259427 f259428) ((primitive-ref string=?) f259418) (let ((f259427 f259427) (f259428 f259428)) (if ((primitive-ref string=?) f259427 (symbol->string (car f259428))) (car f259428) (if (null? (cdr f259428)) (let ((f259432 (make-symbol f259427 #f))) (let ((f259434 (cons f259432 ()))) (begin (set-cdr! f259428 f259434) f259432))) ((vector-ref f259418 0) f259427 (cdr f259428)))))))) (closure (f259436) (f259418 (primitive-ref symbols)) (let ((f259436 f259436)) ((vector-ref f259418 0) f259436 ((primitive-ref symbols))))))
# emit-expr (make-vector 1)
# make-vector 1
# emit-expr 1
    movl $4, %eax     # immed 1
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1576142"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $128,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1576142:
# check the argument is a fixnum >= 0
    cmp $0,%eax
    jge _L_1576143
# invoke error handler eh_length
    .extern mrc_eh$ulength
    movl mrc_eh$ulength, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $128,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1576143:
    movl %eax, %esi
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    orl  $5, %eax
    addl $4, %esi
    addl $4, %esi
    andl $-8, %esi
    addl %esi, %ebp
    movl %eax, 0(%esp)  # stack save
# emit-expr (begin (begin (vector-set! f259418 0 (closure (f259427 f259428) ((primitive-ref string=?) f259418) (let ((f259427 f259427) (f259428 f259428)) (if ((primitive-ref string=?) f259427 (symbol->string (car f259428))) (car f259428) (if (null? (cdr f259428)) (let ((f259432 (make-symbol f259427 #f))) (let ((f259434 (cons f259432 ()))) (begin (set-cdr! f259428 f259434) f259432))) ((vector-ref f259418 0) f259427 (cdr f259428)))))))) (closure (f259436) (f259418 (primitive-ref symbols)) (let ((f259436 f259436)) ((vector-ref f259418 0) f259436 ((primitive-ref symbols))))))
# emit-begin
#   expr=(begin (begin (vector-set! f259418 0 (closure (f259427 f259428) ((primitive-ref string=?) f259418) (let ((f259427 f259427) (f259428 f259428)) (if ((primitive-ref string=?) f259427 (symbol->string (car f259428))) (car f259428) (if (null? (cdr f259428)) (let ((f259432 (make-symbol f259427 #f))) (let ((f259434 (cons f259432 ()))) (begin (set-cdr! f259428 f259434) f259432))) ((vector-ref f259418 0) f259427 (cdr f259428)))))))) (closure (f259436) (f259418 (primitive-ref symbols)) (let ((f259436 f259436)) ((vector-ref f259418 0) f259436 ((primitive-ref symbols))))))
#   env=((f259418 . 0))
# emit-expr (begin (vector-set! f259418 0 (closure (f259427 f259428) ((primitive-ref string=?) f259418) (let ((f259427 f259427) (f259428 f259428)) (if ((primitive-ref string=?) f259427 (symbol->string (car f259428))) (car f259428) (if (null? (cdr f259428)) (let ((f259432 (make-symbol f259427 #f))) (let ((f259434 (cons f259432 ()))) (begin (set-cdr! f259428 f259434) f259432))) ((vector-ref f259418 0) f259427 (cdr f259428))))))))
# emit-begin
#   expr=(begin (vector-set! f259418 0 (closure (f259427 f259428) ((primitive-ref string=?) f259418) (let ((f259427 f259427) (f259428 f259428)) (if ((primitive-ref string=?) f259427 (symbol->string (car f259428))) (car f259428) (if (null? (cdr f259428)) (let ((f259432 (make-symbol f259427 #f))) (let ((f259434 (cons f259432 ()))) (begin (set-cdr! f259428 f259434) f259432))) ((vector-ref f259418 0) f259427 (cdr f259428))))))))
#   env=((f259418 . 0))
# emit-expr (vector-set! f259418 0 (closure (f259427 f259428) ((primitive-ref string=?) f259418) (let ((f259427 f259427) (f259428 f259428)) (if ((primitive-ref string=?) f259427 (symbol->string (car f259428))) (car f259428) (if (null? (cdr f259428)) (let ((f259432 (make-symbol f259427 #f))) (let ((f259434 (cons f259432 ()))) (begin (set-cdr! f259428 f259434) f259432))) ((vector-ref f259418 0) f259427 (cdr f259428)))))))
# emit-expr f259418
# emit-variable-ref
# env=((f259418 . 0))
# var=f259418
    movl 0(%esp), %eax  # stack load f259418
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1576144
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1576144:
    movl %eax, -4(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1576145"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1576145:
# check bounds on vector index
    movl -4(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1576147
    cmp  $0,%eax
    jge _L_1576146
_L_1576147:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1576146:
    movl %eax, -8(%esp)
# emit-expr (closure (f259427 f259428) ((primitive-ref string=?) f259418) (let ((f259427 f259427) (f259428 f259428)) (if ((primitive-ref string=?) f259427 (symbol->string (car f259428))) (car f259428) (if (null? (cdr f259428)) (let ((f259432 (make-symbol f259427 #f))) (let ((f259434 (cons f259432 ()))) (begin (set-cdr! f259428 f259434) f259432))) ((vector-ref f259418 0) f259427 (cdr f259428))))))
# emit-closure
# si = -12
# env = ((f259418 . 0))
# expr = (closure (f259427 f259428) ((primitive-ref string=?) f259418) (let ((f259427 f259427) (f259428 f259428)) (if ((primitive-ref string=?) f259427 (symbol->string (car f259428))) (car f259428) (if (null? (cdr f259428)) (let ((f259432 (make-symbol f259427 #f))) (let ((f259434 (cons f259432 ()))) (begin (set-cdr! f259428 f259434) f259432))) ((vector-ref f259418 0) f259427 (cdr f259428))))))
    movl $_L_1576148, 0(%ebp)  # closure label
# WARNING: free var (primitive-ref string=?) not defined in the environmnet
# emit-variable-ref
# env=((f259418 . 0))
# var=f259418
    movl 0(%esp), %eax  # stack load f259418
# end emit-variable-ref
   movl  %eax, 8(%ebp)  # f259418
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $16, %ebp     # bump ebp
    jmp _L_1576149            # jump around closure body
_L_1576148:
# check argument count
    cmp $8,%eax
    je _L_1576150
# invoke error handler eh_argcount
    .extern mrc_eh$uargcount
    movl mrc_eh$uargcount, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_1576150:
# emit-tail-expr
# si=-16
# env=((f259428 . -12) (f259427 . -8) (f259418 . 8) ((primitive-ref string=?) . 4) (f259418 . 0))
# expr=(let ((f259427 f259427) (f259428 f259428)) (if ((primitive-ref string=?) f259427 (symbol->string (car f259428))) (car f259428) (if (null? (cdr f259428)) (let ((f259432 (make-symbol f259427 #f))) (let ((f259434 (cons f259432 ()))) (begin (set-cdr! f259428 f259434) f259432))) ((vector-ref f259418 0) f259427 (cdr f259428)))))
# emit-tail-let
#  si   = -16
#  env  = ((f259428 . -12) (f259427 . -8) (f259418 . 8) ((primitive-ref string=?) . 4) (f259418 . 0))
#  bindings = ((f259427 f259427) (f259428 f259428))
#  body = (if ((primitive-ref string=?) f259427 (symbol->string (car f259428))) (car f259428) (if (null? (cdr f259428)) (let ((f259432 (make-symbol f259427 #f))) (let ((f259434 (cons f259432 ()))) (begin (set-cdr! f259428 f259434) f259432))) ((vector-ref f259418 0) f259427 (cdr f259428))))
# emit-expr f259427
# emit-variable-ref
# env=((f259428 . -12) (f259427 . -8) (f259418 . 8) ((primitive-ref string=?) . 4) (f259418 . 0))
# var=f259427
    movl -8(%esp), %eax  # stack load f259427
# end emit-variable-ref
    movl %eax, -16(%esp)  # stack save
# emit-expr f259428
# emit-variable-ref
# env=((f259428 . -12) (f259427 . -8) (f259418 . 8) ((primitive-ref string=?) . 4) (f259418 . 0))
# var=f259428
    movl -12(%esp), %eax  # stack load f259428
# end emit-variable-ref
    movl %eax, -20(%esp)  # stack save
# emit-tail-expr
# si=-24
# env=((f259428 . -20) (f259427 . -16) (f259428 . -12) (f259427 . -8) (f259418 . 8) ((primitive-ref string=?) . 4) (f259418 . 0))
# expr=(if ((primitive-ref string=?) f259427 (symbol->string (car f259428))) (car f259428) (if (null? (cdr f259428)) (let ((f259432 (make-symbol f259427 #f))) (let ((f259434 (cons f259432 ()))) (begin (set-cdr! f259428 f259434) f259432))) ((vector-ref f259418 0) f259427 (cdr f259428))))
# emit-expr ((primitive-ref string=?) f259427 (symbol->string (car f259428)))
# funcall
#    si   =-24
#    env  = ((f259428 . -20) (f259427 . -16) (f259428 . -12) (f259427 . -8) (f259418 . 8) ((primitive-ref string=?) . 4) (f259418 . 0))
#    expr = (funcall (primitive-ref string=?) f259427 (symbol->string (car f259428)))
# emit-expr (primitive-ref string=?)
    .extern mrc_string$e$q
    movl mrc_string$e$q,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1576153"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1576153":
   movl %eax,  -32(%esp)  # stash funcall-oper in closure slot
# emit-expr f259427
# emit-variable-ref
# env=((f259428 . -20) (f259427 . -16) (f259428 . -12) (f259427 . -8) (f259418 . 8) ((primitive-ref string=?) . 4) (f259418 . 0))
# var=f259427
    movl -16(%esp), %eax  # stack load f259427
# end emit-variable-ref
    mov %eax, -36(%esp)  # arg f259427
# emit-expr (symbol->string (car f259428))
# symbol->string (car f259428)
# emit-expr (car f259428)
# emit-expr f259428
# emit-variable-ref
# env=((f259428 . -20) (f259427 . -16) (f259428 . -12) (f259427 . -8) (f259418 . 8) ((primitive-ref string=?) . 4) (f259418 . 0))
# var=f259428
    movl -20(%esp), %eax  # stack load f259428
# end emit-variable-ref
# check the argument is a pair
    movl %eax,%ebx
    and $7, %bl
    cmp $1, %bl
    je _L_1576154
# invoke error handler eh_pair
    .extern mrc_eh$upair
    movl mrc_eh$upair, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $108,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1576154:
    movl -1(%eax), %eax
    movl -3(%eax), %eax
    mov %eax, -40(%esp)  # arg (symbol->string (car f259428))
    movl -32(%esp), %edi   # load new closure to %edi
    add $-24, %esp   # adjust base
    movl $8,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $24, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    cmp $47, %al
    je _L_1576151
# emit-tail-expr
# si=-24
# env=((f259428 . -20) (f259427 . -16) (f259428 . -12) (f259427 . -8) (f259418 . 8) ((primitive-ref string=?) . 4) (f259418 . 0))
# expr=(car f259428)
# tail primcall
# emit-expr f259428
# emit-variable-ref
# env=((f259428 . -20) (f259427 . -16) (f259428 . -12) (f259427 . -8) (f259418 . 8) ((primitive-ref string=?) . 4) (f259418 . 0))
# var=f259428
    movl -20(%esp), %eax  # stack load f259428
# end emit-variable-ref
# check the argument is a pair
    movl %eax,%ebx
    and $7, %bl
    cmp $1, %bl
    je _L_1576155
# invoke error handler eh_pair
    .extern mrc_eh$upair
    movl mrc_eh$upair, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $108,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1576155:
    movl -1(%eax), %eax
#return from tail (car f259428)
    ret
    jmp _L_1576152
_L_1576151:
# emit-tail-expr
# si=-24
# env=((f259428 . -20) (f259427 . -16) (f259428 . -12) (f259427 . -8) (f259418 . 8) ((primitive-ref string=?) . 4) (f259418 . 0))
# expr=(if (null? (cdr f259428)) (let ((f259432 (make-symbol f259427 #f))) (let ((f259434 (cons f259432 ()))) (begin (set-cdr! f259428 f259434) f259432))) ((vector-ref f259418 0) f259427 (cdr f259428)))
# emit-expr (null? (cdr f259428))
# emit-expr (cdr f259428)
# emit-expr f259428
# emit-variable-ref
# env=((f259428 . -20) (f259427 . -16) (f259428 . -12) (f259427 . -8) (f259418 . 8) ((primitive-ref string=?) . 4) (f259418 . 0))
# var=f259428
    movl -20(%esp), %eax  # stack load f259428
# end emit-variable-ref
# check the argument is a pair
    movl %eax,%ebx
    and $7, %bl
    cmp $1, %bl
    je _L_1576158
# invoke error handler eh_pair
    .extern mrc_eh$upair
    movl mrc_eh$upair, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $112,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1576158:
    movl 3(%eax), %eax
    cmp $63, %eax
    mov $0, %eax
    sete %al
    movzbl %al, %eax
    sal $6, %al
    or $47, %al
    cmp $47, %al
    je _L_1576156
# emit-tail-expr
# si=-24
# env=((f259428 . -20) (f259427 . -16) (f259428 . -12) (f259427 . -8) (f259418 . 8) ((primitive-ref string=?) . 4) (f259418 . 0))
# expr=(let ((f259432 (make-symbol f259427 #f))) (let ((f259434 (cons f259432 ()))) (begin (set-cdr! f259428 f259434) f259432)))
# emit-tail-let
#  si   = -24
#  env  = ((f259428 . -20) (f259427 . -16) (f259428 . -12) (f259427 . -8) (f259418 . 8) ((primitive-ref string=?) . 4) (f259418 . 0))
#  bindings = ((f259432 (make-symbol f259427 #f)))
#  body = (let ((f259434 (cons f259432 ()))) (begin (set-cdr! f259428 f259434) f259432))
# emit-expr (make-symbol f259427 #f)
# make-symbol arg1=f259427 arg2=#f
# emit-expr f259427
# emit-variable-ref
# env=((f259428 . -20) (f259427 . -16) (f259428 . -12) (f259427 . -8) (f259418 . 8) ((primitive-ref string=?) . 4) (f259418 . 0))
# var=f259427
    movl -16(%esp), %eax  # stack load f259427
# end emit-variable-ref
    movl %eax, -24(%esp)
# emit-expr #f
    movl $47, %eax     # immed #f
    movl %eax, 4(%ebp)
    movl -24(%esp), %eax
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    orl  $3, %eax
    add  $8, %ebp
# make-symbol end
    movl %eax, -24(%esp)  # stack save
# emit-tail-expr
# si=-28
# env=((f259432 . -24) (f259428 . -20) (f259427 . -16) (f259428 . -12) (f259427 . -8) (f259418 . 8) ((primitive-ref string=?) . 4) (f259418 . 0))
# expr=(let ((f259434 (cons f259432 ()))) (begin (set-cdr! f259428 f259434) f259432))
# emit-tail-let
#  si   = -28
#  env  = ((f259432 . -24) (f259428 . -20) (f259427 . -16) (f259428 . -12) (f259427 . -8) (f259418 . 8) ((primitive-ref string=?) . 4) (f259418 . 0))
#  bindings = ((f259434 (cons f259432 ())))
#  body = (begin (set-cdr! f259428 f259434) f259432)
# emit-expr (cons f259432 ())
# cons arg1=f259432 arg2=()
# emit-expr f259432
# emit-variable-ref
# env=((f259432 . -24) (f259428 . -20) (f259427 . -16) (f259428 . -12) (f259427 . -8) (f259418 . 8) ((primitive-ref string=?) . 4) (f259418 . 0))
# var=f259432
    movl -24(%esp), %eax  # stack load f259432
# end emit-variable-ref
    movl %eax, -28(%esp)
# emit-expr ()
    movl $63, %eax     # immed ()
    movl %eax, 4(%ebp)
    movl -28(%esp), %eax
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    or   $1, %al
    add  $8, %ebp
# cons end
    movl %eax, -28(%esp)  # stack save
# emit-tail-expr
# si=-32
# env=((f259434 . -28) (f259432 . -24) (f259428 . -20) (f259427 . -16) (f259428 . -12) (f259427 . -8) (f259418 . 8) ((primitive-ref string=?) . 4) (f259418 . 0))
# expr=(begin (set-cdr! f259428 f259434) f259432)
# tail-begin (begin (set-cdr! f259428 f259434) f259432)
#   env=((f259434 . -28) (f259432 . -24) (f259428 . -20) (f259427 . -16) (f259428 . -12) (f259427 . -8) (f259418 . 8) ((primitive-ref string=?) . 4) (f259418 . 0))
# emit-expr (set-cdr! f259428 f259434)
# emit-expr f259428
# emit-variable-ref
# env=((f259434 . -28) (f259432 . -24) (f259428 . -20) (f259427 . -16) (f259428 . -12) (f259427 . -8) (f259418 . 8) ((primitive-ref string=?) . 4) (f259418 . 0))
# var=f259428
    movl -20(%esp), %eax  # stack load f259428
# end emit-variable-ref
# check the argument is a pair
    movl %eax,%ebx
    and $7, %bl
    cmp $1, %bl
    je _L_1576159
# invoke error handler eh_pair
    .extern mrc_eh$upair
    movl mrc_eh$upair, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $120,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1576159:
    movl %eax, -32(%esp)
# emit-expr f259434
# emit-variable-ref
# env=((f259434 . -28) (f259432 . -24) (f259428 . -20) (f259427 . -16) (f259428 . -12) (f259427 . -8) (f259418 . 8) ((primitive-ref string=?) . 4) (f259418 . 0))
# var=f259434
    movl -28(%esp), %eax  # stack load f259434
# end emit-variable-ref
    movl -32(%esp), %ebx
    movl %eax, 3(%ebx)
# emit-tail-expr
# si=-32
# env=((f259434 . -28) (f259432 . -24) (f259428 . -20) (f259427 . -16) (f259428 . -12) (f259427 . -8) (f259418 . 8) ((primitive-ref string=?) . 4) (f259418 . 0))
# expr=(begin f259432)
# tail-begin (begin f259432)
#   env=((f259434 . -28) (f259432 . -24) (f259428 . -20) (f259427 . -16) (f259428 . -12) (f259427 . -8) (f259418 . 8) ((primitive-ref string=?) . 4) (f259418 . 0))
# emit-tail-expr
# si=-32
# env=((f259434 . -28) (f259432 . -24) (f259428 . -20) (f259427 . -16) (f259428 . -12) (f259427 . -8) (f259418 . 8) ((primitive-ref string=?) . 4) (f259418 . 0))
# expr=f259432
# emit-tail-variable-ref
# emit-variable-ref
# env=((f259434 . -28) (f259432 . -24) (f259428 . -20) (f259427 . -16) (f259428 . -12) (f259427 . -8) (f259418 . 8) ((primitive-ref string=?) . 4) (f259418 . 0))
# var=f259432
    movl -24(%esp), %eax  # stack load f259432
# end emit-variable-ref
    ret
# end emit-tail-variable ref
     ret   # return thru stack
    jmp _L_1576157
_L_1576156:
# emit-tail-expr
# si=-24
# env=((f259428 . -20) (f259427 . -16) (f259428 . -12) (f259427 . -8) (f259418 . 8) ((primitive-ref string=?) . 4) (f259418 . 0))
# expr=((vector-ref f259418 0) f259427 (cdr f259428))
# emit-tail-funcall
#    si   =-24
#    env  = ((f259428 . -20) (f259427 . -16) (f259428 . -12) (f259427 . -8) (f259418 . 8) ((primitive-ref string=?) . 4) (f259418 . 0))
#    expr = (funcall (vector-ref f259418 0) f259427 (cdr f259428))
# emit-expr (vector-ref f259418 0)
# emit-expr f259418
# emit-variable-ref
# env=((f259428 . -20) (f259427 . -16) (f259428 . -12) (f259427 . -8) (f259418 . 8) ((primitive-ref string=?) . 4) (f259418 . 0))
# var=f259418
    movl 6(%edi), %eax  # frame load f259418
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1576160
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1576160:
    movl %eax, -24(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1576161"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1576161:
# check bounds on vector index
    movl -24(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1576163
    cmp  $0,%eax
    jge _L_1576162
_L_1576163:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1576162:
    movl -24(%esp), %esi
    movl -1(%eax,%esi), %eax
   movl %eax,  -24(%esp)  # stash funcall-oper in next closure slot
# emit-expr f259427
# emit-variable-ref
# env=((f259428 . -20) (f259427 . -16) (f259428 . -12) (f259427 . -8) (f259418 . 8) ((primitive-ref string=?) . 4) (f259418 . 0))
# var=f259427
    movl -16(%esp), %eax  # stack load f259427
# end emit-variable-ref
    mov %eax, -28(%esp)    # arg f259427
# emit-expr (cdr f259428)
# emit-expr f259428
# emit-variable-ref
# env=((f259428 . -20) (f259427 . -16) (f259428 . -12) (f259427 . -8) (f259418 . 8) ((primitive-ref string=?) . 4) (f259418 . 0))
# var=f259428
    movl -20(%esp), %eax  # stack load f259428
# end emit-variable-ref
# check the argument is a pair
    movl %eax,%ebx
    and $7, %bl
    cmp $1, %bl
    je _L_1576164
# invoke error handler eh_pair
    .extern mrc_eh$upair
    movl mrc_eh$upair, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $112,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1576164:
    movl 3(%eax), %eax
    mov %eax, -32(%esp)    # arg (cdr f259428)
    movl -24(%esp), %edi   # load new closure to %edi
# emit-shift-args:  size=3   si=-24  delta=20
    mov -24(%esp), %ebx  # shift frame cell
    mov %ebx, -4(%esp)  # down to base
# emit-shift-args:  size=2   si=-28  delta=20
    mov -28(%esp), %ebx  # shift frame cell
    mov %ebx, -8(%esp)  # down to base
# emit-shift-args:  size=1   si=-32  delta=20
    mov -32(%esp), %ebx  # shift frame cell
    mov %ebx, -12(%esp)  # down to base
# emit-shift-args:  size=0   si=-36  delta=20
    movl $8,%eax   # save arg count
    jmp *-2(%edi)  # tail-funcall
_L_1576157:
_L_1576152:
    .align 4,0x90
_L_1576149:
    movl -4(%esp), %ebx
    movl -8(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin)
# emit-begin
#   expr=(begin)
#   env=((f259418 . 0))
# emit-expr (begin (closure (f259436) (f259418 (primitive-ref symbols)) (let ((f259436 f259436)) ((vector-ref f259418 0) f259436 ((primitive-ref symbols))))))
# emit-begin
#   expr=(begin (closure (f259436) (f259418 (primitive-ref symbols)) (let ((f259436 f259436)) ((vector-ref f259418 0) f259436 ((primitive-ref symbols))))))
#   env=((f259418 . 0))
# emit-expr (closure (f259436) (f259418 (primitive-ref symbols)) (let ((f259436 f259436)) ((vector-ref f259418 0) f259436 ((primitive-ref symbols)))))
# emit-closure
# si = -4
# env = ((f259418 . 0))
# expr = (closure (f259436) (f259418 (primitive-ref symbols)) (let ((f259436 f259436)) ((vector-ref f259418 0) f259436 ((primitive-ref symbols)))))
    movl $_L_1576165, 0(%ebp)  # closure label
# emit-variable-ref
# env=((f259418 . 0))
# var=f259418
    movl 0(%esp), %eax  # stack load f259418
# end emit-variable-ref
   movl  %eax, 4(%ebp)  # f259418
# WARNING: free var (primitive-ref symbols) not defined in the environmnet
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $16, %ebp     # bump ebp
    jmp _L_1576166            # jump around closure body
_L_1576165:
# check argument count
    cmp $4,%eax
    je _L_1576167
# invoke error handler eh_argcount
    .extern mrc_eh$uargcount
    movl mrc_eh$uargcount, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_1576167:
# emit-tail-expr
# si=-12
# env=((f259436 . -8) ((primitive-ref symbols) . 8) (f259418 . 4) (f259418 . 0))
# expr=(let ((f259436 f259436)) ((vector-ref f259418 0) f259436 ((primitive-ref symbols))))
# emit-tail-let
#  si   = -12
#  env  = ((f259436 . -8) ((primitive-ref symbols) . 8) (f259418 . 4) (f259418 . 0))
#  bindings = ((f259436 f259436))
#  body = ((vector-ref f259418 0) f259436 ((primitive-ref symbols)))
# emit-expr f259436
# emit-variable-ref
# env=((f259436 . -8) ((primitive-ref symbols) . 8) (f259418 . 4) (f259418 . 0))
# var=f259436
    movl -8(%esp), %eax  # stack load f259436
# end emit-variable-ref
    movl %eax, -12(%esp)  # stack save
# emit-tail-expr
# si=-16
# env=((f259436 . -12) (f259436 . -8) ((primitive-ref symbols) . 8) (f259418 . 4) (f259418 . 0))
# expr=((vector-ref f259418 0) f259436 ((primitive-ref symbols)))
# emit-tail-funcall
#    si   =-16
#    env  = ((f259436 . -12) (f259436 . -8) ((primitive-ref symbols) . 8) (f259418 . 4) (f259418 . 0))
#    expr = (funcall (vector-ref f259418 0) f259436 ((primitive-ref symbols)))
# emit-expr (vector-ref f259418 0)
# emit-expr f259418
# emit-variable-ref
# env=((f259436 . -12) (f259436 . -8) ((primitive-ref symbols) . 8) (f259418 . 4) (f259418 . 0))
# var=f259418
    movl 2(%edi), %eax  # frame load f259418
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1576168
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1576168:
    movl %eax, -16(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1576169"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1576169:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1576171
    cmp  $0,%eax
    jge _L_1576170
_L_1576171:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1576170:
    movl -16(%esp), %esi
    movl -1(%eax,%esi), %eax
   movl %eax,  -16(%esp)  # stash funcall-oper in next closure slot
# emit-expr f259436
# emit-variable-ref
# env=((f259436 . -12) (f259436 . -8) ((primitive-ref symbols) . 8) (f259418 . 4) (f259418 . 0))
# var=f259436
    movl -12(%esp), %eax  # stack load f259436
# end emit-variable-ref
    mov %eax, -20(%esp)    # arg f259436
# emit-expr ((primitive-ref symbols))
# funcall
#    si   =-24
#    env  = ((f259436 . -12) (f259436 . -8) ((primitive-ref symbols) . 8) (f259418 . 4) (f259418 . 0))
#    expr = (funcall (primitive-ref symbols))
# emit-expr (primitive-ref symbols)
    .extern mrc_symbols
    movl mrc_symbols,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1576172"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1576172":
   movl %eax,  -32(%esp)  # stash funcall-oper in closure slot
    movl -32(%esp), %edi   # load new closure to %edi
    add $-24, %esp   # adjust base
    movl $0,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $24, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    mov %eax, -24(%esp)    # arg ((primitive-ref symbols))
    movl -16(%esp), %edi   # load new closure to %edi
# emit-shift-args:  size=3   si=-16  delta=12
    mov -16(%esp), %ebx  # shift frame cell
    mov %ebx, -4(%esp)  # down to base
# emit-shift-args:  size=2   si=-20  delta=12
    mov -20(%esp), %ebx  # shift frame cell
    mov %ebx, -8(%esp)  # down to base
# emit-shift-args:  size=1   si=-24  delta=12
    mov -24(%esp), %ebx  # shift frame cell
    mov %ebx, -12(%esp)  # down to base
# emit-shift-args:  size=0   si=-28  delta=12
    movl $8,%eax   # save arg count
    jmp *-2(%edi)  # tail-funcall
    .align 4,0x90
_L_1576166:
# emit-expr (begin)
# emit-begin
#   expr=(begin)
#   env=((f259418 . 0))
     movl %eax, mrc_string$m$gsymbol
# == explicit-begins  ==>
# (lambda (lst elt) (if (null? lst) (cons elt nil) (cons (car lst) (append1 (cdr lst) elt))))
# == eliminate-let*  ==>
# (lambda (lst elt) (if (null? lst) (cons elt nil) (cons (car lst) (append1 (cdr lst) elt))))
# == uniquify-variables  ==>
# (lambda (f259437 f259438) (if (null? f259437) (cons f259438 nil) (cons (car f259437) (append1 (cdr f259437) f259438))))
# == vectorize-letrec  ==>
# (lambda (f259437 f259438) (if (null? f259437) (cons f259438 nil) (cons (car f259437) (append1 (cdr f259437) f259438))))
# == eliminate-set!  ==>
# (lambda (f259437 f259438) (let ((f259437 f259437) (f259438 f259438)) (if (null? f259437) (cons f259438 nil) (cons (car f259437) (append1 (cdr f259437) f259438)))))
# == close-free-variables  ==>
# (closure (f259437 f259438) (nil append1) (let ((f259437 f259437) (f259438 f259438)) (if (null? f259437) (cons f259438 nil) (cons (car f259437) (append1 (cdr f259437) f259438)))))
# == eliminate-quote  ==>
# (closure (f259437 f259438) (nil append1) (let ((f259437 f259437) (f259438 f259438)) (if (null? f259437) (cons f259438 nil) (cons (car f259437) (append1 (cdr f259437) f259438)))))
# == eliminate-when/unless  ==>
# (closure (f259437 f259438) (nil append1) (let ((f259437 f259437) (f259438 f259438)) (if (null? f259437) (cons f259438 nil) (cons (car f259437) (append1 (cdr f259437) f259438)))))
# == eliminate-cond  ==>
# (closure (f259437 f259438) (nil append1) (let ((f259437 f259437) (f259438 f259438)) (if (null? f259437) (cons f259438 nil) (cons (car f259437) (append1 (cdr f259437) f259438)))))
# == external-symbols  ==>
# (closure (f259437 f259438) (nil (primitive-ref append1)) (let ((f259437 f259437) (f259438 f259438)) (if (null? f259437) (cons f259438 nil) (cons (car f259437) ((primitive-ref append1) (cdr f259437) f259438)))))
# emit-expr (closure (f259437 f259438) (nil (primitive-ref append1)) (let ((f259437 f259437) (f259438 f259438)) (if (null? f259437) (cons f259438 nil) (cons (car f259437) ((primitive-ref append1) (cdr f259437) f259438)))))
# emit-closure
# si = 0
# env = ()
# expr = (closure (f259437 f259438) (nil (primitive-ref append1)) (let ((f259437 f259437) (f259438 f259438)) (if (null? f259437) (cons f259438 nil) (cons (car f259437) ((primitive-ref append1) (cdr f259437) f259438)))))
    movl $_L_1576173, 0(%ebp)  # closure label
# WARNING: free var nil not defined in the environmnet
# WARNING: free var (primitive-ref append1) not defined in the environmnet
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $16, %ebp     # bump ebp
    jmp _L_1576174            # jump around closure body
_L_1576173:
# check argument count
    cmp $8,%eax
    je _L_1576175
# invoke error handler eh_argcount
    .extern mrc_eh$uargcount
    movl mrc_eh$uargcount, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_1576175:
# emit-tail-expr
# si=-16
# env=((f259438 . -12) (f259437 . -8) ((primitive-ref append1) . 8) (nil . 4))
# expr=(let ((f259437 f259437) (f259438 f259438)) (if (null? f259437) (cons f259438 nil) (cons (car f259437) ((primitive-ref append1) (cdr f259437) f259438))))
# emit-tail-let
#  si   = -16
#  env  = ((f259438 . -12) (f259437 . -8) ((primitive-ref append1) . 8) (nil . 4))
#  bindings = ((f259437 f259437) (f259438 f259438))
#  body = (if (null? f259437) (cons f259438 nil) (cons (car f259437) ((primitive-ref append1) (cdr f259437) f259438)))
# emit-expr f259437
# emit-variable-ref
# env=((f259438 . -12) (f259437 . -8) ((primitive-ref append1) . 8) (nil . 4))
# var=f259437
    movl -8(%esp), %eax  # stack load f259437
# end emit-variable-ref
    movl %eax, -16(%esp)  # stack save
# emit-expr f259438
# emit-variable-ref
# env=((f259438 . -12) (f259437 . -8) ((primitive-ref append1) . 8) (nil . 4))
# var=f259438
    movl -12(%esp), %eax  # stack load f259438
# end emit-variable-ref
    movl %eax, -20(%esp)  # stack save
# emit-tail-expr
# si=-24
# env=((f259438 . -20) (f259437 . -16) (f259438 . -12) (f259437 . -8) ((primitive-ref append1) . 8) (nil . 4))
# expr=(if (null? f259437) (cons f259438 nil) (cons (car f259437) ((primitive-ref append1) (cdr f259437) f259438)))
# emit-expr (null? f259437)
# emit-expr f259437
# emit-variable-ref
# env=((f259438 . -20) (f259437 . -16) (f259438 . -12) (f259437 . -8) ((primitive-ref append1) . 8) (nil . 4))
# var=f259437
    movl -16(%esp), %eax  # stack load f259437
# end emit-variable-ref
    cmp $63, %eax
    mov $0, %eax
    sete %al
    movzbl %al, %eax
    sal $6, %al
    or $47, %al
    cmp $47, %al
    je _L_1576176
# emit-tail-expr
# si=-24
# env=((f259438 . -20) (f259437 . -16) (f259438 . -12) (f259437 . -8) ((primitive-ref append1) . 8) (nil . 4))
# expr=(cons f259438 nil)
# tail primcall
# cons arg1=f259438 arg2=nil
# emit-expr f259438
# emit-variable-ref
# env=((f259438 . -20) (f259437 . -16) (f259438 . -12) (f259437 . -8) ((primitive-ref append1) . 8) (nil . 4))
# var=f259438
    movl -20(%esp), %eax  # stack load f259438
# end emit-variable-ref
    movl %eax, -24(%esp)
# emit-expr nil
# emit-variable-ref
# env=((f259438 . -20) (f259437 . -16) (f259438 . -12) (f259437 . -8) ((primitive-ref append1) . 8) (nil . 4))
# var=nil
    movl 2(%edi), %eax  # frame load nil
# end emit-variable-ref
    movl %eax, 4(%ebp)
    movl -24(%esp), %eax
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    or   $1, %al
    add  $8, %ebp
# cons end
#return from tail (cons f259438 nil)
    ret
    jmp _L_1576177
_L_1576176:
# emit-tail-expr
# si=-24
# env=((f259438 . -20) (f259437 . -16) (f259438 . -12) (f259437 . -8) ((primitive-ref append1) . 8) (nil . 4))
# expr=(cons (car f259437) ((primitive-ref append1) (cdr f259437) f259438))
# tail primcall
# cons arg1=(car f259437) arg2=((primitive-ref append1) (cdr f259437) f259438)
# emit-expr (car f259437)
# emit-expr f259437
# emit-variable-ref
# env=((f259438 . -20) (f259437 . -16) (f259438 . -12) (f259437 . -8) ((primitive-ref append1) . 8) (nil . 4))
# var=f259437
    movl -16(%esp), %eax  # stack load f259437
# end emit-variable-ref
# check the argument is a pair
    movl %eax,%ebx
    and $7, %bl
    cmp $1, %bl
    je _L_1576178
# invoke error handler eh_pair
    .extern mrc_eh$upair
    movl mrc_eh$upair, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $108,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1576178:
    movl -1(%eax), %eax
    movl %eax, -24(%esp)
# emit-expr ((primitive-ref append1) (cdr f259437) f259438)
# funcall
#    si   =-28
#    env  = ((f259438 . -20) (f259437 . -16) (f259438 . -12) (f259437 . -8) ((primitive-ref append1) . 8) (nil . 4))
#    expr = (funcall (primitive-ref append1) (cdr f259437) f259438)
# emit-expr (primitive-ref append1)
    .extern mrc_append1
    movl mrc_append1,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1576179"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1576179":
   movl %eax,  -36(%esp)  # stash funcall-oper in closure slot
# emit-expr (cdr f259437)
# emit-expr f259437
# emit-variable-ref
# env=((f259438 . -20) (f259437 . -16) (f259438 . -12) (f259437 . -8) ((primitive-ref append1) . 8) (nil . 4))
# var=f259437
    movl -16(%esp), %eax  # stack load f259437
# end emit-variable-ref
# check the argument is a pair
    movl %eax,%ebx
    and $7, %bl
    cmp $1, %bl
    je _L_1576180
# invoke error handler eh_pair
    .extern mrc_eh$upair
    movl mrc_eh$upair, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $112,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1576180:
    movl 3(%eax), %eax
    mov %eax, -40(%esp)  # arg (cdr f259437)
# emit-expr f259438
# emit-variable-ref
# env=((f259438 . -20) (f259437 . -16) (f259438 . -12) (f259437 . -8) ((primitive-ref append1) . 8) (nil . 4))
# var=f259438
    movl -20(%esp), %eax  # stack load f259438
# end emit-variable-ref
    mov %eax, -44(%esp)  # arg f259438
    movl -36(%esp), %edi   # load new closure to %edi
    add $-28, %esp   # adjust base
    movl $8,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $28, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    movl %eax, 4(%ebp)
    movl -24(%esp), %eax
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    or   $1, %al
    add  $8, %ebp
# cons end
#return from tail (cons (car f259437) ((primitive-ref append1) (cdr f259437) f259438))
    ret
_L_1576177:
    .align 4,0x90
_L_1576174:
     movl %eax, mrc_append1
# == explicit-begins  ==>
# (lambda (l k) (if (fx= k 0) (car l) (list-ref (cdr l) (fx- k 1))))
# == eliminate-let*  ==>
# (lambda (l k) (if (fx= k 0) (car l) (list-ref (cdr l) (fx- k 1))))
# == uniquify-variables  ==>
# (lambda (f259439 f259440) (if (fx= f259440 0) (car f259439) (list-ref (cdr f259439) (fx- f259440 1))))
# == vectorize-letrec  ==>
# (lambda (f259439 f259440) (if (fx= f259440 0) (car f259439) (list-ref (cdr f259439) (fx- f259440 1))))
# == eliminate-set!  ==>
# (lambda (f259439 f259440) (let ((f259439 f259439) (f259440 f259440)) (if (fx= f259440 0) (car f259439) (list-ref (cdr f259439) (fx- f259440 1)))))
# == close-free-variables  ==>
# (closure (f259439 f259440) (list-ref) (let ((f259439 f259439) (f259440 f259440)) (if (fx= f259440 0) (car f259439) (list-ref (cdr f259439) (fx- f259440 1)))))
# == eliminate-quote  ==>
# (closure (f259439 f259440) (list-ref) (let ((f259439 f259439) (f259440 f259440)) (if (fx= f259440 0) (car f259439) (list-ref (cdr f259439) (fx- f259440 1)))))
# == eliminate-when/unless  ==>
# (closure (f259439 f259440) (list-ref) (let ((f259439 f259439) (f259440 f259440)) (if (fx= f259440 0) (car f259439) (list-ref (cdr f259439) (fx- f259440 1)))))
# == eliminate-cond  ==>
# (closure (f259439 f259440) (list-ref) (let ((f259439 f259439) (f259440 f259440)) (if (fx= f259440 0) (car f259439) (list-ref (cdr f259439) (fx- f259440 1)))))
# == external-symbols  ==>
# (closure (f259439 f259440) ((primitive-ref list-ref)) (let ((f259439 f259439) (f259440 f259440)) (if (fx= f259440 0) (car f259439) ((primitive-ref list-ref) (cdr f259439) (fx- f259440 1)))))
# emit-expr (closure (f259439 f259440) ((primitive-ref list-ref)) (let ((f259439 f259439) (f259440 f259440)) (if (fx= f259440 0) (car f259439) ((primitive-ref list-ref) (cdr f259439) (fx- f259440 1)))))
# emit-closure
# si = 0
# env = ()
# expr = (closure (f259439 f259440) ((primitive-ref list-ref)) (let ((f259439 f259439) (f259440 f259440)) (if (fx= f259440 0) (car f259439) ((primitive-ref list-ref) (cdr f259439) (fx- f259440 1)))))
    movl $_L_1576181, 0(%ebp)  # closure label
# WARNING: free var (primitive-ref list-ref) not defined in the environmnet
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $8, %ebp     # bump ebp
    jmp _L_1576182            # jump around closure body
_L_1576181:
# check argument count
    cmp $8,%eax
    je _L_1576183
# invoke error handler eh_argcount
    .extern mrc_eh$uargcount
    movl mrc_eh$uargcount, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_1576183:
# emit-tail-expr
# si=-16
# env=((f259440 . -12) (f259439 . -8) ((primitive-ref list-ref) . 4))
# expr=(let ((f259439 f259439) (f259440 f259440)) (if (fx= f259440 0) (car f259439) ((primitive-ref list-ref) (cdr f259439) (fx- f259440 1))))
# emit-tail-let
#  si   = -16
#  env  = ((f259440 . -12) (f259439 . -8) ((primitive-ref list-ref) . 4))
#  bindings = ((f259439 f259439) (f259440 f259440))
#  body = (if (fx= f259440 0) (car f259439) ((primitive-ref list-ref) (cdr f259439) (fx- f259440 1)))
# emit-expr f259439
# emit-variable-ref
# env=((f259440 . -12) (f259439 . -8) ((primitive-ref list-ref) . 4))
# var=f259439
    movl -8(%esp), %eax  # stack load f259439
# end emit-variable-ref
    movl %eax, -16(%esp)  # stack save
# emit-expr f259440
# emit-variable-ref
# env=((f259440 . -12) (f259439 . -8) ((primitive-ref list-ref) . 4))
# var=f259440
    movl -12(%esp), %eax  # stack load f259440
# end emit-variable-ref
    movl %eax, -20(%esp)  # stack save
# emit-tail-expr
# si=-24
# env=((f259440 . -20) (f259439 . -16) (f259440 . -12) (f259439 . -8) ((primitive-ref list-ref) . 4))
# expr=(if (fx= f259440 0) (car f259439) ((primitive-ref list-ref) (cdr f259439) (fx- f259440 1)))
# emit-expr (fx= f259440 0)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1576186"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $60,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1576186:
    movl %eax, -24(%esp)
# emit-expr f259440
# emit-variable-ref
# env=((f259440 . -20) (f259439 . -16) (f259440 . -12) (f259439 . -8) ((primitive-ref list-ref) . 4))
# var=f259440
    movl -20(%esp), %eax  # stack load f259440
# end emit-variable-ref
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1576187"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $60,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1576187:
    cmp -24(%esp), %eax
    sete %al
    movzbl %al, %eax
    sal $6, %al
    or $47, %al
    cmp $47, %al
    je _L_1576184
# emit-tail-expr
# si=-24
# env=((f259440 . -20) (f259439 . -16) (f259440 . -12) (f259439 . -8) ((primitive-ref list-ref) . 4))
# expr=(car f259439)
# tail primcall
# emit-expr f259439
# emit-variable-ref
# env=((f259440 . -20) (f259439 . -16) (f259440 . -12) (f259439 . -8) ((primitive-ref list-ref) . 4))
# var=f259439
    movl -16(%esp), %eax  # stack load f259439
# end emit-variable-ref
# check the argument is a pair
    movl %eax,%ebx
    and $7, %bl
    cmp $1, %bl
    je _L_1576188
# invoke error handler eh_pair
    .extern mrc_eh$upair
    movl mrc_eh$upair, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $108,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1576188:
    movl -1(%eax), %eax
#return from tail (car f259439)
    ret
    jmp _L_1576185
_L_1576184:
# emit-tail-expr
# si=-24
# env=((f259440 . -20) (f259439 . -16) (f259440 . -12) (f259439 . -8) ((primitive-ref list-ref) . 4))
# expr=((primitive-ref list-ref) (cdr f259439) (fx- f259440 1))
# emit-tail-funcall
#    si   =-24
#    env  = ((f259440 . -20) (f259439 . -16) (f259440 . -12) (f259439 . -8) ((primitive-ref list-ref) . 4))
#    expr = (funcall (primitive-ref list-ref) (cdr f259439) (fx- f259440 1))
# emit-expr (primitive-ref list-ref)
    .extern mrc_list$mref
    movl mrc_list$mref,%eax
   movl %eax,  -24(%esp)  # stash funcall-oper in next closure slot
# emit-expr (cdr f259439)
# emit-expr f259439
# emit-variable-ref
# env=((f259440 . -20) (f259439 . -16) (f259440 . -12) (f259439 . -8) ((primitive-ref list-ref) . 4))
# var=f259439
    movl -16(%esp), %eax  # stack load f259439
# end emit-variable-ref
# check the argument is a pair
    movl %eax,%ebx
    and $7, %bl
    cmp $1, %bl
    je _L_1576189
# invoke error handler eh_pair
    .extern mrc_eh$upair
    movl mrc_eh$upair, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $112,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1576189:
    movl 3(%eax), %eax
    mov %eax, -28(%esp)    # arg (cdr f259439)
# emit-expr (fx- f259440 1)
# emit-expr 1
    movl $4, %eax     # immed 1
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1576190"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $84,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1576190:
    movl %eax, -32(%esp)
# emit-expr f259440
# emit-variable-ref
# env=((f259440 . -20) (f259439 . -16) (f259440 . -12) (f259439 . -8) ((primitive-ref list-ref) . 4))
# var=f259440
    movl -20(%esp), %eax  # stack load f259440
# end emit-variable-ref
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1576191"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $84,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1576191:
    subl -32(%esp), %eax
    mov %eax, -32(%esp)    # arg (fx- f259440 1)
    movl -24(%esp), %edi   # load new closure to %edi
# emit-shift-args:  size=3   si=-24  delta=20
    mov -24(%esp), %ebx  # shift frame cell
    mov %ebx, -4(%esp)  # down to base
# emit-shift-args:  size=2   si=-28  delta=20
    mov -28(%esp), %ebx  # shift frame cell
    mov %ebx, -8(%esp)  # down to base
# emit-shift-args:  size=1   si=-32  delta=20
    mov -32(%esp), %ebx  # shift frame cell
    mov %ebx, -12(%esp)  # down to base
# emit-shift-args:  size=0   si=-36  delta=20
    movl $8,%eax   # save arg count
    jmp *-2(%edi)  # tail-funcall
_L_1576185:
    .align 4,0x90
_L_1576182:
     movl %eax, mrc_list$mref
# == explicit-begins  ==>
# (lambda (l) (if (null? l) 0 (fxadd1 (list-length (cdr l)))))
# == eliminate-let*  ==>
# (lambda (l) (if (null? l) 0 (fxadd1 (list-length (cdr l)))))
# == uniquify-variables  ==>
# (lambda (f259441) (if (null? f259441) 0 (fxadd1 (list-length (cdr f259441)))))
# == vectorize-letrec  ==>
# (lambda (f259441) (if (null? f259441) 0 (fxadd1 (list-length (cdr f259441)))))
# == eliminate-set!  ==>
# (lambda (f259441) (let ((f259441 f259441)) (if (null? f259441) 0 (fxadd1 (list-length (cdr f259441))))))
# == close-free-variables  ==>
# (closure (f259441) (list-length) (let ((f259441 f259441)) (if (null? f259441) 0 (fxadd1 (list-length (cdr f259441))))))
# == eliminate-quote  ==>
# (closure (f259441) (list-length) (let ((f259441 f259441)) (if (null? f259441) 0 (fxadd1 (list-length (cdr f259441))))))
# == eliminate-when/unless  ==>
# (closure (f259441) (list-length) (let ((f259441 f259441)) (if (null? f259441) 0 (fxadd1 (list-length (cdr f259441))))))
# == eliminate-cond  ==>
# (closure (f259441) (list-length) (let ((f259441 f259441)) (if (null? f259441) 0 (fxadd1 (list-length (cdr f259441))))))
# == external-symbols  ==>
# (closure (f259441) ((primitive-ref list-length)) (let ((f259441 f259441)) (if (null? f259441) 0 (fxadd1 ((primitive-ref list-length) (cdr f259441))))))
# emit-expr (closure (f259441) ((primitive-ref list-length)) (let ((f259441 f259441)) (if (null? f259441) 0 (fxadd1 ((primitive-ref list-length) (cdr f259441))))))
# emit-closure
# si = 0
# env = ()
# expr = (closure (f259441) ((primitive-ref list-length)) (let ((f259441 f259441)) (if (null? f259441) 0 (fxadd1 ((primitive-ref list-length) (cdr f259441))))))
    movl $_L_1576192, 0(%ebp)  # closure label
# WARNING: free var (primitive-ref list-length) not defined in the environmnet
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $8, %ebp     # bump ebp
    jmp _L_1576193            # jump around closure body
_L_1576192:
# check argument count
    cmp $4,%eax
    je _L_1576194
# invoke error handler eh_argcount
    .extern mrc_eh$uargcount
    movl mrc_eh$uargcount, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_1576194:
# emit-tail-expr
# si=-12
# env=((f259441 . -8) ((primitive-ref list-length) . 4))
# expr=(let ((f259441 f259441)) (if (null? f259441) 0 (fxadd1 ((primitive-ref list-length) (cdr f259441)))))
# emit-tail-let
#  si   = -12
#  env  = ((f259441 . -8) ((primitive-ref list-length) . 4))
#  bindings = ((f259441 f259441))
#  body = (if (null? f259441) 0 (fxadd1 ((primitive-ref list-length) (cdr f259441))))
# emit-expr f259441
# emit-variable-ref
# env=((f259441 . -8) ((primitive-ref list-length) . 4))
# var=f259441
    movl -8(%esp), %eax  # stack load f259441
# end emit-variable-ref
    movl %eax, -12(%esp)  # stack save
# emit-tail-expr
# si=-16
# env=((f259441 . -12) (f259441 . -8) ((primitive-ref list-length) . 4))
# expr=(if (null? f259441) 0 (fxadd1 ((primitive-ref list-length) (cdr f259441))))
# emit-expr (null? f259441)
# emit-expr f259441
# emit-variable-ref
# env=((f259441 . -12) (f259441 . -8) ((primitive-ref list-length) . 4))
# var=f259441
    movl -12(%esp), %eax  # stack load f259441
# end emit-variable-ref
    cmp $63, %eax
    mov $0, %eax
    sete %al
    movzbl %al, %eax
    sal $6, %al
    or $47, %al
    cmp $47, %al
    je _L_1576195
# emit-tail-expr
# si=-16
# env=((f259441 . -12) (f259441 . -8) ((primitive-ref list-length) . 4))
# expr=0
    movl $0, %eax     # immed 0
    ret                  # immediate tail return
    jmp _L_1576196
_L_1576195:
# emit-tail-expr
# si=-16
# env=((f259441 . -12) (f259441 . -8) ((primitive-ref list-length) . 4))
# expr=(fxadd1 ((primitive-ref list-length) (cdr f259441)))
# tail primcall
# emit-expr ((primitive-ref list-length) (cdr f259441))
# funcall
#    si   =-16
#    env  = ((f259441 . -12) (f259441 . -8) ((primitive-ref list-length) . 4))
#    expr = (funcall (primitive-ref list-length) (cdr f259441))
# emit-expr (primitive-ref list-length)
    .extern mrc_list$mlength
    movl mrc_list$mlength,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1576197"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1576197":
   movl %eax,  -24(%esp)  # stash funcall-oper in closure slot
# emit-expr (cdr f259441)
# emit-expr f259441
# emit-variable-ref
# env=((f259441 . -12) (f259441 . -8) ((primitive-ref list-length) . 4))
# var=f259441
    movl -12(%esp), %eax  # stack load f259441
# end emit-variable-ref
# check the argument is a pair
    movl %eax,%ebx
    and $7, %bl
    cmp $1, %bl
    je _L_1576198
# invoke error handler eh_pair
    .extern mrc_eh$upair
    movl mrc_eh$upair, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $112,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1576198:
    movl 3(%eax), %eax
    mov %eax, -28(%esp)  # arg (cdr f259441)
    movl -24(%esp), %edi   # load new closure to %edi
    add $-16, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $16, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1576199"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $48,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1576199:
     addl $4, %eax
#return from tail (fxadd1 ((primitive-ref list-length) (cdr f259441)))
    ret
_L_1576196:
    .align 4,0x90
_L_1576193:
     movl %eax, mrc_list$mlength
# == explicit-begins  ==>
# (letrec ((f (lambda (l lrev) (if (null? l) lrev (f (cdr l) (cons (car l) lrev)))))) (lambda (l) (f l (quote ()))))
# == eliminate-let*  ==>
# (letrec ((f (lambda (l lrev) (if (null? l) lrev (f (cdr l) (cons (car l) lrev)))))) (lambda (l) (f l (quote ()))))
# == uniquify-variables  ==>
# (letrec ((f259442 (lambda (f259445 f259446) (if (null? f259445) f259446 (f259442 (cdr f259445) (cons (car f259445) f259446)))))) (lambda (f259448) (f259442 f259448 (quote ()))))
# == vectorize-letrec  ==>
# (let ((f259442 (make-vector 1))) (begin (begin (vector-set! f259442 0 (lambda (f259445 f259446) (if (null? f259445) f259446 ((vector-ref f259442 0) (cdr f259445) (cons (car f259445) f259446)))))) (lambda (f259448) ((vector-ref f259442 0) f259448 (quote ())))))
# == eliminate-set!  ==>
# (let ((f259442 (make-vector 1))) (begin (begin (vector-set! f259442 0 (lambda (f259445 f259446) (let ((f259445 f259445) (f259446 f259446)) (if (null? f259445) f259446 ((vector-ref f259442 0) (cdr f259445) (cons (car f259445) f259446))))))) (lambda (f259448) (let ((f259448 f259448)) ((vector-ref f259442 0) f259448 (quote ()))))))
# == close-free-variables  ==>
# (let ((f259442 (make-vector 1))) (begin (begin (vector-set! f259442 0 (closure (f259445 f259446) (f259442) (let ((f259445 f259445) (f259446 f259446)) (if (null? f259445) f259446 ((vector-ref f259442 0) (cdr f259445) (cons (car f259445) f259446))))))) (closure (f259448) (f259442) (let ((f259448 f259448)) ((vector-ref f259442 0) f259448 (quote ()))))))
# == eliminate-quote  ==>
# (let ((f259442 (make-vector 1))) (begin (begin (vector-set! f259442 0 (closure (f259445 f259446) (f259442) (let ((f259445 f259445) (f259446 f259446)) (if (null? f259445) f259446 ((vector-ref f259442 0) (cdr f259445) (cons (car f259445) f259446))))))) (closure (f259448) (f259442) (let ((f259448 f259448)) ((vector-ref f259442 0) f259448 ())))))
# == eliminate-when/unless  ==>
# (let ((f259442 (make-vector 1))) (begin (begin (vector-set! f259442 0 (closure (f259445 f259446) (f259442) (let ((f259445 f259445) (f259446 f259446)) (if (null? f259445) f259446 ((vector-ref f259442 0) (cdr f259445) (cons (car f259445) f259446))))))) (closure (f259448) (f259442) (let ((f259448 f259448)) ((vector-ref f259442 0) f259448 ())))))
# == eliminate-cond  ==>
# (let ((f259442 (make-vector 1))) (begin (begin (vector-set! f259442 0 (closure (f259445 f259446) (f259442) (let ((f259445 f259445) (f259446 f259446)) (if (null? f259445) f259446 ((vector-ref f259442 0) (cdr f259445) (cons (car f259445) f259446))))))) (closure (f259448) (f259442) (let ((f259448 f259448)) ((vector-ref f259442 0) f259448 ())))))
# == external-symbols  ==>
# (let ((f259442 (make-vector 1))) (begin (begin (vector-set! f259442 0 (closure (f259445 f259446) (f259442) (let ((f259445 f259445) (f259446 f259446)) (if (null? f259445) f259446 ((vector-ref f259442 0) (cdr f259445) (cons (car f259445) f259446))))))) (closure (f259448) (f259442) (let ((f259448 f259448)) ((vector-ref f259442 0) f259448 ())))))
# emit-expr (let ((f259442 (make-vector 1))) (begin (begin (vector-set! f259442 0 (closure (f259445 f259446) (f259442) (let ((f259445 f259445) (f259446 f259446)) (if (null? f259445) f259446 ((vector-ref f259442 0) (cdr f259445) (cons (car f259445) f259446))))))) (closure (f259448) (f259442) (let ((f259448 f259448)) ((vector-ref f259442 0) f259448 ())))))
# emit-let
#  si   = 0
#  env  = ()
#  bindings = ((f259442 (make-vector 1)))
#  body = (begin (begin (vector-set! f259442 0 (closure (f259445 f259446) (f259442) (let ((f259445 f259445) (f259446 f259446)) (if (null? f259445) f259446 ((vector-ref f259442 0) (cdr f259445) (cons (car f259445) f259446))))))) (closure (f259448) (f259442) (let ((f259448 f259448)) ((vector-ref f259442 0) f259448 ()))))
# emit-expr (make-vector 1)
# make-vector 1
# emit-expr 1
    movl $4, %eax     # immed 1
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1576200"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $128,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1576200:
# check the argument is a fixnum >= 0
    cmp $0,%eax
    jge _L_1576201
# invoke error handler eh_length
    .extern mrc_eh$ulength
    movl mrc_eh$ulength, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $128,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1576201:
    movl %eax, %esi
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    orl  $5, %eax
    addl $4, %esi
    addl $4, %esi
    andl $-8, %esi
    addl %esi, %ebp
    movl %eax, 0(%esp)  # stack save
# emit-expr (begin (begin (vector-set! f259442 0 (closure (f259445 f259446) (f259442) (let ((f259445 f259445) (f259446 f259446)) (if (null? f259445) f259446 ((vector-ref f259442 0) (cdr f259445) (cons (car f259445) f259446))))))) (closure (f259448) (f259442) (let ((f259448 f259448)) ((vector-ref f259442 0) f259448 ()))))
# emit-begin
#   expr=(begin (begin (vector-set! f259442 0 (closure (f259445 f259446) (f259442) (let ((f259445 f259445) (f259446 f259446)) (if (null? f259445) f259446 ((vector-ref f259442 0) (cdr f259445) (cons (car f259445) f259446))))))) (closure (f259448) (f259442) (let ((f259448 f259448)) ((vector-ref f259442 0) f259448 ()))))
#   env=((f259442 . 0))
# emit-expr (begin (vector-set! f259442 0 (closure (f259445 f259446) (f259442) (let ((f259445 f259445) (f259446 f259446)) (if (null? f259445) f259446 ((vector-ref f259442 0) (cdr f259445) (cons (car f259445) f259446)))))))
# emit-begin
#   expr=(begin (vector-set! f259442 0 (closure (f259445 f259446) (f259442) (let ((f259445 f259445) (f259446 f259446)) (if (null? f259445) f259446 ((vector-ref f259442 0) (cdr f259445) (cons (car f259445) f259446)))))))
#   env=((f259442 . 0))
# emit-expr (vector-set! f259442 0 (closure (f259445 f259446) (f259442) (let ((f259445 f259445) (f259446 f259446)) (if (null? f259445) f259446 ((vector-ref f259442 0) (cdr f259445) (cons (car f259445) f259446))))))
# emit-expr f259442
# emit-variable-ref
# env=((f259442 . 0))
# var=f259442
    movl 0(%esp), %eax  # stack load f259442
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1576202
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1576202:
    movl %eax, -4(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1576203"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1576203:
# check bounds on vector index
    movl -4(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1576205
    cmp  $0,%eax
    jge _L_1576204
_L_1576205:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1576204:
    movl %eax, -8(%esp)
# emit-expr (closure (f259445 f259446) (f259442) (let ((f259445 f259445) (f259446 f259446)) (if (null? f259445) f259446 ((vector-ref f259442 0) (cdr f259445) (cons (car f259445) f259446)))))
# emit-closure
# si = -12
# env = ((f259442 . 0))
# expr = (closure (f259445 f259446) (f259442) (let ((f259445 f259445) (f259446 f259446)) (if (null? f259445) f259446 ((vector-ref f259442 0) (cdr f259445) (cons (car f259445) f259446)))))
    movl $_L_1576206, 0(%ebp)  # closure label
# emit-variable-ref
# env=((f259442 . 0))
# var=f259442
    movl 0(%esp), %eax  # stack load f259442
# end emit-variable-ref
   movl  %eax, 4(%ebp)  # f259442
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $8, %ebp     # bump ebp
    jmp _L_1576207            # jump around closure body
_L_1576206:
# check argument count
    cmp $8,%eax
    je _L_1576208
# invoke error handler eh_argcount
    .extern mrc_eh$uargcount
    movl mrc_eh$uargcount, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_1576208:
# emit-tail-expr
# si=-16
# env=((f259446 . -12) (f259445 . -8) (f259442 . 4) (f259442 . 0))
# expr=(let ((f259445 f259445) (f259446 f259446)) (if (null? f259445) f259446 ((vector-ref f259442 0) (cdr f259445) (cons (car f259445) f259446))))
# emit-tail-let
#  si   = -16
#  env  = ((f259446 . -12) (f259445 . -8) (f259442 . 4) (f259442 . 0))
#  bindings = ((f259445 f259445) (f259446 f259446))
#  body = (if (null? f259445) f259446 ((vector-ref f259442 0) (cdr f259445) (cons (car f259445) f259446)))
# emit-expr f259445
# emit-variable-ref
# env=((f259446 . -12) (f259445 . -8) (f259442 . 4) (f259442 . 0))
# var=f259445
    movl -8(%esp), %eax  # stack load f259445
# end emit-variable-ref
    movl %eax, -16(%esp)  # stack save
# emit-expr f259446
# emit-variable-ref
# env=((f259446 . -12) (f259445 . -8) (f259442 . 4) (f259442 . 0))
# var=f259446
    movl -12(%esp), %eax  # stack load f259446
# end emit-variable-ref
    movl %eax, -20(%esp)  # stack save
# emit-tail-expr
# si=-24
# env=((f259446 . -20) (f259445 . -16) (f259446 . -12) (f259445 . -8) (f259442 . 4) (f259442 . 0))
# expr=(if (null? f259445) f259446 ((vector-ref f259442 0) (cdr f259445) (cons (car f259445) f259446)))
# emit-expr (null? f259445)
# emit-expr f259445
# emit-variable-ref
# env=((f259446 . -20) (f259445 . -16) (f259446 . -12) (f259445 . -8) (f259442 . 4) (f259442 . 0))
# var=f259445
    movl -16(%esp), %eax  # stack load f259445
# end emit-variable-ref
    cmp $63, %eax
    mov $0, %eax
    sete %al
    movzbl %al, %eax
    sal $6, %al
    or $47, %al
    cmp $47, %al
    je _L_1576209
# emit-tail-expr
# si=-24
# env=((f259446 . -20) (f259445 . -16) (f259446 . -12) (f259445 . -8) (f259442 . 4) (f259442 . 0))
# expr=f259446
# emit-tail-variable-ref
# emit-variable-ref
# env=((f259446 . -20) (f259445 . -16) (f259446 . -12) (f259445 . -8) (f259442 . 4) (f259442 . 0))
# var=f259446
    movl -20(%esp), %eax  # stack load f259446
# end emit-variable-ref
    ret
# end emit-tail-variable ref
    jmp _L_1576210
_L_1576209:
# emit-tail-expr
# si=-24
# env=((f259446 . -20) (f259445 . -16) (f259446 . -12) (f259445 . -8) (f259442 . 4) (f259442 . 0))
# expr=((vector-ref f259442 0) (cdr f259445) (cons (car f259445) f259446))
# emit-tail-funcall
#    si   =-24
#    env  = ((f259446 . -20) (f259445 . -16) (f259446 . -12) (f259445 . -8) (f259442 . 4) (f259442 . 0))
#    expr = (funcall (vector-ref f259442 0) (cdr f259445) (cons (car f259445) f259446))
# emit-expr (vector-ref f259442 0)
# emit-expr f259442
# emit-variable-ref
# env=((f259446 . -20) (f259445 . -16) (f259446 . -12) (f259445 . -8) (f259442 . 4) (f259442 . 0))
# var=f259442
    movl 2(%edi), %eax  # frame load f259442
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1576211
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1576211:
    movl %eax, -24(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1576212"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1576212:
# check bounds on vector index
    movl -24(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1576214
    cmp  $0,%eax
    jge _L_1576213
_L_1576214:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1576213:
    movl -24(%esp), %esi
    movl -1(%eax,%esi), %eax
   movl %eax,  -24(%esp)  # stash funcall-oper in next closure slot
# emit-expr (cdr f259445)
# emit-expr f259445
# emit-variable-ref
# env=((f259446 . -20) (f259445 . -16) (f259446 . -12) (f259445 . -8) (f259442 . 4) (f259442 . 0))
# var=f259445
    movl -16(%esp), %eax  # stack load f259445
# end emit-variable-ref
# check the argument is a pair
    movl %eax,%ebx
    and $7, %bl
    cmp $1, %bl
    je _L_1576215
# invoke error handler eh_pair
    .extern mrc_eh$upair
    movl mrc_eh$upair, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $112,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1576215:
    movl 3(%eax), %eax
    mov %eax, -28(%esp)    # arg (cdr f259445)
# emit-expr (cons (car f259445) f259446)
# cons arg1=(car f259445) arg2=f259446
# emit-expr (car f259445)
# emit-expr f259445
# emit-variable-ref
# env=((f259446 . -20) (f259445 . -16) (f259446 . -12) (f259445 . -8) (f259442 . 4) (f259442 . 0))
# var=f259445
    movl -16(%esp), %eax  # stack load f259445
# end emit-variable-ref
# check the argument is a pair
    movl %eax,%ebx
    and $7, %bl
    cmp $1, %bl
    je _L_1576216
# invoke error handler eh_pair
    .extern mrc_eh$upair
    movl mrc_eh$upair, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $108,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1576216:
    movl -1(%eax), %eax
    movl %eax, -32(%esp)
# emit-expr f259446
# emit-variable-ref
# env=((f259446 . -20) (f259445 . -16) (f259446 . -12) (f259445 . -8) (f259442 . 4) (f259442 . 0))
# var=f259446
    movl -20(%esp), %eax  # stack load f259446
# end emit-variable-ref
    movl %eax, 4(%ebp)
    movl -32(%esp), %eax
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    or   $1, %al
    add  $8, %ebp
# cons end
    mov %eax, -32(%esp)    # arg (cons (car f259445) f259446)
    movl -24(%esp), %edi   # load new closure to %edi
# emit-shift-args:  size=3   si=-24  delta=20
    mov -24(%esp), %ebx  # shift frame cell
    mov %ebx, -4(%esp)  # down to base
# emit-shift-args:  size=2   si=-28  delta=20
    mov -28(%esp), %ebx  # shift frame cell
    mov %ebx, -8(%esp)  # down to base
# emit-shift-args:  size=1   si=-32  delta=20
    mov -32(%esp), %ebx  # shift frame cell
    mov %ebx, -12(%esp)  # down to base
# emit-shift-args:  size=0   si=-36  delta=20
    movl $8,%eax   # save arg count
    jmp *-2(%edi)  # tail-funcall
_L_1576210:
    .align 4,0x90
_L_1576207:
    movl -4(%esp), %ebx
    movl -8(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin)
# emit-begin
#   expr=(begin)
#   env=((f259442 . 0))
# emit-expr (begin (closure (f259448) (f259442) (let ((f259448 f259448)) ((vector-ref f259442 0) f259448 ()))))
# emit-begin
#   expr=(begin (closure (f259448) (f259442) (let ((f259448 f259448)) ((vector-ref f259442 0) f259448 ()))))
#   env=((f259442 . 0))
# emit-expr (closure (f259448) (f259442) (let ((f259448 f259448)) ((vector-ref f259442 0) f259448 ())))
# emit-closure
# si = -4
# env = ((f259442 . 0))
# expr = (closure (f259448) (f259442) (let ((f259448 f259448)) ((vector-ref f259442 0) f259448 ())))
    movl $_L_1576217, 0(%ebp)  # closure label
# emit-variable-ref
# env=((f259442 . 0))
# var=f259442
    movl 0(%esp), %eax  # stack load f259442
# end emit-variable-ref
   movl  %eax, 4(%ebp)  # f259442
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $8, %ebp     # bump ebp
    jmp _L_1576218            # jump around closure body
_L_1576217:
# check argument count
    cmp $4,%eax
    je _L_1576219
# invoke error handler eh_argcount
    .extern mrc_eh$uargcount
    movl mrc_eh$uargcount, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_1576219:
# emit-tail-expr
# si=-12
# env=((f259448 . -8) (f259442 . 4) (f259442 . 0))
# expr=(let ((f259448 f259448)) ((vector-ref f259442 0) f259448 ()))
# emit-tail-let
#  si   = -12
#  env  = ((f259448 . -8) (f259442 . 4) (f259442 . 0))
#  bindings = ((f259448 f259448))
#  body = ((vector-ref f259442 0) f259448 ())
# emit-expr f259448
# emit-variable-ref
# env=((f259448 . -8) (f259442 . 4) (f259442 . 0))
# var=f259448
    movl -8(%esp), %eax  # stack load f259448
# end emit-variable-ref
    movl %eax, -12(%esp)  # stack save
# emit-tail-expr
# si=-16
# env=((f259448 . -12) (f259448 . -8) (f259442 . 4) (f259442 . 0))
# expr=((vector-ref f259442 0) f259448 ())
# emit-tail-funcall
#    si   =-16
#    env  = ((f259448 . -12) (f259448 . -8) (f259442 . 4) (f259442 . 0))
#    expr = (funcall (vector-ref f259442 0) f259448 ())
# emit-expr (vector-ref f259442 0)
# emit-expr f259442
# emit-variable-ref
# env=((f259448 . -12) (f259448 . -8) (f259442 . 4) (f259442 . 0))
# var=f259442
    movl 2(%edi), %eax  # frame load f259442
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1576220
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1576220:
    movl %eax, -16(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1576221"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1576221:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1576223
    cmp  $0,%eax
    jge _L_1576222
_L_1576223:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1576222:
    movl -16(%esp), %esi
    movl -1(%eax,%esi), %eax
   movl %eax,  -16(%esp)  # stash funcall-oper in next closure slot
# emit-expr f259448
# emit-variable-ref
# env=((f259448 . -12) (f259448 . -8) (f259442 . 4) (f259442 . 0))
# var=f259448
    movl -12(%esp), %eax  # stack load f259448
# end emit-variable-ref
    mov %eax, -20(%esp)    # arg f259448
# emit-expr ()
    movl $63, %eax     # immed ()
    mov %eax, -24(%esp)    # arg ()
    movl -16(%esp), %edi   # load new closure to %edi
# emit-shift-args:  size=3   si=-16  delta=12
    mov -16(%esp), %ebx  # shift frame cell
    mov %ebx, -4(%esp)  # down to base
# emit-shift-args:  size=2   si=-20  delta=12
    mov -20(%esp), %ebx  # shift frame cell
    mov %ebx, -8(%esp)  # down to base
# emit-shift-args:  size=1   si=-24  delta=12
    mov -24(%esp), %ebx  # shift frame cell
    mov %ebx, -12(%esp)  # down to base
# emit-shift-args:  size=0   si=-28  delta=12
    movl $8,%eax   # save arg count
    jmp *-2(%edi)  # tail-funcall
    .align 4,0x90
_L_1576218:
# emit-expr (begin)
# emit-begin
#   expr=(begin)
#   env=((f259442 . 0))
     movl %eax, mrc_reverse
# == explicit-begins  ==>
# (letrec ((fill-vector (lambda (v k args) (if (null? args) v (begin (vector-set! v k (car args)) (fill-vector v (fxadd1 k) (cdr args))))))) (lambda args (let ((v (make-vector (list-length args)))) (fill-vector v 0 args))))
# == eliminate-let*  ==>
# (letrec ((fill-vector (lambda (v k args) (if (null? args) v (begin (vector-set! v k (car args)) (fill-vector v (fxadd1 k) (cdr args))))))) (lambda args (let ((v (make-vector (list-length args)))) (fill-vector v 0 args))))
# == uniquify-variables  ==>
# (letrec ((f259449 (lambda (f259453 f259454 f259455) (if (null? f259455) f259453 (begin (vector-set! f259453 f259454 (car f259455)) (f259449 f259453 (fxadd1 f259454) (cdr f259455))))))) (lambda f259459 (let ((f259461 (make-vector (list-length f259459)))) (f259449 f259461 0 f259459))))
# == vectorize-letrec  ==>
# (let ((f259449 (make-vector 1))) (begin (begin (vector-set! f259449 0 (lambda (f259453 f259454 f259455) (if (null? f259455) f259453 (begin (vector-set! f259453 f259454 (car f259455)) ((vector-ref f259449 0) f259453 (fxadd1 f259454) (cdr f259455))))))) (lambda f259459 (let ((f259461 (make-vector (list-length f259459)))) ((vector-ref f259449 0) f259461 0 f259459)))))
# == eliminate-set!  ==>
# (let ((f259449 (make-vector 1))) (begin (begin (vector-set! f259449 0 (lambda (f259453 f259454 f259455) (let ((f259453 f259453) (f259454 f259454) (f259455 f259455)) (if (null? f259455) f259453 (begin (vector-set! f259453 f259454 (car f259455)) ((vector-ref f259449 0) f259453 (fxadd1 f259454) (cdr f259455)))))))) (lambda f259459 (let () (let ((f259461 (make-vector (list-length f259459)))) ((vector-ref f259449 0) f259461 0 f259459))))))
# == close-free-variables  ==>
# (let ((f259449 (make-vector 1))) (begin (begin (vector-set! f259449 0 (closure (f259453 f259454 f259455) (f259449) (let ((f259453 f259453) (f259454 f259454) (f259455 f259455)) (if (null? f259455) f259453 (begin (vector-set! f259453 f259454 (car f259455)) ((vector-ref f259449 0) f259453 (fxadd1 f259454) (cdr f259455)))))))) (closure f259459 (f259449) (let () (let ((f259461 (make-vector (list-length f259459)))) ((vector-ref f259449 0) f259461 0 f259459))))))
# == eliminate-quote  ==>
# (let ((f259449 (make-vector 1))) (begin (begin (vector-set! f259449 0 (closure (f259453 f259454 f259455) (f259449) (let ((f259453 f259453) (f259454 f259454) (f259455 f259455)) (if (null? f259455) f259453 (begin (vector-set! f259453 f259454 (car f259455)) ((vector-ref f259449 0) f259453 (fxadd1 f259454) (cdr f259455)))))))) (closure f259459 (f259449) (let () (let ((f259461 (make-vector (list-length f259459)))) ((vector-ref f259449 0) f259461 0 f259459))))))
# == eliminate-when/unless  ==>
# (let ((f259449 (make-vector 1))) (begin (begin (vector-set! f259449 0 (closure (f259453 f259454 f259455) (f259449) (let ((f259453 f259453) (f259454 f259454) (f259455 f259455)) (if (null? f259455) f259453 (begin (vector-set! f259453 f259454 (car f259455)) ((vector-ref f259449 0) f259453 (fxadd1 f259454) (cdr f259455)))))))) (closure f259459 (f259449) (let () (let ((f259461 (make-vector (list-length f259459)))) ((vector-ref f259449 0) f259461 0 f259459))))))
# == eliminate-cond  ==>
# (let ((f259449 (make-vector 1))) (begin (begin (vector-set! f259449 0 (closure (f259453 f259454 f259455) (f259449) (let ((f259453 f259453) (f259454 f259454) (f259455 f259455)) (if (null? f259455) f259453 (begin (vector-set! f259453 f259454 (car f259455)) ((vector-ref f259449 0) f259453 (fxadd1 f259454) (cdr f259455)))))))) (closure f259459 (f259449) (let () (let ((f259461 (make-vector (list-length f259459)))) ((vector-ref f259449 0) f259461 0 f259459))))))
# == external-symbols  ==>
# (let ((f259449 (make-vector 1))) (begin (begin (vector-set! f259449 0 (closure (f259453 f259454 f259455) (f259449) (let ((f259453 f259453) (f259454 f259454) (f259455 f259455)) (if (null? f259455) f259453 (begin (vector-set! f259453 f259454 (car f259455)) ((vector-ref f259449 0) f259453 (fxadd1 f259454) (cdr f259455)))))))) (closure f259459 (f259449) (let () (let ((f259461 (make-vector ((primitive-ref list-length) f259459)))) ((vector-ref f259449 0) f259461 0 f259459))))))
# emit-expr (let ((f259449 (make-vector 1))) (begin (begin (vector-set! f259449 0 (closure (f259453 f259454 f259455) (f259449) (let ((f259453 f259453) (f259454 f259454) (f259455 f259455)) (if (null? f259455) f259453 (begin (vector-set! f259453 f259454 (car f259455)) ((vector-ref f259449 0) f259453 (fxadd1 f259454) (cdr f259455)))))))) (closure f259459 (f259449) (let () (let ((f259461 (make-vector ((primitive-ref list-length) f259459)))) ((vector-ref f259449 0) f259461 0 f259459))))))
# emit-let
#  si   = 0
#  env  = ()
#  bindings = ((f259449 (make-vector 1)))
#  body = (begin (begin (vector-set! f259449 0 (closure (f259453 f259454 f259455) (f259449) (let ((f259453 f259453) (f259454 f259454) (f259455 f259455)) (if (null? f259455) f259453 (begin (vector-set! f259453 f259454 (car f259455)) ((vector-ref f259449 0) f259453 (fxadd1 f259454) (cdr f259455)))))))) (closure f259459 (f259449) (let () (let ((f259461 (make-vector ((primitive-ref list-length) f259459)))) ((vector-ref f259449 0) f259461 0 f259459)))))
# emit-expr (make-vector 1)
# make-vector 1
# emit-expr 1
    movl $4, %eax     # immed 1
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1576224"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $128,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1576224:
# check the argument is a fixnum >= 0
    cmp $0,%eax
    jge _L_1576225
# invoke error handler eh_length
    .extern mrc_eh$ulength
    movl mrc_eh$ulength, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $128,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1576225:
    movl %eax, %esi
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    orl  $5, %eax
    addl $4, %esi
    addl $4, %esi
    andl $-8, %esi
    addl %esi, %ebp
    movl %eax, 0(%esp)  # stack save
# emit-expr (begin (begin (vector-set! f259449 0 (closure (f259453 f259454 f259455) (f259449) (let ((f259453 f259453) (f259454 f259454) (f259455 f259455)) (if (null? f259455) f259453 (begin (vector-set! f259453 f259454 (car f259455)) ((vector-ref f259449 0) f259453 (fxadd1 f259454) (cdr f259455)))))))) (closure f259459 (f259449) (let () (let ((f259461 (make-vector ((primitive-ref list-length) f259459)))) ((vector-ref f259449 0) f259461 0 f259459)))))
# emit-begin
#   expr=(begin (begin (vector-set! f259449 0 (closure (f259453 f259454 f259455) (f259449) (let ((f259453 f259453) (f259454 f259454) (f259455 f259455)) (if (null? f259455) f259453 (begin (vector-set! f259453 f259454 (car f259455)) ((vector-ref f259449 0) f259453 (fxadd1 f259454) (cdr f259455)))))))) (closure f259459 (f259449) (let () (let ((f259461 (make-vector ((primitive-ref list-length) f259459)))) ((vector-ref f259449 0) f259461 0 f259459)))))
#   env=((f259449 . 0))
# emit-expr (begin (vector-set! f259449 0 (closure (f259453 f259454 f259455) (f259449) (let ((f259453 f259453) (f259454 f259454) (f259455 f259455)) (if (null? f259455) f259453 (begin (vector-set! f259453 f259454 (car f259455)) ((vector-ref f259449 0) f259453 (fxadd1 f259454) (cdr f259455))))))))
# emit-begin
#   expr=(begin (vector-set! f259449 0 (closure (f259453 f259454 f259455) (f259449) (let ((f259453 f259453) (f259454 f259454) (f259455 f259455)) (if (null? f259455) f259453 (begin (vector-set! f259453 f259454 (car f259455)) ((vector-ref f259449 0) f259453 (fxadd1 f259454) (cdr f259455))))))))
#   env=((f259449 . 0))
# emit-expr (vector-set! f259449 0 (closure (f259453 f259454 f259455) (f259449) (let ((f259453 f259453) (f259454 f259454) (f259455 f259455)) (if (null? f259455) f259453 (begin (vector-set! f259453 f259454 (car f259455)) ((vector-ref f259449 0) f259453 (fxadd1 f259454) (cdr f259455)))))))
# emit-expr f259449
# emit-variable-ref
# env=((f259449 . 0))
# var=f259449
    movl 0(%esp), %eax  # stack load f259449
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1576226
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1576226:
    movl %eax, -4(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1576227"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1576227:
# check bounds on vector index
    movl -4(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1576229
    cmp  $0,%eax
    jge _L_1576228
_L_1576229:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1576228:
    movl %eax, -8(%esp)
# emit-expr (closure (f259453 f259454 f259455) (f259449) (let ((f259453 f259453) (f259454 f259454) (f259455 f259455)) (if (null? f259455) f259453 (begin (vector-set! f259453 f259454 (car f259455)) ((vector-ref f259449 0) f259453 (fxadd1 f259454) (cdr f259455))))))
# emit-closure
# si = -12
# env = ((f259449 . 0))
# expr = (closure (f259453 f259454 f259455) (f259449) (let ((f259453 f259453) (f259454 f259454) (f259455 f259455)) (if (null? f259455) f259453 (begin (vector-set! f259453 f259454 (car f259455)) ((vector-ref f259449 0) f259453 (fxadd1 f259454) (cdr f259455))))))
    movl $_L_1576230, 0(%ebp)  # closure label
# emit-variable-ref
# env=((f259449 . 0))
# var=f259449
    movl 0(%esp), %eax  # stack load f259449
# end emit-variable-ref
   movl  %eax, 4(%ebp)  # f259449
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $8, %ebp     # bump ebp
    jmp _L_1576231            # jump around closure body
_L_1576230:
# check argument count
    cmp $12,%eax
    je _L_1576232
# invoke error handler eh_argcount
    .extern mrc_eh$uargcount
    movl mrc_eh$uargcount, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_1576232:
# emit-tail-expr
# si=-20
# env=((f259455 . -16) (f259454 . -12) (f259453 . -8) (f259449 . 4) (f259449 . 0))
# expr=(let ((f259453 f259453) (f259454 f259454) (f259455 f259455)) (if (null? f259455) f259453 (begin (vector-set! f259453 f259454 (car f259455)) ((vector-ref f259449 0) f259453 (fxadd1 f259454) (cdr f259455)))))
# emit-tail-let
#  si   = -20
#  env  = ((f259455 . -16) (f259454 . -12) (f259453 . -8) (f259449 . 4) (f259449 . 0))
#  bindings = ((f259453 f259453) (f259454 f259454) (f259455 f259455))
#  body = (if (null? f259455) f259453 (begin (vector-set! f259453 f259454 (car f259455)) ((vector-ref f259449 0) f259453 (fxadd1 f259454) (cdr f259455))))
# emit-expr f259453
# emit-variable-ref
# env=((f259455 . -16) (f259454 . -12) (f259453 . -8) (f259449 . 4) (f259449 . 0))
# var=f259453
    movl -8(%esp), %eax  # stack load f259453
# end emit-variable-ref
    movl %eax, -20(%esp)  # stack save
# emit-expr f259454
# emit-variable-ref
# env=((f259455 . -16) (f259454 . -12) (f259453 . -8) (f259449 . 4) (f259449 . 0))
# var=f259454
    movl -12(%esp), %eax  # stack load f259454
# end emit-variable-ref
    movl %eax, -24(%esp)  # stack save
# emit-expr f259455
# emit-variable-ref
# env=((f259455 . -16) (f259454 . -12) (f259453 . -8) (f259449 . 4) (f259449 . 0))
# var=f259455
    movl -16(%esp), %eax  # stack load f259455
# end emit-variable-ref
    movl %eax, -28(%esp)  # stack save
# emit-tail-expr
# si=-32
# env=((f259455 . -28) (f259454 . -24) (f259453 . -20) (f259455 . -16) (f259454 . -12) (f259453 . -8) (f259449 . 4) (f259449 . 0))
# expr=(if (null? f259455) f259453 (begin (vector-set! f259453 f259454 (car f259455)) ((vector-ref f259449 0) f259453 (fxadd1 f259454) (cdr f259455))))
# emit-expr (null? f259455)
# emit-expr f259455
# emit-variable-ref
# env=((f259455 . -28) (f259454 . -24) (f259453 . -20) (f259455 . -16) (f259454 . -12) (f259453 . -8) (f259449 . 4) (f259449 . 0))
# var=f259455
    movl -28(%esp), %eax  # stack load f259455
# end emit-variable-ref
    cmp $63, %eax
    mov $0, %eax
    sete %al
    movzbl %al, %eax
    sal $6, %al
    or $47, %al
    cmp $47, %al
    je _L_1576233
# emit-tail-expr
# si=-32
# env=((f259455 . -28) (f259454 . -24) (f259453 . -20) (f259455 . -16) (f259454 . -12) (f259453 . -8) (f259449 . 4) (f259449 . 0))
# expr=f259453
# emit-tail-variable-ref
# emit-variable-ref
# env=((f259455 . -28) (f259454 . -24) (f259453 . -20) (f259455 . -16) (f259454 . -12) (f259453 . -8) (f259449 . 4) (f259449 . 0))
# var=f259453
    movl -20(%esp), %eax  # stack load f259453
# end emit-variable-ref
    ret
# end emit-tail-variable ref
    jmp _L_1576234
_L_1576233:
# emit-tail-expr
# si=-32
# env=((f259455 . -28) (f259454 . -24) (f259453 . -20) (f259455 . -16) (f259454 . -12) (f259453 . -8) (f259449 . 4) (f259449 . 0))
# expr=(begin (vector-set! f259453 f259454 (car f259455)) ((vector-ref f259449 0) f259453 (fxadd1 f259454) (cdr f259455)))
# tail-begin (begin (vector-set! f259453 f259454 (car f259455)) ((vector-ref f259449 0) f259453 (fxadd1 f259454) (cdr f259455)))
#   env=((f259455 . -28) (f259454 . -24) (f259453 . -20) (f259455 . -16) (f259454 . -12) (f259453 . -8) (f259449 . 4) (f259449 . 0))
# emit-expr (vector-set! f259453 f259454 (car f259455))
# emit-expr f259453
# emit-variable-ref
# env=((f259455 . -28) (f259454 . -24) (f259453 . -20) (f259455 . -16) (f259454 . -12) (f259453 . -8) (f259449 . 4) (f259449 . 0))
# var=f259453
    movl -20(%esp), %eax  # stack load f259453
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1576235
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1576235:
    movl %eax, -32(%esp)
# emit-expr f259454
# emit-variable-ref
# env=((f259455 . -28) (f259454 . -24) (f259453 . -20) (f259455 . -16) (f259454 . -12) (f259453 . -8) (f259449 . 4) (f259449 . 0))
# var=f259454
    movl -24(%esp), %eax  # stack load f259454
# end emit-variable-ref
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1576236"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1576236:
# check bounds on vector index
    movl -32(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1576238
    cmp  $0,%eax
    jge _L_1576237
_L_1576238:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1576237:
    movl %eax, -36(%esp)
# emit-expr (car f259455)
# emit-expr f259455
# emit-variable-ref
# env=((f259455 . -28) (f259454 . -24) (f259453 . -20) (f259455 . -16) (f259454 . -12) (f259453 . -8) (f259449 . 4) (f259449 . 0))
# var=f259455
    movl -28(%esp), %eax  # stack load f259455
# end emit-variable-ref
# check the argument is a pair
    movl %eax,%ebx
    and $7, %bl
    cmp $1, %bl
    je _L_1576239
# invoke error handler eh_pair
    .extern mrc_eh$upair
    movl mrc_eh$upair, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $108,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1576239:
    movl -1(%eax), %eax
    movl -32(%esp), %ebx
    movl -36(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-tail-expr
# si=-32
# env=((f259455 . -28) (f259454 . -24) (f259453 . -20) (f259455 . -16) (f259454 . -12) (f259453 . -8) (f259449 . 4) (f259449 . 0))
# expr=(begin ((vector-ref f259449 0) f259453 (fxadd1 f259454) (cdr f259455)))
# tail-begin (begin ((vector-ref f259449 0) f259453 (fxadd1 f259454) (cdr f259455)))
#   env=((f259455 . -28) (f259454 . -24) (f259453 . -20) (f259455 . -16) (f259454 . -12) (f259453 . -8) (f259449 . 4) (f259449 . 0))
# emit-tail-expr
# si=-32
# env=((f259455 . -28) (f259454 . -24) (f259453 . -20) (f259455 . -16) (f259454 . -12) (f259453 . -8) (f259449 . 4) (f259449 . 0))
# expr=((vector-ref f259449 0) f259453 (fxadd1 f259454) (cdr f259455))
# emit-tail-funcall
#    si   =-32
#    env  = ((f259455 . -28) (f259454 . -24) (f259453 . -20) (f259455 . -16) (f259454 . -12) (f259453 . -8) (f259449 . 4) (f259449 . 0))
#    expr = (funcall (vector-ref f259449 0) f259453 (fxadd1 f259454) (cdr f259455))
# emit-expr (vector-ref f259449 0)
# emit-expr f259449
# emit-variable-ref
# env=((f259455 . -28) (f259454 . -24) (f259453 . -20) (f259455 . -16) (f259454 . -12) (f259453 . -8) (f259449 . 4) (f259449 . 0))
# var=f259449
    movl 2(%edi), %eax  # frame load f259449
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1576240
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1576240:
    movl %eax, -32(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1576241"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1576241:
# check bounds on vector index
    movl -32(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1576243
    cmp  $0,%eax
    jge _L_1576242
_L_1576243:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1576242:
    movl -32(%esp), %esi
    movl -1(%eax,%esi), %eax
   movl %eax,  -32(%esp)  # stash funcall-oper in next closure slot
# emit-expr f259453
# emit-variable-ref
# env=((f259455 . -28) (f259454 . -24) (f259453 . -20) (f259455 . -16) (f259454 . -12) (f259453 . -8) (f259449 . 4) (f259449 . 0))
# var=f259453
    movl -20(%esp), %eax  # stack load f259453
# end emit-variable-ref
    mov %eax, -36(%esp)    # arg f259453
# emit-expr (fxadd1 f259454)
# emit-expr f259454
# emit-variable-ref
# env=((f259455 . -28) (f259454 . -24) (f259453 . -20) (f259455 . -16) (f259454 . -12) (f259453 . -8) (f259449 . 4) (f259449 . 0))
# var=f259454
    movl -24(%esp), %eax  # stack load f259454
# end emit-variable-ref
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1576244"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $48,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1576244:
     addl $4, %eax
    mov %eax, -40(%esp)    # arg (fxadd1 f259454)
# emit-expr (cdr f259455)
# emit-expr f259455
# emit-variable-ref
# env=((f259455 . -28) (f259454 . -24) (f259453 . -20) (f259455 . -16) (f259454 . -12) (f259453 . -8) (f259449 . 4) (f259449 . 0))
# var=f259455
    movl -28(%esp), %eax  # stack load f259455
# end emit-variable-ref
# check the argument is a pair
    movl %eax,%ebx
    and $7, %bl
    cmp $1, %bl
    je _L_1576245
# invoke error handler eh_pair
    .extern mrc_eh$upair
    movl mrc_eh$upair, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $112,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1576245:
    movl 3(%eax), %eax
    mov %eax, -44(%esp)    # arg (cdr f259455)
    movl -32(%esp), %edi   # load new closure to %edi
# emit-shift-args:  size=4   si=-32  delta=28
    mov -32(%esp), %ebx  # shift frame cell
    mov %ebx, -4(%esp)  # down to base
# emit-shift-args:  size=3   si=-36  delta=28
    mov -36(%esp), %ebx  # shift frame cell
    mov %ebx, -8(%esp)  # down to base
# emit-shift-args:  size=2   si=-40  delta=28
    mov -40(%esp), %ebx  # shift frame cell
    mov %ebx, -12(%esp)  # down to base
# emit-shift-args:  size=1   si=-44  delta=28
    mov -44(%esp), %ebx  # shift frame cell
    mov %ebx, -16(%esp)  # down to base
# emit-shift-args:  size=0   si=-48  delta=28
    movl $12,%eax   # save arg count
    jmp *-2(%edi)  # tail-funcall
     ret   # return thru stack
_L_1576234:
    .align 4,0x90
_L_1576231:
    movl -4(%esp), %ebx
    movl -8(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin)
# emit-begin
#   expr=(begin)
#   env=((f259449 . 0))
# emit-expr (begin (closure f259459 (f259449) (let () (let ((f259461 (make-vector ((primitive-ref list-length) f259459)))) ((vector-ref f259449 0) f259461 0 f259459)))))
# emit-begin
#   expr=(begin (closure f259459 (f259449) (let () (let ((f259461 (make-vector ((primitive-ref list-length) f259459)))) ((vector-ref f259449 0) f259461 0 f259459)))))
#   env=((f259449 . 0))
# emit-expr (closure f259459 (f259449) (let () (let ((f259461 (make-vector ((primitive-ref list-length) f259459)))) ((vector-ref f259449 0) f259461 0 f259459))))
# emit-closure
# si = -4
# env = ((f259449 . 0))
# expr = (closure f259459 (f259449) (let () (let ((f259461 (make-vector ((primitive-ref list-length) f259459)))) ((vector-ref f259449 0) f259461 0 f259459))))
    movl $_L_1576246, 0(%ebp)  # closure label
# emit-variable-ref
# env=((f259449 . 0))
# var=f259449
    movl 0(%esp), %eax  # stack load f259449
# end emit-variable-ref
   movl  %eax, 4(%ebp)  # f259449
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $8, %ebp     # bump ebp
    jmp _L_1576247            # jump around closure body
_L_1576246:
# check argument count
    cmp $0,%eax
    jge _L_1576248
# invoke error handler eh_argcount_min
    .extern mrc_eh$uargcount$umin
    movl mrc_eh$uargcount$umin, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_1576248:
# emit-build-varargs-list
    movl $63, %esi       # args <- () 
    lea -4(%esp),%edi    # edi <- esp-4
    subl %eax, %edi      # edi <- esp-4-eax    addr of arg[K+N] on stack
_L_1576250:
    lea -4(%esp),%ebx    # addr of arg[K] on stack
    cmp %edi, %ebx       # while edi <> esp+(si+4)
    je _L_1576249
    movl (%edi),%ebx     # arg i -> car
    movl %ebx, 0(%ebp)
    movl %esi, 4(%ebp)  # esi -> cdr
    movl %ebp, %esi
    addl $1, %esi       # tag as pair
    addl $8,%ebp         # bump heap ptr
    addl $4,%edi         # move to next previous arg from the end
    jmp _L_1576250
_L_1576249:
    movl %esi, -8(%esp)  # set args
# emit-tail-expr
# si=-12
# env=((f259459 . -8) (f259449 . 4) (f259449 . 0))
# expr=(let () (let ((f259461 (make-vector ((primitive-ref list-length) f259459)))) ((vector-ref f259449 0) f259461 0 f259459)))
# emit-tail-let
#  si   = -12
#  env  = ((f259459 . -8) (f259449 . 4) (f259449 . 0))
#  bindings = ()
#  body = (let ((f259461 (make-vector ((primitive-ref list-length) f259459)))) ((vector-ref f259449 0) f259461 0 f259459))
# emit-tail-expr
# si=-12
# env=((f259459 . -8) (f259449 . 4) (f259449 . 0))
# expr=(let ((f259461 (make-vector ((primitive-ref list-length) f259459)))) ((vector-ref f259449 0) f259461 0 f259459))
# emit-tail-let
#  si   = -12
#  env  = ((f259459 . -8) (f259449 . 4) (f259449 . 0))
#  bindings = ((f259461 (make-vector ((primitive-ref list-length) f259459))))
#  body = ((vector-ref f259449 0) f259461 0 f259459)
# emit-expr (make-vector ((primitive-ref list-length) f259459))
# make-vector ((primitive-ref list-length) f259459)
# emit-expr ((primitive-ref list-length) f259459)
# funcall
#    si   =-12
#    env  = ((f259459 . -8) (f259449 . 4) (f259449 . 0))
#    expr = (funcall (primitive-ref list-length) f259459)
# emit-expr (primitive-ref list-length)
    .extern mrc_list$mlength
    movl mrc_list$mlength,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1576251"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1576251":
   movl %eax,  -20(%esp)  # stash funcall-oper in closure slot
# emit-expr f259459
# emit-variable-ref
# env=((f259459 . -8) (f259449 . 4) (f259449 . 0))
# var=f259459
    movl -8(%esp), %eax  # stack load f259459
# end emit-variable-ref
    mov %eax, -24(%esp)  # arg f259459
    movl -20(%esp), %edi   # load new closure to %edi
    add $-12, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $12, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1576252"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $128,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1576252:
# check the argument is a fixnum >= 0
    cmp $0,%eax
    jge _L_1576253
# invoke error handler eh_length
    .extern mrc_eh$ulength
    movl mrc_eh$ulength, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $128,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1576253:
    movl %eax, %esi
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    orl  $5, %eax
    addl $4, %esi
    addl $4, %esi
    andl $-8, %esi
    addl %esi, %ebp
    movl %eax, -12(%esp)  # stack save
# emit-tail-expr
# si=-16
# env=((f259461 . -12) (f259459 . -8) (f259449 . 4) (f259449 . 0))
# expr=((vector-ref f259449 0) f259461 0 f259459)
# emit-tail-funcall
#    si   =-16
#    env  = ((f259461 . -12) (f259459 . -8) (f259449 . 4) (f259449 . 0))
#    expr = (funcall (vector-ref f259449 0) f259461 0 f259459)
# emit-expr (vector-ref f259449 0)
# emit-expr f259449
# emit-variable-ref
# env=((f259461 . -12) (f259459 . -8) (f259449 . 4) (f259449 . 0))
# var=f259449
    movl 2(%edi), %eax  # frame load f259449
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1576254
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1576254:
    movl %eax, -16(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1576255"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1576255:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1576257
    cmp  $0,%eax
    jge _L_1576256
_L_1576257:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1576256:
    movl -16(%esp), %esi
    movl -1(%eax,%esi), %eax
   movl %eax,  -16(%esp)  # stash funcall-oper in next closure slot
# emit-expr f259461
# emit-variable-ref
# env=((f259461 . -12) (f259459 . -8) (f259449 . 4) (f259449 . 0))
# var=f259461
    movl -12(%esp), %eax  # stack load f259461
# end emit-variable-ref
    mov %eax, -20(%esp)    # arg f259461
# emit-expr 0
    movl $0, %eax     # immed 0
    mov %eax, -24(%esp)    # arg 0
# emit-expr f259459
# emit-variable-ref
# env=((f259461 . -12) (f259459 . -8) (f259449 . 4) (f259449 . 0))
# var=f259459
    movl -8(%esp), %eax  # stack load f259459
# end emit-variable-ref
    mov %eax, -28(%esp)    # arg f259459
    movl -16(%esp), %edi   # load new closure to %edi
# emit-shift-args:  size=4   si=-16  delta=12
    mov -16(%esp), %ebx  # shift frame cell
    mov %ebx, -4(%esp)  # down to base
# emit-shift-args:  size=3   si=-20  delta=12
    mov -20(%esp), %ebx  # shift frame cell
    mov %ebx, -8(%esp)  # down to base
# emit-shift-args:  size=2   si=-24  delta=12
    mov -24(%esp), %ebx  # shift frame cell
    mov %ebx, -12(%esp)  # down to base
# emit-shift-args:  size=1   si=-28  delta=12
    mov -28(%esp), %ebx  # shift frame cell
    mov %ebx, -16(%esp)  # down to base
# emit-shift-args:  size=0   si=-32  delta=12
    movl $12,%eax   # save arg count
    jmp *-2(%edi)  # tail-funcall
    .align 4,0x90
_L_1576247:
# emit-expr (begin)
# emit-begin
#   expr=(begin)
#   env=((f259449 . 0))
     movl %eax, mrc_vector
# == explicit-begins  ==>
# (letrec ((fill-string (lambda (s k args) (if (null? args) s (begin (string-set! s k (car args)) (fill-string s (fxadd1 k) (cdr args))))))) (lambda args (let ((s (make-string (list-length args)))) (fill-string s 0 args))))
# == eliminate-let*  ==>
# (letrec ((fill-string (lambda (s k args) (if (null? args) s (begin (string-set! s k (car args)) (fill-string s (fxadd1 k) (cdr args))))))) (lambda args (let ((s (make-string (list-length args)))) (fill-string s 0 args))))
# == uniquify-variables  ==>
# (letrec ((f259462 (lambda (f259466 f259467 f259468) (if (null? f259468) f259466 (begin (string-set! f259466 f259467 (car f259468)) (f259462 f259466 (fxadd1 f259467) (cdr f259468))))))) (lambda f259472 (let ((f259474 (make-string (list-length f259472)))) (f259462 f259474 0 f259472))))
# == vectorize-letrec  ==>
# (let ((f259462 (make-vector 1))) (begin (begin (vector-set! f259462 0 (lambda (f259466 f259467 f259468) (if (null? f259468) f259466 (begin (string-set! f259466 f259467 (car f259468)) ((vector-ref f259462 0) f259466 (fxadd1 f259467) (cdr f259468))))))) (lambda f259472 (let ((f259474 (make-string (list-length f259472)))) ((vector-ref f259462 0) f259474 0 f259472)))))
# == eliminate-set!  ==>
# (let ((f259462 (make-vector 1))) (begin (begin (vector-set! f259462 0 (lambda (f259466 f259467 f259468) (let ((f259466 f259466) (f259467 f259467) (f259468 f259468)) (if (null? f259468) f259466 (begin (string-set! f259466 f259467 (car f259468)) ((vector-ref f259462 0) f259466 (fxadd1 f259467) (cdr f259468)))))))) (lambda f259472 (let () (let ((f259474 (make-string (list-length f259472)))) ((vector-ref f259462 0) f259474 0 f259472))))))
# == close-free-variables  ==>
# (let ((f259462 (make-vector 1))) (begin (begin (vector-set! f259462 0 (closure (f259466 f259467 f259468) (f259462) (let ((f259466 f259466) (f259467 f259467) (f259468 f259468)) (if (null? f259468) f259466 (begin (string-set! f259466 f259467 (car f259468)) ((vector-ref f259462 0) f259466 (fxadd1 f259467) (cdr f259468)))))))) (closure f259472 (f259462) (let () (let ((f259474 (make-string (list-length f259472)))) ((vector-ref f259462 0) f259474 0 f259472))))))
# == eliminate-quote  ==>
# (let ((f259462 (make-vector 1))) (begin (begin (vector-set! f259462 0 (closure (f259466 f259467 f259468) (f259462) (let ((f259466 f259466) (f259467 f259467) (f259468 f259468)) (if (null? f259468) f259466 (begin (string-set! f259466 f259467 (car f259468)) ((vector-ref f259462 0) f259466 (fxadd1 f259467) (cdr f259468)))))))) (closure f259472 (f259462) (let () (let ((f259474 (make-string (list-length f259472)))) ((vector-ref f259462 0) f259474 0 f259472))))))
# == eliminate-when/unless  ==>
# (let ((f259462 (make-vector 1))) (begin (begin (vector-set! f259462 0 (closure (f259466 f259467 f259468) (f259462) (let ((f259466 f259466) (f259467 f259467) (f259468 f259468)) (if (null? f259468) f259466 (begin (string-set! f259466 f259467 (car f259468)) ((vector-ref f259462 0) f259466 (fxadd1 f259467) (cdr f259468)))))))) (closure f259472 (f259462) (let () (let ((f259474 (make-string (list-length f259472)))) ((vector-ref f259462 0) f259474 0 f259472))))))
# == eliminate-cond  ==>
# (let ((f259462 (make-vector 1))) (begin (begin (vector-set! f259462 0 (closure (f259466 f259467 f259468) (f259462) (let ((f259466 f259466) (f259467 f259467) (f259468 f259468)) (if (null? f259468) f259466 (begin (string-set! f259466 f259467 (car f259468)) ((vector-ref f259462 0) f259466 (fxadd1 f259467) (cdr f259468)))))))) (closure f259472 (f259462) (let () (let ((f259474 (make-string (list-length f259472)))) ((vector-ref f259462 0) f259474 0 f259472))))))
# == external-symbols  ==>
# (let ((f259462 (make-vector 1))) (begin (begin (vector-set! f259462 0 (closure (f259466 f259467 f259468) (f259462) (let ((f259466 f259466) (f259467 f259467) (f259468 f259468)) (if (null? f259468) f259466 (begin (string-set! f259466 f259467 (car f259468)) ((vector-ref f259462 0) f259466 (fxadd1 f259467) (cdr f259468)))))))) (closure f259472 (f259462) (let () (let ((f259474 (make-string ((primitive-ref list-length) f259472)))) ((vector-ref f259462 0) f259474 0 f259472))))))
# emit-expr (let ((f259462 (make-vector 1))) (begin (begin (vector-set! f259462 0 (closure (f259466 f259467 f259468) (f259462) (let ((f259466 f259466) (f259467 f259467) (f259468 f259468)) (if (null? f259468) f259466 (begin (string-set! f259466 f259467 (car f259468)) ((vector-ref f259462 0) f259466 (fxadd1 f259467) (cdr f259468)))))))) (closure f259472 (f259462) (let () (let ((f259474 (make-string ((primitive-ref list-length) f259472)))) ((vector-ref f259462 0) f259474 0 f259472))))))
# emit-let
#  si   = 0
#  env  = ()
#  bindings = ((f259462 (make-vector 1)))
#  body = (begin (begin (vector-set! f259462 0 (closure (f259466 f259467 f259468) (f259462) (let ((f259466 f259466) (f259467 f259467) (f259468 f259468)) (if (null? f259468) f259466 (begin (string-set! f259466 f259467 (car f259468)) ((vector-ref f259462 0) f259466 (fxadd1 f259467) (cdr f259468)))))))) (closure f259472 (f259462) (let () (let ((f259474 (make-string ((primitive-ref list-length) f259472)))) ((vector-ref f259462 0) f259474 0 f259472)))))
# emit-expr (make-vector 1)
# make-vector 1
# emit-expr 1
    movl $4, %eax     # immed 1
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1576258"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $128,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1576258:
# check the argument is a fixnum >= 0
    cmp $0,%eax
    jge _L_1576259
# invoke error handler eh_length
    .extern mrc_eh$ulength
    movl mrc_eh$ulength, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $128,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1576259:
    movl %eax, %esi
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    orl  $5, %eax
    addl $4, %esi
    addl $4, %esi
    andl $-8, %esi
    addl %esi, %ebp
    movl %eax, 0(%esp)  # stack save
# emit-expr (begin (begin (vector-set! f259462 0 (closure (f259466 f259467 f259468) (f259462) (let ((f259466 f259466) (f259467 f259467) (f259468 f259468)) (if (null? f259468) f259466 (begin (string-set! f259466 f259467 (car f259468)) ((vector-ref f259462 0) f259466 (fxadd1 f259467) (cdr f259468)))))))) (closure f259472 (f259462) (let () (let ((f259474 (make-string ((primitive-ref list-length) f259472)))) ((vector-ref f259462 0) f259474 0 f259472)))))
# emit-begin
#   expr=(begin (begin (vector-set! f259462 0 (closure (f259466 f259467 f259468) (f259462) (let ((f259466 f259466) (f259467 f259467) (f259468 f259468)) (if (null? f259468) f259466 (begin (string-set! f259466 f259467 (car f259468)) ((vector-ref f259462 0) f259466 (fxadd1 f259467) (cdr f259468)))))))) (closure f259472 (f259462) (let () (let ((f259474 (make-string ((primitive-ref list-length) f259472)))) ((vector-ref f259462 0) f259474 0 f259472)))))
#   env=((f259462 . 0))
# emit-expr (begin (vector-set! f259462 0 (closure (f259466 f259467 f259468) (f259462) (let ((f259466 f259466) (f259467 f259467) (f259468 f259468)) (if (null? f259468) f259466 (begin (string-set! f259466 f259467 (car f259468)) ((vector-ref f259462 0) f259466 (fxadd1 f259467) (cdr f259468))))))))
# emit-begin
#   expr=(begin (vector-set! f259462 0 (closure (f259466 f259467 f259468) (f259462) (let ((f259466 f259466) (f259467 f259467) (f259468 f259468)) (if (null? f259468) f259466 (begin (string-set! f259466 f259467 (car f259468)) ((vector-ref f259462 0) f259466 (fxadd1 f259467) (cdr f259468))))))))
#   env=((f259462 . 0))
# emit-expr (vector-set! f259462 0 (closure (f259466 f259467 f259468) (f259462) (let ((f259466 f259466) (f259467 f259467) (f259468 f259468)) (if (null? f259468) f259466 (begin (string-set! f259466 f259467 (car f259468)) ((vector-ref f259462 0) f259466 (fxadd1 f259467) (cdr f259468)))))))
# emit-expr f259462
# emit-variable-ref
# env=((f259462 . 0))
# var=f259462
    movl 0(%esp), %eax  # stack load f259462
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1576260
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1576260:
    movl %eax, -4(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1576261"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1576261:
# check bounds on vector index
    movl -4(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1576263
    cmp  $0,%eax
    jge _L_1576262
_L_1576263:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1576262:
    movl %eax, -8(%esp)
# emit-expr (closure (f259466 f259467 f259468) (f259462) (let ((f259466 f259466) (f259467 f259467) (f259468 f259468)) (if (null? f259468) f259466 (begin (string-set! f259466 f259467 (car f259468)) ((vector-ref f259462 0) f259466 (fxadd1 f259467) (cdr f259468))))))
# emit-closure
# si = -12
# env = ((f259462 . 0))
# expr = (closure (f259466 f259467 f259468) (f259462) (let ((f259466 f259466) (f259467 f259467) (f259468 f259468)) (if (null? f259468) f259466 (begin (string-set! f259466 f259467 (car f259468)) ((vector-ref f259462 0) f259466 (fxadd1 f259467) (cdr f259468))))))
    movl $_L_1576264, 0(%ebp)  # closure label
# emit-variable-ref
# env=((f259462 . 0))
# var=f259462
    movl 0(%esp), %eax  # stack load f259462
# end emit-variable-ref
   movl  %eax, 4(%ebp)  # f259462
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $8, %ebp     # bump ebp
    jmp _L_1576265            # jump around closure body
_L_1576264:
# check argument count
    cmp $12,%eax
    je _L_1576266
# invoke error handler eh_argcount
    .extern mrc_eh$uargcount
    movl mrc_eh$uargcount, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_1576266:
# emit-tail-expr
# si=-20
# env=((f259468 . -16) (f259467 . -12) (f259466 . -8) (f259462 . 4) (f259462 . 0))
# expr=(let ((f259466 f259466) (f259467 f259467) (f259468 f259468)) (if (null? f259468) f259466 (begin (string-set! f259466 f259467 (car f259468)) ((vector-ref f259462 0) f259466 (fxadd1 f259467) (cdr f259468)))))
# emit-tail-let
#  si   = -20
#  env  = ((f259468 . -16) (f259467 . -12) (f259466 . -8) (f259462 . 4) (f259462 . 0))
#  bindings = ((f259466 f259466) (f259467 f259467) (f259468 f259468))
#  body = (if (null? f259468) f259466 (begin (string-set! f259466 f259467 (car f259468)) ((vector-ref f259462 0) f259466 (fxadd1 f259467) (cdr f259468))))
# emit-expr f259466
# emit-variable-ref
# env=((f259468 . -16) (f259467 . -12) (f259466 . -8) (f259462 . 4) (f259462 . 0))
# var=f259466
    movl -8(%esp), %eax  # stack load f259466
# end emit-variable-ref
    movl %eax, -20(%esp)  # stack save
# emit-expr f259467
# emit-variable-ref
# env=((f259468 . -16) (f259467 . -12) (f259466 . -8) (f259462 . 4) (f259462 . 0))
# var=f259467
    movl -12(%esp), %eax  # stack load f259467
# end emit-variable-ref
    movl %eax, -24(%esp)  # stack save
# emit-expr f259468
# emit-variable-ref
# env=((f259468 . -16) (f259467 . -12) (f259466 . -8) (f259462 . 4) (f259462 . 0))
# var=f259468
    movl -16(%esp), %eax  # stack load f259468
# end emit-variable-ref
    movl %eax, -28(%esp)  # stack save
# emit-tail-expr
# si=-32
# env=((f259468 . -28) (f259467 . -24) (f259466 . -20) (f259468 . -16) (f259467 . -12) (f259466 . -8) (f259462 . 4) (f259462 . 0))
# expr=(if (null? f259468) f259466 (begin (string-set! f259466 f259467 (car f259468)) ((vector-ref f259462 0) f259466 (fxadd1 f259467) (cdr f259468))))
# emit-expr (null? f259468)
# emit-expr f259468
# emit-variable-ref
# env=((f259468 . -28) (f259467 . -24) (f259466 . -20) (f259468 . -16) (f259467 . -12) (f259466 . -8) (f259462 . 4) (f259462 . 0))
# var=f259468
    movl -28(%esp), %eax  # stack load f259468
# end emit-variable-ref
    cmp $63, %eax
    mov $0, %eax
    sete %al
    movzbl %al, %eax
    sal $6, %al
    or $47, %al
    cmp $47, %al
    je _L_1576267
# emit-tail-expr
# si=-32
# env=((f259468 . -28) (f259467 . -24) (f259466 . -20) (f259468 . -16) (f259467 . -12) (f259466 . -8) (f259462 . 4) (f259462 . 0))
# expr=f259466
# emit-tail-variable-ref
# emit-variable-ref
# env=((f259468 . -28) (f259467 . -24) (f259466 . -20) (f259468 . -16) (f259467 . -12) (f259466 . -8) (f259462 . 4) (f259462 . 0))
# var=f259466
    movl -20(%esp), %eax  # stack load f259466
# end emit-variable-ref
    ret
# end emit-tail-variable ref
    jmp _L_1576268
_L_1576267:
# emit-tail-expr
# si=-32
# env=((f259468 . -28) (f259467 . -24) (f259466 . -20) (f259468 . -16) (f259467 . -12) (f259466 . -8) (f259462 . 4) (f259462 . 0))
# expr=(begin (string-set! f259466 f259467 (car f259468)) ((vector-ref f259462 0) f259466 (fxadd1 f259467) (cdr f259468)))
# tail-begin (begin (string-set! f259466 f259467 (car f259468)) ((vector-ref f259462 0) f259466 (fxadd1 f259467) (cdr f259468)))
#   env=((f259468 . -28) (f259467 . -24) (f259466 . -20) (f259468 . -16) (f259467 . -12) (f259466 . -8) (f259462 . 4) (f259462 . 0))
# emit-expr (string-set! f259466 f259467 (car f259468))
# emit-expr f259466
# emit-variable-ref
# env=((f259468 . -28) (f259467 . -24) (f259466 . -20) (f259468 . -16) (f259467 . -12) (f259466 . -8) (f259462 . 4) (f259462 . 0))
# var=f259466
    movl -20(%esp), %eax  # stack load f259466
# end emit-variable-ref
# check the argument is a string
    movl %eax,%ebx
    and $7, %bl
    cmp $6, %bl
    je _L_1576269
# invoke error handler eh_string
    .extern mrc_eh$ustring
    movl mrc_eh$ustring, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $160,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1576269:
    movl %eax, -32(%esp)
# emit-expr f259467
# emit-variable-ref
# env=((f259468 . -28) (f259467 . -24) (f259466 . -20) (f259468 . -16) (f259467 . -12) (f259466 . -8) (f259462 . 4) (f259462 . 0))
# var=f259467
    movl -24(%esp), %eax  # stack load f259467
# end emit-variable-ref
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1576270"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $160,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1576270:
# check bounds on string index
    movl -32(%esp), %ebx
    cmp  %eax,-6(%ebx) 
    jle _L_1576272
    cmp  $0,%eax
    jge _L_1576271
_L_1576272:
# invoke error handler eh_string_index
    .extern mrc_eh$ustring$uindex
    movl mrc_eh$ustring$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $160,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1576271:
    movl %eax, -36(%esp)
# emit-expr (car f259468)
# emit-expr f259468
# emit-variable-ref
# env=((f259468 . -28) (f259467 . -24) (f259466 . -20) (f259468 . -16) (f259467 . -12) (f259466 . -8) (f259462 . 4) (f259462 . 0))
# var=f259468
    movl -28(%esp), %eax  # stack load f259468
# end emit-variable-ref
# check the argument is a pair
    movl %eax,%ebx
    and $7, %bl
    cmp $1, %bl
    je _L_1576273
# invoke error handler eh_pair
    .extern mrc_eh$upair
    movl mrc_eh$upair, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $108,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1576273:
    movl -1(%eax), %eax
# check the argument is a char
    movl %eax,%ebx
    and $255, %bl
    cmp $15, %bl
    je "_L_1576274"
# invoke error handler eh_character
    .extern mrc_eh$ucharacter
    movl mrc_eh$ucharacter, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $160,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1576274:
    movl -32(%esp), %ebx
    movl -36(%esp), %esi
    sar $2, %esi
    movb  %ah, -2(%ebx,%esi)
# emit-tail-expr
# si=-32
# env=((f259468 . -28) (f259467 . -24) (f259466 . -20) (f259468 . -16) (f259467 . -12) (f259466 . -8) (f259462 . 4) (f259462 . 0))
# expr=(begin ((vector-ref f259462 0) f259466 (fxadd1 f259467) (cdr f259468)))
# tail-begin (begin ((vector-ref f259462 0) f259466 (fxadd1 f259467) (cdr f259468)))
#   env=((f259468 . -28) (f259467 . -24) (f259466 . -20) (f259468 . -16) (f259467 . -12) (f259466 . -8) (f259462 . 4) (f259462 . 0))
# emit-tail-expr
# si=-32
# env=((f259468 . -28) (f259467 . -24) (f259466 . -20) (f259468 . -16) (f259467 . -12) (f259466 . -8) (f259462 . 4) (f259462 . 0))
# expr=((vector-ref f259462 0) f259466 (fxadd1 f259467) (cdr f259468))
# emit-tail-funcall
#    si   =-32
#    env  = ((f259468 . -28) (f259467 . -24) (f259466 . -20) (f259468 . -16) (f259467 . -12) (f259466 . -8) (f259462 . 4) (f259462 . 0))
#    expr = (funcall (vector-ref f259462 0) f259466 (fxadd1 f259467) (cdr f259468))
# emit-expr (vector-ref f259462 0)
# emit-expr f259462
# emit-variable-ref
# env=((f259468 . -28) (f259467 . -24) (f259466 . -20) (f259468 . -16) (f259467 . -12) (f259466 . -8) (f259462 . 4) (f259462 . 0))
# var=f259462
    movl 2(%edi), %eax  # frame load f259462
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1576275
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1576275:
    movl %eax, -32(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1576276"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1576276:
# check bounds on vector index
    movl -32(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1576278
    cmp  $0,%eax
    jge _L_1576277
_L_1576278:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1576277:
    movl -32(%esp), %esi
    movl -1(%eax,%esi), %eax
   movl %eax,  -32(%esp)  # stash funcall-oper in next closure slot
# emit-expr f259466
# emit-variable-ref
# env=((f259468 . -28) (f259467 . -24) (f259466 . -20) (f259468 . -16) (f259467 . -12) (f259466 . -8) (f259462 . 4) (f259462 . 0))
# var=f259466
    movl -20(%esp), %eax  # stack load f259466
# end emit-variable-ref
    mov %eax, -36(%esp)    # arg f259466
# emit-expr (fxadd1 f259467)
# emit-expr f259467
# emit-variable-ref
# env=((f259468 . -28) (f259467 . -24) (f259466 . -20) (f259468 . -16) (f259467 . -12) (f259466 . -8) (f259462 . 4) (f259462 . 0))
# var=f259467
    movl -24(%esp), %eax  # stack load f259467
# end emit-variable-ref
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1576279"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $48,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1576279:
     addl $4, %eax
    mov %eax, -40(%esp)    # arg (fxadd1 f259467)
# emit-expr (cdr f259468)
# emit-expr f259468
# emit-variable-ref
# env=((f259468 . -28) (f259467 . -24) (f259466 . -20) (f259468 . -16) (f259467 . -12) (f259466 . -8) (f259462 . 4) (f259462 . 0))
# var=f259468
    movl -28(%esp), %eax  # stack load f259468
# end emit-variable-ref
# check the argument is a pair
    movl %eax,%ebx
    and $7, %bl
    cmp $1, %bl
    je _L_1576280
# invoke error handler eh_pair
    .extern mrc_eh$upair
    movl mrc_eh$upair, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $112,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1576280:
    movl 3(%eax), %eax
    mov %eax, -44(%esp)    # arg (cdr f259468)
    movl -32(%esp), %edi   # load new closure to %edi
# emit-shift-args:  size=4   si=-32  delta=28
    mov -32(%esp), %ebx  # shift frame cell
    mov %ebx, -4(%esp)  # down to base
# emit-shift-args:  size=3   si=-36  delta=28
    mov -36(%esp), %ebx  # shift frame cell
    mov %ebx, -8(%esp)  # down to base
# emit-shift-args:  size=2   si=-40  delta=28
    mov -40(%esp), %ebx  # shift frame cell
    mov %ebx, -12(%esp)  # down to base
# emit-shift-args:  size=1   si=-44  delta=28
    mov -44(%esp), %ebx  # shift frame cell
    mov %ebx, -16(%esp)  # down to base
# emit-shift-args:  size=0   si=-48  delta=28
    movl $12,%eax   # save arg count
    jmp *-2(%edi)  # tail-funcall
     ret   # return thru stack
_L_1576268:
    .align 4,0x90
_L_1576265:
    movl -4(%esp), %ebx
    movl -8(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin)
# emit-begin
#   expr=(begin)
#   env=((f259462 . 0))
# emit-expr (begin (closure f259472 (f259462) (let () (let ((f259474 (make-string ((primitive-ref list-length) f259472)))) ((vector-ref f259462 0) f259474 0 f259472)))))
# emit-begin
#   expr=(begin (closure f259472 (f259462) (let () (let ((f259474 (make-string ((primitive-ref list-length) f259472)))) ((vector-ref f259462 0) f259474 0 f259472)))))
#   env=((f259462 . 0))
# emit-expr (closure f259472 (f259462) (let () (let ((f259474 (make-string ((primitive-ref list-length) f259472)))) ((vector-ref f259462 0) f259474 0 f259472))))
# emit-closure
# si = -4
# env = ((f259462 . 0))
# expr = (closure f259472 (f259462) (let () (let ((f259474 (make-string ((primitive-ref list-length) f259472)))) ((vector-ref f259462 0) f259474 0 f259472))))
    movl $_L_1576281, 0(%ebp)  # closure label
# emit-variable-ref
# env=((f259462 . 0))
# var=f259462
    movl 0(%esp), %eax  # stack load f259462
# end emit-variable-ref
   movl  %eax, 4(%ebp)  # f259462
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $8, %ebp     # bump ebp
    jmp _L_1576282            # jump around closure body
_L_1576281:
# check argument count
    cmp $0,%eax
    jge _L_1576283
# invoke error handler eh_argcount_min
    .extern mrc_eh$uargcount$umin
    movl mrc_eh$uargcount$umin, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_1576283:
# emit-build-varargs-list
    movl $63, %esi       # args <- () 
    lea -4(%esp),%edi    # edi <- esp-4
    subl %eax, %edi      # edi <- esp-4-eax    addr of arg[K+N] on stack
_L_1576285:
    lea -4(%esp),%ebx    # addr of arg[K] on stack
    cmp %edi, %ebx       # while edi <> esp+(si+4)
    je _L_1576284
    movl (%edi),%ebx     # arg i -> car
    movl %ebx, 0(%ebp)
    movl %esi, 4(%ebp)  # esi -> cdr
    movl %ebp, %esi
    addl $1, %esi       # tag as pair
    addl $8,%ebp         # bump heap ptr
    addl $4,%edi         # move to next previous arg from the end
    jmp _L_1576285
_L_1576284:
    movl %esi, -8(%esp)  # set args
# emit-tail-expr
# si=-12
# env=((f259472 . -8) (f259462 . 4) (f259462 . 0))
# expr=(let () (let ((f259474 (make-string ((primitive-ref list-length) f259472)))) ((vector-ref f259462 0) f259474 0 f259472)))
# emit-tail-let
#  si   = -12
#  env  = ((f259472 . -8) (f259462 . 4) (f259462 . 0))
#  bindings = ()
#  body = (let ((f259474 (make-string ((primitive-ref list-length) f259472)))) ((vector-ref f259462 0) f259474 0 f259472))
# emit-tail-expr
# si=-12
# env=((f259472 . -8) (f259462 . 4) (f259462 . 0))
# expr=(let ((f259474 (make-string ((primitive-ref list-length) f259472)))) ((vector-ref f259462 0) f259474 0 f259472))
# emit-tail-let
#  si   = -12
#  env  = ((f259472 . -8) (f259462 . 4) (f259462 . 0))
#  bindings = ((f259474 (make-string ((primitive-ref list-length) f259472))))
#  body = ((vector-ref f259462 0) f259474 0 f259472)
# emit-expr (make-string ((primitive-ref list-length) f259472))
# make-string len=((primitive-ref list-length) f259472)
# emit-expr ((primitive-ref list-length) f259472)
# funcall
#    si   =-12
#    env  = ((f259472 . -8) (f259462 . 4) (f259462 . 0))
#    expr = (funcall (primitive-ref list-length) f259472)
# emit-expr (primitive-ref list-length)
    .extern mrc_list$mlength
    movl mrc_list$mlength,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1576286"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1576286":
   movl %eax,  -20(%esp)  # stash funcall-oper in closure slot
# emit-expr f259472
# emit-variable-ref
# env=((f259472 . -8) (f259462 . 4) (f259462 . 0))
# var=f259472
    movl -8(%esp), %eax  # stack load f259472
# end emit-variable-ref
    mov %eax, -24(%esp)  # arg f259472
    movl -20(%esp), %edi   # load new closure to %edi
    add $-12, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $12, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1576287"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1576287:
# check the argument is a fixnum >= 0
    cmp $0,%eax
    jge _L_1576288
# invoke error handler eh_length
    .extern mrc_eh$ulength
    movl mrc_eh$ulength, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1576288:
    movl %eax, %esi
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    orl $6, %eax
    sar $2, %esi
    add $4, %esi
    add $7, %esi
    andl $-8, %esi
    add  %esi, %ebp
# make-string end
    movl %eax, -12(%esp)  # stack save
# emit-tail-expr
# si=-16
# env=((f259474 . -12) (f259472 . -8) (f259462 . 4) (f259462 . 0))
# expr=((vector-ref f259462 0) f259474 0 f259472)
# emit-tail-funcall
#    si   =-16
#    env  = ((f259474 . -12) (f259472 . -8) (f259462 . 4) (f259462 . 0))
#    expr = (funcall (vector-ref f259462 0) f259474 0 f259472)
# emit-expr (vector-ref f259462 0)
# emit-expr f259462
# emit-variable-ref
# env=((f259474 . -12) (f259472 . -8) (f259462 . 4) (f259462 . 0))
# var=f259462
    movl 2(%edi), %eax  # frame load f259462
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1576289
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1576289:
    movl %eax, -16(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1576290"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1576290:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1576292
    cmp  $0,%eax
    jge _L_1576291
_L_1576292:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1576291:
    movl -16(%esp), %esi
    movl -1(%eax,%esi), %eax
   movl %eax,  -16(%esp)  # stash funcall-oper in next closure slot
# emit-expr f259474
# emit-variable-ref
# env=((f259474 . -12) (f259472 . -8) (f259462 . 4) (f259462 . 0))
# var=f259474
    movl -12(%esp), %eax  # stack load f259474
# end emit-variable-ref
    mov %eax, -20(%esp)    # arg f259474
# emit-expr 0
    movl $0, %eax     # immed 0
    mov %eax, -24(%esp)    # arg 0
# emit-expr f259472
# emit-variable-ref
# env=((f259474 . -12) (f259472 . -8) (f259462 . 4) (f259462 . 0))
# var=f259472
    movl -8(%esp), %eax  # stack load f259472
# end emit-variable-ref
    mov %eax, -28(%esp)    # arg f259472
    movl -16(%esp), %edi   # load new closure to %edi
# emit-shift-args:  size=4   si=-16  delta=12
    mov -16(%esp), %ebx  # shift frame cell
    mov %ebx, -4(%esp)  # down to base
# emit-shift-args:  size=3   si=-20  delta=12
    mov -20(%esp), %ebx  # shift frame cell
    mov %ebx, -8(%esp)  # down to base
# emit-shift-args:  size=2   si=-24  delta=12
    mov -24(%esp), %ebx  # shift frame cell
    mov %ebx, -12(%esp)  # down to base
# emit-shift-args:  size=1   si=-28  delta=12
    mov -28(%esp), %ebx  # shift frame cell
    mov %ebx, -16(%esp)  # down to base
# emit-shift-args:  size=0   si=-32  delta=12
    movl $12,%eax   # save arg count
    jmp *-2(%edi)  # tail-funcall
    .align 4,0x90
_L_1576282:
# emit-expr (begin)
# emit-begin
#   expr=(begin)
#   env=((f259462 . 0))
     movl %eax, mrc_string
# == explicit-begins  ==>
# (letrec ((f (lambda (s i) (if (fx= i (string-length s)) (quote ()) (cons (string-ref s i) (f s (fxadd1 i))))))) (lambda (s) (f s 0)))
# == eliminate-let*  ==>
# (letrec ((f (lambda (s i) (if (fx= i (string-length s)) (quote ()) (cons (string-ref s i) (f s (fxadd1 i))))))) (lambda (s) (f s 0)))
# == uniquify-variables  ==>
# (letrec ((f259475 (lambda (f259478 f259479) (if (fx= f259479 (string-length f259478)) (quote ()) (cons (string-ref f259478 f259479) (f259475 f259478 (fxadd1 f259479))))))) (lambda (f259481) (f259475 f259481 0)))
# == vectorize-letrec  ==>
# (let ((f259475 (make-vector 1))) (begin (begin (vector-set! f259475 0 (lambda (f259478 f259479) (if (fx= f259479 (string-length f259478)) (quote ()) (cons (string-ref f259478 f259479) ((vector-ref f259475 0) f259478 (fxadd1 f259479))))))) (lambda (f259481) ((vector-ref f259475 0) f259481 0))))
# == eliminate-set!  ==>
# (let ((f259475 (make-vector 1))) (begin (begin (vector-set! f259475 0 (lambda (f259478 f259479) (let ((f259478 f259478) (f259479 f259479)) (if (fx= f259479 (string-length f259478)) (quote ()) (cons (string-ref f259478 f259479) ((vector-ref f259475 0) f259478 (fxadd1 f259479)))))))) (lambda (f259481) (let ((f259481 f259481)) ((vector-ref f259475 0) f259481 0)))))
# == close-free-variables  ==>
# (let ((f259475 (make-vector 1))) (begin (begin (vector-set! f259475 0 (closure (f259478 f259479) (f259475) (let ((f259478 f259478) (f259479 f259479)) (if (fx= f259479 (string-length f259478)) (quote ()) (cons (string-ref f259478 f259479) ((vector-ref f259475 0) f259478 (fxadd1 f259479)))))))) (closure (f259481) (f259475) (let ((f259481 f259481)) ((vector-ref f259475 0) f259481 0)))))
# == eliminate-quote  ==>
# (let ((f259475 (make-vector 1))) (begin (begin (vector-set! f259475 0 (closure (f259478 f259479) (f259475) (let ((f259478 f259478) (f259479 f259479)) (if (fx= f259479 (string-length f259478)) () (cons (string-ref f259478 f259479) ((vector-ref f259475 0) f259478 (fxadd1 f259479)))))))) (closure (f259481) (f259475) (let ((f259481 f259481)) ((vector-ref f259475 0) f259481 0)))))
# == eliminate-when/unless  ==>
# (let ((f259475 (make-vector 1))) (begin (begin (vector-set! f259475 0 (closure (f259478 f259479) (f259475) (let ((f259478 f259478) (f259479 f259479)) (if (fx= f259479 (string-length f259478)) () (cons (string-ref f259478 f259479) ((vector-ref f259475 0) f259478 (fxadd1 f259479)))))))) (closure (f259481) (f259475) (let ((f259481 f259481)) ((vector-ref f259475 0) f259481 0)))))
# == eliminate-cond  ==>
# (let ((f259475 (make-vector 1))) (begin (begin (vector-set! f259475 0 (closure (f259478 f259479) (f259475) (let ((f259478 f259478) (f259479 f259479)) (if (fx= f259479 (string-length f259478)) () (cons (string-ref f259478 f259479) ((vector-ref f259475 0) f259478 (fxadd1 f259479)))))))) (closure (f259481) (f259475) (let ((f259481 f259481)) ((vector-ref f259475 0) f259481 0)))))
# == external-symbols  ==>
# (let ((f259475 (make-vector 1))) (begin (begin (vector-set! f259475 0 (closure (f259478 f259479) (f259475) (let ((f259478 f259478) (f259479 f259479)) (if (fx= f259479 (string-length f259478)) () (cons (string-ref f259478 f259479) ((vector-ref f259475 0) f259478 (fxadd1 f259479)))))))) (closure (f259481) (f259475) (let ((f259481 f259481)) ((vector-ref f259475 0) f259481 0)))))
# emit-expr (let ((f259475 (make-vector 1))) (begin (begin (vector-set! f259475 0 (closure (f259478 f259479) (f259475) (let ((f259478 f259478) (f259479 f259479)) (if (fx= f259479 (string-length f259478)) () (cons (string-ref f259478 f259479) ((vector-ref f259475 0) f259478 (fxadd1 f259479)))))))) (closure (f259481) (f259475) (let ((f259481 f259481)) ((vector-ref f259475 0) f259481 0)))))
# emit-let
#  si   = 0
#  env  = ()
#  bindings = ((f259475 (make-vector 1)))
#  body = (begin (begin (vector-set! f259475 0 (closure (f259478 f259479) (f259475) (let ((f259478 f259478) (f259479 f259479)) (if (fx= f259479 (string-length f259478)) () (cons (string-ref f259478 f259479) ((vector-ref f259475 0) f259478 (fxadd1 f259479)))))))) (closure (f259481) (f259475) (let ((f259481 f259481)) ((vector-ref f259475 0) f259481 0))))
# emit-expr (make-vector 1)
# make-vector 1
# emit-expr 1
    movl $4, %eax     # immed 1
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1576293"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $128,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1576293:
# check the argument is a fixnum >= 0
    cmp $0,%eax
    jge _L_1576294
# invoke error handler eh_length
    .extern mrc_eh$ulength
    movl mrc_eh$ulength, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $128,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1576294:
    movl %eax, %esi
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    orl  $5, %eax
    addl $4, %esi
    addl $4, %esi
    andl $-8, %esi
    addl %esi, %ebp
    movl %eax, 0(%esp)  # stack save
# emit-expr (begin (begin (vector-set! f259475 0 (closure (f259478 f259479) (f259475) (let ((f259478 f259478) (f259479 f259479)) (if (fx= f259479 (string-length f259478)) () (cons (string-ref f259478 f259479) ((vector-ref f259475 0) f259478 (fxadd1 f259479)))))))) (closure (f259481) (f259475) (let ((f259481 f259481)) ((vector-ref f259475 0) f259481 0))))
# emit-begin
#   expr=(begin (begin (vector-set! f259475 0 (closure (f259478 f259479) (f259475) (let ((f259478 f259478) (f259479 f259479)) (if (fx= f259479 (string-length f259478)) () (cons (string-ref f259478 f259479) ((vector-ref f259475 0) f259478 (fxadd1 f259479)))))))) (closure (f259481) (f259475) (let ((f259481 f259481)) ((vector-ref f259475 0) f259481 0))))
#   env=((f259475 . 0))
# emit-expr (begin (vector-set! f259475 0 (closure (f259478 f259479) (f259475) (let ((f259478 f259478) (f259479 f259479)) (if (fx= f259479 (string-length f259478)) () (cons (string-ref f259478 f259479) ((vector-ref f259475 0) f259478 (fxadd1 f259479))))))))
# emit-begin
#   expr=(begin (vector-set! f259475 0 (closure (f259478 f259479) (f259475) (let ((f259478 f259478) (f259479 f259479)) (if (fx= f259479 (string-length f259478)) () (cons (string-ref f259478 f259479) ((vector-ref f259475 0) f259478 (fxadd1 f259479))))))))
#   env=((f259475 . 0))
# emit-expr (vector-set! f259475 0 (closure (f259478 f259479) (f259475) (let ((f259478 f259478) (f259479 f259479)) (if (fx= f259479 (string-length f259478)) () (cons (string-ref f259478 f259479) ((vector-ref f259475 0) f259478 (fxadd1 f259479)))))))
# emit-expr f259475
# emit-variable-ref
# env=((f259475 . 0))
# var=f259475
    movl 0(%esp), %eax  # stack load f259475
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1576295
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1576295:
    movl %eax, -4(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1576296"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1576296:
# check bounds on vector index
    movl -4(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1576298
    cmp  $0,%eax
    jge _L_1576297
_L_1576298:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1576297:
    movl %eax, -8(%esp)
# emit-expr (closure (f259478 f259479) (f259475) (let ((f259478 f259478) (f259479 f259479)) (if (fx= f259479 (string-length f259478)) () (cons (string-ref f259478 f259479) ((vector-ref f259475 0) f259478 (fxadd1 f259479))))))
# emit-closure
# si = -12
# env = ((f259475 . 0))
# expr = (closure (f259478 f259479) (f259475) (let ((f259478 f259478) (f259479 f259479)) (if (fx= f259479 (string-length f259478)) () (cons (string-ref f259478 f259479) ((vector-ref f259475 0) f259478 (fxadd1 f259479))))))
    movl $_L_1576299, 0(%ebp)  # closure label
# emit-variable-ref
# env=((f259475 . 0))
# var=f259475
    movl 0(%esp), %eax  # stack load f259475
# end emit-variable-ref
   movl  %eax, 4(%ebp)  # f259475
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $8, %ebp     # bump ebp
    jmp _L_1576300            # jump around closure body
_L_1576299:
# check argument count
    cmp $8,%eax
    je _L_1576301
# invoke error handler eh_argcount
    .extern mrc_eh$uargcount
    movl mrc_eh$uargcount, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_1576301:
# emit-tail-expr
# si=-16
# env=((f259479 . -12) (f259478 . -8) (f259475 . 4) (f259475 . 0))
# expr=(let ((f259478 f259478) (f259479 f259479)) (if (fx= f259479 (string-length f259478)) () (cons (string-ref f259478 f259479) ((vector-ref f259475 0) f259478 (fxadd1 f259479)))))
# emit-tail-let
#  si   = -16
#  env  = ((f259479 . -12) (f259478 . -8) (f259475 . 4) (f259475 . 0))
#  bindings = ((f259478 f259478) (f259479 f259479))
#  body = (if (fx= f259479 (string-length f259478)) () (cons (string-ref f259478 f259479) ((vector-ref f259475 0) f259478 (fxadd1 f259479))))
# emit-expr f259478
# emit-variable-ref
# env=((f259479 . -12) (f259478 . -8) (f259475 . 4) (f259475 . 0))
# var=f259478
    movl -8(%esp), %eax  # stack load f259478
# end emit-variable-ref
    movl %eax, -16(%esp)  # stack save
# emit-expr f259479
# emit-variable-ref
# env=((f259479 . -12) (f259478 . -8) (f259475 . 4) (f259475 . 0))
# var=f259479
    movl -12(%esp), %eax  # stack load f259479
# end emit-variable-ref
    movl %eax, -20(%esp)  # stack save
# emit-tail-expr
# si=-24
# env=((f259479 . -20) (f259478 . -16) (f259479 . -12) (f259478 . -8) (f259475 . 4) (f259475 . 0))
# expr=(if (fx= f259479 (string-length f259478)) () (cons (string-ref f259478 f259479) ((vector-ref f259475 0) f259478 (fxadd1 f259479))))
# emit-expr (fx= f259479 (string-length f259478))
# emit-expr (string-length f259478)
# emit-expr f259478
# emit-variable-ref
# env=((f259479 . -20) (f259478 . -16) (f259479 . -12) (f259478 . -8) (f259475 . 4) (f259475 . 0))
# var=f259478
    movl -16(%esp), %eax  # stack load f259478
# end emit-variable-ref
# check the argument is a string
    movl %eax,%ebx
    and $7, %bl
    cmp $6, %bl
    je _L_1576304
# invoke error handler eh_string
    .extern mrc_eh$ustring
    movl mrc_eh$ustring, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $152,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1576304:
    movl -6(%eax), %eax
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1576305"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $60,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1576305:
    movl %eax, -24(%esp)
# emit-expr f259479
# emit-variable-ref
# env=((f259479 . -20) (f259478 . -16) (f259479 . -12) (f259478 . -8) (f259475 . 4) (f259475 . 0))
# var=f259479
    movl -20(%esp), %eax  # stack load f259479
# end emit-variable-ref
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1576306"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $60,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1576306:
    cmp -24(%esp), %eax
    sete %al
    movzbl %al, %eax
    sal $6, %al
    or $47, %al
    cmp $47, %al
    je _L_1576302
# emit-tail-expr
# si=-24
# env=((f259479 . -20) (f259478 . -16) (f259479 . -12) (f259478 . -8) (f259475 . 4) (f259475 . 0))
# expr=()
    movl $63, %eax     # immed ()
    ret                  # immediate tail return
    jmp _L_1576303
_L_1576302:
# emit-tail-expr
# si=-24
# env=((f259479 . -20) (f259478 . -16) (f259479 . -12) (f259478 . -8) (f259475 . 4) (f259475 . 0))
# expr=(cons (string-ref f259478 f259479) ((vector-ref f259475 0) f259478 (fxadd1 f259479)))
# tail primcall
# cons arg1=(string-ref f259478 f259479) arg2=((vector-ref f259475 0) f259478 (fxadd1 f259479))
# emit-expr (string-ref f259478 f259479)
# emit-expr f259478
# emit-variable-ref
# env=((f259479 . -20) (f259478 . -16) (f259479 . -12) (f259478 . -8) (f259475 . 4) (f259475 . 0))
# var=f259478
    movl -16(%esp), %eax  # stack load f259478
# end emit-variable-ref
# check the argument is a string
    movl %eax,%ebx
    and $7, %bl
    cmp $6, %bl
    je _L_1576307
# invoke error handler eh_string
    .extern mrc_eh$ustring
    movl mrc_eh$ustring, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $156,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1576307:
    movl %eax, -24(%esp)
# emit-expr f259479
# emit-variable-ref
# env=((f259479 . -20) (f259478 . -16) (f259479 . -12) (f259478 . -8) (f259475 . 4) (f259475 . 0))
# var=f259479
    movl -20(%esp), %eax  # stack load f259479
# end emit-variable-ref
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1576308"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $156,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1576308:
# check bounds on string index
    movl -24(%esp), %ebx
    cmp  %eax,-6(%ebx) 
    jle _L_1576310
    cmp  $0,%eax
    jge _L_1576309
_L_1576310:
# invoke error handler eh_string_index
    .extern mrc_eh$ustring$uindex
    movl mrc_eh$ustring$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $156,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1576309:
    sar $2, %eax
    movl -24(%esp), %esi
    movl -2(%eax,%esi), %eax
    sal $8, %eax
    or  $15, %eax
    movl %eax, -24(%esp)
# emit-expr ((vector-ref f259475 0) f259478 (fxadd1 f259479))
# funcall
#    si   =-28
#    env  = ((f259479 . -20) (f259478 . -16) (f259479 . -12) (f259478 . -8) (f259475 . 4) (f259475 . 0))
#    expr = (funcall (vector-ref f259475 0) f259478 (fxadd1 f259479))
# emit-expr (vector-ref f259475 0)
# emit-expr f259475
# emit-variable-ref
# env=((f259479 . -20) (f259478 . -16) (f259479 . -12) (f259478 . -8) (f259475 . 4) (f259475 . 0))
# var=f259475
    movl 2(%edi), %eax  # frame load f259475
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1576311
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1576311:
    movl %eax, -36(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1576312"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1576312:
# check bounds on vector index
    movl -36(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1576314
    cmp  $0,%eax
    jge _L_1576313
_L_1576314:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1576313:
    movl -36(%esp), %esi
    movl -1(%eax,%esi), %eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1576315"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1576315":
   movl %eax,  -36(%esp)  # stash funcall-oper in closure slot
# emit-expr f259478
# emit-variable-ref
# env=((f259479 . -20) (f259478 . -16) (f259479 . -12) (f259478 . -8) (f259475 . 4) (f259475 . 0))
# var=f259478
    movl -16(%esp), %eax  # stack load f259478
# end emit-variable-ref
    mov %eax, -40(%esp)  # arg f259478
# emit-expr (fxadd1 f259479)
# emit-expr f259479
# emit-variable-ref
# env=((f259479 . -20) (f259478 . -16) (f259479 . -12) (f259478 . -8) (f259475 . 4) (f259475 . 0))
# var=f259479
    movl -20(%esp), %eax  # stack load f259479
# end emit-variable-ref
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1576316"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $48,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1576316:
     addl $4, %eax
    mov %eax, -44(%esp)  # arg (fxadd1 f259479)
    movl -36(%esp), %edi   # load new closure to %edi
    add $-28, %esp   # adjust base
    movl $8,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $28, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    movl %eax, 4(%ebp)
    movl -24(%esp), %eax
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    or   $1, %al
    add  $8, %ebp
# cons end
#return from tail (cons (string-ref f259478 f259479) ((vector-ref f259475 0) f259478 (fxadd1 f259479)))
    ret
_L_1576303:
    .align 4,0x90
_L_1576300:
    movl -4(%esp), %ebx
    movl -8(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin)
# emit-begin
#   expr=(begin)
#   env=((f259475 . 0))
# emit-expr (begin (closure (f259481) (f259475) (let ((f259481 f259481)) ((vector-ref f259475 0) f259481 0))))
# emit-begin
#   expr=(begin (closure (f259481) (f259475) (let ((f259481 f259481)) ((vector-ref f259475 0) f259481 0))))
#   env=((f259475 . 0))
# emit-expr (closure (f259481) (f259475) (let ((f259481 f259481)) ((vector-ref f259475 0) f259481 0)))
# emit-closure
# si = -4
# env = ((f259475 . 0))
# expr = (closure (f259481) (f259475) (let ((f259481 f259481)) ((vector-ref f259475 0) f259481 0)))
    movl $_L_1576317, 0(%ebp)  # closure label
# emit-variable-ref
# env=((f259475 . 0))
# var=f259475
    movl 0(%esp), %eax  # stack load f259475
# end emit-variable-ref
   movl  %eax, 4(%ebp)  # f259475
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $8, %ebp     # bump ebp
    jmp _L_1576318            # jump around closure body
_L_1576317:
# check argument count
    cmp $4,%eax
    je _L_1576319
# invoke error handler eh_argcount
    .extern mrc_eh$uargcount
    movl mrc_eh$uargcount, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_1576319:
# emit-tail-expr
# si=-12
# env=((f259481 . -8) (f259475 . 4) (f259475 . 0))
# expr=(let ((f259481 f259481)) ((vector-ref f259475 0) f259481 0))
# emit-tail-let
#  si   = -12
#  env  = ((f259481 . -8) (f259475 . 4) (f259475 . 0))
#  bindings = ((f259481 f259481))
#  body = ((vector-ref f259475 0) f259481 0)
# emit-expr f259481
# emit-variable-ref
# env=((f259481 . -8) (f259475 . 4) (f259475 . 0))
# var=f259481
    movl -8(%esp), %eax  # stack load f259481
# end emit-variable-ref
    movl %eax, -12(%esp)  # stack save
# emit-tail-expr
# si=-16
# env=((f259481 . -12) (f259481 . -8) (f259475 . 4) (f259475 . 0))
# expr=((vector-ref f259475 0) f259481 0)
# emit-tail-funcall
#    si   =-16
#    env  = ((f259481 . -12) (f259481 . -8) (f259475 . 4) (f259475 . 0))
#    expr = (funcall (vector-ref f259475 0) f259481 0)
# emit-expr (vector-ref f259475 0)
# emit-expr f259475
# emit-variable-ref
# env=((f259481 . -12) (f259481 . -8) (f259475 . 4) (f259475 . 0))
# var=f259475
    movl 2(%edi), %eax  # frame load f259475
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1576320
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1576320:
    movl %eax, -16(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1576321"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1576321:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1576323
    cmp  $0,%eax
    jge _L_1576322
_L_1576323:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1576322:
    movl -16(%esp), %esi
    movl -1(%eax,%esi), %eax
   movl %eax,  -16(%esp)  # stash funcall-oper in next closure slot
# emit-expr f259481
# emit-variable-ref
# env=((f259481 . -12) (f259481 . -8) (f259475 . 4) (f259475 . 0))
# var=f259481
    movl -12(%esp), %eax  # stack load f259481
# end emit-variable-ref
    mov %eax, -20(%esp)    # arg f259481
# emit-expr 0
    movl $0, %eax     # immed 0
    mov %eax, -24(%esp)    # arg 0
    movl -16(%esp), %edi   # load new closure to %edi
# emit-shift-args:  size=3   si=-16  delta=12
    mov -16(%esp), %ebx  # shift frame cell
    mov %ebx, -4(%esp)  # down to base
# emit-shift-args:  size=2   si=-20  delta=12
    mov -20(%esp), %ebx  # shift frame cell
    mov %ebx, -8(%esp)  # down to base
# emit-shift-args:  size=1   si=-24  delta=12
    mov -24(%esp), %ebx  # shift frame cell
    mov %ebx, -12(%esp)  # down to base
# emit-shift-args:  size=0   si=-28  delta=12
    movl $8,%eax   # save arg count
    jmp *-2(%edi)  # tail-funcall
    .align 4,0x90
_L_1576318:
# emit-expr (begin)
# emit-begin
#   expr=(begin)
#   env=((f259475 . 0))
     movl %eax, mrc_string$m$glist
# == explicit-begins  ==>
# (letrec ((f (lambda (i l) (cond ((fx< i 10) (cons i l)) (else (f (fxquotient i 10) (cons (fxremainder i 10) l))))))) (lambda (i) (f i (quote ()))))
# == eliminate-let*  ==>
# (letrec ((f (lambda (i l) (cond ((fx< i 10) (cons i l)) (else (f (fxquotient i 10) (cons (fxremainder i 10) l))))))) (lambda (i) (f i (quote ()))))
# == uniquify-variables  ==>
# (letrec ((f259482 (lambda (f259485 f259486) (cond ((fx< f259485 10) (cons f259485 f259486)) (else (f259482 (fxquotient f259485 10) (cons (fxremainder f259485 10) f259486))))))) (lambda (f259488) (f259482 f259488 (quote ()))))
# == vectorize-letrec  ==>
# (let ((f259482 (make-vector 1))) (begin (begin (vector-set! f259482 0 (lambda (f259485 f259486) (cond ((fx< f259485 10) (cons f259485 f259486)) (else ((vector-ref f259482 0) (fxquotient f259485 10) (cons (fxremainder f259485 10) f259486))))))) (lambda (f259488) ((vector-ref f259482 0) f259488 (quote ())))))
# == eliminate-set!  ==>
# (let ((f259482 (make-vector 1))) (begin (begin (vector-set! f259482 0 (lambda (f259485 f259486) (let ((f259485 f259485) (f259486 f259486)) (cond ((fx< f259485 10) (cons f259485 f259486)) (else ((vector-ref f259482 0) (fxquotient f259485 10) (cons (fxremainder f259485 10) f259486)))))))) (lambda (f259488) (let ((f259488 f259488)) ((vector-ref f259482 0) f259488 (quote ()))))))
# == close-free-variables  ==>
# (let ((f259482 (make-vector 1))) (begin (begin (vector-set! f259482 0 (closure (f259485 f259486) (else f259482) (let ((f259485 f259485) (f259486 f259486)) (cond ((fx< f259485 10) (cons f259485 f259486)) (else ((vector-ref f259482 0) (fxquotient f259485 10) (cons (fxremainder f259485 10) f259486)))))))) (closure (f259488) (f259482) (let ((f259488 f259488)) ((vector-ref f259482 0) f259488 (quote ()))))))
# == eliminate-quote  ==>
# (let ((f259482 (make-vector 1))) (begin (begin (vector-set! f259482 0 (closure (f259485 f259486) (else f259482) (let ((f259485 f259485) (f259486 f259486)) (cond ((fx< f259485 10) (cons f259485 f259486)) (else ((vector-ref f259482 0) (fxquotient f259485 10) (cons (fxremainder f259485 10) f259486)))))))) (closure (f259488) (f259482) (let ((f259488 f259488)) ((vector-ref f259482 0) f259488 ())))))
# == eliminate-when/unless  ==>
# (let ((f259482 (make-vector 1))) (begin (begin (vector-set! f259482 0 (closure (f259485 f259486) (else f259482) (let ((f259485 f259485) (f259486 f259486)) (cond ((fx< f259485 10) (cons f259485 f259486)) (else ((vector-ref f259482 0) (fxquotient f259485 10) (cons (fxremainder f259485 10) f259486)))))))) (closure (f259488) (f259482) (let ((f259488 f259488)) ((vector-ref f259482 0) f259488 ())))))
# == eliminate-cond  ==>
# (let ((f259482 (make-vector 1))) (begin (begin (vector-set! f259482 0 (closure (f259485 f259486) (else f259482) (let ((f259485 f259485) (f259486 f259486)) (if (fx< f259485 10) (cons f259485 f259486) ((vector-ref f259482 0) (fxquotient f259485 10) (cons (fxremainder f259485 10) f259486))))))) (closure (f259488) (f259482) (let ((f259488 f259488)) ((vector-ref f259482 0) f259488 ())))))
# == external-symbols  ==>
# (let ((f259482 (make-vector 1))) (begin (begin (vector-set! f259482 0 (closure (f259485 f259486) (else f259482) (let ((f259485 f259485) (f259486 f259486)) (if (fx< f259485 10) (cons f259485 f259486) ((vector-ref f259482 0) (fxquotient f259485 10) (cons (fxremainder f259485 10) f259486))))))) (closure (f259488) (f259482) (let ((f259488 f259488)) ((vector-ref f259482 0) f259488 ())))))
# emit-expr (let ((f259482 (make-vector 1))) (begin (begin (vector-set! f259482 0 (closure (f259485 f259486) (else f259482) (let ((f259485 f259485) (f259486 f259486)) (if (fx< f259485 10) (cons f259485 f259486) ((vector-ref f259482 0) (fxquotient f259485 10) (cons (fxremainder f259485 10) f259486))))))) (closure (f259488) (f259482) (let ((f259488 f259488)) ((vector-ref f259482 0) f259488 ())))))
# emit-let
#  si   = 0
#  env  = ()
#  bindings = ((f259482 (make-vector 1)))
#  body = (begin (begin (vector-set! f259482 0 (closure (f259485 f259486) (else f259482) (let ((f259485 f259485) (f259486 f259486)) (if (fx< f259485 10) (cons f259485 f259486) ((vector-ref f259482 0) (fxquotient f259485 10) (cons (fxremainder f259485 10) f259486))))))) (closure (f259488) (f259482) (let ((f259488 f259488)) ((vector-ref f259482 0) f259488 ()))))
# emit-expr (make-vector 1)
# make-vector 1
# emit-expr 1
    movl $4, %eax     # immed 1
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1576324"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $128,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1576324:
# check the argument is a fixnum >= 0
    cmp $0,%eax
    jge _L_1576325
# invoke error handler eh_length
    .extern mrc_eh$ulength
    movl mrc_eh$ulength, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $128,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1576325:
    movl %eax, %esi
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    orl  $5, %eax
    addl $4, %esi
    addl $4, %esi
    andl $-8, %esi
    addl %esi, %ebp
    movl %eax, 0(%esp)  # stack save
# emit-expr (begin (begin (vector-set! f259482 0 (closure (f259485 f259486) (else f259482) (let ((f259485 f259485) (f259486 f259486)) (if (fx< f259485 10) (cons f259485 f259486) ((vector-ref f259482 0) (fxquotient f259485 10) (cons (fxremainder f259485 10) f259486))))))) (closure (f259488) (f259482) (let ((f259488 f259488)) ((vector-ref f259482 0) f259488 ()))))
# emit-begin
#   expr=(begin (begin (vector-set! f259482 0 (closure (f259485 f259486) (else f259482) (let ((f259485 f259485) (f259486 f259486)) (if (fx< f259485 10) (cons f259485 f259486) ((vector-ref f259482 0) (fxquotient f259485 10) (cons (fxremainder f259485 10) f259486))))))) (closure (f259488) (f259482) (let ((f259488 f259488)) ((vector-ref f259482 0) f259488 ()))))
#   env=((f259482 . 0))
# emit-expr (begin (vector-set! f259482 0 (closure (f259485 f259486) (else f259482) (let ((f259485 f259485) (f259486 f259486)) (if (fx< f259485 10) (cons f259485 f259486) ((vector-ref f259482 0) (fxquotient f259485 10) (cons (fxremainder f259485 10) f259486)))))))
# emit-begin
#   expr=(begin (vector-set! f259482 0 (closure (f259485 f259486) (else f259482) (let ((f259485 f259485) (f259486 f259486)) (if (fx< f259485 10) (cons f259485 f259486) ((vector-ref f259482 0) (fxquotient f259485 10) (cons (fxremainder f259485 10) f259486)))))))
#   env=((f259482 . 0))
# emit-expr (vector-set! f259482 0 (closure (f259485 f259486) (else f259482) (let ((f259485 f259485) (f259486 f259486)) (if (fx< f259485 10) (cons f259485 f259486) ((vector-ref f259482 0) (fxquotient f259485 10) (cons (fxremainder f259485 10) f259486))))))
# emit-expr f259482
# emit-variable-ref
# env=((f259482 . 0))
# var=f259482
    movl 0(%esp), %eax  # stack load f259482
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1576326
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1576326:
    movl %eax, -4(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1576327"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1576327:
# check bounds on vector index
    movl -4(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1576329
    cmp  $0,%eax
    jge _L_1576328
_L_1576329:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1576328:
    movl %eax, -8(%esp)
# emit-expr (closure (f259485 f259486) (else f259482) (let ((f259485 f259485) (f259486 f259486)) (if (fx< f259485 10) (cons f259485 f259486) ((vector-ref f259482 0) (fxquotient f259485 10) (cons (fxremainder f259485 10) f259486)))))
# emit-closure
# si = -12
# env = ((f259482 . 0))
# expr = (closure (f259485 f259486) (else f259482) (let ((f259485 f259485) (f259486 f259486)) (if (fx< f259485 10) (cons f259485 f259486) ((vector-ref f259482 0) (fxquotient f259485 10) (cons (fxremainder f259485 10) f259486)))))
    movl $_L_1576330, 0(%ebp)  # closure label
# WARNING: free var else not defined in the environmnet
# emit-variable-ref
# env=((f259482 . 0))
# var=f259482
    movl 0(%esp), %eax  # stack load f259482
# end emit-variable-ref
   movl  %eax, 8(%ebp)  # f259482
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $16, %ebp     # bump ebp
    jmp _L_1576331            # jump around closure body
_L_1576330:
# check argument count
    cmp $8,%eax
    je _L_1576332
# invoke error handler eh_argcount
    .extern mrc_eh$uargcount
    movl mrc_eh$uargcount, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_1576332:
# emit-tail-expr
# si=-16
# env=((f259486 . -12) (f259485 . -8) (f259482 . 8) (else . 4) (f259482 . 0))
# expr=(let ((f259485 f259485) (f259486 f259486)) (if (fx< f259485 10) (cons f259485 f259486) ((vector-ref f259482 0) (fxquotient f259485 10) (cons (fxremainder f259485 10) f259486))))
# emit-tail-let
#  si   = -16
#  env  = ((f259486 . -12) (f259485 . -8) (f259482 . 8) (else . 4) (f259482 . 0))
#  bindings = ((f259485 f259485) (f259486 f259486))
#  body = (if (fx< f259485 10) (cons f259485 f259486) ((vector-ref f259482 0) (fxquotient f259485 10) (cons (fxremainder f259485 10) f259486)))
# emit-expr f259485
# emit-variable-ref
# env=((f259486 . -12) (f259485 . -8) (f259482 . 8) (else . 4) (f259482 . 0))
# var=f259485
    movl -8(%esp), %eax  # stack load f259485
# end emit-variable-ref
    movl %eax, -16(%esp)  # stack save
# emit-expr f259486
# emit-variable-ref
# env=((f259486 . -12) (f259485 . -8) (f259482 . 8) (else . 4) (f259482 . 0))
# var=f259486
    movl -12(%esp), %eax  # stack load f259486
# end emit-variable-ref
    movl %eax, -20(%esp)  # stack save
# emit-tail-expr
# si=-24
# env=((f259486 . -20) (f259485 . -16) (f259486 . -12) (f259485 . -8) (f259482 . 8) (else . 4) (f259482 . 0))
# expr=(if (fx< f259485 10) (cons f259485 f259486) ((vector-ref f259482 0) (fxquotient f259485 10) (cons (fxremainder f259485 10) f259486)))
# emit-expr (fx< f259485 10)
# emit-expr 10
    movl $40, %eax     # immed 10
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1576335"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $64,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1576335:
    movl %eax, -24(%esp)
# emit-expr f259485
# emit-variable-ref
# env=((f259486 . -20) (f259485 . -16) (f259486 . -12) (f259485 . -8) (f259482 . 8) (else . 4) (f259482 . 0))
# var=f259485
    movl -16(%esp), %eax  # stack load f259485
# end emit-variable-ref
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1576336"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $64,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1576336:
    cmp -24(%esp), %eax
    setl %al
    movzbl %al, %eax
    sal $6, %al
    or $47, %al
    cmp $47, %al
    je _L_1576333
# emit-tail-expr
# si=-24
# env=((f259486 . -20) (f259485 . -16) (f259486 . -12) (f259485 . -8) (f259482 . 8) (else . 4) (f259482 . 0))
# expr=(cons f259485 f259486)
# tail primcall
# cons arg1=f259485 arg2=f259486
# emit-expr f259485
# emit-variable-ref
# env=((f259486 . -20) (f259485 . -16) (f259486 . -12) (f259485 . -8) (f259482 . 8) (else . 4) (f259482 . 0))
# var=f259485
    movl -16(%esp), %eax  # stack load f259485
# end emit-variable-ref
    movl %eax, -24(%esp)
# emit-expr f259486
# emit-variable-ref
# env=((f259486 . -20) (f259485 . -16) (f259486 . -12) (f259485 . -8) (f259482 . 8) (else . 4) (f259482 . 0))
# var=f259486
    movl -20(%esp), %eax  # stack load f259486
# end emit-variable-ref
    movl %eax, 4(%ebp)
    movl -24(%esp), %eax
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    or   $1, %al
    add  $8, %ebp
# cons end
#return from tail (cons f259485 f259486)
    ret
    jmp _L_1576334
_L_1576333:
# emit-tail-expr
# si=-24
# env=((f259486 . -20) (f259485 . -16) (f259486 . -12) (f259485 . -8) (f259482 . 8) (else . 4) (f259482 . 0))
# expr=((vector-ref f259482 0) (fxquotient f259485 10) (cons (fxremainder f259485 10) f259486))
# emit-tail-funcall
#    si   =-24
#    env  = ((f259486 . -20) (f259485 . -16) (f259486 . -12) (f259485 . -8) (f259482 . 8) (else . 4) (f259482 . 0))
#    expr = (funcall (vector-ref f259482 0) (fxquotient f259485 10) (cons (fxremainder f259485 10) f259486))
# emit-expr (vector-ref f259482 0)
# emit-expr f259482
# emit-variable-ref
# env=((f259486 . -20) (f259485 . -16) (f259486 . -12) (f259485 . -8) (f259482 . 8) (else . 4) (f259482 . 0))
# var=f259482
    movl 6(%edi), %eax  # frame load f259482
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1576337
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1576337:
    movl %eax, -24(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1576338"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1576338:
# check bounds on vector index
    movl -24(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1576340
    cmp  $0,%eax
    jge _L_1576339
_L_1576340:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1576339:
    movl -24(%esp), %esi
    movl -1(%eax,%esi), %eax
   movl %eax,  -24(%esp)  # stash funcall-oper in next closure slot
# emit-expr (fxquotient f259485 10)
# emit-expr 10
    movl $40, %eax     # immed 10
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1576342"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $92,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1576342:
    movl %eax, -28(%esp)  # denominator
# emit-expr f259485
# emit-variable-ref
# env=((f259486 . -20) (f259485 . -16) (f259486 . -12) (f259485 . -8) (f259482 . 8) (else . 4) (f259482 . 0))
# var=f259485
    movl -16(%esp), %eax  # stack load f259485
# end emit-variable-ref
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1576343"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $92,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1576343:
    movl -28(%esp),%ebx   # ebx <- denominator
    xor %edx,%edx        # edx <- 0
    cmp $0,%eax
    jge _L_1576341
    not %edx
_L_1576341:
    idiv %ebx            # eax <- edx:eax/ebx
    sal $2,%eax          # eax <- eax*4 (since it was divided away)
    mov %eax, -28(%esp)    # arg (fxquotient f259485 10)
# emit-expr (cons (fxremainder f259485 10) f259486)
# cons arg1=(fxremainder f259485 10) arg2=f259486
# emit-expr (fxremainder f259485 10)
# emit-expr 10
    movl $40, %eax     # immed 10
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1576345"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $92,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1576345:
    movl %eax, -32(%esp)  # denominator
# emit-expr f259485
# emit-variable-ref
# env=((f259486 . -20) (f259485 . -16) (f259486 . -12) (f259485 . -8) (f259482 . 8) (else . 4) (f259482 . 0))
# var=f259485
    movl -16(%esp), %eax  # stack load f259485
# end emit-variable-ref
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1576346"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $92,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1576346:
    movl -32(%esp),%ebx   # ebx <- denominator
    xor %edx,%edx        # edx <- 0
    cmp $0,%eax
    jge _L_1576344
    not %edx
_L_1576344:
    idiv %ebx            # edx <- edx:eax/ebx  remainder
    movl %edx,%eax
    movl %eax, -32(%esp)
# emit-expr f259486
# emit-variable-ref
# env=((f259486 . -20) (f259485 . -16) (f259486 . -12) (f259485 . -8) (f259482 . 8) (else . 4) (f259482 . 0))
# var=f259486
    movl -20(%esp), %eax  # stack load f259486
# end emit-variable-ref
    movl %eax, 4(%ebp)
    movl -32(%esp), %eax
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    or   $1, %al
    add  $8, %ebp
# cons end
    mov %eax, -32(%esp)    # arg (cons (fxremainder f259485 10) f259486)
    movl -24(%esp), %edi   # load new closure to %edi
# emit-shift-args:  size=3   si=-24  delta=20
    mov -24(%esp), %ebx  # shift frame cell
    mov %ebx, -4(%esp)  # down to base
# emit-shift-args:  size=2   si=-28  delta=20
    mov -28(%esp), %ebx  # shift frame cell
    mov %ebx, -8(%esp)  # down to base
# emit-shift-args:  size=1   si=-32  delta=20
    mov -32(%esp), %ebx  # shift frame cell
    mov %ebx, -12(%esp)  # down to base
# emit-shift-args:  size=0   si=-36  delta=20
    movl $8,%eax   # save arg count
    jmp *-2(%edi)  # tail-funcall
_L_1576334:
    .align 4,0x90
_L_1576331:
    movl -4(%esp), %ebx
    movl -8(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin)
# emit-begin
#   expr=(begin)
#   env=((f259482 . 0))
# emit-expr (begin (closure (f259488) (f259482) (let ((f259488 f259488)) ((vector-ref f259482 0) f259488 ()))))
# emit-begin
#   expr=(begin (closure (f259488) (f259482) (let ((f259488 f259488)) ((vector-ref f259482 0) f259488 ()))))
#   env=((f259482 . 0))
# emit-expr (closure (f259488) (f259482) (let ((f259488 f259488)) ((vector-ref f259482 0) f259488 ())))
# emit-closure
# si = -4
# env = ((f259482 . 0))
# expr = (closure (f259488) (f259482) (let ((f259488 f259488)) ((vector-ref f259482 0) f259488 ())))
    movl $_L_1576347, 0(%ebp)  # closure label
# emit-variable-ref
# env=((f259482 . 0))
# var=f259482
    movl 0(%esp), %eax  # stack load f259482
# end emit-variable-ref
   movl  %eax, 4(%ebp)  # f259482
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $8, %ebp     # bump ebp
    jmp _L_1576348            # jump around closure body
_L_1576347:
# check argument count
    cmp $4,%eax
    je _L_1576349
# invoke error handler eh_argcount
    .extern mrc_eh$uargcount
    movl mrc_eh$uargcount, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_1576349:
# emit-tail-expr
# si=-12
# env=((f259488 . -8) (f259482 . 4) (f259482 . 0))
# expr=(let ((f259488 f259488)) ((vector-ref f259482 0) f259488 ()))
# emit-tail-let
#  si   = -12
#  env  = ((f259488 . -8) (f259482 . 4) (f259482 . 0))
#  bindings = ((f259488 f259488))
#  body = ((vector-ref f259482 0) f259488 ())
# emit-expr f259488
# emit-variable-ref
# env=((f259488 . -8) (f259482 . 4) (f259482 . 0))
# var=f259488
    movl -8(%esp), %eax  # stack load f259488
# end emit-variable-ref
    movl %eax, -12(%esp)  # stack save
# emit-tail-expr
# si=-16
# env=((f259488 . -12) (f259488 . -8) (f259482 . 4) (f259482 . 0))
# expr=((vector-ref f259482 0) f259488 ())
# emit-tail-funcall
#    si   =-16
#    env  = ((f259488 . -12) (f259488 . -8) (f259482 . 4) (f259482 . 0))
#    expr = (funcall (vector-ref f259482 0) f259488 ())
# emit-expr (vector-ref f259482 0)
# emit-expr f259482
# emit-variable-ref
# env=((f259488 . -12) (f259488 . -8) (f259482 . 4) (f259482 . 0))
# var=f259482
    movl 2(%edi), %eax  # frame load f259482
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1576350
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1576350:
    movl %eax, -16(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1576351"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1576351:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1576353
    cmp  $0,%eax
    jge _L_1576352
_L_1576353:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1576352:
    movl -16(%esp), %esi
    movl -1(%eax,%esi), %eax
   movl %eax,  -16(%esp)  # stash funcall-oper in next closure slot
# emit-expr f259488
# emit-variable-ref
# env=((f259488 . -12) (f259488 . -8) (f259482 . 4) (f259482 . 0))
# var=f259488
    movl -12(%esp), %eax  # stack load f259488
# end emit-variable-ref
    mov %eax, -20(%esp)    # arg f259488
# emit-expr ()
    movl $63, %eax     # immed ()
    mov %eax, -24(%esp)    # arg ()
    movl -16(%esp), %edi   # load new closure to %edi
# emit-shift-args:  size=3   si=-16  delta=12
    mov -16(%esp), %ebx  # shift frame cell
    mov %ebx, -4(%esp)  # down to base
# emit-shift-args:  size=2   si=-20  delta=12
    mov -20(%esp), %ebx  # shift frame cell
    mov %ebx, -8(%esp)  # down to base
# emit-shift-args:  size=1   si=-24  delta=12
    mov -24(%esp), %ebx  # shift frame cell
    mov %ebx, -12(%esp)  # down to base
# emit-shift-args:  size=0   si=-28  delta=12
    movl $8,%eax   # save arg count
    jmp *-2(%edi)  # tail-funcall
    .align 4,0x90
_L_1576348:
# emit-expr (begin)
# emit-begin
#   expr=(begin)
#   env=((f259482 . 0))
     movl %eax, mrc_integer$m$glist
# == explicit-begins  ==>
# (let* ((write-stderr (lambda (s) (foreign-call "s_write" 2 s (string-length s)))) (write-errmsg (lambda (sym emsg) (begin (write-stderr "error:") (write-stderr (symbol->string sym)) (write-stderr ": ") (write-stderr emsg) (write-stderr "\n"))))) (lambda (sym emsg) (begin (write-errmsg sym emsg) (foreign-call "s_exit" 1))))
# == eliminate-let*  ==>
# (let ((write-stderr (lambda (s) (foreign-call "s_write" 2 s (string-length s))))) (let ((write-errmsg (lambda (sym emsg) (begin (write-stderr "error:") (write-stderr (symbol->string sym)) (write-stderr ": ") (write-stderr emsg) (write-stderr "\n"))))) (lambda (sym emsg) (begin (write-errmsg sym emsg) (foreign-call "s_exit" 1)))))
# == uniquify-variables  ==>
# (let ((f259489 (lambda (f259490) (foreign-call "s_write" 2 f259490 (string-length f259490))))) (let ((f259498 (lambda (f259499 f259500) (begin (f259489 "error:") (f259489 (symbol->string f259499)) (f259489 ": ") (f259489 f259500) (f259489 "\n"))))) (lambda (f259503 f259504) (begin (f259498 f259503 f259504) (foreign-call "s_exit" 1)))))
# == vectorize-letrec  ==>
# (let ((f259489 (lambda (f259490) (foreign-call "s_write" 2 f259490 (string-length f259490))))) (let ((f259498 (lambda (f259499 f259500) (begin (f259489 "error:") (f259489 (symbol->string f259499)) (f259489 ": ") (f259489 f259500) (f259489 "\n"))))) (lambda (f259503 f259504) (begin (f259498 f259503 f259504) (foreign-call "s_exit" 1)))))
# == eliminate-set!  ==>
# (let ((f259489 (lambda (f259490) (let ((f259490 f259490)) (foreign-call "s_write" 2 f259490 (string-length f259490)))))) (let ((f259498 (lambda (f259499 f259500) (let ((f259499 f259499) (f259500 f259500)) (begin (f259489 "error:") (f259489 (symbol->string f259499)) (f259489 ": ") (f259489 f259500) (f259489 "\n")))))) (lambda (f259503 f259504) (let ((f259503 f259503) (f259504 f259504)) (begin (f259498 f259503 f259504) (foreign-call "s_exit" 1))))))
# == close-free-variables  ==>
# (let ((f259489 (closure (f259490) () (let ((f259490 f259490)) (foreign-call "s_write" 2 f259490 (string-length f259490)))))) (let ((f259498 (closure (f259499 f259500) (f259489 f259489 f259489 f259489 f259489) (let ((f259499 f259499) (f259500 f259500)) (begin (f259489 "error:") (f259489 (symbol->string f259499)) (f259489 ": ") (f259489 f259500) (f259489 "\n")))))) (closure (f259503 f259504) (f259498) (let ((f259503 f259503) (f259504 f259504)) (begin (f259498 f259503 f259504) (foreign-call "s_exit" 1))))))
# == eliminate-quote  ==>
# (let ((f259489 (closure (f259490) () (let ((f259490 f259490)) (foreign-call "s_write" 2 f259490 (string-length f259490)))))) (let ((f259498 (closure (f259499 f259500) (f259489 f259489 f259489 f259489 f259489) (let ((f259499 f259499) (f259500 f259500)) (begin (f259489 "error:") (f259489 (symbol->string f259499)) (f259489 ": ") (f259489 f259500) (f259489 "\n")))))) (closure (f259503 f259504) (f259498) (let ((f259503 f259503) (f259504 f259504)) (begin (f259498 f259503 f259504) (foreign-call "s_exit" 1))))))
# == eliminate-when/unless  ==>
# (let ((f259489 (closure (f259490) () (let ((f259490 f259490)) (foreign-call "s_write" 2 f259490 (string-length f259490)))))) (let ((f259498 (closure (f259499 f259500) (f259489 f259489 f259489 f259489 f259489) (let ((f259499 f259499) (f259500 f259500)) (begin (f259489 "error:") (f259489 (symbol->string f259499)) (f259489 ": ") (f259489 f259500) (f259489 "\n")))))) (closure (f259503 f259504) (f259498) (let ((f259503 f259503) (f259504 f259504)) (begin (f259498 f259503 f259504) (foreign-call "s_exit" 1))))))
# == eliminate-cond  ==>
# (let ((f259489 (closure (f259490) () (let ((f259490 f259490)) (foreign-call "s_write" 2 f259490 (string-length f259490)))))) (let ((f259498 (closure (f259499 f259500) (f259489 f259489 f259489 f259489 f259489) (let ((f259499 f259499) (f259500 f259500)) (begin (f259489 "error:") (f259489 (symbol->string f259499)) (f259489 ": ") (f259489 f259500) (f259489 "\n")))))) (closure (f259503 f259504) (f259498) (let ((f259503 f259503) (f259504 f259504)) (begin (f259498 f259503 f259504) (foreign-call "s_exit" 1))))))
# == external-symbols  ==>
# (let ((f259489 (closure (f259490) () (let ((f259490 f259490)) (foreign-call "s_write" 2 f259490 (string-length f259490)))))) (let ((f259498 (closure (f259499 f259500) (f259489 f259489 f259489 f259489 f259489) (let ((f259499 f259499) (f259500 f259500)) (begin (f259489 "error:") (f259489 (symbol->string f259499)) (f259489 ": ") (f259489 f259500) (f259489 "\n")))))) (closure (f259503 f259504) (f259498) (let ((f259503 f259503) (f259504 f259504)) (begin (f259498 f259503 f259504) (foreign-call "s_exit" 1))))))
# emit-expr (let ((f259489 (closure (f259490) () (let ((f259490 f259490)) (foreign-call "s_write" 2 f259490 (string-length f259490)))))) (let ((f259498 (closure (f259499 f259500) (f259489 f259489 f259489 f259489 f259489) (let ((f259499 f259499) (f259500 f259500)) (begin (f259489 "error:") (f259489 (symbol->string f259499)) (f259489 ": ") (f259489 f259500) (f259489 "\n")))))) (closure (f259503 f259504) (f259498) (let ((f259503 f259503) (f259504 f259504)) (begin (f259498 f259503 f259504) (foreign-call "s_exit" 1))))))
# emit-let
#  si   = 0
#  env  = ()
#  bindings = ((f259489 (closure (f259490) () (let ((f259490 f259490)) (foreign-call "s_write" 2 f259490 (string-length f259490))))))
#  body = (let ((f259498 (closure (f259499 f259500) (f259489 f259489 f259489 f259489 f259489) (let ((f259499 f259499) (f259500 f259500)) (begin (f259489 "error:") (f259489 (symbol->string f259499)) (f259489 ": ") (f259489 f259500) (f259489 "\n")))))) (closure (f259503 f259504) (f259498) (let ((f259503 f259503) (f259504 f259504)) (begin (f259498 f259503 f259504) (foreign-call "s_exit" 1)))))
# emit-expr (closure (f259490) () (let ((f259490 f259490)) (foreign-call "s_write" 2 f259490 (string-length f259490))))
# emit-closure
# si = 0
# env = ()
# expr = (closure (f259490) () (let ((f259490 f259490)) (foreign-call "s_write" 2 f259490 (string-length f259490))))
    movl $_L_1576354, 0(%ebp)  # closure label
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $8, %ebp     # bump ebp
    jmp _L_1576355            # jump around closure body
_L_1576354:
# check argument count
    cmp $4,%eax
    je _L_1576356
# invoke error handler eh_argcount
    .extern mrc_eh$uargcount
    movl mrc_eh$uargcount, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_1576356:
# emit-tail-expr
# si=-12
# env=((f259490 . -8))
# expr=(let ((f259490 f259490)) (foreign-call "s_write" 2 f259490 (string-length f259490)))
# emit-tail-let
#  si   = -12
#  env  = ((f259490 . -8))
#  bindings = ((f259490 f259490))
#  body = (foreign-call "s_write" 2 f259490 (string-length f259490))
# emit-expr f259490
# emit-variable-ref
# env=((f259490 . -8))
# var=f259490
    movl -8(%esp), %eax  # stack load f259490
# end emit-variable-ref
    movl %eax, -12(%esp)  # stack save
# emit-tail-expr
# si=-16
# env=((f259490 . -12) (f259490 . -8))
# expr=(foreign-call "s_write" 2 f259490 (string-length f259490))
    movl %ecx,-16(%esp)
    movl %esp,-20(%esp)
# emit-expr (string-length f259490)
# emit-expr f259490
# emit-variable-ref
# env=((f259490 . -12) (f259490 . -8))
# var=f259490
    movl -12(%esp), %eax  # stack load f259490
# end emit-variable-ref
# check the argument is a string
    movl %eax,%ebx
    and $7, %bl
    cmp $6, %bl
    je _L_1576357
# invoke error handler eh_string
    .extern mrc_eh$ustring
    movl mrc_eh$ustring, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $152,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1576357:
    movl -6(%eax), %eax
    movl %eax, -24(%esp)
# emit-expr f259490
# emit-variable-ref
# env=((f259490 . -12) (f259490 . -8))
# var=f259490
    movl -12(%esp), %eax  # stack load f259490
# end emit-variable-ref
    movl %eax, -28(%esp)
# emit-expr 2
    movl $8, %eax     # immed 2
    movl %eax, -32(%esp)
    leal -32(%esp),%edi
    movl %edi,%esi
    andl $-16,%esi
    movl 0(%edi),%eax
    movl %eax,0(%esi)
    movl 4(%edi),%eax
    movl %eax,4(%esi)
    movl 8(%edi),%eax
    movl %eax,8(%esi)
    movl 12(%edi),%eax
    movl %eax,12(%esi)
    movl %esi,%esp
    .extern _s_write
    call _s_write
    movl 12(%esi),%esp
    movl -16(%esp),%ecx
     ret
    .align 4,0x90
_L_1576355:
    movl %eax, 0(%esp)  # stack save
# emit-expr (let ((f259498 (closure (f259499 f259500) (f259489 f259489 f259489 f259489 f259489) (let ((f259499 f259499) (f259500 f259500)) (begin (f259489 "error:") (f259489 (symbol->string f259499)) (f259489 ": ") (f259489 f259500) (f259489 "\n")))))) (closure (f259503 f259504) (f259498) (let ((f259503 f259503) (f259504 f259504)) (begin (f259498 f259503 f259504) (foreign-call "s_exit" 1)))))
# emit-let
#  si   = -4
#  env  = ((f259489 . 0))
#  bindings = ((f259498 (closure (f259499 f259500) (f259489 f259489 f259489 f259489 f259489) (let ((f259499 f259499) (f259500 f259500)) (begin (f259489 "error:") (f259489 (symbol->string f259499)) (f259489 ": ") (f259489 f259500) (f259489 "\n"))))))
#  body = (closure (f259503 f259504) (f259498) (let ((f259503 f259503) (f259504 f259504)) (begin (f259498 f259503 f259504) (foreign-call "s_exit" 1))))
# emit-expr (closure (f259499 f259500) (f259489 f259489 f259489 f259489 f259489) (let ((f259499 f259499) (f259500 f259500)) (begin (f259489 "error:") (f259489 (symbol->string f259499)) (f259489 ": ") (f259489 f259500) (f259489 "\n"))))
# emit-closure
# si = -4
# env = ((f259489 . 0))
# expr = (closure (f259499 f259500) (f259489 f259489 f259489 f259489 f259489) (let ((f259499 f259499) (f259500 f259500)) (begin (f259489 "error:") (f259489 (symbol->string f259499)) (f259489 ": ") (f259489 f259500) (f259489 "\n"))))
    movl $_L_1576358, 0(%ebp)  # closure label
# emit-variable-ref
# env=((f259489 . 0))
# var=f259489
    movl 0(%esp), %eax  # stack load f259489
# end emit-variable-ref
   movl  %eax, 4(%ebp)  # f259489
# emit-variable-ref
# env=((f259489 . 0))
# var=f259489
    movl 0(%esp), %eax  # stack load f259489
# end emit-variable-ref
   movl  %eax, 8(%ebp)  # f259489
# emit-variable-ref
# env=((f259489 . 0))
# var=f259489
    movl 0(%esp), %eax  # stack load f259489
# end emit-variable-ref
   movl  %eax, 12(%ebp)  # f259489
# emit-variable-ref
# env=((f259489 . 0))
# var=f259489
    movl 0(%esp), %eax  # stack load f259489
# end emit-variable-ref
   movl  %eax, 16(%ebp)  # f259489
# emit-variable-ref
# env=((f259489 . 0))
# var=f259489
    movl 0(%esp), %eax  # stack load f259489
# end emit-variable-ref
   movl  %eax, 20(%ebp)  # f259489
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $24, %ebp     # bump ebp
    jmp _L_1576359            # jump around closure body
_L_1576358:
# check argument count
    cmp $8,%eax
    je _L_1576360
# invoke error handler eh_argcount
    .extern mrc_eh$uargcount
    movl mrc_eh$uargcount, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_1576360:
# emit-tail-expr
# si=-16
# env=((f259500 . -12) (f259499 . -8) (f259489 . 20) (f259489 . 16) (f259489 . 12) (f259489 . 8) (f259489 . 4) (f259489 . 0))
# expr=(let ((f259499 f259499) (f259500 f259500)) (begin (f259489 "error:") (f259489 (symbol->string f259499)) (f259489 ": ") (f259489 f259500) (f259489 "\n")))
# emit-tail-let
#  si   = -16
#  env  = ((f259500 . -12) (f259499 . -8) (f259489 . 20) (f259489 . 16) (f259489 . 12) (f259489 . 8) (f259489 . 4) (f259489 . 0))
#  bindings = ((f259499 f259499) (f259500 f259500))
#  body = (begin (f259489 "error:") (f259489 (symbol->string f259499)) (f259489 ": ") (f259489 f259500) (f259489 "\n"))
# emit-expr f259499
# emit-variable-ref
# env=((f259500 . -12) (f259499 . -8) (f259489 . 20) (f259489 . 16) (f259489 . 12) (f259489 . 8) (f259489 . 4) (f259489 . 0))
# var=f259499
    movl -8(%esp), %eax  # stack load f259499
# end emit-variable-ref
    movl %eax, -16(%esp)  # stack save
# emit-expr f259500
# emit-variable-ref
# env=((f259500 . -12) (f259499 . -8) (f259489 . 20) (f259489 . 16) (f259489 . 12) (f259489 . 8) (f259489 . 4) (f259489 . 0))
# var=f259500
    movl -12(%esp), %eax  # stack load f259500
# end emit-variable-ref
    movl %eax, -20(%esp)  # stack save
# emit-tail-expr
# si=-24
# env=((f259500 . -20) (f259499 . -16) (f259500 . -12) (f259499 . -8) (f259489 . 20) (f259489 . 16) (f259489 . 12) (f259489 . 8) (f259489 . 4) (f259489 . 0))
# expr=(begin (f259489 "error:") (f259489 (symbol->string f259499)) (f259489 ": ") (f259489 f259500) (f259489 "\n"))
# tail-begin (begin (f259489 "error:") (f259489 (symbol->string f259499)) (f259489 ": ") (f259489 f259500) (f259489 "\n"))
#   env=((f259500 . -20) (f259499 . -16) (f259500 . -12) (f259499 . -8) (f259489 . 20) (f259489 . 16) (f259489 . 12) (f259489 . 8) (f259489 . 4) (f259489 . 0))
# emit-expr (f259489 "error:")
# funcall
#    si   =-24
#    env  = ((f259500 . -20) (f259499 . -16) (f259500 . -12) (f259499 . -8) (f259489 . 20) (f259489 . 16) (f259489 . 12) (f259489 . 8) (f259489 . 4) (f259489 . 0))
#    expr = (funcall f259489 "error:")
# emit-expr f259489
# emit-variable-ref
# env=((f259500 . -20) (f259499 . -16) (f259500 . -12) (f259499 . -8) (f259489 . 20) (f259489 . 16) (f259489 . 12) (f259489 . 8) (f259489 . 4) (f259489 . 0))
# var=f259489
    movl 18(%edi), %eax  # frame load f259489
# end emit-variable-ref
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1576361"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1576361":
   movl %eax,  -32(%esp)  # stash funcall-oper in closure slot
# emit-expr "error:"
# string literal
    jmp _L_1576363
    .align 8,0x90
_L_1576362 :
    .int 24
    .ascii "error:"
_L_1576363:
    movl $_L_1576362, %eax
    orl $6, %eax
    mov %eax, -36(%esp)  # arg error:
    movl -32(%esp), %edi   # load new closure to %edi
    add $-24, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $24, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
# emit-tail-expr
# si=-24
# env=((f259500 . -20) (f259499 . -16) (f259500 . -12) (f259499 . -8) (f259489 . 20) (f259489 . 16) (f259489 . 12) (f259489 . 8) (f259489 . 4) (f259489 . 0))
# expr=(begin (f259489 (symbol->string f259499)) (f259489 ": ") (f259489 f259500) (f259489 "\n"))
# tail-begin (begin (f259489 (symbol->string f259499)) (f259489 ": ") (f259489 f259500) (f259489 "\n"))
#   env=((f259500 . -20) (f259499 . -16) (f259500 . -12) (f259499 . -8) (f259489 . 20) (f259489 . 16) (f259489 . 12) (f259489 . 8) (f259489 . 4) (f259489 . 0))
# emit-expr (f259489 (symbol->string f259499))
# funcall
#    si   =-24
#    env  = ((f259500 . -20) (f259499 . -16) (f259500 . -12) (f259499 . -8) (f259489 . 20) (f259489 . 16) (f259489 . 12) (f259489 . 8) (f259489 . 4) (f259489 . 0))
#    expr = (funcall f259489 (symbol->string f259499))
# emit-expr f259489
# emit-variable-ref
# env=((f259500 . -20) (f259499 . -16) (f259500 . -12) (f259499 . -8) (f259489 . 20) (f259489 . 16) (f259489 . 12) (f259489 . 8) (f259489 . 4) (f259489 . 0))
# var=f259489
    movl 18(%edi), %eax  # frame load f259489
# end emit-variable-ref
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1576364"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1576364":
   movl %eax,  -32(%esp)  # stash funcall-oper in closure slot
# emit-expr (symbol->string f259499)
# symbol->string f259499
# emit-expr f259499
# emit-variable-ref
# env=((f259500 . -20) (f259499 . -16) (f259500 . -12) (f259499 . -8) (f259489 . 20) (f259489 . 16) (f259489 . 12) (f259489 . 8) (f259489 . 4) (f259489 . 0))
# var=f259499
    movl -16(%esp), %eax  # stack load f259499
# end emit-variable-ref
    movl -3(%eax), %eax
    mov %eax, -36(%esp)  # arg (symbol->string f259499)
    movl -32(%esp), %edi   # load new closure to %edi
    add $-24, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $24, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
# emit-tail-expr
# si=-24
# env=((f259500 . -20) (f259499 . -16) (f259500 . -12) (f259499 . -8) (f259489 . 20) (f259489 . 16) (f259489 . 12) (f259489 . 8) (f259489 . 4) (f259489 . 0))
# expr=(begin (f259489 ": ") (f259489 f259500) (f259489 "\n"))
# tail-begin (begin (f259489 ": ") (f259489 f259500) (f259489 "\n"))
#   env=((f259500 . -20) (f259499 . -16) (f259500 . -12) (f259499 . -8) (f259489 . 20) (f259489 . 16) (f259489 . 12) (f259489 . 8) (f259489 . 4) (f259489 . 0))
# emit-expr (f259489 ": ")
# funcall
#    si   =-24
#    env  = ((f259500 . -20) (f259499 . -16) (f259500 . -12) (f259499 . -8) (f259489 . 20) (f259489 . 16) (f259489 . 12) (f259489 . 8) (f259489 . 4) (f259489 . 0))
#    expr = (funcall f259489 ": ")
# emit-expr f259489
# emit-variable-ref
# env=((f259500 . -20) (f259499 . -16) (f259500 . -12) (f259499 . -8) (f259489 . 20) (f259489 . 16) (f259489 . 12) (f259489 . 8) (f259489 . 4) (f259489 . 0))
# var=f259489
    movl 18(%edi), %eax  # frame load f259489
# end emit-variable-ref
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1576365"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1576365":
   movl %eax,  -32(%esp)  # stash funcall-oper in closure slot
# emit-expr ": "
# string literal
    jmp _L_1576367
    .align 8,0x90
_L_1576366 :
    .int 8
    .ascii ": "
_L_1576367:
    movl $_L_1576366, %eax
    orl $6, %eax
    mov %eax, -36(%esp)  # arg : 
    movl -32(%esp), %edi   # load new closure to %edi
    add $-24, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $24, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
# emit-tail-expr
# si=-24
# env=((f259500 . -20) (f259499 . -16) (f259500 . -12) (f259499 . -8) (f259489 . 20) (f259489 . 16) (f259489 . 12) (f259489 . 8) (f259489 . 4) (f259489 . 0))
# expr=(begin (f259489 f259500) (f259489 "\n"))
# tail-begin (begin (f259489 f259500) (f259489 "\n"))
#   env=((f259500 . -20) (f259499 . -16) (f259500 . -12) (f259499 . -8) (f259489 . 20) (f259489 . 16) (f259489 . 12) (f259489 . 8) (f259489 . 4) (f259489 . 0))
# emit-expr (f259489 f259500)
# funcall
#    si   =-24
#    env  = ((f259500 . -20) (f259499 . -16) (f259500 . -12) (f259499 . -8) (f259489 . 20) (f259489 . 16) (f259489 . 12) (f259489 . 8) (f259489 . 4) (f259489 . 0))
#    expr = (funcall f259489 f259500)
# emit-expr f259489
# emit-variable-ref
# env=((f259500 . -20) (f259499 . -16) (f259500 . -12) (f259499 . -8) (f259489 . 20) (f259489 . 16) (f259489 . 12) (f259489 . 8) (f259489 . 4) (f259489 . 0))
# var=f259489
    movl 18(%edi), %eax  # frame load f259489
# end emit-variable-ref
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1576368"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1576368":
   movl %eax,  -32(%esp)  # stash funcall-oper in closure slot
# emit-expr f259500
# emit-variable-ref
# env=((f259500 . -20) (f259499 . -16) (f259500 . -12) (f259499 . -8) (f259489 . 20) (f259489 . 16) (f259489 . 12) (f259489 . 8) (f259489 . 4) (f259489 . 0))
# var=f259500
    movl -20(%esp), %eax  # stack load f259500
# end emit-variable-ref
    mov %eax, -36(%esp)  # arg f259500
    movl -32(%esp), %edi   # load new closure to %edi
    add $-24, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $24, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
# emit-tail-expr
# si=-24
# env=((f259500 . -20) (f259499 . -16) (f259500 . -12) (f259499 . -8) (f259489 . 20) (f259489 . 16) (f259489 . 12) (f259489 . 8) (f259489 . 4) (f259489 . 0))
# expr=(begin (f259489 "\n"))
# tail-begin (begin (f259489 "\n"))
#   env=((f259500 . -20) (f259499 . -16) (f259500 . -12) (f259499 . -8) (f259489 . 20) (f259489 . 16) (f259489 . 12) (f259489 . 8) (f259489 . 4) (f259489 . 0))
# emit-tail-expr
# si=-24
# env=((f259500 . -20) (f259499 . -16) (f259500 . -12) (f259499 . -8) (f259489 . 20) (f259489 . 16) (f259489 . 12) (f259489 . 8) (f259489 . 4) (f259489 . 0))
# expr=(f259489 "\n")
# emit-tail-funcall
#    si   =-24
#    env  = ((f259500 . -20) (f259499 . -16) (f259500 . -12) (f259499 . -8) (f259489 . 20) (f259489 . 16) (f259489 . 12) (f259489 . 8) (f259489 . 4) (f259489 . 0))
#    expr = (funcall f259489 "\n")
# emit-expr f259489
# emit-variable-ref
# env=((f259500 . -20) (f259499 . -16) (f259500 . -12) (f259499 . -8) (f259489 . 20) (f259489 . 16) (f259489 . 12) (f259489 . 8) (f259489 . 4) (f259489 . 0))
# var=f259489
    movl 18(%edi), %eax  # frame load f259489
# end emit-variable-ref
   movl %eax,  -24(%esp)  # stash funcall-oper in next closure slot
# emit-expr "\n"
# string literal
    jmp _L_1576370
    .align 8,0x90
_L_1576369 :
    .int 4
    .ascii "\n"
_L_1576370:
    movl $_L_1576369, %eax
    orl $6, %eax
    mov %eax, -28(%esp)    # arg 

    movl -24(%esp), %edi   # load new closure to %edi
# emit-shift-args:  size=2   si=-24  delta=20
    mov -24(%esp), %ebx  # shift frame cell
    mov %ebx, -4(%esp)  # down to base
# emit-shift-args:  size=1   si=-28  delta=20
    mov -28(%esp), %ebx  # shift frame cell
    mov %ebx, -8(%esp)  # down to base
# emit-shift-args:  size=0   si=-32  delta=20
    movl $4,%eax   # save arg count
    jmp *-2(%edi)  # tail-funcall
     ret   # return thru stack
    .align 4,0x90
_L_1576359:
    movl %eax, -4(%esp)  # stack save
# emit-expr (closure (f259503 f259504) (f259498) (let ((f259503 f259503) (f259504 f259504)) (begin (f259498 f259503 f259504) (foreign-call "s_exit" 1))))
# emit-closure
# si = -8
# env = ((f259498 . -4) (f259489 . 0))
# expr = (closure (f259503 f259504) (f259498) (let ((f259503 f259503) (f259504 f259504)) (begin (f259498 f259503 f259504) (foreign-call "s_exit" 1))))
    movl $_L_1576371, 0(%ebp)  # closure label
# emit-variable-ref
# env=((f259498 . -4) (f259489 . 0))
# var=f259498
    movl -4(%esp), %eax  # stack load f259498
# end emit-variable-ref
   movl  %eax, 4(%ebp)  # f259498
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $8, %ebp     # bump ebp
    jmp _L_1576372            # jump around closure body
_L_1576371:
# check argument count
    cmp $8,%eax
    je _L_1576373
# invoke error handler eh_argcount
    .extern mrc_eh$uargcount
    movl mrc_eh$uargcount, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_1576373:
# emit-tail-expr
# si=-16
# env=((f259504 . -12) (f259503 . -8) (f259498 . 4) (f259498 . -4) (f259489 . 0))
# expr=(let ((f259503 f259503) (f259504 f259504)) (begin (f259498 f259503 f259504) (foreign-call "s_exit" 1)))
# emit-tail-let
#  si   = -16
#  env  = ((f259504 . -12) (f259503 . -8) (f259498 . 4) (f259498 . -4) (f259489 . 0))
#  bindings = ((f259503 f259503) (f259504 f259504))
#  body = (begin (f259498 f259503 f259504) (foreign-call "s_exit" 1))
# emit-expr f259503
# emit-variable-ref
# env=((f259504 . -12) (f259503 . -8) (f259498 . 4) (f259498 . -4) (f259489 . 0))
# var=f259503
    movl -8(%esp), %eax  # stack load f259503
# end emit-variable-ref
    movl %eax, -16(%esp)  # stack save
# emit-expr f259504
# emit-variable-ref
# env=((f259504 . -12) (f259503 . -8) (f259498 . 4) (f259498 . -4) (f259489 . 0))
# var=f259504
    movl -12(%esp), %eax  # stack load f259504
# end emit-variable-ref
    movl %eax, -20(%esp)  # stack save
# emit-tail-expr
# si=-24
# env=((f259504 . -20) (f259503 . -16) (f259504 . -12) (f259503 . -8) (f259498 . 4) (f259498 . -4) (f259489 . 0))
# expr=(begin (f259498 f259503 f259504) (foreign-call "s_exit" 1))
# tail-begin (begin (f259498 f259503 f259504) (foreign-call "s_exit" 1))
#   env=((f259504 . -20) (f259503 . -16) (f259504 . -12) (f259503 . -8) (f259498 . 4) (f259498 . -4) (f259489 . 0))
# emit-expr (f259498 f259503 f259504)
# funcall
#    si   =-24
#    env  = ((f259504 . -20) (f259503 . -16) (f259504 . -12) (f259503 . -8) (f259498 . 4) (f259498 . -4) (f259489 . 0))
#    expr = (funcall f259498 f259503 f259504)
# emit-expr f259498
# emit-variable-ref
# env=((f259504 . -20) (f259503 . -16) (f259504 . -12) (f259503 . -8) (f259498 . 4) (f259498 . -4) (f259489 . 0))
# var=f259498
    movl 2(%edi), %eax  # frame load f259498
# end emit-variable-ref
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1576374"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1576374":
   movl %eax,  -32(%esp)  # stash funcall-oper in closure slot
# emit-expr f259503
# emit-variable-ref
# env=((f259504 . -20) (f259503 . -16) (f259504 . -12) (f259503 . -8) (f259498 . 4) (f259498 . -4) (f259489 . 0))
# var=f259503
    movl -16(%esp), %eax  # stack load f259503
# end emit-variable-ref
    mov %eax, -36(%esp)  # arg f259503
# emit-expr f259504
# emit-variable-ref
# env=((f259504 . -20) (f259503 . -16) (f259504 . -12) (f259503 . -8) (f259498 . 4) (f259498 . -4) (f259489 . 0))
# var=f259504
    movl -20(%esp), %eax  # stack load f259504
# end emit-variable-ref
    mov %eax, -40(%esp)  # arg f259504
    movl -32(%esp), %edi   # load new closure to %edi
    add $-24, %esp   # adjust base
    movl $8,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $24, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
# emit-tail-expr
# si=-24
# env=((f259504 . -20) (f259503 . -16) (f259504 . -12) (f259503 . -8) (f259498 . 4) (f259498 . -4) (f259489 . 0))
# expr=(begin (foreign-call "s_exit" 1))
# tail-begin (begin (foreign-call "s_exit" 1))
#   env=((f259504 . -20) (f259503 . -16) (f259504 . -12) (f259503 . -8) (f259498 . 4) (f259498 . -4) (f259489 . 0))
# emit-tail-expr
# si=-24
# env=((f259504 . -20) (f259503 . -16) (f259504 . -12) (f259503 . -8) (f259498 . 4) (f259498 . -4) (f259489 . 0))
# expr=(foreign-call "s_exit" 1)
    movl %ecx,-24(%esp)
    movl %esp,-28(%esp)
# emit-expr 1
    movl $4, %eax     # immed 1
    movl %eax, -32(%esp)
    leal -32(%esp),%edi
    movl %edi,%esi
    andl $-16,%esi
    movl 0(%edi),%eax
    movl %eax,0(%esi)
    movl 4(%edi),%eax
    movl %eax,4(%esi)
    movl %esi,%esp
    .extern _s_exit
    call _s_exit
    movl 4(%esi),%esp
    movl -24(%esp),%ecx
     ret
     ret   # return thru stack
    .align 4,0x90
_L_1576372:
     movl %eax, mrc_error
# == explicit-begins  ==>
# (let ((p (quote ()))) (begin (set! p (cons (quote procedure?) p)) (set! p (cons (quote cdr) p)) (set! p (cons (quote car) p)) (set! p (cons (quote symbol-value) p)) (set! p (cons (quote symbol->string) p)) (set! p (cons (quote make-symbol) p)) (set! p (cons (quote symbol?) p)) (set! p (cons (quote string-set!) p)) (set! p (cons (quote string-ref) p)) (set! p (cons (quote string-length) p)) (set! p (cons (quote string?) p)) (set! p (cons (quote make-string) p)) (set! p (cons (quote vector-ref) p)) (set! p (cons (quote vector-set!) p)) (set! p (cons (quote vector-length) p)) (set! p (cons (quote make-vector) p)) (set! p (cons (quote vector?) p)) (set! p (cons (quote set-cdr!) p)) (set! p (cons (quote set-car!) p)) (set! p (cons (quote cdr) p)) (set! p (cons (quote car) p)) (set! p (cons (quote cons) p)) (set! p (cons (quote pair?) p)) (set! p (cons (quote fxremainder) p)) (set! p (cons (quote fxquotient) p)) (set! p (cons (quote fx*) p)) (set! p (cons (quote fx-) p)) (set! p (cons (quote fx+) p)) (set! p (cons (quote fx>=) p)) (set! p (cons (quote fx>) p)) (set! p (cons (quote fx<=) p)) (set! p (cons (quote fx<) p)) (set! p (cons (quote fx=) p)) (set! p (cons (quote fxzero?) p)) (set! p (cons (quote fxsub1) p)) (set! p (cons (quote fxadd1) p)) (set! p (cons (quote fxlogor) p)) (set! p (cons (quote fxlogand) p)) (set! p (cons (quote fxlognot) p)) (set! p (cons (quote char=?) p)) (set! p (cons (quote eq?) p)) (set! p (cons (quote not) p)) (set! p (cons (quote boolean?) p)) (set! p (cons (quote fixnum?) p)) (set! p (cons (quote char?) p)) (set! p (cons (quote null?) p)) (set! p (cons (quote char->fixnum) p)) (set! p (cons (quote fixnum->char) p)) (lambda () p)))
# == eliminate-let*  ==>
# (let ((p (quote ()))) (begin (set! p (cons (quote procedure?) p)) (set! p (cons (quote cdr) p)) (set! p (cons (quote car) p)) (set! p (cons (quote symbol-value) p)) (set! p (cons (quote symbol->string) p)) (set! p (cons (quote make-symbol) p)) (set! p (cons (quote symbol?) p)) (set! p (cons (quote string-set!) p)) (set! p (cons (quote string-ref) p)) (set! p (cons (quote string-length) p)) (set! p (cons (quote string?) p)) (set! p (cons (quote make-string) p)) (set! p (cons (quote vector-ref) p)) (set! p (cons (quote vector-set!) p)) (set! p (cons (quote vector-length) p)) (set! p (cons (quote make-vector) p)) (set! p (cons (quote vector?) p)) (set! p (cons (quote set-cdr!) p)) (set! p (cons (quote set-car!) p)) (set! p (cons (quote cdr) p)) (set! p (cons (quote car) p)) (set! p (cons (quote cons) p)) (set! p (cons (quote pair?) p)) (set! p (cons (quote fxremainder) p)) (set! p (cons (quote fxquotient) p)) (set! p (cons (quote fx*) p)) (set! p (cons (quote fx-) p)) (set! p (cons (quote fx+) p)) (set! p (cons (quote fx>=) p)) (set! p (cons (quote fx>) p)) (set! p (cons (quote fx<=) p)) (set! p (cons (quote fx<) p)) (set! p (cons (quote fx=) p)) (set! p (cons (quote fxzero?) p)) (set! p (cons (quote fxsub1) p)) (set! p (cons (quote fxadd1) p)) (set! p (cons (quote fxlogor) p)) (set! p (cons (quote fxlogand) p)) (set! p (cons (quote fxlognot) p)) (set! p (cons (quote char=?) p)) (set! p (cons (quote eq?) p)) (set! p (cons (quote not) p)) (set! p (cons (quote boolean?) p)) (set! p (cons (quote fixnum?) p)) (set! p (cons (quote char?) p)) (set! p (cons (quote null?) p)) (set! p (cons (quote char->fixnum) p)) (set! p (cons (quote fixnum->char) p)) (lambda () p)))
# == uniquify-variables  ==>
# (let ((f259505 (quote ()))) (begin (set! f259505 (cons (quote procedure?) f259505)) (set! f259505 (cons (quote cdr) f259505)) (set! f259505 (cons (quote car) f259505)) (set! f259505 (cons (quote symbol-value) f259505)) (set! f259505 (cons (quote symbol->string) f259505)) (set! f259505 (cons (quote make-symbol) f259505)) (set! f259505 (cons (quote symbol?) f259505)) (set! f259505 (cons (quote string-set!) f259505)) (set! f259505 (cons (quote string-ref) f259505)) (set! f259505 (cons (quote string-length) f259505)) (set! f259505 (cons (quote string?) f259505)) (set! f259505 (cons (quote make-string) f259505)) (set! f259505 (cons (quote vector-ref) f259505)) (set! f259505 (cons (quote vector-set!) f259505)) (set! f259505 (cons (quote vector-length) f259505)) (set! f259505 (cons (quote make-vector) f259505)) (set! f259505 (cons (quote vector?) f259505)) (set! f259505 (cons (quote set-cdr!) f259505)) (set! f259505 (cons (quote set-car!) f259505)) (set! f259505 (cons (quote cdr) f259505)) (set! f259505 (cons (quote car) f259505)) (set! f259505 (cons (quote cons) f259505)) (set! f259505 (cons (quote pair?) f259505)) (set! f259505 (cons (quote fxremainder) f259505)) (set! f259505 (cons (quote fxquotient) f259505)) (set! f259505 (cons (quote fx*) f259505)) (set! f259505 (cons (quote fx-) f259505)) (set! f259505 (cons (quote fx+) f259505)) (set! f259505 (cons (quote fx>=) f259505)) (set! f259505 (cons (quote fx>) f259505)) (set! f259505 (cons (quote fx<=) f259505)) (set! f259505 (cons (quote fx<) f259505)) (set! f259505 (cons (quote fx=) f259505)) (set! f259505 (cons (quote fxzero?) f259505)) (set! f259505 (cons (quote fxsub1) f259505)) (set! f259505 (cons (quote fxadd1) f259505)) (set! f259505 (cons (quote fxlogor) f259505)) (set! f259505 (cons (quote fxlogand) f259505)) (set! f259505 (cons (quote fxlognot) f259505)) (set! f259505 (cons (quote char=?) f259505)) (set! f259505 (cons (quote eq?) f259505)) (set! f259505 (cons (quote not) f259505)) (set! f259505 (cons (quote boolean?) f259505)) (set! f259505 (cons (quote fixnum?) f259505)) (set! f259505 (cons (quote char?) f259505)) (set! f259505 (cons (quote null?) f259505)) (set! f259505 (cons (quote char->fixnum) f259505)) (set! f259505 (cons (quote fixnum->char) f259505)) (lambda () f259505)))
# == vectorize-letrec  ==>
# (let ((f259505 (quote ()))) (begin (set! f259505 (cons (quote procedure?) f259505)) (set! f259505 (cons (quote cdr) f259505)) (set! f259505 (cons (quote car) f259505)) (set! f259505 (cons (quote symbol-value) f259505)) (set! f259505 (cons (quote symbol->string) f259505)) (set! f259505 (cons (quote make-symbol) f259505)) (set! f259505 (cons (quote symbol?) f259505)) (set! f259505 (cons (quote string-set!) f259505)) (set! f259505 (cons (quote string-ref) f259505)) (set! f259505 (cons (quote string-length) f259505)) (set! f259505 (cons (quote string?) f259505)) (set! f259505 (cons (quote make-string) f259505)) (set! f259505 (cons (quote vector-ref) f259505)) (set! f259505 (cons (quote vector-set!) f259505)) (set! f259505 (cons (quote vector-length) f259505)) (set! f259505 (cons (quote make-vector) f259505)) (set! f259505 (cons (quote vector?) f259505)) (set! f259505 (cons (quote set-cdr!) f259505)) (set! f259505 (cons (quote set-car!) f259505)) (set! f259505 (cons (quote cdr) f259505)) (set! f259505 (cons (quote car) f259505)) (set! f259505 (cons (quote cons) f259505)) (set! f259505 (cons (quote pair?) f259505)) (set! f259505 (cons (quote fxremainder) f259505)) (set! f259505 (cons (quote fxquotient) f259505)) (set! f259505 (cons (quote fx*) f259505)) (set! f259505 (cons (quote fx-) f259505)) (set! f259505 (cons (quote fx+) f259505)) (set! f259505 (cons (quote fx>=) f259505)) (set! f259505 (cons (quote fx>) f259505)) (set! f259505 (cons (quote fx<=) f259505)) (set! f259505 (cons (quote fx<) f259505)) (set! f259505 (cons (quote fx=) f259505)) (set! f259505 (cons (quote fxzero?) f259505)) (set! f259505 (cons (quote fxsub1) f259505)) (set! f259505 (cons (quote fxadd1) f259505)) (set! f259505 (cons (quote fxlogor) f259505)) (set! f259505 (cons (quote fxlogand) f259505)) (set! f259505 (cons (quote fxlognot) f259505)) (set! f259505 (cons (quote char=?) f259505)) (set! f259505 (cons (quote eq?) f259505)) (set! f259505 (cons (quote not) f259505)) (set! f259505 (cons (quote boolean?) f259505)) (set! f259505 (cons (quote fixnum?) f259505)) (set! f259505 (cons (quote char?) f259505)) (set! f259505 (cons (quote null?) f259505)) (set! f259505 (cons (quote char->fixnum) f259505)) (set! f259505 (cons (quote fixnum->char) f259505)) (lambda () f259505)))
# == eliminate-set!  ==>
# (let ((f259505 (vector (quote ())))) (begin (vector-set! f259505 0 (cons (quote procedure?) (vector-ref f259505 0))) (vector-set! f259505 0 (cons (quote cdr) (vector-ref f259505 0))) (vector-set! f259505 0 (cons (quote car) (vector-ref f259505 0))) (vector-set! f259505 0 (cons (quote symbol-value) (vector-ref f259505 0))) (vector-set! f259505 0 (cons (quote symbol->string) (vector-ref f259505 0))) (vector-set! f259505 0 (cons (quote make-symbol) (vector-ref f259505 0))) (vector-set! f259505 0 (cons (quote symbol?) (vector-ref f259505 0))) (vector-set! f259505 0 (cons (quote string-set!) (vector-ref f259505 0))) (vector-set! f259505 0 (cons (quote string-ref) (vector-ref f259505 0))) (vector-set! f259505 0 (cons (quote string-length) (vector-ref f259505 0))) (vector-set! f259505 0 (cons (quote string?) (vector-ref f259505 0))) (vector-set! f259505 0 (cons (quote make-string) (vector-ref f259505 0))) (vector-set! f259505 0 (cons (quote vector-ref) (vector-ref f259505 0))) (vector-set! f259505 0 (cons (quote vector-set!) (vector-ref f259505 0))) (vector-set! f259505 0 (cons (quote vector-length) (vector-ref f259505 0))) (vector-set! f259505 0 (cons (quote make-vector) (vector-ref f259505 0))) (vector-set! f259505 0 (cons (quote vector?) (vector-ref f259505 0))) (vector-set! f259505 0 (cons (quote set-cdr!) (vector-ref f259505 0))) (vector-set! f259505 0 (cons (quote set-car!) (vector-ref f259505 0))) (vector-set! f259505 0 (cons (quote cdr) (vector-ref f259505 0))) (vector-set! f259505 0 (cons (quote car) (vector-ref f259505 0))) (vector-set! f259505 0 (cons (quote cons) (vector-ref f259505 0))) (vector-set! f259505 0 (cons (quote pair?) (vector-ref f259505 0))) (vector-set! f259505 0 (cons (quote fxremainder) (vector-ref f259505 0))) (vector-set! f259505 0 (cons (quote fxquotient) (vector-ref f259505 0))) (vector-set! f259505 0 (cons (quote fx*) (vector-ref f259505 0))) (vector-set! f259505 0 (cons (quote fx-) (vector-ref f259505 0))) (vector-set! f259505 0 (cons (quote fx+) (vector-ref f259505 0))) (vector-set! f259505 0 (cons (quote fx>=) (vector-ref f259505 0))) (vector-set! f259505 0 (cons (quote fx>) (vector-ref f259505 0))) (vector-set! f259505 0 (cons (quote fx<=) (vector-ref f259505 0))) (vector-set! f259505 0 (cons (quote fx<) (vector-ref f259505 0))) (vector-set! f259505 0 (cons (quote fx=) (vector-ref f259505 0))) (vector-set! f259505 0 (cons (quote fxzero?) (vector-ref f259505 0))) (vector-set! f259505 0 (cons (quote fxsub1) (vector-ref f259505 0))) (vector-set! f259505 0 (cons (quote fxadd1) (vector-ref f259505 0))) (vector-set! f259505 0 (cons (quote fxlogor) (vector-ref f259505 0))) (vector-set! f259505 0 (cons (quote fxlogand) (vector-ref f259505 0))) (vector-set! f259505 0 (cons (quote fxlognot) (vector-ref f259505 0))) (vector-set! f259505 0 (cons (quote char=?) (vector-ref f259505 0))) (vector-set! f259505 0 (cons (quote eq?) (vector-ref f259505 0))) (vector-set! f259505 0 (cons (quote not) (vector-ref f259505 0))) (vector-set! f259505 0 (cons (quote boolean?) (vector-ref f259505 0))) (vector-set! f259505 0 (cons (quote fixnum?) (vector-ref f259505 0))) (vector-set! f259505 0 (cons (quote char?) (vector-ref f259505 0))) (vector-set! f259505 0 (cons (quote null?) (vector-ref f259505 0))) (vector-set! f259505 0 (cons (quote char->fixnum) (vector-ref f259505 0))) (vector-set! f259505 0 (cons (quote fixnum->char) (vector-ref f259505 0))) (lambda () (let () (vector-ref f259505 0)))))
# == close-free-variables  ==>
# (let ((f259505 (vector (quote ())))) (begin (vector-set! f259505 0 (cons (quote procedure?) (vector-ref f259505 0))) (vector-set! f259505 0 (cons (quote cdr) (vector-ref f259505 0))) (vector-set! f259505 0 (cons (quote car) (vector-ref f259505 0))) (vector-set! f259505 0 (cons (quote symbol-value) (vector-ref f259505 0))) (vector-set! f259505 0 (cons (quote symbol->string) (vector-ref f259505 0))) (vector-set! f259505 0 (cons (quote make-symbol) (vector-ref f259505 0))) (vector-set! f259505 0 (cons (quote symbol?) (vector-ref f259505 0))) (vector-set! f259505 0 (cons (quote string-set!) (vector-ref f259505 0))) (vector-set! f259505 0 (cons (quote string-ref) (vector-ref f259505 0))) (vector-set! f259505 0 (cons (quote string-length) (vector-ref f259505 0))) (vector-set! f259505 0 (cons (quote string?) (vector-ref f259505 0))) (vector-set! f259505 0 (cons (quote make-string) (vector-ref f259505 0))) (vector-set! f259505 0 (cons (quote vector-ref) (vector-ref f259505 0))) (vector-set! f259505 0 (cons (quote vector-set!) (vector-ref f259505 0))) (vector-set! f259505 0 (cons (quote vector-length) (vector-ref f259505 0))) (vector-set! f259505 0 (cons (quote make-vector) (vector-ref f259505 0))) (vector-set! f259505 0 (cons (quote vector?) (vector-ref f259505 0))) (vector-set! f259505 0 (cons (quote set-cdr!) (vector-ref f259505 0))) (vector-set! f259505 0 (cons (quote set-car!) (vector-ref f259505 0))) (vector-set! f259505 0 (cons (quote cdr) (vector-ref f259505 0))) (vector-set! f259505 0 (cons (quote car) (vector-ref f259505 0))) (vector-set! f259505 0 (cons (quote cons) (vector-ref f259505 0))) (vector-set! f259505 0 (cons (quote pair?) (vector-ref f259505 0))) (vector-set! f259505 0 (cons (quote fxremainder) (vector-ref f259505 0))) (vector-set! f259505 0 (cons (quote fxquotient) (vector-ref f259505 0))) (vector-set! f259505 0 (cons (quote fx*) (vector-ref f259505 0))) (vector-set! f259505 0 (cons (quote fx-) (vector-ref f259505 0))) (vector-set! f259505 0 (cons (quote fx+) (vector-ref f259505 0))) (vector-set! f259505 0 (cons (quote fx>=) (vector-ref f259505 0))) (vector-set! f259505 0 (cons (quote fx>) (vector-ref f259505 0))) (vector-set! f259505 0 (cons (quote fx<=) (vector-ref f259505 0))) (vector-set! f259505 0 (cons (quote fx<) (vector-ref f259505 0))) (vector-set! f259505 0 (cons (quote fx=) (vector-ref f259505 0))) (vector-set! f259505 0 (cons (quote fxzero?) (vector-ref f259505 0))) (vector-set! f259505 0 (cons (quote fxsub1) (vector-ref f259505 0))) (vector-set! f259505 0 (cons (quote fxadd1) (vector-ref f259505 0))) (vector-set! f259505 0 (cons (quote fxlogor) (vector-ref f259505 0))) (vector-set! f259505 0 (cons (quote fxlogand) (vector-ref f259505 0))) (vector-set! f259505 0 (cons (quote fxlognot) (vector-ref f259505 0))) (vector-set! f259505 0 (cons (quote char=?) (vector-ref f259505 0))) (vector-set! f259505 0 (cons (quote eq?) (vector-ref f259505 0))) (vector-set! f259505 0 (cons (quote not) (vector-ref f259505 0))) (vector-set! f259505 0 (cons (quote boolean?) (vector-ref f259505 0))) (vector-set! f259505 0 (cons (quote fixnum?) (vector-ref f259505 0))) (vector-set! f259505 0 (cons (quote char?) (vector-ref f259505 0))) (vector-set! f259505 0 (cons (quote null?) (vector-ref f259505 0))) (vector-set! f259505 0 (cons (quote char->fixnum) (vector-ref f259505 0))) (vector-set! f259505 0 (cons (quote fixnum->char) (vector-ref f259505 0))) (closure () (f259505) (let () (vector-ref f259505 0)))))
# == eliminate-quote  ==>
# (let ((f259505 (vector ()))) (begin (vector-set! f259505 0 (cons (string->symbol "procedure?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons (string->symbol "cdr") (vector-ref f259505 0))) (vector-set! f259505 0 (cons (string->symbol "car") (vector-ref f259505 0))) (vector-set! f259505 0 (cons (string->symbol "symbol-value") (vector-ref f259505 0))) (vector-set! f259505 0 (cons (string->symbol "symbol->string") (vector-ref f259505 0))) (vector-set! f259505 0 (cons (string->symbol "make-symbol") (vector-ref f259505 0))) (vector-set! f259505 0 (cons (string->symbol "symbol?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons (string->symbol "string-set!") (vector-ref f259505 0))) (vector-set! f259505 0 (cons (string->symbol "string-ref") (vector-ref f259505 0))) (vector-set! f259505 0 (cons (string->symbol "string-length") (vector-ref f259505 0))) (vector-set! f259505 0 (cons (string->symbol "string?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons (string->symbol "make-string") (vector-ref f259505 0))) (vector-set! f259505 0 (cons (string->symbol "vector-ref") (vector-ref f259505 0))) (vector-set! f259505 0 (cons (string->symbol "vector-set!") (vector-ref f259505 0))) (vector-set! f259505 0 (cons (string->symbol "vector-length") (vector-ref f259505 0))) (vector-set! f259505 0 (cons (string->symbol "make-vector") (vector-ref f259505 0))) (vector-set! f259505 0 (cons (string->symbol "vector?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons (string->symbol "set-cdr!") (vector-ref f259505 0))) (vector-set! f259505 0 (cons (string->symbol "set-car!") (vector-ref f259505 0))) (vector-set! f259505 0 (cons (string->symbol "cdr") (vector-ref f259505 0))) (vector-set! f259505 0 (cons (string->symbol "car") (vector-ref f259505 0))) (vector-set! f259505 0 (cons (string->symbol "cons") (vector-ref f259505 0))) (vector-set! f259505 0 (cons (string->symbol "pair?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons (string->symbol "fxremainder") (vector-ref f259505 0))) (vector-set! f259505 0 (cons (string->symbol "fxquotient") (vector-ref f259505 0))) (vector-set! f259505 0 (cons (string->symbol "fx*") (vector-ref f259505 0))) (vector-set! f259505 0 (cons (string->symbol "fx-") (vector-ref f259505 0))) (vector-set! f259505 0 (cons (string->symbol "fx+") (vector-ref f259505 0))) (vector-set! f259505 0 (cons (string->symbol "fx>=") (vector-ref f259505 0))) (vector-set! f259505 0 (cons (string->symbol "fx>") (vector-ref f259505 0))) (vector-set! f259505 0 (cons (string->symbol "fx<=") (vector-ref f259505 0))) (vector-set! f259505 0 (cons (string->symbol "fx<") (vector-ref f259505 0))) (vector-set! f259505 0 (cons (string->symbol "fx=") (vector-ref f259505 0))) (vector-set! f259505 0 (cons (string->symbol "fxzero?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons (string->symbol "fxsub1") (vector-ref f259505 0))) (vector-set! f259505 0 (cons (string->symbol "fxadd1") (vector-ref f259505 0))) (vector-set! f259505 0 (cons (string->symbol "fxlogor") (vector-ref f259505 0))) (vector-set! f259505 0 (cons (string->symbol "fxlogand") (vector-ref f259505 0))) (vector-set! f259505 0 (cons (string->symbol "fxlognot") (vector-ref f259505 0))) (vector-set! f259505 0 (cons (string->symbol "char=?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons (string->symbol "eq?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons (string->symbol "not") (vector-ref f259505 0))) (vector-set! f259505 0 (cons (string->symbol "boolean?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons (string->symbol "fixnum?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons (string->symbol "char?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons (string->symbol "null?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons (string->symbol "char->fixnum") (vector-ref f259505 0))) (vector-set! f259505 0 (cons (string->symbol "fixnum->char") (vector-ref f259505 0))) (closure () (f259505) (let () (vector-ref f259505 0)))))
# == eliminate-when/unless  ==>
# (let ((f259505 (vector ()))) (begin (vector-set! f259505 0 (cons (string->symbol "procedure?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons (string->symbol "cdr") (vector-ref f259505 0))) (vector-set! f259505 0 (cons (string->symbol "car") (vector-ref f259505 0))) (vector-set! f259505 0 (cons (string->symbol "symbol-value") (vector-ref f259505 0))) (vector-set! f259505 0 (cons (string->symbol "symbol->string") (vector-ref f259505 0))) (vector-set! f259505 0 (cons (string->symbol "make-symbol") (vector-ref f259505 0))) (vector-set! f259505 0 (cons (string->symbol "symbol?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons (string->symbol "string-set!") (vector-ref f259505 0))) (vector-set! f259505 0 (cons (string->symbol "string-ref") (vector-ref f259505 0))) (vector-set! f259505 0 (cons (string->symbol "string-length") (vector-ref f259505 0))) (vector-set! f259505 0 (cons (string->symbol "string?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons (string->symbol "make-string") (vector-ref f259505 0))) (vector-set! f259505 0 (cons (string->symbol "vector-ref") (vector-ref f259505 0))) (vector-set! f259505 0 (cons (string->symbol "vector-set!") (vector-ref f259505 0))) (vector-set! f259505 0 (cons (string->symbol "vector-length") (vector-ref f259505 0))) (vector-set! f259505 0 (cons (string->symbol "make-vector") (vector-ref f259505 0))) (vector-set! f259505 0 (cons (string->symbol "vector?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons (string->symbol "set-cdr!") (vector-ref f259505 0))) (vector-set! f259505 0 (cons (string->symbol "set-car!") (vector-ref f259505 0))) (vector-set! f259505 0 (cons (string->symbol "cdr") (vector-ref f259505 0))) (vector-set! f259505 0 (cons (string->symbol "car") (vector-ref f259505 0))) (vector-set! f259505 0 (cons (string->symbol "cons") (vector-ref f259505 0))) (vector-set! f259505 0 (cons (string->symbol "pair?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons (string->symbol "fxremainder") (vector-ref f259505 0))) (vector-set! f259505 0 (cons (string->symbol "fxquotient") (vector-ref f259505 0))) (vector-set! f259505 0 (cons (string->symbol "fx*") (vector-ref f259505 0))) (vector-set! f259505 0 (cons (string->symbol "fx-") (vector-ref f259505 0))) (vector-set! f259505 0 (cons (string->symbol "fx+") (vector-ref f259505 0))) (vector-set! f259505 0 (cons (string->symbol "fx>=") (vector-ref f259505 0))) (vector-set! f259505 0 (cons (string->symbol "fx>") (vector-ref f259505 0))) (vector-set! f259505 0 (cons (string->symbol "fx<=") (vector-ref f259505 0))) (vector-set! f259505 0 (cons (string->symbol "fx<") (vector-ref f259505 0))) (vector-set! f259505 0 (cons (string->symbol "fx=") (vector-ref f259505 0))) (vector-set! f259505 0 (cons (string->symbol "fxzero?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons (string->symbol "fxsub1") (vector-ref f259505 0))) (vector-set! f259505 0 (cons (string->symbol "fxadd1") (vector-ref f259505 0))) (vector-set! f259505 0 (cons (string->symbol "fxlogor") (vector-ref f259505 0))) (vector-set! f259505 0 (cons (string->symbol "fxlogand") (vector-ref f259505 0))) (vector-set! f259505 0 (cons (string->symbol "fxlognot") (vector-ref f259505 0))) (vector-set! f259505 0 (cons (string->symbol "char=?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons (string->symbol "eq?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons (string->symbol "not") (vector-ref f259505 0))) (vector-set! f259505 0 (cons (string->symbol "boolean?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons (string->symbol "fixnum?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons (string->symbol "char?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons (string->symbol "null?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons (string->symbol "char->fixnum") (vector-ref f259505 0))) (vector-set! f259505 0 (cons (string->symbol "fixnum->char") (vector-ref f259505 0))) (closure () (f259505) (let () (vector-ref f259505 0)))))
# == eliminate-cond  ==>
# (let ((f259505 (vector ()))) (begin (vector-set! f259505 0 (cons (string->symbol "procedure?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons (string->symbol "cdr") (vector-ref f259505 0))) (vector-set! f259505 0 (cons (string->symbol "car") (vector-ref f259505 0))) (vector-set! f259505 0 (cons (string->symbol "symbol-value") (vector-ref f259505 0))) (vector-set! f259505 0 (cons (string->symbol "symbol->string") (vector-ref f259505 0))) (vector-set! f259505 0 (cons (string->symbol "make-symbol") (vector-ref f259505 0))) (vector-set! f259505 0 (cons (string->symbol "symbol?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons (string->symbol "string-set!") (vector-ref f259505 0))) (vector-set! f259505 0 (cons (string->symbol "string-ref") (vector-ref f259505 0))) (vector-set! f259505 0 (cons (string->symbol "string-length") (vector-ref f259505 0))) (vector-set! f259505 0 (cons (string->symbol "string?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons (string->symbol "make-string") (vector-ref f259505 0))) (vector-set! f259505 0 (cons (string->symbol "vector-ref") (vector-ref f259505 0))) (vector-set! f259505 0 (cons (string->symbol "vector-set!") (vector-ref f259505 0))) (vector-set! f259505 0 (cons (string->symbol "vector-length") (vector-ref f259505 0))) (vector-set! f259505 0 (cons (string->symbol "make-vector") (vector-ref f259505 0))) (vector-set! f259505 0 (cons (string->symbol "vector?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons (string->symbol "set-cdr!") (vector-ref f259505 0))) (vector-set! f259505 0 (cons (string->symbol "set-car!") (vector-ref f259505 0))) (vector-set! f259505 0 (cons (string->symbol "cdr") (vector-ref f259505 0))) (vector-set! f259505 0 (cons (string->symbol "car") (vector-ref f259505 0))) (vector-set! f259505 0 (cons (string->symbol "cons") (vector-ref f259505 0))) (vector-set! f259505 0 (cons (string->symbol "pair?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons (string->symbol "fxremainder") (vector-ref f259505 0))) (vector-set! f259505 0 (cons (string->symbol "fxquotient") (vector-ref f259505 0))) (vector-set! f259505 0 (cons (string->symbol "fx*") (vector-ref f259505 0))) (vector-set! f259505 0 (cons (string->symbol "fx-") (vector-ref f259505 0))) (vector-set! f259505 0 (cons (string->symbol "fx+") (vector-ref f259505 0))) (vector-set! f259505 0 (cons (string->symbol "fx>=") (vector-ref f259505 0))) (vector-set! f259505 0 (cons (string->symbol "fx>") (vector-ref f259505 0))) (vector-set! f259505 0 (cons (string->symbol "fx<=") (vector-ref f259505 0))) (vector-set! f259505 0 (cons (string->symbol "fx<") (vector-ref f259505 0))) (vector-set! f259505 0 (cons (string->symbol "fx=") (vector-ref f259505 0))) (vector-set! f259505 0 (cons (string->symbol "fxzero?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons (string->symbol "fxsub1") (vector-ref f259505 0))) (vector-set! f259505 0 (cons (string->symbol "fxadd1") (vector-ref f259505 0))) (vector-set! f259505 0 (cons (string->symbol "fxlogor") (vector-ref f259505 0))) (vector-set! f259505 0 (cons (string->symbol "fxlogand") (vector-ref f259505 0))) (vector-set! f259505 0 (cons (string->symbol "fxlognot") (vector-ref f259505 0))) (vector-set! f259505 0 (cons (string->symbol "char=?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons (string->symbol "eq?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons (string->symbol "not") (vector-ref f259505 0))) (vector-set! f259505 0 (cons (string->symbol "boolean?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons (string->symbol "fixnum?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons (string->symbol "char?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons (string->symbol "null?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons (string->symbol "char->fixnum") (vector-ref f259505 0))) (vector-set! f259505 0 (cons (string->symbol "fixnum->char") (vector-ref f259505 0))) (closure () (f259505) (let () (vector-ref f259505 0)))))
# == external-symbols  ==>
# (let ((f259505 ((primitive-ref vector) ()))) (begin (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "procedure?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "cdr") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "car") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "symbol-value") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "symbol->string") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "make-symbol") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "symbol?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "string-set!") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "string-ref") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "string-length") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "string?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "make-string") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "vector-ref") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "vector-set!") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "vector-length") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "make-vector") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "vector?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "set-cdr!") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "set-car!") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "cdr") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "car") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "cons") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "pair?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fxremainder") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fxquotient") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fx*") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fx-") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fx+") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fx>=") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fx>") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fx<=") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fx<") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fx=") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f259505 0))) (closure () (f259505) (let () (vector-ref f259505 0)))))
# emit-expr (let ((f259505 ((primitive-ref vector) ()))) (begin (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "procedure?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "cdr") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "car") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "symbol-value") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "symbol->string") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "make-symbol") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "symbol?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "string-set!") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "string-ref") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "string-length") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "string?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "make-string") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "vector-ref") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "vector-set!") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "vector-length") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "make-vector") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "vector?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "set-cdr!") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "set-car!") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "cdr") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "car") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "cons") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "pair?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fxremainder") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fxquotient") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fx*") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fx-") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fx+") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fx>=") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fx>") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fx<=") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fx<") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fx=") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f259505 0))) (closure () (f259505) (let () (vector-ref f259505 0)))))
# emit-let
#  si   = 0
#  env  = ()
#  bindings = ((f259505 ((primitive-ref vector) ())))
#  body = (begin (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "procedure?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "cdr") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "car") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "symbol-value") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "symbol->string") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "make-symbol") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "symbol?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "string-set!") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "string-ref") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "string-length") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "string?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "make-string") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "vector-ref") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "vector-set!") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "vector-length") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "make-vector") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "vector?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "set-cdr!") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "set-car!") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "cdr") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "car") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "cons") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "pair?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fxremainder") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fxquotient") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fx*") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fx-") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fx+") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fx>=") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fx>") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fx<=") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fx<") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fx=") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f259505 0))) (closure () (f259505) (let () (vector-ref f259505 0))))
# emit-expr ((primitive-ref vector) ())
# funcall
#    si   =0
#    env  = ()
#    expr = (funcall (primitive-ref vector) ())
# emit-expr (primitive-ref vector)
    .extern mrc_vector
    movl mrc_vector,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1576375"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1576375":
   movl %eax,  -8(%esp)  # stash funcall-oper in closure slot
# emit-expr ()
    movl $63, %eax     # immed ()
    mov %eax, -12(%esp)  # arg ()
    movl -8(%esp), %edi   # load new closure to %edi
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    movl -4(%esp), %edi   # restore closure frame ptr
    movl %eax, 0(%esp)  # stack save
# emit-expr (begin (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "procedure?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "cdr") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "car") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "symbol-value") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "symbol->string") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "make-symbol") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "symbol?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "string-set!") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "string-ref") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "string-length") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "string?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "make-string") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "vector-ref") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "vector-set!") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "vector-length") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "make-vector") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "vector?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "set-cdr!") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "set-car!") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "cdr") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "car") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "cons") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "pair?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fxremainder") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fxquotient") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fx*") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fx-") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fx+") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fx>=") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fx>") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fx<=") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fx<") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fx=") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f259505 0))) (closure () (f259505) (let () (vector-ref f259505 0))))
# emit-begin
#   expr=(begin (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "procedure?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "cdr") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "car") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "symbol-value") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "symbol->string") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "make-symbol") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "symbol?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "string-set!") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "string-ref") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "string-length") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "string?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "make-string") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "vector-ref") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "vector-set!") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "vector-length") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "make-vector") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "vector?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "set-cdr!") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "set-car!") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "cdr") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "car") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "cons") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "pair?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fxremainder") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fxquotient") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fx*") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fx-") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fx+") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fx>=") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fx>") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fx<=") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fx<") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fx=") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f259505 0))) (closure () (f259505) (let () (vector-ref f259505 0))))
#   env=((f259505 . 0))
# emit-expr (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "procedure?") (vector-ref f259505 0)))
# emit-expr f259505
# emit-variable-ref
# env=((f259505 . 0))
# var=f259505
    movl 0(%esp), %eax  # stack load f259505
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1576376
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1576376:
    movl %eax, -4(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1576377"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1576377:
# check bounds on vector index
    movl -4(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1576379
    cmp  $0,%eax
    jge _L_1576378
_L_1576379:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1576378:
    movl %eax, -8(%esp)
# emit-expr (cons ((primitive-ref string->symbol) "procedure?") (vector-ref f259505 0))
# cons arg1=((primitive-ref string->symbol) "procedure?") arg2=(vector-ref f259505 0)
# emit-expr ((primitive-ref string->symbol) "procedure?")
# funcall
#    si   =-12
#    env  = ((f259505 . 0))
#    expr = (funcall (primitive-ref string->symbol) "procedure?")
# emit-expr (primitive-ref string->symbol)
    .extern mrc_string$m$gsymbol
    movl mrc_string$m$gsymbol,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1576380"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1576380":
   movl %eax,  -20(%esp)  # stash funcall-oper in closure slot
# emit-expr "procedure?"
# string literal
    jmp _L_1576382
    .align 8,0x90
_L_1576381 :
    .int 40
    .ascii "procedure?"
_L_1576382:
    movl $_L_1576381, %eax
    orl $6, %eax
    mov %eax, -24(%esp)  # arg procedure?
    movl -20(%esp), %edi   # load new closure to %edi
    add $-12, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $12, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    movl %eax, -12(%esp)
# emit-expr (vector-ref f259505 0)
# emit-expr f259505
# emit-variable-ref
# env=((f259505 . 0))
# var=f259505
    movl 0(%esp), %eax  # stack load f259505
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1576383
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1576383:
    movl %eax, -16(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1576384"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1576384:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1576386
    cmp  $0,%eax
    jge _L_1576385
_L_1576386:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1576385:
    movl -16(%esp), %esi
    movl -1(%eax,%esi), %eax
    movl %eax, 4(%ebp)
    movl -12(%esp), %eax
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    or   $1, %al
    add  $8, %ebp
# cons end
    movl -4(%esp), %ebx
    movl -8(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "cdr") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "car") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "symbol-value") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "symbol->string") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "make-symbol") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "symbol?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "string-set!") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "string-ref") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "string-length") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "string?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "make-string") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "vector-ref") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "vector-set!") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "vector-length") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "make-vector") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "vector?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "set-cdr!") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "set-car!") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "cdr") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "car") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "cons") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "pair?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fxremainder") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fxquotient") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fx*") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fx-") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fx+") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fx>=") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fx>") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fx<=") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fx<") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fx=") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f259505 0))) (closure () (f259505) (let () (vector-ref f259505 0))))
# emit-begin
#   expr=(begin (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "cdr") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "car") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "symbol-value") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "symbol->string") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "make-symbol") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "symbol?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "string-set!") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "string-ref") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "string-length") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "string?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "make-string") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "vector-ref") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "vector-set!") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "vector-length") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "make-vector") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "vector?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "set-cdr!") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "set-car!") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "cdr") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "car") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "cons") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "pair?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fxremainder") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fxquotient") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fx*") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fx-") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fx+") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fx>=") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fx>") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fx<=") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fx<") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fx=") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f259505 0))) (closure () (f259505) (let () (vector-ref f259505 0))))
#   env=((f259505 . 0))
# emit-expr (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "cdr") (vector-ref f259505 0)))
# emit-expr f259505
# emit-variable-ref
# env=((f259505 . 0))
# var=f259505
    movl 0(%esp), %eax  # stack load f259505
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1576387
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1576387:
    movl %eax, -4(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1576388"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1576388:
# check bounds on vector index
    movl -4(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1576390
    cmp  $0,%eax
    jge _L_1576389
_L_1576390:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1576389:
    movl %eax, -8(%esp)
# emit-expr (cons ((primitive-ref string->symbol) "cdr") (vector-ref f259505 0))
# cons arg1=((primitive-ref string->symbol) "cdr") arg2=(vector-ref f259505 0)
# emit-expr ((primitive-ref string->symbol) "cdr")
# funcall
#    si   =-12
#    env  = ((f259505 . 0))
#    expr = (funcall (primitive-ref string->symbol) "cdr")
# emit-expr (primitive-ref string->symbol)
    .extern mrc_string$m$gsymbol
    movl mrc_string$m$gsymbol,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1576391"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1576391":
   movl %eax,  -20(%esp)  # stash funcall-oper in closure slot
# emit-expr "cdr"
# string literal
    jmp _L_1576393
    .align 8,0x90
_L_1576392 :
    .int 12
    .ascii "cdr"
_L_1576393:
    movl $_L_1576392, %eax
    orl $6, %eax
    mov %eax, -24(%esp)  # arg cdr
    movl -20(%esp), %edi   # load new closure to %edi
    add $-12, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $12, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    movl %eax, -12(%esp)
# emit-expr (vector-ref f259505 0)
# emit-expr f259505
# emit-variable-ref
# env=((f259505 . 0))
# var=f259505
    movl 0(%esp), %eax  # stack load f259505
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1576394
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1576394:
    movl %eax, -16(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1576395"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1576395:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1576397
    cmp  $0,%eax
    jge _L_1576396
_L_1576397:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1576396:
    movl -16(%esp), %esi
    movl -1(%eax,%esi), %eax
    movl %eax, 4(%ebp)
    movl -12(%esp), %eax
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    or   $1, %al
    add  $8, %ebp
# cons end
    movl -4(%esp), %ebx
    movl -8(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "car") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "symbol-value") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "symbol->string") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "make-symbol") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "symbol?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "string-set!") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "string-ref") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "string-length") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "string?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "make-string") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "vector-ref") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "vector-set!") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "vector-length") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "make-vector") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "vector?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "set-cdr!") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "set-car!") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "cdr") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "car") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "cons") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "pair?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fxremainder") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fxquotient") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fx*") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fx-") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fx+") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fx>=") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fx>") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fx<=") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fx<") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fx=") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f259505 0))) (closure () (f259505) (let () (vector-ref f259505 0))))
# emit-begin
#   expr=(begin (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "car") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "symbol-value") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "symbol->string") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "make-symbol") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "symbol?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "string-set!") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "string-ref") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "string-length") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "string?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "make-string") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "vector-ref") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "vector-set!") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "vector-length") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "make-vector") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "vector?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "set-cdr!") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "set-car!") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "cdr") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "car") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "cons") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "pair?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fxremainder") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fxquotient") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fx*") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fx-") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fx+") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fx>=") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fx>") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fx<=") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fx<") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fx=") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f259505 0))) (closure () (f259505) (let () (vector-ref f259505 0))))
#   env=((f259505 . 0))
# emit-expr (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "car") (vector-ref f259505 0)))
# emit-expr f259505
# emit-variable-ref
# env=((f259505 . 0))
# var=f259505
    movl 0(%esp), %eax  # stack load f259505
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1576398
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1576398:
    movl %eax, -4(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1576399"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1576399:
# check bounds on vector index
    movl -4(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1576401
    cmp  $0,%eax
    jge _L_1576400
_L_1576401:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1576400:
    movl %eax, -8(%esp)
# emit-expr (cons ((primitive-ref string->symbol) "car") (vector-ref f259505 0))
# cons arg1=((primitive-ref string->symbol) "car") arg2=(vector-ref f259505 0)
# emit-expr ((primitive-ref string->symbol) "car")
# funcall
#    si   =-12
#    env  = ((f259505 . 0))
#    expr = (funcall (primitive-ref string->symbol) "car")
# emit-expr (primitive-ref string->symbol)
    .extern mrc_string$m$gsymbol
    movl mrc_string$m$gsymbol,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1576402"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1576402":
   movl %eax,  -20(%esp)  # stash funcall-oper in closure slot
# emit-expr "car"
# string literal
    jmp _L_1576404
    .align 8,0x90
_L_1576403 :
    .int 12
    .ascii "car"
_L_1576404:
    movl $_L_1576403, %eax
    orl $6, %eax
    mov %eax, -24(%esp)  # arg car
    movl -20(%esp), %edi   # load new closure to %edi
    add $-12, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $12, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    movl %eax, -12(%esp)
# emit-expr (vector-ref f259505 0)
# emit-expr f259505
# emit-variable-ref
# env=((f259505 . 0))
# var=f259505
    movl 0(%esp), %eax  # stack load f259505
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1576405
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1576405:
    movl %eax, -16(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1576406"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1576406:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1576408
    cmp  $0,%eax
    jge _L_1576407
_L_1576408:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1576407:
    movl -16(%esp), %esi
    movl -1(%eax,%esi), %eax
    movl %eax, 4(%ebp)
    movl -12(%esp), %eax
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    or   $1, %al
    add  $8, %ebp
# cons end
    movl -4(%esp), %ebx
    movl -8(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "symbol-value") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "symbol->string") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "make-symbol") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "symbol?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "string-set!") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "string-ref") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "string-length") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "string?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "make-string") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "vector-ref") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "vector-set!") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "vector-length") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "make-vector") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "vector?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "set-cdr!") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "set-car!") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "cdr") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "car") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "cons") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "pair?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fxremainder") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fxquotient") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fx*") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fx-") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fx+") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fx>=") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fx>") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fx<=") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fx<") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fx=") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f259505 0))) (closure () (f259505) (let () (vector-ref f259505 0))))
# emit-begin
#   expr=(begin (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "symbol-value") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "symbol->string") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "make-symbol") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "symbol?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "string-set!") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "string-ref") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "string-length") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "string?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "make-string") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "vector-ref") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "vector-set!") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "vector-length") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "make-vector") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "vector?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "set-cdr!") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "set-car!") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "cdr") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "car") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "cons") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "pair?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fxremainder") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fxquotient") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fx*") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fx-") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fx+") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fx>=") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fx>") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fx<=") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fx<") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fx=") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f259505 0))) (closure () (f259505) (let () (vector-ref f259505 0))))
#   env=((f259505 . 0))
# emit-expr (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "symbol-value") (vector-ref f259505 0)))
# emit-expr f259505
# emit-variable-ref
# env=((f259505 . 0))
# var=f259505
    movl 0(%esp), %eax  # stack load f259505
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1576409
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1576409:
    movl %eax, -4(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1576410"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1576410:
# check bounds on vector index
    movl -4(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1576412
    cmp  $0,%eax
    jge _L_1576411
_L_1576412:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1576411:
    movl %eax, -8(%esp)
# emit-expr (cons ((primitive-ref string->symbol) "symbol-value") (vector-ref f259505 0))
# cons arg1=((primitive-ref string->symbol) "symbol-value") arg2=(vector-ref f259505 0)
# emit-expr ((primitive-ref string->symbol) "symbol-value")
# funcall
#    si   =-12
#    env  = ((f259505 . 0))
#    expr = (funcall (primitive-ref string->symbol) "symbol-value")
# emit-expr (primitive-ref string->symbol)
    .extern mrc_string$m$gsymbol
    movl mrc_string$m$gsymbol,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1576413"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1576413":
   movl %eax,  -20(%esp)  # stash funcall-oper in closure slot
# emit-expr "symbol-value"
# string literal
    jmp _L_1576415
    .align 8,0x90
_L_1576414 :
    .int 48
    .ascii "symbol-value"
_L_1576415:
    movl $_L_1576414, %eax
    orl $6, %eax
    mov %eax, -24(%esp)  # arg symbol-value
    movl -20(%esp), %edi   # load new closure to %edi
    add $-12, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $12, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    movl %eax, -12(%esp)
# emit-expr (vector-ref f259505 0)
# emit-expr f259505
# emit-variable-ref
# env=((f259505 . 0))
# var=f259505
    movl 0(%esp), %eax  # stack load f259505
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1576416
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1576416:
    movl %eax, -16(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1576417"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1576417:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1576419
    cmp  $0,%eax
    jge _L_1576418
_L_1576419:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1576418:
    movl -16(%esp), %esi
    movl -1(%eax,%esi), %eax
    movl %eax, 4(%ebp)
    movl -12(%esp), %eax
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    or   $1, %al
    add  $8, %ebp
# cons end
    movl -4(%esp), %ebx
    movl -8(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "symbol->string") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "make-symbol") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "symbol?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "string-set!") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "string-ref") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "string-length") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "string?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "make-string") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "vector-ref") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "vector-set!") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "vector-length") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "make-vector") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "vector?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "set-cdr!") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "set-car!") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "cdr") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "car") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "cons") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "pair?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fxremainder") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fxquotient") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fx*") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fx-") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fx+") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fx>=") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fx>") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fx<=") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fx<") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fx=") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f259505 0))) (closure () (f259505) (let () (vector-ref f259505 0))))
# emit-begin
#   expr=(begin (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "symbol->string") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "make-symbol") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "symbol?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "string-set!") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "string-ref") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "string-length") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "string?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "make-string") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "vector-ref") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "vector-set!") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "vector-length") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "make-vector") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "vector?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "set-cdr!") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "set-car!") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "cdr") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "car") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "cons") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "pair?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fxremainder") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fxquotient") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fx*") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fx-") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fx+") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fx>=") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fx>") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fx<=") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fx<") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fx=") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f259505 0))) (closure () (f259505) (let () (vector-ref f259505 0))))
#   env=((f259505 . 0))
# emit-expr (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "symbol->string") (vector-ref f259505 0)))
# emit-expr f259505
# emit-variable-ref
# env=((f259505 . 0))
# var=f259505
    movl 0(%esp), %eax  # stack load f259505
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1576420
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1576420:
    movl %eax, -4(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1576421"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1576421:
# check bounds on vector index
    movl -4(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1576423
    cmp  $0,%eax
    jge _L_1576422
_L_1576423:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1576422:
    movl %eax, -8(%esp)
# emit-expr (cons ((primitive-ref string->symbol) "symbol->string") (vector-ref f259505 0))
# cons arg1=((primitive-ref string->symbol) "symbol->string") arg2=(vector-ref f259505 0)
# emit-expr ((primitive-ref string->symbol) "symbol->string")
# funcall
#    si   =-12
#    env  = ((f259505 . 0))
#    expr = (funcall (primitive-ref string->symbol) "symbol->string")
# emit-expr (primitive-ref string->symbol)
    .extern mrc_string$m$gsymbol
    movl mrc_string$m$gsymbol,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1576424"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1576424":
   movl %eax,  -20(%esp)  # stash funcall-oper in closure slot
# emit-expr "symbol->string"
# string literal
    jmp _L_1576426
    .align 8,0x90
_L_1576425 :
    .int 56
    .ascii "symbol->string"
_L_1576426:
    movl $_L_1576425, %eax
    orl $6, %eax
    mov %eax, -24(%esp)  # arg symbol->string
    movl -20(%esp), %edi   # load new closure to %edi
    add $-12, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $12, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    movl %eax, -12(%esp)
# emit-expr (vector-ref f259505 0)
# emit-expr f259505
# emit-variable-ref
# env=((f259505 . 0))
# var=f259505
    movl 0(%esp), %eax  # stack load f259505
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1576427
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1576427:
    movl %eax, -16(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1576428"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1576428:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1576430
    cmp  $0,%eax
    jge _L_1576429
_L_1576430:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1576429:
    movl -16(%esp), %esi
    movl -1(%eax,%esi), %eax
    movl %eax, 4(%ebp)
    movl -12(%esp), %eax
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    or   $1, %al
    add  $8, %ebp
# cons end
    movl -4(%esp), %ebx
    movl -8(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "make-symbol") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "symbol?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "string-set!") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "string-ref") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "string-length") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "string?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "make-string") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "vector-ref") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "vector-set!") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "vector-length") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "make-vector") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "vector?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "set-cdr!") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "set-car!") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "cdr") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "car") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "cons") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "pair?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fxremainder") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fxquotient") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fx*") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fx-") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fx+") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fx>=") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fx>") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fx<=") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fx<") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fx=") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f259505 0))) (closure () (f259505) (let () (vector-ref f259505 0))))
# emit-begin
#   expr=(begin (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "make-symbol") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "symbol?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "string-set!") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "string-ref") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "string-length") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "string?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "make-string") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "vector-ref") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "vector-set!") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "vector-length") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "make-vector") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "vector?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "set-cdr!") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "set-car!") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "cdr") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "car") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "cons") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "pair?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fxremainder") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fxquotient") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fx*") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fx-") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fx+") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fx>=") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fx>") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fx<=") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fx<") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fx=") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f259505 0))) (closure () (f259505) (let () (vector-ref f259505 0))))
#   env=((f259505 . 0))
# emit-expr (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "make-symbol") (vector-ref f259505 0)))
# emit-expr f259505
# emit-variable-ref
# env=((f259505 . 0))
# var=f259505
    movl 0(%esp), %eax  # stack load f259505
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1576431
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1576431:
    movl %eax, -4(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1576432"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1576432:
# check bounds on vector index
    movl -4(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1576434
    cmp  $0,%eax
    jge _L_1576433
_L_1576434:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1576433:
    movl %eax, -8(%esp)
# emit-expr (cons ((primitive-ref string->symbol) "make-symbol") (vector-ref f259505 0))
# cons arg1=((primitive-ref string->symbol) "make-symbol") arg2=(vector-ref f259505 0)
# emit-expr ((primitive-ref string->symbol) "make-symbol")
# funcall
#    si   =-12
#    env  = ((f259505 . 0))
#    expr = (funcall (primitive-ref string->symbol) "make-symbol")
# emit-expr (primitive-ref string->symbol)
    .extern mrc_string$m$gsymbol
    movl mrc_string$m$gsymbol,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1576435"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1576435":
   movl %eax,  -20(%esp)  # stash funcall-oper in closure slot
# emit-expr "make-symbol"
# string literal
    jmp _L_1576437
    .align 8,0x90
_L_1576436 :
    .int 44
    .ascii "make-symbol"
_L_1576437:
    movl $_L_1576436, %eax
    orl $6, %eax
    mov %eax, -24(%esp)  # arg make-symbol
    movl -20(%esp), %edi   # load new closure to %edi
    add $-12, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $12, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    movl %eax, -12(%esp)
# emit-expr (vector-ref f259505 0)
# emit-expr f259505
# emit-variable-ref
# env=((f259505 . 0))
# var=f259505
    movl 0(%esp), %eax  # stack load f259505
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1576438
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1576438:
    movl %eax, -16(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1576439"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1576439:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1576441
    cmp  $0,%eax
    jge _L_1576440
_L_1576441:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1576440:
    movl -16(%esp), %esi
    movl -1(%eax,%esi), %eax
    movl %eax, 4(%ebp)
    movl -12(%esp), %eax
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    or   $1, %al
    add  $8, %ebp
# cons end
    movl -4(%esp), %ebx
    movl -8(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "symbol?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "string-set!") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "string-ref") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "string-length") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "string?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "make-string") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "vector-ref") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "vector-set!") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "vector-length") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "make-vector") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "vector?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "set-cdr!") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "set-car!") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "cdr") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "car") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "cons") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "pair?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fxremainder") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fxquotient") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fx*") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fx-") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fx+") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fx>=") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fx>") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fx<=") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fx<") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fx=") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f259505 0))) (closure () (f259505) (let () (vector-ref f259505 0))))
# emit-begin
#   expr=(begin (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "symbol?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "string-set!") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "string-ref") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "string-length") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "string?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "make-string") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "vector-ref") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "vector-set!") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "vector-length") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "make-vector") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "vector?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "set-cdr!") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "set-car!") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "cdr") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "car") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "cons") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "pair?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fxremainder") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fxquotient") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fx*") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fx-") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fx+") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fx>=") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fx>") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fx<=") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fx<") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fx=") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f259505 0))) (closure () (f259505) (let () (vector-ref f259505 0))))
#   env=((f259505 . 0))
# emit-expr (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "symbol?") (vector-ref f259505 0)))
# emit-expr f259505
# emit-variable-ref
# env=((f259505 . 0))
# var=f259505
    movl 0(%esp), %eax  # stack load f259505
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1576442
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1576442:
    movl %eax, -4(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1576443"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1576443:
# check bounds on vector index
    movl -4(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1576445
    cmp  $0,%eax
    jge _L_1576444
_L_1576445:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1576444:
    movl %eax, -8(%esp)
# emit-expr (cons ((primitive-ref string->symbol) "symbol?") (vector-ref f259505 0))
# cons arg1=((primitive-ref string->symbol) "symbol?") arg2=(vector-ref f259505 0)
# emit-expr ((primitive-ref string->symbol) "symbol?")
# funcall
#    si   =-12
#    env  = ((f259505 . 0))
#    expr = (funcall (primitive-ref string->symbol) "symbol?")
# emit-expr (primitive-ref string->symbol)
    .extern mrc_string$m$gsymbol
    movl mrc_string$m$gsymbol,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1576446"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1576446":
   movl %eax,  -20(%esp)  # stash funcall-oper in closure slot
# emit-expr "symbol?"
# string literal
    jmp _L_1576448
    .align 8,0x90
_L_1576447 :
    .int 28
    .ascii "symbol?"
_L_1576448:
    movl $_L_1576447, %eax
    orl $6, %eax
    mov %eax, -24(%esp)  # arg symbol?
    movl -20(%esp), %edi   # load new closure to %edi
    add $-12, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $12, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    movl %eax, -12(%esp)
# emit-expr (vector-ref f259505 0)
# emit-expr f259505
# emit-variable-ref
# env=((f259505 . 0))
# var=f259505
    movl 0(%esp), %eax  # stack load f259505
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1576449
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1576449:
    movl %eax, -16(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1576450"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1576450:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1576452
    cmp  $0,%eax
    jge _L_1576451
_L_1576452:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1576451:
    movl -16(%esp), %esi
    movl -1(%eax,%esi), %eax
    movl %eax, 4(%ebp)
    movl -12(%esp), %eax
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    or   $1, %al
    add  $8, %ebp
# cons end
    movl -4(%esp), %ebx
    movl -8(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "string-set!") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "string-ref") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "string-length") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "string?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "make-string") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "vector-ref") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "vector-set!") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "vector-length") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "make-vector") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "vector?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "set-cdr!") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "set-car!") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "cdr") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "car") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "cons") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "pair?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fxremainder") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fxquotient") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fx*") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fx-") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fx+") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fx>=") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fx>") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fx<=") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fx<") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fx=") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f259505 0))) (closure () (f259505) (let () (vector-ref f259505 0))))
# emit-begin
#   expr=(begin (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "string-set!") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "string-ref") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "string-length") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "string?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "make-string") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "vector-ref") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "vector-set!") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "vector-length") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "make-vector") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "vector?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "set-cdr!") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "set-car!") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "cdr") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "car") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "cons") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "pair?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fxremainder") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fxquotient") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fx*") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fx-") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fx+") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fx>=") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fx>") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fx<=") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fx<") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fx=") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f259505 0))) (closure () (f259505) (let () (vector-ref f259505 0))))
#   env=((f259505 . 0))
# emit-expr (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "string-set!") (vector-ref f259505 0)))
# emit-expr f259505
# emit-variable-ref
# env=((f259505 . 0))
# var=f259505
    movl 0(%esp), %eax  # stack load f259505
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1576453
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1576453:
    movl %eax, -4(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1576454"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1576454:
# check bounds on vector index
    movl -4(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1576456
    cmp  $0,%eax
    jge _L_1576455
_L_1576456:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1576455:
    movl %eax, -8(%esp)
# emit-expr (cons ((primitive-ref string->symbol) "string-set!") (vector-ref f259505 0))
# cons arg1=((primitive-ref string->symbol) "string-set!") arg2=(vector-ref f259505 0)
# emit-expr ((primitive-ref string->symbol) "string-set!")
# funcall
#    si   =-12
#    env  = ((f259505 . 0))
#    expr = (funcall (primitive-ref string->symbol) "string-set!")
# emit-expr (primitive-ref string->symbol)
    .extern mrc_string$m$gsymbol
    movl mrc_string$m$gsymbol,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1576457"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1576457":
   movl %eax,  -20(%esp)  # stash funcall-oper in closure slot
# emit-expr "string-set!"
# string literal
    jmp _L_1576459
    .align 8,0x90
_L_1576458 :
    .int 44
    .ascii "string-set!"
_L_1576459:
    movl $_L_1576458, %eax
    orl $6, %eax
    mov %eax, -24(%esp)  # arg string-set!
    movl -20(%esp), %edi   # load new closure to %edi
    add $-12, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $12, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    movl %eax, -12(%esp)
# emit-expr (vector-ref f259505 0)
# emit-expr f259505
# emit-variable-ref
# env=((f259505 . 0))
# var=f259505
    movl 0(%esp), %eax  # stack load f259505
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1576460
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1576460:
    movl %eax, -16(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1576461"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1576461:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1576463
    cmp  $0,%eax
    jge _L_1576462
_L_1576463:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1576462:
    movl -16(%esp), %esi
    movl -1(%eax,%esi), %eax
    movl %eax, 4(%ebp)
    movl -12(%esp), %eax
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    or   $1, %al
    add  $8, %ebp
# cons end
    movl -4(%esp), %ebx
    movl -8(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "string-ref") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "string-length") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "string?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "make-string") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "vector-ref") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "vector-set!") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "vector-length") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "make-vector") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "vector?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "set-cdr!") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "set-car!") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "cdr") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "car") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "cons") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "pair?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fxremainder") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fxquotient") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fx*") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fx-") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fx+") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fx>=") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fx>") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fx<=") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fx<") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fx=") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f259505 0))) (closure () (f259505) (let () (vector-ref f259505 0))))
# emit-begin
#   expr=(begin (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "string-ref") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "string-length") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "string?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "make-string") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "vector-ref") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "vector-set!") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "vector-length") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "make-vector") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "vector?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "set-cdr!") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "set-car!") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "cdr") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "car") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "cons") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "pair?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fxremainder") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fxquotient") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fx*") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fx-") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fx+") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fx>=") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fx>") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fx<=") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fx<") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fx=") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f259505 0))) (closure () (f259505) (let () (vector-ref f259505 0))))
#   env=((f259505 . 0))
# emit-expr (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "string-ref") (vector-ref f259505 0)))
# emit-expr f259505
# emit-variable-ref
# env=((f259505 . 0))
# var=f259505
    movl 0(%esp), %eax  # stack load f259505
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1576464
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1576464:
    movl %eax, -4(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1576465"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1576465:
# check bounds on vector index
    movl -4(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1576467
    cmp  $0,%eax
    jge _L_1576466
_L_1576467:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1576466:
    movl %eax, -8(%esp)
# emit-expr (cons ((primitive-ref string->symbol) "string-ref") (vector-ref f259505 0))
# cons arg1=((primitive-ref string->symbol) "string-ref") arg2=(vector-ref f259505 0)
# emit-expr ((primitive-ref string->symbol) "string-ref")
# funcall
#    si   =-12
#    env  = ((f259505 . 0))
#    expr = (funcall (primitive-ref string->symbol) "string-ref")
# emit-expr (primitive-ref string->symbol)
    .extern mrc_string$m$gsymbol
    movl mrc_string$m$gsymbol,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1576468"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1576468":
   movl %eax,  -20(%esp)  # stash funcall-oper in closure slot
# emit-expr "string-ref"
# string literal
    jmp _L_1576470
    .align 8,0x90
_L_1576469 :
    .int 40
    .ascii "string-ref"
_L_1576470:
    movl $_L_1576469, %eax
    orl $6, %eax
    mov %eax, -24(%esp)  # arg string-ref
    movl -20(%esp), %edi   # load new closure to %edi
    add $-12, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $12, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    movl %eax, -12(%esp)
# emit-expr (vector-ref f259505 0)
# emit-expr f259505
# emit-variable-ref
# env=((f259505 . 0))
# var=f259505
    movl 0(%esp), %eax  # stack load f259505
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1576471
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1576471:
    movl %eax, -16(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1576472"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1576472:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1576474
    cmp  $0,%eax
    jge _L_1576473
_L_1576474:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1576473:
    movl -16(%esp), %esi
    movl -1(%eax,%esi), %eax
    movl %eax, 4(%ebp)
    movl -12(%esp), %eax
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    or   $1, %al
    add  $8, %ebp
# cons end
    movl -4(%esp), %ebx
    movl -8(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "string-length") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "string?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "make-string") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "vector-ref") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "vector-set!") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "vector-length") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "make-vector") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "vector?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "set-cdr!") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "set-car!") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "cdr") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "car") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "cons") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "pair?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fxremainder") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fxquotient") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fx*") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fx-") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fx+") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fx>=") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fx>") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fx<=") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fx<") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fx=") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f259505 0))) (closure () (f259505) (let () (vector-ref f259505 0))))
# emit-begin
#   expr=(begin (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "string-length") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "string?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "make-string") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "vector-ref") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "vector-set!") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "vector-length") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "make-vector") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "vector?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "set-cdr!") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "set-car!") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "cdr") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "car") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "cons") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "pair?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fxremainder") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fxquotient") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fx*") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fx-") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fx+") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fx>=") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fx>") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fx<=") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fx<") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fx=") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f259505 0))) (closure () (f259505) (let () (vector-ref f259505 0))))
#   env=((f259505 . 0))
# emit-expr (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "string-length") (vector-ref f259505 0)))
# emit-expr f259505
# emit-variable-ref
# env=((f259505 . 0))
# var=f259505
    movl 0(%esp), %eax  # stack load f259505
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1576475
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1576475:
    movl %eax, -4(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1576476"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1576476:
# check bounds on vector index
    movl -4(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1576478
    cmp  $0,%eax
    jge _L_1576477
_L_1576478:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1576477:
    movl %eax, -8(%esp)
# emit-expr (cons ((primitive-ref string->symbol) "string-length") (vector-ref f259505 0))
# cons arg1=((primitive-ref string->symbol) "string-length") arg2=(vector-ref f259505 0)
# emit-expr ((primitive-ref string->symbol) "string-length")
# funcall
#    si   =-12
#    env  = ((f259505 . 0))
#    expr = (funcall (primitive-ref string->symbol) "string-length")
# emit-expr (primitive-ref string->symbol)
    .extern mrc_string$m$gsymbol
    movl mrc_string$m$gsymbol,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1576479"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1576479":
   movl %eax,  -20(%esp)  # stash funcall-oper in closure slot
# emit-expr "string-length"
# string literal
    jmp _L_1576481
    .align 8,0x90
_L_1576480 :
    .int 52
    .ascii "string-length"
_L_1576481:
    movl $_L_1576480, %eax
    orl $6, %eax
    mov %eax, -24(%esp)  # arg string-length
    movl -20(%esp), %edi   # load new closure to %edi
    add $-12, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $12, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    movl %eax, -12(%esp)
# emit-expr (vector-ref f259505 0)
# emit-expr f259505
# emit-variable-ref
# env=((f259505 . 0))
# var=f259505
    movl 0(%esp), %eax  # stack load f259505
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1576482
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1576482:
    movl %eax, -16(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1576483"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1576483:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1576485
    cmp  $0,%eax
    jge _L_1576484
_L_1576485:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1576484:
    movl -16(%esp), %esi
    movl -1(%eax,%esi), %eax
    movl %eax, 4(%ebp)
    movl -12(%esp), %eax
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    or   $1, %al
    add  $8, %ebp
# cons end
    movl -4(%esp), %ebx
    movl -8(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "string?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "make-string") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "vector-ref") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "vector-set!") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "vector-length") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "make-vector") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "vector?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "set-cdr!") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "set-car!") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "cdr") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "car") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "cons") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "pair?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fxremainder") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fxquotient") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fx*") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fx-") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fx+") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fx>=") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fx>") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fx<=") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fx<") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fx=") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f259505 0))) (closure () (f259505) (let () (vector-ref f259505 0))))
# emit-begin
#   expr=(begin (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "string?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "make-string") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "vector-ref") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "vector-set!") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "vector-length") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "make-vector") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "vector?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "set-cdr!") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "set-car!") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "cdr") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "car") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "cons") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "pair?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fxremainder") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fxquotient") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fx*") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fx-") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fx+") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fx>=") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fx>") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fx<=") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fx<") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fx=") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f259505 0))) (closure () (f259505) (let () (vector-ref f259505 0))))
#   env=((f259505 . 0))
# emit-expr (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "string?") (vector-ref f259505 0)))
# emit-expr f259505
# emit-variable-ref
# env=((f259505 . 0))
# var=f259505
    movl 0(%esp), %eax  # stack load f259505
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1576486
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1576486:
    movl %eax, -4(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1576487"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1576487:
# check bounds on vector index
    movl -4(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1576489
    cmp  $0,%eax
    jge _L_1576488
_L_1576489:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1576488:
    movl %eax, -8(%esp)
# emit-expr (cons ((primitive-ref string->symbol) "string?") (vector-ref f259505 0))
# cons arg1=((primitive-ref string->symbol) "string?") arg2=(vector-ref f259505 0)
# emit-expr ((primitive-ref string->symbol) "string?")
# funcall
#    si   =-12
#    env  = ((f259505 . 0))
#    expr = (funcall (primitive-ref string->symbol) "string?")
# emit-expr (primitive-ref string->symbol)
    .extern mrc_string$m$gsymbol
    movl mrc_string$m$gsymbol,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1576490"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1576490":
   movl %eax,  -20(%esp)  # stash funcall-oper in closure slot
# emit-expr "string?"
# string literal
    jmp _L_1576492
    .align 8,0x90
_L_1576491 :
    .int 28
    .ascii "string?"
_L_1576492:
    movl $_L_1576491, %eax
    orl $6, %eax
    mov %eax, -24(%esp)  # arg string?
    movl -20(%esp), %edi   # load new closure to %edi
    add $-12, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $12, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    movl %eax, -12(%esp)
# emit-expr (vector-ref f259505 0)
# emit-expr f259505
# emit-variable-ref
# env=((f259505 . 0))
# var=f259505
    movl 0(%esp), %eax  # stack load f259505
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1576493
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1576493:
    movl %eax, -16(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1576494"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1576494:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1576496
    cmp  $0,%eax
    jge _L_1576495
_L_1576496:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1576495:
    movl -16(%esp), %esi
    movl -1(%eax,%esi), %eax
    movl %eax, 4(%ebp)
    movl -12(%esp), %eax
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    or   $1, %al
    add  $8, %ebp
# cons end
    movl -4(%esp), %ebx
    movl -8(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "make-string") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "vector-ref") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "vector-set!") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "vector-length") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "make-vector") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "vector?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "set-cdr!") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "set-car!") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "cdr") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "car") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "cons") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "pair?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fxremainder") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fxquotient") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fx*") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fx-") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fx+") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fx>=") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fx>") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fx<=") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fx<") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fx=") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f259505 0))) (closure () (f259505) (let () (vector-ref f259505 0))))
# emit-begin
#   expr=(begin (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "make-string") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "vector-ref") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "vector-set!") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "vector-length") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "make-vector") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "vector?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "set-cdr!") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "set-car!") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "cdr") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "car") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "cons") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "pair?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fxremainder") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fxquotient") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fx*") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fx-") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fx+") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fx>=") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fx>") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fx<=") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fx<") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fx=") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f259505 0))) (closure () (f259505) (let () (vector-ref f259505 0))))
#   env=((f259505 . 0))
# emit-expr (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "make-string") (vector-ref f259505 0)))
# emit-expr f259505
# emit-variable-ref
# env=((f259505 . 0))
# var=f259505
    movl 0(%esp), %eax  # stack load f259505
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1576497
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1576497:
    movl %eax, -4(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1576498"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1576498:
# check bounds on vector index
    movl -4(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1576500
    cmp  $0,%eax
    jge _L_1576499
_L_1576500:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1576499:
    movl %eax, -8(%esp)
# emit-expr (cons ((primitive-ref string->symbol) "make-string") (vector-ref f259505 0))
# cons arg1=((primitive-ref string->symbol) "make-string") arg2=(vector-ref f259505 0)
# emit-expr ((primitive-ref string->symbol) "make-string")
# funcall
#    si   =-12
#    env  = ((f259505 . 0))
#    expr = (funcall (primitive-ref string->symbol) "make-string")
# emit-expr (primitive-ref string->symbol)
    .extern mrc_string$m$gsymbol
    movl mrc_string$m$gsymbol,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1576501"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1576501":
   movl %eax,  -20(%esp)  # stash funcall-oper in closure slot
# emit-expr "make-string"
# string literal
    jmp _L_1576503
    .align 8,0x90
_L_1576502 :
    .int 44
    .ascii "make-string"
_L_1576503:
    movl $_L_1576502, %eax
    orl $6, %eax
    mov %eax, -24(%esp)  # arg make-string
    movl -20(%esp), %edi   # load new closure to %edi
    add $-12, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $12, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    movl %eax, -12(%esp)
# emit-expr (vector-ref f259505 0)
# emit-expr f259505
# emit-variable-ref
# env=((f259505 . 0))
# var=f259505
    movl 0(%esp), %eax  # stack load f259505
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1576504
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1576504:
    movl %eax, -16(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1576505"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1576505:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1576507
    cmp  $0,%eax
    jge _L_1576506
_L_1576507:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1576506:
    movl -16(%esp), %esi
    movl -1(%eax,%esi), %eax
    movl %eax, 4(%ebp)
    movl -12(%esp), %eax
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    or   $1, %al
    add  $8, %ebp
# cons end
    movl -4(%esp), %ebx
    movl -8(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "vector-ref") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "vector-set!") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "vector-length") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "make-vector") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "vector?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "set-cdr!") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "set-car!") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "cdr") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "car") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "cons") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "pair?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fxremainder") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fxquotient") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fx*") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fx-") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fx+") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fx>=") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fx>") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fx<=") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fx<") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fx=") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f259505 0))) (closure () (f259505) (let () (vector-ref f259505 0))))
# emit-begin
#   expr=(begin (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "vector-ref") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "vector-set!") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "vector-length") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "make-vector") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "vector?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "set-cdr!") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "set-car!") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "cdr") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "car") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "cons") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "pair?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fxremainder") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fxquotient") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fx*") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fx-") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fx+") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fx>=") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fx>") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fx<=") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fx<") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fx=") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f259505 0))) (closure () (f259505) (let () (vector-ref f259505 0))))
#   env=((f259505 . 0))
# emit-expr (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "vector-ref") (vector-ref f259505 0)))
# emit-expr f259505
# emit-variable-ref
# env=((f259505 . 0))
# var=f259505
    movl 0(%esp), %eax  # stack load f259505
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1576508
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1576508:
    movl %eax, -4(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1576509"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1576509:
# check bounds on vector index
    movl -4(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1576511
    cmp  $0,%eax
    jge _L_1576510
_L_1576511:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1576510:
    movl %eax, -8(%esp)
# emit-expr (cons ((primitive-ref string->symbol) "vector-ref") (vector-ref f259505 0))
# cons arg1=((primitive-ref string->symbol) "vector-ref") arg2=(vector-ref f259505 0)
# emit-expr ((primitive-ref string->symbol) "vector-ref")
# funcall
#    si   =-12
#    env  = ((f259505 . 0))
#    expr = (funcall (primitive-ref string->symbol) "vector-ref")
# emit-expr (primitive-ref string->symbol)
    .extern mrc_string$m$gsymbol
    movl mrc_string$m$gsymbol,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1576512"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1576512":
   movl %eax,  -20(%esp)  # stash funcall-oper in closure slot
# emit-expr "vector-ref"
# string literal
    jmp _L_1576514
    .align 8,0x90
_L_1576513 :
    .int 40
    .ascii "vector-ref"
_L_1576514:
    movl $_L_1576513, %eax
    orl $6, %eax
    mov %eax, -24(%esp)  # arg vector-ref
    movl -20(%esp), %edi   # load new closure to %edi
    add $-12, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $12, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    movl %eax, -12(%esp)
# emit-expr (vector-ref f259505 0)
# emit-expr f259505
# emit-variable-ref
# env=((f259505 . 0))
# var=f259505
    movl 0(%esp), %eax  # stack load f259505
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1576515
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1576515:
    movl %eax, -16(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1576516"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1576516:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1576518
    cmp  $0,%eax
    jge _L_1576517
_L_1576518:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1576517:
    movl -16(%esp), %esi
    movl -1(%eax,%esi), %eax
    movl %eax, 4(%ebp)
    movl -12(%esp), %eax
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    or   $1, %al
    add  $8, %ebp
# cons end
    movl -4(%esp), %ebx
    movl -8(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "vector-set!") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "vector-length") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "make-vector") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "vector?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "set-cdr!") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "set-car!") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "cdr") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "car") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "cons") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "pair?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fxremainder") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fxquotient") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fx*") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fx-") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fx+") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fx>=") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fx>") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fx<=") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fx<") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fx=") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f259505 0))) (closure () (f259505) (let () (vector-ref f259505 0))))
# emit-begin
#   expr=(begin (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "vector-set!") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "vector-length") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "make-vector") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "vector?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "set-cdr!") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "set-car!") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "cdr") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "car") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "cons") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "pair?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fxremainder") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fxquotient") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fx*") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fx-") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fx+") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fx>=") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fx>") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fx<=") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fx<") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fx=") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f259505 0))) (closure () (f259505) (let () (vector-ref f259505 0))))
#   env=((f259505 . 0))
# emit-expr (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "vector-set!") (vector-ref f259505 0)))
# emit-expr f259505
# emit-variable-ref
# env=((f259505 . 0))
# var=f259505
    movl 0(%esp), %eax  # stack load f259505
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1576519
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1576519:
    movl %eax, -4(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1576520"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1576520:
# check bounds on vector index
    movl -4(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1576522
    cmp  $0,%eax
    jge _L_1576521
_L_1576522:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1576521:
    movl %eax, -8(%esp)
# emit-expr (cons ((primitive-ref string->symbol) "vector-set!") (vector-ref f259505 0))
# cons arg1=((primitive-ref string->symbol) "vector-set!") arg2=(vector-ref f259505 0)
# emit-expr ((primitive-ref string->symbol) "vector-set!")
# funcall
#    si   =-12
#    env  = ((f259505 . 0))
#    expr = (funcall (primitive-ref string->symbol) "vector-set!")
# emit-expr (primitive-ref string->symbol)
    .extern mrc_string$m$gsymbol
    movl mrc_string$m$gsymbol,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1576523"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1576523":
   movl %eax,  -20(%esp)  # stash funcall-oper in closure slot
# emit-expr "vector-set!"
# string literal
    jmp _L_1576525
    .align 8,0x90
_L_1576524 :
    .int 44
    .ascii "vector-set!"
_L_1576525:
    movl $_L_1576524, %eax
    orl $6, %eax
    mov %eax, -24(%esp)  # arg vector-set!
    movl -20(%esp), %edi   # load new closure to %edi
    add $-12, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $12, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    movl %eax, -12(%esp)
# emit-expr (vector-ref f259505 0)
# emit-expr f259505
# emit-variable-ref
# env=((f259505 . 0))
# var=f259505
    movl 0(%esp), %eax  # stack load f259505
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1576526
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1576526:
    movl %eax, -16(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1576527"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1576527:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1576529
    cmp  $0,%eax
    jge _L_1576528
_L_1576529:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1576528:
    movl -16(%esp), %esi
    movl -1(%eax,%esi), %eax
    movl %eax, 4(%ebp)
    movl -12(%esp), %eax
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    or   $1, %al
    add  $8, %ebp
# cons end
    movl -4(%esp), %ebx
    movl -8(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "vector-length") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "make-vector") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "vector?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "set-cdr!") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "set-car!") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "cdr") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "car") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "cons") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "pair?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fxremainder") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fxquotient") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fx*") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fx-") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fx+") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fx>=") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fx>") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fx<=") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fx<") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fx=") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f259505 0))) (closure () (f259505) (let () (vector-ref f259505 0))))
# emit-begin
#   expr=(begin (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "vector-length") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "make-vector") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "vector?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "set-cdr!") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "set-car!") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "cdr") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "car") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "cons") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "pair?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fxremainder") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fxquotient") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fx*") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fx-") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fx+") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fx>=") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fx>") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fx<=") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fx<") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fx=") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f259505 0))) (closure () (f259505) (let () (vector-ref f259505 0))))
#   env=((f259505 . 0))
# emit-expr (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "vector-length") (vector-ref f259505 0)))
# emit-expr f259505
# emit-variable-ref
# env=((f259505 . 0))
# var=f259505
    movl 0(%esp), %eax  # stack load f259505
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1576530
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1576530:
    movl %eax, -4(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1576531"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1576531:
# check bounds on vector index
    movl -4(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1576533
    cmp  $0,%eax
    jge _L_1576532
_L_1576533:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1576532:
    movl %eax, -8(%esp)
# emit-expr (cons ((primitive-ref string->symbol) "vector-length") (vector-ref f259505 0))
# cons arg1=((primitive-ref string->symbol) "vector-length") arg2=(vector-ref f259505 0)
# emit-expr ((primitive-ref string->symbol) "vector-length")
# funcall
#    si   =-12
#    env  = ((f259505 . 0))
#    expr = (funcall (primitive-ref string->symbol) "vector-length")
# emit-expr (primitive-ref string->symbol)
    .extern mrc_string$m$gsymbol
    movl mrc_string$m$gsymbol,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1576534"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1576534":
   movl %eax,  -20(%esp)  # stash funcall-oper in closure slot
# emit-expr "vector-length"
# string literal
    jmp _L_1576536
    .align 8,0x90
_L_1576535 :
    .int 52
    .ascii "vector-length"
_L_1576536:
    movl $_L_1576535, %eax
    orl $6, %eax
    mov %eax, -24(%esp)  # arg vector-length
    movl -20(%esp), %edi   # load new closure to %edi
    add $-12, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $12, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    movl %eax, -12(%esp)
# emit-expr (vector-ref f259505 0)
# emit-expr f259505
# emit-variable-ref
# env=((f259505 . 0))
# var=f259505
    movl 0(%esp), %eax  # stack load f259505
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1576537
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1576537:
    movl %eax, -16(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1576538"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1576538:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1576540
    cmp  $0,%eax
    jge _L_1576539
_L_1576540:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1576539:
    movl -16(%esp), %esi
    movl -1(%eax,%esi), %eax
    movl %eax, 4(%ebp)
    movl -12(%esp), %eax
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    or   $1, %al
    add  $8, %ebp
# cons end
    movl -4(%esp), %ebx
    movl -8(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "make-vector") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "vector?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "set-cdr!") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "set-car!") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "cdr") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "car") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "cons") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "pair?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fxremainder") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fxquotient") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fx*") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fx-") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fx+") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fx>=") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fx>") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fx<=") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fx<") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fx=") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f259505 0))) (closure () (f259505) (let () (vector-ref f259505 0))))
# emit-begin
#   expr=(begin (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "make-vector") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "vector?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "set-cdr!") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "set-car!") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "cdr") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "car") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "cons") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "pair?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fxremainder") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fxquotient") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fx*") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fx-") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fx+") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fx>=") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fx>") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fx<=") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fx<") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fx=") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f259505 0))) (closure () (f259505) (let () (vector-ref f259505 0))))
#   env=((f259505 . 0))
# emit-expr (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "make-vector") (vector-ref f259505 0)))
# emit-expr f259505
# emit-variable-ref
# env=((f259505 . 0))
# var=f259505
    movl 0(%esp), %eax  # stack load f259505
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1576541
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1576541:
    movl %eax, -4(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1576542"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1576542:
# check bounds on vector index
    movl -4(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1576544
    cmp  $0,%eax
    jge _L_1576543
_L_1576544:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1576543:
    movl %eax, -8(%esp)
# emit-expr (cons ((primitive-ref string->symbol) "make-vector") (vector-ref f259505 0))
# cons arg1=((primitive-ref string->symbol) "make-vector") arg2=(vector-ref f259505 0)
# emit-expr ((primitive-ref string->symbol) "make-vector")
# funcall
#    si   =-12
#    env  = ((f259505 . 0))
#    expr = (funcall (primitive-ref string->symbol) "make-vector")
# emit-expr (primitive-ref string->symbol)
    .extern mrc_string$m$gsymbol
    movl mrc_string$m$gsymbol,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1576545"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1576545":
   movl %eax,  -20(%esp)  # stash funcall-oper in closure slot
# emit-expr "make-vector"
# string literal
    jmp _L_1576547
    .align 8,0x90
_L_1576546 :
    .int 44
    .ascii "make-vector"
_L_1576547:
    movl $_L_1576546, %eax
    orl $6, %eax
    mov %eax, -24(%esp)  # arg make-vector
    movl -20(%esp), %edi   # load new closure to %edi
    add $-12, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $12, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    movl %eax, -12(%esp)
# emit-expr (vector-ref f259505 0)
# emit-expr f259505
# emit-variable-ref
# env=((f259505 . 0))
# var=f259505
    movl 0(%esp), %eax  # stack load f259505
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1576548
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1576548:
    movl %eax, -16(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1576549"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1576549:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1576551
    cmp  $0,%eax
    jge _L_1576550
_L_1576551:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1576550:
    movl -16(%esp), %esi
    movl -1(%eax,%esi), %eax
    movl %eax, 4(%ebp)
    movl -12(%esp), %eax
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    or   $1, %al
    add  $8, %ebp
# cons end
    movl -4(%esp), %ebx
    movl -8(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "vector?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "set-cdr!") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "set-car!") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "cdr") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "car") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "cons") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "pair?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fxremainder") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fxquotient") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fx*") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fx-") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fx+") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fx>=") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fx>") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fx<=") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fx<") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fx=") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f259505 0))) (closure () (f259505) (let () (vector-ref f259505 0))))
# emit-begin
#   expr=(begin (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "vector?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "set-cdr!") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "set-car!") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "cdr") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "car") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "cons") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "pair?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fxremainder") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fxquotient") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fx*") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fx-") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fx+") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fx>=") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fx>") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fx<=") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fx<") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fx=") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f259505 0))) (closure () (f259505) (let () (vector-ref f259505 0))))
#   env=((f259505 . 0))
# emit-expr (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "vector?") (vector-ref f259505 0)))
# emit-expr f259505
# emit-variable-ref
# env=((f259505 . 0))
# var=f259505
    movl 0(%esp), %eax  # stack load f259505
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1576552
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1576552:
    movl %eax, -4(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1576553"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1576553:
# check bounds on vector index
    movl -4(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1576555
    cmp  $0,%eax
    jge _L_1576554
_L_1576555:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1576554:
    movl %eax, -8(%esp)
# emit-expr (cons ((primitive-ref string->symbol) "vector?") (vector-ref f259505 0))
# cons arg1=((primitive-ref string->symbol) "vector?") arg2=(vector-ref f259505 0)
# emit-expr ((primitive-ref string->symbol) "vector?")
# funcall
#    si   =-12
#    env  = ((f259505 . 0))
#    expr = (funcall (primitive-ref string->symbol) "vector?")
# emit-expr (primitive-ref string->symbol)
    .extern mrc_string$m$gsymbol
    movl mrc_string$m$gsymbol,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1576556"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1576556":
   movl %eax,  -20(%esp)  # stash funcall-oper in closure slot
# emit-expr "vector?"
# string literal
    jmp _L_1576558
    .align 8,0x90
_L_1576557 :
    .int 28
    .ascii "vector?"
_L_1576558:
    movl $_L_1576557, %eax
    orl $6, %eax
    mov %eax, -24(%esp)  # arg vector?
    movl -20(%esp), %edi   # load new closure to %edi
    add $-12, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $12, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    movl %eax, -12(%esp)
# emit-expr (vector-ref f259505 0)
# emit-expr f259505
# emit-variable-ref
# env=((f259505 . 0))
# var=f259505
    movl 0(%esp), %eax  # stack load f259505
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1576559
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1576559:
    movl %eax, -16(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1576560"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1576560:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1576562
    cmp  $0,%eax
    jge _L_1576561
_L_1576562:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1576561:
    movl -16(%esp), %esi
    movl -1(%eax,%esi), %eax
    movl %eax, 4(%ebp)
    movl -12(%esp), %eax
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    or   $1, %al
    add  $8, %ebp
# cons end
    movl -4(%esp), %ebx
    movl -8(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "set-cdr!") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "set-car!") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "cdr") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "car") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "cons") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "pair?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fxremainder") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fxquotient") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fx*") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fx-") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fx+") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fx>=") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fx>") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fx<=") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fx<") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fx=") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f259505 0))) (closure () (f259505) (let () (vector-ref f259505 0))))
# emit-begin
#   expr=(begin (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "set-cdr!") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "set-car!") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "cdr") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "car") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "cons") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "pair?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fxremainder") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fxquotient") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fx*") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fx-") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fx+") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fx>=") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fx>") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fx<=") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fx<") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fx=") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f259505 0))) (closure () (f259505) (let () (vector-ref f259505 0))))
#   env=((f259505 . 0))
# emit-expr (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "set-cdr!") (vector-ref f259505 0)))
# emit-expr f259505
# emit-variable-ref
# env=((f259505 . 0))
# var=f259505
    movl 0(%esp), %eax  # stack load f259505
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1576563
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1576563:
    movl %eax, -4(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1576564"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1576564:
# check bounds on vector index
    movl -4(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1576566
    cmp  $0,%eax
    jge _L_1576565
_L_1576566:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1576565:
    movl %eax, -8(%esp)
# emit-expr (cons ((primitive-ref string->symbol) "set-cdr!") (vector-ref f259505 0))
# cons arg1=((primitive-ref string->symbol) "set-cdr!") arg2=(vector-ref f259505 0)
# emit-expr ((primitive-ref string->symbol) "set-cdr!")
# funcall
#    si   =-12
#    env  = ((f259505 . 0))
#    expr = (funcall (primitive-ref string->symbol) "set-cdr!")
# emit-expr (primitive-ref string->symbol)
    .extern mrc_string$m$gsymbol
    movl mrc_string$m$gsymbol,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1576567"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1576567":
   movl %eax,  -20(%esp)  # stash funcall-oper in closure slot
# emit-expr "set-cdr!"
# string literal
    jmp _L_1576569
    .align 8,0x90
_L_1576568 :
    .int 32
    .ascii "set-cdr!"
_L_1576569:
    movl $_L_1576568, %eax
    orl $6, %eax
    mov %eax, -24(%esp)  # arg set-cdr!
    movl -20(%esp), %edi   # load new closure to %edi
    add $-12, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $12, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    movl %eax, -12(%esp)
# emit-expr (vector-ref f259505 0)
# emit-expr f259505
# emit-variable-ref
# env=((f259505 . 0))
# var=f259505
    movl 0(%esp), %eax  # stack load f259505
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1576570
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1576570:
    movl %eax, -16(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1576571"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1576571:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1576573
    cmp  $0,%eax
    jge _L_1576572
_L_1576573:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1576572:
    movl -16(%esp), %esi
    movl -1(%eax,%esi), %eax
    movl %eax, 4(%ebp)
    movl -12(%esp), %eax
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    or   $1, %al
    add  $8, %ebp
# cons end
    movl -4(%esp), %ebx
    movl -8(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "set-car!") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "cdr") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "car") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "cons") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "pair?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fxremainder") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fxquotient") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fx*") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fx-") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fx+") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fx>=") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fx>") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fx<=") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fx<") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fx=") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f259505 0))) (closure () (f259505) (let () (vector-ref f259505 0))))
# emit-begin
#   expr=(begin (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "set-car!") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "cdr") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "car") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "cons") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "pair?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fxremainder") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fxquotient") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fx*") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fx-") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fx+") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fx>=") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fx>") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fx<=") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fx<") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fx=") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f259505 0))) (closure () (f259505) (let () (vector-ref f259505 0))))
#   env=((f259505 . 0))
# emit-expr (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "set-car!") (vector-ref f259505 0)))
# emit-expr f259505
# emit-variable-ref
# env=((f259505 . 0))
# var=f259505
    movl 0(%esp), %eax  # stack load f259505
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1576574
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1576574:
    movl %eax, -4(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1576575"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1576575:
# check bounds on vector index
    movl -4(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1576577
    cmp  $0,%eax
    jge _L_1576576
_L_1576577:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1576576:
    movl %eax, -8(%esp)
# emit-expr (cons ((primitive-ref string->symbol) "set-car!") (vector-ref f259505 0))
# cons arg1=((primitive-ref string->symbol) "set-car!") arg2=(vector-ref f259505 0)
# emit-expr ((primitive-ref string->symbol) "set-car!")
# funcall
#    si   =-12
#    env  = ((f259505 . 0))
#    expr = (funcall (primitive-ref string->symbol) "set-car!")
# emit-expr (primitive-ref string->symbol)
    .extern mrc_string$m$gsymbol
    movl mrc_string$m$gsymbol,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1576578"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1576578":
   movl %eax,  -20(%esp)  # stash funcall-oper in closure slot
# emit-expr "set-car!"
# string literal
    jmp _L_1576580
    .align 8,0x90
_L_1576579 :
    .int 32
    .ascii "set-car!"
_L_1576580:
    movl $_L_1576579, %eax
    orl $6, %eax
    mov %eax, -24(%esp)  # arg set-car!
    movl -20(%esp), %edi   # load new closure to %edi
    add $-12, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $12, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    movl %eax, -12(%esp)
# emit-expr (vector-ref f259505 0)
# emit-expr f259505
# emit-variable-ref
# env=((f259505 . 0))
# var=f259505
    movl 0(%esp), %eax  # stack load f259505
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1576581
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1576581:
    movl %eax, -16(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1576582"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1576582:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1576584
    cmp  $0,%eax
    jge _L_1576583
_L_1576584:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1576583:
    movl -16(%esp), %esi
    movl -1(%eax,%esi), %eax
    movl %eax, 4(%ebp)
    movl -12(%esp), %eax
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    or   $1, %al
    add  $8, %ebp
# cons end
    movl -4(%esp), %ebx
    movl -8(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "cdr") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "car") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "cons") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "pair?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fxremainder") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fxquotient") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fx*") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fx-") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fx+") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fx>=") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fx>") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fx<=") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fx<") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fx=") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f259505 0))) (closure () (f259505) (let () (vector-ref f259505 0))))
# emit-begin
#   expr=(begin (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "cdr") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "car") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "cons") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "pair?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fxremainder") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fxquotient") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fx*") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fx-") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fx+") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fx>=") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fx>") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fx<=") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fx<") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fx=") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f259505 0))) (closure () (f259505) (let () (vector-ref f259505 0))))
#   env=((f259505 . 0))
# emit-expr (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "cdr") (vector-ref f259505 0)))
# emit-expr f259505
# emit-variable-ref
# env=((f259505 . 0))
# var=f259505
    movl 0(%esp), %eax  # stack load f259505
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1576585
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1576585:
    movl %eax, -4(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1576586"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1576586:
# check bounds on vector index
    movl -4(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1576588
    cmp  $0,%eax
    jge _L_1576587
_L_1576588:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1576587:
    movl %eax, -8(%esp)
# emit-expr (cons ((primitive-ref string->symbol) "cdr") (vector-ref f259505 0))
# cons arg1=((primitive-ref string->symbol) "cdr") arg2=(vector-ref f259505 0)
# emit-expr ((primitive-ref string->symbol) "cdr")
# funcall
#    si   =-12
#    env  = ((f259505 . 0))
#    expr = (funcall (primitive-ref string->symbol) "cdr")
# emit-expr (primitive-ref string->symbol)
    .extern mrc_string$m$gsymbol
    movl mrc_string$m$gsymbol,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1576589"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1576589":
   movl %eax,  -20(%esp)  # stash funcall-oper in closure slot
# emit-expr "cdr"
# string literal
    jmp _L_1576591
    .align 8,0x90
_L_1576590 :
    .int 12
    .ascii "cdr"
_L_1576591:
    movl $_L_1576590, %eax
    orl $6, %eax
    mov %eax, -24(%esp)  # arg cdr
    movl -20(%esp), %edi   # load new closure to %edi
    add $-12, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $12, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    movl %eax, -12(%esp)
# emit-expr (vector-ref f259505 0)
# emit-expr f259505
# emit-variable-ref
# env=((f259505 . 0))
# var=f259505
    movl 0(%esp), %eax  # stack load f259505
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1576592
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1576592:
    movl %eax, -16(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1576593"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1576593:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1576595
    cmp  $0,%eax
    jge _L_1576594
_L_1576595:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1576594:
    movl -16(%esp), %esi
    movl -1(%eax,%esi), %eax
    movl %eax, 4(%ebp)
    movl -12(%esp), %eax
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    or   $1, %al
    add  $8, %ebp
# cons end
    movl -4(%esp), %ebx
    movl -8(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "car") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "cons") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "pair?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fxremainder") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fxquotient") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fx*") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fx-") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fx+") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fx>=") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fx>") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fx<=") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fx<") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fx=") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f259505 0))) (closure () (f259505) (let () (vector-ref f259505 0))))
# emit-begin
#   expr=(begin (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "car") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "cons") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "pair?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fxremainder") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fxquotient") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fx*") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fx-") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fx+") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fx>=") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fx>") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fx<=") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fx<") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fx=") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f259505 0))) (closure () (f259505) (let () (vector-ref f259505 0))))
#   env=((f259505 . 0))
# emit-expr (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "car") (vector-ref f259505 0)))
# emit-expr f259505
# emit-variable-ref
# env=((f259505 . 0))
# var=f259505
    movl 0(%esp), %eax  # stack load f259505
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1576596
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1576596:
    movl %eax, -4(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1576597"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1576597:
# check bounds on vector index
    movl -4(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1576599
    cmp  $0,%eax
    jge _L_1576598
_L_1576599:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1576598:
    movl %eax, -8(%esp)
# emit-expr (cons ((primitive-ref string->symbol) "car") (vector-ref f259505 0))
# cons arg1=((primitive-ref string->symbol) "car") arg2=(vector-ref f259505 0)
# emit-expr ((primitive-ref string->symbol) "car")
# funcall
#    si   =-12
#    env  = ((f259505 . 0))
#    expr = (funcall (primitive-ref string->symbol) "car")
# emit-expr (primitive-ref string->symbol)
    .extern mrc_string$m$gsymbol
    movl mrc_string$m$gsymbol,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1576600"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1576600":
   movl %eax,  -20(%esp)  # stash funcall-oper in closure slot
# emit-expr "car"
# string literal
    jmp _L_1576602
    .align 8,0x90
_L_1576601 :
    .int 12
    .ascii "car"
_L_1576602:
    movl $_L_1576601, %eax
    orl $6, %eax
    mov %eax, -24(%esp)  # arg car
    movl -20(%esp), %edi   # load new closure to %edi
    add $-12, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $12, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    movl %eax, -12(%esp)
# emit-expr (vector-ref f259505 0)
# emit-expr f259505
# emit-variable-ref
# env=((f259505 . 0))
# var=f259505
    movl 0(%esp), %eax  # stack load f259505
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1576603
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1576603:
    movl %eax, -16(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1576604"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1576604:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1576606
    cmp  $0,%eax
    jge _L_1576605
_L_1576606:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1576605:
    movl -16(%esp), %esi
    movl -1(%eax,%esi), %eax
    movl %eax, 4(%ebp)
    movl -12(%esp), %eax
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    or   $1, %al
    add  $8, %ebp
# cons end
    movl -4(%esp), %ebx
    movl -8(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "cons") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "pair?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fxremainder") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fxquotient") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fx*") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fx-") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fx+") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fx>=") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fx>") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fx<=") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fx<") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fx=") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f259505 0))) (closure () (f259505) (let () (vector-ref f259505 0))))
# emit-begin
#   expr=(begin (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "cons") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "pair?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fxremainder") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fxquotient") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fx*") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fx-") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fx+") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fx>=") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fx>") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fx<=") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fx<") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fx=") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f259505 0))) (closure () (f259505) (let () (vector-ref f259505 0))))
#   env=((f259505 . 0))
# emit-expr (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "cons") (vector-ref f259505 0)))
# emit-expr f259505
# emit-variable-ref
# env=((f259505 . 0))
# var=f259505
    movl 0(%esp), %eax  # stack load f259505
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1576607
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1576607:
    movl %eax, -4(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1576608"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1576608:
# check bounds on vector index
    movl -4(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1576610
    cmp  $0,%eax
    jge _L_1576609
_L_1576610:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1576609:
    movl %eax, -8(%esp)
# emit-expr (cons ((primitive-ref string->symbol) "cons") (vector-ref f259505 0))
# cons arg1=((primitive-ref string->symbol) "cons") arg2=(vector-ref f259505 0)
# emit-expr ((primitive-ref string->symbol) "cons")
# funcall
#    si   =-12
#    env  = ((f259505 . 0))
#    expr = (funcall (primitive-ref string->symbol) "cons")
# emit-expr (primitive-ref string->symbol)
    .extern mrc_string$m$gsymbol
    movl mrc_string$m$gsymbol,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1576611"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1576611":
   movl %eax,  -20(%esp)  # stash funcall-oper in closure slot
# emit-expr "cons"
# string literal
    jmp _L_1576613
    .align 8,0x90
_L_1576612 :
    .int 16
    .ascii "cons"
_L_1576613:
    movl $_L_1576612, %eax
    orl $6, %eax
    mov %eax, -24(%esp)  # arg cons
    movl -20(%esp), %edi   # load new closure to %edi
    add $-12, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $12, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    movl %eax, -12(%esp)
# emit-expr (vector-ref f259505 0)
# emit-expr f259505
# emit-variable-ref
# env=((f259505 . 0))
# var=f259505
    movl 0(%esp), %eax  # stack load f259505
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1576614
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1576614:
    movl %eax, -16(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1576615"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1576615:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1576617
    cmp  $0,%eax
    jge _L_1576616
_L_1576617:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1576616:
    movl -16(%esp), %esi
    movl -1(%eax,%esi), %eax
    movl %eax, 4(%ebp)
    movl -12(%esp), %eax
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    or   $1, %al
    add  $8, %ebp
# cons end
    movl -4(%esp), %ebx
    movl -8(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "pair?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fxremainder") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fxquotient") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fx*") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fx-") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fx+") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fx>=") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fx>") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fx<=") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fx<") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fx=") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f259505 0))) (closure () (f259505) (let () (vector-ref f259505 0))))
# emit-begin
#   expr=(begin (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "pair?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fxremainder") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fxquotient") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fx*") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fx-") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fx+") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fx>=") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fx>") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fx<=") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fx<") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fx=") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f259505 0))) (closure () (f259505) (let () (vector-ref f259505 0))))
#   env=((f259505 . 0))
# emit-expr (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "pair?") (vector-ref f259505 0)))
# emit-expr f259505
# emit-variable-ref
# env=((f259505 . 0))
# var=f259505
    movl 0(%esp), %eax  # stack load f259505
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1576618
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1576618:
    movl %eax, -4(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1576619"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1576619:
# check bounds on vector index
    movl -4(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1576621
    cmp  $0,%eax
    jge _L_1576620
_L_1576621:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1576620:
    movl %eax, -8(%esp)
# emit-expr (cons ((primitive-ref string->symbol) "pair?") (vector-ref f259505 0))
# cons arg1=((primitive-ref string->symbol) "pair?") arg2=(vector-ref f259505 0)
# emit-expr ((primitive-ref string->symbol) "pair?")
# funcall
#    si   =-12
#    env  = ((f259505 . 0))
#    expr = (funcall (primitive-ref string->symbol) "pair?")
# emit-expr (primitive-ref string->symbol)
    .extern mrc_string$m$gsymbol
    movl mrc_string$m$gsymbol,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1576622"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1576622":
   movl %eax,  -20(%esp)  # stash funcall-oper in closure slot
# emit-expr "pair?"
# string literal
    jmp _L_1576624
    .align 8,0x90
_L_1576623 :
    .int 20
    .ascii "pair?"
_L_1576624:
    movl $_L_1576623, %eax
    orl $6, %eax
    mov %eax, -24(%esp)  # arg pair?
    movl -20(%esp), %edi   # load new closure to %edi
    add $-12, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $12, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    movl %eax, -12(%esp)
# emit-expr (vector-ref f259505 0)
# emit-expr f259505
# emit-variable-ref
# env=((f259505 . 0))
# var=f259505
    movl 0(%esp), %eax  # stack load f259505
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1576625
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1576625:
    movl %eax, -16(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1576626"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1576626:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1576628
    cmp  $0,%eax
    jge _L_1576627
_L_1576628:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1576627:
    movl -16(%esp), %esi
    movl -1(%eax,%esi), %eax
    movl %eax, 4(%ebp)
    movl -12(%esp), %eax
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    or   $1, %al
    add  $8, %ebp
# cons end
    movl -4(%esp), %ebx
    movl -8(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fxremainder") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fxquotient") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fx*") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fx-") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fx+") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fx>=") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fx>") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fx<=") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fx<") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fx=") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f259505 0))) (closure () (f259505) (let () (vector-ref f259505 0))))
# emit-begin
#   expr=(begin (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fxremainder") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fxquotient") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fx*") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fx-") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fx+") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fx>=") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fx>") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fx<=") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fx<") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fx=") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f259505 0))) (closure () (f259505) (let () (vector-ref f259505 0))))
#   env=((f259505 . 0))
# emit-expr (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fxremainder") (vector-ref f259505 0)))
# emit-expr f259505
# emit-variable-ref
# env=((f259505 . 0))
# var=f259505
    movl 0(%esp), %eax  # stack load f259505
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1576629
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1576629:
    movl %eax, -4(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1576630"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1576630:
# check bounds on vector index
    movl -4(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1576632
    cmp  $0,%eax
    jge _L_1576631
_L_1576632:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1576631:
    movl %eax, -8(%esp)
# emit-expr (cons ((primitive-ref string->symbol) "fxremainder") (vector-ref f259505 0))
# cons arg1=((primitive-ref string->symbol) "fxremainder") arg2=(vector-ref f259505 0)
# emit-expr ((primitive-ref string->symbol) "fxremainder")
# funcall
#    si   =-12
#    env  = ((f259505 . 0))
#    expr = (funcall (primitive-ref string->symbol) "fxremainder")
# emit-expr (primitive-ref string->symbol)
    .extern mrc_string$m$gsymbol
    movl mrc_string$m$gsymbol,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1576633"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1576633":
   movl %eax,  -20(%esp)  # stash funcall-oper in closure slot
# emit-expr "fxremainder"
# string literal
    jmp _L_1576635
    .align 8,0x90
_L_1576634 :
    .int 44
    .ascii "fxremainder"
_L_1576635:
    movl $_L_1576634, %eax
    orl $6, %eax
    mov %eax, -24(%esp)  # arg fxremainder
    movl -20(%esp), %edi   # load new closure to %edi
    add $-12, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $12, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    movl %eax, -12(%esp)
# emit-expr (vector-ref f259505 0)
# emit-expr f259505
# emit-variable-ref
# env=((f259505 . 0))
# var=f259505
    movl 0(%esp), %eax  # stack load f259505
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1576636
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1576636:
    movl %eax, -16(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1576637"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1576637:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1576639
    cmp  $0,%eax
    jge _L_1576638
_L_1576639:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1576638:
    movl -16(%esp), %esi
    movl -1(%eax,%esi), %eax
    movl %eax, 4(%ebp)
    movl -12(%esp), %eax
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    or   $1, %al
    add  $8, %ebp
# cons end
    movl -4(%esp), %ebx
    movl -8(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fxquotient") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fx*") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fx-") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fx+") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fx>=") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fx>") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fx<=") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fx<") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fx=") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f259505 0))) (closure () (f259505) (let () (vector-ref f259505 0))))
# emit-begin
#   expr=(begin (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fxquotient") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fx*") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fx-") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fx+") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fx>=") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fx>") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fx<=") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fx<") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fx=") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f259505 0))) (closure () (f259505) (let () (vector-ref f259505 0))))
#   env=((f259505 . 0))
# emit-expr (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fxquotient") (vector-ref f259505 0)))
# emit-expr f259505
# emit-variable-ref
# env=((f259505 . 0))
# var=f259505
    movl 0(%esp), %eax  # stack load f259505
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1576640
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1576640:
    movl %eax, -4(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1576641"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1576641:
# check bounds on vector index
    movl -4(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1576643
    cmp  $0,%eax
    jge _L_1576642
_L_1576643:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1576642:
    movl %eax, -8(%esp)
# emit-expr (cons ((primitive-ref string->symbol) "fxquotient") (vector-ref f259505 0))
# cons arg1=((primitive-ref string->symbol) "fxquotient") arg2=(vector-ref f259505 0)
# emit-expr ((primitive-ref string->symbol) "fxquotient")
# funcall
#    si   =-12
#    env  = ((f259505 . 0))
#    expr = (funcall (primitive-ref string->symbol) "fxquotient")
# emit-expr (primitive-ref string->symbol)
    .extern mrc_string$m$gsymbol
    movl mrc_string$m$gsymbol,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1576644"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1576644":
   movl %eax,  -20(%esp)  # stash funcall-oper in closure slot
# emit-expr "fxquotient"
# string literal
    jmp _L_1576646
    .align 8,0x90
_L_1576645 :
    .int 40
    .ascii "fxquotient"
_L_1576646:
    movl $_L_1576645, %eax
    orl $6, %eax
    mov %eax, -24(%esp)  # arg fxquotient
    movl -20(%esp), %edi   # load new closure to %edi
    add $-12, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $12, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    movl %eax, -12(%esp)
# emit-expr (vector-ref f259505 0)
# emit-expr f259505
# emit-variable-ref
# env=((f259505 . 0))
# var=f259505
    movl 0(%esp), %eax  # stack load f259505
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1576647
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1576647:
    movl %eax, -16(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1576648"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1576648:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1576650
    cmp  $0,%eax
    jge _L_1576649
_L_1576650:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1576649:
    movl -16(%esp), %esi
    movl -1(%eax,%esi), %eax
    movl %eax, 4(%ebp)
    movl -12(%esp), %eax
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    or   $1, %al
    add  $8, %ebp
# cons end
    movl -4(%esp), %ebx
    movl -8(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fx*") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fx-") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fx+") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fx>=") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fx>") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fx<=") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fx<") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fx=") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f259505 0))) (closure () (f259505) (let () (vector-ref f259505 0))))
# emit-begin
#   expr=(begin (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fx*") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fx-") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fx+") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fx>=") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fx>") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fx<=") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fx<") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fx=") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f259505 0))) (closure () (f259505) (let () (vector-ref f259505 0))))
#   env=((f259505 . 0))
# emit-expr (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fx*") (vector-ref f259505 0)))
# emit-expr f259505
# emit-variable-ref
# env=((f259505 . 0))
# var=f259505
    movl 0(%esp), %eax  # stack load f259505
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1576651
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1576651:
    movl %eax, -4(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1576652"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1576652:
# check bounds on vector index
    movl -4(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1576654
    cmp  $0,%eax
    jge _L_1576653
_L_1576654:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1576653:
    movl %eax, -8(%esp)
# emit-expr (cons ((primitive-ref string->symbol) "fx*") (vector-ref f259505 0))
# cons arg1=((primitive-ref string->symbol) "fx*") arg2=(vector-ref f259505 0)
# emit-expr ((primitive-ref string->symbol) "fx*")
# funcall
#    si   =-12
#    env  = ((f259505 . 0))
#    expr = (funcall (primitive-ref string->symbol) "fx*")
# emit-expr (primitive-ref string->symbol)
    .extern mrc_string$m$gsymbol
    movl mrc_string$m$gsymbol,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1576655"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1576655":
   movl %eax,  -20(%esp)  # stash funcall-oper in closure slot
# emit-expr "fx*"
# string literal
    jmp _L_1576657
    .align 8,0x90
_L_1576656 :
    .int 12
    .ascii "fx*"
_L_1576657:
    movl $_L_1576656, %eax
    orl $6, %eax
    mov %eax, -24(%esp)  # arg fx*
    movl -20(%esp), %edi   # load new closure to %edi
    add $-12, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $12, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    movl %eax, -12(%esp)
# emit-expr (vector-ref f259505 0)
# emit-expr f259505
# emit-variable-ref
# env=((f259505 . 0))
# var=f259505
    movl 0(%esp), %eax  # stack load f259505
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1576658
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1576658:
    movl %eax, -16(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1576659"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1576659:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1576661
    cmp  $0,%eax
    jge _L_1576660
_L_1576661:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1576660:
    movl -16(%esp), %esi
    movl -1(%eax,%esi), %eax
    movl %eax, 4(%ebp)
    movl -12(%esp), %eax
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    or   $1, %al
    add  $8, %ebp
# cons end
    movl -4(%esp), %ebx
    movl -8(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fx-") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fx+") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fx>=") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fx>") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fx<=") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fx<") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fx=") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f259505 0))) (closure () (f259505) (let () (vector-ref f259505 0))))
# emit-begin
#   expr=(begin (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fx-") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fx+") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fx>=") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fx>") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fx<=") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fx<") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fx=") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f259505 0))) (closure () (f259505) (let () (vector-ref f259505 0))))
#   env=((f259505 . 0))
# emit-expr (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fx-") (vector-ref f259505 0)))
# emit-expr f259505
# emit-variable-ref
# env=((f259505 . 0))
# var=f259505
    movl 0(%esp), %eax  # stack load f259505
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1576662
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1576662:
    movl %eax, -4(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1576663"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1576663:
# check bounds on vector index
    movl -4(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1576665
    cmp  $0,%eax
    jge _L_1576664
_L_1576665:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1576664:
    movl %eax, -8(%esp)
# emit-expr (cons ((primitive-ref string->symbol) "fx-") (vector-ref f259505 0))
# cons arg1=((primitive-ref string->symbol) "fx-") arg2=(vector-ref f259505 0)
# emit-expr ((primitive-ref string->symbol) "fx-")
# funcall
#    si   =-12
#    env  = ((f259505 . 0))
#    expr = (funcall (primitive-ref string->symbol) "fx-")
# emit-expr (primitive-ref string->symbol)
    .extern mrc_string$m$gsymbol
    movl mrc_string$m$gsymbol,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1576666"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1576666":
   movl %eax,  -20(%esp)  # stash funcall-oper in closure slot
# emit-expr "fx-"
# string literal
    jmp _L_1576668
    .align 8,0x90
_L_1576667 :
    .int 12
    .ascii "fx-"
_L_1576668:
    movl $_L_1576667, %eax
    orl $6, %eax
    mov %eax, -24(%esp)  # arg fx-
    movl -20(%esp), %edi   # load new closure to %edi
    add $-12, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $12, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    movl %eax, -12(%esp)
# emit-expr (vector-ref f259505 0)
# emit-expr f259505
# emit-variable-ref
# env=((f259505 . 0))
# var=f259505
    movl 0(%esp), %eax  # stack load f259505
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1576669
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1576669:
    movl %eax, -16(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1576670"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1576670:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1576672
    cmp  $0,%eax
    jge _L_1576671
_L_1576672:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1576671:
    movl -16(%esp), %esi
    movl -1(%eax,%esi), %eax
    movl %eax, 4(%ebp)
    movl -12(%esp), %eax
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    or   $1, %al
    add  $8, %ebp
# cons end
    movl -4(%esp), %ebx
    movl -8(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fx+") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fx>=") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fx>") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fx<=") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fx<") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fx=") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f259505 0))) (closure () (f259505) (let () (vector-ref f259505 0))))
# emit-begin
#   expr=(begin (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fx+") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fx>=") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fx>") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fx<=") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fx<") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fx=") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f259505 0))) (closure () (f259505) (let () (vector-ref f259505 0))))
#   env=((f259505 . 0))
# emit-expr (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fx+") (vector-ref f259505 0)))
# emit-expr f259505
# emit-variable-ref
# env=((f259505 . 0))
# var=f259505
    movl 0(%esp), %eax  # stack load f259505
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1576673
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1576673:
    movl %eax, -4(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1576674"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1576674:
# check bounds on vector index
    movl -4(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1576676
    cmp  $0,%eax
    jge _L_1576675
_L_1576676:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1576675:
    movl %eax, -8(%esp)
# emit-expr (cons ((primitive-ref string->symbol) "fx+") (vector-ref f259505 0))
# cons arg1=((primitive-ref string->symbol) "fx+") arg2=(vector-ref f259505 0)
# emit-expr ((primitive-ref string->symbol) "fx+")
# funcall
#    si   =-12
#    env  = ((f259505 . 0))
#    expr = (funcall (primitive-ref string->symbol) "fx+")
# emit-expr (primitive-ref string->symbol)
    .extern mrc_string$m$gsymbol
    movl mrc_string$m$gsymbol,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1576677"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1576677":
   movl %eax,  -20(%esp)  # stash funcall-oper in closure slot
# emit-expr "fx+"
# string literal
    jmp _L_1576679
    .align 8,0x90
_L_1576678 :
    .int 12
    .ascii "fx+"
_L_1576679:
    movl $_L_1576678, %eax
    orl $6, %eax
    mov %eax, -24(%esp)  # arg fx+
    movl -20(%esp), %edi   # load new closure to %edi
    add $-12, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $12, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    movl %eax, -12(%esp)
# emit-expr (vector-ref f259505 0)
# emit-expr f259505
# emit-variable-ref
# env=((f259505 . 0))
# var=f259505
    movl 0(%esp), %eax  # stack load f259505
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1576680
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1576680:
    movl %eax, -16(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1576681"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1576681:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1576683
    cmp  $0,%eax
    jge _L_1576682
_L_1576683:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1576682:
    movl -16(%esp), %esi
    movl -1(%eax,%esi), %eax
    movl %eax, 4(%ebp)
    movl -12(%esp), %eax
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    or   $1, %al
    add  $8, %ebp
# cons end
    movl -4(%esp), %ebx
    movl -8(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fx>=") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fx>") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fx<=") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fx<") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fx=") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f259505 0))) (closure () (f259505) (let () (vector-ref f259505 0))))
# emit-begin
#   expr=(begin (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fx>=") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fx>") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fx<=") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fx<") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fx=") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f259505 0))) (closure () (f259505) (let () (vector-ref f259505 0))))
#   env=((f259505 . 0))
# emit-expr (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fx>=") (vector-ref f259505 0)))
# emit-expr f259505
# emit-variable-ref
# env=((f259505 . 0))
# var=f259505
    movl 0(%esp), %eax  # stack load f259505
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1576684
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1576684:
    movl %eax, -4(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1576685"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1576685:
# check bounds on vector index
    movl -4(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1576687
    cmp  $0,%eax
    jge _L_1576686
_L_1576687:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1576686:
    movl %eax, -8(%esp)
# emit-expr (cons ((primitive-ref string->symbol) "fx>=") (vector-ref f259505 0))
# cons arg1=((primitive-ref string->symbol) "fx>=") arg2=(vector-ref f259505 0)
# emit-expr ((primitive-ref string->symbol) "fx>=")
# funcall
#    si   =-12
#    env  = ((f259505 . 0))
#    expr = (funcall (primitive-ref string->symbol) "fx>=")
# emit-expr (primitive-ref string->symbol)
    .extern mrc_string$m$gsymbol
    movl mrc_string$m$gsymbol,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1576688"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1576688":
   movl %eax,  -20(%esp)  # stash funcall-oper in closure slot
# emit-expr "fx>="
# string literal
    jmp _L_1576690
    .align 8,0x90
_L_1576689 :
    .int 16
    .ascii "fx>="
_L_1576690:
    movl $_L_1576689, %eax
    orl $6, %eax
    mov %eax, -24(%esp)  # arg fx>=
    movl -20(%esp), %edi   # load new closure to %edi
    add $-12, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $12, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    movl %eax, -12(%esp)
# emit-expr (vector-ref f259505 0)
# emit-expr f259505
# emit-variable-ref
# env=((f259505 . 0))
# var=f259505
    movl 0(%esp), %eax  # stack load f259505
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1576691
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1576691:
    movl %eax, -16(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1576692"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1576692:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1576694
    cmp  $0,%eax
    jge _L_1576693
_L_1576694:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1576693:
    movl -16(%esp), %esi
    movl -1(%eax,%esi), %eax
    movl %eax, 4(%ebp)
    movl -12(%esp), %eax
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    or   $1, %al
    add  $8, %ebp
# cons end
    movl -4(%esp), %ebx
    movl -8(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fx>") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fx<=") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fx<") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fx=") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f259505 0))) (closure () (f259505) (let () (vector-ref f259505 0))))
# emit-begin
#   expr=(begin (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fx>") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fx<=") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fx<") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fx=") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f259505 0))) (closure () (f259505) (let () (vector-ref f259505 0))))
#   env=((f259505 . 0))
# emit-expr (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fx>") (vector-ref f259505 0)))
# emit-expr f259505
# emit-variable-ref
# env=((f259505 . 0))
# var=f259505
    movl 0(%esp), %eax  # stack load f259505
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1576695
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1576695:
    movl %eax, -4(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1576696"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1576696:
# check bounds on vector index
    movl -4(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1576698
    cmp  $0,%eax
    jge _L_1576697
_L_1576698:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1576697:
    movl %eax, -8(%esp)
# emit-expr (cons ((primitive-ref string->symbol) "fx>") (vector-ref f259505 0))
# cons arg1=((primitive-ref string->symbol) "fx>") arg2=(vector-ref f259505 0)
# emit-expr ((primitive-ref string->symbol) "fx>")
# funcall
#    si   =-12
#    env  = ((f259505 . 0))
#    expr = (funcall (primitive-ref string->symbol) "fx>")
# emit-expr (primitive-ref string->symbol)
    .extern mrc_string$m$gsymbol
    movl mrc_string$m$gsymbol,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1576699"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1576699":
   movl %eax,  -20(%esp)  # stash funcall-oper in closure slot
# emit-expr "fx>"
# string literal
    jmp _L_1576701
    .align 8,0x90
_L_1576700 :
    .int 12
    .ascii "fx>"
_L_1576701:
    movl $_L_1576700, %eax
    orl $6, %eax
    mov %eax, -24(%esp)  # arg fx>
    movl -20(%esp), %edi   # load new closure to %edi
    add $-12, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $12, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    movl %eax, -12(%esp)
# emit-expr (vector-ref f259505 0)
# emit-expr f259505
# emit-variable-ref
# env=((f259505 . 0))
# var=f259505
    movl 0(%esp), %eax  # stack load f259505
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1576702
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1576702:
    movl %eax, -16(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1576703"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1576703:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1576705
    cmp  $0,%eax
    jge _L_1576704
_L_1576705:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1576704:
    movl -16(%esp), %esi
    movl -1(%eax,%esi), %eax
    movl %eax, 4(%ebp)
    movl -12(%esp), %eax
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    or   $1, %al
    add  $8, %ebp
# cons end
    movl -4(%esp), %ebx
    movl -8(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fx<=") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fx<") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fx=") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f259505 0))) (closure () (f259505) (let () (vector-ref f259505 0))))
# emit-begin
#   expr=(begin (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fx<=") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fx<") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fx=") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f259505 0))) (closure () (f259505) (let () (vector-ref f259505 0))))
#   env=((f259505 . 0))
# emit-expr (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fx<=") (vector-ref f259505 0)))
# emit-expr f259505
# emit-variable-ref
# env=((f259505 . 0))
# var=f259505
    movl 0(%esp), %eax  # stack load f259505
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1576706
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1576706:
    movl %eax, -4(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1576707"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1576707:
# check bounds on vector index
    movl -4(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1576709
    cmp  $0,%eax
    jge _L_1576708
_L_1576709:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1576708:
    movl %eax, -8(%esp)
# emit-expr (cons ((primitive-ref string->symbol) "fx<=") (vector-ref f259505 0))
# cons arg1=((primitive-ref string->symbol) "fx<=") arg2=(vector-ref f259505 0)
# emit-expr ((primitive-ref string->symbol) "fx<=")
# funcall
#    si   =-12
#    env  = ((f259505 . 0))
#    expr = (funcall (primitive-ref string->symbol) "fx<=")
# emit-expr (primitive-ref string->symbol)
    .extern mrc_string$m$gsymbol
    movl mrc_string$m$gsymbol,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1576710"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1576710":
   movl %eax,  -20(%esp)  # stash funcall-oper in closure slot
# emit-expr "fx<="
# string literal
    jmp _L_1576712
    .align 8,0x90
_L_1576711 :
    .int 16
    .ascii "fx<="
_L_1576712:
    movl $_L_1576711, %eax
    orl $6, %eax
    mov %eax, -24(%esp)  # arg fx<=
    movl -20(%esp), %edi   # load new closure to %edi
    add $-12, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $12, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    movl %eax, -12(%esp)
# emit-expr (vector-ref f259505 0)
# emit-expr f259505
# emit-variable-ref
# env=((f259505 . 0))
# var=f259505
    movl 0(%esp), %eax  # stack load f259505
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1576713
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1576713:
    movl %eax, -16(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1576714"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1576714:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1576716
    cmp  $0,%eax
    jge _L_1576715
_L_1576716:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1576715:
    movl -16(%esp), %esi
    movl -1(%eax,%esi), %eax
    movl %eax, 4(%ebp)
    movl -12(%esp), %eax
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    or   $1, %al
    add  $8, %ebp
# cons end
    movl -4(%esp), %ebx
    movl -8(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fx<") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fx=") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f259505 0))) (closure () (f259505) (let () (vector-ref f259505 0))))
# emit-begin
#   expr=(begin (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fx<") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fx=") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f259505 0))) (closure () (f259505) (let () (vector-ref f259505 0))))
#   env=((f259505 . 0))
# emit-expr (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fx<") (vector-ref f259505 0)))
# emit-expr f259505
# emit-variable-ref
# env=((f259505 . 0))
# var=f259505
    movl 0(%esp), %eax  # stack load f259505
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1576717
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1576717:
    movl %eax, -4(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1576718"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1576718:
# check bounds on vector index
    movl -4(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1576720
    cmp  $0,%eax
    jge _L_1576719
_L_1576720:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1576719:
    movl %eax, -8(%esp)
# emit-expr (cons ((primitive-ref string->symbol) "fx<") (vector-ref f259505 0))
# cons arg1=((primitive-ref string->symbol) "fx<") arg2=(vector-ref f259505 0)
# emit-expr ((primitive-ref string->symbol) "fx<")
# funcall
#    si   =-12
#    env  = ((f259505 . 0))
#    expr = (funcall (primitive-ref string->symbol) "fx<")
# emit-expr (primitive-ref string->symbol)
    .extern mrc_string$m$gsymbol
    movl mrc_string$m$gsymbol,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1576721"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1576721":
   movl %eax,  -20(%esp)  # stash funcall-oper in closure slot
# emit-expr "fx<"
# string literal
    jmp _L_1576723
    .align 8,0x90
_L_1576722 :
    .int 12
    .ascii "fx<"
_L_1576723:
    movl $_L_1576722, %eax
    orl $6, %eax
    mov %eax, -24(%esp)  # arg fx<
    movl -20(%esp), %edi   # load new closure to %edi
    add $-12, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $12, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    movl %eax, -12(%esp)
# emit-expr (vector-ref f259505 0)
# emit-expr f259505
# emit-variable-ref
# env=((f259505 . 0))
# var=f259505
    movl 0(%esp), %eax  # stack load f259505
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1576724
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1576724:
    movl %eax, -16(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1576725"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1576725:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1576727
    cmp  $0,%eax
    jge _L_1576726
_L_1576727:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1576726:
    movl -16(%esp), %esi
    movl -1(%eax,%esi), %eax
    movl %eax, 4(%ebp)
    movl -12(%esp), %eax
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    or   $1, %al
    add  $8, %ebp
# cons end
    movl -4(%esp), %ebx
    movl -8(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fx=") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f259505 0))) (closure () (f259505) (let () (vector-ref f259505 0))))
# emit-begin
#   expr=(begin (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fx=") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f259505 0))) (closure () (f259505) (let () (vector-ref f259505 0))))
#   env=((f259505 . 0))
# emit-expr (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fx=") (vector-ref f259505 0)))
# emit-expr f259505
# emit-variable-ref
# env=((f259505 . 0))
# var=f259505
    movl 0(%esp), %eax  # stack load f259505
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1576728
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1576728:
    movl %eax, -4(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1576729"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1576729:
# check bounds on vector index
    movl -4(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1576731
    cmp  $0,%eax
    jge _L_1576730
_L_1576731:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1576730:
    movl %eax, -8(%esp)
# emit-expr (cons ((primitive-ref string->symbol) "fx=") (vector-ref f259505 0))
# cons arg1=((primitive-ref string->symbol) "fx=") arg2=(vector-ref f259505 0)
# emit-expr ((primitive-ref string->symbol) "fx=")
# funcall
#    si   =-12
#    env  = ((f259505 . 0))
#    expr = (funcall (primitive-ref string->symbol) "fx=")
# emit-expr (primitive-ref string->symbol)
    .extern mrc_string$m$gsymbol
    movl mrc_string$m$gsymbol,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1576732"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1576732":
   movl %eax,  -20(%esp)  # stash funcall-oper in closure slot
# emit-expr "fx="
# string literal
    jmp _L_1576734
    .align 8,0x90
_L_1576733 :
    .int 12
    .ascii "fx="
_L_1576734:
    movl $_L_1576733, %eax
    orl $6, %eax
    mov %eax, -24(%esp)  # arg fx=
    movl -20(%esp), %edi   # load new closure to %edi
    add $-12, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $12, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    movl %eax, -12(%esp)
# emit-expr (vector-ref f259505 0)
# emit-expr f259505
# emit-variable-ref
# env=((f259505 . 0))
# var=f259505
    movl 0(%esp), %eax  # stack load f259505
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1576735
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1576735:
    movl %eax, -16(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1576736"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1576736:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1576738
    cmp  $0,%eax
    jge _L_1576737
_L_1576738:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1576737:
    movl -16(%esp), %esi
    movl -1(%eax,%esi), %eax
    movl %eax, 4(%ebp)
    movl -12(%esp), %eax
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    or   $1, %al
    add  $8, %ebp
# cons end
    movl -4(%esp), %ebx
    movl -8(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f259505 0))) (closure () (f259505) (let () (vector-ref f259505 0))))
# emit-begin
#   expr=(begin (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f259505 0))) (closure () (f259505) (let () (vector-ref f259505 0))))
#   env=((f259505 . 0))
# emit-expr (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f259505 0)))
# emit-expr f259505
# emit-variable-ref
# env=((f259505 . 0))
# var=f259505
    movl 0(%esp), %eax  # stack load f259505
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1576739
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1576739:
    movl %eax, -4(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1576740"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1576740:
# check bounds on vector index
    movl -4(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1576742
    cmp  $0,%eax
    jge _L_1576741
_L_1576742:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1576741:
    movl %eax, -8(%esp)
# emit-expr (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f259505 0))
# cons arg1=((primitive-ref string->symbol) "fxzero?") arg2=(vector-ref f259505 0)
# emit-expr ((primitive-ref string->symbol) "fxzero?")
# funcall
#    si   =-12
#    env  = ((f259505 . 0))
#    expr = (funcall (primitive-ref string->symbol) "fxzero?")
# emit-expr (primitive-ref string->symbol)
    .extern mrc_string$m$gsymbol
    movl mrc_string$m$gsymbol,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1576743"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1576743":
   movl %eax,  -20(%esp)  # stash funcall-oper in closure slot
# emit-expr "fxzero?"
# string literal
    jmp _L_1576745
    .align 8,0x90
_L_1576744 :
    .int 28
    .ascii "fxzero?"
_L_1576745:
    movl $_L_1576744, %eax
    orl $6, %eax
    mov %eax, -24(%esp)  # arg fxzero?
    movl -20(%esp), %edi   # load new closure to %edi
    add $-12, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $12, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    movl %eax, -12(%esp)
# emit-expr (vector-ref f259505 0)
# emit-expr f259505
# emit-variable-ref
# env=((f259505 . 0))
# var=f259505
    movl 0(%esp), %eax  # stack load f259505
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1576746
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1576746:
    movl %eax, -16(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1576747"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1576747:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1576749
    cmp  $0,%eax
    jge _L_1576748
_L_1576749:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1576748:
    movl -16(%esp), %esi
    movl -1(%eax,%esi), %eax
    movl %eax, 4(%ebp)
    movl -12(%esp), %eax
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    or   $1, %al
    add  $8, %ebp
# cons end
    movl -4(%esp), %ebx
    movl -8(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f259505 0))) (closure () (f259505) (let () (vector-ref f259505 0))))
# emit-begin
#   expr=(begin (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f259505 0))) (closure () (f259505) (let () (vector-ref f259505 0))))
#   env=((f259505 . 0))
# emit-expr (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f259505 0)))
# emit-expr f259505
# emit-variable-ref
# env=((f259505 . 0))
# var=f259505
    movl 0(%esp), %eax  # stack load f259505
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1576750
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1576750:
    movl %eax, -4(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1576751"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1576751:
# check bounds on vector index
    movl -4(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1576753
    cmp  $0,%eax
    jge _L_1576752
_L_1576753:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1576752:
    movl %eax, -8(%esp)
# emit-expr (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f259505 0))
# cons arg1=((primitive-ref string->symbol) "fxsub1") arg2=(vector-ref f259505 0)
# emit-expr ((primitive-ref string->symbol) "fxsub1")
# funcall
#    si   =-12
#    env  = ((f259505 . 0))
#    expr = (funcall (primitive-ref string->symbol) "fxsub1")
# emit-expr (primitive-ref string->symbol)
    .extern mrc_string$m$gsymbol
    movl mrc_string$m$gsymbol,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1576754"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1576754":
   movl %eax,  -20(%esp)  # stash funcall-oper in closure slot
# emit-expr "fxsub1"
# string literal
    jmp _L_1576756
    .align 8,0x90
_L_1576755 :
    .int 24
    .ascii "fxsub1"
_L_1576756:
    movl $_L_1576755, %eax
    orl $6, %eax
    mov %eax, -24(%esp)  # arg fxsub1
    movl -20(%esp), %edi   # load new closure to %edi
    add $-12, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $12, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    movl %eax, -12(%esp)
# emit-expr (vector-ref f259505 0)
# emit-expr f259505
# emit-variable-ref
# env=((f259505 . 0))
# var=f259505
    movl 0(%esp), %eax  # stack load f259505
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1576757
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1576757:
    movl %eax, -16(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1576758"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1576758:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1576760
    cmp  $0,%eax
    jge _L_1576759
_L_1576760:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1576759:
    movl -16(%esp), %esi
    movl -1(%eax,%esi), %eax
    movl %eax, 4(%ebp)
    movl -12(%esp), %eax
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    or   $1, %al
    add  $8, %ebp
# cons end
    movl -4(%esp), %ebx
    movl -8(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f259505 0))) (closure () (f259505) (let () (vector-ref f259505 0))))
# emit-begin
#   expr=(begin (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f259505 0))) (closure () (f259505) (let () (vector-ref f259505 0))))
#   env=((f259505 . 0))
# emit-expr (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f259505 0)))
# emit-expr f259505
# emit-variable-ref
# env=((f259505 . 0))
# var=f259505
    movl 0(%esp), %eax  # stack load f259505
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1576761
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1576761:
    movl %eax, -4(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1576762"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1576762:
# check bounds on vector index
    movl -4(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1576764
    cmp  $0,%eax
    jge _L_1576763
_L_1576764:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1576763:
    movl %eax, -8(%esp)
# emit-expr (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f259505 0))
# cons arg1=((primitive-ref string->symbol) "fxadd1") arg2=(vector-ref f259505 0)
# emit-expr ((primitive-ref string->symbol) "fxadd1")
# funcall
#    si   =-12
#    env  = ((f259505 . 0))
#    expr = (funcall (primitive-ref string->symbol) "fxadd1")
# emit-expr (primitive-ref string->symbol)
    .extern mrc_string$m$gsymbol
    movl mrc_string$m$gsymbol,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1576765"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1576765":
   movl %eax,  -20(%esp)  # stash funcall-oper in closure slot
# emit-expr "fxadd1"
# string literal
    jmp _L_1576767
    .align 8,0x90
_L_1576766 :
    .int 24
    .ascii "fxadd1"
_L_1576767:
    movl $_L_1576766, %eax
    orl $6, %eax
    mov %eax, -24(%esp)  # arg fxadd1
    movl -20(%esp), %edi   # load new closure to %edi
    add $-12, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $12, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    movl %eax, -12(%esp)
# emit-expr (vector-ref f259505 0)
# emit-expr f259505
# emit-variable-ref
# env=((f259505 . 0))
# var=f259505
    movl 0(%esp), %eax  # stack load f259505
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1576768
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1576768:
    movl %eax, -16(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1576769"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1576769:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1576771
    cmp  $0,%eax
    jge _L_1576770
_L_1576771:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1576770:
    movl -16(%esp), %esi
    movl -1(%eax,%esi), %eax
    movl %eax, 4(%ebp)
    movl -12(%esp), %eax
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    or   $1, %al
    add  $8, %ebp
# cons end
    movl -4(%esp), %ebx
    movl -8(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f259505 0))) (closure () (f259505) (let () (vector-ref f259505 0))))
# emit-begin
#   expr=(begin (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f259505 0))) (closure () (f259505) (let () (vector-ref f259505 0))))
#   env=((f259505 . 0))
# emit-expr (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f259505 0)))
# emit-expr f259505
# emit-variable-ref
# env=((f259505 . 0))
# var=f259505
    movl 0(%esp), %eax  # stack load f259505
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1576772
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1576772:
    movl %eax, -4(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1576773"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1576773:
# check bounds on vector index
    movl -4(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1576775
    cmp  $0,%eax
    jge _L_1576774
_L_1576775:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1576774:
    movl %eax, -8(%esp)
# emit-expr (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f259505 0))
# cons arg1=((primitive-ref string->symbol) "fxlogor") arg2=(vector-ref f259505 0)
# emit-expr ((primitive-ref string->symbol) "fxlogor")
# funcall
#    si   =-12
#    env  = ((f259505 . 0))
#    expr = (funcall (primitive-ref string->symbol) "fxlogor")
# emit-expr (primitive-ref string->symbol)
    .extern mrc_string$m$gsymbol
    movl mrc_string$m$gsymbol,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1576776"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1576776":
   movl %eax,  -20(%esp)  # stash funcall-oper in closure slot
# emit-expr "fxlogor"
# string literal
    jmp _L_1576778
    .align 8,0x90
_L_1576777 :
    .int 28
    .ascii "fxlogor"
_L_1576778:
    movl $_L_1576777, %eax
    orl $6, %eax
    mov %eax, -24(%esp)  # arg fxlogor
    movl -20(%esp), %edi   # load new closure to %edi
    add $-12, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $12, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    movl %eax, -12(%esp)
# emit-expr (vector-ref f259505 0)
# emit-expr f259505
# emit-variable-ref
# env=((f259505 . 0))
# var=f259505
    movl 0(%esp), %eax  # stack load f259505
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1576779
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1576779:
    movl %eax, -16(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1576780"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1576780:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1576782
    cmp  $0,%eax
    jge _L_1576781
_L_1576782:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1576781:
    movl -16(%esp), %esi
    movl -1(%eax,%esi), %eax
    movl %eax, 4(%ebp)
    movl -12(%esp), %eax
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    or   $1, %al
    add  $8, %ebp
# cons end
    movl -4(%esp), %ebx
    movl -8(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f259505 0))) (closure () (f259505) (let () (vector-ref f259505 0))))
# emit-begin
#   expr=(begin (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f259505 0))) (closure () (f259505) (let () (vector-ref f259505 0))))
#   env=((f259505 . 0))
# emit-expr (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f259505 0)))
# emit-expr f259505
# emit-variable-ref
# env=((f259505 . 0))
# var=f259505
    movl 0(%esp), %eax  # stack load f259505
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1576783
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1576783:
    movl %eax, -4(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1576784"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1576784:
# check bounds on vector index
    movl -4(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1576786
    cmp  $0,%eax
    jge _L_1576785
_L_1576786:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1576785:
    movl %eax, -8(%esp)
# emit-expr (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f259505 0))
# cons arg1=((primitive-ref string->symbol) "fxlogand") arg2=(vector-ref f259505 0)
# emit-expr ((primitive-ref string->symbol) "fxlogand")
# funcall
#    si   =-12
#    env  = ((f259505 . 0))
#    expr = (funcall (primitive-ref string->symbol) "fxlogand")
# emit-expr (primitive-ref string->symbol)
    .extern mrc_string$m$gsymbol
    movl mrc_string$m$gsymbol,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1576787"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1576787":
   movl %eax,  -20(%esp)  # stash funcall-oper in closure slot
# emit-expr "fxlogand"
# string literal
    jmp _L_1576789
    .align 8,0x90
_L_1576788 :
    .int 32
    .ascii "fxlogand"
_L_1576789:
    movl $_L_1576788, %eax
    orl $6, %eax
    mov %eax, -24(%esp)  # arg fxlogand
    movl -20(%esp), %edi   # load new closure to %edi
    add $-12, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $12, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    movl %eax, -12(%esp)
# emit-expr (vector-ref f259505 0)
# emit-expr f259505
# emit-variable-ref
# env=((f259505 . 0))
# var=f259505
    movl 0(%esp), %eax  # stack load f259505
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1576790
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1576790:
    movl %eax, -16(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1576791"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1576791:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1576793
    cmp  $0,%eax
    jge _L_1576792
_L_1576793:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1576792:
    movl -16(%esp), %esi
    movl -1(%eax,%esi), %eax
    movl %eax, 4(%ebp)
    movl -12(%esp), %eax
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    or   $1, %al
    add  $8, %ebp
# cons end
    movl -4(%esp), %ebx
    movl -8(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f259505 0))) (closure () (f259505) (let () (vector-ref f259505 0))))
# emit-begin
#   expr=(begin (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f259505 0))) (closure () (f259505) (let () (vector-ref f259505 0))))
#   env=((f259505 . 0))
# emit-expr (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f259505 0)))
# emit-expr f259505
# emit-variable-ref
# env=((f259505 . 0))
# var=f259505
    movl 0(%esp), %eax  # stack load f259505
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1576794
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1576794:
    movl %eax, -4(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1576795"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1576795:
# check bounds on vector index
    movl -4(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1576797
    cmp  $0,%eax
    jge _L_1576796
_L_1576797:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1576796:
    movl %eax, -8(%esp)
# emit-expr (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f259505 0))
# cons arg1=((primitive-ref string->symbol) "fxlognot") arg2=(vector-ref f259505 0)
# emit-expr ((primitive-ref string->symbol) "fxlognot")
# funcall
#    si   =-12
#    env  = ((f259505 . 0))
#    expr = (funcall (primitive-ref string->symbol) "fxlognot")
# emit-expr (primitive-ref string->symbol)
    .extern mrc_string$m$gsymbol
    movl mrc_string$m$gsymbol,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1576798"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1576798":
   movl %eax,  -20(%esp)  # stash funcall-oper in closure slot
# emit-expr "fxlognot"
# string literal
    jmp _L_1576800
    .align 8,0x90
_L_1576799 :
    .int 32
    .ascii "fxlognot"
_L_1576800:
    movl $_L_1576799, %eax
    orl $6, %eax
    mov %eax, -24(%esp)  # arg fxlognot
    movl -20(%esp), %edi   # load new closure to %edi
    add $-12, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $12, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    movl %eax, -12(%esp)
# emit-expr (vector-ref f259505 0)
# emit-expr f259505
# emit-variable-ref
# env=((f259505 . 0))
# var=f259505
    movl 0(%esp), %eax  # stack load f259505
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1576801
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1576801:
    movl %eax, -16(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1576802"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1576802:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1576804
    cmp  $0,%eax
    jge _L_1576803
_L_1576804:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1576803:
    movl -16(%esp), %esi
    movl -1(%eax,%esi), %eax
    movl %eax, 4(%ebp)
    movl -12(%esp), %eax
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    or   $1, %al
    add  $8, %ebp
# cons end
    movl -4(%esp), %ebx
    movl -8(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f259505 0))) (closure () (f259505) (let () (vector-ref f259505 0))))
# emit-begin
#   expr=(begin (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f259505 0))) (closure () (f259505) (let () (vector-ref f259505 0))))
#   env=((f259505 . 0))
# emit-expr (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f259505 0)))
# emit-expr f259505
# emit-variable-ref
# env=((f259505 . 0))
# var=f259505
    movl 0(%esp), %eax  # stack load f259505
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1576805
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1576805:
    movl %eax, -4(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1576806"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1576806:
# check bounds on vector index
    movl -4(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1576808
    cmp  $0,%eax
    jge _L_1576807
_L_1576808:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1576807:
    movl %eax, -8(%esp)
# emit-expr (cons ((primitive-ref string->symbol) "char=?") (vector-ref f259505 0))
# cons arg1=((primitive-ref string->symbol) "char=?") arg2=(vector-ref f259505 0)
# emit-expr ((primitive-ref string->symbol) "char=?")
# funcall
#    si   =-12
#    env  = ((f259505 . 0))
#    expr = (funcall (primitive-ref string->symbol) "char=?")
# emit-expr (primitive-ref string->symbol)
    .extern mrc_string$m$gsymbol
    movl mrc_string$m$gsymbol,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1576809"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1576809":
   movl %eax,  -20(%esp)  # stash funcall-oper in closure slot
# emit-expr "char=?"
# string literal
    jmp _L_1576811
    .align 8,0x90
_L_1576810 :
    .int 24
    .ascii "char=?"
_L_1576811:
    movl $_L_1576810, %eax
    orl $6, %eax
    mov %eax, -24(%esp)  # arg char=?
    movl -20(%esp), %edi   # load new closure to %edi
    add $-12, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $12, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    movl %eax, -12(%esp)
# emit-expr (vector-ref f259505 0)
# emit-expr f259505
# emit-variable-ref
# env=((f259505 . 0))
# var=f259505
    movl 0(%esp), %eax  # stack load f259505
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1576812
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1576812:
    movl %eax, -16(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1576813"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1576813:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1576815
    cmp  $0,%eax
    jge _L_1576814
_L_1576815:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1576814:
    movl -16(%esp), %esi
    movl -1(%eax,%esi), %eax
    movl %eax, 4(%ebp)
    movl -12(%esp), %eax
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    or   $1, %al
    add  $8, %ebp
# cons end
    movl -4(%esp), %ebx
    movl -8(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f259505 0))) (closure () (f259505) (let () (vector-ref f259505 0))))
# emit-begin
#   expr=(begin (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f259505 0))) (closure () (f259505) (let () (vector-ref f259505 0))))
#   env=((f259505 . 0))
# emit-expr (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f259505 0)))
# emit-expr f259505
# emit-variable-ref
# env=((f259505 . 0))
# var=f259505
    movl 0(%esp), %eax  # stack load f259505
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1576816
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1576816:
    movl %eax, -4(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1576817"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1576817:
# check bounds on vector index
    movl -4(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1576819
    cmp  $0,%eax
    jge _L_1576818
_L_1576819:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1576818:
    movl %eax, -8(%esp)
# emit-expr (cons ((primitive-ref string->symbol) "eq?") (vector-ref f259505 0))
# cons arg1=((primitive-ref string->symbol) "eq?") arg2=(vector-ref f259505 0)
# emit-expr ((primitive-ref string->symbol) "eq?")
# funcall
#    si   =-12
#    env  = ((f259505 . 0))
#    expr = (funcall (primitive-ref string->symbol) "eq?")
# emit-expr (primitive-ref string->symbol)
    .extern mrc_string$m$gsymbol
    movl mrc_string$m$gsymbol,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1576820"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1576820":
   movl %eax,  -20(%esp)  # stash funcall-oper in closure slot
# emit-expr "eq?"
# string literal
    jmp _L_1576822
    .align 8,0x90
_L_1576821 :
    .int 12
    .ascii "eq?"
_L_1576822:
    movl $_L_1576821, %eax
    orl $6, %eax
    mov %eax, -24(%esp)  # arg eq?
    movl -20(%esp), %edi   # load new closure to %edi
    add $-12, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $12, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    movl %eax, -12(%esp)
# emit-expr (vector-ref f259505 0)
# emit-expr f259505
# emit-variable-ref
# env=((f259505 . 0))
# var=f259505
    movl 0(%esp), %eax  # stack load f259505
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1576823
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1576823:
    movl %eax, -16(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1576824"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1576824:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1576826
    cmp  $0,%eax
    jge _L_1576825
_L_1576826:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1576825:
    movl -16(%esp), %esi
    movl -1(%eax,%esi), %eax
    movl %eax, 4(%ebp)
    movl -12(%esp), %eax
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    or   $1, %al
    add  $8, %ebp
# cons end
    movl -4(%esp), %ebx
    movl -8(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f259505 0))) (closure () (f259505) (let () (vector-ref f259505 0))))
# emit-begin
#   expr=(begin (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f259505 0))) (closure () (f259505) (let () (vector-ref f259505 0))))
#   env=((f259505 . 0))
# emit-expr (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f259505 0)))
# emit-expr f259505
# emit-variable-ref
# env=((f259505 . 0))
# var=f259505
    movl 0(%esp), %eax  # stack load f259505
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1576827
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1576827:
    movl %eax, -4(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1576828"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1576828:
# check bounds on vector index
    movl -4(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1576830
    cmp  $0,%eax
    jge _L_1576829
_L_1576830:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1576829:
    movl %eax, -8(%esp)
# emit-expr (cons ((primitive-ref string->symbol) "not") (vector-ref f259505 0))
# cons arg1=((primitive-ref string->symbol) "not") arg2=(vector-ref f259505 0)
# emit-expr ((primitive-ref string->symbol) "not")
# funcall
#    si   =-12
#    env  = ((f259505 . 0))
#    expr = (funcall (primitive-ref string->symbol) "not")
# emit-expr (primitive-ref string->symbol)
    .extern mrc_string$m$gsymbol
    movl mrc_string$m$gsymbol,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1576831"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1576831":
   movl %eax,  -20(%esp)  # stash funcall-oper in closure slot
# emit-expr "not"
# string literal
    jmp _L_1576833
    .align 8,0x90
_L_1576832 :
    .int 12
    .ascii "not"
_L_1576833:
    movl $_L_1576832, %eax
    orl $6, %eax
    mov %eax, -24(%esp)  # arg not
    movl -20(%esp), %edi   # load new closure to %edi
    add $-12, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $12, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    movl %eax, -12(%esp)
# emit-expr (vector-ref f259505 0)
# emit-expr f259505
# emit-variable-ref
# env=((f259505 . 0))
# var=f259505
    movl 0(%esp), %eax  # stack load f259505
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1576834
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1576834:
    movl %eax, -16(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1576835"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1576835:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1576837
    cmp  $0,%eax
    jge _L_1576836
_L_1576837:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1576836:
    movl -16(%esp), %esi
    movl -1(%eax,%esi), %eax
    movl %eax, 4(%ebp)
    movl -12(%esp), %eax
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    or   $1, %al
    add  $8, %ebp
# cons end
    movl -4(%esp), %ebx
    movl -8(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f259505 0))) (closure () (f259505) (let () (vector-ref f259505 0))))
# emit-begin
#   expr=(begin (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f259505 0))) (closure () (f259505) (let () (vector-ref f259505 0))))
#   env=((f259505 . 0))
# emit-expr (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f259505 0)))
# emit-expr f259505
# emit-variable-ref
# env=((f259505 . 0))
# var=f259505
    movl 0(%esp), %eax  # stack load f259505
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1576838
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1576838:
    movl %eax, -4(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1576839"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1576839:
# check bounds on vector index
    movl -4(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1576841
    cmp  $0,%eax
    jge _L_1576840
_L_1576841:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1576840:
    movl %eax, -8(%esp)
# emit-expr (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f259505 0))
# cons arg1=((primitive-ref string->symbol) "boolean?") arg2=(vector-ref f259505 0)
# emit-expr ((primitive-ref string->symbol) "boolean?")
# funcall
#    si   =-12
#    env  = ((f259505 . 0))
#    expr = (funcall (primitive-ref string->symbol) "boolean?")
# emit-expr (primitive-ref string->symbol)
    .extern mrc_string$m$gsymbol
    movl mrc_string$m$gsymbol,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1576842"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1576842":
   movl %eax,  -20(%esp)  # stash funcall-oper in closure slot
# emit-expr "boolean?"
# string literal
    jmp _L_1576844
    .align 8,0x90
_L_1576843 :
    .int 32
    .ascii "boolean?"
_L_1576844:
    movl $_L_1576843, %eax
    orl $6, %eax
    mov %eax, -24(%esp)  # arg boolean?
    movl -20(%esp), %edi   # load new closure to %edi
    add $-12, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $12, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    movl %eax, -12(%esp)
# emit-expr (vector-ref f259505 0)
# emit-expr f259505
# emit-variable-ref
# env=((f259505 . 0))
# var=f259505
    movl 0(%esp), %eax  # stack load f259505
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1576845
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1576845:
    movl %eax, -16(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1576846"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1576846:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1576848
    cmp  $0,%eax
    jge _L_1576847
_L_1576848:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1576847:
    movl -16(%esp), %esi
    movl -1(%eax,%esi), %eax
    movl %eax, 4(%ebp)
    movl -12(%esp), %eax
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    or   $1, %al
    add  $8, %ebp
# cons end
    movl -4(%esp), %ebx
    movl -8(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f259505 0))) (closure () (f259505) (let () (vector-ref f259505 0))))
# emit-begin
#   expr=(begin (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f259505 0))) (closure () (f259505) (let () (vector-ref f259505 0))))
#   env=((f259505 . 0))
# emit-expr (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f259505 0)))
# emit-expr f259505
# emit-variable-ref
# env=((f259505 . 0))
# var=f259505
    movl 0(%esp), %eax  # stack load f259505
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1576849
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1576849:
    movl %eax, -4(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1576850"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1576850:
# check bounds on vector index
    movl -4(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1576852
    cmp  $0,%eax
    jge _L_1576851
_L_1576852:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1576851:
    movl %eax, -8(%esp)
# emit-expr (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f259505 0))
# cons arg1=((primitive-ref string->symbol) "fixnum?") arg2=(vector-ref f259505 0)
# emit-expr ((primitive-ref string->symbol) "fixnum?")
# funcall
#    si   =-12
#    env  = ((f259505 . 0))
#    expr = (funcall (primitive-ref string->symbol) "fixnum?")
# emit-expr (primitive-ref string->symbol)
    .extern mrc_string$m$gsymbol
    movl mrc_string$m$gsymbol,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1576853"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1576853":
   movl %eax,  -20(%esp)  # stash funcall-oper in closure slot
# emit-expr "fixnum?"
# string literal
    jmp _L_1576855
    .align 8,0x90
_L_1576854 :
    .int 28
    .ascii "fixnum?"
_L_1576855:
    movl $_L_1576854, %eax
    orl $6, %eax
    mov %eax, -24(%esp)  # arg fixnum?
    movl -20(%esp), %edi   # load new closure to %edi
    add $-12, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $12, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    movl %eax, -12(%esp)
# emit-expr (vector-ref f259505 0)
# emit-expr f259505
# emit-variable-ref
# env=((f259505 . 0))
# var=f259505
    movl 0(%esp), %eax  # stack load f259505
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1576856
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1576856:
    movl %eax, -16(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1576857"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1576857:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1576859
    cmp  $0,%eax
    jge _L_1576858
_L_1576859:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1576858:
    movl -16(%esp), %esi
    movl -1(%eax,%esi), %eax
    movl %eax, 4(%ebp)
    movl -12(%esp), %eax
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    or   $1, %al
    add  $8, %ebp
# cons end
    movl -4(%esp), %ebx
    movl -8(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f259505 0))) (closure () (f259505) (let () (vector-ref f259505 0))))
# emit-begin
#   expr=(begin (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f259505 0))) (closure () (f259505) (let () (vector-ref f259505 0))))
#   env=((f259505 . 0))
# emit-expr (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f259505 0)))
# emit-expr f259505
# emit-variable-ref
# env=((f259505 . 0))
# var=f259505
    movl 0(%esp), %eax  # stack load f259505
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1576860
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1576860:
    movl %eax, -4(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1576861"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1576861:
# check bounds on vector index
    movl -4(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1576863
    cmp  $0,%eax
    jge _L_1576862
_L_1576863:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1576862:
    movl %eax, -8(%esp)
# emit-expr (cons ((primitive-ref string->symbol) "char?") (vector-ref f259505 0))
# cons arg1=((primitive-ref string->symbol) "char?") arg2=(vector-ref f259505 0)
# emit-expr ((primitive-ref string->symbol) "char?")
# funcall
#    si   =-12
#    env  = ((f259505 . 0))
#    expr = (funcall (primitive-ref string->symbol) "char?")
# emit-expr (primitive-ref string->symbol)
    .extern mrc_string$m$gsymbol
    movl mrc_string$m$gsymbol,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1576864"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1576864":
   movl %eax,  -20(%esp)  # stash funcall-oper in closure slot
# emit-expr "char?"
# string literal
    jmp _L_1576866
    .align 8,0x90
_L_1576865 :
    .int 20
    .ascii "char?"
_L_1576866:
    movl $_L_1576865, %eax
    orl $6, %eax
    mov %eax, -24(%esp)  # arg char?
    movl -20(%esp), %edi   # load new closure to %edi
    add $-12, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $12, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    movl %eax, -12(%esp)
# emit-expr (vector-ref f259505 0)
# emit-expr f259505
# emit-variable-ref
# env=((f259505 . 0))
# var=f259505
    movl 0(%esp), %eax  # stack load f259505
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1576867
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1576867:
    movl %eax, -16(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1576868"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1576868:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1576870
    cmp  $0,%eax
    jge _L_1576869
_L_1576870:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1576869:
    movl -16(%esp), %esi
    movl -1(%eax,%esi), %eax
    movl %eax, 4(%ebp)
    movl -12(%esp), %eax
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    or   $1, %al
    add  $8, %ebp
# cons end
    movl -4(%esp), %ebx
    movl -8(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f259505 0))) (closure () (f259505) (let () (vector-ref f259505 0))))
# emit-begin
#   expr=(begin (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f259505 0))) (closure () (f259505) (let () (vector-ref f259505 0))))
#   env=((f259505 . 0))
# emit-expr (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f259505 0)))
# emit-expr f259505
# emit-variable-ref
# env=((f259505 . 0))
# var=f259505
    movl 0(%esp), %eax  # stack load f259505
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1576871
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1576871:
    movl %eax, -4(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1576872"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1576872:
# check bounds on vector index
    movl -4(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1576874
    cmp  $0,%eax
    jge _L_1576873
_L_1576874:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1576873:
    movl %eax, -8(%esp)
# emit-expr (cons ((primitive-ref string->symbol) "null?") (vector-ref f259505 0))
# cons arg1=((primitive-ref string->symbol) "null?") arg2=(vector-ref f259505 0)
# emit-expr ((primitive-ref string->symbol) "null?")
# funcall
#    si   =-12
#    env  = ((f259505 . 0))
#    expr = (funcall (primitive-ref string->symbol) "null?")
# emit-expr (primitive-ref string->symbol)
    .extern mrc_string$m$gsymbol
    movl mrc_string$m$gsymbol,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1576875"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1576875":
   movl %eax,  -20(%esp)  # stash funcall-oper in closure slot
# emit-expr "null?"
# string literal
    jmp _L_1576877
    .align 8,0x90
_L_1576876 :
    .int 20
    .ascii "null?"
_L_1576877:
    movl $_L_1576876, %eax
    orl $6, %eax
    mov %eax, -24(%esp)  # arg null?
    movl -20(%esp), %edi   # load new closure to %edi
    add $-12, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $12, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    movl %eax, -12(%esp)
# emit-expr (vector-ref f259505 0)
# emit-expr f259505
# emit-variable-ref
# env=((f259505 . 0))
# var=f259505
    movl 0(%esp), %eax  # stack load f259505
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1576878
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1576878:
    movl %eax, -16(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1576879"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1576879:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1576881
    cmp  $0,%eax
    jge _L_1576880
_L_1576881:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1576880:
    movl -16(%esp), %esi
    movl -1(%eax,%esi), %eax
    movl %eax, 4(%ebp)
    movl -12(%esp), %eax
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    or   $1, %al
    add  $8, %ebp
# cons end
    movl -4(%esp), %ebx
    movl -8(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f259505 0))) (closure () (f259505) (let () (vector-ref f259505 0))))
# emit-begin
#   expr=(begin (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f259505 0))) (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f259505 0))) (closure () (f259505) (let () (vector-ref f259505 0))))
#   env=((f259505 . 0))
# emit-expr (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f259505 0)))
# emit-expr f259505
# emit-variable-ref
# env=((f259505 . 0))
# var=f259505
    movl 0(%esp), %eax  # stack load f259505
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1576882
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1576882:
    movl %eax, -4(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1576883"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1576883:
# check bounds on vector index
    movl -4(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1576885
    cmp  $0,%eax
    jge _L_1576884
_L_1576885:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1576884:
    movl %eax, -8(%esp)
# emit-expr (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f259505 0))
# cons arg1=((primitive-ref string->symbol) "char->fixnum") arg2=(vector-ref f259505 0)
# emit-expr ((primitive-ref string->symbol) "char->fixnum")
# funcall
#    si   =-12
#    env  = ((f259505 . 0))
#    expr = (funcall (primitive-ref string->symbol) "char->fixnum")
# emit-expr (primitive-ref string->symbol)
    .extern mrc_string$m$gsymbol
    movl mrc_string$m$gsymbol,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1576886"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1576886":
   movl %eax,  -20(%esp)  # stash funcall-oper in closure slot
# emit-expr "char->fixnum"
# string literal
    jmp _L_1576888
    .align 8,0x90
_L_1576887 :
    .int 48
    .ascii "char->fixnum"
_L_1576888:
    movl $_L_1576887, %eax
    orl $6, %eax
    mov %eax, -24(%esp)  # arg char->fixnum
    movl -20(%esp), %edi   # load new closure to %edi
    add $-12, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $12, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    movl %eax, -12(%esp)
# emit-expr (vector-ref f259505 0)
# emit-expr f259505
# emit-variable-ref
# env=((f259505 . 0))
# var=f259505
    movl 0(%esp), %eax  # stack load f259505
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1576889
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1576889:
    movl %eax, -16(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1576890"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1576890:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1576892
    cmp  $0,%eax
    jge _L_1576891
_L_1576892:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1576891:
    movl -16(%esp), %esi
    movl -1(%eax,%esi), %eax
    movl %eax, 4(%ebp)
    movl -12(%esp), %eax
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    or   $1, %al
    add  $8, %ebp
# cons end
    movl -4(%esp), %ebx
    movl -8(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f259505 0))) (closure () (f259505) (let () (vector-ref f259505 0))))
# emit-begin
#   expr=(begin (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f259505 0))) (closure () (f259505) (let () (vector-ref f259505 0))))
#   env=((f259505 . 0))
# emit-expr (vector-set! f259505 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f259505 0)))
# emit-expr f259505
# emit-variable-ref
# env=((f259505 . 0))
# var=f259505
    movl 0(%esp), %eax  # stack load f259505
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1576893
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1576893:
    movl %eax, -4(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1576894"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1576894:
# check bounds on vector index
    movl -4(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1576896
    cmp  $0,%eax
    jge _L_1576895
_L_1576896:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1576895:
    movl %eax, -8(%esp)
# emit-expr (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f259505 0))
# cons arg1=((primitive-ref string->symbol) "fixnum->char") arg2=(vector-ref f259505 0)
# emit-expr ((primitive-ref string->symbol) "fixnum->char")
# funcall
#    si   =-12
#    env  = ((f259505 . 0))
#    expr = (funcall (primitive-ref string->symbol) "fixnum->char")
# emit-expr (primitive-ref string->symbol)
    .extern mrc_string$m$gsymbol
    movl mrc_string$m$gsymbol,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1576897"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1576897":
   movl %eax,  -20(%esp)  # stash funcall-oper in closure slot
# emit-expr "fixnum->char"
# string literal
    jmp _L_1576899
    .align 8,0x90
_L_1576898 :
    .int 48
    .ascii "fixnum->char"
_L_1576899:
    movl $_L_1576898, %eax
    orl $6, %eax
    mov %eax, -24(%esp)  # arg fixnum->char
    movl -20(%esp), %edi   # load new closure to %edi
    add $-12, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $12, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    movl %eax, -12(%esp)
# emit-expr (vector-ref f259505 0)
# emit-expr f259505
# emit-variable-ref
# env=((f259505 . 0))
# var=f259505
    movl 0(%esp), %eax  # stack load f259505
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1576900
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1576900:
    movl %eax, -16(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1576901"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1576901:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1576903
    cmp  $0,%eax
    jge _L_1576902
_L_1576903:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1576902:
    movl -16(%esp), %esi
    movl -1(%eax,%esi), %eax
    movl %eax, 4(%ebp)
    movl -12(%esp), %eax
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    or   $1, %al
    add  $8, %ebp
# cons end
    movl -4(%esp), %ebx
    movl -8(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin (closure () (f259505) (let () (vector-ref f259505 0))))
# emit-begin
#   expr=(begin (closure () (f259505) (let () (vector-ref f259505 0))))
#   env=((f259505 . 0))
# emit-expr (closure () (f259505) (let () (vector-ref f259505 0)))
# emit-closure
# si = -4
# env = ((f259505 . 0))
# expr = (closure () (f259505) (let () (vector-ref f259505 0)))
    movl $_L_1576904, 0(%ebp)  # closure label
# emit-variable-ref
# env=((f259505 . 0))
# var=f259505
    movl 0(%esp), %eax  # stack load f259505
# end emit-variable-ref
   movl  %eax, 4(%ebp)  # f259505
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $8, %ebp     # bump ebp
    jmp _L_1576905            # jump around closure body
_L_1576904:
# check argument count
    cmp $0,%eax
    je _L_1576906
# invoke error handler eh_argcount
    .extern mrc_eh$uargcount
    movl mrc_eh$uargcount, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_1576906:
# emit-tail-expr
# si=-8
# env=((f259505 . 4) (f259505 . 0))
# expr=(let () (vector-ref f259505 0))
# emit-tail-let
#  si   = -8
#  env  = ((f259505 . 4) (f259505 . 0))
#  bindings = ()
#  body = (vector-ref f259505 0)
# emit-tail-expr
# si=-8
# env=((f259505 . 4) (f259505 . 0))
# expr=(vector-ref f259505 0)
# tail primcall
# emit-expr f259505
# emit-variable-ref
# env=((f259505 . 4) (f259505 . 0))
# var=f259505
    movl 2(%edi), %eax  # frame load f259505
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1576907
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1576907:
    movl %eax, -8(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1576908"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1576908:
# check bounds on vector index
    movl -8(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1576910
    cmp  $0,%eax
    jge _L_1576909
_L_1576910:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1576909:
    movl -8(%esp), %esi
    movl -1(%eax,%esi), %eax
#return from tail (vector-ref f259505 0)
    ret
    .align 4,0x90
_L_1576905:
# emit-expr (begin)
# emit-begin
#   expr=(begin)
#   env=((f259505 . 0))
     movl %eax, mrc_primitives
# == explicit-begins  ==>
# (lambda () (error (quote funcall) "arg 1 must be a procedure"))
# == eliminate-let*  ==>
# (lambda () (error (quote funcall) "arg 1 must be a procedure"))
# == uniquify-variables  ==>
# (lambda () (error (quote funcall) "arg 1 must be a procedure"))
# == vectorize-letrec  ==>
# (lambda () (error (quote funcall) "arg 1 must be a procedure"))
# == eliminate-set!  ==>
# (lambda () (let () (error (quote funcall) "arg 1 must be a procedure")))
# == close-free-variables  ==>
# (closure () (error funcall) (let () (error (quote funcall) "arg 1 must be a procedure")))
# == eliminate-quote  ==>
# (closure () (error funcall) (let () (error (string->symbol "funcall") "arg 1 must be a procedure")))
# == eliminate-when/unless  ==>
# (closure () (error funcall) (let () (error (string->symbol "funcall") "arg 1 must be a procedure")))
# == eliminate-cond  ==>
# (closure () (error funcall) (let () (error (string->symbol "funcall") "arg 1 must be a procedure")))
# == external-symbols  ==>
# (closure () ((primitive-ref error) funcall) (let () ((primitive-ref error) ((primitive-ref string->symbol) "funcall") "arg 1 must be a procedure")))
# emit-expr (closure () ((primitive-ref error) funcall) (let () ((primitive-ref error) ((primitive-ref string->symbol) "funcall") "arg 1 must be a procedure")))
# emit-closure
# si = 0
# env = ()
# expr = (closure () ((primitive-ref error) funcall) (let () ((primitive-ref error) ((primitive-ref string->symbol) "funcall") "arg 1 must be a procedure")))
    movl $_L_1576911, 0(%ebp)  # closure label
# WARNING: free var (primitive-ref error) not defined in the environmnet
# WARNING: free var funcall not defined in the environmnet
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $16, %ebp     # bump ebp
    jmp _L_1576912            # jump around closure body
_L_1576911:
# check argument count
    cmp $0,%eax
    je _L_1576913
# invoke error handler eh_argcount
    .extern mrc_eh$uargcount
    movl mrc_eh$uargcount, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_1576913:
# emit-tail-expr
# si=-8
# env=((funcall . 8) ((primitive-ref error) . 4))
# expr=(let () ((primitive-ref error) ((primitive-ref string->symbol) "funcall") "arg 1 must be a procedure"))
# emit-tail-let
#  si   = -8
#  env  = ((funcall . 8) ((primitive-ref error) . 4))
#  bindings = ()
#  body = ((primitive-ref error) ((primitive-ref string->symbol) "funcall") "arg 1 must be a procedure")
# emit-tail-expr
# si=-8
# env=((funcall . 8) ((primitive-ref error) . 4))
# expr=((primitive-ref error) ((primitive-ref string->symbol) "funcall") "arg 1 must be a procedure")
# emit-tail-funcall
#    si   =-8
#    env  = ((funcall . 8) ((primitive-ref error) . 4))
#    expr = (funcall (primitive-ref error) ((primitive-ref string->symbol) "funcall") "arg 1 must be a procedure")
# emit-expr (primitive-ref error)
    .extern mrc_error
    movl mrc_error,%eax
   movl %eax,  -8(%esp)  # stash funcall-oper in next closure slot
# emit-expr ((primitive-ref string->symbol) "funcall")
# funcall
#    si   =-12
#    env  = ((funcall . 8) ((primitive-ref error) . 4))
#    expr = (funcall (primitive-ref string->symbol) "funcall")
# emit-expr (primitive-ref string->symbol)
    .extern mrc_string$m$gsymbol
    movl mrc_string$m$gsymbol,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1576914"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1576914":
   movl %eax,  -20(%esp)  # stash funcall-oper in closure slot
# emit-expr "funcall"
# string literal
    jmp _L_1576916
    .align 8,0x90
_L_1576915 :
    .int 28
    .ascii "funcall"
_L_1576916:
    movl $_L_1576915, %eax
    orl $6, %eax
    mov %eax, -24(%esp)  # arg funcall
    movl -20(%esp), %edi   # load new closure to %edi
    add $-12, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $12, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    mov %eax, -12(%esp)    # arg ((primitive-ref string->symbol) funcall)
# emit-expr "arg 1 must be a procedure"
# string literal
    jmp _L_1576918
    .align 8,0x90
_L_1576917 :
    .int 100
    .ascii "arg 1 must be a procedure"
_L_1576918:
    movl $_L_1576917, %eax
    orl $6, %eax
    mov %eax, -16(%esp)    # arg arg 1 must be a procedure
    movl -8(%esp), %edi   # load new closure to %edi
# emit-shift-args:  size=3   si=-8  delta=4
    mov -8(%esp), %ebx  # shift frame cell
    mov %ebx, -4(%esp)  # down to base
# emit-shift-args:  size=2   si=-12  delta=4
    mov -12(%esp), %ebx  # shift frame cell
    mov %ebx, -8(%esp)  # down to base
# emit-shift-args:  size=1   si=-16  delta=4
    mov -16(%esp), %ebx  # shift frame cell
    mov %ebx, -12(%esp)  # down to base
# emit-shift-args:  size=0   si=-20  delta=4
    movl $8,%eax   # save arg count
    jmp *-2(%edi)  # tail-funcall
    .align 4,0x90
_L_1576912:
     movl %eax, mrc_eh$uprocedure
# == explicit-begins  ==>
# (lambda () (error (quote funcall) "wrong number of args"))
# == eliminate-let*  ==>
# (lambda () (error (quote funcall) "wrong number of args"))
# == uniquify-variables  ==>
# (lambda () (error (quote funcall) "wrong number of args"))
# == vectorize-letrec  ==>
# (lambda () (error (quote funcall) "wrong number of args"))
# == eliminate-set!  ==>
# (lambda () (let () (error (quote funcall) "wrong number of args")))
# == close-free-variables  ==>
# (closure () (error funcall) (let () (error (quote funcall) "wrong number of args")))
# == eliminate-quote  ==>
# (closure () (error funcall) (let () (error (string->symbol "funcall") "wrong number of args")))
# == eliminate-when/unless  ==>
# (closure () (error funcall) (let () (error (string->symbol "funcall") "wrong number of args")))
# == eliminate-cond  ==>
# (closure () (error funcall) (let () (error (string->symbol "funcall") "wrong number of args")))
# == external-symbols  ==>
# (closure () ((primitive-ref error) funcall) (let () ((primitive-ref error) ((primitive-ref string->symbol) "funcall") "wrong number of args")))
# emit-expr (closure () ((primitive-ref error) funcall) (let () ((primitive-ref error) ((primitive-ref string->symbol) "funcall") "wrong number of args")))
# emit-closure
# si = 0
# env = ()
# expr = (closure () ((primitive-ref error) funcall) (let () ((primitive-ref error) ((primitive-ref string->symbol) "funcall") "wrong number of args")))
    movl $_L_1576919, 0(%ebp)  # closure label
# WARNING: free var (primitive-ref error) not defined in the environmnet
# WARNING: free var funcall not defined in the environmnet
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $16, %ebp     # bump ebp
    jmp _L_1576920            # jump around closure body
_L_1576919:
# check argument count
    cmp $0,%eax
    je _L_1576921
# invoke error handler eh_argcount
    .extern mrc_eh$uargcount
    movl mrc_eh$uargcount, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_1576921:
# emit-tail-expr
# si=-8
# env=((funcall . 8) ((primitive-ref error) . 4))
# expr=(let () ((primitive-ref error) ((primitive-ref string->symbol) "funcall") "wrong number of args"))
# emit-tail-let
#  si   = -8
#  env  = ((funcall . 8) ((primitive-ref error) . 4))
#  bindings = ()
#  body = ((primitive-ref error) ((primitive-ref string->symbol) "funcall") "wrong number of args")
# emit-tail-expr
# si=-8
# env=((funcall . 8) ((primitive-ref error) . 4))
# expr=((primitive-ref error) ((primitive-ref string->symbol) "funcall") "wrong number of args")
# emit-tail-funcall
#    si   =-8
#    env  = ((funcall . 8) ((primitive-ref error) . 4))
#    expr = (funcall (primitive-ref error) ((primitive-ref string->symbol) "funcall") "wrong number of args")
# emit-expr (primitive-ref error)
    .extern mrc_error
    movl mrc_error,%eax
   movl %eax,  -8(%esp)  # stash funcall-oper in next closure slot
# emit-expr ((primitive-ref string->symbol) "funcall")
# funcall
#    si   =-12
#    env  = ((funcall . 8) ((primitive-ref error) . 4))
#    expr = (funcall (primitive-ref string->symbol) "funcall")
# emit-expr (primitive-ref string->symbol)
    .extern mrc_string$m$gsymbol
    movl mrc_string$m$gsymbol,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1576922"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1576922":
   movl %eax,  -20(%esp)  # stash funcall-oper in closure slot
# emit-expr "funcall"
# string literal
    jmp _L_1576924
    .align 8,0x90
_L_1576923 :
    .int 28
    .ascii "funcall"
_L_1576924:
    movl $_L_1576923, %eax
    orl $6, %eax
    mov %eax, -24(%esp)  # arg funcall
    movl -20(%esp), %edi   # load new closure to %edi
    add $-12, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $12, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    mov %eax, -12(%esp)    # arg ((primitive-ref string->symbol) funcall)
# emit-expr "wrong number of args"
# string literal
    jmp _L_1576926
    .align 8,0x90
_L_1576925 :
    .int 80
    .ascii "wrong number of args"
_L_1576926:
    movl $_L_1576925, %eax
    orl $6, %eax
    mov %eax, -16(%esp)    # arg wrong number of args
    movl -8(%esp), %edi   # load new closure to %edi
# emit-shift-args:  size=3   si=-8  delta=4
    mov -8(%esp), %ebx  # shift frame cell
    mov %ebx, -4(%esp)  # down to base
# emit-shift-args:  size=2   si=-12  delta=4
    mov -12(%esp), %ebx  # shift frame cell
    mov %ebx, -8(%esp)  # down to base
# emit-shift-args:  size=1   si=-16  delta=4
    mov -16(%esp), %ebx  # shift frame cell
    mov %ebx, -12(%esp)  # down to base
# emit-shift-args:  size=0   si=-20  delta=4
    movl $8,%eax   # save arg count
    jmp *-2(%edi)  # tail-funcall
    .align 4,0x90
_L_1576920:
     movl %eax, mrc_eh$uargcount
# == explicit-begins  ==>
# (lambda () (error (quote funcall) "too few args"))
# == eliminate-let*  ==>
# (lambda () (error (quote funcall) "too few args"))
# == uniquify-variables  ==>
# (lambda () (error (quote funcall) "too few args"))
# == vectorize-letrec  ==>
# (lambda () (error (quote funcall) "too few args"))
# == eliminate-set!  ==>
# (lambda () (let () (error (quote funcall) "too few args")))
# == close-free-variables  ==>
# (closure () (error funcall) (let () (error (quote funcall) "too few args")))
# == eliminate-quote  ==>
# (closure () (error funcall) (let () (error (string->symbol "funcall") "too few args")))
# == eliminate-when/unless  ==>
# (closure () (error funcall) (let () (error (string->symbol "funcall") "too few args")))
# == eliminate-cond  ==>
# (closure () (error funcall) (let () (error (string->symbol "funcall") "too few args")))
# == external-symbols  ==>
# (closure () ((primitive-ref error) funcall) (let () ((primitive-ref error) ((primitive-ref string->symbol) "funcall") "too few args")))
# emit-expr (closure () ((primitive-ref error) funcall) (let () ((primitive-ref error) ((primitive-ref string->symbol) "funcall") "too few args")))
# emit-closure
# si = 0
# env = ()
# expr = (closure () ((primitive-ref error) funcall) (let () ((primitive-ref error) ((primitive-ref string->symbol) "funcall") "too few args")))
    movl $_L_1576927, 0(%ebp)  # closure label
# WARNING: free var (primitive-ref error) not defined in the environmnet
# WARNING: free var funcall not defined in the environmnet
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $16, %ebp     # bump ebp
    jmp _L_1576928            # jump around closure body
_L_1576927:
# check argument count
    cmp $0,%eax
    je _L_1576929
# invoke error handler eh_argcount
    .extern mrc_eh$uargcount
    movl mrc_eh$uargcount, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_1576929:
# emit-tail-expr
# si=-8
# env=((funcall . 8) ((primitive-ref error) . 4))
# expr=(let () ((primitive-ref error) ((primitive-ref string->symbol) "funcall") "too few args"))
# emit-tail-let
#  si   = -8
#  env  = ((funcall . 8) ((primitive-ref error) . 4))
#  bindings = ()
#  body = ((primitive-ref error) ((primitive-ref string->symbol) "funcall") "too few args")
# emit-tail-expr
# si=-8
# env=((funcall . 8) ((primitive-ref error) . 4))
# expr=((primitive-ref error) ((primitive-ref string->symbol) "funcall") "too few args")
# emit-tail-funcall
#    si   =-8
#    env  = ((funcall . 8) ((primitive-ref error) . 4))
#    expr = (funcall (primitive-ref error) ((primitive-ref string->symbol) "funcall") "too few args")
# emit-expr (primitive-ref error)
    .extern mrc_error
    movl mrc_error,%eax
   movl %eax,  -8(%esp)  # stash funcall-oper in next closure slot
# emit-expr ((primitive-ref string->symbol) "funcall")
# funcall
#    si   =-12
#    env  = ((funcall . 8) ((primitive-ref error) . 4))
#    expr = (funcall (primitive-ref string->symbol) "funcall")
# emit-expr (primitive-ref string->symbol)
    .extern mrc_string$m$gsymbol
    movl mrc_string$m$gsymbol,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1576930"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1576930":
   movl %eax,  -20(%esp)  # stash funcall-oper in closure slot
# emit-expr "funcall"
# string literal
    jmp _L_1576932
    .align 8,0x90
_L_1576931 :
    .int 28
    .ascii "funcall"
_L_1576932:
    movl $_L_1576931, %eax
    orl $6, %eax
    mov %eax, -24(%esp)  # arg funcall
    movl -20(%esp), %edi   # load new closure to %edi
    add $-12, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $12, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    mov %eax, -12(%esp)    # arg ((primitive-ref string->symbol) funcall)
# emit-expr "too few args"
# string literal
    jmp _L_1576934
    .align 8,0x90
_L_1576933 :
    .int 48
    .ascii "too few args"
_L_1576934:
    movl $_L_1576933, %eax
    orl $6, %eax
    mov %eax, -16(%esp)    # arg too few args
    movl -8(%esp), %edi   # load new closure to %edi
# emit-shift-args:  size=3   si=-8  delta=4
    mov -8(%esp), %ebx  # shift frame cell
    mov %ebx, -4(%esp)  # down to base
# emit-shift-args:  size=2   si=-12  delta=4
    mov -12(%esp), %ebx  # shift frame cell
    mov %ebx, -8(%esp)  # down to base
# emit-shift-args:  size=1   si=-16  delta=4
    mov -16(%esp), %ebx  # shift frame cell
    mov %ebx, -12(%esp)  # down to base
# emit-shift-args:  size=0   si=-20  delta=4
    movl $8,%eax   # save arg count
    jmp *-2(%edi)  # tail-funcall
    .align 4,0x90
_L_1576928:
     movl %eax, mrc_eh$uargcount$umin
# == explicit-begins  ==>
# (lambda (i) (error (list-ref (primitives) i) "arg must be a fixnum"))
# == eliminate-let*  ==>
# (lambda (i) (error (list-ref (primitives) i) "arg must be a fixnum"))
# == uniquify-variables  ==>
# (lambda (f259506) (error (list-ref (primitives) f259506) "arg must be a fixnum"))
# == vectorize-letrec  ==>
# (lambda (f259506) (error (list-ref (primitives) f259506) "arg must be a fixnum"))
# == eliminate-set!  ==>
# (lambda (f259506) (let ((f259506 f259506)) (error (list-ref (primitives) f259506) "arg must be a fixnum")))
# == close-free-variables  ==>
# (closure (f259506) (error list-ref primitives) (let ((f259506 f259506)) (error (list-ref (primitives) f259506) "arg must be a fixnum")))
# == eliminate-quote  ==>
# (closure (f259506) (error list-ref primitives) (let ((f259506 f259506)) (error (list-ref (primitives) f259506) "arg must be a fixnum")))
# == eliminate-when/unless  ==>
# (closure (f259506) (error list-ref primitives) (let ((f259506 f259506)) (error (list-ref (primitives) f259506) "arg must be a fixnum")))
# == eliminate-cond  ==>
# (closure (f259506) (error list-ref primitives) (let ((f259506 f259506)) (error (list-ref (primitives) f259506) "arg must be a fixnum")))
# == external-symbols  ==>
# (closure (f259506) ((primitive-ref error) (primitive-ref list-ref) (primitive-ref primitives)) (let ((f259506 f259506)) ((primitive-ref error) ((primitive-ref list-ref) ((primitive-ref primitives)) f259506) "arg must be a fixnum")))
# emit-expr (closure (f259506) ((primitive-ref error) (primitive-ref list-ref) (primitive-ref primitives)) (let ((f259506 f259506)) ((primitive-ref error) ((primitive-ref list-ref) ((primitive-ref primitives)) f259506) "arg must be a fixnum")))
# emit-closure
# si = 0
# env = ()
# expr = (closure (f259506) ((primitive-ref error) (primitive-ref list-ref) (primitive-ref primitives)) (let ((f259506 f259506)) ((primitive-ref error) ((primitive-ref list-ref) ((primitive-ref primitives)) f259506) "arg must be a fixnum")))
    movl $_L_1576935, 0(%ebp)  # closure label
# WARNING: free var (primitive-ref error) not defined in the environmnet
# WARNING: free var (primitive-ref list-ref) not defined in the environmnet
# WARNING: free var (primitive-ref primitives) not defined in the environmnet
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $16, %ebp     # bump ebp
    jmp _L_1576936            # jump around closure body
_L_1576935:
# check argument count
    cmp $4,%eax
    je _L_1576937
# invoke error handler eh_argcount
    .extern mrc_eh$uargcount
    movl mrc_eh$uargcount, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_1576937:
# emit-tail-expr
# si=-12
# env=((f259506 . -8) ((primitive-ref primitives) . 12) ((primitive-ref list-ref) . 8) ((primitive-ref error) . 4))
# expr=(let ((f259506 f259506)) ((primitive-ref error) ((primitive-ref list-ref) ((primitive-ref primitives)) f259506) "arg must be a fixnum"))
# emit-tail-let
#  si   = -12
#  env  = ((f259506 . -8) ((primitive-ref primitives) . 12) ((primitive-ref list-ref) . 8) ((primitive-ref error) . 4))
#  bindings = ((f259506 f259506))
#  body = ((primitive-ref error) ((primitive-ref list-ref) ((primitive-ref primitives)) f259506) "arg must be a fixnum")
# emit-expr f259506
# emit-variable-ref
# env=((f259506 . -8) ((primitive-ref primitives) . 12) ((primitive-ref list-ref) . 8) ((primitive-ref error) . 4))
# var=f259506
    movl -8(%esp), %eax  # stack load f259506
# end emit-variable-ref
    movl %eax, -12(%esp)  # stack save
# emit-tail-expr
# si=-16
# env=((f259506 . -12) (f259506 . -8) ((primitive-ref primitives) . 12) ((primitive-ref list-ref) . 8) ((primitive-ref error) . 4))
# expr=((primitive-ref error) ((primitive-ref list-ref) ((primitive-ref primitives)) f259506) "arg must be a fixnum")
# emit-tail-funcall
#    si   =-16
#    env  = ((f259506 . -12) (f259506 . -8) ((primitive-ref primitives) . 12) ((primitive-ref list-ref) . 8) ((primitive-ref error) . 4))
#    expr = (funcall (primitive-ref error) ((primitive-ref list-ref) ((primitive-ref primitives)) f259506) "arg must be a fixnum")
# emit-expr (primitive-ref error)
    .extern mrc_error
    movl mrc_error,%eax
   movl %eax,  -16(%esp)  # stash funcall-oper in next closure slot
# emit-expr ((primitive-ref list-ref) ((primitive-ref primitives)) f259506)
# funcall
#    si   =-20
#    env  = ((f259506 . -12) (f259506 . -8) ((primitive-ref primitives) . 12) ((primitive-ref list-ref) . 8) ((primitive-ref error) . 4))
#    expr = (funcall (primitive-ref list-ref) ((primitive-ref primitives)) f259506)
# emit-expr (primitive-ref list-ref)
    .extern mrc_list$mref
    movl mrc_list$mref,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1576938"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1576938":
   movl %eax,  -28(%esp)  # stash funcall-oper in closure slot
# emit-expr ((primitive-ref primitives))
# funcall
#    si   =-32
#    env  = ((f259506 . -12) (f259506 . -8) ((primitive-ref primitives) . 12) ((primitive-ref list-ref) . 8) ((primitive-ref error) . 4))
#    expr = (funcall (primitive-ref primitives))
# emit-expr (primitive-ref primitives)
    .extern mrc_primitives
    movl mrc_primitives,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1576939"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1576939":
   movl %eax,  -40(%esp)  # stash funcall-oper in closure slot
    movl -40(%esp), %edi   # load new closure to %edi
    add $-32, %esp   # adjust base
    movl $0,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $32, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    mov %eax, -32(%esp)  # arg ((primitive-ref primitives))
# emit-expr f259506
# emit-variable-ref
# env=((f259506 . -12) (f259506 . -8) ((primitive-ref primitives) . 12) ((primitive-ref list-ref) . 8) ((primitive-ref error) . 4))
# var=f259506
    movl -12(%esp), %eax  # stack load f259506
# end emit-variable-ref
    mov %eax, -36(%esp)  # arg f259506
    movl -28(%esp), %edi   # load new closure to %edi
    add $-20, %esp   # adjust base
    movl $8,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $20, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    mov %eax, -20(%esp)    # arg ((primitive-ref list-ref) ((primitive-ref primitives)) f259506)
# emit-expr "arg must be a fixnum"
# string literal
    jmp _L_1576941
    .align 8,0x90
_L_1576940 :
    .int 80
    .ascii "arg must be a fixnum"
_L_1576941:
    movl $_L_1576940, %eax
    orl $6, %eax
    mov %eax, -24(%esp)    # arg arg must be a fixnum
    movl -16(%esp), %edi   # load new closure to %edi
# emit-shift-args:  size=3   si=-16  delta=12
    mov -16(%esp), %ebx  # shift frame cell
    mov %ebx, -4(%esp)  # down to base
# emit-shift-args:  size=2   si=-20  delta=12
    mov -20(%esp), %ebx  # shift frame cell
    mov %ebx, -8(%esp)  # down to base
# emit-shift-args:  size=1   si=-24  delta=12
    mov -24(%esp), %ebx  # shift frame cell
    mov %ebx, -12(%esp)  # down to base
# emit-shift-args:  size=0   si=-28  delta=12
    movl $8,%eax   # save arg count
    jmp *-2(%edi)  # tail-funcall
    .align 4,0x90
_L_1576936:
     movl %eax, mrc_eh$ufixnum
# == explicit-begins  ==>
# (lambda (i) (error (list-ref (primitives) i) "arg must be a string"))
# == eliminate-let*  ==>
# (lambda (i) (error (list-ref (primitives) i) "arg must be a string"))
# == uniquify-variables  ==>
# (lambda (f259507) (error (list-ref (primitives) f259507) "arg must be a string"))
# == vectorize-letrec  ==>
# (lambda (f259507) (error (list-ref (primitives) f259507) "arg must be a string"))
# == eliminate-set!  ==>
# (lambda (f259507) (let ((f259507 f259507)) (error (list-ref (primitives) f259507) "arg must be a string")))
# == close-free-variables  ==>
# (closure (f259507) (error list-ref primitives) (let ((f259507 f259507)) (error (list-ref (primitives) f259507) "arg must be a string")))
# == eliminate-quote  ==>
# (closure (f259507) (error list-ref primitives) (let ((f259507 f259507)) (error (list-ref (primitives) f259507) "arg must be a string")))
# == eliminate-when/unless  ==>
# (closure (f259507) (error list-ref primitives) (let ((f259507 f259507)) (error (list-ref (primitives) f259507) "arg must be a string")))
# == eliminate-cond  ==>
# (closure (f259507) (error list-ref primitives) (let ((f259507 f259507)) (error (list-ref (primitives) f259507) "arg must be a string")))
# == external-symbols  ==>
# (closure (f259507) ((primitive-ref error) (primitive-ref list-ref) (primitive-ref primitives)) (let ((f259507 f259507)) ((primitive-ref error) ((primitive-ref list-ref) ((primitive-ref primitives)) f259507) "arg must be a string")))
# emit-expr (closure (f259507) ((primitive-ref error) (primitive-ref list-ref) (primitive-ref primitives)) (let ((f259507 f259507)) ((primitive-ref error) ((primitive-ref list-ref) ((primitive-ref primitives)) f259507) "arg must be a string")))
# emit-closure
# si = 0
# env = ()
# expr = (closure (f259507) ((primitive-ref error) (primitive-ref list-ref) (primitive-ref primitives)) (let ((f259507 f259507)) ((primitive-ref error) ((primitive-ref list-ref) ((primitive-ref primitives)) f259507) "arg must be a string")))
    movl $_L_1576942, 0(%ebp)  # closure label
# WARNING: free var (primitive-ref error) not defined in the environmnet
# WARNING: free var (primitive-ref list-ref) not defined in the environmnet
# WARNING: free var (primitive-ref primitives) not defined in the environmnet
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $16, %ebp     # bump ebp
    jmp _L_1576943            # jump around closure body
_L_1576942:
# check argument count
    cmp $4,%eax
    je _L_1576944
# invoke error handler eh_argcount
    .extern mrc_eh$uargcount
    movl mrc_eh$uargcount, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_1576944:
# emit-tail-expr
# si=-12
# env=((f259507 . -8) ((primitive-ref primitives) . 12) ((primitive-ref list-ref) . 8) ((primitive-ref error) . 4))
# expr=(let ((f259507 f259507)) ((primitive-ref error) ((primitive-ref list-ref) ((primitive-ref primitives)) f259507) "arg must be a string"))
# emit-tail-let
#  si   = -12
#  env  = ((f259507 . -8) ((primitive-ref primitives) . 12) ((primitive-ref list-ref) . 8) ((primitive-ref error) . 4))
#  bindings = ((f259507 f259507))
#  body = ((primitive-ref error) ((primitive-ref list-ref) ((primitive-ref primitives)) f259507) "arg must be a string")
# emit-expr f259507
# emit-variable-ref
# env=((f259507 . -8) ((primitive-ref primitives) . 12) ((primitive-ref list-ref) . 8) ((primitive-ref error) . 4))
# var=f259507
    movl -8(%esp), %eax  # stack load f259507
# end emit-variable-ref
    movl %eax, -12(%esp)  # stack save
# emit-tail-expr
# si=-16
# env=((f259507 . -12) (f259507 . -8) ((primitive-ref primitives) . 12) ((primitive-ref list-ref) . 8) ((primitive-ref error) . 4))
# expr=((primitive-ref error) ((primitive-ref list-ref) ((primitive-ref primitives)) f259507) "arg must be a string")
# emit-tail-funcall
#    si   =-16
#    env  = ((f259507 . -12) (f259507 . -8) ((primitive-ref primitives) . 12) ((primitive-ref list-ref) . 8) ((primitive-ref error) . 4))
#    expr = (funcall (primitive-ref error) ((primitive-ref list-ref) ((primitive-ref primitives)) f259507) "arg must be a string")
# emit-expr (primitive-ref error)
    .extern mrc_error
    movl mrc_error,%eax
   movl %eax,  -16(%esp)  # stash funcall-oper in next closure slot
# emit-expr ((primitive-ref list-ref) ((primitive-ref primitives)) f259507)
# funcall
#    si   =-20
#    env  = ((f259507 . -12) (f259507 . -8) ((primitive-ref primitives) . 12) ((primitive-ref list-ref) . 8) ((primitive-ref error) . 4))
#    expr = (funcall (primitive-ref list-ref) ((primitive-ref primitives)) f259507)
# emit-expr (primitive-ref list-ref)
    .extern mrc_list$mref
    movl mrc_list$mref,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1576945"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1576945":
   movl %eax,  -28(%esp)  # stash funcall-oper in closure slot
# emit-expr ((primitive-ref primitives))
# funcall
#    si   =-32
#    env  = ((f259507 . -12) (f259507 . -8) ((primitive-ref primitives) . 12) ((primitive-ref list-ref) . 8) ((primitive-ref error) . 4))
#    expr = (funcall (primitive-ref primitives))
# emit-expr (primitive-ref primitives)
    .extern mrc_primitives
    movl mrc_primitives,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1576946"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1576946":
   movl %eax,  -40(%esp)  # stash funcall-oper in closure slot
    movl -40(%esp), %edi   # load new closure to %edi
    add $-32, %esp   # adjust base
    movl $0,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $32, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    mov %eax, -32(%esp)  # arg ((primitive-ref primitives))
# emit-expr f259507
# emit-variable-ref
# env=((f259507 . -12) (f259507 . -8) ((primitive-ref primitives) . 12) ((primitive-ref list-ref) . 8) ((primitive-ref error) . 4))
# var=f259507
    movl -12(%esp), %eax  # stack load f259507
# end emit-variable-ref
    mov %eax, -36(%esp)  # arg f259507
    movl -28(%esp), %edi   # load new closure to %edi
    add $-20, %esp   # adjust base
    movl $8,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $20, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    mov %eax, -20(%esp)    # arg ((primitive-ref list-ref) ((primitive-ref primitives)) f259507)
# emit-expr "arg must be a string"
# string literal
    jmp _L_1576948
    .align 8,0x90
_L_1576947 :
    .int 80
    .ascii "arg must be a string"
_L_1576948:
    movl $_L_1576947, %eax
    orl $6, %eax
    mov %eax, -24(%esp)    # arg arg must be a string
    movl -16(%esp), %edi   # load new closure to %edi
# emit-shift-args:  size=3   si=-16  delta=12
    mov -16(%esp), %ebx  # shift frame cell
    mov %ebx, -4(%esp)  # down to base
# emit-shift-args:  size=2   si=-20  delta=12
    mov -20(%esp), %ebx  # shift frame cell
    mov %ebx, -8(%esp)  # down to base
# emit-shift-args:  size=1   si=-24  delta=12
    mov -24(%esp), %ebx  # shift frame cell
    mov %ebx, -12(%esp)  # down to base
# emit-shift-args:  size=0   si=-28  delta=12
    movl $8,%eax   # save arg count
    jmp *-2(%edi)  # tail-funcall
    .align 4,0x90
_L_1576943:
     movl %eax, mrc_eh$ustring
# == explicit-begins  ==>
# (lambda (i) (error (list-ref (primitives) i) "arg must be a character"))
# == eliminate-let*  ==>
# (lambda (i) (error (list-ref (primitives) i) "arg must be a character"))
# == uniquify-variables  ==>
# (lambda (f259508) (error (list-ref (primitives) f259508) "arg must be a character"))
# == vectorize-letrec  ==>
# (lambda (f259508) (error (list-ref (primitives) f259508) "arg must be a character"))
# == eliminate-set!  ==>
# (lambda (f259508) (let ((f259508 f259508)) (error (list-ref (primitives) f259508) "arg must be a character")))
# == close-free-variables  ==>
# (closure (f259508) (error list-ref primitives) (let ((f259508 f259508)) (error (list-ref (primitives) f259508) "arg must be a character")))
# == eliminate-quote  ==>
# (closure (f259508) (error list-ref primitives) (let ((f259508 f259508)) (error (list-ref (primitives) f259508) "arg must be a character")))
# == eliminate-when/unless  ==>
# (closure (f259508) (error list-ref primitives) (let ((f259508 f259508)) (error (list-ref (primitives) f259508) "arg must be a character")))
# == eliminate-cond  ==>
# (closure (f259508) (error list-ref primitives) (let ((f259508 f259508)) (error (list-ref (primitives) f259508) "arg must be a character")))
# == external-symbols  ==>
# (closure (f259508) ((primitive-ref error) (primitive-ref list-ref) (primitive-ref primitives)) (let ((f259508 f259508)) ((primitive-ref error) ((primitive-ref list-ref) ((primitive-ref primitives)) f259508) "arg must be a character")))
# emit-expr (closure (f259508) ((primitive-ref error) (primitive-ref list-ref) (primitive-ref primitives)) (let ((f259508 f259508)) ((primitive-ref error) ((primitive-ref list-ref) ((primitive-ref primitives)) f259508) "arg must be a character")))
# emit-closure
# si = 0
# env = ()
# expr = (closure (f259508) ((primitive-ref error) (primitive-ref list-ref) (primitive-ref primitives)) (let ((f259508 f259508)) ((primitive-ref error) ((primitive-ref list-ref) ((primitive-ref primitives)) f259508) "arg must be a character")))
    movl $_L_1576949, 0(%ebp)  # closure label
# WARNING: free var (primitive-ref error) not defined in the environmnet
# WARNING: free var (primitive-ref list-ref) not defined in the environmnet
# WARNING: free var (primitive-ref primitives) not defined in the environmnet
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $16, %ebp     # bump ebp
    jmp _L_1576950            # jump around closure body
_L_1576949:
# check argument count
    cmp $4,%eax
    je _L_1576951
# invoke error handler eh_argcount
    .extern mrc_eh$uargcount
    movl mrc_eh$uargcount, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_1576951:
# emit-tail-expr
# si=-12
# env=((f259508 . -8) ((primitive-ref primitives) . 12) ((primitive-ref list-ref) . 8) ((primitive-ref error) . 4))
# expr=(let ((f259508 f259508)) ((primitive-ref error) ((primitive-ref list-ref) ((primitive-ref primitives)) f259508) "arg must be a character"))
# emit-tail-let
#  si   = -12
#  env  = ((f259508 . -8) ((primitive-ref primitives) . 12) ((primitive-ref list-ref) . 8) ((primitive-ref error) . 4))
#  bindings = ((f259508 f259508))
#  body = ((primitive-ref error) ((primitive-ref list-ref) ((primitive-ref primitives)) f259508) "arg must be a character")
# emit-expr f259508
# emit-variable-ref
# env=((f259508 . -8) ((primitive-ref primitives) . 12) ((primitive-ref list-ref) . 8) ((primitive-ref error) . 4))
# var=f259508
    movl -8(%esp), %eax  # stack load f259508
# end emit-variable-ref
    movl %eax, -12(%esp)  # stack save
# emit-tail-expr
# si=-16
# env=((f259508 . -12) (f259508 . -8) ((primitive-ref primitives) . 12) ((primitive-ref list-ref) . 8) ((primitive-ref error) . 4))
# expr=((primitive-ref error) ((primitive-ref list-ref) ((primitive-ref primitives)) f259508) "arg must be a character")
# emit-tail-funcall
#    si   =-16
#    env  = ((f259508 . -12) (f259508 . -8) ((primitive-ref primitives) . 12) ((primitive-ref list-ref) . 8) ((primitive-ref error) . 4))
#    expr = (funcall (primitive-ref error) ((primitive-ref list-ref) ((primitive-ref primitives)) f259508) "arg must be a character")
# emit-expr (primitive-ref error)
    .extern mrc_error
    movl mrc_error,%eax
   movl %eax,  -16(%esp)  # stash funcall-oper in next closure slot
# emit-expr ((primitive-ref list-ref) ((primitive-ref primitives)) f259508)
# funcall
#    si   =-20
#    env  = ((f259508 . -12) (f259508 . -8) ((primitive-ref primitives) . 12) ((primitive-ref list-ref) . 8) ((primitive-ref error) . 4))
#    expr = (funcall (primitive-ref list-ref) ((primitive-ref primitives)) f259508)
# emit-expr (primitive-ref list-ref)
    .extern mrc_list$mref
    movl mrc_list$mref,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1576952"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1576952":
   movl %eax,  -28(%esp)  # stash funcall-oper in closure slot
# emit-expr ((primitive-ref primitives))
# funcall
#    si   =-32
#    env  = ((f259508 . -12) (f259508 . -8) ((primitive-ref primitives) . 12) ((primitive-ref list-ref) . 8) ((primitive-ref error) . 4))
#    expr = (funcall (primitive-ref primitives))
# emit-expr (primitive-ref primitives)
    .extern mrc_primitives
    movl mrc_primitives,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1576953"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1576953":
   movl %eax,  -40(%esp)  # stash funcall-oper in closure slot
    movl -40(%esp), %edi   # load new closure to %edi
    add $-32, %esp   # adjust base
    movl $0,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $32, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    mov %eax, -32(%esp)  # arg ((primitive-ref primitives))
# emit-expr f259508
# emit-variable-ref
# env=((f259508 . -12) (f259508 . -8) ((primitive-ref primitives) . 12) ((primitive-ref list-ref) . 8) ((primitive-ref error) . 4))
# var=f259508
    movl -12(%esp), %eax  # stack load f259508
# end emit-variable-ref
    mov %eax, -36(%esp)  # arg f259508
    movl -28(%esp), %edi   # load new closure to %edi
    add $-20, %esp   # adjust base
    movl $8,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $20, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    mov %eax, -20(%esp)    # arg ((primitive-ref list-ref) ((primitive-ref primitives)) f259508)
# emit-expr "arg must be a character"
# string literal
    jmp _L_1576955
    .align 8,0x90
_L_1576954 :
    .int 92
    .ascii "arg must be a character"
_L_1576955:
    movl $_L_1576954, %eax
    orl $6, %eax
    mov %eax, -24(%esp)    # arg arg must be a character
    movl -16(%esp), %edi   # load new closure to %edi
# emit-shift-args:  size=3   si=-16  delta=12
    mov -16(%esp), %ebx  # shift frame cell
    mov %ebx, -4(%esp)  # down to base
# emit-shift-args:  size=2   si=-20  delta=12
    mov -20(%esp), %ebx  # shift frame cell
    mov %ebx, -8(%esp)  # down to base
# emit-shift-args:  size=1   si=-24  delta=12
    mov -24(%esp), %ebx  # shift frame cell
    mov %ebx, -12(%esp)  # down to base
# emit-shift-args:  size=0   si=-28  delta=12
    movl $8,%eax   # save arg count
    jmp *-2(%edi)  # tail-funcall
    .align 4,0x90
_L_1576950:
     movl %eax, mrc_eh$ucharacter
# == explicit-begins  ==>
# (lambda (i) (error (list-ref (primitives) i) "arg must be a pair"))
# == eliminate-let*  ==>
# (lambda (i) (error (list-ref (primitives) i) "arg must be a pair"))
# == uniquify-variables  ==>
# (lambda (f259509) (error (list-ref (primitives) f259509) "arg must be a pair"))
# == vectorize-letrec  ==>
# (lambda (f259509) (error (list-ref (primitives) f259509) "arg must be a pair"))
# == eliminate-set!  ==>
# (lambda (f259509) (let ((f259509 f259509)) (error (list-ref (primitives) f259509) "arg must be a pair")))
# == close-free-variables  ==>
# (closure (f259509) (error list-ref primitives) (let ((f259509 f259509)) (error (list-ref (primitives) f259509) "arg must be a pair")))
# == eliminate-quote  ==>
# (closure (f259509) (error list-ref primitives) (let ((f259509 f259509)) (error (list-ref (primitives) f259509) "arg must be a pair")))
# == eliminate-when/unless  ==>
# (closure (f259509) (error list-ref primitives) (let ((f259509 f259509)) (error (list-ref (primitives) f259509) "arg must be a pair")))
# == eliminate-cond  ==>
# (closure (f259509) (error list-ref primitives) (let ((f259509 f259509)) (error (list-ref (primitives) f259509) "arg must be a pair")))
# == external-symbols  ==>
# (closure (f259509) ((primitive-ref error) (primitive-ref list-ref) (primitive-ref primitives)) (let ((f259509 f259509)) ((primitive-ref error) ((primitive-ref list-ref) ((primitive-ref primitives)) f259509) "arg must be a pair")))
# emit-expr (closure (f259509) ((primitive-ref error) (primitive-ref list-ref) (primitive-ref primitives)) (let ((f259509 f259509)) ((primitive-ref error) ((primitive-ref list-ref) ((primitive-ref primitives)) f259509) "arg must be a pair")))
# emit-closure
# si = 0
# env = ()
# expr = (closure (f259509) ((primitive-ref error) (primitive-ref list-ref) (primitive-ref primitives)) (let ((f259509 f259509)) ((primitive-ref error) ((primitive-ref list-ref) ((primitive-ref primitives)) f259509) "arg must be a pair")))
    movl $_L_1576956, 0(%ebp)  # closure label
# WARNING: free var (primitive-ref error) not defined in the environmnet
# WARNING: free var (primitive-ref list-ref) not defined in the environmnet
# WARNING: free var (primitive-ref primitives) not defined in the environmnet
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $16, %ebp     # bump ebp
    jmp _L_1576957            # jump around closure body
_L_1576956:
# check argument count
    cmp $4,%eax
    je _L_1576958
# invoke error handler eh_argcount
    .extern mrc_eh$uargcount
    movl mrc_eh$uargcount, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_1576958:
# emit-tail-expr
# si=-12
# env=((f259509 . -8) ((primitive-ref primitives) . 12) ((primitive-ref list-ref) . 8) ((primitive-ref error) . 4))
# expr=(let ((f259509 f259509)) ((primitive-ref error) ((primitive-ref list-ref) ((primitive-ref primitives)) f259509) "arg must be a pair"))
# emit-tail-let
#  si   = -12
#  env  = ((f259509 . -8) ((primitive-ref primitives) . 12) ((primitive-ref list-ref) . 8) ((primitive-ref error) . 4))
#  bindings = ((f259509 f259509))
#  body = ((primitive-ref error) ((primitive-ref list-ref) ((primitive-ref primitives)) f259509) "arg must be a pair")
# emit-expr f259509
# emit-variable-ref
# env=((f259509 . -8) ((primitive-ref primitives) . 12) ((primitive-ref list-ref) . 8) ((primitive-ref error) . 4))
# var=f259509
    movl -8(%esp), %eax  # stack load f259509
# end emit-variable-ref
    movl %eax, -12(%esp)  # stack save
# emit-tail-expr
# si=-16
# env=((f259509 . -12) (f259509 . -8) ((primitive-ref primitives) . 12) ((primitive-ref list-ref) . 8) ((primitive-ref error) . 4))
# expr=((primitive-ref error) ((primitive-ref list-ref) ((primitive-ref primitives)) f259509) "arg must be a pair")
# emit-tail-funcall
#    si   =-16
#    env  = ((f259509 . -12) (f259509 . -8) ((primitive-ref primitives) . 12) ((primitive-ref list-ref) . 8) ((primitive-ref error) . 4))
#    expr = (funcall (primitive-ref error) ((primitive-ref list-ref) ((primitive-ref primitives)) f259509) "arg must be a pair")
# emit-expr (primitive-ref error)
    .extern mrc_error
    movl mrc_error,%eax
   movl %eax,  -16(%esp)  # stash funcall-oper in next closure slot
# emit-expr ((primitive-ref list-ref) ((primitive-ref primitives)) f259509)
# funcall
#    si   =-20
#    env  = ((f259509 . -12) (f259509 . -8) ((primitive-ref primitives) . 12) ((primitive-ref list-ref) . 8) ((primitive-ref error) . 4))
#    expr = (funcall (primitive-ref list-ref) ((primitive-ref primitives)) f259509)
# emit-expr (primitive-ref list-ref)
    .extern mrc_list$mref
    movl mrc_list$mref,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1576959"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1576959":
   movl %eax,  -28(%esp)  # stash funcall-oper in closure slot
# emit-expr ((primitive-ref primitives))
# funcall
#    si   =-32
#    env  = ((f259509 . -12) (f259509 . -8) ((primitive-ref primitives) . 12) ((primitive-ref list-ref) . 8) ((primitive-ref error) . 4))
#    expr = (funcall (primitive-ref primitives))
# emit-expr (primitive-ref primitives)
    .extern mrc_primitives
    movl mrc_primitives,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1576960"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1576960":
   movl %eax,  -40(%esp)  # stash funcall-oper in closure slot
    movl -40(%esp), %edi   # load new closure to %edi
    add $-32, %esp   # adjust base
    movl $0,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $32, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    mov %eax, -32(%esp)  # arg ((primitive-ref primitives))
# emit-expr f259509
# emit-variable-ref
# env=((f259509 . -12) (f259509 . -8) ((primitive-ref primitives) . 12) ((primitive-ref list-ref) . 8) ((primitive-ref error) . 4))
# var=f259509
    movl -12(%esp), %eax  # stack load f259509
# end emit-variable-ref
    mov %eax, -36(%esp)  # arg f259509
    movl -28(%esp), %edi   # load new closure to %edi
    add $-20, %esp   # adjust base
    movl $8,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $20, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    mov %eax, -20(%esp)    # arg ((primitive-ref list-ref) ((primitive-ref primitives)) f259509)
# emit-expr "arg must be a pair"
# string literal
    jmp _L_1576962
    .align 8,0x90
_L_1576961 :
    .int 72
    .ascii "arg must be a pair"
_L_1576962:
    movl $_L_1576961, %eax
    orl $6, %eax
    mov %eax, -24(%esp)    # arg arg must be a pair
    movl -16(%esp), %edi   # load new closure to %edi
# emit-shift-args:  size=3   si=-16  delta=12
    mov -16(%esp), %ebx  # shift frame cell
    mov %ebx, -4(%esp)  # down to base
# emit-shift-args:  size=2   si=-20  delta=12
    mov -20(%esp), %ebx  # shift frame cell
    mov %ebx, -8(%esp)  # down to base
# emit-shift-args:  size=1   si=-24  delta=12
    mov -24(%esp), %ebx  # shift frame cell
    mov %ebx, -12(%esp)  # down to base
# emit-shift-args:  size=0   si=-28  delta=12
    movl $8,%eax   # save arg count
    jmp *-2(%edi)  # tail-funcall
    .align 4,0x90
_L_1576957:
     movl %eax, mrc_eh$upair
# == explicit-begins  ==>
# (lambda (i) (error (list-ref (primitives) i) "arg must be a vector"))
# == eliminate-let*  ==>
# (lambda (i) (error (list-ref (primitives) i) "arg must be a vector"))
# == uniquify-variables  ==>
# (lambda (f259510) (error (list-ref (primitives) f259510) "arg must be a vector"))
# == vectorize-letrec  ==>
# (lambda (f259510) (error (list-ref (primitives) f259510) "arg must be a vector"))
# == eliminate-set!  ==>
# (lambda (f259510) (let ((f259510 f259510)) (error (list-ref (primitives) f259510) "arg must be a vector")))
# == close-free-variables  ==>
# (closure (f259510) (error list-ref primitives) (let ((f259510 f259510)) (error (list-ref (primitives) f259510) "arg must be a vector")))
# == eliminate-quote  ==>
# (closure (f259510) (error list-ref primitives) (let ((f259510 f259510)) (error (list-ref (primitives) f259510) "arg must be a vector")))
# == eliminate-when/unless  ==>
# (closure (f259510) (error list-ref primitives) (let ((f259510 f259510)) (error (list-ref (primitives) f259510) "arg must be a vector")))
# == eliminate-cond  ==>
# (closure (f259510) (error list-ref primitives) (let ((f259510 f259510)) (error (list-ref (primitives) f259510) "arg must be a vector")))
# == external-symbols  ==>
# (closure (f259510) ((primitive-ref error) (primitive-ref list-ref) (primitive-ref primitives)) (let ((f259510 f259510)) ((primitive-ref error) ((primitive-ref list-ref) ((primitive-ref primitives)) f259510) "arg must be a vector")))
# emit-expr (closure (f259510) ((primitive-ref error) (primitive-ref list-ref) (primitive-ref primitives)) (let ((f259510 f259510)) ((primitive-ref error) ((primitive-ref list-ref) ((primitive-ref primitives)) f259510) "arg must be a vector")))
# emit-closure
# si = 0
# env = ()
# expr = (closure (f259510) ((primitive-ref error) (primitive-ref list-ref) (primitive-ref primitives)) (let ((f259510 f259510)) ((primitive-ref error) ((primitive-ref list-ref) ((primitive-ref primitives)) f259510) "arg must be a vector")))
    movl $_L_1576963, 0(%ebp)  # closure label
# WARNING: free var (primitive-ref error) not defined in the environmnet
# WARNING: free var (primitive-ref list-ref) not defined in the environmnet
# WARNING: free var (primitive-ref primitives) not defined in the environmnet
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $16, %ebp     # bump ebp
    jmp _L_1576964            # jump around closure body
_L_1576963:
# check argument count
    cmp $4,%eax
    je _L_1576965
# invoke error handler eh_argcount
    .extern mrc_eh$uargcount
    movl mrc_eh$uargcount, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_1576965:
# emit-tail-expr
# si=-12
# env=((f259510 . -8) ((primitive-ref primitives) . 12) ((primitive-ref list-ref) . 8) ((primitive-ref error) . 4))
# expr=(let ((f259510 f259510)) ((primitive-ref error) ((primitive-ref list-ref) ((primitive-ref primitives)) f259510) "arg must be a vector"))
# emit-tail-let
#  si   = -12
#  env  = ((f259510 . -8) ((primitive-ref primitives) . 12) ((primitive-ref list-ref) . 8) ((primitive-ref error) . 4))
#  bindings = ((f259510 f259510))
#  body = ((primitive-ref error) ((primitive-ref list-ref) ((primitive-ref primitives)) f259510) "arg must be a vector")
# emit-expr f259510
# emit-variable-ref
# env=((f259510 . -8) ((primitive-ref primitives) . 12) ((primitive-ref list-ref) . 8) ((primitive-ref error) . 4))
# var=f259510
    movl -8(%esp), %eax  # stack load f259510
# end emit-variable-ref
    movl %eax, -12(%esp)  # stack save
# emit-tail-expr
# si=-16
# env=((f259510 . -12) (f259510 . -8) ((primitive-ref primitives) . 12) ((primitive-ref list-ref) . 8) ((primitive-ref error) . 4))
# expr=((primitive-ref error) ((primitive-ref list-ref) ((primitive-ref primitives)) f259510) "arg must be a vector")
# emit-tail-funcall
#    si   =-16
#    env  = ((f259510 . -12) (f259510 . -8) ((primitive-ref primitives) . 12) ((primitive-ref list-ref) . 8) ((primitive-ref error) . 4))
#    expr = (funcall (primitive-ref error) ((primitive-ref list-ref) ((primitive-ref primitives)) f259510) "arg must be a vector")
# emit-expr (primitive-ref error)
    .extern mrc_error
    movl mrc_error,%eax
   movl %eax,  -16(%esp)  # stash funcall-oper in next closure slot
# emit-expr ((primitive-ref list-ref) ((primitive-ref primitives)) f259510)
# funcall
#    si   =-20
#    env  = ((f259510 . -12) (f259510 . -8) ((primitive-ref primitives) . 12) ((primitive-ref list-ref) . 8) ((primitive-ref error) . 4))
#    expr = (funcall (primitive-ref list-ref) ((primitive-ref primitives)) f259510)
# emit-expr (primitive-ref list-ref)
    .extern mrc_list$mref
    movl mrc_list$mref,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1576966"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1576966":
   movl %eax,  -28(%esp)  # stash funcall-oper in closure slot
# emit-expr ((primitive-ref primitives))
# funcall
#    si   =-32
#    env  = ((f259510 . -12) (f259510 . -8) ((primitive-ref primitives) . 12) ((primitive-ref list-ref) . 8) ((primitive-ref error) . 4))
#    expr = (funcall (primitive-ref primitives))
# emit-expr (primitive-ref primitives)
    .extern mrc_primitives
    movl mrc_primitives,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1576967"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1576967":
   movl %eax,  -40(%esp)  # stash funcall-oper in closure slot
    movl -40(%esp), %edi   # load new closure to %edi
    add $-32, %esp   # adjust base
    movl $0,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $32, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    mov %eax, -32(%esp)  # arg ((primitive-ref primitives))
# emit-expr f259510
# emit-variable-ref
# env=((f259510 . -12) (f259510 . -8) ((primitive-ref primitives) . 12) ((primitive-ref list-ref) . 8) ((primitive-ref error) . 4))
# var=f259510
    movl -12(%esp), %eax  # stack load f259510
# end emit-variable-ref
    mov %eax, -36(%esp)  # arg f259510
    movl -28(%esp), %edi   # load new closure to %edi
    add $-20, %esp   # adjust base
    movl $8,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $20, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    mov %eax, -20(%esp)    # arg ((primitive-ref list-ref) ((primitive-ref primitives)) f259510)
# emit-expr "arg must be a vector"
# string literal
    jmp _L_1576969
    .align 8,0x90
_L_1576968 :
    .int 80
    .ascii "arg must be a vector"
_L_1576969:
    movl $_L_1576968, %eax
    orl $6, %eax
    mov %eax, -24(%esp)    # arg arg must be a vector
    movl -16(%esp), %edi   # load new closure to %edi
# emit-shift-args:  size=3   si=-16  delta=12
    mov -16(%esp), %ebx  # shift frame cell
    mov %ebx, -4(%esp)  # down to base
# emit-shift-args:  size=2   si=-20  delta=12
    mov -20(%esp), %ebx  # shift frame cell
    mov %ebx, -8(%esp)  # down to base
# emit-shift-args:  size=1   si=-24  delta=12
    mov -24(%esp), %ebx  # shift frame cell
    mov %ebx, -12(%esp)  # down to base
# emit-shift-args:  size=0   si=-28  delta=12
    movl $8,%eax   # save arg count
    jmp *-2(%edi)  # tail-funcall
    .align 4,0x90
_L_1576964:
     movl %eax, mrc_eh$uvector
# == explicit-begins  ==>
# (lambda (i) (error (list-ref (primitives) i) "length must be a fixnum >= 0"))
# == eliminate-let*  ==>
# (lambda (i) (error (list-ref (primitives) i) "length must be a fixnum >= 0"))
# == uniquify-variables  ==>
# (lambda (f259511) (error (list-ref (primitives) f259511) "length must be a fixnum >= 0"))
# == vectorize-letrec  ==>
# (lambda (f259511) (error (list-ref (primitives) f259511) "length must be a fixnum >= 0"))
# == eliminate-set!  ==>
# (lambda (f259511) (let ((f259511 f259511)) (error (list-ref (primitives) f259511) "length must be a fixnum >= 0")))
# == close-free-variables  ==>
# (closure (f259511) (error list-ref primitives) (let ((f259511 f259511)) (error (list-ref (primitives) f259511) "length must be a fixnum >= 0")))
# == eliminate-quote  ==>
# (closure (f259511) (error list-ref primitives) (let ((f259511 f259511)) (error (list-ref (primitives) f259511) "length must be a fixnum >= 0")))
# == eliminate-when/unless  ==>
# (closure (f259511) (error list-ref primitives) (let ((f259511 f259511)) (error (list-ref (primitives) f259511) "length must be a fixnum >= 0")))
# == eliminate-cond  ==>
# (closure (f259511) (error list-ref primitives) (let ((f259511 f259511)) (error (list-ref (primitives) f259511) "length must be a fixnum >= 0")))
# == external-symbols  ==>
# (closure (f259511) ((primitive-ref error) (primitive-ref list-ref) (primitive-ref primitives)) (let ((f259511 f259511)) ((primitive-ref error) ((primitive-ref list-ref) ((primitive-ref primitives)) f259511) "length must be a fixnum >= 0")))
# emit-expr (closure (f259511) ((primitive-ref error) (primitive-ref list-ref) (primitive-ref primitives)) (let ((f259511 f259511)) ((primitive-ref error) ((primitive-ref list-ref) ((primitive-ref primitives)) f259511) "length must be a fixnum >= 0")))
# emit-closure
# si = 0
# env = ()
# expr = (closure (f259511) ((primitive-ref error) (primitive-ref list-ref) (primitive-ref primitives)) (let ((f259511 f259511)) ((primitive-ref error) ((primitive-ref list-ref) ((primitive-ref primitives)) f259511) "length must be a fixnum >= 0")))
    movl $_L_1576970, 0(%ebp)  # closure label
# WARNING: free var (primitive-ref error) not defined in the environmnet
# WARNING: free var (primitive-ref list-ref) not defined in the environmnet
# WARNING: free var (primitive-ref primitives) not defined in the environmnet
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $16, %ebp     # bump ebp
    jmp _L_1576971            # jump around closure body
_L_1576970:
# check argument count
    cmp $4,%eax
    je _L_1576972
# invoke error handler eh_argcount
    .extern mrc_eh$uargcount
    movl mrc_eh$uargcount, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_1576972:
# emit-tail-expr
# si=-12
# env=((f259511 . -8) ((primitive-ref primitives) . 12) ((primitive-ref list-ref) . 8) ((primitive-ref error) . 4))
# expr=(let ((f259511 f259511)) ((primitive-ref error) ((primitive-ref list-ref) ((primitive-ref primitives)) f259511) "length must be a fixnum >= 0"))
# emit-tail-let
#  si   = -12
#  env  = ((f259511 . -8) ((primitive-ref primitives) . 12) ((primitive-ref list-ref) . 8) ((primitive-ref error) . 4))
#  bindings = ((f259511 f259511))
#  body = ((primitive-ref error) ((primitive-ref list-ref) ((primitive-ref primitives)) f259511) "length must be a fixnum >= 0")
# emit-expr f259511
# emit-variable-ref
# env=((f259511 . -8) ((primitive-ref primitives) . 12) ((primitive-ref list-ref) . 8) ((primitive-ref error) . 4))
# var=f259511
    movl -8(%esp), %eax  # stack load f259511
# end emit-variable-ref
    movl %eax, -12(%esp)  # stack save
# emit-tail-expr
# si=-16
# env=((f259511 . -12) (f259511 . -8) ((primitive-ref primitives) . 12) ((primitive-ref list-ref) . 8) ((primitive-ref error) . 4))
# expr=((primitive-ref error) ((primitive-ref list-ref) ((primitive-ref primitives)) f259511) "length must be a fixnum >= 0")
# emit-tail-funcall
#    si   =-16
#    env  = ((f259511 . -12) (f259511 . -8) ((primitive-ref primitives) . 12) ((primitive-ref list-ref) . 8) ((primitive-ref error) . 4))
#    expr = (funcall (primitive-ref error) ((primitive-ref list-ref) ((primitive-ref primitives)) f259511) "length must be a fixnum >= 0")
# emit-expr (primitive-ref error)
    .extern mrc_error
    movl mrc_error,%eax
   movl %eax,  -16(%esp)  # stash funcall-oper in next closure slot
# emit-expr ((primitive-ref list-ref) ((primitive-ref primitives)) f259511)
# funcall
#    si   =-20
#    env  = ((f259511 . -12) (f259511 . -8) ((primitive-ref primitives) . 12) ((primitive-ref list-ref) . 8) ((primitive-ref error) . 4))
#    expr = (funcall (primitive-ref list-ref) ((primitive-ref primitives)) f259511)
# emit-expr (primitive-ref list-ref)
    .extern mrc_list$mref
    movl mrc_list$mref,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1576973"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1576973":
   movl %eax,  -28(%esp)  # stash funcall-oper in closure slot
# emit-expr ((primitive-ref primitives))
# funcall
#    si   =-32
#    env  = ((f259511 . -12) (f259511 . -8) ((primitive-ref primitives) . 12) ((primitive-ref list-ref) . 8) ((primitive-ref error) . 4))
#    expr = (funcall (primitive-ref primitives))
# emit-expr (primitive-ref primitives)
    .extern mrc_primitives
    movl mrc_primitives,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1576974"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1576974":
   movl %eax,  -40(%esp)  # stash funcall-oper in closure slot
    movl -40(%esp), %edi   # load new closure to %edi
    add $-32, %esp   # adjust base
    movl $0,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $32, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    mov %eax, -32(%esp)  # arg ((primitive-ref primitives))
# emit-expr f259511
# emit-variable-ref
# env=((f259511 . -12) (f259511 . -8) ((primitive-ref primitives) . 12) ((primitive-ref list-ref) . 8) ((primitive-ref error) . 4))
# var=f259511
    movl -12(%esp), %eax  # stack load f259511
# end emit-variable-ref
    mov %eax, -36(%esp)  # arg f259511
    movl -28(%esp), %edi   # load new closure to %edi
    add $-20, %esp   # adjust base
    movl $8,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $20, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    mov %eax, -20(%esp)    # arg ((primitive-ref list-ref) ((primitive-ref primitives)) f259511)
# emit-expr "length must be a fixnum >= 0"
# string literal
    jmp _L_1576976
    .align 8,0x90
_L_1576975 :
    .int 112
    .ascii "length must be a fixnum >= 0"
_L_1576976:
    movl $_L_1576975, %eax
    orl $6, %eax
    mov %eax, -24(%esp)    # arg length must be a fixnum >= 0
    movl -16(%esp), %edi   # load new closure to %edi
# emit-shift-args:  size=3   si=-16  delta=12
    mov -16(%esp), %ebx  # shift frame cell
    mov %ebx, -4(%esp)  # down to base
# emit-shift-args:  size=2   si=-20  delta=12
    mov -20(%esp), %ebx  # shift frame cell
    mov %ebx, -8(%esp)  # down to base
# emit-shift-args:  size=1   si=-24  delta=12
    mov -24(%esp), %ebx  # shift frame cell
    mov %ebx, -12(%esp)  # down to base
# emit-shift-args:  size=0   si=-28  delta=12
    movl $8,%eax   # save arg count
    jmp *-2(%edi)  # tail-funcall
    .align 4,0x90
_L_1576971:
     movl %eax, mrc_eh$ulength
# == explicit-begins  ==>
# (lambda (i) (error (list-ref (primitives) i) "index out of bounds"))
# == eliminate-let*  ==>
# (lambda (i) (error (list-ref (primitives) i) "index out of bounds"))
# == uniquify-variables  ==>
# (lambda (f259512) (error (list-ref (primitives) f259512) "index out of bounds"))
# == vectorize-letrec  ==>
# (lambda (f259512) (error (list-ref (primitives) f259512) "index out of bounds"))
# == eliminate-set!  ==>
# (lambda (f259512) (let ((f259512 f259512)) (error (list-ref (primitives) f259512) "index out of bounds")))
# == close-free-variables  ==>
# (closure (f259512) (error list-ref primitives) (let ((f259512 f259512)) (error (list-ref (primitives) f259512) "index out of bounds")))
# == eliminate-quote  ==>
# (closure (f259512) (error list-ref primitives) (let ((f259512 f259512)) (error (list-ref (primitives) f259512) "index out of bounds")))
# == eliminate-when/unless  ==>
# (closure (f259512) (error list-ref primitives) (let ((f259512 f259512)) (error (list-ref (primitives) f259512) "index out of bounds")))
# == eliminate-cond  ==>
# (closure (f259512) (error list-ref primitives) (let ((f259512 f259512)) (error (list-ref (primitives) f259512) "index out of bounds")))
# == external-symbols  ==>
# (closure (f259512) ((primitive-ref error) (primitive-ref list-ref) (primitive-ref primitives)) (let ((f259512 f259512)) ((primitive-ref error) ((primitive-ref list-ref) ((primitive-ref primitives)) f259512) "index out of bounds")))
# emit-expr (closure (f259512) ((primitive-ref error) (primitive-ref list-ref) (primitive-ref primitives)) (let ((f259512 f259512)) ((primitive-ref error) ((primitive-ref list-ref) ((primitive-ref primitives)) f259512) "index out of bounds")))
# emit-closure
# si = 0
# env = ()
# expr = (closure (f259512) ((primitive-ref error) (primitive-ref list-ref) (primitive-ref primitives)) (let ((f259512 f259512)) ((primitive-ref error) ((primitive-ref list-ref) ((primitive-ref primitives)) f259512) "index out of bounds")))
    movl $_L_1576977, 0(%ebp)  # closure label
# WARNING: free var (primitive-ref error) not defined in the environmnet
# WARNING: free var (primitive-ref list-ref) not defined in the environmnet
# WARNING: free var (primitive-ref primitives) not defined in the environmnet
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $16, %ebp     # bump ebp
    jmp _L_1576978            # jump around closure body
_L_1576977:
# check argument count
    cmp $4,%eax
    je _L_1576979
# invoke error handler eh_argcount
    .extern mrc_eh$uargcount
    movl mrc_eh$uargcount, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_1576979:
# emit-tail-expr
# si=-12
# env=((f259512 . -8) ((primitive-ref primitives) . 12) ((primitive-ref list-ref) . 8) ((primitive-ref error) . 4))
# expr=(let ((f259512 f259512)) ((primitive-ref error) ((primitive-ref list-ref) ((primitive-ref primitives)) f259512) "index out of bounds"))
# emit-tail-let
#  si   = -12
#  env  = ((f259512 . -8) ((primitive-ref primitives) . 12) ((primitive-ref list-ref) . 8) ((primitive-ref error) . 4))
#  bindings = ((f259512 f259512))
#  body = ((primitive-ref error) ((primitive-ref list-ref) ((primitive-ref primitives)) f259512) "index out of bounds")
# emit-expr f259512
# emit-variable-ref
# env=((f259512 . -8) ((primitive-ref primitives) . 12) ((primitive-ref list-ref) . 8) ((primitive-ref error) . 4))
# var=f259512
    movl -8(%esp), %eax  # stack load f259512
# end emit-variable-ref
    movl %eax, -12(%esp)  # stack save
# emit-tail-expr
# si=-16
# env=((f259512 . -12) (f259512 . -8) ((primitive-ref primitives) . 12) ((primitive-ref list-ref) . 8) ((primitive-ref error) . 4))
# expr=((primitive-ref error) ((primitive-ref list-ref) ((primitive-ref primitives)) f259512) "index out of bounds")
# emit-tail-funcall
#    si   =-16
#    env  = ((f259512 . -12) (f259512 . -8) ((primitive-ref primitives) . 12) ((primitive-ref list-ref) . 8) ((primitive-ref error) . 4))
#    expr = (funcall (primitive-ref error) ((primitive-ref list-ref) ((primitive-ref primitives)) f259512) "index out of bounds")
# emit-expr (primitive-ref error)
    .extern mrc_error
    movl mrc_error,%eax
   movl %eax,  -16(%esp)  # stash funcall-oper in next closure slot
# emit-expr ((primitive-ref list-ref) ((primitive-ref primitives)) f259512)
# funcall
#    si   =-20
#    env  = ((f259512 . -12) (f259512 . -8) ((primitive-ref primitives) . 12) ((primitive-ref list-ref) . 8) ((primitive-ref error) . 4))
#    expr = (funcall (primitive-ref list-ref) ((primitive-ref primitives)) f259512)
# emit-expr (primitive-ref list-ref)
    .extern mrc_list$mref
    movl mrc_list$mref,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1576980"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1576980":
   movl %eax,  -28(%esp)  # stash funcall-oper in closure slot
# emit-expr ((primitive-ref primitives))
# funcall
#    si   =-32
#    env  = ((f259512 . -12) (f259512 . -8) ((primitive-ref primitives) . 12) ((primitive-ref list-ref) . 8) ((primitive-ref error) . 4))
#    expr = (funcall (primitive-ref primitives))
# emit-expr (primitive-ref primitives)
    .extern mrc_primitives
    movl mrc_primitives,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1576981"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1576981":
   movl %eax,  -40(%esp)  # stash funcall-oper in closure slot
    movl -40(%esp), %edi   # load new closure to %edi
    add $-32, %esp   # adjust base
    movl $0,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $32, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    mov %eax, -32(%esp)  # arg ((primitive-ref primitives))
# emit-expr f259512
# emit-variable-ref
# env=((f259512 . -12) (f259512 . -8) ((primitive-ref primitives) . 12) ((primitive-ref list-ref) . 8) ((primitive-ref error) . 4))
# var=f259512
    movl -12(%esp), %eax  # stack load f259512
# end emit-variable-ref
    mov %eax, -36(%esp)  # arg f259512
    movl -28(%esp), %edi   # load new closure to %edi
    add $-20, %esp   # adjust base
    movl $8,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $20, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    mov %eax, -20(%esp)    # arg ((primitive-ref list-ref) ((primitive-ref primitives)) f259512)
# emit-expr "index out of bounds"
# string literal
    jmp _L_1576983
    .align 8,0x90
_L_1576982 :
    .int 76
    .ascii "index out of bounds"
_L_1576983:
    movl $_L_1576982, %eax
    orl $6, %eax
    mov %eax, -24(%esp)    # arg index out of bounds
    movl -16(%esp), %edi   # load new closure to %edi
# emit-shift-args:  size=3   si=-16  delta=12
    mov -16(%esp), %ebx  # shift frame cell
    mov %ebx, -4(%esp)  # down to base
# emit-shift-args:  size=2   si=-20  delta=12
    mov -20(%esp), %ebx  # shift frame cell
    mov %ebx, -8(%esp)  # down to base
# emit-shift-args:  size=1   si=-24  delta=12
    mov -24(%esp), %ebx  # shift frame cell
    mov %ebx, -12(%esp)  # down to base
# emit-shift-args:  size=0   si=-28  delta=12
    movl $8,%eax   # save arg count
    jmp *-2(%edi)  # tail-funcall
    .align 4,0x90
_L_1576978:
     movl %eax, mrc_eh$uvector$uindex
# == explicit-begins  ==>
# (lambda (i) (error (list-ref (primitives) i) "index out of bounds"))
# == eliminate-let*  ==>
# (lambda (i) (error (list-ref (primitives) i) "index out of bounds"))
# == uniquify-variables  ==>
# (lambda (f259513) (error (list-ref (primitives) f259513) "index out of bounds"))
# == vectorize-letrec  ==>
# (lambda (f259513) (error (list-ref (primitives) f259513) "index out of bounds"))
# == eliminate-set!  ==>
# (lambda (f259513) (let ((f259513 f259513)) (error (list-ref (primitives) f259513) "index out of bounds")))
# == close-free-variables  ==>
# (closure (f259513) (error list-ref primitives) (let ((f259513 f259513)) (error (list-ref (primitives) f259513) "index out of bounds")))
# == eliminate-quote  ==>
# (closure (f259513) (error list-ref primitives) (let ((f259513 f259513)) (error (list-ref (primitives) f259513) "index out of bounds")))
# == eliminate-when/unless  ==>
# (closure (f259513) (error list-ref primitives) (let ((f259513 f259513)) (error (list-ref (primitives) f259513) "index out of bounds")))
# == eliminate-cond  ==>
# (closure (f259513) (error list-ref primitives) (let ((f259513 f259513)) (error (list-ref (primitives) f259513) "index out of bounds")))
# == external-symbols  ==>
# (closure (f259513) ((primitive-ref error) (primitive-ref list-ref) (primitive-ref primitives)) (let ((f259513 f259513)) ((primitive-ref error) ((primitive-ref list-ref) ((primitive-ref primitives)) f259513) "index out of bounds")))
# emit-expr (closure (f259513) ((primitive-ref error) (primitive-ref list-ref) (primitive-ref primitives)) (let ((f259513 f259513)) ((primitive-ref error) ((primitive-ref list-ref) ((primitive-ref primitives)) f259513) "index out of bounds")))
# emit-closure
# si = 0
# env = ()
# expr = (closure (f259513) ((primitive-ref error) (primitive-ref list-ref) (primitive-ref primitives)) (let ((f259513 f259513)) ((primitive-ref error) ((primitive-ref list-ref) ((primitive-ref primitives)) f259513) "index out of bounds")))
    movl $_L_1576984, 0(%ebp)  # closure label
# WARNING: free var (primitive-ref error) not defined in the environmnet
# WARNING: free var (primitive-ref list-ref) not defined in the environmnet
# WARNING: free var (primitive-ref primitives) not defined in the environmnet
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $16, %ebp     # bump ebp
    jmp _L_1576985            # jump around closure body
_L_1576984:
# check argument count
    cmp $4,%eax
    je _L_1576986
# invoke error handler eh_argcount
    .extern mrc_eh$uargcount
    movl mrc_eh$uargcount, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_1576986:
# emit-tail-expr
# si=-12
# env=((f259513 . -8) ((primitive-ref primitives) . 12) ((primitive-ref list-ref) . 8) ((primitive-ref error) . 4))
# expr=(let ((f259513 f259513)) ((primitive-ref error) ((primitive-ref list-ref) ((primitive-ref primitives)) f259513) "index out of bounds"))
# emit-tail-let
#  si   = -12
#  env  = ((f259513 . -8) ((primitive-ref primitives) . 12) ((primitive-ref list-ref) . 8) ((primitive-ref error) . 4))
#  bindings = ((f259513 f259513))
#  body = ((primitive-ref error) ((primitive-ref list-ref) ((primitive-ref primitives)) f259513) "index out of bounds")
# emit-expr f259513
# emit-variable-ref
# env=((f259513 . -8) ((primitive-ref primitives) . 12) ((primitive-ref list-ref) . 8) ((primitive-ref error) . 4))
# var=f259513
    movl -8(%esp), %eax  # stack load f259513
# end emit-variable-ref
    movl %eax, -12(%esp)  # stack save
# emit-tail-expr
# si=-16
# env=((f259513 . -12) (f259513 . -8) ((primitive-ref primitives) . 12) ((primitive-ref list-ref) . 8) ((primitive-ref error) . 4))
# expr=((primitive-ref error) ((primitive-ref list-ref) ((primitive-ref primitives)) f259513) "index out of bounds")
# emit-tail-funcall
#    si   =-16
#    env  = ((f259513 . -12) (f259513 . -8) ((primitive-ref primitives) . 12) ((primitive-ref list-ref) . 8) ((primitive-ref error) . 4))
#    expr = (funcall (primitive-ref error) ((primitive-ref list-ref) ((primitive-ref primitives)) f259513) "index out of bounds")
# emit-expr (primitive-ref error)
    .extern mrc_error
    movl mrc_error,%eax
   movl %eax,  -16(%esp)  # stash funcall-oper in next closure slot
# emit-expr ((primitive-ref list-ref) ((primitive-ref primitives)) f259513)
# funcall
#    si   =-20
#    env  = ((f259513 . -12) (f259513 . -8) ((primitive-ref primitives) . 12) ((primitive-ref list-ref) . 8) ((primitive-ref error) . 4))
#    expr = (funcall (primitive-ref list-ref) ((primitive-ref primitives)) f259513)
# emit-expr (primitive-ref list-ref)
    .extern mrc_list$mref
    movl mrc_list$mref,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1576987"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1576987":
   movl %eax,  -28(%esp)  # stash funcall-oper in closure slot
# emit-expr ((primitive-ref primitives))
# funcall
#    si   =-32
#    env  = ((f259513 . -12) (f259513 . -8) ((primitive-ref primitives) . 12) ((primitive-ref list-ref) . 8) ((primitive-ref error) . 4))
#    expr = (funcall (primitive-ref primitives))
# emit-expr (primitive-ref primitives)
    .extern mrc_primitives
    movl mrc_primitives,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1576988"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1576988":
   movl %eax,  -40(%esp)  # stash funcall-oper in closure slot
    movl -40(%esp), %edi   # load new closure to %edi
    add $-32, %esp   # adjust base
    movl $0,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $32, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    mov %eax, -32(%esp)  # arg ((primitive-ref primitives))
# emit-expr f259513
# emit-variable-ref
# env=((f259513 . -12) (f259513 . -8) ((primitive-ref primitives) . 12) ((primitive-ref list-ref) . 8) ((primitive-ref error) . 4))
# var=f259513
    movl -12(%esp), %eax  # stack load f259513
# end emit-variable-ref
    mov %eax, -36(%esp)  # arg f259513
    movl -28(%esp), %edi   # load new closure to %edi
    add $-20, %esp   # adjust base
    movl $8,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $20, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    mov %eax, -20(%esp)    # arg ((primitive-ref list-ref) ((primitive-ref primitives)) f259513)
# emit-expr "index out of bounds"
# string literal
    jmp _L_1576990
    .align 8,0x90
_L_1576989 :
    .int 76
    .ascii "index out of bounds"
_L_1576990:
    movl $_L_1576989, %eax
    orl $6, %eax
    mov %eax, -24(%esp)    # arg index out of bounds
    movl -16(%esp), %edi   # load new closure to %edi
# emit-shift-args:  size=3   si=-16  delta=12
    mov -16(%esp), %ebx  # shift frame cell
    mov %ebx, -4(%esp)  # down to base
# emit-shift-args:  size=2   si=-20  delta=12
    mov -20(%esp), %ebx  # shift frame cell
    mov %ebx, -8(%esp)  # down to base
# emit-shift-args:  size=1   si=-24  delta=12
    mov -24(%esp), %ebx  # shift frame cell
    mov %ebx, -12(%esp)  # down to base
# emit-shift-args:  size=0   si=-28  delta=12
    movl $8,%eax   # save arg count
    jmp *-2(%edi)  # tail-funcall
    .align 4,0x90
_L_1576985:
     movl %eax, mrc_eh$ustring$uindex
# == explicit-begins  ==>
# (lambda (z) (fxzero? z))
# == eliminate-let*  ==>
# (lambda (z) (fxzero? z))
# == uniquify-variables  ==>
# (lambda (f259514) (fxzero? f259514))
# == vectorize-letrec  ==>
# (lambda (f259514) (fxzero? f259514))
# == eliminate-set!  ==>
# (lambda (f259514) (let ((f259514 f259514)) (fxzero? f259514)))
# == close-free-variables  ==>
# (closure (f259514) () (let ((f259514 f259514)) (fxzero? f259514)))
# == eliminate-quote  ==>
# (closure (f259514) () (let ((f259514 f259514)) (fxzero? f259514)))
# == eliminate-when/unless  ==>
# (closure (f259514) () (let ((f259514 f259514)) (fxzero? f259514)))
# == eliminate-cond  ==>
# (closure (f259514) () (let ((f259514 f259514)) (fxzero? f259514)))
# == external-symbols  ==>
# (closure (f259514) () (let ((f259514 f259514)) (fxzero? f259514)))
# emit-expr (closure (f259514) () (let ((f259514 f259514)) (fxzero? f259514)))
# emit-closure
# si = 0
# env = ()
# expr = (closure (f259514) () (let ((f259514 f259514)) (fxzero? f259514)))
    movl $_L_1576991, 0(%ebp)  # closure label
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $8, %ebp     # bump ebp
    jmp _L_1576992            # jump around closure body
_L_1576991:
# check argument count
    cmp $4,%eax
    je _L_1576993
# invoke error handler eh_argcount
    .extern mrc_eh$uargcount
    movl mrc_eh$uargcount, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_1576993:
# emit-tail-expr
# si=-12
# env=((f259514 . -8))
# expr=(let ((f259514 f259514)) (fxzero? f259514))
# emit-tail-let
#  si   = -12
#  env  = ((f259514 . -8))
#  bindings = ((f259514 f259514))
#  body = (fxzero? f259514)
# emit-expr f259514
# emit-variable-ref
# env=((f259514 . -8))
# var=f259514
    movl -8(%esp), %eax  # stack load f259514
# end emit-variable-ref
    movl %eax, -12(%esp)  # stack save
# emit-tail-expr
# si=-16
# env=((f259514 . -12) (f259514 . -8))
# expr=(fxzero? f259514)
# tail primcall
# emit-expr f259514
# emit-variable-ref
# env=((f259514 . -12) (f259514 . -8))
# var=f259514
    movl -12(%esp), %eax  # stack load f259514
# end emit-variable-ref
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1576994"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $56,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1576994:
    cmp $0, %eax
    sete %al
    movzbl %al, %eax
    sal $6, %al
    or $47, %al
#return from tail (fxzero? f259514)
    ret
    .align 4,0x90
_L_1576992:
     movl %eax, mrc_zero$q
# == explicit-begins  ==>
# (lambda (x) (fx> x 0))
# == eliminate-let*  ==>
# (lambda (x) (fx> x 0))
# == uniquify-variables  ==>
# (lambda (f259515) (fx> f259515 0))
# == vectorize-letrec  ==>
# (lambda (f259515) (fx> f259515 0))
# == eliminate-set!  ==>
# (lambda (f259515) (let ((f259515 f259515)) (fx> f259515 0)))
# == close-free-variables  ==>
# (closure (f259515) () (let ((f259515 f259515)) (fx> f259515 0)))
# == eliminate-quote  ==>
# (closure (f259515) () (let ((f259515 f259515)) (fx> f259515 0)))
# == eliminate-when/unless  ==>
# (closure (f259515) () (let ((f259515 f259515)) (fx> f259515 0)))
# == eliminate-cond  ==>
# (closure (f259515) () (let ((f259515 f259515)) (fx> f259515 0)))
# == external-symbols  ==>
# (closure (f259515) () (let ((f259515 f259515)) (fx> f259515 0)))
# emit-expr (closure (f259515) () (let ((f259515 f259515)) (fx> f259515 0)))
# emit-closure
# si = 0
# env = ()
# expr = (closure (f259515) () (let ((f259515 f259515)) (fx> f259515 0)))
    movl $_L_1576995, 0(%ebp)  # closure label
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $8, %ebp     # bump ebp
    jmp _L_1576996            # jump around closure body
_L_1576995:
# check argument count
    cmp $4,%eax
    je _L_1576997
# invoke error handler eh_argcount
    .extern mrc_eh$uargcount
    movl mrc_eh$uargcount, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_1576997:
# emit-tail-expr
# si=-12
# env=((f259515 . -8))
# expr=(let ((f259515 f259515)) (fx> f259515 0))
# emit-tail-let
#  si   = -12
#  env  = ((f259515 . -8))
#  bindings = ((f259515 f259515))
#  body = (fx> f259515 0)
# emit-expr f259515
# emit-variable-ref
# env=((f259515 . -8))
# var=f259515
    movl -8(%esp), %eax  # stack load f259515
# end emit-variable-ref
    movl %eax, -12(%esp)  # stack save
# emit-tail-expr
# si=-16
# env=((f259515 . -12) (f259515 . -8))
# expr=(fx> f259515 0)
# tail primcall
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1576998"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $72,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1576998:
    movl %eax, -16(%esp)
# emit-expr f259515
# emit-variable-ref
# env=((f259515 . -12) (f259515 . -8))
# var=f259515
    movl -12(%esp), %eax  # stack load f259515
# end emit-variable-ref
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1576999"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $72,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1576999:
    cmp -16(%esp), %eax
    setg %al
    movzbl %al, %eax
    sal $6, %al
    or $47, %al
#return from tail (fx> f259515 0)
    ret
    .align 4,0x90
_L_1576996:
     movl %eax, mrc_positive$q
# == explicit-begins  ==>
# (lambda (x) (fx< x 0))
# == eliminate-let*  ==>
# (lambda (x) (fx< x 0))
# == uniquify-variables  ==>
# (lambda (f259516) (fx< f259516 0))
# == vectorize-letrec  ==>
# (lambda (f259516) (fx< f259516 0))
# == eliminate-set!  ==>
# (lambda (f259516) (let ((f259516 f259516)) (fx< f259516 0)))
# == close-free-variables  ==>
# (closure (f259516) () (let ((f259516 f259516)) (fx< f259516 0)))
# == eliminate-quote  ==>
# (closure (f259516) () (let ((f259516 f259516)) (fx< f259516 0)))
# == eliminate-when/unless  ==>
# (closure (f259516) () (let ((f259516 f259516)) (fx< f259516 0)))
# == eliminate-cond  ==>
# (closure (f259516) () (let ((f259516 f259516)) (fx< f259516 0)))
# == external-symbols  ==>
# (closure (f259516) () (let ((f259516 f259516)) (fx< f259516 0)))
# emit-expr (closure (f259516) () (let ((f259516 f259516)) (fx< f259516 0)))
# emit-closure
# si = 0
# env = ()
# expr = (closure (f259516) () (let ((f259516 f259516)) (fx< f259516 0)))
    movl $_L_1577000, 0(%ebp)  # closure label
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $8, %ebp     # bump ebp
    jmp _L_1577001            # jump around closure body
_L_1577000:
# check argument count
    cmp $4,%eax
    je _L_1577002
# invoke error handler eh_argcount
    .extern mrc_eh$uargcount
    movl mrc_eh$uargcount, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_1577002:
# emit-tail-expr
# si=-12
# env=((f259516 . -8))
# expr=(let ((f259516 f259516)) (fx< f259516 0))
# emit-tail-let
#  si   = -12
#  env  = ((f259516 . -8))
#  bindings = ((f259516 f259516))
#  body = (fx< f259516 0)
# emit-expr f259516
# emit-variable-ref
# env=((f259516 . -8))
# var=f259516
    movl -8(%esp), %eax  # stack load f259516
# end emit-variable-ref
    movl %eax, -12(%esp)  # stack save
# emit-tail-expr
# si=-16
# env=((f259516 . -12) (f259516 . -8))
# expr=(fx< f259516 0)
# tail primcall
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1577003"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $64,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1577003:
    movl %eax, -16(%esp)
# emit-expr f259516
# emit-variable-ref
# env=((f259516 . -12) (f259516 . -8))
# var=f259516
    movl -12(%esp), %eax  # stack load f259516
# end emit-variable-ref
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1577004"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $64,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1577004:
    cmp -16(%esp), %eax
    setl %al
    movzbl %al, %eax
    sal $6, %al
    or $47, %al
#return from tail (fx< f259516 0)
    ret
    .align 4,0x90
_L_1577001:
     movl %eax, mrc_negative$q
# == explicit-begins  ==>
# (lambda (x) (fxzero? (remainder x 2)))
# == eliminate-let*  ==>
# (lambda (x) (fxzero? (remainder x 2)))
# == uniquify-variables  ==>
# (lambda (f259517) (fxzero? (remainder f259517 2)))
# == vectorize-letrec  ==>
# (lambda (f259517) (fxzero? (remainder f259517 2)))
# == eliminate-set!  ==>
# (lambda (f259517) (let ((f259517 f259517)) (fxzero? (remainder f259517 2))))
# == close-free-variables  ==>
# (closure (f259517) (remainder) (let ((f259517 f259517)) (fxzero? (remainder f259517 2))))
# == eliminate-quote  ==>
# (closure (f259517) (remainder) (let ((f259517 f259517)) (fxzero? (remainder f259517 2))))
# == eliminate-when/unless  ==>
# (closure (f259517) (remainder) (let ((f259517 f259517)) (fxzero? (remainder f259517 2))))
# == eliminate-cond  ==>
# (closure (f259517) (remainder) (let ((f259517 f259517)) (fxzero? (remainder f259517 2))))
# == external-symbols  ==>
# (closure (f259517) (remainder) (let ((f259517 f259517)) (fxzero? (remainder f259517 2))))
# emit-expr (closure (f259517) (remainder) (let ((f259517 f259517)) (fxzero? (remainder f259517 2))))
# emit-closure
# si = 0
# env = ()
# expr = (closure (f259517) (remainder) (let ((f259517 f259517)) (fxzero? (remainder f259517 2))))
    movl $_L_1577005, 0(%ebp)  # closure label
# WARNING: free var remainder not defined in the environmnet
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $8, %ebp     # bump ebp
    jmp _L_1577006            # jump around closure body
_L_1577005:
# check argument count
    cmp $4,%eax
    je _L_1577007
# invoke error handler eh_argcount
    .extern mrc_eh$uargcount
    movl mrc_eh$uargcount, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_1577007:
# emit-tail-expr
# si=-12
# env=((f259517 . -8) (remainder . 4))
# expr=(let ((f259517 f259517)) (fxzero? (remainder f259517 2)))
# emit-tail-let
#  si   = -12
#  env  = ((f259517 . -8) (remainder . 4))
#  bindings = ((f259517 f259517))
#  body = (fxzero? (remainder f259517 2))
# emit-expr f259517
# emit-variable-ref
# env=((f259517 . -8) (remainder . 4))
# var=f259517
    movl -8(%esp), %eax  # stack load f259517
# end emit-variable-ref
    movl %eax, -12(%esp)  # stack save
# emit-tail-expr
# si=-16
# env=((f259517 . -12) (f259517 . -8) (remainder . 4))
# expr=(fxzero? (remainder f259517 2))
# tail primcall
# emit-expr (remainder f259517 2)
# funcall
#    si   =-16
#    env  = ((f259517 . -12) (f259517 . -8) (remainder . 4))
#    expr = (funcall remainder f259517 2)
# emit-expr remainder
# emit-variable-ref
# env=((f259517 . -12) (f259517 . -8) (remainder . 4))
# var=remainder
    movl 2(%edi), %eax  # frame load remainder
# end emit-variable-ref
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1577008"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1577008":
   movl %eax,  -24(%esp)  # stash funcall-oper in closure slot
# emit-expr f259517
# emit-variable-ref
# env=((f259517 . -12) (f259517 . -8) (remainder . 4))
# var=f259517
    movl -12(%esp), %eax  # stack load f259517
# end emit-variable-ref
    mov %eax, -28(%esp)  # arg f259517
# emit-expr 2
    movl $8, %eax     # immed 2
    mov %eax, -32(%esp)  # arg 2
    movl -24(%esp), %edi   # load new closure to %edi
    add $-16, %esp   # adjust base
    movl $8,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $16, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1577009"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $56,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1577009:
    cmp $0, %eax
    sete %al
    movzbl %al, %eax
    sal $6, %al
    or $47, %al
#return from tail (fxzero? (remainder f259517 2))
    ret
    .align 4,0x90
_L_1577006:
     movl %eax, mrc_even$q
# == explicit-begins  ==>
# (lambda (x) (not (even? x)))
# == eliminate-let*  ==>
# (lambda (x) (not (even? x)))
# == uniquify-variables  ==>
# (lambda (f259518) (not (even? f259518)))
# == vectorize-letrec  ==>
# (lambda (f259518) (not (even? f259518)))
# == eliminate-set!  ==>
# (lambda (f259518) (let ((f259518 f259518)) (not (even? f259518))))
# == close-free-variables  ==>
# (closure (f259518) (even?) (let ((f259518 f259518)) (not (even? f259518))))
# == eliminate-quote  ==>
# (closure (f259518) (even?) (let ((f259518 f259518)) (not (even? f259518))))
# == eliminate-when/unless  ==>
# (closure (f259518) (even?) (let ((f259518 f259518)) (not (even? f259518))))
# == eliminate-cond  ==>
# (closure (f259518) (even?) (let ((f259518 f259518)) (not (even? f259518))))
# == external-symbols  ==>
# (closure (f259518) ((primitive-ref even?)) (let ((f259518 f259518)) (not ((primitive-ref even?) f259518))))
# emit-expr (closure (f259518) ((primitive-ref even?)) (let ((f259518 f259518)) (not ((primitive-ref even?) f259518))))
# emit-closure
# si = 0
# env = ()
# expr = (closure (f259518) ((primitive-ref even?)) (let ((f259518 f259518)) (not ((primitive-ref even?) f259518))))
    movl $_L_1577010, 0(%ebp)  # closure label
# WARNING: free var (primitive-ref even?) not defined in the environmnet
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $8, %ebp     # bump ebp
    jmp _L_1577011            # jump around closure body
_L_1577010:
# check argument count
    cmp $4,%eax
    je _L_1577012
# invoke error handler eh_argcount
    .extern mrc_eh$uargcount
    movl mrc_eh$uargcount, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_1577012:
# emit-tail-expr
# si=-12
# env=((f259518 . -8) ((primitive-ref even?) . 4))
# expr=(let ((f259518 f259518)) (not ((primitive-ref even?) f259518)))
# emit-tail-let
#  si   = -12
#  env  = ((f259518 . -8) ((primitive-ref even?) . 4))
#  bindings = ((f259518 f259518))
#  body = (not ((primitive-ref even?) f259518))
# emit-expr f259518
# emit-variable-ref
# env=((f259518 . -8) ((primitive-ref even?) . 4))
# var=f259518
    movl -8(%esp), %eax  # stack load f259518
# end emit-variable-ref
    movl %eax, -12(%esp)  # stack save
# emit-tail-expr
# si=-16
# env=((f259518 . -12) (f259518 . -8) ((primitive-ref even?) . 4))
# expr=(not ((primitive-ref even?) f259518))
# tail primcall
# emit-expr ((primitive-ref even?) f259518)
# funcall
#    si   =-16
#    env  = ((f259518 . -12) (f259518 . -8) ((primitive-ref even?) . 4))
#    expr = (funcall (primitive-ref even?) f259518)
# emit-expr (primitive-ref even?)
    .extern mrc_even$q
    movl mrc_even$q,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1577013"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1577013":
   movl %eax,  -24(%esp)  # stash funcall-oper in closure slot
# emit-expr f259518
# emit-variable-ref
# env=((f259518 . -12) (f259518 . -8) ((primitive-ref even?) . 4))
# var=f259518
    movl -12(%esp), %eax  # stack load f259518
# end emit-variable-ref
    mov %eax, -28(%esp)  # arg f259518
    movl -24(%esp), %edi   # load new closure to %edi
    add $-16, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $16, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    cmp $47, %eax
    sete %al
    movzbl %al, %eax
    sal $6, %al
    or $47, %al
#return from tail (not ((primitive-ref even?) f259518))
    ret
    .align 4,0x90
_L_1577011:
     movl %eax, mrc_odd$q
# == explicit-begins  ==>
# (lambda (f l) (if (null? l) (quote ()) (cons (f (car l)) (map f (cdr l)))))
# == eliminate-let*  ==>
# (lambda (f l) (if (null? l) (quote ()) (cons (f (car l)) (map f (cdr l)))))
# == uniquify-variables  ==>
# (lambda (f259519 f259520) (if (null? f259520) (quote ()) (cons (f259519 (car f259520)) (map f259519 (cdr f259520)))))
# == vectorize-letrec  ==>
# (lambda (f259519 f259520) (if (null? f259520) (quote ()) (cons (f259519 (car f259520)) (map f259519 (cdr f259520)))))
# == eliminate-set!  ==>
# (lambda (f259519 f259520) (let ((f259519 f259519) (f259520 f259520)) (if (null? f259520) (quote ()) (cons (f259519 (car f259520)) (map f259519 (cdr f259520))))))
# == close-free-variables  ==>
# (closure (f259519 f259520) (map) (let ((f259519 f259519) (f259520 f259520)) (if (null? f259520) (quote ()) (cons (f259519 (car f259520)) (map f259519 (cdr f259520))))))
# == eliminate-quote  ==>
# (closure (f259519 f259520) (map) (let ((f259519 f259519) (f259520 f259520)) (if (null? f259520) () (cons (f259519 (car f259520)) (map f259519 (cdr f259520))))))
# == eliminate-when/unless  ==>
# (closure (f259519 f259520) (map) (let ((f259519 f259519) (f259520 f259520)) (if (null? f259520) () (cons (f259519 (car f259520)) (map f259519 (cdr f259520))))))
# == eliminate-cond  ==>
# (closure (f259519 f259520) (map) (let ((f259519 f259519) (f259520 f259520)) (if (null? f259520) () (cons (f259519 (car f259520)) (map f259519 (cdr f259520))))))
# == external-symbols  ==>
# (closure (f259519 f259520) ((primitive-ref map)) (let ((f259519 f259519) (f259520 f259520)) (if (null? f259520) () (cons (f259519 (car f259520)) ((primitive-ref map) f259519 (cdr f259520))))))
# emit-expr (closure (f259519 f259520) ((primitive-ref map)) (let ((f259519 f259519) (f259520 f259520)) (if (null? f259520) () (cons (f259519 (car f259520)) ((primitive-ref map) f259519 (cdr f259520))))))
# emit-closure
# si = 0
# env = ()
# expr = (closure (f259519 f259520) ((primitive-ref map)) (let ((f259519 f259519) (f259520 f259520)) (if (null? f259520) () (cons (f259519 (car f259520)) ((primitive-ref map) f259519 (cdr f259520))))))
    movl $_L_1577014, 0(%ebp)  # closure label
# WARNING: free var (primitive-ref map) not defined in the environmnet
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $8, %ebp     # bump ebp
    jmp _L_1577015            # jump around closure body
_L_1577014:
# check argument count
    cmp $8,%eax
    je _L_1577016
# invoke error handler eh_argcount
    .extern mrc_eh$uargcount
    movl mrc_eh$uargcount, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_1577016:
# emit-tail-expr
# si=-16
# env=((f259520 . -12) (f259519 . -8) ((primitive-ref map) . 4))
# expr=(let ((f259519 f259519) (f259520 f259520)) (if (null? f259520) () (cons (f259519 (car f259520)) ((primitive-ref map) f259519 (cdr f259520)))))
# emit-tail-let
#  si   = -16
#  env  = ((f259520 . -12) (f259519 . -8) ((primitive-ref map) . 4))
#  bindings = ((f259519 f259519) (f259520 f259520))
#  body = (if (null? f259520) () (cons (f259519 (car f259520)) ((primitive-ref map) f259519 (cdr f259520))))
# emit-expr f259519
# emit-variable-ref
# env=((f259520 . -12) (f259519 . -8) ((primitive-ref map) . 4))
# var=f259519
    movl -8(%esp), %eax  # stack load f259519
# end emit-variable-ref
    movl %eax, -16(%esp)  # stack save
# emit-expr f259520
# emit-variable-ref
# env=((f259520 . -12) (f259519 . -8) ((primitive-ref map) . 4))
# var=f259520
    movl -12(%esp), %eax  # stack load f259520
# end emit-variable-ref
    movl %eax, -20(%esp)  # stack save
# emit-tail-expr
# si=-24
# env=((f259520 . -20) (f259519 . -16) (f259520 . -12) (f259519 . -8) ((primitive-ref map) . 4))
# expr=(if (null? f259520) () (cons (f259519 (car f259520)) ((primitive-ref map) f259519 (cdr f259520))))
# emit-expr (null? f259520)
# emit-expr f259520
# emit-variable-ref
# env=((f259520 . -20) (f259519 . -16) (f259520 . -12) (f259519 . -8) ((primitive-ref map) . 4))
# var=f259520
    movl -20(%esp), %eax  # stack load f259520
# end emit-variable-ref
    cmp $63, %eax
    mov $0, %eax
    sete %al
    movzbl %al, %eax
    sal $6, %al
    or $47, %al
    cmp $47, %al
    je _L_1577017
# emit-tail-expr
# si=-24
# env=((f259520 . -20) (f259519 . -16) (f259520 . -12) (f259519 . -8) ((primitive-ref map) . 4))
# expr=()
    movl $63, %eax     # immed ()
    ret                  # immediate tail return
    jmp _L_1577018
_L_1577017:
# emit-tail-expr
# si=-24
# env=((f259520 . -20) (f259519 . -16) (f259520 . -12) (f259519 . -8) ((primitive-ref map) . 4))
# expr=(cons (f259519 (car f259520)) ((primitive-ref map) f259519 (cdr f259520)))
# tail primcall
# cons arg1=(f259519 (car f259520)) arg2=((primitive-ref map) f259519 (cdr f259520))
# emit-expr (f259519 (car f259520))
# funcall
#    si   =-24
#    env  = ((f259520 . -20) (f259519 . -16) (f259520 . -12) (f259519 . -8) ((primitive-ref map) . 4))
#    expr = (funcall f259519 (car f259520))
# emit-expr f259519
# emit-variable-ref
# env=((f259520 . -20) (f259519 . -16) (f259520 . -12) (f259519 . -8) ((primitive-ref map) . 4))
# var=f259519
    movl -16(%esp), %eax  # stack load f259519
# end emit-variable-ref
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1577019"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1577019":
   movl %eax,  -32(%esp)  # stash funcall-oper in closure slot
# emit-expr (car f259520)
# emit-expr f259520
# emit-variable-ref
# env=((f259520 . -20) (f259519 . -16) (f259520 . -12) (f259519 . -8) ((primitive-ref map) . 4))
# var=f259520
    movl -20(%esp), %eax  # stack load f259520
# end emit-variable-ref
# check the argument is a pair
    movl %eax,%ebx
    and $7, %bl
    cmp $1, %bl
    je _L_1577020
# invoke error handler eh_pair
    .extern mrc_eh$upair
    movl mrc_eh$upair, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $108,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1577020:
    movl -1(%eax), %eax
    mov %eax, -36(%esp)  # arg (car f259520)
    movl -32(%esp), %edi   # load new closure to %edi
    add $-24, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $24, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    movl %eax, -24(%esp)
# emit-expr ((primitive-ref map) f259519 (cdr f259520))
# funcall
#    si   =-28
#    env  = ((f259520 . -20) (f259519 . -16) (f259520 . -12) (f259519 . -8) ((primitive-ref map) . 4))
#    expr = (funcall (primitive-ref map) f259519 (cdr f259520))
# emit-expr (primitive-ref map)
    .extern mrc_map
    movl mrc_map,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1577021"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1577021":
   movl %eax,  -36(%esp)  # stash funcall-oper in closure slot
# emit-expr f259519
# emit-variable-ref
# env=((f259520 . -20) (f259519 . -16) (f259520 . -12) (f259519 . -8) ((primitive-ref map) . 4))
# var=f259519
    movl -16(%esp), %eax  # stack load f259519
# end emit-variable-ref
    mov %eax, -40(%esp)  # arg f259519
# emit-expr (cdr f259520)
# emit-expr f259520
# emit-variable-ref
# env=((f259520 . -20) (f259519 . -16) (f259520 . -12) (f259519 . -8) ((primitive-ref map) . 4))
# var=f259520
    movl -20(%esp), %eax  # stack load f259520
# end emit-variable-ref
# check the argument is a pair
    movl %eax,%ebx
    and $7, %bl
    cmp $1, %bl
    je _L_1577022
# invoke error handler eh_pair
    .extern mrc_eh$upair
    movl mrc_eh$upair, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $112,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1577022:
    movl 3(%eax), %eax
    mov %eax, -44(%esp)  # arg (cdr f259520)
    movl -36(%esp), %edi   # load new closure to %edi
    add $-28, %esp   # adjust base
    movl $8,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $28, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    movl %eax, 4(%ebp)
    movl -24(%esp), %eax
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    or   $1, %al
    add  $8, %ebp
# cons end
#return from tail (cons (f259519 (car f259520)) ((primitive-ref map) f259519 (cdr f259520)))
    ret
_L_1577018:
    .align 4,0x90
_L_1577015:
     movl %eax, mrc_map
# == explicit-begins  ==>
# (lambda (f l) (unless (null? l) (begin (f (car l)) (for-each f (cdr l)))))
# == eliminate-let*  ==>
# (lambda (f l) (unless (null? l) (begin (f (car l)) (for-each f (cdr l)))))
# == uniquify-variables  ==>
# (lambda (f259521 f259522) (unless (null? f259522) (begin (f259521 (car f259522)) (for-each f259521 (cdr f259522)))))
# == vectorize-letrec  ==>
# (lambda (f259521 f259522) (unless (null? f259522) (begin (f259521 (car f259522)) (for-each f259521 (cdr f259522)))))
# == eliminate-set!  ==>
# (lambda (f259521 f259522) (let ((f259521 f259521) (f259522 f259522)) (unless (null? f259522) (begin (f259521 (car f259522)) (for-each f259521 (cdr f259522))))))
# == close-free-variables  ==>
# (closure (f259521 f259522) (unless for-each) (let ((f259521 f259521) (f259522 f259522)) (unless (null? f259522) (begin (f259521 (car f259522)) (for-each f259521 (cdr f259522))))))
# == eliminate-quote  ==>
# (closure (f259521 f259522) (unless for-each) (let ((f259521 f259521) (f259522 f259522)) (unless (null? f259522) (begin (f259521 (car f259522)) (for-each f259521 (cdr f259522))))))
# == eliminate-when/unless  ==>
# (closure (f259521 f259522) (if (not for-each) (begin) #f) (let ((f259521 f259521) (f259522 f259522)) (if (not (null? f259522)) (begin (begin (f259521 (car f259522)) (for-each f259521 (cdr f259522)))) #f)))
# == eliminate-cond  ==>
# (closure (f259521 f259522) (if (not for-each) (begin) #f) (let ((f259521 f259521) (f259522 f259522)) (if (not (null? f259522)) (begin (begin (f259521 (car f259522)) (for-each f259521 (cdr f259522)))) #f)))
# == external-symbols  ==>
# (closure (f259521 f259522) (if (not (primitive-ref for-each)) (begin) #f) (let ((f259521 f259521) (f259522 f259522)) (if (not (null? f259522)) (begin (begin (f259521 (car f259522)) ((primitive-ref for-each) f259521 (cdr f259522)))) #f)))
# emit-expr (closure (f259521 f259522) (if (not (primitive-ref for-each)) (begin) #f) (let ((f259521 f259521) (f259522 f259522)) (if (not (null? f259522)) (begin (begin (f259521 (car f259522)) ((primitive-ref for-each) f259521 (cdr f259522)))) #f)))
# emit-closure
# si = 0
# env = ()
# expr = (closure (f259521 f259522) (if (not (primitive-ref for-each)) (begin) #f) (let ((f259521 f259521) (f259522 f259522)) (if (not (null? f259522)) (begin (begin (f259521 (car f259522)) ((primitive-ref for-each) f259521 (cdr f259522)))) #f)))
    movl $_L_1577023, 0(%ebp)  # closure label
# WARNING: free var if not defined in the environmnet
# WARNING: free var (not (primitive-ref for-each)) not defined in the environmnet
# WARNING: free var (begin) not defined in the environmnet
# WARNING: free var #f not defined in the environmnet
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $24, %ebp     # bump ebp
    jmp _L_1577024            # jump around closure body
_L_1577023:
# check argument count
    cmp $8,%eax
    je _L_1577025
# invoke error handler eh_argcount
    .extern mrc_eh$uargcount
    movl mrc_eh$uargcount, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_1577025:
# emit-tail-expr
# si=-16
# env=((f259522 . -12) (f259521 . -8) (#f . 16) ((begin) . 12) ((not (primitive-ref for-each)) . 8) (if . 4))
# expr=(let ((f259521 f259521) (f259522 f259522)) (if (not (null? f259522)) (begin (begin (f259521 (car f259522)) ((primitive-ref for-each) f259521 (cdr f259522)))) #f))
# emit-tail-let
#  si   = -16
#  env  = ((f259522 . -12) (f259521 . -8) (#f . 16) ((begin) . 12) ((not (primitive-ref for-each)) . 8) (if . 4))
#  bindings = ((f259521 f259521) (f259522 f259522))
#  body = (if (not (null? f259522)) (begin (begin (f259521 (car f259522)) ((primitive-ref for-each) f259521 (cdr f259522)))) #f)
# emit-expr f259521
# emit-variable-ref
# env=((f259522 . -12) (f259521 . -8) (#f . 16) ((begin) . 12) ((not (primitive-ref for-each)) . 8) (if . 4))
# var=f259521
    movl -8(%esp), %eax  # stack load f259521
# end emit-variable-ref
    movl %eax, -16(%esp)  # stack save
# emit-expr f259522
# emit-variable-ref
# env=((f259522 . -12) (f259521 . -8) (#f . 16) ((begin) . 12) ((not (primitive-ref for-each)) . 8) (if . 4))
# var=f259522
    movl -12(%esp), %eax  # stack load f259522
# end emit-variable-ref
    movl %eax, -20(%esp)  # stack save
# emit-tail-expr
# si=-24
# env=((f259522 . -20) (f259521 . -16) (f259522 . -12) (f259521 . -8) (#f . 16) ((begin) . 12) ((not (primitive-ref for-each)) . 8) (if . 4))
# expr=(if (not (null? f259522)) (begin (begin (f259521 (car f259522)) ((primitive-ref for-each) f259521 (cdr f259522)))) #f)
# emit-expr (not (null? f259522))
# emit-expr (null? f259522)
# emit-expr f259522
# emit-variable-ref
# env=((f259522 . -20) (f259521 . -16) (f259522 . -12) (f259521 . -8) (#f . 16) ((begin) . 12) ((not (primitive-ref for-each)) . 8) (if . 4))
# var=f259522
    movl -20(%esp), %eax  # stack load f259522
# end emit-variable-ref
    cmp $63, %eax
    mov $0, %eax
    sete %al
    movzbl %al, %eax
    sal $6, %al
    or $47, %al
    cmp $47, %eax
    sete %al
    movzbl %al, %eax
    sal $6, %al
    or $47, %al
    cmp $47, %al
    je _L_1577026
# emit-tail-expr
# si=-24
# env=((f259522 . -20) (f259521 . -16) (f259522 . -12) (f259521 . -8) (#f . 16) ((begin) . 12) ((not (primitive-ref for-each)) . 8) (if . 4))
# expr=(begin (begin (f259521 (car f259522)) ((primitive-ref for-each) f259521 (cdr f259522))))
# tail-begin (begin (begin (f259521 (car f259522)) ((primitive-ref for-each) f259521 (cdr f259522))))
#   env=((f259522 . -20) (f259521 . -16) (f259522 . -12) (f259521 . -8) (#f . 16) ((begin) . 12) ((not (primitive-ref for-each)) . 8) (if . 4))
# emit-tail-expr
# si=-24
# env=((f259522 . -20) (f259521 . -16) (f259522 . -12) (f259521 . -8) (#f . 16) ((begin) . 12) ((not (primitive-ref for-each)) . 8) (if . 4))
# expr=(begin (f259521 (car f259522)) ((primitive-ref for-each) f259521 (cdr f259522)))
# tail-begin (begin (f259521 (car f259522)) ((primitive-ref for-each) f259521 (cdr f259522)))
#   env=((f259522 . -20) (f259521 . -16) (f259522 . -12) (f259521 . -8) (#f . 16) ((begin) . 12) ((not (primitive-ref for-each)) . 8) (if . 4))
# emit-expr (f259521 (car f259522))
# funcall
#    si   =-24
#    env  = ((f259522 . -20) (f259521 . -16) (f259522 . -12) (f259521 . -8) (#f . 16) ((begin) . 12) ((not (primitive-ref for-each)) . 8) (if . 4))
#    expr = (funcall f259521 (car f259522))
# emit-expr f259521
# emit-variable-ref
# env=((f259522 . -20) (f259521 . -16) (f259522 . -12) (f259521 . -8) (#f . 16) ((begin) . 12) ((not (primitive-ref for-each)) . 8) (if . 4))
# var=f259521
    movl -16(%esp), %eax  # stack load f259521
# end emit-variable-ref
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1577028"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1577028":
   movl %eax,  -32(%esp)  # stash funcall-oper in closure slot
# emit-expr (car f259522)
# emit-expr f259522
# emit-variable-ref
# env=((f259522 . -20) (f259521 . -16) (f259522 . -12) (f259521 . -8) (#f . 16) ((begin) . 12) ((not (primitive-ref for-each)) . 8) (if . 4))
# var=f259522
    movl -20(%esp), %eax  # stack load f259522
# end emit-variable-ref
# check the argument is a pair
    movl %eax,%ebx
    and $7, %bl
    cmp $1, %bl
    je _L_1577029
# invoke error handler eh_pair
    .extern mrc_eh$upair
    movl mrc_eh$upair, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $108,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1577029:
    movl -1(%eax), %eax
    mov %eax, -36(%esp)  # arg (car f259522)
    movl -32(%esp), %edi   # load new closure to %edi
    add $-24, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $24, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
# emit-tail-expr
# si=-24
# env=((f259522 . -20) (f259521 . -16) (f259522 . -12) (f259521 . -8) (#f . 16) ((begin) . 12) ((not (primitive-ref for-each)) . 8) (if . 4))
# expr=(begin ((primitive-ref for-each) f259521 (cdr f259522)))
# tail-begin (begin ((primitive-ref for-each) f259521 (cdr f259522)))
#   env=((f259522 . -20) (f259521 . -16) (f259522 . -12) (f259521 . -8) (#f . 16) ((begin) . 12) ((not (primitive-ref for-each)) . 8) (if . 4))
# emit-tail-expr
# si=-24
# env=((f259522 . -20) (f259521 . -16) (f259522 . -12) (f259521 . -8) (#f . 16) ((begin) . 12) ((not (primitive-ref for-each)) . 8) (if . 4))
# expr=((primitive-ref for-each) f259521 (cdr f259522))
# emit-tail-funcall
#    si   =-24
#    env  = ((f259522 . -20) (f259521 . -16) (f259522 . -12) (f259521 . -8) (#f . 16) ((begin) . 12) ((not (primitive-ref for-each)) . 8) (if . 4))
#    expr = (funcall (primitive-ref for-each) f259521 (cdr f259522))
# emit-expr (primitive-ref for-each)
    .extern mrc_for$meach
    movl mrc_for$meach,%eax
   movl %eax,  -24(%esp)  # stash funcall-oper in next closure slot
# emit-expr f259521
# emit-variable-ref
# env=((f259522 . -20) (f259521 . -16) (f259522 . -12) (f259521 . -8) (#f . 16) ((begin) . 12) ((not (primitive-ref for-each)) . 8) (if . 4))
# var=f259521
    movl -16(%esp), %eax  # stack load f259521
# end emit-variable-ref
    mov %eax, -28(%esp)    # arg f259521
# emit-expr (cdr f259522)
# emit-expr f259522
# emit-variable-ref
# env=((f259522 . -20) (f259521 . -16) (f259522 . -12) (f259521 . -8) (#f . 16) ((begin) . 12) ((not (primitive-ref for-each)) . 8) (if . 4))
# var=f259522
    movl -20(%esp), %eax  # stack load f259522
# end emit-variable-ref
# check the argument is a pair
    movl %eax,%ebx
    and $7, %bl
    cmp $1, %bl
    je _L_1577030
# invoke error handler eh_pair
    .extern mrc_eh$upair
    movl mrc_eh$upair, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $112,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1577030:
    movl 3(%eax), %eax
    mov %eax, -32(%esp)    # arg (cdr f259522)
    movl -24(%esp), %edi   # load new closure to %edi
# emit-shift-args:  size=3   si=-24  delta=20
    mov -24(%esp), %ebx  # shift frame cell
    mov %ebx, -4(%esp)  # down to base
# emit-shift-args:  size=2   si=-28  delta=20
    mov -28(%esp), %ebx  # shift frame cell
    mov %ebx, -8(%esp)  # down to base
# emit-shift-args:  size=1   si=-32  delta=20
    mov -32(%esp), %ebx  # shift frame cell
    mov %ebx, -12(%esp)  # down to base
# emit-shift-args:  size=0   si=-36  delta=20
    movl $8,%eax   # save arg count
    jmp *-2(%edi)  # tail-funcall
     ret   # return thru stack
     ret   # return thru stack
    jmp _L_1577027
_L_1577026:
# emit-tail-expr
# si=-24
# env=((f259522 . -20) (f259521 . -16) (f259522 . -12) (f259521 . -8) (#f . 16) ((begin) . 12) ((not (primitive-ref for-each)) . 8) (if . 4))
# expr=#f
    movl $47, %eax     # immed #f
    ret                  # immediate tail return
_L_1577027:
    .align 4,0x90
_L_1577024:
     movl %eax, mrc_for$meach
# == explicit-begins  ==>
# (let ((p (make-vector 6)) (sz 1024)) (begin (vector-set! p 0 (quote output-port)) (vector-set! p 1 "/dev/stdout") (vector-set! p 2 1) (vector-set! p 3 (make-string sz)) (vector-set! p 4 0) (vector-set! p 5 sz) p))
# == eliminate-let*  ==>
# (let ((p (make-vector 6)) (sz 1024)) (begin (vector-set! p 0 (quote output-port)) (vector-set! p 1 "/dev/stdout") (vector-set! p 2 1) (vector-set! p 3 (make-string sz)) (vector-set! p 4 0) (vector-set! p 5 sz) p))
# == uniquify-variables  ==>
# (let ((f259524 (make-vector 6)) (f259523 1024)) (begin (vector-set! f259524 0 (quote output-port)) (vector-set! f259524 1 "/dev/stdout") (vector-set! f259524 2 1) (vector-set! f259524 3 (make-string f259523)) (vector-set! f259524 4 0) (vector-set! f259524 5 f259523) f259524))
# == vectorize-letrec  ==>
# (let ((f259524 (make-vector 6)) (f259523 1024)) (begin (vector-set! f259524 0 (quote output-port)) (vector-set! f259524 1 "/dev/stdout") (vector-set! f259524 2 1) (vector-set! f259524 3 (make-string f259523)) (vector-set! f259524 4 0) (vector-set! f259524 5 f259523) f259524))
# == eliminate-set!  ==>
# (let ((f259524 (make-vector 6)) (f259523 1024)) (begin (vector-set! f259524 0 (quote output-port)) (vector-set! f259524 1 "/dev/stdout") (vector-set! f259524 2 1) (vector-set! f259524 3 (make-string f259523)) (vector-set! f259524 4 0) (vector-set! f259524 5 f259523) f259524))
# == close-free-variables  ==>
# (let ((f259524 (make-vector 6)) (f259523 1024)) (begin (vector-set! f259524 0 (quote output-port)) (vector-set! f259524 1 "/dev/stdout") (vector-set! f259524 2 1) (vector-set! f259524 3 (make-string f259523)) (vector-set! f259524 4 0) (vector-set! f259524 5 f259523) f259524))
# == eliminate-quote  ==>
# (let ((f259524 (make-vector 6)) (f259523 1024)) (begin (vector-set! f259524 0 (string->symbol "output-port")) (vector-set! f259524 1 "/dev/stdout") (vector-set! f259524 2 1) (vector-set! f259524 3 (make-string f259523)) (vector-set! f259524 4 0) (vector-set! f259524 5 f259523) f259524))
# == eliminate-when/unless  ==>
# (let ((f259524 (make-vector 6)) (f259523 1024)) (begin (vector-set! f259524 0 (string->symbol "output-port")) (vector-set! f259524 1 "/dev/stdout") (vector-set! f259524 2 1) (vector-set! f259524 3 (make-string f259523)) (vector-set! f259524 4 0) (vector-set! f259524 5 f259523) f259524))
# == eliminate-cond  ==>
# (let ((f259524 (make-vector 6)) (f259523 1024)) (begin (vector-set! f259524 0 (string->symbol "output-port")) (vector-set! f259524 1 "/dev/stdout") (vector-set! f259524 2 1) (vector-set! f259524 3 (make-string f259523)) (vector-set! f259524 4 0) (vector-set! f259524 5 f259523) f259524))
# == external-symbols  ==>
# (let ((f259524 (make-vector 6)) (f259523 1024)) (begin (vector-set! f259524 0 ((primitive-ref string->symbol) "output-port")) (vector-set! f259524 1 "/dev/stdout") (vector-set! f259524 2 1) (vector-set! f259524 3 (make-string f259523)) (vector-set! f259524 4 0) (vector-set! f259524 5 f259523) f259524))
# emit-expr (let ((f259524 (make-vector 6)) (f259523 1024)) (begin (vector-set! f259524 0 ((primitive-ref string->symbol) "output-port")) (vector-set! f259524 1 "/dev/stdout") (vector-set! f259524 2 1) (vector-set! f259524 3 (make-string f259523)) (vector-set! f259524 4 0) (vector-set! f259524 5 f259523) f259524))
# emit-let
#  si   = 0
#  env  = ()
#  bindings = ((f259524 (make-vector 6)) (f259523 1024))
#  body = (begin (vector-set! f259524 0 ((primitive-ref string->symbol) "output-port")) (vector-set! f259524 1 "/dev/stdout") (vector-set! f259524 2 1) (vector-set! f259524 3 (make-string f259523)) (vector-set! f259524 4 0) (vector-set! f259524 5 f259523) f259524)
# emit-expr (make-vector 6)
# make-vector 6
# emit-expr 6
    movl $24, %eax     # immed 6
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1577031"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $128,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1577031:
# check the argument is a fixnum >= 0
    cmp $0,%eax
    jge _L_1577032
# invoke error handler eh_length
    .extern mrc_eh$ulength
    movl mrc_eh$ulength, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $128,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1577032:
    movl %eax, %esi
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    orl  $5, %eax
    addl $4, %esi
    addl $4, %esi
    andl $-8, %esi
    addl %esi, %ebp
    movl %eax, 0(%esp)  # stack save
# emit-expr 1024
    movl $4096, %eax     # immed 1024
    movl %eax, -4(%esp)  # stack save
# emit-expr (begin (vector-set! f259524 0 ((primitive-ref string->symbol) "output-port")) (vector-set! f259524 1 "/dev/stdout") (vector-set! f259524 2 1) (vector-set! f259524 3 (make-string f259523)) (vector-set! f259524 4 0) (vector-set! f259524 5 f259523) f259524)
# emit-begin
#   expr=(begin (vector-set! f259524 0 ((primitive-ref string->symbol) "output-port")) (vector-set! f259524 1 "/dev/stdout") (vector-set! f259524 2 1) (vector-set! f259524 3 (make-string f259523)) (vector-set! f259524 4 0) (vector-set! f259524 5 f259523) f259524)
#   env=((f259523 . -4) (f259524 . 0))
# emit-expr (vector-set! f259524 0 ((primitive-ref string->symbol) "output-port"))
# emit-expr f259524
# emit-variable-ref
# env=((f259523 . -4) (f259524 . 0))
# var=f259524
    movl 0(%esp), %eax  # stack load f259524
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1577033
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1577033:
    movl %eax, -8(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1577034"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1577034:
# check bounds on vector index
    movl -8(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1577036
    cmp  $0,%eax
    jge _L_1577035
_L_1577036:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1577035:
    movl %eax, -12(%esp)
# emit-expr ((primitive-ref string->symbol) "output-port")
# funcall
#    si   =-16
#    env  = ((f259523 . -4) (f259524 . 0))
#    expr = (funcall (primitive-ref string->symbol) "output-port")
# emit-expr (primitive-ref string->symbol)
    .extern mrc_string$m$gsymbol
    movl mrc_string$m$gsymbol,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1577037"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1577037":
   movl %eax,  -24(%esp)  # stash funcall-oper in closure slot
# emit-expr "output-port"
# string literal
    jmp _L_1577039
    .align 8,0x90
_L_1577038 :
    .int 44
    .ascii "output-port"
_L_1577039:
    movl $_L_1577038, %eax
    orl $6, %eax
    mov %eax, -28(%esp)  # arg output-port
    movl -24(%esp), %edi   # load new closure to %edi
    add $-16, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $16, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    movl -8(%esp), %ebx
    movl -12(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin (vector-set! f259524 1 "/dev/stdout") (vector-set! f259524 2 1) (vector-set! f259524 3 (make-string f259523)) (vector-set! f259524 4 0) (vector-set! f259524 5 f259523) f259524)
# emit-begin
#   expr=(begin (vector-set! f259524 1 "/dev/stdout") (vector-set! f259524 2 1) (vector-set! f259524 3 (make-string f259523)) (vector-set! f259524 4 0) (vector-set! f259524 5 f259523) f259524)
#   env=((f259523 . -4) (f259524 . 0))
# emit-expr (vector-set! f259524 1 "/dev/stdout")
# emit-expr f259524
# emit-variable-ref
# env=((f259523 . -4) (f259524 . 0))
# var=f259524
    movl 0(%esp), %eax  # stack load f259524
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1577040
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1577040:
    movl %eax, -8(%esp)
# emit-expr 1
    movl $4, %eax     # immed 1
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1577041"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1577041:
# check bounds on vector index
    movl -8(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1577043
    cmp  $0,%eax
    jge _L_1577042
_L_1577043:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1577042:
    movl %eax, -12(%esp)
# emit-expr "/dev/stdout"
# string literal
    jmp _L_1577045
    .align 8,0x90
_L_1577044 :
    .int 44
    .ascii "/dev/stdout"
_L_1577045:
    movl $_L_1577044, %eax
    orl $6, %eax
    movl -8(%esp), %ebx
    movl -12(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin (vector-set! f259524 2 1) (vector-set! f259524 3 (make-string f259523)) (vector-set! f259524 4 0) (vector-set! f259524 5 f259523) f259524)
# emit-begin
#   expr=(begin (vector-set! f259524 2 1) (vector-set! f259524 3 (make-string f259523)) (vector-set! f259524 4 0) (vector-set! f259524 5 f259523) f259524)
#   env=((f259523 . -4) (f259524 . 0))
# emit-expr (vector-set! f259524 2 1)
# emit-expr f259524
# emit-variable-ref
# env=((f259523 . -4) (f259524 . 0))
# var=f259524
    movl 0(%esp), %eax  # stack load f259524
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1577046
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1577046:
    movl %eax, -8(%esp)
# emit-expr 2
    movl $8, %eax     # immed 2
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1577047"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1577047:
# check bounds on vector index
    movl -8(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1577049
    cmp  $0,%eax
    jge _L_1577048
_L_1577049:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1577048:
    movl %eax, -12(%esp)
# emit-expr 1
    movl $4, %eax     # immed 1
    movl -8(%esp), %ebx
    movl -12(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin (vector-set! f259524 3 (make-string f259523)) (vector-set! f259524 4 0) (vector-set! f259524 5 f259523) f259524)
# emit-begin
#   expr=(begin (vector-set! f259524 3 (make-string f259523)) (vector-set! f259524 4 0) (vector-set! f259524 5 f259523) f259524)
#   env=((f259523 . -4) (f259524 . 0))
# emit-expr (vector-set! f259524 3 (make-string f259523))
# emit-expr f259524
# emit-variable-ref
# env=((f259523 . -4) (f259524 . 0))
# var=f259524
    movl 0(%esp), %eax  # stack load f259524
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1577050
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1577050:
    movl %eax, -8(%esp)
# emit-expr 3
    movl $12, %eax     # immed 3
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1577051"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1577051:
# check bounds on vector index
    movl -8(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1577053
    cmp  $0,%eax
    jge _L_1577052
_L_1577053:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1577052:
    movl %eax, -12(%esp)
# emit-expr (make-string f259523)
# make-string len=f259523
# emit-expr f259523
# emit-variable-ref
# env=((f259523 . -4) (f259524 . 0))
# var=f259523
    movl -4(%esp), %eax  # stack load f259523
# end emit-variable-ref
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1577054"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1577054:
# check the argument is a fixnum >= 0
    cmp $0,%eax
    jge _L_1577055
# invoke error handler eh_length
    .extern mrc_eh$ulength
    movl mrc_eh$ulength, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1577055:
    movl %eax, %esi
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    orl $6, %eax
    sar $2, %esi
    add $4, %esi
    add $7, %esi
    andl $-8, %esi
    add  %esi, %ebp
# make-string end
    movl -8(%esp), %ebx
    movl -12(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin (vector-set! f259524 4 0) (vector-set! f259524 5 f259523) f259524)
# emit-begin
#   expr=(begin (vector-set! f259524 4 0) (vector-set! f259524 5 f259523) f259524)
#   env=((f259523 . -4) (f259524 . 0))
# emit-expr (vector-set! f259524 4 0)
# emit-expr f259524
# emit-variable-ref
# env=((f259523 . -4) (f259524 . 0))
# var=f259524
    movl 0(%esp), %eax  # stack load f259524
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1577056
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1577056:
    movl %eax, -8(%esp)
# emit-expr 4
    movl $16, %eax     # immed 4
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1577057"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1577057:
# check bounds on vector index
    movl -8(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1577059
    cmp  $0,%eax
    jge _L_1577058
_L_1577059:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1577058:
    movl %eax, -12(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
    movl -8(%esp), %ebx
    movl -12(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin (vector-set! f259524 5 f259523) f259524)
# emit-begin
#   expr=(begin (vector-set! f259524 5 f259523) f259524)
#   env=((f259523 . -4) (f259524 . 0))
# emit-expr (vector-set! f259524 5 f259523)
# emit-expr f259524
# emit-variable-ref
# env=((f259523 . -4) (f259524 . 0))
# var=f259524
    movl 0(%esp), %eax  # stack load f259524
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1577060
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1577060:
    movl %eax, -8(%esp)
# emit-expr 5
    movl $20, %eax     # immed 5
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1577061"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1577061:
# check bounds on vector index
    movl -8(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1577063
    cmp  $0,%eax
    jge _L_1577062
_L_1577063:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1577062:
    movl %eax, -12(%esp)
# emit-expr f259523
# emit-variable-ref
# env=((f259523 . -4) (f259524 . 0))
# var=f259523
    movl -4(%esp), %eax  # stack load f259523
# end emit-variable-ref
    movl -8(%esp), %ebx
    movl -12(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin f259524)
# emit-begin
#   expr=(begin f259524)
#   env=((f259523 . -4) (f259524 . 0))
# emit-expr f259524
# emit-variable-ref
# env=((f259523 . -4) (f259524 . 0))
# var=f259524
    movl 0(%esp), %eax  # stack load f259524
# end emit-variable-ref
# emit-expr (begin)
# emit-begin
#   expr=(begin)
#   env=((f259523 . -4) (f259524 . 0))
     movl %eax, mrc_standard$mout
# == explicit-begins  ==>
# (let ((current-out standard-out)) (lambda () current-out))
# == eliminate-let*  ==>
# (let ((current-out standard-out)) (lambda () current-out))
# == uniquify-variables  ==>
# (let ((f259525 standard-out)) (lambda () f259525))
# == vectorize-letrec  ==>
# (let ((f259525 standard-out)) (lambda () f259525))
# == eliminate-set!  ==>
# (let ((f259525 standard-out)) (lambda () (let () f259525)))
# == close-free-variables  ==>
# (let ((f259525 standard-out)) (closure () (f259525) (let () f259525)))
# == eliminate-quote  ==>
# (let ((f259525 standard-out)) (closure () (f259525) (let () f259525)))
# == eliminate-when/unless  ==>
# (let ((f259525 standard-out)) (closure () (f259525) (let () f259525)))
# == eliminate-cond  ==>
# (let ((f259525 standard-out)) (closure () (f259525) (let () f259525)))
# == external-symbols  ==>
# (let ((f259525 (primitive-ref standard-out))) (closure () (f259525) (let () f259525)))
# emit-expr (let ((f259525 (primitive-ref standard-out))) (closure () (f259525) (let () f259525)))
# emit-let
#  si   = 0
#  env  = ()
#  bindings = ((f259525 (primitive-ref standard-out)))
#  body = (closure () (f259525) (let () f259525))
# emit-expr (primitive-ref standard-out)
    .extern mrc_standard$mout
    movl mrc_standard$mout,%eax
    movl %eax, 0(%esp)  # stack save
# emit-expr (closure () (f259525) (let () f259525))
# emit-closure
# si = -4
# env = ((f259525 . 0))
# expr = (closure () (f259525) (let () f259525))
    movl $_L_1577064, 0(%ebp)  # closure label
# emit-variable-ref
# env=((f259525 . 0))
# var=f259525
    movl 0(%esp), %eax  # stack load f259525
# end emit-variable-ref
   movl  %eax, 4(%ebp)  # f259525
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $8, %ebp     # bump ebp
    jmp _L_1577065            # jump around closure body
_L_1577064:
# check argument count
    cmp $0,%eax
    je _L_1577066
# invoke error handler eh_argcount
    .extern mrc_eh$uargcount
    movl mrc_eh$uargcount, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_1577066:
# emit-tail-expr
# si=-8
# env=((f259525 . 4) (f259525 . 0))
# expr=(let () f259525)
# emit-tail-let
#  si   = -8
#  env  = ((f259525 . 4) (f259525 . 0))
#  bindings = ()
#  body = f259525
# emit-tail-expr
# si=-8
# env=((f259525 . 4) (f259525 . 0))
# expr=f259525
# emit-tail-variable-ref
# emit-variable-ref
# env=((f259525 . 4) (f259525 . 0))
# var=f259525
    movl 2(%edi), %eax  # frame load f259525
# end emit-variable-ref
    ret
# end emit-tail-variable ref
    .align 4,0x90
_L_1577065:
     movl %eax, mrc_current$moutput$mport
# == explicit-begins  ==>
# (lambda (p) (vector-ref p 0))
# == eliminate-let*  ==>
# (lambda (p) (vector-ref p 0))
# == uniquify-variables  ==>
# (lambda (f259526) (vector-ref f259526 0))
# == vectorize-letrec  ==>
# (lambda (f259526) (vector-ref f259526 0))
# == eliminate-set!  ==>
# (lambda (f259526) (let ((f259526 f259526)) (vector-ref f259526 0)))
# == close-free-variables  ==>
# (closure (f259526) () (let ((f259526 f259526)) (vector-ref f259526 0)))
# == eliminate-quote  ==>
# (closure (f259526) () (let ((f259526 f259526)) (vector-ref f259526 0)))
# == eliminate-when/unless  ==>
# (closure (f259526) () (let ((f259526 f259526)) (vector-ref f259526 0)))
# == eliminate-cond  ==>
# (closure (f259526) () (let ((f259526 f259526)) (vector-ref f259526 0)))
# == external-symbols  ==>
# (closure (f259526) () (let ((f259526 f259526)) (vector-ref f259526 0)))
# emit-expr (closure (f259526) () (let ((f259526 f259526)) (vector-ref f259526 0)))
# emit-closure
# si = 0
# env = ()
# expr = (closure (f259526) () (let ((f259526 f259526)) (vector-ref f259526 0)))
    movl $_L_1577067, 0(%ebp)  # closure label
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $8, %ebp     # bump ebp
    jmp _L_1577068            # jump around closure body
_L_1577067:
# check argument count
    cmp $4,%eax
    je _L_1577069
# invoke error handler eh_argcount
    .extern mrc_eh$uargcount
    movl mrc_eh$uargcount, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_1577069:
# emit-tail-expr
# si=-12
# env=((f259526 . -8))
# expr=(let ((f259526 f259526)) (vector-ref f259526 0))
# emit-tail-let
#  si   = -12
#  env  = ((f259526 . -8))
#  bindings = ((f259526 f259526))
#  body = (vector-ref f259526 0)
# emit-expr f259526
# emit-variable-ref
# env=((f259526 . -8))
# var=f259526
    movl -8(%esp), %eax  # stack load f259526
# end emit-variable-ref
    movl %eax, -12(%esp)  # stack save
# emit-tail-expr
# si=-16
# env=((f259526 . -12) (f259526 . -8))
# expr=(vector-ref f259526 0)
# tail primcall
# emit-expr f259526
# emit-variable-ref
# env=((f259526 . -12) (f259526 . -8))
# var=f259526
    movl -12(%esp), %eax  # stack load f259526
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1577070
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1577070:
    movl %eax, -16(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1577071"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1577071:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1577073
    cmp  $0,%eax
    jge _L_1577072
_L_1577073:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1577072:
    movl -16(%esp), %esi
    movl -1(%eax,%esi), %eax
#return from tail (vector-ref f259526 0)
    ret
    .align 4,0x90
_L_1577068:
     movl %eax, mrc_port$mkind
# == explicit-begins  ==>
# (lambda (p) (vector-ref p 1))
# == eliminate-let*  ==>
# (lambda (p) (vector-ref p 1))
# == uniquify-variables  ==>
# (lambda (f259527) (vector-ref f259527 1))
# == vectorize-letrec  ==>
# (lambda (f259527) (vector-ref f259527 1))
# == eliminate-set!  ==>
# (lambda (f259527) (let ((f259527 f259527)) (vector-ref f259527 1)))
# == close-free-variables  ==>
# (closure (f259527) () (let ((f259527 f259527)) (vector-ref f259527 1)))
# == eliminate-quote  ==>
# (closure (f259527) () (let ((f259527 f259527)) (vector-ref f259527 1)))
# == eliminate-when/unless  ==>
# (closure (f259527) () (let ((f259527 f259527)) (vector-ref f259527 1)))
# == eliminate-cond  ==>
# (closure (f259527) () (let ((f259527 f259527)) (vector-ref f259527 1)))
# == external-symbols  ==>
# (closure (f259527) () (let ((f259527 f259527)) (vector-ref f259527 1)))
# emit-expr (closure (f259527) () (let ((f259527 f259527)) (vector-ref f259527 1)))
# emit-closure
# si = 0
# env = ()
# expr = (closure (f259527) () (let ((f259527 f259527)) (vector-ref f259527 1)))
    movl $_L_1577074, 0(%ebp)  # closure label
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $8, %ebp     # bump ebp
    jmp _L_1577075            # jump around closure body
_L_1577074:
# check argument count
    cmp $4,%eax
    je _L_1577076
# invoke error handler eh_argcount
    .extern mrc_eh$uargcount
    movl mrc_eh$uargcount, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_1577076:
# emit-tail-expr
# si=-12
# env=((f259527 . -8))
# expr=(let ((f259527 f259527)) (vector-ref f259527 1))
# emit-tail-let
#  si   = -12
#  env  = ((f259527 . -8))
#  bindings = ((f259527 f259527))
#  body = (vector-ref f259527 1)
# emit-expr f259527
# emit-variable-ref
# env=((f259527 . -8))
# var=f259527
    movl -8(%esp), %eax  # stack load f259527
# end emit-variable-ref
    movl %eax, -12(%esp)  # stack save
# emit-tail-expr
# si=-16
# env=((f259527 . -12) (f259527 . -8))
# expr=(vector-ref f259527 1)
# tail primcall
# emit-expr f259527
# emit-variable-ref
# env=((f259527 . -12) (f259527 . -8))
# var=f259527
    movl -12(%esp), %eax  # stack load f259527
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1577077
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1577077:
    movl %eax, -16(%esp)
# emit-expr 1
    movl $4, %eax     # immed 1
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1577078"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1577078:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1577080
    cmp  $0,%eax
    jge _L_1577079
_L_1577080:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1577079:
    movl -16(%esp), %esi
    movl -1(%eax,%esi), %eax
#return from tail (vector-ref f259527 1)
    ret
    .align 4,0x90
_L_1577075:
     movl %eax, mrc_port$mpath
# == explicit-begins  ==>
# (lambda (p) (vector-ref p 2))
# == eliminate-let*  ==>
# (lambda (p) (vector-ref p 2))
# == uniquify-variables  ==>
# (lambda (f259528) (vector-ref f259528 2))
# == vectorize-letrec  ==>
# (lambda (f259528) (vector-ref f259528 2))
# == eliminate-set!  ==>
# (lambda (f259528) (let ((f259528 f259528)) (vector-ref f259528 2)))
# == close-free-variables  ==>
# (closure (f259528) () (let ((f259528 f259528)) (vector-ref f259528 2)))
# == eliminate-quote  ==>
# (closure (f259528) () (let ((f259528 f259528)) (vector-ref f259528 2)))
# == eliminate-when/unless  ==>
# (closure (f259528) () (let ((f259528 f259528)) (vector-ref f259528 2)))
# == eliminate-cond  ==>
# (closure (f259528) () (let ((f259528 f259528)) (vector-ref f259528 2)))
# == external-symbols  ==>
# (closure (f259528) () (let ((f259528 f259528)) (vector-ref f259528 2)))
# emit-expr (closure (f259528) () (let ((f259528 f259528)) (vector-ref f259528 2)))
# emit-closure
# si = 0
# env = ()
# expr = (closure (f259528) () (let ((f259528 f259528)) (vector-ref f259528 2)))
    movl $_L_1577081, 0(%ebp)  # closure label
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $8, %ebp     # bump ebp
    jmp _L_1577082            # jump around closure body
_L_1577081:
# check argument count
    cmp $4,%eax
    je _L_1577083
# invoke error handler eh_argcount
    .extern mrc_eh$uargcount
    movl mrc_eh$uargcount, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_1577083:
# emit-tail-expr
# si=-12
# env=((f259528 . -8))
# expr=(let ((f259528 f259528)) (vector-ref f259528 2))
# emit-tail-let
#  si   = -12
#  env  = ((f259528 . -8))
#  bindings = ((f259528 f259528))
#  body = (vector-ref f259528 2)
# emit-expr f259528
# emit-variable-ref
# env=((f259528 . -8))
# var=f259528
    movl -8(%esp), %eax  # stack load f259528
# end emit-variable-ref
    movl %eax, -12(%esp)  # stack save
# emit-tail-expr
# si=-16
# env=((f259528 . -12) (f259528 . -8))
# expr=(vector-ref f259528 2)
# tail primcall
# emit-expr f259528
# emit-variable-ref
# env=((f259528 . -12) (f259528 . -8))
# var=f259528
    movl -12(%esp), %eax  # stack load f259528
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1577084
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1577084:
    movl %eax, -16(%esp)
# emit-expr 2
    movl $8, %eax     # immed 2
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1577085"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1577085:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1577087
    cmp  $0,%eax
    jge _L_1577086
_L_1577087:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1577086:
    movl -16(%esp), %esi
    movl -1(%eax,%esi), %eax
#return from tail (vector-ref f259528 2)
    ret
    .align 4,0x90
_L_1577082:
     movl %eax, mrc_port$mfd
# == explicit-begins  ==>
# (lambda (p) (vector-ref p 3))
# == eliminate-let*  ==>
# (lambda (p) (vector-ref p 3))
# == uniquify-variables  ==>
# (lambda (f259529) (vector-ref f259529 3))
# == vectorize-letrec  ==>
# (lambda (f259529) (vector-ref f259529 3))
# == eliminate-set!  ==>
# (lambda (f259529) (let ((f259529 f259529)) (vector-ref f259529 3)))
# == close-free-variables  ==>
# (closure (f259529) () (let ((f259529 f259529)) (vector-ref f259529 3)))
# == eliminate-quote  ==>
# (closure (f259529) () (let ((f259529 f259529)) (vector-ref f259529 3)))
# == eliminate-when/unless  ==>
# (closure (f259529) () (let ((f259529 f259529)) (vector-ref f259529 3)))
# == eliminate-cond  ==>
# (closure (f259529) () (let ((f259529 f259529)) (vector-ref f259529 3)))
# == external-symbols  ==>
# (closure (f259529) () (let ((f259529 f259529)) (vector-ref f259529 3)))
# emit-expr (closure (f259529) () (let ((f259529 f259529)) (vector-ref f259529 3)))
# emit-closure
# si = 0
# env = ()
# expr = (closure (f259529) () (let ((f259529 f259529)) (vector-ref f259529 3)))
    movl $_L_1577088, 0(%ebp)  # closure label
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $8, %ebp     # bump ebp
    jmp _L_1577089            # jump around closure body
_L_1577088:
# check argument count
    cmp $4,%eax
    je _L_1577090
# invoke error handler eh_argcount
    .extern mrc_eh$uargcount
    movl mrc_eh$uargcount, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_1577090:
# emit-tail-expr
# si=-12
# env=((f259529 . -8))
# expr=(let ((f259529 f259529)) (vector-ref f259529 3))
# emit-tail-let
#  si   = -12
#  env  = ((f259529 . -8))
#  bindings = ((f259529 f259529))
#  body = (vector-ref f259529 3)
# emit-expr f259529
# emit-variable-ref
# env=((f259529 . -8))
# var=f259529
    movl -8(%esp), %eax  # stack load f259529
# end emit-variable-ref
    movl %eax, -12(%esp)  # stack save
# emit-tail-expr
# si=-16
# env=((f259529 . -12) (f259529 . -8))
# expr=(vector-ref f259529 3)
# tail primcall
# emit-expr f259529
# emit-variable-ref
# env=((f259529 . -12) (f259529 . -8))
# var=f259529
    movl -12(%esp), %eax  # stack load f259529
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1577091
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1577091:
    movl %eax, -16(%esp)
# emit-expr 3
    movl $12, %eax     # immed 3
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1577092"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1577092:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1577094
    cmp  $0,%eax
    jge _L_1577093
_L_1577094:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1577093:
    movl -16(%esp), %esi
    movl -1(%eax,%esi), %eax
#return from tail (vector-ref f259529 3)
    ret
    .align 4,0x90
_L_1577089:
     movl %eax, mrc_port$mbuf
# == explicit-begins  ==>
# (lambda (p) (vector-ref p 4))
# == eliminate-let*  ==>
# (lambda (p) (vector-ref p 4))
# == uniquify-variables  ==>
# (lambda (f259530) (vector-ref f259530 4))
# == vectorize-letrec  ==>
# (lambda (f259530) (vector-ref f259530 4))
# == eliminate-set!  ==>
# (lambda (f259530) (let ((f259530 f259530)) (vector-ref f259530 4)))
# == close-free-variables  ==>
# (closure (f259530) () (let ((f259530 f259530)) (vector-ref f259530 4)))
# == eliminate-quote  ==>
# (closure (f259530) () (let ((f259530 f259530)) (vector-ref f259530 4)))
# == eliminate-when/unless  ==>
# (closure (f259530) () (let ((f259530 f259530)) (vector-ref f259530 4)))
# == eliminate-cond  ==>
# (closure (f259530) () (let ((f259530 f259530)) (vector-ref f259530 4)))
# == external-symbols  ==>
# (closure (f259530) () (let ((f259530 f259530)) (vector-ref f259530 4)))
# emit-expr (closure (f259530) () (let ((f259530 f259530)) (vector-ref f259530 4)))
# emit-closure
# si = 0
# env = ()
# expr = (closure (f259530) () (let ((f259530 f259530)) (vector-ref f259530 4)))
    movl $_L_1577095, 0(%ebp)  # closure label
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $8, %ebp     # bump ebp
    jmp _L_1577096            # jump around closure body
_L_1577095:
# check argument count
    cmp $4,%eax
    je _L_1577097
# invoke error handler eh_argcount
    .extern mrc_eh$uargcount
    movl mrc_eh$uargcount, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_1577097:
# emit-tail-expr
# si=-12
# env=((f259530 . -8))
# expr=(let ((f259530 f259530)) (vector-ref f259530 4))
# emit-tail-let
#  si   = -12
#  env  = ((f259530 . -8))
#  bindings = ((f259530 f259530))
#  body = (vector-ref f259530 4)
# emit-expr f259530
# emit-variable-ref
# env=((f259530 . -8))
# var=f259530
    movl -8(%esp), %eax  # stack load f259530
# end emit-variable-ref
    movl %eax, -12(%esp)  # stack save
# emit-tail-expr
# si=-16
# env=((f259530 . -12) (f259530 . -8))
# expr=(vector-ref f259530 4)
# tail primcall
# emit-expr f259530
# emit-variable-ref
# env=((f259530 . -12) (f259530 . -8))
# var=f259530
    movl -12(%esp), %eax  # stack load f259530
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1577098
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1577098:
    movl %eax, -16(%esp)
# emit-expr 4
    movl $16, %eax     # immed 4
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1577099"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1577099:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1577101
    cmp  $0,%eax
    jge _L_1577100
_L_1577101:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1577100:
    movl -16(%esp), %esi
    movl -1(%eax,%esi), %eax
#return from tail (vector-ref f259530 4)
    ret
    .align 4,0x90
_L_1577096:
     movl %eax, mrc_port$mndx
# == explicit-begins  ==>
# (lambda (p) (vector-set! p 4 (fxadd1 (vector-ref p 4))))
# == eliminate-let*  ==>
# (lambda (p) (vector-set! p 4 (fxadd1 (vector-ref p 4))))
# == uniquify-variables  ==>
# (lambda (f259531) (vector-set! f259531 4 (fxadd1 (vector-ref f259531 4))))
# == vectorize-letrec  ==>
# (lambda (f259531) (vector-set! f259531 4 (fxadd1 (vector-ref f259531 4))))
# == eliminate-set!  ==>
# (lambda (f259531) (let ((f259531 f259531)) (vector-set! f259531 4 (fxadd1 (vector-ref f259531 4)))))
# == close-free-variables  ==>
# (closure (f259531) () (let ((f259531 f259531)) (vector-set! f259531 4 (fxadd1 (vector-ref f259531 4)))))
# == eliminate-quote  ==>
# (closure (f259531) () (let ((f259531 f259531)) (vector-set! f259531 4 (fxadd1 (vector-ref f259531 4)))))
# == eliminate-when/unless  ==>
# (closure (f259531) () (let ((f259531 f259531)) (vector-set! f259531 4 (fxadd1 (vector-ref f259531 4)))))
# == eliminate-cond  ==>
# (closure (f259531) () (let ((f259531 f259531)) (vector-set! f259531 4 (fxadd1 (vector-ref f259531 4)))))
# == external-symbols  ==>
# (closure (f259531) () (let ((f259531 f259531)) (vector-set! f259531 4 (fxadd1 (vector-ref f259531 4)))))
# emit-expr (closure (f259531) () (let ((f259531 f259531)) (vector-set! f259531 4 (fxadd1 (vector-ref f259531 4)))))
# emit-closure
# si = 0
# env = ()
# expr = (closure (f259531) () (let ((f259531 f259531)) (vector-set! f259531 4 (fxadd1 (vector-ref f259531 4)))))
    movl $_L_1577102, 0(%ebp)  # closure label
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $8, %ebp     # bump ebp
    jmp _L_1577103            # jump around closure body
_L_1577102:
# check argument count
    cmp $4,%eax
    je _L_1577104
# invoke error handler eh_argcount
    .extern mrc_eh$uargcount
    movl mrc_eh$uargcount, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_1577104:
# emit-tail-expr
# si=-12
# env=((f259531 . -8))
# expr=(let ((f259531 f259531)) (vector-set! f259531 4 (fxadd1 (vector-ref f259531 4))))
# emit-tail-let
#  si   = -12
#  env  = ((f259531 . -8))
#  bindings = ((f259531 f259531))
#  body = (vector-set! f259531 4 (fxadd1 (vector-ref f259531 4)))
# emit-expr f259531
# emit-variable-ref
# env=((f259531 . -8))
# var=f259531
    movl -8(%esp), %eax  # stack load f259531
# end emit-variable-ref
    movl %eax, -12(%esp)  # stack save
# emit-tail-expr
# si=-16
# env=((f259531 . -12) (f259531 . -8))
# expr=(vector-set! f259531 4 (fxadd1 (vector-ref f259531 4)))
# tail primcall
# emit-expr f259531
# emit-variable-ref
# env=((f259531 . -12) (f259531 . -8))
# var=f259531
    movl -12(%esp), %eax  # stack load f259531
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1577105
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1577105:
    movl %eax, -16(%esp)
# emit-expr 4
    movl $16, %eax     # immed 4
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1577106"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1577106:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1577108
    cmp  $0,%eax
    jge _L_1577107
_L_1577108:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1577107:
    movl %eax, -20(%esp)
# emit-expr (fxadd1 (vector-ref f259531 4))
# emit-expr (vector-ref f259531 4)
# emit-expr f259531
# emit-variable-ref
# env=((f259531 . -12) (f259531 . -8))
# var=f259531
    movl -12(%esp), %eax  # stack load f259531
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1577109
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1577109:
    movl %eax, -24(%esp)
# emit-expr 4
    movl $16, %eax     # immed 4
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1577110"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1577110:
# check bounds on vector index
    movl -24(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1577112
    cmp  $0,%eax
    jge _L_1577111
_L_1577112:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1577111:
    movl -24(%esp), %esi
    movl -1(%eax,%esi), %eax
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1577113"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $48,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1577113:
     addl $4, %eax
    movl -16(%esp), %ebx
    movl -20(%esp), %esi
    movl %eax, -1(%ebx,%esi)
#return from tail (vector-set! f259531 4 (fxadd1 (vector-ref f259531 4)))
    ret
    .align 4,0x90
_L_1577103:
     movl %eax, mrc_port$mndx$madd1
# == explicit-begins  ==>
# (lambda (p) (vector-set! p 4 0))
# == eliminate-let*  ==>
# (lambda (p) (vector-set! p 4 0))
# == uniquify-variables  ==>
# (lambda (f259532) (vector-set! f259532 4 0))
# == vectorize-letrec  ==>
# (lambda (f259532) (vector-set! f259532 4 0))
# == eliminate-set!  ==>
# (lambda (f259532) (let ((f259532 f259532)) (vector-set! f259532 4 0)))
# == close-free-variables  ==>
# (closure (f259532) () (let ((f259532 f259532)) (vector-set! f259532 4 0)))
# == eliminate-quote  ==>
# (closure (f259532) () (let ((f259532 f259532)) (vector-set! f259532 4 0)))
# == eliminate-when/unless  ==>
# (closure (f259532) () (let ((f259532 f259532)) (vector-set! f259532 4 0)))
# == eliminate-cond  ==>
# (closure (f259532) () (let ((f259532 f259532)) (vector-set! f259532 4 0)))
# == external-symbols  ==>
# (closure (f259532) () (let ((f259532 f259532)) (vector-set! f259532 4 0)))
# emit-expr (closure (f259532) () (let ((f259532 f259532)) (vector-set! f259532 4 0)))
# emit-closure
# si = 0
# env = ()
# expr = (closure (f259532) () (let ((f259532 f259532)) (vector-set! f259532 4 0)))
    movl $_L_1577114, 0(%ebp)  # closure label
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $8, %ebp     # bump ebp
    jmp _L_1577115            # jump around closure body
_L_1577114:
# check argument count
    cmp $4,%eax
    je _L_1577116
# invoke error handler eh_argcount
    .extern mrc_eh$uargcount
    movl mrc_eh$uargcount, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_1577116:
# emit-tail-expr
# si=-12
# env=((f259532 . -8))
# expr=(let ((f259532 f259532)) (vector-set! f259532 4 0))
# emit-tail-let
#  si   = -12
#  env  = ((f259532 . -8))
#  bindings = ((f259532 f259532))
#  body = (vector-set! f259532 4 0)
# emit-expr f259532
# emit-variable-ref
# env=((f259532 . -8))
# var=f259532
    movl -8(%esp), %eax  # stack load f259532
# end emit-variable-ref
    movl %eax, -12(%esp)  # stack save
# emit-tail-expr
# si=-16
# env=((f259532 . -12) (f259532 . -8))
# expr=(vector-set! f259532 4 0)
# tail primcall
# emit-expr f259532
# emit-variable-ref
# env=((f259532 . -12) (f259532 . -8))
# var=f259532
    movl -12(%esp), %eax  # stack load f259532
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1577117
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1577117:
    movl %eax, -16(%esp)
# emit-expr 4
    movl $16, %eax     # immed 4
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1577118"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1577118:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1577120
    cmp  $0,%eax
    jge _L_1577119
_L_1577120:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1577119:
    movl %eax, -20(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
    movl -16(%esp), %ebx
    movl -20(%esp), %esi
    movl %eax, -1(%ebx,%esi)
#return from tail (vector-set! f259532 4 0)
    ret
    .align 4,0x90
_L_1577115:
     movl %eax, mrc_port$mndx$mreset
# == explicit-begins  ==>
# (lambda (p) (vector-ref p 5))
# == eliminate-let*  ==>
# (lambda (p) (vector-ref p 5))
# == uniquify-variables  ==>
# (lambda (f259533) (vector-ref f259533 5))
# == vectorize-letrec  ==>
# (lambda (f259533) (vector-ref f259533 5))
# == eliminate-set!  ==>
# (lambda (f259533) (let ((f259533 f259533)) (vector-ref f259533 5)))
# == close-free-variables  ==>
# (closure (f259533) () (let ((f259533 f259533)) (vector-ref f259533 5)))
# == eliminate-quote  ==>
# (closure (f259533) () (let ((f259533 f259533)) (vector-ref f259533 5)))
# == eliminate-when/unless  ==>
# (closure (f259533) () (let ((f259533 f259533)) (vector-ref f259533 5)))
# == eliminate-cond  ==>
# (closure (f259533) () (let ((f259533 f259533)) (vector-ref f259533 5)))
# == external-symbols  ==>
# (closure (f259533) () (let ((f259533 f259533)) (vector-ref f259533 5)))
# emit-expr (closure (f259533) () (let ((f259533 f259533)) (vector-ref f259533 5)))
# emit-closure
# si = 0
# env = ()
# expr = (closure (f259533) () (let ((f259533 f259533)) (vector-ref f259533 5)))
    movl $_L_1577121, 0(%ebp)  # closure label
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $8, %ebp     # bump ebp
    jmp _L_1577122            # jump around closure body
_L_1577121:
# check argument count
    cmp $4,%eax
    je _L_1577123
# invoke error handler eh_argcount
    .extern mrc_eh$uargcount
    movl mrc_eh$uargcount, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_1577123:
# emit-tail-expr
# si=-12
# env=((f259533 . -8))
# expr=(let ((f259533 f259533)) (vector-ref f259533 5))
# emit-tail-let
#  si   = -12
#  env  = ((f259533 . -8))
#  bindings = ((f259533 f259533))
#  body = (vector-ref f259533 5)
# emit-expr f259533
# emit-variable-ref
# env=((f259533 . -8))
# var=f259533
    movl -8(%esp), %eax  # stack load f259533
# end emit-variable-ref
    movl %eax, -12(%esp)  # stack save
# emit-tail-expr
# si=-16
# env=((f259533 . -12) (f259533 . -8))
# expr=(vector-ref f259533 5)
# tail primcall
# emit-expr f259533
# emit-variable-ref
# env=((f259533 . -12) (f259533 . -8))
# var=f259533
    movl -12(%esp), %eax  # stack load f259533
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1577124
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1577124:
    movl %eax, -16(%esp)
# emit-expr 5
    movl $20, %eax     # immed 5
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1577125"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1577125:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1577127
    cmp  $0,%eax
    jge _L_1577126
_L_1577127:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1577126:
    movl -16(%esp), %esi
    movl -1(%eax,%esi), %eax
#return from tail (vector-ref f259533 5)
    ret
    .align 4,0x90
_L_1577122:
     movl %eax, mrc_port$msize
# == explicit-begins  ==>
# (lambda (ch . args) (let ((p (if (null? args) (current-output-port) (car args)))) (begin (when (fx= (port-ndx p) (port-size p)) (flush-output-port p)) (string-set! (port-buf p) (port-ndx p) ch) (port-ndx-add1 p))))
# == eliminate-let*  ==>
# (lambda (ch . args) (let ((p (if (null? args) (current-output-port) (car args)))) (begin (when (fx= (port-ndx p) (port-size p)) (flush-output-port p)) (string-set! (port-buf p) (port-ndx p) ch) (port-ndx-add1 p))))
# == uniquify-variables  ==>
# (lambda (f259534 . f259535) (let ((f259537 (if (null? f259535) (current-output-port) (car f259535)))) (begin (when (fx= (port-ndx f259537) (port-size f259537)) (flush-output-port f259537)) (string-set! (port-buf f259537) (port-ndx f259537) f259534) (port-ndx-add1 f259537))))
# == vectorize-letrec  ==>
# (lambda (f259534 . f259535) (let ((f259537 (if (null? f259535) (current-output-port) (car f259535)))) (begin (when (fx= (port-ndx f259537) (port-size f259537)) (flush-output-port f259537)) (string-set! (port-buf f259537) (port-ndx f259537) f259534) (port-ndx-add1 f259537))))
# == eliminate-set!  ==>
# (lambda (f259534 . f259535) (let ((f259534 f259534)) (let ((f259537 (if (null? f259535) (current-output-port) (car f259535)))) (begin (when (fx= (port-ndx f259537) (port-size f259537)) (flush-output-port f259537)) (string-set! (port-buf f259537) (port-ndx f259537) f259534) (port-ndx-add1 f259537)))))
# == close-free-variables  ==>
# (closure (f259534 . f259535) (when port-ndx port-size flush-output-port port-buf port-ndx port-ndx-add1) (let ((f259534 f259534)) (let ((f259537 (if (null? f259535) (current-output-port) (car f259535)))) (begin (when (fx= (port-ndx f259537) (port-size f259537)) (flush-output-port f259537)) (string-set! (port-buf f259537) (port-ndx f259537) f259534) (port-ndx-add1 f259537)))))
# == eliminate-quote  ==>
# (closure (f259534 . f259535) (when port-ndx port-size flush-output-port port-buf port-ndx port-ndx-add1) (let ((f259534 f259534)) (let ((f259537 (if (null? f259535) (current-output-port) (car f259535)))) (begin (when (fx= (port-ndx f259537) (port-size f259537)) (flush-output-port f259537)) (string-set! (port-buf f259537) (port-ndx f259537) f259534) (port-ndx-add1 f259537)))))
# == eliminate-when/unless  ==>
# (closure (f259534 . f259535) (if port-ndx (begin port-size flush-output-port port-buf port-ndx port-ndx-add1) #f) (let ((f259534 f259534)) (let ((f259537 (if (null? f259535) (current-output-port) (car f259535)))) (begin (if (fx= (port-ndx f259537) (port-size f259537)) (begin (flush-output-port f259537)) #f) (string-set! (port-buf f259537) (port-ndx f259537) f259534) (port-ndx-add1 f259537)))))
# == eliminate-cond  ==>
# (closure (f259534 . f259535) (if port-ndx (begin port-size flush-output-port port-buf port-ndx port-ndx-add1) #f) (let ((f259534 f259534)) (let ((f259537 (if (null? f259535) (current-output-port) (car f259535)))) (begin (if (fx= (port-ndx f259537) (port-size f259537)) (begin (flush-output-port f259537)) #f) (string-set! (port-buf f259537) (port-ndx f259537) f259534) (port-ndx-add1 f259537)))))
# == external-symbols  ==>
# (closure (f259534 . f259535) (if (primitive-ref port-ndx) (begin (primitive-ref port-size) (primitive-ref flush-output-port) (primitive-ref port-buf) (primitive-ref port-ndx) (primitive-ref port-ndx-add1)) #f) (let ((f259534 f259534)) (let ((f259537 (if (null? f259535) ((primitive-ref current-output-port)) (car f259535)))) (begin (if (fx= ((primitive-ref port-ndx) f259537) ((primitive-ref port-size) f259537)) (begin ((primitive-ref flush-output-port) f259537)) #f) (string-set! ((primitive-ref port-buf) f259537) ((primitive-ref port-ndx) f259537) f259534) ((primitive-ref port-ndx-add1) f259537)))))
# emit-expr (closure (f259534 . f259535) (if (primitive-ref port-ndx) (begin (primitive-ref port-size) (primitive-ref flush-output-port) (primitive-ref port-buf) (primitive-ref port-ndx) (primitive-ref port-ndx-add1)) #f) (let ((f259534 f259534)) (let ((f259537 (if (null? f259535) ((primitive-ref current-output-port)) (car f259535)))) (begin (if (fx= ((primitive-ref port-ndx) f259537) ((primitive-ref port-size) f259537)) (begin ((primitive-ref flush-output-port) f259537)) #f) (string-set! ((primitive-ref port-buf) f259537) ((primitive-ref port-ndx) f259537) f259534) ((primitive-ref port-ndx-add1) f259537)))))
# emit-closure
# si = 0
# env = ()
# expr = (closure (f259534 . f259535) (if (primitive-ref port-ndx) (begin (primitive-ref port-size) (primitive-ref flush-output-port) (primitive-ref port-buf) (primitive-ref port-ndx) (primitive-ref port-ndx-add1)) #f) (let ((f259534 f259534)) (let ((f259537 (if (null? f259535) ((primitive-ref current-output-port)) (car f259535)))) (begin (if (fx= ((primitive-ref port-ndx) f259537) ((primitive-ref port-size) f259537)) (begin ((primitive-ref flush-output-port) f259537)) #f) (string-set! ((primitive-ref port-buf) f259537) ((primitive-ref port-ndx) f259537) f259534) ((primitive-ref port-ndx-add1) f259537)))))
    movl $_L_1577128, 0(%ebp)  # closure label
# WARNING: free var if not defined in the environmnet
# WARNING: free var (primitive-ref port-ndx) not defined in the environmnet
# WARNING: free var (begin (primitive-ref port-size) (primitive-ref flush-output-port) (primitive-ref port-buf) (primitive-ref port-ndx) (primitive-ref port-ndx-add1)) not defined in the environmnet
# WARNING: free var #f not defined in the environmnet
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $24, %ebp     # bump ebp
    jmp _L_1577129            # jump around closure body
_L_1577128:
# check argument count
    cmp $4,%eax
    jge _L_1577130
# invoke error handler eh_argcount_min
    .extern mrc_eh$uargcount$umin
    movl mrc_eh$uargcount$umin, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_1577130:
# emit-build-varargs-list
    movl $63, %esi       # args <- () 
    lea -4(%esp),%edi    # edi <- esp-4
    subl %eax, %edi      # edi <- esp-4-eax    addr of arg[K+N] on stack
_L_1577132:
    lea -8(%esp),%ebx    # addr of arg[K] on stack
    cmp %edi, %ebx       # while edi <> esp+(si+4)
    je _L_1577131
    movl (%edi),%ebx     # arg i -> car
    movl %ebx, 0(%ebp)
    movl %esi, 4(%ebp)  # esi -> cdr
    movl %ebp, %esi
    addl $1, %esi       # tag as pair
    addl $8,%ebp         # bump heap ptr
    addl $4,%edi         # move to next previous arg from the end
    jmp _L_1577132
_L_1577131:
    movl %esi, -12(%esp)  # set args
# emit-tail-expr
# si=-16
# env=((f259535 . -12) (f259534 . -8) (#f . 16) ((begin (primitive-ref port-size) (primitive-ref flush-output-port) (primitive-ref port-buf) (primitive-ref port-ndx) (primitive-ref port-ndx-add1)) . 12) ((primitive-ref port-ndx) . 8) (if . 4))
# expr=(let ((f259534 f259534)) (let ((f259537 (if (null? f259535) ((primitive-ref current-output-port)) (car f259535)))) (begin (if (fx= ((primitive-ref port-ndx) f259537) ((primitive-ref port-size) f259537)) (begin ((primitive-ref flush-output-port) f259537)) #f) (string-set! ((primitive-ref port-buf) f259537) ((primitive-ref port-ndx) f259537) f259534) ((primitive-ref port-ndx-add1) f259537))))
# emit-tail-let
#  si   = -16
#  env  = ((f259535 . -12) (f259534 . -8) (#f . 16) ((begin (primitive-ref port-size) (primitive-ref flush-output-port) (primitive-ref port-buf) (primitive-ref port-ndx) (primitive-ref port-ndx-add1)) . 12) ((primitive-ref port-ndx) . 8) (if . 4))
#  bindings = ((f259534 f259534))
#  body = (let ((f259537 (if (null? f259535) ((primitive-ref current-output-port)) (car f259535)))) (begin (if (fx= ((primitive-ref port-ndx) f259537) ((primitive-ref port-size) f259537)) (begin ((primitive-ref flush-output-port) f259537)) #f) (string-set! ((primitive-ref port-buf) f259537) ((primitive-ref port-ndx) f259537) f259534) ((primitive-ref port-ndx-add1) f259537)))
# emit-expr f259534
# emit-variable-ref
# env=((f259535 . -12) (f259534 . -8) (#f . 16) ((begin (primitive-ref port-size) (primitive-ref flush-output-port) (primitive-ref port-buf) (primitive-ref port-ndx) (primitive-ref port-ndx-add1)) . 12) ((primitive-ref port-ndx) . 8) (if . 4))
# var=f259534
    movl -8(%esp), %eax  # stack load f259534
# end emit-variable-ref
    movl %eax, -16(%esp)  # stack save
# emit-tail-expr
# si=-20
# env=((f259534 . -16) (f259535 . -12) (f259534 . -8) (#f . 16) ((begin (primitive-ref port-size) (primitive-ref flush-output-port) (primitive-ref port-buf) (primitive-ref port-ndx) (primitive-ref port-ndx-add1)) . 12) ((primitive-ref port-ndx) . 8) (if . 4))
# expr=(let ((f259537 (if (null? f259535) ((primitive-ref current-output-port)) (car f259535)))) (begin (if (fx= ((primitive-ref port-ndx) f259537) ((primitive-ref port-size) f259537)) (begin ((primitive-ref flush-output-port) f259537)) #f) (string-set! ((primitive-ref port-buf) f259537) ((primitive-ref port-ndx) f259537) f259534) ((primitive-ref port-ndx-add1) f259537)))
# emit-tail-let
#  si   = -20
#  env  = ((f259534 . -16) (f259535 . -12) (f259534 . -8) (#f . 16) ((begin (primitive-ref port-size) (primitive-ref flush-output-port) (primitive-ref port-buf) (primitive-ref port-ndx) (primitive-ref port-ndx-add1)) . 12) ((primitive-ref port-ndx) . 8) (if . 4))
#  bindings = ((f259537 (if (null? f259535) ((primitive-ref current-output-port)) (car f259535))))
#  body = (begin (if (fx= ((primitive-ref port-ndx) f259537) ((primitive-ref port-size) f259537)) (begin ((primitive-ref flush-output-port) f259537)) #f) (string-set! ((primitive-ref port-buf) f259537) ((primitive-ref port-ndx) f259537) f259534) ((primitive-ref port-ndx-add1) f259537))
# emit-expr (if (null? f259535) ((primitive-ref current-output-port)) (car f259535))
# emit-expr (null? f259535)
# emit-expr f259535
# emit-variable-ref
# env=((f259534 . -16) (f259535 . -12) (f259534 . -8) (#f . 16) ((begin (primitive-ref port-size) (primitive-ref flush-output-port) (primitive-ref port-buf) (primitive-ref port-ndx) (primitive-ref port-ndx-add1)) . 12) ((primitive-ref port-ndx) . 8) (if . 4))
# var=f259535
    movl -12(%esp), %eax  # stack load f259535
# end emit-variable-ref
    cmp $63, %eax
    mov $0, %eax
    sete %al
    movzbl %al, %eax
    sal $6, %al
    or $47, %al
    cmp $47, %al
    je _L_1577133
# emit-expr ((primitive-ref current-output-port))
# funcall
#    si   =-20
#    env  = ((f259534 . -16) (f259535 . -12) (f259534 . -8) (#f . 16) ((begin (primitive-ref port-size) (primitive-ref flush-output-port) (primitive-ref port-buf) (primitive-ref port-ndx) (primitive-ref port-ndx-add1)) . 12) ((primitive-ref port-ndx) . 8) (if . 4))
#    expr = (funcall (primitive-ref current-output-port))
# emit-expr (primitive-ref current-output-port)
    .extern mrc_current$moutput$mport
    movl mrc_current$moutput$mport,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1577135"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1577135":
   movl %eax,  -28(%esp)  # stash funcall-oper in closure slot
    movl -28(%esp), %edi   # load new closure to %edi
    add $-20, %esp   # adjust base
    movl $0,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $20, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    jmp _L_1577134
_L_1577133:
# emit-expr (car f259535)
# emit-expr f259535
# emit-variable-ref
# env=((f259534 . -16) (f259535 . -12) (f259534 . -8) (#f . 16) ((begin (primitive-ref port-size) (primitive-ref flush-output-port) (primitive-ref port-buf) (primitive-ref port-ndx) (primitive-ref port-ndx-add1)) . 12) ((primitive-ref port-ndx) . 8) (if . 4))
# var=f259535
    movl -12(%esp), %eax  # stack load f259535
# end emit-variable-ref
# check the argument is a pair
    movl %eax,%ebx
    and $7, %bl
    cmp $1, %bl
    je _L_1577136
# invoke error handler eh_pair
    .extern mrc_eh$upair
    movl mrc_eh$upair, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $108,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1577136:
    movl -1(%eax), %eax
_L_1577134:
    movl %eax, -20(%esp)  # stack save
# emit-tail-expr
# si=-24
# env=((f259537 . -20) (f259534 . -16) (f259535 . -12) (f259534 . -8) (#f . 16) ((begin (primitive-ref port-size) (primitive-ref flush-output-port) (primitive-ref port-buf) (primitive-ref port-ndx) (primitive-ref port-ndx-add1)) . 12) ((primitive-ref port-ndx) . 8) (if . 4))
# expr=(begin (if (fx= ((primitive-ref port-ndx) f259537) ((primitive-ref port-size) f259537)) (begin ((primitive-ref flush-output-port) f259537)) #f) (string-set! ((primitive-ref port-buf) f259537) ((primitive-ref port-ndx) f259537) f259534) ((primitive-ref port-ndx-add1) f259537))
# tail-begin (begin (if (fx= ((primitive-ref port-ndx) f259537) ((primitive-ref port-size) f259537)) (begin ((primitive-ref flush-output-port) f259537)) #f) (string-set! ((primitive-ref port-buf) f259537) ((primitive-ref port-ndx) f259537) f259534) ((primitive-ref port-ndx-add1) f259537))
#   env=((f259537 . -20) (f259534 . -16) (f259535 . -12) (f259534 . -8) (#f . 16) ((begin (primitive-ref port-size) (primitive-ref flush-output-port) (primitive-ref port-buf) (primitive-ref port-ndx) (primitive-ref port-ndx-add1)) . 12) ((primitive-ref port-ndx) . 8) (if . 4))
# emit-expr (if (fx= ((primitive-ref port-ndx) f259537) ((primitive-ref port-size) f259537)) (begin ((primitive-ref flush-output-port) f259537)) #f)
# emit-expr (fx= ((primitive-ref port-ndx) f259537) ((primitive-ref port-size) f259537))
# emit-expr ((primitive-ref port-size) f259537)
# funcall
#    si   =-24
#    env  = ((f259537 . -20) (f259534 . -16) (f259535 . -12) (f259534 . -8) (#f . 16) ((begin (primitive-ref port-size) (primitive-ref flush-output-port) (primitive-ref port-buf) (primitive-ref port-ndx) (primitive-ref port-ndx-add1)) . 12) ((primitive-ref port-ndx) . 8) (if . 4))
#    expr = (funcall (primitive-ref port-size) f259537)
# emit-expr (primitive-ref port-size)
    .extern mrc_port$msize
    movl mrc_port$msize,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1577139"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1577139":
   movl %eax,  -32(%esp)  # stash funcall-oper in closure slot
# emit-expr f259537
# emit-variable-ref
# env=((f259537 . -20) (f259534 . -16) (f259535 . -12) (f259534 . -8) (#f . 16) ((begin (primitive-ref port-size) (primitive-ref flush-output-port) (primitive-ref port-buf) (primitive-ref port-ndx) (primitive-ref port-ndx-add1)) . 12) ((primitive-ref port-ndx) . 8) (if . 4))
# var=f259537
    movl -20(%esp), %eax  # stack load f259537
# end emit-variable-ref
    mov %eax, -36(%esp)  # arg f259537
    movl -32(%esp), %edi   # load new closure to %edi
    add $-24, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $24, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1577140"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $60,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1577140:
    movl %eax, -24(%esp)
# emit-expr ((primitive-ref port-ndx) f259537)
# funcall
#    si   =-28
#    env  = ((f259537 . -20) (f259534 . -16) (f259535 . -12) (f259534 . -8) (#f . 16) ((begin (primitive-ref port-size) (primitive-ref flush-output-port) (primitive-ref port-buf) (primitive-ref port-ndx) (primitive-ref port-ndx-add1)) . 12) ((primitive-ref port-ndx) . 8) (if . 4))
#    expr = (funcall (primitive-ref port-ndx) f259537)
# emit-expr (primitive-ref port-ndx)
    .extern mrc_port$mndx
    movl mrc_port$mndx,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1577141"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1577141":
   movl %eax,  -36(%esp)  # stash funcall-oper in closure slot
# emit-expr f259537
# emit-variable-ref
# env=((f259537 . -20) (f259534 . -16) (f259535 . -12) (f259534 . -8) (#f . 16) ((begin (primitive-ref port-size) (primitive-ref flush-output-port) (primitive-ref port-buf) (primitive-ref port-ndx) (primitive-ref port-ndx-add1)) . 12) ((primitive-ref port-ndx) . 8) (if . 4))
# var=f259537
    movl -20(%esp), %eax  # stack load f259537
# end emit-variable-ref
    mov %eax, -40(%esp)  # arg f259537
    movl -36(%esp), %edi   # load new closure to %edi
    add $-28, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $28, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1577142"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $60,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1577142:
    cmp -24(%esp), %eax
    sete %al
    movzbl %al, %eax
    sal $6, %al
    or $47, %al
    cmp $47, %al
    je _L_1577137
# emit-expr (begin ((primitive-ref flush-output-port) f259537))
# emit-begin
#   expr=(begin ((primitive-ref flush-output-port) f259537))
#   env=((f259537 . -20) (f259534 . -16) (f259535 . -12) (f259534 . -8) (#f . 16) ((begin (primitive-ref port-size) (primitive-ref flush-output-port) (primitive-ref port-buf) (primitive-ref port-ndx) (primitive-ref port-ndx-add1)) . 12) ((primitive-ref port-ndx) . 8) (if . 4))
# emit-expr ((primitive-ref flush-output-port) f259537)
# funcall
#    si   =-24
#    env  = ((f259537 . -20) (f259534 . -16) (f259535 . -12) (f259534 . -8) (#f . 16) ((begin (primitive-ref port-size) (primitive-ref flush-output-port) (primitive-ref port-buf) (primitive-ref port-ndx) (primitive-ref port-ndx-add1)) . 12) ((primitive-ref port-ndx) . 8) (if . 4))
#    expr = (funcall (primitive-ref flush-output-port) f259537)
# emit-expr (primitive-ref flush-output-port)
    .extern mrc_flush$moutput$mport
    movl mrc_flush$moutput$mport,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1577143"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1577143":
   movl %eax,  -32(%esp)  # stash funcall-oper in closure slot
# emit-expr f259537
# emit-variable-ref
# env=((f259537 . -20) (f259534 . -16) (f259535 . -12) (f259534 . -8) (#f . 16) ((begin (primitive-ref port-size) (primitive-ref flush-output-port) (primitive-ref port-buf) (primitive-ref port-ndx) (primitive-ref port-ndx-add1)) . 12) ((primitive-ref port-ndx) . 8) (if . 4))
# var=f259537
    movl -20(%esp), %eax  # stack load f259537
# end emit-variable-ref
    mov %eax, -36(%esp)  # arg f259537
    movl -32(%esp), %edi   # load new closure to %edi
    add $-24, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $24, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
# emit-expr (begin)
# emit-begin
#   expr=(begin)
#   env=((f259537 . -20) (f259534 . -16) (f259535 . -12) (f259534 . -8) (#f . 16) ((begin (primitive-ref port-size) (primitive-ref flush-output-port) (primitive-ref port-buf) (primitive-ref port-ndx) (primitive-ref port-ndx-add1)) . 12) ((primitive-ref port-ndx) . 8) (if . 4))
    jmp _L_1577138
_L_1577137:
# emit-expr #f
    movl $47, %eax     # immed #f
_L_1577138:
# emit-tail-expr
# si=-24
# env=((f259537 . -20) (f259534 . -16) (f259535 . -12) (f259534 . -8) (#f . 16) ((begin (primitive-ref port-size) (primitive-ref flush-output-port) (primitive-ref port-buf) (primitive-ref port-ndx) (primitive-ref port-ndx-add1)) . 12) ((primitive-ref port-ndx) . 8) (if . 4))
# expr=(begin (string-set! ((primitive-ref port-buf) f259537) ((primitive-ref port-ndx) f259537) f259534) ((primitive-ref port-ndx-add1) f259537))
# tail-begin (begin (string-set! ((primitive-ref port-buf) f259537) ((primitive-ref port-ndx) f259537) f259534) ((primitive-ref port-ndx-add1) f259537))
#   env=((f259537 . -20) (f259534 . -16) (f259535 . -12) (f259534 . -8) (#f . 16) ((begin (primitive-ref port-size) (primitive-ref flush-output-port) (primitive-ref port-buf) (primitive-ref port-ndx) (primitive-ref port-ndx-add1)) . 12) ((primitive-ref port-ndx) . 8) (if . 4))
# emit-expr (string-set! ((primitive-ref port-buf) f259537) ((primitive-ref port-ndx) f259537) f259534)
# emit-expr ((primitive-ref port-buf) f259537)
# funcall
#    si   =-24
#    env  = ((f259537 . -20) (f259534 . -16) (f259535 . -12) (f259534 . -8) (#f . 16) ((begin (primitive-ref port-size) (primitive-ref flush-output-port) (primitive-ref port-buf) (primitive-ref port-ndx) (primitive-ref port-ndx-add1)) . 12) ((primitive-ref port-ndx) . 8) (if . 4))
#    expr = (funcall (primitive-ref port-buf) f259537)
# emit-expr (primitive-ref port-buf)
    .extern mrc_port$mbuf
    movl mrc_port$mbuf,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1577144"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1577144":
   movl %eax,  -32(%esp)  # stash funcall-oper in closure slot
# emit-expr f259537
# emit-variable-ref
# env=((f259537 . -20) (f259534 . -16) (f259535 . -12) (f259534 . -8) (#f . 16) ((begin (primitive-ref port-size) (primitive-ref flush-output-port) (primitive-ref port-buf) (primitive-ref port-ndx) (primitive-ref port-ndx-add1)) . 12) ((primitive-ref port-ndx) . 8) (if . 4))
# var=f259537
    movl -20(%esp), %eax  # stack load f259537
# end emit-variable-ref
    mov %eax, -36(%esp)  # arg f259537
    movl -32(%esp), %edi   # load new closure to %edi
    add $-24, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $24, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
# check the argument is a string
    movl %eax,%ebx
    and $7, %bl
    cmp $6, %bl
    je _L_1577145
# invoke error handler eh_string
    .extern mrc_eh$ustring
    movl mrc_eh$ustring, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $160,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1577145:
    movl %eax, -24(%esp)
# emit-expr ((primitive-ref port-ndx) f259537)
# funcall
#    si   =-24
#    env  = ((f259537 . -20) (f259534 . -16) (f259535 . -12) (f259534 . -8) (#f . 16) ((begin (primitive-ref port-size) (primitive-ref flush-output-port) (primitive-ref port-buf) (primitive-ref port-ndx) (primitive-ref port-ndx-add1)) . 12) ((primitive-ref port-ndx) . 8) (if . 4))
#    expr = (funcall (primitive-ref port-ndx) f259537)
# emit-expr (primitive-ref port-ndx)
    .extern mrc_port$mndx
    movl mrc_port$mndx,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1577146"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1577146":
   movl %eax,  -32(%esp)  # stash funcall-oper in closure slot
# emit-expr f259537
# emit-variable-ref
# env=((f259537 . -20) (f259534 . -16) (f259535 . -12) (f259534 . -8) (#f . 16) ((begin (primitive-ref port-size) (primitive-ref flush-output-port) (primitive-ref port-buf) (primitive-ref port-ndx) (primitive-ref port-ndx-add1)) . 12) ((primitive-ref port-ndx) . 8) (if . 4))
# var=f259537
    movl -20(%esp), %eax  # stack load f259537
# end emit-variable-ref
    mov %eax, -36(%esp)  # arg f259537
    movl -32(%esp), %edi   # load new closure to %edi
    add $-24, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $24, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1577147"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $160,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1577147:
# check bounds on string index
    movl -24(%esp), %ebx
    cmp  %eax,-6(%ebx) 
    jle _L_1577149
    cmp  $0,%eax
    jge _L_1577148
_L_1577149:
# invoke error handler eh_string_index
    .extern mrc_eh$ustring$uindex
    movl mrc_eh$ustring$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $160,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1577148:
    movl %eax, -28(%esp)
# emit-expr f259534
# emit-variable-ref
# env=((f259537 . -20) (f259534 . -16) (f259535 . -12) (f259534 . -8) (#f . 16) ((begin (primitive-ref port-size) (primitive-ref flush-output-port) (primitive-ref port-buf) (primitive-ref port-ndx) (primitive-ref port-ndx-add1)) . 12) ((primitive-ref port-ndx) . 8) (if . 4))
# var=f259534
    movl -16(%esp), %eax  # stack load f259534
# end emit-variable-ref
# check the argument is a char
    movl %eax,%ebx
    and $255, %bl
    cmp $15, %bl
    je "_L_1577150"
# invoke error handler eh_character
    .extern mrc_eh$ucharacter
    movl mrc_eh$ucharacter, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $160,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1577150:
    movl -24(%esp), %ebx
    movl -28(%esp), %esi
    sar $2, %esi
    movb  %ah, -2(%ebx,%esi)
# emit-tail-expr
# si=-24
# env=((f259537 . -20) (f259534 . -16) (f259535 . -12) (f259534 . -8) (#f . 16) ((begin (primitive-ref port-size) (primitive-ref flush-output-port) (primitive-ref port-buf) (primitive-ref port-ndx) (primitive-ref port-ndx-add1)) . 12) ((primitive-ref port-ndx) . 8) (if . 4))
# expr=(begin ((primitive-ref port-ndx-add1) f259537))
# tail-begin (begin ((primitive-ref port-ndx-add1) f259537))
#   env=((f259537 . -20) (f259534 . -16) (f259535 . -12) (f259534 . -8) (#f . 16) ((begin (primitive-ref port-size) (primitive-ref flush-output-port) (primitive-ref port-buf) (primitive-ref port-ndx) (primitive-ref port-ndx-add1)) . 12) ((primitive-ref port-ndx) . 8) (if . 4))
# emit-tail-expr
# si=-24
# env=((f259537 . -20) (f259534 . -16) (f259535 . -12) (f259534 . -8) (#f . 16) ((begin (primitive-ref port-size) (primitive-ref flush-output-port) (primitive-ref port-buf) (primitive-ref port-ndx) (primitive-ref port-ndx-add1)) . 12) ((primitive-ref port-ndx) . 8) (if . 4))
# expr=((primitive-ref port-ndx-add1) f259537)
# emit-tail-funcall
#    si   =-24
#    env  = ((f259537 . -20) (f259534 . -16) (f259535 . -12) (f259534 . -8) (#f . 16) ((begin (primitive-ref port-size) (primitive-ref flush-output-port) (primitive-ref port-buf) (primitive-ref port-ndx) (primitive-ref port-ndx-add1)) . 12) ((primitive-ref port-ndx) . 8) (if . 4))
#    expr = (funcall (primitive-ref port-ndx-add1) f259537)
# emit-expr (primitive-ref port-ndx-add1)
    .extern mrc_port$mndx$madd1
    movl mrc_port$mndx$madd1,%eax
   movl %eax,  -24(%esp)  # stash funcall-oper in next closure slot
# emit-expr f259537
# emit-variable-ref
# env=((f259537 . -20) (f259534 . -16) (f259535 . -12) (f259534 . -8) (#f . 16) ((begin (primitive-ref port-size) (primitive-ref flush-output-port) (primitive-ref port-buf) (primitive-ref port-ndx) (primitive-ref port-ndx-add1)) . 12) ((primitive-ref port-ndx) . 8) (if . 4))
# var=f259537
    movl -20(%esp), %eax  # stack load f259537
# end emit-variable-ref
    mov %eax, -28(%esp)    # arg f259537
    movl -24(%esp), %edi   # load new closure to %edi
# emit-shift-args:  size=2   si=-24  delta=20
    mov -24(%esp), %ebx  # shift frame cell
    mov %ebx, -4(%esp)  # down to base
# emit-shift-args:  size=1   si=-28  delta=20
    mov -28(%esp), %ebx  # shift frame cell
    mov %ebx, -8(%esp)  # down to base
# emit-shift-args:  size=0   si=-32  delta=20
    movl $4,%eax   # save arg count
    jmp *-2(%edi)  # tail-funcall
     ret   # return thru stack
    .align 4,0x90
_L_1577129:
     movl %eax, mrc_write$mchar
# == explicit-begins  ==>
# (lambda args (let ((p (if (null? args) (current-output-port) (car args)))) (begin (foreign-call "s_write" (port-fd p) (port-buf p) (port-ndx p)) (port-ndx-reset p))))
# == eliminate-let*  ==>
# (lambda args (let ((p (if (null? args) (current-output-port) (car args)))) (begin (foreign-call "s_write" (port-fd p) (port-buf p) (port-ndx p)) (port-ndx-reset p))))
# == uniquify-variables  ==>
# (lambda f259538 (let ((f259540 (if (null? f259538) (current-output-port) (car f259538)))) (begin (foreign-call "s_write" (port-fd f259540) (port-buf f259540) (port-ndx f259540)) (port-ndx-reset f259540))))
# == vectorize-letrec  ==>
# (lambda f259538 (let ((f259540 (if (null? f259538) (current-output-port) (car f259538)))) (begin (foreign-call "s_write" (port-fd f259540) (port-buf f259540) (port-ndx f259540)) (port-ndx-reset f259540))))
# == eliminate-set!  ==>
# (lambda f259538 (let () (let ((f259540 (if (null? f259538) (current-output-port) (car f259538)))) (begin (foreign-call "s_write" (port-fd f259540) (port-buf f259540) (port-ndx f259540)) (port-ndx-reset f259540)))))
# == close-free-variables  ==>
# (closure f259538 (port-fd port-buf port-ndx port-ndx-reset) (let () (let ((f259540 (if (null? f259538) (current-output-port) (car f259538)))) (begin (foreign-call "s_write" (port-fd f259540) (port-buf f259540) (port-ndx f259540)) (port-ndx-reset f259540)))))
# == eliminate-quote  ==>
# (closure f259538 (port-fd port-buf port-ndx port-ndx-reset) (let () (let ((f259540 (if (null? f259538) (current-output-port) (car f259538)))) (begin (foreign-call "s_write" (port-fd f259540) (port-buf f259540) (port-ndx f259540)) (port-ndx-reset f259540)))))
# == eliminate-when/unless  ==>
# (closure f259538 (port-fd port-buf port-ndx port-ndx-reset) (let () (let ((f259540 (if (null? f259538) (current-output-port) (car f259538)))) (begin (foreign-call "s_write" (port-fd f259540) (port-buf f259540) (port-ndx f259540)) (port-ndx-reset f259540)))))
# == eliminate-cond  ==>
# (closure f259538 (port-fd port-buf port-ndx port-ndx-reset) (let () (let ((f259540 (if (null? f259538) (current-output-port) (car f259538)))) (begin (foreign-call "s_write" (port-fd f259540) (port-buf f259540) (port-ndx f259540)) (port-ndx-reset f259540)))))
# == external-symbols  ==>
# (closure f259538 ((primitive-ref port-fd) (primitive-ref port-buf) (primitive-ref port-ndx) (primitive-ref port-ndx-reset)) (let () (let ((f259540 (if (null? f259538) ((primitive-ref current-output-port)) (car f259538)))) (begin (foreign-call "s_write" ((primitive-ref port-fd) f259540) ((primitive-ref port-buf) f259540) ((primitive-ref port-ndx) f259540)) ((primitive-ref port-ndx-reset) f259540)))))
# emit-expr (closure f259538 ((primitive-ref port-fd) (primitive-ref port-buf) (primitive-ref port-ndx) (primitive-ref port-ndx-reset)) (let () (let ((f259540 (if (null? f259538) ((primitive-ref current-output-port)) (car f259538)))) (begin (foreign-call "s_write" ((primitive-ref port-fd) f259540) ((primitive-ref port-buf) f259540) ((primitive-ref port-ndx) f259540)) ((primitive-ref port-ndx-reset) f259540)))))
# emit-closure
# si = 0
# env = ()
# expr = (closure f259538 ((primitive-ref port-fd) (primitive-ref port-buf) (primitive-ref port-ndx) (primitive-ref port-ndx-reset)) (let () (let ((f259540 (if (null? f259538) ((primitive-ref current-output-port)) (car f259538)))) (begin (foreign-call "s_write" ((primitive-ref port-fd) f259540) ((primitive-ref port-buf) f259540) ((primitive-ref port-ndx) f259540)) ((primitive-ref port-ndx-reset) f259540)))))
    movl $_L_1577151, 0(%ebp)  # closure label
# WARNING: free var (primitive-ref port-fd) not defined in the environmnet
# WARNING: free var (primitive-ref port-buf) not defined in the environmnet
# WARNING: free var (primitive-ref port-ndx) not defined in the environmnet
# WARNING: free var (primitive-ref port-ndx-reset) not defined in the environmnet
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $24, %ebp     # bump ebp
    jmp _L_1577152            # jump around closure body
_L_1577151:
# check argument count
    cmp $0,%eax
    jge _L_1577153
# invoke error handler eh_argcount_min
    .extern mrc_eh$uargcount$umin
    movl mrc_eh$uargcount$umin, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_1577153:
# emit-build-varargs-list
    movl $63, %esi       # args <- () 
    lea -4(%esp),%edi    # edi <- esp-4
    subl %eax, %edi      # edi <- esp-4-eax    addr of arg[K+N] on stack
_L_1577155:
    lea -4(%esp),%ebx    # addr of arg[K] on stack
    cmp %edi, %ebx       # while edi <> esp+(si+4)
    je _L_1577154
    movl (%edi),%ebx     # arg i -> car
    movl %ebx, 0(%ebp)
    movl %esi, 4(%ebp)  # esi -> cdr
    movl %ebp, %esi
    addl $1, %esi       # tag as pair
    addl $8,%ebp         # bump heap ptr
    addl $4,%edi         # move to next previous arg from the end
    jmp _L_1577155
_L_1577154:
    movl %esi, -8(%esp)  # set args
# emit-tail-expr
# si=-12
# env=((f259538 . -8) ((primitive-ref port-ndx-reset) . 16) ((primitive-ref port-ndx) . 12) ((primitive-ref port-buf) . 8) ((primitive-ref port-fd) . 4))
# expr=(let () (let ((f259540 (if (null? f259538) ((primitive-ref current-output-port)) (car f259538)))) (begin (foreign-call "s_write" ((primitive-ref port-fd) f259540) ((primitive-ref port-buf) f259540) ((primitive-ref port-ndx) f259540)) ((primitive-ref port-ndx-reset) f259540))))
# emit-tail-let
#  si   = -12
#  env  = ((f259538 . -8) ((primitive-ref port-ndx-reset) . 16) ((primitive-ref port-ndx) . 12) ((primitive-ref port-buf) . 8) ((primitive-ref port-fd) . 4))
#  bindings = ()
#  body = (let ((f259540 (if (null? f259538) ((primitive-ref current-output-port)) (car f259538)))) (begin (foreign-call "s_write" ((primitive-ref port-fd) f259540) ((primitive-ref port-buf) f259540) ((primitive-ref port-ndx) f259540)) ((primitive-ref port-ndx-reset) f259540)))
# emit-tail-expr
# si=-12
# env=((f259538 . -8) ((primitive-ref port-ndx-reset) . 16) ((primitive-ref port-ndx) . 12) ((primitive-ref port-buf) . 8) ((primitive-ref port-fd) . 4))
# expr=(let ((f259540 (if (null? f259538) ((primitive-ref current-output-port)) (car f259538)))) (begin (foreign-call "s_write" ((primitive-ref port-fd) f259540) ((primitive-ref port-buf) f259540) ((primitive-ref port-ndx) f259540)) ((primitive-ref port-ndx-reset) f259540)))
# emit-tail-let
#  si   = -12
#  env  = ((f259538 . -8) ((primitive-ref port-ndx-reset) . 16) ((primitive-ref port-ndx) . 12) ((primitive-ref port-buf) . 8) ((primitive-ref port-fd) . 4))
#  bindings = ((f259540 (if (null? f259538) ((primitive-ref current-output-port)) (car f259538))))
#  body = (begin (foreign-call "s_write" ((primitive-ref port-fd) f259540) ((primitive-ref port-buf) f259540) ((primitive-ref port-ndx) f259540)) ((primitive-ref port-ndx-reset) f259540))
# emit-expr (if (null? f259538) ((primitive-ref current-output-port)) (car f259538))
# emit-expr (null? f259538)
# emit-expr f259538
# emit-variable-ref
# env=((f259538 . -8) ((primitive-ref port-ndx-reset) . 16) ((primitive-ref port-ndx) . 12) ((primitive-ref port-buf) . 8) ((primitive-ref port-fd) . 4))
# var=f259538
    movl -8(%esp), %eax  # stack load f259538
# end emit-variable-ref
    cmp $63, %eax
    mov $0, %eax
    sete %al
    movzbl %al, %eax
    sal $6, %al
    or $47, %al
    cmp $47, %al
    je _L_1577156
# emit-expr ((primitive-ref current-output-port))
# funcall
#    si   =-12
#    env  = ((f259538 . -8) ((primitive-ref port-ndx-reset) . 16) ((primitive-ref port-ndx) . 12) ((primitive-ref port-buf) . 8) ((primitive-ref port-fd) . 4))
#    expr = (funcall (primitive-ref current-output-port))
# emit-expr (primitive-ref current-output-port)
    .extern mrc_current$moutput$mport
    movl mrc_current$moutput$mport,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1577158"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1577158":
   movl %eax,  -20(%esp)  # stash funcall-oper in closure slot
    movl -20(%esp), %edi   # load new closure to %edi
    add $-12, %esp   # adjust base
    movl $0,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $12, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    jmp _L_1577157
_L_1577156:
# emit-expr (car f259538)
# emit-expr f259538
# emit-variable-ref
# env=((f259538 . -8) ((primitive-ref port-ndx-reset) . 16) ((primitive-ref port-ndx) . 12) ((primitive-ref port-buf) . 8) ((primitive-ref port-fd) . 4))
# var=f259538
    movl -8(%esp), %eax  # stack load f259538
# end emit-variable-ref
# check the argument is a pair
    movl %eax,%ebx
    and $7, %bl
    cmp $1, %bl
    je _L_1577159
# invoke error handler eh_pair
    .extern mrc_eh$upair
    movl mrc_eh$upair, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $108,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1577159:
    movl -1(%eax), %eax
_L_1577157:
    movl %eax, -12(%esp)  # stack save
# emit-tail-expr
# si=-16
# env=((f259540 . -12) (f259538 . -8) ((primitive-ref port-ndx-reset) . 16) ((primitive-ref port-ndx) . 12) ((primitive-ref port-buf) . 8) ((primitive-ref port-fd) . 4))
# expr=(begin (foreign-call "s_write" ((primitive-ref port-fd) f259540) ((primitive-ref port-buf) f259540) ((primitive-ref port-ndx) f259540)) ((primitive-ref port-ndx-reset) f259540))
# tail-begin (begin (foreign-call "s_write" ((primitive-ref port-fd) f259540) ((primitive-ref port-buf) f259540) ((primitive-ref port-ndx) f259540)) ((primitive-ref port-ndx-reset) f259540))
#   env=((f259540 . -12) (f259538 . -8) ((primitive-ref port-ndx-reset) . 16) ((primitive-ref port-ndx) . 12) ((primitive-ref port-buf) . 8) ((primitive-ref port-fd) . 4))
# emit-expr (foreign-call "s_write" ((primitive-ref port-fd) f259540) ((primitive-ref port-buf) f259540) ((primitive-ref port-ndx) f259540))
    movl %ecx,-16(%esp)
    movl %esp,-20(%esp)
# emit-expr ((primitive-ref port-ndx) f259540)
# funcall
#    si   =-24
#    env  = ((f259540 . -12) (f259538 . -8) ((primitive-ref port-ndx-reset) . 16) ((primitive-ref port-ndx) . 12) ((primitive-ref port-buf) . 8) ((primitive-ref port-fd) . 4))
#    expr = (funcall (primitive-ref port-ndx) f259540)
# emit-expr (primitive-ref port-ndx)
    .extern mrc_port$mndx
    movl mrc_port$mndx,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1577160"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1577160":
   movl %eax,  -32(%esp)  # stash funcall-oper in closure slot
# emit-expr f259540
# emit-variable-ref
# env=((f259540 . -12) (f259538 . -8) ((primitive-ref port-ndx-reset) . 16) ((primitive-ref port-ndx) . 12) ((primitive-ref port-buf) . 8) ((primitive-ref port-fd) . 4))
# var=f259540
    movl -12(%esp), %eax  # stack load f259540
# end emit-variable-ref
    mov %eax, -36(%esp)  # arg f259540
    movl -32(%esp), %edi   # load new closure to %edi
    add $-24, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $24, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    movl %eax, -24(%esp)
# emit-expr ((primitive-ref port-buf) f259540)
# funcall
#    si   =-28
#    env  = ((f259540 . -12) (f259538 . -8) ((primitive-ref port-ndx-reset) . 16) ((primitive-ref port-ndx) . 12) ((primitive-ref port-buf) . 8) ((primitive-ref port-fd) . 4))
#    expr = (funcall (primitive-ref port-buf) f259540)
# emit-expr (primitive-ref port-buf)
    .extern mrc_port$mbuf
    movl mrc_port$mbuf,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1577161"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1577161":
   movl %eax,  -36(%esp)  # stash funcall-oper in closure slot
# emit-expr f259540
# emit-variable-ref
# env=((f259540 . -12) (f259538 . -8) ((primitive-ref port-ndx-reset) . 16) ((primitive-ref port-ndx) . 12) ((primitive-ref port-buf) . 8) ((primitive-ref port-fd) . 4))
# var=f259540
    movl -12(%esp), %eax  # stack load f259540
# end emit-variable-ref
    mov %eax, -40(%esp)  # arg f259540
    movl -36(%esp), %edi   # load new closure to %edi
    add $-28, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $28, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    movl %eax, -28(%esp)
# emit-expr ((primitive-ref port-fd) f259540)
# funcall
#    si   =-32
#    env  = ((f259540 . -12) (f259538 . -8) ((primitive-ref port-ndx-reset) . 16) ((primitive-ref port-ndx) . 12) ((primitive-ref port-buf) . 8) ((primitive-ref port-fd) . 4))
#    expr = (funcall (primitive-ref port-fd) f259540)
# emit-expr (primitive-ref port-fd)
    .extern mrc_port$mfd
    movl mrc_port$mfd,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1577162"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1577162":
   movl %eax,  -40(%esp)  # stash funcall-oper in closure slot
# emit-expr f259540
# emit-variable-ref
# env=((f259540 . -12) (f259538 . -8) ((primitive-ref port-ndx-reset) . 16) ((primitive-ref port-ndx) . 12) ((primitive-ref port-buf) . 8) ((primitive-ref port-fd) . 4))
# var=f259540
    movl -12(%esp), %eax  # stack load f259540
# end emit-variable-ref
    mov %eax, -44(%esp)  # arg f259540
    movl -40(%esp), %edi   # load new closure to %edi
    add $-32, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $32, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    movl %eax, -32(%esp)
    leal -32(%esp),%edi
    movl %edi,%esi
    andl $-16,%esi
    movl 0(%edi),%eax
    movl %eax,0(%esi)
    movl 4(%edi),%eax
    movl %eax,4(%esi)
    movl 8(%edi),%eax
    movl %eax,8(%esi)
    movl 12(%edi),%eax
    movl %eax,12(%esi)
    movl %esi,%esp
    .extern _s_write
    call _s_write
    movl 12(%esi),%esp
    movl -16(%esp),%ecx
# emit-tail-expr
# si=-16
# env=((f259540 . -12) (f259538 . -8) ((primitive-ref port-ndx-reset) . 16) ((primitive-ref port-ndx) . 12) ((primitive-ref port-buf) . 8) ((primitive-ref port-fd) . 4))
# expr=(begin ((primitive-ref port-ndx-reset) f259540))
# tail-begin (begin ((primitive-ref port-ndx-reset) f259540))
#   env=((f259540 . -12) (f259538 . -8) ((primitive-ref port-ndx-reset) . 16) ((primitive-ref port-ndx) . 12) ((primitive-ref port-buf) . 8) ((primitive-ref port-fd) . 4))
# emit-tail-expr
# si=-16
# env=((f259540 . -12) (f259538 . -8) ((primitive-ref port-ndx-reset) . 16) ((primitive-ref port-ndx) . 12) ((primitive-ref port-buf) . 8) ((primitive-ref port-fd) . 4))
# expr=((primitive-ref port-ndx-reset) f259540)
# emit-tail-funcall
#    si   =-16
#    env  = ((f259540 . -12) (f259538 . -8) ((primitive-ref port-ndx-reset) . 16) ((primitive-ref port-ndx) . 12) ((primitive-ref port-buf) . 8) ((primitive-ref port-fd) . 4))
#    expr = (funcall (primitive-ref port-ndx-reset) f259540)
# emit-expr (primitive-ref port-ndx-reset)
    .extern mrc_port$mndx$mreset
    movl mrc_port$mndx$mreset,%eax
   movl %eax,  -16(%esp)  # stash funcall-oper in next closure slot
# emit-expr f259540
# emit-variable-ref
# env=((f259540 . -12) (f259538 . -8) ((primitive-ref port-ndx-reset) . 16) ((primitive-ref port-ndx) . 12) ((primitive-ref port-buf) . 8) ((primitive-ref port-fd) . 4))
# var=f259540
    movl -12(%esp), %eax  # stack load f259540
# end emit-variable-ref
    mov %eax, -20(%esp)    # arg f259540
    movl -16(%esp), %edi   # load new closure to %edi
# emit-shift-args:  size=2   si=-16  delta=12
    mov -16(%esp), %ebx  # shift frame cell
    mov %ebx, -4(%esp)  # down to base
# emit-shift-args:  size=1   si=-20  delta=12
    mov -20(%esp), %ebx  # shift frame cell
    mov %ebx, -8(%esp)  # down to base
# emit-shift-args:  size=0   si=-24  delta=12
    movl $4,%eax   # save arg count
    jmp *-2(%edi)  # tail-funcall
     ret   # return thru stack
    .align 4,0x90
_L_1577152:
     movl %eax, mrc_flush$moutput$mport
# == explicit-begins  ==>
# (lambda () (begin (flush-output-port) (foreign-call "s_exit")))
# == eliminate-let*  ==>
# (lambda () (begin (flush-output-port) (foreign-call "s_exit")))
# == uniquify-variables  ==>
# (lambda () (begin (flush-output-port) (foreign-call "s_exit")))
# == vectorize-letrec  ==>
# (lambda () (begin (flush-output-port) (foreign-call "s_exit")))
# == eliminate-set!  ==>
# (lambda () (let () (begin (flush-output-port) (foreign-call "s_exit"))))
# == close-free-variables  ==>
# (closure () (flush-output-port) (let () (begin (flush-output-port) (foreign-call "s_exit"))))
# == eliminate-quote  ==>
# (closure () (flush-output-port) (let () (begin (flush-output-port) (foreign-call "s_exit"))))
# == eliminate-when/unless  ==>
# (closure () (flush-output-port) (let () (begin (flush-output-port) (foreign-call "s_exit"))))
# == eliminate-cond  ==>
# (closure () (flush-output-port) (let () (begin (flush-output-port) (foreign-call "s_exit"))))
# == external-symbols  ==>
# (closure () ((primitive-ref flush-output-port)) (let () (begin ((primitive-ref flush-output-port)) (foreign-call "s_exit"))))
# emit-expr (closure () ((primitive-ref flush-output-port)) (let () (begin ((primitive-ref flush-output-port)) (foreign-call "s_exit"))))
# emit-closure
# si = 0
# env = ()
# expr = (closure () ((primitive-ref flush-output-port)) (let () (begin ((primitive-ref flush-output-port)) (foreign-call "s_exit"))))
    movl $_L_1577163, 0(%ebp)  # closure label
# WARNING: free var (primitive-ref flush-output-port) not defined in the environmnet
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $8, %ebp     # bump ebp
    jmp _L_1577164            # jump around closure body
_L_1577163:
# check argument count
    cmp $0,%eax
    je _L_1577165
# invoke error handler eh_argcount
    .extern mrc_eh$uargcount
    movl mrc_eh$uargcount, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_1577165:
# emit-tail-expr
# si=-8
# env=(((primitive-ref flush-output-port) . 4))
# expr=(let () (begin ((primitive-ref flush-output-port)) (foreign-call "s_exit")))
# emit-tail-let
#  si   = -8
#  env  = (((primitive-ref flush-output-port) . 4))
#  bindings = ()
#  body = (begin ((primitive-ref flush-output-port)) (foreign-call "s_exit"))
# emit-tail-expr
# si=-8
# env=(((primitive-ref flush-output-port) . 4))
# expr=(begin ((primitive-ref flush-output-port)) (foreign-call "s_exit"))
# tail-begin (begin ((primitive-ref flush-output-port)) (foreign-call "s_exit"))
#   env=(((primitive-ref flush-output-port) . 4))
# emit-expr ((primitive-ref flush-output-port))
# funcall
#    si   =-8
#    env  = (((primitive-ref flush-output-port) . 4))
#    expr = (funcall (primitive-ref flush-output-port))
# emit-expr (primitive-ref flush-output-port)
    .extern mrc_flush$moutput$mport
    movl mrc_flush$moutput$mport,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1577166"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1577166":
   movl %eax,  -16(%esp)  # stash funcall-oper in closure slot
    movl -16(%esp), %edi   # load new closure to %edi
    add $-8, %esp   # adjust base
    movl $0,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $8, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
# emit-tail-expr
# si=-8
# env=(((primitive-ref flush-output-port) . 4))
# expr=(begin (foreign-call "s_exit"))
# tail-begin (begin (foreign-call "s_exit"))
#   env=(((primitive-ref flush-output-port) . 4))
# emit-tail-expr
# si=-8
# env=(((primitive-ref flush-output-port) . 4))
# expr=(foreign-call "s_exit")
    movl %ecx,-8(%esp)
    movl %esp,-12(%esp)
    leal -12(%esp),%edi
    movl %edi,%esi
    andl $-16,%esi
    movl 0(%edi),%eax
    movl %eax,0(%esi)
    movl %esi,%esp
    .extern _s_exit
    call _s_exit
    movl 0(%esi),%esp
    movl -8(%esp),%ecx
     ret
     ret   # return thru stack
    .align 4,0x90
_L_1577164:
     movl %eax, mrc_exit
# == explicit-begins  ==>
# (lambda (p) (and (vector? p) (and (fx= (vector-length p) 6) (eq? (port-kind p) (quote output-port)))))
# == eliminate-let*  ==>
# (lambda (p) (and (vector? p) (and (fx= (vector-length p) 6) (eq? (port-kind p) (quote output-port)))))
# == uniquify-variables  ==>
# (lambda (f259541) (and (vector? f259541) (and (fx= (vector-length f259541) 6) (eq? (port-kind f259541) (quote output-port)))))
# == vectorize-letrec  ==>
# (lambda (f259541) (and (vector? f259541) (and (fx= (vector-length f259541) 6) (eq? (port-kind f259541) (quote output-port)))))
# == eliminate-set!  ==>
# (lambda (f259541) (let ((f259541 f259541)) (and (vector? f259541) (and (fx= (vector-length f259541) 6) (eq? (port-kind f259541) (quote output-port))))))
# == close-free-variables  ==>
# (closure (f259541) (and and port-kind output-port) (let ((f259541 f259541)) (and (vector? f259541) (and (fx= (vector-length f259541) 6) (eq? (port-kind f259541) (quote output-port))))))
# == eliminate-quote  ==>
# (closure (f259541) (and and port-kind output-port) (let ((f259541 f259541)) (and (vector? f259541) (and (fx= (vector-length f259541) 6) (eq? (port-kind f259541) (string->symbol "output-port"))))))
# == eliminate-when/unless  ==>
# (closure (f259541) (and and port-kind output-port) (let ((f259541 f259541)) (and (vector? f259541) (and (fx= (vector-length f259541) 6) (eq? (port-kind f259541) (string->symbol "output-port"))))))
# == eliminate-cond  ==>
# (closure (f259541) (and and port-kind output-port) (let ((f259541 f259541)) (and (vector? f259541) (and (fx= (vector-length f259541) 6) (eq? (port-kind f259541) (string->symbol "output-port"))))))
# == external-symbols  ==>
# (closure (f259541) (and and (primitive-ref port-kind) output-port) (let ((f259541 f259541)) (and (vector? f259541) (and (fx= (vector-length f259541) 6) (eq? ((primitive-ref port-kind) f259541) ((primitive-ref string->symbol) "output-port"))))))
# emit-expr (closure (f259541) (and and (primitive-ref port-kind) output-port) (let ((f259541 f259541)) (and (vector? f259541) (and (fx= (vector-length f259541) 6) (eq? ((primitive-ref port-kind) f259541) ((primitive-ref string->symbol) "output-port"))))))
# emit-closure
# si = 0
# env = ()
# expr = (closure (f259541) (and and (primitive-ref port-kind) output-port) (let ((f259541 f259541)) (and (vector? f259541) (and (fx= (vector-length f259541) 6) (eq? ((primitive-ref port-kind) f259541) ((primitive-ref string->symbol) "output-port"))))))
    movl $_L_1577167, 0(%ebp)  # closure label
# WARNING: free var and not defined in the environmnet
# WARNING: free var and not defined in the environmnet
# WARNING: free var (primitive-ref port-kind) not defined in the environmnet
# WARNING: free var output-port not defined in the environmnet
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $24, %ebp     # bump ebp
    jmp _L_1577168            # jump around closure body
_L_1577167:
# check argument count
    cmp $4,%eax
    je _L_1577169
# invoke error handler eh_argcount
    .extern mrc_eh$uargcount
    movl mrc_eh$uargcount, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_1577169:
# emit-tail-expr
# si=-12
# env=((f259541 . -8) (output-port . 16) ((primitive-ref port-kind) . 12) (and . 8) (and . 4))
# expr=(let ((f259541 f259541)) (and (vector? f259541) (and (fx= (vector-length f259541) 6) (eq? ((primitive-ref port-kind) f259541) ((primitive-ref string->symbol) "output-port")))))
# emit-tail-let
#  si   = -12
#  env  = ((f259541 . -8) (output-port . 16) ((primitive-ref port-kind) . 12) (and . 8) (and . 4))
#  bindings = ((f259541 f259541))
#  body = (and (vector? f259541) (and (fx= (vector-length f259541) 6) (eq? ((primitive-ref port-kind) f259541) ((primitive-ref string->symbol) "output-port"))))
# emit-expr f259541
# emit-variable-ref
# env=((f259541 . -8) (output-port . 16) ((primitive-ref port-kind) . 12) (and . 8) (and . 4))
# var=f259541
    movl -8(%esp), %eax  # stack load f259541
# end emit-variable-ref
    movl %eax, -12(%esp)  # stack save
# emit-tail-expr
# si=-16
# env=((f259541 . -12) (f259541 . -8) (output-port . 16) ((primitive-ref port-kind) . 12) (and . 8) (and . 4))
# expr=(and (vector? f259541) (and (fx= (vector-length f259541) 6) (eq? ((primitive-ref port-kind) f259541) ((primitive-ref string->symbol) "output-port"))))
# emit-tail-expr
# si=-16
# env=((f259541 . -12) (f259541 . -8) (output-port . 16) ((primitive-ref port-kind) . 12) (and . 8) (and . 4))
# expr=(if (vector? f259541) (and (and (fx= (vector-length f259541) 6) (eq? ((primitive-ref port-kind) f259541) ((primitive-ref string->symbol) "output-port")))) #f)
# emit-expr (vector? f259541)
# emit-expr f259541
# emit-variable-ref
# env=((f259541 . -12) (f259541 . -8) (output-port . 16) ((primitive-ref port-kind) . 12) (and . 8) (and . 4))
# var=f259541
    movl -12(%esp), %eax  # stack load f259541
# end emit-variable-ref
    and $7, %al
    cmp $5, %al
    sete %al
    movzbl %al, %eax
    sal $6, %al
    or $47, %al
    cmp $47, %al
    je _L_1577170
# emit-tail-expr
# si=-16
# env=((f259541 . -12) (f259541 . -8) (output-port . 16) ((primitive-ref port-kind) . 12) (and . 8) (and . 4))
# expr=(and (and (fx= (vector-length f259541) 6) (eq? ((primitive-ref port-kind) f259541) ((primitive-ref string->symbol) "output-port"))))
# emit-tail-expr
# si=-16
# env=((f259541 . -12) (f259541 . -8) (output-port . 16) ((primitive-ref port-kind) . 12) (and . 8) (and . 4))
# expr=(and (fx= (vector-length f259541) 6) (eq? ((primitive-ref port-kind) f259541) ((primitive-ref string->symbol) "output-port")))
# emit-tail-expr
# si=-16
# env=((f259541 . -12) (f259541 . -8) (output-port . 16) ((primitive-ref port-kind) . 12) (and . 8) (and . 4))
# expr=(if (fx= (vector-length f259541) 6) (and (eq? ((primitive-ref port-kind) f259541) ((primitive-ref string->symbol) "output-port"))) #f)
# emit-expr (fx= (vector-length f259541) 6)
# emit-expr 6
    movl $24, %eax     # immed 6
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1577174"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $60,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1577174:
    movl %eax, -16(%esp)
# emit-expr (vector-length f259541)
# emit-expr f259541
# emit-variable-ref
# env=((f259541 . -12) (f259541 . -8) (output-port . 16) ((primitive-ref port-kind) . 12) (and . 8) (and . 4))
# var=f259541
    movl -12(%esp), %eax  # stack load f259541
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1577175
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $132,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1577175:
andl $-8, %eax
movl 0(%eax), %eax
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1577176"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $60,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1577176:
    cmp -16(%esp), %eax
    sete %al
    movzbl %al, %eax
    sal $6, %al
    or $47, %al
    cmp $47, %al
    je _L_1577172
# emit-tail-expr
# si=-16
# env=((f259541 . -12) (f259541 . -8) (output-port . 16) ((primitive-ref port-kind) . 12) (and . 8) (and . 4))
# expr=(and (eq? ((primitive-ref port-kind) f259541) ((primitive-ref string->symbol) "output-port")))
# emit-tail-expr
# si=-16
# env=((f259541 . -12) (f259541 . -8) (output-port . 16) ((primitive-ref port-kind) . 12) (and . 8) (and . 4))
# expr=(eq? ((primitive-ref port-kind) f259541) ((primitive-ref string->symbol) "output-port"))
# tail primcall
# eq? arg1=((primitive-ref port-kind) f259541) arg2=((primitive-ref string->symbol) "output-port")
# emit-expr ((primitive-ref port-kind) f259541)
# funcall
#    si   =-16
#    env  = ((f259541 . -12) (f259541 . -8) (output-port . 16) ((primitive-ref port-kind) . 12) (and . 8) (and . 4))
#    expr = (funcall (primitive-ref port-kind) f259541)
# emit-expr (primitive-ref port-kind)
    .extern mrc_port$mkind
    movl mrc_port$mkind,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1577177"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1577177":
   movl %eax,  -24(%esp)  # stash funcall-oper in closure slot
# emit-expr f259541
# emit-variable-ref
# env=((f259541 . -12) (f259541 . -8) (output-port . 16) ((primitive-ref port-kind) . 12) (and . 8) (and . 4))
# var=f259541
    movl -12(%esp), %eax  # stack load f259541
# end emit-variable-ref
    mov %eax, -28(%esp)  # arg f259541
    movl -24(%esp), %edi   # load new closure to %edi
    add $-16, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $16, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    movl %eax, -16(%esp)
# emit-expr ((primitive-ref string->symbol) "output-port")
# funcall
#    si   =-20
#    env  = ((f259541 . -12) (f259541 . -8) (output-port . 16) ((primitive-ref port-kind) . 12) (and . 8) (and . 4))
#    expr = (funcall (primitive-ref string->symbol) "output-port")
# emit-expr (primitive-ref string->symbol)
    .extern mrc_string$m$gsymbol
    movl mrc_string$m$gsymbol,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1577178"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1577178":
   movl %eax,  -28(%esp)  # stash funcall-oper in closure slot
# emit-expr "output-port"
# string literal
    jmp _L_1577180
    .align 8,0x90
_L_1577179 :
    .int 44
    .ascii "output-port"
_L_1577180:
    movl $_L_1577179, %eax
    orl $6, %eax
    mov %eax, -32(%esp)  # arg output-port
    movl -28(%esp), %edi   # load new closure to %edi
    add $-20, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $20, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    cmp %eax, -16(%esp)
    sete %al
    movzbl %al, %eax
    sal $6, %al
    or $47, %al
#return from tail (eq? ((primitive-ref port-kind) f259541) ((primitive-ref string->symbol) output-port))
    ret
    jmp _L_1577173
_L_1577172:
# emit-tail-expr
# si=-16
# env=((f259541 . -12) (f259541 . -8) (output-port . 16) ((primitive-ref port-kind) . 12) (and . 8) (and . 4))
# expr=#f
    movl $47, %eax     # immed #f
    ret                  # immediate tail return
_L_1577173:
    jmp _L_1577171
_L_1577170:
# emit-tail-expr
# si=-16
# env=((f259541 . -12) (f259541 . -8) (output-port . 16) ((primitive-ref port-kind) . 12) (and . 8) (and . 4))
# expr=#f
    movl $47, %eax     # immed #f
    ret                  # immediate tail return
_L_1577171:
    .align 4,0x90
_L_1577168:
     movl %eax, mrc_output$mport$q
# == explicit-begins  ==>
# (lambda (filename) (begin (unless (string? filename) (error (quote open-output-file) "filename must be a string")) (let ((fd (foreign-call "s_open" filename))) (begin (when (negative? fd) (error (quote open-output-file) "open failed")) (let ((p (make-vector 6)) (sz 1024)) (begin (vector-set! p 0 (quote output-port)) (vector-set! p 1 filename) (vector-set! p 2 fd) (vector-set! p 3 (make-string sz)) (vector-set! p 4 0) (vector-set! p 5 sz) p))))))
# == eliminate-let*  ==>
# (lambda (filename) (begin (unless (string? filename) (error (quote open-output-file) "filename must be a string")) (let ((fd (foreign-call "s_open" filename))) (begin (when (negative? fd) (error (quote open-output-file) "open failed")) (let ((p (make-vector 6)) (sz 1024)) (begin (vector-set! p 0 (quote output-port)) (vector-set! p 1 filename) (vector-set! p 2 fd) (vector-set! p 3 (make-string sz)) (vector-set! p 4 0) (vector-set! p 5 sz) p))))))
# == uniquify-variables  ==>
# (lambda (f259542) (begin (unless (string? f259542) (error (quote open-output-file) "filename must be a string")) (let ((f259548 (foreign-call "s_open" f259542))) (begin (when (negative? f259548) (error (quote open-output-file) "open failed")) (let ((f259552 (make-vector 6)) (f259551 1024)) (begin (vector-set! f259552 0 (quote output-port)) (vector-set! f259552 1 f259542) (vector-set! f259552 2 f259548) (vector-set! f259552 3 (make-string f259551)) (vector-set! f259552 4 0) (vector-set! f259552 5 f259551) f259552))))))
# == vectorize-letrec  ==>
# (lambda (f259542) (begin (unless (string? f259542) (error (quote open-output-file) "filename must be a string")) (let ((f259548 (foreign-call "s_open" f259542))) (begin (when (negative? f259548) (error (quote open-output-file) "open failed")) (let ((f259552 (make-vector 6)) (f259551 1024)) (begin (vector-set! f259552 0 (quote output-port)) (vector-set! f259552 1 f259542) (vector-set! f259552 2 f259548) (vector-set! f259552 3 (make-string f259551)) (vector-set! f259552 4 0) (vector-set! f259552 5 f259551) f259552))))))
# == eliminate-set!  ==>
# (lambda (f259542) (let ((f259542 f259542)) (begin (unless (string? f259542) (error (quote open-output-file) "filename must be a string")) (let ((f259548 (foreign-call "s_open" f259542))) (begin (when (negative? f259548) (error (quote open-output-file) "open failed")) (let ((f259552 (make-vector 6)) (f259551 1024)) (begin (vector-set! f259552 0 (quote output-port)) (vector-set! f259552 1 f259542) (vector-set! f259552 2 f259548) (vector-set! f259552 3 (make-string f259551)) (vector-set! f259552 4 0) (vector-set! f259552 5 f259551) f259552)))))))
# == close-free-variables  ==>
# (closure (f259542) (unless error open-output-file when negative? error open-output-file output-port) (let ((f259542 f259542)) (begin (unless (string? f259542) (error (quote open-output-file) "filename must be a string")) (let ((f259548 (foreign-call "s_open" f259542))) (begin (when (negative? f259548) (error (quote open-output-file) "open failed")) (let ((f259552 (make-vector 6)) (f259551 1024)) (begin (vector-set! f259552 0 (quote output-port)) (vector-set! f259552 1 f259542) (vector-set! f259552 2 f259548) (vector-set! f259552 3 (make-string f259551)) (vector-set! f259552 4 0) (vector-set! f259552 5 f259551) f259552)))))))
# == eliminate-quote  ==>
# (closure (f259542) (unless error open-output-file when negative? error open-output-file output-port) (let ((f259542 f259542)) (begin (unless (string? f259542) (error (string->symbol "open-output-file") "filename must be a string")) (let ((f259548 (foreign-call "s_open" f259542))) (begin (when (negative? f259548) (error (string->symbol "open-output-file") "open failed")) (let ((f259552 (make-vector 6)) (f259551 1024)) (begin (vector-set! f259552 0 (string->symbol "output-port")) (vector-set! f259552 1 f259542) (vector-set! f259552 2 f259548) (vector-set! f259552 3 (make-string f259551)) (vector-set! f259552 4 0) (vector-set! f259552 5 f259551) f259552)))))))
# == eliminate-when/unless  ==>
# (closure (f259542) (if (not error) (begin open-output-file if negative? (begin error open-output-file output-port) #f) #f) (let ((f259542 f259542)) (begin (if (not (string? f259542)) (begin (error (string->symbol "open-output-file") "filename must be a string")) #f) (let ((f259548 (foreign-call "s_open" f259542))) (begin (if (negative? f259548) (begin (error (string->symbol "open-output-file") "open failed")) #f) (let ((f259552 (make-vector 6)) (f259551 1024)) (begin (vector-set! f259552 0 (string->symbol "output-port")) (vector-set! f259552 1 f259542) (vector-set! f259552 2 f259548) (vector-set! f259552 3 (make-string f259551)) (vector-set! f259552 4 0) (vector-set! f259552 5 f259551) f259552)))))))
# == eliminate-cond  ==>
# (closure (f259542) (if (not error) (begin open-output-file if negative? (begin error open-output-file output-port) #f) #f) (let ((f259542 f259542)) (begin (if (not (string? f259542)) (begin (error (string->symbol "open-output-file") "filename must be a string")) #f) (let ((f259548 (foreign-call "s_open" f259542))) (begin (if (negative? f259548) (begin (error (string->symbol "open-output-file") "open failed")) #f) (let ((f259552 (make-vector 6)) (f259551 1024)) (begin (vector-set! f259552 0 (string->symbol "output-port")) (vector-set! f259552 1 f259542) (vector-set! f259552 2 f259548) (vector-set! f259552 3 (make-string f259551)) (vector-set! f259552 4 0) (vector-set! f259552 5 f259551) f259552)))))))
# == external-symbols  ==>
# (closure (f259542) (if (not (primitive-ref error)) (begin (primitive-ref open-output-file) if (primitive-ref negative?) (begin (primitive-ref error) (primitive-ref open-output-file) output-port) #f) #f) (let ((f259542 f259542)) (begin (if (not (string? f259542)) (begin ((primitive-ref error) ((primitive-ref string->symbol) "open-output-file") "filename must be a string")) #f) (let ((f259548 (foreign-call "s_open" f259542))) (begin (if ((primitive-ref negative?) f259548) (begin ((primitive-ref error) ((primitive-ref string->symbol) "open-output-file") "open failed")) #f) (let ((f259552 (make-vector 6)) (f259551 1024)) (begin (vector-set! f259552 0 ((primitive-ref string->symbol) "output-port")) (vector-set! f259552 1 f259542) (vector-set! f259552 2 f259548) (vector-set! f259552 3 (make-string f259551)) (vector-set! f259552 4 0) (vector-set! f259552 5 f259551) f259552)))))))
# emit-expr (closure (f259542) (if (not (primitive-ref error)) (begin (primitive-ref open-output-file) if (primitive-ref negative?) (begin (primitive-ref error) (primitive-ref open-output-file) output-port) #f) #f) (let ((f259542 f259542)) (begin (if (not (string? f259542)) (begin ((primitive-ref error) ((primitive-ref string->symbol) "open-output-file") "filename must be a string")) #f) (let ((f259548 (foreign-call "s_open" f259542))) (begin (if ((primitive-ref negative?) f259548) (begin ((primitive-ref error) ((primitive-ref string->symbol) "open-output-file") "open failed")) #f) (let ((f259552 (make-vector 6)) (f259551 1024)) (begin (vector-set! f259552 0 ((primitive-ref string->symbol) "output-port")) (vector-set! f259552 1 f259542) (vector-set! f259552 2 f259548) (vector-set! f259552 3 (make-string f259551)) (vector-set! f259552 4 0) (vector-set! f259552 5 f259551) f259552)))))))
# emit-closure
# si = 0
# env = ()
# expr = (closure (f259542) (if (not (primitive-ref error)) (begin (primitive-ref open-output-file) if (primitive-ref negative?) (begin (primitive-ref error) (primitive-ref open-output-file) output-port) #f) #f) (let ((f259542 f259542)) (begin (if (not (string? f259542)) (begin ((primitive-ref error) ((primitive-ref string->symbol) "open-output-file") "filename must be a string")) #f) (let ((f259548 (foreign-call "s_open" f259542))) (begin (if ((primitive-ref negative?) f259548) (begin ((primitive-ref error) ((primitive-ref string->symbol) "open-output-file") "open failed")) #f) (let ((f259552 (make-vector 6)) (f259551 1024)) (begin (vector-set! f259552 0 ((primitive-ref string->symbol) "output-port")) (vector-set! f259552 1 f259542) (vector-set! f259552 2 f259548) (vector-set! f259552 3 (make-string f259551)) (vector-set! f259552 4 0) (vector-set! f259552 5 f259551) f259552)))))))
    movl $_L_1577181, 0(%ebp)  # closure label
# WARNING: free var if not defined in the environmnet
# WARNING: free var (not (primitive-ref error)) not defined in the environmnet
# WARNING: free var (begin (primitive-ref open-output-file) if (primitive-ref negative?) (begin (primitive-ref error) (primitive-ref open-output-file) output-port) #f) not defined in the environmnet
# WARNING: free var #f not defined in the environmnet
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $24, %ebp     # bump ebp
    jmp _L_1577182            # jump around closure body
_L_1577181:
# check argument count
    cmp $4,%eax
    je _L_1577183
# invoke error handler eh_argcount
    .extern mrc_eh$uargcount
    movl mrc_eh$uargcount, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_1577183:
# emit-tail-expr
# si=-12
# env=((f259542 . -8) (#f . 16) ((begin (primitive-ref open-output-file) if (primitive-ref negative?) (begin (primitive-ref error) (primitive-ref open-output-file) output-port) #f) . 12) ((not (primitive-ref error)) . 8) (if . 4))
# expr=(let ((f259542 f259542)) (begin (if (not (string? f259542)) (begin ((primitive-ref error) ((primitive-ref string->symbol) "open-output-file") "filename must be a string")) #f) (let ((f259548 (foreign-call "s_open" f259542))) (begin (if ((primitive-ref negative?) f259548) (begin ((primitive-ref error) ((primitive-ref string->symbol) "open-output-file") "open failed")) #f) (let ((f259552 (make-vector 6)) (f259551 1024)) (begin (vector-set! f259552 0 ((primitive-ref string->symbol) "output-port")) (vector-set! f259552 1 f259542) (vector-set! f259552 2 f259548) (vector-set! f259552 3 (make-string f259551)) (vector-set! f259552 4 0) (vector-set! f259552 5 f259551) f259552))))))
# emit-tail-let
#  si   = -12
#  env  = ((f259542 . -8) (#f . 16) ((begin (primitive-ref open-output-file) if (primitive-ref negative?) (begin (primitive-ref error) (primitive-ref open-output-file) output-port) #f) . 12) ((not (primitive-ref error)) . 8) (if . 4))
#  bindings = ((f259542 f259542))
#  body = (begin (if (not (string? f259542)) (begin ((primitive-ref error) ((primitive-ref string->symbol) "open-output-file") "filename must be a string")) #f) (let ((f259548 (foreign-call "s_open" f259542))) (begin (if ((primitive-ref negative?) f259548) (begin ((primitive-ref error) ((primitive-ref string->symbol) "open-output-file") "open failed")) #f) (let ((f259552 (make-vector 6)) (f259551 1024)) (begin (vector-set! f259552 0 ((primitive-ref string->symbol) "output-port")) (vector-set! f259552 1 f259542) (vector-set! f259552 2 f259548) (vector-set! f259552 3 (make-string f259551)) (vector-set! f259552 4 0) (vector-set! f259552 5 f259551) f259552)))))
# emit-expr f259542
# emit-variable-ref
# env=((f259542 . -8) (#f . 16) ((begin (primitive-ref open-output-file) if (primitive-ref negative?) (begin (primitive-ref error) (primitive-ref open-output-file) output-port) #f) . 12) ((not (primitive-ref error)) . 8) (if . 4))
# var=f259542
    movl -8(%esp), %eax  # stack load f259542
# end emit-variable-ref
    movl %eax, -12(%esp)  # stack save
# emit-tail-expr
# si=-16
# env=((f259542 . -12) (f259542 . -8) (#f . 16) ((begin (primitive-ref open-output-file) if (primitive-ref negative?) (begin (primitive-ref error) (primitive-ref open-output-file) output-port) #f) . 12) ((not (primitive-ref error)) . 8) (if . 4))
# expr=(begin (if (not (string? f259542)) (begin ((primitive-ref error) ((primitive-ref string->symbol) "open-output-file") "filename must be a string")) #f) (let ((f259548 (foreign-call "s_open" f259542))) (begin (if ((primitive-ref negative?) f259548) (begin ((primitive-ref error) ((primitive-ref string->symbol) "open-output-file") "open failed")) #f) (let ((f259552 (make-vector 6)) (f259551 1024)) (begin (vector-set! f259552 0 ((primitive-ref string->symbol) "output-port")) (vector-set! f259552 1 f259542) (vector-set! f259552 2 f259548) (vector-set! f259552 3 (make-string f259551)) (vector-set! f259552 4 0) (vector-set! f259552 5 f259551) f259552)))))
# tail-begin (begin (if (not (string? f259542)) (begin ((primitive-ref error) ((primitive-ref string->symbol) "open-output-file") "filename must be a string")) #f) (let ((f259548 (foreign-call "s_open" f259542))) (begin (if ((primitive-ref negative?) f259548) (begin ((primitive-ref error) ((primitive-ref string->symbol) "open-output-file") "open failed")) #f) (let ((f259552 (make-vector 6)) (f259551 1024)) (begin (vector-set! f259552 0 ((primitive-ref string->symbol) "output-port")) (vector-set! f259552 1 f259542) (vector-set! f259552 2 f259548) (vector-set! f259552 3 (make-string f259551)) (vector-set! f259552 4 0) (vector-set! f259552 5 f259551) f259552)))))
#   env=((f259542 . -12) (f259542 . -8) (#f . 16) ((begin (primitive-ref open-output-file) if (primitive-ref negative?) (begin (primitive-ref error) (primitive-ref open-output-file) output-port) #f) . 12) ((not (primitive-ref error)) . 8) (if . 4))
# emit-expr (if (not (string? f259542)) (begin ((primitive-ref error) ((primitive-ref string->symbol) "open-output-file") "filename must be a string")) #f)
# emit-expr (not (string? f259542))
# emit-expr (string? f259542)
# emit-expr f259542
# emit-variable-ref
# env=((f259542 . -12) (f259542 . -8) (#f . 16) ((begin (primitive-ref open-output-file) if (primitive-ref negative?) (begin (primitive-ref error) (primitive-ref open-output-file) output-port) #f) . 12) ((not (primitive-ref error)) . 8) (if . 4))
# var=f259542
    movl -12(%esp), %eax  # stack load f259542
# end emit-variable-ref
    and $7, %al
    cmp $6, %al
    sete %al
    movzbl %al, %eax
    sal $6, %al
    or $47, %al
    cmp $47, %eax
    sete %al
    movzbl %al, %eax
    sal $6, %al
    or $47, %al
    cmp $47, %al
    je _L_1577184
# emit-expr (begin ((primitive-ref error) ((primitive-ref string->symbol) "open-output-file") "filename must be a string"))
# emit-begin
#   expr=(begin ((primitive-ref error) ((primitive-ref string->symbol) "open-output-file") "filename must be a string"))
#   env=((f259542 . -12) (f259542 . -8) (#f . 16) ((begin (primitive-ref open-output-file) if (primitive-ref negative?) (begin (primitive-ref error) (primitive-ref open-output-file) output-port) #f) . 12) ((not (primitive-ref error)) . 8) (if . 4))
# emit-expr ((primitive-ref error) ((primitive-ref string->symbol) "open-output-file") "filename must be a string")
# funcall
#    si   =-16
#    env  = ((f259542 . -12) (f259542 . -8) (#f . 16) ((begin (primitive-ref open-output-file) if (primitive-ref negative?) (begin (primitive-ref error) (primitive-ref open-output-file) output-port) #f) . 12) ((not (primitive-ref error)) . 8) (if . 4))
#    expr = (funcall (primitive-ref error) ((primitive-ref string->symbol) "open-output-file") "filename must be a string")
# emit-expr (primitive-ref error)
    .extern mrc_error
    movl mrc_error,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1577186"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1577186":
   movl %eax,  -24(%esp)  # stash funcall-oper in closure slot
# emit-expr ((primitive-ref string->symbol) "open-output-file")
# funcall
#    si   =-28
#    env  = ((f259542 . -12) (f259542 . -8) (#f . 16) ((begin (primitive-ref open-output-file) if (primitive-ref negative?) (begin (primitive-ref error) (primitive-ref open-output-file) output-port) #f) . 12) ((not (primitive-ref error)) . 8) (if . 4))
#    expr = (funcall (primitive-ref string->symbol) "open-output-file")
# emit-expr (primitive-ref string->symbol)
    .extern mrc_string$m$gsymbol
    movl mrc_string$m$gsymbol,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1577187"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1577187":
   movl %eax,  -36(%esp)  # stash funcall-oper in closure slot
# emit-expr "open-output-file"
# string literal
    jmp _L_1577189
    .align 8,0x90
_L_1577188 :
    .int 64
    .ascii "open-output-file"
_L_1577189:
    movl $_L_1577188, %eax
    orl $6, %eax
    mov %eax, -40(%esp)  # arg open-output-file
    movl -36(%esp), %edi   # load new closure to %edi
    add $-28, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $28, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    mov %eax, -28(%esp)  # arg ((primitive-ref string->symbol) open-output-file)
# emit-expr "filename must be a string"
# string literal
    jmp _L_1577191
    .align 8,0x90
_L_1577190 :
    .int 100
    .ascii "filename must be a string"
_L_1577191:
    movl $_L_1577190, %eax
    orl $6, %eax
    mov %eax, -32(%esp)  # arg filename must be a string
    movl -24(%esp), %edi   # load new closure to %edi
    add $-16, %esp   # adjust base
    movl $8,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $16, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
# emit-expr (begin)
# emit-begin
#   expr=(begin)
#   env=((f259542 . -12) (f259542 . -8) (#f . 16) ((begin (primitive-ref open-output-file) if (primitive-ref negative?) (begin (primitive-ref error) (primitive-ref open-output-file) output-port) #f) . 12) ((not (primitive-ref error)) . 8) (if . 4))
    jmp _L_1577185
_L_1577184:
# emit-expr #f
    movl $47, %eax     # immed #f
_L_1577185:
# emit-tail-expr
# si=-16
# env=((f259542 . -12) (f259542 . -8) (#f . 16) ((begin (primitive-ref open-output-file) if (primitive-ref negative?) (begin (primitive-ref error) (primitive-ref open-output-file) output-port) #f) . 12) ((not (primitive-ref error)) . 8) (if . 4))
# expr=(begin (let ((f259548 (foreign-call "s_open" f259542))) (begin (if ((primitive-ref negative?) f259548) (begin ((primitive-ref error) ((primitive-ref string->symbol) "open-output-file") "open failed")) #f) (let ((f259552 (make-vector 6)) (f259551 1024)) (begin (vector-set! f259552 0 ((primitive-ref string->symbol) "output-port")) (vector-set! f259552 1 f259542) (vector-set! f259552 2 f259548) (vector-set! f259552 3 (make-string f259551)) (vector-set! f259552 4 0) (vector-set! f259552 5 f259551) f259552)))))
# tail-begin (begin (let ((f259548 (foreign-call "s_open" f259542))) (begin (if ((primitive-ref negative?) f259548) (begin ((primitive-ref error) ((primitive-ref string->symbol) "open-output-file") "open failed")) #f) (let ((f259552 (make-vector 6)) (f259551 1024)) (begin (vector-set! f259552 0 ((primitive-ref string->symbol) "output-port")) (vector-set! f259552 1 f259542) (vector-set! f259552 2 f259548) (vector-set! f259552 3 (make-string f259551)) (vector-set! f259552 4 0) (vector-set! f259552 5 f259551) f259552)))))
#   env=((f259542 . -12) (f259542 . -8) (#f . 16) ((begin (primitive-ref open-output-file) if (primitive-ref negative?) (begin (primitive-ref error) (primitive-ref open-output-file) output-port) #f) . 12) ((not (primitive-ref error)) . 8) (if . 4))
# emit-tail-expr
# si=-16
# env=((f259542 . -12) (f259542 . -8) (#f . 16) ((begin (primitive-ref open-output-file) if (primitive-ref negative?) (begin (primitive-ref error) (primitive-ref open-output-file) output-port) #f) . 12) ((not (primitive-ref error)) . 8) (if . 4))
# expr=(let ((f259548 (foreign-call "s_open" f259542))) (begin (if ((primitive-ref negative?) f259548) (begin ((primitive-ref error) ((primitive-ref string->symbol) "open-output-file") "open failed")) #f) (let ((f259552 (make-vector 6)) (f259551 1024)) (begin (vector-set! f259552 0 ((primitive-ref string->symbol) "output-port")) (vector-set! f259552 1 f259542) (vector-set! f259552 2 f259548) (vector-set! f259552 3 (make-string f259551)) (vector-set! f259552 4 0) (vector-set! f259552 5 f259551) f259552))))
# emit-tail-let
#  si   = -16
#  env  = ((f259542 . -12) (f259542 . -8) (#f . 16) ((begin (primitive-ref open-output-file) if (primitive-ref negative?) (begin (primitive-ref error) (primitive-ref open-output-file) output-port) #f) . 12) ((not (primitive-ref error)) . 8) (if . 4))
#  bindings = ((f259548 (foreign-call "s_open" f259542)))
#  body = (begin (if ((primitive-ref negative?) f259548) (begin ((primitive-ref error) ((primitive-ref string->symbol) "open-output-file") "open failed")) #f) (let ((f259552 (make-vector 6)) (f259551 1024)) (begin (vector-set! f259552 0 ((primitive-ref string->symbol) "output-port")) (vector-set! f259552 1 f259542) (vector-set! f259552 2 f259548) (vector-set! f259552 3 (make-string f259551)) (vector-set! f259552 4 0) (vector-set! f259552 5 f259551) f259552)))
# emit-expr (foreign-call "s_open" f259542)
    movl %ecx,-16(%esp)
    movl %esp,-20(%esp)
# emit-expr f259542
# emit-variable-ref
# env=((f259542 . -12) (f259542 . -8) (#f . 16) ((begin (primitive-ref open-output-file) if (primitive-ref negative?) (begin (primitive-ref error) (primitive-ref open-output-file) output-port) #f) . 12) ((not (primitive-ref error)) . 8) (if . 4))
# var=f259542
    movl -12(%esp), %eax  # stack load f259542
# end emit-variable-ref
    movl %eax, -24(%esp)
    leal -24(%esp),%edi
    movl %edi,%esi
    andl $-16,%esi
    movl 0(%edi),%eax
    movl %eax,0(%esi)
    movl 4(%edi),%eax
    movl %eax,4(%esi)
    movl %esi,%esp
    .extern _s_open
    call _s_open
    movl 4(%esi),%esp
    movl -16(%esp),%ecx
    movl %eax, -16(%esp)  # stack save
# emit-tail-expr
# si=-20
# env=((f259548 . -16) (f259542 . -12) (f259542 . -8) (#f . 16) ((begin (primitive-ref open-output-file) if (primitive-ref negative?) (begin (primitive-ref error) (primitive-ref open-output-file) output-port) #f) . 12) ((not (primitive-ref error)) . 8) (if . 4))
# expr=(begin (if ((primitive-ref negative?) f259548) (begin ((primitive-ref error) ((primitive-ref string->symbol) "open-output-file") "open failed")) #f) (let ((f259552 (make-vector 6)) (f259551 1024)) (begin (vector-set! f259552 0 ((primitive-ref string->symbol) "output-port")) (vector-set! f259552 1 f259542) (vector-set! f259552 2 f259548) (vector-set! f259552 3 (make-string f259551)) (vector-set! f259552 4 0) (vector-set! f259552 5 f259551) f259552)))
# tail-begin (begin (if ((primitive-ref negative?) f259548) (begin ((primitive-ref error) ((primitive-ref string->symbol) "open-output-file") "open failed")) #f) (let ((f259552 (make-vector 6)) (f259551 1024)) (begin (vector-set! f259552 0 ((primitive-ref string->symbol) "output-port")) (vector-set! f259552 1 f259542) (vector-set! f259552 2 f259548) (vector-set! f259552 3 (make-string f259551)) (vector-set! f259552 4 0) (vector-set! f259552 5 f259551) f259552)))
#   env=((f259548 . -16) (f259542 . -12) (f259542 . -8) (#f . 16) ((begin (primitive-ref open-output-file) if (primitive-ref negative?) (begin (primitive-ref error) (primitive-ref open-output-file) output-port) #f) . 12) ((not (primitive-ref error)) . 8) (if . 4))
# emit-expr (if ((primitive-ref negative?) f259548) (begin ((primitive-ref error) ((primitive-ref string->symbol) "open-output-file") "open failed")) #f)
# emit-expr ((primitive-ref negative?) f259548)
# funcall
#    si   =-20
#    env  = ((f259548 . -16) (f259542 . -12) (f259542 . -8) (#f . 16) ((begin (primitive-ref open-output-file) if (primitive-ref negative?) (begin (primitive-ref error) (primitive-ref open-output-file) output-port) #f) . 12) ((not (primitive-ref error)) . 8) (if . 4))
#    expr = (funcall (primitive-ref negative?) f259548)
# emit-expr (primitive-ref negative?)
    .extern mrc_negative$q
    movl mrc_negative$q,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1577194"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1577194":
   movl %eax,  -28(%esp)  # stash funcall-oper in closure slot
# emit-expr f259548
# emit-variable-ref
# env=((f259548 . -16) (f259542 . -12) (f259542 . -8) (#f . 16) ((begin (primitive-ref open-output-file) if (primitive-ref negative?) (begin (primitive-ref error) (primitive-ref open-output-file) output-port) #f) . 12) ((not (primitive-ref error)) . 8) (if . 4))
# var=f259548
    movl -16(%esp), %eax  # stack load f259548
# end emit-variable-ref
    mov %eax, -32(%esp)  # arg f259548
    movl -28(%esp), %edi   # load new closure to %edi
    add $-20, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $20, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    cmp $47, %al
    je _L_1577192
# emit-expr (begin ((primitive-ref error) ((primitive-ref string->symbol) "open-output-file") "open failed"))
# emit-begin
#   expr=(begin ((primitive-ref error) ((primitive-ref string->symbol) "open-output-file") "open failed"))
#   env=((f259548 . -16) (f259542 . -12) (f259542 . -8) (#f . 16) ((begin (primitive-ref open-output-file) if (primitive-ref negative?) (begin (primitive-ref error) (primitive-ref open-output-file) output-port) #f) . 12) ((not (primitive-ref error)) . 8) (if . 4))
# emit-expr ((primitive-ref error) ((primitive-ref string->symbol) "open-output-file") "open failed")
# funcall
#    si   =-20
#    env  = ((f259548 . -16) (f259542 . -12) (f259542 . -8) (#f . 16) ((begin (primitive-ref open-output-file) if (primitive-ref negative?) (begin (primitive-ref error) (primitive-ref open-output-file) output-port) #f) . 12) ((not (primitive-ref error)) . 8) (if . 4))
#    expr = (funcall (primitive-ref error) ((primitive-ref string->symbol) "open-output-file") "open failed")
# emit-expr (primitive-ref error)
    .extern mrc_error
    movl mrc_error,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1577195"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1577195":
   movl %eax,  -28(%esp)  # stash funcall-oper in closure slot
# emit-expr ((primitive-ref string->symbol) "open-output-file")
# funcall
#    si   =-32
#    env  = ((f259548 . -16) (f259542 . -12) (f259542 . -8) (#f . 16) ((begin (primitive-ref open-output-file) if (primitive-ref negative?) (begin (primitive-ref error) (primitive-ref open-output-file) output-port) #f) . 12) ((not (primitive-ref error)) . 8) (if . 4))
#    expr = (funcall (primitive-ref string->symbol) "open-output-file")
# emit-expr (primitive-ref string->symbol)
    .extern mrc_string$m$gsymbol
    movl mrc_string$m$gsymbol,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1577196"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1577196":
   movl %eax,  -40(%esp)  # stash funcall-oper in closure slot
# emit-expr "open-output-file"
# string literal
    jmp _L_1577198
    .align 8,0x90
_L_1577197 :
    .int 64
    .ascii "open-output-file"
_L_1577198:
    movl $_L_1577197, %eax
    orl $6, %eax
    mov %eax, -44(%esp)  # arg open-output-file
    movl -40(%esp), %edi   # load new closure to %edi
    add $-32, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $32, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    mov %eax, -32(%esp)  # arg ((primitive-ref string->symbol) open-output-file)
# emit-expr "open failed"
# string literal
    jmp _L_1577200
    .align 8,0x90
_L_1577199 :
    .int 44
    .ascii "open failed"
_L_1577200:
    movl $_L_1577199, %eax
    orl $6, %eax
    mov %eax, -36(%esp)  # arg open failed
    movl -28(%esp), %edi   # load new closure to %edi
    add $-20, %esp   # adjust base
    movl $8,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $20, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
# emit-expr (begin)
# emit-begin
#   expr=(begin)
#   env=((f259548 . -16) (f259542 . -12) (f259542 . -8) (#f . 16) ((begin (primitive-ref open-output-file) if (primitive-ref negative?) (begin (primitive-ref error) (primitive-ref open-output-file) output-port) #f) . 12) ((not (primitive-ref error)) . 8) (if . 4))
    jmp _L_1577193
_L_1577192:
# emit-expr #f
    movl $47, %eax     # immed #f
_L_1577193:
# emit-tail-expr
# si=-20
# env=((f259548 . -16) (f259542 . -12) (f259542 . -8) (#f . 16) ((begin (primitive-ref open-output-file) if (primitive-ref negative?) (begin (primitive-ref error) (primitive-ref open-output-file) output-port) #f) . 12) ((not (primitive-ref error)) . 8) (if . 4))
# expr=(begin (let ((f259552 (make-vector 6)) (f259551 1024)) (begin (vector-set! f259552 0 ((primitive-ref string->symbol) "output-port")) (vector-set! f259552 1 f259542) (vector-set! f259552 2 f259548) (vector-set! f259552 3 (make-string f259551)) (vector-set! f259552 4 0) (vector-set! f259552 5 f259551) f259552)))
# tail-begin (begin (let ((f259552 (make-vector 6)) (f259551 1024)) (begin (vector-set! f259552 0 ((primitive-ref string->symbol) "output-port")) (vector-set! f259552 1 f259542) (vector-set! f259552 2 f259548) (vector-set! f259552 3 (make-string f259551)) (vector-set! f259552 4 0) (vector-set! f259552 5 f259551) f259552)))
#   env=((f259548 . -16) (f259542 . -12) (f259542 . -8) (#f . 16) ((begin (primitive-ref open-output-file) if (primitive-ref negative?) (begin (primitive-ref error) (primitive-ref open-output-file) output-port) #f) . 12) ((not (primitive-ref error)) . 8) (if . 4))
# emit-tail-expr
# si=-20
# env=((f259548 . -16) (f259542 . -12) (f259542 . -8) (#f . 16) ((begin (primitive-ref open-output-file) if (primitive-ref negative?) (begin (primitive-ref error) (primitive-ref open-output-file) output-port) #f) . 12) ((not (primitive-ref error)) . 8) (if . 4))
# expr=(let ((f259552 (make-vector 6)) (f259551 1024)) (begin (vector-set! f259552 0 ((primitive-ref string->symbol) "output-port")) (vector-set! f259552 1 f259542) (vector-set! f259552 2 f259548) (vector-set! f259552 3 (make-string f259551)) (vector-set! f259552 4 0) (vector-set! f259552 5 f259551) f259552))
# emit-tail-let
#  si   = -20
#  env  = ((f259548 . -16) (f259542 . -12) (f259542 . -8) (#f . 16) ((begin (primitive-ref open-output-file) if (primitive-ref negative?) (begin (primitive-ref error) (primitive-ref open-output-file) output-port) #f) . 12) ((not (primitive-ref error)) . 8) (if . 4))
#  bindings = ((f259552 (make-vector 6)) (f259551 1024))
#  body = (begin (vector-set! f259552 0 ((primitive-ref string->symbol) "output-port")) (vector-set! f259552 1 f259542) (vector-set! f259552 2 f259548) (vector-set! f259552 3 (make-string f259551)) (vector-set! f259552 4 0) (vector-set! f259552 5 f259551) f259552)
# emit-expr (make-vector 6)
# make-vector 6
# emit-expr 6
    movl $24, %eax     # immed 6
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1577201"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $128,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1577201:
# check the argument is a fixnum >= 0
    cmp $0,%eax
    jge _L_1577202
# invoke error handler eh_length
    .extern mrc_eh$ulength
    movl mrc_eh$ulength, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $128,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1577202:
    movl %eax, %esi
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    orl  $5, %eax
    addl $4, %esi
    addl $4, %esi
    andl $-8, %esi
    addl %esi, %ebp
    movl %eax, -20(%esp)  # stack save
# emit-expr 1024
    movl $4096, %eax     # immed 1024
    movl %eax, -24(%esp)  # stack save
# emit-tail-expr
# si=-28
# env=((f259551 . -24) (f259552 . -20) (f259548 . -16) (f259542 . -12) (f259542 . -8) (#f . 16) ((begin (primitive-ref open-output-file) if (primitive-ref negative?) (begin (primitive-ref error) (primitive-ref open-output-file) output-port) #f) . 12) ((not (primitive-ref error)) . 8) (if . 4))
# expr=(begin (vector-set! f259552 0 ((primitive-ref string->symbol) "output-port")) (vector-set! f259552 1 f259542) (vector-set! f259552 2 f259548) (vector-set! f259552 3 (make-string f259551)) (vector-set! f259552 4 0) (vector-set! f259552 5 f259551) f259552)
# tail-begin (begin (vector-set! f259552 0 ((primitive-ref string->symbol) "output-port")) (vector-set! f259552 1 f259542) (vector-set! f259552 2 f259548) (vector-set! f259552 3 (make-string f259551)) (vector-set! f259552 4 0) (vector-set! f259552 5 f259551) f259552)
#   env=((f259551 . -24) (f259552 . -20) (f259548 . -16) (f259542 . -12) (f259542 . -8) (#f . 16) ((begin (primitive-ref open-output-file) if (primitive-ref negative?) (begin (primitive-ref error) (primitive-ref open-output-file) output-port) #f) . 12) ((not (primitive-ref error)) . 8) (if . 4))
# emit-expr (vector-set! f259552 0 ((primitive-ref string->symbol) "output-port"))
# emit-expr f259552
# emit-variable-ref
# env=((f259551 . -24) (f259552 . -20) (f259548 . -16) (f259542 . -12) (f259542 . -8) (#f . 16) ((begin (primitive-ref open-output-file) if (primitive-ref negative?) (begin (primitive-ref error) (primitive-ref open-output-file) output-port) #f) . 12) ((not (primitive-ref error)) . 8) (if . 4))
# var=f259552
    movl -20(%esp), %eax  # stack load f259552
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1577203
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1577203:
    movl %eax, -28(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1577204"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1577204:
# check bounds on vector index
    movl -28(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1577206
    cmp  $0,%eax
    jge _L_1577205
_L_1577206:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1577205:
    movl %eax, -32(%esp)
# emit-expr ((primitive-ref string->symbol) "output-port")
# funcall
#    si   =-36
#    env  = ((f259551 . -24) (f259552 . -20) (f259548 . -16) (f259542 . -12) (f259542 . -8) (#f . 16) ((begin (primitive-ref open-output-file) if (primitive-ref negative?) (begin (primitive-ref error) (primitive-ref open-output-file) output-port) #f) . 12) ((not (primitive-ref error)) . 8) (if . 4))
#    expr = (funcall (primitive-ref string->symbol) "output-port")
# emit-expr (primitive-ref string->symbol)
    .extern mrc_string$m$gsymbol
    movl mrc_string$m$gsymbol,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1577207"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1577207":
   movl %eax,  -44(%esp)  # stash funcall-oper in closure slot
# emit-expr "output-port"
# string literal
    jmp _L_1577209
    .align 8,0x90
_L_1577208 :
    .int 44
    .ascii "output-port"
_L_1577209:
    movl $_L_1577208, %eax
    orl $6, %eax
    mov %eax, -48(%esp)  # arg output-port
    movl -44(%esp), %edi   # load new closure to %edi
    add $-36, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $36, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    movl -28(%esp), %ebx
    movl -32(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-tail-expr
# si=-28
# env=((f259551 . -24) (f259552 . -20) (f259548 . -16) (f259542 . -12) (f259542 . -8) (#f . 16) ((begin (primitive-ref open-output-file) if (primitive-ref negative?) (begin (primitive-ref error) (primitive-ref open-output-file) output-port) #f) . 12) ((not (primitive-ref error)) . 8) (if . 4))
# expr=(begin (vector-set! f259552 1 f259542) (vector-set! f259552 2 f259548) (vector-set! f259552 3 (make-string f259551)) (vector-set! f259552 4 0) (vector-set! f259552 5 f259551) f259552)
# tail-begin (begin (vector-set! f259552 1 f259542) (vector-set! f259552 2 f259548) (vector-set! f259552 3 (make-string f259551)) (vector-set! f259552 4 0) (vector-set! f259552 5 f259551) f259552)
#   env=((f259551 . -24) (f259552 . -20) (f259548 . -16) (f259542 . -12) (f259542 . -8) (#f . 16) ((begin (primitive-ref open-output-file) if (primitive-ref negative?) (begin (primitive-ref error) (primitive-ref open-output-file) output-port) #f) . 12) ((not (primitive-ref error)) . 8) (if . 4))
# emit-expr (vector-set! f259552 1 f259542)
# emit-expr f259552
# emit-variable-ref
# env=((f259551 . -24) (f259552 . -20) (f259548 . -16) (f259542 . -12) (f259542 . -8) (#f . 16) ((begin (primitive-ref open-output-file) if (primitive-ref negative?) (begin (primitive-ref error) (primitive-ref open-output-file) output-port) #f) . 12) ((not (primitive-ref error)) . 8) (if . 4))
# var=f259552
    movl -20(%esp), %eax  # stack load f259552
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1577210
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1577210:
    movl %eax, -28(%esp)
# emit-expr 1
    movl $4, %eax     # immed 1
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1577211"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1577211:
# check bounds on vector index
    movl -28(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1577213
    cmp  $0,%eax
    jge _L_1577212
_L_1577213:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1577212:
    movl %eax, -32(%esp)
# emit-expr f259542
# emit-variable-ref
# env=((f259551 . -24) (f259552 . -20) (f259548 . -16) (f259542 . -12) (f259542 . -8) (#f . 16) ((begin (primitive-ref open-output-file) if (primitive-ref negative?) (begin (primitive-ref error) (primitive-ref open-output-file) output-port) #f) . 12) ((not (primitive-ref error)) . 8) (if . 4))
# var=f259542
    movl -12(%esp), %eax  # stack load f259542
# end emit-variable-ref
    movl -28(%esp), %ebx
    movl -32(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-tail-expr
# si=-28
# env=((f259551 . -24) (f259552 . -20) (f259548 . -16) (f259542 . -12) (f259542 . -8) (#f . 16) ((begin (primitive-ref open-output-file) if (primitive-ref negative?) (begin (primitive-ref error) (primitive-ref open-output-file) output-port) #f) . 12) ((not (primitive-ref error)) . 8) (if . 4))
# expr=(begin (vector-set! f259552 2 f259548) (vector-set! f259552 3 (make-string f259551)) (vector-set! f259552 4 0) (vector-set! f259552 5 f259551) f259552)
# tail-begin (begin (vector-set! f259552 2 f259548) (vector-set! f259552 3 (make-string f259551)) (vector-set! f259552 4 0) (vector-set! f259552 5 f259551) f259552)
#   env=((f259551 . -24) (f259552 . -20) (f259548 . -16) (f259542 . -12) (f259542 . -8) (#f . 16) ((begin (primitive-ref open-output-file) if (primitive-ref negative?) (begin (primitive-ref error) (primitive-ref open-output-file) output-port) #f) . 12) ((not (primitive-ref error)) . 8) (if . 4))
# emit-expr (vector-set! f259552 2 f259548)
# emit-expr f259552
# emit-variable-ref
# env=((f259551 . -24) (f259552 . -20) (f259548 . -16) (f259542 . -12) (f259542 . -8) (#f . 16) ((begin (primitive-ref open-output-file) if (primitive-ref negative?) (begin (primitive-ref error) (primitive-ref open-output-file) output-port) #f) . 12) ((not (primitive-ref error)) . 8) (if . 4))
# var=f259552
    movl -20(%esp), %eax  # stack load f259552
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1577214
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1577214:
    movl %eax, -28(%esp)
# emit-expr 2
    movl $8, %eax     # immed 2
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1577215"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1577215:
# check bounds on vector index
    movl -28(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1577217
    cmp  $0,%eax
    jge _L_1577216
_L_1577217:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1577216:
    movl %eax, -32(%esp)
# emit-expr f259548
# emit-variable-ref
# env=((f259551 . -24) (f259552 . -20) (f259548 . -16) (f259542 . -12) (f259542 . -8) (#f . 16) ((begin (primitive-ref open-output-file) if (primitive-ref negative?) (begin (primitive-ref error) (primitive-ref open-output-file) output-port) #f) . 12) ((not (primitive-ref error)) . 8) (if . 4))
# var=f259548
    movl -16(%esp), %eax  # stack load f259548
# end emit-variable-ref
    movl -28(%esp), %ebx
    movl -32(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-tail-expr
# si=-28
# env=((f259551 . -24) (f259552 . -20) (f259548 . -16) (f259542 . -12) (f259542 . -8) (#f . 16) ((begin (primitive-ref open-output-file) if (primitive-ref negative?) (begin (primitive-ref error) (primitive-ref open-output-file) output-port) #f) . 12) ((not (primitive-ref error)) . 8) (if . 4))
# expr=(begin (vector-set! f259552 3 (make-string f259551)) (vector-set! f259552 4 0) (vector-set! f259552 5 f259551) f259552)
# tail-begin (begin (vector-set! f259552 3 (make-string f259551)) (vector-set! f259552 4 0) (vector-set! f259552 5 f259551) f259552)
#   env=((f259551 . -24) (f259552 . -20) (f259548 . -16) (f259542 . -12) (f259542 . -8) (#f . 16) ((begin (primitive-ref open-output-file) if (primitive-ref negative?) (begin (primitive-ref error) (primitive-ref open-output-file) output-port) #f) . 12) ((not (primitive-ref error)) . 8) (if . 4))
# emit-expr (vector-set! f259552 3 (make-string f259551))
# emit-expr f259552
# emit-variable-ref
# env=((f259551 . -24) (f259552 . -20) (f259548 . -16) (f259542 . -12) (f259542 . -8) (#f . 16) ((begin (primitive-ref open-output-file) if (primitive-ref negative?) (begin (primitive-ref error) (primitive-ref open-output-file) output-port) #f) . 12) ((not (primitive-ref error)) . 8) (if . 4))
# var=f259552
    movl -20(%esp), %eax  # stack load f259552
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1577218
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1577218:
    movl %eax, -28(%esp)
# emit-expr 3
    movl $12, %eax     # immed 3
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1577219"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1577219:
# check bounds on vector index
    movl -28(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1577221
    cmp  $0,%eax
    jge _L_1577220
_L_1577221:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1577220:
    movl %eax, -32(%esp)
# emit-expr (make-string f259551)
# make-string len=f259551
# emit-expr f259551
# emit-variable-ref
# env=((f259551 . -24) (f259552 . -20) (f259548 . -16) (f259542 . -12) (f259542 . -8) (#f . 16) ((begin (primitive-ref open-output-file) if (primitive-ref negative?) (begin (primitive-ref error) (primitive-ref open-output-file) output-port) #f) . 12) ((not (primitive-ref error)) . 8) (if . 4))
# var=f259551
    movl -24(%esp), %eax  # stack load f259551
# end emit-variable-ref
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1577222"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1577222:
# check the argument is a fixnum >= 0
    cmp $0,%eax
    jge _L_1577223
# invoke error handler eh_length
    .extern mrc_eh$ulength
    movl mrc_eh$ulength, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1577223:
    movl %eax, %esi
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    orl $6, %eax
    sar $2, %esi
    add $4, %esi
    add $7, %esi
    andl $-8, %esi
    add  %esi, %ebp
# make-string end
    movl -28(%esp), %ebx
    movl -32(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-tail-expr
# si=-28
# env=((f259551 . -24) (f259552 . -20) (f259548 . -16) (f259542 . -12) (f259542 . -8) (#f . 16) ((begin (primitive-ref open-output-file) if (primitive-ref negative?) (begin (primitive-ref error) (primitive-ref open-output-file) output-port) #f) . 12) ((not (primitive-ref error)) . 8) (if . 4))
# expr=(begin (vector-set! f259552 4 0) (vector-set! f259552 5 f259551) f259552)
# tail-begin (begin (vector-set! f259552 4 0) (vector-set! f259552 5 f259551) f259552)
#   env=((f259551 . -24) (f259552 . -20) (f259548 . -16) (f259542 . -12) (f259542 . -8) (#f . 16) ((begin (primitive-ref open-output-file) if (primitive-ref negative?) (begin (primitive-ref error) (primitive-ref open-output-file) output-port) #f) . 12) ((not (primitive-ref error)) . 8) (if . 4))
# emit-expr (vector-set! f259552 4 0)
# emit-expr f259552
# emit-variable-ref
# env=((f259551 . -24) (f259552 . -20) (f259548 . -16) (f259542 . -12) (f259542 . -8) (#f . 16) ((begin (primitive-ref open-output-file) if (primitive-ref negative?) (begin (primitive-ref error) (primitive-ref open-output-file) output-port) #f) . 12) ((not (primitive-ref error)) . 8) (if . 4))
# var=f259552
    movl -20(%esp), %eax  # stack load f259552
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1577224
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1577224:
    movl %eax, -28(%esp)
# emit-expr 4
    movl $16, %eax     # immed 4
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1577225"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1577225:
# check bounds on vector index
    movl -28(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1577227
    cmp  $0,%eax
    jge _L_1577226
_L_1577227:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1577226:
    movl %eax, -32(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
    movl -28(%esp), %ebx
    movl -32(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-tail-expr
# si=-28
# env=((f259551 . -24) (f259552 . -20) (f259548 . -16) (f259542 . -12) (f259542 . -8) (#f . 16) ((begin (primitive-ref open-output-file) if (primitive-ref negative?) (begin (primitive-ref error) (primitive-ref open-output-file) output-port) #f) . 12) ((not (primitive-ref error)) . 8) (if . 4))
# expr=(begin (vector-set! f259552 5 f259551) f259552)
# tail-begin (begin (vector-set! f259552 5 f259551) f259552)
#   env=((f259551 . -24) (f259552 . -20) (f259548 . -16) (f259542 . -12) (f259542 . -8) (#f . 16) ((begin (primitive-ref open-output-file) if (primitive-ref negative?) (begin (primitive-ref error) (primitive-ref open-output-file) output-port) #f) . 12) ((not (primitive-ref error)) . 8) (if . 4))
# emit-expr (vector-set! f259552 5 f259551)
# emit-expr f259552
# emit-variable-ref
# env=((f259551 . -24) (f259552 . -20) (f259548 . -16) (f259542 . -12) (f259542 . -8) (#f . 16) ((begin (primitive-ref open-output-file) if (primitive-ref negative?) (begin (primitive-ref error) (primitive-ref open-output-file) output-port) #f) . 12) ((not (primitive-ref error)) . 8) (if . 4))
# var=f259552
    movl -20(%esp), %eax  # stack load f259552
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1577228
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1577228:
    movl %eax, -28(%esp)
# emit-expr 5
    movl $20, %eax     # immed 5
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1577229"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1577229:
# check bounds on vector index
    movl -28(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1577231
    cmp  $0,%eax
    jge _L_1577230
_L_1577231:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1577230:
    movl %eax, -32(%esp)
# emit-expr f259551
# emit-variable-ref
# env=((f259551 . -24) (f259552 . -20) (f259548 . -16) (f259542 . -12) (f259542 . -8) (#f . 16) ((begin (primitive-ref open-output-file) if (primitive-ref negative?) (begin (primitive-ref error) (primitive-ref open-output-file) output-port) #f) . 12) ((not (primitive-ref error)) . 8) (if . 4))
# var=f259551
    movl -24(%esp), %eax  # stack load f259551
# end emit-variable-ref
    movl -28(%esp), %ebx
    movl -32(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-tail-expr
# si=-28
# env=((f259551 . -24) (f259552 . -20) (f259548 . -16) (f259542 . -12) (f259542 . -8) (#f . 16) ((begin (primitive-ref open-output-file) if (primitive-ref negative?) (begin (primitive-ref error) (primitive-ref open-output-file) output-port) #f) . 12) ((not (primitive-ref error)) . 8) (if . 4))
# expr=(begin f259552)
# tail-begin (begin f259552)
#   env=((f259551 . -24) (f259552 . -20) (f259548 . -16) (f259542 . -12) (f259542 . -8) (#f . 16) ((begin (primitive-ref open-output-file) if (primitive-ref negative?) (begin (primitive-ref error) (primitive-ref open-output-file) output-port) #f) . 12) ((not (primitive-ref error)) . 8) (if . 4))
# emit-tail-expr
# si=-28
# env=((f259551 . -24) (f259552 . -20) (f259548 . -16) (f259542 . -12) (f259542 . -8) (#f . 16) ((begin (primitive-ref open-output-file) if (primitive-ref negative?) (begin (primitive-ref error) (primitive-ref open-output-file) output-port) #f) . 12) ((not (primitive-ref error)) . 8) (if . 4))
# expr=f259552
# emit-tail-variable-ref
# emit-variable-ref
# env=((f259551 . -24) (f259552 . -20) (f259548 . -16) (f259542 . -12) (f259542 . -8) (#f . 16) ((begin (primitive-ref open-output-file) if (primitive-ref negative?) (begin (primitive-ref error) (primitive-ref open-output-file) output-port) #f) . 12) ((not (primitive-ref error)) . 8) (if . 4))
# var=f259552
    movl -20(%esp), %eax  # stack load f259552
# end emit-variable-ref
    ret
# end emit-tail-variable ref
     ret   # return thru stack
     ret   # return thru stack
     ret   # return thru stack
    .align 4,0x90
_L_1577182:
     movl %eax, mrc_open$moutput$mfile
# == explicit-begins  ==>
# (lambda (p) (begin (flush-output-port p) (foreign-call "s_close" (port-fd p))))
# == eliminate-let*  ==>
# (lambda (p) (begin (flush-output-port p) (foreign-call "s_close" (port-fd p))))
# == uniquify-variables  ==>
# (lambda (f259553) (begin (flush-output-port f259553) (foreign-call "s_close" (port-fd f259553))))
# == vectorize-letrec  ==>
# (lambda (f259553) (begin (flush-output-port f259553) (foreign-call "s_close" (port-fd f259553))))
# == eliminate-set!  ==>
# (lambda (f259553) (let ((f259553 f259553)) (begin (flush-output-port f259553) (foreign-call "s_close" (port-fd f259553)))))
# == close-free-variables  ==>
# (closure (f259553) (flush-output-port port-fd) (let ((f259553 f259553)) (begin (flush-output-port f259553) (foreign-call "s_close" (port-fd f259553)))))
# == eliminate-quote  ==>
# (closure (f259553) (flush-output-port port-fd) (let ((f259553 f259553)) (begin (flush-output-port f259553) (foreign-call "s_close" (port-fd f259553)))))
# == eliminate-when/unless  ==>
# (closure (f259553) (flush-output-port port-fd) (let ((f259553 f259553)) (begin (flush-output-port f259553) (foreign-call "s_close" (port-fd f259553)))))
# == eliminate-cond  ==>
# (closure (f259553) (flush-output-port port-fd) (let ((f259553 f259553)) (begin (flush-output-port f259553) (foreign-call "s_close" (port-fd f259553)))))
# == external-symbols  ==>
# (closure (f259553) ((primitive-ref flush-output-port) (primitive-ref port-fd)) (let ((f259553 f259553)) (begin ((primitive-ref flush-output-port) f259553) (foreign-call "s_close" ((primitive-ref port-fd) f259553)))))
# emit-expr (closure (f259553) ((primitive-ref flush-output-port) (primitive-ref port-fd)) (let ((f259553 f259553)) (begin ((primitive-ref flush-output-port) f259553) (foreign-call "s_close" ((primitive-ref port-fd) f259553)))))
# emit-closure
# si = 0
# env = ()
# expr = (closure (f259553) ((primitive-ref flush-output-port) (primitive-ref port-fd)) (let ((f259553 f259553)) (begin ((primitive-ref flush-output-port) f259553) (foreign-call "s_close" ((primitive-ref port-fd) f259553)))))
    movl $_L_1577232, 0(%ebp)  # closure label
# WARNING: free var (primitive-ref flush-output-port) not defined in the environmnet
# WARNING: free var (primitive-ref port-fd) not defined in the environmnet
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $16, %ebp     # bump ebp
    jmp _L_1577233            # jump around closure body
_L_1577232:
# check argument count
    cmp $4,%eax
    je _L_1577234
# invoke error handler eh_argcount
    .extern mrc_eh$uargcount
    movl mrc_eh$uargcount, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_1577234:
# emit-tail-expr
# si=-12
# env=((f259553 . -8) ((primitive-ref port-fd) . 8) ((primitive-ref flush-output-port) . 4))
# expr=(let ((f259553 f259553)) (begin ((primitive-ref flush-output-port) f259553) (foreign-call "s_close" ((primitive-ref port-fd) f259553))))
# emit-tail-let
#  si   = -12
#  env  = ((f259553 . -8) ((primitive-ref port-fd) . 8) ((primitive-ref flush-output-port) . 4))
#  bindings = ((f259553 f259553))
#  body = (begin ((primitive-ref flush-output-port) f259553) (foreign-call "s_close" ((primitive-ref port-fd) f259553)))
# emit-expr f259553
# emit-variable-ref
# env=((f259553 . -8) ((primitive-ref port-fd) . 8) ((primitive-ref flush-output-port) . 4))
# var=f259553
    movl -8(%esp), %eax  # stack load f259553
# end emit-variable-ref
    movl %eax, -12(%esp)  # stack save
# emit-tail-expr
# si=-16
# env=((f259553 . -12) (f259553 . -8) ((primitive-ref port-fd) . 8) ((primitive-ref flush-output-port) . 4))
# expr=(begin ((primitive-ref flush-output-port) f259553) (foreign-call "s_close" ((primitive-ref port-fd) f259553)))
# tail-begin (begin ((primitive-ref flush-output-port) f259553) (foreign-call "s_close" ((primitive-ref port-fd) f259553)))
#   env=((f259553 . -12) (f259553 . -8) ((primitive-ref port-fd) . 8) ((primitive-ref flush-output-port) . 4))
# emit-expr ((primitive-ref flush-output-port) f259553)
# funcall
#    si   =-16
#    env  = ((f259553 . -12) (f259553 . -8) ((primitive-ref port-fd) . 8) ((primitive-ref flush-output-port) . 4))
#    expr = (funcall (primitive-ref flush-output-port) f259553)
# emit-expr (primitive-ref flush-output-port)
    .extern mrc_flush$moutput$mport
    movl mrc_flush$moutput$mport,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1577235"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1577235":
   movl %eax,  -24(%esp)  # stash funcall-oper in closure slot
# emit-expr f259553
# emit-variable-ref
# env=((f259553 . -12) (f259553 . -8) ((primitive-ref port-fd) . 8) ((primitive-ref flush-output-port) . 4))
# var=f259553
    movl -12(%esp), %eax  # stack load f259553
# end emit-variable-ref
    mov %eax, -28(%esp)  # arg f259553
    movl -24(%esp), %edi   # load new closure to %edi
    add $-16, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $16, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
# emit-tail-expr
# si=-16
# env=((f259553 . -12) (f259553 . -8) ((primitive-ref port-fd) . 8) ((primitive-ref flush-output-port) . 4))
# expr=(begin (foreign-call "s_close" ((primitive-ref port-fd) f259553)))
# tail-begin (begin (foreign-call "s_close" ((primitive-ref port-fd) f259553)))
#   env=((f259553 . -12) (f259553 . -8) ((primitive-ref port-fd) . 8) ((primitive-ref flush-output-port) . 4))
# emit-tail-expr
# si=-16
# env=((f259553 . -12) (f259553 . -8) ((primitive-ref port-fd) . 8) ((primitive-ref flush-output-port) . 4))
# expr=(foreign-call "s_close" ((primitive-ref port-fd) f259553))
    movl %ecx,-16(%esp)
    movl %esp,-20(%esp)
# emit-expr ((primitive-ref port-fd) f259553)
# funcall
#    si   =-24
#    env  = ((f259553 . -12) (f259553 . -8) ((primitive-ref port-fd) . 8) ((primitive-ref flush-output-port) . 4))
#    expr = (funcall (primitive-ref port-fd) f259553)
# emit-expr (primitive-ref port-fd)
    .extern mrc_port$mfd
    movl mrc_port$mfd,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1577236"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1577236":
   movl %eax,  -32(%esp)  # stash funcall-oper in closure slot
# emit-expr f259553
# emit-variable-ref
# env=((f259553 . -12) (f259553 . -8) ((primitive-ref port-fd) . 8) ((primitive-ref flush-output-port) . 4))
# var=f259553
    movl -12(%esp), %eax  # stack load f259553
# end emit-variable-ref
    mov %eax, -36(%esp)  # arg f259553
    movl -32(%esp), %edi   # load new closure to %edi
    add $-24, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $24, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    movl %eax, -24(%esp)
    leal -24(%esp),%edi
    movl %edi,%esi
    andl $-16,%esi
    movl 0(%edi),%eax
    movl %eax,0(%esi)
    movl 4(%edi),%eax
    movl %eax,4(%esi)
    movl %esi,%esp
    .extern _s_close
    call _s_close
    movl 4(%esi),%esp
    movl -16(%esp),%ecx
     ret
     ret   # return thru stack
    .align 4,0x90
_L_1577233:
     movl %eax, mrc_close$moutput$mport
# == explicit-begins  ==>
# (letrec ((print-boolean (lambda (expr p) (begin (write-char #\# p) (if expr (write-char #\t p) (write-char #\f p))))) (print-null (lambda (p) (begin (write-char #\( p) (write-char #\) p)))) (print-char (lambda (expr p) (begin (write-char #\# p) (write-char #\\ p) (write-char expr p)))) (print-fixnum (lambda (i p) (if (negative? i) (begin (write-char #\- p) (print-fixnum (fx* -1 i) p)) (map (lambda (x) (write-char (fixnum->char (fx+ (char->fixnum #\0) x)) p)) (integer->list i))))) (print-string (lambda (s p) (begin (write-char #\" p) (for-each (lambda (c) (write-char c p)) (string->list s)) (write-char #\" p)))) (print-string-alpha (lambda (s p) (for-each (lambda (c) (write-char c p)) (string->list s)))) (print-pair (lambda (pr p) (begin (write-char #\( p) (print-pairs pr p) (write-char #\) p)))) (print-pairs (lambda (pr p) (begin (write (car pr) p) (cond ((null? (cdr pr)) #t) ((pair? (cdr pr)) (begin (write-char #\space p) (print-pairs (cdr pr) p))) (else (begin (write-char #\space p) (write-char #\. p) (write-char #\space p) (write (cdr pr) p)))))))) (lambda (expr p alpha) (cond ((boolean? expr) (print-boolean expr p)) ((null? expr) (print-null p)) ((char? expr) (if alpha (write-char expr p) (print-char expr p))) ((fixnum? expr) (print-fixnum expr p)) ((string? expr) (if alpha (print-string-alpha expr p) (print-string expr p))) ((pair? expr) (print-pair expr p)) (else (error (quote write) "unrecognized expression")))))
# == eliminate-let*  ==>
# (letrec ((print-boolean (lambda (expr p) (begin (write-char #\# p) (if expr (write-char #\t p) (write-char #\f p))))) (print-null (lambda (p) (begin (write-char #\( p) (write-char #\) p)))) (print-char (lambda (expr p) (begin (write-char #\# p) (write-char #\\ p) (write-char expr p)))) (print-fixnum (lambda (i p) (if (negative? i) (begin (write-char #\- p) (print-fixnum (fx* -1 i) p)) (map (lambda (x) (write-char (fixnum->char (fx+ (char->fixnum #\0) x)) p)) (integer->list i))))) (print-string (lambda (s p) (begin (write-char #\" p) (for-each (lambda (c) (write-char c p)) (string->list s)) (write-char #\" p)))) (print-string-alpha (lambda (s p) (for-each (lambda (c) (write-char c p)) (string->list s)))) (print-pair (lambda (pr p) (begin (write-char #\( p) (print-pairs pr p) (write-char #\) p)))) (print-pairs (lambda (pr p) (begin (write (car pr) p) (cond ((null? (cdr pr)) #t) ((pair? (cdr pr)) (begin (write-char #\space p) (print-pairs (cdr pr) p))) (else (begin (write-char #\space p) (write-char #\. p) (write-char #\space p) (write (cdr pr) p)))))))) (lambda (expr p alpha) (cond ((boolean? expr) (print-boolean expr p)) ((null? expr) (print-null p)) ((char? expr) (if alpha (write-char expr p) (print-char expr p))) ((fixnum? expr) (print-fixnum expr p)) ((string? expr) (if alpha (print-string-alpha expr p) (print-string expr p))) ((pair? expr) (print-pair expr p)) (else (error (quote write) "unrecognized expression")))))
# == uniquify-variables  ==>
# (letrec ((f259561 (lambda (f259602 f259603) (begin (write-char #\# f259603) (if f259602 (write-char #\t f259603) (write-char #\f f259603))))) (f259560 (lambda (f259601) (begin (write-char #\( f259601) (write-char #\) f259601)))) (f259559 (lambda (f259599 f259600) (begin (write-char #\# f259600) (write-char #\\ f259600) (write-char f259599 f259600)))) (f259558 (lambda (f259595 f259596) (if (negative? f259595) (begin (write-char #\- f259596) (f259558 (fx* -1 f259595) f259596)) (map (lambda (f259598) (write-char (fixnum->char (fx+ (char->fixnum #\0) f259598)) f259596)) (integer->list f259595))))) (f259557 (lambda (f259591 f259592) (begin (write-char #\" f259592) (for-each (lambda (f259594) (write-char f259594 f259592)) (string->list f259591)) (write-char #\" f259592)))) (f259556 (lambda (f259587 f259588) (for-each (lambda (f259590) (write-char f259590 f259588)) (string->list f259587)))) (f259555 (lambda (f259585 f259586) (begin (write-char #\( f259586) (f259554 f259585 f259586) (write-char #\) f259586)))) (f259554 (lambda (f259583 f259584) (begin (write (car f259583) f259584) (cond ((null? (cdr f259583)) #t) ((pair? (cdr f259583)) (begin (write-char #\space f259584) (f259554 (cdr f259583) f259584))) (else (begin (write-char #\space f259584) (write-char #\. f259584) (write-char #\space f259584) (write (cdr f259583) f259584)))))))) (lambda (f259607 f259608 f259609) (cond ((boolean? f259607) (f259561 f259607 f259608)) ((null? f259607) (f259560 f259608)) ((char? f259607) (if f259609 (write-char f259607 f259608) (f259559 f259607 f259608))) ((fixnum? f259607) (f259558 f259607 f259608)) ((string? f259607) (if f259609 (f259556 f259607 f259608) (f259557 f259607 f259608))) ((pair? f259607) (f259555 f259607 f259608)) (else (error (quote write) "unrecognized expression")))))
# == vectorize-letrec  ==>
# (let ((f259561 (make-vector 1)) (f259560 (make-vector 1)) (f259559 (make-vector 1)) (f259558 (make-vector 1)) (f259557 (make-vector 1)) (f259556 (make-vector 1)) (f259555 (make-vector 1)) (f259554 (make-vector 1))) (begin (begin (vector-set! f259561 0 (lambda (f259602 f259603) (begin (write-char #\# f259603) (if f259602 (write-char #\t f259603) (write-char #\f f259603))))) (vector-set! f259560 0 (lambda (f259601) (begin (write-char #\( f259601) (write-char #\) f259601)))) (vector-set! f259559 0 (lambda (f259599 f259600) (begin (write-char #\# f259600) (write-char #\\ f259600) (write-char f259599 f259600)))) (vector-set! f259558 0 (lambda (f259595 f259596) (if (negative? f259595) (begin (write-char #\- f259596) ((vector-ref f259558 0) (fx* -1 f259595) f259596)) (map (lambda (f259598) (write-char (fixnum->char (fx+ (char->fixnum #\0) f259598)) f259596)) (integer->list f259595))))) (vector-set! f259557 0 (lambda (f259591 f259592) (begin (write-char #\" f259592) (for-each (lambda (f259594) (write-char f259594 f259592)) (string->list f259591)) (write-char #\" f259592)))) (vector-set! f259556 0 (lambda (f259587 f259588) (for-each (lambda (f259590) (write-char f259590 f259588)) (string->list f259587)))) (vector-set! f259555 0 (lambda (f259585 f259586) (begin (write-char #\( f259586) ((vector-ref f259554 0) f259585 f259586) (write-char #\) f259586)))) (vector-set! f259554 0 (lambda (f259583 f259584) (begin (write (car f259583) f259584) (cond ((null? (cdr f259583)) #t) ((pair? (cdr f259583)) (begin (write-char #\space f259584) ((vector-ref f259554 0) (cdr f259583) f259584))) (else (begin (write-char #\space f259584) (write-char #\. f259584) (write-char #\space f259584) (write (cdr f259583) f259584)))))))) (lambda (f259607 f259608 f259609) (cond ((boolean? f259607) ((vector-ref f259561 0) f259607 f259608)) ((null? f259607) ((vector-ref f259560 0) f259608)) ((char? f259607) (if f259609 (write-char f259607 f259608) ((vector-ref f259559 0) f259607 f259608))) ((fixnum? f259607) ((vector-ref f259558 0) f259607 f259608)) ((string? f259607) (if f259609 ((vector-ref f259556 0) f259607 f259608) ((vector-ref f259557 0) f259607 f259608))) ((pair? f259607) ((vector-ref f259555 0) f259607 f259608)) (else (error (quote write) "unrecognized expression"))))))
# == eliminate-set!  ==>
# (let ((f259561 (make-vector 1)) (f259560 (make-vector 1)) (f259559 (make-vector 1)) (f259558 (make-vector 1)) (f259557 (make-vector 1)) (f259556 (make-vector 1)) (f259555 (make-vector 1)) (f259554 (make-vector 1))) (begin (begin (vector-set! f259561 0 (lambda (f259602 f259603) (let ((f259602 f259602) (f259603 f259603)) (begin (write-char #\# f259603) (if f259602 (write-char #\t f259603) (write-char #\f f259603)))))) (vector-set! f259560 0 (lambda (f259601) (let ((f259601 f259601)) (begin (write-char #\( f259601) (write-char #\) f259601))))) (vector-set! f259559 0 (lambda (f259599 f259600) (let ((f259599 f259599) (f259600 f259600)) (begin (write-char #\# f259600) (write-char #\\ f259600) (write-char f259599 f259600))))) (vector-set! f259558 0 (lambda (f259595 f259596) (let ((f259595 f259595) (f259596 f259596)) (if (negative? f259595) (begin (write-char #\- f259596) ((vector-ref f259558 0) (fx* -1 f259595) f259596)) (map (lambda (f259598) (let ((f259598 f259598)) (write-char (fixnum->char (fx+ (char->fixnum #\0) f259598)) f259596))) (integer->list f259595)))))) (vector-set! f259557 0 (lambda (f259591 f259592) (let ((f259591 f259591) (f259592 f259592)) (begin (write-char #\" f259592) (for-each (lambda (f259594) (let ((f259594 f259594)) (write-char f259594 f259592))) (string->list f259591)) (write-char #\" f259592))))) (vector-set! f259556 0 (lambda (f259587 f259588) (let ((f259587 f259587) (f259588 f259588)) (for-each (lambda (f259590) (let ((f259590 f259590)) (write-char f259590 f259588))) (string->list f259587))))) (vector-set! f259555 0 (lambda (f259585 f259586) (let ((f259585 f259585) (f259586 f259586)) (begin (write-char #\( f259586) ((vector-ref f259554 0) f259585 f259586) (write-char #\) f259586))))) (vector-set! f259554 0 (lambda (f259583 f259584) (let ((f259583 f259583) (f259584 f259584)) (begin (write (car f259583) f259584) (cond ((null? (cdr f259583)) #t) ((pair? (cdr f259583)) (begin (write-char #\space f259584) ((vector-ref f259554 0) (cdr f259583) f259584))) (else (begin (write-char #\space f259584) (write-char #\. f259584) (write-char #\space f259584) (write (cdr f259583) f259584))))))))) (lambda (f259607 f259608 f259609) (let ((f259607 f259607) (f259608 f259608) (f259609 f259609)) (cond ((boolean? f259607) ((vector-ref f259561 0) f259607 f259608)) ((null? f259607) ((vector-ref f259560 0) f259608)) ((char? f259607) (if f259609 (write-char f259607 f259608) ((vector-ref f259559 0) f259607 f259608))) ((fixnum? f259607) ((vector-ref f259558 0) f259607 f259608)) ((string? f259607) (if f259609 ((vector-ref f259556 0) f259607 f259608) ((vector-ref f259557 0) f259607 f259608))) ((pair? f259607) ((vector-ref f259555 0) f259607 f259608)) (else (error (quote write) "unrecognized expression")))))))
# == close-free-variables  ==>
# (let ((f259561 (make-vector 1)) (f259560 (make-vector 1)) (f259559 (make-vector 1)) (f259558 (make-vector 1)) (f259557 (make-vector 1)) (f259556 (make-vector 1)) (f259555 (make-vector 1)) (f259554 (make-vector 1))) (begin (begin (vector-set! f259561 0 (closure (f259602 f259603) (write-char write-char write-char) (let ((f259602 f259602) (f259603 f259603)) (begin (write-char #\# f259603) (if f259602 (write-char #\t f259603) (write-char #\f f259603)))))) (vector-set! f259560 0 (closure (f259601) (write-char write-char) (let ((f259601 f259601)) (begin (write-char #\( f259601) (write-char #\) f259601))))) (vector-set! f259559 0 (closure (f259599 f259600) (write-char write-char write-char) (let ((f259599 f259599) (f259600 f259600)) (begin (write-char #\# f259600) (write-char #\\ f259600) (write-char f259599 f259600))))) (vector-set! f259558 0 (closure (f259595 f259596) (negative? write-char f259558 map write-char integer->list) (let ((f259595 f259595) (f259596 f259596)) (if (negative? f259595) (begin (write-char #\- f259596) ((vector-ref f259558 0) (fx* -1 f259595) f259596)) (map (closure (f259598) (write-char f259596) (let ((f259598 f259598)) (write-char (fixnum->char (fx+ (char->fixnum #\0) f259598)) f259596))) (integer->list f259595)))))) (vector-set! f259557 0 (closure (f259591 f259592) (write-char for-each write-char string->list write-char) (let ((f259591 f259591) (f259592 f259592)) (begin (write-char #\" f259592) (for-each (closure (f259594) (write-char f259592) (let ((f259594 f259594)) (write-char f259594 f259592))) (string->list f259591)) (write-char #\" f259592))))) (vector-set! f259556 0 (closure (f259587 f259588) (for-each write-char string->list) (let ((f259587 f259587) (f259588 f259588)) (for-each (closure (f259590) (write-char f259588) (let ((f259590 f259590)) (write-char f259590 f259588))) (string->list f259587))))) (vector-set! f259555 0 (closure (f259585 f259586) (write-char f259554 write-char) (let ((f259585 f259585) (f259586 f259586)) (begin (write-char #\( f259586) ((vector-ref f259554 0) f259585 f259586) (write-char #\) f259586))))) (vector-set! f259554 0 (closure (f259583 f259584) (write write-char f259554 else write-char write-char write-char write) (let ((f259583 f259583) (f259584 f259584)) (begin (write (car f259583) f259584) (cond ((null? (cdr f259583)) #t) ((pair? (cdr f259583)) (begin (write-char #\space f259584) ((vector-ref f259554 0) (cdr f259583) f259584))) (else (begin (write-char #\space f259584) (write-char #\. f259584) (write-char #\space f259584) (write (cdr f259583) f259584))))))))) (closure (f259607 f259608 f259609) (f259561 f259560 write-char f259559 f259558 f259556 f259557 f259555 else error write) (let ((f259607 f259607) (f259608 f259608) (f259609 f259609)) (cond ((boolean? f259607) ((vector-ref f259561 0) f259607 f259608)) ((null? f259607) ((vector-ref f259560 0) f259608)) ((char? f259607) (if f259609 (write-char f259607 f259608) ((vector-ref f259559 0) f259607 f259608))) ((fixnum? f259607) ((vector-ref f259558 0) f259607 f259608)) ((string? f259607) (if f259609 ((vector-ref f259556 0) f259607 f259608) ((vector-ref f259557 0) f259607 f259608))) ((pair? f259607) ((vector-ref f259555 0) f259607 f259608)) (else (error (quote write) "unrecognized expression")))))))
# == eliminate-quote  ==>
# (let ((f259561 (make-vector 1)) (f259560 (make-vector 1)) (f259559 (make-vector 1)) (f259558 (make-vector 1)) (f259557 (make-vector 1)) (f259556 (make-vector 1)) (f259555 (make-vector 1)) (f259554 (make-vector 1))) (begin (begin (vector-set! f259561 0 (closure (f259602 f259603) (write-char write-char write-char) (let ((f259602 f259602) (f259603 f259603)) (begin (write-char #\# f259603) (if f259602 (write-char #\t f259603) (write-char #\f f259603)))))) (vector-set! f259560 0 (closure (f259601) (write-char write-char) (let ((f259601 f259601)) (begin (write-char #\( f259601) (write-char #\) f259601))))) (vector-set! f259559 0 (closure (f259599 f259600) (write-char write-char write-char) (let ((f259599 f259599) (f259600 f259600)) (begin (write-char #\# f259600) (write-char #\\ f259600) (write-char f259599 f259600))))) (vector-set! f259558 0 (closure (f259595 f259596) (negative? write-char f259558 map write-char integer->list) (let ((f259595 f259595) (f259596 f259596)) (if (negative? f259595) (begin (write-char #\- f259596) ((vector-ref f259558 0) (fx* -1 f259595) f259596)) (map (closure (f259598) (write-char f259596) (let ((f259598 f259598)) (write-char (fixnum->char (fx+ (char->fixnum #\0) f259598)) f259596))) (integer->list f259595)))))) (vector-set! f259557 0 (closure (f259591 f259592) (write-char for-each write-char string->list write-char) (let ((f259591 f259591) (f259592 f259592)) (begin (write-char #\" f259592) (for-each (closure (f259594) (write-char f259592) (let ((f259594 f259594)) (write-char f259594 f259592))) (string->list f259591)) (write-char #\" f259592))))) (vector-set! f259556 0 (closure (f259587 f259588) (for-each write-char string->list) (let ((f259587 f259587) (f259588 f259588)) (for-each (closure (f259590) (write-char f259588) (let ((f259590 f259590)) (write-char f259590 f259588))) (string->list f259587))))) (vector-set! f259555 0 (closure (f259585 f259586) (write-char f259554 write-char) (let ((f259585 f259585) (f259586 f259586)) (begin (write-char #\( f259586) ((vector-ref f259554 0) f259585 f259586) (write-char #\) f259586))))) (vector-set! f259554 0 (closure (f259583 f259584) (write write-char f259554 else write-char write-char write-char write) (let ((f259583 f259583) (f259584 f259584)) (begin (write (car f259583) f259584) (cond ((null? (cdr f259583)) #t) ((pair? (cdr f259583)) (begin (write-char #\space f259584) ((vector-ref f259554 0) (cdr f259583) f259584))) (else (begin (write-char #\space f259584) (write-char #\. f259584) (write-char #\space f259584) (write (cdr f259583) f259584))))))))) (closure (f259607 f259608 f259609) (f259561 f259560 write-char f259559 f259558 f259556 f259557 f259555 else error write) (let ((f259607 f259607) (f259608 f259608) (f259609 f259609)) (cond ((boolean? f259607) ((vector-ref f259561 0) f259607 f259608)) ((null? f259607) ((vector-ref f259560 0) f259608)) ((char? f259607) (if f259609 (write-char f259607 f259608) ((vector-ref f259559 0) f259607 f259608))) ((fixnum? f259607) ((vector-ref f259558 0) f259607 f259608)) ((string? f259607) (if f259609 ((vector-ref f259556 0) f259607 f259608) ((vector-ref f259557 0) f259607 f259608))) ((pair? f259607) ((vector-ref f259555 0) f259607 f259608)) (else (error (string->symbol "write") "unrecognized expression")))))))
# == eliminate-when/unless  ==>
# (let ((f259561 (make-vector 1)) (f259560 (make-vector 1)) (f259559 (make-vector 1)) (f259558 (make-vector 1)) (f259557 (make-vector 1)) (f259556 (make-vector 1)) (f259555 (make-vector 1)) (f259554 (make-vector 1))) (begin (begin (vector-set! f259561 0 (closure (f259602 f259603) (write-char write-char write-char) (let ((f259602 f259602) (f259603 f259603)) (begin (write-char #\# f259603) (if f259602 (write-char #\t f259603) (write-char #\f f259603)))))) (vector-set! f259560 0 (closure (f259601) (write-char write-char) (let ((f259601 f259601)) (begin (write-char #\( f259601) (write-char #\) f259601))))) (vector-set! f259559 0 (closure (f259599 f259600) (write-char write-char write-char) (let ((f259599 f259599) (f259600 f259600)) (begin (write-char #\# f259600) (write-char #\\ f259600) (write-char f259599 f259600))))) (vector-set! f259558 0 (closure (f259595 f259596) (negative? write-char f259558 map write-char integer->list) (let ((f259595 f259595) (f259596 f259596)) (if (negative? f259595) (begin (write-char #\- f259596) ((vector-ref f259558 0) (fx* -1 f259595) f259596)) (map (closure (f259598) (write-char f259596) (let ((f259598 f259598)) (write-char (fixnum->char (fx+ (char->fixnum #\0) f259598)) f259596))) (integer->list f259595)))))) (vector-set! f259557 0 (closure (f259591 f259592) (write-char for-each write-char string->list write-char) (let ((f259591 f259591) (f259592 f259592)) (begin (write-char #\" f259592) (for-each (closure (f259594) (write-char f259592) (let ((f259594 f259594)) (write-char f259594 f259592))) (string->list f259591)) (write-char #\" f259592))))) (vector-set! f259556 0 (closure (f259587 f259588) (for-each write-char string->list) (let ((f259587 f259587) (f259588 f259588)) (for-each (closure (f259590) (write-char f259588) (let ((f259590 f259590)) (write-char f259590 f259588))) (string->list f259587))))) (vector-set! f259555 0 (closure (f259585 f259586) (write-char f259554 write-char) (let ((f259585 f259585) (f259586 f259586)) (begin (write-char #\( f259586) ((vector-ref f259554 0) f259585 f259586) (write-char #\) f259586))))) (vector-set! f259554 0 (closure (f259583 f259584) (write write-char f259554 else write-char write-char write-char write) (let ((f259583 f259583) (f259584 f259584)) (begin (write (car f259583) f259584) (cond ((null? (cdr f259583)) #t) ((pair? (cdr f259583)) (begin (write-char #\space f259584) ((vector-ref f259554 0) (cdr f259583) f259584))) (else (begin (write-char #\space f259584) (write-char #\. f259584) (write-char #\space f259584) (write (cdr f259583) f259584))))))))) (closure (f259607 f259608 f259609) (f259561 f259560 write-char f259559 f259558 f259556 f259557 f259555 else error write) (let ((f259607 f259607) (f259608 f259608) (f259609 f259609)) (cond ((boolean? f259607) ((vector-ref f259561 0) f259607 f259608)) ((null? f259607) ((vector-ref f259560 0) f259608)) ((char? f259607) (if f259609 (write-char f259607 f259608) ((vector-ref f259559 0) f259607 f259608))) ((fixnum? f259607) ((vector-ref f259558 0) f259607 f259608)) ((string? f259607) (if f259609 ((vector-ref f259556 0) f259607 f259608) ((vector-ref f259557 0) f259607 f259608))) ((pair? f259607) ((vector-ref f259555 0) f259607 f259608)) (else (error (string->symbol "write") "unrecognized expression")))))))
# == eliminate-cond  ==>
# (let ((f259561 (make-vector 1)) (f259560 (make-vector 1)) (f259559 (make-vector 1)) (f259558 (make-vector 1)) (f259557 (make-vector 1)) (f259556 (make-vector 1)) (f259555 (make-vector 1)) (f259554 (make-vector 1))) (begin (begin (vector-set! f259561 0 (closure (f259602 f259603) (write-char write-char write-char) (let ((f259602 f259602) (f259603 f259603)) (begin (write-char #\# f259603) (if f259602 (write-char #\t f259603) (write-char #\f f259603)))))) (vector-set! f259560 0 (closure (f259601) (write-char write-char) (let ((f259601 f259601)) (begin (write-char #\( f259601) (write-char #\) f259601))))) (vector-set! f259559 0 (closure (f259599 f259600) (write-char write-char write-char) (let ((f259599 f259599) (f259600 f259600)) (begin (write-char #\# f259600) (write-char #\\ f259600) (write-char f259599 f259600))))) (vector-set! f259558 0 (closure (f259595 f259596) (negative? write-char f259558 map write-char integer->list) (let ((f259595 f259595) (f259596 f259596)) (if (negative? f259595) (begin (write-char #\- f259596) ((vector-ref f259558 0) (fx* -1 f259595) f259596)) (map (closure (f259598) (write-char f259596) (let ((f259598 f259598)) (write-char (fixnum->char (fx+ (char->fixnum #\0) f259598)) f259596))) (integer->list f259595)))))) (vector-set! f259557 0 (closure (f259591 f259592) (write-char for-each write-char string->list write-char) (let ((f259591 f259591) (f259592 f259592)) (begin (write-char #\" f259592) (for-each (closure (f259594) (write-char f259592) (let ((f259594 f259594)) (write-char f259594 f259592))) (string->list f259591)) (write-char #\" f259592))))) (vector-set! f259556 0 (closure (f259587 f259588) (for-each write-char string->list) (let ((f259587 f259587) (f259588 f259588)) (for-each (closure (f259590) (write-char f259588) (let ((f259590 f259590)) (write-char f259590 f259588))) (string->list f259587))))) (vector-set! f259555 0 (closure (f259585 f259586) (write-char f259554 write-char) (let ((f259585 f259585) (f259586 f259586)) (begin (write-char #\( f259586) ((vector-ref f259554 0) f259585 f259586) (write-char #\) f259586))))) (vector-set! f259554 0 (closure (f259583 f259584) (write write-char f259554 else write-char write-char write-char write) (let ((f259583 f259583) (f259584 f259584)) (begin (write (car f259583) f259584) (if (null? (cdr f259583)) #t (if (pair? (cdr f259583)) (begin (write-char #\space f259584) ((vector-ref f259554 0) (cdr f259583) f259584)) (begin (write-char #\space f259584) (write-char #\. f259584) (write-char #\space f259584) (write (cdr f259583) f259584))))))))) (closure (f259607 f259608 f259609) (f259561 f259560 write-char f259559 f259558 f259556 f259557 f259555 else error write) (let ((f259607 f259607) (f259608 f259608) (f259609 f259609)) (if (boolean? f259607) ((vector-ref f259561 0) f259607 f259608) (if (null? f259607) ((vector-ref f259560 0) f259608) (if (char? f259607) (if f259609 (write-char f259607 f259608) ((vector-ref f259559 0) f259607 f259608)) (if (fixnum? f259607) ((vector-ref f259558 0) f259607 f259608) (if (string? f259607) (if f259609 ((vector-ref f259556 0) f259607 f259608) ((vector-ref f259557 0) f259607 f259608)) (if (pair? f259607) ((vector-ref f259555 0) f259607 f259608) (error (string->symbol "write") "unrecognized expression")))))))))))
# == external-symbols  ==>
# (let ((f259561 (make-vector 1)) (f259560 (make-vector 1)) (f259559 (make-vector 1)) (f259558 (make-vector 1)) (f259557 (make-vector 1)) (f259556 (make-vector 1)) (f259555 (make-vector 1)) (f259554 (make-vector 1))) (begin (begin (vector-set! f259561 0 (closure (f259602 f259603) ((primitive-ref write-char) (primitive-ref write-char) (primitive-ref write-char)) (let ((f259602 f259602) (f259603 f259603)) (begin ((primitive-ref write-char) #\# f259603) (if f259602 ((primitive-ref write-char) #\t f259603) ((primitive-ref write-char) #\f f259603)))))) (vector-set! f259560 0 (closure (f259601) ((primitive-ref write-char) (primitive-ref write-char)) (let ((f259601 f259601)) (begin ((primitive-ref write-char) #\( f259601) ((primitive-ref write-char) #\) f259601))))) (vector-set! f259559 0 (closure (f259599 f259600) ((primitive-ref write-char) (primitive-ref write-char) (primitive-ref write-char)) (let ((f259599 f259599) (f259600 f259600)) (begin ((primitive-ref write-char) #\# f259600) ((primitive-ref write-char) #\\ f259600) ((primitive-ref write-char) f259599 f259600))))) (vector-set! f259558 0 (closure (f259595 f259596) ((primitive-ref negative?) (primitive-ref write-char) f259558 (primitive-ref map) (primitive-ref write-char) (primitive-ref integer->list)) (let ((f259595 f259595) (f259596 f259596)) (if ((primitive-ref negative?) f259595) (begin ((primitive-ref write-char) #\- f259596) ((vector-ref f259558 0) (fx* -1 f259595) f259596)) ((primitive-ref map) (closure (f259598) ((primitive-ref write-char) f259596) (let ((f259598 f259598)) ((primitive-ref write-char) (fixnum->char (fx+ (char->fixnum #\0) f259598)) f259596))) ((primitive-ref integer->list) f259595)))))) (vector-set! f259557 0 (closure (f259591 f259592) ((primitive-ref write-char) (primitive-ref for-each) (primitive-ref write-char) (primitive-ref string->list) (primitive-ref write-char)) (let ((f259591 f259591) (f259592 f259592)) (begin ((primitive-ref write-char) #\" f259592) ((primitive-ref for-each) (closure (f259594) ((primitive-ref write-char) f259592) (let ((f259594 f259594)) ((primitive-ref write-char) f259594 f259592))) ((primitive-ref string->list) f259591)) ((primitive-ref write-char) #\" f259592))))) (vector-set! f259556 0 (closure (f259587 f259588) ((primitive-ref for-each) (primitive-ref write-char) (primitive-ref string->list)) (let ((f259587 f259587) (f259588 f259588)) ((primitive-ref for-each) (closure (f259590) ((primitive-ref write-char) f259588) (let ((f259590 f259590)) ((primitive-ref write-char) f259590 f259588))) ((primitive-ref string->list) f259587))))) (vector-set! f259555 0 (closure (f259585 f259586) ((primitive-ref write-char) f259554 (primitive-ref write-char)) (let ((f259585 f259585) (f259586 f259586)) (begin ((primitive-ref write-char) #\( f259586) ((vector-ref f259554 0) f259585 f259586) ((primitive-ref write-char) #\) f259586))))) (vector-set! f259554 0 (closure (f259583 f259584) ((primitive-ref write) (primitive-ref write-char) f259554 else (primitive-ref write-char) (primitive-ref write-char) (primitive-ref write-char) (primitive-ref write)) (let ((f259583 f259583) (f259584 f259584)) (begin ((primitive-ref write) (car f259583) f259584) (if (null? (cdr f259583)) #t (if (pair? (cdr f259583)) (begin ((primitive-ref write-char) #\space f259584) ((vector-ref f259554 0) (cdr f259583) f259584)) (begin ((primitive-ref write-char) #\space f259584) ((primitive-ref write-char) #\. f259584) ((primitive-ref write-char) #\space f259584) ((primitive-ref write) (cdr f259583) f259584))))))))) (closure (f259607 f259608 f259609) (f259561 f259560 (primitive-ref write-char) f259559 f259558 f259556 f259557 f259555 else (primitive-ref error) (primitive-ref write)) (let ((f259607 f259607) (f259608 f259608) (f259609 f259609)) (if (boolean? f259607) ((vector-ref f259561 0) f259607 f259608) (if (null? f259607) ((vector-ref f259560 0) f259608) (if (char? f259607) (if f259609 ((primitive-ref write-char) f259607 f259608) ((vector-ref f259559 0) f259607 f259608)) (if (fixnum? f259607) ((vector-ref f259558 0) f259607 f259608) (if (string? f259607) (if f259609 ((vector-ref f259556 0) f259607 f259608) ((vector-ref f259557 0) f259607 f259608)) (if (pair? f259607) ((vector-ref f259555 0) f259607 f259608) ((primitive-ref error) ((primitive-ref string->symbol) "write") "unrecognized expression")))))))))))
# emit-expr (let ((f259561 (make-vector 1)) (f259560 (make-vector 1)) (f259559 (make-vector 1)) (f259558 (make-vector 1)) (f259557 (make-vector 1)) (f259556 (make-vector 1)) (f259555 (make-vector 1)) (f259554 (make-vector 1))) (begin (begin (vector-set! f259561 0 (closure (f259602 f259603) ((primitive-ref write-char) (primitive-ref write-char) (primitive-ref write-char)) (let ((f259602 f259602) (f259603 f259603)) (begin ((primitive-ref write-char) #\# f259603) (if f259602 ((primitive-ref write-char) #\t f259603) ((primitive-ref write-char) #\f f259603)))))) (vector-set! f259560 0 (closure (f259601) ((primitive-ref write-char) (primitive-ref write-char)) (let ((f259601 f259601)) (begin ((primitive-ref write-char) #\( f259601) ((primitive-ref write-char) #\) f259601))))) (vector-set! f259559 0 (closure (f259599 f259600) ((primitive-ref write-char) (primitive-ref write-char) (primitive-ref write-char)) (let ((f259599 f259599) (f259600 f259600)) (begin ((primitive-ref write-char) #\# f259600) ((primitive-ref write-char) #\\ f259600) ((primitive-ref write-char) f259599 f259600))))) (vector-set! f259558 0 (closure (f259595 f259596) ((primitive-ref negative?) (primitive-ref write-char) f259558 (primitive-ref map) (primitive-ref write-char) (primitive-ref integer->list)) (let ((f259595 f259595) (f259596 f259596)) (if ((primitive-ref negative?) f259595) (begin ((primitive-ref write-char) #\- f259596) ((vector-ref f259558 0) (fx* -1 f259595) f259596)) ((primitive-ref map) (closure (f259598) ((primitive-ref write-char) f259596) (let ((f259598 f259598)) ((primitive-ref write-char) (fixnum->char (fx+ (char->fixnum #\0) f259598)) f259596))) ((primitive-ref integer->list) f259595)))))) (vector-set! f259557 0 (closure (f259591 f259592) ((primitive-ref write-char) (primitive-ref for-each) (primitive-ref write-char) (primitive-ref string->list) (primitive-ref write-char)) (let ((f259591 f259591) (f259592 f259592)) (begin ((primitive-ref write-char) #\" f259592) ((primitive-ref for-each) (closure (f259594) ((primitive-ref write-char) f259592) (let ((f259594 f259594)) ((primitive-ref write-char) f259594 f259592))) ((primitive-ref string->list) f259591)) ((primitive-ref write-char) #\" f259592))))) (vector-set! f259556 0 (closure (f259587 f259588) ((primitive-ref for-each) (primitive-ref write-char) (primitive-ref string->list)) (let ((f259587 f259587) (f259588 f259588)) ((primitive-ref for-each) (closure (f259590) ((primitive-ref write-char) f259588) (let ((f259590 f259590)) ((primitive-ref write-char) f259590 f259588))) ((primitive-ref string->list) f259587))))) (vector-set! f259555 0 (closure (f259585 f259586) ((primitive-ref write-char) f259554 (primitive-ref write-char)) (let ((f259585 f259585) (f259586 f259586)) (begin ((primitive-ref write-char) #\( f259586) ((vector-ref f259554 0) f259585 f259586) ((primitive-ref write-char) #\) f259586))))) (vector-set! f259554 0 (closure (f259583 f259584) ((primitive-ref write) (primitive-ref write-char) f259554 else (primitive-ref write-char) (primitive-ref write-char) (primitive-ref write-char) (primitive-ref write)) (let ((f259583 f259583) (f259584 f259584)) (begin ((primitive-ref write) (car f259583) f259584) (if (null? (cdr f259583)) #t (if (pair? (cdr f259583)) (begin ((primitive-ref write-char) #\space f259584) ((vector-ref f259554 0) (cdr f259583) f259584)) (begin ((primitive-ref write-char) #\space f259584) ((primitive-ref write-char) #\. f259584) ((primitive-ref write-char) #\space f259584) ((primitive-ref write) (cdr f259583) f259584))))))))) (closure (f259607 f259608 f259609) (f259561 f259560 (primitive-ref write-char) f259559 f259558 f259556 f259557 f259555 else (primitive-ref error) (primitive-ref write)) (let ((f259607 f259607) (f259608 f259608) (f259609 f259609)) (if (boolean? f259607) ((vector-ref f259561 0) f259607 f259608) (if (null? f259607) ((vector-ref f259560 0) f259608) (if (char? f259607) (if f259609 ((primitive-ref write-char) f259607 f259608) ((vector-ref f259559 0) f259607 f259608)) (if (fixnum? f259607) ((vector-ref f259558 0) f259607 f259608) (if (string? f259607) (if f259609 ((vector-ref f259556 0) f259607 f259608) ((vector-ref f259557 0) f259607 f259608)) (if (pair? f259607) ((vector-ref f259555 0) f259607 f259608) ((primitive-ref error) ((primitive-ref string->symbol) "write") "unrecognized expression")))))))))))
# emit-let
#  si   = 0
#  env  = ()
#  bindings = ((f259561 (make-vector 1)) (f259560 (make-vector 1)) (f259559 (make-vector 1)) (f259558 (make-vector 1)) (f259557 (make-vector 1)) (f259556 (make-vector 1)) (f259555 (make-vector 1)) (f259554 (make-vector 1)))
#  body = (begin (begin (vector-set! f259561 0 (closure (f259602 f259603) ((primitive-ref write-char) (primitive-ref write-char) (primitive-ref write-char)) (let ((f259602 f259602) (f259603 f259603)) (begin ((primitive-ref write-char) #\# f259603) (if f259602 ((primitive-ref write-char) #\t f259603) ((primitive-ref write-char) #\f f259603)))))) (vector-set! f259560 0 (closure (f259601) ((primitive-ref write-char) (primitive-ref write-char)) (let ((f259601 f259601)) (begin ((primitive-ref write-char) #\( f259601) ((primitive-ref write-char) #\) f259601))))) (vector-set! f259559 0 (closure (f259599 f259600) ((primitive-ref write-char) (primitive-ref write-char) (primitive-ref write-char)) (let ((f259599 f259599) (f259600 f259600)) (begin ((primitive-ref write-char) #\# f259600) ((primitive-ref write-char) #\\ f259600) ((primitive-ref write-char) f259599 f259600))))) (vector-set! f259558 0 (closure (f259595 f259596) ((primitive-ref negative?) (primitive-ref write-char) f259558 (primitive-ref map) (primitive-ref write-char) (primitive-ref integer->list)) (let ((f259595 f259595) (f259596 f259596)) (if ((primitive-ref negative?) f259595) (begin ((primitive-ref write-char) #\- f259596) ((vector-ref f259558 0) (fx* -1 f259595) f259596)) ((primitive-ref map) (closure (f259598) ((primitive-ref write-char) f259596) (let ((f259598 f259598)) ((primitive-ref write-char) (fixnum->char (fx+ (char->fixnum #\0) f259598)) f259596))) ((primitive-ref integer->list) f259595)))))) (vector-set! f259557 0 (closure (f259591 f259592) ((primitive-ref write-char) (primitive-ref for-each) (primitive-ref write-char) (primitive-ref string->list) (primitive-ref write-char)) (let ((f259591 f259591) (f259592 f259592)) (begin ((primitive-ref write-char) #\" f259592) ((primitive-ref for-each) (closure (f259594) ((primitive-ref write-char) f259592) (let ((f259594 f259594)) ((primitive-ref write-char) f259594 f259592))) ((primitive-ref string->list) f259591)) ((primitive-ref write-char) #\" f259592))))) (vector-set! f259556 0 (closure (f259587 f259588) ((primitive-ref for-each) (primitive-ref write-char) (primitive-ref string->list)) (let ((f259587 f259587) (f259588 f259588)) ((primitive-ref for-each) (closure (f259590) ((primitive-ref write-char) f259588) (let ((f259590 f259590)) ((primitive-ref write-char) f259590 f259588))) ((primitive-ref string->list) f259587))))) (vector-set! f259555 0 (closure (f259585 f259586) ((primitive-ref write-char) f259554 (primitive-ref write-char)) (let ((f259585 f259585) (f259586 f259586)) (begin ((primitive-ref write-char) #\( f259586) ((vector-ref f259554 0) f259585 f259586) ((primitive-ref write-char) #\) f259586))))) (vector-set! f259554 0 (closure (f259583 f259584) ((primitive-ref write) (primitive-ref write-char) f259554 else (primitive-ref write-char) (primitive-ref write-char) (primitive-ref write-char) (primitive-ref write)) (let ((f259583 f259583) (f259584 f259584)) (begin ((primitive-ref write) (car f259583) f259584) (if (null? (cdr f259583)) #t (if (pair? (cdr f259583)) (begin ((primitive-ref write-char) #\space f259584) ((vector-ref f259554 0) (cdr f259583) f259584)) (begin ((primitive-ref write-char) #\space f259584) ((primitive-ref write-char) #\. f259584) ((primitive-ref write-char) #\space f259584) ((primitive-ref write) (cdr f259583) f259584))))))))) (closure (f259607 f259608 f259609) (f259561 f259560 (primitive-ref write-char) f259559 f259558 f259556 f259557 f259555 else (primitive-ref error) (primitive-ref write)) (let ((f259607 f259607) (f259608 f259608) (f259609 f259609)) (if (boolean? f259607) ((vector-ref f259561 0) f259607 f259608) (if (null? f259607) ((vector-ref f259560 0) f259608) (if (char? f259607) (if f259609 ((primitive-ref write-char) f259607 f259608) ((vector-ref f259559 0) f259607 f259608)) (if (fixnum? f259607) ((vector-ref f259558 0) f259607 f259608) (if (string? f259607) (if f259609 ((vector-ref f259556 0) f259607 f259608) ((vector-ref f259557 0) f259607 f259608)) (if (pair? f259607) ((vector-ref f259555 0) f259607 f259608) ((primitive-ref error) ((primitive-ref string->symbol) "write") "unrecognized expression"))))))))))
# emit-expr (make-vector 1)
# make-vector 1
# emit-expr 1
    movl $4, %eax     # immed 1
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1577237"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $128,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1577237:
# check the argument is a fixnum >= 0
    cmp $0,%eax
    jge _L_1577238
# invoke error handler eh_length
    .extern mrc_eh$ulength
    movl mrc_eh$ulength, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $128,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1577238:
    movl %eax, %esi
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    orl  $5, %eax
    addl $4, %esi
    addl $4, %esi
    andl $-8, %esi
    addl %esi, %ebp
    movl %eax, 0(%esp)  # stack save
# emit-expr (make-vector 1)
# make-vector 1
# emit-expr 1
    movl $4, %eax     # immed 1
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1577239"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $128,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1577239:
# check the argument is a fixnum >= 0
    cmp $0,%eax
    jge _L_1577240
# invoke error handler eh_length
    .extern mrc_eh$ulength
    movl mrc_eh$ulength, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $128,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1577240:
    movl %eax, %esi
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    orl  $5, %eax
    addl $4, %esi
    addl $4, %esi
    andl $-8, %esi
    addl %esi, %ebp
    movl %eax, -4(%esp)  # stack save
# emit-expr (make-vector 1)
# make-vector 1
# emit-expr 1
    movl $4, %eax     # immed 1
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1577241"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $128,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1577241:
# check the argument is a fixnum >= 0
    cmp $0,%eax
    jge _L_1577242
# invoke error handler eh_length
    .extern mrc_eh$ulength
    movl mrc_eh$ulength, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $128,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1577242:
    movl %eax, %esi
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    orl  $5, %eax
    addl $4, %esi
    addl $4, %esi
    andl $-8, %esi
    addl %esi, %ebp
    movl %eax, -8(%esp)  # stack save
# emit-expr (make-vector 1)
# make-vector 1
# emit-expr 1
    movl $4, %eax     # immed 1
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1577243"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $128,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1577243:
# check the argument is a fixnum >= 0
    cmp $0,%eax
    jge _L_1577244
# invoke error handler eh_length
    .extern mrc_eh$ulength
    movl mrc_eh$ulength, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $128,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1577244:
    movl %eax, %esi
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    orl  $5, %eax
    addl $4, %esi
    addl $4, %esi
    andl $-8, %esi
    addl %esi, %ebp
    movl %eax, -12(%esp)  # stack save
# emit-expr (make-vector 1)
# make-vector 1
# emit-expr 1
    movl $4, %eax     # immed 1
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1577245"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $128,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1577245:
# check the argument is a fixnum >= 0
    cmp $0,%eax
    jge _L_1577246
# invoke error handler eh_length
    .extern mrc_eh$ulength
    movl mrc_eh$ulength, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $128,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1577246:
    movl %eax, %esi
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    orl  $5, %eax
    addl $4, %esi
    addl $4, %esi
    andl $-8, %esi
    addl %esi, %ebp
    movl %eax, -16(%esp)  # stack save
# emit-expr (make-vector 1)
# make-vector 1
# emit-expr 1
    movl $4, %eax     # immed 1
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1577247"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $128,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1577247:
# check the argument is a fixnum >= 0
    cmp $0,%eax
    jge _L_1577248
# invoke error handler eh_length
    .extern mrc_eh$ulength
    movl mrc_eh$ulength, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $128,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1577248:
    movl %eax, %esi
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    orl  $5, %eax
    addl $4, %esi
    addl $4, %esi
    andl $-8, %esi
    addl %esi, %ebp
    movl %eax, -20(%esp)  # stack save
# emit-expr (make-vector 1)
# make-vector 1
# emit-expr 1
    movl $4, %eax     # immed 1
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1577249"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $128,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1577249:
# check the argument is a fixnum >= 0
    cmp $0,%eax
    jge _L_1577250
# invoke error handler eh_length
    .extern mrc_eh$ulength
    movl mrc_eh$ulength, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $128,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1577250:
    movl %eax, %esi
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    orl  $5, %eax
    addl $4, %esi
    addl $4, %esi
    andl $-8, %esi
    addl %esi, %ebp
    movl %eax, -24(%esp)  # stack save
# emit-expr (make-vector 1)
# make-vector 1
# emit-expr 1
    movl $4, %eax     # immed 1
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1577251"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $128,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1577251:
# check the argument is a fixnum >= 0
    cmp $0,%eax
    jge _L_1577252
# invoke error handler eh_length
    .extern mrc_eh$ulength
    movl mrc_eh$ulength, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $128,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1577252:
    movl %eax, %esi
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    orl  $5, %eax
    addl $4, %esi
    addl $4, %esi
    andl $-8, %esi
    addl %esi, %ebp
    movl %eax, -28(%esp)  # stack save
# emit-expr (begin (begin (vector-set! f259561 0 (closure (f259602 f259603) ((primitive-ref write-char) (primitive-ref write-char) (primitive-ref write-char)) (let ((f259602 f259602) (f259603 f259603)) (begin ((primitive-ref write-char) #\# f259603) (if f259602 ((primitive-ref write-char) #\t f259603) ((primitive-ref write-char) #\f f259603)))))) (vector-set! f259560 0 (closure (f259601) ((primitive-ref write-char) (primitive-ref write-char)) (let ((f259601 f259601)) (begin ((primitive-ref write-char) #\( f259601) ((primitive-ref write-char) #\) f259601))))) (vector-set! f259559 0 (closure (f259599 f259600) ((primitive-ref write-char) (primitive-ref write-char) (primitive-ref write-char)) (let ((f259599 f259599) (f259600 f259600)) (begin ((primitive-ref write-char) #\# f259600) ((primitive-ref write-char) #\\ f259600) ((primitive-ref write-char) f259599 f259600))))) (vector-set! f259558 0 (closure (f259595 f259596) ((primitive-ref negative?) (primitive-ref write-char) f259558 (primitive-ref map) (primitive-ref write-char) (primitive-ref integer->list)) (let ((f259595 f259595) (f259596 f259596)) (if ((primitive-ref negative?) f259595) (begin ((primitive-ref write-char) #\- f259596) ((vector-ref f259558 0) (fx* -1 f259595) f259596)) ((primitive-ref map) (closure (f259598) ((primitive-ref write-char) f259596) (let ((f259598 f259598)) ((primitive-ref write-char) (fixnum->char (fx+ (char->fixnum #\0) f259598)) f259596))) ((primitive-ref integer->list) f259595)))))) (vector-set! f259557 0 (closure (f259591 f259592) ((primitive-ref write-char) (primitive-ref for-each) (primitive-ref write-char) (primitive-ref string->list) (primitive-ref write-char)) (let ((f259591 f259591) (f259592 f259592)) (begin ((primitive-ref write-char) #\" f259592) ((primitive-ref for-each) (closure (f259594) ((primitive-ref write-char) f259592) (let ((f259594 f259594)) ((primitive-ref write-char) f259594 f259592))) ((primitive-ref string->list) f259591)) ((primitive-ref write-char) #\" f259592))))) (vector-set! f259556 0 (closure (f259587 f259588) ((primitive-ref for-each) (primitive-ref write-char) (primitive-ref string->list)) (let ((f259587 f259587) (f259588 f259588)) ((primitive-ref for-each) (closure (f259590) ((primitive-ref write-char) f259588) (let ((f259590 f259590)) ((primitive-ref write-char) f259590 f259588))) ((primitive-ref string->list) f259587))))) (vector-set! f259555 0 (closure (f259585 f259586) ((primitive-ref write-char) f259554 (primitive-ref write-char)) (let ((f259585 f259585) (f259586 f259586)) (begin ((primitive-ref write-char) #\( f259586) ((vector-ref f259554 0) f259585 f259586) ((primitive-ref write-char) #\) f259586))))) (vector-set! f259554 0 (closure (f259583 f259584) ((primitive-ref write) (primitive-ref write-char) f259554 else (primitive-ref write-char) (primitive-ref write-char) (primitive-ref write-char) (primitive-ref write)) (let ((f259583 f259583) (f259584 f259584)) (begin ((primitive-ref write) (car f259583) f259584) (if (null? (cdr f259583)) #t (if (pair? (cdr f259583)) (begin ((primitive-ref write-char) #\space f259584) ((vector-ref f259554 0) (cdr f259583) f259584)) (begin ((primitive-ref write-char) #\space f259584) ((primitive-ref write-char) #\. f259584) ((primitive-ref write-char) #\space f259584) ((primitive-ref write) (cdr f259583) f259584))))))))) (closure (f259607 f259608 f259609) (f259561 f259560 (primitive-ref write-char) f259559 f259558 f259556 f259557 f259555 else (primitive-ref error) (primitive-ref write)) (let ((f259607 f259607) (f259608 f259608) (f259609 f259609)) (if (boolean? f259607) ((vector-ref f259561 0) f259607 f259608) (if (null? f259607) ((vector-ref f259560 0) f259608) (if (char? f259607) (if f259609 ((primitive-ref write-char) f259607 f259608) ((vector-ref f259559 0) f259607 f259608)) (if (fixnum? f259607) ((vector-ref f259558 0) f259607 f259608) (if (string? f259607) (if f259609 ((vector-ref f259556 0) f259607 f259608) ((vector-ref f259557 0) f259607 f259608)) (if (pair? f259607) ((vector-ref f259555 0) f259607 f259608) ((primitive-ref error) ((primitive-ref string->symbol) "write") "unrecognized expression"))))))))))
# emit-begin
#   expr=(begin (begin (vector-set! f259561 0 (closure (f259602 f259603) ((primitive-ref write-char) (primitive-ref write-char) (primitive-ref write-char)) (let ((f259602 f259602) (f259603 f259603)) (begin ((primitive-ref write-char) #\# f259603) (if f259602 ((primitive-ref write-char) #\t f259603) ((primitive-ref write-char) #\f f259603)))))) (vector-set! f259560 0 (closure (f259601) ((primitive-ref write-char) (primitive-ref write-char)) (let ((f259601 f259601)) (begin ((primitive-ref write-char) #\( f259601) ((primitive-ref write-char) #\) f259601))))) (vector-set! f259559 0 (closure (f259599 f259600) ((primitive-ref write-char) (primitive-ref write-char) (primitive-ref write-char)) (let ((f259599 f259599) (f259600 f259600)) (begin ((primitive-ref write-char) #\# f259600) ((primitive-ref write-char) #\\ f259600) ((primitive-ref write-char) f259599 f259600))))) (vector-set! f259558 0 (closure (f259595 f259596) ((primitive-ref negative?) (primitive-ref write-char) f259558 (primitive-ref map) (primitive-ref write-char) (primitive-ref integer->list)) (let ((f259595 f259595) (f259596 f259596)) (if ((primitive-ref negative?) f259595) (begin ((primitive-ref write-char) #\- f259596) ((vector-ref f259558 0) (fx* -1 f259595) f259596)) ((primitive-ref map) (closure (f259598) ((primitive-ref write-char) f259596) (let ((f259598 f259598)) ((primitive-ref write-char) (fixnum->char (fx+ (char->fixnum #\0) f259598)) f259596))) ((primitive-ref integer->list) f259595)))))) (vector-set! f259557 0 (closure (f259591 f259592) ((primitive-ref write-char) (primitive-ref for-each) (primitive-ref write-char) (primitive-ref string->list) (primitive-ref write-char)) (let ((f259591 f259591) (f259592 f259592)) (begin ((primitive-ref write-char) #\" f259592) ((primitive-ref for-each) (closure (f259594) ((primitive-ref write-char) f259592) (let ((f259594 f259594)) ((primitive-ref write-char) f259594 f259592))) ((primitive-ref string->list) f259591)) ((primitive-ref write-char) #\" f259592))))) (vector-set! f259556 0 (closure (f259587 f259588) ((primitive-ref for-each) (primitive-ref write-char) (primitive-ref string->list)) (let ((f259587 f259587) (f259588 f259588)) ((primitive-ref for-each) (closure (f259590) ((primitive-ref write-char) f259588) (let ((f259590 f259590)) ((primitive-ref write-char) f259590 f259588))) ((primitive-ref string->list) f259587))))) (vector-set! f259555 0 (closure (f259585 f259586) ((primitive-ref write-char) f259554 (primitive-ref write-char)) (let ((f259585 f259585) (f259586 f259586)) (begin ((primitive-ref write-char) #\( f259586) ((vector-ref f259554 0) f259585 f259586) ((primitive-ref write-char) #\) f259586))))) (vector-set! f259554 0 (closure (f259583 f259584) ((primitive-ref write) (primitive-ref write-char) f259554 else (primitive-ref write-char) (primitive-ref write-char) (primitive-ref write-char) (primitive-ref write)) (let ((f259583 f259583) (f259584 f259584)) (begin ((primitive-ref write) (car f259583) f259584) (if (null? (cdr f259583)) #t (if (pair? (cdr f259583)) (begin ((primitive-ref write-char) #\space f259584) ((vector-ref f259554 0) (cdr f259583) f259584)) (begin ((primitive-ref write-char) #\space f259584) ((primitive-ref write-char) #\. f259584) ((primitive-ref write-char) #\space f259584) ((primitive-ref write) (cdr f259583) f259584))))))))) (closure (f259607 f259608 f259609) (f259561 f259560 (primitive-ref write-char) f259559 f259558 f259556 f259557 f259555 else (primitive-ref error) (primitive-ref write)) (let ((f259607 f259607) (f259608 f259608) (f259609 f259609)) (if (boolean? f259607) ((vector-ref f259561 0) f259607 f259608) (if (null? f259607) ((vector-ref f259560 0) f259608) (if (char? f259607) (if f259609 ((primitive-ref write-char) f259607 f259608) ((vector-ref f259559 0) f259607 f259608)) (if (fixnum? f259607) ((vector-ref f259558 0) f259607 f259608) (if (string? f259607) (if f259609 ((vector-ref f259556 0) f259607 f259608) ((vector-ref f259557 0) f259607 f259608)) (if (pair? f259607) ((vector-ref f259555 0) f259607 f259608) ((primitive-ref error) ((primitive-ref string->symbol) "write") "unrecognized expression"))))))))))
#   env=((f259554 . -28) (f259555 . -24) (f259556 . -20) (f259557 . -16) (f259558 . -12) (f259559 . -8) (f259560 . -4) (f259561 . 0))
# emit-expr (begin (vector-set! f259561 0 (closure (f259602 f259603) ((primitive-ref write-char) (primitive-ref write-char) (primitive-ref write-char)) (let ((f259602 f259602) (f259603 f259603)) (begin ((primitive-ref write-char) #\# f259603) (if f259602 ((primitive-ref write-char) #\t f259603) ((primitive-ref write-char) #\f f259603)))))) (vector-set! f259560 0 (closure (f259601) ((primitive-ref write-char) (primitive-ref write-char)) (let ((f259601 f259601)) (begin ((primitive-ref write-char) #\( f259601) ((primitive-ref write-char) #\) f259601))))) (vector-set! f259559 0 (closure (f259599 f259600) ((primitive-ref write-char) (primitive-ref write-char) (primitive-ref write-char)) (let ((f259599 f259599) (f259600 f259600)) (begin ((primitive-ref write-char) #\# f259600) ((primitive-ref write-char) #\\ f259600) ((primitive-ref write-char) f259599 f259600))))) (vector-set! f259558 0 (closure (f259595 f259596) ((primitive-ref negative?) (primitive-ref write-char) f259558 (primitive-ref map) (primitive-ref write-char) (primitive-ref integer->list)) (let ((f259595 f259595) (f259596 f259596)) (if ((primitive-ref negative?) f259595) (begin ((primitive-ref write-char) #\- f259596) ((vector-ref f259558 0) (fx* -1 f259595) f259596)) ((primitive-ref map) (closure (f259598) ((primitive-ref write-char) f259596) (let ((f259598 f259598)) ((primitive-ref write-char) (fixnum->char (fx+ (char->fixnum #\0) f259598)) f259596))) ((primitive-ref integer->list) f259595)))))) (vector-set! f259557 0 (closure (f259591 f259592) ((primitive-ref write-char) (primitive-ref for-each) (primitive-ref write-char) (primitive-ref string->list) (primitive-ref write-char)) (let ((f259591 f259591) (f259592 f259592)) (begin ((primitive-ref write-char) #\" f259592) ((primitive-ref for-each) (closure (f259594) ((primitive-ref write-char) f259592) (let ((f259594 f259594)) ((primitive-ref write-char) f259594 f259592))) ((primitive-ref string->list) f259591)) ((primitive-ref write-char) #\" f259592))))) (vector-set! f259556 0 (closure (f259587 f259588) ((primitive-ref for-each) (primitive-ref write-char) (primitive-ref string->list)) (let ((f259587 f259587) (f259588 f259588)) ((primitive-ref for-each) (closure (f259590) ((primitive-ref write-char) f259588) (let ((f259590 f259590)) ((primitive-ref write-char) f259590 f259588))) ((primitive-ref string->list) f259587))))) (vector-set! f259555 0 (closure (f259585 f259586) ((primitive-ref write-char) f259554 (primitive-ref write-char)) (let ((f259585 f259585) (f259586 f259586)) (begin ((primitive-ref write-char) #\( f259586) ((vector-ref f259554 0) f259585 f259586) ((primitive-ref write-char) #\) f259586))))) (vector-set! f259554 0 (closure (f259583 f259584) ((primitive-ref write) (primitive-ref write-char) f259554 else (primitive-ref write-char) (primitive-ref write-char) (primitive-ref write-char) (primitive-ref write)) (let ((f259583 f259583) (f259584 f259584)) (begin ((primitive-ref write) (car f259583) f259584) (if (null? (cdr f259583)) #t (if (pair? (cdr f259583)) (begin ((primitive-ref write-char) #\space f259584) ((vector-ref f259554 0) (cdr f259583) f259584)) (begin ((primitive-ref write-char) #\space f259584) ((primitive-ref write-char) #\. f259584) ((primitive-ref write-char) #\space f259584) ((primitive-ref write) (cdr f259583) f259584)))))))))
# emit-begin
#   expr=(begin (vector-set! f259561 0 (closure (f259602 f259603) ((primitive-ref write-char) (primitive-ref write-char) (primitive-ref write-char)) (let ((f259602 f259602) (f259603 f259603)) (begin ((primitive-ref write-char) #\# f259603) (if f259602 ((primitive-ref write-char) #\t f259603) ((primitive-ref write-char) #\f f259603)))))) (vector-set! f259560 0 (closure (f259601) ((primitive-ref write-char) (primitive-ref write-char)) (let ((f259601 f259601)) (begin ((primitive-ref write-char) #\( f259601) ((primitive-ref write-char) #\) f259601))))) (vector-set! f259559 0 (closure (f259599 f259600) ((primitive-ref write-char) (primitive-ref write-char) (primitive-ref write-char)) (let ((f259599 f259599) (f259600 f259600)) (begin ((primitive-ref write-char) #\# f259600) ((primitive-ref write-char) #\\ f259600) ((primitive-ref write-char) f259599 f259600))))) (vector-set! f259558 0 (closure (f259595 f259596) ((primitive-ref negative?) (primitive-ref write-char) f259558 (primitive-ref map) (primitive-ref write-char) (primitive-ref integer->list)) (let ((f259595 f259595) (f259596 f259596)) (if ((primitive-ref negative?) f259595) (begin ((primitive-ref write-char) #\- f259596) ((vector-ref f259558 0) (fx* -1 f259595) f259596)) ((primitive-ref map) (closure (f259598) ((primitive-ref write-char) f259596) (let ((f259598 f259598)) ((primitive-ref write-char) (fixnum->char (fx+ (char->fixnum #\0) f259598)) f259596))) ((primitive-ref integer->list) f259595)))))) (vector-set! f259557 0 (closure (f259591 f259592) ((primitive-ref write-char) (primitive-ref for-each) (primitive-ref write-char) (primitive-ref string->list) (primitive-ref write-char)) (let ((f259591 f259591) (f259592 f259592)) (begin ((primitive-ref write-char) #\" f259592) ((primitive-ref for-each) (closure (f259594) ((primitive-ref write-char) f259592) (let ((f259594 f259594)) ((primitive-ref write-char) f259594 f259592))) ((primitive-ref string->list) f259591)) ((primitive-ref write-char) #\" f259592))))) (vector-set! f259556 0 (closure (f259587 f259588) ((primitive-ref for-each) (primitive-ref write-char) (primitive-ref string->list)) (let ((f259587 f259587) (f259588 f259588)) ((primitive-ref for-each) (closure (f259590) ((primitive-ref write-char) f259588) (let ((f259590 f259590)) ((primitive-ref write-char) f259590 f259588))) ((primitive-ref string->list) f259587))))) (vector-set! f259555 0 (closure (f259585 f259586) ((primitive-ref write-char) f259554 (primitive-ref write-char)) (let ((f259585 f259585) (f259586 f259586)) (begin ((primitive-ref write-char) #\( f259586) ((vector-ref f259554 0) f259585 f259586) ((primitive-ref write-char) #\) f259586))))) (vector-set! f259554 0 (closure (f259583 f259584) ((primitive-ref write) (primitive-ref write-char) f259554 else (primitive-ref write-char) (primitive-ref write-char) (primitive-ref write-char) (primitive-ref write)) (let ((f259583 f259583) (f259584 f259584)) (begin ((primitive-ref write) (car f259583) f259584) (if (null? (cdr f259583)) #t (if (pair? (cdr f259583)) (begin ((primitive-ref write-char) #\space f259584) ((vector-ref f259554 0) (cdr f259583) f259584)) (begin ((primitive-ref write-char) #\space f259584) ((primitive-ref write-char) #\. f259584) ((primitive-ref write-char) #\space f259584) ((primitive-ref write) (cdr f259583) f259584)))))))))
#   env=((f259554 . -28) (f259555 . -24) (f259556 . -20) (f259557 . -16) (f259558 . -12) (f259559 . -8) (f259560 . -4) (f259561 . 0))
# emit-expr (vector-set! f259561 0 (closure (f259602 f259603) ((primitive-ref write-char) (primitive-ref write-char) (primitive-ref write-char)) (let ((f259602 f259602) (f259603 f259603)) (begin ((primitive-ref write-char) #\# f259603) (if f259602 ((primitive-ref write-char) #\t f259603) ((primitive-ref write-char) #\f f259603))))))
# emit-expr f259561
# emit-variable-ref
# env=((f259554 . -28) (f259555 . -24) (f259556 . -20) (f259557 . -16) (f259558 . -12) (f259559 . -8) (f259560 . -4) (f259561 . 0))
# var=f259561
    movl 0(%esp), %eax  # stack load f259561
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1577253
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1577253:
    movl %eax, -32(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1577254"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1577254:
# check bounds on vector index
    movl -32(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1577256
    cmp  $0,%eax
    jge _L_1577255
_L_1577256:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1577255:
    movl %eax, -36(%esp)
# emit-expr (closure (f259602 f259603) ((primitive-ref write-char) (primitive-ref write-char) (primitive-ref write-char)) (let ((f259602 f259602) (f259603 f259603)) (begin ((primitive-ref write-char) #\# f259603) (if f259602 ((primitive-ref write-char) #\t f259603) ((primitive-ref write-char) #\f f259603)))))
# emit-closure
# si = -40
# env = ((f259554 . -28) (f259555 . -24) (f259556 . -20) (f259557 . -16) (f259558 . -12) (f259559 . -8) (f259560 . -4) (f259561 . 0))
# expr = (closure (f259602 f259603) ((primitive-ref write-char) (primitive-ref write-char) (primitive-ref write-char)) (let ((f259602 f259602) (f259603 f259603)) (begin ((primitive-ref write-char) #\# f259603) (if f259602 ((primitive-ref write-char) #\t f259603) ((primitive-ref write-char) #\f f259603)))))
    movl $_L_1577257, 0(%ebp)  # closure label
# WARNING: free var (primitive-ref write-char) not defined in the environmnet
# WARNING: free var (primitive-ref write-char) not defined in the environmnet
# WARNING: free var (primitive-ref write-char) not defined in the environmnet
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $16, %ebp     # bump ebp
    jmp _L_1577258            # jump around closure body
_L_1577257:
# check argument count
    cmp $8,%eax
    je _L_1577259
# invoke error handler eh_argcount
    .extern mrc_eh$uargcount
    movl mrc_eh$uargcount, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_1577259:
# emit-tail-expr
# si=-16
# env=((f259603 . -12) (f259602 . -8) ((primitive-ref write-char) . 12) ((primitive-ref write-char) . 8) ((primitive-ref write-char) . 4) (f259554 . -28) (f259555 . -24) (f259556 . -20) (f259557 . -16) (f259558 . -12) (f259559 . -8) (f259560 . -4) (f259561 . 0))
# expr=(let ((f259602 f259602) (f259603 f259603)) (begin ((primitive-ref write-char) #\# f259603) (if f259602 ((primitive-ref write-char) #\t f259603) ((primitive-ref write-char) #\f f259603))))
# emit-tail-let
#  si   = -16
#  env  = ((f259603 . -12) (f259602 . -8) ((primitive-ref write-char) . 12) ((primitive-ref write-char) . 8) ((primitive-ref write-char) . 4) (f259554 . -28) (f259555 . -24) (f259556 . -20) (f259557 . -16) (f259558 . -12) (f259559 . -8) (f259560 . -4) (f259561 . 0))
#  bindings = ((f259602 f259602) (f259603 f259603))
#  body = (begin ((primitive-ref write-char) #\# f259603) (if f259602 ((primitive-ref write-char) #\t f259603) ((primitive-ref write-char) #\f f259603)))
# emit-expr f259602
# emit-variable-ref
# env=((f259603 . -12) (f259602 . -8) ((primitive-ref write-char) . 12) ((primitive-ref write-char) . 8) ((primitive-ref write-char) . 4) (f259554 . -28) (f259555 . -24) (f259556 . -20) (f259557 . -16) (f259558 . -12) (f259559 . -8) (f259560 . -4) (f259561 . 0))
# var=f259602
    movl -8(%esp), %eax  # stack load f259602
# end emit-variable-ref
    movl %eax, -16(%esp)  # stack save
# emit-expr f259603
# emit-variable-ref
# env=((f259603 . -12) (f259602 . -8) ((primitive-ref write-char) . 12) ((primitive-ref write-char) . 8) ((primitive-ref write-char) . 4) (f259554 . -28) (f259555 . -24) (f259556 . -20) (f259557 . -16) (f259558 . -12) (f259559 . -8) (f259560 . -4) (f259561 . 0))
# var=f259603
    movl -12(%esp), %eax  # stack load f259603
# end emit-variable-ref
    movl %eax, -20(%esp)  # stack save
# emit-tail-expr
# si=-24
# env=((f259603 . -20) (f259602 . -16) (f259603 . -12) (f259602 . -8) ((primitive-ref write-char) . 12) ((primitive-ref write-char) . 8) ((primitive-ref write-char) . 4) (f259554 . -28) (f259555 . -24) (f259556 . -20) (f259557 . -16) (f259558 . -12) (f259559 . -8) (f259560 . -4) (f259561 . 0))
# expr=(begin ((primitive-ref write-char) #\# f259603) (if f259602 ((primitive-ref write-char) #\t f259603) ((primitive-ref write-char) #\f f259603)))
# tail-begin (begin ((primitive-ref write-char) #\# f259603) (if f259602 ((primitive-ref write-char) #\t f259603) ((primitive-ref write-char) #\f f259603)))
#   env=((f259603 . -20) (f259602 . -16) (f259603 . -12) (f259602 . -8) ((primitive-ref write-char) . 12) ((primitive-ref write-char) . 8) ((primitive-ref write-char) . 4) (f259554 . -28) (f259555 . -24) (f259556 . -20) (f259557 . -16) (f259558 . -12) (f259559 . -8) (f259560 . -4) (f259561 . 0))
# emit-expr ((primitive-ref write-char) #\# f259603)
# funcall
#    si   =-24
#    env  = ((f259603 . -20) (f259602 . -16) (f259603 . -12) (f259602 . -8) ((primitive-ref write-char) . 12) ((primitive-ref write-char) . 8) ((primitive-ref write-char) . 4) (f259554 . -28) (f259555 . -24) (f259556 . -20) (f259557 . -16) (f259558 . -12) (f259559 . -8) (f259560 . -4) (f259561 . 0))
#    expr = (funcall (primitive-ref write-char) #\# f259603)
# emit-expr (primitive-ref write-char)
    .extern mrc_write$mchar
    movl mrc_write$mchar,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1577260"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1577260":
   movl %eax,  -32(%esp)  # stash funcall-oper in closure slot
# emit-expr #\#
    movl $8975, %eax     # immed #\#
    mov %eax, -36(%esp)  # arg #
# emit-expr f259603
# emit-variable-ref
# env=((f259603 . -20) (f259602 . -16) (f259603 . -12) (f259602 . -8) ((primitive-ref write-char) . 12) ((primitive-ref write-char) . 8) ((primitive-ref write-char) . 4) (f259554 . -28) (f259555 . -24) (f259556 . -20) (f259557 . -16) (f259558 . -12) (f259559 . -8) (f259560 . -4) (f259561 . 0))
# var=f259603
    movl -20(%esp), %eax  # stack load f259603
# end emit-variable-ref
    mov %eax, -40(%esp)  # arg f259603
    movl -32(%esp), %edi   # load new closure to %edi
    add $-24, %esp   # adjust base
    movl $8,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $24, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
# emit-tail-expr
# si=-24
# env=((f259603 . -20) (f259602 . -16) (f259603 . -12) (f259602 . -8) ((primitive-ref write-char) . 12) ((primitive-ref write-char) . 8) ((primitive-ref write-char) . 4) (f259554 . -28) (f259555 . -24) (f259556 . -20) (f259557 . -16) (f259558 . -12) (f259559 . -8) (f259560 . -4) (f259561 . 0))
# expr=(begin (if f259602 ((primitive-ref write-char) #\t f259603) ((primitive-ref write-char) #\f f259603)))
# tail-begin (begin (if f259602 ((primitive-ref write-char) #\t f259603) ((primitive-ref write-char) #\f f259603)))
#   env=((f259603 . -20) (f259602 . -16) (f259603 . -12) (f259602 . -8) ((primitive-ref write-char) . 12) ((primitive-ref write-char) . 8) ((primitive-ref write-char) . 4) (f259554 . -28) (f259555 . -24) (f259556 . -20) (f259557 . -16) (f259558 . -12) (f259559 . -8) (f259560 . -4) (f259561 . 0))
# emit-tail-expr
# si=-24
# env=((f259603 . -20) (f259602 . -16) (f259603 . -12) (f259602 . -8) ((primitive-ref write-char) . 12) ((primitive-ref write-char) . 8) ((primitive-ref write-char) . 4) (f259554 . -28) (f259555 . -24) (f259556 . -20) (f259557 . -16) (f259558 . -12) (f259559 . -8) (f259560 . -4) (f259561 . 0))
# expr=(if f259602 ((primitive-ref write-char) #\t f259603) ((primitive-ref write-char) #\f f259603))
# emit-expr f259602
# emit-variable-ref
# env=((f259603 . -20) (f259602 . -16) (f259603 . -12) (f259602 . -8) ((primitive-ref write-char) . 12) ((primitive-ref write-char) . 8) ((primitive-ref write-char) . 4) (f259554 . -28) (f259555 . -24) (f259556 . -20) (f259557 . -16) (f259558 . -12) (f259559 . -8) (f259560 . -4) (f259561 . 0))
# var=f259602
    movl -16(%esp), %eax  # stack load f259602
# end emit-variable-ref
    cmp $47, %al
    je _L_1577261
# emit-tail-expr
# si=-24
# env=((f259603 . -20) (f259602 . -16) (f259603 . -12) (f259602 . -8) ((primitive-ref write-char) . 12) ((primitive-ref write-char) . 8) ((primitive-ref write-char) . 4) (f259554 . -28) (f259555 . -24) (f259556 . -20) (f259557 . -16) (f259558 . -12) (f259559 . -8) (f259560 . -4) (f259561 . 0))
# expr=((primitive-ref write-char) #\t f259603)
# emit-tail-funcall
#    si   =-24
#    env  = ((f259603 . -20) (f259602 . -16) (f259603 . -12) (f259602 . -8) ((primitive-ref write-char) . 12) ((primitive-ref write-char) . 8) ((primitive-ref write-char) . 4) (f259554 . -28) (f259555 . -24) (f259556 . -20) (f259557 . -16) (f259558 . -12) (f259559 . -8) (f259560 . -4) (f259561 . 0))
#    expr = (funcall (primitive-ref write-char) #\t f259603)
# emit-expr (primitive-ref write-char)
    .extern mrc_write$mchar
    movl mrc_write$mchar,%eax
   movl %eax,  -24(%esp)  # stash funcall-oper in next closure slot
# emit-expr #\t
    movl $29711, %eax     # immed #\t
    mov %eax, -28(%esp)    # arg t
# emit-expr f259603
# emit-variable-ref
# env=((f259603 . -20) (f259602 . -16) (f259603 . -12) (f259602 . -8) ((primitive-ref write-char) . 12) ((primitive-ref write-char) . 8) ((primitive-ref write-char) . 4) (f259554 . -28) (f259555 . -24) (f259556 . -20) (f259557 . -16) (f259558 . -12) (f259559 . -8) (f259560 . -4) (f259561 . 0))
# var=f259603
    movl -20(%esp), %eax  # stack load f259603
# end emit-variable-ref
    mov %eax, -32(%esp)    # arg f259603
    movl -24(%esp), %edi   # load new closure to %edi
# emit-shift-args:  size=3   si=-24  delta=20
    mov -24(%esp), %ebx  # shift frame cell
    mov %ebx, -4(%esp)  # down to base
# emit-shift-args:  size=2   si=-28  delta=20
    mov -28(%esp), %ebx  # shift frame cell
    mov %ebx, -8(%esp)  # down to base
# emit-shift-args:  size=1   si=-32  delta=20
    mov -32(%esp), %ebx  # shift frame cell
    mov %ebx, -12(%esp)  # down to base
# emit-shift-args:  size=0   si=-36  delta=20
    movl $8,%eax   # save arg count
    jmp *-2(%edi)  # tail-funcall
    jmp _L_1577262
_L_1577261:
# emit-tail-expr
# si=-24
# env=((f259603 . -20) (f259602 . -16) (f259603 . -12) (f259602 . -8) ((primitive-ref write-char) . 12) ((primitive-ref write-char) . 8) ((primitive-ref write-char) . 4) (f259554 . -28) (f259555 . -24) (f259556 . -20) (f259557 . -16) (f259558 . -12) (f259559 . -8) (f259560 . -4) (f259561 . 0))
# expr=((primitive-ref write-char) #\f f259603)
# emit-tail-funcall
#    si   =-24
#    env  = ((f259603 . -20) (f259602 . -16) (f259603 . -12) (f259602 . -8) ((primitive-ref write-char) . 12) ((primitive-ref write-char) . 8) ((primitive-ref write-char) . 4) (f259554 . -28) (f259555 . -24) (f259556 . -20) (f259557 . -16) (f259558 . -12) (f259559 . -8) (f259560 . -4) (f259561 . 0))
#    expr = (funcall (primitive-ref write-char) #\f f259603)
# emit-expr (primitive-ref write-char)
    .extern mrc_write$mchar
    movl mrc_write$mchar,%eax
   movl %eax,  -24(%esp)  # stash funcall-oper in next closure slot
# emit-expr #\f
    movl $26127, %eax     # immed #\f
    mov %eax, -28(%esp)    # arg f
# emit-expr f259603
# emit-variable-ref
# env=((f259603 . -20) (f259602 . -16) (f259603 . -12) (f259602 . -8) ((primitive-ref write-char) . 12) ((primitive-ref write-char) . 8) ((primitive-ref write-char) . 4) (f259554 . -28) (f259555 . -24) (f259556 . -20) (f259557 . -16) (f259558 . -12) (f259559 . -8) (f259560 . -4) (f259561 . 0))
# var=f259603
    movl -20(%esp), %eax  # stack load f259603
# end emit-variable-ref
    mov %eax, -32(%esp)    # arg f259603
    movl -24(%esp), %edi   # load new closure to %edi
# emit-shift-args:  size=3   si=-24  delta=20
    mov -24(%esp), %ebx  # shift frame cell
    mov %ebx, -4(%esp)  # down to base
# emit-shift-args:  size=2   si=-28  delta=20
    mov -28(%esp), %ebx  # shift frame cell
    mov %ebx, -8(%esp)  # down to base
# emit-shift-args:  size=1   si=-32  delta=20
    mov -32(%esp), %ebx  # shift frame cell
    mov %ebx, -12(%esp)  # down to base
# emit-shift-args:  size=0   si=-36  delta=20
    movl $8,%eax   # save arg count
    jmp *-2(%edi)  # tail-funcall
_L_1577262:
     ret   # return thru stack
    .align 4,0x90
_L_1577258:
    movl -32(%esp), %ebx
    movl -36(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin (vector-set! f259560 0 (closure (f259601) ((primitive-ref write-char) (primitive-ref write-char)) (let ((f259601 f259601)) (begin ((primitive-ref write-char) #\( f259601) ((primitive-ref write-char) #\) f259601))))) (vector-set! f259559 0 (closure (f259599 f259600) ((primitive-ref write-char) (primitive-ref write-char) (primitive-ref write-char)) (let ((f259599 f259599) (f259600 f259600)) (begin ((primitive-ref write-char) #\# f259600) ((primitive-ref write-char) #\\ f259600) ((primitive-ref write-char) f259599 f259600))))) (vector-set! f259558 0 (closure (f259595 f259596) ((primitive-ref negative?) (primitive-ref write-char) f259558 (primitive-ref map) (primitive-ref write-char) (primitive-ref integer->list)) (let ((f259595 f259595) (f259596 f259596)) (if ((primitive-ref negative?) f259595) (begin ((primitive-ref write-char) #\- f259596) ((vector-ref f259558 0) (fx* -1 f259595) f259596)) ((primitive-ref map) (closure (f259598) ((primitive-ref write-char) f259596) (let ((f259598 f259598)) ((primitive-ref write-char) (fixnum->char (fx+ (char->fixnum #\0) f259598)) f259596))) ((primitive-ref integer->list) f259595)))))) (vector-set! f259557 0 (closure (f259591 f259592) ((primitive-ref write-char) (primitive-ref for-each) (primitive-ref write-char) (primitive-ref string->list) (primitive-ref write-char)) (let ((f259591 f259591) (f259592 f259592)) (begin ((primitive-ref write-char) #\" f259592) ((primitive-ref for-each) (closure (f259594) ((primitive-ref write-char) f259592) (let ((f259594 f259594)) ((primitive-ref write-char) f259594 f259592))) ((primitive-ref string->list) f259591)) ((primitive-ref write-char) #\" f259592))))) (vector-set! f259556 0 (closure (f259587 f259588) ((primitive-ref for-each) (primitive-ref write-char) (primitive-ref string->list)) (let ((f259587 f259587) (f259588 f259588)) ((primitive-ref for-each) (closure (f259590) ((primitive-ref write-char) f259588) (let ((f259590 f259590)) ((primitive-ref write-char) f259590 f259588))) ((primitive-ref string->list) f259587))))) (vector-set! f259555 0 (closure (f259585 f259586) ((primitive-ref write-char) f259554 (primitive-ref write-char)) (let ((f259585 f259585) (f259586 f259586)) (begin ((primitive-ref write-char) #\( f259586) ((vector-ref f259554 0) f259585 f259586) ((primitive-ref write-char) #\) f259586))))) (vector-set! f259554 0 (closure (f259583 f259584) ((primitive-ref write) (primitive-ref write-char) f259554 else (primitive-ref write-char) (primitive-ref write-char) (primitive-ref write-char) (primitive-ref write)) (let ((f259583 f259583) (f259584 f259584)) (begin ((primitive-ref write) (car f259583) f259584) (if (null? (cdr f259583)) #t (if (pair? (cdr f259583)) (begin ((primitive-ref write-char) #\space f259584) ((vector-ref f259554 0) (cdr f259583) f259584)) (begin ((primitive-ref write-char) #\space f259584) ((primitive-ref write-char) #\. f259584) ((primitive-ref write-char) #\space f259584) ((primitive-ref write) (cdr f259583) f259584)))))))))
# emit-begin
#   expr=(begin (vector-set! f259560 0 (closure (f259601) ((primitive-ref write-char) (primitive-ref write-char)) (let ((f259601 f259601)) (begin ((primitive-ref write-char) #\( f259601) ((primitive-ref write-char) #\) f259601))))) (vector-set! f259559 0 (closure (f259599 f259600) ((primitive-ref write-char) (primitive-ref write-char) (primitive-ref write-char)) (let ((f259599 f259599) (f259600 f259600)) (begin ((primitive-ref write-char) #\# f259600) ((primitive-ref write-char) #\\ f259600) ((primitive-ref write-char) f259599 f259600))))) (vector-set! f259558 0 (closure (f259595 f259596) ((primitive-ref negative?) (primitive-ref write-char) f259558 (primitive-ref map) (primitive-ref write-char) (primitive-ref integer->list)) (let ((f259595 f259595) (f259596 f259596)) (if ((primitive-ref negative?) f259595) (begin ((primitive-ref write-char) #\- f259596) ((vector-ref f259558 0) (fx* -1 f259595) f259596)) ((primitive-ref map) (closure (f259598) ((primitive-ref write-char) f259596) (let ((f259598 f259598)) ((primitive-ref write-char) (fixnum->char (fx+ (char->fixnum #\0) f259598)) f259596))) ((primitive-ref integer->list) f259595)))))) (vector-set! f259557 0 (closure (f259591 f259592) ((primitive-ref write-char) (primitive-ref for-each) (primitive-ref write-char) (primitive-ref string->list) (primitive-ref write-char)) (let ((f259591 f259591) (f259592 f259592)) (begin ((primitive-ref write-char) #\" f259592) ((primitive-ref for-each) (closure (f259594) ((primitive-ref write-char) f259592) (let ((f259594 f259594)) ((primitive-ref write-char) f259594 f259592))) ((primitive-ref string->list) f259591)) ((primitive-ref write-char) #\" f259592))))) (vector-set! f259556 0 (closure (f259587 f259588) ((primitive-ref for-each) (primitive-ref write-char) (primitive-ref string->list)) (let ((f259587 f259587) (f259588 f259588)) ((primitive-ref for-each) (closure (f259590) ((primitive-ref write-char) f259588) (let ((f259590 f259590)) ((primitive-ref write-char) f259590 f259588))) ((primitive-ref string->list) f259587))))) (vector-set! f259555 0 (closure (f259585 f259586) ((primitive-ref write-char) f259554 (primitive-ref write-char)) (let ((f259585 f259585) (f259586 f259586)) (begin ((primitive-ref write-char) #\( f259586) ((vector-ref f259554 0) f259585 f259586) ((primitive-ref write-char) #\) f259586))))) (vector-set! f259554 0 (closure (f259583 f259584) ((primitive-ref write) (primitive-ref write-char) f259554 else (primitive-ref write-char) (primitive-ref write-char) (primitive-ref write-char) (primitive-ref write)) (let ((f259583 f259583) (f259584 f259584)) (begin ((primitive-ref write) (car f259583) f259584) (if (null? (cdr f259583)) #t (if (pair? (cdr f259583)) (begin ((primitive-ref write-char) #\space f259584) ((vector-ref f259554 0) (cdr f259583) f259584)) (begin ((primitive-ref write-char) #\space f259584) ((primitive-ref write-char) #\. f259584) ((primitive-ref write-char) #\space f259584) ((primitive-ref write) (cdr f259583) f259584)))))))))
#   env=((f259554 . -28) (f259555 . -24) (f259556 . -20) (f259557 . -16) (f259558 . -12) (f259559 . -8) (f259560 . -4) (f259561 . 0))
# emit-expr (vector-set! f259560 0 (closure (f259601) ((primitive-ref write-char) (primitive-ref write-char)) (let ((f259601 f259601)) (begin ((primitive-ref write-char) #\( f259601) ((primitive-ref write-char) #\) f259601)))))
# emit-expr f259560
# emit-variable-ref
# env=((f259554 . -28) (f259555 . -24) (f259556 . -20) (f259557 . -16) (f259558 . -12) (f259559 . -8) (f259560 . -4) (f259561 . 0))
# var=f259560
    movl -4(%esp), %eax  # stack load f259560
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1577263
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1577263:
    movl %eax, -32(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1577264"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1577264:
# check bounds on vector index
    movl -32(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1577266
    cmp  $0,%eax
    jge _L_1577265
_L_1577266:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1577265:
    movl %eax, -36(%esp)
# emit-expr (closure (f259601) ((primitive-ref write-char) (primitive-ref write-char)) (let ((f259601 f259601)) (begin ((primitive-ref write-char) #\( f259601) ((primitive-ref write-char) #\) f259601))))
# emit-closure
# si = -40
# env = ((f259554 . -28) (f259555 . -24) (f259556 . -20) (f259557 . -16) (f259558 . -12) (f259559 . -8) (f259560 . -4) (f259561 . 0))
# expr = (closure (f259601) ((primitive-ref write-char) (primitive-ref write-char)) (let ((f259601 f259601)) (begin ((primitive-ref write-char) #\( f259601) ((primitive-ref write-char) #\) f259601))))
    movl $_L_1577267, 0(%ebp)  # closure label
# WARNING: free var (primitive-ref write-char) not defined in the environmnet
# WARNING: free var (primitive-ref write-char) not defined in the environmnet
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $16, %ebp     # bump ebp
    jmp _L_1577268            # jump around closure body
_L_1577267:
# check argument count
    cmp $4,%eax
    je _L_1577269
# invoke error handler eh_argcount
    .extern mrc_eh$uargcount
    movl mrc_eh$uargcount, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_1577269:
# emit-tail-expr
# si=-12
# env=((f259601 . -8) ((primitive-ref write-char) . 8) ((primitive-ref write-char) . 4) (f259554 . -28) (f259555 . -24) (f259556 . -20) (f259557 . -16) (f259558 . -12) (f259559 . -8) (f259560 . -4) (f259561 . 0))
# expr=(let ((f259601 f259601)) (begin ((primitive-ref write-char) #\( f259601) ((primitive-ref write-char) #\) f259601)))
# emit-tail-let
#  si   = -12
#  env  = ((f259601 . -8) ((primitive-ref write-char) . 8) ((primitive-ref write-char) . 4) (f259554 . -28) (f259555 . -24) (f259556 . -20) (f259557 . -16) (f259558 . -12) (f259559 . -8) (f259560 . -4) (f259561 . 0))
#  bindings = ((f259601 f259601))
#  body = (begin ((primitive-ref write-char) #\( f259601) ((primitive-ref write-char) #\) f259601))
# emit-expr f259601
# emit-variable-ref
# env=((f259601 . -8) ((primitive-ref write-char) . 8) ((primitive-ref write-char) . 4) (f259554 . -28) (f259555 . -24) (f259556 . -20) (f259557 . -16) (f259558 . -12) (f259559 . -8) (f259560 . -4) (f259561 . 0))
# var=f259601
    movl -8(%esp), %eax  # stack load f259601
# end emit-variable-ref
    movl %eax, -12(%esp)  # stack save
# emit-tail-expr
# si=-16
# env=((f259601 . -12) (f259601 . -8) ((primitive-ref write-char) . 8) ((primitive-ref write-char) . 4) (f259554 . -28) (f259555 . -24) (f259556 . -20) (f259557 . -16) (f259558 . -12) (f259559 . -8) (f259560 . -4) (f259561 . 0))
# expr=(begin ((primitive-ref write-char) #\( f259601) ((primitive-ref write-char) #\) f259601))
# tail-begin (begin ((primitive-ref write-char) #\( f259601) ((primitive-ref write-char) #\) f259601))
#   env=((f259601 . -12) (f259601 . -8) ((primitive-ref write-char) . 8) ((primitive-ref write-char) . 4) (f259554 . -28) (f259555 . -24) (f259556 . -20) (f259557 . -16) (f259558 . -12) (f259559 . -8) (f259560 . -4) (f259561 . 0))
# emit-expr ((primitive-ref write-char) #\( f259601)
# funcall
#    si   =-16
#    env  = ((f259601 . -12) (f259601 . -8) ((primitive-ref write-char) . 8) ((primitive-ref write-char) . 4) (f259554 . -28) (f259555 . -24) (f259556 . -20) (f259557 . -16) (f259558 . -12) (f259559 . -8) (f259560 . -4) (f259561 . 0))
#    expr = (funcall (primitive-ref write-char) #\( f259601)
# emit-expr (primitive-ref write-char)
    .extern mrc_write$mchar
    movl mrc_write$mchar,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1577270"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1577270":
   movl %eax,  -24(%esp)  # stash funcall-oper in closure slot
# emit-expr #\(
    movl $10255, %eax     # immed #\(
    mov %eax, -28(%esp)  # arg (
# emit-expr f259601
# emit-variable-ref
# env=((f259601 . -12) (f259601 . -8) ((primitive-ref write-char) . 8) ((primitive-ref write-char) . 4) (f259554 . -28) (f259555 . -24) (f259556 . -20) (f259557 . -16) (f259558 . -12) (f259559 . -8) (f259560 . -4) (f259561 . 0))
# var=f259601
    movl -12(%esp), %eax  # stack load f259601
# end emit-variable-ref
    mov %eax, -32(%esp)  # arg f259601
    movl -24(%esp), %edi   # load new closure to %edi
    add $-16, %esp   # adjust base
    movl $8,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $16, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
# emit-tail-expr
# si=-16
# env=((f259601 . -12) (f259601 . -8) ((primitive-ref write-char) . 8) ((primitive-ref write-char) . 4) (f259554 . -28) (f259555 . -24) (f259556 . -20) (f259557 . -16) (f259558 . -12) (f259559 . -8) (f259560 . -4) (f259561 . 0))
# expr=(begin ((primitive-ref write-char) #\) f259601))
# tail-begin (begin ((primitive-ref write-char) #\) f259601))
#   env=((f259601 . -12) (f259601 . -8) ((primitive-ref write-char) . 8) ((primitive-ref write-char) . 4) (f259554 . -28) (f259555 . -24) (f259556 . -20) (f259557 . -16) (f259558 . -12) (f259559 . -8) (f259560 . -4) (f259561 . 0))
# emit-tail-expr
# si=-16
# env=((f259601 . -12) (f259601 . -8) ((primitive-ref write-char) . 8) ((primitive-ref write-char) . 4) (f259554 . -28) (f259555 . -24) (f259556 . -20) (f259557 . -16) (f259558 . -12) (f259559 . -8) (f259560 . -4) (f259561 . 0))
# expr=((primitive-ref write-char) #\) f259601)
# emit-tail-funcall
#    si   =-16
#    env  = ((f259601 . -12) (f259601 . -8) ((primitive-ref write-char) . 8) ((primitive-ref write-char) . 4) (f259554 . -28) (f259555 . -24) (f259556 . -20) (f259557 . -16) (f259558 . -12) (f259559 . -8) (f259560 . -4) (f259561 . 0))
#    expr = (funcall (primitive-ref write-char) #\) f259601)
# emit-expr (primitive-ref write-char)
    .extern mrc_write$mchar
    movl mrc_write$mchar,%eax
   movl %eax,  -16(%esp)  # stash funcall-oper in next closure slot
# emit-expr #\)
    movl $10511, %eax     # immed #\)
    mov %eax, -20(%esp)    # arg )
# emit-expr f259601
# emit-variable-ref
# env=((f259601 . -12) (f259601 . -8) ((primitive-ref write-char) . 8) ((primitive-ref write-char) . 4) (f259554 . -28) (f259555 . -24) (f259556 . -20) (f259557 . -16) (f259558 . -12) (f259559 . -8) (f259560 . -4) (f259561 . 0))
# var=f259601
    movl -12(%esp), %eax  # stack load f259601
# end emit-variable-ref
    mov %eax, -24(%esp)    # arg f259601
    movl -16(%esp), %edi   # load new closure to %edi
# emit-shift-args:  size=3   si=-16  delta=12
    mov -16(%esp), %ebx  # shift frame cell
    mov %ebx, -4(%esp)  # down to base
# emit-shift-args:  size=2   si=-20  delta=12
    mov -20(%esp), %ebx  # shift frame cell
    mov %ebx, -8(%esp)  # down to base
# emit-shift-args:  size=1   si=-24  delta=12
    mov -24(%esp), %ebx  # shift frame cell
    mov %ebx, -12(%esp)  # down to base
# emit-shift-args:  size=0   si=-28  delta=12
    movl $8,%eax   # save arg count
    jmp *-2(%edi)  # tail-funcall
     ret   # return thru stack
    .align 4,0x90
_L_1577268:
    movl -32(%esp), %ebx
    movl -36(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin (vector-set! f259559 0 (closure (f259599 f259600) ((primitive-ref write-char) (primitive-ref write-char) (primitive-ref write-char)) (let ((f259599 f259599) (f259600 f259600)) (begin ((primitive-ref write-char) #\# f259600) ((primitive-ref write-char) #\\ f259600) ((primitive-ref write-char) f259599 f259600))))) (vector-set! f259558 0 (closure (f259595 f259596) ((primitive-ref negative?) (primitive-ref write-char) f259558 (primitive-ref map) (primitive-ref write-char) (primitive-ref integer->list)) (let ((f259595 f259595) (f259596 f259596)) (if ((primitive-ref negative?) f259595) (begin ((primitive-ref write-char) #\- f259596) ((vector-ref f259558 0) (fx* -1 f259595) f259596)) ((primitive-ref map) (closure (f259598) ((primitive-ref write-char) f259596) (let ((f259598 f259598)) ((primitive-ref write-char) (fixnum->char (fx+ (char->fixnum #\0) f259598)) f259596))) ((primitive-ref integer->list) f259595)))))) (vector-set! f259557 0 (closure (f259591 f259592) ((primitive-ref write-char) (primitive-ref for-each) (primitive-ref write-char) (primitive-ref string->list) (primitive-ref write-char)) (let ((f259591 f259591) (f259592 f259592)) (begin ((primitive-ref write-char) #\" f259592) ((primitive-ref for-each) (closure (f259594) ((primitive-ref write-char) f259592) (let ((f259594 f259594)) ((primitive-ref write-char) f259594 f259592))) ((primitive-ref string->list) f259591)) ((primitive-ref write-char) #\" f259592))))) (vector-set! f259556 0 (closure (f259587 f259588) ((primitive-ref for-each) (primitive-ref write-char) (primitive-ref string->list)) (let ((f259587 f259587) (f259588 f259588)) ((primitive-ref for-each) (closure (f259590) ((primitive-ref write-char) f259588) (let ((f259590 f259590)) ((primitive-ref write-char) f259590 f259588))) ((primitive-ref string->list) f259587))))) (vector-set! f259555 0 (closure (f259585 f259586) ((primitive-ref write-char) f259554 (primitive-ref write-char)) (let ((f259585 f259585) (f259586 f259586)) (begin ((primitive-ref write-char) #\( f259586) ((vector-ref f259554 0) f259585 f259586) ((primitive-ref write-char) #\) f259586))))) (vector-set! f259554 0 (closure (f259583 f259584) ((primitive-ref write) (primitive-ref write-char) f259554 else (primitive-ref write-char) (primitive-ref write-char) (primitive-ref write-char) (primitive-ref write)) (let ((f259583 f259583) (f259584 f259584)) (begin ((primitive-ref write) (car f259583) f259584) (if (null? (cdr f259583)) #t (if (pair? (cdr f259583)) (begin ((primitive-ref write-char) #\space f259584) ((vector-ref f259554 0) (cdr f259583) f259584)) (begin ((primitive-ref write-char) #\space f259584) ((primitive-ref write-char) #\. f259584) ((primitive-ref write-char) #\space f259584) ((primitive-ref write) (cdr f259583) f259584)))))))))
# emit-begin
#   expr=(begin (vector-set! f259559 0 (closure (f259599 f259600) ((primitive-ref write-char) (primitive-ref write-char) (primitive-ref write-char)) (let ((f259599 f259599) (f259600 f259600)) (begin ((primitive-ref write-char) #\# f259600) ((primitive-ref write-char) #\\ f259600) ((primitive-ref write-char) f259599 f259600))))) (vector-set! f259558 0 (closure (f259595 f259596) ((primitive-ref negative?) (primitive-ref write-char) f259558 (primitive-ref map) (primitive-ref write-char) (primitive-ref integer->list)) (let ((f259595 f259595) (f259596 f259596)) (if ((primitive-ref negative?) f259595) (begin ((primitive-ref write-char) #\- f259596) ((vector-ref f259558 0) (fx* -1 f259595) f259596)) ((primitive-ref map) (closure (f259598) ((primitive-ref write-char) f259596) (let ((f259598 f259598)) ((primitive-ref write-char) (fixnum->char (fx+ (char->fixnum #\0) f259598)) f259596))) ((primitive-ref integer->list) f259595)))))) (vector-set! f259557 0 (closure (f259591 f259592) ((primitive-ref write-char) (primitive-ref for-each) (primitive-ref write-char) (primitive-ref string->list) (primitive-ref write-char)) (let ((f259591 f259591) (f259592 f259592)) (begin ((primitive-ref write-char) #\" f259592) ((primitive-ref for-each) (closure (f259594) ((primitive-ref write-char) f259592) (let ((f259594 f259594)) ((primitive-ref write-char) f259594 f259592))) ((primitive-ref string->list) f259591)) ((primitive-ref write-char) #\" f259592))))) (vector-set! f259556 0 (closure (f259587 f259588) ((primitive-ref for-each) (primitive-ref write-char) (primitive-ref string->list)) (let ((f259587 f259587) (f259588 f259588)) ((primitive-ref for-each) (closure (f259590) ((primitive-ref write-char) f259588) (let ((f259590 f259590)) ((primitive-ref write-char) f259590 f259588))) ((primitive-ref string->list) f259587))))) (vector-set! f259555 0 (closure (f259585 f259586) ((primitive-ref write-char) f259554 (primitive-ref write-char)) (let ((f259585 f259585) (f259586 f259586)) (begin ((primitive-ref write-char) #\( f259586) ((vector-ref f259554 0) f259585 f259586) ((primitive-ref write-char) #\) f259586))))) (vector-set! f259554 0 (closure (f259583 f259584) ((primitive-ref write) (primitive-ref write-char) f259554 else (primitive-ref write-char) (primitive-ref write-char) (primitive-ref write-char) (primitive-ref write)) (let ((f259583 f259583) (f259584 f259584)) (begin ((primitive-ref write) (car f259583) f259584) (if (null? (cdr f259583)) #t (if (pair? (cdr f259583)) (begin ((primitive-ref write-char) #\space f259584) ((vector-ref f259554 0) (cdr f259583) f259584)) (begin ((primitive-ref write-char) #\space f259584) ((primitive-ref write-char) #\. f259584) ((primitive-ref write-char) #\space f259584) ((primitive-ref write) (cdr f259583) f259584)))))))))
#   env=((f259554 . -28) (f259555 . -24) (f259556 . -20) (f259557 . -16) (f259558 . -12) (f259559 . -8) (f259560 . -4) (f259561 . 0))
# emit-expr (vector-set! f259559 0 (closure (f259599 f259600) ((primitive-ref write-char) (primitive-ref write-char) (primitive-ref write-char)) (let ((f259599 f259599) (f259600 f259600)) (begin ((primitive-ref write-char) #\# f259600) ((primitive-ref write-char) #\\ f259600) ((primitive-ref write-char) f259599 f259600)))))
# emit-expr f259559
# emit-variable-ref
# env=((f259554 . -28) (f259555 . -24) (f259556 . -20) (f259557 . -16) (f259558 . -12) (f259559 . -8) (f259560 . -4) (f259561 . 0))
# var=f259559
    movl -8(%esp), %eax  # stack load f259559
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1577271
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1577271:
    movl %eax, -32(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1577272"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1577272:
# check bounds on vector index
    movl -32(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1577274
    cmp  $0,%eax
    jge _L_1577273
_L_1577274:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1577273:
    movl %eax, -36(%esp)
# emit-expr (closure (f259599 f259600) ((primitive-ref write-char) (primitive-ref write-char) (primitive-ref write-char)) (let ((f259599 f259599) (f259600 f259600)) (begin ((primitive-ref write-char) #\# f259600) ((primitive-ref write-char) #\\ f259600) ((primitive-ref write-char) f259599 f259600))))
# emit-closure
# si = -40
# env = ((f259554 . -28) (f259555 . -24) (f259556 . -20) (f259557 . -16) (f259558 . -12) (f259559 . -8) (f259560 . -4) (f259561 . 0))
# expr = (closure (f259599 f259600) ((primitive-ref write-char) (primitive-ref write-char) (primitive-ref write-char)) (let ((f259599 f259599) (f259600 f259600)) (begin ((primitive-ref write-char) #\# f259600) ((primitive-ref write-char) #\\ f259600) ((primitive-ref write-char) f259599 f259600))))
    movl $_L_1577275, 0(%ebp)  # closure label
# WARNING: free var (primitive-ref write-char) not defined in the environmnet
# WARNING: free var (primitive-ref write-char) not defined in the environmnet
# WARNING: free var (primitive-ref write-char) not defined in the environmnet
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $16, %ebp     # bump ebp
    jmp _L_1577276            # jump around closure body
_L_1577275:
# check argument count
    cmp $8,%eax
    je _L_1577277
# invoke error handler eh_argcount
    .extern mrc_eh$uargcount
    movl mrc_eh$uargcount, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_1577277:
# emit-tail-expr
# si=-16
# env=((f259600 . -12) (f259599 . -8) ((primitive-ref write-char) . 12) ((primitive-ref write-char) . 8) ((primitive-ref write-char) . 4) (f259554 . -28) (f259555 . -24) (f259556 . -20) (f259557 . -16) (f259558 . -12) (f259559 . -8) (f259560 . -4) (f259561 . 0))
# expr=(let ((f259599 f259599) (f259600 f259600)) (begin ((primitive-ref write-char) #\# f259600) ((primitive-ref write-char) #\\ f259600) ((primitive-ref write-char) f259599 f259600)))
# emit-tail-let
#  si   = -16
#  env  = ((f259600 . -12) (f259599 . -8) ((primitive-ref write-char) . 12) ((primitive-ref write-char) . 8) ((primitive-ref write-char) . 4) (f259554 . -28) (f259555 . -24) (f259556 . -20) (f259557 . -16) (f259558 . -12) (f259559 . -8) (f259560 . -4) (f259561 . 0))
#  bindings = ((f259599 f259599) (f259600 f259600))
#  body = (begin ((primitive-ref write-char) #\# f259600) ((primitive-ref write-char) #\\ f259600) ((primitive-ref write-char) f259599 f259600))
# emit-expr f259599
# emit-variable-ref
# env=((f259600 . -12) (f259599 . -8) ((primitive-ref write-char) . 12) ((primitive-ref write-char) . 8) ((primitive-ref write-char) . 4) (f259554 . -28) (f259555 . -24) (f259556 . -20) (f259557 . -16) (f259558 . -12) (f259559 . -8) (f259560 . -4) (f259561 . 0))
# var=f259599
    movl -8(%esp), %eax  # stack load f259599
# end emit-variable-ref
    movl %eax, -16(%esp)  # stack save
# emit-expr f259600
# emit-variable-ref
# env=((f259600 . -12) (f259599 . -8) ((primitive-ref write-char) . 12) ((primitive-ref write-char) . 8) ((primitive-ref write-char) . 4) (f259554 . -28) (f259555 . -24) (f259556 . -20) (f259557 . -16) (f259558 . -12) (f259559 . -8) (f259560 . -4) (f259561 . 0))
# var=f259600
    movl -12(%esp), %eax  # stack load f259600
# end emit-variable-ref
    movl %eax, -20(%esp)  # stack save
# emit-tail-expr
# si=-24
# env=((f259600 . -20) (f259599 . -16) (f259600 . -12) (f259599 . -8) ((primitive-ref write-char) . 12) ((primitive-ref write-char) . 8) ((primitive-ref write-char) . 4) (f259554 . -28) (f259555 . -24) (f259556 . -20) (f259557 . -16) (f259558 . -12) (f259559 . -8) (f259560 . -4) (f259561 . 0))
# expr=(begin ((primitive-ref write-char) #\# f259600) ((primitive-ref write-char) #\\ f259600) ((primitive-ref write-char) f259599 f259600))
# tail-begin (begin ((primitive-ref write-char) #\# f259600) ((primitive-ref write-char) #\\ f259600) ((primitive-ref write-char) f259599 f259600))
#   env=((f259600 . -20) (f259599 . -16) (f259600 . -12) (f259599 . -8) ((primitive-ref write-char) . 12) ((primitive-ref write-char) . 8) ((primitive-ref write-char) . 4) (f259554 . -28) (f259555 . -24) (f259556 . -20) (f259557 . -16) (f259558 . -12) (f259559 . -8) (f259560 . -4) (f259561 . 0))
# emit-expr ((primitive-ref write-char) #\# f259600)
# funcall
#    si   =-24
#    env  = ((f259600 . -20) (f259599 . -16) (f259600 . -12) (f259599 . -8) ((primitive-ref write-char) . 12) ((primitive-ref write-char) . 8) ((primitive-ref write-char) . 4) (f259554 . -28) (f259555 . -24) (f259556 . -20) (f259557 . -16) (f259558 . -12) (f259559 . -8) (f259560 . -4) (f259561 . 0))
#    expr = (funcall (primitive-ref write-char) #\# f259600)
# emit-expr (primitive-ref write-char)
    .extern mrc_write$mchar
    movl mrc_write$mchar,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1577278"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1577278":
   movl %eax,  -32(%esp)  # stash funcall-oper in closure slot
# emit-expr #\#
    movl $8975, %eax     # immed #\#
    mov %eax, -36(%esp)  # arg #
# emit-expr f259600
# emit-variable-ref
# env=((f259600 . -20) (f259599 . -16) (f259600 . -12) (f259599 . -8) ((primitive-ref write-char) . 12) ((primitive-ref write-char) . 8) ((primitive-ref write-char) . 4) (f259554 . -28) (f259555 . -24) (f259556 . -20) (f259557 . -16) (f259558 . -12) (f259559 . -8) (f259560 . -4) (f259561 . 0))
# var=f259600
    movl -20(%esp), %eax  # stack load f259600
# end emit-variable-ref
    mov %eax, -40(%esp)  # arg f259600
    movl -32(%esp), %edi   # load new closure to %edi
    add $-24, %esp   # adjust base
    movl $8,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $24, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
# emit-tail-expr
# si=-24
# env=((f259600 . -20) (f259599 . -16) (f259600 . -12) (f259599 . -8) ((primitive-ref write-char) . 12) ((primitive-ref write-char) . 8) ((primitive-ref write-char) . 4) (f259554 . -28) (f259555 . -24) (f259556 . -20) (f259557 . -16) (f259558 . -12) (f259559 . -8) (f259560 . -4) (f259561 . 0))
# expr=(begin ((primitive-ref write-char) #\\ f259600) ((primitive-ref write-char) f259599 f259600))
# tail-begin (begin ((primitive-ref write-char) #\\ f259600) ((primitive-ref write-char) f259599 f259600))
#   env=((f259600 . -20) (f259599 . -16) (f259600 . -12) (f259599 . -8) ((primitive-ref write-char) . 12) ((primitive-ref write-char) . 8) ((primitive-ref write-char) . 4) (f259554 . -28) (f259555 . -24) (f259556 . -20) (f259557 . -16) (f259558 . -12) (f259559 . -8) (f259560 . -4) (f259561 . 0))
# emit-expr ((primitive-ref write-char) #\\ f259600)
# funcall
#    si   =-24
#    env  = ((f259600 . -20) (f259599 . -16) (f259600 . -12) (f259599 . -8) ((primitive-ref write-char) . 12) ((primitive-ref write-char) . 8) ((primitive-ref write-char) . 4) (f259554 . -28) (f259555 . -24) (f259556 . -20) (f259557 . -16) (f259558 . -12) (f259559 . -8) (f259560 . -4) (f259561 . 0))
#    expr = (funcall (primitive-ref write-char) #\\ f259600)
# emit-expr (primitive-ref write-char)
    .extern mrc_write$mchar
    movl mrc_write$mchar,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1577279"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1577279":
   movl %eax,  -32(%esp)  # stash funcall-oper in closure slot
# emit-expr #\\
    movl $23567, %eax     # immed #\\
    mov %eax, -36(%esp)  # arg \
# emit-expr f259600
# emit-variable-ref
# env=((f259600 . -20) (f259599 . -16) (f259600 . -12) (f259599 . -8) ((primitive-ref write-char) . 12) ((primitive-ref write-char) . 8) ((primitive-ref write-char) . 4) (f259554 . -28) (f259555 . -24) (f259556 . -20) (f259557 . -16) (f259558 . -12) (f259559 . -8) (f259560 . -4) (f259561 . 0))
# var=f259600
    movl -20(%esp), %eax  # stack load f259600
# end emit-variable-ref
    mov %eax, -40(%esp)  # arg f259600
    movl -32(%esp), %edi   # load new closure to %edi
    add $-24, %esp   # adjust base
    movl $8,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $24, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
# emit-tail-expr
# si=-24
# env=((f259600 . -20) (f259599 . -16) (f259600 . -12) (f259599 . -8) ((primitive-ref write-char) . 12) ((primitive-ref write-char) . 8) ((primitive-ref write-char) . 4) (f259554 . -28) (f259555 . -24) (f259556 . -20) (f259557 . -16) (f259558 . -12) (f259559 . -8) (f259560 . -4) (f259561 . 0))
# expr=(begin ((primitive-ref write-char) f259599 f259600))
# tail-begin (begin ((primitive-ref write-char) f259599 f259600))
#   env=((f259600 . -20) (f259599 . -16) (f259600 . -12) (f259599 . -8) ((primitive-ref write-char) . 12) ((primitive-ref write-char) . 8) ((primitive-ref write-char) . 4) (f259554 . -28) (f259555 . -24) (f259556 . -20) (f259557 . -16) (f259558 . -12) (f259559 . -8) (f259560 . -4) (f259561 . 0))
# emit-tail-expr
# si=-24
# env=((f259600 . -20) (f259599 . -16) (f259600 . -12) (f259599 . -8) ((primitive-ref write-char) . 12) ((primitive-ref write-char) . 8) ((primitive-ref write-char) . 4) (f259554 . -28) (f259555 . -24) (f259556 . -20) (f259557 . -16) (f259558 . -12) (f259559 . -8) (f259560 . -4) (f259561 . 0))
# expr=((primitive-ref write-char) f259599 f259600)
# emit-tail-funcall
#    si   =-24
#    env  = ((f259600 . -20) (f259599 . -16) (f259600 . -12) (f259599 . -8) ((primitive-ref write-char) . 12) ((primitive-ref write-char) . 8) ((primitive-ref write-char) . 4) (f259554 . -28) (f259555 . -24) (f259556 . -20) (f259557 . -16) (f259558 . -12) (f259559 . -8) (f259560 . -4) (f259561 . 0))
#    expr = (funcall (primitive-ref write-char) f259599 f259600)
# emit-expr (primitive-ref write-char)
    .extern mrc_write$mchar
    movl mrc_write$mchar,%eax
   movl %eax,  -24(%esp)  # stash funcall-oper in next closure slot
# emit-expr f259599
# emit-variable-ref
# env=((f259600 . -20) (f259599 . -16) (f259600 . -12) (f259599 . -8) ((primitive-ref write-char) . 12) ((primitive-ref write-char) . 8) ((primitive-ref write-char) . 4) (f259554 . -28) (f259555 . -24) (f259556 . -20) (f259557 . -16) (f259558 . -12) (f259559 . -8) (f259560 . -4) (f259561 . 0))
# var=f259599
    movl -16(%esp), %eax  # stack load f259599
# end emit-variable-ref
    mov %eax, -28(%esp)    # arg f259599
# emit-expr f259600
# emit-variable-ref
# env=((f259600 . -20) (f259599 . -16) (f259600 . -12) (f259599 . -8) ((primitive-ref write-char) . 12) ((primitive-ref write-char) . 8) ((primitive-ref write-char) . 4) (f259554 . -28) (f259555 . -24) (f259556 . -20) (f259557 . -16) (f259558 . -12) (f259559 . -8) (f259560 . -4) (f259561 . 0))
# var=f259600
    movl -20(%esp), %eax  # stack load f259600
# end emit-variable-ref
    mov %eax, -32(%esp)    # arg f259600
    movl -24(%esp), %edi   # load new closure to %edi
# emit-shift-args:  size=3   si=-24  delta=20
    mov -24(%esp), %ebx  # shift frame cell
    mov %ebx, -4(%esp)  # down to base
# emit-shift-args:  size=2   si=-28  delta=20
    mov -28(%esp), %ebx  # shift frame cell
    mov %ebx, -8(%esp)  # down to base
# emit-shift-args:  size=1   si=-32  delta=20
    mov -32(%esp), %ebx  # shift frame cell
    mov %ebx, -12(%esp)  # down to base
# emit-shift-args:  size=0   si=-36  delta=20
    movl $8,%eax   # save arg count
    jmp *-2(%edi)  # tail-funcall
     ret   # return thru stack
    .align 4,0x90
_L_1577276:
    movl -32(%esp), %ebx
    movl -36(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin (vector-set! f259558 0 (closure (f259595 f259596) ((primitive-ref negative?) (primitive-ref write-char) f259558 (primitive-ref map) (primitive-ref write-char) (primitive-ref integer->list)) (let ((f259595 f259595) (f259596 f259596)) (if ((primitive-ref negative?) f259595) (begin ((primitive-ref write-char) #\- f259596) ((vector-ref f259558 0) (fx* -1 f259595) f259596)) ((primitive-ref map) (closure (f259598) ((primitive-ref write-char) f259596) (let ((f259598 f259598)) ((primitive-ref write-char) (fixnum->char (fx+ (char->fixnum #\0) f259598)) f259596))) ((primitive-ref integer->list) f259595)))))) (vector-set! f259557 0 (closure (f259591 f259592) ((primitive-ref write-char) (primitive-ref for-each) (primitive-ref write-char) (primitive-ref string->list) (primitive-ref write-char)) (let ((f259591 f259591) (f259592 f259592)) (begin ((primitive-ref write-char) #\" f259592) ((primitive-ref for-each) (closure (f259594) ((primitive-ref write-char) f259592) (let ((f259594 f259594)) ((primitive-ref write-char) f259594 f259592))) ((primitive-ref string->list) f259591)) ((primitive-ref write-char) #\" f259592))))) (vector-set! f259556 0 (closure (f259587 f259588) ((primitive-ref for-each) (primitive-ref write-char) (primitive-ref string->list)) (let ((f259587 f259587) (f259588 f259588)) ((primitive-ref for-each) (closure (f259590) ((primitive-ref write-char) f259588) (let ((f259590 f259590)) ((primitive-ref write-char) f259590 f259588))) ((primitive-ref string->list) f259587))))) (vector-set! f259555 0 (closure (f259585 f259586) ((primitive-ref write-char) f259554 (primitive-ref write-char)) (let ((f259585 f259585) (f259586 f259586)) (begin ((primitive-ref write-char) #\( f259586) ((vector-ref f259554 0) f259585 f259586) ((primitive-ref write-char) #\) f259586))))) (vector-set! f259554 0 (closure (f259583 f259584) ((primitive-ref write) (primitive-ref write-char) f259554 else (primitive-ref write-char) (primitive-ref write-char) (primitive-ref write-char) (primitive-ref write)) (let ((f259583 f259583) (f259584 f259584)) (begin ((primitive-ref write) (car f259583) f259584) (if (null? (cdr f259583)) #t (if (pair? (cdr f259583)) (begin ((primitive-ref write-char) #\space f259584) ((vector-ref f259554 0) (cdr f259583) f259584)) (begin ((primitive-ref write-char) #\space f259584) ((primitive-ref write-char) #\. f259584) ((primitive-ref write-char) #\space f259584) ((primitive-ref write) (cdr f259583) f259584)))))))))
# emit-begin
#   expr=(begin (vector-set! f259558 0 (closure (f259595 f259596) ((primitive-ref negative?) (primitive-ref write-char) f259558 (primitive-ref map) (primitive-ref write-char) (primitive-ref integer->list)) (let ((f259595 f259595) (f259596 f259596)) (if ((primitive-ref negative?) f259595) (begin ((primitive-ref write-char) #\- f259596) ((vector-ref f259558 0) (fx* -1 f259595) f259596)) ((primitive-ref map) (closure (f259598) ((primitive-ref write-char) f259596) (let ((f259598 f259598)) ((primitive-ref write-char) (fixnum->char (fx+ (char->fixnum #\0) f259598)) f259596))) ((primitive-ref integer->list) f259595)))))) (vector-set! f259557 0 (closure (f259591 f259592) ((primitive-ref write-char) (primitive-ref for-each) (primitive-ref write-char) (primitive-ref string->list) (primitive-ref write-char)) (let ((f259591 f259591) (f259592 f259592)) (begin ((primitive-ref write-char) #\" f259592) ((primitive-ref for-each) (closure (f259594) ((primitive-ref write-char) f259592) (let ((f259594 f259594)) ((primitive-ref write-char) f259594 f259592))) ((primitive-ref string->list) f259591)) ((primitive-ref write-char) #\" f259592))))) (vector-set! f259556 0 (closure (f259587 f259588) ((primitive-ref for-each) (primitive-ref write-char) (primitive-ref string->list)) (let ((f259587 f259587) (f259588 f259588)) ((primitive-ref for-each) (closure (f259590) ((primitive-ref write-char) f259588) (let ((f259590 f259590)) ((primitive-ref write-char) f259590 f259588))) ((primitive-ref string->list) f259587))))) (vector-set! f259555 0 (closure (f259585 f259586) ((primitive-ref write-char) f259554 (primitive-ref write-char)) (let ((f259585 f259585) (f259586 f259586)) (begin ((primitive-ref write-char) #\( f259586) ((vector-ref f259554 0) f259585 f259586) ((primitive-ref write-char) #\) f259586))))) (vector-set! f259554 0 (closure (f259583 f259584) ((primitive-ref write) (primitive-ref write-char) f259554 else (primitive-ref write-char) (primitive-ref write-char) (primitive-ref write-char) (primitive-ref write)) (let ((f259583 f259583) (f259584 f259584)) (begin ((primitive-ref write) (car f259583) f259584) (if (null? (cdr f259583)) #t (if (pair? (cdr f259583)) (begin ((primitive-ref write-char) #\space f259584) ((vector-ref f259554 0) (cdr f259583) f259584)) (begin ((primitive-ref write-char) #\space f259584) ((primitive-ref write-char) #\. f259584) ((primitive-ref write-char) #\space f259584) ((primitive-ref write) (cdr f259583) f259584)))))))))
#   env=((f259554 . -28) (f259555 . -24) (f259556 . -20) (f259557 . -16) (f259558 . -12) (f259559 . -8) (f259560 . -4) (f259561 . 0))
# emit-expr (vector-set! f259558 0 (closure (f259595 f259596) ((primitive-ref negative?) (primitive-ref write-char) f259558 (primitive-ref map) (primitive-ref write-char) (primitive-ref integer->list)) (let ((f259595 f259595) (f259596 f259596)) (if ((primitive-ref negative?) f259595) (begin ((primitive-ref write-char) #\- f259596) ((vector-ref f259558 0) (fx* -1 f259595) f259596)) ((primitive-ref map) (closure (f259598) ((primitive-ref write-char) f259596) (let ((f259598 f259598)) ((primitive-ref write-char) (fixnum->char (fx+ (char->fixnum #\0) f259598)) f259596))) ((primitive-ref integer->list) f259595))))))
# emit-expr f259558
# emit-variable-ref
# env=((f259554 . -28) (f259555 . -24) (f259556 . -20) (f259557 . -16) (f259558 . -12) (f259559 . -8) (f259560 . -4) (f259561 . 0))
# var=f259558
    movl -12(%esp), %eax  # stack load f259558
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1577280
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1577280:
    movl %eax, -32(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1577281"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1577281:
# check bounds on vector index
    movl -32(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1577283
    cmp  $0,%eax
    jge _L_1577282
_L_1577283:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1577282:
    movl %eax, -36(%esp)
# emit-expr (closure (f259595 f259596) ((primitive-ref negative?) (primitive-ref write-char) f259558 (primitive-ref map) (primitive-ref write-char) (primitive-ref integer->list)) (let ((f259595 f259595) (f259596 f259596)) (if ((primitive-ref negative?) f259595) (begin ((primitive-ref write-char) #\- f259596) ((vector-ref f259558 0) (fx* -1 f259595) f259596)) ((primitive-ref map) (closure (f259598) ((primitive-ref write-char) f259596) (let ((f259598 f259598)) ((primitive-ref write-char) (fixnum->char (fx+ (char->fixnum #\0) f259598)) f259596))) ((primitive-ref integer->list) f259595)))))
# emit-closure
# si = -40
# env = ((f259554 . -28) (f259555 . -24) (f259556 . -20) (f259557 . -16) (f259558 . -12) (f259559 . -8) (f259560 . -4) (f259561 . 0))
# expr = (closure (f259595 f259596) ((primitive-ref negative?) (primitive-ref write-char) f259558 (primitive-ref map) (primitive-ref write-char) (primitive-ref integer->list)) (let ((f259595 f259595) (f259596 f259596)) (if ((primitive-ref negative?) f259595) (begin ((primitive-ref write-char) #\- f259596) ((vector-ref f259558 0) (fx* -1 f259595) f259596)) ((primitive-ref map) (closure (f259598) ((primitive-ref write-char) f259596) (let ((f259598 f259598)) ((primitive-ref write-char) (fixnum->char (fx+ (char->fixnum #\0) f259598)) f259596))) ((primitive-ref integer->list) f259595)))))
    movl $_L_1577284, 0(%ebp)  # closure label
# WARNING: free var (primitive-ref negative?) not defined in the environmnet
# WARNING: free var (primitive-ref write-char) not defined in the environmnet
# emit-variable-ref
# env=((f259554 . -28) (f259555 . -24) (f259556 . -20) (f259557 . -16) (f259558 . -12) (f259559 . -8) (f259560 . -4) (f259561 . 0))
# var=f259558
    movl -12(%esp), %eax  # stack load f259558
# end emit-variable-ref
   movl  %eax, 12(%ebp)  # f259558
# WARNING: free var (primitive-ref map) not defined in the environmnet
# WARNING: free var (primitive-ref write-char) not defined in the environmnet
# WARNING: free var (primitive-ref integer->list) not defined in the environmnet
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $32, %ebp     # bump ebp
    jmp _L_1577285            # jump around closure body
_L_1577284:
# check argument count
    cmp $8,%eax
    je _L_1577286
# invoke error handler eh_argcount
    .extern mrc_eh$uargcount
    movl mrc_eh$uargcount, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_1577286:
# emit-tail-expr
# si=-16
# env=((f259596 . -12) (f259595 . -8) ((primitive-ref integer->list) . 24) ((primitive-ref write-char) . 20) ((primitive-ref map) . 16) (f259558 . 12) ((primitive-ref write-char) . 8) ((primitive-ref negative?) . 4) (f259554 . -28) (f259555 . -24) (f259556 . -20) (f259557 . -16) (f259558 . -12) (f259559 . -8) (f259560 . -4) (f259561 . 0))
# expr=(let ((f259595 f259595) (f259596 f259596)) (if ((primitive-ref negative?) f259595) (begin ((primitive-ref write-char) #\- f259596) ((vector-ref f259558 0) (fx* -1 f259595) f259596)) ((primitive-ref map) (closure (f259598) ((primitive-ref write-char) f259596) (let ((f259598 f259598)) ((primitive-ref write-char) (fixnum->char (fx+ (char->fixnum #\0) f259598)) f259596))) ((primitive-ref integer->list) f259595))))
# emit-tail-let
#  si   = -16
#  env  = ((f259596 . -12) (f259595 . -8) ((primitive-ref integer->list) . 24) ((primitive-ref write-char) . 20) ((primitive-ref map) . 16) (f259558 . 12) ((primitive-ref write-char) . 8) ((primitive-ref negative?) . 4) (f259554 . -28) (f259555 . -24) (f259556 . -20) (f259557 . -16) (f259558 . -12) (f259559 . -8) (f259560 . -4) (f259561 . 0))
#  bindings = ((f259595 f259595) (f259596 f259596))
#  body = (if ((primitive-ref negative?) f259595) (begin ((primitive-ref write-char) #\- f259596) ((vector-ref f259558 0) (fx* -1 f259595) f259596)) ((primitive-ref map) (closure (f259598) ((primitive-ref write-char) f259596) (let ((f259598 f259598)) ((primitive-ref write-char) (fixnum->char (fx+ (char->fixnum #\0) f259598)) f259596))) ((primitive-ref integer->list) f259595)))
# emit-expr f259595
# emit-variable-ref
# env=((f259596 . -12) (f259595 . -8) ((primitive-ref integer->list) . 24) ((primitive-ref write-char) . 20) ((primitive-ref map) . 16) (f259558 . 12) ((primitive-ref write-char) . 8) ((primitive-ref negative?) . 4) (f259554 . -28) (f259555 . -24) (f259556 . -20) (f259557 . -16) (f259558 . -12) (f259559 . -8) (f259560 . -4) (f259561 . 0))
# var=f259595
    movl -8(%esp), %eax  # stack load f259595
# end emit-variable-ref
    movl %eax, -16(%esp)  # stack save
# emit-expr f259596
# emit-variable-ref
# env=((f259596 . -12) (f259595 . -8) ((primitive-ref integer->list) . 24) ((primitive-ref write-char) . 20) ((primitive-ref map) . 16) (f259558 . 12) ((primitive-ref write-char) . 8) ((primitive-ref negative?) . 4) (f259554 . -28) (f259555 . -24) (f259556 . -20) (f259557 . -16) (f259558 . -12) (f259559 . -8) (f259560 . -4) (f259561 . 0))
# var=f259596
    movl -12(%esp), %eax  # stack load f259596
# end emit-variable-ref
    movl %eax, -20(%esp)  # stack save
# emit-tail-expr
# si=-24
# env=((f259596 . -20) (f259595 . -16) (f259596 . -12) (f259595 . -8) ((primitive-ref integer->list) . 24) ((primitive-ref write-char) . 20) ((primitive-ref map) . 16) (f259558 . 12) ((primitive-ref write-char) . 8) ((primitive-ref negative?) . 4) (f259554 . -28) (f259555 . -24) (f259556 . -20) (f259557 . -16) (f259558 . -12) (f259559 . -8) (f259560 . -4) (f259561 . 0))
# expr=(if ((primitive-ref negative?) f259595) (begin ((primitive-ref write-char) #\- f259596) ((vector-ref f259558 0) (fx* -1 f259595) f259596)) ((primitive-ref map) (closure (f259598) ((primitive-ref write-char) f259596) (let ((f259598 f259598)) ((primitive-ref write-char) (fixnum->char (fx+ (char->fixnum #\0) f259598)) f259596))) ((primitive-ref integer->list) f259595)))
# emit-expr ((primitive-ref negative?) f259595)
# funcall
#    si   =-24
#    env  = ((f259596 . -20) (f259595 . -16) (f259596 . -12) (f259595 . -8) ((primitive-ref integer->list) . 24) ((primitive-ref write-char) . 20) ((primitive-ref map) . 16) (f259558 . 12) ((primitive-ref write-char) . 8) ((primitive-ref negative?) . 4) (f259554 . -28) (f259555 . -24) (f259556 . -20) (f259557 . -16) (f259558 . -12) (f259559 . -8) (f259560 . -4) (f259561 . 0))
#    expr = (funcall (primitive-ref negative?) f259595)
# emit-expr (primitive-ref negative?)
    .extern mrc_negative$q
    movl mrc_negative$q,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1577289"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1577289":
   movl %eax,  -32(%esp)  # stash funcall-oper in closure slot
# emit-expr f259595
# emit-variable-ref
# env=((f259596 . -20) (f259595 . -16) (f259596 . -12) (f259595 . -8) ((primitive-ref integer->list) . 24) ((primitive-ref write-char) . 20) ((primitive-ref map) . 16) (f259558 . 12) ((primitive-ref write-char) . 8) ((primitive-ref negative?) . 4) (f259554 . -28) (f259555 . -24) (f259556 . -20) (f259557 . -16) (f259558 . -12) (f259559 . -8) (f259560 . -4) (f259561 . 0))
# var=f259595
    movl -16(%esp), %eax  # stack load f259595
# end emit-variable-ref
    mov %eax, -36(%esp)  # arg f259595
    movl -32(%esp), %edi   # load new closure to %edi
    add $-24, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $24, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    cmp $47, %al
    je _L_1577287
# emit-tail-expr
# si=-24
# env=((f259596 . -20) (f259595 . -16) (f259596 . -12) (f259595 . -8) ((primitive-ref integer->list) . 24) ((primitive-ref write-char) . 20) ((primitive-ref map) . 16) (f259558 . 12) ((primitive-ref write-char) . 8) ((primitive-ref negative?) . 4) (f259554 . -28) (f259555 . -24) (f259556 . -20) (f259557 . -16) (f259558 . -12) (f259559 . -8) (f259560 . -4) (f259561 . 0))
# expr=(begin ((primitive-ref write-char) #\- f259596) ((vector-ref f259558 0) (fx* -1 f259595) f259596))
# tail-begin (begin ((primitive-ref write-char) #\- f259596) ((vector-ref f259558 0) (fx* -1 f259595) f259596))
#   env=((f259596 . -20) (f259595 . -16) (f259596 . -12) (f259595 . -8) ((primitive-ref integer->list) . 24) ((primitive-ref write-char) . 20) ((primitive-ref map) . 16) (f259558 . 12) ((primitive-ref write-char) . 8) ((primitive-ref negative?) . 4) (f259554 . -28) (f259555 . -24) (f259556 . -20) (f259557 . -16) (f259558 . -12) (f259559 . -8) (f259560 . -4) (f259561 . 0))
# emit-expr ((primitive-ref write-char) #\- f259596)
# funcall
#    si   =-24
#    env  = ((f259596 . -20) (f259595 . -16) (f259596 . -12) (f259595 . -8) ((primitive-ref integer->list) . 24) ((primitive-ref write-char) . 20) ((primitive-ref map) . 16) (f259558 . 12) ((primitive-ref write-char) . 8) ((primitive-ref negative?) . 4) (f259554 . -28) (f259555 . -24) (f259556 . -20) (f259557 . -16) (f259558 . -12) (f259559 . -8) (f259560 . -4) (f259561 . 0))
#    expr = (funcall (primitive-ref write-char) #\- f259596)
# emit-expr (primitive-ref write-char)
    .extern mrc_write$mchar
    movl mrc_write$mchar,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1577290"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1577290":
   movl %eax,  -32(%esp)  # stash funcall-oper in closure slot
# emit-expr #\-
    movl $11535, %eax     # immed #\-
    mov %eax, -36(%esp)  # arg -
# emit-expr f259596
# emit-variable-ref
# env=((f259596 . -20) (f259595 . -16) (f259596 . -12) (f259595 . -8) ((primitive-ref integer->list) . 24) ((primitive-ref write-char) . 20) ((primitive-ref map) . 16) (f259558 . 12) ((primitive-ref write-char) . 8) ((primitive-ref negative?) . 4) (f259554 . -28) (f259555 . -24) (f259556 . -20) (f259557 . -16) (f259558 . -12) (f259559 . -8) (f259560 . -4) (f259561 . 0))
# var=f259596
    movl -20(%esp), %eax  # stack load f259596
# end emit-variable-ref
    mov %eax, -40(%esp)  # arg f259596
    movl -32(%esp), %edi   # load new closure to %edi
    add $-24, %esp   # adjust base
    movl $8,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $24, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
# emit-tail-expr
# si=-24
# env=((f259596 . -20) (f259595 . -16) (f259596 . -12) (f259595 . -8) ((primitive-ref integer->list) . 24) ((primitive-ref write-char) . 20) ((primitive-ref map) . 16) (f259558 . 12) ((primitive-ref write-char) . 8) ((primitive-ref negative?) . 4) (f259554 . -28) (f259555 . -24) (f259556 . -20) (f259557 . -16) (f259558 . -12) (f259559 . -8) (f259560 . -4) (f259561 . 0))
# expr=(begin ((vector-ref f259558 0) (fx* -1 f259595) f259596))
# tail-begin (begin ((vector-ref f259558 0) (fx* -1 f259595) f259596))
#   env=((f259596 . -20) (f259595 . -16) (f259596 . -12) (f259595 . -8) ((primitive-ref integer->list) . 24) ((primitive-ref write-char) . 20) ((primitive-ref map) . 16) (f259558 . 12) ((primitive-ref write-char) . 8) ((primitive-ref negative?) . 4) (f259554 . -28) (f259555 . -24) (f259556 . -20) (f259557 . -16) (f259558 . -12) (f259559 . -8) (f259560 . -4) (f259561 . 0))
# emit-tail-expr
# si=-24
# env=((f259596 . -20) (f259595 . -16) (f259596 . -12) (f259595 . -8) ((primitive-ref integer->list) . 24) ((primitive-ref write-char) . 20) ((primitive-ref map) . 16) (f259558 . 12) ((primitive-ref write-char) . 8) ((primitive-ref negative?) . 4) (f259554 . -28) (f259555 . -24) (f259556 . -20) (f259557 . -16) (f259558 . -12) (f259559 . -8) (f259560 . -4) (f259561 . 0))
# expr=((vector-ref f259558 0) (fx* -1 f259595) f259596)
# emit-tail-funcall
#    si   =-24
#    env  = ((f259596 . -20) (f259595 . -16) (f259596 . -12) (f259595 . -8) ((primitive-ref integer->list) . 24) ((primitive-ref write-char) . 20) ((primitive-ref map) . 16) (f259558 . 12) ((primitive-ref write-char) . 8) ((primitive-ref negative?) . 4) (f259554 . -28) (f259555 . -24) (f259556 . -20) (f259557 . -16) (f259558 . -12) (f259559 . -8) (f259560 . -4) (f259561 . 0))
#    expr = (funcall (vector-ref f259558 0) (fx* -1 f259595) f259596)
# emit-expr (vector-ref f259558 0)
# emit-expr f259558
# emit-variable-ref
# env=((f259596 . -20) (f259595 . -16) (f259596 . -12) (f259595 . -8) ((primitive-ref integer->list) . 24) ((primitive-ref write-char) . 20) ((primitive-ref map) . 16) (f259558 . 12) ((primitive-ref write-char) . 8) ((primitive-ref negative?) . 4) (f259554 . -28) (f259555 . -24) (f259556 . -20) (f259557 . -16) (f259558 . -12) (f259559 . -8) (f259560 . -4) (f259561 . 0))
# var=f259558
    movl 10(%edi), %eax  # frame load f259558
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1577291
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1577291:
    movl %eax, -24(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1577292"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1577292:
# check bounds on vector index
    movl -24(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1577294
    cmp  $0,%eax
    jge _L_1577293
_L_1577294:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1577293:
    movl -24(%esp), %esi
    movl -1(%eax,%esi), %eax
   movl %eax,  -24(%esp)  # stash funcall-oper in next closure slot
# emit-expr (fx* -1 f259595)
# emit-expr f259595
# emit-variable-ref
# env=((f259596 . -20) (f259595 . -16) (f259596 . -12) (f259595 . -8) ((primitive-ref integer->list) . 24) ((primitive-ref write-char) . 20) ((primitive-ref map) . 16) (f259558 . 12) ((primitive-ref write-char) . 8) ((primitive-ref negative?) . 4) (f259554 . -28) (f259555 . -24) (f259556 . -20) (f259557 . -16) (f259558 . -12) (f259559 . -8) (f259560 . -4) (f259561 . 0))
# var=f259595
    movl -16(%esp), %eax  # stack load f259595
# end emit-variable-ref
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1577295"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $88,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1577295:
    sar $2, %eax
    movl %eax, -28(%esp)
# emit-expr -1
    movl $-4, %eax     # immed -1
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1577296"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $88,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1577296:
    imul -28(%esp), %eax
    mov %eax, -28(%esp)    # arg (fx* -1 f259595)
# emit-expr f259596
# emit-variable-ref
# env=((f259596 . -20) (f259595 . -16) (f259596 . -12) (f259595 . -8) ((primitive-ref integer->list) . 24) ((primitive-ref write-char) . 20) ((primitive-ref map) . 16) (f259558 . 12) ((primitive-ref write-char) . 8) ((primitive-ref negative?) . 4) (f259554 . -28) (f259555 . -24) (f259556 . -20) (f259557 . -16) (f259558 . -12) (f259559 . -8) (f259560 . -4) (f259561 . 0))
# var=f259596
    movl -20(%esp), %eax  # stack load f259596
# end emit-variable-ref
    mov %eax, -32(%esp)    # arg f259596
    movl -24(%esp), %edi   # load new closure to %edi
# emit-shift-args:  size=3   si=-24  delta=20
    mov -24(%esp), %ebx  # shift frame cell
    mov %ebx, -4(%esp)  # down to base
# emit-shift-args:  size=2   si=-28  delta=20
    mov -28(%esp), %ebx  # shift frame cell
    mov %ebx, -8(%esp)  # down to base
# emit-shift-args:  size=1   si=-32  delta=20
    mov -32(%esp), %ebx  # shift frame cell
    mov %ebx, -12(%esp)  # down to base
# emit-shift-args:  size=0   si=-36  delta=20
    movl $8,%eax   # save arg count
    jmp *-2(%edi)  # tail-funcall
     ret   # return thru stack
    jmp _L_1577288
_L_1577287:
# emit-tail-expr
# si=-24
# env=((f259596 . -20) (f259595 . -16) (f259596 . -12) (f259595 . -8) ((primitive-ref integer->list) . 24) ((primitive-ref write-char) . 20) ((primitive-ref map) . 16) (f259558 . 12) ((primitive-ref write-char) . 8) ((primitive-ref negative?) . 4) (f259554 . -28) (f259555 . -24) (f259556 . -20) (f259557 . -16) (f259558 . -12) (f259559 . -8) (f259560 . -4) (f259561 . 0))
# expr=((primitive-ref map) (closure (f259598) ((primitive-ref write-char) f259596) (let ((f259598 f259598)) ((primitive-ref write-char) (fixnum->char (fx+ (char->fixnum #\0) f259598)) f259596))) ((primitive-ref integer->list) f259595))
# emit-tail-funcall
#    si   =-24
#    env  = ((f259596 . -20) (f259595 . -16) (f259596 . -12) (f259595 . -8) ((primitive-ref integer->list) . 24) ((primitive-ref write-char) . 20) ((primitive-ref map) . 16) (f259558 . 12) ((primitive-ref write-char) . 8) ((primitive-ref negative?) . 4) (f259554 . -28) (f259555 . -24) (f259556 . -20) (f259557 . -16) (f259558 . -12) (f259559 . -8) (f259560 . -4) (f259561 . 0))
#    expr = (funcall (primitive-ref map) (closure (f259598) ((primitive-ref write-char) f259596) (let ((f259598 f259598)) ((primitive-ref write-char) (fixnum->char (fx+ (char->fixnum #\0) f259598)) f259596))) ((primitive-ref integer->list) f259595))
# emit-expr (primitive-ref map)
    .extern mrc_map
    movl mrc_map,%eax
   movl %eax,  -24(%esp)  # stash funcall-oper in next closure slot
# emit-expr (closure (f259598) ((primitive-ref write-char) f259596) (let ((f259598 f259598)) ((primitive-ref write-char) (fixnum->char (fx+ (char->fixnum #\0) f259598)) f259596)))
# emit-closure
# si = -28
# env = ((f259596 . -20) (f259595 . -16) (f259596 . -12) (f259595 . -8) ((primitive-ref integer->list) . 24) ((primitive-ref write-char) . 20) ((primitive-ref map) . 16) (f259558 . 12) ((primitive-ref write-char) . 8) ((primitive-ref negative?) . 4) (f259554 . -28) (f259555 . -24) (f259556 . -20) (f259557 . -16) (f259558 . -12) (f259559 . -8) (f259560 . -4) (f259561 . 0))
# expr = (closure (f259598) ((primitive-ref write-char) f259596) (let ((f259598 f259598)) ((primitive-ref write-char) (fixnum->char (fx+ (char->fixnum #\0) f259598)) f259596)))
    movl $_L_1577297, 0(%ebp)  # closure label
# emit-variable-ref
# env=((f259596 . -20) (f259595 . -16) (f259596 . -12) (f259595 . -8) ((primitive-ref integer->list) . 24) ((primitive-ref write-char) . 20) ((primitive-ref map) . 16) (f259558 . 12) ((primitive-ref write-char) . 8) ((primitive-ref negative?) . 4) (f259554 . -28) (f259555 . -24) (f259556 . -20) (f259557 . -16) (f259558 . -12) (f259559 . -8) (f259560 . -4) (f259561 . 0))
# var=(primitive-ref write-char)
    movl 18(%edi), %eax  # frame load (primitive-ref write-char)
# end emit-variable-ref
   movl  %eax, 4(%ebp)  # (primitive-ref write-char)
# emit-variable-ref
# env=((f259596 . -20) (f259595 . -16) (f259596 . -12) (f259595 . -8) ((primitive-ref integer->list) . 24) ((primitive-ref write-char) . 20) ((primitive-ref map) . 16) (f259558 . 12) ((primitive-ref write-char) . 8) ((primitive-ref negative?) . 4) (f259554 . -28) (f259555 . -24) (f259556 . -20) (f259557 . -16) (f259558 . -12) (f259559 . -8) (f259560 . -4) (f259561 . 0))
# var=f259596
    movl -20(%esp), %eax  # stack load f259596
# end emit-variable-ref
   movl  %eax, 8(%ebp)  # f259596
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $16, %ebp     # bump ebp
    jmp _L_1577298            # jump around closure body
_L_1577297:
# check argument count
    cmp $4,%eax
    je _L_1577299
# invoke error handler eh_argcount
    .extern mrc_eh$uargcount
    movl mrc_eh$uargcount, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_1577299:
# emit-tail-expr
# si=-12
# env=((f259598 . -8) (f259596 . 8) ((primitive-ref write-char) . 4) (f259596 . -20) (f259595 . -16) (f259596 . -12) (f259595 . -8) ((primitive-ref integer->list) . 24) ((primitive-ref write-char) . 20) ((primitive-ref map) . 16) (f259558 . 12) ((primitive-ref write-char) . 8) ((primitive-ref negative?) . 4) (f259554 . -28) (f259555 . -24) (f259556 . -20) (f259557 . -16) (f259558 . -12) (f259559 . -8) (f259560 . -4) (f259561 . 0))
# expr=(let ((f259598 f259598)) ((primitive-ref write-char) (fixnum->char (fx+ (char->fixnum #\0) f259598)) f259596))
# emit-tail-let
#  si   = -12
#  env  = ((f259598 . -8) (f259596 . 8) ((primitive-ref write-char) . 4) (f259596 . -20) (f259595 . -16) (f259596 . -12) (f259595 . -8) ((primitive-ref integer->list) . 24) ((primitive-ref write-char) . 20) ((primitive-ref map) . 16) (f259558 . 12) ((primitive-ref write-char) . 8) ((primitive-ref negative?) . 4) (f259554 . -28) (f259555 . -24) (f259556 . -20) (f259557 . -16) (f259558 . -12) (f259559 . -8) (f259560 . -4) (f259561 . 0))
#  bindings = ((f259598 f259598))
#  body = ((primitive-ref write-char) (fixnum->char (fx+ (char->fixnum #\0) f259598)) f259596)
# emit-expr f259598
# emit-variable-ref
# env=((f259598 . -8) (f259596 . 8) ((primitive-ref write-char) . 4) (f259596 . -20) (f259595 . -16) (f259596 . -12) (f259595 . -8) ((primitive-ref integer->list) . 24) ((primitive-ref write-char) . 20) ((primitive-ref map) . 16) (f259558 . 12) ((primitive-ref write-char) . 8) ((primitive-ref negative?) . 4) (f259554 . -28) (f259555 . -24) (f259556 . -20) (f259557 . -16) (f259558 . -12) (f259559 . -8) (f259560 . -4) (f259561 . 0))
# var=f259598
    movl -8(%esp), %eax  # stack load f259598
# end emit-variable-ref
    movl %eax, -12(%esp)  # stack save
# emit-tail-expr
# si=-16
# env=((f259598 . -12) (f259598 . -8) (f259596 . 8) ((primitive-ref write-char) . 4) (f259596 . -20) (f259595 . -16) (f259596 . -12) (f259595 . -8) ((primitive-ref integer->list) . 24) ((primitive-ref write-char) . 20) ((primitive-ref map) . 16) (f259558 . 12) ((primitive-ref write-char) . 8) ((primitive-ref negative?) . 4) (f259554 . -28) (f259555 . -24) (f259556 . -20) (f259557 . -16) (f259558 . -12) (f259559 . -8) (f259560 . -4) (f259561 . 0))
# expr=((primitive-ref write-char) (fixnum->char (fx+ (char->fixnum #\0) f259598)) f259596)
# emit-tail-funcall
#    si   =-16
#    env  = ((f259598 . -12) (f259598 . -8) (f259596 . 8) ((primitive-ref write-char) . 4) (f259596 . -20) (f259595 . -16) (f259596 . -12) (f259595 . -8) ((primitive-ref integer->list) . 24) ((primitive-ref write-char) . 20) ((primitive-ref map) . 16) (f259558 . 12) ((primitive-ref write-char) . 8) ((primitive-ref negative?) . 4) (f259554 . -28) (f259555 . -24) (f259556 . -20) (f259557 . -16) (f259558 . -12) (f259559 . -8) (f259560 . -4) (f259561 . 0))
#    expr = (funcall (primitive-ref write-char) (fixnum->char (fx+ (char->fixnum #\0) f259598)) f259596)
# emit-expr (primitive-ref write-char)
    .extern mrc_write$mchar
    movl mrc_write$mchar,%eax
   movl %eax,  -16(%esp)  # stash funcall-oper in next closure slot
# emit-expr (fixnum->char (fx+ (char->fixnum #\0) f259598))
# emit-expr (fx+ (char->fixnum #\0) f259598)
# emit-expr f259598
# emit-variable-ref
# env=((f259598 . -12) (f259598 . -8) (f259596 . 8) ((primitive-ref write-char) . 4) (f259596 . -20) (f259595 . -16) (f259596 . -12) (f259595 . -8) ((primitive-ref integer->list) . 24) ((primitive-ref write-char) . 20) ((primitive-ref map) . 16) (f259558 . 12) ((primitive-ref write-char) . 8) ((primitive-ref negative?) . 4) (f259554 . -28) (f259555 . -24) (f259556 . -20) (f259557 . -16) (f259558 . -12) (f259559 . -8) (f259560 . -4) (f259561 . 0))
# var=f259598
    movl -12(%esp), %eax  # stack load f259598
# end emit-variable-ref
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1577300"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $80,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1577300:
    movl %eax, -20(%esp)  # fx+ push arg1
# emit-expr (char->fixnum #\0)
# emit-expr #\0
    movl $12303, %eax     # immed #\0
# check the argument is a char
    movl %eax,%ebx
    and $255, %bl
    cmp $15, %bl
    je "_L_1577301"
# invoke error handler eh_character
    .extern mrc_eh$ucharacter
    movl mrc_eh$ucharacter, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $4,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1577301:
   shrl $8, %eax
   shll $2, %eax
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1577302"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $80,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1577302:
    addl -20(%esp), %eax  # fx+ arg1 arg2
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1577303"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $0,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1577303:
    shll $6, %eax
    orl $15, %eax
    mov %eax, -20(%esp)    # arg (fixnum->char (fx+ (char->fixnum 0) f259598))
# emit-expr f259596
# emit-variable-ref
# env=((f259598 . -12) (f259598 . -8) (f259596 . 8) ((primitive-ref write-char) . 4) (f259596 . -20) (f259595 . -16) (f259596 . -12) (f259595 . -8) ((primitive-ref integer->list) . 24) ((primitive-ref write-char) . 20) ((primitive-ref map) . 16) (f259558 . 12) ((primitive-ref write-char) . 8) ((primitive-ref negative?) . 4) (f259554 . -28) (f259555 . -24) (f259556 . -20) (f259557 . -16) (f259558 . -12) (f259559 . -8) (f259560 . -4) (f259561 . 0))
# var=f259596
    movl 6(%edi), %eax  # frame load f259596
# end emit-variable-ref
    mov %eax, -24(%esp)    # arg f259596
    movl -16(%esp), %edi   # load new closure to %edi
# emit-shift-args:  size=3   si=-16  delta=12
    mov -16(%esp), %ebx  # shift frame cell
    mov %ebx, -4(%esp)  # down to base
# emit-shift-args:  size=2   si=-20  delta=12
    mov -20(%esp), %ebx  # shift frame cell
    mov %ebx, -8(%esp)  # down to base
# emit-shift-args:  size=1   si=-24  delta=12
    mov -24(%esp), %ebx  # shift frame cell
    mov %ebx, -12(%esp)  # down to base
# emit-shift-args:  size=0   si=-28  delta=12
    movl $8,%eax   # save arg count
    jmp *-2(%edi)  # tail-funcall
    .align 4,0x90
_L_1577298:
    mov %eax, -28(%esp)    # arg (closure (f259598) ((primitive-ref write-char) f259596) (let ((f259598 f259598)) ((primitive-ref write-char) (fixnum->char (fx+ (char->fixnum 0) f259598)) f259596)))
# emit-expr ((primitive-ref integer->list) f259595)
# funcall
#    si   =-32
#    env  = ((f259596 . -20) (f259595 . -16) (f259596 . -12) (f259595 . -8) ((primitive-ref integer->list) . 24) ((primitive-ref write-char) . 20) ((primitive-ref map) . 16) (f259558 . 12) ((primitive-ref write-char) . 8) ((primitive-ref negative?) . 4) (f259554 . -28) (f259555 . -24) (f259556 . -20) (f259557 . -16) (f259558 . -12) (f259559 . -8) (f259560 . -4) (f259561 . 0))
#    expr = (funcall (primitive-ref integer->list) f259595)
# emit-expr (primitive-ref integer->list)
    .extern mrc_integer$m$glist
    movl mrc_integer$m$glist,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1577304"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1577304":
   movl %eax,  -40(%esp)  # stash funcall-oper in closure slot
# emit-expr f259595
# emit-variable-ref
# env=((f259596 . -20) (f259595 . -16) (f259596 . -12) (f259595 . -8) ((primitive-ref integer->list) . 24) ((primitive-ref write-char) . 20) ((primitive-ref map) . 16) (f259558 . 12) ((primitive-ref write-char) . 8) ((primitive-ref negative?) . 4) (f259554 . -28) (f259555 . -24) (f259556 . -20) (f259557 . -16) (f259558 . -12) (f259559 . -8) (f259560 . -4) (f259561 . 0))
# var=f259595
    movl -16(%esp), %eax  # stack load f259595
# end emit-variable-ref
    mov %eax, -44(%esp)  # arg f259595
    movl -40(%esp), %edi   # load new closure to %edi
    add $-32, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $32, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    mov %eax, -32(%esp)    # arg ((primitive-ref integer->list) f259595)
    movl -24(%esp), %edi   # load new closure to %edi
# emit-shift-args:  size=3   si=-24  delta=20
    mov -24(%esp), %ebx  # shift frame cell
    mov %ebx, -4(%esp)  # down to base
# emit-shift-args:  size=2   si=-28  delta=20
    mov -28(%esp), %ebx  # shift frame cell
    mov %ebx, -8(%esp)  # down to base
# emit-shift-args:  size=1   si=-32  delta=20
    mov -32(%esp), %ebx  # shift frame cell
    mov %ebx, -12(%esp)  # down to base
# emit-shift-args:  size=0   si=-36  delta=20
    movl $8,%eax   # save arg count
    jmp *-2(%edi)  # tail-funcall
_L_1577288:
    .align 4,0x90
_L_1577285:
    movl -32(%esp), %ebx
    movl -36(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin (vector-set! f259557 0 (closure (f259591 f259592) ((primitive-ref write-char) (primitive-ref for-each) (primitive-ref write-char) (primitive-ref string->list) (primitive-ref write-char)) (let ((f259591 f259591) (f259592 f259592)) (begin ((primitive-ref write-char) #\" f259592) ((primitive-ref for-each) (closure (f259594) ((primitive-ref write-char) f259592) (let ((f259594 f259594)) ((primitive-ref write-char) f259594 f259592))) ((primitive-ref string->list) f259591)) ((primitive-ref write-char) #\" f259592))))) (vector-set! f259556 0 (closure (f259587 f259588) ((primitive-ref for-each) (primitive-ref write-char) (primitive-ref string->list)) (let ((f259587 f259587) (f259588 f259588)) ((primitive-ref for-each) (closure (f259590) ((primitive-ref write-char) f259588) (let ((f259590 f259590)) ((primitive-ref write-char) f259590 f259588))) ((primitive-ref string->list) f259587))))) (vector-set! f259555 0 (closure (f259585 f259586) ((primitive-ref write-char) f259554 (primitive-ref write-char)) (let ((f259585 f259585) (f259586 f259586)) (begin ((primitive-ref write-char) #\( f259586) ((vector-ref f259554 0) f259585 f259586) ((primitive-ref write-char) #\) f259586))))) (vector-set! f259554 0 (closure (f259583 f259584) ((primitive-ref write) (primitive-ref write-char) f259554 else (primitive-ref write-char) (primitive-ref write-char) (primitive-ref write-char) (primitive-ref write)) (let ((f259583 f259583) (f259584 f259584)) (begin ((primitive-ref write) (car f259583) f259584) (if (null? (cdr f259583)) #t (if (pair? (cdr f259583)) (begin ((primitive-ref write-char) #\space f259584) ((vector-ref f259554 0) (cdr f259583) f259584)) (begin ((primitive-ref write-char) #\space f259584) ((primitive-ref write-char) #\. f259584) ((primitive-ref write-char) #\space f259584) ((primitive-ref write) (cdr f259583) f259584)))))))))
# emit-begin
#   expr=(begin (vector-set! f259557 0 (closure (f259591 f259592) ((primitive-ref write-char) (primitive-ref for-each) (primitive-ref write-char) (primitive-ref string->list) (primitive-ref write-char)) (let ((f259591 f259591) (f259592 f259592)) (begin ((primitive-ref write-char) #\" f259592) ((primitive-ref for-each) (closure (f259594) ((primitive-ref write-char) f259592) (let ((f259594 f259594)) ((primitive-ref write-char) f259594 f259592))) ((primitive-ref string->list) f259591)) ((primitive-ref write-char) #\" f259592))))) (vector-set! f259556 0 (closure (f259587 f259588) ((primitive-ref for-each) (primitive-ref write-char) (primitive-ref string->list)) (let ((f259587 f259587) (f259588 f259588)) ((primitive-ref for-each) (closure (f259590) ((primitive-ref write-char) f259588) (let ((f259590 f259590)) ((primitive-ref write-char) f259590 f259588))) ((primitive-ref string->list) f259587))))) (vector-set! f259555 0 (closure (f259585 f259586) ((primitive-ref write-char) f259554 (primitive-ref write-char)) (let ((f259585 f259585) (f259586 f259586)) (begin ((primitive-ref write-char) #\( f259586) ((vector-ref f259554 0) f259585 f259586) ((primitive-ref write-char) #\) f259586))))) (vector-set! f259554 0 (closure (f259583 f259584) ((primitive-ref write) (primitive-ref write-char) f259554 else (primitive-ref write-char) (primitive-ref write-char) (primitive-ref write-char) (primitive-ref write)) (let ((f259583 f259583) (f259584 f259584)) (begin ((primitive-ref write) (car f259583) f259584) (if (null? (cdr f259583)) #t (if (pair? (cdr f259583)) (begin ((primitive-ref write-char) #\space f259584) ((vector-ref f259554 0) (cdr f259583) f259584)) (begin ((primitive-ref write-char) #\space f259584) ((primitive-ref write-char) #\. f259584) ((primitive-ref write-char) #\space f259584) ((primitive-ref write) (cdr f259583) f259584)))))))))
#   env=((f259554 . -28) (f259555 . -24) (f259556 . -20) (f259557 . -16) (f259558 . -12) (f259559 . -8) (f259560 . -4) (f259561 . 0))
# emit-expr (vector-set! f259557 0 (closure (f259591 f259592) ((primitive-ref write-char) (primitive-ref for-each) (primitive-ref write-char) (primitive-ref string->list) (primitive-ref write-char)) (let ((f259591 f259591) (f259592 f259592)) (begin ((primitive-ref write-char) #\" f259592) ((primitive-ref for-each) (closure (f259594) ((primitive-ref write-char) f259592) (let ((f259594 f259594)) ((primitive-ref write-char) f259594 f259592))) ((primitive-ref string->list) f259591)) ((primitive-ref write-char) #\" f259592)))))
# emit-expr f259557
# emit-variable-ref
# env=((f259554 . -28) (f259555 . -24) (f259556 . -20) (f259557 . -16) (f259558 . -12) (f259559 . -8) (f259560 . -4) (f259561 . 0))
# var=f259557
    movl -16(%esp), %eax  # stack load f259557
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1577305
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1577305:
    movl %eax, -32(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1577306"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1577306:
# check bounds on vector index
    movl -32(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1577308
    cmp  $0,%eax
    jge _L_1577307
_L_1577308:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1577307:
    movl %eax, -36(%esp)
# emit-expr (closure (f259591 f259592) ((primitive-ref write-char) (primitive-ref for-each) (primitive-ref write-char) (primitive-ref string->list) (primitive-ref write-char)) (let ((f259591 f259591) (f259592 f259592)) (begin ((primitive-ref write-char) #\" f259592) ((primitive-ref for-each) (closure (f259594) ((primitive-ref write-char) f259592) (let ((f259594 f259594)) ((primitive-ref write-char) f259594 f259592))) ((primitive-ref string->list) f259591)) ((primitive-ref write-char) #\" f259592))))
# emit-closure
# si = -40
# env = ((f259554 . -28) (f259555 . -24) (f259556 . -20) (f259557 . -16) (f259558 . -12) (f259559 . -8) (f259560 . -4) (f259561 . 0))
# expr = (closure (f259591 f259592) ((primitive-ref write-char) (primitive-ref for-each) (primitive-ref write-char) (primitive-ref string->list) (primitive-ref write-char)) (let ((f259591 f259591) (f259592 f259592)) (begin ((primitive-ref write-char) #\" f259592) ((primitive-ref for-each) (closure (f259594) ((primitive-ref write-char) f259592) (let ((f259594 f259594)) ((primitive-ref write-char) f259594 f259592))) ((primitive-ref string->list) f259591)) ((primitive-ref write-char) #\" f259592))))
    movl $_L_1577309, 0(%ebp)  # closure label
# WARNING: free var (primitive-ref write-char) not defined in the environmnet
# WARNING: free var (primitive-ref for-each) not defined in the environmnet
# WARNING: free var (primitive-ref write-char) not defined in the environmnet
# WARNING: free var (primitive-ref string->list) not defined in the environmnet
# WARNING: free var (primitive-ref write-char) not defined in the environmnet
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $24, %ebp     # bump ebp
    jmp _L_1577310            # jump around closure body
_L_1577309:
# check argument count
    cmp $8,%eax
    je _L_1577311
# invoke error handler eh_argcount
    .extern mrc_eh$uargcount
    movl mrc_eh$uargcount, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_1577311:
# emit-tail-expr
# si=-16
# env=((f259592 . -12) (f259591 . -8) ((primitive-ref write-char) . 20) ((primitive-ref string->list) . 16) ((primitive-ref write-char) . 12) ((primitive-ref for-each) . 8) ((primitive-ref write-char) . 4) (f259554 . -28) (f259555 . -24) (f259556 . -20) (f259557 . -16) (f259558 . -12) (f259559 . -8) (f259560 . -4) (f259561 . 0))
# expr=(let ((f259591 f259591) (f259592 f259592)) (begin ((primitive-ref write-char) #\" f259592) ((primitive-ref for-each) (closure (f259594) ((primitive-ref write-char) f259592) (let ((f259594 f259594)) ((primitive-ref write-char) f259594 f259592))) ((primitive-ref string->list) f259591)) ((primitive-ref write-char) #\" f259592)))
# emit-tail-let
#  si   = -16
#  env  = ((f259592 . -12) (f259591 . -8) ((primitive-ref write-char) . 20) ((primitive-ref string->list) . 16) ((primitive-ref write-char) . 12) ((primitive-ref for-each) . 8) ((primitive-ref write-char) . 4) (f259554 . -28) (f259555 . -24) (f259556 . -20) (f259557 . -16) (f259558 . -12) (f259559 . -8) (f259560 . -4) (f259561 . 0))
#  bindings = ((f259591 f259591) (f259592 f259592))
#  body = (begin ((primitive-ref write-char) #\" f259592) ((primitive-ref for-each) (closure (f259594) ((primitive-ref write-char) f259592) (let ((f259594 f259594)) ((primitive-ref write-char) f259594 f259592))) ((primitive-ref string->list) f259591)) ((primitive-ref write-char) #\" f259592))
# emit-expr f259591
# emit-variable-ref
# env=((f259592 . -12) (f259591 . -8) ((primitive-ref write-char) . 20) ((primitive-ref string->list) . 16) ((primitive-ref write-char) . 12) ((primitive-ref for-each) . 8) ((primitive-ref write-char) . 4) (f259554 . -28) (f259555 . -24) (f259556 . -20) (f259557 . -16) (f259558 . -12) (f259559 . -8) (f259560 . -4) (f259561 . 0))
# var=f259591
    movl -8(%esp), %eax  # stack load f259591
# end emit-variable-ref
    movl %eax, -16(%esp)  # stack save
# emit-expr f259592
# emit-variable-ref
# env=((f259592 . -12) (f259591 . -8) ((primitive-ref write-char) . 20) ((primitive-ref string->list) . 16) ((primitive-ref write-char) . 12) ((primitive-ref for-each) . 8) ((primitive-ref write-char) . 4) (f259554 . -28) (f259555 . -24) (f259556 . -20) (f259557 . -16) (f259558 . -12) (f259559 . -8) (f259560 . -4) (f259561 . 0))
# var=f259592
    movl -12(%esp), %eax  # stack load f259592
# end emit-variable-ref
    movl %eax, -20(%esp)  # stack save
# emit-tail-expr
# si=-24
# env=((f259592 . -20) (f259591 . -16) (f259592 . -12) (f259591 . -8) ((primitive-ref write-char) . 20) ((primitive-ref string->list) . 16) ((primitive-ref write-char) . 12) ((primitive-ref for-each) . 8) ((primitive-ref write-char) . 4) (f259554 . -28) (f259555 . -24) (f259556 . -20) (f259557 . -16) (f259558 . -12) (f259559 . -8) (f259560 . -4) (f259561 . 0))
# expr=(begin ((primitive-ref write-char) #\" f259592) ((primitive-ref for-each) (closure (f259594) ((primitive-ref write-char) f259592) (let ((f259594 f259594)) ((primitive-ref write-char) f259594 f259592))) ((primitive-ref string->list) f259591)) ((primitive-ref write-char) #\" f259592))
# tail-begin (begin ((primitive-ref write-char) #\" f259592) ((primitive-ref for-each) (closure (f259594) ((primitive-ref write-char) f259592) (let ((f259594 f259594)) ((primitive-ref write-char) f259594 f259592))) ((primitive-ref string->list) f259591)) ((primitive-ref write-char) #\" f259592))
#   env=((f259592 . -20) (f259591 . -16) (f259592 . -12) (f259591 . -8) ((primitive-ref write-char) . 20) ((primitive-ref string->list) . 16) ((primitive-ref write-char) . 12) ((primitive-ref for-each) . 8) ((primitive-ref write-char) . 4) (f259554 . -28) (f259555 . -24) (f259556 . -20) (f259557 . -16) (f259558 . -12) (f259559 . -8) (f259560 . -4) (f259561 . 0))
# emit-expr ((primitive-ref write-char) #\" f259592)
# funcall
#    si   =-24
#    env  = ((f259592 . -20) (f259591 . -16) (f259592 . -12) (f259591 . -8) ((primitive-ref write-char) . 20) ((primitive-ref string->list) . 16) ((primitive-ref write-char) . 12) ((primitive-ref for-each) . 8) ((primitive-ref write-char) . 4) (f259554 . -28) (f259555 . -24) (f259556 . -20) (f259557 . -16) (f259558 . -12) (f259559 . -8) (f259560 . -4) (f259561 . 0))
#    expr = (funcall (primitive-ref write-char) #\" f259592)
# emit-expr (primitive-ref write-char)
    .extern mrc_write$mchar
    movl mrc_write$mchar,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1577312"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1577312":
   movl %eax,  -32(%esp)  # stash funcall-oper in closure slot
# emit-expr #\"
    movl $8719, %eax     # immed #\"
    mov %eax, -36(%esp)  # arg "
# emit-expr f259592
# emit-variable-ref
# env=((f259592 . -20) (f259591 . -16) (f259592 . -12) (f259591 . -8) ((primitive-ref write-char) . 20) ((primitive-ref string->list) . 16) ((primitive-ref write-char) . 12) ((primitive-ref for-each) . 8) ((primitive-ref write-char) . 4) (f259554 . -28) (f259555 . -24) (f259556 . -20) (f259557 . -16) (f259558 . -12) (f259559 . -8) (f259560 . -4) (f259561 . 0))
# var=f259592
    movl -20(%esp), %eax  # stack load f259592
# end emit-variable-ref
    mov %eax, -40(%esp)  # arg f259592
    movl -32(%esp), %edi   # load new closure to %edi
    add $-24, %esp   # adjust base
    movl $8,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $24, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
# emit-tail-expr
# si=-24
# env=((f259592 . -20) (f259591 . -16) (f259592 . -12) (f259591 . -8) ((primitive-ref write-char) . 20) ((primitive-ref string->list) . 16) ((primitive-ref write-char) . 12) ((primitive-ref for-each) . 8) ((primitive-ref write-char) . 4) (f259554 . -28) (f259555 . -24) (f259556 . -20) (f259557 . -16) (f259558 . -12) (f259559 . -8) (f259560 . -4) (f259561 . 0))
# expr=(begin ((primitive-ref for-each) (closure (f259594) ((primitive-ref write-char) f259592) (let ((f259594 f259594)) ((primitive-ref write-char) f259594 f259592))) ((primitive-ref string->list) f259591)) ((primitive-ref write-char) #\" f259592))
# tail-begin (begin ((primitive-ref for-each) (closure (f259594) ((primitive-ref write-char) f259592) (let ((f259594 f259594)) ((primitive-ref write-char) f259594 f259592))) ((primitive-ref string->list) f259591)) ((primitive-ref write-char) #\" f259592))
#   env=((f259592 . -20) (f259591 . -16) (f259592 . -12) (f259591 . -8) ((primitive-ref write-char) . 20) ((primitive-ref string->list) . 16) ((primitive-ref write-char) . 12) ((primitive-ref for-each) . 8) ((primitive-ref write-char) . 4) (f259554 . -28) (f259555 . -24) (f259556 . -20) (f259557 . -16) (f259558 . -12) (f259559 . -8) (f259560 . -4) (f259561 . 0))
# emit-expr ((primitive-ref for-each) (closure (f259594) ((primitive-ref write-char) f259592) (let ((f259594 f259594)) ((primitive-ref write-char) f259594 f259592))) ((primitive-ref string->list) f259591))
# funcall
#    si   =-24
#    env  = ((f259592 . -20) (f259591 . -16) (f259592 . -12) (f259591 . -8) ((primitive-ref write-char) . 20) ((primitive-ref string->list) . 16) ((primitive-ref write-char) . 12) ((primitive-ref for-each) . 8) ((primitive-ref write-char) . 4) (f259554 . -28) (f259555 . -24) (f259556 . -20) (f259557 . -16) (f259558 . -12) (f259559 . -8) (f259560 . -4) (f259561 . 0))
#    expr = (funcall (primitive-ref for-each) (closure (f259594) ((primitive-ref write-char) f259592) (let ((f259594 f259594)) ((primitive-ref write-char) f259594 f259592))) ((primitive-ref string->list) f259591))
# emit-expr (primitive-ref for-each)
    .extern mrc_for$meach
    movl mrc_for$meach,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1577313"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1577313":
   movl %eax,  -32(%esp)  # stash funcall-oper in closure slot
# emit-expr (closure (f259594) ((primitive-ref write-char) f259592) (let ((f259594 f259594)) ((primitive-ref write-char) f259594 f259592)))
# emit-closure
# si = -36
# env = ((f259592 . -20) (f259591 . -16) (f259592 . -12) (f259591 . -8) ((primitive-ref write-char) . 20) ((primitive-ref string->list) . 16) ((primitive-ref write-char) . 12) ((primitive-ref for-each) . 8) ((primitive-ref write-char) . 4) (f259554 . -28) (f259555 . -24) (f259556 . -20) (f259557 . -16) (f259558 . -12) (f259559 . -8) (f259560 . -4) (f259561 . 0))
# expr = (closure (f259594) ((primitive-ref write-char) f259592) (let ((f259594 f259594)) ((primitive-ref write-char) f259594 f259592)))
    movl $_L_1577314, 0(%ebp)  # closure label
# emit-variable-ref
# env=((f259592 . -20) (f259591 . -16) (f259592 . -12) (f259591 . -8) ((primitive-ref write-char) . 20) ((primitive-ref string->list) . 16) ((primitive-ref write-char) . 12) ((primitive-ref for-each) . 8) ((primitive-ref write-char) . 4) (f259554 . -28) (f259555 . -24) (f259556 . -20) (f259557 . -16) (f259558 . -12) (f259559 . -8) (f259560 . -4) (f259561 . 0))
# var=(primitive-ref write-char)
    movl 18(%edi), %eax  # frame load (primitive-ref write-char)
# end emit-variable-ref
   movl  %eax, 4(%ebp)  # (primitive-ref write-char)
# emit-variable-ref
# env=((f259592 . -20) (f259591 . -16) (f259592 . -12) (f259591 . -8) ((primitive-ref write-char) . 20) ((primitive-ref string->list) . 16) ((primitive-ref write-char) . 12) ((primitive-ref for-each) . 8) ((primitive-ref write-char) . 4) (f259554 . -28) (f259555 . -24) (f259556 . -20) (f259557 . -16) (f259558 . -12) (f259559 . -8) (f259560 . -4) (f259561 . 0))
# var=f259592
    movl -20(%esp), %eax  # stack load f259592
# end emit-variable-ref
   movl  %eax, 8(%ebp)  # f259592
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $16, %ebp     # bump ebp
    jmp _L_1577315            # jump around closure body
_L_1577314:
# check argument count
    cmp $4,%eax
    je _L_1577316
# invoke error handler eh_argcount
    .extern mrc_eh$uargcount
    movl mrc_eh$uargcount, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_1577316:
# emit-tail-expr
# si=-12
# env=((f259594 . -8) (f259592 . 8) ((primitive-ref write-char) . 4) (f259592 . -20) (f259591 . -16) (f259592 . -12) (f259591 . -8) ((primitive-ref write-char) . 20) ((primitive-ref string->list) . 16) ((primitive-ref write-char) . 12) ((primitive-ref for-each) . 8) ((primitive-ref write-char) . 4) (f259554 . -28) (f259555 . -24) (f259556 . -20) (f259557 . -16) (f259558 . -12) (f259559 . -8) (f259560 . -4) (f259561 . 0))
# expr=(let ((f259594 f259594)) ((primitive-ref write-char) f259594 f259592))
# emit-tail-let
#  si   = -12
#  env  = ((f259594 . -8) (f259592 . 8) ((primitive-ref write-char) . 4) (f259592 . -20) (f259591 . -16) (f259592 . -12) (f259591 . -8) ((primitive-ref write-char) . 20) ((primitive-ref string->list) . 16) ((primitive-ref write-char) . 12) ((primitive-ref for-each) . 8) ((primitive-ref write-char) . 4) (f259554 . -28) (f259555 . -24) (f259556 . -20) (f259557 . -16) (f259558 . -12) (f259559 . -8) (f259560 . -4) (f259561 . 0))
#  bindings = ((f259594 f259594))
#  body = ((primitive-ref write-char) f259594 f259592)
# emit-expr f259594
# emit-variable-ref
# env=((f259594 . -8) (f259592 . 8) ((primitive-ref write-char) . 4) (f259592 . -20) (f259591 . -16) (f259592 . -12) (f259591 . -8) ((primitive-ref write-char) . 20) ((primitive-ref string->list) . 16) ((primitive-ref write-char) . 12) ((primitive-ref for-each) . 8) ((primitive-ref write-char) . 4) (f259554 . -28) (f259555 . -24) (f259556 . -20) (f259557 . -16) (f259558 . -12) (f259559 . -8) (f259560 . -4) (f259561 . 0))
# var=f259594
    movl -8(%esp), %eax  # stack load f259594
# end emit-variable-ref
    movl %eax, -12(%esp)  # stack save
# emit-tail-expr
# si=-16
# env=((f259594 . -12) (f259594 . -8) (f259592 . 8) ((primitive-ref write-char) . 4) (f259592 . -20) (f259591 . -16) (f259592 . -12) (f259591 . -8) ((primitive-ref write-char) . 20) ((primitive-ref string->list) . 16) ((primitive-ref write-char) . 12) ((primitive-ref for-each) . 8) ((primitive-ref write-char) . 4) (f259554 . -28) (f259555 . -24) (f259556 . -20) (f259557 . -16) (f259558 . -12) (f259559 . -8) (f259560 . -4) (f259561 . 0))
# expr=((primitive-ref write-char) f259594 f259592)
# emit-tail-funcall
#    si   =-16
#    env  = ((f259594 . -12) (f259594 . -8) (f259592 . 8) ((primitive-ref write-char) . 4) (f259592 . -20) (f259591 . -16) (f259592 . -12) (f259591 . -8) ((primitive-ref write-char) . 20) ((primitive-ref string->list) . 16) ((primitive-ref write-char) . 12) ((primitive-ref for-each) . 8) ((primitive-ref write-char) . 4) (f259554 . -28) (f259555 . -24) (f259556 . -20) (f259557 . -16) (f259558 . -12) (f259559 . -8) (f259560 . -4) (f259561 . 0))
#    expr = (funcall (primitive-ref write-char) f259594 f259592)
# emit-expr (primitive-ref write-char)
    .extern mrc_write$mchar
    movl mrc_write$mchar,%eax
   movl %eax,  -16(%esp)  # stash funcall-oper in next closure slot
# emit-expr f259594
# emit-variable-ref
# env=((f259594 . -12) (f259594 . -8) (f259592 . 8) ((primitive-ref write-char) . 4) (f259592 . -20) (f259591 . -16) (f259592 . -12) (f259591 . -8) ((primitive-ref write-char) . 20) ((primitive-ref string->list) . 16) ((primitive-ref write-char) . 12) ((primitive-ref for-each) . 8) ((primitive-ref write-char) . 4) (f259554 . -28) (f259555 . -24) (f259556 . -20) (f259557 . -16) (f259558 . -12) (f259559 . -8) (f259560 . -4) (f259561 . 0))
# var=f259594
    movl -12(%esp), %eax  # stack load f259594
# end emit-variable-ref
    mov %eax, -20(%esp)    # arg f259594
# emit-expr f259592
# emit-variable-ref
# env=((f259594 . -12) (f259594 . -8) (f259592 . 8) ((primitive-ref write-char) . 4) (f259592 . -20) (f259591 . -16) (f259592 . -12) (f259591 . -8) ((primitive-ref write-char) . 20) ((primitive-ref string->list) . 16) ((primitive-ref write-char) . 12) ((primitive-ref for-each) . 8) ((primitive-ref write-char) . 4) (f259554 . -28) (f259555 . -24) (f259556 . -20) (f259557 . -16) (f259558 . -12) (f259559 . -8) (f259560 . -4) (f259561 . 0))
# var=f259592
    movl 6(%edi), %eax  # frame load f259592
# end emit-variable-ref
    mov %eax, -24(%esp)    # arg f259592
    movl -16(%esp), %edi   # load new closure to %edi
# emit-shift-args:  size=3   si=-16  delta=12
    mov -16(%esp), %ebx  # shift frame cell
    mov %ebx, -4(%esp)  # down to base
# emit-shift-args:  size=2   si=-20  delta=12
    mov -20(%esp), %ebx  # shift frame cell
    mov %ebx, -8(%esp)  # down to base
# emit-shift-args:  size=1   si=-24  delta=12
    mov -24(%esp), %ebx  # shift frame cell
    mov %ebx, -12(%esp)  # down to base
# emit-shift-args:  size=0   si=-28  delta=12
    movl $8,%eax   # save arg count
    jmp *-2(%edi)  # tail-funcall
    .align 4,0x90
_L_1577315:
    mov %eax, -36(%esp)  # arg (closure (f259594) ((primitive-ref write-char) f259592) (let ((f259594 f259594)) ((primitive-ref write-char) f259594 f259592)))
# emit-expr ((primitive-ref string->list) f259591)
# funcall
#    si   =-40
#    env  = ((f259592 . -20) (f259591 . -16) (f259592 . -12) (f259591 . -8) ((primitive-ref write-char) . 20) ((primitive-ref string->list) . 16) ((primitive-ref write-char) . 12) ((primitive-ref for-each) . 8) ((primitive-ref write-char) . 4) (f259554 . -28) (f259555 . -24) (f259556 . -20) (f259557 . -16) (f259558 . -12) (f259559 . -8) (f259560 . -4) (f259561 . 0))
#    expr = (funcall (primitive-ref string->list) f259591)
# emit-expr (primitive-ref string->list)
    .extern mrc_string$m$glist
    movl mrc_string$m$glist,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1577317"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1577317":
   movl %eax,  -48(%esp)  # stash funcall-oper in closure slot
# emit-expr f259591
# emit-variable-ref
# env=((f259592 . -20) (f259591 . -16) (f259592 . -12) (f259591 . -8) ((primitive-ref write-char) . 20) ((primitive-ref string->list) . 16) ((primitive-ref write-char) . 12) ((primitive-ref for-each) . 8) ((primitive-ref write-char) . 4) (f259554 . -28) (f259555 . -24) (f259556 . -20) (f259557 . -16) (f259558 . -12) (f259559 . -8) (f259560 . -4) (f259561 . 0))
# var=f259591
    movl -16(%esp), %eax  # stack load f259591
# end emit-variable-ref
    mov %eax, -52(%esp)  # arg f259591
    movl -48(%esp), %edi   # load new closure to %edi
    add $-40, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $40, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    mov %eax, -40(%esp)  # arg ((primitive-ref string->list) f259591)
    movl -32(%esp), %edi   # load new closure to %edi
    add $-24, %esp   # adjust base
    movl $8,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $24, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
# emit-tail-expr
# si=-24
# env=((f259592 . -20) (f259591 . -16) (f259592 . -12) (f259591 . -8) ((primitive-ref write-char) . 20) ((primitive-ref string->list) . 16) ((primitive-ref write-char) . 12) ((primitive-ref for-each) . 8) ((primitive-ref write-char) . 4) (f259554 . -28) (f259555 . -24) (f259556 . -20) (f259557 . -16) (f259558 . -12) (f259559 . -8) (f259560 . -4) (f259561 . 0))
# expr=(begin ((primitive-ref write-char) #\" f259592))
# tail-begin (begin ((primitive-ref write-char) #\" f259592))
#   env=((f259592 . -20) (f259591 . -16) (f259592 . -12) (f259591 . -8) ((primitive-ref write-char) . 20) ((primitive-ref string->list) . 16) ((primitive-ref write-char) . 12) ((primitive-ref for-each) . 8) ((primitive-ref write-char) . 4) (f259554 . -28) (f259555 . -24) (f259556 . -20) (f259557 . -16) (f259558 . -12) (f259559 . -8) (f259560 . -4) (f259561 . 0))
# emit-tail-expr
# si=-24
# env=((f259592 . -20) (f259591 . -16) (f259592 . -12) (f259591 . -8) ((primitive-ref write-char) . 20) ((primitive-ref string->list) . 16) ((primitive-ref write-char) . 12) ((primitive-ref for-each) . 8) ((primitive-ref write-char) . 4) (f259554 . -28) (f259555 . -24) (f259556 . -20) (f259557 . -16) (f259558 . -12) (f259559 . -8) (f259560 . -4) (f259561 . 0))
# expr=((primitive-ref write-char) #\" f259592)
# emit-tail-funcall
#    si   =-24
#    env  = ((f259592 . -20) (f259591 . -16) (f259592 . -12) (f259591 . -8) ((primitive-ref write-char) . 20) ((primitive-ref string->list) . 16) ((primitive-ref write-char) . 12) ((primitive-ref for-each) . 8) ((primitive-ref write-char) . 4) (f259554 . -28) (f259555 . -24) (f259556 . -20) (f259557 . -16) (f259558 . -12) (f259559 . -8) (f259560 . -4) (f259561 . 0))
#    expr = (funcall (primitive-ref write-char) #\" f259592)
# emit-expr (primitive-ref write-char)
    .extern mrc_write$mchar
    movl mrc_write$mchar,%eax
   movl %eax,  -24(%esp)  # stash funcall-oper in next closure slot
# emit-expr #\"
    movl $8719, %eax     # immed #\"
    mov %eax, -28(%esp)    # arg "
# emit-expr f259592
# emit-variable-ref
# env=((f259592 . -20) (f259591 . -16) (f259592 . -12) (f259591 . -8) ((primitive-ref write-char) . 20) ((primitive-ref string->list) . 16) ((primitive-ref write-char) . 12) ((primitive-ref for-each) . 8) ((primitive-ref write-char) . 4) (f259554 . -28) (f259555 . -24) (f259556 . -20) (f259557 . -16) (f259558 . -12) (f259559 . -8) (f259560 . -4) (f259561 . 0))
# var=f259592
    movl -20(%esp), %eax  # stack load f259592
# end emit-variable-ref
    mov %eax, -32(%esp)    # arg f259592
    movl -24(%esp), %edi   # load new closure to %edi
# emit-shift-args:  size=3   si=-24  delta=20
    mov -24(%esp), %ebx  # shift frame cell
    mov %ebx, -4(%esp)  # down to base
# emit-shift-args:  size=2   si=-28  delta=20
    mov -28(%esp), %ebx  # shift frame cell
    mov %ebx, -8(%esp)  # down to base
# emit-shift-args:  size=1   si=-32  delta=20
    mov -32(%esp), %ebx  # shift frame cell
    mov %ebx, -12(%esp)  # down to base
# emit-shift-args:  size=0   si=-36  delta=20
    movl $8,%eax   # save arg count
    jmp *-2(%edi)  # tail-funcall
     ret   # return thru stack
    .align 4,0x90
_L_1577310:
    movl -32(%esp), %ebx
    movl -36(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin (vector-set! f259556 0 (closure (f259587 f259588) ((primitive-ref for-each) (primitive-ref write-char) (primitive-ref string->list)) (let ((f259587 f259587) (f259588 f259588)) ((primitive-ref for-each) (closure (f259590) ((primitive-ref write-char) f259588) (let ((f259590 f259590)) ((primitive-ref write-char) f259590 f259588))) ((primitive-ref string->list) f259587))))) (vector-set! f259555 0 (closure (f259585 f259586) ((primitive-ref write-char) f259554 (primitive-ref write-char)) (let ((f259585 f259585) (f259586 f259586)) (begin ((primitive-ref write-char) #\( f259586) ((vector-ref f259554 0) f259585 f259586) ((primitive-ref write-char) #\) f259586))))) (vector-set! f259554 0 (closure (f259583 f259584) ((primitive-ref write) (primitive-ref write-char) f259554 else (primitive-ref write-char) (primitive-ref write-char) (primitive-ref write-char) (primitive-ref write)) (let ((f259583 f259583) (f259584 f259584)) (begin ((primitive-ref write) (car f259583) f259584) (if (null? (cdr f259583)) #t (if (pair? (cdr f259583)) (begin ((primitive-ref write-char) #\space f259584) ((vector-ref f259554 0) (cdr f259583) f259584)) (begin ((primitive-ref write-char) #\space f259584) ((primitive-ref write-char) #\. f259584) ((primitive-ref write-char) #\space f259584) ((primitive-ref write) (cdr f259583) f259584)))))))))
# emit-begin
#   expr=(begin (vector-set! f259556 0 (closure (f259587 f259588) ((primitive-ref for-each) (primitive-ref write-char) (primitive-ref string->list)) (let ((f259587 f259587) (f259588 f259588)) ((primitive-ref for-each) (closure (f259590) ((primitive-ref write-char) f259588) (let ((f259590 f259590)) ((primitive-ref write-char) f259590 f259588))) ((primitive-ref string->list) f259587))))) (vector-set! f259555 0 (closure (f259585 f259586) ((primitive-ref write-char) f259554 (primitive-ref write-char)) (let ((f259585 f259585) (f259586 f259586)) (begin ((primitive-ref write-char) #\( f259586) ((vector-ref f259554 0) f259585 f259586) ((primitive-ref write-char) #\) f259586))))) (vector-set! f259554 0 (closure (f259583 f259584) ((primitive-ref write) (primitive-ref write-char) f259554 else (primitive-ref write-char) (primitive-ref write-char) (primitive-ref write-char) (primitive-ref write)) (let ((f259583 f259583) (f259584 f259584)) (begin ((primitive-ref write) (car f259583) f259584) (if (null? (cdr f259583)) #t (if (pair? (cdr f259583)) (begin ((primitive-ref write-char) #\space f259584) ((vector-ref f259554 0) (cdr f259583) f259584)) (begin ((primitive-ref write-char) #\space f259584) ((primitive-ref write-char) #\. f259584) ((primitive-ref write-char) #\space f259584) ((primitive-ref write) (cdr f259583) f259584)))))))))
#   env=((f259554 . -28) (f259555 . -24) (f259556 . -20) (f259557 . -16) (f259558 . -12) (f259559 . -8) (f259560 . -4) (f259561 . 0))
# emit-expr (vector-set! f259556 0 (closure (f259587 f259588) ((primitive-ref for-each) (primitive-ref write-char) (primitive-ref string->list)) (let ((f259587 f259587) (f259588 f259588)) ((primitive-ref for-each) (closure (f259590) ((primitive-ref write-char) f259588) (let ((f259590 f259590)) ((primitive-ref write-char) f259590 f259588))) ((primitive-ref string->list) f259587)))))
# emit-expr f259556
# emit-variable-ref
# env=((f259554 . -28) (f259555 . -24) (f259556 . -20) (f259557 . -16) (f259558 . -12) (f259559 . -8) (f259560 . -4) (f259561 . 0))
# var=f259556
    movl -20(%esp), %eax  # stack load f259556
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1577318
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1577318:
    movl %eax, -32(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1577319"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1577319:
# check bounds on vector index
    movl -32(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1577321
    cmp  $0,%eax
    jge _L_1577320
_L_1577321:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1577320:
    movl %eax, -36(%esp)
# emit-expr (closure (f259587 f259588) ((primitive-ref for-each) (primitive-ref write-char) (primitive-ref string->list)) (let ((f259587 f259587) (f259588 f259588)) ((primitive-ref for-each) (closure (f259590) ((primitive-ref write-char) f259588) (let ((f259590 f259590)) ((primitive-ref write-char) f259590 f259588))) ((primitive-ref string->list) f259587))))
# emit-closure
# si = -40
# env = ((f259554 . -28) (f259555 . -24) (f259556 . -20) (f259557 . -16) (f259558 . -12) (f259559 . -8) (f259560 . -4) (f259561 . 0))
# expr = (closure (f259587 f259588) ((primitive-ref for-each) (primitive-ref write-char) (primitive-ref string->list)) (let ((f259587 f259587) (f259588 f259588)) ((primitive-ref for-each) (closure (f259590) ((primitive-ref write-char) f259588) (let ((f259590 f259590)) ((primitive-ref write-char) f259590 f259588))) ((primitive-ref string->list) f259587))))
    movl $_L_1577322, 0(%ebp)  # closure label
# WARNING: free var (primitive-ref for-each) not defined in the environmnet
# WARNING: free var (primitive-ref write-char) not defined in the environmnet
# WARNING: free var (primitive-ref string->list) not defined in the environmnet
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $16, %ebp     # bump ebp
    jmp _L_1577323            # jump around closure body
_L_1577322:
# check argument count
    cmp $8,%eax
    je _L_1577324
# invoke error handler eh_argcount
    .extern mrc_eh$uargcount
    movl mrc_eh$uargcount, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_1577324:
# emit-tail-expr
# si=-16
# env=((f259588 . -12) (f259587 . -8) ((primitive-ref string->list) . 12) ((primitive-ref write-char) . 8) ((primitive-ref for-each) . 4) (f259554 . -28) (f259555 . -24) (f259556 . -20) (f259557 . -16) (f259558 . -12) (f259559 . -8) (f259560 . -4) (f259561 . 0))
# expr=(let ((f259587 f259587) (f259588 f259588)) ((primitive-ref for-each) (closure (f259590) ((primitive-ref write-char) f259588) (let ((f259590 f259590)) ((primitive-ref write-char) f259590 f259588))) ((primitive-ref string->list) f259587)))
# emit-tail-let
#  si   = -16
#  env  = ((f259588 . -12) (f259587 . -8) ((primitive-ref string->list) . 12) ((primitive-ref write-char) . 8) ((primitive-ref for-each) . 4) (f259554 . -28) (f259555 . -24) (f259556 . -20) (f259557 . -16) (f259558 . -12) (f259559 . -8) (f259560 . -4) (f259561 . 0))
#  bindings = ((f259587 f259587) (f259588 f259588))
#  body = ((primitive-ref for-each) (closure (f259590) ((primitive-ref write-char) f259588) (let ((f259590 f259590)) ((primitive-ref write-char) f259590 f259588))) ((primitive-ref string->list) f259587))
# emit-expr f259587
# emit-variable-ref
# env=((f259588 . -12) (f259587 . -8) ((primitive-ref string->list) . 12) ((primitive-ref write-char) . 8) ((primitive-ref for-each) . 4) (f259554 . -28) (f259555 . -24) (f259556 . -20) (f259557 . -16) (f259558 . -12) (f259559 . -8) (f259560 . -4) (f259561 . 0))
# var=f259587
    movl -8(%esp), %eax  # stack load f259587
# end emit-variable-ref
    movl %eax, -16(%esp)  # stack save
# emit-expr f259588
# emit-variable-ref
# env=((f259588 . -12) (f259587 . -8) ((primitive-ref string->list) . 12) ((primitive-ref write-char) . 8) ((primitive-ref for-each) . 4) (f259554 . -28) (f259555 . -24) (f259556 . -20) (f259557 . -16) (f259558 . -12) (f259559 . -8) (f259560 . -4) (f259561 . 0))
# var=f259588
    movl -12(%esp), %eax  # stack load f259588
# end emit-variable-ref
    movl %eax, -20(%esp)  # stack save
# emit-tail-expr
# si=-24
# env=((f259588 . -20) (f259587 . -16) (f259588 . -12) (f259587 . -8) ((primitive-ref string->list) . 12) ((primitive-ref write-char) . 8) ((primitive-ref for-each) . 4) (f259554 . -28) (f259555 . -24) (f259556 . -20) (f259557 . -16) (f259558 . -12) (f259559 . -8) (f259560 . -4) (f259561 . 0))
# expr=((primitive-ref for-each) (closure (f259590) ((primitive-ref write-char) f259588) (let ((f259590 f259590)) ((primitive-ref write-char) f259590 f259588))) ((primitive-ref string->list) f259587))
# emit-tail-funcall
#    si   =-24
#    env  = ((f259588 . -20) (f259587 . -16) (f259588 . -12) (f259587 . -8) ((primitive-ref string->list) . 12) ((primitive-ref write-char) . 8) ((primitive-ref for-each) . 4) (f259554 . -28) (f259555 . -24) (f259556 . -20) (f259557 . -16) (f259558 . -12) (f259559 . -8) (f259560 . -4) (f259561 . 0))
#    expr = (funcall (primitive-ref for-each) (closure (f259590) ((primitive-ref write-char) f259588) (let ((f259590 f259590)) ((primitive-ref write-char) f259590 f259588))) ((primitive-ref string->list) f259587))
# emit-expr (primitive-ref for-each)
    .extern mrc_for$meach
    movl mrc_for$meach,%eax
   movl %eax,  -24(%esp)  # stash funcall-oper in next closure slot
# emit-expr (closure (f259590) ((primitive-ref write-char) f259588) (let ((f259590 f259590)) ((primitive-ref write-char) f259590 f259588)))
# emit-closure
# si = -28
# env = ((f259588 . -20) (f259587 . -16) (f259588 . -12) (f259587 . -8) ((primitive-ref string->list) . 12) ((primitive-ref write-char) . 8) ((primitive-ref for-each) . 4) (f259554 . -28) (f259555 . -24) (f259556 . -20) (f259557 . -16) (f259558 . -12) (f259559 . -8) (f259560 . -4) (f259561 . 0))
# expr = (closure (f259590) ((primitive-ref write-char) f259588) (let ((f259590 f259590)) ((primitive-ref write-char) f259590 f259588)))
    movl $_L_1577325, 0(%ebp)  # closure label
# emit-variable-ref
# env=((f259588 . -20) (f259587 . -16) (f259588 . -12) (f259587 . -8) ((primitive-ref string->list) . 12) ((primitive-ref write-char) . 8) ((primitive-ref for-each) . 4) (f259554 . -28) (f259555 . -24) (f259556 . -20) (f259557 . -16) (f259558 . -12) (f259559 . -8) (f259560 . -4) (f259561 . 0))
# var=(primitive-ref write-char)
    movl 6(%edi), %eax  # frame load (primitive-ref write-char)
# end emit-variable-ref
   movl  %eax, 4(%ebp)  # (primitive-ref write-char)
# emit-variable-ref
# env=((f259588 . -20) (f259587 . -16) (f259588 . -12) (f259587 . -8) ((primitive-ref string->list) . 12) ((primitive-ref write-char) . 8) ((primitive-ref for-each) . 4) (f259554 . -28) (f259555 . -24) (f259556 . -20) (f259557 . -16) (f259558 . -12) (f259559 . -8) (f259560 . -4) (f259561 . 0))
# var=f259588
    movl -20(%esp), %eax  # stack load f259588
# end emit-variable-ref
   movl  %eax, 8(%ebp)  # f259588
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $16, %ebp     # bump ebp
    jmp _L_1577326            # jump around closure body
_L_1577325:
# check argument count
    cmp $4,%eax
    je _L_1577327
# invoke error handler eh_argcount
    .extern mrc_eh$uargcount
    movl mrc_eh$uargcount, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_1577327:
# emit-tail-expr
# si=-12
# env=((f259590 . -8) (f259588 . 8) ((primitive-ref write-char) . 4) (f259588 . -20) (f259587 . -16) (f259588 . -12) (f259587 . -8) ((primitive-ref string->list) . 12) ((primitive-ref write-char) . 8) ((primitive-ref for-each) . 4) (f259554 . -28) (f259555 . -24) (f259556 . -20) (f259557 . -16) (f259558 . -12) (f259559 . -8) (f259560 . -4) (f259561 . 0))
# expr=(let ((f259590 f259590)) ((primitive-ref write-char) f259590 f259588))
# emit-tail-let
#  si   = -12
#  env  = ((f259590 . -8) (f259588 . 8) ((primitive-ref write-char) . 4) (f259588 . -20) (f259587 . -16) (f259588 . -12) (f259587 . -8) ((primitive-ref string->list) . 12) ((primitive-ref write-char) . 8) ((primitive-ref for-each) . 4) (f259554 . -28) (f259555 . -24) (f259556 . -20) (f259557 . -16) (f259558 . -12) (f259559 . -8) (f259560 . -4) (f259561 . 0))
#  bindings = ((f259590 f259590))
#  body = ((primitive-ref write-char) f259590 f259588)
# emit-expr f259590
# emit-variable-ref
# env=((f259590 . -8) (f259588 . 8) ((primitive-ref write-char) . 4) (f259588 . -20) (f259587 . -16) (f259588 . -12) (f259587 . -8) ((primitive-ref string->list) . 12) ((primitive-ref write-char) . 8) ((primitive-ref for-each) . 4) (f259554 . -28) (f259555 . -24) (f259556 . -20) (f259557 . -16) (f259558 . -12) (f259559 . -8) (f259560 . -4) (f259561 . 0))
# var=f259590
    movl -8(%esp), %eax  # stack load f259590
# end emit-variable-ref
    movl %eax, -12(%esp)  # stack save
# emit-tail-expr
# si=-16
# env=((f259590 . -12) (f259590 . -8) (f259588 . 8) ((primitive-ref write-char) . 4) (f259588 . -20) (f259587 . -16) (f259588 . -12) (f259587 . -8) ((primitive-ref string->list) . 12) ((primitive-ref write-char) . 8) ((primitive-ref for-each) . 4) (f259554 . -28) (f259555 . -24) (f259556 . -20) (f259557 . -16) (f259558 . -12) (f259559 . -8) (f259560 . -4) (f259561 . 0))
# expr=((primitive-ref write-char) f259590 f259588)
# emit-tail-funcall
#    si   =-16
#    env  = ((f259590 . -12) (f259590 . -8) (f259588 . 8) ((primitive-ref write-char) . 4) (f259588 . -20) (f259587 . -16) (f259588 . -12) (f259587 . -8) ((primitive-ref string->list) . 12) ((primitive-ref write-char) . 8) ((primitive-ref for-each) . 4) (f259554 . -28) (f259555 . -24) (f259556 . -20) (f259557 . -16) (f259558 . -12) (f259559 . -8) (f259560 . -4) (f259561 . 0))
#    expr = (funcall (primitive-ref write-char) f259590 f259588)
# emit-expr (primitive-ref write-char)
    .extern mrc_write$mchar
    movl mrc_write$mchar,%eax
   movl %eax,  -16(%esp)  # stash funcall-oper in next closure slot
# emit-expr f259590
# emit-variable-ref
# env=((f259590 . -12) (f259590 . -8) (f259588 . 8) ((primitive-ref write-char) . 4) (f259588 . -20) (f259587 . -16) (f259588 . -12) (f259587 . -8) ((primitive-ref string->list) . 12) ((primitive-ref write-char) . 8) ((primitive-ref for-each) . 4) (f259554 . -28) (f259555 . -24) (f259556 . -20) (f259557 . -16) (f259558 . -12) (f259559 . -8) (f259560 . -4) (f259561 . 0))
# var=f259590
    movl -12(%esp), %eax  # stack load f259590
# end emit-variable-ref
    mov %eax, -20(%esp)    # arg f259590
# emit-expr f259588
# emit-variable-ref
# env=((f259590 . -12) (f259590 . -8) (f259588 . 8) ((primitive-ref write-char) . 4) (f259588 . -20) (f259587 . -16) (f259588 . -12) (f259587 . -8) ((primitive-ref string->list) . 12) ((primitive-ref write-char) . 8) ((primitive-ref for-each) . 4) (f259554 . -28) (f259555 . -24) (f259556 . -20) (f259557 . -16) (f259558 . -12) (f259559 . -8) (f259560 . -4) (f259561 . 0))
# var=f259588
    movl 6(%edi), %eax  # frame load f259588
# end emit-variable-ref
    mov %eax, -24(%esp)    # arg f259588
    movl -16(%esp), %edi   # load new closure to %edi
# emit-shift-args:  size=3   si=-16  delta=12
    mov -16(%esp), %ebx  # shift frame cell
    mov %ebx, -4(%esp)  # down to base
# emit-shift-args:  size=2   si=-20  delta=12
    mov -20(%esp), %ebx  # shift frame cell
    mov %ebx, -8(%esp)  # down to base
# emit-shift-args:  size=1   si=-24  delta=12
    mov -24(%esp), %ebx  # shift frame cell
    mov %ebx, -12(%esp)  # down to base
# emit-shift-args:  size=0   si=-28  delta=12
    movl $8,%eax   # save arg count
    jmp *-2(%edi)  # tail-funcall
    .align 4,0x90
_L_1577326:
    mov %eax, -28(%esp)    # arg (closure (f259590) ((primitive-ref write-char) f259588) (let ((f259590 f259590)) ((primitive-ref write-char) f259590 f259588)))
# emit-expr ((primitive-ref string->list) f259587)
# funcall
#    si   =-32
#    env  = ((f259588 . -20) (f259587 . -16) (f259588 . -12) (f259587 . -8) ((primitive-ref string->list) . 12) ((primitive-ref write-char) . 8) ((primitive-ref for-each) . 4) (f259554 . -28) (f259555 . -24) (f259556 . -20) (f259557 . -16) (f259558 . -12) (f259559 . -8) (f259560 . -4) (f259561 . 0))
#    expr = (funcall (primitive-ref string->list) f259587)
# emit-expr (primitive-ref string->list)
    .extern mrc_string$m$glist
    movl mrc_string$m$glist,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1577328"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1577328":
   movl %eax,  -40(%esp)  # stash funcall-oper in closure slot
# emit-expr f259587
# emit-variable-ref
# env=((f259588 . -20) (f259587 . -16) (f259588 . -12) (f259587 . -8) ((primitive-ref string->list) . 12) ((primitive-ref write-char) . 8) ((primitive-ref for-each) . 4) (f259554 . -28) (f259555 . -24) (f259556 . -20) (f259557 . -16) (f259558 . -12) (f259559 . -8) (f259560 . -4) (f259561 . 0))
# var=f259587
    movl -16(%esp), %eax  # stack load f259587
# end emit-variable-ref
    mov %eax, -44(%esp)  # arg f259587
    movl -40(%esp), %edi   # load new closure to %edi
    add $-32, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $32, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    mov %eax, -32(%esp)    # arg ((primitive-ref string->list) f259587)
    movl -24(%esp), %edi   # load new closure to %edi
# emit-shift-args:  size=3   si=-24  delta=20
    mov -24(%esp), %ebx  # shift frame cell
    mov %ebx, -4(%esp)  # down to base
# emit-shift-args:  size=2   si=-28  delta=20
    mov -28(%esp), %ebx  # shift frame cell
    mov %ebx, -8(%esp)  # down to base
# emit-shift-args:  size=1   si=-32  delta=20
    mov -32(%esp), %ebx  # shift frame cell
    mov %ebx, -12(%esp)  # down to base
# emit-shift-args:  size=0   si=-36  delta=20
    movl $8,%eax   # save arg count
    jmp *-2(%edi)  # tail-funcall
    .align 4,0x90
_L_1577323:
    movl -32(%esp), %ebx
    movl -36(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin (vector-set! f259555 0 (closure (f259585 f259586) ((primitive-ref write-char) f259554 (primitive-ref write-char)) (let ((f259585 f259585) (f259586 f259586)) (begin ((primitive-ref write-char) #\( f259586) ((vector-ref f259554 0) f259585 f259586) ((primitive-ref write-char) #\) f259586))))) (vector-set! f259554 0 (closure (f259583 f259584) ((primitive-ref write) (primitive-ref write-char) f259554 else (primitive-ref write-char) (primitive-ref write-char) (primitive-ref write-char) (primitive-ref write)) (let ((f259583 f259583) (f259584 f259584)) (begin ((primitive-ref write) (car f259583) f259584) (if (null? (cdr f259583)) #t (if (pair? (cdr f259583)) (begin ((primitive-ref write-char) #\space f259584) ((vector-ref f259554 0) (cdr f259583) f259584)) (begin ((primitive-ref write-char) #\space f259584) ((primitive-ref write-char) #\. f259584) ((primitive-ref write-char) #\space f259584) ((primitive-ref write) (cdr f259583) f259584)))))))))
# emit-begin
#   expr=(begin (vector-set! f259555 0 (closure (f259585 f259586) ((primitive-ref write-char) f259554 (primitive-ref write-char)) (let ((f259585 f259585) (f259586 f259586)) (begin ((primitive-ref write-char) #\( f259586) ((vector-ref f259554 0) f259585 f259586) ((primitive-ref write-char) #\) f259586))))) (vector-set! f259554 0 (closure (f259583 f259584) ((primitive-ref write) (primitive-ref write-char) f259554 else (primitive-ref write-char) (primitive-ref write-char) (primitive-ref write-char) (primitive-ref write)) (let ((f259583 f259583) (f259584 f259584)) (begin ((primitive-ref write) (car f259583) f259584) (if (null? (cdr f259583)) #t (if (pair? (cdr f259583)) (begin ((primitive-ref write-char) #\space f259584) ((vector-ref f259554 0) (cdr f259583) f259584)) (begin ((primitive-ref write-char) #\space f259584) ((primitive-ref write-char) #\. f259584) ((primitive-ref write-char) #\space f259584) ((primitive-ref write) (cdr f259583) f259584)))))))))
#   env=((f259554 . -28) (f259555 . -24) (f259556 . -20) (f259557 . -16) (f259558 . -12) (f259559 . -8) (f259560 . -4) (f259561 . 0))
# emit-expr (vector-set! f259555 0 (closure (f259585 f259586) ((primitive-ref write-char) f259554 (primitive-ref write-char)) (let ((f259585 f259585) (f259586 f259586)) (begin ((primitive-ref write-char) #\( f259586) ((vector-ref f259554 0) f259585 f259586) ((primitive-ref write-char) #\) f259586)))))
# emit-expr f259555
# emit-variable-ref
# env=((f259554 . -28) (f259555 . -24) (f259556 . -20) (f259557 . -16) (f259558 . -12) (f259559 . -8) (f259560 . -4) (f259561 . 0))
# var=f259555
    movl -24(%esp), %eax  # stack load f259555
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1577329
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1577329:
    movl %eax, -32(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1577330"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1577330:
# check bounds on vector index
    movl -32(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1577332
    cmp  $0,%eax
    jge _L_1577331
_L_1577332:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1577331:
    movl %eax, -36(%esp)
# emit-expr (closure (f259585 f259586) ((primitive-ref write-char) f259554 (primitive-ref write-char)) (let ((f259585 f259585) (f259586 f259586)) (begin ((primitive-ref write-char) #\( f259586) ((vector-ref f259554 0) f259585 f259586) ((primitive-ref write-char) #\) f259586))))
# emit-closure
# si = -40
# env = ((f259554 . -28) (f259555 . -24) (f259556 . -20) (f259557 . -16) (f259558 . -12) (f259559 . -8) (f259560 . -4) (f259561 . 0))
# expr = (closure (f259585 f259586) ((primitive-ref write-char) f259554 (primitive-ref write-char)) (let ((f259585 f259585) (f259586 f259586)) (begin ((primitive-ref write-char) #\( f259586) ((vector-ref f259554 0) f259585 f259586) ((primitive-ref write-char) #\) f259586))))
    movl $_L_1577333, 0(%ebp)  # closure label
# WARNING: free var (primitive-ref write-char) not defined in the environmnet
# emit-variable-ref
# env=((f259554 . -28) (f259555 . -24) (f259556 . -20) (f259557 . -16) (f259558 . -12) (f259559 . -8) (f259560 . -4) (f259561 . 0))
# var=f259554
    movl -28(%esp), %eax  # stack load f259554
# end emit-variable-ref
   movl  %eax, 8(%ebp)  # f259554
# WARNING: free var (primitive-ref write-char) not defined in the environmnet
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $16, %ebp     # bump ebp
    jmp _L_1577334            # jump around closure body
_L_1577333:
# check argument count
    cmp $8,%eax
    je _L_1577335
# invoke error handler eh_argcount
    .extern mrc_eh$uargcount
    movl mrc_eh$uargcount, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_1577335:
# emit-tail-expr
# si=-16
# env=((f259586 . -12) (f259585 . -8) ((primitive-ref write-char) . 12) (f259554 . 8) ((primitive-ref write-char) . 4) (f259554 . -28) (f259555 . -24) (f259556 . -20) (f259557 . -16) (f259558 . -12) (f259559 . -8) (f259560 . -4) (f259561 . 0))
# expr=(let ((f259585 f259585) (f259586 f259586)) (begin ((primitive-ref write-char) #\( f259586) ((vector-ref f259554 0) f259585 f259586) ((primitive-ref write-char) #\) f259586)))
# emit-tail-let
#  si   = -16
#  env  = ((f259586 . -12) (f259585 . -8) ((primitive-ref write-char) . 12) (f259554 . 8) ((primitive-ref write-char) . 4) (f259554 . -28) (f259555 . -24) (f259556 . -20) (f259557 . -16) (f259558 . -12) (f259559 . -8) (f259560 . -4) (f259561 . 0))
#  bindings = ((f259585 f259585) (f259586 f259586))
#  body = (begin ((primitive-ref write-char) #\( f259586) ((vector-ref f259554 0) f259585 f259586) ((primitive-ref write-char) #\) f259586))
# emit-expr f259585
# emit-variable-ref
# env=((f259586 . -12) (f259585 . -8) ((primitive-ref write-char) . 12) (f259554 . 8) ((primitive-ref write-char) . 4) (f259554 . -28) (f259555 . -24) (f259556 . -20) (f259557 . -16) (f259558 . -12) (f259559 . -8) (f259560 . -4) (f259561 . 0))
# var=f259585
    movl -8(%esp), %eax  # stack load f259585
# end emit-variable-ref
    movl %eax, -16(%esp)  # stack save
# emit-expr f259586
# emit-variable-ref
# env=((f259586 . -12) (f259585 . -8) ((primitive-ref write-char) . 12) (f259554 . 8) ((primitive-ref write-char) . 4) (f259554 . -28) (f259555 . -24) (f259556 . -20) (f259557 . -16) (f259558 . -12) (f259559 . -8) (f259560 . -4) (f259561 . 0))
# var=f259586
    movl -12(%esp), %eax  # stack load f259586
# end emit-variable-ref
    movl %eax, -20(%esp)  # stack save
# emit-tail-expr
# si=-24
# env=((f259586 . -20) (f259585 . -16) (f259586 . -12) (f259585 . -8) ((primitive-ref write-char) . 12) (f259554 . 8) ((primitive-ref write-char) . 4) (f259554 . -28) (f259555 . -24) (f259556 . -20) (f259557 . -16) (f259558 . -12) (f259559 . -8) (f259560 . -4) (f259561 . 0))
# expr=(begin ((primitive-ref write-char) #\( f259586) ((vector-ref f259554 0) f259585 f259586) ((primitive-ref write-char) #\) f259586))
# tail-begin (begin ((primitive-ref write-char) #\( f259586) ((vector-ref f259554 0) f259585 f259586) ((primitive-ref write-char) #\) f259586))
#   env=((f259586 . -20) (f259585 . -16) (f259586 . -12) (f259585 . -8) ((primitive-ref write-char) . 12) (f259554 . 8) ((primitive-ref write-char) . 4) (f259554 . -28) (f259555 . -24) (f259556 . -20) (f259557 . -16) (f259558 . -12) (f259559 . -8) (f259560 . -4) (f259561 . 0))
# emit-expr ((primitive-ref write-char) #\( f259586)
# funcall
#    si   =-24
#    env  = ((f259586 . -20) (f259585 . -16) (f259586 . -12) (f259585 . -8) ((primitive-ref write-char) . 12) (f259554 . 8) ((primitive-ref write-char) . 4) (f259554 . -28) (f259555 . -24) (f259556 . -20) (f259557 . -16) (f259558 . -12) (f259559 . -8) (f259560 . -4) (f259561 . 0))
#    expr = (funcall (primitive-ref write-char) #\( f259586)
# emit-expr (primitive-ref write-char)
    .extern mrc_write$mchar
    movl mrc_write$mchar,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1577336"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1577336":
   movl %eax,  -32(%esp)  # stash funcall-oper in closure slot
# emit-expr #\(
    movl $10255, %eax     # immed #\(
    mov %eax, -36(%esp)  # arg (
# emit-expr f259586
# emit-variable-ref
# env=((f259586 . -20) (f259585 . -16) (f259586 . -12) (f259585 . -8) ((primitive-ref write-char) . 12) (f259554 . 8) ((primitive-ref write-char) . 4) (f259554 . -28) (f259555 . -24) (f259556 . -20) (f259557 . -16) (f259558 . -12) (f259559 . -8) (f259560 . -4) (f259561 . 0))
# var=f259586
    movl -20(%esp), %eax  # stack load f259586
# end emit-variable-ref
    mov %eax, -40(%esp)  # arg f259586
    movl -32(%esp), %edi   # load new closure to %edi
    add $-24, %esp   # adjust base
    movl $8,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $24, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
# emit-tail-expr
# si=-24
# env=((f259586 . -20) (f259585 . -16) (f259586 . -12) (f259585 . -8) ((primitive-ref write-char) . 12) (f259554 . 8) ((primitive-ref write-char) . 4) (f259554 . -28) (f259555 . -24) (f259556 . -20) (f259557 . -16) (f259558 . -12) (f259559 . -8) (f259560 . -4) (f259561 . 0))
# expr=(begin ((vector-ref f259554 0) f259585 f259586) ((primitive-ref write-char) #\) f259586))
# tail-begin (begin ((vector-ref f259554 0) f259585 f259586) ((primitive-ref write-char) #\) f259586))
#   env=((f259586 . -20) (f259585 . -16) (f259586 . -12) (f259585 . -8) ((primitive-ref write-char) . 12) (f259554 . 8) ((primitive-ref write-char) . 4) (f259554 . -28) (f259555 . -24) (f259556 . -20) (f259557 . -16) (f259558 . -12) (f259559 . -8) (f259560 . -4) (f259561 . 0))
# emit-expr ((vector-ref f259554 0) f259585 f259586)
# funcall
#    si   =-24
#    env  = ((f259586 . -20) (f259585 . -16) (f259586 . -12) (f259585 . -8) ((primitive-ref write-char) . 12) (f259554 . 8) ((primitive-ref write-char) . 4) (f259554 . -28) (f259555 . -24) (f259556 . -20) (f259557 . -16) (f259558 . -12) (f259559 . -8) (f259560 . -4) (f259561 . 0))
#    expr = (funcall (vector-ref f259554 0) f259585 f259586)
# emit-expr (vector-ref f259554 0)
# emit-expr f259554
# emit-variable-ref
# env=((f259586 . -20) (f259585 . -16) (f259586 . -12) (f259585 . -8) ((primitive-ref write-char) . 12) (f259554 . 8) ((primitive-ref write-char) . 4) (f259554 . -28) (f259555 . -24) (f259556 . -20) (f259557 . -16) (f259558 . -12) (f259559 . -8) (f259560 . -4) (f259561 . 0))
# var=f259554
    movl 6(%edi), %eax  # frame load f259554
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1577337
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1577337:
    movl %eax, -32(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1577338"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1577338:
# check bounds on vector index
    movl -32(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1577340
    cmp  $0,%eax
    jge _L_1577339
_L_1577340:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1577339:
    movl -32(%esp), %esi
    movl -1(%eax,%esi), %eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1577341"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1577341":
   movl %eax,  -32(%esp)  # stash funcall-oper in closure slot
# emit-expr f259585
# emit-variable-ref
# env=((f259586 . -20) (f259585 . -16) (f259586 . -12) (f259585 . -8) ((primitive-ref write-char) . 12) (f259554 . 8) ((primitive-ref write-char) . 4) (f259554 . -28) (f259555 . -24) (f259556 . -20) (f259557 . -16) (f259558 . -12) (f259559 . -8) (f259560 . -4) (f259561 . 0))
# var=f259585
    movl -16(%esp), %eax  # stack load f259585
# end emit-variable-ref
    mov %eax, -36(%esp)  # arg f259585
# emit-expr f259586
# emit-variable-ref
# env=((f259586 . -20) (f259585 . -16) (f259586 . -12) (f259585 . -8) ((primitive-ref write-char) . 12) (f259554 . 8) ((primitive-ref write-char) . 4) (f259554 . -28) (f259555 . -24) (f259556 . -20) (f259557 . -16) (f259558 . -12) (f259559 . -8) (f259560 . -4) (f259561 . 0))
# var=f259586
    movl -20(%esp), %eax  # stack load f259586
# end emit-variable-ref
    mov %eax, -40(%esp)  # arg f259586
    movl -32(%esp), %edi   # load new closure to %edi
    add $-24, %esp   # adjust base
    movl $8,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $24, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
# emit-tail-expr
# si=-24
# env=((f259586 . -20) (f259585 . -16) (f259586 . -12) (f259585 . -8) ((primitive-ref write-char) . 12) (f259554 . 8) ((primitive-ref write-char) . 4) (f259554 . -28) (f259555 . -24) (f259556 . -20) (f259557 . -16) (f259558 . -12) (f259559 . -8) (f259560 . -4) (f259561 . 0))
# expr=(begin ((primitive-ref write-char) #\) f259586))
# tail-begin (begin ((primitive-ref write-char) #\) f259586))
#   env=((f259586 . -20) (f259585 . -16) (f259586 . -12) (f259585 . -8) ((primitive-ref write-char) . 12) (f259554 . 8) ((primitive-ref write-char) . 4) (f259554 . -28) (f259555 . -24) (f259556 . -20) (f259557 . -16) (f259558 . -12) (f259559 . -8) (f259560 . -4) (f259561 . 0))
# emit-tail-expr
# si=-24
# env=((f259586 . -20) (f259585 . -16) (f259586 . -12) (f259585 . -8) ((primitive-ref write-char) . 12) (f259554 . 8) ((primitive-ref write-char) . 4) (f259554 . -28) (f259555 . -24) (f259556 . -20) (f259557 . -16) (f259558 . -12) (f259559 . -8) (f259560 . -4) (f259561 . 0))
# expr=((primitive-ref write-char) #\) f259586)
# emit-tail-funcall
#    si   =-24
#    env  = ((f259586 . -20) (f259585 . -16) (f259586 . -12) (f259585 . -8) ((primitive-ref write-char) . 12) (f259554 . 8) ((primitive-ref write-char) . 4) (f259554 . -28) (f259555 . -24) (f259556 . -20) (f259557 . -16) (f259558 . -12) (f259559 . -8) (f259560 . -4) (f259561 . 0))
#    expr = (funcall (primitive-ref write-char) #\) f259586)
# emit-expr (primitive-ref write-char)
    .extern mrc_write$mchar
    movl mrc_write$mchar,%eax
   movl %eax,  -24(%esp)  # stash funcall-oper in next closure slot
# emit-expr #\)
    movl $10511, %eax     # immed #\)
    mov %eax, -28(%esp)    # arg )
# emit-expr f259586
# emit-variable-ref
# env=((f259586 . -20) (f259585 . -16) (f259586 . -12) (f259585 . -8) ((primitive-ref write-char) . 12) (f259554 . 8) ((primitive-ref write-char) . 4) (f259554 . -28) (f259555 . -24) (f259556 . -20) (f259557 . -16) (f259558 . -12) (f259559 . -8) (f259560 . -4) (f259561 . 0))
# var=f259586
    movl -20(%esp), %eax  # stack load f259586
# end emit-variable-ref
    mov %eax, -32(%esp)    # arg f259586
    movl -24(%esp), %edi   # load new closure to %edi
# emit-shift-args:  size=3   si=-24  delta=20
    mov -24(%esp), %ebx  # shift frame cell
    mov %ebx, -4(%esp)  # down to base
# emit-shift-args:  size=2   si=-28  delta=20
    mov -28(%esp), %ebx  # shift frame cell
    mov %ebx, -8(%esp)  # down to base
# emit-shift-args:  size=1   si=-32  delta=20
    mov -32(%esp), %ebx  # shift frame cell
    mov %ebx, -12(%esp)  # down to base
# emit-shift-args:  size=0   si=-36  delta=20
    movl $8,%eax   # save arg count
    jmp *-2(%edi)  # tail-funcall
     ret   # return thru stack
    .align 4,0x90
_L_1577334:
    movl -32(%esp), %ebx
    movl -36(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin (vector-set! f259554 0 (closure (f259583 f259584) ((primitive-ref write) (primitive-ref write-char) f259554 else (primitive-ref write-char) (primitive-ref write-char) (primitive-ref write-char) (primitive-ref write)) (let ((f259583 f259583) (f259584 f259584)) (begin ((primitive-ref write) (car f259583) f259584) (if (null? (cdr f259583)) #t (if (pair? (cdr f259583)) (begin ((primitive-ref write-char) #\space f259584) ((vector-ref f259554 0) (cdr f259583) f259584)) (begin ((primitive-ref write-char) #\space f259584) ((primitive-ref write-char) #\. f259584) ((primitive-ref write-char) #\space f259584) ((primitive-ref write) (cdr f259583) f259584)))))))))
# emit-begin
#   expr=(begin (vector-set! f259554 0 (closure (f259583 f259584) ((primitive-ref write) (primitive-ref write-char) f259554 else (primitive-ref write-char) (primitive-ref write-char) (primitive-ref write-char) (primitive-ref write)) (let ((f259583 f259583) (f259584 f259584)) (begin ((primitive-ref write) (car f259583) f259584) (if (null? (cdr f259583)) #t (if (pair? (cdr f259583)) (begin ((primitive-ref write-char) #\space f259584) ((vector-ref f259554 0) (cdr f259583) f259584)) (begin ((primitive-ref write-char) #\space f259584) ((primitive-ref write-char) #\. f259584) ((primitive-ref write-char) #\space f259584) ((primitive-ref write) (cdr f259583) f259584)))))))))
#   env=((f259554 . -28) (f259555 . -24) (f259556 . -20) (f259557 . -16) (f259558 . -12) (f259559 . -8) (f259560 . -4) (f259561 . 0))
# emit-expr (vector-set! f259554 0 (closure (f259583 f259584) ((primitive-ref write) (primitive-ref write-char) f259554 else (primitive-ref write-char) (primitive-ref write-char) (primitive-ref write-char) (primitive-ref write)) (let ((f259583 f259583) (f259584 f259584)) (begin ((primitive-ref write) (car f259583) f259584) (if (null? (cdr f259583)) #t (if (pair? (cdr f259583)) (begin ((primitive-ref write-char) #\space f259584) ((vector-ref f259554 0) (cdr f259583) f259584)) (begin ((primitive-ref write-char) #\space f259584) ((primitive-ref write-char) #\. f259584) ((primitive-ref write-char) #\space f259584) ((primitive-ref write) (cdr f259583) f259584))))))))
# emit-expr f259554
# emit-variable-ref
# env=((f259554 . -28) (f259555 . -24) (f259556 . -20) (f259557 . -16) (f259558 . -12) (f259559 . -8) (f259560 . -4) (f259561 . 0))
# var=f259554
    movl -28(%esp), %eax  # stack load f259554
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1577342
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1577342:
    movl %eax, -32(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1577343"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1577343:
# check bounds on vector index
    movl -32(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1577345
    cmp  $0,%eax
    jge _L_1577344
_L_1577345:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1577344:
    movl %eax, -36(%esp)
# emit-expr (closure (f259583 f259584) ((primitive-ref write) (primitive-ref write-char) f259554 else (primitive-ref write-char) (primitive-ref write-char) (primitive-ref write-char) (primitive-ref write)) (let ((f259583 f259583) (f259584 f259584)) (begin ((primitive-ref write) (car f259583) f259584) (if (null? (cdr f259583)) #t (if (pair? (cdr f259583)) (begin ((primitive-ref write-char) #\space f259584) ((vector-ref f259554 0) (cdr f259583) f259584)) (begin ((primitive-ref write-char) #\space f259584) ((primitive-ref write-char) #\. f259584) ((primitive-ref write-char) #\space f259584) ((primitive-ref write) (cdr f259583) f259584)))))))
# emit-closure
# si = -40
# env = ((f259554 . -28) (f259555 . -24) (f259556 . -20) (f259557 . -16) (f259558 . -12) (f259559 . -8) (f259560 . -4) (f259561 . 0))
# expr = (closure (f259583 f259584) ((primitive-ref write) (primitive-ref write-char) f259554 else (primitive-ref write-char) (primitive-ref write-char) (primitive-ref write-char) (primitive-ref write)) (let ((f259583 f259583) (f259584 f259584)) (begin ((primitive-ref write) (car f259583) f259584) (if (null? (cdr f259583)) #t (if (pair? (cdr f259583)) (begin ((primitive-ref write-char) #\space f259584) ((vector-ref f259554 0) (cdr f259583) f259584)) (begin ((primitive-ref write-char) #\space f259584) ((primitive-ref write-char) #\. f259584) ((primitive-ref write-char) #\space f259584) ((primitive-ref write) (cdr f259583) f259584)))))))
    movl $_L_1577346, 0(%ebp)  # closure label
# WARNING: free var (primitive-ref write) not defined in the environmnet
# WARNING: free var (primitive-ref write-char) not defined in the environmnet
# emit-variable-ref
# env=((f259554 . -28) (f259555 . -24) (f259556 . -20) (f259557 . -16) (f259558 . -12) (f259559 . -8) (f259560 . -4) (f259561 . 0))
# var=f259554
    movl -28(%esp), %eax  # stack load f259554
# end emit-variable-ref
   movl  %eax, 12(%ebp)  # f259554
# WARNING: free var else not defined in the environmnet
# WARNING: free var (primitive-ref write-char) not defined in the environmnet
# WARNING: free var (primitive-ref write-char) not defined in the environmnet
# WARNING: free var (primitive-ref write-char) not defined in the environmnet
# WARNING: free var (primitive-ref write) not defined in the environmnet
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $40, %ebp     # bump ebp
    jmp _L_1577347            # jump around closure body
_L_1577346:
# check argument count
    cmp $8,%eax
    je _L_1577348
# invoke error handler eh_argcount
    .extern mrc_eh$uargcount
    movl mrc_eh$uargcount, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_1577348:
# emit-tail-expr
# si=-16
# env=((f259584 . -12) (f259583 . -8) ((primitive-ref write) . 32) ((primitive-ref write-char) . 28) ((primitive-ref write-char) . 24) ((primitive-ref write-char) . 20) (else . 16) (f259554 . 12) ((primitive-ref write-char) . 8) ((primitive-ref write) . 4) (f259554 . -28) (f259555 . -24) (f259556 . -20) (f259557 . -16) (f259558 . -12) (f259559 . -8) (f259560 . -4) (f259561 . 0))
# expr=(let ((f259583 f259583) (f259584 f259584)) (begin ((primitive-ref write) (car f259583) f259584) (if (null? (cdr f259583)) #t (if (pair? (cdr f259583)) (begin ((primitive-ref write-char) #\space f259584) ((vector-ref f259554 0) (cdr f259583) f259584)) (begin ((primitive-ref write-char) #\space f259584) ((primitive-ref write-char) #\. f259584) ((primitive-ref write-char) #\space f259584) ((primitive-ref write) (cdr f259583) f259584))))))
# emit-tail-let
#  si   = -16
#  env  = ((f259584 . -12) (f259583 . -8) ((primitive-ref write) . 32) ((primitive-ref write-char) . 28) ((primitive-ref write-char) . 24) ((primitive-ref write-char) . 20) (else . 16) (f259554 . 12) ((primitive-ref write-char) . 8) ((primitive-ref write) . 4) (f259554 . -28) (f259555 . -24) (f259556 . -20) (f259557 . -16) (f259558 . -12) (f259559 . -8) (f259560 . -4) (f259561 . 0))
#  bindings = ((f259583 f259583) (f259584 f259584))
#  body = (begin ((primitive-ref write) (car f259583) f259584) (if (null? (cdr f259583)) #t (if (pair? (cdr f259583)) (begin ((primitive-ref write-char) #\space f259584) ((vector-ref f259554 0) (cdr f259583) f259584)) (begin ((primitive-ref write-char) #\space f259584) ((primitive-ref write-char) #\. f259584) ((primitive-ref write-char) #\space f259584) ((primitive-ref write) (cdr f259583) f259584)))))
# emit-expr f259583
# emit-variable-ref
# env=((f259584 . -12) (f259583 . -8) ((primitive-ref write) . 32) ((primitive-ref write-char) . 28) ((primitive-ref write-char) . 24) ((primitive-ref write-char) . 20) (else . 16) (f259554 . 12) ((primitive-ref write-char) . 8) ((primitive-ref write) . 4) (f259554 . -28) (f259555 . -24) (f259556 . -20) (f259557 . -16) (f259558 . -12) (f259559 . -8) (f259560 . -4) (f259561 . 0))
# var=f259583
    movl -8(%esp), %eax  # stack load f259583
# end emit-variable-ref
    movl %eax, -16(%esp)  # stack save
# emit-expr f259584
# emit-variable-ref
# env=((f259584 . -12) (f259583 . -8) ((primitive-ref write) . 32) ((primitive-ref write-char) . 28) ((primitive-ref write-char) . 24) ((primitive-ref write-char) . 20) (else . 16) (f259554 . 12) ((primitive-ref write-char) . 8) ((primitive-ref write) . 4) (f259554 . -28) (f259555 . -24) (f259556 . -20) (f259557 . -16) (f259558 . -12) (f259559 . -8) (f259560 . -4) (f259561 . 0))
# var=f259584
    movl -12(%esp), %eax  # stack load f259584
# end emit-variable-ref
    movl %eax, -20(%esp)  # stack save
# emit-tail-expr
# si=-24
# env=((f259584 . -20) (f259583 . -16) (f259584 . -12) (f259583 . -8) ((primitive-ref write) . 32) ((primitive-ref write-char) . 28) ((primitive-ref write-char) . 24) ((primitive-ref write-char) . 20) (else . 16) (f259554 . 12) ((primitive-ref write-char) . 8) ((primitive-ref write) . 4) (f259554 . -28) (f259555 . -24) (f259556 . -20) (f259557 . -16) (f259558 . -12) (f259559 . -8) (f259560 . -4) (f259561 . 0))
# expr=(begin ((primitive-ref write) (car f259583) f259584) (if (null? (cdr f259583)) #t (if (pair? (cdr f259583)) (begin ((primitive-ref write-char) #\space f259584) ((vector-ref f259554 0) (cdr f259583) f259584)) (begin ((primitive-ref write-char) #\space f259584) ((primitive-ref write-char) #\. f259584) ((primitive-ref write-char) #\space f259584) ((primitive-ref write) (cdr f259583) f259584)))))
# tail-begin (begin ((primitive-ref write) (car f259583) f259584) (if (null? (cdr f259583)) #t (if (pair? (cdr f259583)) (begin ((primitive-ref write-char) #\space f259584) ((vector-ref f259554 0) (cdr f259583) f259584)) (begin ((primitive-ref write-char) #\space f259584) ((primitive-ref write-char) #\. f259584) ((primitive-ref write-char) #\space f259584) ((primitive-ref write) (cdr f259583) f259584)))))
#   env=((f259584 . -20) (f259583 . -16) (f259584 . -12) (f259583 . -8) ((primitive-ref write) . 32) ((primitive-ref write-char) . 28) ((primitive-ref write-char) . 24) ((primitive-ref write-char) . 20) (else . 16) (f259554 . 12) ((primitive-ref write-char) . 8) ((primitive-ref write) . 4) (f259554 . -28) (f259555 . -24) (f259556 . -20) (f259557 . -16) (f259558 . -12) (f259559 . -8) (f259560 . -4) (f259561 . 0))
# emit-expr ((primitive-ref write) (car f259583) f259584)
# funcall
#    si   =-24
#    env  = ((f259584 . -20) (f259583 . -16) (f259584 . -12) (f259583 . -8) ((primitive-ref write) . 32) ((primitive-ref write-char) . 28) ((primitive-ref write-char) . 24) ((primitive-ref write-char) . 20) (else . 16) (f259554 . 12) ((primitive-ref write-char) . 8) ((primitive-ref write) . 4) (f259554 . -28) (f259555 . -24) (f259556 . -20) (f259557 . -16) (f259558 . -12) (f259559 . -8) (f259560 . -4) (f259561 . 0))
#    expr = (funcall (primitive-ref write) (car f259583) f259584)
# emit-expr (primitive-ref write)
    .extern mrc_write
    movl mrc_write,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1577349"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1577349":
   movl %eax,  -32(%esp)  # stash funcall-oper in closure slot
# emit-expr (car f259583)
# emit-expr f259583
# emit-variable-ref
# env=((f259584 . -20) (f259583 . -16) (f259584 . -12) (f259583 . -8) ((primitive-ref write) . 32) ((primitive-ref write-char) . 28) ((primitive-ref write-char) . 24) ((primitive-ref write-char) . 20) (else . 16) (f259554 . 12) ((primitive-ref write-char) . 8) ((primitive-ref write) . 4) (f259554 . -28) (f259555 . -24) (f259556 . -20) (f259557 . -16) (f259558 . -12) (f259559 . -8) (f259560 . -4) (f259561 . 0))
# var=f259583
    movl -16(%esp), %eax  # stack load f259583
# end emit-variable-ref
# check the argument is a pair
    movl %eax,%ebx
    and $7, %bl
    cmp $1, %bl
    je _L_1577350
# invoke error handler eh_pair
    .extern mrc_eh$upair
    movl mrc_eh$upair, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $108,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1577350:
    movl -1(%eax), %eax
    mov %eax, -36(%esp)  # arg (car f259583)
# emit-expr f259584
# emit-variable-ref
# env=((f259584 . -20) (f259583 . -16) (f259584 . -12) (f259583 . -8) ((primitive-ref write) . 32) ((primitive-ref write-char) . 28) ((primitive-ref write-char) . 24) ((primitive-ref write-char) . 20) (else . 16) (f259554 . 12) ((primitive-ref write-char) . 8) ((primitive-ref write) . 4) (f259554 . -28) (f259555 . -24) (f259556 . -20) (f259557 . -16) (f259558 . -12) (f259559 . -8) (f259560 . -4) (f259561 . 0))
# var=f259584
    movl -20(%esp), %eax  # stack load f259584
# end emit-variable-ref
    mov %eax, -40(%esp)  # arg f259584
    movl -32(%esp), %edi   # load new closure to %edi
    add $-24, %esp   # adjust base
    movl $8,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $24, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
# emit-tail-expr
# si=-24
# env=((f259584 . -20) (f259583 . -16) (f259584 . -12) (f259583 . -8) ((primitive-ref write) . 32) ((primitive-ref write-char) . 28) ((primitive-ref write-char) . 24) ((primitive-ref write-char) . 20) (else . 16) (f259554 . 12) ((primitive-ref write-char) . 8) ((primitive-ref write) . 4) (f259554 . -28) (f259555 . -24) (f259556 . -20) (f259557 . -16) (f259558 . -12) (f259559 . -8) (f259560 . -4) (f259561 . 0))
# expr=(begin (if (null? (cdr f259583)) #t (if (pair? (cdr f259583)) (begin ((primitive-ref write-char) #\space f259584) ((vector-ref f259554 0) (cdr f259583) f259584)) (begin ((primitive-ref write-char) #\space f259584) ((primitive-ref write-char) #\. f259584) ((primitive-ref write-char) #\space f259584) ((primitive-ref write) (cdr f259583) f259584)))))
# tail-begin (begin (if (null? (cdr f259583)) #t (if (pair? (cdr f259583)) (begin ((primitive-ref write-char) #\space f259584) ((vector-ref f259554 0) (cdr f259583) f259584)) (begin ((primitive-ref write-char) #\space f259584) ((primitive-ref write-char) #\. f259584) ((primitive-ref write-char) #\space f259584) ((primitive-ref write) (cdr f259583) f259584)))))
#   env=((f259584 . -20) (f259583 . -16) (f259584 . -12) (f259583 . -8) ((primitive-ref write) . 32) ((primitive-ref write-char) . 28) ((primitive-ref write-char) . 24) ((primitive-ref write-char) . 20) (else . 16) (f259554 . 12) ((primitive-ref write-char) . 8) ((primitive-ref write) . 4) (f259554 . -28) (f259555 . -24) (f259556 . -20) (f259557 . -16) (f259558 . -12) (f259559 . -8) (f259560 . -4) (f259561 . 0))
# emit-tail-expr
# si=-24
# env=((f259584 . -20) (f259583 . -16) (f259584 . -12) (f259583 . -8) ((primitive-ref write) . 32) ((primitive-ref write-char) . 28) ((primitive-ref write-char) . 24) ((primitive-ref write-char) . 20) (else . 16) (f259554 . 12) ((primitive-ref write-char) . 8) ((primitive-ref write) . 4) (f259554 . -28) (f259555 . -24) (f259556 . -20) (f259557 . -16) (f259558 . -12) (f259559 . -8) (f259560 . -4) (f259561 . 0))
# expr=(if (null? (cdr f259583)) #t (if (pair? (cdr f259583)) (begin ((primitive-ref write-char) #\space f259584) ((vector-ref f259554 0) (cdr f259583) f259584)) (begin ((primitive-ref write-char) #\space f259584) ((primitive-ref write-char) #\. f259584) ((primitive-ref write-char) #\space f259584) ((primitive-ref write) (cdr f259583) f259584))))
# emit-expr (null? (cdr f259583))
# emit-expr (cdr f259583)
# emit-expr f259583
# emit-variable-ref
# env=((f259584 . -20) (f259583 . -16) (f259584 . -12) (f259583 . -8) ((primitive-ref write) . 32) ((primitive-ref write-char) . 28) ((primitive-ref write-char) . 24) ((primitive-ref write-char) . 20) (else . 16) (f259554 . 12) ((primitive-ref write-char) . 8) ((primitive-ref write) . 4) (f259554 . -28) (f259555 . -24) (f259556 . -20) (f259557 . -16) (f259558 . -12) (f259559 . -8) (f259560 . -4) (f259561 . 0))
# var=f259583
    movl -16(%esp), %eax  # stack load f259583
# end emit-variable-ref
# check the argument is a pair
    movl %eax,%ebx
    and $7, %bl
    cmp $1, %bl
    je _L_1577353
# invoke error handler eh_pair
    .extern mrc_eh$upair
    movl mrc_eh$upair, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $112,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1577353:
    movl 3(%eax), %eax
    cmp $63, %eax
    mov $0, %eax
    sete %al
    movzbl %al, %eax
    sal $6, %al
    or $47, %al
    cmp $47, %al
    je _L_1577351
# emit-tail-expr
# si=-24
# env=((f259584 . -20) (f259583 . -16) (f259584 . -12) (f259583 . -8) ((primitive-ref write) . 32) ((primitive-ref write-char) . 28) ((primitive-ref write-char) . 24) ((primitive-ref write-char) . 20) (else . 16) (f259554 . 12) ((primitive-ref write-char) . 8) ((primitive-ref write) . 4) (f259554 . -28) (f259555 . -24) (f259556 . -20) (f259557 . -16) (f259558 . -12) (f259559 . -8) (f259560 . -4) (f259561 . 0))
# expr=#t
    movl $111, %eax     # immed #t
    ret                  # immediate tail return
    jmp _L_1577352
_L_1577351:
# emit-tail-expr
# si=-24
# env=((f259584 . -20) (f259583 . -16) (f259584 . -12) (f259583 . -8) ((primitive-ref write) . 32) ((primitive-ref write-char) . 28) ((primitive-ref write-char) . 24) ((primitive-ref write-char) . 20) (else . 16) (f259554 . 12) ((primitive-ref write-char) . 8) ((primitive-ref write) . 4) (f259554 . -28) (f259555 . -24) (f259556 . -20) (f259557 . -16) (f259558 . -12) (f259559 . -8) (f259560 . -4) (f259561 . 0))
# expr=(if (pair? (cdr f259583)) (begin ((primitive-ref write-char) #\space f259584) ((vector-ref f259554 0) (cdr f259583) f259584)) (begin ((primitive-ref write-char) #\space f259584) ((primitive-ref write-char) #\. f259584) ((primitive-ref write-char) #\space f259584) ((primitive-ref write) (cdr f259583) f259584)))
# emit-expr (pair? (cdr f259583))
# emit-expr (cdr f259583)
# emit-expr f259583
# emit-variable-ref
# env=((f259584 . -20) (f259583 . -16) (f259584 . -12) (f259583 . -8) ((primitive-ref write) . 32) ((primitive-ref write-char) . 28) ((primitive-ref write-char) . 24) ((primitive-ref write-char) . 20) (else . 16) (f259554 . 12) ((primitive-ref write-char) . 8) ((primitive-ref write) . 4) (f259554 . -28) (f259555 . -24) (f259556 . -20) (f259557 . -16) (f259558 . -12) (f259559 . -8) (f259560 . -4) (f259561 . 0))
# var=f259583
    movl -16(%esp), %eax  # stack load f259583
# end emit-variable-ref
# check the argument is a pair
    movl %eax,%ebx
    and $7, %bl
    cmp $1, %bl
    je _L_1577356
# invoke error handler eh_pair
    .extern mrc_eh$upair
    movl mrc_eh$upair, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $112,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1577356:
    movl 3(%eax), %eax
    and $7, %al
    cmp $1, %al
    sete %al
    movzbl %al, %eax
    sal $6, %al
    or $47, %al
    cmp $47, %al
    je _L_1577354
# emit-tail-expr
# si=-24
# env=((f259584 . -20) (f259583 . -16) (f259584 . -12) (f259583 . -8) ((primitive-ref write) . 32) ((primitive-ref write-char) . 28) ((primitive-ref write-char) . 24) ((primitive-ref write-char) . 20) (else . 16) (f259554 . 12) ((primitive-ref write-char) . 8) ((primitive-ref write) . 4) (f259554 . -28) (f259555 . -24) (f259556 . -20) (f259557 . -16) (f259558 . -12) (f259559 . -8) (f259560 . -4) (f259561 . 0))
# expr=(begin ((primitive-ref write-char) #\space f259584) ((vector-ref f259554 0) (cdr f259583) f259584))
# tail-begin (begin ((primitive-ref write-char) #\space f259584) ((vector-ref f259554 0) (cdr f259583) f259584))
#   env=((f259584 . -20) (f259583 . -16) (f259584 . -12) (f259583 . -8) ((primitive-ref write) . 32) ((primitive-ref write-char) . 28) ((primitive-ref write-char) . 24) ((primitive-ref write-char) . 20) (else . 16) (f259554 . 12) ((primitive-ref write-char) . 8) ((primitive-ref write) . 4) (f259554 . -28) (f259555 . -24) (f259556 . -20) (f259557 . -16) (f259558 . -12) (f259559 . -8) (f259560 . -4) (f259561 . 0))
# emit-expr ((primitive-ref write-char) #\space f259584)
# funcall
#    si   =-24
#    env  = ((f259584 . -20) (f259583 . -16) (f259584 . -12) (f259583 . -8) ((primitive-ref write) . 32) ((primitive-ref write-char) . 28) ((primitive-ref write-char) . 24) ((primitive-ref write-char) . 20) (else . 16) (f259554 . 12) ((primitive-ref write-char) . 8) ((primitive-ref write) . 4) (f259554 . -28) (f259555 . -24) (f259556 . -20) (f259557 . -16) (f259558 . -12) (f259559 . -8) (f259560 . -4) (f259561 . 0))
#    expr = (funcall (primitive-ref write-char) #\space f259584)
# emit-expr (primitive-ref write-char)
    .extern mrc_write$mchar
    movl mrc_write$mchar,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1577357"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1577357":
   movl %eax,  -32(%esp)  # stash funcall-oper in closure slot
# emit-expr #\space
    movl $8207, %eax     # immed #\space
    mov %eax, -36(%esp)  # arg  
# emit-expr f259584
# emit-variable-ref
# env=((f259584 . -20) (f259583 . -16) (f259584 . -12) (f259583 . -8) ((primitive-ref write) . 32) ((primitive-ref write-char) . 28) ((primitive-ref write-char) . 24) ((primitive-ref write-char) . 20) (else . 16) (f259554 . 12) ((primitive-ref write-char) . 8) ((primitive-ref write) . 4) (f259554 . -28) (f259555 . -24) (f259556 . -20) (f259557 . -16) (f259558 . -12) (f259559 . -8) (f259560 . -4) (f259561 . 0))
# var=f259584
    movl -20(%esp), %eax  # stack load f259584
# end emit-variable-ref
    mov %eax, -40(%esp)  # arg f259584
    movl -32(%esp), %edi   # load new closure to %edi
    add $-24, %esp   # adjust base
    movl $8,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $24, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
# emit-tail-expr
# si=-24
# env=((f259584 . -20) (f259583 . -16) (f259584 . -12) (f259583 . -8) ((primitive-ref write) . 32) ((primitive-ref write-char) . 28) ((primitive-ref write-char) . 24) ((primitive-ref write-char) . 20) (else . 16) (f259554 . 12) ((primitive-ref write-char) . 8) ((primitive-ref write) . 4) (f259554 . -28) (f259555 . -24) (f259556 . -20) (f259557 . -16) (f259558 . -12) (f259559 . -8) (f259560 . -4) (f259561 . 0))
# expr=(begin ((vector-ref f259554 0) (cdr f259583) f259584))
# tail-begin (begin ((vector-ref f259554 0) (cdr f259583) f259584))
#   env=((f259584 . -20) (f259583 . -16) (f259584 . -12) (f259583 . -8) ((primitive-ref write) . 32) ((primitive-ref write-char) . 28) ((primitive-ref write-char) . 24) ((primitive-ref write-char) . 20) (else . 16) (f259554 . 12) ((primitive-ref write-char) . 8) ((primitive-ref write) . 4) (f259554 . -28) (f259555 . -24) (f259556 . -20) (f259557 . -16) (f259558 . -12) (f259559 . -8) (f259560 . -4) (f259561 . 0))
# emit-tail-expr
# si=-24
# env=((f259584 . -20) (f259583 . -16) (f259584 . -12) (f259583 . -8) ((primitive-ref write) . 32) ((primitive-ref write-char) . 28) ((primitive-ref write-char) . 24) ((primitive-ref write-char) . 20) (else . 16) (f259554 . 12) ((primitive-ref write-char) . 8) ((primitive-ref write) . 4) (f259554 . -28) (f259555 . -24) (f259556 . -20) (f259557 . -16) (f259558 . -12) (f259559 . -8) (f259560 . -4) (f259561 . 0))
# expr=((vector-ref f259554 0) (cdr f259583) f259584)
# emit-tail-funcall
#    si   =-24
#    env  = ((f259584 . -20) (f259583 . -16) (f259584 . -12) (f259583 . -8) ((primitive-ref write) . 32) ((primitive-ref write-char) . 28) ((primitive-ref write-char) . 24) ((primitive-ref write-char) . 20) (else . 16) (f259554 . 12) ((primitive-ref write-char) . 8) ((primitive-ref write) . 4) (f259554 . -28) (f259555 . -24) (f259556 . -20) (f259557 . -16) (f259558 . -12) (f259559 . -8) (f259560 . -4) (f259561 . 0))
#    expr = (funcall (vector-ref f259554 0) (cdr f259583) f259584)
# emit-expr (vector-ref f259554 0)
# emit-expr f259554
# emit-variable-ref
# env=((f259584 . -20) (f259583 . -16) (f259584 . -12) (f259583 . -8) ((primitive-ref write) . 32) ((primitive-ref write-char) . 28) ((primitive-ref write-char) . 24) ((primitive-ref write-char) . 20) (else . 16) (f259554 . 12) ((primitive-ref write-char) . 8) ((primitive-ref write) . 4) (f259554 . -28) (f259555 . -24) (f259556 . -20) (f259557 . -16) (f259558 . -12) (f259559 . -8) (f259560 . -4) (f259561 . 0))
# var=f259554
    movl 10(%edi), %eax  # frame load f259554
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1577358
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1577358:
    movl %eax, -24(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1577359"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1577359:
# check bounds on vector index
    movl -24(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1577361
    cmp  $0,%eax
    jge _L_1577360
_L_1577361:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1577360:
    movl -24(%esp), %esi
    movl -1(%eax,%esi), %eax
   movl %eax,  -24(%esp)  # stash funcall-oper in next closure slot
# emit-expr (cdr f259583)
# emit-expr f259583
# emit-variable-ref
# env=((f259584 . -20) (f259583 . -16) (f259584 . -12) (f259583 . -8) ((primitive-ref write) . 32) ((primitive-ref write-char) . 28) ((primitive-ref write-char) . 24) ((primitive-ref write-char) . 20) (else . 16) (f259554 . 12) ((primitive-ref write-char) . 8) ((primitive-ref write) . 4) (f259554 . -28) (f259555 . -24) (f259556 . -20) (f259557 . -16) (f259558 . -12) (f259559 . -8) (f259560 . -4) (f259561 . 0))
# var=f259583
    movl -16(%esp), %eax  # stack load f259583
# end emit-variable-ref
# check the argument is a pair
    movl %eax,%ebx
    and $7, %bl
    cmp $1, %bl
    je _L_1577362
# invoke error handler eh_pair
    .extern mrc_eh$upair
    movl mrc_eh$upair, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $112,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1577362:
    movl 3(%eax), %eax
    mov %eax, -28(%esp)    # arg (cdr f259583)
# emit-expr f259584
# emit-variable-ref
# env=((f259584 . -20) (f259583 . -16) (f259584 . -12) (f259583 . -8) ((primitive-ref write) . 32) ((primitive-ref write-char) . 28) ((primitive-ref write-char) . 24) ((primitive-ref write-char) . 20) (else . 16) (f259554 . 12) ((primitive-ref write-char) . 8) ((primitive-ref write) . 4) (f259554 . -28) (f259555 . -24) (f259556 . -20) (f259557 . -16) (f259558 . -12) (f259559 . -8) (f259560 . -4) (f259561 . 0))
# var=f259584
    movl -20(%esp), %eax  # stack load f259584
# end emit-variable-ref
    mov %eax, -32(%esp)    # arg f259584
    movl -24(%esp), %edi   # load new closure to %edi
# emit-shift-args:  size=3   si=-24  delta=20
    mov -24(%esp), %ebx  # shift frame cell
    mov %ebx, -4(%esp)  # down to base
# emit-shift-args:  size=2   si=-28  delta=20
    mov -28(%esp), %ebx  # shift frame cell
    mov %ebx, -8(%esp)  # down to base
# emit-shift-args:  size=1   si=-32  delta=20
    mov -32(%esp), %ebx  # shift frame cell
    mov %ebx, -12(%esp)  # down to base
# emit-shift-args:  size=0   si=-36  delta=20
    movl $8,%eax   # save arg count
    jmp *-2(%edi)  # tail-funcall
     ret   # return thru stack
    jmp _L_1577355
_L_1577354:
# emit-tail-expr
# si=-24
# env=((f259584 . -20) (f259583 . -16) (f259584 . -12) (f259583 . -8) ((primitive-ref write) . 32) ((primitive-ref write-char) . 28) ((primitive-ref write-char) . 24) ((primitive-ref write-char) . 20) (else . 16) (f259554 . 12) ((primitive-ref write-char) . 8) ((primitive-ref write) . 4) (f259554 . -28) (f259555 . -24) (f259556 . -20) (f259557 . -16) (f259558 . -12) (f259559 . -8) (f259560 . -4) (f259561 . 0))
# expr=(begin ((primitive-ref write-char) #\space f259584) ((primitive-ref write-char) #\. f259584) ((primitive-ref write-char) #\space f259584) ((primitive-ref write) (cdr f259583) f259584))
# tail-begin (begin ((primitive-ref write-char) #\space f259584) ((primitive-ref write-char) #\. f259584) ((primitive-ref write-char) #\space f259584) ((primitive-ref write) (cdr f259583) f259584))
#   env=((f259584 . -20) (f259583 . -16) (f259584 . -12) (f259583 . -8) ((primitive-ref write) . 32) ((primitive-ref write-char) . 28) ((primitive-ref write-char) . 24) ((primitive-ref write-char) . 20) (else . 16) (f259554 . 12) ((primitive-ref write-char) . 8) ((primitive-ref write) . 4) (f259554 . -28) (f259555 . -24) (f259556 . -20) (f259557 . -16) (f259558 . -12) (f259559 . -8) (f259560 . -4) (f259561 . 0))
# emit-expr ((primitive-ref write-char) #\space f259584)
# funcall
#    si   =-24
#    env  = ((f259584 . -20) (f259583 . -16) (f259584 . -12) (f259583 . -8) ((primitive-ref write) . 32) ((primitive-ref write-char) . 28) ((primitive-ref write-char) . 24) ((primitive-ref write-char) . 20) (else . 16) (f259554 . 12) ((primitive-ref write-char) . 8) ((primitive-ref write) . 4) (f259554 . -28) (f259555 . -24) (f259556 . -20) (f259557 . -16) (f259558 . -12) (f259559 . -8) (f259560 . -4) (f259561 . 0))
#    expr = (funcall (primitive-ref write-char) #\space f259584)
# emit-expr (primitive-ref write-char)
    .extern mrc_write$mchar
    movl mrc_write$mchar,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1577363"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1577363":
   movl %eax,  -32(%esp)  # stash funcall-oper in closure slot
# emit-expr #\space
    movl $8207, %eax     # immed #\space
    mov %eax, -36(%esp)  # arg  
# emit-expr f259584
# emit-variable-ref
# env=((f259584 . -20) (f259583 . -16) (f259584 . -12) (f259583 . -8) ((primitive-ref write) . 32) ((primitive-ref write-char) . 28) ((primitive-ref write-char) . 24) ((primitive-ref write-char) . 20) (else . 16) (f259554 . 12) ((primitive-ref write-char) . 8) ((primitive-ref write) . 4) (f259554 . -28) (f259555 . -24) (f259556 . -20) (f259557 . -16) (f259558 . -12) (f259559 . -8) (f259560 . -4) (f259561 . 0))
# var=f259584
    movl -20(%esp), %eax  # stack load f259584
# end emit-variable-ref
    mov %eax, -40(%esp)  # arg f259584
    movl -32(%esp), %edi   # load new closure to %edi
    add $-24, %esp   # adjust base
    movl $8,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $24, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
# emit-tail-expr
# si=-24
# env=((f259584 . -20) (f259583 . -16) (f259584 . -12) (f259583 . -8) ((primitive-ref write) . 32) ((primitive-ref write-char) . 28) ((primitive-ref write-char) . 24) ((primitive-ref write-char) . 20) (else . 16) (f259554 . 12) ((primitive-ref write-char) . 8) ((primitive-ref write) . 4) (f259554 . -28) (f259555 . -24) (f259556 . -20) (f259557 . -16) (f259558 . -12) (f259559 . -8) (f259560 . -4) (f259561 . 0))
# expr=(begin ((primitive-ref write-char) #\. f259584) ((primitive-ref write-char) #\space f259584) ((primitive-ref write) (cdr f259583) f259584))
# tail-begin (begin ((primitive-ref write-char) #\. f259584) ((primitive-ref write-char) #\space f259584) ((primitive-ref write) (cdr f259583) f259584))
#   env=((f259584 . -20) (f259583 . -16) (f259584 . -12) (f259583 . -8) ((primitive-ref write) . 32) ((primitive-ref write-char) . 28) ((primitive-ref write-char) . 24) ((primitive-ref write-char) . 20) (else . 16) (f259554 . 12) ((primitive-ref write-char) . 8) ((primitive-ref write) . 4) (f259554 . -28) (f259555 . -24) (f259556 . -20) (f259557 . -16) (f259558 . -12) (f259559 . -8) (f259560 . -4) (f259561 . 0))
# emit-expr ((primitive-ref write-char) #\. f259584)
# funcall
#    si   =-24
#    env  = ((f259584 . -20) (f259583 . -16) (f259584 . -12) (f259583 . -8) ((primitive-ref write) . 32) ((primitive-ref write-char) . 28) ((primitive-ref write-char) . 24) ((primitive-ref write-char) . 20) (else . 16) (f259554 . 12) ((primitive-ref write-char) . 8) ((primitive-ref write) . 4) (f259554 . -28) (f259555 . -24) (f259556 . -20) (f259557 . -16) (f259558 . -12) (f259559 . -8) (f259560 . -4) (f259561 . 0))
#    expr = (funcall (primitive-ref write-char) #\. f259584)
# emit-expr (primitive-ref write-char)
    .extern mrc_write$mchar
    movl mrc_write$mchar,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1577364"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1577364":
   movl %eax,  -32(%esp)  # stash funcall-oper in closure slot
# emit-expr #\.
    movl $11791, %eax     # immed #\.
    mov %eax, -36(%esp)  # arg .
# emit-expr f259584
# emit-variable-ref
# env=((f259584 . -20) (f259583 . -16) (f259584 . -12) (f259583 . -8) ((primitive-ref write) . 32) ((primitive-ref write-char) . 28) ((primitive-ref write-char) . 24) ((primitive-ref write-char) . 20) (else . 16) (f259554 . 12) ((primitive-ref write-char) . 8) ((primitive-ref write) . 4) (f259554 . -28) (f259555 . -24) (f259556 . -20) (f259557 . -16) (f259558 . -12) (f259559 . -8) (f259560 . -4) (f259561 . 0))
# var=f259584
    movl -20(%esp), %eax  # stack load f259584
# end emit-variable-ref
    mov %eax, -40(%esp)  # arg f259584
    movl -32(%esp), %edi   # load new closure to %edi
    add $-24, %esp   # adjust base
    movl $8,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $24, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
# emit-tail-expr
# si=-24
# env=((f259584 . -20) (f259583 . -16) (f259584 . -12) (f259583 . -8) ((primitive-ref write) . 32) ((primitive-ref write-char) . 28) ((primitive-ref write-char) . 24) ((primitive-ref write-char) . 20) (else . 16) (f259554 . 12) ((primitive-ref write-char) . 8) ((primitive-ref write) . 4) (f259554 . -28) (f259555 . -24) (f259556 . -20) (f259557 . -16) (f259558 . -12) (f259559 . -8) (f259560 . -4) (f259561 . 0))
# expr=(begin ((primitive-ref write-char) #\space f259584) ((primitive-ref write) (cdr f259583) f259584))
# tail-begin (begin ((primitive-ref write-char) #\space f259584) ((primitive-ref write) (cdr f259583) f259584))
#   env=((f259584 . -20) (f259583 . -16) (f259584 . -12) (f259583 . -8) ((primitive-ref write) . 32) ((primitive-ref write-char) . 28) ((primitive-ref write-char) . 24) ((primitive-ref write-char) . 20) (else . 16) (f259554 . 12) ((primitive-ref write-char) . 8) ((primitive-ref write) . 4) (f259554 . -28) (f259555 . -24) (f259556 . -20) (f259557 . -16) (f259558 . -12) (f259559 . -8) (f259560 . -4) (f259561 . 0))
# emit-expr ((primitive-ref write-char) #\space f259584)
# funcall
#    si   =-24
#    env  = ((f259584 . -20) (f259583 . -16) (f259584 . -12) (f259583 . -8) ((primitive-ref write) . 32) ((primitive-ref write-char) . 28) ((primitive-ref write-char) . 24) ((primitive-ref write-char) . 20) (else . 16) (f259554 . 12) ((primitive-ref write-char) . 8) ((primitive-ref write) . 4) (f259554 . -28) (f259555 . -24) (f259556 . -20) (f259557 . -16) (f259558 . -12) (f259559 . -8) (f259560 . -4) (f259561 . 0))
#    expr = (funcall (primitive-ref write-char) #\space f259584)
# emit-expr (primitive-ref write-char)
    .extern mrc_write$mchar
    movl mrc_write$mchar,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1577365"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1577365":
   movl %eax,  -32(%esp)  # stash funcall-oper in closure slot
# emit-expr #\space
    movl $8207, %eax     # immed #\space
    mov %eax, -36(%esp)  # arg  
# emit-expr f259584
# emit-variable-ref
# env=((f259584 . -20) (f259583 . -16) (f259584 . -12) (f259583 . -8) ((primitive-ref write) . 32) ((primitive-ref write-char) . 28) ((primitive-ref write-char) . 24) ((primitive-ref write-char) . 20) (else . 16) (f259554 . 12) ((primitive-ref write-char) . 8) ((primitive-ref write) . 4) (f259554 . -28) (f259555 . -24) (f259556 . -20) (f259557 . -16) (f259558 . -12) (f259559 . -8) (f259560 . -4) (f259561 . 0))
# var=f259584
    movl -20(%esp), %eax  # stack load f259584
# end emit-variable-ref
    mov %eax, -40(%esp)  # arg f259584
    movl -32(%esp), %edi   # load new closure to %edi
    add $-24, %esp   # adjust base
    movl $8,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $24, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
# emit-tail-expr
# si=-24
# env=((f259584 . -20) (f259583 . -16) (f259584 . -12) (f259583 . -8) ((primitive-ref write) . 32) ((primitive-ref write-char) . 28) ((primitive-ref write-char) . 24) ((primitive-ref write-char) . 20) (else . 16) (f259554 . 12) ((primitive-ref write-char) . 8) ((primitive-ref write) . 4) (f259554 . -28) (f259555 . -24) (f259556 . -20) (f259557 . -16) (f259558 . -12) (f259559 . -8) (f259560 . -4) (f259561 . 0))
# expr=(begin ((primitive-ref write) (cdr f259583) f259584))
# tail-begin (begin ((primitive-ref write) (cdr f259583) f259584))
#   env=((f259584 . -20) (f259583 . -16) (f259584 . -12) (f259583 . -8) ((primitive-ref write) . 32) ((primitive-ref write-char) . 28) ((primitive-ref write-char) . 24) ((primitive-ref write-char) . 20) (else . 16) (f259554 . 12) ((primitive-ref write-char) . 8) ((primitive-ref write) . 4) (f259554 . -28) (f259555 . -24) (f259556 . -20) (f259557 . -16) (f259558 . -12) (f259559 . -8) (f259560 . -4) (f259561 . 0))
# emit-tail-expr
# si=-24
# env=((f259584 . -20) (f259583 . -16) (f259584 . -12) (f259583 . -8) ((primitive-ref write) . 32) ((primitive-ref write-char) . 28) ((primitive-ref write-char) . 24) ((primitive-ref write-char) . 20) (else . 16) (f259554 . 12) ((primitive-ref write-char) . 8) ((primitive-ref write) . 4) (f259554 . -28) (f259555 . -24) (f259556 . -20) (f259557 . -16) (f259558 . -12) (f259559 . -8) (f259560 . -4) (f259561 . 0))
# expr=((primitive-ref write) (cdr f259583) f259584)
# emit-tail-funcall
#    si   =-24
#    env  = ((f259584 . -20) (f259583 . -16) (f259584 . -12) (f259583 . -8) ((primitive-ref write) . 32) ((primitive-ref write-char) . 28) ((primitive-ref write-char) . 24) ((primitive-ref write-char) . 20) (else . 16) (f259554 . 12) ((primitive-ref write-char) . 8) ((primitive-ref write) . 4) (f259554 . -28) (f259555 . -24) (f259556 . -20) (f259557 . -16) (f259558 . -12) (f259559 . -8) (f259560 . -4) (f259561 . 0))
#    expr = (funcall (primitive-ref write) (cdr f259583) f259584)
# emit-expr (primitive-ref write)
    .extern mrc_write
    movl mrc_write,%eax
   movl %eax,  -24(%esp)  # stash funcall-oper in next closure slot
# emit-expr (cdr f259583)
# emit-expr f259583
# emit-variable-ref
# env=((f259584 . -20) (f259583 . -16) (f259584 . -12) (f259583 . -8) ((primitive-ref write) . 32) ((primitive-ref write-char) . 28) ((primitive-ref write-char) . 24) ((primitive-ref write-char) . 20) (else . 16) (f259554 . 12) ((primitive-ref write-char) . 8) ((primitive-ref write) . 4) (f259554 . -28) (f259555 . -24) (f259556 . -20) (f259557 . -16) (f259558 . -12) (f259559 . -8) (f259560 . -4) (f259561 . 0))
# var=f259583
    movl -16(%esp), %eax  # stack load f259583
# end emit-variable-ref
# check the argument is a pair
    movl %eax,%ebx
    and $7, %bl
    cmp $1, %bl
    je _L_1577366
# invoke error handler eh_pair
    .extern mrc_eh$upair
    movl mrc_eh$upair, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $112,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1577366:
    movl 3(%eax), %eax
    mov %eax, -28(%esp)    # arg (cdr f259583)
# emit-expr f259584
# emit-variable-ref
# env=((f259584 . -20) (f259583 . -16) (f259584 . -12) (f259583 . -8) ((primitive-ref write) . 32) ((primitive-ref write-char) . 28) ((primitive-ref write-char) . 24) ((primitive-ref write-char) . 20) (else . 16) (f259554 . 12) ((primitive-ref write-char) . 8) ((primitive-ref write) . 4) (f259554 . -28) (f259555 . -24) (f259556 . -20) (f259557 . -16) (f259558 . -12) (f259559 . -8) (f259560 . -4) (f259561 . 0))
# var=f259584
    movl -20(%esp), %eax  # stack load f259584
# end emit-variable-ref
    mov %eax, -32(%esp)    # arg f259584
    movl -24(%esp), %edi   # load new closure to %edi
# emit-shift-args:  size=3   si=-24  delta=20
    mov -24(%esp), %ebx  # shift frame cell
    mov %ebx, -4(%esp)  # down to base
# emit-shift-args:  size=2   si=-28  delta=20
    mov -28(%esp), %ebx  # shift frame cell
    mov %ebx, -8(%esp)  # down to base
# emit-shift-args:  size=1   si=-32  delta=20
    mov -32(%esp), %ebx  # shift frame cell
    mov %ebx, -12(%esp)  # down to base
# emit-shift-args:  size=0   si=-36  delta=20
    movl $8,%eax   # save arg count
    jmp *-2(%edi)  # tail-funcall
     ret   # return thru stack
_L_1577355:
_L_1577352:
     ret   # return thru stack
    .align 4,0x90
_L_1577347:
    movl -32(%esp), %ebx
    movl -36(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin)
# emit-begin
#   expr=(begin)
#   env=((f259554 . -28) (f259555 . -24) (f259556 . -20) (f259557 . -16) (f259558 . -12) (f259559 . -8) (f259560 . -4) (f259561 . 0))
# emit-expr (begin (closure (f259607 f259608 f259609) (f259561 f259560 (primitive-ref write-char) f259559 f259558 f259556 f259557 f259555 else (primitive-ref error) (primitive-ref write)) (let ((f259607 f259607) (f259608 f259608) (f259609 f259609)) (if (boolean? f259607) ((vector-ref f259561 0) f259607 f259608) (if (null? f259607) ((vector-ref f259560 0) f259608) (if (char? f259607) (if f259609 ((primitive-ref write-char) f259607 f259608) ((vector-ref f259559 0) f259607 f259608)) (if (fixnum? f259607) ((vector-ref f259558 0) f259607 f259608) (if (string? f259607) (if f259609 ((vector-ref f259556 0) f259607 f259608) ((vector-ref f259557 0) f259607 f259608)) (if (pair? f259607) ((vector-ref f259555 0) f259607 f259608) ((primitive-ref error) ((primitive-ref string->symbol) "write") "unrecognized expression"))))))))))
# emit-begin
#   expr=(begin (closure (f259607 f259608 f259609) (f259561 f259560 (primitive-ref write-char) f259559 f259558 f259556 f259557 f259555 else (primitive-ref error) (primitive-ref write)) (let ((f259607 f259607) (f259608 f259608) (f259609 f259609)) (if (boolean? f259607) ((vector-ref f259561 0) f259607 f259608) (if (null? f259607) ((vector-ref f259560 0) f259608) (if (char? f259607) (if f259609 ((primitive-ref write-char) f259607 f259608) ((vector-ref f259559 0) f259607 f259608)) (if (fixnum? f259607) ((vector-ref f259558 0) f259607 f259608) (if (string? f259607) (if f259609 ((vector-ref f259556 0) f259607 f259608) ((vector-ref f259557 0) f259607 f259608)) (if (pair? f259607) ((vector-ref f259555 0) f259607 f259608) ((primitive-ref error) ((primitive-ref string->symbol) "write") "unrecognized expression"))))))))))
#   env=((f259554 . -28) (f259555 . -24) (f259556 . -20) (f259557 . -16) (f259558 . -12) (f259559 . -8) (f259560 . -4) (f259561 . 0))
# emit-expr (closure (f259607 f259608 f259609) (f259561 f259560 (primitive-ref write-char) f259559 f259558 f259556 f259557 f259555 else (primitive-ref error) (primitive-ref write)) (let ((f259607 f259607) (f259608 f259608) (f259609 f259609)) (if (boolean? f259607) ((vector-ref f259561 0) f259607 f259608) (if (null? f259607) ((vector-ref f259560 0) f259608) (if (char? f259607) (if f259609 ((primitive-ref write-char) f259607 f259608) ((vector-ref f259559 0) f259607 f259608)) (if (fixnum? f259607) ((vector-ref f259558 0) f259607 f259608) (if (string? f259607) (if f259609 ((vector-ref f259556 0) f259607 f259608) ((vector-ref f259557 0) f259607 f259608)) (if (pair? f259607) ((vector-ref f259555 0) f259607 f259608) ((primitive-ref error) ((primitive-ref string->symbol) "write") "unrecognized expression")))))))))
# emit-closure
# si = -32
# env = ((f259554 . -28) (f259555 . -24) (f259556 . -20) (f259557 . -16) (f259558 . -12) (f259559 . -8) (f259560 . -4) (f259561 . 0))
# expr = (closure (f259607 f259608 f259609) (f259561 f259560 (primitive-ref write-char) f259559 f259558 f259556 f259557 f259555 else (primitive-ref error) (primitive-ref write)) (let ((f259607 f259607) (f259608 f259608) (f259609 f259609)) (if (boolean? f259607) ((vector-ref f259561 0) f259607 f259608) (if (null? f259607) ((vector-ref f259560 0) f259608) (if (char? f259607) (if f259609 ((primitive-ref write-char) f259607 f259608) ((vector-ref f259559 0) f259607 f259608)) (if (fixnum? f259607) ((vector-ref f259558 0) f259607 f259608) (if (string? f259607) (if f259609 ((vector-ref f259556 0) f259607 f259608) ((vector-ref f259557 0) f259607 f259608)) (if (pair? f259607) ((vector-ref f259555 0) f259607 f259608) ((primitive-ref error) ((primitive-ref string->symbol) "write") "unrecognized expression")))))))))
    movl $_L_1577367, 0(%ebp)  # closure label
# emit-variable-ref
# env=((f259554 . -28) (f259555 . -24) (f259556 . -20) (f259557 . -16) (f259558 . -12) (f259559 . -8) (f259560 . -4) (f259561 . 0))
# var=f259561
    movl 0(%esp), %eax  # stack load f259561
# end emit-variable-ref
   movl  %eax, 4(%ebp)  # f259561
# emit-variable-ref
# env=((f259554 . -28) (f259555 . -24) (f259556 . -20) (f259557 . -16) (f259558 . -12) (f259559 . -8) (f259560 . -4) (f259561 . 0))
# var=f259560
    movl -4(%esp), %eax  # stack load f259560
# end emit-variable-ref
   movl  %eax, 8(%ebp)  # f259560
# WARNING: free var (primitive-ref write-char) not defined in the environmnet
# emit-variable-ref
# env=((f259554 . -28) (f259555 . -24) (f259556 . -20) (f259557 . -16) (f259558 . -12) (f259559 . -8) (f259560 . -4) (f259561 . 0))
# var=f259559
    movl -8(%esp), %eax  # stack load f259559
# end emit-variable-ref
   movl  %eax, 16(%ebp)  # f259559
# emit-variable-ref
# env=((f259554 . -28) (f259555 . -24) (f259556 . -20) (f259557 . -16) (f259558 . -12) (f259559 . -8) (f259560 . -4) (f259561 . 0))
# var=f259558
    movl -12(%esp), %eax  # stack load f259558
# end emit-variable-ref
   movl  %eax, 20(%ebp)  # f259558
# emit-variable-ref
# env=((f259554 . -28) (f259555 . -24) (f259556 . -20) (f259557 . -16) (f259558 . -12) (f259559 . -8) (f259560 . -4) (f259561 . 0))
# var=f259556
    movl -20(%esp), %eax  # stack load f259556
# end emit-variable-ref
   movl  %eax, 24(%ebp)  # f259556
# emit-variable-ref
# env=((f259554 . -28) (f259555 . -24) (f259556 . -20) (f259557 . -16) (f259558 . -12) (f259559 . -8) (f259560 . -4) (f259561 . 0))
# var=f259557
    movl -16(%esp), %eax  # stack load f259557
# end emit-variable-ref
   movl  %eax, 28(%ebp)  # f259557
# emit-variable-ref
# env=((f259554 . -28) (f259555 . -24) (f259556 . -20) (f259557 . -16) (f259558 . -12) (f259559 . -8) (f259560 . -4) (f259561 . 0))
# var=f259555
    movl -24(%esp), %eax  # stack load f259555
# end emit-variable-ref
   movl  %eax, 32(%ebp)  # f259555
# WARNING: free var else not defined in the environmnet
# WARNING: free var (primitive-ref error) not defined in the environmnet
# WARNING: free var (primitive-ref write) not defined in the environmnet
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $48, %ebp     # bump ebp
    jmp _L_1577368            # jump around closure body
_L_1577367:
# check argument count
    cmp $12,%eax
    je _L_1577369
# invoke error handler eh_argcount
    .extern mrc_eh$uargcount
    movl mrc_eh$uargcount, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_1577369:
# emit-tail-expr
# si=-20
# env=((f259609 . -16) (f259608 . -12) (f259607 . -8) ((primitive-ref write) . 44) ((primitive-ref error) . 40) (else . 36) (f259555 . 32) (f259557 . 28) (f259556 . 24) (f259558 . 20) (f259559 . 16) ((primitive-ref write-char) . 12) (f259560 . 8) (f259561 . 4) (f259554 . -28) (f259555 . -24) (f259556 . -20) (f259557 . -16) (f259558 . -12) (f259559 . -8) (f259560 . -4) (f259561 . 0))
# expr=(let ((f259607 f259607) (f259608 f259608) (f259609 f259609)) (if (boolean? f259607) ((vector-ref f259561 0) f259607 f259608) (if (null? f259607) ((vector-ref f259560 0) f259608) (if (char? f259607) (if f259609 ((primitive-ref write-char) f259607 f259608) ((vector-ref f259559 0) f259607 f259608)) (if (fixnum? f259607) ((vector-ref f259558 0) f259607 f259608) (if (string? f259607) (if f259609 ((vector-ref f259556 0) f259607 f259608) ((vector-ref f259557 0) f259607 f259608)) (if (pair? f259607) ((vector-ref f259555 0) f259607 f259608) ((primitive-ref error) ((primitive-ref string->symbol) "write") "unrecognized expression"))))))))
# emit-tail-let
#  si   = -20
#  env  = ((f259609 . -16) (f259608 . -12) (f259607 . -8) ((primitive-ref write) . 44) ((primitive-ref error) . 40) (else . 36) (f259555 . 32) (f259557 . 28) (f259556 . 24) (f259558 . 20) (f259559 . 16) ((primitive-ref write-char) . 12) (f259560 . 8) (f259561 . 4) (f259554 . -28) (f259555 . -24) (f259556 . -20) (f259557 . -16) (f259558 . -12) (f259559 . -8) (f259560 . -4) (f259561 . 0))
#  bindings = ((f259607 f259607) (f259608 f259608) (f259609 f259609))
#  body = (if (boolean? f259607) ((vector-ref f259561 0) f259607 f259608) (if (null? f259607) ((vector-ref f259560 0) f259608) (if (char? f259607) (if f259609 ((primitive-ref write-char) f259607 f259608) ((vector-ref f259559 0) f259607 f259608)) (if (fixnum? f259607) ((vector-ref f259558 0) f259607 f259608) (if (string? f259607) (if f259609 ((vector-ref f259556 0) f259607 f259608) ((vector-ref f259557 0) f259607 f259608)) (if (pair? f259607) ((vector-ref f259555 0) f259607 f259608) ((primitive-ref error) ((primitive-ref string->symbol) "write") "unrecognized expression")))))))
# emit-expr f259607
# emit-variable-ref
# env=((f259609 . -16) (f259608 . -12) (f259607 . -8) ((primitive-ref write) . 44) ((primitive-ref error) . 40) (else . 36) (f259555 . 32) (f259557 . 28) (f259556 . 24) (f259558 . 20) (f259559 . 16) ((primitive-ref write-char) . 12) (f259560 . 8) (f259561 . 4) (f259554 . -28) (f259555 . -24) (f259556 . -20) (f259557 . -16) (f259558 . -12) (f259559 . -8) (f259560 . -4) (f259561 . 0))
# var=f259607
    movl -8(%esp), %eax  # stack load f259607
# end emit-variable-ref
    movl %eax, -20(%esp)  # stack save
# emit-expr f259608
# emit-variable-ref
# env=((f259609 . -16) (f259608 . -12) (f259607 . -8) ((primitive-ref write) . 44) ((primitive-ref error) . 40) (else . 36) (f259555 . 32) (f259557 . 28) (f259556 . 24) (f259558 . 20) (f259559 . 16) ((primitive-ref write-char) . 12) (f259560 . 8) (f259561 . 4) (f259554 . -28) (f259555 . -24) (f259556 . -20) (f259557 . -16) (f259558 . -12) (f259559 . -8) (f259560 . -4) (f259561 . 0))
# var=f259608
    movl -12(%esp), %eax  # stack load f259608
# end emit-variable-ref
    movl %eax, -24(%esp)  # stack save
# emit-expr f259609
# emit-variable-ref
# env=((f259609 . -16) (f259608 . -12) (f259607 . -8) ((primitive-ref write) . 44) ((primitive-ref error) . 40) (else . 36) (f259555 . 32) (f259557 . 28) (f259556 . 24) (f259558 . 20) (f259559 . 16) ((primitive-ref write-char) . 12) (f259560 . 8) (f259561 . 4) (f259554 . -28) (f259555 . -24) (f259556 . -20) (f259557 . -16) (f259558 . -12) (f259559 . -8) (f259560 . -4) (f259561 . 0))
# var=f259609
    movl -16(%esp), %eax  # stack load f259609
# end emit-variable-ref
    movl %eax, -28(%esp)  # stack save
# emit-tail-expr
# si=-32
# env=((f259609 . -28) (f259608 . -24) (f259607 . -20) (f259609 . -16) (f259608 . -12) (f259607 . -8) ((primitive-ref write) . 44) ((primitive-ref error) . 40) (else . 36) (f259555 . 32) (f259557 . 28) (f259556 . 24) (f259558 . 20) (f259559 . 16) ((primitive-ref write-char) . 12) (f259560 . 8) (f259561 . 4) (f259554 . -28) (f259555 . -24) (f259556 . -20) (f259557 . -16) (f259558 . -12) (f259559 . -8) (f259560 . -4) (f259561 . 0))
# expr=(if (boolean? f259607) ((vector-ref f259561 0) f259607 f259608) (if (null? f259607) ((vector-ref f259560 0) f259608) (if (char? f259607) (if f259609 ((primitive-ref write-char) f259607 f259608) ((vector-ref f259559 0) f259607 f259608)) (if (fixnum? f259607) ((vector-ref f259558 0) f259607 f259608) (if (string? f259607) (if f259609 ((vector-ref f259556 0) f259607 f259608) ((vector-ref f259557 0) f259607 f259608)) (if (pair? f259607) ((vector-ref f259555 0) f259607 f259608) ((primitive-ref error) ((primitive-ref string->symbol) "write") "unrecognized expression")))))))
# emit-expr (boolean? f259607)
# emit-expr f259607
# emit-variable-ref
# env=((f259609 . -28) (f259608 . -24) (f259607 . -20) (f259609 . -16) (f259608 . -12) (f259607 . -8) ((primitive-ref write) . 44) ((primitive-ref error) . 40) (else . 36) (f259555 . 32) (f259557 . 28) (f259556 . 24) (f259558 . 20) (f259559 . 16) ((primitive-ref write-char) . 12) (f259560 . 8) (f259561 . 4) (f259554 . -28) (f259555 . -24) (f259556 . -20) (f259557 . -16) (f259558 . -12) (f259559 . -8) (f259560 . -4) (f259561 . 0))
# var=f259607
    movl -20(%esp), %eax  # stack load f259607
# end emit-variable-ref
    and $191, %eax
    cmp $47, %eax
    sete %al
    movzbl %al, %eax
    sal $6, %al
    or $47, %al
    cmp $47, %al
    je _L_1577370
# emit-tail-expr
# si=-32
# env=((f259609 . -28) (f259608 . -24) (f259607 . -20) (f259609 . -16) (f259608 . -12) (f259607 . -8) ((primitive-ref write) . 44) ((primitive-ref error) . 40) (else . 36) (f259555 . 32) (f259557 . 28) (f259556 . 24) (f259558 . 20) (f259559 . 16) ((primitive-ref write-char) . 12) (f259560 . 8) (f259561 . 4) (f259554 . -28) (f259555 . -24) (f259556 . -20) (f259557 . -16) (f259558 . -12) (f259559 . -8) (f259560 . -4) (f259561 . 0))
# expr=((vector-ref f259561 0) f259607 f259608)
# emit-tail-funcall
#    si   =-32
#    env  = ((f259609 . -28) (f259608 . -24) (f259607 . -20) (f259609 . -16) (f259608 . -12) (f259607 . -8) ((primitive-ref write) . 44) ((primitive-ref error) . 40) (else . 36) (f259555 . 32) (f259557 . 28) (f259556 . 24) (f259558 . 20) (f259559 . 16) ((primitive-ref write-char) . 12) (f259560 . 8) (f259561 . 4) (f259554 . -28) (f259555 . -24) (f259556 . -20) (f259557 . -16) (f259558 . -12) (f259559 . -8) (f259560 . -4) (f259561 . 0))
#    expr = (funcall (vector-ref f259561 0) f259607 f259608)
# emit-expr (vector-ref f259561 0)
# emit-expr f259561
# emit-variable-ref
# env=((f259609 . -28) (f259608 . -24) (f259607 . -20) (f259609 . -16) (f259608 . -12) (f259607 . -8) ((primitive-ref write) . 44) ((primitive-ref error) . 40) (else . 36) (f259555 . 32) (f259557 . 28) (f259556 . 24) (f259558 . 20) (f259559 . 16) ((primitive-ref write-char) . 12) (f259560 . 8) (f259561 . 4) (f259554 . -28) (f259555 . -24) (f259556 . -20) (f259557 . -16) (f259558 . -12) (f259559 . -8) (f259560 . -4) (f259561 . 0))
# var=f259561
    movl 2(%edi), %eax  # frame load f259561
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1577372
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1577372:
    movl %eax, -32(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1577373"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1577373:
# check bounds on vector index
    movl -32(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1577375
    cmp  $0,%eax
    jge _L_1577374
_L_1577375:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1577374:
    movl -32(%esp), %esi
    movl -1(%eax,%esi), %eax
   movl %eax,  -32(%esp)  # stash funcall-oper in next closure slot
# emit-expr f259607
# emit-variable-ref
# env=((f259609 . -28) (f259608 . -24) (f259607 . -20) (f259609 . -16) (f259608 . -12) (f259607 . -8) ((primitive-ref write) . 44) ((primitive-ref error) . 40) (else . 36) (f259555 . 32) (f259557 . 28) (f259556 . 24) (f259558 . 20) (f259559 . 16) ((primitive-ref write-char) . 12) (f259560 . 8) (f259561 . 4) (f259554 . -28) (f259555 . -24) (f259556 . -20) (f259557 . -16) (f259558 . -12) (f259559 . -8) (f259560 . -4) (f259561 . 0))
# var=f259607
    movl -20(%esp), %eax  # stack load f259607
# end emit-variable-ref
    mov %eax, -36(%esp)    # arg f259607
# emit-expr f259608
# emit-variable-ref
# env=((f259609 . -28) (f259608 . -24) (f259607 . -20) (f259609 . -16) (f259608 . -12) (f259607 . -8) ((primitive-ref write) . 44) ((primitive-ref error) . 40) (else . 36) (f259555 . 32) (f259557 . 28) (f259556 . 24) (f259558 . 20) (f259559 . 16) ((primitive-ref write-char) . 12) (f259560 . 8) (f259561 . 4) (f259554 . -28) (f259555 . -24) (f259556 . -20) (f259557 . -16) (f259558 . -12) (f259559 . -8) (f259560 . -4) (f259561 . 0))
# var=f259608
    movl -24(%esp), %eax  # stack load f259608
# end emit-variable-ref
    mov %eax, -40(%esp)    # arg f259608
    movl -32(%esp), %edi   # load new closure to %edi
# emit-shift-args:  size=3   si=-32  delta=28
    mov -32(%esp), %ebx  # shift frame cell
    mov %ebx, -4(%esp)  # down to base
# emit-shift-args:  size=2   si=-36  delta=28
    mov -36(%esp), %ebx  # shift frame cell
    mov %ebx, -8(%esp)  # down to base
# emit-shift-args:  size=1   si=-40  delta=28
    mov -40(%esp), %ebx  # shift frame cell
    mov %ebx, -12(%esp)  # down to base
# emit-shift-args:  size=0   si=-44  delta=28
    movl $8,%eax   # save arg count
    jmp *-2(%edi)  # tail-funcall
    jmp _L_1577371
_L_1577370:
# emit-tail-expr
# si=-32
# env=((f259609 . -28) (f259608 . -24) (f259607 . -20) (f259609 . -16) (f259608 . -12) (f259607 . -8) ((primitive-ref write) . 44) ((primitive-ref error) . 40) (else . 36) (f259555 . 32) (f259557 . 28) (f259556 . 24) (f259558 . 20) (f259559 . 16) ((primitive-ref write-char) . 12) (f259560 . 8) (f259561 . 4) (f259554 . -28) (f259555 . -24) (f259556 . -20) (f259557 . -16) (f259558 . -12) (f259559 . -8) (f259560 . -4) (f259561 . 0))
# expr=(if (null? f259607) ((vector-ref f259560 0) f259608) (if (char? f259607) (if f259609 ((primitive-ref write-char) f259607 f259608) ((vector-ref f259559 0) f259607 f259608)) (if (fixnum? f259607) ((vector-ref f259558 0) f259607 f259608) (if (string? f259607) (if f259609 ((vector-ref f259556 0) f259607 f259608) ((vector-ref f259557 0) f259607 f259608)) (if (pair? f259607) ((vector-ref f259555 0) f259607 f259608) ((primitive-ref error) ((primitive-ref string->symbol) "write") "unrecognized expression"))))))
# emit-expr (null? f259607)
# emit-expr f259607
# emit-variable-ref
# env=((f259609 . -28) (f259608 . -24) (f259607 . -20) (f259609 . -16) (f259608 . -12) (f259607 . -8) ((primitive-ref write) . 44) ((primitive-ref error) . 40) (else . 36) (f259555 . 32) (f259557 . 28) (f259556 . 24) (f259558 . 20) (f259559 . 16) ((primitive-ref write-char) . 12) (f259560 . 8) (f259561 . 4) (f259554 . -28) (f259555 . -24) (f259556 . -20) (f259557 . -16) (f259558 . -12) (f259559 . -8) (f259560 . -4) (f259561 . 0))
# var=f259607
    movl -20(%esp), %eax  # stack load f259607
# end emit-variable-ref
    cmp $63, %eax
    mov $0, %eax
    sete %al
    movzbl %al, %eax
    sal $6, %al
    or $47, %al
    cmp $47, %al
    je _L_1577376
# emit-tail-expr
# si=-32
# env=((f259609 . -28) (f259608 . -24) (f259607 . -20) (f259609 . -16) (f259608 . -12) (f259607 . -8) ((primitive-ref write) . 44) ((primitive-ref error) . 40) (else . 36) (f259555 . 32) (f259557 . 28) (f259556 . 24) (f259558 . 20) (f259559 . 16) ((primitive-ref write-char) . 12) (f259560 . 8) (f259561 . 4) (f259554 . -28) (f259555 . -24) (f259556 . -20) (f259557 . -16) (f259558 . -12) (f259559 . -8) (f259560 . -4) (f259561 . 0))
# expr=((vector-ref f259560 0) f259608)
# emit-tail-funcall
#    si   =-32
#    env  = ((f259609 . -28) (f259608 . -24) (f259607 . -20) (f259609 . -16) (f259608 . -12) (f259607 . -8) ((primitive-ref write) . 44) ((primitive-ref error) . 40) (else . 36) (f259555 . 32) (f259557 . 28) (f259556 . 24) (f259558 . 20) (f259559 . 16) ((primitive-ref write-char) . 12) (f259560 . 8) (f259561 . 4) (f259554 . -28) (f259555 . -24) (f259556 . -20) (f259557 . -16) (f259558 . -12) (f259559 . -8) (f259560 . -4) (f259561 . 0))
#    expr = (funcall (vector-ref f259560 0) f259608)
# emit-expr (vector-ref f259560 0)
# emit-expr f259560
# emit-variable-ref
# env=((f259609 . -28) (f259608 . -24) (f259607 . -20) (f259609 . -16) (f259608 . -12) (f259607 . -8) ((primitive-ref write) . 44) ((primitive-ref error) . 40) (else . 36) (f259555 . 32) (f259557 . 28) (f259556 . 24) (f259558 . 20) (f259559 . 16) ((primitive-ref write-char) . 12) (f259560 . 8) (f259561 . 4) (f259554 . -28) (f259555 . -24) (f259556 . -20) (f259557 . -16) (f259558 . -12) (f259559 . -8) (f259560 . -4) (f259561 . 0))
# var=f259560
    movl 6(%edi), %eax  # frame load f259560
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1577378
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1577378:
    movl %eax, -32(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1577379"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1577379:
# check bounds on vector index
    movl -32(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1577381
    cmp  $0,%eax
    jge _L_1577380
_L_1577381:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1577380:
    movl -32(%esp), %esi
    movl -1(%eax,%esi), %eax
   movl %eax,  -32(%esp)  # stash funcall-oper in next closure slot
# emit-expr f259608
# emit-variable-ref
# env=((f259609 . -28) (f259608 . -24) (f259607 . -20) (f259609 . -16) (f259608 . -12) (f259607 . -8) ((primitive-ref write) . 44) ((primitive-ref error) . 40) (else . 36) (f259555 . 32) (f259557 . 28) (f259556 . 24) (f259558 . 20) (f259559 . 16) ((primitive-ref write-char) . 12) (f259560 . 8) (f259561 . 4) (f259554 . -28) (f259555 . -24) (f259556 . -20) (f259557 . -16) (f259558 . -12) (f259559 . -8) (f259560 . -4) (f259561 . 0))
# var=f259608
    movl -24(%esp), %eax  # stack load f259608
# end emit-variable-ref
    mov %eax, -36(%esp)    # arg f259608
    movl -32(%esp), %edi   # load new closure to %edi
# emit-shift-args:  size=2   si=-32  delta=28
    mov -32(%esp), %ebx  # shift frame cell
    mov %ebx, -4(%esp)  # down to base
# emit-shift-args:  size=1   si=-36  delta=28
    mov -36(%esp), %ebx  # shift frame cell
    mov %ebx, -8(%esp)  # down to base
# emit-shift-args:  size=0   si=-40  delta=28
    movl $4,%eax   # save arg count
    jmp *-2(%edi)  # tail-funcall
    jmp _L_1577377
_L_1577376:
# emit-tail-expr
# si=-32
# env=((f259609 . -28) (f259608 . -24) (f259607 . -20) (f259609 . -16) (f259608 . -12) (f259607 . -8) ((primitive-ref write) . 44) ((primitive-ref error) . 40) (else . 36) (f259555 . 32) (f259557 . 28) (f259556 . 24) (f259558 . 20) (f259559 . 16) ((primitive-ref write-char) . 12) (f259560 . 8) (f259561 . 4) (f259554 . -28) (f259555 . -24) (f259556 . -20) (f259557 . -16) (f259558 . -12) (f259559 . -8) (f259560 . -4) (f259561 . 0))
# expr=(if (char? f259607) (if f259609 ((primitive-ref write-char) f259607 f259608) ((vector-ref f259559 0) f259607 f259608)) (if (fixnum? f259607) ((vector-ref f259558 0) f259607 f259608) (if (string? f259607) (if f259609 ((vector-ref f259556 0) f259607 f259608) ((vector-ref f259557 0) f259607 f259608)) (if (pair? f259607) ((vector-ref f259555 0) f259607 f259608) ((primitive-ref error) ((primitive-ref string->symbol) "write") "unrecognized expression")))))
# emit-expr (char? f259607)
# emit-expr f259607
# emit-variable-ref
# env=((f259609 . -28) (f259608 . -24) (f259607 . -20) (f259609 . -16) (f259608 . -12) (f259607 . -8) ((primitive-ref write) . 44) ((primitive-ref error) . 40) (else . 36) (f259555 . 32) (f259557 . 28) (f259556 . 24) (f259558 . 20) (f259559 . 16) ((primitive-ref write-char) . 12) (f259560 . 8) (f259561 . 4) (f259554 . -28) (f259555 . -24) (f259556 . -20) (f259557 . -16) (f259558 . -12) (f259559 . -8) (f259560 . -4) (f259561 . 0))
# var=f259607
    movl -20(%esp), %eax  # stack load f259607
# end emit-variable-ref
    and $255, %eax
    cmp $15, %eax
    sete %al
    movzbl %al, %eax
    sal $6, %al
    or $47, %al
    cmp $47, %al
    je _L_1577382
# emit-tail-expr
# si=-32
# env=((f259609 . -28) (f259608 . -24) (f259607 . -20) (f259609 . -16) (f259608 . -12) (f259607 . -8) ((primitive-ref write) . 44) ((primitive-ref error) . 40) (else . 36) (f259555 . 32) (f259557 . 28) (f259556 . 24) (f259558 . 20) (f259559 . 16) ((primitive-ref write-char) . 12) (f259560 . 8) (f259561 . 4) (f259554 . -28) (f259555 . -24) (f259556 . -20) (f259557 . -16) (f259558 . -12) (f259559 . -8) (f259560 . -4) (f259561 . 0))
# expr=(if f259609 ((primitive-ref write-char) f259607 f259608) ((vector-ref f259559 0) f259607 f259608))
# emit-expr f259609
# emit-variable-ref
# env=((f259609 . -28) (f259608 . -24) (f259607 . -20) (f259609 . -16) (f259608 . -12) (f259607 . -8) ((primitive-ref write) . 44) ((primitive-ref error) . 40) (else . 36) (f259555 . 32) (f259557 . 28) (f259556 . 24) (f259558 . 20) (f259559 . 16) ((primitive-ref write-char) . 12) (f259560 . 8) (f259561 . 4) (f259554 . -28) (f259555 . -24) (f259556 . -20) (f259557 . -16) (f259558 . -12) (f259559 . -8) (f259560 . -4) (f259561 . 0))
# var=f259609
    movl -28(%esp), %eax  # stack load f259609
# end emit-variable-ref
    cmp $47, %al
    je _L_1577384
# emit-tail-expr
# si=-32
# env=((f259609 . -28) (f259608 . -24) (f259607 . -20) (f259609 . -16) (f259608 . -12) (f259607 . -8) ((primitive-ref write) . 44) ((primitive-ref error) . 40) (else . 36) (f259555 . 32) (f259557 . 28) (f259556 . 24) (f259558 . 20) (f259559 . 16) ((primitive-ref write-char) . 12) (f259560 . 8) (f259561 . 4) (f259554 . -28) (f259555 . -24) (f259556 . -20) (f259557 . -16) (f259558 . -12) (f259559 . -8) (f259560 . -4) (f259561 . 0))
# expr=((primitive-ref write-char) f259607 f259608)
# emit-tail-funcall
#    si   =-32
#    env  = ((f259609 . -28) (f259608 . -24) (f259607 . -20) (f259609 . -16) (f259608 . -12) (f259607 . -8) ((primitive-ref write) . 44) ((primitive-ref error) . 40) (else . 36) (f259555 . 32) (f259557 . 28) (f259556 . 24) (f259558 . 20) (f259559 . 16) ((primitive-ref write-char) . 12) (f259560 . 8) (f259561 . 4) (f259554 . -28) (f259555 . -24) (f259556 . -20) (f259557 . -16) (f259558 . -12) (f259559 . -8) (f259560 . -4) (f259561 . 0))
#    expr = (funcall (primitive-ref write-char) f259607 f259608)
# emit-expr (primitive-ref write-char)
    .extern mrc_write$mchar
    movl mrc_write$mchar,%eax
   movl %eax,  -32(%esp)  # stash funcall-oper in next closure slot
# emit-expr f259607
# emit-variable-ref
# env=((f259609 . -28) (f259608 . -24) (f259607 . -20) (f259609 . -16) (f259608 . -12) (f259607 . -8) ((primitive-ref write) . 44) ((primitive-ref error) . 40) (else . 36) (f259555 . 32) (f259557 . 28) (f259556 . 24) (f259558 . 20) (f259559 . 16) ((primitive-ref write-char) . 12) (f259560 . 8) (f259561 . 4) (f259554 . -28) (f259555 . -24) (f259556 . -20) (f259557 . -16) (f259558 . -12) (f259559 . -8) (f259560 . -4) (f259561 . 0))
# var=f259607
    movl -20(%esp), %eax  # stack load f259607
# end emit-variable-ref
    mov %eax, -36(%esp)    # arg f259607
# emit-expr f259608
# emit-variable-ref
# env=((f259609 . -28) (f259608 . -24) (f259607 . -20) (f259609 . -16) (f259608 . -12) (f259607 . -8) ((primitive-ref write) . 44) ((primitive-ref error) . 40) (else . 36) (f259555 . 32) (f259557 . 28) (f259556 . 24) (f259558 . 20) (f259559 . 16) ((primitive-ref write-char) . 12) (f259560 . 8) (f259561 . 4) (f259554 . -28) (f259555 . -24) (f259556 . -20) (f259557 . -16) (f259558 . -12) (f259559 . -8) (f259560 . -4) (f259561 . 0))
# var=f259608
    movl -24(%esp), %eax  # stack load f259608
# end emit-variable-ref
    mov %eax, -40(%esp)    # arg f259608
    movl -32(%esp), %edi   # load new closure to %edi
# emit-shift-args:  size=3   si=-32  delta=28
    mov -32(%esp), %ebx  # shift frame cell
    mov %ebx, -4(%esp)  # down to base
# emit-shift-args:  size=2   si=-36  delta=28
    mov -36(%esp), %ebx  # shift frame cell
    mov %ebx, -8(%esp)  # down to base
# emit-shift-args:  size=1   si=-40  delta=28
    mov -40(%esp), %ebx  # shift frame cell
    mov %ebx, -12(%esp)  # down to base
# emit-shift-args:  size=0   si=-44  delta=28
    movl $8,%eax   # save arg count
    jmp *-2(%edi)  # tail-funcall
    jmp _L_1577385
_L_1577384:
# emit-tail-expr
# si=-32
# env=((f259609 . -28) (f259608 . -24) (f259607 . -20) (f259609 . -16) (f259608 . -12) (f259607 . -8) ((primitive-ref write) . 44) ((primitive-ref error) . 40) (else . 36) (f259555 . 32) (f259557 . 28) (f259556 . 24) (f259558 . 20) (f259559 . 16) ((primitive-ref write-char) . 12) (f259560 . 8) (f259561 . 4) (f259554 . -28) (f259555 . -24) (f259556 . -20) (f259557 . -16) (f259558 . -12) (f259559 . -8) (f259560 . -4) (f259561 . 0))
# expr=((vector-ref f259559 0) f259607 f259608)
# emit-tail-funcall
#    si   =-32
#    env  = ((f259609 . -28) (f259608 . -24) (f259607 . -20) (f259609 . -16) (f259608 . -12) (f259607 . -8) ((primitive-ref write) . 44) ((primitive-ref error) . 40) (else . 36) (f259555 . 32) (f259557 . 28) (f259556 . 24) (f259558 . 20) (f259559 . 16) ((primitive-ref write-char) . 12) (f259560 . 8) (f259561 . 4) (f259554 . -28) (f259555 . -24) (f259556 . -20) (f259557 . -16) (f259558 . -12) (f259559 . -8) (f259560 . -4) (f259561 . 0))
#    expr = (funcall (vector-ref f259559 0) f259607 f259608)
# emit-expr (vector-ref f259559 0)
# emit-expr f259559
# emit-variable-ref
# env=((f259609 . -28) (f259608 . -24) (f259607 . -20) (f259609 . -16) (f259608 . -12) (f259607 . -8) ((primitive-ref write) . 44) ((primitive-ref error) . 40) (else . 36) (f259555 . 32) (f259557 . 28) (f259556 . 24) (f259558 . 20) (f259559 . 16) ((primitive-ref write-char) . 12) (f259560 . 8) (f259561 . 4) (f259554 . -28) (f259555 . -24) (f259556 . -20) (f259557 . -16) (f259558 . -12) (f259559 . -8) (f259560 . -4) (f259561 . 0))
# var=f259559
    movl 14(%edi), %eax  # frame load f259559
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1577386
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1577386:
    movl %eax, -32(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1577387"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1577387:
# check bounds on vector index
    movl -32(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1577389
    cmp  $0,%eax
    jge _L_1577388
_L_1577389:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1577388:
    movl -32(%esp), %esi
    movl -1(%eax,%esi), %eax
   movl %eax,  -32(%esp)  # stash funcall-oper in next closure slot
# emit-expr f259607
# emit-variable-ref
# env=((f259609 . -28) (f259608 . -24) (f259607 . -20) (f259609 . -16) (f259608 . -12) (f259607 . -8) ((primitive-ref write) . 44) ((primitive-ref error) . 40) (else . 36) (f259555 . 32) (f259557 . 28) (f259556 . 24) (f259558 . 20) (f259559 . 16) ((primitive-ref write-char) . 12) (f259560 . 8) (f259561 . 4) (f259554 . -28) (f259555 . -24) (f259556 . -20) (f259557 . -16) (f259558 . -12) (f259559 . -8) (f259560 . -4) (f259561 . 0))
# var=f259607
    movl -20(%esp), %eax  # stack load f259607
# end emit-variable-ref
    mov %eax, -36(%esp)    # arg f259607
# emit-expr f259608
# emit-variable-ref
# env=((f259609 . -28) (f259608 . -24) (f259607 . -20) (f259609 . -16) (f259608 . -12) (f259607 . -8) ((primitive-ref write) . 44) ((primitive-ref error) . 40) (else . 36) (f259555 . 32) (f259557 . 28) (f259556 . 24) (f259558 . 20) (f259559 . 16) ((primitive-ref write-char) . 12) (f259560 . 8) (f259561 . 4) (f259554 . -28) (f259555 . -24) (f259556 . -20) (f259557 . -16) (f259558 . -12) (f259559 . -8) (f259560 . -4) (f259561 . 0))
# var=f259608
    movl -24(%esp), %eax  # stack load f259608
# end emit-variable-ref
    mov %eax, -40(%esp)    # arg f259608
    movl -32(%esp), %edi   # load new closure to %edi
# emit-shift-args:  size=3   si=-32  delta=28
    mov -32(%esp), %ebx  # shift frame cell
    mov %ebx, -4(%esp)  # down to base
# emit-shift-args:  size=2   si=-36  delta=28
    mov -36(%esp), %ebx  # shift frame cell
    mov %ebx, -8(%esp)  # down to base
# emit-shift-args:  size=1   si=-40  delta=28
    mov -40(%esp), %ebx  # shift frame cell
    mov %ebx, -12(%esp)  # down to base
# emit-shift-args:  size=0   si=-44  delta=28
    movl $8,%eax   # save arg count
    jmp *-2(%edi)  # tail-funcall
_L_1577385:
    jmp _L_1577383
_L_1577382:
# emit-tail-expr
# si=-32
# env=((f259609 . -28) (f259608 . -24) (f259607 . -20) (f259609 . -16) (f259608 . -12) (f259607 . -8) ((primitive-ref write) . 44) ((primitive-ref error) . 40) (else . 36) (f259555 . 32) (f259557 . 28) (f259556 . 24) (f259558 . 20) (f259559 . 16) ((primitive-ref write-char) . 12) (f259560 . 8) (f259561 . 4) (f259554 . -28) (f259555 . -24) (f259556 . -20) (f259557 . -16) (f259558 . -12) (f259559 . -8) (f259560 . -4) (f259561 . 0))
# expr=(if (fixnum? f259607) ((vector-ref f259558 0) f259607 f259608) (if (string? f259607) (if f259609 ((vector-ref f259556 0) f259607 f259608) ((vector-ref f259557 0) f259607 f259608)) (if (pair? f259607) ((vector-ref f259555 0) f259607 f259608) ((primitive-ref error) ((primitive-ref string->symbol) "write") "unrecognized expression"))))
# emit-expr (fixnum? f259607)
# emit-expr f259607
# emit-variable-ref
# env=((f259609 . -28) (f259608 . -24) (f259607 . -20) (f259609 . -16) (f259608 . -12) (f259607 . -8) ((primitive-ref write) . 44) ((primitive-ref error) . 40) (else . 36) (f259555 . 32) (f259557 . 28) (f259556 . 24) (f259558 . 20) (f259559 . 16) ((primitive-ref write-char) . 12) (f259560 . 8) (f259561 . 4) (f259554 . -28) (f259555 . -24) (f259556 . -20) (f259557 . -16) (f259558 . -12) (f259559 . -8) (f259560 . -4) (f259561 . 0))
# var=f259607
    movl -20(%esp), %eax  # stack load f259607
# end emit-variable-ref
    and $3, %al
    cmp $0, %al
    sete %al
    movzbl %al, %eax
    sal $6, %al
    or $47, %al
    cmp $47, %al
    je _L_1577390
# emit-tail-expr
# si=-32
# env=((f259609 . -28) (f259608 . -24) (f259607 . -20) (f259609 . -16) (f259608 . -12) (f259607 . -8) ((primitive-ref write) . 44) ((primitive-ref error) . 40) (else . 36) (f259555 . 32) (f259557 . 28) (f259556 . 24) (f259558 . 20) (f259559 . 16) ((primitive-ref write-char) . 12) (f259560 . 8) (f259561 . 4) (f259554 . -28) (f259555 . -24) (f259556 . -20) (f259557 . -16) (f259558 . -12) (f259559 . -8) (f259560 . -4) (f259561 . 0))
# expr=((vector-ref f259558 0) f259607 f259608)
# emit-tail-funcall
#    si   =-32
#    env  = ((f259609 . -28) (f259608 . -24) (f259607 . -20) (f259609 . -16) (f259608 . -12) (f259607 . -8) ((primitive-ref write) . 44) ((primitive-ref error) . 40) (else . 36) (f259555 . 32) (f259557 . 28) (f259556 . 24) (f259558 . 20) (f259559 . 16) ((primitive-ref write-char) . 12) (f259560 . 8) (f259561 . 4) (f259554 . -28) (f259555 . -24) (f259556 . -20) (f259557 . -16) (f259558 . -12) (f259559 . -8) (f259560 . -4) (f259561 . 0))
#    expr = (funcall (vector-ref f259558 0) f259607 f259608)
# emit-expr (vector-ref f259558 0)
# emit-expr f259558
# emit-variable-ref
# env=((f259609 . -28) (f259608 . -24) (f259607 . -20) (f259609 . -16) (f259608 . -12) (f259607 . -8) ((primitive-ref write) . 44) ((primitive-ref error) . 40) (else . 36) (f259555 . 32) (f259557 . 28) (f259556 . 24) (f259558 . 20) (f259559 . 16) ((primitive-ref write-char) . 12) (f259560 . 8) (f259561 . 4) (f259554 . -28) (f259555 . -24) (f259556 . -20) (f259557 . -16) (f259558 . -12) (f259559 . -8) (f259560 . -4) (f259561 . 0))
# var=f259558
    movl 18(%edi), %eax  # frame load f259558
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1577392
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1577392:
    movl %eax, -32(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1577393"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1577393:
# check bounds on vector index
    movl -32(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1577395
    cmp  $0,%eax
    jge _L_1577394
_L_1577395:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1577394:
    movl -32(%esp), %esi
    movl -1(%eax,%esi), %eax
   movl %eax,  -32(%esp)  # stash funcall-oper in next closure slot
# emit-expr f259607
# emit-variable-ref
# env=((f259609 . -28) (f259608 . -24) (f259607 . -20) (f259609 . -16) (f259608 . -12) (f259607 . -8) ((primitive-ref write) . 44) ((primitive-ref error) . 40) (else . 36) (f259555 . 32) (f259557 . 28) (f259556 . 24) (f259558 . 20) (f259559 . 16) ((primitive-ref write-char) . 12) (f259560 . 8) (f259561 . 4) (f259554 . -28) (f259555 . -24) (f259556 . -20) (f259557 . -16) (f259558 . -12) (f259559 . -8) (f259560 . -4) (f259561 . 0))
# var=f259607
    movl -20(%esp), %eax  # stack load f259607
# end emit-variable-ref
    mov %eax, -36(%esp)    # arg f259607
# emit-expr f259608
# emit-variable-ref
# env=((f259609 . -28) (f259608 . -24) (f259607 . -20) (f259609 . -16) (f259608 . -12) (f259607 . -8) ((primitive-ref write) . 44) ((primitive-ref error) . 40) (else . 36) (f259555 . 32) (f259557 . 28) (f259556 . 24) (f259558 . 20) (f259559 . 16) ((primitive-ref write-char) . 12) (f259560 . 8) (f259561 . 4) (f259554 . -28) (f259555 . -24) (f259556 . -20) (f259557 . -16) (f259558 . -12) (f259559 . -8) (f259560 . -4) (f259561 . 0))
# var=f259608
    movl -24(%esp), %eax  # stack load f259608
# end emit-variable-ref
    mov %eax, -40(%esp)    # arg f259608
    movl -32(%esp), %edi   # load new closure to %edi
# emit-shift-args:  size=3   si=-32  delta=28
    mov -32(%esp), %ebx  # shift frame cell
    mov %ebx, -4(%esp)  # down to base
# emit-shift-args:  size=2   si=-36  delta=28
    mov -36(%esp), %ebx  # shift frame cell
    mov %ebx, -8(%esp)  # down to base
# emit-shift-args:  size=1   si=-40  delta=28
    mov -40(%esp), %ebx  # shift frame cell
    mov %ebx, -12(%esp)  # down to base
# emit-shift-args:  size=0   si=-44  delta=28
    movl $8,%eax   # save arg count
    jmp *-2(%edi)  # tail-funcall
    jmp _L_1577391
_L_1577390:
# emit-tail-expr
# si=-32
# env=((f259609 . -28) (f259608 . -24) (f259607 . -20) (f259609 . -16) (f259608 . -12) (f259607 . -8) ((primitive-ref write) . 44) ((primitive-ref error) . 40) (else . 36) (f259555 . 32) (f259557 . 28) (f259556 . 24) (f259558 . 20) (f259559 . 16) ((primitive-ref write-char) . 12) (f259560 . 8) (f259561 . 4) (f259554 . -28) (f259555 . -24) (f259556 . -20) (f259557 . -16) (f259558 . -12) (f259559 . -8) (f259560 . -4) (f259561 . 0))
# expr=(if (string? f259607) (if f259609 ((vector-ref f259556 0) f259607 f259608) ((vector-ref f259557 0) f259607 f259608)) (if (pair? f259607) ((vector-ref f259555 0) f259607 f259608) ((primitive-ref error) ((primitive-ref string->symbol) "write") "unrecognized expression")))
# emit-expr (string? f259607)
# emit-expr f259607
# emit-variable-ref
# env=((f259609 . -28) (f259608 . -24) (f259607 . -20) (f259609 . -16) (f259608 . -12) (f259607 . -8) ((primitive-ref write) . 44) ((primitive-ref error) . 40) (else . 36) (f259555 . 32) (f259557 . 28) (f259556 . 24) (f259558 . 20) (f259559 . 16) ((primitive-ref write-char) . 12) (f259560 . 8) (f259561 . 4) (f259554 . -28) (f259555 . -24) (f259556 . -20) (f259557 . -16) (f259558 . -12) (f259559 . -8) (f259560 . -4) (f259561 . 0))
# var=f259607
    movl -20(%esp), %eax  # stack load f259607
# end emit-variable-ref
    and $7, %al
    cmp $6, %al
    sete %al
    movzbl %al, %eax
    sal $6, %al
    or $47, %al
    cmp $47, %al
    je _L_1577396
# emit-tail-expr
# si=-32
# env=((f259609 . -28) (f259608 . -24) (f259607 . -20) (f259609 . -16) (f259608 . -12) (f259607 . -8) ((primitive-ref write) . 44) ((primitive-ref error) . 40) (else . 36) (f259555 . 32) (f259557 . 28) (f259556 . 24) (f259558 . 20) (f259559 . 16) ((primitive-ref write-char) . 12) (f259560 . 8) (f259561 . 4) (f259554 . -28) (f259555 . -24) (f259556 . -20) (f259557 . -16) (f259558 . -12) (f259559 . -8) (f259560 . -4) (f259561 . 0))
# expr=(if f259609 ((vector-ref f259556 0) f259607 f259608) ((vector-ref f259557 0) f259607 f259608))
# emit-expr f259609
# emit-variable-ref
# env=((f259609 . -28) (f259608 . -24) (f259607 . -20) (f259609 . -16) (f259608 . -12) (f259607 . -8) ((primitive-ref write) . 44) ((primitive-ref error) . 40) (else . 36) (f259555 . 32) (f259557 . 28) (f259556 . 24) (f259558 . 20) (f259559 . 16) ((primitive-ref write-char) . 12) (f259560 . 8) (f259561 . 4) (f259554 . -28) (f259555 . -24) (f259556 . -20) (f259557 . -16) (f259558 . -12) (f259559 . -8) (f259560 . -4) (f259561 . 0))
# var=f259609
    movl -28(%esp), %eax  # stack load f259609
# end emit-variable-ref
    cmp $47, %al
    je _L_1577398
# emit-tail-expr
# si=-32
# env=((f259609 . -28) (f259608 . -24) (f259607 . -20) (f259609 . -16) (f259608 . -12) (f259607 . -8) ((primitive-ref write) . 44) ((primitive-ref error) . 40) (else . 36) (f259555 . 32) (f259557 . 28) (f259556 . 24) (f259558 . 20) (f259559 . 16) ((primitive-ref write-char) . 12) (f259560 . 8) (f259561 . 4) (f259554 . -28) (f259555 . -24) (f259556 . -20) (f259557 . -16) (f259558 . -12) (f259559 . -8) (f259560 . -4) (f259561 . 0))
# expr=((vector-ref f259556 0) f259607 f259608)
# emit-tail-funcall
#    si   =-32
#    env  = ((f259609 . -28) (f259608 . -24) (f259607 . -20) (f259609 . -16) (f259608 . -12) (f259607 . -8) ((primitive-ref write) . 44) ((primitive-ref error) . 40) (else . 36) (f259555 . 32) (f259557 . 28) (f259556 . 24) (f259558 . 20) (f259559 . 16) ((primitive-ref write-char) . 12) (f259560 . 8) (f259561 . 4) (f259554 . -28) (f259555 . -24) (f259556 . -20) (f259557 . -16) (f259558 . -12) (f259559 . -8) (f259560 . -4) (f259561 . 0))
#    expr = (funcall (vector-ref f259556 0) f259607 f259608)
# emit-expr (vector-ref f259556 0)
# emit-expr f259556
# emit-variable-ref
# env=((f259609 . -28) (f259608 . -24) (f259607 . -20) (f259609 . -16) (f259608 . -12) (f259607 . -8) ((primitive-ref write) . 44) ((primitive-ref error) . 40) (else . 36) (f259555 . 32) (f259557 . 28) (f259556 . 24) (f259558 . 20) (f259559 . 16) ((primitive-ref write-char) . 12) (f259560 . 8) (f259561 . 4) (f259554 . -28) (f259555 . -24) (f259556 . -20) (f259557 . -16) (f259558 . -12) (f259559 . -8) (f259560 . -4) (f259561 . 0))
# var=f259556
    movl 22(%edi), %eax  # frame load f259556
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1577400
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1577400:
    movl %eax, -32(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1577401"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1577401:
# check bounds on vector index
    movl -32(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1577403
    cmp  $0,%eax
    jge _L_1577402
_L_1577403:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1577402:
    movl -32(%esp), %esi
    movl -1(%eax,%esi), %eax
   movl %eax,  -32(%esp)  # stash funcall-oper in next closure slot
# emit-expr f259607
# emit-variable-ref
# env=((f259609 . -28) (f259608 . -24) (f259607 . -20) (f259609 . -16) (f259608 . -12) (f259607 . -8) ((primitive-ref write) . 44) ((primitive-ref error) . 40) (else . 36) (f259555 . 32) (f259557 . 28) (f259556 . 24) (f259558 . 20) (f259559 . 16) ((primitive-ref write-char) . 12) (f259560 . 8) (f259561 . 4) (f259554 . -28) (f259555 . -24) (f259556 . -20) (f259557 . -16) (f259558 . -12) (f259559 . -8) (f259560 . -4) (f259561 . 0))
# var=f259607
    movl -20(%esp), %eax  # stack load f259607
# end emit-variable-ref
    mov %eax, -36(%esp)    # arg f259607
# emit-expr f259608
# emit-variable-ref
# env=((f259609 . -28) (f259608 . -24) (f259607 . -20) (f259609 . -16) (f259608 . -12) (f259607 . -8) ((primitive-ref write) . 44) ((primitive-ref error) . 40) (else . 36) (f259555 . 32) (f259557 . 28) (f259556 . 24) (f259558 . 20) (f259559 . 16) ((primitive-ref write-char) . 12) (f259560 . 8) (f259561 . 4) (f259554 . -28) (f259555 . -24) (f259556 . -20) (f259557 . -16) (f259558 . -12) (f259559 . -8) (f259560 . -4) (f259561 . 0))
# var=f259608
    movl -24(%esp), %eax  # stack load f259608
# end emit-variable-ref
    mov %eax, -40(%esp)    # arg f259608
    movl -32(%esp), %edi   # load new closure to %edi
# emit-shift-args:  size=3   si=-32  delta=28
    mov -32(%esp), %ebx  # shift frame cell
    mov %ebx, -4(%esp)  # down to base
# emit-shift-args:  size=2   si=-36  delta=28
    mov -36(%esp), %ebx  # shift frame cell
    mov %ebx, -8(%esp)  # down to base
# emit-shift-args:  size=1   si=-40  delta=28
    mov -40(%esp), %ebx  # shift frame cell
    mov %ebx, -12(%esp)  # down to base
# emit-shift-args:  size=0   si=-44  delta=28
    movl $8,%eax   # save arg count
    jmp *-2(%edi)  # tail-funcall
    jmp _L_1577399
_L_1577398:
# emit-tail-expr
# si=-32
# env=((f259609 . -28) (f259608 . -24) (f259607 . -20) (f259609 . -16) (f259608 . -12) (f259607 . -8) ((primitive-ref write) . 44) ((primitive-ref error) . 40) (else . 36) (f259555 . 32) (f259557 . 28) (f259556 . 24) (f259558 . 20) (f259559 . 16) ((primitive-ref write-char) . 12) (f259560 . 8) (f259561 . 4) (f259554 . -28) (f259555 . -24) (f259556 . -20) (f259557 . -16) (f259558 . -12) (f259559 . -8) (f259560 . -4) (f259561 . 0))
# expr=((vector-ref f259557 0) f259607 f259608)
# emit-tail-funcall
#    si   =-32
#    env  = ((f259609 . -28) (f259608 . -24) (f259607 . -20) (f259609 . -16) (f259608 . -12) (f259607 . -8) ((primitive-ref write) . 44) ((primitive-ref error) . 40) (else . 36) (f259555 . 32) (f259557 . 28) (f259556 . 24) (f259558 . 20) (f259559 . 16) ((primitive-ref write-char) . 12) (f259560 . 8) (f259561 . 4) (f259554 . -28) (f259555 . -24) (f259556 . -20) (f259557 . -16) (f259558 . -12) (f259559 . -8) (f259560 . -4) (f259561 . 0))
#    expr = (funcall (vector-ref f259557 0) f259607 f259608)
# emit-expr (vector-ref f259557 0)
# emit-expr f259557
# emit-variable-ref
# env=((f259609 . -28) (f259608 . -24) (f259607 . -20) (f259609 . -16) (f259608 . -12) (f259607 . -8) ((primitive-ref write) . 44) ((primitive-ref error) . 40) (else . 36) (f259555 . 32) (f259557 . 28) (f259556 . 24) (f259558 . 20) (f259559 . 16) ((primitive-ref write-char) . 12) (f259560 . 8) (f259561 . 4) (f259554 . -28) (f259555 . -24) (f259556 . -20) (f259557 . -16) (f259558 . -12) (f259559 . -8) (f259560 . -4) (f259561 . 0))
# var=f259557
    movl 26(%edi), %eax  # frame load f259557
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1577404
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1577404:
    movl %eax, -32(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1577405"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1577405:
# check bounds on vector index
    movl -32(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1577407
    cmp  $0,%eax
    jge _L_1577406
_L_1577407:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1577406:
    movl -32(%esp), %esi
    movl -1(%eax,%esi), %eax
   movl %eax,  -32(%esp)  # stash funcall-oper in next closure slot
# emit-expr f259607
# emit-variable-ref
# env=((f259609 . -28) (f259608 . -24) (f259607 . -20) (f259609 . -16) (f259608 . -12) (f259607 . -8) ((primitive-ref write) . 44) ((primitive-ref error) . 40) (else . 36) (f259555 . 32) (f259557 . 28) (f259556 . 24) (f259558 . 20) (f259559 . 16) ((primitive-ref write-char) . 12) (f259560 . 8) (f259561 . 4) (f259554 . -28) (f259555 . -24) (f259556 . -20) (f259557 . -16) (f259558 . -12) (f259559 . -8) (f259560 . -4) (f259561 . 0))
# var=f259607
    movl -20(%esp), %eax  # stack load f259607
# end emit-variable-ref
    mov %eax, -36(%esp)    # arg f259607
# emit-expr f259608
# emit-variable-ref
# env=((f259609 . -28) (f259608 . -24) (f259607 . -20) (f259609 . -16) (f259608 . -12) (f259607 . -8) ((primitive-ref write) . 44) ((primitive-ref error) . 40) (else . 36) (f259555 . 32) (f259557 . 28) (f259556 . 24) (f259558 . 20) (f259559 . 16) ((primitive-ref write-char) . 12) (f259560 . 8) (f259561 . 4) (f259554 . -28) (f259555 . -24) (f259556 . -20) (f259557 . -16) (f259558 . -12) (f259559 . -8) (f259560 . -4) (f259561 . 0))
# var=f259608
    movl -24(%esp), %eax  # stack load f259608
# end emit-variable-ref
    mov %eax, -40(%esp)    # arg f259608
    movl -32(%esp), %edi   # load new closure to %edi
# emit-shift-args:  size=3   si=-32  delta=28
    mov -32(%esp), %ebx  # shift frame cell
    mov %ebx, -4(%esp)  # down to base
# emit-shift-args:  size=2   si=-36  delta=28
    mov -36(%esp), %ebx  # shift frame cell
    mov %ebx, -8(%esp)  # down to base
# emit-shift-args:  size=1   si=-40  delta=28
    mov -40(%esp), %ebx  # shift frame cell
    mov %ebx, -12(%esp)  # down to base
# emit-shift-args:  size=0   si=-44  delta=28
    movl $8,%eax   # save arg count
    jmp *-2(%edi)  # tail-funcall
_L_1577399:
    jmp _L_1577397
_L_1577396:
# emit-tail-expr
# si=-32
# env=((f259609 . -28) (f259608 . -24) (f259607 . -20) (f259609 . -16) (f259608 . -12) (f259607 . -8) ((primitive-ref write) . 44) ((primitive-ref error) . 40) (else . 36) (f259555 . 32) (f259557 . 28) (f259556 . 24) (f259558 . 20) (f259559 . 16) ((primitive-ref write-char) . 12) (f259560 . 8) (f259561 . 4) (f259554 . -28) (f259555 . -24) (f259556 . -20) (f259557 . -16) (f259558 . -12) (f259559 . -8) (f259560 . -4) (f259561 . 0))
# expr=(if (pair? f259607) ((vector-ref f259555 0) f259607 f259608) ((primitive-ref error) ((primitive-ref string->symbol) "write") "unrecognized expression"))
# emit-expr (pair? f259607)
# emit-expr f259607
# emit-variable-ref
# env=((f259609 . -28) (f259608 . -24) (f259607 . -20) (f259609 . -16) (f259608 . -12) (f259607 . -8) ((primitive-ref write) . 44) ((primitive-ref error) . 40) (else . 36) (f259555 . 32) (f259557 . 28) (f259556 . 24) (f259558 . 20) (f259559 . 16) ((primitive-ref write-char) . 12) (f259560 . 8) (f259561 . 4) (f259554 . -28) (f259555 . -24) (f259556 . -20) (f259557 . -16) (f259558 . -12) (f259559 . -8) (f259560 . -4) (f259561 . 0))
# var=f259607
    movl -20(%esp), %eax  # stack load f259607
# end emit-variable-ref
    and $7, %al
    cmp $1, %al
    sete %al
    movzbl %al, %eax
    sal $6, %al
    or $47, %al
    cmp $47, %al
    je _L_1577408
# emit-tail-expr
# si=-32
# env=((f259609 . -28) (f259608 . -24) (f259607 . -20) (f259609 . -16) (f259608 . -12) (f259607 . -8) ((primitive-ref write) . 44) ((primitive-ref error) . 40) (else . 36) (f259555 . 32) (f259557 . 28) (f259556 . 24) (f259558 . 20) (f259559 . 16) ((primitive-ref write-char) . 12) (f259560 . 8) (f259561 . 4) (f259554 . -28) (f259555 . -24) (f259556 . -20) (f259557 . -16) (f259558 . -12) (f259559 . -8) (f259560 . -4) (f259561 . 0))
# expr=((vector-ref f259555 0) f259607 f259608)
# emit-tail-funcall
#    si   =-32
#    env  = ((f259609 . -28) (f259608 . -24) (f259607 . -20) (f259609 . -16) (f259608 . -12) (f259607 . -8) ((primitive-ref write) . 44) ((primitive-ref error) . 40) (else . 36) (f259555 . 32) (f259557 . 28) (f259556 . 24) (f259558 . 20) (f259559 . 16) ((primitive-ref write-char) . 12) (f259560 . 8) (f259561 . 4) (f259554 . -28) (f259555 . -24) (f259556 . -20) (f259557 . -16) (f259558 . -12) (f259559 . -8) (f259560 . -4) (f259561 . 0))
#    expr = (funcall (vector-ref f259555 0) f259607 f259608)
# emit-expr (vector-ref f259555 0)
# emit-expr f259555
# emit-variable-ref
# env=((f259609 . -28) (f259608 . -24) (f259607 . -20) (f259609 . -16) (f259608 . -12) (f259607 . -8) ((primitive-ref write) . 44) ((primitive-ref error) . 40) (else . 36) (f259555 . 32) (f259557 . 28) (f259556 . 24) (f259558 . 20) (f259559 . 16) ((primitive-ref write-char) . 12) (f259560 . 8) (f259561 . 4) (f259554 . -28) (f259555 . -24) (f259556 . -20) (f259557 . -16) (f259558 . -12) (f259559 . -8) (f259560 . -4) (f259561 . 0))
# var=f259555
    movl 30(%edi), %eax  # frame load f259555
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1577410
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1577410:
    movl %eax, -32(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1577411"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1577411:
# check bounds on vector index
    movl -32(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1577413
    cmp  $0,%eax
    jge _L_1577412
_L_1577413:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1577412:
    movl -32(%esp), %esi
    movl -1(%eax,%esi), %eax
   movl %eax,  -32(%esp)  # stash funcall-oper in next closure slot
# emit-expr f259607
# emit-variable-ref
# env=((f259609 . -28) (f259608 . -24) (f259607 . -20) (f259609 . -16) (f259608 . -12) (f259607 . -8) ((primitive-ref write) . 44) ((primitive-ref error) . 40) (else . 36) (f259555 . 32) (f259557 . 28) (f259556 . 24) (f259558 . 20) (f259559 . 16) ((primitive-ref write-char) . 12) (f259560 . 8) (f259561 . 4) (f259554 . -28) (f259555 . -24) (f259556 . -20) (f259557 . -16) (f259558 . -12) (f259559 . -8) (f259560 . -4) (f259561 . 0))
# var=f259607
    movl -20(%esp), %eax  # stack load f259607
# end emit-variable-ref
    mov %eax, -36(%esp)    # arg f259607
# emit-expr f259608
# emit-variable-ref
# env=((f259609 . -28) (f259608 . -24) (f259607 . -20) (f259609 . -16) (f259608 . -12) (f259607 . -8) ((primitive-ref write) . 44) ((primitive-ref error) . 40) (else . 36) (f259555 . 32) (f259557 . 28) (f259556 . 24) (f259558 . 20) (f259559 . 16) ((primitive-ref write-char) . 12) (f259560 . 8) (f259561 . 4) (f259554 . -28) (f259555 . -24) (f259556 . -20) (f259557 . -16) (f259558 . -12) (f259559 . -8) (f259560 . -4) (f259561 . 0))
# var=f259608
    movl -24(%esp), %eax  # stack load f259608
# end emit-variable-ref
    mov %eax, -40(%esp)    # arg f259608
    movl -32(%esp), %edi   # load new closure to %edi
# emit-shift-args:  size=3   si=-32  delta=28
    mov -32(%esp), %ebx  # shift frame cell
    mov %ebx, -4(%esp)  # down to base
# emit-shift-args:  size=2   si=-36  delta=28
    mov -36(%esp), %ebx  # shift frame cell
    mov %ebx, -8(%esp)  # down to base
# emit-shift-args:  size=1   si=-40  delta=28
    mov -40(%esp), %ebx  # shift frame cell
    mov %ebx, -12(%esp)  # down to base
# emit-shift-args:  size=0   si=-44  delta=28
    movl $8,%eax   # save arg count
    jmp *-2(%edi)  # tail-funcall
    jmp _L_1577409
_L_1577408:
# emit-tail-expr
# si=-32
# env=((f259609 . -28) (f259608 . -24) (f259607 . -20) (f259609 . -16) (f259608 . -12) (f259607 . -8) ((primitive-ref write) . 44) ((primitive-ref error) . 40) (else . 36) (f259555 . 32) (f259557 . 28) (f259556 . 24) (f259558 . 20) (f259559 . 16) ((primitive-ref write-char) . 12) (f259560 . 8) (f259561 . 4) (f259554 . -28) (f259555 . -24) (f259556 . -20) (f259557 . -16) (f259558 . -12) (f259559 . -8) (f259560 . -4) (f259561 . 0))
# expr=((primitive-ref error) ((primitive-ref string->symbol) "write") "unrecognized expression")
# emit-tail-funcall
#    si   =-32
#    env  = ((f259609 . -28) (f259608 . -24) (f259607 . -20) (f259609 . -16) (f259608 . -12) (f259607 . -8) ((primitive-ref write) . 44) ((primitive-ref error) . 40) (else . 36) (f259555 . 32) (f259557 . 28) (f259556 . 24) (f259558 . 20) (f259559 . 16) ((primitive-ref write-char) . 12) (f259560 . 8) (f259561 . 4) (f259554 . -28) (f259555 . -24) (f259556 . -20) (f259557 . -16) (f259558 . -12) (f259559 . -8) (f259560 . -4) (f259561 . 0))
#    expr = (funcall (primitive-ref error) ((primitive-ref string->symbol) "write") "unrecognized expression")
# emit-expr (primitive-ref error)
    .extern mrc_error
    movl mrc_error,%eax
   movl %eax,  -32(%esp)  # stash funcall-oper in next closure slot
# emit-expr ((primitive-ref string->symbol) "write")
# funcall
#    si   =-36
#    env  = ((f259609 . -28) (f259608 . -24) (f259607 . -20) (f259609 . -16) (f259608 . -12) (f259607 . -8) ((primitive-ref write) . 44) ((primitive-ref error) . 40) (else . 36) (f259555 . 32) (f259557 . 28) (f259556 . 24) (f259558 . 20) (f259559 . 16) ((primitive-ref write-char) . 12) (f259560 . 8) (f259561 . 4) (f259554 . -28) (f259555 . -24) (f259556 . -20) (f259557 . -16) (f259558 . -12) (f259559 . -8) (f259560 . -4) (f259561 . 0))
#    expr = (funcall (primitive-ref string->symbol) "write")
# emit-expr (primitive-ref string->symbol)
    .extern mrc_string$m$gsymbol
    movl mrc_string$m$gsymbol,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1577414"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1577414":
   movl %eax,  -44(%esp)  # stash funcall-oper in closure slot
# emit-expr "write"
# string literal
    jmp _L_1577416
    .align 8,0x90
_L_1577415 :
    .int 20
    .ascii "write"
_L_1577416:
    movl $_L_1577415, %eax
    orl $6, %eax
    mov %eax, -48(%esp)  # arg write
    movl -44(%esp), %edi   # load new closure to %edi
    add $-36, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $36, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    mov %eax, -36(%esp)    # arg ((primitive-ref string->symbol) write)
# emit-expr "unrecognized expression"
# string literal
    jmp _L_1577418
    .align 8,0x90
_L_1577417 :
    .int 92
    .ascii "unrecognized expression"
_L_1577418:
    movl $_L_1577417, %eax
    orl $6, %eax
    mov %eax, -40(%esp)    # arg unrecognized expression
    movl -32(%esp), %edi   # load new closure to %edi
# emit-shift-args:  size=3   si=-32  delta=28
    mov -32(%esp), %ebx  # shift frame cell
    mov %ebx, -4(%esp)  # down to base
# emit-shift-args:  size=2   si=-36  delta=28
    mov -36(%esp), %ebx  # shift frame cell
    mov %ebx, -8(%esp)  # down to base
# emit-shift-args:  size=1   si=-40  delta=28
    mov -40(%esp), %ebx  # shift frame cell
    mov %ebx, -12(%esp)  # down to base
# emit-shift-args:  size=0   si=-44  delta=28
    movl $8,%eax   # save arg count
    jmp *-2(%edi)  # tail-funcall
_L_1577409:
_L_1577397:
_L_1577391:
_L_1577383:
_L_1577377:
_L_1577371:
    .align 4,0x90
_L_1577368:
# emit-expr (begin)
# emit-begin
#   expr=(begin)
#   env=((f259554 . -28) (f259555 . -24) (f259556 . -20) (f259557 . -16) (f259558 . -12) (f259559 . -8) (f259560 . -4) (f259561 . 0))
     movl %eax, mrc_base$mwrite
# == explicit-begins  ==>
# (lambda (expr . args) (let ((p (if (null? args) (current-output-port) (car args)))) (base-write expr p #f)))
# == eliminate-let*  ==>
# (lambda (expr . args) (let ((p (if (null? args) (current-output-port) (car args)))) (base-write expr p #f)))
# == uniquify-variables  ==>
# (lambda (f259610 . f259611) (let ((f259613 (if (null? f259611) (current-output-port) (car f259611)))) (base-write f259610 f259613 #f)))
# == vectorize-letrec  ==>
# (lambda (f259610 . f259611) (let ((f259613 (if (null? f259611) (current-output-port) (car f259611)))) (base-write f259610 f259613 #f)))
# == eliminate-set!  ==>
# (lambda (f259610 . f259611) (let ((f259610 f259610)) (let ((f259613 (if (null? f259611) (current-output-port) (car f259611)))) (base-write f259610 f259613 #f))))
# == close-free-variables  ==>
# (closure (f259610 . f259611) (base-write) (let ((f259610 f259610)) (let ((f259613 (if (null? f259611) (current-output-port) (car f259611)))) (base-write f259610 f259613 #f))))
# == eliminate-quote  ==>
# (closure (f259610 . f259611) (base-write) (let ((f259610 f259610)) (let ((f259613 (if (null? f259611) (current-output-port) (car f259611)))) (base-write f259610 f259613 #f))))
# == eliminate-when/unless  ==>
# (closure (f259610 . f259611) (base-write) (let ((f259610 f259610)) (let ((f259613 (if (null? f259611) (current-output-port) (car f259611)))) (base-write f259610 f259613 #f))))
# == eliminate-cond  ==>
# (closure (f259610 . f259611) (base-write) (let ((f259610 f259610)) (let ((f259613 (if (null? f259611) (current-output-port) (car f259611)))) (base-write f259610 f259613 #f))))
# == external-symbols  ==>
# (closure (f259610 . f259611) ((primitive-ref base-write)) (let ((f259610 f259610)) (let ((f259613 (if (null? f259611) ((primitive-ref current-output-port)) (car f259611)))) ((primitive-ref base-write) f259610 f259613 #f))))
# emit-expr (closure (f259610 . f259611) ((primitive-ref base-write)) (let ((f259610 f259610)) (let ((f259613 (if (null? f259611) ((primitive-ref current-output-port)) (car f259611)))) ((primitive-ref base-write) f259610 f259613 #f))))
# emit-closure
# si = 0
# env = ()
# expr = (closure (f259610 . f259611) ((primitive-ref base-write)) (let ((f259610 f259610)) (let ((f259613 (if (null? f259611) ((primitive-ref current-output-port)) (car f259611)))) ((primitive-ref base-write) f259610 f259613 #f))))
    movl $_L_1577419, 0(%ebp)  # closure label
# WARNING: free var (primitive-ref base-write) not defined in the environmnet
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $8, %ebp     # bump ebp
    jmp _L_1577420            # jump around closure body
_L_1577419:
# check argument count
    cmp $4,%eax
    jge _L_1577421
# invoke error handler eh_argcount_min
    .extern mrc_eh$uargcount$umin
    movl mrc_eh$uargcount$umin, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_1577421:
# emit-build-varargs-list
    movl $63, %esi       # args <- () 
    lea -4(%esp),%edi    # edi <- esp-4
    subl %eax, %edi      # edi <- esp-4-eax    addr of arg[K+N] on stack
_L_1577423:
    lea -8(%esp),%ebx    # addr of arg[K] on stack
    cmp %edi, %ebx       # while edi <> esp+(si+4)
    je _L_1577422
    movl (%edi),%ebx     # arg i -> car
    movl %ebx, 0(%ebp)
    movl %esi, 4(%ebp)  # esi -> cdr
    movl %ebp, %esi
    addl $1, %esi       # tag as pair
    addl $8,%ebp         # bump heap ptr
    addl $4,%edi         # move to next previous arg from the end
    jmp _L_1577423
_L_1577422:
    movl %esi, -12(%esp)  # set args
# emit-tail-expr
# si=-16
# env=((f259611 . -12) (f259610 . -8) ((primitive-ref base-write) . 4))
# expr=(let ((f259610 f259610)) (let ((f259613 (if (null? f259611) ((primitive-ref current-output-port)) (car f259611)))) ((primitive-ref base-write) f259610 f259613 #f)))
# emit-tail-let
#  si   = -16
#  env  = ((f259611 . -12) (f259610 . -8) ((primitive-ref base-write) . 4))
#  bindings = ((f259610 f259610))
#  body = (let ((f259613 (if (null? f259611) ((primitive-ref current-output-port)) (car f259611)))) ((primitive-ref base-write) f259610 f259613 #f))
# emit-expr f259610
# emit-variable-ref
# env=((f259611 . -12) (f259610 . -8) ((primitive-ref base-write) . 4))
# var=f259610
    movl -8(%esp), %eax  # stack load f259610
# end emit-variable-ref
    movl %eax, -16(%esp)  # stack save
# emit-tail-expr
# si=-20
# env=((f259610 . -16) (f259611 . -12) (f259610 . -8) ((primitive-ref base-write) . 4))
# expr=(let ((f259613 (if (null? f259611) ((primitive-ref current-output-port)) (car f259611)))) ((primitive-ref base-write) f259610 f259613 #f))
# emit-tail-let
#  si   = -20
#  env  = ((f259610 . -16) (f259611 . -12) (f259610 . -8) ((primitive-ref base-write) . 4))
#  bindings = ((f259613 (if (null? f259611) ((primitive-ref current-output-port)) (car f259611))))
#  body = ((primitive-ref base-write) f259610 f259613 #f)
# emit-expr (if (null? f259611) ((primitive-ref current-output-port)) (car f259611))
# emit-expr (null? f259611)
# emit-expr f259611
# emit-variable-ref
# env=((f259610 . -16) (f259611 . -12) (f259610 . -8) ((primitive-ref base-write) . 4))
# var=f259611
    movl -12(%esp), %eax  # stack load f259611
# end emit-variable-ref
    cmp $63, %eax
    mov $0, %eax
    sete %al
    movzbl %al, %eax
    sal $6, %al
    or $47, %al
    cmp $47, %al
    je _L_1577424
# emit-expr ((primitive-ref current-output-port))
# funcall
#    si   =-20
#    env  = ((f259610 . -16) (f259611 . -12) (f259610 . -8) ((primitive-ref base-write) . 4))
#    expr = (funcall (primitive-ref current-output-port))
# emit-expr (primitive-ref current-output-port)
    .extern mrc_current$moutput$mport
    movl mrc_current$moutput$mport,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1577426"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1577426":
   movl %eax,  -28(%esp)  # stash funcall-oper in closure slot
    movl -28(%esp), %edi   # load new closure to %edi
    add $-20, %esp   # adjust base
    movl $0,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $20, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    jmp _L_1577425
_L_1577424:
# emit-expr (car f259611)
# emit-expr f259611
# emit-variable-ref
# env=((f259610 . -16) (f259611 . -12) (f259610 . -8) ((primitive-ref base-write) . 4))
# var=f259611
    movl -12(%esp), %eax  # stack load f259611
# end emit-variable-ref
# check the argument is a pair
    movl %eax,%ebx
    and $7, %bl
    cmp $1, %bl
    je _L_1577427
# invoke error handler eh_pair
    .extern mrc_eh$upair
    movl mrc_eh$upair, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $108,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1577427:
    movl -1(%eax), %eax
_L_1577425:
    movl %eax, -20(%esp)  # stack save
# emit-tail-expr
# si=-24
# env=((f259613 . -20) (f259610 . -16) (f259611 . -12) (f259610 . -8) ((primitive-ref base-write) . 4))
# expr=((primitive-ref base-write) f259610 f259613 #f)
# emit-tail-funcall
#    si   =-24
#    env  = ((f259613 . -20) (f259610 . -16) (f259611 . -12) (f259610 . -8) ((primitive-ref base-write) . 4))
#    expr = (funcall (primitive-ref base-write) f259610 f259613 #f)
# emit-expr (primitive-ref base-write)
    .extern mrc_base$mwrite
    movl mrc_base$mwrite,%eax
   movl %eax,  -24(%esp)  # stash funcall-oper in next closure slot
# emit-expr f259610
# emit-variable-ref
# env=((f259613 . -20) (f259610 . -16) (f259611 . -12) (f259610 . -8) ((primitive-ref base-write) . 4))
# var=f259610
    movl -16(%esp), %eax  # stack load f259610
# end emit-variable-ref
    mov %eax, -28(%esp)    # arg f259610
# emit-expr f259613
# emit-variable-ref
# env=((f259613 . -20) (f259610 . -16) (f259611 . -12) (f259610 . -8) ((primitive-ref base-write) . 4))
# var=f259613
    movl -20(%esp), %eax  # stack load f259613
# end emit-variable-ref
    mov %eax, -32(%esp)    # arg f259613
# emit-expr #f
    movl $47, %eax     # immed #f
    mov %eax, -36(%esp)    # arg #f
    movl -24(%esp), %edi   # load new closure to %edi
# emit-shift-args:  size=4   si=-24  delta=20
    mov -24(%esp), %ebx  # shift frame cell
    mov %ebx, -4(%esp)  # down to base
# emit-shift-args:  size=3   si=-28  delta=20
    mov -28(%esp), %ebx  # shift frame cell
    mov %ebx, -8(%esp)  # down to base
# emit-shift-args:  size=2   si=-32  delta=20
    mov -32(%esp), %ebx  # shift frame cell
    mov %ebx, -12(%esp)  # down to base
# emit-shift-args:  size=1   si=-36  delta=20
    mov -36(%esp), %ebx  # shift frame cell
    mov %ebx, -16(%esp)  # down to base
# emit-shift-args:  size=0   si=-40  delta=20
    movl $12,%eax   # save arg count
    jmp *-2(%edi)  # tail-funcall
    .align 4,0x90
_L_1577420:
     movl %eax, mrc_write
# == explicit-begins  ==>
# (lambda (expr . args) (let ((p (if (null? args) (current-output-port) (car args)))) (base-write expr p #t)))
# == eliminate-let*  ==>
# (lambda (expr . args) (let ((p (if (null? args) (current-output-port) (car args)))) (base-write expr p #t)))
# == uniquify-variables  ==>
# (lambda (f259614 . f259615) (let ((f259617 (if (null? f259615) (current-output-port) (car f259615)))) (base-write f259614 f259617 #t)))
# == vectorize-letrec  ==>
# (lambda (f259614 . f259615) (let ((f259617 (if (null? f259615) (current-output-port) (car f259615)))) (base-write f259614 f259617 #t)))
# == eliminate-set!  ==>
# (lambda (f259614 . f259615) (let ((f259614 f259614)) (let ((f259617 (if (null? f259615) (current-output-port) (car f259615)))) (base-write f259614 f259617 #t))))
# == close-free-variables  ==>
# (closure (f259614 . f259615) (base-write) (let ((f259614 f259614)) (let ((f259617 (if (null? f259615) (current-output-port) (car f259615)))) (base-write f259614 f259617 #t))))
# == eliminate-quote  ==>
# (closure (f259614 . f259615) (base-write) (let ((f259614 f259614)) (let ((f259617 (if (null? f259615) (current-output-port) (car f259615)))) (base-write f259614 f259617 #t))))
# == eliminate-when/unless  ==>
# (closure (f259614 . f259615) (base-write) (let ((f259614 f259614)) (let ((f259617 (if (null? f259615) (current-output-port) (car f259615)))) (base-write f259614 f259617 #t))))
# == eliminate-cond  ==>
# (closure (f259614 . f259615) (base-write) (let ((f259614 f259614)) (let ((f259617 (if (null? f259615) (current-output-port) (car f259615)))) (base-write f259614 f259617 #t))))
# == external-symbols  ==>
# (closure (f259614 . f259615) ((primitive-ref base-write)) (let ((f259614 f259614)) (let ((f259617 (if (null? f259615) ((primitive-ref current-output-port)) (car f259615)))) ((primitive-ref base-write) f259614 f259617 #t))))
# emit-expr (closure (f259614 . f259615) ((primitive-ref base-write)) (let ((f259614 f259614)) (let ((f259617 (if (null? f259615) ((primitive-ref current-output-port)) (car f259615)))) ((primitive-ref base-write) f259614 f259617 #t))))
# emit-closure
# si = 0
# env = ()
# expr = (closure (f259614 . f259615) ((primitive-ref base-write)) (let ((f259614 f259614)) (let ((f259617 (if (null? f259615) ((primitive-ref current-output-port)) (car f259615)))) ((primitive-ref base-write) f259614 f259617 #t))))
    movl $_L_1577428, 0(%ebp)  # closure label
# WARNING: free var (primitive-ref base-write) not defined in the environmnet
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $8, %ebp     # bump ebp
    jmp _L_1577429            # jump around closure body
_L_1577428:
# check argument count
    cmp $4,%eax
    jge _L_1577430
# invoke error handler eh_argcount_min
    .extern mrc_eh$uargcount$umin
    movl mrc_eh$uargcount$umin, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_1577430:
# emit-build-varargs-list
    movl $63, %esi       # args <- () 
    lea -4(%esp),%edi    # edi <- esp-4
    subl %eax, %edi      # edi <- esp-4-eax    addr of arg[K+N] on stack
_L_1577432:
    lea -8(%esp),%ebx    # addr of arg[K] on stack
    cmp %edi, %ebx       # while edi <> esp+(si+4)
    je _L_1577431
    movl (%edi),%ebx     # arg i -> car
    movl %ebx, 0(%ebp)
    movl %esi, 4(%ebp)  # esi -> cdr
    movl %ebp, %esi
    addl $1, %esi       # tag as pair
    addl $8,%ebp         # bump heap ptr
    addl $4,%edi         # move to next previous arg from the end
    jmp _L_1577432
_L_1577431:
    movl %esi, -12(%esp)  # set args
# emit-tail-expr
# si=-16
# env=((f259615 . -12) (f259614 . -8) ((primitive-ref base-write) . 4))
# expr=(let ((f259614 f259614)) (let ((f259617 (if (null? f259615) ((primitive-ref current-output-port)) (car f259615)))) ((primitive-ref base-write) f259614 f259617 #t)))
# emit-tail-let
#  si   = -16
#  env  = ((f259615 . -12) (f259614 . -8) ((primitive-ref base-write) . 4))
#  bindings = ((f259614 f259614))
#  body = (let ((f259617 (if (null? f259615) ((primitive-ref current-output-port)) (car f259615)))) ((primitive-ref base-write) f259614 f259617 #t))
# emit-expr f259614
# emit-variable-ref
# env=((f259615 . -12) (f259614 . -8) ((primitive-ref base-write) . 4))
# var=f259614
    movl -8(%esp), %eax  # stack load f259614
# end emit-variable-ref
    movl %eax, -16(%esp)  # stack save
# emit-tail-expr
# si=-20
# env=((f259614 . -16) (f259615 . -12) (f259614 . -8) ((primitive-ref base-write) . 4))
# expr=(let ((f259617 (if (null? f259615) ((primitive-ref current-output-port)) (car f259615)))) ((primitive-ref base-write) f259614 f259617 #t))
# emit-tail-let
#  si   = -20
#  env  = ((f259614 . -16) (f259615 . -12) (f259614 . -8) ((primitive-ref base-write) . 4))
#  bindings = ((f259617 (if (null? f259615) ((primitive-ref current-output-port)) (car f259615))))
#  body = ((primitive-ref base-write) f259614 f259617 #t)
# emit-expr (if (null? f259615) ((primitive-ref current-output-port)) (car f259615))
# emit-expr (null? f259615)
# emit-expr f259615
# emit-variable-ref
# env=((f259614 . -16) (f259615 . -12) (f259614 . -8) ((primitive-ref base-write) . 4))
# var=f259615
    movl -12(%esp), %eax  # stack load f259615
# end emit-variable-ref
    cmp $63, %eax
    mov $0, %eax
    sete %al
    movzbl %al, %eax
    sal $6, %al
    or $47, %al
    cmp $47, %al
    je _L_1577433
# emit-expr ((primitive-ref current-output-port))
# funcall
#    si   =-20
#    env  = ((f259614 . -16) (f259615 . -12) (f259614 . -8) ((primitive-ref base-write) . 4))
#    expr = (funcall (primitive-ref current-output-port))
# emit-expr (primitive-ref current-output-port)
    .extern mrc_current$moutput$mport
    movl mrc_current$moutput$mport,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1577435"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1577435":
   movl %eax,  -28(%esp)  # stash funcall-oper in closure slot
    movl -28(%esp), %edi   # load new closure to %edi
    add $-20, %esp   # adjust base
    movl $0,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $20, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    jmp _L_1577434
_L_1577433:
# emit-expr (car f259615)
# emit-expr f259615
# emit-variable-ref
# env=((f259614 . -16) (f259615 . -12) (f259614 . -8) ((primitive-ref base-write) . 4))
# var=f259615
    movl -12(%esp), %eax  # stack load f259615
# end emit-variable-ref
# check the argument is a pair
    movl %eax,%ebx
    and $7, %bl
    cmp $1, %bl
    je _L_1577436
# invoke error handler eh_pair
    .extern mrc_eh$upair
    movl mrc_eh$upair, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $108,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1577436:
    movl -1(%eax), %eax
_L_1577434:
    movl %eax, -20(%esp)  # stack save
# emit-tail-expr
# si=-24
# env=((f259617 . -20) (f259614 . -16) (f259615 . -12) (f259614 . -8) ((primitive-ref base-write) . 4))
# expr=((primitive-ref base-write) f259614 f259617 #t)
# emit-tail-funcall
#    si   =-24
#    env  = ((f259617 . -20) (f259614 . -16) (f259615 . -12) (f259614 . -8) ((primitive-ref base-write) . 4))
#    expr = (funcall (primitive-ref base-write) f259614 f259617 #t)
# emit-expr (primitive-ref base-write)
    .extern mrc_base$mwrite
    movl mrc_base$mwrite,%eax
   movl %eax,  -24(%esp)  # stash funcall-oper in next closure slot
# emit-expr f259614
# emit-variable-ref
# env=((f259617 . -20) (f259614 . -16) (f259615 . -12) (f259614 . -8) ((primitive-ref base-write) . 4))
# var=f259614
    movl -16(%esp), %eax  # stack load f259614
# end emit-variable-ref
    mov %eax, -28(%esp)    # arg f259614
# emit-expr f259617
# emit-variable-ref
# env=((f259617 . -20) (f259614 . -16) (f259615 . -12) (f259614 . -8) ((primitive-ref base-write) . 4))
# var=f259617
    movl -20(%esp), %eax  # stack load f259617
# end emit-variable-ref
    mov %eax, -32(%esp)    # arg f259617
# emit-expr #t
    movl $111, %eax     # immed #t
    mov %eax, -36(%esp)    # arg #t
    movl -24(%esp), %edi   # load new closure to %edi
# emit-shift-args:  size=4   si=-24  delta=20
    mov -24(%esp), %ebx  # shift frame cell
    mov %ebx, -4(%esp)  # down to base
# emit-shift-args:  size=3   si=-28  delta=20
    mov -28(%esp), %ebx  # shift frame cell
    mov %ebx, -8(%esp)  # down to base
# emit-shift-args:  size=2   si=-32  delta=20
    mov -32(%esp), %ebx  # shift frame cell
    mov %ebx, -12(%esp)  # down to base
# emit-shift-args:  size=1   si=-36  delta=20
    mov -36(%esp), %ebx  # shift frame cell
    mov %ebx, -16(%esp)  # down to base
# emit-shift-args:  size=0   si=-40  delta=20
    movl $12,%eax   # save arg count
    jmp *-2(%edi)  # tail-funcall
    .align 4,0x90
_L_1577429:
     movl %eax, mrc_display
# == explicit-begins  ==>
# (lambda (i) (fixnum->char i))
# == eliminate-let*  ==>
# (lambda (i) (fixnum->char i))
# == uniquify-variables  ==>
# (lambda (f259618) (fixnum->char f259618))
# == vectorize-letrec  ==>
# (lambda (f259618) (fixnum->char f259618))
# == eliminate-set!  ==>
# (lambda (f259618) (let ((f259618 f259618)) (fixnum->char f259618)))
# == close-free-variables  ==>
# (closure (f259618) () (let ((f259618 f259618)) (fixnum->char f259618)))
# == eliminate-quote  ==>
# (closure (f259618) () (let ((f259618 f259618)) (fixnum->char f259618)))
# == eliminate-when/unless  ==>
# (closure (f259618) () (let ((f259618 f259618)) (fixnum->char f259618)))
# == eliminate-cond  ==>
# (closure (f259618) () (let ((f259618 f259618)) (fixnum->char f259618)))
# == external-symbols  ==>
# (closure (f259618) () (let ((f259618 f259618)) (fixnum->char f259618)))
# emit-expr (closure (f259618) () (let ((f259618 f259618)) (fixnum->char f259618)))
# emit-closure
# si = 0
# env = ()
# expr = (closure (f259618) () (let ((f259618 f259618)) (fixnum->char f259618)))
    movl $_L_1577437, 0(%ebp)  # closure label
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $8, %ebp     # bump ebp
    jmp _L_1577438            # jump around closure body
_L_1577437:
# check argument count
    cmp $4,%eax
    je _L_1577439
# invoke error handler eh_argcount
    .extern mrc_eh$uargcount
    movl mrc_eh$uargcount, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_1577439:
# emit-tail-expr
# si=-12
# env=((f259618 . -8))
# expr=(let ((f259618 f259618)) (fixnum->char f259618))
# emit-tail-let
#  si   = -12
#  env  = ((f259618 . -8))
#  bindings = ((f259618 f259618))
#  body = (fixnum->char f259618)
# emit-expr f259618
# emit-variable-ref
# env=((f259618 . -8))
# var=f259618
    movl -8(%esp), %eax  # stack load f259618
# end emit-variable-ref
    movl %eax, -12(%esp)  # stack save
# emit-tail-expr
# si=-16
# env=((f259618 . -12) (f259618 . -8))
# expr=(fixnum->char f259618)
# tail primcall
# emit-expr f259618
# emit-variable-ref
# env=((f259618 . -12) (f259618 . -8))
# var=f259618
    movl -12(%esp), %eax  # stack load f259618
# end emit-variable-ref
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1577440"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $0,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1577440:
    shll $6, %eax
    orl $15, %eax
#return from tail (fixnum->char f259618)
    ret
    .align 4,0x90
_L_1577438:
     movl %eax, mrc_integer$m$gchar
# emit-expr (begin #t)
# emit-begin
#   expr=(begin #t)
#   env=()
# emit-expr #t
    movl $111, %eax     # immed #t
# emit-expr (begin)
# emit-begin
#   expr=(begin)
#   env=()
    .extern base_init_callback
    jmp base_init_callback
