     .data
     .global "mrc_symbols"
     .align 8
mrc_symbols:
     .int 0xFF
     .global "mrc_string$e$q"
     .align 8
mrc_string$e$q:
     .int 0xFF
     .global "mrc_string$m$gsymbol"
     .align 8
mrc_string$m$gsymbol:
     .int 0xFF
     .global "mrc_append1"
     .align 8
mrc_append1:
     .int 0xFF
     .global "mrc_list$mref"
     .align 8
mrc_list$mref:
     .int 0xFF
     .global "mrc_list$mlength"
     .align 8
mrc_list$mlength:
     .int 0xFF
     .global "mrc_reverse"
     .align 8
mrc_reverse:
     .int 0xFF
     .global "mrc_list"
     .align 8
mrc_list:
     .int 0xFF
     .global "mrc_vector"
     .align 8
mrc_vector:
     .int 0xFF
     .global "mrc_string"
     .align 8
mrc_string:
     .int 0xFF
     .global "mrc_string$m$glist"
     .align 8
mrc_string$m$glist:
     .int 0xFF
     .global "mrc_integer$m$glist"
     .align 8
mrc_integer$m$glist:
     .int 0xFF
     .global "mrc_error"
     .align 8
mrc_error:
     .int 0xFF
     .global "mrc_primitives"
     .align 8
mrc_primitives:
     .int 0xFF
     .global "mrc_eh$uprocedure"
     .align 8
mrc_eh$uprocedure:
     .int 0xFF
     .global "mrc_eh$uargcount"
     .align 8
mrc_eh$uargcount:
     .int 0xFF
     .global "mrc_eh$uargcount$umin"
     .align 8
mrc_eh$uargcount$umin:
     .int 0xFF
     .global "mrc_eh$ufixnum"
     .align 8
mrc_eh$ufixnum:
     .int 0xFF
     .global "mrc_eh$ustring"
     .align 8
mrc_eh$ustring:
     .int 0xFF
     .global "mrc_eh$ucharacter"
     .align 8
mrc_eh$ucharacter:
     .int 0xFF
     .global "mrc_eh$upair"
     .align 8
mrc_eh$upair:
     .int 0xFF
     .global "mrc_eh$uvector"
     .align 8
mrc_eh$uvector:
     .int 0xFF
     .global "mrc_eh$ulength"
     .align 8
mrc_eh$ulength:
     .int 0xFF
     .global "mrc_eh$uvector$uindex"
     .align 8
mrc_eh$uvector$uindex:
     .int 0xFF
     .global "mrc_eh$ustring$uindex"
     .align 8
mrc_eh$ustring$uindex:
     .int 0xFF
     .global "mrc_zero$q"
     .align 8
mrc_zero$q:
     .int 0xFF
     .global "mrc_positive$q"
     .align 8
mrc_positive$q:
     .int 0xFF
     .global "mrc_negative$q"
     .align 8
mrc_negative$q:
     .int 0xFF
     .global "mrc_even$q"
     .align 8
mrc_even$q:
     .int 0xFF
     .global "mrc_odd$q"
     .align 8
mrc_odd$q:
     .int 0xFF
     .global "mrc_map"
     .align 8
mrc_map:
     .int 0xFF
     .global "mrc_for$meach"
     .align 8
mrc_for$meach:
     .int 0xFF
     .global "mrc_standard$mout"
     .align 8
mrc_standard$mout:
     .int 0xFF
     .global "mrc_current$moutput$mport"
     .align 8
mrc_current$moutput$mport:
     .int 0xFF
     .global "mrc_current$minput$mport"
     .align 8
mrc_current$minput$mport:
     .int 0xFF
     .global "mrc_port$mkind"
     .align 8
mrc_port$mkind:
     .int 0xFF
     .global "mrc_port$mpath"
     .align 8
mrc_port$mpath:
     .int 0xFF
     .global "mrc_port$mfd"
     .align 8
mrc_port$mfd:
     .int 0xFF
     .global "mrc_port$mbuf"
     .align 8
mrc_port$mbuf:
     .int 0xFF
     .global "mrc_port$mndx"
     .align 8
mrc_port$mndx:
     .int 0xFF
     .global "mrc_port$mndx$madd1"
     .align 8
mrc_port$mndx$madd1:
     .int 0xFF
     .global "mrc_port$mndx$mreset"
     .align 8
mrc_port$mndx$mreset:
     .int 0xFF
     .global "mrc_port$msize"
     .align 8
mrc_port$msize:
     .int 0xFF
     .global "mrc_write$mchar"
     .align 8
mrc_write$mchar:
     .int 0xFF
     .global "mrc_flush$moutput$mport"
     .align 8
mrc_flush$moutput$mport:
     .int 0xFF
     .global "mrc_exit"
     .align 8
mrc_exit:
     .int 0xFF
     .global "mrc_open$moutput$mfile"
     .align 8
mrc_open$moutput$mfile:
     .int 0xFF
     .global "mrc_close$moutput$mport"
     .align 8
mrc_close$moutput$mport:
     .int 0xFF
     .global "mrc_base$mwrite"
     .align 8
mrc_base$mwrite:
     .int 0xFF
     .global "mrc_write"
     .align 8
mrc_write:
     .int 0xFF
     .global "mrc_display"
     .align 8
mrc_display:
     .int 0xFF
     .global "mrc_integer$m$gchar"
     .align 8
mrc_integer$m$gchar:
     .int 0xFF
     .global "mrc_standard$min"
     .align 8
mrc_standard$min:
     .int 0xFF
     .global "mrc_port$munread"
     .align 8
mrc_port$munread:
     .int 0xFF
     .global "mrc_port$munread$mclear"
     .align 8
mrc_port$munread$mclear:
     .int 0xFF
     .global "mrc_port$munread$mset$b"
     .align 8
mrc_port$munread$mset$b:
     .int 0xFF
     .global "mrc_port$mlast"
     .align 8
mrc_port$mlast:
     .int 0xFF
     .global "mrc_port$mlast$mset$b"
     .align 8
mrc_port$mlast$mset$b:
     .int 0xFF
     .global "mrc_input$mport$q"
     .align 8
mrc_input$mport$q:
     .int 0xFF
     .global "mrc_output$mport$q"
     .align 8
mrc_output$mport$q:
     .int 0xFF
     .global "mrc_open$minput$mfile"
     .align 8
mrc_open$minput$mfile:
     .int 0xFF
     .global "mrc_read$mchar"
     .align 8
mrc_read$mchar:
     .int 0xFF
     .global "mrc_fill$minput$mbuffer"
     .align 8
mrc_fill$minput$mbuffer:
     .int 0xFF
     .global "mrc_unread$mchar"
     .align 8
mrc_unread$mchar:
     .int 0xFF
     .text
     .global base_init
     .align 4
base_init:
# == explicit-begins  ==>
# (let ((interned-symbols (cons (make-symbol "nil" ()) ()))) (lambda () interned-symbols))
# == eliminate-let*  ==>
# (let ((interned-symbols (cons (make-symbol "nil" ()) ()))) (lambda () interned-symbols))
# == uniquify-variables  ==>
# (let ((f6398 (cons (make-symbol "nil" ()) ()))) (lambda () f6398))
# == vectorize-letrec  ==>
# (let ((f6398 (cons (make-symbol "nil" ()) ()))) (lambda () f6398))
# == eliminate-set!  ==>
# (let ((f6398 (cons (make-symbol "nil" ()) ()))) (lambda () (let () f6398)))
# == close-free-variables  ==>
# (let ((f6398 (cons (make-symbol "nil" ()) ()))) (closure () (f6398) (let () f6398)))
# == eliminate-quote  ==>
# (let ((f6398 (cons (make-symbol "nil" ()) ()))) (closure () (f6398) (let () f6398)))
# == eliminate-when/unless  ==>
# (let ((f6398 (cons (make-symbol "nil" ()) ()))) (closure () (f6398) (let () f6398)))
# == eliminate-cond  ==>
# (let ((f6398 (cons (make-symbol "nil" ()) ()))) (closure () (f6398) (let () f6398)))
# == external-symbols  ==>
# (let ((f6398 (cons (make-symbol "nil" ()) ()))) (closure () (f6398) (let () f6398)))
# emit-expr (let ((f6398 (cons (make-symbol "nil" ()) ()))) (closure () (f6398) (let () f6398)))
# emit-let
#  si   = 0
#  env  = ()
#  bindings = ((f6398 (cons (make-symbol "nil" ()) ())))
#  body = (closure () (f6398) (let () f6398))
# emit-expr (cons (make-symbol "nil" ()) ())
# cons arg1=(make-symbol "nil" ()) arg2=()
# emit-expr (make-symbol "nil" ())
# make-symbol arg1="nil" arg2=()
# emit-expr "nil"
# string literal
    jmp _L_38796
    .align 8,0x90
_L_38795 :
    .int 12
    .ascii "nil"
_L_38796:
    movl $_L_38795, %eax
    orl $6, %eax
    movl %eax, 0(%esp)
# emit-expr ()
    movl $63, %eax     # immed ()
    movl %eax, 4(%ebp)
    movl 0(%esp), %eax
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    orl  $3, %eax
    add  $8, %ebp
# make-symbol end
    movl %eax, 0(%esp)
# emit-expr ()
    movl $63, %eax     # immed ()
    movl %eax, 4(%ebp)
    movl 0(%esp), %eax
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    or   $1, %al
    add  $8, %ebp
# cons end
    movl %eax, 0(%esp)  # stack save
# emit-expr (closure () (f6398) (let () f6398))
# emit-closure
# si = -4
# env = ((f6398 . 0))
# expr = (closure () (f6398) (let () f6398))
    movl $_L_38797, 0(%ebp)  # closure label
# emit-variable-ref
# env=((f6398 . 0))
# var=f6398
    movl 0(%esp), %eax  # stack load f6398
# end emit-variable-ref
   movl  %eax, 4(%ebp)  # f6398
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $8, %ebp     # bump ebp
    jmp _L_38798            # jump around closure body
_L_38797:
# check argument count
    cmp $0,%eax
    je _L_38799
# invoke error handler eh_argcount
    .extern mrc_eh$uargcount
    movl mrc_eh$uargcount, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_38799:
# emit-tail-expr
# si=-8
# env=((f6398 . 4) (f6398 . 0))
# expr=(let () f6398)
# emit-tail-let
#  si   = -8
#  env  = ((f6398 . 4) (f6398 . 0))
#  bindings = ()
#  body = f6398
# emit-tail-expr
# si=-8
# env=((f6398 . 4) (f6398 . 0))
# expr=f6398
# emit-tail-variable-ref
# emit-variable-ref
# env=((f6398 . 4) (f6398 . 0))
# var=f6398
    movl 2(%edi), %eax  # frame load f6398
# end emit-variable-ref
    ret
# end emit-tail-variable ref
    .align 4,0x90
_L_38798:
     movl %eax, mrc_symbols
# == explicit-begins  ==>
# (letrec ((slen= (lambda (s1 s2) (fx= (string-length s1) (string-length s2)))) (si= (lambda (s1 s2 i) (char=? (string-ref s1 i) (string-ref s2 i)))) (si<n= (lambda (s1 s2 i n) (if (fx= i n) #t (if (si= s1 s2 i) (si<n= s1 s2 (fx+ i 1) n) #f)))) (ss= (lambda (s1 s2) (if (slen= s1 s2) (si<n= s1 s2 0 (string-length s1)) #f)))) ss=)
# == eliminate-let*  ==>
# (letrec ((slen= (lambda (s1 s2) (fx= (string-length s1) (string-length s2)))) (si= (lambda (s1 s2 i) (char=? (string-ref s1 i) (string-ref s2 i)))) (si<n= (lambda (s1 s2 i n) (if (fx= i n) #t (if (si= s1 s2 i) (si<n= s1 s2 (fx+ i 1) n) #f)))) (ss= (lambda (s1 s2) (if (slen= s1 s2) (si<n= s1 s2 0 (string-length s1)) #f)))) ss=)
# == uniquify-variables  ==>
# (letrec ((f6402 (lambda (f6423 f6424) (fx= (string-length f6423) (string-length f6424)))) (f6401 (lambda (f6420 f6421 f6422) (char=? (string-ref f6420 f6422) (string-ref f6421 f6422)))) (f6400 (lambda (f6416 f6417 f6418 f6419) (if (fx= f6418 f6419) #t (if (f6401 f6416 f6417 f6418) (f6400 f6416 f6417 (fx+ f6418 1) f6419) #f)))) (f6399 (lambda (f6414 f6415) (if (f6402 f6414 f6415) (f6400 f6414 f6415 0 (string-length f6414)) #f)))) f6399)
# == vectorize-letrec  ==>
# (let ((f6402 (make-vector 1)) (f6401 (make-vector 1)) (f6400 (make-vector 1)) (f6399 (make-vector 1))) (begin (begin (vector-set! f6402 0 (lambda (f6423 f6424) (fx= (string-length f6423) (string-length f6424)))) (vector-set! f6401 0 (lambda (f6420 f6421 f6422) (char=? (string-ref f6420 f6422) (string-ref f6421 f6422)))) (vector-set! f6400 0 (lambda (f6416 f6417 f6418 f6419) (if (fx= f6418 f6419) #t (if ((vector-ref f6401 0) f6416 f6417 f6418) ((vector-ref f6400 0) f6416 f6417 (fx+ f6418 1) f6419) #f)))) (vector-set! f6399 0 (lambda (f6414 f6415) (if ((vector-ref f6402 0) f6414 f6415) ((vector-ref f6400 0) f6414 f6415 0 (string-length f6414)) #f)))) (vector-ref f6399 0)))
# == eliminate-set!  ==>
# (let ((f6402 (make-vector 1)) (f6401 (make-vector 1)) (f6400 (make-vector 1)) (f6399 (make-vector 1))) (begin (begin (vector-set! f6402 0 (lambda (f6423 f6424) (let ((f6423 f6423) (f6424 f6424)) (fx= (string-length f6423) (string-length f6424))))) (vector-set! f6401 0 (lambda (f6420 f6421 f6422) (let ((f6420 f6420) (f6421 f6421) (f6422 f6422)) (char=? (string-ref f6420 f6422) (string-ref f6421 f6422))))) (vector-set! f6400 0 (lambda (f6416 f6417 f6418 f6419) (let ((f6416 f6416) (f6417 f6417) (f6418 f6418) (f6419 f6419)) (if (fx= f6418 f6419) #t (if ((vector-ref f6401 0) f6416 f6417 f6418) ((vector-ref f6400 0) f6416 f6417 (fx+ f6418 1) f6419) #f))))) (vector-set! f6399 0 (lambda (f6414 f6415) (let ((f6414 f6414) (f6415 f6415)) (if ((vector-ref f6402 0) f6414 f6415) ((vector-ref f6400 0) f6414 f6415 0 (string-length f6414)) #f))))) (vector-ref f6399 0)))
# == close-free-variables  ==>
# (let ((f6402 (make-vector 1)) (f6401 (make-vector 1)) (f6400 (make-vector 1)) (f6399 (make-vector 1))) (begin (begin (vector-set! f6402 0 (closure (f6423 f6424) () (let ((f6423 f6423) (f6424 f6424)) (fx= (string-length f6423) (string-length f6424))))) (vector-set! f6401 0 (closure (f6420 f6421 f6422) () (let ((f6420 f6420) (f6421 f6421) (f6422 f6422)) (char=? (string-ref f6420 f6422) (string-ref f6421 f6422))))) (vector-set! f6400 0 (closure (f6416 f6417 f6418 f6419) (f6401 f6400) (let ((f6416 f6416) (f6417 f6417) (f6418 f6418) (f6419 f6419)) (if (fx= f6418 f6419) #t (if ((vector-ref f6401 0) f6416 f6417 f6418) ((vector-ref f6400 0) f6416 f6417 (fx+ f6418 1) f6419) #f))))) (vector-set! f6399 0 (closure (f6414 f6415) (f6402 f6400) (let ((f6414 f6414) (f6415 f6415)) (if ((vector-ref f6402 0) f6414 f6415) ((vector-ref f6400 0) f6414 f6415 0 (string-length f6414)) #f))))) (vector-ref f6399 0)))
# == eliminate-quote  ==>
# (let ((f6402 (make-vector 1)) (f6401 (make-vector 1)) (f6400 (make-vector 1)) (f6399 (make-vector 1))) (begin (begin (vector-set! f6402 0 (closure (f6423 f6424) () (let ((f6423 f6423) (f6424 f6424)) (fx= (string-length f6423) (string-length f6424))))) (vector-set! f6401 0 (closure (f6420 f6421 f6422) () (let ((f6420 f6420) (f6421 f6421) (f6422 f6422)) (char=? (string-ref f6420 f6422) (string-ref f6421 f6422))))) (vector-set! f6400 0 (closure (f6416 f6417 f6418 f6419) (f6401 f6400) (let ((f6416 f6416) (f6417 f6417) (f6418 f6418) (f6419 f6419)) (if (fx= f6418 f6419) #t (if ((vector-ref f6401 0) f6416 f6417 f6418) ((vector-ref f6400 0) f6416 f6417 (fx+ f6418 1) f6419) #f))))) (vector-set! f6399 0 (closure (f6414 f6415) (f6402 f6400) (let ((f6414 f6414) (f6415 f6415)) (if ((vector-ref f6402 0) f6414 f6415) ((vector-ref f6400 0) f6414 f6415 0 (string-length f6414)) #f))))) (vector-ref f6399 0)))
# == eliminate-when/unless  ==>
# (let ((f6402 (make-vector 1)) (f6401 (make-vector 1)) (f6400 (make-vector 1)) (f6399 (make-vector 1))) (begin (begin (vector-set! f6402 0 (closure (f6423 f6424) () (let ((f6423 f6423) (f6424 f6424)) (fx= (string-length f6423) (string-length f6424))))) (vector-set! f6401 0 (closure (f6420 f6421 f6422) () (let ((f6420 f6420) (f6421 f6421) (f6422 f6422)) (char=? (string-ref f6420 f6422) (string-ref f6421 f6422))))) (vector-set! f6400 0 (closure (f6416 f6417 f6418 f6419) (f6401 f6400) (let ((f6416 f6416) (f6417 f6417) (f6418 f6418) (f6419 f6419)) (if (fx= f6418 f6419) #t (if ((vector-ref f6401 0) f6416 f6417 f6418) ((vector-ref f6400 0) f6416 f6417 (fx+ f6418 1) f6419) #f))))) (vector-set! f6399 0 (closure (f6414 f6415) (f6402 f6400) (let ((f6414 f6414) (f6415 f6415)) (if ((vector-ref f6402 0) f6414 f6415) ((vector-ref f6400 0) f6414 f6415 0 (string-length f6414)) #f))))) (vector-ref f6399 0)))
# == eliminate-cond  ==>
# (let ((f6402 (make-vector 1)) (f6401 (make-vector 1)) (f6400 (make-vector 1)) (f6399 (make-vector 1))) (begin (begin (vector-set! f6402 0 (closure (f6423 f6424) () (let ((f6423 f6423) (f6424 f6424)) (fx= (string-length f6423) (string-length f6424))))) (vector-set! f6401 0 (closure (f6420 f6421 f6422) () (let ((f6420 f6420) (f6421 f6421) (f6422 f6422)) (char=? (string-ref f6420 f6422) (string-ref f6421 f6422))))) (vector-set! f6400 0 (closure (f6416 f6417 f6418 f6419) (f6401 f6400) (let ((f6416 f6416) (f6417 f6417) (f6418 f6418) (f6419 f6419)) (if (fx= f6418 f6419) #t (if ((vector-ref f6401 0) f6416 f6417 f6418) ((vector-ref f6400 0) f6416 f6417 (fx+ f6418 1) f6419) #f))))) (vector-set! f6399 0 (closure (f6414 f6415) (f6402 f6400) (let ((f6414 f6414) (f6415 f6415)) (if ((vector-ref f6402 0) f6414 f6415) ((vector-ref f6400 0) f6414 f6415 0 (string-length f6414)) #f))))) (vector-ref f6399 0)))
# == external-symbols  ==>
# (let ((f6402 (make-vector 1)) (f6401 (make-vector 1)) (f6400 (make-vector 1)) (f6399 (make-vector 1))) (begin (begin (vector-set! f6402 0 (closure (f6423 f6424) () (let ((f6423 f6423) (f6424 f6424)) (fx= (string-length f6423) (string-length f6424))))) (vector-set! f6401 0 (closure (f6420 f6421 f6422) () (let ((f6420 f6420) (f6421 f6421) (f6422 f6422)) (char=? (string-ref f6420 f6422) (string-ref f6421 f6422))))) (vector-set! f6400 0 (closure (f6416 f6417 f6418 f6419) (f6401 f6400) (let ((f6416 f6416) (f6417 f6417) (f6418 f6418) (f6419 f6419)) (if (fx= f6418 f6419) #t (if ((vector-ref f6401 0) f6416 f6417 f6418) ((vector-ref f6400 0) f6416 f6417 (fx+ f6418 1) f6419) #f))))) (vector-set! f6399 0 (closure (f6414 f6415) (f6402 f6400) (let ((f6414 f6414) (f6415 f6415)) (if ((vector-ref f6402 0) f6414 f6415) ((vector-ref f6400 0) f6414 f6415 0 (string-length f6414)) #f))))) (vector-ref f6399 0)))
# emit-expr (let ((f6402 (make-vector 1)) (f6401 (make-vector 1)) (f6400 (make-vector 1)) (f6399 (make-vector 1))) (begin (begin (vector-set! f6402 0 (closure (f6423 f6424) () (let ((f6423 f6423) (f6424 f6424)) (fx= (string-length f6423) (string-length f6424))))) (vector-set! f6401 0 (closure (f6420 f6421 f6422) () (let ((f6420 f6420) (f6421 f6421) (f6422 f6422)) (char=? (string-ref f6420 f6422) (string-ref f6421 f6422))))) (vector-set! f6400 0 (closure (f6416 f6417 f6418 f6419) (f6401 f6400) (let ((f6416 f6416) (f6417 f6417) (f6418 f6418) (f6419 f6419)) (if (fx= f6418 f6419) #t (if ((vector-ref f6401 0) f6416 f6417 f6418) ((vector-ref f6400 0) f6416 f6417 (fx+ f6418 1) f6419) #f))))) (vector-set! f6399 0 (closure (f6414 f6415) (f6402 f6400) (let ((f6414 f6414) (f6415 f6415)) (if ((vector-ref f6402 0) f6414 f6415) ((vector-ref f6400 0) f6414 f6415 0 (string-length f6414)) #f))))) (vector-ref f6399 0)))
# emit-let
#  si   = 0
#  env  = ()
#  bindings = ((f6402 (make-vector 1)) (f6401 (make-vector 1)) (f6400 (make-vector 1)) (f6399 (make-vector 1)))
#  body = (begin (begin (vector-set! f6402 0 (closure (f6423 f6424) () (let ((f6423 f6423) (f6424 f6424)) (fx= (string-length f6423) (string-length f6424))))) (vector-set! f6401 0 (closure (f6420 f6421 f6422) () (let ((f6420 f6420) (f6421 f6421) (f6422 f6422)) (char=? (string-ref f6420 f6422) (string-ref f6421 f6422))))) (vector-set! f6400 0 (closure (f6416 f6417 f6418 f6419) (f6401 f6400) (let ((f6416 f6416) (f6417 f6417) (f6418 f6418) (f6419 f6419)) (if (fx= f6418 f6419) #t (if ((vector-ref f6401 0) f6416 f6417 f6418) ((vector-ref f6400 0) f6416 f6417 (fx+ f6418 1) f6419) #f))))) (vector-set! f6399 0 (closure (f6414 f6415) (f6402 f6400) (let ((f6414 f6414) (f6415 f6415)) (if ((vector-ref f6402 0) f6414 f6415) ((vector-ref f6400 0) f6414 f6415 0 (string-length f6414)) #f))))) (vector-ref f6399 0))
# emit-expr (make-vector 1)
# make-vector 1
# emit-expr 1
    movl $4, %eax     # immed 1
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_38800"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_38800:
# check the argument is a fixnum >= 0
    cmp $0,%eax
    jge _L_38801
# invoke error handler eh_length
    .extern mrc_eh$ulength
    movl mrc_eh$ulength, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_38801:
    movl %eax, %esi
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    orl  $5, %eax
    addl $4, %esi
    addl $4, %esi
    andl $-8, %esi
    addl %esi, %ebp
    movl %eax, 0(%esp)  # stack save
# emit-expr (make-vector 1)
# make-vector 1
# emit-expr 1
    movl $4, %eax     # immed 1
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_38802"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_38802:
# check the argument is a fixnum >= 0
    cmp $0,%eax
    jge _L_38803
# invoke error handler eh_length
    .extern mrc_eh$ulength
    movl mrc_eh$ulength, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_38803:
    movl %eax, %esi
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    orl  $5, %eax
    addl $4, %esi
    addl $4, %esi
    andl $-8, %esi
    addl %esi, %ebp
    movl %eax, -4(%esp)  # stack save
# emit-expr (make-vector 1)
# make-vector 1
# emit-expr 1
    movl $4, %eax     # immed 1
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_38804"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_38804:
# check the argument is a fixnum >= 0
    cmp $0,%eax
    jge _L_38805
# invoke error handler eh_length
    .extern mrc_eh$ulength
    movl mrc_eh$ulength, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_38805:
    movl %eax, %esi
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    orl  $5, %eax
    addl $4, %esi
    addl $4, %esi
    andl $-8, %esi
    addl %esi, %ebp
    movl %eax, -8(%esp)  # stack save
# emit-expr (make-vector 1)
# make-vector 1
# emit-expr 1
    movl $4, %eax     # immed 1
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_38806"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_38806:
# check the argument is a fixnum >= 0
    cmp $0,%eax
    jge _L_38807
# invoke error handler eh_length
    .extern mrc_eh$ulength
    movl mrc_eh$ulength, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_38807:
    movl %eax, %esi
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    orl  $5, %eax
    addl $4, %esi
    addl $4, %esi
    andl $-8, %esi
    addl %esi, %ebp
    movl %eax, -12(%esp)  # stack save
# emit-expr (begin (begin (vector-set! f6402 0 (closure (f6423 f6424) () (let ((f6423 f6423) (f6424 f6424)) (fx= (string-length f6423) (string-length f6424))))) (vector-set! f6401 0 (closure (f6420 f6421 f6422) () (let ((f6420 f6420) (f6421 f6421) (f6422 f6422)) (char=? (string-ref f6420 f6422) (string-ref f6421 f6422))))) (vector-set! f6400 0 (closure (f6416 f6417 f6418 f6419) (f6401 f6400) (let ((f6416 f6416) (f6417 f6417) (f6418 f6418) (f6419 f6419)) (if (fx= f6418 f6419) #t (if ((vector-ref f6401 0) f6416 f6417 f6418) ((vector-ref f6400 0) f6416 f6417 (fx+ f6418 1) f6419) #f))))) (vector-set! f6399 0 (closure (f6414 f6415) (f6402 f6400) (let ((f6414 f6414) (f6415 f6415)) (if ((vector-ref f6402 0) f6414 f6415) ((vector-ref f6400 0) f6414 f6415 0 (string-length f6414)) #f))))) (vector-ref f6399 0))
# emit-begin
#   expr=(begin (begin (vector-set! f6402 0 (closure (f6423 f6424) () (let ((f6423 f6423) (f6424 f6424)) (fx= (string-length f6423) (string-length f6424))))) (vector-set! f6401 0 (closure (f6420 f6421 f6422) () (let ((f6420 f6420) (f6421 f6421) (f6422 f6422)) (char=? (string-ref f6420 f6422) (string-ref f6421 f6422))))) (vector-set! f6400 0 (closure (f6416 f6417 f6418 f6419) (f6401 f6400) (let ((f6416 f6416) (f6417 f6417) (f6418 f6418) (f6419 f6419)) (if (fx= f6418 f6419) #t (if ((vector-ref f6401 0) f6416 f6417 f6418) ((vector-ref f6400 0) f6416 f6417 (fx+ f6418 1) f6419) #f))))) (vector-set! f6399 0 (closure (f6414 f6415) (f6402 f6400) (let ((f6414 f6414) (f6415 f6415)) (if ((vector-ref f6402 0) f6414 f6415) ((vector-ref f6400 0) f6414 f6415 0 (string-length f6414)) #f))))) (vector-ref f6399 0))
#   env=((f6399 . -12) (f6400 . -8) (f6401 . -4) (f6402 . 0))
# emit-expr (begin (vector-set! f6402 0 (closure (f6423 f6424) () (let ((f6423 f6423) (f6424 f6424)) (fx= (string-length f6423) (string-length f6424))))) (vector-set! f6401 0 (closure (f6420 f6421 f6422) () (let ((f6420 f6420) (f6421 f6421) (f6422 f6422)) (char=? (string-ref f6420 f6422) (string-ref f6421 f6422))))) (vector-set! f6400 0 (closure (f6416 f6417 f6418 f6419) (f6401 f6400) (let ((f6416 f6416) (f6417 f6417) (f6418 f6418) (f6419 f6419)) (if (fx= f6418 f6419) #t (if ((vector-ref f6401 0) f6416 f6417 f6418) ((vector-ref f6400 0) f6416 f6417 (fx+ f6418 1) f6419) #f))))) (vector-set! f6399 0 (closure (f6414 f6415) (f6402 f6400) (let ((f6414 f6414) (f6415 f6415)) (if ((vector-ref f6402 0) f6414 f6415) ((vector-ref f6400 0) f6414 f6415 0 (string-length f6414)) #f)))))
# emit-begin
#   expr=(begin (vector-set! f6402 0 (closure (f6423 f6424) () (let ((f6423 f6423) (f6424 f6424)) (fx= (string-length f6423) (string-length f6424))))) (vector-set! f6401 0 (closure (f6420 f6421 f6422) () (let ((f6420 f6420) (f6421 f6421) (f6422 f6422)) (char=? (string-ref f6420 f6422) (string-ref f6421 f6422))))) (vector-set! f6400 0 (closure (f6416 f6417 f6418 f6419) (f6401 f6400) (let ((f6416 f6416) (f6417 f6417) (f6418 f6418) (f6419 f6419)) (if (fx= f6418 f6419) #t (if ((vector-ref f6401 0) f6416 f6417 f6418) ((vector-ref f6400 0) f6416 f6417 (fx+ f6418 1) f6419) #f))))) (vector-set! f6399 0 (closure (f6414 f6415) (f6402 f6400) (let ((f6414 f6414) (f6415 f6415)) (if ((vector-ref f6402 0) f6414 f6415) ((vector-ref f6400 0) f6414 f6415 0 (string-length f6414)) #f)))))
#   env=((f6399 . -12) (f6400 . -8) (f6401 . -4) (f6402 . 0))
# emit-expr (vector-set! f6402 0 (closure (f6423 f6424) () (let ((f6423 f6423) (f6424 f6424)) (fx= (string-length f6423) (string-length f6424)))))
# emit-expr f6402
# emit-variable-ref
# env=((f6399 . -12) (f6400 . -8) (f6401 . -4) (f6402 . 0))
# var=f6402
    movl 0(%esp), %eax  # stack load f6402
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_38808
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_38808:
    movl %eax, -16(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_38809"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_38809:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_38811
    cmp  $0,%eax
    jge _L_38810
_L_38811:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_38810:
    movl %eax, -20(%esp)
# emit-expr (closure (f6423 f6424) () (let ((f6423 f6423) (f6424 f6424)) (fx= (string-length f6423) (string-length f6424))))
# emit-closure
# si = -24
# env = ((f6399 . -12) (f6400 . -8) (f6401 . -4) (f6402 . 0))
# expr = (closure (f6423 f6424) () (let ((f6423 f6423) (f6424 f6424)) (fx= (string-length f6423) (string-length f6424))))
    movl $_L_38812, 0(%ebp)  # closure label
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $8, %ebp     # bump ebp
    jmp _L_38813            # jump around closure body
_L_38812:
# check argument count
    cmp $8,%eax
    je _L_38814
# invoke error handler eh_argcount
    .extern mrc_eh$uargcount
    movl mrc_eh$uargcount, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_38814:
# emit-tail-expr
# si=-16
# env=((f6424 . -12) (f6423 . -8) (f6399 . -12) (f6400 . -8) (f6401 . -4) (f6402 . 0))
# expr=(let ((f6423 f6423) (f6424 f6424)) (fx= (string-length f6423) (string-length f6424)))
# emit-tail-let
#  si   = -16
#  env  = ((f6424 . -12) (f6423 . -8) (f6399 . -12) (f6400 . -8) (f6401 . -4) (f6402 . 0))
#  bindings = ((f6423 f6423) (f6424 f6424))
#  body = (fx= (string-length f6423) (string-length f6424))
# emit-expr f6423
# emit-variable-ref
# env=((f6424 . -12) (f6423 . -8) (f6399 . -12) (f6400 . -8) (f6401 . -4) (f6402 . 0))
# var=f6423
    movl -8(%esp), %eax  # stack load f6423
# end emit-variable-ref
    movl %eax, -16(%esp)  # stack save
# emit-expr f6424
# emit-variable-ref
# env=((f6424 . -12) (f6423 . -8) (f6399 . -12) (f6400 . -8) (f6401 . -4) (f6402 . 0))
# var=f6424
    movl -12(%esp), %eax  # stack load f6424
# end emit-variable-ref
    movl %eax, -20(%esp)  # stack save
# emit-tail-expr
# si=-24
# env=((f6424 . -20) (f6423 . -16) (f6424 . -12) (f6423 . -8) (f6399 . -12) (f6400 . -8) (f6401 . -4) (f6402 . 0))
# expr=(fx= (string-length f6423) (string-length f6424))
# tail primcall
# emit-expr (string-length f6424)
# emit-expr f6424
# emit-variable-ref
# env=((f6424 . -20) (f6423 . -16) (f6424 . -12) (f6423 . -8) (f6399 . -12) (f6400 . -8) (f6401 . -4) (f6402 . 0))
# var=f6424
    movl -20(%esp), %eax  # stack load f6424
# end emit-variable-ref
# check the argument is a string
    movl %eax,%ebx
    and $7, %bl
    cmp $6, %bl
    je _L_38815
# invoke error handler eh_string
    .extern mrc_eh$ustring
    movl mrc_eh$ustring, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $160,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_38815:
    movl -6(%eax), %eax
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_38816"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $68,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_38816:
    movl %eax, -24(%esp)
# emit-expr (string-length f6423)
# emit-expr f6423
# emit-variable-ref
# env=((f6424 . -20) (f6423 . -16) (f6424 . -12) (f6423 . -8) (f6399 . -12) (f6400 . -8) (f6401 . -4) (f6402 . 0))
# var=f6423
    movl -16(%esp), %eax  # stack load f6423
# end emit-variable-ref
# check the argument is a string
    movl %eax,%ebx
    and $7, %bl
    cmp $6, %bl
    je _L_38817
# invoke error handler eh_string
    .extern mrc_eh$ustring
    movl mrc_eh$ustring, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $160,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_38817:
    movl -6(%eax), %eax
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_38818"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $68,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_38818:
    cmp -24(%esp), %eax
    sete %al
    movzbl %al, %eax
    sal $6, %al
    or $47, %al
#return from tail (fx= (string-length f6423) (string-length f6424))
    ret
    .align 4,0x90
_L_38813:
    movl -16(%esp), %ebx
    movl -20(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin (vector-set! f6401 0 (closure (f6420 f6421 f6422) () (let ((f6420 f6420) (f6421 f6421) (f6422 f6422)) (char=? (string-ref f6420 f6422) (string-ref f6421 f6422))))) (vector-set! f6400 0 (closure (f6416 f6417 f6418 f6419) (f6401 f6400) (let ((f6416 f6416) (f6417 f6417) (f6418 f6418) (f6419 f6419)) (if (fx= f6418 f6419) #t (if ((vector-ref f6401 0) f6416 f6417 f6418) ((vector-ref f6400 0) f6416 f6417 (fx+ f6418 1) f6419) #f))))) (vector-set! f6399 0 (closure (f6414 f6415) (f6402 f6400) (let ((f6414 f6414) (f6415 f6415)) (if ((vector-ref f6402 0) f6414 f6415) ((vector-ref f6400 0) f6414 f6415 0 (string-length f6414)) #f)))))
# emit-begin
#   expr=(begin (vector-set! f6401 0 (closure (f6420 f6421 f6422) () (let ((f6420 f6420) (f6421 f6421) (f6422 f6422)) (char=? (string-ref f6420 f6422) (string-ref f6421 f6422))))) (vector-set! f6400 0 (closure (f6416 f6417 f6418 f6419) (f6401 f6400) (let ((f6416 f6416) (f6417 f6417) (f6418 f6418) (f6419 f6419)) (if (fx= f6418 f6419) #t (if ((vector-ref f6401 0) f6416 f6417 f6418) ((vector-ref f6400 0) f6416 f6417 (fx+ f6418 1) f6419) #f))))) (vector-set! f6399 0 (closure (f6414 f6415) (f6402 f6400) (let ((f6414 f6414) (f6415 f6415)) (if ((vector-ref f6402 0) f6414 f6415) ((vector-ref f6400 0) f6414 f6415 0 (string-length f6414)) #f)))))
#   env=((f6399 . -12) (f6400 . -8) (f6401 . -4) (f6402 . 0))
# emit-expr (vector-set! f6401 0 (closure (f6420 f6421 f6422) () (let ((f6420 f6420) (f6421 f6421) (f6422 f6422)) (char=? (string-ref f6420 f6422) (string-ref f6421 f6422)))))
# emit-expr f6401
# emit-variable-ref
# env=((f6399 . -12) (f6400 . -8) (f6401 . -4) (f6402 . 0))
# var=f6401
    movl -4(%esp), %eax  # stack load f6401
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_38819
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_38819:
    movl %eax, -16(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_38820"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_38820:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_38822
    cmp  $0,%eax
    jge _L_38821
_L_38822:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_38821:
    movl %eax, -20(%esp)
# emit-expr (closure (f6420 f6421 f6422) () (let ((f6420 f6420) (f6421 f6421) (f6422 f6422)) (char=? (string-ref f6420 f6422) (string-ref f6421 f6422))))
# emit-closure
# si = -24
# env = ((f6399 . -12) (f6400 . -8) (f6401 . -4) (f6402 . 0))
# expr = (closure (f6420 f6421 f6422) () (let ((f6420 f6420) (f6421 f6421) (f6422 f6422)) (char=? (string-ref f6420 f6422) (string-ref f6421 f6422))))
    movl $_L_38823, 0(%ebp)  # closure label
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $8, %ebp     # bump ebp
    jmp _L_38824            # jump around closure body
_L_38823:
# check argument count
    cmp $12,%eax
    je _L_38825
# invoke error handler eh_argcount
    .extern mrc_eh$uargcount
    movl mrc_eh$uargcount, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_38825:
# emit-tail-expr
# si=-20
# env=((f6422 . -16) (f6421 . -12) (f6420 . -8) (f6399 . -12) (f6400 . -8) (f6401 . -4) (f6402 . 0))
# expr=(let ((f6420 f6420) (f6421 f6421) (f6422 f6422)) (char=? (string-ref f6420 f6422) (string-ref f6421 f6422)))
# emit-tail-let
#  si   = -20
#  env  = ((f6422 . -16) (f6421 . -12) (f6420 . -8) (f6399 . -12) (f6400 . -8) (f6401 . -4) (f6402 . 0))
#  bindings = ((f6420 f6420) (f6421 f6421) (f6422 f6422))
#  body = (char=? (string-ref f6420 f6422) (string-ref f6421 f6422))
# emit-expr f6420
# emit-variable-ref
# env=((f6422 . -16) (f6421 . -12) (f6420 . -8) (f6399 . -12) (f6400 . -8) (f6401 . -4) (f6402 . 0))
# var=f6420
    movl -8(%esp), %eax  # stack load f6420
# end emit-variable-ref
    movl %eax, -20(%esp)  # stack save
# emit-expr f6421
# emit-variable-ref
# env=((f6422 . -16) (f6421 . -12) (f6420 . -8) (f6399 . -12) (f6400 . -8) (f6401 . -4) (f6402 . 0))
# var=f6421
    movl -12(%esp), %eax  # stack load f6421
# end emit-variable-ref
    movl %eax, -24(%esp)  # stack save
# emit-expr f6422
# emit-variable-ref
# env=((f6422 . -16) (f6421 . -12) (f6420 . -8) (f6399 . -12) (f6400 . -8) (f6401 . -4) (f6402 . 0))
# var=f6422
    movl -16(%esp), %eax  # stack load f6422
# end emit-variable-ref
    movl %eax, -28(%esp)  # stack save
# emit-tail-expr
# si=-32
# env=((f6422 . -28) (f6421 . -24) (f6420 . -20) (f6422 . -16) (f6421 . -12) (f6420 . -8) (f6399 . -12) (f6400 . -8) (f6401 . -4) (f6402 . 0))
# expr=(char=? (string-ref f6420 f6422) (string-ref f6421 f6422))
# tail primcall
# char= c1=(string-ref f6420 f6422) c2=(string-ref f6421 f6422)
# emit-expr (string-ref f6420 f6422)
# emit-expr f6420
# emit-variable-ref
# env=((f6422 . -28) (f6421 . -24) (f6420 . -20) (f6422 . -16) (f6421 . -12) (f6420 . -8) (f6399 . -12) (f6400 . -8) (f6401 . -4) (f6402 . 0))
# var=f6420
    movl -20(%esp), %eax  # stack load f6420
# end emit-variable-ref
# check the argument is a string
    movl %eax,%ebx
    and $7, %bl
    cmp $6, %bl
    je _L_38826
# invoke error handler eh_string
    .extern mrc_eh$ustring
    movl mrc_eh$ustring, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $164,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_38826:
    movl %eax, -32(%esp)
# emit-expr f6422
# emit-variable-ref
# env=((f6422 . -28) (f6421 . -24) (f6420 . -20) (f6422 . -16) (f6421 . -12) (f6420 . -8) (f6399 . -12) (f6400 . -8) (f6401 . -4) (f6402 . 0))
# var=f6422
    movl -28(%esp), %eax  # stack load f6422
# end emit-variable-ref
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_38827"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $164,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_38827:
# check bounds on string index
    movl -32(%esp), %ebx
    cmp  %eax,-6(%ebx) 
    jle _L_38829
    cmp  $0,%eax
    jge _L_38828
_L_38829:
# invoke error handler eh_string_index
    .extern mrc_eh$ustring$uindex
    movl mrc_eh$ustring$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $164,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_38828:
    sar $2, %eax
    movl -32(%esp), %esi
    movl -2(%eax,%esi), %eax
    sal $8, %eax
    or  $15, %eax
# check the argument is a char
    movl %eax,%ebx
    and $255, %bl
    cmp $15, %bl
    je "_L_38830"
# invoke error handler eh_character
    .extern mrc_eh$ucharacter
    movl mrc_eh$ucharacter, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $40,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_38830:
    movb %ah, -32(%esp)
# emit-expr (string-ref f6421 f6422)
# emit-expr f6421
# emit-variable-ref
# env=((f6422 . -28) (f6421 . -24) (f6420 . -20) (f6422 . -16) (f6421 . -12) (f6420 . -8) (f6399 . -12) (f6400 . -8) (f6401 . -4) (f6402 . 0))
# var=f6421
    movl -24(%esp), %eax  # stack load f6421
# end emit-variable-ref
# check the argument is a string
    movl %eax,%ebx
    and $7, %bl
    cmp $6, %bl
    je _L_38831
# invoke error handler eh_string
    .extern mrc_eh$ustring
    movl mrc_eh$ustring, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $164,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_38831:
    movl %eax, -36(%esp)
# emit-expr f6422
# emit-variable-ref
# env=((f6422 . -28) (f6421 . -24) (f6420 . -20) (f6422 . -16) (f6421 . -12) (f6420 . -8) (f6399 . -12) (f6400 . -8) (f6401 . -4) (f6402 . 0))
# var=f6422
    movl -28(%esp), %eax  # stack load f6422
# end emit-variable-ref
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_38832"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $164,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_38832:
# check bounds on string index
    movl -36(%esp), %ebx
    cmp  %eax,-6(%ebx) 
    jle _L_38834
    cmp  $0,%eax
    jge _L_38833
_L_38834:
# invoke error handler eh_string_index
    .extern mrc_eh$ustring$uindex
    movl mrc_eh$ustring$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $164,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_38833:
    sar $2, %eax
    movl -36(%esp), %esi
    movl -2(%eax,%esi), %eax
    sal $8, %eax
    or  $15, %eax
# check the argument is a char
    movl %eax,%ebx
    and $255, %bl
    cmp $15, %bl
    je "_L_38835"
# invoke error handler eh_character
    .extern mrc_eh$ucharacter
    movl mrc_eh$ucharacter, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $40,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_38835:
    cmp %ah, -32(%esp)
    sete %al
    movzbl %al, %eax
    sal $6, %al
    or $47, %al
#return from tail (char=? (string-ref f6420 f6422) (string-ref f6421 f6422))
    ret
    .align 4,0x90
_L_38824:
    movl -16(%esp), %ebx
    movl -20(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin (vector-set! f6400 0 (closure (f6416 f6417 f6418 f6419) (f6401 f6400) (let ((f6416 f6416) (f6417 f6417) (f6418 f6418) (f6419 f6419)) (if (fx= f6418 f6419) #t (if ((vector-ref f6401 0) f6416 f6417 f6418) ((vector-ref f6400 0) f6416 f6417 (fx+ f6418 1) f6419) #f))))) (vector-set! f6399 0 (closure (f6414 f6415) (f6402 f6400) (let ((f6414 f6414) (f6415 f6415)) (if ((vector-ref f6402 0) f6414 f6415) ((vector-ref f6400 0) f6414 f6415 0 (string-length f6414)) #f)))))
# emit-begin
#   expr=(begin (vector-set! f6400 0 (closure (f6416 f6417 f6418 f6419) (f6401 f6400) (let ((f6416 f6416) (f6417 f6417) (f6418 f6418) (f6419 f6419)) (if (fx= f6418 f6419) #t (if ((vector-ref f6401 0) f6416 f6417 f6418) ((vector-ref f6400 0) f6416 f6417 (fx+ f6418 1) f6419) #f))))) (vector-set! f6399 0 (closure (f6414 f6415) (f6402 f6400) (let ((f6414 f6414) (f6415 f6415)) (if ((vector-ref f6402 0) f6414 f6415) ((vector-ref f6400 0) f6414 f6415 0 (string-length f6414)) #f)))))
#   env=((f6399 . -12) (f6400 . -8) (f6401 . -4) (f6402 . 0))
# emit-expr (vector-set! f6400 0 (closure (f6416 f6417 f6418 f6419) (f6401 f6400) (let ((f6416 f6416) (f6417 f6417) (f6418 f6418) (f6419 f6419)) (if (fx= f6418 f6419) #t (if ((vector-ref f6401 0) f6416 f6417 f6418) ((vector-ref f6400 0) f6416 f6417 (fx+ f6418 1) f6419) #f)))))
# emit-expr f6400
# emit-variable-ref
# env=((f6399 . -12) (f6400 . -8) (f6401 . -4) (f6402 . 0))
# var=f6400
    movl -8(%esp), %eax  # stack load f6400
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_38836
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_38836:
    movl %eax, -16(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_38837"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_38837:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_38839
    cmp  $0,%eax
    jge _L_38838
_L_38839:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_38838:
    movl %eax, -20(%esp)
# emit-expr (closure (f6416 f6417 f6418 f6419) (f6401 f6400) (let ((f6416 f6416) (f6417 f6417) (f6418 f6418) (f6419 f6419)) (if (fx= f6418 f6419) #t (if ((vector-ref f6401 0) f6416 f6417 f6418) ((vector-ref f6400 0) f6416 f6417 (fx+ f6418 1) f6419) #f))))
# emit-closure
# si = -24
# env = ((f6399 . -12) (f6400 . -8) (f6401 . -4) (f6402 . 0))
# expr = (closure (f6416 f6417 f6418 f6419) (f6401 f6400) (let ((f6416 f6416) (f6417 f6417) (f6418 f6418) (f6419 f6419)) (if (fx= f6418 f6419) #t (if ((vector-ref f6401 0) f6416 f6417 f6418) ((vector-ref f6400 0) f6416 f6417 (fx+ f6418 1) f6419) #f))))
    movl $_L_38840, 0(%ebp)  # closure label
# emit-variable-ref
# env=((f6399 . -12) (f6400 . -8) (f6401 . -4) (f6402 . 0))
# var=f6401
    movl -4(%esp), %eax  # stack load f6401
# end emit-variable-ref
   movl  %eax, 4(%ebp)  # f6401
# emit-variable-ref
# env=((f6399 . -12) (f6400 . -8) (f6401 . -4) (f6402 . 0))
# var=f6400
    movl -8(%esp), %eax  # stack load f6400
# end emit-variable-ref
   movl  %eax, 8(%ebp)  # f6400
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $16, %ebp     # bump ebp
    jmp _L_38841            # jump around closure body
_L_38840:
# check argument count
    cmp $16,%eax
    je _L_38842
# invoke error handler eh_argcount
    .extern mrc_eh$uargcount
    movl mrc_eh$uargcount, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_38842:
# emit-tail-expr
# si=-24
# env=((f6419 . -20) (f6418 . -16) (f6417 . -12) (f6416 . -8) (f6400 . 8) (f6401 . 4) (f6399 . -12) (f6400 . -8) (f6401 . -4) (f6402 . 0))
# expr=(let ((f6416 f6416) (f6417 f6417) (f6418 f6418) (f6419 f6419)) (if (fx= f6418 f6419) #t (if ((vector-ref f6401 0) f6416 f6417 f6418) ((vector-ref f6400 0) f6416 f6417 (fx+ f6418 1) f6419) #f)))
# emit-tail-let
#  si   = -24
#  env  = ((f6419 . -20) (f6418 . -16) (f6417 . -12) (f6416 . -8) (f6400 . 8) (f6401 . 4) (f6399 . -12) (f6400 . -8) (f6401 . -4) (f6402 . 0))
#  bindings = ((f6416 f6416) (f6417 f6417) (f6418 f6418) (f6419 f6419))
#  body = (if (fx= f6418 f6419) #t (if ((vector-ref f6401 0) f6416 f6417 f6418) ((vector-ref f6400 0) f6416 f6417 (fx+ f6418 1) f6419) #f))
# emit-expr f6416
# emit-variable-ref
# env=((f6419 . -20) (f6418 . -16) (f6417 . -12) (f6416 . -8) (f6400 . 8) (f6401 . 4) (f6399 . -12) (f6400 . -8) (f6401 . -4) (f6402 . 0))
# var=f6416
    movl -8(%esp), %eax  # stack load f6416
# end emit-variable-ref
    movl %eax, -24(%esp)  # stack save
# emit-expr f6417
# emit-variable-ref
# env=((f6419 . -20) (f6418 . -16) (f6417 . -12) (f6416 . -8) (f6400 . 8) (f6401 . 4) (f6399 . -12) (f6400 . -8) (f6401 . -4) (f6402 . 0))
# var=f6417
    movl -12(%esp), %eax  # stack load f6417
# end emit-variable-ref
    movl %eax, -28(%esp)  # stack save
# emit-expr f6418
# emit-variable-ref
# env=((f6419 . -20) (f6418 . -16) (f6417 . -12) (f6416 . -8) (f6400 . 8) (f6401 . 4) (f6399 . -12) (f6400 . -8) (f6401 . -4) (f6402 . 0))
# var=f6418
    movl -16(%esp), %eax  # stack load f6418
# end emit-variable-ref
    movl %eax, -32(%esp)  # stack save
# emit-expr f6419
# emit-variable-ref
# env=((f6419 . -20) (f6418 . -16) (f6417 . -12) (f6416 . -8) (f6400 . 8) (f6401 . 4) (f6399 . -12) (f6400 . -8) (f6401 . -4) (f6402 . 0))
# var=f6419
    movl -20(%esp), %eax  # stack load f6419
# end emit-variable-ref
    movl %eax, -36(%esp)  # stack save
# emit-tail-expr
# si=-40
# env=((f6419 . -36) (f6418 . -32) (f6417 . -28) (f6416 . -24) (f6419 . -20) (f6418 . -16) (f6417 . -12) (f6416 . -8) (f6400 . 8) (f6401 . 4) (f6399 . -12) (f6400 . -8) (f6401 . -4) (f6402 . 0))
# expr=(if (fx= f6418 f6419) #t (if ((vector-ref f6401 0) f6416 f6417 f6418) ((vector-ref f6400 0) f6416 f6417 (fx+ f6418 1) f6419) #f))
# emit-expr (fx= f6418 f6419)
# emit-expr f6419
# emit-variable-ref
# env=((f6419 . -36) (f6418 . -32) (f6417 . -28) (f6416 . -24) (f6419 . -20) (f6418 . -16) (f6417 . -12) (f6416 . -8) (f6400 . 8) (f6401 . 4) (f6399 . -12) (f6400 . -8) (f6401 . -4) (f6402 . 0))
# var=f6419
    movl -36(%esp), %eax  # stack load f6419
# end emit-variable-ref
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_38845"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $68,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_38845:
    movl %eax, -40(%esp)
# emit-expr f6418
# emit-variable-ref
# env=((f6419 . -36) (f6418 . -32) (f6417 . -28) (f6416 . -24) (f6419 . -20) (f6418 . -16) (f6417 . -12) (f6416 . -8) (f6400 . 8) (f6401 . 4) (f6399 . -12) (f6400 . -8) (f6401 . -4) (f6402 . 0))
# var=f6418
    movl -32(%esp), %eax  # stack load f6418
# end emit-variable-ref
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_38846"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $68,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_38846:
    cmp -40(%esp), %eax
    sete %al
    movzbl %al, %eax
    sal $6, %al
    or $47, %al
    cmp $47, %al
    je _L_38843
# emit-tail-expr
# si=-40
# env=((f6419 . -36) (f6418 . -32) (f6417 . -28) (f6416 . -24) (f6419 . -20) (f6418 . -16) (f6417 . -12) (f6416 . -8) (f6400 . 8) (f6401 . 4) (f6399 . -12) (f6400 . -8) (f6401 . -4) (f6402 . 0))
# expr=#t
    movl $111, %eax     # immed #t
    ret                  # immediate tail return
    jmp _L_38844
_L_38843:
# emit-tail-expr
# si=-40
# env=((f6419 . -36) (f6418 . -32) (f6417 . -28) (f6416 . -24) (f6419 . -20) (f6418 . -16) (f6417 . -12) (f6416 . -8) (f6400 . 8) (f6401 . 4) (f6399 . -12) (f6400 . -8) (f6401 . -4) (f6402 . 0))
# expr=(if ((vector-ref f6401 0) f6416 f6417 f6418) ((vector-ref f6400 0) f6416 f6417 (fx+ f6418 1) f6419) #f)
# emit-expr ((vector-ref f6401 0) f6416 f6417 f6418)
# funcall
#    si   =-40
#    env  = ((f6419 . -36) (f6418 . -32) (f6417 . -28) (f6416 . -24) (f6419 . -20) (f6418 . -16) (f6417 . -12) (f6416 . -8) (f6400 . 8) (f6401 . 4) (f6399 . -12) (f6400 . -8) (f6401 . -4) (f6402 . 0))
#    expr = (funcall (vector-ref f6401 0) f6416 f6417 f6418)
# emit-expr (vector-ref f6401 0)
# emit-expr f6401
# emit-variable-ref
# env=((f6419 . -36) (f6418 . -32) (f6417 . -28) (f6416 . -24) (f6419 . -20) (f6418 . -16) (f6417 . -12) (f6416 . -8) (f6400 . 8) (f6401 . 4) (f6399 . -12) (f6400 . -8) (f6401 . -4) (f6402 . 0))
# var=f6401
    movl 2(%edi), %eax  # frame load f6401
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_38849
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_38849:
    movl %eax, -48(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_38850"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_38850:
# check bounds on vector index
    movl -48(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_38852
    cmp  $0,%eax
    jge _L_38851
_L_38852:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_38851:
    movl -48(%esp), %esi
    movl -1(%eax,%esi), %eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_38853"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_38853":
   movl %eax,  -48(%esp)  # stash funcall-oper in closure slot
# emit-expr f6416
# emit-variable-ref
# env=((f6419 . -36) (f6418 . -32) (f6417 . -28) (f6416 . -24) (f6419 . -20) (f6418 . -16) (f6417 . -12) (f6416 . -8) (f6400 . 8) (f6401 . 4) (f6399 . -12) (f6400 . -8) (f6401 . -4) (f6402 . 0))
# var=f6416
    movl -24(%esp), %eax  # stack load f6416
# end emit-variable-ref
    mov %eax, -52(%esp)  # arg f6416
# emit-expr f6417
# emit-variable-ref
# env=((f6419 . -36) (f6418 . -32) (f6417 . -28) (f6416 . -24) (f6419 . -20) (f6418 . -16) (f6417 . -12) (f6416 . -8) (f6400 . 8) (f6401 . 4) (f6399 . -12) (f6400 . -8) (f6401 . -4) (f6402 . 0))
# var=f6417
    movl -28(%esp), %eax  # stack load f6417
# end emit-variable-ref
    mov %eax, -56(%esp)  # arg f6417
# emit-expr f6418
# emit-variable-ref
# env=((f6419 . -36) (f6418 . -32) (f6417 . -28) (f6416 . -24) (f6419 . -20) (f6418 . -16) (f6417 . -12) (f6416 . -8) (f6400 . 8) (f6401 . 4) (f6399 . -12) (f6400 . -8) (f6401 . -4) (f6402 . 0))
# var=f6418
    movl -32(%esp), %eax  # stack load f6418
# end emit-variable-ref
    mov %eax, -60(%esp)  # arg f6418
    movl -48(%esp), %edi   # load new closure to %edi
    add $-40, %esp   # adjust base
    movl $12,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $40, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    cmp $47, %al
    je _L_38847
# emit-tail-expr
# si=-40
# env=((f6419 . -36) (f6418 . -32) (f6417 . -28) (f6416 . -24) (f6419 . -20) (f6418 . -16) (f6417 . -12) (f6416 . -8) (f6400 . 8) (f6401 . 4) (f6399 . -12) (f6400 . -8) (f6401 . -4) (f6402 . 0))
# expr=((vector-ref f6400 0) f6416 f6417 (fx+ f6418 1) f6419)
# emit-tail-funcall
#    si   =-40
#    env  = ((f6419 . -36) (f6418 . -32) (f6417 . -28) (f6416 . -24) (f6419 . -20) (f6418 . -16) (f6417 . -12) (f6416 . -8) (f6400 . 8) (f6401 . 4) (f6399 . -12) (f6400 . -8) (f6401 . -4) (f6402 . 0))
#    expr = (funcall (vector-ref f6400 0) f6416 f6417 (fx+ f6418 1) f6419)
# emit-expr (vector-ref f6400 0)
# emit-expr f6400
# emit-variable-ref
# env=((f6419 . -36) (f6418 . -32) (f6417 . -28) (f6416 . -24) (f6419 . -20) (f6418 . -16) (f6417 . -12) (f6416 . -8) (f6400 . 8) (f6401 . 4) (f6399 . -12) (f6400 . -8) (f6401 . -4) (f6402 . 0))
# var=f6400
    movl 6(%edi), %eax  # frame load f6400
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_38854
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_38854:
    movl %eax, -40(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_38855"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_38855:
# check bounds on vector index
    movl -40(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_38857
    cmp  $0,%eax
    jge _L_38856
_L_38857:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_38856:
    movl -40(%esp), %esi
    movl -1(%eax,%esi), %eax
   movl %eax,  -40(%esp)  # stash funcall-oper in next closure slot
# emit-expr f6416
# emit-variable-ref
# env=((f6419 . -36) (f6418 . -32) (f6417 . -28) (f6416 . -24) (f6419 . -20) (f6418 . -16) (f6417 . -12) (f6416 . -8) (f6400 . 8) (f6401 . 4) (f6399 . -12) (f6400 . -8) (f6401 . -4) (f6402 . 0))
# var=f6416
    movl -24(%esp), %eax  # stack load f6416
# end emit-variable-ref
    mov %eax, -44(%esp)    # arg f6416
# emit-expr f6417
# emit-variable-ref
# env=((f6419 . -36) (f6418 . -32) (f6417 . -28) (f6416 . -24) (f6419 . -20) (f6418 . -16) (f6417 . -12) (f6416 . -8) (f6400 . 8) (f6401 . 4) (f6399 . -12) (f6400 . -8) (f6401 . -4) (f6402 . 0))
# var=f6417
    movl -28(%esp), %eax  # stack load f6417
# end emit-variable-ref
    mov %eax, -48(%esp)    # arg f6417
# emit-expr (fx+ f6418 1)
# emit-expr 1
    movl $4, %eax     # immed 1
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_38858"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $88,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_38858:
    movl %eax, -52(%esp)  # fx+ push arg1
# emit-expr f6418
# emit-variable-ref
# env=((f6419 . -36) (f6418 . -32) (f6417 . -28) (f6416 . -24) (f6419 . -20) (f6418 . -16) (f6417 . -12) (f6416 . -8) (f6400 . 8) (f6401 . 4) (f6399 . -12) (f6400 . -8) (f6401 . -4) (f6402 . 0))
# var=f6418
    movl -32(%esp), %eax  # stack load f6418
# end emit-variable-ref
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_38859"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $88,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_38859:
    addl -52(%esp), %eax  # fx+ arg1 arg2
    mov %eax, -52(%esp)    # arg (fx+ f6418 1)
# emit-expr f6419
# emit-variable-ref
# env=((f6419 . -36) (f6418 . -32) (f6417 . -28) (f6416 . -24) (f6419 . -20) (f6418 . -16) (f6417 . -12) (f6416 . -8) (f6400 . 8) (f6401 . 4) (f6399 . -12) (f6400 . -8) (f6401 . -4) (f6402 . 0))
# var=f6419
    movl -36(%esp), %eax  # stack load f6419
# end emit-variable-ref
    mov %eax, -56(%esp)    # arg f6419
    movl -40(%esp), %edi   # load new closure to %edi
# emit-shift-args:  size=5   si=-40  delta=36
    mov -40(%esp), %ebx  # shift frame cell
    mov %ebx, -4(%esp)  # down to base
# emit-shift-args:  size=4   si=-44  delta=36
    mov -44(%esp), %ebx  # shift frame cell
    mov %ebx, -8(%esp)  # down to base
# emit-shift-args:  size=3   si=-48  delta=36
    mov -48(%esp), %ebx  # shift frame cell
    mov %ebx, -12(%esp)  # down to base
# emit-shift-args:  size=2   si=-52  delta=36
    mov -52(%esp), %ebx  # shift frame cell
    mov %ebx, -16(%esp)  # down to base
# emit-shift-args:  size=1   si=-56  delta=36
    mov -56(%esp), %ebx  # shift frame cell
    mov %ebx, -20(%esp)  # down to base
# emit-shift-args:  size=0   si=-60  delta=36
    movl $16,%eax   # save arg count
    jmp *-2(%edi)  # tail-funcall
    jmp _L_38848
_L_38847:
# emit-tail-expr
# si=-40
# env=((f6419 . -36) (f6418 . -32) (f6417 . -28) (f6416 . -24) (f6419 . -20) (f6418 . -16) (f6417 . -12) (f6416 . -8) (f6400 . 8) (f6401 . 4) (f6399 . -12) (f6400 . -8) (f6401 . -4) (f6402 . 0))
# expr=#f
    movl $47, %eax     # immed #f
    ret                  # immediate tail return
_L_38848:
_L_38844:
    .align 4,0x90
_L_38841:
    movl -16(%esp), %ebx
    movl -20(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin (vector-set! f6399 0 (closure (f6414 f6415) (f6402 f6400) (let ((f6414 f6414) (f6415 f6415)) (if ((vector-ref f6402 0) f6414 f6415) ((vector-ref f6400 0) f6414 f6415 0 (string-length f6414)) #f)))))
# emit-begin
#   expr=(begin (vector-set! f6399 0 (closure (f6414 f6415) (f6402 f6400) (let ((f6414 f6414) (f6415 f6415)) (if ((vector-ref f6402 0) f6414 f6415) ((vector-ref f6400 0) f6414 f6415 0 (string-length f6414)) #f)))))
#   env=((f6399 . -12) (f6400 . -8) (f6401 . -4) (f6402 . 0))
# emit-expr (vector-set! f6399 0 (closure (f6414 f6415) (f6402 f6400) (let ((f6414 f6414) (f6415 f6415)) (if ((vector-ref f6402 0) f6414 f6415) ((vector-ref f6400 0) f6414 f6415 0 (string-length f6414)) #f))))
# emit-expr f6399
# emit-variable-ref
# env=((f6399 . -12) (f6400 . -8) (f6401 . -4) (f6402 . 0))
# var=f6399
    movl -12(%esp), %eax  # stack load f6399
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_38860
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_38860:
    movl %eax, -16(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_38861"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_38861:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_38863
    cmp  $0,%eax
    jge _L_38862
_L_38863:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_38862:
    movl %eax, -20(%esp)
# emit-expr (closure (f6414 f6415) (f6402 f6400) (let ((f6414 f6414) (f6415 f6415)) (if ((vector-ref f6402 0) f6414 f6415) ((vector-ref f6400 0) f6414 f6415 0 (string-length f6414)) #f)))
# emit-closure
# si = -24
# env = ((f6399 . -12) (f6400 . -8) (f6401 . -4) (f6402 . 0))
# expr = (closure (f6414 f6415) (f6402 f6400) (let ((f6414 f6414) (f6415 f6415)) (if ((vector-ref f6402 0) f6414 f6415) ((vector-ref f6400 0) f6414 f6415 0 (string-length f6414)) #f)))
    movl $_L_38864, 0(%ebp)  # closure label
# emit-variable-ref
# env=((f6399 . -12) (f6400 . -8) (f6401 . -4) (f6402 . 0))
# var=f6402
    movl 0(%esp), %eax  # stack load f6402
# end emit-variable-ref
   movl  %eax, 4(%ebp)  # f6402
# emit-variable-ref
# env=((f6399 . -12) (f6400 . -8) (f6401 . -4) (f6402 . 0))
# var=f6400
    movl -8(%esp), %eax  # stack load f6400
# end emit-variable-ref
   movl  %eax, 8(%ebp)  # f6400
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $16, %ebp     # bump ebp
    jmp _L_38865            # jump around closure body
_L_38864:
# check argument count
    cmp $8,%eax
    je _L_38866
# invoke error handler eh_argcount
    .extern mrc_eh$uargcount
    movl mrc_eh$uargcount, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_38866:
# emit-tail-expr
# si=-16
# env=((f6415 . -12) (f6414 . -8) (f6400 . 8) (f6402 . 4) (f6399 . -12) (f6400 . -8) (f6401 . -4) (f6402 . 0))
# expr=(let ((f6414 f6414) (f6415 f6415)) (if ((vector-ref f6402 0) f6414 f6415) ((vector-ref f6400 0) f6414 f6415 0 (string-length f6414)) #f))
# emit-tail-let
#  si   = -16
#  env  = ((f6415 . -12) (f6414 . -8) (f6400 . 8) (f6402 . 4) (f6399 . -12) (f6400 . -8) (f6401 . -4) (f6402 . 0))
#  bindings = ((f6414 f6414) (f6415 f6415))
#  body = (if ((vector-ref f6402 0) f6414 f6415) ((vector-ref f6400 0) f6414 f6415 0 (string-length f6414)) #f)
# emit-expr f6414
# emit-variable-ref
# env=((f6415 . -12) (f6414 . -8) (f6400 . 8) (f6402 . 4) (f6399 . -12) (f6400 . -8) (f6401 . -4) (f6402 . 0))
# var=f6414
    movl -8(%esp), %eax  # stack load f6414
# end emit-variable-ref
    movl %eax, -16(%esp)  # stack save
# emit-expr f6415
# emit-variable-ref
# env=((f6415 . -12) (f6414 . -8) (f6400 . 8) (f6402 . 4) (f6399 . -12) (f6400 . -8) (f6401 . -4) (f6402 . 0))
# var=f6415
    movl -12(%esp), %eax  # stack load f6415
# end emit-variable-ref
    movl %eax, -20(%esp)  # stack save
# emit-tail-expr
# si=-24
# env=((f6415 . -20) (f6414 . -16) (f6415 . -12) (f6414 . -8) (f6400 . 8) (f6402 . 4) (f6399 . -12) (f6400 . -8) (f6401 . -4) (f6402 . 0))
# expr=(if ((vector-ref f6402 0) f6414 f6415) ((vector-ref f6400 0) f6414 f6415 0 (string-length f6414)) #f)
# emit-expr ((vector-ref f6402 0) f6414 f6415)
# funcall
#    si   =-24
#    env  = ((f6415 . -20) (f6414 . -16) (f6415 . -12) (f6414 . -8) (f6400 . 8) (f6402 . 4) (f6399 . -12) (f6400 . -8) (f6401 . -4) (f6402 . 0))
#    expr = (funcall (vector-ref f6402 0) f6414 f6415)
# emit-expr (vector-ref f6402 0)
# emit-expr f6402
# emit-variable-ref
# env=((f6415 . -20) (f6414 . -16) (f6415 . -12) (f6414 . -8) (f6400 . 8) (f6402 . 4) (f6399 . -12) (f6400 . -8) (f6401 . -4) (f6402 . 0))
# var=f6402
    movl 2(%edi), %eax  # frame load f6402
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_38869
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_38869:
    movl %eax, -32(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_38870"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_38870:
# check bounds on vector index
    movl -32(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_38872
    cmp  $0,%eax
    jge _L_38871
_L_38872:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_38871:
    movl -32(%esp), %esi
    movl -1(%eax,%esi), %eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_38873"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_38873":
   movl %eax,  -32(%esp)  # stash funcall-oper in closure slot
# emit-expr f6414
# emit-variable-ref
# env=((f6415 . -20) (f6414 . -16) (f6415 . -12) (f6414 . -8) (f6400 . 8) (f6402 . 4) (f6399 . -12) (f6400 . -8) (f6401 . -4) (f6402 . 0))
# var=f6414
    movl -16(%esp), %eax  # stack load f6414
# end emit-variable-ref
    mov %eax, -36(%esp)  # arg f6414
# emit-expr f6415
# emit-variable-ref
# env=((f6415 . -20) (f6414 . -16) (f6415 . -12) (f6414 . -8) (f6400 . 8) (f6402 . 4) (f6399 . -12) (f6400 . -8) (f6401 . -4) (f6402 . 0))
# var=f6415
    movl -20(%esp), %eax  # stack load f6415
# end emit-variable-ref
    mov %eax, -40(%esp)  # arg f6415
    movl -32(%esp), %edi   # load new closure to %edi
    add $-24, %esp   # adjust base
    movl $8,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $24, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    cmp $47, %al
    je _L_38867
# emit-tail-expr
# si=-24
# env=((f6415 . -20) (f6414 . -16) (f6415 . -12) (f6414 . -8) (f6400 . 8) (f6402 . 4) (f6399 . -12) (f6400 . -8) (f6401 . -4) (f6402 . 0))
# expr=((vector-ref f6400 0) f6414 f6415 0 (string-length f6414))
# emit-tail-funcall
#    si   =-24
#    env  = ((f6415 . -20) (f6414 . -16) (f6415 . -12) (f6414 . -8) (f6400 . 8) (f6402 . 4) (f6399 . -12) (f6400 . -8) (f6401 . -4) (f6402 . 0))
#    expr = (funcall (vector-ref f6400 0) f6414 f6415 0 (string-length f6414))
# emit-expr (vector-ref f6400 0)
# emit-expr f6400
# emit-variable-ref
# env=((f6415 . -20) (f6414 . -16) (f6415 . -12) (f6414 . -8) (f6400 . 8) (f6402 . 4) (f6399 . -12) (f6400 . -8) (f6401 . -4) (f6402 . 0))
# var=f6400
    movl 6(%edi), %eax  # frame load f6400
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_38874
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_38874:
    movl %eax, -24(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_38875"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_38875:
# check bounds on vector index
    movl -24(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_38877
    cmp  $0,%eax
    jge _L_38876
_L_38877:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_38876:
    movl -24(%esp), %esi
    movl -1(%eax,%esi), %eax
   movl %eax,  -24(%esp)  # stash funcall-oper in next closure slot
# emit-expr f6414
# emit-variable-ref
# env=((f6415 . -20) (f6414 . -16) (f6415 . -12) (f6414 . -8) (f6400 . 8) (f6402 . 4) (f6399 . -12) (f6400 . -8) (f6401 . -4) (f6402 . 0))
# var=f6414
    movl -16(%esp), %eax  # stack load f6414
# end emit-variable-ref
    mov %eax, -28(%esp)    # arg f6414
# emit-expr f6415
# emit-variable-ref
# env=((f6415 . -20) (f6414 . -16) (f6415 . -12) (f6414 . -8) (f6400 . 8) (f6402 . 4) (f6399 . -12) (f6400 . -8) (f6401 . -4) (f6402 . 0))
# var=f6415
    movl -20(%esp), %eax  # stack load f6415
# end emit-variable-ref
    mov %eax, -32(%esp)    # arg f6415
# emit-expr 0
    movl $0, %eax     # immed 0
    mov %eax, -36(%esp)    # arg 0
# emit-expr (string-length f6414)
# emit-expr f6414
# emit-variable-ref
# env=((f6415 . -20) (f6414 . -16) (f6415 . -12) (f6414 . -8) (f6400 . 8) (f6402 . 4) (f6399 . -12) (f6400 . -8) (f6401 . -4) (f6402 . 0))
# var=f6414
    movl -16(%esp), %eax  # stack load f6414
# end emit-variable-ref
# check the argument is a string
    movl %eax,%ebx
    and $7, %bl
    cmp $6, %bl
    je _L_38878
# invoke error handler eh_string
    .extern mrc_eh$ustring
    movl mrc_eh$ustring, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $160,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_38878:
    movl -6(%eax), %eax
    mov %eax, -40(%esp)    # arg (string-length f6414)
    movl -24(%esp), %edi   # load new closure to %edi
# emit-shift-args:  size=5   si=-24  delta=20
    mov -24(%esp), %ebx  # shift frame cell
    mov %ebx, -4(%esp)  # down to base
# emit-shift-args:  size=4   si=-28  delta=20
    mov -28(%esp), %ebx  # shift frame cell
    mov %ebx, -8(%esp)  # down to base
# emit-shift-args:  size=3   si=-32  delta=20
    mov -32(%esp), %ebx  # shift frame cell
    mov %ebx, -12(%esp)  # down to base
# emit-shift-args:  size=2   si=-36  delta=20
    mov -36(%esp), %ebx  # shift frame cell
    mov %ebx, -16(%esp)  # down to base
# emit-shift-args:  size=1   si=-40  delta=20
    mov -40(%esp), %ebx  # shift frame cell
    mov %ebx, -20(%esp)  # down to base
# emit-shift-args:  size=0   si=-44  delta=20
    movl $16,%eax   # save arg count
    jmp *-2(%edi)  # tail-funcall
    jmp _L_38868
_L_38867:
# emit-tail-expr
# si=-24
# env=((f6415 . -20) (f6414 . -16) (f6415 . -12) (f6414 . -8) (f6400 . 8) (f6402 . 4) (f6399 . -12) (f6400 . -8) (f6401 . -4) (f6402 . 0))
# expr=#f
    movl $47, %eax     # immed #f
    ret                  # immediate tail return
_L_38868:
    .align 4,0x90
_L_38865:
    movl -16(%esp), %ebx
    movl -20(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin)
# emit-begin
#   expr=(begin)
#   env=((f6399 . -12) (f6400 . -8) (f6401 . -4) (f6402 . 0))
# emit-expr (begin (vector-ref f6399 0))
# emit-begin
#   expr=(begin (vector-ref f6399 0))
#   env=((f6399 . -12) (f6400 . -8) (f6401 . -4) (f6402 . 0))
# emit-expr (vector-ref f6399 0)
# emit-expr f6399
# emit-variable-ref
# env=((f6399 . -12) (f6400 . -8) (f6401 . -4) (f6402 . 0))
# var=f6399
    movl -12(%esp), %eax  # stack load f6399
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_38879
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_38879:
    movl %eax, -16(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_38880"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_38880:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_38882
    cmp  $0,%eax
    jge _L_38881
_L_38882:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_38881:
    movl -16(%esp), %esi
    movl -1(%eax,%esi), %eax
# emit-expr (begin)
# emit-begin
#   expr=(begin)
#   env=((f6399 . -12) (f6400 . -8) (f6401 . -4) (f6402 . 0))
     movl %eax, mrc_string$e$q
# == explicit-begins  ==>
# (letrec ((str->sym (lambda (str symlist) (if (string=? str (symbol->string (car symlist))) (car symlist) (if (null? (cdr symlist)) (let* ((new-sym (make-symbol str #f)) (new-cdr (cons new-sym ()))) (begin (set-cdr! symlist new-cdr) new-sym)) (str->sym str (cdr symlist))))))) (lambda (str) (str->sym str (symbols))))
# == eliminate-let*  ==>
# (letrec ((str->sym (lambda (str symlist) (if (string=? str (symbol->string (car symlist))) (car symlist) (if (null? (cdr symlist)) (let ((new-sym (make-symbol str #f))) (let ((new-cdr (cons new-sym ()))) (begin (set-cdr! symlist new-cdr) new-sym))) (str->sym str (cdr symlist))))))) (lambda (str) (str->sym str (symbols))))
# == uniquify-variables  ==>
# (letrec ((f6425 (lambda (f6434 f6435) (if (string=? f6434 (symbol->string (car f6435))) (car f6435) (if (null? (cdr f6435)) (let ((f6439 (make-symbol f6434 #f))) (let ((f6441 (cons f6439 ()))) (begin (set-cdr! f6435 f6441) f6439))) (f6425 f6434 (cdr f6435))))))) (lambda (f6443) (f6425 f6443 (symbols))))
# == vectorize-letrec  ==>
# (let ((f6425 (make-vector 1))) (begin (begin (vector-set! f6425 0 (lambda (f6434 f6435) (if (string=? f6434 (symbol->string (car f6435))) (car f6435) (if (null? (cdr f6435)) (let ((f6439 (make-symbol f6434 #f))) (let ((f6441 (cons f6439 ()))) (begin (set-cdr! f6435 f6441) f6439))) ((vector-ref f6425 0) f6434 (cdr f6435))))))) (lambda (f6443) ((vector-ref f6425 0) f6443 (symbols)))))
# == eliminate-set!  ==>
# (let ((f6425 (make-vector 1))) (begin (begin (vector-set! f6425 0 (lambda (f6434 f6435) (let ((f6434 f6434) (f6435 f6435)) (if (string=? f6434 (symbol->string (car f6435))) (car f6435) (if (null? (cdr f6435)) (let ((f6439 (make-symbol f6434 #f))) (let ((f6441 (cons f6439 ()))) (begin (set-cdr! f6435 f6441) f6439))) ((vector-ref f6425 0) f6434 (cdr f6435)))))))) (lambda (f6443) (let ((f6443 f6443)) ((vector-ref f6425 0) f6443 (symbols))))))
# == close-free-variables  ==>
# (let ((f6425 (make-vector 1))) (begin (begin (vector-set! f6425 0 (closure (f6434 f6435) (string=? f6425) (let ((f6434 f6434) (f6435 f6435)) (if (string=? f6434 (symbol->string (car f6435))) (car f6435) (if (null? (cdr f6435)) (let ((f6439 (make-symbol f6434 #f))) (let ((f6441 (cons f6439 ()))) (begin (set-cdr! f6435 f6441) f6439))) ((vector-ref f6425 0) f6434 (cdr f6435)))))))) (closure (f6443) (f6425 symbols) (let ((f6443 f6443)) ((vector-ref f6425 0) f6443 (symbols))))))
# == eliminate-quote  ==>
# (let ((f6425 (make-vector 1))) (begin (begin (vector-set! f6425 0 (closure (f6434 f6435) (string=? f6425) (let ((f6434 f6434) (f6435 f6435)) (if (string=? f6434 (symbol->string (car f6435))) (car f6435) (if (null? (cdr f6435)) (let ((f6439 (make-symbol f6434 #f))) (let ((f6441 (cons f6439 ()))) (begin (set-cdr! f6435 f6441) f6439))) ((vector-ref f6425 0) f6434 (cdr f6435)))))))) (closure (f6443) (f6425 symbols) (let ((f6443 f6443)) ((vector-ref f6425 0) f6443 (symbols))))))
# == eliminate-when/unless  ==>
# (let ((f6425 (make-vector 1))) (begin (begin (vector-set! f6425 0 (closure (f6434 f6435) (string=? f6425) (let ((f6434 f6434) (f6435 f6435)) (if (string=? f6434 (symbol->string (car f6435))) (car f6435) (if (null? (cdr f6435)) (let ((f6439 (make-symbol f6434 #f))) (let ((f6441 (cons f6439 ()))) (begin (set-cdr! f6435 f6441) f6439))) ((vector-ref f6425 0) f6434 (cdr f6435)))))))) (closure (f6443) (f6425 symbols) (let ((f6443 f6443)) ((vector-ref f6425 0) f6443 (symbols))))))
# == eliminate-cond  ==>
# (let ((f6425 (make-vector 1))) (begin (begin (vector-set! f6425 0 (closure (f6434 f6435) (string=? f6425) (let ((f6434 f6434) (f6435 f6435)) (if (string=? f6434 (symbol->string (car f6435))) (car f6435) (if (null? (cdr f6435)) (let ((f6439 (make-symbol f6434 #f))) (let ((f6441 (cons f6439 ()))) (begin (set-cdr! f6435 f6441) f6439))) ((vector-ref f6425 0) f6434 (cdr f6435)))))))) (closure (f6443) (f6425 symbols) (let ((f6443 f6443)) ((vector-ref f6425 0) f6443 (symbols))))))
# == external-symbols  ==>
# (let ((f6425 (make-vector 1))) (begin (begin (vector-set! f6425 0 (closure (f6434 f6435) ((primitive-ref string=?) f6425) (let ((f6434 f6434) (f6435 f6435)) (if ((primitive-ref string=?) f6434 (symbol->string (car f6435))) (car f6435) (if (null? (cdr f6435)) (let ((f6439 (make-symbol f6434 #f))) (let ((f6441 (cons f6439 ()))) (begin (set-cdr! f6435 f6441) f6439))) ((vector-ref f6425 0) f6434 (cdr f6435)))))))) (closure (f6443) (f6425 (primitive-ref symbols)) (let ((f6443 f6443)) ((vector-ref f6425 0) f6443 ((primitive-ref symbols)))))))
# emit-expr (let ((f6425 (make-vector 1))) (begin (begin (vector-set! f6425 0 (closure (f6434 f6435) ((primitive-ref string=?) f6425) (let ((f6434 f6434) (f6435 f6435)) (if ((primitive-ref string=?) f6434 (symbol->string (car f6435))) (car f6435) (if (null? (cdr f6435)) (let ((f6439 (make-symbol f6434 #f))) (let ((f6441 (cons f6439 ()))) (begin (set-cdr! f6435 f6441) f6439))) ((vector-ref f6425 0) f6434 (cdr f6435)))))))) (closure (f6443) (f6425 (primitive-ref symbols)) (let ((f6443 f6443)) ((vector-ref f6425 0) f6443 ((primitive-ref symbols)))))))
# emit-let
#  si   = 0
#  env  = ()
#  bindings = ((f6425 (make-vector 1)))
#  body = (begin (begin (vector-set! f6425 0 (closure (f6434 f6435) ((primitive-ref string=?) f6425) (let ((f6434 f6434) (f6435 f6435)) (if ((primitive-ref string=?) f6434 (symbol->string (car f6435))) (car f6435) (if (null? (cdr f6435)) (let ((f6439 (make-symbol f6434 #f))) (let ((f6441 (cons f6439 ()))) (begin (set-cdr! f6435 f6441) f6439))) ((vector-ref f6425 0) f6434 (cdr f6435)))))))) (closure (f6443) (f6425 (primitive-ref symbols)) (let ((f6443 f6443)) ((vector-ref f6425 0) f6443 ((primitive-ref symbols))))))
# emit-expr (make-vector 1)
# make-vector 1
# emit-expr 1
    movl $4, %eax     # immed 1
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_38883"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_38883:
# check the argument is a fixnum >= 0
    cmp $0,%eax
    jge _L_38884
# invoke error handler eh_length
    .extern mrc_eh$ulength
    movl mrc_eh$ulength, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_38884:
    movl %eax, %esi
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    orl  $5, %eax
    addl $4, %esi
    addl $4, %esi
    andl $-8, %esi
    addl %esi, %ebp
    movl %eax, 0(%esp)  # stack save
# emit-expr (begin (begin (vector-set! f6425 0 (closure (f6434 f6435) ((primitive-ref string=?) f6425) (let ((f6434 f6434) (f6435 f6435)) (if ((primitive-ref string=?) f6434 (symbol->string (car f6435))) (car f6435) (if (null? (cdr f6435)) (let ((f6439 (make-symbol f6434 #f))) (let ((f6441 (cons f6439 ()))) (begin (set-cdr! f6435 f6441) f6439))) ((vector-ref f6425 0) f6434 (cdr f6435)))))))) (closure (f6443) (f6425 (primitive-ref symbols)) (let ((f6443 f6443)) ((vector-ref f6425 0) f6443 ((primitive-ref symbols))))))
# emit-begin
#   expr=(begin (begin (vector-set! f6425 0 (closure (f6434 f6435) ((primitive-ref string=?) f6425) (let ((f6434 f6434) (f6435 f6435)) (if ((primitive-ref string=?) f6434 (symbol->string (car f6435))) (car f6435) (if (null? (cdr f6435)) (let ((f6439 (make-symbol f6434 #f))) (let ((f6441 (cons f6439 ()))) (begin (set-cdr! f6435 f6441) f6439))) ((vector-ref f6425 0) f6434 (cdr f6435)))))))) (closure (f6443) (f6425 (primitive-ref symbols)) (let ((f6443 f6443)) ((vector-ref f6425 0) f6443 ((primitive-ref symbols))))))
#   env=((f6425 . 0))
# emit-expr (begin (vector-set! f6425 0 (closure (f6434 f6435) ((primitive-ref string=?) f6425) (let ((f6434 f6434) (f6435 f6435)) (if ((primitive-ref string=?) f6434 (symbol->string (car f6435))) (car f6435) (if (null? (cdr f6435)) (let ((f6439 (make-symbol f6434 #f))) (let ((f6441 (cons f6439 ()))) (begin (set-cdr! f6435 f6441) f6439))) ((vector-ref f6425 0) f6434 (cdr f6435))))))))
# emit-begin
#   expr=(begin (vector-set! f6425 0 (closure (f6434 f6435) ((primitive-ref string=?) f6425) (let ((f6434 f6434) (f6435 f6435)) (if ((primitive-ref string=?) f6434 (symbol->string (car f6435))) (car f6435) (if (null? (cdr f6435)) (let ((f6439 (make-symbol f6434 #f))) (let ((f6441 (cons f6439 ()))) (begin (set-cdr! f6435 f6441) f6439))) ((vector-ref f6425 0) f6434 (cdr f6435))))))))
#   env=((f6425 . 0))
# emit-expr (vector-set! f6425 0 (closure (f6434 f6435) ((primitive-ref string=?) f6425) (let ((f6434 f6434) (f6435 f6435)) (if ((primitive-ref string=?) f6434 (symbol->string (car f6435))) (car f6435) (if (null? (cdr f6435)) (let ((f6439 (make-symbol f6434 #f))) (let ((f6441 (cons f6439 ()))) (begin (set-cdr! f6435 f6441) f6439))) ((vector-ref f6425 0) f6434 (cdr f6435)))))))
# emit-expr f6425
# emit-variable-ref
# env=((f6425 . 0))
# var=f6425
    movl 0(%esp), %eax  # stack load f6425
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_38885
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_38885:
    movl %eax, -4(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_38886"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_38886:
# check bounds on vector index
    movl -4(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_38888
    cmp  $0,%eax
    jge _L_38887
_L_38888:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_38887:
    movl %eax, -8(%esp)
# emit-expr (closure (f6434 f6435) ((primitive-ref string=?) f6425) (let ((f6434 f6434) (f6435 f6435)) (if ((primitive-ref string=?) f6434 (symbol->string (car f6435))) (car f6435) (if (null? (cdr f6435)) (let ((f6439 (make-symbol f6434 #f))) (let ((f6441 (cons f6439 ()))) (begin (set-cdr! f6435 f6441) f6439))) ((vector-ref f6425 0) f6434 (cdr f6435))))))
# emit-closure
# si = -12
# env = ((f6425 . 0))
# expr = (closure (f6434 f6435) ((primitive-ref string=?) f6425) (let ((f6434 f6434) (f6435 f6435)) (if ((primitive-ref string=?) f6434 (symbol->string (car f6435))) (car f6435) (if (null? (cdr f6435)) (let ((f6439 (make-symbol f6434 #f))) (let ((f6441 (cons f6439 ()))) (begin (set-cdr! f6435 f6441) f6439))) ((vector-ref f6425 0) f6434 (cdr f6435))))))
    movl $_L_38889, 0(%ebp)  # closure label
# WARNING: free var (primitive-ref string=?) not defined in the environmnet
# emit-variable-ref
# env=((f6425 . 0))
# var=f6425
    movl 0(%esp), %eax  # stack load f6425
# end emit-variable-ref
   movl  %eax, 8(%ebp)  # f6425
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $16, %ebp     # bump ebp
    jmp _L_38890            # jump around closure body
_L_38889:
# check argument count
    cmp $8,%eax
    je _L_38891
# invoke error handler eh_argcount
    .extern mrc_eh$uargcount
    movl mrc_eh$uargcount, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_38891:
# emit-tail-expr
# si=-16
# env=((f6435 . -12) (f6434 . -8) (f6425 . 8) ((primitive-ref string=?) . 4) (f6425 . 0))
# expr=(let ((f6434 f6434) (f6435 f6435)) (if ((primitive-ref string=?) f6434 (symbol->string (car f6435))) (car f6435) (if (null? (cdr f6435)) (let ((f6439 (make-symbol f6434 #f))) (let ((f6441 (cons f6439 ()))) (begin (set-cdr! f6435 f6441) f6439))) ((vector-ref f6425 0) f6434 (cdr f6435)))))
# emit-tail-let
#  si   = -16
#  env  = ((f6435 . -12) (f6434 . -8) (f6425 . 8) ((primitive-ref string=?) . 4) (f6425 . 0))
#  bindings = ((f6434 f6434) (f6435 f6435))
#  body = (if ((primitive-ref string=?) f6434 (symbol->string (car f6435))) (car f6435) (if (null? (cdr f6435)) (let ((f6439 (make-symbol f6434 #f))) (let ((f6441 (cons f6439 ()))) (begin (set-cdr! f6435 f6441) f6439))) ((vector-ref f6425 0) f6434 (cdr f6435))))
# emit-expr f6434
# emit-variable-ref
# env=((f6435 . -12) (f6434 . -8) (f6425 . 8) ((primitive-ref string=?) . 4) (f6425 . 0))
# var=f6434
    movl -8(%esp), %eax  # stack load f6434
# end emit-variable-ref
    movl %eax, -16(%esp)  # stack save
# emit-expr f6435
# emit-variable-ref
# env=((f6435 . -12) (f6434 . -8) (f6425 . 8) ((primitive-ref string=?) . 4) (f6425 . 0))
# var=f6435
    movl -12(%esp), %eax  # stack load f6435
# end emit-variable-ref
    movl %eax, -20(%esp)  # stack save
# emit-tail-expr
# si=-24
# env=((f6435 . -20) (f6434 . -16) (f6435 . -12) (f6434 . -8) (f6425 . 8) ((primitive-ref string=?) . 4) (f6425 . 0))
# expr=(if ((primitive-ref string=?) f6434 (symbol->string (car f6435))) (car f6435) (if (null? (cdr f6435)) (let ((f6439 (make-symbol f6434 #f))) (let ((f6441 (cons f6439 ()))) (begin (set-cdr! f6435 f6441) f6439))) ((vector-ref f6425 0) f6434 (cdr f6435))))
# emit-expr ((primitive-ref string=?) f6434 (symbol->string (car f6435)))
# funcall
#    si   =-24
#    env  = ((f6435 . -20) (f6434 . -16) (f6435 . -12) (f6434 . -8) (f6425 . 8) ((primitive-ref string=?) . 4) (f6425 . 0))
#    expr = (funcall (primitive-ref string=?) f6434 (symbol->string (car f6435)))
# emit-expr (primitive-ref string=?)
    .extern mrc_string$e$q
    movl mrc_string$e$q,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_38894"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_38894":
   movl %eax,  -32(%esp)  # stash funcall-oper in closure slot
# emit-expr f6434
# emit-variable-ref
# env=((f6435 . -20) (f6434 . -16) (f6435 . -12) (f6434 . -8) (f6425 . 8) ((primitive-ref string=?) . 4) (f6425 . 0))
# var=f6434
    movl -16(%esp), %eax  # stack load f6434
# end emit-variable-ref
    mov %eax, -36(%esp)  # arg f6434
# emit-expr (symbol->string (car f6435))
# symbol->string (car f6435)
# emit-expr (car f6435)
# emit-expr f6435
# emit-variable-ref
# env=((f6435 . -20) (f6434 . -16) (f6435 . -12) (f6434 . -8) (f6425 . 8) ((primitive-ref string=?) . 4) (f6425 . 0))
# var=f6435
    movl -20(%esp), %eax  # stack load f6435
# end emit-variable-ref
# check the argument is a pair
    movl %eax,%ebx
    and $7, %bl
    cmp $1, %bl
    je _L_38895
# invoke error handler eh_pair
    .extern mrc_eh$upair
    movl mrc_eh$upair, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $116,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_38895:
    movl -1(%eax), %eax
    movl -3(%eax), %eax
    mov %eax, -40(%esp)  # arg (symbol->string (car f6435))
    movl -32(%esp), %edi   # load new closure to %edi
    add $-24, %esp   # adjust base
    movl $8,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $24, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    cmp $47, %al
    je _L_38892
# emit-tail-expr
# si=-24
# env=((f6435 . -20) (f6434 . -16) (f6435 . -12) (f6434 . -8) (f6425 . 8) ((primitive-ref string=?) . 4) (f6425 . 0))
# expr=(car f6435)
# tail primcall
# emit-expr f6435
# emit-variable-ref
# env=((f6435 . -20) (f6434 . -16) (f6435 . -12) (f6434 . -8) (f6425 . 8) ((primitive-ref string=?) . 4) (f6425 . 0))
# var=f6435
    movl -20(%esp), %eax  # stack load f6435
# end emit-variable-ref
# check the argument is a pair
    movl %eax,%ebx
    and $7, %bl
    cmp $1, %bl
    je _L_38896
# invoke error handler eh_pair
    .extern mrc_eh$upair
    movl mrc_eh$upair, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $116,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_38896:
    movl -1(%eax), %eax
#return from tail (car f6435)
    ret
    jmp _L_38893
_L_38892:
# emit-tail-expr
# si=-24
# env=((f6435 . -20) (f6434 . -16) (f6435 . -12) (f6434 . -8) (f6425 . 8) ((primitive-ref string=?) . 4) (f6425 . 0))
# expr=(if (null? (cdr f6435)) (let ((f6439 (make-symbol f6434 #f))) (let ((f6441 (cons f6439 ()))) (begin (set-cdr! f6435 f6441) f6439))) ((vector-ref f6425 0) f6434 (cdr f6435)))
# emit-expr (null? (cdr f6435))
# emit-expr (cdr f6435)
# emit-expr f6435
# emit-variable-ref
# env=((f6435 . -20) (f6434 . -16) (f6435 . -12) (f6434 . -8) (f6425 . 8) ((primitive-ref string=?) . 4) (f6425 . 0))
# var=f6435
    movl -20(%esp), %eax  # stack load f6435
# end emit-variable-ref
# check the argument is a pair
    movl %eax,%ebx
    and $7, %bl
    cmp $1, %bl
    je _L_38899
# invoke error handler eh_pair
    .extern mrc_eh$upair
    movl mrc_eh$upair, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $120,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_38899:
    movl 3(%eax), %eax
    cmp $63, %eax
    mov $0, %eax
    sete %al
    movzbl %al, %eax
    sal $6, %al
    or $47, %al
    cmp $47, %al
    je _L_38897
# emit-tail-expr
# si=-24
# env=((f6435 . -20) (f6434 . -16) (f6435 . -12) (f6434 . -8) (f6425 . 8) ((primitive-ref string=?) . 4) (f6425 . 0))
# expr=(let ((f6439 (make-symbol f6434 #f))) (let ((f6441 (cons f6439 ()))) (begin (set-cdr! f6435 f6441) f6439)))
# emit-tail-let
#  si   = -24
#  env  = ((f6435 . -20) (f6434 . -16) (f6435 . -12) (f6434 . -8) (f6425 . 8) ((primitive-ref string=?) . 4) (f6425 . 0))
#  bindings = ((f6439 (make-symbol f6434 #f)))
#  body = (let ((f6441 (cons f6439 ()))) (begin (set-cdr! f6435 f6441) f6439))
# emit-expr (make-symbol f6434 #f)
# make-symbol arg1=f6434 arg2=#f
# emit-expr f6434
# emit-variable-ref
# env=((f6435 . -20) (f6434 . -16) (f6435 . -12) (f6434 . -8) (f6425 . 8) ((primitive-ref string=?) . 4) (f6425 . 0))
# var=f6434
    movl -16(%esp), %eax  # stack load f6434
# end emit-variable-ref
    movl %eax, -24(%esp)
# emit-expr #f
    movl $47, %eax     # immed #f
    movl %eax, 4(%ebp)
    movl -24(%esp), %eax
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    orl  $3, %eax
    add  $8, %ebp
# make-symbol end
    movl %eax, -24(%esp)  # stack save
# emit-tail-expr
# si=-28
# env=((f6439 . -24) (f6435 . -20) (f6434 . -16) (f6435 . -12) (f6434 . -8) (f6425 . 8) ((primitive-ref string=?) . 4) (f6425 . 0))
# expr=(let ((f6441 (cons f6439 ()))) (begin (set-cdr! f6435 f6441) f6439))
# emit-tail-let
#  si   = -28
#  env  = ((f6439 . -24) (f6435 . -20) (f6434 . -16) (f6435 . -12) (f6434 . -8) (f6425 . 8) ((primitive-ref string=?) . 4) (f6425 . 0))
#  bindings = ((f6441 (cons f6439 ())))
#  body = (begin (set-cdr! f6435 f6441) f6439)
# emit-expr (cons f6439 ())
# cons arg1=f6439 arg2=()
# emit-expr f6439
# emit-variable-ref
# env=((f6439 . -24) (f6435 . -20) (f6434 . -16) (f6435 . -12) (f6434 . -8) (f6425 . 8) ((primitive-ref string=?) . 4) (f6425 . 0))
# var=f6439
    movl -24(%esp), %eax  # stack load f6439
# end emit-variable-ref
    movl %eax, -28(%esp)
# emit-expr ()
    movl $63, %eax     # immed ()
    movl %eax, 4(%ebp)
    movl -28(%esp), %eax
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    or   $1, %al
    add  $8, %ebp
# cons end
    movl %eax, -28(%esp)  # stack save
# emit-tail-expr
# si=-32
# env=((f6441 . -28) (f6439 . -24) (f6435 . -20) (f6434 . -16) (f6435 . -12) (f6434 . -8) (f6425 . 8) ((primitive-ref string=?) . 4) (f6425 . 0))
# expr=(begin (set-cdr! f6435 f6441) f6439)
# tail-begin (begin (set-cdr! f6435 f6441) f6439)
#   env=((f6441 . -28) (f6439 . -24) (f6435 . -20) (f6434 . -16) (f6435 . -12) (f6434 . -8) (f6425 . 8) ((primitive-ref string=?) . 4) (f6425 . 0))
# emit-expr (set-cdr! f6435 f6441)
# emit-expr f6435
# emit-variable-ref
# env=((f6441 . -28) (f6439 . -24) (f6435 . -20) (f6434 . -16) (f6435 . -12) (f6434 . -8) (f6425 . 8) ((primitive-ref string=?) . 4) (f6425 . 0))
# var=f6435
    movl -20(%esp), %eax  # stack load f6435
# end emit-variable-ref
# check the argument is a pair
    movl %eax,%ebx
    and $7, %bl
    cmp $1, %bl
    je _L_38900
# invoke error handler eh_pair
    .extern mrc_eh$upair
    movl mrc_eh$upair, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $128,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_38900:
    movl %eax, -32(%esp)
# emit-expr f6441
# emit-variable-ref
# env=((f6441 . -28) (f6439 . -24) (f6435 . -20) (f6434 . -16) (f6435 . -12) (f6434 . -8) (f6425 . 8) ((primitive-ref string=?) . 4) (f6425 . 0))
# var=f6441
    movl -28(%esp), %eax  # stack load f6441
# end emit-variable-ref
    movl -32(%esp), %ebx
    movl %eax, 3(%ebx)
# emit-tail-expr
# si=-32
# env=((f6441 . -28) (f6439 . -24) (f6435 . -20) (f6434 . -16) (f6435 . -12) (f6434 . -8) (f6425 . 8) ((primitive-ref string=?) . 4) (f6425 . 0))
# expr=(begin f6439)
# tail-begin (begin f6439)
#   env=((f6441 . -28) (f6439 . -24) (f6435 . -20) (f6434 . -16) (f6435 . -12) (f6434 . -8) (f6425 . 8) ((primitive-ref string=?) . 4) (f6425 . 0))
# emit-tail-expr
# si=-32
# env=((f6441 . -28) (f6439 . -24) (f6435 . -20) (f6434 . -16) (f6435 . -12) (f6434 . -8) (f6425 . 8) ((primitive-ref string=?) . 4) (f6425 . 0))
# expr=f6439
# emit-tail-variable-ref
# emit-variable-ref
# env=((f6441 . -28) (f6439 . -24) (f6435 . -20) (f6434 . -16) (f6435 . -12) (f6434 . -8) (f6425 . 8) ((primitive-ref string=?) . 4) (f6425 . 0))
# var=f6439
    movl -24(%esp), %eax  # stack load f6439
# end emit-variable-ref
    ret
# end emit-tail-variable ref
     ret   # return thru stack
    jmp _L_38898
_L_38897:
# emit-tail-expr
# si=-24
# env=((f6435 . -20) (f6434 . -16) (f6435 . -12) (f6434 . -8) (f6425 . 8) ((primitive-ref string=?) . 4) (f6425 . 0))
# expr=((vector-ref f6425 0) f6434 (cdr f6435))
# emit-tail-funcall
#    si   =-24
#    env  = ((f6435 . -20) (f6434 . -16) (f6435 . -12) (f6434 . -8) (f6425 . 8) ((primitive-ref string=?) . 4) (f6425 . 0))
#    expr = (funcall (vector-ref f6425 0) f6434 (cdr f6435))
# emit-expr (vector-ref f6425 0)
# emit-expr f6425
# emit-variable-ref
# env=((f6435 . -20) (f6434 . -16) (f6435 . -12) (f6434 . -8) (f6425 . 8) ((primitive-ref string=?) . 4) (f6425 . 0))
# var=f6425
    movl 6(%edi), %eax  # frame load f6425
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_38901
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_38901:
    movl %eax, -24(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_38902"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_38902:
# check bounds on vector index
    movl -24(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_38904
    cmp  $0,%eax
    jge _L_38903
_L_38904:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_38903:
    movl -24(%esp), %esi
    movl -1(%eax,%esi), %eax
   movl %eax,  -24(%esp)  # stash funcall-oper in next closure slot
# emit-expr f6434
# emit-variable-ref
# env=((f6435 . -20) (f6434 . -16) (f6435 . -12) (f6434 . -8) (f6425 . 8) ((primitive-ref string=?) . 4) (f6425 . 0))
# var=f6434
    movl -16(%esp), %eax  # stack load f6434
# end emit-variable-ref
    mov %eax, -28(%esp)    # arg f6434
# emit-expr (cdr f6435)
# emit-expr f6435
# emit-variable-ref
# env=((f6435 . -20) (f6434 . -16) (f6435 . -12) (f6434 . -8) (f6425 . 8) ((primitive-ref string=?) . 4) (f6425 . 0))
# var=f6435
    movl -20(%esp), %eax  # stack load f6435
# end emit-variable-ref
# check the argument is a pair
    movl %eax,%ebx
    and $7, %bl
    cmp $1, %bl
    je _L_38905
# invoke error handler eh_pair
    .extern mrc_eh$upair
    movl mrc_eh$upair, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $120,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_38905:
    movl 3(%eax), %eax
    mov %eax, -32(%esp)    # arg (cdr f6435)
    movl -24(%esp), %edi   # load new closure to %edi
# emit-shift-args:  size=3   si=-24  delta=20
    mov -24(%esp), %ebx  # shift frame cell
    mov %ebx, -4(%esp)  # down to base
# emit-shift-args:  size=2   si=-28  delta=20
    mov -28(%esp), %ebx  # shift frame cell
    mov %ebx, -8(%esp)  # down to base
# emit-shift-args:  size=1   si=-32  delta=20
    mov -32(%esp), %ebx  # shift frame cell
    mov %ebx, -12(%esp)  # down to base
# emit-shift-args:  size=0   si=-36  delta=20
    movl $8,%eax   # save arg count
    jmp *-2(%edi)  # tail-funcall
_L_38898:
_L_38893:
    .align 4,0x90
_L_38890:
    movl -4(%esp), %ebx
    movl -8(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin)
# emit-begin
#   expr=(begin)
#   env=((f6425 . 0))
# emit-expr (begin (closure (f6443) (f6425 (primitive-ref symbols)) (let ((f6443 f6443)) ((vector-ref f6425 0) f6443 ((primitive-ref symbols))))))
# emit-begin
#   expr=(begin (closure (f6443) (f6425 (primitive-ref symbols)) (let ((f6443 f6443)) ((vector-ref f6425 0) f6443 ((primitive-ref symbols))))))
#   env=((f6425 . 0))
# emit-expr (closure (f6443) (f6425 (primitive-ref symbols)) (let ((f6443 f6443)) ((vector-ref f6425 0) f6443 ((primitive-ref symbols)))))
# emit-closure
# si = -4
# env = ((f6425 . 0))
# expr = (closure (f6443) (f6425 (primitive-ref symbols)) (let ((f6443 f6443)) ((vector-ref f6425 0) f6443 ((primitive-ref symbols)))))
    movl $_L_38906, 0(%ebp)  # closure label
# emit-variable-ref
# env=((f6425 . 0))
# var=f6425
    movl 0(%esp), %eax  # stack load f6425
# end emit-variable-ref
   movl  %eax, 4(%ebp)  # f6425
# WARNING: free var (primitive-ref symbols) not defined in the environmnet
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $16, %ebp     # bump ebp
    jmp _L_38907            # jump around closure body
_L_38906:
# check argument count
    cmp $4,%eax
    je _L_38908
# invoke error handler eh_argcount
    .extern mrc_eh$uargcount
    movl mrc_eh$uargcount, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_38908:
# emit-tail-expr
# si=-12
# env=((f6443 . -8) ((primitive-ref symbols) . 8) (f6425 . 4) (f6425 . 0))
# expr=(let ((f6443 f6443)) ((vector-ref f6425 0) f6443 ((primitive-ref symbols))))
# emit-tail-let
#  si   = -12
#  env  = ((f6443 . -8) ((primitive-ref symbols) . 8) (f6425 . 4) (f6425 . 0))
#  bindings = ((f6443 f6443))
#  body = ((vector-ref f6425 0) f6443 ((primitive-ref symbols)))
# emit-expr f6443
# emit-variable-ref
# env=((f6443 . -8) ((primitive-ref symbols) . 8) (f6425 . 4) (f6425 . 0))
# var=f6443
    movl -8(%esp), %eax  # stack load f6443
# end emit-variable-ref
    movl %eax, -12(%esp)  # stack save
# emit-tail-expr
# si=-16
# env=((f6443 . -12) (f6443 . -8) ((primitive-ref symbols) . 8) (f6425 . 4) (f6425 . 0))
# expr=((vector-ref f6425 0) f6443 ((primitive-ref symbols)))
# emit-tail-funcall
#    si   =-16
#    env  = ((f6443 . -12) (f6443 . -8) ((primitive-ref symbols) . 8) (f6425 . 4) (f6425 . 0))
#    expr = (funcall (vector-ref f6425 0) f6443 ((primitive-ref symbols)))
# emit-expr (vector-ref f6425 0)
# emit-expr f6425
# emit-variable-ref
# env=((f6443 . -12) (f6443 . -8) ((primitive-ref symbols) . 8) (f6425 . 4) (f6425 . 0))
# var=f6425
    movl 2(%edi), %eax  # frame load f6425
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_38909
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_38909:
    movl %eax, -16(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_38910"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_38910:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_38912
    cmp  $0,%eax
    jge _L_38911
_L_38912:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_38911:
    movl -16(%esp), %esi
    movl -1(%eax,%esi), %eax
   movl %eax,  -16(%esp)  # stash funcall-oper in next closure slot
# emit-expr f6443
# emit-variable-ref
# env=((f6443 . -12) (f6443 . -8) ((primitive-ref symbols) . 8) (f6425 . 4) (f6425 . 0))
# var=f6443
    movl -12(%esp), %eax  # stack load f6443
# end emit-variable-ref
    mov %eax, -20(%esp)    # arg f6443
# emit-expr ((primitive-ref symbols))
# funcall
#    si   =-24
#    env  = ((f6443 . -12) (f6443 . -8) ((primitive-ref symbols) . 8) (f6425 . 4) (f6425 . 0))
#    expr = (funcall (primitive-ref symbols))
# emit-expr (primitive-ref symbols)
    .extern mrc_symbols
    movl mrc_symbols,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_38913"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_38913":
   movl %eax,  -32(%esp)  # stash funcall-oper in closure slot
    movl -32(%esp), %edi   # load new closure to %edi
    add $-24, %esp   # adjust base
    movl $0,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $24, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    mov %eax, -24(%esp)    # arg ((primitive-ref symbols))
    movl -16(%esp), %edi   # load new closure to %edi
# emit-shift-args:  size=3   si=-16  delta=12
    mov -16(%esp), %ebx  # shift frame cell
    mov %ebx, -4(%esp)  # down to base
# emit-shift-args:  size=2   si=-20  delta=12
    mov -20(%esp), %ebx  # shift frame cell
    mov %ebx, -8(%esp)  # down to base
# emit-shift-args:  size=1   si=-24  delta=12
    mov -24(%esp), %ebx  # shift frame cell
    mov %ebx, -12(%esp)  # down to base
# emit-shift-args:  size=0   si=-28  delta=12
    movl $8,%eax   # save arg count
    jmp *-2(%edi)  # tail-funcall
    .align 4,0x90
_L_38907:
# emit-expr (begin)
# emit-begin
#   expr=(begin)
#   env=((f6425 . 0))
     movl %eax, mrc_string$m$gsymbol
# == explicit-begins  ==>
# (lambda (lst elt) (if (null? lst) (cons elt nil) (cons (car lst) (append1 (cdr lst) elt))))
# == eliminate-let*  ==>
# (lambda (lst elt) (if (null? lst) (cons elt nil) (cons (car lst) (append1 (cdr lst) elt))))
# == uniquify-variables  ==>
# (lambda (f6444 f6445) (if (null? f6444) (cons f6445 nil) (cons (car f6444) (append1 (cdr f6444) f6445))))
# == vectorize-letrec  ==>
# (lambda (f6444 f6445) (if (null? f6444) (cons f6445 nil) (cons (car f6444) (append1 (cdr f6444) f6445))))
# == eliminate-set!  ==>
# (lambda (f6444 f6445) (let ((f6444 f6444) (f6445 f6445)) (if (null? f6444) (cons f6445 nil) (cons (car f6444) (append1 (cdr f6444) f6445)))))
# == close-free-variables  ==>
# (closure (f6444 f6445) (nil append1) (let ((f6444 f6444) (f6445 f6445)) (if (null? f6444) (cons f6445 nil) (cons (car f6444) (append1 (cdr f6444) f6445)))))
# == eliminate-quote  ==>
# (closure (f6444 f6445) (nil append1) (let ((f6444 f6444) (f6445 f6445)) (if (null? f6444) (cons f6445 nil) (cons (car f6444) (append1 (cdr f6444) f6445)))))
# == eliminate-when/unless  ==>
# (closure (f6444 f6445) (nil append1) (let ((f6444 f6444) (f6445 f6445)) (if (null? f6444) (cons f6445 nil) (cons (car f6444) (append1 (cdr f6444) f6445)))))
# == eliminate-cond  ==>
# (closure (f6444 f6445) (nil append1) (let ((f6444 f6444) (f6445 f6445)) (if (null? f6444) (cons f6445 nil) (cons (car f6444) (append1 (cdr f6444) f6445)))))
# == external-symbols  ==>
# (closure (f6444 f6445) (nil (primitive-ref append1)) (let ((f6444 f6444) (f6445 f6445)) (if (null? f6444) (cons f6445 nil) (cons (car f6444) ((primitive-ref append1) (cdr f6444) f6445)))))
# emit-expr (closure (f6444 f6445) (nil (primitive-ref append1)) (let ((f6444 f6444) (f6445 f6445)) (if (null? f6444) (cons f6445 nil) (cons (car f6444) ((primitive-ref append1) (cdr f6444) f6445)))))
# emit-closure
# si = 0
# env = ()
# expr = (closure (f6444 f6445) (nil (primitive-ref append1)) (let ((f6444 f6444) (f6445 f6445)) (if (null? f6444) (cons f6445 nil) (cons (car f6444) ((primitive-ref append1) (cdr f6444) f6445)))))
    movl $_L_38914, 0(%ebp)  # closure label
# WARNING: free var nil not defined in the environmnet
# WARNING: free var (primitive-ref append1) not defined in the environmnet
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $16, %ebp     # bump ebp
    jmp _L_38915            # jump around closure body
_L_38914:
# check argument count
    cmp $8,%eax
    je _L_38916
# invoke error handler eh_argcount
    .extern mrc_eh$uargcount
    movl mrc_eh$uargcount, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_38916:
# emit-tail-expr
# si=-16
# env=((f6445 . -12) (f6444 . -8) ((primitive-ref append1) . 8) (nil . 4))
# expr=(let ((f6444 f6444) (f6445 f6445)) (if (null? f6444) (cons f6445 nil) (cons (car f6444) ((primitive-ref append1) (cdr f6444) f6445))))
# emit-tail-let
#  si   = -16
#  env  = ((f6445 . -12) (f6444 . -8) ((primitive-ref append1) . 8) (nil . 4))
#  bindings = ((f6444 f6444) (f6445 f6445))
#  body = (if (null? f6444) (cons f6445 nil) (cons (car f6444) ((primitive-ref append1) (cdr f6444) f6445)))
# emit-expr f6444
# emit-variable-ref
# env=((f6445 . -12) (f6444 . -8) ((primitive-ref append1) . 8) (nil . 4))
# var=f6444
    movl -8(%esp), %eax  # stack load f6444
# end emit-variable-ref
    movl %eax, -16(%esp)  # stack save
# emit-expr f6445
# emit-variable-ref
# env=((f6445 . -12) (f6444 . -8) ((primitive-ref append1) . 8) (nil . 4))
# var=f6445
    movl -12(%esp), %eax  # stack load f6445
# end emit-variable-ref
    movl %eax, -20(%esp)  # stack save
# emit-tail-expr
# si=-24
# env=((f6445 . -20) (f6444 . -16) (f6445 . -12) (f6444 . -8) ((primitive-ref append1) . 8) (nil . 4))
# expr=(if (null? f6444) (cons f6445 nil) (cons (car f6444) ((primitive-ref append1) (cdr f6444) f6445)))
# emit-expr (null? f6444)
# emit-expr f6444
# emit-variable-ref
# env=((f6445 . -20) (f6444 . -16) (f6445 . -12) (f6444 . -8) ((primitive-ref append1) . 8) (nil . 4))
# var=f6444
    movl -16(%esp), %eax  # stack load f6444
# end emit-variable-ref
    cmp $63, %eax
    mov $0, %eax
    sete %al
    movzbl %al, %eax
    sal $6, %al
    or $47, %al
    cmp $47, %al
    je _L_38917
# emit-tail-expr
# si=-24
# env=((f6445 . -20) (f6444 . -16) (f6445 . -12) (f6444 . -8) ((primitive-ref append1) . 8) (nil . 4))
# expr=(cons f6445 nil)
# tail primcall
# cons arg1=f6445 arg2=nil
# emit-expr f6445
# emit-variable-ref
# env=((f6445 . -20) (f6444 . -16) (f6445 . -12) (f6444 . -8) ((primitive-ref append1) . 8) (nil . 4))
# var=f6445
    movl -20(%esp), %eax  # stack load f6445
# end emit-variable-ref
    movl %eax, -24(%esp)
# emit-expr nil
# emit-variable-ref
# env=((f6445 . -20) (f6444 . -16) (f6445 . -12) (f6444 . -8) ((primitive-ref append1) . 8) (nil . 4))
# var=nil
    movl 2(%edi), %eax  # frame load nil
# end emit-variable-ref
    movl %eax, 4(%ebp)
    movl -24(%esp), %eax
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    or   $1, %al
    add  $8, %ebp
# cons end
#return from tail (cons f6445 nil)
    ret
    jmp _L_38918
_L_38917:
# emit-tail-expr
# si=-24
# env=((f6445 . -20) (f6444 . -16) (f6445 . -12) (f6444 . -8) ((primitive-ref append1) . 8) (nil . 4))
# expr=(cons (car f6444) ((primitive-ref append1) (cdr f6444) f6445))
# tail primcall
# cons arg1=(car f6444) arg2=((primitive-ref append1) (cdr f6444) f6445)
# emit-expr (car f6444)
# emit-expr f6444
# emit-variable-ref
# env=((f6445 . -20) (f6444 . -16) (f6445 . -12) (f6444 . -8) ((primitive-ref append1) . 8) (nil . 4))
# var=f6444
    movl -16(%esp), %eax  # stack load f6444
# end emit-variable-ref
# check the argument is a pair
    movl %eax,%ebx
    and $7, %bl
    cmp $1, %bl
    je _L_38919
# invoke error handler eh_pair
    .extern mrc_eh$upair
    movl mrc_eh$upair, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $116,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_38919:
    movl -1(%eax), %eax
    movl %eax, -24(%esp)
# emit-expr ((primitive-ref append1) (cdr f6444) f6445)
# funcall
#    si   =-28
#    env  = ((f6445 . -20) (f6444 . -16) (f6445 . -12) (f6444 . -8) ((primitive-ref append1) . 8) (nil . 4))
#    expr = (funcall (primitive-ref append1) (cdr f6444) f6445)
# emit-expr (primitive-ref append1)
    .extern mrc_append1
    movl mrc_append1,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_38920"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_38920":
   movl %eax,  -36(%esp)  # stash funcall-oper in closure slot
# emit-expr (cdr f6444)
# emit-expr f6444
# emit-variable-ref
# env=((f6445 . -20) (f6444 . -16) (f6445 . -12) (f6444 . -8) ((primitive-ref append1) . 8) (nil . 4))
# var=f6444
    movl -16(%esp), %eax  # stack load f6444
# end emit-variable-ref
# check the argument is a pair
    movl %eax,%ebx
    and $7, %bl
    cmp $1, %bl
    je _L_38921
# invoke error handler eh_pair
    .extern mrc_eh$upair
    movl mrc_eh$upair, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $120,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_38921:
    movl 3(%eax), %eax
    mov %eax, -40(%esp)  # arg (cdr f6444)
# emit-expr f6445
# emit-variable-ref
# env=((f6445 . -20) (f6444 . -16) (f6445 . -12) (f6444 . -8) ((primitive-ref append1) . 8) (nil . 4))
# var=f6445
    movl -20(%esp), %eax  # stack load f6445
# end emit-variable-ref
    mov %eax, -44(%esp)  # arg f6445
    movl -36(%esp), %edi   # load new closure to %edi
    add $-28, %esp   # adjust base
    movl $8,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $28, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    movl %eax, 4(%ebp)
    movl -24(%esp), %eax
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    or   $1, %al
    add  $8, %ebp
# cons end
#return from tail (cons (car f6444) ((primitive-ref append1) (cdr f6444) f6445))
    ret
_L_38918:
    .align 4,0x90
_L_38915:
     movl %eax, mrc_append1
# == explicit-begins  ==>
# (lambda (l k) (if (fx= k 0) (car l) (list-ref (cdr l) (fx- k 1))))
# == eliminate-let*  ==>
# (lambda (l k) (if (fx= k 0) (car l) (list-ref (cdr l) (fx- k 1))))
# == uniquify-variables  ==>
# (lambda (f6446 f6447) (if (fx= f6447 0) (car f6446) (list-ref (cdr f6446) (fx- f6447 1))))
# == vectorize-letrec  ==>
# (lambda (f6446 f6447) (if (fx= f6447 0) (car f6446) (list-ref (cdr f6446) (fx- f6447 1))))
# == eliminate-set!  ==>
# (lambda (f6446 f6447) (let ((f6446 f6446) (f6447 f6447)) (if (fx= f6447 0) (car f6446) (list-ref (cdr f6446) (fx- f6447 1)))))
# == close-free-variables  ==>
# (closure (f6446 f6447) (list-ref) (let ((f6446 f6446) (f6447 f6447)) (if (fx= f6447 0) (car f6446) (list-ref (cdr f6446) (fx- f6447 1)))))
# == eliminate-quote  ==>
# (closure (f6446 f6447) (list-ref) (let ((f6446 f6446) (f6447 f6447)) (if (fx= f6447 0) (car f6446) (list-ref (cdr f6446) (fx- f6447 1)))))
# == eliminate-when/unless  ==>
# (closure (f6446 f6447) (list-ref) (let ((f6446 f6446) (f6447 f6447)) (if (fx= f6447 0) (car f6446) (list-ref (cdr f6446) (fx- f6447 1)))))
# == eliminate-cond  ==>
# (closure (f6446 f6447) (list-ref) (let ((f6446 f6446) (f6447 f6447)) (if (fx= f6447 0) (car f6446) (list-ref (cdr f6446) (fx- f6447 1)))))
# == external-symbols  ==>
# (closure (f6446 f6447) ((primitive-ref list-ref)) (let ((f6446 f6446) (f6447 f6447)) (if (fx= f6447 0) (car f6446) ((primitive-ref list-ref) (cdr f6446) (fx- f6447 1)))))
# emit-expr (closure (f6446 f6447) ((primitive-ref list-ref)) (let ((f6446 f6446) (f6447 f6447)) (if (fx= f6447 0) (car f6446) ((primitive-ref list-ref) (cdr f6446) (fx- f6447 1)))))
# emit-closure
# si = 0
# env = ()
# expr = (closure (f6446 f6447) ((primitive-ref list-ref)) (let ((f6446 f6446) (f6447 f6447)) (if (fx= f6447 0) (car f6446) ((primitive-ref list-ref) (cdr f6446) (fx- f6447 1)))))
    movl $_L_38922, 0(%ebp)  # closure label
# WARNING: free var (primitive-ref list-ref) not defined in the environmnet
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $8, %ebp     # bump ebp
    jmp _L_38923            # jump around closure body
_L_38922:
# check argument count
    cmp $8,%eax
    je _L_38924
# invoke error handler eh_argcount
    .extern mrc_eh$uargcount
    movl mrc_eh$uargcount, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_38924:
# emit-tail-expr
# si=-16
# env=((f6447 . -12) (f6446 . -8) ((primitive-ref list-ref) . 4))
# expr=(let ((f6446 f6446) (f6447 f6447)) (if (fx= f6447 0) (car f6446) ((primitive-ref list-ref) (cdr f6446) (fx- f6447 1))))
# emit-tail-let
#  si   = -16
#  env  = ((f6447 . -12) (f6446 . -8) ((primitive-ref list-ref) . 4))
#  bindings = ((f6446 f6446) (f6447 f6447))
#  body = (if (fx= f6447 0) (car f6446) ((primitive-ref list-ref) (cdr f6446) (fx- f6447 1)))
# emit-expr f6446
# emit-variable-ref
# env=((f6447 . -12) (f6446 . -8) ((primitive-ref list-ref) . 4))
# var=f6446
    movl -8(%esp), %eax  # stack load f6446
# end emit-variable-ref
    movl %eax, -16(%esp)  # stack save
# emit-expr f6447
# emit-variable-ref
# env=((f6447 . -12) (f6446 . -8) ((primitive-ref list-ref) . 4))
# var=f6447
    movl -12(%esp), %eax  # stack load f6447
# end emit-variable-ref
    movl %eax, -20(%esp)  # stack save
# emit-tail-expr
# si=-24
# env=((f6447 . -20) (f6446 . -16) (f6447 . -12) (f6446 . -8) ((primitive-ref list-ref) . 4))
# expr=(if (fx= f6447 0) (car f6446) ((primitive-ref list-ref) (cdr f6446) (fx- f6447 1)))
# emit-expr (fx= f6447 0)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_38927"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $68,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_38927:
    movl %eax, -24(%esp)
# emit-expr f6447
# emit-variable-ref
# env=((f6447 . -20) (f6446 . -16) (f6447 . -12) (f6446 . -8) ((primitive-ref list-ref) . 4))
# var=f6447
    movl -20(%esp), %eax  # stack load f6447
# end emit-variable-ref
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_38928"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $68,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_38928:
    cmp -24(%esp), %eax
    sete %al
    movzbl %al, %eax
    sal $6, %al
    or $47, %al
    cmp $47, %al
    je _L_38925
# emit-tail-expr
# si=-24
# env=((f6447 . -20) (f6446 . -16) (f6447 . -12) (f6446 . -8) ((primitive-ref list-ref) . 4))
# expr=(car f6446)
# tail primcall
# emit-expr f6446
# emit-variable-ref
# env=((f6447 . -20) (f6446 . -16) (f6447 . -12) (f6446 . -8) ((primitive-ref list-ref) . 4))
# var=f6446
    movl -16(%esp), %eax  # stack load f6446
# end emit-variable-ref
# check the argument is a pair
    movl %eax,%ebx
    and $7, %bl
    cmp $1, %bl
    je _L_38929
# invoke error handler eh_pair
    .extern mrc_eh$upair
    movl mrc_eh$upair, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $116,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_38929:
    movl -1(%eax), %eax
#return from tail (car f6446)
    ret
    jmp _L_38926
_L_38925:
# emit-tail-expr
# si=-24
# env=((f6447 . -20) (f6446 . -16) (f6447 . -12) (f6446 . -8) ((primitive-ref list-ref) . 4))
# expr=((primitive-ref list-ref) (cdr f6446) (fx- f6447 1))
# emit-tail-funcall
#    si   =-24
#    env  = ((f6447 . -20) (f6446 . -16) (f6447 . -12) (f6446 . -8) ((primitive-ref list-ref) . 4))
#    expr = (funcall (primitive-ref list-ref) (cdr f6446) (fx- f6447 1))
# emit-expr (primitive-ref list-ref)
    .extern mrc_list$mref
    movl mrc_list$mref,%eax
   movl %eax,  -24(%esp)  # stash funcall-oper in next closure slot
# emit-expr (cdr f6446)
# emit-expr f6446
# emit-variable-ref
# env=((f6447 . -20) (f6446 . -16) (f6447 . -12) (f6446 . -8) ((primitive-ref list-ref) . 4))
# var=f6446
    movl -16(%esp), %eax  # stack load f6446
# end emit-variable-ref
# check the argument is a pair
    movl %eax,%ebx
    and $7, %bl
    cmp $1, %bl
    je _L_38930
# invoke error handler eh_pair
    .extern mrc_eh$upair
    movl mrc_eh$upair, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $120,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_38930:
    movl 3(%eax), %eax
    mov %eax, -28(%esp)    # arg (cdr f6446)
# emit-expr (fx- f6447 1)
# emit-expr 1
    movl $4, %eax     # immed 1
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_38931"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $92,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_38931:
    movl %eax, -32(%esp)
# emit-expr f6447
# emit-variable-ref
# env=((f6447 . -20) (f6446 . -16) (f6447 . -12) (f6446 . -8) ((primitive-ref list-ref) . 4))
# var=f6447
    movl -20(%esp), %eax  # stack load f6447
# end emit-variable-ref
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_38932"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $92,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_38932:
    subl -32(%esp), %eax
    mov %eax, -32(%esp)    # arg (fx- f6447 1)
    movl -24(%esp), %edi   # load new closure to %edi
# emit-shift-args:  size=3   si=-24  delta=20
    mov -24(%esp), %ebx  # shift frame cell
    mov %ebx, -4(%esp)  # down to base
# emit-shift-args:  size=2   si=-28  delta=20
    mov -28(%esp), %ebx  # shift frame cell
    mov %ebx, -8(%esp)  # down to base
# emit-shift-args:  size=1   si=-32  delta=20
    mov -32(%esp), %ebx  # shift frame cell
    mov %ebx, -12(%esp)  # down to base
# emit-shift-args:  size=0   si=-36  delta=20
    movl $8,%eax   # save arg count
    jmp *-2(%edi)  # tail-funcall
_L_38926:
    .align 4,0x90
_L_38923:
     movl %eax, mrc_list$mref
# == explicit-begins  ==>
# (lambda (l) (if (null? l) 0 (fxadd1 (list-length (cdr l)))))
# == eliminate-let*  ==>
# (lambda (l) (if (null? l) 0 (fxadd1 (list-length (cdr l)))))
# == uniquify-variables  ==>
# (lambda (f6448) (if (null? f6448) 0 (fxadd1 (list-length (cdr f6448)))))
# == vectorize-letrec  ==>
# (lambda (f6448) (if (null? f6448) 0 (fxadd1 (list-length (cdr f6448)))))
# == eliminate-set!  ==>
# (lambda (f6448) (let ((f6448 f6448)) (if (null? f6448) 0 (fxadd1 (list-length (cdr f6448))))))
# == close-free-variables  ==>
# (closure (f6448) (list-length) (let ((f6448 f6448)) (if (null? f6448) 0 (fxadd1 (list-length (cdr f6448))))))
# == eliminate-quote  ==>
# (closure (f6448) (list-length) (let ((f6448 f6448)) (if (null? f6448) 0 (fxadd1 (list-length (cdr f6448))))))
# == eliminate-when/unless  ==>
# (closure (f6448) (list-length) (let ((f6448 f6448)) (if (null? f6448) 0 (fxadd1 (list-length (cdr f6448))))))
# == eliminate-cond  ==>
# (closure (f6448) (list-length) (let ((f6448 f6448)) (if (null? f6448) 0 (fxadd1 (list-length (cdr f6448))))))
# == external-symbols  ==>
# (closure (f6448) ((primitive-ref list-length)) (let ((f6448 f6448)) (if (null? f6448) 0 (fxadd1 ((primitive-ref list-length) (cdr f6448))))))
# emit-expr (closure (f6448) ((primitive-ref list-length)) (let ((f6448 f6448)) (if (null? f6448) 0 (fxadd1 ((primitive-ref list-length) (cdr f6448))))))
# emit-closure
# si = 0
# env = ()
# expr = (closure (f6448) ((primitive-ref list-length)) (let ((f6448 f6448)) (if (null? f6448) 0 (fxadd1 ((primitive-ref list-length) (cdr f6448))))))
    movl $_L_38933, 0(%ebp)  # closure label
# WARNING: free var (primitive-ref list-length) not defined in the environmnet
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $8, %ebp     # bump ebp
    jmp _L_38934            # jump around closure body
_L_38933:
# check argument count
    cmp $4,%eax
    je _L_38935
# invoke error handler eh_argcount
    .extern mrc_eh$uargcount
    movl mrc_eh$uargcount, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_38935:
# emit-tail-expr
# si=-12
# env=((f6448 . -8) ((primitive-ref list-length) . 4))
# expr=(let ((f6448 f6448)) (if (null? f6448) 0 (fxadd1 ((primitive-ref list-length) (cdr f6448)))))
# emit-tail-let
#  si   = -12
#  env  = ((f6448 . -8) ((primitive-ref list-length) . 4))
#  bindings = ((f6448 f6448))
#  body = (if (null? f6448) 0 (fxadd1 ((primitive-ref list-length) (cdr f6448))))
# emit-expr f6448
# emit-variable-ref
# env=((f6448 . -8) ((primitive-ref list-length) . 4))
# var=f6448
    movl -8(%esp), %eax  # stack load f6448
# end emit-variable-ref
    movl %eax, -12(%esp)  # stack save
# emit-tail-expr
# si=-16
# env=((f6448 . -12) (f6448 . -8) ((primitive-ref list-length) . 4))
# expr=(if (null? f6448) 0 (fxadd1 ((primitive-ref list-length) (cdr f6448))))
# emit-expr (null? f6448)
# emit-expr f6448
# emit-variable-ref
# env=((f6448 . -12) (f6448 . -8) ((primitive-ref list-length) . 4))
# var=f6448
    movl -12(%esp), %eax  # stack load f6448
# end emit-variable-ref
    cmp $63, %eax
    mov $0, %eax
    sete %al
    movzbl %al, %eax
    sal $6, %al
    or $47, %al
    cmp $47, %al
    je _L_38936
# emit-tail-expr
# si=-16
# env=((f6448 . -12) (f6448 . -8) ((primitive-ref list-length) . 4))
# expr=0
    movl $0, %eax     # immed 0
    ret                  # immediate tail return
    jmp _L_38937
_L_38936:
# emit-tail-expr
# si=-16
# env=((f6448 . -12) (f6448 . -8) ((primitive-ref list-length) . 4))
# expr=(fxadd1 ((primitive-ref list-length) (cdr f6448)))
# tail primcall
# emit-expr ((primitive-ref list-length) (cdr f6448))
# funcall
#    si   =-16
#    env  = ((f6448 . -12) (f6448 . -8) ((primitive-ref list-length) . 4))
#    expr = (funcall (primitive-ref list-length) (cdr f6448))
# emit-expr (primitive-ref list-length)
    .extern mrc_list$mlength
    movl mrc_list$mlength,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_38938"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_38938":
   movl %eax,  -24(%esp)  # stash funcall-oper in closure slot
# emit-expr (cdr f6448)
# emit-expr f6448
# emit-variable-ref
# env=((f6448 . -12) (f6448 . -8) ((primitive-ref list-length) . 4))
# var=f6448
    movl -12(%esp), %eax  # stack load f6448
# end emit-variable-ref
# check the argument is a pair
    movl %eax,%ebx
    and $7, %bl
    cmp $1, %bl
    je _L_38939
# invoke error handler eh_pair
    .extern mrc_eh$upair
    movl mrc_eh$upair, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $120,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_38939:
    movl 3(%eax), %eax
    mov %eax, -28(%esp)  # arg (cdr f6448)
    movl -24(%esp), %edi   # load new closure to %edi
    add $-16, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $16, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_38940"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $56,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_38940:
     addl $4, %eax
#return from tail (fxadd1 ((primitive-ref list-length) (cdr f6448)))
    ret
_L_38937:
    .align 4,0x90
_L_38934:
     movl %eax, mrc_list$mlength
# == explicit-begins  ==>
# (letrec ((f (lambda (l lrev) (if (null? l) lrev (f (cdr l) (cons (car l) lrev)))))) (lambda (l) (f l (quote ()))))
# == eliminate-let*  ==>
# (letrec ((f (lambda (l lrev) (if (null? l) lrev (f (cdr l) (cons (car l) lrev)))))) (lambda (l) (f l (quote ()))))
# == uniquify-variables  ==>
# (letrec ((f6449 (lambda (f6452 f6453) (if (null? f6452) f6453 (f6449 (cdr f6452) (cons (car f6452) f6453)))))) (lambda (f6455) (f6449 f6455 (quote ()))))
# == vectorize-letrec  ==>
# (let ((f6449 (make-vector 1))) (begin (begin (vector-set! f6449 0 (lambda (f6452 f6453) (if (null? f6452) f6453 ((vector-ref f6449 0) (cdr f6452) (cons (car f6452) f6453)))))) (lambda (f6455) ((vector-ref f6449 0) f6455 (quote ())))))
# == eliminate-set!  ==>
# (let ((f6449 (make-vector 1))) (begin (begin (vector-set! f6449 0 (lambda (f6452 f6453) (let ((f6452 f6452) (f6453 f6453)) (if (null? f6452) f6453 ((vector-ref f6449 0) (cdr f6452) (cons (car f6452) f6453))))))) (lambda (f6455) (let ((f6455 f6455)) ((vector-ref f6449 0) f6455 (quote ()))))))
# == close-free-variables  ==>
# (let ((f6449 (make-vector 1))) (begin (begin (vector-set! f6449 0 (closure (f6452 f6453) (f6449) (let ((f6452 f6452) (f6453 f6453)) (if (null? f6452) f6453 ((vector-ref f6449 0) (cdr f6452) (cons (car f6452) f6453))))))) (closure (f6455) (f6449) (let ((f6455 f6455)) ((vector-ref f6449 0) f6455 (quote ()))))))
# == eliminate-quote  ==>
# (let ((f6449 (make-vector 1))) (begin (begin (vector-set! f6449 0 (closure (f6452 f6453) (f6449) (let ((f6452 f6452) (f6453 f6453)) (if (null? f6452) f6453 ((vector-ref f6449 0) (cdr f6452) (cons (car f6452) f6453))))))) (closure (f6455) (f6449) (let ((f6455 f6455)) ((vector-ref f6449 0) f6455 ())))))
# == eliminate-when/unless  ==>
# (let ((f6449 (make-vector 1))) (begin (begin (vector-set! f6449 0 (closure (f6452 f6453) (f6449) (let ((f6452 f6452) (f6453 f6453)) (if (null? f6452) f6453 ((vector-ref f6449 0) (cdr f6452) (cons (car f6452) f6453))))))) (closure (f6455) (f6449) (let ((f6455 f6455)) ((vector-ref f6449 0) f6455 ())))))
# == eliminate-cond  ==>
# (let ((f6449 (make-vector 1))) (begin (begin (vector-set! f6449 0 (closure (f6452 f6453) (f6449) (let ((f6452 f6452) (f6453 f6453)) (if (null? f6452) f6453 ((vector-ref f6449 0) (cdr f6452) (cons (car f6452) f6453))))))) (closure (f6455) (f6449) (let ((f6455 f6455)) ((vector-ref f6449 0) f6455 ())))))
# == external-symbols  ==>
# (let ((f6449 (make-vector 1))) (begin (begin (vector-set! f6449 0 (closure (f6452 f6453) (f6449) (let ((f6452 f6452) (f6453 f6453)) (if (null? f6452) f6453 ((vector-ref f6449 0) (cdr f6452) (cons (car f6452) f6453))))))) (closure (f6455) (f6449) (let ((f6455 f6455)) ((vector-ref f6449 0) f6455 ())))))
# emit-expr (let ((f6449 (make-vector 1))) (begin (begin (vector-set! f6449 0 (closure (f6452 f6453) (f6449) (let ((f6452 f6452) (f6453 f6453)) (if (null? f6452) f6453 ((vector-ref f6449 0) (cdr f6452) (cons (car f6452) f6453))))))) (closure (f6455) (f6449) (let ((f6455 f6455)) ((vector-ref f6449 0) f6455 ())))))
# emit-let
#  si   = 0
#  env  = ()
#  bindings = ((f6449 (make-vector 1)))
#  body = (begin (begin (vector-set! f6449 0 (closure (f6452 f6453) (f6449) (let ((f6452 f6452) (f6453 f6453)) (if (null? f6452) f6453 ((vector-ref f6449 0) (cdr f6452) (cons (car f6452) f6453))))))) (closure (f6455) (f6449) (let ((f6455 f6455)) ((vector-ref f6449 0) f6455 ()))))
# emit-expr (make-vector 1)
# make-vector 1
# emit-expr 1
    movl $4, %eax     # immed 1
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_38941"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_38941:
# check the argument is a fixnum >= 0
    cmp $0,%eax
    jge _L_38942
# invoke error handler eh_length
    .extern mrc_eh$ulength
    movl mrc_eh$ulength, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_38942:
    movl %eax, %esi
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    orl  $5, %eax
    addl $4, %esi
    addl $4, %esi
    andl $-8, %esi
    addl %esi, %ebp
    movl %eax, 0(%esp)  # stack save
# emit-expr (begin (begin (vector-set! f6449 0 (closure (f6452 f6453) (f6449) (let ((f6452 f6452) (f6453 f6453)) (if (null? f6452) f6453 ((vector-ref f6449 0) (cdr f6452) (cons (car f6452) f6453))))))) (closure (f6455) (f6449) (let ((f6455 f6455)) ((vector-ref f6449 0) f6455 ()))))
# emit-begin
#   expr=(begin (begin (vector-set! f6449 0 (closure (f6452 f6453) (f6449) (let ((f6452 f6452) (f6453 f6453)) (if (null? f6452) f6453 ((vector-ref f6449 0) (cdr f6452) (cons (car f6452) f6453))))))) (closure (f6455) (f6449) (let ((f6455 f6455)) ((vector-ref f6449 0) f6455 ()))))
#   env=((f6449 . 0))
# emit-expr (begin (vector-set! f6449 0 (closure (f6452 f6453) (f6449) (let ((f6452 f6452) (f6453 f6453)) (if (null? f6452) f6453 ((vector-ref f6449 0) (cdr f6452) (cons (car f6452) f6453)))))))
# emit-begin
#   expr=(begin (vector-set! f6449 0 (closure (f6452 f6453) (f6449) (let ((f6452 f6452) (f6453 f6453)) (if (null? f6452) f6453 ((vector-ref f6449 0) (cdr f6452) (cons (car f6452) f6453)))))))
#   env=((f6449 . 0))
# emit-expr (vector-set! f6449 0 (closure (f6452 f6453) (f6449) (let ((f6452 f6452) (f6453 f6453)) (if (null? f6452) f6453 ((vector-ref f6449 0) (cdr f6452) (cons (car f6452) f6453))))))
# emit-expr f6449
# emit-variable-ref
# env=((f6449 . 0))
# var=f6449
    movl 0(%esp), %eax  # stack load f6449
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_38943
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_38943:
    movl %eax, -4(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_38944"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_38944:
# check bounds on vector index
    movl -4(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_38946
    cmp  $0,%eax
    jge _L_38945
_L_38946:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_38945:
    movl %eax, -8(%esp)
# emit-expr (closure (f6452 f6453) (f6449) (let ((f6452 f6452) (f6453 f6453)) (if (null? f6452) f6453 ((vector-ref f6449 0) (cdr f6452) (cons (car f6452) f6453)))))
# emit-closure
# si = -12
# env = ((f6449 . 0))
# expr = (closure (f6452 f6453) (f6449) (let ((f6452 f6452) (f6453 f6453)) (if (null? f6452) f6453 ((vector-ref f6449 0) (cdr f6452) (cons (car f6452) f6453)))))
    movl $_L_38947, 0(%ebp)  # closure label
# emit-variable-ref
# env=((f6449 . 0))
# var=f6449
    movl 0(%esp), %eax  # stack load f6449
# end emit-variable-ref
   movl  %eax, 4(%ebp)  # f6449
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $8, %ebp     # bump ebp
    jmp _L_38948            # jump around closure body
_L_38947:
# check argument count
    cmp $8,%eax
    je _L_38949
# invoke error handler eh_argcount
    .extern mrc_eh$uargcount
    movl mrc_eh$uargcount, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_38949:
# emit-tail-expr
# si=-16
# env=((f6453 . -12) (f6452 . -8) (f6449 . 4) (f6449 . 0))
# expr=(let ((f6452 f6452) (f6453 f6453)) (if (null? f6452) f6453 ((vector-ref f6449 0) (cdr f6452) (cons (car f6452) f6453))))
# emit-tail-let
#  si   = -16
#  env  = ((f6453 . -12) (f6452 . -8) (f6449 . 4) (f6449 . 0))
#  bindings = ((f6452 f6452) (f6453 f6453))
#  body = (if (null? f6452) f6453 ((vector-ref f6449 0) (cdr f6452) (cons (car f6452) f6453)))
# emit-expr f6452
# emit-variable-ref
# env=((f6453 . -12) (f6452 . -8) (f6449 . 4) (f6449 . 0))
# var=f6452
    movl -8(%esp), %eax  # stack load f6452
# end emit-variable-ref
    movl %eax, -16(%esp)  # stack save
# emit-expr f6453
# emit-variable-ref
# env=((f6453 . -12) (f6452 . -8) (f6449 . 4) (f6449 . 0))
# var=f6453
    movl -12(%esp), %eax  # stack load f6453
# end emit-variable-ref
    movl %eax, -20(%esp)  # stack save
# emit-tail-expr
# si=-24
# env=((f6453 . -20) (f6452 . -16) (f6453 . -12) (f6452 . -8) (f6449 . 4) (f6449 . 0))
# expr=(if (null? f6452) f6453 ((vector-ref f6449 0) (cdr f6452) (cons (car f6452) f6453)))
# emit-expr (null? f6452)
# emit-expr f6452
# emit-variable-ref
# env=((f6453 . -20) (f6452 . -16) (f6453 . -12) (f6452 . -8) (f6449 . 4) (f6449 . 0))
# var=f6452
    movl -16(%esp), %eax  # stack load f6452
# end emit-variable-ref
    cmp $63, %eax
    mov $0, %eax
    sete %al
    movzbl %al, %eax
    sal $6, %al
    or $47, %al
    cmp $47, %al
    je _L_38950
# emit-tail-expr
# si=-24
# env=((f6453 . -20) (f6452 . -16) (f6453 . -12) (f6452 . -8) (f6449 . 4) (f6449 . 0))
# expr=f6453
# emit-tail-variable-ref
# emit-variable-ref
# env=((f6453 . -20) (f6452 . -16) (f6453 . -12) (f6452 . -8) (f6449 . 4) (f6449 . 0))
# var=f6453
    movl -20(%esp), %eax  # stack load f6453
# end emit-variable-ref
    ret
# end emit-tail-variable ref
    jmp _L_38951
_L_38950:
# emit-tail-expr
# si=-24
# env=((f6453 . -20) (f6452 . -16) (f6453 . -12) (f6452 . -8) (f6449 . 4) (f6449 . 0))
# expr=((vector-ref f6449 0) (cdr f6452) (cons (car f6452) f6453))
# emit-tail-funcall
#    si   =-24
#    env  = ((f6453 . -20) (f6452 . -16) (f6453 . -12) (f6452 . -8) (f6449 . 4) (f6449 . 0))
#    expr = (funcall (vector-ref f6449 0) (cdr f6452) (cons (car f6452) f6453))
# emit-expr (vector-ref f6449 0)
# emit-expr f6449
# emit-variable-ref
# env=((f6453 . -20) (f6452 . -16) (f6453 . -12) (f6452 . -8) (f6449 . 4) (f6449 . 0))
# var=f6449
    movl 2(%edi), %eax  # frame load f6449
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_38952
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_38952:
    movl %eax, -24(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_38953"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_38953:
# check bounds on vector index
    movl -24(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_38955
    cmp  $0,%eax
    jge _L_38954
_L_38955:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_38954:
    movl -24(%esp), %esi
    movl -1(%eax,%esi), %eax
   movl %eax,  -24(%esp)  # stash funcall-oper in next closure slot
# emit-expr (cdr f6452)
# emit-expr f6452
# emit-variable-ref
# env=((f6453 . -20) (f6452 . -16) (f6453 . -12) (f6452 . -8) (f6449 . 4) (f6449 . 0))
# var=f6452
    movl -16(%esp), %eax  # stack load f6452
# end emit-variable-ref
# check the argument is a pair
    movl %eax,%ebx
    and $7, %bl
    cmp $1, %bl
    je _L_38956
# invoke error handler eh_pair
    .extern mrc_eh$upair
    movl mrc_eh$upair, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $120,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_38956:
    movl 3(%eax), %eax
    mov %eax, -28(%esp)    # arg (cdr f6452)
# emit-expr (cons (car f6452) f6453)
# cons arg1=(car f6452) arg2=f6453
# emit-expr (car f6452)
# emit-expr f6452
# emit-variable-ref
# env=((f6453 . -20) (f6452 . -16) (f6453 . -12) (f6452 . -8) (f6449 . 4) (f6449 . 0))
# var=f6452
    movl -16(%esp), %eax  # stack load f6452
# end emit-variable-ref
# check the argument is a pair
    movl %eax,%ebx
    and $7, %bl
    cmp $1, %bl
    je _L_38957
# invoke error handler eh_pair
    .extern mrc_eh$upair
    movl mrc_eh$upair, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $116,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_38957:
    movl -1(%eax), %eax
    movl %eax, -32(%esp)
# emit-expr f6453
# emit-variable-ref
# env=((f6453 . -20) (f6452 . -16) (f6453 . -12) (f6452 . -8) (f6449 . 4) (f6449 . 0))
# var=f6453
    movl -20(%esp), %eax  # stack load f6453
# end emit-variable-ref
    movl %eax, 4(%ebp)
    movl -32(%esp), %eax
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    or   $1, %al
    add  $8, %ebp
# cons end
    mov %eax, -32(%esp)    # arg (cons (car f6452) f6453)
    movl -24(%esp), %edi   # load new closure to %edi
# emit-shift-args:  size=3   si=-24  delta=20
    mov -24(%esp), %ebx  # shift frame cell
    mov %ebx, -4(%esp)  # down to base
# emit-shift-args:  size=2   si=-28  delta=20
    mov -28(%esp), %ebx  # shift frame cell
    mov %ebx, -8(%esp)  # down to base
# emit-shift-args:  size=1   si=-32  delta=20
    mov -32(%esp), %ebx  # shift frame cell
    mov %ebx, -12(%esp)  # down to base
# emit-shift-args:  size=0   si=-36  delta=20
    movl $8,%eax   # save arg count
    jmp *-2(%edi)  # tail-funcall
_L_38951:
    .align 4,0x90
_L_38948:
    movl -4(%esp), %ebx
    movl -8(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin)
# emit-begin
#   expr=(begin)
#   env=((f6449 . 0))
# emit-expr (begin (closure (f6455) (f6449) (let ((f6455 f6455)) ((vector-ref f6449 0) f6455 ()))))
# emit-begin
#   expr=(begin (closure (f6455) (f6449) (let ((f6455 f6455)) ((vector-ref f6449 0) f6455 ()))))
#   env=((f6449 . 0))
# emit-expr (closure (f6455) (f6449) (let ((f6455 f6455)) ((vector-ref f6449 0) f6455 ())))
# emit-closure
# si = -4
# env = ((f6449 . 0))
# expr = (closure (f6455) (f6449) (let ((f6455 f6455)) ((vector-ref f6449 0) f6455 ())))
    movl $_L_38958, 0(%ebp)  # closure label
# emit-variable-ref
# env=((f6449 . 0))
# var=f6449
    movl 0(%esp), %eax  # stack load f6449
# end emit-variable-ref
   movl  %eax, 4(%ebp)  # f6449
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $8, %ebp     # bump ebp
    jmp _L_38959            # jump around closure body
_L_38958:
# check argument count
    cmp $4,%eax
    je _L_38960
# invoke error handler eh_argcount
    .extern mrc_eh$uargcount
    movl mrc_eh$uargcount, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_38960:
# emit-tail-expr
# si=-12
# env=((f6455 . -8) (f6449 . 4) (f6449 . 0))
# expr=(let ((f6455 f6455)) ((vector-ref f6449 0) f6455 ()))
# emit-tail-let
#  si   = -12
#  env  = ((f6455 . -8) (f6449 . 4) (f6449 . 0))
#  bindings = ((f6455 f6455))
#  body = ((vector-ref f6449 0) f6455 ())
# emit-expr f6455
# emit-variable-ref
# env=((f6455 . -8) (f6449 . 4) (f6449 . 0))
# var=f6455
    movl -8(%esp), %eax  # stack load f6455
# end emit-variable-ref
    movl %eax, -12(%esp)  # stack save
# emit-tail-expr
# si=-16
# env=((f6455 . -12) (f6455 . -8) (f6449 . 4) (f6449 . 0))
# expr=((vector-ref f6449 0) f6455 ())
# emit-tail-funcall
#    si   =-16
#    env  = ((f6455 . -12) (f6455 . -8) (f6449 . 4) (f6449 . 0))
#    expr = (funcall (vector-ref f6449 0) f6455 ())
# emit-expr (vector-ref f6449 0)
# emit-expr f6449
# emit-variable-ref
# env=((f6455 . -12) (f6455 . -8) (f6449 . 4) (f6449 . 0))
# var=f6449
    movl 2(%edi), %eax  # frame load f6449
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_38961
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_38961:
    movl %eax, -16(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_38962"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_38962:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_38964
    cmp  $0,%eax
    jge _L_38963
_L_38964:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_38963:
    movl -16(%esp), %esi
    movl -1(%eax,%esi), %eax
   movl %eax,  -16(%esp)  # stash funcall-oper in next closure slot
# emit-expr f6455
# emit-variable-ref
# env=((f6455 . -12) (f6455 . -8) (f6449 . 4) (f6449 . 0))
# var=f6455
    movl -12(%esp), %eax  # stack load f6455
# end emit-variable-ref
    mov %eax, -20(%esp)    # arg f6455
# emit-expr ()
    movl $63, %eax     # immed ()
    mov %eax, -24(%esp)    # arg ()
    movl -16(%esp), %edi   # load new closure to %edi
# emit-shift-args:  size=3   si=-16  delta=12
    mov -16(%esp), %ebx  # shift frame cell
    mov %ebx, -4(%esp)  # down to base
# emit-shift-args:  size=2   si=-20  delta=12
    mov -20(%esp), %ebx  # shift frame cell
    mov %ebx, -8(%esp)  # down to base
# emit-shift-args:  size=1   si=-24  delta=12
    mov -24(%esp), %ebx  # shift frame cell
    mov %ebx, -12(%esp)  # down to base
# emit-shift-args:  size=0   si=-28  delta=12
    movl $8,%eax   # save arg count
    jmp *-2(%edi)  # tail-funcall
    .align 4,0x90
_L_38959:
# emit-expr (begin)
# emit-begin
#   expr=(begin)
#   env=((f6449 . 0))
     movl %eax, mrc_reverse
# == explicit-begins  ==>
# (lambda args args)
# == eliminate-let*  ==>
# (lambda args args)
# == uniquify-variables  ==>
# (lambda f6456 f6456)
# == vectorize-letrec  ==>
# (lambda f6456 f6456)
# == eliminate-set!  ==>
# (lambda f6456 (let () f6456))
# == close-free-variables  ==>
# (closure f6456 () (let () f6456))
# == eliminate-quote  ==>
# (closure f6456 () (let () f6456))
# == eliminate-when/unless  ==>
# (closure f6456 () (let () f6456))
# == eliminate-cond  ==>
# (closure f6456 () (let () f6456))
# == external-symbols  ==>
# (closure f6456 () (let () f6456))
# emit-expr (closure f6456 () (let () f6456))
# emit-closure
# si = 0
# env = ()
# expr = (closure f6456 () (let () f6456))
    movl $_L_38965, 0(%ebp)  # closure label
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $8, %ebp     # bump ebp
    jmp _L_38966            # jump around closure body
_L_38965:
# check argument count
    cmp $0,%eax
    jge _L_38967
# invoke error handler eh_argcount_min
    .extern mrc_eh$uargcount$umin
    movl mrc_eh$uargcount$umin, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_38967:
# emit-build-varargs-list
    movl $63, %esi       # args <- () 
    lea -4(%esp),%edi    # edi <- esp-4
    subl %eax, %edi      # edi <- esp-4-eax    addr of arg[K+N] on stack
_L_38969:
    lea -4(%esp),%ebx    # addr of arg[K] on stack
    cmp %edi, %ebx       # while edi <> esp+(si+4)
    je _L_38968
    movl (%edi),%ebx     # arg i -> car
    movl %ebx, 0(%ebp)
    movl %esi, 4(%ebp)  # esi -> cdr
    movl %ebp, %esi
    addl $1, %esi       # tag as pair
    addl $8,%ebp         # bump heap ptr
    addl $4,%edi         # move to next previous arg from the end
    jmp _L_38969
_L_38968:
    movl %esi, -8(%esp)  # set args
# emit-tail-expr
# si=-12
# env=((f6456 . -8))
# expr=(let () f6456)
# emit-tail-let
#  si   = -12
#  env  = ((f6456 . -8))
#  bindings = ()
#  body = f6456
# emit-tail-expr
# si=-12
# env=((f6456 . -8))
# expr=f6456
# emit-tail-variable-ref
# emit-variable-ref
# env=((f6456 . -8))
# var=f6456
    movl -8(%esp), %eax  # stack load f6456
# end emit-variable-ref
    ret
# end emit-tail-variable ref
    .align 4,0x90
_L_38966:
     movl %eax, mrc_list
# == explicit-begins  ==>
# (letrec ((fill-vector (lambda (v k args) (if (null? args) v (begin (vector-set! v k (car args)) (fill-vector v (fxadd1 k) (cdr args))))))) (lambda args (let ((v (make-vector (list-length args)))) (fill-vector v 0 args))))
# == eliminate-let*  ==>
# (letrec ((fill-vector (lambda (v k args) (if (null? args) v (begin (vector-set! v k (car args)) (fill-vector v (fxadd1 k) (cdr args))))))) (lambda args (let ((v (make-vector (list-length args)))) (fill-vector v 0 args))))
# == uniquify-variables  ==>
# (letrec ((f6457 (lambda (f6461 f6462 f6463) (if (null? f6463) f6461 (begin (vector-set! f6461 f6462 (car f6463)) (f6457 f6461 (fxadd1 f6462) (cdr f6463))))))) (lambda f6467 (let ((f6469 (make-vector (list-length f6467)))) (f6457 f6469 0 f6467))))
# == vectorize-letrec  ==>
# (let ((f6457 (make-vector 1))) (begin (begin (vector-set! f6457 0 (lambda (f6461 f6462 f6463) (if (null? f6463) f6461 (begin (vector-set! f6461 f6462 (car f6463)) ((vector-ref f6457 0) f6461 (fxadd1 f6462) (cdr f6463))))))) (lambda f6467 (let ((f6469 (make-vector (list-length f6467)))) ((vector-ref f6457 0) f6469 0 f6467)))))
# == eliminate-set!  ==>
# (let ((f6457 (make-vector 1))) (begin (begin (vector-set! f6457 0 (lambda (f6461 f6462 f6463) (let ((f6461 f6461) (f6462 f6462) (f6463 f6463)) (if (null? f6463) f6461 (begin (vector-set! f6461 f6462 (car f6463)) ((vector-ref f6457 0) f6461 (fxadd1 f6462) (cdr f6463)))))))) (lambda f6467 (let () (let ((f6469 (make-vector (list-length f6467)))) ((vector-ref f6457 0) f6469 0 f6467))))))
# == close-free-variables  ==>
# (let ((f6457 (make-vector 1))) (begin (begin (vector-set! f6457 0 (closure (f6461 f6462 f6463) (f6457) (let ((f6461 f6461) (f6462 f6462) (f6463 f6463)) (if (null? f6463) f6461 (begin (vector-set! f6461 f6462 (car f6463)) ((vector-ref f6457 0) f6461 (fxadd1 f6462) (cdr f6463)))))))) (closure f6467 (f6457) (let () (let ((f6469 (make-vector (list-length f6467)))) ((vector-ref f6457 0) f6469 0 f6467))))))
# == eliminate-quote  ==>
# (let ((f6457 (make-vector 1))) (begin (begin (vector-set! f6457 0 (closure (f6461 f6462 f6463) (f6457) (let ((f6461 f6461) (f6462 f6462) (f6463 f6463)) (if (null? f6463) f6461 (begin (vector-set! f6461 f6462 (car f6463)) ((vector-ref f6457 0) f6461 (fxadd1 f6462) (cdr f6463)))))))) (closure f6467 (f6457) (let () (let ((f6469 (make-vector (list-length f6467)))) ((vector-ref f6457 0) f6469 0 f6467))))))
# == eliminate-when/unless  ==>
# (let ((f6457 (make-vector 1))) (begin (begin (vector-set! f6457 0 (closure (f6461 f6462 f6463) (f6457) (let ((f6461 f6461) (f6462 f6462) (f6463 f6463)) (if (null? f6463) f6461 (begin (vector-set! f6461 f6462 (car f6463)) ((vector-ref f6457 0) f6461 (fxadd1 f6462) (cdr f6463)))))))) (closure f6467 (f6457) (let () (let ((f6469 (make-vector (list-length f6467)))) ((vector-ref f6457 0) f6469 0 f6467))))))
# == eliminate-cond  ==>
# (let ((f6457 (make-vector 1))) (begin (begin (vector-set! f6457 0 (closure (f6461 f6462 f6463) (f6457) (let ((f6461 f6461) (f6462 f6462) (f6463 f6463)) (if (null? f6463) f6461 (begin (vector-set! f6461 f6462 (car f6463)) ((vector-ref f6457 0) f6461 (fxadd1 f6462) (cdr f6463)))))))) (closure f6467 (f6457) (let () (let ((f6469 (make-vector (list-length f6467)))) ((vector-ref f6457 0) f6469 0 f6467))))))
# == external-symbols  ==>
# (let ((f6457 (make-vector 1))) (begin (begin (vector-set! f6457 0 (closure (f6461 f6462 f6463) (f6457) (let ((f6461 f6461) (f6462 f6462) (f6463 f6463)) (if (null? f6463) f6461 (begin (vector-set! f6461 f6462 (car f6463)) ((vector-ref f6457 0) f6461 (fxadd1 f6462) (cdr f6463)))))))) (closure f6467 (f6457) (let () (let ((f6469 (make-vector ((primitive-ref list-length) f6467)))) ((vector-ref f6457 0) f6469 0 f6467))))))
# emit-expr (let ((f6457 (make-vector 1))) (begin (begin (vector-set! f6457 0 (closure (f6461 f6462 f6463) (f6457) (let ((f6461 f6461) (f6462 f6462) (f6463 f6463)) (if (null? f6463) f6461 (begin (vector-set! f6461 f6462 (car f6463)) ((vector-ref f6457 0) f6461 (fxadd1 f6462) (cdr f6463)))))))) (closure f6467 (f6457) (let () (let ((f6469 (make-vector ((primitive-ref list-length) f6467)))) ((vector-ref f6457 0) f6469 0 f6467))))))
# emit-let
#  si   = 0
#  env  = ()
#  bindings = ((f6457 (make-vector 1)))
#  body = (begin (begin (vector-set! f6457 0 (closure (f6461 f6462 f6463) (f6457) (let ((f6461 f6461) (f6462 f6462) (f6463 f6463)) (if (null? f6463) f6461 (begin (vector-set! f6461 f6462 (car f6463)) ((vector-ref f6457 0) f6461 (fxadd1 f6462) (cdr f6463)))))))) (closure f6467 (f6457) (let () (let ((f6469 (make-vector ((primitive-ref list-length) f6467)))) ((vector-ref f6457 0) f6469 0 f6467)))))
# emit-expr (make-vector 1)
# make-vector 1
# emit-expr 1
    movl $4, %eax     # immed 1
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_38970"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_38970:
# check the argument is a fixnum >= 0
    cmp $0,%eax
    jge _L_38971
# invoke error handler eh_length
    .extern mrc_eh$ulength
    movl mrc_eh$ulength, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_38971:
    movl %eax, %esi
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    orl  $5, %eax
    addl $4, %esi
    addl $4, %esi
    andl $-8, %esi
    addl %esi, %ebp
    movl %eax, 0(%esp)  # stack save
# emit-expr (begin (begin (vector-set! f6457 0 (closure (f6461 f6462 f6463) (f6457) (let ((f6461 f6461) (f6462 f6462) (f6463 f6463)) (if (null? f6463) f6461 (begin (vector-set! f6461 f6462 (car f6463)) ((vector-ref f6457 0) f6461 (fxadd1 f6462) (cdr f6463)))))))) (closure f6467 (f6457) (let () (let ((f6469 (make-vector ((primitive-ref list-length) f6467)))) ((vector-ref f6457 0) f6469 0 f6467)))))
# emit-begin
#   expr=(begin (begin (vector-set! f6457 0 (closure (f6461 f6462 f6463) (f6457) (let ((f6461 f6461) (f6462 f6462) (f6463 f6463)) (if (null? f6463) f6461 (begin (vector-set! f6461 f6462 (car f6463)) ((vector-ref f6457 0) f6461 (fxadd1 f6462) (cdr f6463)))))))) (closure f6467 (f6457) (let () (let ((f6469 (make-vector ((primitive-ref list-length) f6467)))) ((vector-ref f6457 0) f6469 0 f6467)))))
#   env=((f6457 . 0))
# emit-expr (begin (vector-set! f6457 0 (closure (f6461 f6462 f6463) (f6457) (let ((f6461 f6461) (f6462 f6462) (f6463 f6463)) (if (null? f6463) f6461 (begin (vector-set! f6461 f6462 (car f6463)) ((vector-ref f6457 0) f6461 (fxadd1 f6462) (cdr f6463))))))))
# emit-begin
#   expr=(begin (vector-set! f6457 0 (closure (f6461 f6462 f6463) (f6457) (let ((f6461 f6461) (f6462 f6462) (f6463 f6463)) (if (null? f6463) f6461 (begin (vector-set! f6461 f6462 (car f6463)) ((vector-ref f6457 0) f6461 (fxadd1 f6462) (cdr f6463))))))))
#   env=((f6457 . 0))
# emit-expr (vector-set! f6457 0 (closure (f6461 f6462 f6463) (f6457) (let ((f6461 f6461) (f6462 f6462) (f6463 f6463)) (if (null? f6463) f6461 (begin (vector-set! f6461 f6462 (car f6463)) ((vector-ref f6457 0) f6461 (fxadd1 f6462) (cdr f6463)))))))
# emit-expr f6457
# emit-variable-ref
# env=((f6457 . 0))
# var=f6457
    movl 0(%esp), %eax  # stack load f6457
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_38972
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_38972:
    movl %eax, -4(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_38973"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_38973:
# check bounds on vector index
    movl -4(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_38975
    cmp  $0,%eax
    jge _L_38974
_L_38975:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_38974:
    movl %eax, -8(%esp)
# emit-expr (closure (f6461 f6462 f6463) (f6457) (let ((f6461 f6461) (f6462 f6462) (f6463 f6463)) (if (null? f6463) f6461 (begin (vector-set! f6461 f6462 (car f6463)) ((vector-ref f6457 0) f6461 (fxadd1 f6462) (cdr f6463))))))
# emit-closure
# si = -12
# env = ((f6457 . 0))
# expr = (closure (f6461 f6462 f6463) (f6457) (let ((f6461 f6461) (f6462 f6462) (f6463 f6463)) (if (null? f6463) f6461 (begin (vector-set! f6461 f6462 (car f6463)) ((vector-ref f6457 0) f6461 (fxadd1 f6462) (cdr f6463))))))
    movl $_L_38976, 0(%ebp)  # closure label
# emit-variable-ref
# env=((f6457 . 0))
# var=f6457
    movl 0(%esp), %eax  # stack load f6457
# end emit-variable-ref
   movl  %eax, 4(%ebp)  # f6457
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $8, %ebp     # bump ebp
    jmp _L_38977            # jump around closure body
_L_38976:
# check argument count
    cmp $12,%eax
    je _L_38978
# invoke error handler eh_argcount
    .extern mrc_eh$uargcount
    movl mrc_eh$uargcount, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_38978:
# emit-tail-expr
# si=-20
# env=((f6463 . -16) (f6462 . -12) (f6461 . -8) (f6457 . 4) (f6457 . 0))
# expr=(let ((f6461 f6461) (f6462 f6462) (f6463 f6463)) (if (null? f6463) f6461 (begin (vector-set! f6461 f6462 (car f6463)) ((vector-ref f6457 0) f6461 (fxadd1 f6462) (cdr f6463)))))
# emit-tail-let
#  si   = -20
#  env  = ((f6463 . -16) (f6462 . -12) (f6461 . -8) (f6457 . 4) (f6457 . 0))
#  bindings = ((f6461 f6461) (f6462 f6462) (f6463 f6463))
#  body = (if (null? f6463) f6461 (begin (vector-set! f6461 f6462 (car f6463)) ((vector-ref f6457 0) f6461 (fxadd1 f6462) (cdr f6463))))
# emit-expr f6461
# emit-variable-ref
# env=((f6463 . -16) (f6462 . -12) (f6461 . -8) (f6457 . 4) (f6457 . 0))
# var=f6461
    movl -8(%esp), %eax  # stack load f6461
# end emit-variable-ref
    movl %eax, -20(%esp)  # stack save
# emit-expr f6462
# emit-variable-ref
# env=((f6463 . -16) (f6462 . -12) (f6461 . -8) (f6457 . 4) (f6457 . 0))
# var=f6462
    movl -12(%esp), %eax  # stack load f6462
# end emit-variable-ref
    movl %eax, -24(%esp)  # stack save
# emit-expr f6463
# emit-variable-ref
# env=((f6463 . -16) (f6462 . -12) (f6461 . -8) (f6457 . 4) (f6457 . 0))
# var=f6463
    movl -16(%esp), %eax  # stack load f6463
# end emit-variable-ref
    movl %eax, -28(%esp)  # stack save
# emit-tail-expr
# si=-32
# env=((f6463 . -28) (f6462 . -24) (f6461 . -20) (f6463 . -16) (f6462 . -12) (f6461 . -8) (f6457 . 4) (f6457 . 0))
# expr=(if (null? f6463) f6461 (begin (vector-set! f6461 f6462 (car f6463)) ((vector-ref f6457 0) f6461 (fxadd1 f6462) (cdr f6463))))
# emit-expr (null? f6463)
# emit-expr f6463
# emit-variable-ref
# env=((f6463 . -28) (f6462 . -24) (f6461 . -20) (f6463 . -16) (f6462 . -12) (f6461 . -8) (f6457 . 4) (f6457 . 0))
# var=f6463
    movl -28(%esp), %eax  # stack load f6463
# end emit-variable-ref
    cmp $63, %eax
    mov $0, %eax
    sete %al
    movzbl %al, %eax
    sal $6, %al
    or $47, %al
    cmp $47, %al
    je _L_38979
# emit-tail-expr
# si=-32
# env=((f6463 . -28) (f6462 . -24) (f6461 . -20) (f6463 . -16) (f6462 . -12) (f6461 . -8) (f6457 . 4) (f6457 . 0))
# expr=f6461
# emit-tail-variable-ref
# emit-variable-ref
# env=((f6463 . -28) (f6462 . -24) (f6461 . -20) (f6463 . -16) (f6462 . -12) (f6461 . -8) (f6457 . 4) (f6457 . 0))
# var=f6461
    movl -20(%esp), %eax  # stack load f6461
# end emit-variable-ref
    ret
# end emit-tail-variable ref
    jmp _L_38980
_L_38979:
# emit-tail-expr
# si=-32
# env=((f6463 . -28) (f6462 . -24) (f6461 . -20) (f6463 . -16) (f6462 . -12) (f6461 . -8) (f6457 . 4) (f6457 . 0))
# expr=(begin (vector-set! f6461 f6462 (car f6463)) ((vector-ref f6457 0) f6461 (fxadd1 f6462) (cdr f6463)))
# tail-begin (begin (vector-set! f6461 f6462 (car f6463)) ((vector-ref f6457 0) f6461 (fxadd1 f6462) (cdr f6463)))
#   env=((f6463 . -28) (f6462 . -24) (f6461 . -20) (f6463 . -16) (f6462 . -12) (f6461 . -8) (f6457 . 4) (f6457 . 0))
# emit-expr (vector-set! f6461 f6462 (car f6463))
# emit-expr f6461
# emit-variable-ref
# env=((f6463 . -28) (f6462 . -24) (f6461 . -20) (f6463 . -16) (f6462 . -12) (f6461 . -8) (f6457 . 4) (f6457 . 0))
# var=f6461
    movl -20(%esp), %eax  # stack load f6461
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_38981
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_38981:
    movl %eax, -32(%esp)
# emit-expr f6462
# emit-variable-ref
# env=((f6463 . -28) (f6462 . -24) (f6461 . -20) (f6463 . -16) (f6462 . -12) (f6461 . -8) (f6457 . 4) (f6457 . 0))
# var=f6462
    movl -24(%esp), %eax  # stack load f6462
# end emit-variable-ref
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_38982"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_38982:
# check bounds on vector index
    movl -32(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_38984
    cmp  $0,%eax
    jge _L_38983
_L_38984:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_38983:
    movl %eax, -36(%esp)
# emit-expr (car f6463)
# emit-expr f6463
# emit-variable-ref
# env=((f6463 . -28) (f6462 . -24) (f6461 . -20) (f6463 . -16) (f6462 . -12) (f6461 . -8) (f6457 . 4) (f6457 . 0))
# var=f6463
    movl -28(%esp), %eax  # stack load f6463
# end emit-variable-ref
# check the argument is a pair
    movl %eax,%ebx
    and $7, %bl
    cmp $1, %bl
    je _L_38985
# invoke error handler eh_pair
    .extern mrc_eh$upair
    movl mrc_eh$upair, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $116,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_38985:
    movl -1(%eax), %eax
    movl -32(%esp), %ebx
    movl -36(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-tail-expr
# si=-32
# env=((f6463 . -28) (f6462 . -24) (f6461 . -20) (f6463 . -16) (f6462 . -12) (f6461 . -8) (f6457 . 4) (f6457 . 0))
# expr=(begin ((vector-ref f6457 0) f6461 (fxadd1 f6462) (cdr f6463)))
# tail-begin (begin ((vector-ref f6457 0) f6461 (fxadd1 f6462) (cdr f6463)))
#   env=((f6463 . -28) (f6462 . -24) (f6461 . -20) (f6463 . -16) (f6462 . -12) (f6461 . -8) (f6457 . 4) (f6457 . 0))
# emit-tail-expr
# si=-32
# env=((f6463 . -28) (f6462 . -24) (f6461 . -20) (f6463 . -16) (f6462 . -12) (f6461 . -8) (f6457 . 4) (f6457 . 0))
# expr=((vector-ref f6457 0) f6461 (fxadd1 f6462) (cdr f6463))
# emit-tail-funcall
#    si   =-32
#    env  = ((f6463 . -28) (f6462 . -24) (f6461 . -20) (f6463 . -16) (f6462 . -12) (f6461 . -8) (f6457 . 4) (f6457 . 0))
#    expr = (funcall (vector-ref f6457 0) f6461 (fxadd1 f6462) (cdr f6463))
# emit-expr (vector-ref f6457 0)
# emit-expr f6457
# emit-variable-ref
# env=((f6463 . -28) (f6462 . -24) (f6461 . -20) (f6463 . -16) (f6462 . -12) (f6461 . -8) (f6457 . 4) (f6457 . 0))
# var=f6457
    movl 2(%edi), %eax  # frame load f6457
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_38986
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_38986:
    movl %eax, -32(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_38987"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_38987:
# check bounds on vector index
    movl -32(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_38989
    cmp  $0,%eax
    jge _L_38988
_L_38989:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_38988:
    movl -32(%esp), %esi
    movl -1(%eax,%esi), %eax
   movl %eax,  -32(%esp)  # stash funcall-oper in next closure slot
# emit-expr f6461
# emit-variable-ref
# env=((f6463 . -28) (f6462 . -24) (f6461 . -20) (f6463 . -16) (f6462 . -12) (f6461 . -8) (f6457 . 4) (f6457 . 0))
# var=f6461
    movl -20(%esp), %eax  # stack load f6461
# end emit-variable-ref
    mov %eax, -36(%esp)    # arg f6461
# emit-expr (fxadd1 f6462)
# emit-expr f6462
# emit-variable-ref
# env=((f6463 . -28) (f6462 . -24) (f6461 . -20) (f6463 . -16) (f6462 . -12) (f6461 . -8) (f6457 . 4) (f6457 . 0))
# var=f6462
    movl -24(%esp), %eax  # stack load f6462
# end emit-variable-ref
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_38990"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $56,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_38990:
     addl $4, %eax
    mov %eax, -40(%esp)    # arg (fxadd1 f6462)
# emit-expr (cdr f6463)
# emit-expr f6463
# emit-variable-ref
# env=((f6463 . -28) (f6462 . -24) (f6461 . -20) (f6463 . -16) (f6462 . -12) (f6461 . -8) (f6457 . 4) (f6457 . 0))
# var=f6463
    movl -28(%esp), %eax  # stack load f6463
# end emit-variable-ref
# check the argument is a pair
    movl %eax,%ebx
    and $7, %bl
    cmp $1, %bl
    je _L_38991
# invoke error handler eh_pair
    .extern mrc_eh$upair
    movl mrc_eh$upair, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $120,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_38991:
    movl 3(%eax), %eax
    mov %eax, -44(%esp)    # arg (cdr f6463)
    movl -32(%esp), %edi   # load new closure to %edi
# emit-shift-args:  size=4   si=-32  delta=28
    mov -32(%esp), %ebx  # shift frame cell
    mov %ebx, -4(%esp)  # down to base
# emit-shift-args:  size=3   si=-36  delta=28
    mov -36(%esp), %ebx  # shift frame cell
    mov %ebx, -8(%esp)  # down to base
# emit-shift-args:  size=2   si=-40  delta=28
    mov -40(%esp), %ebx  # shift frame cell
    mov %ebx, -12(%esp)  # down to base
# emit-shift-args:  size=1   si=-44  delta=28
    mov -44(%esp), %ebx  # shift frame cell
    mov %ebx, -16(%esp)  # down to base
# emit-shift-args:  size=0   si=-48  delta=28
    movl $12,%eax   # save arg count
    jmp *-2(%edi)  # tail-funcall
     ret   # return thru stack
_L_38980:
    .align 4,0x90
_L_38977:
    movl -4(%esp), %ebx
    movl -8(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin)
# emit-begin
#   expr=(begin)
#   env=((f6457 . 0))
# emit-expr (begin (closure f6467 (f6457) (let () (let ((f6469 (make-vector ((primitive-ref list-length) f6467)))) ((vector-ref f6457 0) f6469 0 f6467)))))
# emit-begin
#   expr=(begin (closure f6467 (f6457) (let () (let ((f6469 (make-vector ((primitive-ref list-length) f6467)))) ((vector-ref f6457 0) f6469 0 f6467)))))
#   env=((f6457 . 0))
# emit-expr (closure f6467 (f6457) (let () (let ((f6469 (make-vector ((primitive-ref list-length) f6467)))) ((vector-ref f6457 0) f6469 0 f6467))))
# emit-closure
# si = -4
# env = ((f6457 . 0))
# expr = (closure f6467 (f6457) (let () (let ((f6469 (make-vector ((primitive-ref list-length) f6467)))) ((vector-ref f6457 0) f6469 0 f6467))))
    movl $_L_38992, 0(%ebp)  # closure label
# emit-variable-ref
# env=((f6457 . 0))
# var=f6457
    movl 0(%esp), %eax  # stack load f6457
# end emit-variable-ref
   movl  %eax, 4(%ebp)  # f6457
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $8, %ebp     # bump ebp
    jmp _L_38993            # jump around closure body
_L_38992:
# check argument count
    cmp $0,%eax
    jge _L_38994
# invoke error handler eh_argcount_min
    .extern mrc_eh$uargcount$umin
    movl mrc_eh$uargcount$umin, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_38994:
# emit-build-varargs-list
    movl $63, %esi       # args <- () 
    lea -4(%esp),%edi    # edi <- esp-4
    subl %eax, %edi      # edi <- esp-4-eax    addr of arg[K+N] on stack
_L_38996:
    lea -4(%esp),%ebx    # addr of arg[K] on stack
    cmp %edi, %ebx       # while edi <> esp+(si+4)
    je _L_38995
    movl (%edi),%ebx     # arg i -> car
    movl %ebx, 0(%ebp)
    movl %esi, 4(%ebp)  # esi -> cdr
    movl %ebp, %esi
    addl $1, %esi       # tag as pair
    addl $8,%ebp         # bump heap ptr
    addl $4,%edi         # move to next previous arg from the end
    jmp _L_38996
_L_38995:
    movl %esi, -8(%esp)  # set args
# emit-tail-expr
# si=-12
# env=((f6467 . -8) (f6457 . 4) (f6457 . 0))
# expr=(let () (let ((f6469 (make-vector ((primitive-ref list-length) f6467)))) ((vector-ref f6457 0) f6469 0 f6467)))
# emit-tail-let
#  si   = -12
#  env  = ((f6467 . -8) (f6457 . 4) (f6457 . 0))
#  bindings = ()
#  body = (let ((f6469 (make-vector ((primitive-ref list-length) f6467)))) ((vector-ref f6457 0) f6469 0 f6467))
# emit-tail-expr
# si=-12
# env=((f6467 . -8) (f6457 . 4) (f6457 . 0))
# expr=(let ((f6469 (make-vector ((primitive-ref list-length) f6467)))) ((vector-ref f6457 0) f6469 0 f6467))
# emit-tail-let
#  si   = -12
#  env  = ((f6467 . -8) (f6457 . 4) (f6457 . 0))
#  bindings = ((f6469 (make-vector ((primitive-ref list-length) f6467))))
#  body = ((vector-ref f6457 0) f6469 0 f6467)
# emit-expr (make-vector ((primitive-ref list-length) f6467))
# make-vector ((primitive-ref list-length) f6467)
# emit-expr ((primitive-ref list-length) f6467)
# funcall
#    si   =-12
#    env  = ((f6467 . -8) (f6457 . 4) (f6457 . 0))
#    expr = (funcall (primitive-ref list-length) f6467)
# emit-expr (primitive-ref list-length)
    .extern mrc_list$mlength
    movl mrc_list$mlength,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_38997"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_38997":
   movl %eax,  -20(%esp)  # stash funcall-oper in closure slot
# emit-expr f6467
# emit-variable-ref
# env=((f6467 . -8) (f6457 . 4) (f6457 . 0))
# var=f6467
    movl -8(%esp), %eax  # stack load f6467
# end emit-variable-ref
    mov %eax, -24(%esp)  # arg f6467
    movl -20(%esp), %edi   # load new closure to %edi
    add $-12, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $12, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_38998"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_38998:
# check the argument is a fixnum >= 0
    cmp $0,%eax
    jge _L_38999
# invoke error handler eh_length
    .extern mrc_eh$ulength
    movl mrc_eh$ulength, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_38999:
    movl %eax, %esi
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    orl  $5, %eax
    addl $4, %esi
    addl $4, %esi
    andl $-8, %esi
    addl %esi, %ebp
    movl %eax, -12(%esp)  # stack save
# emit-tail-expr
# si=-16
# env=((f6469 . -12) (f6467 . -8) (f6457 . 4) (f6457 . 0))
# expr=((vector-ref f6457 0) f6469 0 f6467)
# emit-tail-funcall
#    si   =-16
#    env  = ((f6469 . -12) (f6467 . -8) (f6457 . 4) (f6457 . 0))
#    expr = (funcall (vector-ref f6457 0) f6469 0 f6467)
# emit-expr (vector-ref f6457 0)
# emit-expr f6457
# emit-variable-ref
# env=((f6469 . -12) (f6467 . -8) (f6457 . 4) (f6457 . 0))
# var=f6457
    movl 2(%edi), %eax  # frame load f6457
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_39000
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_39000:
    movl %eax, -16(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_39001"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_39001:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_39003
    cmp  $0,%eax
    jge _L_39002
_L_39003:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_39002:
    movl -16(%esp), %esi
    movl -1(%eax,%esi), %eax
   movl %eax,  -16(%esp)  # stash funcall-oper in next closure slot
# emit-expr f6469
# emit-variable-ref
# env=((f6469 . -12) (f6467 . -8) (f6457 . 4) (f6457 . 0))
# var=f6469
    movl -12(%esp), %eax  # stack load f6469
# end emit-variable-ref
    mov %eax, -20(%esp)    # arg f6469
# emit-expr 0
    movl $0, %eax     # immed 0
    mov %eax, -24(%esp)    # arg 0
# emit-expr f6467
# emit-variable-ref
# env=((f6469 . -12) (f6467 . -8) (f6457 . 4) (f6457 . 0))
# var=f6467
    movl -8(%esp), %eax  # stack load f6467
# end emit-variable-ref
    mov %eax, -28(%esp)    # arg f6467
    movl -16(%esp), %edi   # load new closure to %edi
# emit-shift-args:  size=4   si=-16  delta=12
    mov -16(%esp), %ebx  # shift frame cell
    mov %ebx, -4(%esp)  # down to base
# emit-shift-args:  size=3   si=-20  delta=12
    mov -20(%esp), %ebx  # shift frame cell
    mov %ebx, -8(%esp)  # down to base
# emit-shift-args:  size=2   si=-24  delta=12
    mov -24(%esp), %ebx  # shift frame cell
    mov %ebx, -12(%esp)  # down to base
# emit-shift-args:  size=1   si=-28  delta=12
    mov -28(%esp), %ebx  # shift frame cell
    mov %ebx, -16(%esp)  # down to base
# emit-shift-args:  size=0   si=-32  delta=12
    movl $12,%eax   # save arg count
    jmp *-2(%edi)  # tail-funcall
    .align 4,0x90
_L_38993:
# emit-expr (begin)
# emit-begin
#   expr=(begin)
#   env=((f6457 . 0))
     movl %eax, mrc_vector
# == explicit-begins  ==>
# (letrec ((fill-string (lambda (s k args) (if (null? args) s (begin (string-set! s k (car args)) (fill-string s (fxadd1 k) (cdr args))))))) (lambda args (let ((s (make-string (list-length args)))) (fill-string s 0 args))))
# == eliminate-let*  ==>
# (letrec ((fill-string (lambda (s k args) (if (null? args) s (begin (string-set! s k (car args)) (fill-string s (fxadd1 k) (cdr args))))))) (lambda args (let ((s (make-string (list-length args)))) (fill-string s 0 args))))
# == uniquify-variables  ==>
# (letrec ((f6470 (lambda (f6474 f6475 f6476) (if (null? f6476) f6474 (begin (string-set! f6474 f6475 (car f6476)) (f6470 f6474 (fxadd1 f6475) (cdr f6476))))))) (lambda f6480 (let ((f6482 (make-string (list-length f6480)))) (f6470 f6482 0 f6480))))
# == vectorize-letrec  ==>
# (let ((f6470 (make-vector 1))) (begin (begin (vector-set! f6470 0 (lambda (f6474 f6475 f6476) (if (null? f6476) f6474 (begin (string-set! f6474 f6475 (car f6476)) ((vector-ref f6470 0) f6474 (fxadd1 f6475) (cdr f6476))))))) (lambda f6480 (let ((f6482 (make-string (list-length f6480)))) ((vector-ref f6470 0) f6482 0 f6480)))))
# == eliminate-set!  ==>
# (let ((f6470 (make-vector 1))) (begin (begin (vector-set! f6470 0 (lambda (f6474 f6475 f6476) (let ((f6474 f6474) (f6475 f6475) (f6476 f6476)) (if (null? f6476) f6474 (begin (string-set! f6474 f6475 (car f6476)) ((vector-ref f6470 0) f6474 (fxadd1 f6475) (cdr f6476)))))))) (lambda f6480 (let () (let ((f6482 (make-string (list-length f6480)))) ((vector-ref f6470 0) f6482 0 f6480))))))
# == close-free-variables  ==>
# (let ((f6470 (make-vector 1))) (begin (begin (vector-set! f6470 0 (closure (f6474 f6475 f6476) (f6470) (let ((f6474 f6474) (f6475 f6475) (f6476 f6476)) (if (null? f6476) f6474 (begin (string-set! f6474 f6475 (car f6476)) ((vector-ref f6470 0) f6474 (fxadd1 f6475) (cdr f6476)))))))) (closure f6480 (f6470) (let () (let ((f6482 (make-string (list-length f6480)))) ((vector-ref f6470 0) f6482 0 f6480))))))
# == eliminate-quote  ==>
# (let ((f6470 (make-vector 1))) (begin (begin (vector-set! f6470 0 (closure (f6474 f6475 f6476) (f6470) (let ((f6474 f6474) (f6475 f6475) (f6476 f6476)) (if (null? f6476) f6474 (begin (string-set! f6474 f6475 (car f6476)) ((vector-ref f6470 0) f6474 (fxadd1 f6475) (cdr f6476)))))))) (closure f6480 (f6470) (let () (let ((f6482 (make-string (list-length f6480)))) ((vector-ref f6470 0) f6482 0 f6480))))))
# == eliminate-when/unless  ==>
# (let ((f6470 (make-vector 1))) (begin (begin (vector-set! f6470 0 (closure (f6474 f6475 f6476) (f6470) (let ((f6474 f6474) (f6475 f6475) (f6476 f6476)) (if (null? f6476) f6474 (begin (string-set! f6474 f6475 (car f6476)) ((vector-ref f6470 0) f6474 (fxadd1 f6475) (cdr f6476)))))))) (closure f6480 (f6470) (let () (let ((f6482 (make-string (list-length f6480)))) ((vector-ref f6470 0) f6482 0 f6480))))))
# == eliminate-cond  ==>
# (let ((f6470 (make-vector 1))) (begin (begin (vector-set! f6470 0 (closure (f6474 f6475 f6476) (f6470) (let ((f6474 f6474) (f6475 f6475) (f6476 f6476)) (if (null? f6476) f6474 (begin (string-set! f6474 f6475 (car f6476)) ((vector-ref f6470 0) f6474 (fxadd1 f6475) (cdr f6476)))))))) (closure f6480 (f6470) (let () (let ((f6482 (make-string (list-length f6480)))) ((vector-ref f6470 0) f6482 0 f6480))))))
# == external-symbols  ==>
# (let ((f6470 (make-vector 1))) (begin (begin (vector-set! f6470 0 (closure (f6474 f6475 f6476) (f6470) (let ((f6474 f6474) (f6475 f6475) (f6476 f6476)) (if (null? f6476) f6474 (begin (string-set! f6474 f6475 (car f6476)) ((vector-ref f6470 0) f6474 (fxadd1 f6475) (cdr f6476)))))))) (closure f6480 (f6470) (let () (let ((f6482 (make-string ((primitive-ref list-length) f6480)))) ((vector-ref f6470 0) f6482 0 f6480))))))
# emit-expr (let ((f6470 (make-vector 1))) (begin (begin (vector-set! f6470 0 (closure (f6474 f6475 f6476) (f6470) (let ((f6474 f6474) (f6475 f6475) (f6476 f6476)) (if (null? f6476) f6474 (begin (string-set! f6474 f6475 (car f6476)) ((vector-ref f6470 0) f6474 (fxadd1 f6475) (cdr f6476)))))))) (closure f6480 (f6470) (let () (let ((f6482 (make-string ((primitive-ref list-length) f6480)))) ((vector-ref f6470 0) f6482 0 f6480))))))
# emit-let
#  si   = 0
#  env  = ()
#  bindings = ((f6470 (make-vector 1)))
#  body = (begin (begin (vector-set! f6470 0 (closure (f6474 f6475 f6476) (f6470) (let ((f6474 f6474) (f6475 f6475) (f6476 f6476)) (if (null? f6476) f6474 (begin (string-set! f6474 f6475 (car f6476)) ((vector-ref f6470 0) f6474 (fxadd1 f6475) (cdr f6476)))))))) (closure f6480 (f6470) (let () (let ((f6482 (make-string ((primitive-ref list-length) f6480)))) ((vector-ref f6470 0) f6482 0 f6480)))))
# emit-expr (make-vector 1)
# make-vector 1
# emit-expr 1
    movl $4, %eax     # immed 1
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_39004"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_39004:
# check the argument is a fixnum >= 0
    cmp $0,%eax
    jge _L_39005
# invoke error handler eh_length
    .extern mrc_eh$ulength
    movl mrc_eh$ulength, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_39005:
    movl %eax, %esi
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    orl  $5, %eax
    addl $4, %esi
    addl $4, %esi
    andl $-8, %esi
    addl %esi, %ebp
    movl %eax, 0(%esp)  # stack save
# emit-expr (begin (begin (vector-set! f6470 0 (closure (f6474 f6475 f6476) (f6470) (let ((f6474 f6474) (f6475 f6475) (f6476 f6476)) (if (null? f6476) f6474 (begin (string-set! f6474 f6475 (car f6476)) ((vector-ref f6470 0) f6474 (fxadd1 f6475) (cdr f6476)))))))) (closure f6480 (f6470) (let () (let ((f6482 (make-string ((primitive-ref list-length) f6480)))) ((vector-ref f6470 0) f6482 0 f6480)))))
# emit-begin
#   expr=(begin (begin (vector-set! f6470 0 (closure (f6474 f6475 f6476) (f6470) (let ((f6474 f6474) (f6475 f6475) (f6476 f6476)) (if (null? f6476) f6474 (begin (string-set! f6474 f6475 (car f6476)) ((vector-ref f6470 0) f6474 (fxadd1 f6475) (cdr f6476)))))))) (closure f6480 (f6470) (let () (let ((f6482 (make-string ((primitive-ref list-length) f6480)))) ((vector-ref f6470 0) f6482 0 f6480)))))
#   env=((f6470 . 0))
# emit-expr (begin (vector-set! f6470 0 (closure (f6474 f6475 f6476) (f6470) (let ((f6474 f6474) (f6475 f6475) (f6476 f6476)) (if (null? f6476) f6474 (begin (string-set! f6474 f6475 (car f6476)) ((vector-ref f6470 0) f6474 (fxadd1 f6475) (cdr f6476))))))))
# emit-begin
#   expr=(begin (vector-set! f6470 0 (closure (f6474 f6475 f6476) (f6470) (let ((f6474 f6474) (f6475 f6475) (f6476 f6476)) (if (null? f6476) f6474 (begin (string-set! f6474 f6475 (car f6476)) ((vector-ref f6470 0) f6474 (fxadd1 f6475) (cdr f6476))))))))
#   env=((f6470 . 0))
# emit-expr (vector-set! f6470 0 (closure (f6474 f6475 f6476) (f6470) (let ((f6474 f6474) (f6475 f6475) (f6476 f6476)) (if (null? f6476) f6474 (begin (string-set! f6474 f6475 (car f6476)) ((vector-ref f6470 0) f6474 (fxadd1 f6475) (cdr f6476)))))))
# emit-expr f6470
# emit-variable-ref
# env=((f6470 . 0))
# var=f6470
    movl 0(%esp), %eax  # stack load f6470
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_39006
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_39006:
    movl %eax, -4(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_39007"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_39007:
# check bounds on vector index
    movl -4(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_39009
    cmp  $0,%eax
    jge _L_39008
_L_39009:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_39008:
    movl %eax, -8(%esp)
# emit-expr (closure (f6474 f6475 f6476) (f6470) (let ((f6474 f6474) (f6475 f6475) (f6476 f6476)) (if (null? f6476) f6474 (begin (string-set! f6474 f6475 (car f6476)) ((vector-ref f6470 0) f6474 (fxadd1 f6475) (cdr f6476))))))
# emit-closure
# si = -12
# env = ((f6470 . 0))
# expr = (closure (f6474 f6475 f6476) (f6470) (let ((f6474 f6474) (f6475 f6475) (f6476 f6476)) (if (null? f6476) f6474 (begin (string-set! f6474 f6475 (car f6476)) ((vector-ref f6470 0) f6474 (fxadd1 f6475) (cdr f6476))))))
    movl $_L_39010, 0(%ebp)  # closure label
# emit-variable-ref
# env=((f6470 . 0))
# var=f6470
    movl 0(%esp), %eax  # stack load f6470
# end emit-variable-ref
   movl  %eax, 4(%ebp)  # f6470
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $8, %ebp     # bump ebp
    jmp _L_39011            # jump around closure body
_L_39010:
# check argument count
    cmp $12,%eax
    je _L_39012
# invoke error handler eh_argcount
    .extern mrc_eh$uargcount
    movl mrc_eh$uargcount, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_39012:
# emit-tail-expr
# si=-20
# env=((f6476 . -16) (f6475 . -12) (f6474 . -8) (f6470 . 4) (f6470 . 0))
# expr=(let ((f6474 f6474) (f6475 f6475) (f6476 f6476)) (if (null? f6476) f6474 (begin (string-set! f6474 f6475 (car f6476)) ((vector-ref f6470 0) f6474 (fxadd1 f6475) (cdr f6476)))))
# emit-tail-let
#  si   = -20
#  env  = ((f6476 . -16) (f6475 . -12) (f6474 . -8) (f6470 . 4) (f6470 . 0))
#  bindings = ((f6474 f6474) (f6475 f6475) (f6476 f6476))
#  body = (if (null? f6476) f6474 (begin (string-set! f6474 f6475 (car f6476)) ((vector-ref f6470 0) f6474 (fxadd1 f6475) (cdr f6476))))
# emit-expr f6474
# emit-variable-ref
# env=((f6476 . -16) (f6475 . -12) (f6474 . -8) (f6470 . 4) (f6470 . 0))
# var=f6474
    movl -8(%esp), %eax  # stack load f6474
# end emit-variable-ref
    movl %eax, -20(%esp)  # stack save
# emit-expr f6475
# emit-variable-ref
# env=((f6476 . -16) (f6475 . -12) (f6474 . -8) (f6470 . 4) (f6470 . 0))
# var=f6475
    movl -12(%esp), %eax  # stack load f6475
# end emit-variable-ref
    movl %eax, -24(%esp)  # stack save
# emit-expr f6476
# emit-variable-ref
# env=((f6476 . -16) (f6475 . -12) (f6474 . -8) (f6470 . 4) (f6470 . 0))
# var=f6476
    movl -16(%esp), %eax  # stack load f6476
# end emit-variable-ref
    movl %eax, -28(%esp)  # stack save
# emit-tail-expr
# si=-32
# env=((f6476 . -28) (f6475 . -24) (f6474 . -20) (f6476 . -16) (f6475 . -12) (f6474 . -8) (f6470 . 4) (f6470 . 0))
# expr=(if (null? f6476) f6474 (begin (string-set! f6474 f6475 (car f6476)) ((vector-ref f6470 0) f6474 (fxadd1 f6475) (cdr f6476))))
# emit-expr (null? f6476)
# emit-expr f6476
# emit-variable-ref
# env=((f6476 . -28) (f6475 . -24) (f6474 . -20) (f6476 . -16) (f6475 . -12) (f6474 . -8) (f6470 . 4) (f6470 . 0))
# var=f6476
    movl -28(%esp), %eax  # stack load f6476
# end emit-variable-ref
    cmp $63, %eax
    mov $0, %eax
    sete %al
    movzbl %al, %eax
    sal $6, %al
    or $47, %al
    cmp $47, %al
    je _L_39013
# emit-tail-expr
# si=-32
# env=((f6476 . -28) (f6475 . -24) (f6474 . -20) (f6476 . -16) (f6475 . -12) (f6474 . -8) (f6470 . 4) (f6470 . 0))
# expr=f6474
# emit-tail-variable-ref
# emit-variable-ref
# env=((f6476 . -28) (f6475 . -24) (f6474 . -20) (f6476 . -16) (f6475 . -12) (f6474 . -8) (f6470 . 4) (f6470 . 0))
# var=f6474
    movl -20(%esp), %eax  # stack load f6474
# end emit-variable-ref
    ret
# end emit-tail-variable ref
    jmp _L_39014
_L_39013:
# emit-tail-expr
# si=-32
# env=((f6476 . -28) (f6475 . -24) (f6474 . -20) (f6476 . -16) (f6475 . -12) (f6474 . -8) (f6470 . 4) (f6470 . 0))
# expr=(begin (string-set! f6474 f6475 (car f6476)) ((vector-ref f6470 0) f6474 (fxadd1 f6475) (cdr f6476)))
# tail-begin (begin (string-set! f6474 f6475 (car f6476)) ((vector-ref f6470 0) f6474 (fxadd1 f6475) (cdr f6476)))
#   env=((f6476 . -28) (f6475 . -24) (f6474 . -20) (f6476 . -16) (f6475 . -12) (f6474 . -8) (f6470 . 4) (f6470 . 0))
# emit-expr (string-set! f6474 f6475 (car f6476))
# emit-expr f6474
# emit-variable-ref
# env=((f6476 . -28) (f6475 . -24) (f6474 . -20) (f6476 . -16) (f6475 . -12) (f6474 . -8) (f6470 . 4) (f6470 . 0))
# var=f6474
    movl -20(%esp), %eax  # stack load f6474
# end emit-variable-ref
# check the argument is a string
    movl %eax,%ebx
    and $7, %bl
    cmp $6, %bl
    je _L_39015
# invoke error handler eh_string
    .extern mrc_eh$ustring
    movl mrc_eh$ustring, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $168,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_39015:
    movl %eax, -32(%esp)
# emit-expr f6475
# emit-variable-ref
# env=((f6476 . -28) (f6475 . -24) (f6474 . -20) (f6476 . -16) (f6475 . -12) (f6474 . -8) (f6470 . 4) (f6470 . 0))
# var=f6475
    movl -24(%esp), %eax  # stack load f6475
# end emit-variable-ref
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_39016"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $168,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_39016:
# check bounds on string index
    movl -32(%esp), %ebx
    cmp  %eax,-6(%ebx) 
    jle _L_39018
    cmp  $0,%eax
    jge _L_39017
_L_39018:
# invoke error handler eh_string_index
    .extern mrc_eh$ustring$uindex
    movl mrc_eh$ustring$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $168,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_39017:
    movl %eax, -36(%esp)
# emit-expr (car f6476)
# emit-expr f6476
# emit-variable-ref
# env=((f6476 . -28) (f6475 . -24) (f6474 . -20) (f6476 . -16) (f6475 . -12) (f6474 . -8) (f6470 . 4) (f6470 . 0))
# var=f6476
    movl -28(%esp), %eax  # stack load f6476
# end emit-variable-ref
# check the argument is a pair
    movl %eax,%ebx
    and $7, %bl
    cmp $1, %bl
    je _L_39019
# invoke error handler eh_pair
    .extern mrc_eh$upair
    movl mrc_eh$upair, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $116,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_39019:
    movl -1(%eax), %eax
# check the argument is a char
    movl %eax,%ebx
    and $255, %bl
    cmp $15, %bl
    je "_L_39020"
# invoke error handler eh_character
    .extern mrc_eh$ucharacter
    movl mrc_eh$ucharacter, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $168,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_39020:
    movl -32(%esp), %ebx
    movl -36(%esp), %esi
    sar $2, %esi
    movb  %ah, -2(%ebx,%esi)
# emit-tail-expr
# si=-32
# env=((f6476 . -28) (f6475 . -24) (f6474 . -20) (f6476 . -16) (f6475 . -12) (f6474 . -8) (f6470 . 4) (f6470 . 0))
# expr=(begin ((vector-ref f6470 0) f6474 (fxadd1 f6475) (cdr f6476)))
# tail-begin (begin ((vector-ref f6470 0) f6474 (fxadd1 f6475) (cdr f6476)))
#   env=((f6476 . -28) (f6475 . -24) (f6474 . -20) (f6476 . -16) (f6475 . -12) (f6474 . -8) (f6470 . 4) (f6470 . 0))
# emit-tail-expr
# si=-32
# env=((f6476 . -28) (f6475 . -24) (f6474 . -20) (f6476 . -16) (f6475 . -12) (f6474 . -8) (f6470 . 4) (f6470 . 0))
# expr=((vector-ref f6470 0) f6474 (fxadd1 f6475) (cdr f6476))
# emit-tail-funcall
#    si   =-32
#    env  = ((f6476 . -28) (f6475 . -24) (f6474 . -20) (f6476 . -16) (f6475 . -12) (f6474 . -8) (f6470 . 4) (f6470 . 0))
#    expr = (funcall (vector-ref f6470 0) f6474 (fxadd1 f6475) (cdr f6476))
# emit-expr (vector-ref f6470 0)
# emit-expr f6470
# emit-variable-ref
# env=((f6476 . -28) (f6475 . -24) (f6474 . -20) (f6476 . -16) (f6475 . -12) (f6474 . -8) (f6470 . 4) (f6470 . 0))
# var=f6470
    movl 2(%edi), %eax  # frame load f6470
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_39021
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_39021:
    movl %eax, -32(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_39022"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_39022:
# check bounds on vector index
    movl -32(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_39024
    cmp  $0,%eax
    jge _L_39023
_L_39024:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_39023:
    movl -32(%esp), %esi
    movl -1(%eax,%esi), %eax
   movl %eax,  -32(%esp)  # stash funcall-oper in next closure slot
# emit-expr f6474
# emit-variable-ref
# env=((f6476 . -28) (f6475 . -24) (f6474 . -20) (f6476 . -16) (f6475 . -12) (f6474 . -8) (f6470 . 4) (f6470 . 0))
# var=f6474
    movl -20(%esp), %eax  # stack load f6474
# end emit-variable-ref
    mov %eax, -36(%esp)    # arg f6474
# emit-expr (fxadd1 f6475)
# emit-expr f6475
# emit-variable-ref
# env=((f6476 . -28) (f6475 . -24) (f6474 . -20) (f6476 . -16) (f6475 . -12) (f6474 . -8) (f6470 . 4) (f6470 . 0))
# var=f6475
    movl -24(%esp), %eax  # stack load f6475
# end emit-variable-ref
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_39025"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $56,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_39025:
     addl $4, %eax
    mov %eax, -40(%esp)    # arg (fxadd1 f6475)
# emit-expr (cdr f6476)
# emit-expr f6476
# emit-variable-ref
# env=((f6476 . -28) (f6475 . -24) (f6474 . -20) (f6476 . -16) (f6475 . -12) (f6474 . -8) (f6470 . 4) (f6470 . 0))
# var=f6476
    movl -28(%esp), %eax  # stack load f6476
# end emit-variable-ref
# check the argument is a pair
    movl %eax,%ebx
    and $7, %bl
    cmp $1, %bl
    je _L_39026
# invoke error handler eh_pair
    .extern mrc_eh$upair
    movl mrc_eh$upair, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $120,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_39026:
    movl 3(%eax), %eax
    mov %eax, -44(%esp)    # arg (cdr f6476)
    movl -32(%esp), %edi   # load new closure to %edi
# emit-shift-args:  size=4   si=-32  delta=28
    mov -32(%esp), %ebx  # shift frame cell
    mov %ebx, -4(%esp)  # down to base
# emit-shift-args:  size=3   si=-36  delta=28
    mov -36(%esp), %ebx  # shift frame cell
    mov %ebx, -8(%esp)  # down to base
# emit-shift-args:  size=2   si=-40  delta=28
    mov -40(%esp), %ebx  # shift frame cell
    mov %ebx, -12(%esp)  # down to base
# emit-shift-args:  size=1   si=-44  delta=28
    mov -44(%esp), %ebx  # shift frame cell
    mov %ebx, -16(%esp)  # down to base
# emit-shift-args:  size=0   si=-48  delta=28
    movl $12,%eax   # save arg count
    jmp *-2(%edi)  # tail-funcall
     ret   # return thru stack
_L_39014:
    .align 4,0x90
_L_39011:
    movl -4(%esp), %ebx
    movl -8(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin)
# emit-begin
#   expr=(begin)
#   env=((f6470 . 0))
# emit-expr (begin (closure f6480 (f6470) (let () (let ((f6482 (make-string ((primitive-ref list-length) f6480)))) ((vector-ref f6470 0) f6482 0 f6480)))))
# emit-begin
#   expr=(begin (closure f6480 (f6470) (let () (let ((f6482 (make-string ((primitive-ref list-length) f6480)))) ((vector-ref f6470 0) f6482 0 f6480)))))
#   env=((f6470 . 0))
# emit-expr (closure f6480 (f6470) (let () (let ((f6482 (make-string ((primitive-ref list-length) f6480)))) ((vector-ref f6470 0) f6482 0 f6480))))
# emit-closure
# si = -4
# env = ((f6470 . 0))
# expr = (closure f6480 (f6470) (let () (let ((f6482 (make-string ((primitive-ref list-length) f6480)))) ((vector-ref f6470 0) f6482 0 f6480))))
    movl $_L_39027, 0(%ebp)  # closure label
# emit-variable-ref
# env=((f6470 . 0))
# var=f6470
    movl 0(%esp), %eax  # stack load f6470
# end emit-variable-ref
   movl  %eax, 4(%ebp)  # f6470
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $8, %ebp     # bump ebp
    jmp _L_39028            # jump around closure body
_L_39027:
# check argument count
    cmp $0,%eax
    jge _L_39029
# invoke error handler eh_argcount_min
    .extern mrc_eh$uargcount$umin
    movl mrc_eh$uargcount$umin, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_39029:
# emit-build-varargs-list
    movl $63, %esi       # args <- () 
    lea -4(%esp),%edi    # edi <- esp-4
    subl %eax, %edi      # edi <- esp-4-eax    addr of arg[K+N] on stack
_L_39031:
    lea -4(%esp),%ebx    # addr of arg[K] on stack
    cmp %edi, %ebx       # while edi <> esp+(si+4)
    je _L_39030
    movl (%edi),%ebx     # arg i -> car
    movl %ebx, 0(%ebp)
    movl %esi, 4(%ebp)  # esi -> cdr
    movl %ebp, %esi
    addl $1, %esi       # tag as pair
    addl $8,%ebp         # bump heap ptr
    addl $4,%edi         # move to next previous arg from the end
    jmp _L_39031
_L_39030:
    movl %esi, -8(%esp)  # set args
# emit-tail-expr
# si=-12
# env=((f6480 . -8) (f6470 . 4) (f6470 . 0))
# expr=(let () (let ((f6482 (make-string ((primitive-ref list-length) f6480)))) ((vector-ref f6470 0) f6482 0 f6480)))
# emit-tail-let
#  si   = -12
#  env  = ((f6480 . -8) (f6470 . 4) (f6470 . 0))
#  bindings = ()
#  body = (let ((f6482 (make-string ((primitive-ref list-length) f6480)))) ((vector-ref f6470 0) f6482 0 f6480))
# emit-tail-expr
# si=-12
# env=((f6480 . -8) (f6470 . 4) (f6470 . 0))
# expr=(let ((f6482 (make-string ((primitive-ref list-length) f6480)))) ((vector-ref f6470 0) f6482 0 f6480))
# emit-tail-let
#  si   = -12
#  env  = ((f6480 . -8) (f6470 . 4) (f6470 . 0))
#  bindings = ((f6482 (make-string ((primitive-ref list-length) f6480))))
#  body = ((vector-ref f6470 0) f6482 0 f6480)
# emit-expr (make-string ((primitive-ref list-length) f6480))
# make-string len=((primitive-ref list-length) f6480)
# emit-expr ((primitive-ref list-length) f6480)
# funcall
#    si   =-12
#    env  = ((f6480 . -8) (f6470 . 4) (f6470 . 0))
#    expr = (funcall (primitive-ref list-length) f6480)
# emit-expr (primitive-ref list-length)
    .extern mrc_list$mlength
    movl mrc_list$mlength,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_39032"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_39032":
   movl %eax,  -20(%esp)  # stash funcall-oper in closure slot
# emit-expr f6480
# emit-variable-ref
# env=((f6480 . -8) (f6470 . 4) (f6470 . 0))
# var=f6480
    movl -8(%esp), %eax  # stack load f6480
# end emit-variable-ref
    mov %eax, -24(%esp)  # arg f6480
    movl -20(%esp), %edi   # load new closure to %edi
    add $-12, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $12, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_39033"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $152,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_39033:
# check the argument is a fixnum >= 0
    cmp $0,%eax
    jge _L_39034
# invoke error handler eh_length
    .extern mrc_eh$ulength
    movl mrc_eh$ulength, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $152,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_39034:
    movl %eax, %esi
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    orl $6, %eax
    sar $2, %esi
    add $4, %esi
    add $7, %esi
    andl $-8, %esi
    add  %esi, %ebp
# make-string end
    movl %eax, -12(%esp)  # stack save
# emit-tail-expr
# si=-16
# env=((f6482 . -12) (f6480 . -8) (f6470 . 4) (f6470 . 0))
# expr=((vector-ref f6470 0) f6482 0 f6480)
# emit-tail-funcall
#    si   =-16
#    env  = ((f6482 . -12) (f6480 . -8) (f6470 . 4) (f6470 . 0))
#    expr = (funcall (vector-ref f6470 0) f6482 0 f6480)
# emit-expr (vector-ref f6470 0)
# emit-expr f6470
# emit-variable-ref
# env=((f6482 . -12) (f6480 . -8) (f6470 . 4) (f6470 . 0))
# var=f6470
    movl 2(%edi), %eax  # frame load f6470
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_39035
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_39035:
    movl %eax, -16(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_39036"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_39036:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_39038
    cmp  $0,%eax
    jge _L_39037
_L_39038:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_39037:
    movl -16(%esp), %esi
    movl -1(%eax,%esi), %eax
   movl %eax,  -16(%esp)  # stash funcall-oper in next closure slot
# emit-expr f6482
# emit-variable-ref
# env=((f6482 . -12) (f6480 . -8) (f6470 . 4) (f6470 . 0))
# var=f6482
    movl -12(%esp), %eax  # stack load f6482
# end emit-variable-ref
    mov %eax, -20(%esp)    # arg f6482
# emit-expr 0
    movl $0, %eax     # immed 0
    mov %eax, -24(%esp)    # arg 0
# emit-expr f6480
# emit-variable-ref
# env=((f6482 . -12) (f6480 . -8) (f6470 . 4) (f6470 . 0))
# var=f6480
    movl -8(%esp), %eax  # stack load f6480
# end emit-variable-ref
    mov %eax, -28(%esp)    # arg f6480
    movl -16(%esp), %edi   # load new closure to %edi
# emit-shift-args:  size=4   si=-16  delta=12
    mov -16(%esp), %ebx  # shift frame cell
    mov %ebx, -4(%esp)  # down to base
# emit-shift-args:  size=3   si=-20  delta=12
    mov -20(%esp), %ebx  # shift frame cell
    mov %ebx, -8(%esp)  # down to base
# emit-shift-args:  size=2   si=-24  delta=12
    mov -24(%esp), %ebx  # shift frame cell
    mov %ebx, -12(%esp)  # down to base
# emit-shift-args:  size=1   si=-28  delta=12
    mov -28(%esp), %ebx  # shift frame cell
    mov %ebx, -16(%esp)  # down to base
# emit-shift-args:  size=0   si=-32  delta=12
    movl $12,%eax   # save arg count
    jmp *-2(%edi)  # tail-funcall
    .align 4,0x90
_L_39028:
# emit-expr (begin)
# emit-begin
#   expr=(begin)
#   env=((f6470 . 0))
     movl %eax, mrc_string
# == explicit-begins  ==>
# (letrec ((f (lambda (s i) (if (fx= i (string-length s)) (quote ()) (cons (string-ref s i) (f s (fxadd1 i))))))) (lambda (s) (f s 0)))
# == eliminate-let*  ==>
# (letrec ((f (lambda (s i) (if (fx= i (string-length s)) (quote ()) (cons (string-ref s i) (f s (fxadd1 i))))))) (lambda (s) (f s 0)))
# == uniquify-variables  ==>
# (letrec ((f6483 (lambda (f6486 f6487) (if (fx= f6487 (string-length f6486)) (quote ()) (cons (string-ref f6486 f6487) (f6483 f6486 (fxadd1 f6487))))))) (lambda (f6489) (f6483 f6489 0)))
# == vectorize-letrec  ==>
# (let ((f6483 (make-vector 1))) (begin (begin (vector-set! f6483 0 (lambda (f6486 f6487) (if (fx= f6487 (string-length f6486)) (quote ()) (cons (string-ref f6486 f6487) ((vector-ref f6483 0) f6486 (fxadd1 f6487))))))) (lambda (f6489) ((vector-ref f6483 0) f6489 0))))
# == eliminate-set!  ==>
# (let ((f6483 (make-vector 1))) (begin (begin (vector-set! f6483 0 (lambda (f6486 f6487) (let ((f6486 f6486) (f6487 f6487)) (if (fx= f6487 (string-length f6486)) (quote ()) (cons (string-ref f6486 f6487) ((vector-ref f6483 0) f6486 (fxadd1 f6487)))))))) (lambda (f6489) (let ((f6489 f6489)) ((vector-ref f6483 0) f6489 0)))))
# == close-free-variables  ==>
# (let ((f6483 (make-vector 1))) (begin (begin (vector-set! f6483 0 (closure (f6486 f6487) (f6483) (let ((f6486 f6486) (f6487 f6487)) (if (fx= f6487 (string-length f6486)) (quote ()) (cons (string-ref f6486 f6487) ((vector-ref f6483 0) f6486 (fxadd1 f6487)))))))) (closure (f6489) (f6483) (let ((f6489 f6489)) ((vector-ref f6483 0) f6489 0)))))
# == eliminate-quote  ==>
# (let ((f6483 (make-vector 1))) (begin (begin (vector-set! f6483 0 (closure (f6486 f6487) (f6483) (let ((f6486 f6486) (f6487 f6487)) (if (fx= f6487 (string-length f6486)) () (cons (string-ref f6486 f6487) ((vector-ref f6483 0) f6486 (fxadd1 f6487)))))))) (closure (f6489) (f6483) (let ((f6489 f6489)) ((vector-ref f6483 0) f6489 0)))))
# == eliminate-when/unless  ==>
# (let ((f6483 (make-vector 1))) (begin (begin (vector-set! f6483 0 (closure (f6486 f6487) (f6483) (let ((f6486 f6486) (f6487 f6487)) (if (fx= f6487 (string-length f6486)) () (cons (string-ref f6486 f6487) ((vector-ref f6483 0) f6486 (fxadd1 f6487)))))))) (closure (f6489) (f6483) (let ((f6489 f6489)) ((vector-ref f6483 0) f6489 0)))))
# == eliminate-cond  ==>
# (let ((f6483 (make-vector 1))) (begin (begin (vector-set! f6483 0 (closure (f6486 f6487) (f6483) (let ((f6486 f6486) (f6487 f6487)) (if (fx= f6487 (string-length f6486)) () (cons (string-ref f6486 f6487) ((vector-ref f6483 0) f6486 (fxadd1 f6487)))))))) (closure (f6489) (f6483) (let ((f6489 f6489)) ((vector-ref f6483 0) f6489 0)))))
# == external-symbols  ==>
# (let ((f6483 (make-vector 1))) (begin (begin (vector-set! f6483 0 (closure (f6486 f6487) (f6483) (let ((f6486 f6486) (f6487 f6487)) (if (fx= f6487 (string-length f6486)) () (cons (string-ref f6486 f6487) ((vector-ref f6483 0) f6486 (fxadd1 f6487)))))))) (closure (f6489) (f6483) (let ((f6489 f6489)) ((vector-ref f6483 0) f6489 0)))))
# emit-expr (let ((f6483 (make-vector 1))) (begin (begin (vector-set! f6483 0 (closure (f6486 f6487) (f6483) (let ((f6486 f6486) (f6487 f6487)) (if (fx= f6487 (string-length f6486)) () (cons (string-ref f6486 f6487) ((vector-ref f6483 0) f6486 (fxadd1 f6487)))))))) (closure (f6489) (f6483) (let ((f6489 f6489)) ((vector-ref f6483 0) f6489 0)))))
# emit-let
#  si   = 0
#  env  = ()
#  bindings = ((f6483 (make-vector 1)))
#  body = (begin (begin (vector-set! f6483 0 (closure (f6486 f6487) (f6483) (let ((f6486 f6486) (f6487 f6487)) (if (fx= f6487 (string-length f6486)) () (cons (string-ref f6486 f6487) ((vector-ref f6483 0) f6486 (fxadd1 f6487)))))))) (closure (f6489) (f6483) (let ((f6489 f6489)) ((vector-ref f6483 0) f6489 0))))
# emit-expr (make-vector 1)
# make-vector 1
# emit-expr 1
    movl $4, %eax     # immed 1
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_39039"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_39039:
# check the argument is a fixnum >= 0
    cmp $0,%eax
    jge _L_39040
# invoke error handler eh_length
    .extern mrc_eh$ulength
    movl mrc_eh$ulength, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_39040:
    movl %eax, %esi
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    orl  $5, %eax
    addl $4, %esi
    addl $4, %esi
    andl $-8, %esi
    addl %esi, %ebp
    movl %eax, 0(%esp)  # stack save
# emit-expr (begin (begin (vector-set! f6483 0 (closure (f6486 f6487) (f6483) (let ((f6486 f6486) (f6487 f6487)) (if (fx= f6487 (string-length f6486)) () (cons (string-ref f6486 f6487) ((vector-ref f6483 0) f6486 (fxadd1 f6487)))))))) (closure (f6489) (f6483) (let ((f6489 f6489)) ((vector-ref f6483 0) f6489 0))))
# emit-begin
#   expr=(begin (begin (vector-set! f6483 0 (closure (f6486 f6487) (f6483) (let ((f6486 f6486) (f6487 f6487)) (if (fx= f6487 (string-length f6486)) () (cons (string-ref f6486 f6487) ((vector-ref f6483 0) f6486 (fxadd1 f6487)))))))) (closure (f6489) (f6483) (let ((f6489 f6489)) ((vector-ref f6483 0) f6489 0))))
#   env=((f6483 . 0))
# emit-expr (begin (vector-set! f6483 0 (closure (f6486 f6487) (f6483) (let ((f6486 f6486) (f6487 f6487)) (if (fx= f6487 (string-length f6486)) () (cons (string-ref f6486 f6487) ((vector-ref f6483 0) f6486 (fxadd1 f6487))))))))
# emit-begin
#   expr=(begin (vector-set! f6483 0 (closure (f6486 f6487) (f6483) (let ((f6486 f6486) (f6487 f6487)) (if (fx= f6487 (string-length f6486)) () (cons (string-ref f6486 f6487) ((vector-ref f6483 0) f6486 (fxadd1 f6487))))))))
#   env=((f6483 . 0))
# emit-expr (vector-set! f6483 0 (closure (f6486 f6487) (f6483) (let ((f6486 f6486) (f6487 f6487)) (if (fx= f6487 (string-length f6486)) () (cons (string-ref f6486 f6487) ((vector-ref f6483 0) f6486 (fxadd1 f6487)))))))
# emit-expr f6483
# emit-variable-ref
# env=((f6483 . 0))
# var=f6483
    movl 0(%esp), %eax  # stack load f6483
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_39041
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_39041:
    movl %eax, -4(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_39042"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_39042:
# check bounds on vector index
    movl -4(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_39044
    cmp  $0,%eax
    jge _L_39043
_L_39044:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_39043:
    movl %eax, -8(%esp)
# emit-expr (closure (f6486 f6487) (f6483) (let ((f6486 f6486) (f6487 f6487)) (if (fx= f6487 (string-length f6486)) () (cons (string-ref f6486 f6487) ((vector-ref f6483 0) f6486 (fxadd1 f6487))))))
# emit-closure
# si = -12
# env = ((f6483 . 0))
# expr = (closure (f6486 f6487) (f6483) (let ((f6486 f6486) (f6487 f6487)) (if (fx= f6487 (string-length f6486)) () (cons (string-ref f6486 f6487) ((vector-ref f6483 0) f6486 (fxadd1 f6487))))))
    movl $_L_39045, 0(%ebp)  # closure label
# emit-variable-ref
# env=((f6483 . 0))
# var=f6483
    movl 0(%esp), %eax  # stack load f6483
# end emit-variable-ref
   movl  %eax, 4(%ebp)  # f6483
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $8, %ebp     # bump ebp
    jmp _L_39046            # jump around closure body
_L_39045:
# check argument count
    cmp $8,%eax
    je _L_39047
# invoke error handler eh_argcount
    .extern mrc_eh$uargcount
    movl mrc_eh$uargcount, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_39047:
# emit-tail-expr
# si=-16
# env=((f6487 . -12) (f6486 . -8) (f6483 . 4) (f6483 . 0))
# expr=(let ((f6486 f6486) (f6487 f6487)) (if (fx= f6487 (string-length f6486)) () (cons (string-ref f6486 f6487) ((vector-ref f6483 0) f6486 (fxadd1 f6487)))))
# emit-tail-let
#  si   = -16
#  env  = ((f6487 . -12) (f6486 . -8) (f6483 . 4) (f6483 . 0))
#  bindings = ((f6486 f6486) (f6487 f6487))
#  body = (if (fx= f6487 (string-length f6486)) () (cons (string-ref f6486 f6487) ((vector-ref f6483 0) f6486 (fxadd1 f6487))))
# emit-expr f6486
# emit-variable-ref
# env=((f6487 . -12) (f6486 . -8) (f6483 . 4) (f6483 . 0))
# var=f6486
    movl -8(%esp), %eax  # stack load f6486
# end emit-variable-ref
    movl %eax, -16(%esp)  # stack save
# emit-expr f6487
# emit-variable-ref
# env=((f6487 . -12) (f6486 . -8) (f6483 . 4) (f6483 . 0))
# var=f6487
    movl -12(%esp), %eax  # stack load f6487
# end emit-variable-ref
    movl %eax, -20(%esp)  # stack save
# emit-tail-expr
# si=-24
# env=((f6487 . -20) (f6486 . -16) (f6487 . -12) (f6486 . -8) (f6483 . 4) (f6483 . 0))
# expr=(if (fx= f6487 (string-length f6486)) () (cons (string-ref f6486 f6487) ((vector-ref f6483 0) f6486 (fxadd1 f6487))))
# emit-expr (fx= f6487 (string-length f6486))
# emit-expr (string-length f6486)
# emit-expr f6486
# emit-variable-ref
# env=((f6487 . -20) (f6486 . -16) (f6487 . -12) (f6486 . -8) (f6483 . 4) (f6483 . 0))
# var=f6486
    movl -16(%esp), %eax  # stack load f6486
# end emit-variable-ref
# check the argument is a string
    movl %eax,%ebx
    and $7, %bl
    cmp $6, %bl
    je _L_39050
# invoke error handler eh_string
    .extern mrc_eh$ustring
    movl mrc_eh$ustring, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $160,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_39050:
    movl -6(%eax), %eax
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_39051"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $68,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_39051:
    movl %eax, -24(%esp)
# emit-expr f6487
# emit-variable-ref
# env=((f6487 . -20) (f6486 . -16) (f6487 . -12) (f6486 . -8) (f6483 . 4) (f6483 . 0))
# var=f6487
    movl -20(%esp), %eax  # stack load f6487
# end emit-variable-ref
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_39052"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $68,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_39052:
    cmp -24(%esp), %eax
    sete %al
    movzbl %al, %eax
    sal $6, %al
    or $47, %al
    cmp $47, %al
    je _L_39048
# emit-tail-expr
# si=-24
# env=((f6487 . -20) (f6486 . -16) (f6487 . -12) (f6486 . -8) (f6483 . 4) (f6483 . 0))
# expr=()
    movl $63, %eax     # immed ()
    ret                  # immediate tail return
    jmp _L_39049
_L_39048:
# emit-tail-expr
# si=-24
# env=((f6487 . -20) (f6486 . -16) (f6487 . -12) (f6486 . -8) (f6483 . 4) (f6483 . 0))
# expr=(cons (string-ref f6486 f6487) ((vector-ref f6483 0) f6486 (fxadd1 f6487)))
# tail primcall
# cons arg1=(string-ref f6486 f6487) arg2=((vector-ref f6483 0) f6486 (fxadd1 f6487))
# emit-expr (string-ref f6486 f6487)
# emit-expr f6486
# emit-variable-ref
# env=((f6487 . -20) (f6486 . -16) (f6487 . -12) (f6486 . -8) (f6483 . 4) (f6483 . 0))
# var=f6486
    movl -16(%esp), %eax  # stack load f6486
# end emit-variable-ref
# check the argument is a string
    movl %eax,%ebx
    and $7, %bl
    cmp $6, %bl
    je _L_39053
# invoke error handler eh_string
    .extern mrc_eh$ustring
    movl mrc_eh$ustring, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $164,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_39053:
    movl %eax, -24(%esp)
# emit-expr f6487
# emit-variable-ref
# env=((f6487 . -20) (f6486 . -16) (f6487 . -12) (f6486 . -8) (f6483 . 4) (f6483 . 0))
# var=f6487
    movl -20(%esp), %eax  # stack load f6487
# end emit-variable-ref
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_39054"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $164,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_39054:
# check bounds on string index
    movl -24(%esp), %ebx
    cmp  %eax,-6(%ebx) 
    jle _L_39056
    cmp  $0,%eax
    jge _L_39055
_L_39056:
# invoke error handler eh_string_index
    .extern mrc_eh$ustring$uindex
    movl mrc_eh$ustring$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $164,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_39055:
    sar $2, %eax
    movl -24(%esp), %esi
    movl -2(%eax,%esi), %eax
    sal $8, %eax
    or  $15, %eax
    movl %eax, -24(%esp)
# emit-expr ((vector-ref f6483 0) f6486 (fxadd1 f6487))
# funcall
#    si   =-28
#    env  = ((f6487 . -20) (f6486 . -16) (f6487 . -12) (f6486 . -8) (f6483 . 4) (f6483 . 0))
#    expr = (funcall (vector-ref f6483 0) f6486 (fxadd1 f6487))
# emit-expr (vector-ref f6483 0)
# emit-expr f6483
# emit-variable-ref
# env=((f6487 . -20) (f6486 . -16) (f6487 . -12) (f6486 . -8) (f6483 . 4) (f6483 . 0))
# var=f6483
    movl 2(%edi), %eax  # frame load f6483
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_39057
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_39057:
    movl %eax, -36(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_39058"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_39058:
# check bounds on vector index
    movl -36(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_39060
    cmp  $0,%eax
    jge _L_39059
_L_39060:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_39059:
    movl -36(%esp), %esi
    movl -1(%eax,%esi), %eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_39061"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_39061":
   movl %eax,  -36(%esp)  # stash funcall-oper in closure slot
# emit-expr f6486
# emit-variable-ref
# env=((f6487 . -20) (f6486 . -16) (f6487 . -12) (f6486 . -8) (f6483 . 4) (f6483 . 0))
# var=f6486
    movl -16(%esp), %eax  # stack load f6486
# end emit-variable-ref
    mov %eax, -40(%esp)  # arg f6486
# emit-expr (fxadd1 f6487)
# emit-expr f6487
# emit-variable-ref
# env=((f6487 . -20) (f6486 . -16) (f6487 . -12) (f6486 . -8) (f6483 . 4) (f6483 . 0))
# var=f6487
    movl -20(%esp), %eax  # stack load f6487
# end emit-variable-ref
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_39062"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $56,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_39062:
     addl $4, %eax
    mov %eax, -44(%esp)  # arg (fxadd1 f6487)
    movl -36(%esp), %edi   # load new closure to %edi
    add $-28, %esp   # adjust base
    movl $8,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $28, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    movl %eax, 4(%ebp)
    movl -24(%esp), %eax
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    or   $1, %al
    add  $8, %ebp
# cons end
#return from tail (cons (string-ref f6486 f6487) ((vector-ref f6483 0) f6486 (fxadd1 f6487)))
    ret
_L_39049:
    .align 4,0x90
_L_39046:
    movl -4(%esp), %ebx
    movl -8(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin)
# emit-begin
#   expr=(begin)
#   env=((f6483 . 0))
# emit-expr (begin (closure (f6489) (f6483) (let ((f6489 f6489)) ((vector-ref f6483 0) f6489 0))))
# emit-begin
#   expr=(begin (closure (f6489) (f6483) (let ((f6489 f6489)) ((vector-ref f6483 0) f6489 0))))
#   env=((f6483 . 0))
# emit-expr (closure (f6489) (f6483) (let ((f6489 f6489)) ((vector-ref f6483 0) f6489 0)))
# emit-closure
# si = -4
# env = ((f6483 . 0))
# expr = (closure (f6489) (f6483) (let ((f6489 f6489)) ((vector-ref f6483 0) f6489 0)))
    movl $_L_39063, 0(%ebp)  # closure label
# emit-variable-ref
# env=((f6483 . 0))
# var=f6483
    movl 0(%esp), %eax  # stack load f6483
# end emit-variable-ref
   movl  %eax, 4(%ebp)  # f6483
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $8, %ebp     # bump ebp
    jmp _L_39064            # jump around closure body
_L_39063:
# check argument count
    cmp $4,%eax
    je _L_39065
# invoke error handler eh_argcount
    .extern mrc_eh$uargcount
    movl mrc_eh$uargcount, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_39065:
# emit-tail-expr
# si=-12
# env=((f6489 . -8) (f6483 . 4) (f6483 . 0))
# expr=(let ((f6489 f6489)) ((vector-ref f6483 0) f6489 0))
# emit-tail-let
#  si   = -12
#  env  = ((f6489 . -8) (f6483 . 4) (f6483 . 0))
#  bindings = ((f6489 f6489))
#  body = ((vector-ref f6483 0) f6489 0)
# emit-expr f6489
# emit-variable-ref
# env=((f6489 . -8) (f6483 . 4) (f6483 . 0))
# var=f6489
    movl -8(%esp), %eax  # stack load f6489
# end emit-variable-ref
    movl %eax, -12(%esp)  # stack save
# emit-tail-expr
# si=-16
# env=((f6489 . -12) (f6489 . -8) (f6483 . 4) (f6483 . 0))
# expr=((vector-ref f6483 0) f6489 0)
# emit-tail-funcall
#    si   =-16
#    env  = ((f6489 . -12) (f6489 . -8) (f6483 . 4) (f6483 . 0))
#    expr = (funcall (vector-ref f6483 0) f6489 0)
# emit-expr (vector-ref f6483 0)
# emit-expr f6483
# emit-variable-ref
# env=((f6489 . -12) (f6489 . -8) (f6483 . 4) (f6483 . 0))
# var=f6483
    movl 2(%edi), %eax  # frame load f6483
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_39066
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_39066:
    movl %eax, -16(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_39067"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_39067:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_39069
    cmp  $0,%eax
    jge _L_39068
_L_39069:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_39068:
    movl -16(%esp), %esi
    movl -1(%eax,%esi), %eax
   movl %eax,  -16(%esp)  # stash funcall-oper in next closure slot
# emit-expr f6489
# emit-variable-ref
# env=((f6489 . -12) (f6489 . -8) (f6483 . 4) (f6483 . 0))
# var=f6489
    movl -12(%esp), %eax  # stack load f6489
# end emit-variable-ref
    mov %eax, -20(%esp)    # arg f6489
# emit-expr 0
    movl $0, %eax     # immed 0
    mov %eax, -24(%esp)    # arg 0
    movl -16(%esp), %edi   # load new closure to %edi
# emit-shift-args:  size=3   si=-16  delta=12
    mov -16(%esp), %ebx  # shift frame cell
    mov %ebx, -4(%esp)  # down to base
# emit-shift-args:  size=2   si=-20  delta=12
    mov -20(%esp), %ebx  # shift frame cell
    mov %ebx, -8(%esp)  # down to base
# emit-shift-args:  size=1   si=-24  delta=12
    mov -24(%esp), %ebx  # shift frame cell
    mov %ebx, -12(%esp)  # down to base
# emit-shift-args:  size=0   si=-28  delta=12
    movl $8,%eax   # save arg count
    jmp *-2(%edi)  # tail-funcall
    .align 4,0x90
_L_39064:
# emit-expr (begin)
# emit-begin
#   expr=(begin)
#   env=((f6483 . 0))
     movl %eax, mrc_string$m$glist
# == explicit-begins  ==>
# (letrec ((f (lambda (i l) (cond ((fx< i 10) (cons i l)) (else (f (fxquotient i 10) (cons (fxremainder i 10) l))))))) (lambda (i) (f i (quote ()))))
# == eliminate-let*  ==>
# (letrec ((f (lambda (i l) (cond ((fx< i 10) (cons i l)) (else (f (fxquotient i 10) (cons (fxremainder i 10) l))))))) (lambda (i) (f i (quote ()))))
# == uniquify-variables  ==>
# (letrec ((f6490 (lambda (f6493 f6494) (cond ((fx< f6493 10) (cons f6493 f6494)) (else (f6490 (fxquotient f6493 10) (cons (fxremainder f6493 10) f6494))))))) (lambda (f6496) (f6490 f6496 (quote ()))))
# == vectorize-letrec  ==>
# (let ((f6490 (make-vector 1))) (begin (begin (vector-set! f6490 0 (lambda (f6493 f6494) (cond ((fx< f6493 10) (cons f6493 f6494)) (else ((vector-ref f6490 0) (fxquotient f6493 10) (cons (fxremainder f6493 10) f6494))))))) (lambda (f6496) ((vector-ref f6490 0) f6496 (quote ())))))
# == eliminate-set!  ==>
# (let ((f6490 (make-vector 1))) (begin (begin (vector-set! f6490 0 (lambda (f6493 f6494) (let ((f6493 f6493) (f6494 f6494)) (cond ((fx< f6493 10) (cons f6493 f6494)) (else ((vector-ref f6490 0) (fxquotient f6493 10) (cons (fxremainder f6493 10) f6494)))))))) (lambda (f6496) (let ((f6496 f6496)) ((vector-ref f6490 0) f6496 (quote ()))))))
# == close-free-variables  ==>
# (let ((f6490 (make-vector 1))) (begin (begin (vector-set! f6490 0 (closure (f6493 f6494) (else f6490) (let ((f6493 f6493) (f6494 f6494)) (cond ((fx< f6493 10) (cons f6493 f6494)) (else ((vector-ref f6490 0) (fxquotient f6493 10) (cons (fxremainder f6493 10) f6494)))))))) (closure (f6496) (f6490) (let ((f6496 f6496)) ((vector-ref f6490 0) f6496 (quote ()))))))
# == eliminate-quote  ==>
# (let ((f6490 (make-vector 1))) (begin (begin (vector-set! f6490 0 (closure (f6493 f6494) (else f6490) (let ((f6493 f6493) (f6494 f6494)) (cond ((fx< f6493 10) (cons f6493 f6494)) (else ((vector-ref f6490 0) (fxquotient f6493 10) (cons (fxremainder f6493 10) f6494)))))))) (closure (f6496) (f6490) (let ((f6496 f6496)) ((vector-ref f6490 0) f6496 ())))))
# == eliminate-when/unless  ==>
# (let ((f6490 (make-vector 1))) (begin (begin (vector-set! f6490 0 (closure (f6493 f6494) (else f6490) (let ((f6493 f6493) (f6494 f6494)) (cond ((fx< f6493 10) (cons f6493 f6494)) (else ((vector-ref f6490 0) (fxquotient f6493 10) (cons (fxremainder f6493 10) f6494)))))))) (closure (f6496) (f6490) (let ((f6496 f6496)) ((vector-ref f6490 0) f6496 ())))))
# == eliminate-cond  ==>
# (let ((f6490 (make-vector 1))) (begin (begin (vector-set! f6490 0 (closure (f6493 f6494) (else f6490) (let ((f6493 f6493) (f6494 f6494)) (if (fx< f6493 10) (cons f6493 f6494) ((vector-ref f6490 0) (fxquotient f6493 10) (cons (fxremainder f6493 10) f6494))))))) (closure (f6496) (f6490) (let ((f6496 f6496)) ((vector-ref f6490 0) f6496 ())))))
# == external-symbols  ==>
# (let ((f6490 (make-vector 1))) (begin (begin (vector-set! f6490 0 (closure (f6493 f6494) (else f6490) (let ((f6493 f6493) (f6494 f6494)) (if (fx< f6493 10) (cons f6493 f6494) ((vector-ref f6490 0) (fxquotient f6493 10) (cons (fxremainder f6493 10) f6494))))))) (closure (f6496) (f6490) (let ((f6496 f6496)) ((vector-ref f6490 0) f6496 ())))))
# emit-expr (let ((f6490 (make-vector 1))) (begin (begin (vector-set! f6490 0 (closure (f6493 f6494) (else f6490) (let ((f6493 f6493) (f6494 f6494)) (if (fx< f6493 10) (cons f6493 f6494) ((vector-ref f6490 0) (fxquotient f6493 10) (cons (fxremainder f6493 10) f6494))))))) (closure (f6496) (f6490) (let ((f6496 f6496)) ((vector-ref f6490 0) f6496 ())))))
# emit-let
#  si   = 0
#  env  = ()
#  bindings = ((f6490 (make-vector 1)))
#  body = (begin (begin (vector-set! f6490 0 (closure (f6493 f6494) (else f6490) (let ((f6493 f6493) (f6494 f6494)) (if (fx< f6493 10) (cons f6493 f6494) ((vector-ref f6490 0) (fxquotient f6493 10) (cons (fxremainder f6493 10) f6494))))))) (closure (f6496) (f6490) (let ((f6496 f6496)) ((vector-ref f6490 0) f6496 ()))))
# emit-expr (make-vector 1)
# make-vector 1
# emit-expr 1
    movl $4, %eax     # immed 1
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_39070"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_39070:
# check the argument is a fixnum >= 0
    cmp $0,%eax
    jge _L_39071
# invoke error handler eh_length
    .extern mrc_eh$ulength
    movl mrc_eh$ulength, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_39071:
    movl %eax, %esi
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    orl  $5, %eax
    addl $4, %esi
    addl $4, %esi
    andl $-8, %esi
    addl %esi, %ebp
    movl %eax, 0(%esp)  # stack save
# emit-expr (begin (begin (vector-set! f6490 0 (closure (f6493 f6494) (else f6490) (let ((f6493 f6493) (f6494 f6494)) (if (fx< f6493 10) (cons f6493 f6494) ((vector-ref f6490 0) (fxquotient f6493 10) (cons (fxremainder f6493 10) f6494))))))) (closure (f6496) (f6490) (let ((f6496 f6496)) ((vector-ref f6490 0) f6496 ()))))
# emit-begin
#   expr=(begin (begin (vector-set! f6490 0 (closure (f6493 f6494) (else f6490) (let ((f6493 f6493) (f6494 f6494)) (if (fx< f6493 10) (cons f6493 f6494) ((vector-ref f6490 0) (fxquotient f6493 10) (cons (fxremainder f6493 10) f6494))))))) (closure (f6496) (f6490) (let ((f6496 f6496)) ((vector-ref f6490 0) f6496 ()))))
#   env=((f6490 . 0))
# emit-expr (begin (vector-set! f6490 0 (closure (f6493 f6494) (else f6490) (let ((f6493 f6493) (f6494 f6494)) (if (fx< f6493 10) (cons f6493 f6494) ((vector-ref f6490 0) (fxquotient f6493 10) (cons (fxremainder f6493 10) f6494)))))))
# emit-begin
#   expr=(begin (vector-set! f6490 0 (closure (f6493 f6494) (else f6490) (let ((f6493 f6493) (f6494 f6494)) (if (fx< f6493 10) (cons f6493 f6494) ((vector-ref f6490 0) (fxquotient f6493 10) (cons (fxremainder f6493 10) f6494)))))))
#   env=((f6490 . 0))
# emit-expr (vector-set! f6490 0 (closure (f6493 f6494) (else f6490) (let ((f6493 f6493) (f6494 f6494)) (if (fx< f6493 10) (cons f6493 f6494) ((vector-ref f6490 0) (fxquotient f6493 10) (cons (fxremainder f6493 10) f6494))))))
# emit-expr f6490
# emit-variable-ref
# env=((f6490 . 0))
# var=f6490
    movl 0(%esp), %eax  # stack load f6490
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_39072
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_39072:
    movl %eax, -4(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_39073"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_39073:
# check bounds on vector index
    movl -4(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_39075
    cmp  $0,%eax
    jge _L_39074
_L_39075:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_39074:
    movl %eax, -8(%esp)
# emit-expr (closure (f6493 f6494) (else f6490) (let ((f6493 f6493) (f6494 f6494)) (if (fx< f6493 10) (cons f6493 f6494) ((vector-ref f6490 0) (fxquotient f6493 10) (cons (fxremainder f6493 10) f6494)))))
# emit-closure
# si = -12
# env = ((f6490 . 0))
# expr = (closure (f6493 f6494) (else f6490) (let ((f6493 f6493) (f6494 f6494)) (if (fx< f6493 10) (cons f6493 f6494) ((vector-ref f6490 0) (fxquotient f6493 10) (cons (fxremainder f6493 10) f6494)))))
    movl $_L_39076, 0(%ebp)  # closure label
# WARNING: free var else not defined in the environmnet
# emit-variable-ref
# env=((f6490 . 0))
# var=f6490
    movl 0(%esp), %eax  # stack load f6490
# end emit-variable-ref
   movl  %eax, 8(%ebp)  # f6490
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $16, %ebp     # bump ebp
    jmp _L_39077            # jump around closure body
_L_39076:
# check argument count
    cmp $8,%eax
    je _L_39078
# invoke error handler eh_argcount
    .extern mrc_eh$uargcount
    movl mrc_eh$uargcount, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_39078:
# emit-tail-expr
# si=-16
# env=((f6494 . -12) (f6493 . -8) (f6490 . 8) (else . 4) (f6490 . 0))
# expr=(let ((f6493 f6493) (f6494 f6494)) (if (fx< f6493 10) (cons f6493 f6494) ((vector-ref f6490 0) (fxquotient f6493 10) (cons (fxremainder f6493 10) f6494))))
# emit-tail-let
#  si   = -16
#  env  = ((f6494 . -12) (f6493 . -8) (f6490 . 8) (else . 4) (f6490 . 0))
#  bindings = ((f6493 f6493) (f6494 f6494))
#  body = (if (fx< f6493 10) (cons f6493 f6494) ((vector-ref f6490 0) (fxquotient f6493 10) (cons (fxremainder f6493 10) f6494)))
# emit-expr f6493
# emit-variable-ref
# env=((f6494 . -12) (f6493 . -8) (f6490 . 8) (else . 4) (f6490 . 0))
# var=f6493
    movl -8(%esp), %eax  # stack load f6493
# end emit-variable-ref
    movl %eax, -16(%esp)  # stack save
# emit-expr f6494
# emit-variable-ref
# env=((f6494 . -12) (f6493 . -8) (f6490 . 8) (else . 4) (f6490 . 0))
# var=f6494
    movl -12(%esp), %eax  # stack load f6494
# end emit-variable-ref
    movl %eax, -20(%esp)  # stack save
# emit-tail-expr
# si=-24
# env=((f6494 . -20) (f6493 . -16) (f6494 . -12) (f6493 . -8) (f6490 . 8) (else . 4) (f6490 . 0))
# expr=(if (fx< f6493 10) (cons f6493 f6494) ((vector-ref f6490 0) (fxquotient f6493 10) (cons (fxremainder f6493 10) f6494)))
# emit-expr (fx< f6493 10)
# emit-expr 10
    movl $40, %eax     # immed 10
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_39081"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $72,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_39081:
    movl %eax, -24(%esp)
# emit-expr f6493
# emit-variable-ref
# env=((f6494 . -20) (f6493 . -16) (f6494 . -12) (f6493 . -8) (f6490 . 8) (else . 4) (f6490 . 0))
# var=f6493
    movl -16(%esp), %eax  # stack load f6493
# end emit-variable-ref
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_39082"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $72,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_39082:
    cmp -24(%esp), %eax
    setl %al
    movzbl %al, %eax
    sal $6, %al
    or $47, %al
    cmp $47, %al
    je _L_39079
# emit-tail-expr
# si=-24
# env=((f6494 . -20) (f6493 . -16) (f6494 . -12) (f6493 . -8) (f6490 . 8) (else . 4) (f6490 . 0))
# expr=(cons f6493 f6494)
# tail primcall
# cons arg1=f6493 arg2=f6494
# emit-expr f6493
# emit-variable-ref
# env=((f6494 . -20) (f6493 . -16) (f6494 . -12) (f6493 . -8) (f6490 . 8) (else . 4) (f6490 . 0))
# var=f6493
    movl -16(%esp), %eax  # stack load f6493
# end emit-variable-ref
    movl %eax, -24(%esp)
# emit-expr f6494
# emit-variable-ref
# env=((f6494 . -20) (f6493 . -16) (f6494 . -12) (f6493 . -8) (f6490 . 8) (else . 4) (f6490 . 0))
# var=f6494
    movl -20(%esp), %eax  # stack load f6494
# end emit-variable-ref
    movl %eax, 4(%ebp)
    movl -24(%esp), %eax
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    or   $1, %al
    add  $8, %ebp
# cons end
#return from tail (cons f6493 f6494)
    ret
    jmp _L_39080
_L_39079:
# emit-tail-expr
# si=-24
# env=((f6494 . -20) (f6493 . -16) (f6494 . -12) (f6493 . -8) (f6490 . 8) (else . 4) (f6490 . 0))
# expr=((vector-ref f6490 0) (fxquotient f6493 10) (cons (fxremainder f6493 10) f6494))
# emit-tail-funcall
#    si   =-24
#    env  = ((f6494 . -20) (f6493 . -16) (f6494 . -12) (f6493 . -8) (f6490 . 8) (else . 4) (f6490 . 0))
#    expr = (funcall (vector-ref f6490 0) (fxquotient f6493 10) (cons (fxremainder f6493 10) f6494))
# emit-expr (vector-ref f6490 0)
# emit-expr f6490
# emit-variable-ref
# env=((f6494 . -20) (f6493 . -16) (f6494 . -12) (f6493 . -8) (f6490 . 8) (else . 4) (f6490 . 0))
# var=f6490
    movl 6(%edi), %eax  # frame load f6490
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_39083
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_39083:
    movl %eax, -24(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_39084"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_39084:
# check bounds on vector index
    movl -24(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_39086
    cmp  $0,%eax
    jge _L_39085
_L_39086:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_39085:
    movl -24(%esp), %esi
    movl -1(%eax,%esi), %eax
   movl %eax,  -24(%esp)  # stash funcall-oper in next closure slot
# emit-expr (fxquotient f6493 10)
# emit-expr 10
    movl $40, %eax     # immed 10
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_39088"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $100,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_39088:
    movl %eax, -28(%esp)  # denominator
# emit-expr f6493
# emit-variable-ref
# env=((f6494 . -20) (f6493 . -16) (f6494 . -12) (f6493 . -8) (f6490 . 8) (else . 4) (f6490 . 0))
# var=f6493
    movl -16(%esp), %eax  # stack load f6493
# end emit-variable-ref
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_39089"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $100,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_39089:
    movl -28(%esp),%ebx   # ebx <- denominator
    xor %edx,%edx        # edx <- 0
    cmp $0,%eax
    jge _L_39087
    not %edx
_L_39087:
    idiv %ebx            # eax <- edx:eax/ebx
    sal $2,%eax          # eax <- eax*4 (since it was divided away)
    mov %eax, -28(%esp)    # arg (fxquotient f6493 10)
# emit-expr (cons (fxremainder f6493 10) f6494)
# cons arg1=(fxremainder f6493 10) arg2=f6494
# emit-expr (fxremainder f6493 10)
# emit-expr 10
    movl $40, %eax     # immed 10
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_39091"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $100,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_39091:
    movl %eax, -32(%esp)  # denominator
# emit-expr f6493
# emit-variable-ref
# env=((f6494 . -20) (f6493 . -16) (f6494 . -12) (f6493 . -8) (f6490 . 8) (else . 4) (f6490 . 0))
# var=f6493
    movl -16(%esp), %eax  # stack load f6493
# end emit-variable-ref
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_39092"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $100,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_39092:
    movl -32(%esp),%ebx   # ebx <- denominator
    xor %edx,%edx        # edx <- 0
    cmp $0,%eax
    jge _L_39090
    not %edx
_L_39090:
    idiv %ebx            # edx <- edx:eax/ebx  remainder
    movl %edx,%eax
    movl %eax, -32(%esp)
# emit-expr f6494
# emit-variable-ref
# env=((f6494 . -20) (f6493 . -16) (f6494 . -12) (f6493 . -8) (f6490 . 8) (else . 4) (f6490 . 0))
# var=f6494
    movl -20(%esp), %eax  # stack load f6494
# end emit-variable-ref
    movl %eax, 4(%ebp)
    movl -32(%esp), %eax
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    or   $1, %al
    add  $8, %ebp
# cons end
    mov %eax, -32(%esp)    # arg (cons (fxremainder f6493 10) f6494)
    movl -24(%esp), %edi   # load new closure to %edi
# emit-shift-args:  size=3   si=-24  delta=20
    mov -24(%esp), %ebx  # shift frame cell
    mov %ebx, -4(%esp)  # down to base
# emit-shift-args:  size=2   si=-28  delta=20
    mov -28(%esp), %ebx  # shift frame cell
    mov %ebx, -8(%esp)  # down to base
# emit-shift-args:  size=1   si=-32  delta=20
    mov -32(%esp), %ebx  # shift frame cell
    mov %ebx, -12(%esp)  # down to base
# emit-shift-args:  size=0   si=-36  delta=20
    movl $8,%eax   # save arg count
    jmp *-2(%edi)  # tail-funcall
_L_39080:
    .align 4,0x90
_L_39077:
    movl -4(%esp), %ebx
    movl -8(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin)
# emit-begin
#   expr=(begin)
#   env=((f6490 . 0))
# emit-expr (begin (closure (f6496) (f6490) (let ((f6496 f6496)) ((vector-ref f6490 0) f6496 ()))))
# emit-begin
#   expr=(begin (closure (f6496) (f6490) (let ((f6496 f6496)) ((vector-ref f6490 0) f6496 ()))))
#   env=((f6490 . 0))
# emit-expr (closure (f6496) (f6490) (let ((f6496 f6496)) ((vector-ref f6490 0) f6496 ())))
# emit-closure
# si = -4
# env = ((f6490 . 0))
# expr = (closure (f6496) (f6490) (let ((f6496 f6496)) ((vector-ref f6490 0) f6496 ())))
    movl $_L_39093, 0(%ebp)  # closure label
# emit-variable-ref
# env=((f6490 . 0))
# var=f6490
    movl 0(%esp), %eax  # stack load f6490
# end emit-variable-ref
   movl  %eax, 4(%ebp)  # f6490
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $8, %ebp     # bump ebp
    jmp _L_39094            # jump around closure body
_L_39093:
# check argument count
    cmp $4,%eax
    je _L_39095
# invoke error handler eh_argcount
    .extern mrc_eh$uargcount
    movl mrc_eh$uargcount, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_39095:
# emit-tail-expr
# si=-12
# env=((f6496 . -8) (f6490 . 4) (f6490 . 0))
# expr=(let ((f6496 f6496)) ((vector-ref f6490 0) f6496 ()))
# emit-tail-let
#  si   = -12
#  env  = ((f6496 . -8) (f6490 . 4) (f6490 . 0))
#  bindings = ((f6496 f6496))
#  body = ((vector-ref f6490 0) f6496 ())
# emit-expr f6496
# emit-variable-ref
# env=((f6496 . -8) (f6490 . 4) (f6490 . 0))
# var=f6496
    movl -8(%esp), %eax  # stack load f6496
# end emit-variable-ref
    movl %eax, -12(%esp)  # stack save
# emit-tail-expr
# si=-16
# env=((f6496 . -12) (f6496 . -8) (f6490 . 4) (f6490 . 0))
# expr=((vector-ref f6490 0) f6496 ())
# emit-tail-funcall
#    si   =-16
#    env  = ((f6496 . -12) (f6496 . -8) (f6490 . 4) (f6490 . 0))
#    expr = (funcall (vector-ref f6490 0) f6496 ())
# emit-expr (vector-ref f6490 0)
# emit-expr f6490
# emit-variable-ref
# env=((f6496 . -12) (f6496 . -8) (f6490 . 4) (f6490 . 0))
# var=f6490
    movl 2(%edi), %eax  # frame load f6490
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_39096
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_39096:
    movl %eax, -16(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_39097"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_39097:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_39099
    cmp  $0,%eax
    jge _L_39098
_L_39099:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_39098:
    movl -16(%esp), %esi
    movl -1(%eax,%esi), %eax
   movl %eax,  -16(%esp)  # stash funcall-oper in next closure slot
# emit-expr f6496
# emit-variable-ref
# env=((f6496 . -12) (f6496 . -8) (f6490 . 4) (f6490 . 0))
# var=f6496
    movl -12(%esp), %eax  # stack load f6496
# end emit-variable-ref
    mov %eax, -20(%esp)    # arg f6496
# emit-expr ()
    movl $63, %eax     # immed ()
    mov %eax, -24(%esp)    # arg ()
    movl -16(%esp), %edi   # load new closure to %edi
# emit-shift-args:  size=3   si=-16  delta=12
    mov -16(%esp), %ebx  # shift frame cell
    mov %ebx, -4(%esp)  # down to base
# emit-shift-args:  size=2   si=-20  delta=12
    mov -20(%esp), %ebx  # shift frame cell
    mov %ebx, -8(%esp)  # down to base
# emit-shift-args:  size=1   si=-24  delta=12
    mov -24(%esp), %ebx  # shift frame cell
    mov %ebx, -12(%esp)  # down to base
# emit-shift-args:  size=0   si=-28  delta=12
    movl $8,%eax   # save arg count
    jmp *-2(%edi)  # tail-funcall
    .align 4,0x90
_L_39094:
# emit-expr (begin)
# emit-begin
#   expr=(begin)
#   env=((f6490 . 0))
     movl %eax, mrc_integer$m$glist
# == explicit-begins  ==>
# (let* ((write-stderr (lambda (s) (foreign-call "s_write" 2 s (string-length s)))) (write-errmsg (lambda (sym emsg) (begin (write-stderr "error:") (write-stderr (symbol->string sym)) (write-stderr ": ") (write-stderr emsg) (write-stderr "\n"))))) (lambda (sym emsg) (begin (write-errmsg sym emsg) (foreign-call "s_exit" 1))))
# == eliminate-let*  ==>
# (let ((write-stderr (lambda (s) (foreign-call "s_write" 2 s (string-length s))))) (let ((write-errmsg (lambda (sym emsg) (begin (write-stderr "error:") (write-stderr (symbol->string sym)) (write-stderr ": ") (write-stderr emsg) (write-stderr "\n"))))) (lambda (sym emsg) (begin (write-errmsg sym emsg) (foreign-call "s_exit" 1)))))
# == uniquify-variables  ==>
# (let ((f6497 (lambda (f6498) (foreign-call "s_write" 2 f6498 (string-length f6498))))) (let ((f6506 (lambda (f6507 f6508) (begin (f6497 "error:") (f6497 (symbol->string f6507)) (f6497 ": ") (f6497 f6508) (f6497 "\n"))))) (lambda (f6511 f6512) (begin (f6506 f6511 f6512) (foreign-call "s_exit" 1)))))
# == vectorize-letrec  ==>
# (let ((f6497 (lambda (f6498) (foreign-call "s_write" 2 f6498 (string-length f6498))))) (let ((f6506 (lambda (f6507 f6508) (begin (f6497 "error:") (f6497 (symbol->string f6507)) (f6497 ": ") (f6497 f6508) (f6497 "\n"))))) (lambda (f6511 f6512) (begin (f6506 f6511 f6512) (foreign-call "s_exit" 1)))))
# == eliminate-set!  ==>
# (let ((f6497 (lambda (f6498) (let ((f6498 f6498)) (foreign-call "s_write" 2 f6498 (string-length f6498)))))) (let ((f6506 (lambda (f6507 f6508) (let ((f6507 f6507) (f6508 f6508)) (begin (f6497 "error:") (f6497 (symbol->string f6507)) (f6497 ": ") (f6497 f6508) (f6497 "\n")))))) (lambda (f6511 f6512) (let ((f6511 f6511) (f6512 f6512)) (begin (f6506 f6511 f6512) (foreign-call "s_exit" 1))))))
# == close-free-variables  ==>
# (let ((f6497 (closure (f6498) () (let ((f6498 f6498)) (foreign-call "s_write" 2 f6498 (string-length f6498)))))) (let ((f6506 (closure (f6507 f6508) (f6497 f6497 f6497 f6497 f6497) (let ((f6507 f6507) (f6508 f6508)) (begin (f6497 "error:") (f6497 (symbol->string f6507)) (f6497 ": ") (f6497 f6508) (f6497 "\n")))))) (closure (f6511 f6512) (f6506) (let ((f6511 f6511) (f6512 f6512)) (begin (f6506 f6511 f6512) (foreign-call "s_exit" 1))))))
# == eliminate-quote  ==>
# (let ((f6497 (closure (f6498) () (let ((f6498 f6498)) (foreign-call "s_write" 2 f6498 (string-length f6498)))))) (let ((f6506 (closure (f6507 f6508) (f6497 f6497 f6497 f6497 f6497) (let ((f6507 f6507) (f6508 f6508)) (begin (f6497 "error:") (f6497 (symbol->string f6507)) (f6497 ": ") (f6497 f6508) (f6497 "\n")))))) (closure (f6511 f6512) (f6506) (let ((f6511 f6511) (f6512 f6512)) (begin (f6506 f6511 f6512) (foreign-call "s_exit" 1))))))
# == eliminate-when/unless  ==>
# (let ((f6497 (closure (f6498) () (let ((f6498 f6498)) (foreign-call "s_write" 2 f6498 (string-length f6498)))))) (let ((f6506 (closure (f6507 f6508) (f6497 f6497 f6497 f6497 f6497) (let ((f6507 f6507) (f6508 f6508)) (begin (f6497 "error:") (f6497 (symbol->string f6507)) (f6497 ": ") (f6497 f6508) (f6497 "\n")))))) (closure (f6511 f6512) (f6506) (let ((f6511 f6511) (f6512 f6512)) (begin (f6506 f6511 f6512) (foreign-call "s_exit" 1))))))
# == eliminate-cond  ==>
# (let ((f6497 (closure (f6498) () (let ((f6498 f6498)) (foreign-call "s_write" 2 f6498 (string-length f6498)))))) (let ((f6506 (closure (f6507 f6508) (f6497 f6497 f6497 f6497 f6497) (let ((f6507 f6507) (f6508 f6508)) (begin (f6497 "error:") (f6497 (symbol->string f6507)) (f6497 ": ") (f6497 f6508) (f6497 "\n")))))) (closure (f6511 f6512) (f6506) (let ((f6511 f6511) (f6512 f6512)) (begin (f6506 f6511 f6512) (foreign-call "s_exit" 1))))))
# == external-symbols  ==>
# (let ((f6497 (closure (f6498) () (let ((f6498 f6498)) (foreign-call "s_write" 2 f6498 (string-length f6498)))))) (let ((f6506 (closure (f6507 f6508) (f6497 f6497 f6497 f6497 f6497) (let ((f6507 f6507) (f6508 f6508)) (begin (f6497 "error:") (f6497 (symbol->string f6507)) (f6497 ": ") (f6497 f6508) (f6497 "\n")))))) (closure (f6511 f6512) (f6506) (let ((f6511 f6511) (f6512 f6512)) (begin (f6506 f6511 f6512) (foreign-call "s_exit" 1))))))
# emit-expr (let ((f6497 (closure (f6498) () (let ((f6498 f6498)) (foreign-call "s_write" 2 f6498 (string-length f6498)))))) (let ((f6506 (closure (f6507 f6508) (f6497 f6497 f6497 f6497 f6497) (let ((f6507 f6507) (f6508 f6508)) (begin (f6497 "error:") (f6497 (symbol->string f6507)) (f6497 ": ") (f6497 f6508) (f6497 "\n")))))) (closure (f6511 f6512) (f6506) (let ((f6511 f6511) (f6512 f6512)) (begin (f6506 f6511 f6512) (foreign-call "s_exit" 1))))))
# emit-let
#  si   = 0
#  env  = ()
#  bindings = ((f6497 (closure (f6498) () (let ((f6498 f6498)) (foreign-call "s_write" 2 f6498 (string-length f6498))))))
#  body = (let ((f6506 (closure (f6507 f6508) (f6497 f6497 f6497 f6497 f6497) (let ((f6507 f6507) (f6508 f6508)) (begin (f6497 "error:") (f6497 (symbol->string f6507)) (f6497 ": ") (f6497 f6508) (f6497 "\n")))))) (closure (f6511 f6512) (f6506) (let ((f6511 f6511) (f6512 f6512)) (begin (f6506 f6511 f6512) (foreign-call "s_exit" 1)))))
# emit-expr (closure (f6498) () (let ((f6498 f6498)) (foreign-call "s_write" 2 f6498 (string-length f6498))))
# emit-closure
# si = 0
# env = ()
# expr = (closure (f6498) () (let ((f6498 f6498)) (foreign-call "s_write" 2 f6498 (string-length f6498))))
    movl $_L_39100, 0(%ebp)  # closure label
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $8, %ebp     # bump ebp
    jmp _L_39101            # jump around closure body
_L_39100:
# check argument count
    cmp $4,%eax
    je _L_39102
# invoke error handler eh_argcount
    .extern mrc_eh$uargcount
    movl mrc_eh$uargcount, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_39102:
# emit-tail-expr
# si=-12
# env=((f6498 . -8))
# expr=(let ((f6498 f6498)) (foreign-call "s_write" 2 f6498 (string-length f6498)))
# emit-tail-let
#  si   = -12
#  env  = ((f6498 . -8))
#  bindings = ((f6498 f6498))
#  body = (foreign-call "s_write" 2 f6498 (string-length f6498))
# emit-expr f6498
# emit-variable-ref
# env=((f6498 . -8))
# var=f6498
    movl -8(%esp), %eax  # stack load f6498
# end emit-variable-ref
    movl %eax, -12(%esp)  # stack save
# emit-tail-expr
# si=-16
# env=((f6498 . -12) (f6498 . -8))
# expr=(foreign-call "s_write" 2 f6498 (string-length f6498))
    movl %ecx,-16(%esp)
    movl %esp,-20(%esp)
# emit-expr (string-length f6498)
# emit-expr f6498
# emit-variable-ref
# env=((f6498 . -12) (f6498 . -8))
# var=f6498
    movl -12(%esp), %eax  # stack load f6498
# end emit-variable-ref
# check the argument is a string
    movl %eax,%ebx
    and $7, %bl
    cmp $6, %bl
    je _L_39103
# invoke error handler eh_string
    .extern mrc_eh$ustring
    movl mrc_eh$ustring, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $160,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_39103:
    movl -6(%eax), %eax
    movl %eax, -24(%esp)
# emit-expr f6498
# emit-variable-ref
# env=((f6498 . -12) (f6498 . -8))
# var=f6498
    movl -12(%esp), %eax  # stack load f6498
# end emit-variable-ref
    movl %eax, -28(%esp)
# emit-expr 2
    movl $8, %eax     # immed 2
    movl %eax, -32(%esp)
    leal -32(%esp),%edi
    movl %edi,%esi
    andl $-16,%esi
    movl 0(%edi),%eax
    movl %eax,0(%esi)
    movl 4(%edi),%eax
    movl %eax,4(%esi)
    movl 8(%edi),%eax
    movl %eax,8(%esi)
    movl 12(%edi),%eax
    movl %eax,12(%esi)
    movl %esi,%esp
    .extern _s_write
    call _s_write
    movl 12(%esi),%esp
    movl -16(%esp),%ecx
     ret
    .align 4,0x90
_L_39101:
    movl %eax, 0(%esp)  # stack save
# emit-expr (let ((f6506 (closure (f6507 f6508) (f6497 f6497 f6497 f6497 f6497) (let ((f6507 f6507) (f6508 f6508)) (begin (f6497 "error:") (f6497 (symbol->string f6507)) (f6497 ": ") (f6497 f6508) (f6497 "\n")))))) (closure (f6511 f6512) (f6506) (let ((f6511 f6511) (f6512 f6512)) (begin (f6506 f6511 f6512) (foreign-call "s_exit" 1)))))
# emit-let
#  si   = -4
#  env  = ((f6497 . 0))
#  bindings = ((f6506 (closure (f6507 f6508) (f6497 f6497 f6497 f6497 f6497) (let ((f6507 f6507) (f6508 f6508)) (begin (f6497 "error:") (f6497 (symbol->string f6507)) (f6497 ": ") (f6497 f6508) (f6497 "\n"))))))
#  body = (closure (f6511 f6512) (f6506) (let ((f6511 f6511) (f6512 f6512)) (begin (f6506 f6511 f6512) (foreign-call "s_exit" 1))))
# emit-expr (closure (f6507 f6508) (f6497 f6497 f6497 f6497 f6497) (let ((f6507 f6507) (f6508 f6508)) (begin (f6497 "error:") (f6497 (symbol->string f6507)) (f6497 ": ") (f6497 f6508) (f6497 "\n"))))
# emit-closure
# si = -4
# env = ((f6497 . 0))
# expr = (closure (f6507 f6508) (f6497 f6497 f6497 f6497 f6497) (let ((f6507 f6507) (f6508 f6508)) (begin (f6497 "error:") (f6497 (symbol->string f6507)) (f6497 ": ") (f6497 f6508) (f6497 "\n"))))
    movl $_L_39104, 0(%ebp)  # closure label
# emit-variable-ref
# env=((f6497 . 0))
# var=f6497
    movl 0(%esp), %eax  # stack load f6497
# end emit-variable-ref
   movl  %eax, 4(%ebp)  # f6497
# emit-variable-ref
# env=((f6497 . 0))
# var=f6497
    movl 0(%esp), %eax  # stack load f6497
# end emit-variable-ref
   movl  %eax, 8(%ebp)  # f6497
# emit-variable-ref
# env=((f6497 . 0))
# var=f6497
    movl 0(%esp), %eax  # stack load f6497
# end emit-variable-ref
   movl  %eax, 12(%ebp)  # f6497
# emit-variable-ref
# env=((f6497 . 0))
# var=f6497
    movl 0(%esp), %eax  # stack load f6497
# end emit-variable-ref
   movl  %eax, 16(%ebp)  # f6497
# emit-variable-ref
# env=((f6497 . 0))
# var=f6497
    movl 0(%esp), %eax  # stack load f6497
# end emit-variable-ref
   movl  %eax, 20(%ebp)  # f6497
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $24, %ebp     # bump ebp
    jmp _L_39105            # jump around closure body
_L_39104:
# check argument count
    cmp $8,%eax
    je _L_39106
# invoke error handler eh_argcount
    .extern mrc_eh$uargcount
    movl mrc_eh$uargcount, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_39106:
# emit-tail-expr
# si=-16
# env=((f6508 . -12) (f6507 . -8) (f6497 . 20) (f6497 . 16) (f6497 . 12) (f6497 . 8) (f6497 . 4) (f6497 . 0))
# expr=(let ((f6507 f6507) (f6508 f6508)) (begin (f6497 "error:") (f6497 (symbol->string f6507)) (f6497 ": ") (f6497 f6508) (f6497 "\n")))
# emit-tail-let
#  si   = -16
#  env  = ((f6508 . -12) (f6507 . -8) (f6497 . 20) (f6497 . 16) (f6497 . 12) (f6497 . 8) (f6497 . 4) (f6497 . 0))
#  bindings = ((f6507 f6507) (f6508 f6508))
#  body = (begin (f6497 "error:") (f6497 (symbol->string f6507)) (f6497 ": ") (f6497 f6508) (f6497 "\n"))
# emit-expr f6507
# emit-variable-ref
# env=((f6508 . -12) (f6507 . -8) (f6497 . 20) (f6497 . 16) (f6497 . 12) (f6497 . 8) (f6497 . 4) (f6497 . 0))
# var=f6507
    movl -8(%esp), %eax  # stack load f6507
# end emit-variable-ref
    movl %eax, -16(%esp)  # stack save
# emit-expr f6508
# emit-variable-ref
# env=((f6508 . -12) (f6507 . -8) (f6497 . 20) (f6497 . 16) (f6497 . 12) (f6497 . 8) (f6497 . 4) (f6497 . 0))
# var=f6508
    movl -12(%esp), %eax  # stack load f6508
# end emit-variable-ref
    movl %eax, -20(%esp)  # stack save
# emit-tail-expr
# si=-24
# env=((f6508 . -20) (f6507 . -16) (f6508 . -12) (f6507 . -8) (f6497 . 20) (f6497 . 16) (f6497 . 12) (f6497 . 8) (f6497 . 4) (f6497 . 0))
# expr=(begin (f6497 "error:") (f6497 (symbol->string f6507)) (f6497 ": ") (f6497 f6508) (f6497 "\n"))
# tail-begin (begin (f6497 "error:") (f6497 (symbol->string f6507)) (f6497 ": ") (f6497 f6508) (f6497 "\n"))
#   env=((f6508 . -20) (f6507 . -16) (f6508 . -12) (f6507 . -8) (f6497 . 20) (f6497 . 16) (f6497 . 12) (f6497 . 8) (f6497 . 4) (f6497 . 0))
# emit-expr (f6497 "error:")
# funcall
#    si   =-24
#    env  = ((f6508 . -20) (f6507 . -16) (f6508 . -12) (f6507 . -8) (f6497 . 20) (f6497 . 16) (f6497 . 12) (f6497 . 8) (f6497 . 4) (f6497 . 0))
#    expr = (funcall f6497 "error:")
# emit-expr f6497
# emit-variable-ref
# env=((f6508 . -20) (f6507 . -16) (f6508 . -12) (f6507 . -8) (f6497 . 20) (f6497 . 16) (f6497 . 12) (f6497 . 8) (f6497 . 4) (f6497 . 0))
# var=f6497
    movl 18(%edi), %eax  # frame load f6497
# end emit-variable-ref
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_39107"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_39107":
   movl %eax,  -32(%esp)  # stash funcall-oper in closure slot
# emit-expr "error:"
# string literal
    jmp _L_39109
    .align 8,0x90
_L_39108 :
    .int 24
    .ascii "error:"
_L_39109:
    movl $_L_39108, %eax
    orl $6, %eax
    mov %eax, -36(%esp)  # arg error:
    movl -32(%esp), %edi   # load new closure to %edi
    add $-24, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $24, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
# emit-tail-expr
# si=-24
# env=((f6508 . -20) (f6507 . -16) (f6508 . -12) (f6507 . -8) (f6497 . 20) (f6497 . 16) (f6497 . 12) (f6497 . 8) (f6497 . 4) (f6497 . 0))
# expr=(begin (f6497 (symbol->string f6507)) (f6497 ": ") (f6497 f6508) (f6497 "\n"))
# tail-begin (begin (f6497 (symbol->string f6507)) (f6497 ": ") (f6497 f6508) (f6497 "\n"))
#   env=((f6508 . -20) (f6507 . -16) (f6508 . -12) (f6507 . -8) (f6497 . 20) (f6497 . 16) (f6497 . 12) (f6497 . 8) (f6497 . 4) (f6497 . 0))
# emit-expr (f6497 (symbol->string f6507))
# funcall
#    si   =-24
#    env  = ((f6508 . -20) (f6507 . -16) (f6508 . -12) (f6507 . -8) (f6497 . 20) (f6497 . 16) (f6497 . 12) (f6497 . 8) (f6497 . 4) (f6497 . 0))
#    expr = (funcall f6497 (symbol->string f6507))
# emit-expr f6497
# emit-variable-ref
# env=((f6508 . -20) (f6507 . -16) (f6508 . -12) (f6507 . -8) (f6497 . 20) (f6497 . 16) (f6497 . 12) (f6497 . 8) (f6497 . 4) (f6497 . 0))
# var=f6497
    movl 18(%edi), %eax  # frame load f6497
# end emit-variable-ref
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_39110"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_39110":
   movl %eax,  -32(%esp)  # stash funcall-oper in closure slot
# emit-expr (symbol->string f6507)
# symbol->string f6507
# emit-expr f6507
# emit-variable-ref
# env=((f6508 . -20) (f6507 . -16) (f6508 . -12) (f6507 . -8) (f6497 . 20) (f6497 . 16) (f6497 . 12) (f6497 . 8) (f6497 . 4) (f6497 . 0))
# var=f6507
    movl -16(%esp), %eax  # stack load f6507
# end emit-variable-ref
    movl -3(%eax), %eax
    mov %eax, -36(%esp)  # arg (symbol->string f6507)
    movl -32(%esp), %edi   # load new closure to %edi
    add $-24, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $24, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
# emit-tail-expr
# si=-24
# env=((f6508 . -20) (f6507 . -16) (f6508 . -12) (f6507 . -8) (f6497 . 20) (f6497 . 16) (f6497 . 12) (f6497 . 8) (f6497 . 4) (f6497 . 0))
# expr=(begin (f6497 ": ") (f6497 f6508) (f6497 "\n"))
# tail-begin (begin (f6497 ": ") (f6497 f6508) (f6497 "\n"))
#   env=((f6508 . -20) (f6507 . -16) (f6508 . -12) (f6507 . -8) (f6497 . 20) (f6497 . 16) (f6497 . 12) (f6497 . 8) (f6497 . 4) (f6497 . 0))
# emit-expr (f6497 ": ")
# funcall
#    si   =-24
#    env  = ((f6508 . -20) (f6507 . -16) (f6508 . -12) (f6507 . -8) (f6497 . 20) (f6497 . 16) (f6497 . 12) (f6497 . 8) (f6497 . 4) (f6497 . 0))
#    expr = (funcall f6497 ": ")
# emit-expr f6497
# emit-variable-ref
# env=((f6508 . -20) (f6507 . -16) (f6508 . -12) (f6507 . -8) (f6497 . 20) (f6497 . 16) (f6497 . 12) (f6497 . 8) (f6497 . 4) (f6497 . 0))
# var=f6497
    movl 18(%edi), %eax  # frame load f6497
# end emit-variable-ref
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_39111"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_39111":
   movl %eax,  -32(%esp)  # stash funcall-oper in closure slot
# emit-expr ": "
# string literal
    jmp _L_39113
    .align 8,0x90
_L_39112 :
    .int 8
    .ascii ": "
_L_39113:
    movl $_L_39112, %eax
    orl $6, %eax
    mov %eax, -36(%esp)  # arg : 
    movl -32(%esp), %edi   # load new closure to %edi
    add $-24, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $24, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
# emit-tail-expr
# si=-24
# env=((f6508 . -20) (f6507 . -16) (f6508 . -12) (f6507 . -8) (f6497 . 20) (f6497 . 16) (f6497 . 12) (f6497 . 8) (f6497 . 4) (f6497 . 0))
# expr=(begin (f6497 f6508) (f6497 "\n"))
# tail-begin (begin (f6497 f6508) (f6497 "\n"))
#   env=((f6508 . -20) (f6507 . -16) (f6508 . -12) (f6507 . -8) (f6497 . 20) (f6497 . 16) (f6497 . 12) (f6497 . 8) (f6497 . 4) (f6497 . 0))
# emit-expr (f6497 f6508)
# funcall
#    si   =-24
#    env  = ((f6508 . -20) (f6507 . -16) (f6508 . -12) (f6507 . -8) (f6497 . 20) (f6497 . 16) (f6497 . 12) (f6497 . 8) (f6497 . 4) (f6497 . 0))
#    expr = (funcall f6497 f6508)
# emit-expr f6497
# emit-variable-ref
# env=((f6508 . -20) (f6507 . -16) (f6508 . -12) (f6507 . -8) (f6497 . 20) (f6497 . 16) (f6497 . 12) (f6497 . 8) (f6497 . 4) (f6497 . 0))
# var=f6497
    movl 18(%edi), %eax  # frame load f6497
# end emit-variable-ref
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_39114"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_39114":
   movl %eax,  -32(%esp)  # stash funcall-oper in closure slot
# emit-expr f6508
# emit-variable-ref
# env=((f6508 . -20) (f6507 . -16) (f6508 . -12) (f6507 . -8) (f6497 . 20) (f6497 . 16) (f6497 . 12) (f6497 . 8) (f6497 . 4) (f6497 . 0))
# var=f6508
    movl -20(%esp), %eax  # stack load f6508
# end emit-variable-ref
    mov %eax, -36(%esp)  # arg f6508
    movl -32(%esp), %edi   # load new closure to %edi
    add $-24, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $24, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
# emit-tail-expr
# si=-24
# env=((f6508 . -20) (f6507 . -16) (f6508 . -12) (f6507 . -8) (f6497 . 20) (f6497 . 16) (f6497 . 12) (f6497 . 8) (f6497 . 4) (f6497 . 0))
# expr=(begin (f6497 "\n"))
# tail-begin (begin (f6497 "\n"))
#   env=((f6508 . -20) (f6507 . -16) (f6508 . -12) (f6507 . -8) (f6497 . 20) (f6497 . 16) (f6497 . 12) (f6497 . 8) (f6497 . 4) (f6497 . 0))
# emit-tail-expr
# si=-24
# env=((f6508 . -20) (f6507 . -16) (f6508 . -12) (f6507 . -8) (f6497 . 20) (f6497 . 16) (f6497 . 12) (f6497 . 8) (f6497 . 4) (f6497 . 0))
# expr=(f6497 "\n")
# emit-tail-funcall
#    si   =-24
#    env  = ((f6508 . -20) (f6507 . -16) (f6508 . -12) (f6507 . -8) (f6497 . 20) (f6497 . 16) (f6497 . 12) (f6497 . 8) (f6497 . 4) (f6497 . 0))
#    expr = (funcall f6497 "\n")
# emit-expr f6497
# emit-variable-ref
# env=((f6508 . -20) (f6507 . -16) (f6508 . -12) (f6507 . -8) (f6497 . 20) (f6497 . 16) (f6497 . 12) (f6497 . 8) (f6497 . 4) (f6497 . 0))
# var=f6497
    movl 18(%edi), %eax  # frame load f6497
# end emit-variable-ref
   movl %eax,  -24(%esp)  # stash funcall-oper in next closure slot
# emit-expr "\n"
# string literal
    jmp _L_39116
    .align 8,0x90
_L_39115 :
    .int 4
    .ascii "\n"
_L_39116:
    movl $_L_39115, %eax
    orl $6, %eax
    mov %eax, -28(%esp)    # arg 

    movl -24(%esp), %edi   # load new closure to %edi
# emit-shift-args:  size=2   si=-24  delta=20
    mov -24(%esp), %ebx  # shift frame cell
    mov %ebx, -4(%esp)  # down to base
# emit-shift-args:  size=1   si=-28  delta=20
    mov -28(%esp), %ebx  # shift frame cell
    mov %ebx, -8(%esp)  # down to base
# emit-shift-args:  size=0   si=-32  delta=20
    movl $4,%eax   # save arg count
    jmp *-2(%edi)  # tail-funcall
     ret   # return thru stack
    .align 4,0x90
_L_39105:
    movl %eax, -4(%esp)  # stack save
# emit-expr (closure (f6511 f6512) (f6506) (let ((f6511 f6511) (f6512 f6512)) (begin (f6506 f6511 f6512) (foreign-call "s_exit" 1))))
# emit-closure
# si = -8
# env = ((f6506 . -4) (f6497 . 0))
# expr = (closure (f6511 f6512) (f6506) (let ((f6511 f6511) (f6512 f6512)) (begin (f6506 f6511 f6512) (foreign-call "s_exit" 1))))
    movl $_L_39117, 0(%ebp)  # closure label
# emit-variable-ref
# env=((f6506 . -4) (f6497 . 0))
# var=f6506
    movl -4(%esp), %eax  # stack load f6506
# end emit-variable-ref
   movl  %eax, 4(%ebp)  # f6506
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $8, %ebp     # bump ebp
    jmp _L_39118            # jump around closure body
_L_39117:
# check argument count
    cmp $8,%eax
    je _L_39119
# invoke error handler eh_argcount
    .extern mrc_eh$uargcount
    movl mrc_eh$uargcount, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_39119:
# emit-tail-expr
# si=-16
# env=((f6512 . -12) (f6511 . -8) (f6506 . 4) (f6506 . -4) (f6497 . 0))
# expr=(let ((f6511 f6511) (f6512 f6512)) (begin (f6506 f6511 f6512) (foreign-call "s_exit" 1)))
# emit-tail-let
#  si   = -16
#  env  = ((f6512 . -12) (f6511 . -8) (f6506 . 4) (f6506 . -4) (f6497 . 0))
#  bindings = ((f6511 f6511) (f6512 f6512))
#  body = (begin (f6506 f6511 f6512) (foreign-call "s_exit" 1))
# emit-expr f6511
# emit-variable-ref
# env=((f6512 . -12) (f6511 . -8) (f6506 . 4) (f6506 . -4) (f6497 . 0))
# var=f6511
    movl -8(%esp), %eax  # stack load f6511
# end emit-variable-ref
    movl %eax, -16(%esp)  # stack save
# emit-expr f6512
# emit-variable-ref
# env=((f6512 . -12) (f6511 . -8) (f6506 . 4) (f6506 . -4) (f6497 . 0))
# var=f6512
    movl -12(%esp), %eax  # stack load f6512
# end emit-variable-ref
    movl %eax, -20(%esp)  # stack save
# emit-tail-expr
# si=-24
# env=((f6512 . -20) (f6511 . -16) (f6512 . -12) (f6511 . -8) (f6506 . 4) (f6506 . -4) (f6497 . 0))
# expr=(begin (f6506 f6511 f6512) (foreign-call "s_exit" 1))
# tail-begin (begin (f6506 f6511 f6512) (foreign-call "s_exit" 1))
#   env=((f6512 . -20) (f6511 . -16) (f6512 . -12) (f6511 . -8) (f6506 . 4) (f6506 . -4) (f6497 . 0))
# emit-expr (f6506 f6511 f6512)
# funcall
#    si   =-24
#    env  = ((f6512 . -20) (f6511 . -16) (f6512 . -12) (f6511 . -8) (f6506 . 4) (f6506 . -4) (f6497 . 0))
#    expr = (funcall f6506 f6511 f6512)
# emit-expr f6506
# emit-variable-ref
# env=((f6512 . -20) (f6511 . -16) (f6512 . -12) (f6511 . -8) (f6506 . 4) (f6506 . -4) (f6497 . 0))
# var=f6506
    movl 2(%edi), %eax  # frame load f6506
# end emit-variable-ref
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_39120"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_39120":
   movl %eax,  -32(%esp)  # stash funcall-oper in closure slot
# emit-expr f6511
# emit-variable-ref
# env=((f6512 . -20) (f6511 . -16) (f6512 . -12) (f6511 . -8) (f6506 . 4) (f6506 . -4) (f6497 . 0))
# var=f6511
    movl -16(%esp), %eax  # stack load f6511
# end emit-variable-ref
    mov %eax, -36(%esp)  # arg f6511
# emit-expr f6512
# emit-variable-ref
# env=((f6512 . -20) (f6511 . -16) (f6512 . -12) (f6511 . -8) (f6506 . 4) (f6506 . -4) (f6497 . 0))
# var=f6512
    movl -20(%esp), %eax  # stack load f6512
# end emit-variable-ref
    mov %eax, -40(%esp)  # arg f6512
    movl -32(%esp), %edi   # load new closure to %edi
    add $-24, %esp   # adjust base
    movl $8,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $24, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
# emit-tail-expr
# si=-24
# env=((f6512 . -20) (f6511 . -16) (f6512 . -12) (f6511 . -8) (f6506 . 4) (f6506 . -4) (f6497 . 0))
# expr=(begin (foreign-call "s_exit" 1))
# tail-begin (begin (foreign-call "s_exit" 1))
#   env=((f6512 . -20) (f6511 . -16) (f6512 . -12) (f6511 . -8) (f6506 . 4) (f6506 . -4) (f6497 . 0))
# emit-tail-expr
# si=-24
# env=((f6512 . -20) (f6511 . -16) (f6512 . -12) (f6511 . -8) (f6506 . 4) (f6506 . -4) (f6497 . 0))
# expr=(foreign-call "s_exit" 1)
    movl %ecx,-24(%esp)
    movl %esp,-28(%esp)
# emit-expr 1
    movl $4, %eax     # immed 1
    movl %eax, -32(%esp)
    leal -32(%esp),%edi
    movl %edi,%esi
    andl $-16,%esi
    movl 0(%edi),%eax
    movl %eax,0(%esi)
    movl 4(%edi),%eax
    movl %eax,4(%esi)
    movl %esi,%esp
    .extern _s_exit
    call _s_exit
    movl 4(%esi),%esp
    movl -24(%esp),%ecx
     ret
     ret   # return thru stack
    .align 4,0x90
_L_39118:
     movl %eax, mrc_error
# == explicit-begins  ==>
# (let ((p (quote ()))) (begin (set! p (cons (quote procedure?) p)) (set! p (cons (quote cdr) p)) (set! p (cons (quote car) p)) (set! p (cons (quote symbol-value) p)) (set! p (cons (quote symbol->string) p)) (set! p (cons (quote make-symbol) p)) (set! p (cons (quote symbol?) p)) (set! p (cons (quote string-set!) p)) (set! p (cons (quote string-ref) p)) (set! p (cons (quote string-length) p)) (set! p (cons (quote string?) p)) (set! p (cons (quote make-string) p)) (set! p (cons (quote vector-ref) p)) (set! p (cons (quote vector-set!) p)) (set! p (cons (quote vector-length) p)) (set! p (cons (quote make-vector) p)) (set! p (cons (quote vector?) p)) (set! p (cons (quote set-cdr!) p)) (set! p (cons (quote set-car!) p)) (set! p (cons (quote cdr) p)) (set! p (cons (quote car) p)) (set! p (cons (quote cons) p)) (set! p (cons (quote pair?) p)) (set! p (cons (quote fxremainder) p)) (set! p (cons (quote fxquotient) p)) (set! p (cons (quote fx*) p)) (set! p (cons (quote fx-) p)) (set! p (cons (quote fx+) p)) (set! p (cons (quote fx>=) p)) (set! p (cons (quote fx>) p)) (set! p (cons (quote fx<=) p)) (set! p (cons (quote fx<) p)) (set! p (cons (quote fx=) p)) (set! p (cons (quote fxzero?) p)) (set! p (cons (quote fxsub1) p)) (set! p (cons (quote fxadd1) p)) (set! p (cons (quote fxlogor) p)) (set! p (cons (quote fxlogand) p)) (set! p (cons (quote fxlognot) p)) (set! p (cons (quote char=?) p)) (set! p (cons (quote eq?) p)) (set! p (cons (quote not) p)) (set! p (cons (quote boolean?) p)) (set! p (cons (quote fixnum?) p)) (set! p (cons (quote char?) p)) (set! p (cons (quote eof-object) p)) (set! p (cons (quote eof-object?) p)) (set! p (cons (quote null?) p)) (set! p (cons (quote char->fixnum) p)) (set! p (cons (quote fixnum->char) p)) (lambda () p)))
# == eliminate-let*  ==>
# (let ((p (quote ()))) (begin (set! p (cons (quote procedure?) p)) (set! p (cons (quote cdr) p)) (set! p (cons (quote car) p)) (set! p (cons (quote symbol-value) p)) (set! p (cons (quote symbol->string) p)) (set! p (cons (quote make-symbol) p)) (set! p (cons (quote symbol?) p)) (set! p (cons (quote string-set!) p)) (set! p (cons (quote string-ref) p)) (set! p (cons (quote string-length) p)) (set! p (cons (quote string?) p)) (set! p (cons (quote make-string) p)) (set! p (cons (quote vector-ref) p)) (set! p (cons (quote vector-set!) p)) (set! p (cons (quote vector-length) p)) (set! p (cons (quote make-vector) p)) (set! p (cons (quote vector?) p)) (set! p (cons (quote set-cdr!) p)) (set! p (cons (quote set-car!) p)) (set! p (cons (quote cdr) p)) (set! p (cons (quote car) p)) (set! p (cons (quote cons) p)) (set! p (cons (quote pair?) p)) (set! p (cons (quote fxremainder) p)) (set! p (cons (quote fxquotient) p)) (set! p (cons (quote fx*) p)) (set! p (cons (quote fx-) p)) (set! p (cons (quote fx+) p)) (set! p (cons (quote fx>=) p)) (set! p (cons (quote fx>) p)) (set! p (cons (quote fx<=) p)) (set! p (cons (quote fx<) p)) (set! p (cons (quote fx=) p)) (set! p (cons (quote fxzero?) p)) (set! p (cons (quote fxsub1) p)) (set! p (cons (quote fxadd1) p)) (set! p (cons (quote fxlogor) p)) (set! p (cons (quote fxlogand) p)) (set! p (cons (quote fxlognot) p)) (set! p (cons (quote char=?) p)) (set! p (cons (quote eq?) p)) (set! p (cons (quote not) p)) (set! p (cons (quote boolean?) p)) (set! p (cons (quote fixnum?) p)) (set! p (cons (quote char?) p)) (set! p (cons (quote eof-object) p)) (set! p (cons (quote eof-object?) p)) (set! p (cons (quote null?) p)) (set! p (cons (quote char->fixnum) p)) (set! p (cons (quote fixnum->char) p)) (lambda () p)))
# == uniquify-variables  ==>
# (let ((f6513 (quote ()))) (begin (set! f6513 (cons (quote procedure?) f6513)) (set! f6513 (cons (quote cdr) f6513)) (set! f6513 (cons (quote car) f6513)) (set! f6513 (cons (quote symbol-value) f6513)) (set! f6513 (cons (quote symbol->string) f6513)) (set! f6513 (cons (quote make-symbol) f6513)) (set! f6513 (cons (quote symbol?) f6513)) (set! f6513 (cons (quote string-set!) f6513)) (set! f6513 (cons (quote string-ref) f6513)) (set! f6513 (cons (quote string-length) f6513)) (set! f6513 (cons (quote string?) f6513)) (set! f6513 (cons (quote make-string) f6513)) (set! f6513 (cons (quote vector-ref) f6513)) (set! f6513 (cons (quote vector-set!) f6513)) (set! f6513 (cons (quote vector-length) f6513)) (set! f6513 (cons (quote make-vector) f6513)) (set! f6513 (cons (quote vector?) f6513)) (set! f6513 (cons (quote set-cdr!) f6513)) (set! f6513 (cons (quote set-car!) f6513)) (set! f6513 (cons (quote cdr) f6513)) (set! f6513 (cons (quote car) f6513)) (set! f6513 (cons (quote cons) f6513)) (set! f6513 (cons (quote pair?) f6513)) (set! f6513 (cons (quote fxremainder) f6513)) (set! f6513 (cons (quote fxquotient) f6513)) (set! f6513 (cons (quote fx*) f6513)) (set! f6513 (cons (quote fx-) f6513)) (set! f6513 (cons (quote fx+) f6513)) (set! f6513 (cons (quote fx>=) f6513)) (set! f6513 (cons (quote fx>) f6513)) (set! f6513 (cons (quote fx<=) f6513)) (set! f6513 (cons (quote fx<) f6513)) (set! f6513 (cons (quote fx=) f6513)) (set! f6513 (cons (quote fxzero?) f6513)) (set! f6513 (cons (quote fxsub1) f6513)) (set! f6513 (cons (quote fxadd1) f6513)) (set! f6513 (cons (quote fxlogor) f6513)) (set! f6513 (cons (quote fxlogand) f6513)) (set! f6513 (cons (quote fxlognot) f6513)) (set! f6513 (cons (quote char=?) f6513)) (set! f6513 (cons (quote eq?) f6513)) (set! f6513 (cons (quote not) f6513)) (set! f6513 (cons (quote boolean?) f6513)) (set! f6513 (cons (quote fixnum?) f6513)) (set! f6513 (cons (quote char?) f6513)) (set! f6513 (cons (quote eof-object) f6513)) (set! f6513 (cons (quote eof-object?) f6513)) (set! f6513 (cons (quote null?) f6513)) (set! f6513 (cons (quote char->fixnum) f6513)) (set! f6513 (cons (quote fixnum->char) f6513)) (lambda () f6513)))
# == vectorize-letrec  ==>
# (let ((f6513 (quote ()))) (begin (set! f6513 (cons (quote procedure?) f6513)) (set! f6513 (cons (quote cdr) f6513)) (set! f6513 (cons (quote car) f6513)) (set! f6513 (cons (quote symbol-value) f6513)) (set! f6513 (cons (quote symbol->string) f6513)) (set! f6513 (cons (quote make-symbol) f6513)) (set! f6513 (cons (quote symbol?) f6513)) (set! f6513 (cons (quote string-set!) f6513)) (set! f6513 (cons (quote string-ref) f6513)) (set! f6513 (cons (quote string-length) f6513)) (set! f6513 (cons (quote string?) f6513)) (set! f6513 (cons (quote make-string) f6513)) (set! f6513 (cons (quote vector-ref) f6513)) (set! f6513 (cons (quote vector-set!) f6513)) (set! f6513 (cons (quote vector-length) f6513)) (set! f6513 (cons (quote make-vector) f6513)) (set! f6513 (cons (quote vector?) f6513)) (set! f6513 (cons (quote set-cdr!) f6513)) (set! f6513 (cons (quote set-car!) f6513)) (set! f6513 (cons (quote cdr) f6513)) (set! f6513 (cons (quote car) f6513)) (set! f6513 (cons (quote cons) f6513)) (set! f6513 (cons (quote pair?) f6513)) (set! f6513 (cons (quote fxremainder) f6513)) (set! f6513 (cons (quote fxquotient) f6513)) (set! f6513 (cons (quote fx*) f6513)) (set! f6513 (cons (quote fx-) f6513)) (set! f6513 (cons (quote fx+) f6513)) (set! f6513 (cons (quote fx>=) f6513)) (set! f6513 (cons (quote fx>) f6513)) (set! f6513 (cons (quote fx<=) f6513)) (set! f6513 (cons (quote fx<) f6513)) (set! f6513 (cons (quote fx=) f6513)) (set! f6513 (cons (quote fxzero?) f6513)) (set! f6513 (cons (quote fxsub1) f6513)) (set! f6513 (cons (quote fxadd1) f6513)) (set! f6513 (cons (quote fxlogor) f6513)) (set! f6513 (cons (quote fxlogand) f6513)) (set! f6513 (cons (quote fxlognot) f6513)) (set! f6513 (cons (quote char=?) f6513)) (set! f6513 (cons (quote eq?) f6513)) (set! f6513 (cons (quote not) f6513)) (set! f6513 (cons (quote boolean?) f6513)) (set! f6513 (cons (quote fixnum?) f6513)) (set! f6513 (cons (quote char?) f6513)) (set! f6513 (cons (quote eof-object) f6513)) (set! f6513 (cons (quote eof-object?) f6513)) (set! f6513 (cons (quote null?) f6513)) (set! f6513 (cons (quote char->fixnum) f6513)) (set! f6513 (cons (quote fixnum->char) f6513)) (lambda () f6513)))
# == eliminate-set!  ==>
# (let ((f6513 (vector (quote ())))) (begin (vector-set! f6513 0 (cons (quote procedure?) (vector-ref f6513 0))) (vector-set! f6513 0 (cons (quote cdr) (vector-ref f6513 0))) (vector-set! f6513 0 (cons (quote car) (vector-ref f6513 0))) (vector-set! f6513 0 (cons (quote symbol-value) (vector-ref f6513 0))) (vector-set! f6513 0 (cons (quote symbol->string) (vector-ref f6513 0))) (vector-set! f6513 0 (cons (quote make-symbol) (vector-ref f6513 0))) (vector-set! f6513 0 (cons (quote symbol?) (vector-ref f6513 0))) (vector-set! f6513 0 (cons (quote string-set!) (vector-ref f6513 0))) (vector-set! f6513 0 (cons (quote string-ref) (vector-ref f6513 0))) (vector-set! f6513 0 (cons (quote string-length) (vector-ref f6513 0))) (vector-set! f6513 0 (cons (quote string?) (vector-ref f6513 0))) (vector-set! f6513 0 (cons (quote make-string) (vector-ref f6513 0))) (vector-set! f6513 0 (cons (quote vector-ref) (vector-ref f6513 0))) (vector-set! f6513 0 (cons (quote vector-set!) (vector-ref f6513 0))) (vector-set! f6513 0 (cons (quote vector-length) (vector-ref f6513 0))) (vector-set! f6513 0 (cons (quote make-vector) (vector-ref f6513 0))) (vector-set! f6513 0 (cons (quote vector?) (vector-ref f6513 0))) (vector-set! f6513 0 (cons (quote set-cdr!) (vector-ref f6513 0))) (vector-set! f6513 0 (cons (quote set-car!) (vector-ref f6513 0))) (vector-set! f6513 0 (cons (quote cdr) (vector-ref f6513 0))) (vector-set! f6513 0 (cons (quote car) (vector-ref f6513 0))) (vector-set! f6513 0 (cons (quote cons) (vector-ref f6513 0))) (vector-set! f6513 0 (cons (quote pair?) (vector-ref f6513 0))) (vector-set! f6513 0 (cons (quote fxremainder) (vector-ref f6513 0))) (vector-set! f6513 0 (cons (quote fxquotient) (vector-ref f6513 0))) (vector-set! f6513 0 (cons (quote fx*) (vector-ref f6513 0))) (vector-set! f6513 0 (cons (quote fx-) (vector-ref f6513 0))) (vector-set! f6513 0 (cons (quote fx+) (vector-ref f6513 0))) (vector-set! f6513 0 (cons (quote fx>=) (vector-ref f6513 0))) (vector-set! f6513 0 (cons (quote fx>) (vector-ref f6513 0))) (vector-set! f6513 0 (cons (quote fx<=) (vector-ref f6513 0))) (vector-set! f6513 0 (cons (quote fx<) (vector-ref f6513 0))) (vector-set! f6513 0 (cons (quote fx=) (vector-ref f6513 0))) (vector-set! f6513 0 (cons (quote fxzero?) (vector-ref f6513 0))) (vector-set! f6513 0 (cons (quote fxsub1) (vector-ref f6513 0))) (vector-set! f6513 0 (cons (quote fxadd1) (vector-ref f6513 0))) (vector-set! f6513 0 (cons (quote fxlogor) (vector-ref f6513 0))) (vector-set! f6513 0 (cons (quote fxlogand) (vector-ref f6513 0))) (vector-set! f6513 0 (cons (quote fxlognot) (vector-ref f6513 0))) (vector-set! f6513 0 (cons (quote char=?) (vector-ref f6513 0))) (vector-set! f6513 0 (cons (quote eq?) (vector-ref f6513 0))) (vector-set! f6513 0 (cons (quote not) (vector-ref f6513 0))) (vector-set! f6513 0 (cons (quote boolean?) (vector-ref f6513 0))) (vector-set! f6513 0 (cons (quote fixnum?) (vector-ref f6513 0))) (vector-set! f6513 0 (cons (quote char?) (vector-ref f6513 0))) (vector-set! f6513 0 (cons (quote eof-object) (vector-ref f6513 0))) (vector-set! f6513 0 (cons (quote eof-object?) (vector-ref f6513 0))) (vector-set! f6513 0 (cons (quote null?) (vector-ref f6513 0))) (vector-set! f6513 0 (cons (quote char->fixnum) (vector-ref f6513 0))) (vector-set! f6513 0 (cons (quote fixnum->char) (vector-ref f6513 0))) (lambda () (let () (vector-ref f6513 0)))))
# == close-free-variables  ==>
# (let ((f6513 (vector (quote ())))) (begin (vector-set! f6513 0 (cons (quote procedure?) (vector-ref f6513 0))) (vector-set! f6513 0 (cons (quote cdr) (vector-ref f6513 0))) (vector-set! f6513 0 (cons (quote car) (vector-ref f6513 0))) (vector-set! f6513 0 (cons (quote symbol-value) (vector-ref f6513 0))) (vector-set! f6513 0 (cons (quote symbol->string) (vector-ref f6513 0))) (vector-set! f6513 0 (cons (quote make-symbol) (vector-ref f6513 0))) (vector-set! f6513 0 (cons (quote symbol?) (vector-ref f6513 0))) (vector-set! f6513 0 (cons (quote string-set!) (vector-ref f6513 0))) (vector-set! f6513 0 (cons (quote string-ref) (vector-ref f6513 0))) (vector-set! f6513 0 (cons (quote string-length) (vector-ref f6513 0))) (vector-set! f6513 0 (cons (quote string?) (vector-ref f6513 0))) (vector-set! f6513 0 (cons (quote make-string) (vector-ref f6513 0))) (vector-set! f6513 0 (cons (quote vector-ref) (vector-ref f6513 0))) (vector-set! f6513 0 (cons (quote vector-set!) (vector-ref f6513 0))) (vector-set! f6513 0 (cons (quote vector-length) (vector-ref f6513 0))) (vector-set! f6513 0 (cons (quote make-vector) (vector-ref f6513 0))) (vector-set! f6513 0 (cons (quote vector?) (vector-ref f6513 0))) (vector-set! f6513 0 (cons (quote set-cdr!) (vector-ref f6513 0))) (vector-set! f6513 0 (cons (quote set-car!) (vector-ref f6513 0))) (vector-set! f6513 0 (cons (quote cdr) (vector-ref f6513 0))) (vector-set! f6513 0 (cons (quote car) (vector-ref f6513 0))) (vector-set! f6513 0 (cons (quote cons) (vector-ref f6513 0))) (vector-set! f6513 0 (cons (quote pair?) (vector-ref f6513 0))) (vector-set! f6513 0 (cons (quote fxremainder) (vector-ref f6513 0))) (vector-set! f6513 0 (cons (quote fxquotient) (vector-ref f6513 0))) (vector-set! f6513 0 (cons (quote fx*) (vector-ref f6513 0))) (vector-set! f6513 0 (cons (quote fx-) (vector-ref f6513 0))) (vector-set! f6513 0 (cons (quote fx+) (vector-ref f6513 0))) (vector-set! f6513 0 (cons (quote fx>=) (vector-ref f6513 0))) (vector-set! f6513 0 (cons (quote fx>) (vector-ref f6513 0))) (vector-set! f6513 0 (cons (quote fx<=) (vector-ref f6513 0))) (vector-set! f6513 0 (cons (quote fx<) (vector-ref f6513 0))) (vector-set! f6513 0 (cons (quote fx=) (vector-ref f6513 0))) (vector-set! f6513 0 (cons (quote fxzero?) (vector-ref f6513 0))) (vector-set! f6513 0 (cons (quote fxsub1) (vector-ref f6513 0))) (vector-set! f6513 0 (cons (quote fxadd1) (vector-ref f6513 0))) (vector-set! f6513 0 (cons (quote fxlogor) (vector-ref f6513 0))) (vector-set! f6513 0 (cons (quote fxlogand) (vector-ref f6513 0))) (vector-set! f6513 0 (cons (quote fxlognot) (vector-ref f6513 0))) (vector-set! f6513 0 (cons (quote char=?) (vector-ref f6513 0))) (vector-set! f6513 0 (cons (quote eq?) (vector-ref f6513 0))) (vector-set! f6513 0 (cons (quote not) (vector-ref f6513 0))) (vector-set! f6513 0 (cons (quote boolean?) (vector-ref f6513 0))) (vector-set! f6513 0 (cons (quote fixnum?) (vector-ref f6513 0))) (vector-set! f6513 0 (cons (quote char?) (vector-ref f6513 0))) (vector-set! f6513 0 (cons (quote eof-object) (vector-ref f6513 0))) (vector-set! f6513 0 (cons (quote eof-object?) (vector-ref f6513 0))) (vector-set! f6513 0 (cons (quote null?) (vector-ref f6513 0))) (vector-set! f6513 0 (cons (quote char->fixnum) (vector-ref f6513 0))) (vector-set! f6513 0 (cons (quote fixnum->char) (vector-ref f6513 0))) (closure () (f6513) (let () (vector-ref f6513 0)))))
# == eliminate-quote  ==>
# (let ((f6513 (vector ()))) (begin (vector-set! f6513 0 (cons (string->symbol "procedure?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons (string->symbol "cdr") (vector-ref f6513 0))) (vector-set! f6513 0 (cons (string->symbol "car") (vector-ref f6513 0))) (vector-set! f6513 0 (cons (string->symbol "symbol-value") (vector-ref f6513 0))) (vector-set! f6513 0 (cons (string->symbol "symbol->string") (vector-ref f6513 0))) (vector-set! f6513 0 (cons (string->symbol "make-symbol") (vector-ref f6513 0))) (vector-set! f6513 0 (cons (string->symbol "symbol?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons (string->symbol "string-set!") (vector-ref f6513 0))) (vector-set! f6513 0 (cons (string->symbol "string-ref") (vector-ref f6513 0))) (vector-set! f6513 0 (cons (string->symbol "string-length") (vector-ref f6513 0))) (vector-set! f6513 0 (cons (string->symbol "string?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons (string->symbol "make-string") (vector-ref f6513 0))) (vector-set! f6513 0 (cons (string->symbol "vector-ref") (vector-ref f6513 0))) (vector-set! f6513 0 (cons (string->symbol "vector-set!") (vector-ref f6513 0))) (vector-set! f6513 0 (cons (string->symbol "vector-length") (vector-ref f6513 0))) (vector-set! f6513 0 (cons (string->symbol "make-vector") (vector-ref f6513 0))) (vector-set! f6513 0 (cons (string->symbol "vector?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons (string->symbol "set-cdr!") (vector-ref f6513 0))) (vector-set! f6513 0 (cons (string->symbol "set-car!") (vector-ref f6513 0))) (vector-set! f6513 0 (cons (string->symbol "cdr") (vector-ref f6513 0))) (vector-set! f6513 0 (cons (string->symbol "car") (vector-ref f6513 0))) (vector-set! f6513 0 (cons (string->symbol "cons") (vector-ref f6513 0))) (vector-set! f6513 0 (cons (string->symbol "pair?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons (string->symbol "fxremainder") (vector-ref f6513 0))) (vector-set! f6513 0 (cons (string->symbol "fxquotient") (vector-ref f6513 0))) (vector-set! f6513 0 (cons (string->symbol "fx*") (vector-ref f6513 0))) (vector-set! f6513 0 (cons (string->symbol "fx-") (vector-ref f6513 0))) (vector-set! f6513 0 (cons (string->symbol "fx+") (vector-ref f6513 0))) (vector-set! f6513 0 (cons (string->symbol "fx>=") (vector-ref f6513 0))) (vector-set! f6513 0 (cons (string->symbol "fx>") (vector-ref f6513 0))) (vector-set! f6513 0 (cons (string->symbol "fx<=") (vector-ref f6513 0))) (vector-set! f6513 0 (cons (string->symbol "fx<") (vector-ref f6513 0))) (vector-set! f6513 0 (cons (string->symbol "fx=") (vector-ref f6513 0))) (vector-set! f6513 0 (cons (string->symbol "fxzero?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons (string->symbol "fxsub1") (vector-ref f6513 0))) (vector-set! f6513 0 (cons (string->symbol "fxadd1") (vector-ref f6513 0))) (vector-set! f6513 0 (cons (string->symbol "fxlogor") (vector-ref f6513 0))) (vector-set! f6513 0 (cons (string->symbol "fxlogand") (vector-ref f6513 0))) (vector-set! f6513 0 (cons (string->symbol "fxlognot") (vector-ref f6513 0))) (vector-set! f6513 0 (cons (string->symbol "char=?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons (string->symbol "eq?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons (string->symbol "not") (vector-ref f6513 0))) (vector-set! f6513 0 (cons (string->symbol "boolean?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons (string->symbol "fixnum?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons (string->symbol "char?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons (string->symbol "eof-object") (vector-ref f6513 0))) (vector-set! f6513 0 (cons (string->symbol "eof-object?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons (string->symbol "null?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons (string->symbol "char->fixnum") (vector-ref f6513 0))) (vector-set! f6513 0 (cons (string->symbol "fixnum->char") (vector-ref f6513 0))) (closure () (f6513) (let () (vector-ref f6513 0)))))
# == eliminate-when/unless  ==>
# (let ((f6513 (vector ()))) (begin (vector-set! f6513 0 (cons (string->symbol "procedure?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons (string->symbol "cdr") (vector-ref f6513 0))) (vector-set! f6513 0 (cons (string->symbol "car") (vector-ref f6513 0))) (vector-set! f6513 0 (cons (string->symbol "symbol-value") (vector-ref f6513 0))) (vector-set! f6513 0 (cons (string->symbol "symbol->string") (vector-ref f6513 0))) (vector-set! f6513 0 (cons (string->symbol "make-symbol") (vector-ref f6513 0))) (vector-set! f6513 0 (cons (string->symbol "symbol?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons (string->symbol "string-set!") (vector-ref f6513 0))) (vector-set! f6513 0 (cons (string->symbol "string-ref") (vector-ref f6513 0))) (vector-set! f6513 0 (cons (string->symbol "string-length") (vector-ref f6513 0))) (vector-set! f6513 0 (cons (string->symbol "string?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons (string->symbol "make-string") (vector-ref f6513 0))) (vector-set! f6513 0 (cons (string->symbol "vector-ref") (vector-ref f6513 0))) (vector-set! f6513 0 (cons (string->symbol "vector-set!") (vector-ref f6513 0))) (vector-set! f6513 0 (cons (string->symbol "vector-length") (vector-ref f6513 0))) (vector-set! f6513 0 (cons (string->symbol "make-vector") (vector-ref f6513 0))) (vector-set! f6513 0 (cons (string->symbol "vector?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons (string->symbol "set-cdr!") (vector-ref f6513 0))) (vector-set! f6513 0 (cons (string->symbol "set-car!") (vector-ref f6513 0))) (vector-set! f6513 0 (cons (string->symbol "cdr") (vector-ref f6513 0))) (vector-set! f6513 0 (cons (string->symbol "car") (vector-ref f6513 0))) (vector-set! f6513 0 (cons (string->symbol "cons") (vector-ref f6513 0))) (vector-set! f6513 0 (cons (string->symbol "pair?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons (string->symbol "fxremainder") (vector-ref f6513 0))) (vector-set! f6513 0 (cons (string->symbol "fxquotient") (vector-ref f6513 0))) (vector-set! f6513 0 (cons (string->symbol "fx*") (vector-ref f6513 0))) (vector-set! f6513 0 (cons (string->symbol "fx-") (vector-ref f6513 0))) (vector-set! f6513 0 (cons (string->symbol "fx+") (vector-ref f6513 0))) (vector-set! f6513 0 (cons (string->symbol "fx>=") (vector-ref f6513 0))) (vector-set! f6513 0 (cons (string->symbol "fx>") (vector-ref f6513 0))) (vector-set! f6513 0 (cons (string->symbol "fx<=") (vector-ref f6513 0))) (vector-set! f6513 0 (cons (string->symbol "fx<") (vector-ref f6513 0))) (vector-set! f6513 0 (cons (string->symbol "fx=") (vector-ref f6513 0))) (vector-set! f6513 0 (cons (string->symbol "fxzero?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons (string->symbol "fxsub1") (vector-ref f6513 0))) (vector-set! f6513 0 (cons (string->symbol "fxadd1") (vector-ref f6513 0))) (vector-set! f6513 0 (cons (string->symbol "fxlogor") (vector-ref f6513 0))) (vector-set! f6513 0 (cons (string->symbol "fxlogand") (vector-ref f6513 0))) (vector-set! f6513 0 (cons (string->symbol "fxlognot") (vector-ref f6513 0))) (vector-set! f6513 0 (cons (string->symbol "char=?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons (string->symbol "eq?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons (string->symbol "not") (vector-ref f6513 0))) (vector-set! f6513 0 (cons (string->symbol "boolean?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons (string->symbol "fixnum?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons (string->symbol "char?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons (string->symbol "eof-object") (vector-ref f6513 0))) (vector-set! f6513 0 (cons (string->symbol "eof-object?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons (string->symbol "null?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons (string->symbol "char->fixnum") (vector-ref f6513 0))) (vector-set! f6513 0 (cons (string->symbol "fixnum->char") (vector-ref f6513 0))) (closure () (f6513) (let () (vector-ref f6513 0)))))
# == eliminate-cond  ==>
# (let ((f6513 (vector ()))) (begin (vector-set! f6513 0 (cons (string->symbol "procedure?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons (string->symbol "cdr") (vector-ref f6513 0))) (vector-set! f6513 0 (cons (string->symbol "car") (vector-ref f6513 0))) (vector-set! f6513 0 (cons (string->symbol "symbol-value") (vector-ref f6513 0))) (vector-set! f6513 0 (cons (string->symbol "symbol->string") (vector-ref f6513 0))) (vector-set! f6513 0 (cons (string->symbol "make-symbol") (vector-ref f6513 0))) (vector-set! f6513 0 (cons (string->symbol "symbol?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons (string->symbol "string-set!") (vector-ref f6513 0))) (vector-set! f6513 0 (cons (string->symbol "string-ref") (vector-ref f6513 0))) (vector-set! f6513 0 (cons (string->symbol "string-length") (vector-ref f6513 0))) (vector-set! f6513 0 (cons (string->symbol "string?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons (string->symbol "make-string") (vector-ref f6513 0))) (vector-set! f6513 0 (cons (string->symbol "vector-ref") (vector-ref f6513 0))) (vector-set! f6513 0 (cons (string->symbol "vector-set!") (vector-ref f6513 0))) (vector-set! f6513 0 (cons (string->symbol "vector-length") (vector-ref f6513 0))) (vector-set! f6513 0 (cons (string->symbol "make-vector") (vector-ref f6513 0))) (vector-set! f6513 0 (cons (string->symbol "vector?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons (string->symbol "set-cdr!") (vector-ref f6513 0))) (vector-set! f6513 0 (cons (string->symbol "set-car!") (vector-ref f6513 0))) (vector-set! f6513 0 (cons (string->symbol "cdr") (vector-ref f6513 0))) (vector-set! f6513 0 (cons (string->symbol "car") (vector-ref f6513 0))) (vector-set! f6513 0 (cons (string->symbol "cons") (vector-ref f6513 0))) (vector-set! f6513 0 (cons (string->symbol "pair?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons (string->symbol "fxremainder") (vector-ref f6513 0))) (vector-set! f6513 0 (cons (string->symbol "fxquotient") (vector-ref f6513 0))) (vector-set! f6513 0 (cons (string->symbol "fx*") (vector-ref f6513 0))) (vector-set! f6513 0 (cons (string->symbol "fx-") (vector-ref f6513 0))) (vector-set! f6513 0 (cons (string->symbol "fx+") (vector-ref f6513 0))) (vector-set! f6513 0 (cons (string->symbol "fx>=") (vector-ref f6513 0))) (vector-set! f6513 0 (cons (string->symbol "fx>") (vector-ref f6513 0))) (vector-set! f6513 0 (cons (string->symbol "fx<=") (vector-ref f6513 0))) (vector-set! f6513 0 (cons (string->symbol "fx<") (vector-ref f6513 0))) (vector-set! f6513 0 (cons (string->symbol "fx=") (vector-ref f6513 0))) (vector-set! f6513 0 (cons (string->symbol "fxzero?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons (string->symbol "fxsub1") (vector-ref f6513 0))) (vector-set! f6513 0 (cons (string->symbol "fxadd1") (vector-ref f6513 0))) (vector-set! f6513 0 (cons (string->symbol "fxlogor") (vector-ref f6513 0))) (vector-set! f6513 0 (cons (string->symbol "fxlogand") (vector-ref f6513 0))) (vector-set! f6513 0 (cons (string->symbol "fxlognot") (vector-ref f6513 0))) (vector-set! f6513 0 (cons (string->symbol "char=?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons (string->symbol "eq?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons (string->symbol "not") (vector-ref f6513 0))) (vector-set! f6513 0 (cons (string->symbol "boolean?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons (string->symbol "fixnum?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons (string->symbol "char?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons (string->symbol "eof-object") (vector-ref f6513 0))) (vector-set! f6513 0 (cons (string->symbol "eof-object?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons (string->symbol "null?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons (string->symbol "char->fixnum") (vector-ref f6513 0))) (vector-set! f6513 0 (cons (string->symbol "fixnum->char") (vector-ref f6513 0))) (closure () (f6513) (let () (vector-ref f6513 0)))))
# == external-symbols  ==>
# (let ((f6513 ((primitive-ref vector) ()))) (begin (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "procedure?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "cdr") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "car") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "symbol-value") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "symbol->string") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "make-symbol") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "symbol?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "string-set!") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "string-ref") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "string-length") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "string?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "make-string") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "vector-ref") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "vector-set!") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "vector-length") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "make-vector") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "vector?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "set-cdr!") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "set-car!") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "cdr") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "car") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "cons") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "pair?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fxremainder") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fxquotient") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fx*") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fx-") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fx+") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fx>=") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fx>") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fx<=") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fx<") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fx=") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "eof-object") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "eof-object?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f6513 0))) (closure () (f6513) (let () (vector-ref f6513 0)))))
# emit-expr (let ((f6513 ((primitive-ref vector) ()))) (begin (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "procedure?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "cdr") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "car") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "symbol-value") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "symbol->string") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "make-symbol") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "symbol?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "string-set!") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "string-ref") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "string-length") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "string?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "make-string") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "vector-ref") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "vector-set!") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "vector-length") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "make-vector") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "vector?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "set-cdr!") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "set-car!") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "cdr") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "car") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "cons") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "pair?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fxremainder") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fxquotient") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fx*") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fx-") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fx+") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fx>=") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fx>") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fx<=") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fx<") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fx=") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "eof-object") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "eof-object?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f6513 0))) (closure () (f6513) (let () (vector-ref f6513 0)))))
# emit-let
#  si   = 0
#  env  = ()
#  bindings = ((f6513 ((primitive-ref vector) ())))
#  body = (begin (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "procedure?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "cdr") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "car") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "symbol-value") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "symbol->string") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "make-symbol") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "symbol?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "string-set!") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "string-ref") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "string-length") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "string?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "make-string") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "vector-ref") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "vector-set!") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "vector-length") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "make-vector") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "vector?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "set-cdr!") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "set-car!") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "cdr") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "car") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "cons") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "pair?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fxremainder") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fxquotient") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fx*") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fx-") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fx+") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fx>=") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fx>") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fx<=") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fx<") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fx=") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "eof-object") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "eof-object?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f6513 0))) (closure () (f6513) (let () (vector-ref f6513 0))))
# emit-expr ((primitive-ref vector) ())
# funcall
#    si   =0
#    env  = ()
#    expr = (funcall (primitive-ref vector) ())
# emit-expr (primitive-ref vector)
    .extern mrc_vector
    movl mrc_vector,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_39121"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_39121":
   movl %eax,  -8(%esp)  # stash funcall-oper in closure slot
# emit-expr ()
    movl $63, %eax     # immed ()
    mov %eax, -12(%esp)  # arg ()
    movl -8(%esp), %edi   # load new closure to %edi
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    movl -4(%esp), %edi   # restore closure frame ptr
    movl %eax, 0(%esp)  # stack save
# emit-expr (begin (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "procedure?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "cdr") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "car") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "symbol-value") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "symbol->string") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "make-symbol") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "symbol?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "string-set!") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "string-ref") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "string-length") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "string?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "make-string") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "vector-ref") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "vector-set!") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "vector-length") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "make-vector") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "vector?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "set-cdr!") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "set-car!") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "cdr") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "car") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "cons") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "pair?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fxremainder") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fxquotient") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fx*") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fx-") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fx+") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fx>=") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fx>") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fx<=") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fx<") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fx=") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "eof-object") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "eof-object?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f6513 0))) (closure () (f6513) (let () (vector-ref f6513 0))))
# emit-begin
#   expr=(begin (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "procedure?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "cdr") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "car") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "symbol-value") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "symbol->string") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "make-symbol") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "symbol?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "string-set!") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "string-ref") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "string-length") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "string?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "make-string") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "vector-ref") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "vector-set!") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "vector-length") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "make-vector") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "vector?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "set-cdr!") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "set-car!") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "cdr") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "car") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "cons") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "pair?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fxremainder") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fxquotient") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fx*") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fx-") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fx+") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fx>=") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fx>") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fx<=") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fx<") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fx=") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "eof-object") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "eof-object?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f6513 0))) (closure () (f6513) (let () (vector-ref f6513 0))))
#   env=((f6513 . 0))
# emit-expr (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "procedure?") (vector-ref f6513 0)))
# emit-expr f6513
# emit-variable-ref
# env=((f6513 . 0))
# var=f6513
    movl 0(%esp), %eax  # stack load f6513
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_39122
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_39122:
    movl %eax, -4(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_39123"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_39123:
# check bounds on vector index
    movl -4(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_39125
    cmp  $0,%eax
    jge _L_39124
_L_39125:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_39124:
    movl %eax, -8(%esp)
# emit-expr (cons ((primitive-ref string->symbol) "procedure?") (vector-ref f6513 0))
# cons arg1=((primitive-ref string->symbol) "procedure?") arg2=(vector-ref f6513 0)
# emit-expr ((primitive-ref string->symbol) "procedure?")
# funcall
#    si   =-12
#    env  = ((f6513 . 0))
#    expr = (funcall (primitive-ref string->symbol) "procedure?")
# emit-expr (primitive-ref string->symbol)
    .extern mrc_string$m$gsymbol
    movl mrc_string$m$gsymbol,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_39126"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_39126":
   movl %eax,  -20(%esp)  # stash funcall-oper in closure slot
# emit-expr "procedure?"
# string literal
    jmp _L_39128
    .align 8,0x90
_L_39127 :
    .int 40
    .ascii "procedure?"
_L_39128:
    movl $_L_39127, %eax
    orl $6, %eax
    mov %eax, -24(%esp)  # arg procedure?
    movl -20(%esp), %edi   # load new closure to %edi
    add $-12, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $12, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    movl %eax, -12(%esp)
# emit-expr (vector-ref f6513 0)
# emit-expr f6513
# emit-variable-ref
# env=((f6513 . 0))
# var=f6513
    movl 0(%esp), %eax  # stack load f6513
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_39129
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_39129:
    movl %eax, -16(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_39130"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_39130:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_39132
    cmp  $0,%eax
    jge _L_39131
_L_39132:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_39131:
    movl -16(%esp), %esi
    movl -1(%eax,%esi), %eax
    movl %eax, 4(%ebp)
    movl -12(%esp), %eax
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    or   $1, %al
    add  $8, %ebp
# cons end
    movl -4(%esp), %ebx
    movl -8(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "cdr") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "car") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "symbol-value") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "symbol->string") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "make-symbol") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "symbol?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "string-set!") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "string-ref") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "string-length") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "string?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "make-string") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "vector-ref") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "vector-set!") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "vector-length") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "make-vector") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "vector?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "set-cdr!") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "set-car!") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "cdr") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "car") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "cons") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "pair?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fxremainder") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fxquotient") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fx*") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fx-") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fx+") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fx>=") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fx>") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fx<=") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fx<") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fx=") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "eof-object") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "eof-object?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f6513 0))) (closure () (f6513) (let () (vector-ref f6513 0))))
# emit-begin
#   expr=(begin (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "cdr") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "car") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "symbol-value") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "symbol->string") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "make-symbol") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "symbol?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "string-set!") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "string-ref") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "string-length") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "string?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "make-string") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "vector-ref") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "vector-set!") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "vector-length") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "make-vector") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "vector?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "set-cdr!") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "set-car!") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "cdr") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "car") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "cons") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "pair?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fxremainder") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fxquotient") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fx*") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fx-") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fx+") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fx>=") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fx>") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fx<=") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fx<") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fx=") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "eof-object") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "eof-object?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f6513 0))) (closure () (f6513) (let () (vector-ref f6513 0))))
#   env=((f6513 . 0))
# emit-expr (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "cdr") (vector-ref f6513 0)))
# emit-expr f6513
# emit-variable-ref
# env=((f6513 . 0))
# var=f6513
    movl 0(%esp), %eax  # stack load f6513
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_39133
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_39133:
    movl %eax, -4(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_39134"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_39134:
# check bounds on vector index
    movl -4(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_39136
    cmp  $0,%eax
    jge _L_39135
_L_39136:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_39135:
    movl %eax, -8(%esp)
# emit-expr (cons ((primitive-ref string->symbol) "cdr") (vector-ref f6513 0))
# cons arg1=((primitive-ref string->symbol) "cdr") arg2=(vector-ref f6513 0)
# emit-expr ((primitive-ref string->symbol) "cdr")
# funcall
#    si   =-12
#    env  = ((f6513 . 0))
#    expr = (funcall (primitive-ref string->symbol) "cdr")
# emit-expr (primitive-ref string->symbol)
    .extern mrc_string$m$gsymbol
    movl mrc_string$m$gsymbol,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_39137"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_39137":
   movl %eax,  -20(%esp)  # stash funcall-oper in closure slot
# emit-expr "cdr"
# string literal
    jmp _L_39139
    .align 8,0x90
_L_39138 :
    .int 12
    .ascii "cdr"
_L_39139:
    movl $_L_39138, %eax
    orl $6, %eax
    mov %eax, -24(%esp)  # arg cdr
    movl -20(%esp), %edi   # load new closure to %edi
    add $-12, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $12, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    movl %eax, -12(%esp)
# emit-expr (vector-ref f6513 0)
# emit-expr f6513
# emit-variable-ref
# env=((f6513 . 0))
# var=f6513
    movl 0(%esp), %eax  # stack load f6513
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_39140
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_39140:
    movl %eax, -16(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_39141"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_39141:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_39143
    cmp  $0,%eax
    jge _L_39142
_L_39143:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_39142:
    movl -16(%esp), %esi
    movl -1(%eax,%esi), %eax
    movl %eax, 4(%ebp)
    movl -12(%esp), %eax
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    or   $1, %al
    add  $8, %ebp
# cons end
    movl -4(%esp), %ebx
    movl -8(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "car") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "symbol-value") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "symbol->string") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "make-symbol") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "symbol?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "string-set!") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "string-ref") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "string-length") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "string?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "make-string") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "vector-ref") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "vector-set!") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "vector-length") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "make-vector") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "vector?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "set-cdr!") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "set-car!") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "cdr") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "car") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "cons") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "pair?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fxremainder") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fxquotient") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fx*") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fx-") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fx+") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fx>=") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fx>") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fx<=") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fx<") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fx=") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "eof-object") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "eof-object?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f6513 0))) (closure () (f6513) (let () (vector-ref f6513 0))))
# emit-begin
#   expr=(begin (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "car") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "symbol-value") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "symbol->string") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "make-symbol") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "symbol?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "string-set!") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "string-ref") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "string-length") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "string?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "make-string") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "vector-ref") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "vector-set!") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "vector-length") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "make-vector") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "vector?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "set-cdr!") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "set-car!") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "cdr") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "car") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "cons") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "pair?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fxremainder") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fxquotient") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fx*") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fx-") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fx+") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fx>=") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fx>") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fx<=") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fx<") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fx=") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "eof-object") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "eof-object?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f6513 0))) (closure () (f6513) (let () (vector-ref f6513 0))))
#   env=((f6513 . 0))
# emit-expr (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "car") (vector-ref f6513 0)))
# emit-expr f6513
# emit-variable-ref
# env=((f6513 . 0))
# var=f6513
    movl 0(%esp), %eax  # stack load f6513
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_39144
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_39144:
    movl %eax, -4(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_39145"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_39145:
# check bounds on vector index
    movl -4(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_39147
    cmp  $0,%eax
    jge _L_39146
_L_39147:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_39146:
    movl %eax, -8(%esp)
# emit-expr (cons ((primitive-ref string->symbol) "car") (vector-ref f6513 0))
# cons arg1=((primitive-ref string->symbol) "car") arg2=(vector-ref f6513 0)
# emit-expr ((primitive-ref string->symbol) "car")
# funcall
#    si   =-12
#    env  = ((f6513 . 0))
#    expr = (funcall (primitive-ref string->symbol) "car")
# emit-expr (primitive-ref string->symbol)
    .extern mrc_string$m$gsymbol
    movl mrc_string$m$gsymbol,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_39148"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_39148":
   movl %eax,  -20(%esp)  # stash funcall-oper in closure slot
# emit-expr "car"
# string literal
    jmp _L_39150
    .align 8,0x90
_L_39149 :
    .int 12
    .ascii "car"
_L_39150:
    movl $_L_39149, %eax
    orl $6, %eax
    mov %eax, -24(%esp)  # arg car
    movl -20(%esp), %edi   # load new closure to %edi
    add $-12, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $12, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    movl %eax, -12(%esp)
# emit-expr (vector-ref f6513 0)
# emit-expr f6513
# emit-variable-ref
# env=((f6513 . 0))
# var=f6513
    movl 0(%esp), %eax  # stack load f6513
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_39151
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_39151:
    movl %eax, -16(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_39152"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_39152:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_39154
    cmp  $0,%eax
    jge _L_39153
_L_39154:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_39153:
    movl -16(%esp), %esi
    movl -1(%eax,%esi), %eax
    movl %eax, 4(%ebp)
    movl -12(%esp), %eax
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    or   $1, %al
    add  $8, %ebp
# cons end
    movl -4(%esp), %ebx
    movl -8(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "symbol-value") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "symbol->string") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "make-symbol") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "symbol?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "string-set!") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "string-ref") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "string-length") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "string?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "make-string") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "vector-ref") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "vector-set!") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "vector-length") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "make-vector") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "vector?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "set-cdr!") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "set-car!") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "cdr") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "car") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "cons") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "pair?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fxremainder") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fxquotient") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fx*") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fx-") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fx+") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fx>=") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fx>") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fx<=") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fx<") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fx=") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "eof-object") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "eof-object?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f6513 0))) (closure () (f6513) (let () (vector-ref f6513 0))))
# emit-begin
#   expr=(begin (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "symbol-value") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "symbol->string") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "make-symbol") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "symbol?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "string-set!") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "string-ref") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "string-length") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "string?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "make-string") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "vector-ref") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "vector-set!") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "vector-length") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "make-vector") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "vector?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "set-cdr!") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "set-car!") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "cdr") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "car") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "cons") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "pair?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fxremainder") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fxquotient") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fx*") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fx-") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fx+") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fx>=") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fx>") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fx<=") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fx<") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fx=") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "eof-object") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "eof-object?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f6513 0))) (closure () (f6513) (let () (vector-ref f6513 0))))
#   env=((f6513 . 0))
# emit-expr (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "symbol-value") (vector-ref f6513 0)))
# emit-expr f6513
# emit-variable-ref
# env=((f6513 . 0))
# var=f6513
    movl 0(%esp), %eax  # stack load f6513
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_39155
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_39155:
    movl %eax, -4(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_39156"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_39156:
# check bounds on vector index
    movl -4(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_39158
    cmp  $0,%eax
    jge _L_39157
_L_39158:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_39157:
    movl %eax, -8(%esp)
# emit-expr (cons ((primitive-ref string->symbol) "symbol-value") (vector-ref f6513 0))
# cons arg1=((primitive-ref string->symbol) "symbol-value") arg2=(vector-ref f6513 0)
# emit-expr ((primitive-ref string->symbol) "symbol-value")
# funcall
#    si   =-12
#    env  = ((f6513 . 0))
#    expr = (funcall (primitive-ref string->symbol) "symbol-value")
# emit-expr (primitive-ref string->symbol)
    .extern mrc_string$m$gsymbol
    movl mrc_string$m$gsymbol,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_39159"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_39159":
   movl %eax,  -20(%esp)  # stash funcall-oper in closure slot
# emit-expr "symbol-value"
# string literal
    jmp _L_39161
    .align 8,0x90
_L_39160 :
    .int 48
    .ascii "symbol-value"
_L_39161:
    movl $_L_39160, %eax
    orl $6, %eax
    mov %eax, -24(%esp)  # arg symbol-value
    movl -20(%esp), %edi   # load new closure to %edi
    add $-12, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $12, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    movl %eax, -12(%esp)
# emit-expr (vector-ref f6513 0)
# emit-expr f6513
# emit-variable-ref
# env=((f6513 . 0))
# var=f6513
    movl 0(%esp), %eax  # stack load f6513
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_39162
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_39162:
    movl %eax, -16(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_39163"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_39163:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_39165
    cmp  $0,%eax
    jge _L_39164
_L_39165:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_39164:
    movl -16(%esp), %esi
    movl -1(%eax,%esi), %eax
    movl %eax, 4(%ebp)
    movl -12(%esp), %eax
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    or   $1, %al
    add  $8, %ebp
# cons end
    movl -4(%esp), %ebx
    movl -8(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "symbol->string") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "make-symbol") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "symbol?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "string-set!") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "string-ref") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "string-length") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "string?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "make-string") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "vector-ref") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "vector-set!") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "vector-length") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "make-vector") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "vector?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "set-cdr!") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "set-car!") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "cdr") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "car") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "cons") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "pair?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fxremainder") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fxquotient") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fx*") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fx-") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fx+") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fx>=") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fx>") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fx<=") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fx<") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fx=") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "eof-object") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "eof-object?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f6513 0))) (closure () (f6513) (let () (vector-ref f6513 0))))
# emit-begin
#   expr=(begin (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "symbol->string") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "make-symbol") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "symbol?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "string-set!") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "string-ref") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "string-length") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "string?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "make-string") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "vector-ref") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "vector-set!") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "vector-length") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "make-vector") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "vector?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "set-cdr!") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "set-car!") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "cdr") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "car") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "cons") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "pair?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fxremainder") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fxquotient") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fx*") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fx-") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fx+") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fx>=") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fx>") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fx<=") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fx<") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fx=") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "eof-object") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "eof-object?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f6513 0))) (closure () (f6513) (let () (vector-ref f6513 0))))
#   env=((f6513 . 0))
# emit-expr (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "symbol->string") (vector-ref f6513 0)))
# emit-expr f6513
# emit-variable-ref
# env=((f6513 . 0))
# var=f6513
    movl 0(%esp), %eax  # stack load f6513
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_39166
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_39166:
    movl %eax, -4(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_39167"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_39167:
# check bounds on vector index
    movl -4(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_39169
    cmp  $0,%eax
    jge _L_39168
_L_39169:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_39168:
    movl %eax, -8(%esp)
# emit-expr (cons ((primitive-ref string->symbol) "symbol->string") (vector-ref f6513 0))
# cons arg1=((primitive-ref string->symbol) "symbol->string") arg2=(vector-ref f6513 0)
# emit-expr ((primitive-ref string->symbol) "symbol->string")
# funcall
#    si   =-12
#    env  = ((f6513 . 0))
#    expr = (funcall (primitive-ref string->symbol) "symbol->string")
# emit-expr (primitive-ref string->symbol)
    .extern mrc_string$m$gsymbol
    movl mrc_string$m$gsymbol,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_39170"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_39170":
   movl %eax,  -20(%esp)  # stash funcall-oper in closure slot
# emit-expr "symbol->string"
# string literal
    jmp _L_39172
    .align 8,0x90
_L_39171 :
    .int 56
    .ascii "symbol->string"
_L_39172:
    movl $_L_39171, %eax
    orl $6, %eax
    mov %eax, -24(%esp)  # arg symbol->string
    movl -20(%esp), %edi   # load new closure to %edi
    add $-12, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $12, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    movl %eax, -12(%esp)
# emit-expr (vector-ref f6513 0)
# emit-expr f6513
# emit-variable-ref
# env=((f6513 . 0))
# var=f6513
    movl 0(%esp), %eax  # stack load f6513
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_39173
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_39173:
    movl %eax, -16(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_39174"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_39174:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_39176
    cmp  $0,%eax
    jge _L_39175
_L_39176:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_39175:
    movl -16(%esp), %esi
    movl -1(%eax,%esi), %eax
    movl %eax, 4(%ebp)
    movl -12(%esp), %eax
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    or   $1, %al
    add  $8, %ebp
# cons end
    movl -4(%esp), %ebx
    movl -8(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "make-symbol") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "symbol?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "string-set!") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "string-ref") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "string-length") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "string?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "make-string") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "vector-ref") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "vector-set!") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "vector-length") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "make-vector") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "vector?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "set-cdr!") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "set-car!") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "cdr") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "car") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "cons") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "pair?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fxremainder") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fxquotient") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fx*") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fx-") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fx+") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fx>=") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fx>") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fx<=") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fx<") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fx=") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "eof-object") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "eof-object?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f6513 0))) (closure () (f6513) (let () (vector-ref f6513 0))))
# emit-begin
#   expr=(begin (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "make-symbol") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "symbol?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "string-set!") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "string-ref") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "string-length") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "string?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "make-string") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "vector-ref") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "vector-set!") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "vector-length") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "make-vector") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "vector?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "set-cdr!") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "set-car!") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "cdr") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "car") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "cons") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "pair?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fxremainder") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fxquotient") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fx*") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fx-") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fx+") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fx>=") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fx>") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fx<=") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fx<") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fx=") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "eof-object") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "eof-object?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f6513 0))) (closure () (f6513) (let () (vector-ref f6513 0))))
#   env=((f6513 . 0))
# emit-expr (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "make-symbol") (vector-ref f6513 0)))
# emit-expr f6513
# emit-variable-ref
# env=((f6513 . 0))
# var=f6513
    movl 0(%esp), %eax  # stack load f6513
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_39177
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_39177:
    movl %eax, -4(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_39178"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_39178:
# check bounds on vector index
    movl -4(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_39180
    cmp  $0,%eax
    jge _L_39179
_L_39180:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_39179:
    movl %eax, -8(%esp)
# emit-expr (cons ((primitive-ref string->symbol) "make-symbol") (vector-ref f6513 0))
# cons arg1=((primitive-ref string->symbol) "make-symbol") arg2=(vector-ref f6513 0)
# emit-expr ((primitive-ref string->symbol) "make-symbol")
# funcall
#    si   =-12
#    env  = ((f6513 . 0))
#    expr = (funcall (primitive-ref string->symbol) "make-symbol")
# emit-expr (primitive-ref string->symbol)
    .extern mrc_string$m$gsymbol
    movl mrc_string$m$gsymbol,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_39181"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_39181":
   movl %eax,  -20(%esp)  # stash funcall-oper in closure slot
# emit-expr "make-symbol"
# string literal
    jmp _L_39183
    .align 8,0x90
_L_39182 :
    .int 44
    .ascii "make-symbol"
_L_39183:
    movl $_L_39182, %eax
    orl $6, %eax
    mov %eax, -24(%esp)  # arg make-symbol
    movl -20(%esp), %edi   # load new closure to %edi
    add $-12, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $12, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    movl %eax, -12(%esp)
# emit-expr (vector-ref f6513 0)
# emit-expr f6513
# emit-variable-ref
# env=((f6513 . 0))
# var=f6513
    movl 0(%esp), %eax  # stack load f6513
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_39184
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_39184:
    movl %eax, -16(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_39185"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_39185:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_39187
    cmp  $0,%eax
    jge _L_39186
_L_39187:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_39186:
    movl -16(%esp), %esi
    movl -1(%eax,%esi), %eax
    movl %eax, 4(%ebp)
    movl -12(%esp), %eax
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    or   $1, %al
    add  $8, %ebp
# cons end
    movl -4(%esp), %ebx
    movl -8(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "symbol?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "string-set!") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "string-ref") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "string-length") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "string?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "make-string") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "vector-ref") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "vector-set!") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "vector-length") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "make-vector") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "vector?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "set-cdr!") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "set-car!") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "cdr") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "car") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "cons") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "pair?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fxremainder") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fxquotient") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fx*") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fx-") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fx+") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fx>=") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fx>") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fx<=") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fx<") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fx=") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "eof-object") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "eof-object?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f6513 0))) (closure () (f6513) (let () (vector-ref f6513 0))))
# emit-begin
#   expr=(begin (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "symbol?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "string-set!") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "string-ref") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "string-length") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "string?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "make-string") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "vector-ref") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "vector-set!") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "vector-length") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "make-vector") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "vector?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "set-cdr!") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "set-car!") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "cdr") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "car") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "cons") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "pair?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fxremainder") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fxquotient") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fx*") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fx-") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fx+") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fx>=") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fx>") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fx<=") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fx<") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fx=") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "eof-object") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "eof-object?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f6513 0))) (closure () (f6513) (let () (vector-ref f6513 0))))
#   env=((f6513 . 0))
# emit-expr (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "symbol?") (vector-ref f6513 0)))
# emit-expr f6513
# emit-variable-ref
# env=((f6513 . 0))
# var=f6513
    movl 0(%esp), %eax  # stack load f6513
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_39188
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_39188:
    movl %eax, -4(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_39189"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_39189:
# check bounds on vector index
    movl -4(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_39191
    cmp  $0,%eax
    jge _L_39190
_L_39191:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_39190:
    movl %eax, -8(%esp)
# emit-expr (cons ((primitive-ref string->symbol) "symbol?") (vector-ref f6513 0))
# cons arg1=((primitive-ref string->symbol) "symbol?") arg2=(vector-ref f6513 0)
# emit-expr ((primitive-ref string->symbol) "symbol?")
# funcall
#    si   =-12
#    env  = ((f6513 . 0))
#    expr = (funcall (primitive-ref string->symbol) "symbol?")
# emit-expr (primitive-ref string->symbol)
    .extern mrc_string$m$gsymbol
    movl mrc_string$m$gsymbol,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_39192"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_39192":
   movl %eax,  -20(%esp)  # stash funcall-oper in closure slot
# emit-expr "symbol?"
# string literal
    jmp _L_39194
    .align 8,0x90
_L_39193 :
    .int 28
    .ascii "symbol?"
_L_39194:
    movl $_L_39193, %eax
    orl $6, %eax
    mov %eax, -24(%esp)  # arg symbol?
    movl -20(%esp), %edi   # load new closure to %edi
    add $-12, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $12, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    movl %eax, -12(%esp)
# emit-expr (vector-ref f6513 0)
# emit-expr f6513
# emit-variable-ref
# env=((f6513 . 0))
# var=f6513
    movl 0(%esp), %eax  # stack load f6513
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_39195
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_39195:
    movl %eax, -16(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_39196"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_39196:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_39198
    cmp  $0,%eax
    jge _L_39197
_L_39198:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_39197:
    movl -16(%esp), %esi
    movl -1(%eax,%esi), %eax
    movl %eax, 4(%ebp)
    movl -12(%esp), %eax
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    or   $1, %al
    add  $8, %ebp
# cons end
    movl -4(%esp), %ebx
    movl -8(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "string-set!") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "string-ref") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "string-length") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "string?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "make-string") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "vector-ref") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "vector-set!") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "vector-length") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "make-vector") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "vector?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "set-cdr!") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "set-car!") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "cdr") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "car") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "cons") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "pair?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fxremainder") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fxquotient") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fx*") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fx-") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fx+") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fx>=") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fx>") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fx<=") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fx<") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fx=") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "eof-object") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "eof-object?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f6513 0))) (closure () (f6513) (let () (vector-ref f6513 0))))
# emit-begin
#   expr=(begin (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "string-set!") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "string-ref") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "string-length") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "string?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "make-string") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "vector-ref") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "vector-set!") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "vector-length") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "make-vector") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "vector?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "set-cdr!") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "set-car!") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "cdr") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "car") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "cons") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "pair?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fxremainder") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fxquotient") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fx*") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fx-") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fx+") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fx>=") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fx>") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fx<=") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fx<") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fx=") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "eof-object") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "eof-object?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f6513 0))) (closure () (f6513) (let () (vector-ref f6513 0))))
#   env=((f6513 . 0))
# emit-expr (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "string-set!") (vector-ref f6513 0)))
# emit-expr f6513
# emit-variable-ref
# env=((f6513 . 0))
# var=f6513
    movl 0(%esp), %eax  # stack load f6513
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_39199
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_39199:
    movl %eax, -4(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_39200"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_39200:
# check bounds on vector index
    movl -4(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_39202
    cmp  $0,%eax
    jge _L_39201
_L_39202:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_39201:
    movl %eax, -8(%esp)
# emit-expr (cons ((primitive-ref string->symbol) "string-set!") (vector-ref f6513 0))
# cons arg1=((primitive-ref string->symbol) "string-set!") arg2=(vector-ref f6513 0)
# emit-expr ((primitive-ref string->symbol) "string-set!")
# funcall
#    si   =-12
#    env  = ((f6513 . 0))
#    expr = (funcall (primitive-ref string->symbol) "string-set!")
# emit-expr (primitive-ref string->symbol)
    .extern mrc_string$m$gsymbol
    movl mrc_string$m$gsymbol,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_39203"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_39203":
   movl %eax,  -20(%esp)  # stash funcall-oper in closure slot
# emit-expr "string-set!"
# string literal
    jmp _L_39205
    .align 8,0x90
_L_39204 :
    .int 44
    .ascii "string-set!"
_L_39205:
    movl $_L_39204, %eax
    orl $6, %eax
    mov %eax, -24(%esp)  # arg string-set!
    movl -20(%esp), %edi   # load new closure to %edi
    add $-12, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $12, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    movl %eax, -12(%esp)
# emit-expr (vector-ref f6513 0)
# emit-expr f6513
# emit-variable-ref
# env=((f6513 . 0))
# var=f6513
    movl 0(%esp), %eax  # stack load f6513
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_39206
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_39206:
    movl %eax, -16(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_39207"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_39207:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_39209
    cmp  $0,%eax
    jge _L_39208
_L_39209:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_39208:
    movl -16(%esp), %esi
    movl -1(%eax,%esi), %eax
    movl %eax, 4(%ebp)
    movl -12(%esp), %eax
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    or   $1, %al
    add  $8, %ebp
# cons end
    movl -4(%esp), %ebx
    movl -8(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "string-ref") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "string-length") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "string?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "make-string") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "vector-ref") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "vector-set!") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "vector-length") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "make-vector") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "vector?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "set-cdr!") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "set-car!") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "cdr") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "car") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "cons") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "pair?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fxremainder") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fxquotient") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fx*") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fx-") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fx+") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fx>=") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fx>") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fx<=") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fx<") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fx=") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "eof-object") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "eof-object?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f6513 0))) (closure () (f6513) (let () (vector-ref f6513 0))))
# emit-begin
#   expr=(begin (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "string-ref") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "string-length") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "string?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "make-string") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "vector-ref") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "vector-set!") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "vector-length") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "make-vector") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "vector?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "set-cdr!") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "set-car!") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "cdr") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "car") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "cons") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "pair?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fxremainder") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fxquotient") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fx*") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fx-") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fx+") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fx>=") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fx>") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fx<=") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fx<") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fx=") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "eof-object") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "eof-object?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f6513 0))) (closure () (f6513) (let () (vector-ref f6513 0))))
#   env=((f6513 . 0))
# emit-expr (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "string-ref") (vector-ref f6513 0)))
# emit-expr f6513
# emit-variable-ref
# env=((f6513 . 0))
# var=f6513
    movl 0(%esp), %eax  # stack load f6513
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_39210
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_39210:
    movl %eax, -4(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_39211"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_39211:
# check bounds on vector index
    movl -4(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_39213
    cmp  $0,%eax
    jge _L_39212
_L_39213:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_39212:
    movl %eax, -8(%esp)
# emit-expr (cons ((primitive-ref string->symbol) "string-ref") (vector-ref f6513 0))
# cons arg1=((primitive-ref string->symbol) "string-ref") arg2=(vector-ref f6513 0)
# emit-expr ((primitive-ref string->symbol) "string-ref")
# funcall
#    si   =-12
#    env  = ((f6513 . 0))
#    expr = (funcall (primitive-ref string->symbol) "string-ref")
# emit-expr (primitive-ref string->symbol)
    .extern mrc_string$m$gsymbol
    movl mrc_string$m$gsymbol,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_39214"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_39214":
   movl %eax,  -20(%esp)  # stash funcall-oper in closure slot
# emit-expr "string-ref"
# string literal
    jmp _L_39216
    .align 8,0x90
_L_39215 :
    .int 40
    .ascii "string-ref"
_L_39216:
    movl $_L_39215, %eax
    orl $6, %eax
    mov %eax, -24(%esp)  # arg string-ref
    movl -20(%esp), %edi   # load new closure to %edi
    add $-12, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $12, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    movl %eax, -12(%esp)
# emit-expr (vector-ref f6513 0)
# emit-expr f6513
# emit-variable-ref
# env=((f6513 . 0))
# var=f6513
    movl 0(%esp), %eax  # stack load f6513
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_39217
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_39217:
    movl %eax, -16(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_39218"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_39218:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_39220
    cmp  $0,%eax
    jge _L_39219
_L_39220:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_39219:
    movl -16(%esp), %esi
    movl -1(%eax,%esi), %eax
    movl %eax, 4(%ebp)
    movl -12(%esp), %eax
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    or   $1, %al
    add  $8, %ebp
# cons end
    movl -4(%esp), %ebx
    movl -8(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "string-length") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "string?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "make-string") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "vector-ref") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "vector-set!") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "vector-length") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "make-vector") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "vector?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "set-cdr!") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "set-car!") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "cdr") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "car") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "cons") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "pair?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fxremainder") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fxquotient") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fx*") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fx-") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fx+") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fx>=") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fx>") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fx<=") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fx<") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fx=") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "eof-object") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "eof-object?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f6513 0))) (closure () (f6513) (let () (vector-ref f6513 0))))
# emit-begin
#   expr=(begin (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "string-length") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "string?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "make-string") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "vector-ref") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "vector-set!") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "vector-length") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "make-vector") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "vector?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "set-cdr!") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "set-car!") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "cdr") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "car") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "cons") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "pair?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fxremainder") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fxquotient") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fx*") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fx-") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fx+") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fx>=") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fx>") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fx<=") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fx<") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fx=") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "eof-object") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "eof-object?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f6513 0))) (closure () (f6513) (let () (vector-ref f6513 0))))
#   env=((f6513 . 0))
# emit-expr (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "string-length") (vector-ref f6513 0)))
# emit-expr f6513
# emit-variable-ref
# env=((f6513 . 0))
# var=f6513
    movl 0(%esp), %eax  # stack load f6513
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_39221
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_39221:
    movl %eax, -4(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_39222"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_39222:
# check bounds on vector index
    movl -4(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_39224
    cmp  $0,%eax
    jge _L_39223
_L_39224:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_39223:
    movl %eax, -8(%esp)
# emit-expr (cons ((primitive-ref string->symbol) "string-length") (vector-ref f6513 0))
# cons arg1=((primitive-ref string->symbol) "string-length") arg2=(vector-ref f6513 0)
# emit-expr ((primitive-ref string->symbol) "string-length")
# funcall
#    si   =-12
#    env  = ((f6513 . 0))
#    expr = (funcall (primitive-ref string->symbol) "string-length")
# emit-expr (primitive-ref string->symbol)
    .extern mrc_string$m$gsymbol
    movl mrc_string$m$gsymbol,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_39225"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_39225":
   movl %eax,  -20(%esp)  # stash funcall-oper in closure slot
# emit-expr "string-length"
# string literal
    jmp _L_39227
    .align 8,0x90
_L_39226 :
    .int 52
    .ascii "string-length"
_L_39227:
    movl $_L_39226, %eax
    orl $6, %eax
    mov %eax, -24(%esp)  # arg string-length
    movl -20(%esp), %edi   # load new closure to %edi
    add $-12, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $12, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    movl %eax, -12(%esp)
# emit-expr (vector-ref f6513 0)
# emit-expr f6513
# emit-variable-ref
# env=((f6513 . 0))
# var=f6513
    movl 0(%esp), %eax  # stack load f6513
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_39228
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_39228:
    movl %eax, -16(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_39229"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_39229:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_39231
    cmp  $0,%eax
    jge _L_39230
_L_39231:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_39230:
    movl -16(%esp), %esi
    movl -1(%eax,%esi), %eax
    movl %eax, 4(%ebp)
    movl -12(%esp), %eax
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    or   $1, %al
    add  $8, %ebp
# cons end
    movl -4(%esp), %ebx
    movl -8(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "string?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "make-string") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "vector-ref") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "vector-set!") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "vector-length") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "make-vector") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "vector?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "set-cdr!") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "set-car!") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "cdr") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "car") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "cons") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "pair?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fxremainder") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fxquotient") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fx*") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fx-") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fx+") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fx>=") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fx>") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fx<=") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fx<") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fx=") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "eof-object") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "eof-object?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f6513 0))) (closure () (f6513) (let () (vector-ref f6513 0))))
# emit-begin
#   expr=(begin (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "string?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "make-string") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "vector-ref") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "vector-set!") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "vector-length") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "make-vector") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "vector?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "set-cdr!") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "set-car!") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "cdr") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "car") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "cons") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "pair?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fxremainder") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fxquotient") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fx*") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fx-") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fx+") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fx>=") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fx>") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fx<=") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fx<") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fx=") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "eof-object") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "eof-object?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f6513 0))) (closure () (f6513) (let () (vector-ref f6513 0))))
#   env=((f6513 . 0))
# emit-expr (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "string?") (vector-ref f6513 0)))
# emit-expr f6513
# emit-variable-ref
# env=((f6513 . 0))
# var=f6513
    movl 0(%esp), %eax  # stack load f6513
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_39232
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_39232:
    movl %eax, -4(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_39233"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_39233:
# check bounds on vector index
    movl -4(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_39235
    cmp  $0,%eax
    jge _L_39234
_L_39235:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_39234:
    movl %eax, -8(%esp)
# emit-expr (cons ((primitive-ref string->symbol) "string?") (vector-ref f6513 0))
# cons arg1=((primitive-ref string->symbol) "string?") arg2=(vector-ref f6513 0)
# emit-expr ((primitive-ref string->symbol) "string?")
# funcall
#    si   =-12
#    env  = ((f6513 . 0))
#    expr = (funcall (primitive-ref string->symbol) "string?")
# emit-expr (primitive-ref string->symbol)
    .extern mrc_string$m$gsymbol
    movl mrc_string$m$gsymbol,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_39236"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_39236":
   movl %eax,  -20(%esp)  # stash funcall-oper in closure slot
# emit-expr "string?"
# string literal
    jmp _L_39238
    .align 8,0x90
_L_39237 :
    .int 28
    .ascii "string?"
_L_39238:
    movl $_L_39237, %eax
    orl $6, %eax
    mov %eax, -24(%esp)  # arg string?
    movl -20(%esp), %edi   # load new closure to %edi
    add $-12, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $12, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    movl %eax, -12(%esp)
# emit-expr (vector-ref f6513 0)
# emit-expr f6513
# emit-variable-ref
# env=((f6513 . 0))
# var=f6513
    movl 0(%esp), %eax  # stack load f6513
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_39239
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_39239:
    movl %eax, -16(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_39240"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_39240:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_39242
    cmp  $0,%eax
    jge _L_39241
_L_39242:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_39241:
    movl -16(%esp), %esi
    movl -1(%eax,%esi), %eax
    movl %eax, 4(%ebp)
    movl -12(%esp), %eax
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    or   $1, %al
    add  $8, %ebp
# cons end
    movl -4(%esp), %ebx
    movl -8(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "make-string") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "vector-ref") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "vector-set!") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "vector-length") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "make-vector") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "vector?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "set-cdr!") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "set-car!") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "cdr") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "car") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "cons") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "pair?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fxremainder") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fxquotient") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fx*") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fx-") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fx+") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fx>=") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fx>") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fx<=") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fx<") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fx=") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "eof-object") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "eof-object?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f6513 0))) (closure () (f6513) (let () (vector-ref f6513 0))))
# emit-begin
#   expr=(begin (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "make-string") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "vector-ref") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "vector-set!") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "vector-length") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "make-vector") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "vector?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "set-cdr!") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "set-car!") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "cdr") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "car") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "cons") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "pair?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fxremainder") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fxquotient") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fx*") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fx-") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fx+") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fx>=") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fx>") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fx<=") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fx<") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fx=") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "eof-object") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "eof-object?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f6513 0))) (closure () (f6513) (let () (vector-ref f6513 0))))
#   env=((f6513 . 0))
# emit-expr (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "make-string") (vector-ref f6513 0)))
# emit-expr f6513
# emit-variable-ref
# env=((f6513 . 0))
# var=f6513
    movl 0(%esp), %eax  # stack load f6513
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_39243
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_39243:
    movl %eax, -4(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_39244"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_39244:
# check bounds on vector index
    movl -4(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_39246
    cmp  $0,%eax
    jge _L_39245
_L_39246:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_39245:
    movl %eax, -8(%esp)
# emit-expr (cons ((primitive-ref string->symbol) "make-string") (vector-ref f6513 0))
# cons arg1=((primitive-ref string->symbol) "make-string") arg2=(vector-ref f6513 0)
# emit-expr ((primitive-ref string->symbol) "make-string")
# funcall
#    si   =-12
#    env  = ((f6513 . 0))
#    expr = (funcall (primitive-ref string->symbol) "make-string")
# emit-expr (primitive-ref string->symbol)
    .extern mrc_string$m$gsymbol
    movl mrc_string$m$gsymbol,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_39247"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_39247":
   movl %eax,  -20(%esp)  # stash funcall-oper in closure slot
# emit-expr "make-string"
# string literal
    jmp _L_39249
    .align 8,0x90
_L_39248 :
    .int 44
    .ascii "make-string"
_L_39249:
    movl $_L_39248, %eax
    orl $6, %eax
    mov %eax, -24(%esp)  # arg make-string
    movl -20(%esp), %edi   # load new closure to %edi
    add $-12, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $12, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    movl %eax, -12(%esp)
# emit-expr (vector-ref f6513 0)
# emit-expr f6513
# emit-variable-ref
# env=((f6513 . 0))
# var=f6513
    movl 0(%esp), %eax  # stack load f6513
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_39250
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_39250:
    movl %eax, -16(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_39251"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_39251:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_39253
    cmp  $0,%eax
    jge _L_39252
_L_39253:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_39252:
    movl -16(%esp), %esi
    movl -1(%eax,%esi), %eax
    movl %eax, 4(%ebp)
    movl -12(%esp), %eax
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    or   $1, %al
    add  $8, %ebp
# cons end
    movl -4(%esp), %ebx
    movl -8(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "vector-ref") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "vector-set!") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "vector-length") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "make-vector") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "vector?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "set-cdr!") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "set-car!") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "cdr") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "car") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "cons") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "pair?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fxremainder") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fxquotient") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fx*") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fx-") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fx+") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fx>=") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fx>") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fx<=") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fx<") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fx=") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "eof-object") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "eof-object?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f6513 0))) (closure () (f6513) (let () (vector-ref f6513 0))))
# emit-begin
#   expr=(begin (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "vector-ref") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "vector-set!") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "vector-length") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "make-vector") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "vector?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "set-cdr!") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "set-car!") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "cdr") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "car") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "cons") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "pair?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fxremainder") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fxquotient") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fx*") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fx-") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fx+") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fx>=") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fx>") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fx<=") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fx<") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fx=") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "eof-object") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "eof-object?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f6513 0))) (closure () (f6513) (let () (vector-ref f6513 0))))
#   env=((f6513 . 0))
# emit-expr (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "vector-ref") (vector-ref f6513 0)))
# emit-expr f6513
# emit-variable-ref
# env=((f6513 . 0))
# var=f6513
    movl 0(%esp), %eax  # stack load f6513
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_39254
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_39254:
    movl %eax, -4(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_39255"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_39255:
# check bounds on vector index
    movl -4(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_39257
    cmp  $0,%eax
    jge _L_39256
_L_39257:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_39256:
    movl %eax, -8(%esp)
# emit-expr (cons ((primitive-ref string->symbol) "vector-ref") (vector-ref f6513 0))
# cons arg1=((primitive-ref string->symbol) "vector-ref") arg2=(vector-ref f6513 0)
# emit-expr ((primitive-ref string->symbol) "vector-ref")
# funcall
#    si   =-12
#    env  = ((f6513 . 0))
#    expr = (funcall (primitive-ref string->symbol) "vector-ref")
# emit-expr (primitive-ref string->symbol)
    .extern mrc_string$m$gsymbol
    movl mrc_string$m$gsymbol,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_39258"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_39258":
   movl %eax,  -20(%esp)  # stash funcall-oper in closure slot
# emit-expr "vector-ref"
# string literal
    jmp _L_39260
    .align 8,0x90
_L_39259 :
    .int 40
    .ascii "vector-ref"
_L_39260:
    movl $_L_39259, %eax
    orl $6, %eax
    mov %eax, -24(%esp)  # arg vector-ref
    movl -20(%esp), %edi   # load new closure to %edi
    add $-12, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $12, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    movl %eax, -12(%esp)
# emit-expr (vector-ref f6513 0)
# emit-expr f6513
# emit-variable-ref
# env=((f6513 . 0))
# var=f6513
    movl 0(%esp), %eax  # stack load f6513
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_39261
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_39261:
    movl %eax, -16(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_39262"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_39262:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_39264
    cmp  $0,%eax
    jge _L_39263
_L_39264:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_39263:
    movl -16(%esp), %esi
    movl -1(%eax,%esi), %eax
    movl %eax, 4(%ebp)
    movl -12(%esp), %eax
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    or   $1, %al
    add  $8, %ebp
# cons end
    movl -4(%esp), %ebx
    movl -8(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "vector-set!") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "vector-length") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "make-vector") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "vector?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "set-cdr!") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "set-car!") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "cdr") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "car") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "cons") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "pair?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fxremainder") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fxquotient") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fx*") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fx-") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fx+") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fx>=") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fx>") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fx<=") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fx<") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fx=") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "eof-object") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "eof-object?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f6513 0))) (closure () (f6513) (let () (vector-ref f6513 0))))
# emit-begin
#   expr=(begin (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "vector-set!") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "vector-length") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "make-vector") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "vector?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "set-cdr!") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "set-car!") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "cdr") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "car") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "cons") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "pair?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fxremainder") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fxquotient") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fx*") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fx-") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fx+") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fx>=") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fx>") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fx<=") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fx<") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fx=") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "eof-object") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "eof-object?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f6513 0))) (closure () (f6513) (let () (vector-ref f6513 0))))
#   env=((f6513 . 0))
# emit-expr (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "vector-set!") (vector-ref f6513 0)))
# emit-expr f6513
# emit-variable-ref
# env=((f6513 . 0))
# var=f6513
    movl 0(%esp), %eax  # stack load f6513
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_39265
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_39265:
    movl %eax, -4(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_39266"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_39266:
# check bounds on vector index
    movl -4(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_39268
    cmp  $0,%eax
    jge _L_39267
_L_39268:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_39267:
    movl %eax, -8(%esp)
# emit-expr (cons ((primitive-ref string->symbol) "vector-set!") (vector-ref f6513 0))
# cons arg1=((primitive-ref string->symbol) "vector-set!") arg2=(vector-ref f6513 0)
# emit-expr ((primitive-ref string->symbol) "vector-set!")
# funcall
#    si   =-12
#    env  = ((f6513 . 0))
#    expr = (funcall (primitive-ref string->symbol) "vector-set!")
# emit-expr (primitive-ref string->symbol)
    .extern mrc_string$m$gsymbol
    movl mrc_string$m$gsymbol,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_39269"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_39269":
   movl %eax,  -20(%esp)  # stash funcall-oper in closure slot
# emit-expr "vector-set!"
# string literal
    jmp _L_39271
    .align 8,0x90
_L_39270 :
    .int 44
    .ascii "vector-set!"
_L_39271:
    movl $_L_39270, %eax
    orl $6, %eax
    mov %eax, -24(%esp)  # arg vector-set!
    movl -20(%esp), %edi   # load new closure to %edi
    add $-12, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $12, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    movl %eax, -12(%esp)
# emit-expr (vector-ref f6513 0)
# emit-expr f6513
# emit-variable-ref
# env=((f6513 . 0))
# var=f6513
    movl 0(%esp), %eax  # stack load f6513
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_39272
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_39272:
    movl %eax, -16(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_39273"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_39273:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_39275
    cmp  $0,%eax
    jge _L_39274
_L_39275:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_39274:
    movl -16(%esp), %esi
    movl -1(%eax,%esi), %eax
    movl %eax, 4(%ebp)
    movl -12(%esp), %eax
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    or   $1, %al
    add  $8, %ebp
# cons end
    movl -4(%esp), %ebx
    movl -8(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "vector-length") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "make-vector") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "vector?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "set-cdr!") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "set-car!") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "cdr") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "car") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "cons") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "pair?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fxremainder") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fxquotient") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fx*") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fx-") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fx+") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fx>=") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fx>") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fx<=") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fx<") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fx=") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "eof-object") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "eof-object?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f6513 0))) (closure () (f6513) (let () (vector-ref f6513 0))))
# emit-begin
#   expr=(begin (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "vector-length") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "make-vector") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "vector?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "set-cdr!") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "set-car!") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "cdr") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "car") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "cons") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "pair?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fxremainder") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fxquotient") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fx*") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fx-") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fx+") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fx>=") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fx>") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fx<=") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fx<") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fx=") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "eof-object") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "eof-object?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f6513 0))) (closure () (f6513) (let () (vector-ref f6513 0))))
#   env=((f6513 . 0))
# emit-expr (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "vector-length") (vector-ref f6513 0)))
# emit-expr f6513
# emit-variable-ref
# env=((f6513 . 0))
# var=f6513
    movl 0(%esp), %eax  # stack load f6513
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_39276
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_39276:
    movl %eax, -4(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_39277"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_39277:
# check bounds on vector index
    movl -4(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_39279
    cmp  $0,%eax
    jge _L_39278
_L_39279:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_39278:
    movl %eax, -8(%esp)
# emit-expr (cons ((primitive-ref string->symbol) "vector-length") (vector-ref f6513 0))
# cons arg1=((primitive-ref string->symbol) "vector-length") arg2=(vector-ref f6513 0)
# emit-expr ((primitive-ref string->symbol) "vector-length")
# funcall
#    si   =-12
#    env  = ((f6513 . 0))
#    expr = (funcall (primitive-ref string->symbol) "vector-length")
# emit-expr (primitive-ref string->symbol)
    .extern mrc_string$m$gsymbol
    movl mrc_string$m$gsymbol,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_39280"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_39280":
   movl %eax,  -20(%esp)  # stash funcall-oper in closure slot
# emit-expr "vector-length"
# string literal
    jmp _L_39282
    .align 8,0x90
_L_39281 :
    .int 52
    .ascii "vector-length"
_L_39282:
    movl $_L_39281, %eax
    orl $6, %eax
    mov %eax, -24(%esp)  # arg vector-length
    movl -20(%esp), %edi   # load new closure to %edi
    add $-12, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $12, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    movl %eax, -12(%esp)
# emit-expr (vector-ref f6513 0)
# emit-expr f6513
# emit-variable-ref
# env=((f6513 . 0))
# var=f6513
    movl 0(%esp), %eax  # stack load f6513
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_39283
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_39283:
    movl %eax, -16(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_39284"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_39284:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_39286
    cmp  $0,%eax
    jge _L_39285
_L_39286:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_39285:
    movl -16(%esp), %esi
    movl -1(%eax,%esi), %eax
    movl %eax, 4(%ebp)
    movl -12(%esp), %eax
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    or   $1, %al
    add  $8, %ebp
# cons end
    movl -4(%esp), %ebx
    movl -8(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "make-vector") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "vector?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "set-cdr!") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "set-car!") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "cdr") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "car") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "cons") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "pair?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fxremainder") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fxquotient") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fx*") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fx-") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fx+") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fx>=") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fx>") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fx<=") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fx<") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fx=") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "eof-object") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "eof-object?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f6513 0))) (closure () (f6513) (let () (vector-ref f6513 0))))
# emit-begin
#   expr=(begin (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "make-vector") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "vector?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "set-cdr!") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "set-car!") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "cdr") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "car") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "cons") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "pair?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fxremainder") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fxquotient") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fx*") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fx-") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fx+") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fx>=") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fx>") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fx<=") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fx<") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fx=") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "eof-object") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "eof-object?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f6513 0))) (closure () (f6513) (let () (vector-ref f6513 0))))
#   env=((f6513 . 0))
# emit-expr (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "make-vector") (vector-ref f6513 0)))
# emit-expr f6513
# emit-variable-ref
# env=((f6513 . 0))
# var=f6513
    movl 0(%esp), %eax  # stack load f6513
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_39287
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_39287:
    movl %eax, -4(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_39288"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_39288:
# check bounds on vector index
    movl -4(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_39290
    cmp  $0,%eax
    jge _L_39289
_L_39290:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_39289:
    movl %eax, -8(%esp)
# emit-expr (cons ((primitive-ref string->symbol) "make-vector") (vector-ref f6513 0))
# cons arg1=((primitive-ref string->symbol) "make-vector") arg2=(vector-ref f6513 0)
# emit-expr ((primitive-ref string->symbol) "make-vector")
# funcall
#    si   =-12
#    env  = ((f6513 . 0))
#    expr = (funcall (primitive-ref string->symbol) "make-vector")
# emit-expr (primitive-ref string->symbol)
    .extern mrc_string$m$gsymbol
    movl mrc_string$m$gsymbol,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_39291"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_39291":
   movl %eax,  -20(%esp)  # stash funcall-oper in closure slot
# emit-expr "make-vector"
# string literal
    jmp _L_39293
    .align 8,0x90
_L_39292 :
    .int 44
    .ascii "make-vector"
_L_39293:
    movl $_L_39292, %eax
    orl $6, %eax
    mov %eax, -24(%esp)  # arg make-vector
    movl -20(%esp), %edi   # load new closure to %edi
    add $-12, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $12, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    movl %eax, -12(%esp)
# emit-expr (vector-ref f6513 0)
# emit-expr f6513
# emit-variable-ref
# env=((f6513 . 0))
# var=f6513
    movl 0(%esp), %eax  # stack load f6513
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_39294
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_39294:
    movl %eax, -16(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_39295"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_39295:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_39297
    cmp  $0,%eax
    jge _L_39296
_L_39297:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_39296:
    movl -16(%esp), %esi
    movl -1(%eax,%esi), %eax
    movl %eax, 4(%ebp)
    movl -12(%esp), %eax
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    or   $1, %al
    add  $8, %ebp
# cons end
    movl -4(%esp), %ebx
    movl -8(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "vector?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "set-cdr!") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "set-car!") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "cdr") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "car") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "cons") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "pair?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fxremainder") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fxquotient") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fx*") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fx-") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fx+") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fx>=") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fx>") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fx<=") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fx<") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fx=") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "eof-object") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "eof-object?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f6513 0))) (closure () (f6513) (let () (vector-ref f6513 0))))
# emit-begin
#   expr=(begin (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "vector?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "set-cdr!") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "set-car!") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "cdr") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "car") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "cons") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "pair?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fxremainder") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fxquotient") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fx*") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fx-") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fx+") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fx>=") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fx>") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fx<=") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fx<") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fx=") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "eof-object") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "eof-object?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f6513 0))) (closure () (f6513) (let () (vector-ref f6513 0))))
#   env=((f6513 . 0))
# emit-expr (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "vector?") (vector-ref f6513 0)))
# emit-expr f6513
# emit-variable-ref
# env=((f6513 . 0))
# var=f6513
    movl 0(%esp), %eax  # stack load f6513
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_39298
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_39298:
    movl %eax, -4(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_39299"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_39299:
# check bounds on vector index
    movl -4(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_39301
    cmp  $0,%eax
    jge _L_39300
_L_39301:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_39300:
    movl %eax, -8(%esp)
# emit-expr (cons ((primitive-ref string->symbol) "vector?") (vector-ref f6513 0))
# cons arg1=((primitive-ref string->symbol) "vector?") arg2=(vector-ref f6513 0)
# emit-expr ((primitive-ref string->symbol) "vector?")
# funcall
#    si   =-12
#    env  = ((f6513 . 0))
#    expr = (funcall (primitive-ref string->symbol) "vector?")
# emit-expr (primitive-ref string->symbol)
    .extern mrc_string$m$gsymbol
    movl mrc_string$m$gsymbol,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_39302"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_39302":
   movl %eax,  -20(%esp)  # stash funcall-oper in closure slot
# emit-expr "vector?"
# string literal
    jmp _L_39304
    .align 8,0x90
_L_39303 :
    .int 28
    .ascii "vector?"
_L_39304:
    movl $_L_39303, %eax
    orl $6, %eax
    mov %eax, -24(%esp)  # arg vector?
    movl -20(%esp), %edi   # load new closure to %edi
    add $-12, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $12, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    movl %eax, -12(%esp)
# emit-expr (vector-ref f6513 0)
# emit-expr f6513
# emit-variable-ref
# env=((f6513 . 0))
# var=f6513
    movl 0(%esp), %eax  # stack load f6513
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_39305
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_39305:
    movl %eax, -16(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_39306"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_39306:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_39308
    cmp  $0,%eax
    jge _L_39307
_L_39308:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_39307:
    movl -16(%esp), %esi
    movl -1(%eax,%esi), %eax
    movl %eax, 4(%ebp)
    movl -12(%esp), %eax
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    or   $1, %al
    add  $8, %ebp
# cons end
    movl -4(%esp), %ebx
    movl -8(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "set-cdr!") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "set-car!") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "cdr") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "car") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "cons") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "pair?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fxremainder") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fxquotient") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fx*") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fx-") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fx+") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fx>=") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fx>") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fx<=") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fx<") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fx=") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "eof-object") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "eof-object?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f6513 0))) (closure () (f6513) (let () (vector-ref f6513 0))))
# emit-begin
#   expr=(begin (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "set-cdr!") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "set-car!") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "cdr") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "car") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "cons") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "pair?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fxremainder") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fxquotient") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fx*") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fx-") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fx+") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fx>=") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fx>") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fx<=") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fx<") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fx=") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "eof-object") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "eof-object?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f6513 0))) (closure () (f6513) (let () (vector-ref f6513 0))))
#   env=((f6513 . 0))
# emit-expr (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "set-cdr!") (vector-ref f6513 0)))
# emit-expr f6513
# emit-variable-ref
# env=((f6513 . 0))
# var=f6513
    movl 0(%esp), %eax  # stack load f6513
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_39309
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_39309:
    movl %eax, -4(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_39310"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_39310:
# check bounds on vector index
    movl -4(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_39312
    cmp  $0,%eax
    jge _L_39311
_L_39312:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_39311:
    movl %eax, -8(%esp)
# emit-expr (cons ((primitive-ref string->symbol) "set-cdr!") (vector-ref f6513 0))
# cons arg1=((primitive-ref string->symbol) "set-cdr!") arg2=(vector-ref f6513 0)
# emit-expr ((primitive-ref string->symbol) "set-cdr!")
# funcall
#    si   =-12
#    env  = ((f6513 . 0))
#    expr = (funcall (primitive-ref string->symbol) "set-cdr!")
# emit-expr (primitive-ref string->symbol)
    .extern mrc_string$m$gsymbol
    movl mrc_string$m$gsymbol,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_39313"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_39313":
   movl %eax,  -20(%esp)  # stash funcall-oper in closure slot
# emit-expr "set-cdr!"
# string literal
    jmp _L_39315
    .align 8,0x90
_L_39314 :
    .int 32
    .ascii "set-cdr!"
_L_39315:
    movl $_L_39314, %eax
    orl $6, %eax
    mov %eax, -24(%esp)  # arg set-cdr!
    movl -20(%esp), %edi   # load new closure to %edi
    add $-12, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $12, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    movl %eax, -12(%esp)
# emit-expr (vector-ref f6513 0)
# emit-expr f6513
# emit-variable-ref
# env=((f6513 . 0))
# var=f6513
    movl 0(%esp), %eax  # stack load f6513
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_39316
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_39316:
    movl %eax, -16(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_39317"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_39317:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_39319
    cmp  $0,%eax
    jge _L_39318
_L_39319:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_39318:
    movl -16(%esp), %esi
    movl -1(%eax,%esi), %eax
    movl %eax, 4(%ebp)
    movl -12(%esp), %eax
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    or   $1, %al
    add  $8, %ebp
# cons end
    movl -4(%esp), %ebx
    movl -8(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "set-car!") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "cdr") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "car") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "cons") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "pair?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fxremainder") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fxquotient") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fx*") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fx-") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fx+") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fx>=") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fx>") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fx<=") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fx<") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fx=") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "eof-object") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "eof-object?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f6513 0))) (closure () (f6513) (let () (vector-ref f6513 0))))
# emit-begin
#   expr=(begin (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "set-car!") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "cdr") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "car") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "cons") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "pair?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fxremainder") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fxquotient") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fx*") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fx-") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fx+") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fx>=") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fx>") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fx<=") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fx<") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fx=") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "eof-object") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "eof-object?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f6513 0))) (closure () (f6513) (let () (vector-ref f6513 0))))
#   env=((f6513 . 0))
# emit-expr (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "set-car!") (vector-ref f6513 0)))
# emit-expr f6513
# emit-variable-ref
# env=((f6513 . 0))
# var=f6513
    movl 0(%esp), %eax  # stack load f6513
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_39320
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_39320:
    movl %eax, -4(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_39321"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_39321:
# check bounds on vector index
    movl -4(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_39323
    cmp  $0,%eax
    jge _L_39322
_L_39323:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_39322:
    movl %eax, -8(%esp)
# emit-expr (cons ((primitive-ref string->symbol) "set-car!") (vector-ref f6513 0))
# cons arg1=((primitive-ref string->symbol) "set-car!") arg2=(vector-ref f6513 0)
# emit-expr ((primitive-ref string->symbol) "set-car!")
# funcall
#    si   =-12
#    env  = ((f6513 . 0))
#    expr = (funcall (primitive-ref string->symbol) "set-car!")
# emit-expr (primitive-ref string->symbol)
    .extern mrc_string$m$gsymbol
    movl mrc_string$m$gsymbol,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_39324"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_39324":
   movl %eax,  -20(%esp)  # stash funcall-oper in closure slot
# emit-expr "set-car!"
# string literal
    jmp _L_39326
    .align 8,0x90
_L_39325 :
    .int 32
    .ascii "set-car!"
_L_39326:
    movl $_L_39325, %eax
    orl $6, %eax
    mov %eax, -24(%esp)  # arg set-car!
    movl -20(%esp), %edi   # load new closure to %edi
    add $-12, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $12, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    movl %eax, -12(%esp)
# emit-expr (vector-ref f6513 0)
# emit-expr f6513
# emit-variable-ref
# env=((f6513 . 0))
# var=f6513
    movl 0(%esp), %eax  # stack load f6513
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_39327
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_39327:
    movl %eax, -16(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_39328"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_39328:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_39330
    cmp  $0,%eax
    jge _L_39329
_L_39330:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_39329:
    movl -16(%esp), %esi
    movl -1(%eax,%esi), %eax
    movl %eax, 4(%ebp)
    movl -12(%esp), %eax
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    or   $1, %al
    add  $8, %ebp
# cons end
    movl -4(%esp), %ebx
    movl -8(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "cdr") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "car") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "cons") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "pair?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fxremainder") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fxquotient") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fx*") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fx-") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fx+") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fx>=") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fx>") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fx<=") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fx<") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fx=") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "eof-object") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "eof-object?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f6513 0))) (closure () (f6513) (let () (vector-ref f6513 0))))
# emit-begin
#   expr=(begin (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "cdr") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "car") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "cons") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "pair?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fxremainder") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fxquotient") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fx*") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fx-") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fx+") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fx>=") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fx>") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fx<=") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fx<") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fx=") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "eof-object") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "eof-object?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f6513 0))) (closure () (f6513) (let () (vector-ref f6513 0))))
#   env=((f6513 . 0))
# emit-expr (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "cdr") (vector-ref f6513 0)))
# emit-expr f6513
# emit-variable-ref
# env=((f6513 . 0))
# var=f6513
    movl 0(%esp), %eax  # stack load f6513
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_39331
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_39331:
    movl %eax, -4(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_39332"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_39332:
# check bounds on vector index
    movl -4(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_39334
    cmp  $0,%eax
    jge _L_39333
_L_39334:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_39333:
    movl %eax, -8(%esp)
# emit-expr (cons ((primitive-ref string->symbol) "cdr") (vector-ref f6513 0))
# cons arg1=((primitive-ref string->symbol) "cdr") arg2=(vector-ref f6513 0)
# emit-expr ((primitive-ref string->symbol) "cdr")
# funcall
#    si   =-12
#    env  = ((f6513 . 0))
#    expr = (funcall (primitive-ref string->symbol) "cdr")
# emit-expr (primitive-ref string->symbol)
    .extern mrc_string$m$gsymbol
    movl mrc_string$m$gsymbol,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_39335"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_39335":
   movl %eax,  -20(%esp)  # stash funcall-oper in closure slot
# emit-expr "cdr"
# string literal
    jmp _L_39337
    .align 8,0x90
_L_39336 :
    .int 12
    .ascii "cdr"
_L_39337:
    movl $_L_39336, %eax
    orl $6, %eax
    mov %eax, -24(%esp)  # arg cdr
    movl -20(%esp), %edi   # load new closure to %edi
    add $-12, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $12, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    movl %eax, -12(%esp)
# emit-expr (vector-ref f6513 0)
# emit-expr f6513
# emit-variable-ref
# env=((f6513 . 0))
# var=f6513
    movl 0(%esp), %eax  # stack load f6513
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_39338
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_39338:
    movl %eax, -16(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_39339"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_39339:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_39341
    cmp  $0,%eax
    jge _L_39340
_L_39341:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_39340:
    movl -16(%esp), %esi
    movl -1(%eax,%esi), %eax
    movl %eax, 4(%ebp)
    movl -12(%esp), %eax
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    or   $1, %al
    add  $8, %ebp
# cons end
    movl -4(%esp), %ebx
    movl -8(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "car") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "cons") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "pair?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fxremainder") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fxquotient") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fx*") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fx-") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fx+") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fx>=") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fx>") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fx<=") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fx<") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fx=") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "eof-object") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "eof-object?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f6513 0))) (closure () (f6513) (let () (vector-ref f6513 0))))
# emit-begin
#   expr=(begin (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "car") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "cons") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "pair?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fxremainder") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fxquotient") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fx*") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fx-") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fx+") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fx>=") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fx>") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fx<=") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fx<") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fx=") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "eof-object") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "eof-object?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f6513 0))) (closure () (f6513) (let () (vector-ref f6513 0))))
#   env=((f6513 . 0))
# emit-expr (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "car") (vector-ref f6513 0)))
# emit-expr f6513
# emit-variable-ref
# env=((f6513 . 0))
# var=f6513
    movl 0(%esp), %eax  # stack load f6513
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_39342
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_39342:
    movl %eax, -4(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_39343"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_39343:
# check bounds on vector index
    movl -4(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_39345
    cmp  $0,%eax
    jge _L_39344
_L_39345:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_39344:
    movl %eax, -8(%esp)
# emit-expr (cons ((primitive-ref string->symbol) "car") (vector-ref f6513 0))
# cons arg1=((primitive-ref string->symbol) "car") arg2=(vector-ref f6513 0)
# emit-expr ((primitive-ref string->symbol) "car")
# funcall
#    si   =-12
#    env  = ((f6513 . 0))
#    expr = (funcall (primitive-ref string->symbol) "car")
# emit-expr (primitive-ref string->symbol)
    .extern mrc_string$m$gsymbol
    movl mrc_string$m$gsymbol,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_39346"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_39346":
   movl %eax,  -20(%esp)  # stash funcall-oper in closure slot
# emit-expr "car"
# string literal
    jmp _L_39348
    .align 8,0x90
_L_39347 :
    .int 12
    .ascii "car"
_L_39348:
    movl $_L_39347, %eax
    orl $6, %eax
    mov %eax, -24(%esp)  # arg car
    movl -20(%esp), %edi   # load new closure to %edi
    add $-12, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $12, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    movl %eax, -12(%esp)
# emit-expr (vector-ref f6513 0)
# emit-expr f6513
# emit-variable-ref
# env=((f6513 . 0))
# var=f6513
    movl 0(%esp), %eax  # stack load f6513
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_39349
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_39349:
    movl %eax, -16(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_39350"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_39350:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_39352
    cmp  $0,%eax
    jge _L_39351
_L_39352:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_39351:
    movl -16(%esp), %esi
    movl -1(%eax,%esi), %eax
    movl %eax, 4(%ebp)
    movl -12(%esp), %eax
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    or   $1, %al
    add  $8, %ebp
# cons end
    movl -4(%esp), %ebx
    movl -8(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "cons") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "pair?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fxremainder") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fxquotient") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fx*") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fx-") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fx+") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fx>=") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fx>") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fx<=") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fx<") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fx=") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "eof-object") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "eof-object?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f6513 0))) (closure () (f6513) (let () (vector-ref f6513 0))))
# emit-begin
#   expr=(begin (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "cons") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "pair?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fxremainder") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fxquotient") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fx*") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fx-") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fx+") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fx>=") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fx>") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fx<=") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fx<") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fx=") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "eof-object") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "eof-object?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f6513 0))) (closure () (f6513) (let () (vector-ref f6513 0))))
#   env=((f6513 . 0))
# emit-expr (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "cons") (vector-ref f6513 0)))
# emit-expr f6513
# emit-variable-ref
# env=((f6513 . 0))
# var=f6513
    movl 0(%esp), %eax  # stack load f6513
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_39353
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_39353:
    movl %eax, -4(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_39354"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_39354:
# check bounds on vector index
    movl -4(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_39356
    cmp  $0,%eax
    jge _L_39355
_L_39356:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_39355:
    movl %eax, -8(%esp)
# emit-expr (cons ((primitive-ref string->symbol) "cons") (vector-ref f6513 0))
# cons arg1=((primitive-ref string->symbol) "cons") arg2=(vector-ref f6513 0)
# emit-expr ((primitive-ref string->symbol) "cons")
# funcall
#    si   =-12
#    env  = ((f6513 . 0))
#    expr = (funcall (primitive-ref string->symbol) "cons")
# emit-expr (primitive-ref string->symbol)
    .extern mrc_string$m$gsymbol
    movl mrc_string$m$gsymbol,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_39357"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_39357":
   movl %eax,  -20(%esp)  # stash funcall-oper in closure slot
# emit-expr "cons"
# string literal
    jmp _L_39359
    .align 8,0x90
_L_39358 :
    .int 16
    .ascii "cons"
_L_39359:
    movl $_L_39358, %eax
    orl $6, %eax
    mov %eax, -24(%esp)  # arg cons
    movl -20(%esp), %edi   # load new closure to %edi
    add $-12, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $12, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    movl %eax, -12(%esp)
# emit-expr (vector-ref f6513 0)
# emit-expr f6513
# emit-variable-ref
# env=((f6513 . 0))
# var=f6513
    movl 0(%esp), %eax  # stack load f6513
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_39360
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_39360:
    movl %eax, -16(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_39361"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_39361:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_39363
    cmp  $0,%eax
    jge _L_39362
_L_39363:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_39362:
    movl -16(%esp), %esi
    movl -1(%eax,%esi), %eax
    movl %eax, 4(%ebp)
    movl -12(%esp), %eax
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    or   $1, %al
    add  $8, %ebp
# cons end
    movl -4(%esp), %ebx
    movl -8(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "pair?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fxremainder") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fxquotient") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fx*") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fx-") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fx+") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fx>=") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fx>") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fx<=") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fx<") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fx=") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "eof-object") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "eof-object?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f6513 0))) (closure () (f6513) (let () (vector-ref f6513 0))))
# emit-begin
#   expr=(begin (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "pair?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fxremainder") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fxquotient") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fx*") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fx-") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fx+") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fx>=") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fx>") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fx<=") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fx<") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fx=") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "eof-object") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "eof-object?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f6513 0))) (closure () (f6513) (let () (vector-ref f6513 0))))
#   env=((f6513 . 0))
# emit-expr (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "pair?") (vector-ref f6513 0)))
# emit-expr f6513
# emit-variable-ref
# env=((f6513 . 0))
# var=f6513
    movl 0(%esp), %eax  # stack load f6513
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_39364
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_39364:
    movl %eax, -4(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_39365"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_39365:
# check bounds on vector index
    movl -4(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_39367
    cmp  $0,%eax
    jge _L_39366
_L_39367:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_39366:
    movl %eax, -8(%esp)
# emit-expr (cons ((primitive-ref string->symbol) "pair?") (vector-ref f6513 0))
# cons arg1=((primitive-ref string->symbol) "pair?") arg2=(vector-ref f6513 0)
# emit-expr ((primitive-ref string->symbol) "pair?")
# funcall
#    si   =-12
#    env  = ((f6513 . 0))
#    expr = (funcall (primitive-ref string->symbol) "pair?")
# emit-expr (primitive-ref string->symbol)
    .extern mrc_string$m$gsymbol
    movl mrc_string$m$gsymbol,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_39368"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_39368":
   movl %eax,  -20(%esp)  # stash funcall-oper in closure slot
# emit-expr "pair?"
# string literal
    jmp _L_39370
    .align 8,0x90
_L_39369 :
    .int 20
    .ascii "pair?"
_L_39370:
    movl $_L_39369, %eax
    orl $6, %eax
    mov %eax, -24(%esp)  # arg pair?
    movl -20(%esp), %edi   # load new closure to %edi
    add $-12, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $12, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    movl %eax, -12(%esp)
# emit-expr (vector-ref f6513 0)
# emit-expr f6513
# emit-variable-ref
# env=((f6513 . 0))
# var=f6513
    movl 0(%esp), %eax  # stack load f6513
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_39371
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_39371:
    movl %eax, -16(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_39372"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_39372:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_39374
    cmp  $0,%eax
    jge _L_39373
_L_39374:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_39373:
    movl -16(%esp), %esi
    movl -1(%eax,%esi), %eax
    movl %eax, 4(%ebp)
    movl -12(%esp), %eax
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    or   $1, %al
    add  $8, %ebp
# cons end
    movl -4(%esp), %ebx
    movl -8(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fxremainder") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fxquotient") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fx*") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fx-") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fx+") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fx>=") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fx>") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fx<=") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fx<") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fx=") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "eof-object") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "eof-object?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f6513 0))) (closure () (f6513) (let () (vector-ref f6513 0))))
# emit-begin
#   expr=(begin (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fxremainder") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fxquotient") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fx*") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fx-") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fx+") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fx>=") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fx>") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fx<=") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fx<") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fx=") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "eof-object") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "eof-object?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f6513 0))) (closure () (f6513) (let () (vector-ref f6513 0))))
#   env=((f6513 . 0))
# emit-expr (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fxremainder") (vector-ref f6513 0)))
# emit-expr f6513
# emit-variable-ref
# env=((f6513 . 0))
# var=f6513
    movl 0(%esp), %eax  # stack load f6513
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_39375
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_39375:
    movl %eax, -4(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_39376"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_39376:
# check bounds on vector index
    movl -4(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_39378
    cmp  $0,%eax
    jge _L_39377
_L_39378:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_39377:
    movl %eax, -8(%esp)
# emit-expr (cons ((primitive-ref string->symbol) "fxremainder") (vector-ref f6513 0))
# cons arg1=((primitive-ref string->symbol) "fxremainder") arg2=(vector-ref f6513 0)
# emit-expr ((primitive-ref string->symbol) "fxremainder")
# funcall
#    si   =-12
#    env  = ((f6513 . 0))
#    expr = (funcall (primitive-ref string->symbol) "fxremainder")
# emit-expr (primitive-ref string->symbol)
    .extern mrc_string$m$gsymbol
    movl mrc_string$m$gsymbol,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_39379"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_39379":
   movl %eax,  -20(%esp)  # stash funcall-oper in closure slot
# emit-expr "fxremainder"
# string literal
    jmp _L_39381
    .align 8,0x90
_L_39380 :
    .int 44
    .ascii "fxremainder"
_L_39381:
    movl $_L_39380, %eax
    orl $6, %eax
    mov %eax, -24(%esp)  # arg fxremainder
    movl -20(%esp), %edi   # load new closure to %edi
    add $-12, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $12, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    movl %eax, -12(%esp)
# emit-expr (vector-ref f6513 0)
# emit-expr f6513
# emit-variable-ref
# env=((f6513 . 0))
# var=f6513
    movl 0(%esp), %eax  # stack load f6513
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_39382
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_39382:
    movl %eax, -16(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_39383"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_39383:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_39385
    cmp  $0,%eax
    jge _L_39384
_L_39385:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_39384:
    movl -16(%esp), %esi
    movl -1(%eax,%esi), %eax
    movl %eax, 4(%ebp)
    movl -12(%esp), %eax
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    or   $1, %al
    add  $8, %ebp
# cons end
    movl -4(%esp), %ebx
    movl -8(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fxquotient") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fx*") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fx-") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fx+") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fx>=") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fx>") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fx<=") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fx<") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fx=") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "eof-object") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "eof-object?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f6513 0))) (closure () (f6513) (let () (vector-ref f6513 0))))
# emit-begin
#   expr=(begin (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fxquotient") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fx*") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fx-") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fx+") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fx>=") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fx>") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fx<=") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fx<") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fx=") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "eof-object") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "eof-object?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f6513 0))) (closure () (f6513) (let () (vector-ref f6513 0))))
#   env=((f6513 . 0))
# emit-expr (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fxquotient") (vector-ref f6513 0)))
# emit-expr f6513
# emit-variable-ref
# env=((f6513 . 0))
# var=f6513
    movl 0(%esp), %eax  # stack load f6513
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_39386
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_39386:
    movl %eax, -4(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_39387"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_39387:
# check bounds on vector index
    movl -4(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_39389
    cmp  $0,%eax
    jge _L_39388
_L_39389:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_39388:
    movl %eax, -8(%esp)
# emit-expr (cons ((primitive-ref string->symbol) "fxquotient") (vector-ref f6513 0))
# cons arg1=((primitive-ref string->symbol) "fxquotient") arg2=(vector-ref f6513 0)
# emit-expr ((primitive-ref string->symbol) "fxquotient")
# funcall
#    si   =-12
#    env  = ((f6513 . 0))
#    expr = (funcall (primitive-ref string->symbol) "fxquotient")
# emit-expr (primitive-ref string->symbol)
    .extern mrc_string$m$gsymbol
    movl mrc_string$m$gsymbol,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_39390"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_39390":
   movl %eax,  -20(%esp)  # stash funcall-oper in closure slot
# emit-expr "fxquotient"
# string literal
    jmp _L_39392
    .align 8,0x90
_L_39391 :
    .int 40
    .ascii "fxquotient"
_L_39392:
    movl $_L_39391, %eax
    orl $6, %eax
    mov %eax, -24(%esp)  # arg fxquotient
    movl -20(%esp), %edi   # load new closure to %edi
    add $-12, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $12, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    movl %eax, -12(%esp)
# emit-expr (vector-ref f6513 0)
# emit-expr f6513
# emit-variable-ref
# env=((f6513 . 0))
# var=f6513
    movl 0(%esp), %eax  # stack load f6513
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_39393
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_39393:
    movl %eax, -16(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_39394"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_39394:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_39396
    cmp  $0,%eax
    jge _L_39395
_L_39396:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_39395:
    movl -16(%esp), %esi
    movl -1(%eax,%esi), %eax
    movl %eax, 4(%ebp)
    movl -12(%esp), %eax
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    or   $1, %al
    add  $8, %ebp
# cons end
    movl -4(%esp), %ebx
    movl -8(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fx*") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fx-") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fx+") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fx>=") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fx>") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fx<=") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fx<") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fx=") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "eof-object") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "eof-object?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f6513 0))) (closure () (f6513) (let () (vector-ref f6513 0))))
# emit-begin
#   expr=(begin (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fx*") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fx-") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fx+") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fx>=") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fx>") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fx<=") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fx<") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fx=") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "eof-object") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "eof-object?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f6513 0))) (closure () (f6513) (let () (vector-ref f6513 0))))
#   env=((f6513 . 0))
# emit-expr (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fx*") (vector-ref f6513 0)))
# emit-expr f6513
# emit-variable-ref
# env=((f6513 . 0))
# var=f6513
    movl 0(%esp), %eax  # stack load f6513
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_39397
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_39397:
    movl %eax, -4(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_39398"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_39398:
# check bounds on vector index
    movl -4(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_39400
    cmp  $0,%eax
    jge _L_39399
_L_39400:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_39399:
    movl %eax, -8(%esp)
# emit-expr (cons ((primitive-ref string->symbol) "fx*") (vector-ref f6513 0))
# cons arg1=((primitive-ref string->symbol) "fx*") arg2=(vector-ref f6513 0)
# emit-expr ((primitive-ref string->symbol) "fx*")
# funcall
#    si   =-12
#    env  = ((f6513 . 0))
#    expr = (funcall (primitive-ref string->symbol) "fx*")
# emit-expr (primitive-ref string->symbol)
    .extern mrc_string$m$gsymbol
    movl mrc_string$m$gsymbol,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_39401"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_39401":
   movl %eax,  -20(%esp)  # stash funcall-oper in closure slot
# emit-expr "fx*"
# string literal
    jmp _L_39403
    .align 8,0x90
_L_39402 :
    .int 12
    .ascii "fx*"
_L_39403:
    movl $_L_39402, %eax
    orl $6, %eax
    mov %eax, -24(%esp)  # arg fx*
    movl -20(%esp), %edi   # load new closure to %edi
    add $-12, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $12, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    movl %eax, -12(%esp)
# emit-expr (vector-ref f6513 0)
# emit-expr f6513
# emit-variable-ref
# env=((f6513 . 0))
# var=f6513
    movl 0(%esp), %eax  # stack load f6513
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_39404
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_39404:
    movl %eax, -16(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_39405"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_39405:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_39407
    cmp  $0,%eax
    jge _L_39406
_L_39407:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_39406:
    movl -16(%esp), %esi
    movl -1(%eax,%esi), %eax
    movl %eax, 4(%ebp)
    movl -12(%esp), %eax
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    or   $1, %al
    add  $8, %ebp
# cons end
    movl -4(%esp), %ebx
    movl -8(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fx-") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fx+") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fx>=") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fx>") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fx<=") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fx<") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fx=") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "eof-object") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "eof-object?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f6513 0))) (closure () (f6513) (let () (vector-ref f6513 0))))
# emit-begin
#   expr=(begin (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fx-") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fx+") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fx>=") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fx>") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fx<=") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fx<") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fx=") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "eof-object") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "eof-object?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f6513 0))) (closure () (f6513) (let () (vector-ref f6513 0))))
#   env=((f6513 . 0))
# emit-expr (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fx-") (vector-ref f6513 0)))
# emit-expr f6513
# emit-variable-ref
# env=((f6513 . 0))
# var=f6513
    movl 0(%esp), %eax  # stack load f6513
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_39408
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_39408:
    movl %eax, -4(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_39409"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_39409:
# check bounds on vector index
    movl -4(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_39411
    cmp  $0,%eax
    jge _L_39410
_L_39411:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_39410:
    movl %eax, -8(%esp)
# emit-expr (cons ((primitive-ref string->symbol) "fx-") (vector-ref f6513 0))
# cons arg1=((primitive-ref string->symbol) "fx-") arg2=(vector-ref f6513 0)
# emit-expr ((primitive-ref string->symbol) "fx-")
# funcall
#    si   =-12
#    env  = ((f6513 . 0))
#    expr = (funcall (primitive-ref string->symbol) "fx-")
# emit-expr (primitive-ref string->symbol)
    .extern mrc_string$m$gsymbol
    movl mrc_string$m$gsymbol,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_39412"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_39412":
   movl %eax,  -20(%esp)  # stash funcall-oper in closure slot
# emit-expr "fx-"
# string literal
    jmp _L_39414
    .align 8,0x90
_L_39413 :
    .int 12
    .ascii "fx-"
_L_39414:
    movl $_L_39413, %eax
    orl $6, %eax
    mov %eax, -24(%esp)  # arg fx-
    movl -20(%esp), %edi   # load new closure to %edi
    add $-12, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $12, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    movl %eax, -12(%esp)
# emit-expr (vector-ref f6513 0)
# emit-expr f6513
# emit-variable-ref
# env=((f6513 . 0))
# var=f6513
    movl 0(%esp), %eax  # stack load f6513
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_39415
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_39415:
    movl %eax, -16(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_39416"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_39416:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_39418
    cmp  $0,%eax
    jge _L_39417
_L_39418:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_39417:
    movl -16(%esp), %esi
    movl -1(%eax,%esi), %eax
    movl %eax, 4(%ebp)
    movl -12(%esp), %eax
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    or   $1, %al
    add  $8, %ebp
# cons end
    movl -4(%esp), %ebx
    movl -8(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fx+") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fx>=") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fx>") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fx<=") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fx<") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fx=") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "eof-object") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "eof-object?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f6513 0))) (closure () (f6513) (let () (vector-ref f6513 0))))
# emit-begin
#   expr=(begin (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fx+") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fx>=") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fx>") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fx<=") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fx<") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fx=") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "eof-object") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "eof-object?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f6513 0))) (closure () (f6513) (let () (vector-ref f6513 0))))
#   env=((f6513 . 0))
# emit-expr (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fx+") (vector-ref f6513 0)))
# emit-expr f6513
# emit-variable-ref
# env=((f6513 . 0))
# var=f6513
    movl 0(%esp), %eax  # stack load f6513
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_39419
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_39419:
    movl %eax, -4(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_39420"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_39420:
# check bounds on vector index
    movl -4(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_39422
    cmp  $0,%eax
    jge _L_39421
_L_39422:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_39421:
    movl %eax, -8(%esp)
# emit-expr (cons ((primitive-ref string->symbol) "fx+") (vector-ref f6513 0))
# cons arg1=((primitive-ref string->symbol) "fx+") arg2=(vector-ref f6513 0)
# emit-expr ((primitive-ref string->symbol) "fx+")
# funcall
#    si   =-12
#    env  = ((f6513 . 0))
#    expr = (funcall (primitive-ref string->symbol) "fx+")
# emit-expr (primitive-ref string->symbol)
    .extern mrc_string$m$gsymbol
    movl mrc_string$m$gsymbol,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_39423"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_39423":
   movl %eax,  -20(%esp)  # stash funcall-oper in closure slot
# emit-expr "fx+"
# string literal
    jmp _L_39425
    .align 8,0x90
_L_39424 :
    .int 12
    .ascii "fx+"
_L_39425:
    movl $_L_39424, %eax
    orl $6, %eax
    mov %eax, -24(%esp)  # arg fx+
    movl -20(%esp), %edi   # load new closure to %edi
    add $-12, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $12, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    movl %eax, -12(%esp)
# emit-expr (vector-ref f6513 0)
# emit-expr f6513
# emit-variable-ref
# env=((f6513 . 0))
# var=f6513
    movl 0(%esp), %eax  # stack load f6513
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_39426
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_39426:
    movl %eax, -16(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_39427"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_39427:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_39429
    cmp  $0,%eax
    jge _L_39428
_L_39429:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_39428:
    movl -16(%esp), %esi
    movl -1(%eax,%esi), %eax
    movl %eax, 4(%ebp)
    movl -12(%esp), %eax
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    or   $1, %al
    add  $8, %ebp
# cons end
    movl -4(%esp), %ebx
    movl -8(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fx>=") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fx>") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fx<=") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fx<") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fx=") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "eof-object") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "eof-object?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f6513 0))) (closure () (f6513) (let () (vector-ref f6513 0))))
# emit-begin
#   expr=(begin (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fx>=") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fx>") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fx<=") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fx<") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fx=") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "eof-object") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "eof-object?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f6513 0))) (closure () (f6513) (let () (vector-ref f6513 0))))
#   env=((f6513 . 0))
# emit-expr (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fx>=") (vector-ref f6513 0)))
# emit-expr f6513
# emit-variable-ref
# env=((f6513 . 0))
# var=f6513
    movl 0(%esp), %eax  # stack load f6513
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_39430
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_39430:
    movl %eax, -4(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_39431"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_39431:
# check bounds on vector index
    movl -4(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_39433
    cmp  $0,%eax
    jge _L_39432
_L_39433:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_39432:
    movl %eax, -8(%esp)
# emit-expr (cons ((primitive-ref string->symbol) "fx>=") (vector-ref f6513 0))
# cons arg1=((primitive-ref string->symbol) "fx>=") arg2=(vector-ref f6513 0)
# emit-expr ((primitive-ref string->symbol) "fx>=")
# funcall
#    si   =-12
#    env  = ((f6513 . 0))
#    expr = (funcall (primitive-ref string->symbol) "fx>=")
# emit-expr (primitive-ref string->symbol)
    .extern mrc_string$m$gsymbol
    movl mrc_string$m$gsymbol,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_39434"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_39434":
   movl %eax,  -20(%esp)  # stash funcall-oper in closure slot
# emit-expr "fx>="
# string literal
    jmp _L_39436
    .align 8,0x90
_L_39435 :
    .int 16
    .ascii "fx>="
_L_39436:
    movl $_L_39435, %eax
    orl $6, %eax
    mov %eax, -24(%esp)  # arg fx>=
    movl -20(%esp), %edi   # load new closure to %edi
    add $-12, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $12, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    movl %eax, -12(%esp)
# emit-expr (vector-ref f6513 0)
# emit-expr f6513
# emit-variable-ref
# env=((f6513 . 0))
# var=f6513
    movl 0(%esp), %eax  # stack load f6513
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_39437
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_39437:
    movl %eax, -16(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_39438"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_39438:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_39440
    cmp  $0,%eax
    jge _L_39439
_L_39440:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_39439:
    movl -16(%esp), %esi
    movl -1(%eax,%esi), %eax
    movl %eax, 4(%ebp)
    movl -12(%esp), %eax
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    or   $1, %al
    add  $8, %ebp
# cons end
    movl -4(%esp), %ebx
    movl -8(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fx>") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fx<=") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fx<") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fx=") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "eof-object") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "eof-object?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f6513 0))) (closure () (f6513) (let () (vector-ref f6513 0))))
# emit-begin
#   expr=(begin (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fx>") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fx<=") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fx<") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fx=") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "eof-object") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "eof-object?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f6513 0))) (closure () (f6513) (let () (vector-ref f6513 0))))
#   env=((f6513 . 0))
# emit-expr (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fx>") (vector-ref f6513 0)))
# emit-expr f6513
# emit-variable-ref
# env=((f6513 . 0))
# var=f6513
    movl 0(%esp), %eax  # stack load f6513
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_39441
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_39441:
    movl %eax, -4(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_39442"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_39442:
# check bounds on vector index
    movl -4(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_39444
    cmp  $0,%eax
    jge _L_39443
_L_39444:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_39443:
    movl %eax, -8(%esp)
# emit-expr (cons ((primitive-ref string->symbol) "fx>") (vector-ref f6513 0))
# cons arg1=((primitive-ref string->symbol) "fx>") arg2=(vector-ref f6513 0)
# emit-expr ((primitive-ref string->symbol) "fx>")
# funcall
#    si   =-12
#    env  = ((f6513 . 0))
#    expr = (funcall (primitive-ref string->symbol) "fx>")
# emit-expr (primitive-ref string->symbol)
    .extern mrc_string$m$gsymbol
    movl mrc_string$m$gsymbol,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_39445"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_39445":
   movl %eax,  -20(%esp)  # stash funcall-oper in closure slot
# emit-expr "fx>"
# string literal
    jmp _L_39447
    .align 8,0x90
_L_39446 :
    .int 12
    .ascii "fx>"
_L_39447:
    movl $_L_39446, %eax
    orl $6, %eax
    mov %eax, -24(%esp)  # arg fx>
    movl -20(%esp), %edi   # load new closure to %edi
    add $-12, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $12, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    movl %eax, -12(%esp)
# emit-expr (vector-ref f6513 0)
# emit-expr f6513
# emit-variable-ref
# env=((f6513 . 0))
# var=f6513
    movl 0(%esp), %eax  # stack load f6513
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_39448
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_39448:
    movl %eax, -16(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_39449"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_39449:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_39451
    cmp  $0,%eax
    jge _L_39450
_L_39451:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_39450:
    movl -16(%esp), %esi
    movl -1(%eax,%esi), %eax
    movl %eax, 4(%ebp)
    movl -12(%esp), %eax
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    or   $1, %al
    add  $8, %ebp
# cons end
    movl -4(%esp), %ebx
    movl -8(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fx<=") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fx<") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fx=") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "eof-object") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "eof-object?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f6513 0))) (closure () (f6513) (let () (vector-ref f6513 0))))
# emit-begin
#   expr=(begin (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fx<=") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fx<") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fx=") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "eof-object") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "eof-object?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f6513 0))) (closure () (f6513) (let () (vector-ref f6513 0))))
#   env=((f6513 . 0))
# emit-expr (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fx<=") (vector-ref f6513 0)))
# emit-expr f6513
# emit-variable-ref
# env=((f6513 . 0))
# var=f6513
    movl 0(%esp), %eax  # stack load f6513
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_39452
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_39452:
    movl %eax, -4(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_39453"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_39453:
# check bounds on vector index
    movl -4(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_39455
    cmp  $0,%eax
    jge _L_39454
_L_39455:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_39454:
    movl %eax, -8(%esp)
# emit-expr (cons ((primitive-ref string->symbol) "fx<=") (vector-ref f6513 0))
# cons arg1=((primitive-ref string->symbol) "fx<=") arg2=(vector-ref f6513 0)
# emit-expr ((primitive-ref string->symbol) "fx<=")
# funcall
#    si   =-12
#    env  = ((f6513 . 0))
#    expr = (funcall (primitive-ref string->symbol) "fx<=")
# emit-expr (primitive-ref string->symbol)
    .extern mrc_string$m$gsymbol
    movl mrc_string$m$gsymbol,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_39456"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_39456":
   movl %eax,  -20(%esp)  # stash funcall-oper in closure slot
# emit-expr "fx<="
# string literal
    jmp _L_39458
    .align 8,0x90
_L_39457 :
    .int 16
    .ascii "fx<="
_L_39458:
    movl $_L_39457, %eax
    orl $6, %eax
    mov %eax, -24(%esp)  # arg fx<=
    movl -20(%esp), %edi   # load new closure to %edi
    add $-12, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $12, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    movl %eax, -12(%esp)
# emit-expr (vector-ref f6513 0)
# emit-expr f6513
# emit-variable-ref
# env=((f6513 . 0))
# var=f6513
    movl 0(%esp), %eax  # stack load f6513
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_39459
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_39459:
    movl %eax, -16(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_39460"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_39460:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_39462
    cmp  $0,%eax
    jge _L_39461
_L_39462:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_39461:
    movl -16(%esp), %esi
    movl -1(%eax,%esi), %eax
    movl %eax, 4(%ebp)
    movl -12(%esp), %eax
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    or   $1, %al
    add  $8, %ebp
# cons end
    movl -4(%esp), %ebx
    movl -8(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fx<") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fx=") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "eof-object") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "eof-object?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f6513 0))) (closure () (f6513) (let () (vector-ref f6513 0))))
# emit-begin
#   expr=(begin (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fx<") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fx=") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "eof-object") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "eof-object?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f6513 0))) (closure () (f6513) (let () (vector-ref f6513 0))))
#   env=((f6513 . 0))
# emit-expr (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fx<") (vector-ref f6513 0)))
# emit-expr f6513
# emit-variable-ref
# env=((f6513 . 0))
# var=f6513
    movl 0(%esp), %eax  # stack load f6513
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_39463
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_39463:
    movl %eax, -4(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_39464"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_39464:
# check bounds on vector index
    movl -4(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_39466
    cmp  $0,%eax
    jge _L_39465
_L_39466:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_39465:
    movl %eax, -8(%esp)
# emit-expr (cons ((primitive-ref string->symbol) "fx<") (vector-ref f6513 0))
# cons arg1=((primitive-ref string->symbol) "fx<") arg2=(vector-ref f6513 0)
# emit-expr ((primitive-ref string->symbol) "fx<")
# funcall
#    si   =-12
#    env  = ((f6513 . 0))
#    expr = (funcall (primitive-ref string->symbol) "fx<")
# emit-expr (primitive-ref string->symbol)
    .extern mrc_string$m$gsymbol
    movl mrc_string$m$gsymbol,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_39467"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_39467":
   movl %eax,  -20(%esp)  # stash funcall-oper in closure slot
# emit-expr "fx<"
# string literal
    jmp _L_39469
    .align 8,0x90
_L_39468 :
    .int 12
    .ascii "fx<"
_L_39469:
    movl $_L_39468, %eax
    orl $6, %eax
    mov %eax, -24(%esp)  # arg fx<
    movl -20(%esp), %edi   # load new closure to %edi
    add $-12, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $12, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    movl %eax, -12(%esp)
# emit-expr (vector-ref f6513 0)
# emit-expr f6513
# emit-variable-ref
# env=((f6513 . 0))
# var=f6513
    movl 0(%esp), %eax  # stack load f6513
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_39470
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_39470:
    movl %eax, -16(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_39471"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_39471:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_39473
    cmp  $0,%eax
    jge _L_39472
_L_39473:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_39472:
    movl -16(%esp), %esi
    movl -1(%eax,%esi), %eax
    movl %eax, 4(%ebp)
    movl -12(%esp), %eax
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    or   $1, %al
    add  $8, %ebp
# cons end
    movl -4(%esp), %ebx
    movl -8(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fx=") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "eof-object") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "eof-object?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f6513 0))) (closure () (f6513) (let () (vector-ref f6513 0))))
# emit-begin
#   expr=(begin (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fx=") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "eof-object") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "eof-object?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f6513 0))) (closure () (f6513) (let () (vector-ref f6513 0))))
#   env=((f6513 . 0))
# emit-expr (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fx=") (vector-ref f6513 0)))
# emit-expr f6513
# emit-variable-ref
# env=((f6513 . 0))
# var=f6513
    movl 0(%esp), %eax  # stack load f6513
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_39474
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_39474:
    movl %eax, -4(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_39475"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_39475:
# check bounds on vector index
    movl -4(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_39477
    cmp  $0,%eax
    jge _L_39476
_L_39477:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_39476:
    movl %eax, -8(%esp)
# emit-expr (cons ((primitive-ref string->symbol) "fx=") (vector-ref f6513 0))
# cons arg1=((primitive-ref string->symbol) "fx=") arg2=(vector-ref f6513 0)
# emit-expr ((primitive-ref string->symbol) "fx=")
# funcall
#    si   =-12
#    env  = ((f6513 . 0))
#    expr = (funcall (primitive-ref string->symbol) "fx=")
# emit-expr (primitive-ref string->symbol)
    .extern mrc_string$m$gsymbol
    movl mrc_string$m$gsymbol,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_39478"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_39478":
   movl %eax,  -20(%esp)  # stash funcall-oper in closure slot
# emit-expr "fx="
# string literal
    jmp _L_39480
    .align 8,0x90
_L_39479 :
    .int 12
    .ascii "fx="
_L_39480:
    movl $_L_39479, %eax
    orl $6, %eax
    mov %eax, -24(%esp)  # arg fx=
    movl -20(%esp), %edi   # load new closure to %edi
    add $-12, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $12, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    movl %eax, -12(%esp)
# emit-expr (vector-ref f6513 0)
# emit-expr f6513
# emit-variable-ref
# env=((f6513 . 0))
# var=f6513
    movl 0(%esp), %eax  # stack load f6513
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_39481
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_39481:
    movl %eax, -16(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_39482"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_39482:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_39484
    cmp  $0,%eax
    jge _L_39483
_L_39484:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_39483:
    movl -16(%esp), %esi
    movl -1(%eax,%esi), %eax
    movl %eax, 4(%ebp)
    movl -12(%esp), %eax
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    or   $1, %al
    add  $8, %ebp
# cons end
    movl -4(%esp), %ebx
    movl -8(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "eof-object") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "eof-object?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f6513 0))) (closure () (f6513) (let () (vector-ref f6513 0))))
# emit-begin
#   expr=(begin (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "eof-object") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "eof-object?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f6513 0))) (closure () (f6513) (let () (vector-ref f6513 0))))
#   env=((f6513 . 0))
# emit-expr (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f6513 0)))
# emit-expr f6513
# emit-variable-ref
# env=((f6513 . 0))
# var=f6513
    movl 0(%esp), %eax  # stack load f6513
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_39485
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_39485:
    movl %eax, -4(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_39486"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_39486:
# check bounds on vector index
    movl -4(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_39488
    cmp  $0,%eax
    jge _L_39487
_L_39488:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_39487:
    movl %eax, -8(%esp)
# emit-expr (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f6513 0))
# cons arg1=((primitive-ref string->symbol) "fxzero?") arg2=(vector-ref f6513 0)
# emit-expr ((primitive-ref string->symbol) "fxzero?")
# funcall
#    si   =-12
#    env  = ((f6513 . 0))
#    expr = (funcall (primitive-ref string->symbol) "fxzero?")
# emit-expr (primitive-ref string->symbol)
    .extern mrc_string$m$gsymbol
    movl mrc_string$m$gsymbol,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_39489"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_39489":
   movl %eax,  -20(%esp)  # stash funcall-oper in closure slot
# emit-expr "fxzero?"
# string literal
    jmp _L_39491
    .align 8,0x90
_L_39490 :
    .int 28
    .ascii "fxzero?"
_L_39491:
    movl $_L_39490, %eax
    orl $6, %eax
    mov %eax, -24(%esp)  # arg fxzero?
    movl -20(%esp), %edi   # load new closure to %edi
    add $-12, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $12, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    movl %eax, -12(%esp)
# emit-expr (vector-ref f6513 0)
# emit-expr f6513
# emit-variable-ref
# env=((f6513 . 0))
# var=f6513
    movl 0(%esp), %eax  # stack load f6513
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_39492
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_39492:
    movl %eax, -16(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_39493"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_39493:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_39495
    cmp  $0,%eax
    jge _L_39494
_L_39495:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_39494:
    movl -16(%esp), %esi
    movl -1(%eax,%esi), %eax
    movl %eax, 4(%ebp)
    movl -12(%esp), %eax
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    or   $1, %al
    add  $8, %ebp
# cons end
    movl -4(%esp), %ebx
    movl -8(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "eof-object") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "eof-object?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f6513 0))) (closure () (f6513) (let () (vector-ref f6513 0))))
# emit-begin
#   expr=(begin (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "eof-object") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "eof-object?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f6513 0))) (closure () (f6513) (let () (vector-ref f6513 0))))
#   env=((f6513 . 0))
# emit-expr (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f6513 0)))
# emit-expr f6513
# emit-variable-ref
# env=((f6513 . 0))
# var=f6513
    movl 0(%esp), %eax  # stack load f6513
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_39496
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_39496:
    movl %eax, -4(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_39497"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_39497:
# check bounds on vector index
    movl -4(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_39499
    cmp  $0,%eax
    jge _L_39498
_L_39499:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_39498:
    movl %eax, -8(%esp)
# emit-expr (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f6513 0))
# cons arg1=((primitive-ref string->symbol) "fxsub1") arg2=(vector-ref f6513 0)
# emit-expr ((primitive-ref string->symbol) "fxsub1")
# funcall
#    si   =-12
#    env  = ((f6513 . 0))
#    expr = (funcall (primitive-ref string->symbol) "fxsub1")
# emit-expr (primitive-ref string->symbol)
    .extern mrc_string$m$gsymbol
    movl mrc_string$m$gsymbol,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_39500"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_39500":
   movl %eax,  -20(%esp)  # stash funcall-oper in closure slot
# emit-expr "fxsub1"
# string literal
    jmp _L_39502
    .align 8,0x90
_L_39501 :
    .int 24
    .ascii "fxsub1"
_L_39502:
    movl $_L_39501, %eax
    orl $6, %eax
    mov %eax, -24(%esp)  # arg fxsub1
    movl -20(%esp), %edi   # load new closure to %edi
    add $-12, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $12, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    movl %eax, -12(%esp)
# emit-expr (vector-ref f6513 0)
# emit-expr f6513
# emit-variable-ref
# env=((f6513 . 0))
# var=f6513
    movl 0(%esp), %eax  # stack load f6513
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_39503
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_39503:
    movl %eax, -16(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_39504"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_39504:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_39506
    cmp  $0,%eax
    jge _L_39505
_L_39506:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_39505:
    movl -16(%esp), %esi
    movl -1(%eax,%esi), %eax
    movl %eax, 4(%ebp)
    movl -12(%esp), %eax
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    or   $1, %al
    add  $8, %ebp
# cons end
    movl -4(%esp), %ebx
    movl -8(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "eof-object") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "eof-object?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f6513 0))) (closure () (f6513) (let () (vector-ref f6513 0))))
# emit-begin
#   expr=(begin (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "eof-object") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "eof-object?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f6513 0))) (closure () (f6513) (let () (vector-ref f6513 0))))
#   env=((f6513 . 0))
# emit-expr (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f6513 0)))
# emit-expr f6513
# emit-variable-ref
# env=((f6513 . 0))
# var=f6513
    movl 0(%esp), %eax  # stack load f6513
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_39507
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_39507:
    movl %eax, -4(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_39508"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_39508:
# check bounds on vector index
    movl -4(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_39510
    cmp  $0,%eax
    jge _L_39509
_L_39510:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_39509:
    movl %eax, -8(%esp)
# emit-expr (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f6513 0))
# cons arg1=((primitive-ref string->symbol) "fxadd1") arg2=(vector-ref f6513 0)
# emit-expr ((primitive-ref string->symbol) "fxadd1")
# funcall
#    si   =-12
#    env  = ((f6513 . 0))
#    expr = (funcall (primitive-ref string->symbol) "fxadd1")
# emit-expr (primitive-ref string->symbol)
    .extern mrc_string$m$gsymbol
    movl mrc_string$m$gsymbol,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_39511"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_39511":
   movl %eax,  -20(%esp)  # stash funcall-oper in closure slot
# emit-expr "fxadd1"
# string literal
    jmp _L_39513
    .align 8,0x90
_L_39512 :
    .int 24
    .ascii "fxadd1"
_L_39513:
    movl $_L_39512, %eax
    orl $6, %eax
    mov %eax, -24(%esp)  # arg fxadd1
    movl -20(%esp), %edi   # load new closure to %edi
    add $-12, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $12, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    movl %eax, -12(%esp)
# emit-expr (vector-ref f6513 0)
# emit-expr f6513
# emit-variable-ref
# env=((f6513 . 0))
# var=f6513
    movl 0(%esp), %eax  # stack load f6513
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_39514
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_39514:
    movl %eax, -16(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_39515"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_39515:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_39517
    cmp  $0,%eax
    jge _L_39516
_L_39517:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_39516:
    movl -16(%esp), %esi
    movl -1(%eax,%esi), %eax
    movl %eax, 4(%ebp)
    movl -12(%esp), %eax
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    or   $1, %al
    add  $8, %ebp
# cons end
    movl -4(%esp), %ebx
    movl -8(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "eof-object") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "eof-object?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f6513 0))) (closure () (f6513) (let () (vector-ref f6513 0))))
# emit-begin
#   expr=(begin (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "eof-object") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "eof-object?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f6513 0))) (closure () (f6513) (let () (vector-ref f6513 0))))
#   env=((f6513 . 0))
# emit-expr (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f6513 0)))
# emit-expr f6513
# emit-variable-ref
# env=((f6513 . 0))
# var=f6513
    movl 0(%esp), %eax  # stack load f6513
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_39518
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_39518:
    movl %eax, -4(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_39519"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_39519:
# check bounds on vector index
    movl -4(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_39521
    cmp  $0,%eax
    jge _L_39520
_L_39521:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_39520:
    movl %eax, -8(%esp)
# emit-expr (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f6513 0))
# cons arg1=((primitive-ref string->symbol) "fxlogor") arg2=(vector-ref f6513 0)
# emit-expr ((primitive-ref string->symbol) "fxlogor")
# funcall
#    si   =-12
#    env  = ((f6513 . 0))
#    expr = (funcall (primitive-ref string->symbol) "fxlogor")
# emit-expr (primitive-ref string->symbol)
    .extern mrc_string$m$gsymbol
    movl mrc_string$m$gsymbol,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_39522"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_39522":
   movl %eax,  -20(%esp)  # stash funcall-oper in closure slot
# emit-expr "fxlogor"
# string literal
    jmp _L_39524
    .align 8,0x90
_L_39523 :
    .int 28
    .ascii "fxlogor"
_L_39524:
    movl $_L_39523, %eax
    orl $6, %eax
    mov %eax, -24(%esp)  # arg fxlogor
    movl -20(%esp), %edi   # load new closure to %edi
    add $-12, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $12, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    movl %eax, -12(%esp)
# emit-expr (vector-ref f6513 0)
# emit-expr f6513
# emit-variable-ref
# env=((f6513 . 0))
# var=f6513
    movl 0(%esp), %eax  # stack load f6513
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_39525
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_39525:
    movl %eax, -16(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_39526"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_39526:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_39528
    cmp  $0,%eax
    jge _L_39527
_L_39528:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_39527:
    movl -16(%esp), %esi
    movl -1(%eax,%esi), %eax
    movl %eax, 4(%ebp)
    movl -12(%esp), %eax
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    or   $1, %al
    add  $8, %ebp
# cons end
    movl -4(%esp), %ebx
    movl -8(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "eof-object") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "eof-object?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f6513 0))) (closure () (f6513) (let () (vector-ref f6513 0))))
# emit-begin
#   expr=(begin (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "eof-object") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "eof-object?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f6513 0))) (closure () (f6513) (let () (vector-ref f6513 0))))
#   env=((f6513 . 0))
# emit-expr (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f6513 0)))
# emit-expr f6513
# emit-variable-ref
# env=((f6513 . 0))
# var=f6513
    movl 0(%esp), %eax  # stack load f6513
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_39529
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_39529:
    movl %eax, -4(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_39530"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_39530:
# check bounds on vector index
    movl -4(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_39532
    cmp  $0,%eax
    jge _L_39531
_L_39532:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_39531:
    movl %eax, -8(%esp)
# emit-expr (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f6513 0))
# cons arg1=((primitive-ref string->symbol) "fxlogand") arg2=(vector-ref f6513 0)
# emit-expr ((primitive-ref string->symbol) "fxlogand")
# funcall
#    si   =-12
#    env  = ((f6513 . 0))
#    expr = (funcall (primitive-ref string->symbol) "fxlogand")
# emit-expr (primitive-ref string->symbol)
    .extern mrc_string$m$gsymbol
    movl mrc_string$m$gsymbol,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_39533"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_39533":
   movl %eax,  -20(%esp)  # stash funcall-oper in closure slot
# emit-expr "fxlogand"
# string literal
    jmp _L_39535
    .align 8,0x90
_L_39534 :
    .int 32
    .ascii "fxlogand"
_L_39535:
    movl $_L_39534, %eax
    orl $6, %eax
    mov %eax, -24(%esp)  # arg fxlogand
    movl -20(%esp), %edi   # load new closure to %edi
    add $-12, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $12, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    movl %eax, -12(%esp)
# emit-expr (vector-ref f6513 0)
# emit-expr f6513
# emit-variable-ref
# env=((f6513 . 0))
# var=f6513
    movl 0(%esp), %eax  # stack load f6513
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_39536
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_39536:
    movl %eax, -16(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_39537"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_39537:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_39539
    cmp  $0,%eax
    jge _L_39538
_L_39539:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_39538:
    movl -16(%esp), %esi
    movl -1(%eax,%esi), %eax
    movl %eax, 4(%ebp)
    movl -12(%esp), %eax
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    or   $1, %al
    add  $8, %ebp
# cons end
    movl -4(%esp), %ebx
    movl -8(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "eof-object") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "eof-object?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f6513 0))) (closure () (f6513) (let () (vector-ref f6513 0))))
# emit-begin
#   expr=(begin (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "eof-object") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "eof-object?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f6513 0))) (closure () (f6513) (let () (vector-ref f6513 0))))
#   env=((f6513 . 0))
# emit-expr (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f6513 0)))
# emit-expr f6513
# emit-variable-ref
# env=((f6513 . 0))
# var=f6513
    movl 0(%esp), %eax  # stack load f6513
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_39540
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_39540:
    movl %eax, -4(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_39541"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_39541:
# check bounds on vector index
    movl -4(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_39543
    cmp  $0,%eax
    jge _L_39542
_L_39543:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_39542:
    movl %eax, -8(%esp)
# emit-expr (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f6513 0))
# cons arg1=((primitive-ref string->symbol) "fxlognot") arg2=(vector-ref f6513 0)
# emit-expr ((primitive-ref string->symbol) "fxlognot")
# funcall
#    si   =-12
#    env  = ((f6513 . 0))
#    expr = (funcall (primitive-ref string->symbol) "fxlognot")
# emit-expr (primitive-ref string->symbol)
    .extern mrc_string$m$gsymbol
    movl mrc_string$m$gsymbol,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_39544"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_39544":
   movl %eax,  -20(%esp)  # stash funcall-oper in closure slot
# emit-expr "fxlognot"
# string literal
    jmp _L_39546
    .align 8,0x90
_L_39545 :
    .int 32
    .ascii "fxlognot"
_L_39546:
    movl $_L_39545, %eax
    orl $6, %eax
    mov %eax, -24(%esp)  # arg fxlognot
    movl -20(%esp), %edi   # load new closure to %edi
    add $-12, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $12, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    movl %eax, -12(%esp)
# emit-expr (vector-ref f6513 0)
# emit-expr f6513
# emit-variable-ref
# env=((f6513 . 0))
# var=f6513
    movl 0(%esp), %eax  # stack load f6513
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_39547
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_39547:
    movl %eax, -16(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_39548"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_39548:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_39550
    cmp  $0,%eax
    jge _L_39549
_L_39550:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_39549:
    movl -16(%esp), %esi
    movl -1(%eax,%esi), %eax
    movl %eax, 4(%ebp)
    movl -12(%esp), %eax
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    or   $1, %al
    add  $8, %ebp
# cons end
    movl -4(%esp), %ebx
    movl -8(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "eof-object") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "eof-object?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f6513 0))) (closure () (f6513) (let () (vector-ref f6513 0))))
# emit-begin
#   expr=(begin (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "eof-object") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "eof-object?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f6513 0))) (closure () (f6513) (let () (vector-ref f6513 0))))
#   env=((f6513 . 0))
# emit-expr (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f6513 0)))
# emit-expr f6513
# emit-variable-ref
# env=((f6513 . 0))
# var=f6513
    movl 0(%esp), %eax  # stack load f6513
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_39551
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_39551:
    movl %eax, -4(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_39552"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_39552:
# check bounds on vector index
    movl -4(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_39554
    cmp  $0,%eax
    jge _L_39553
_L_39554:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_39553:
    movl %eax, -8(%esp)
# emit-expr (cons ((primitive-ref string->symbol) "char=?") (vector-ref f6513 0))
# cons arg1=((primitive-ref string->symbol) "char=?") arg2=(vector-ref f6513 0)
# emit-expr ((primitive-ref string->symbol) "char=?")
# funcall
#    si   =-12
#    env  = ((f6513 . 0))
#    expr = (funcall (primitive-ref string->symbol) "char=?")
# emit-expr (primitive-ref string->symbol)
    .extern mrc_string$m$gsymbol
    movl mrc_string$m$gsymbol,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_39555"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_39555":
   movl %eax,  -20(%esp)  # stash funcall-oper in closure slot
# emit-expr "char=?"
# string literal
    jmp _L_39557
    .align 8,0x90
_L_39556 :
    .int 24
    .ascii "char=?"
_L_39557:
    movl $_L_39556, %eax
    orl $6, %eax
    mov %eax, -24(%esp)  # arg char=?
    movl -20(%esp), %edi   # load new closure to %edi
    add $-12, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $12, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    movl %eax, -12(%esp)
# emit-expr (vector-ref f6513 0)
# emit-expr f6513
# emit-variable-ref
# env=((f6513 . 0))
# var=f6513
    movl 0(%esp), %eax  # stack load f6513
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_39558
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_39558:
    movl %eax, -16(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_39559"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_39559:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_39561
    cmp  $0,%eax
    jge _L_39560
_L_39561:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_39560:
    movl -16(%esp), %esi
    movl -1(%eax,%esi), %eax
    movl %eax, 4(%ebp)
    movl -12(%esp), %eax
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    or   $1, %al
    add  $8, %ebp
# cons end
    movl -4(%esp), %ebx
    movl -8(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "eof-object") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "eof-object?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f6513 0))) (closure () (f6513) (let () (vector-ref f6513 0))))
# emit-begin
#   expr=(begin (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "eof-object") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "eof-object?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f6513 0))) (closure () (f6513) (let () (vector-ref f6513 0))))
#   env=((f6513 . 0))
# emit-expr (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f6513 0)))
# emit-expr f6513
# emit-variable-ref
# env=((f6513 . 0))
# var=f6513
    movl 0(%esp), %eax  # stack load f6513
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_39562
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_39562:
    movl %eax, -4(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_39563"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_39563:
# check bounds on vector index
    movl -4(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_39565
    cmp  $0,%eax
    jge _L_39564
_L_39565:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_39564:
    movl %eax, -8(%esp)
# emit-expr (cons ((primitive-ref string->symbol) "eq?") (vector-ref f6513 0))
# cons arg1=((primitive-ref string->symbol) "eq?") arg2=(vector-ref f6513 0)
# emit-expr ((primitive-ref string->symbol) "eq?")
# funcall
#    si   =-12
#    env  = ((f6513 . 0))
#    expr = (funcall (primitive-ref string->symbol) "eq?")
# emit-expr (primitive-ref string->symbol)
    .extern mrc_string$m$gsymbol
    movl mrc_string$m$gsymbol,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_39566"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_39566":
   movl %eax,  -20(%esp)  # stash funcall-oper in closure slot
# emit-expr "eq?"
# string literal
    jmp _L_39568
    .align 8,0x90
_L_39567 :
    .int 12
    .ascii "eq?"
_L_39568:
    movl $_L_39567, %eax
    orl $6, %eax
    mov %eax, -24(%esp)  # arg eq?
    movl -20(%esp), %edi   # load new closure to %edi
    add $-12, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $12, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    movl %eax, -12(%esp)
# emit-expr (vector-ref f6513 0)
# emit-expr f6513
# emit-variable-ref
# env=((f6513 . 0))
# var=f6513
    movl 0(%esp), %eax  # stack load f6513
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_39569
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_39569:
    movl %eax, -16(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_39570"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_39570:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_39572
    cmp  $0,%eax
    jge _L_39571
_L_39572:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_39571:
    movl -16(%esp), %esi
    movl -1(%eax,%esi), %eax
    movl %eax, 4(%ebp)
    movl -12(%esp), %eax
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    or   $1, %al
    add  $8, %ebp
# cons end
    movl -4(%esp), %ebx
    movl -8(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "eof-object") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "eof-object?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f6513 0))) (closure () (f6513) (let () (vector-ref f6513 0))))
# emit-begin
#   expr=(begin (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "eof-object") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "eof-object?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f6513 0))) (closure () (f6513) (let () (vector-ref f6513 0))))
#   env=((f6513 . 0))
# emit-expr (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f6513 0)))
# emit-expr f6513
# emit-variable-ref
# env=((f6513 . 0))
# var=f6513
    movl 0(%esp), %eax  # stack load f6513
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_39573
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_39573:
    movl %eax, -4(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_39574"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_39574:
# check bounds on vector index
    movl -4(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_39576
    cmp  $0,%eax
    jge _L_39575
_L_39576:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_39575:
    movl %eax, -8(%esp)
# emit-expr (cons ((primitive-ref string->symbol) "not") (vector-ref f6513 0))
# cons arg1=((primitive-ref string->symbol) "not") arg2=(vector-ref f6513 0)
# emit-expr ((primitive-ref string->symbol) "not")
# funcall
#    si   =-12
#    env  = ((f6513 . 0))
#    expr = (funcall (primitive-ref string->symbol) "not")
# emit-expr (primitive-ref string->symbol)
    .extern mrc_string$m$gsymbol
    movl mrc_string$m$gsymbol,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_39577"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_39577":
   movl %eax,  -20(%esp)  # stash funcall-oper in closure slot
# emit-expr "not"
# string literal
    jmp _L_39579
    .align 8,0x90
_L_39578 :
    .int 12
    .ascii "not"
_L_39579:
    movl $_L_39578, %eax
    orl $6, %eax
    mov %eax, -24(%esp)  # arg not
    movl -20(%esp), %edi   # load new closure to %edi
    add $-12, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $12, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    movl %eax, -12(%esp)
# emit-expr (vector-ref f6513 0)
# emit-expr f6513
# emit-variable-ref
# env=((f6513 . 0))
# var=f6513
    movl 0(%esp), %eax  # stack load f6513
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_39580
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_39580:
    movl %eax, -16(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_39581"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_39581:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_39583
    cmp  $0,%eax
    jge _L_39582
_L_39583:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_39582:
    movl -16(%esp), %esi
    movl -1(%eax,%esi), %eax
    movl %eax, 4(%ebp)
    movl -12(%esp), %eax
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    or   $1, %al
    add  $8, %ebp
# cons end
    movl -4(%esp), %ebx
    movl -8(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "eof-object") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "eof-object?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f6513 0))) (closure () (f6513) (let () (vector-ref f6513 0))))
# emit-begin
#   expr=(begin (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "eof-object") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "eof-object?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f6513 0))) (closure () (f6513) (let () (vector-ref f6513 0))))
#   env=((f6513 . 0))
# emit-expr (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f6513 0)))
# emit-expr f6513
# emit-variable-ref
# env=((f6513 . 0))
# var=f6513
    movl 0(%esp), %eax  # stack load f6513
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_39584
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_39584:
    movl %eax, -4(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_39585"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_39585:
# check bounds on vector index
    movl -4(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_39587
    cmp  $0,%eax
    jge _L_39586
_L_39587:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_39586:
    movl %eax, -8(%esp)
# emit-expr (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f6513 0))
# cons arg1=((primitive-ref string->symbol) "boolean?") arg2=(vector-ref f6513 0)
# emit-expr ((primitive-ref string->symbol) "boolean?")
# funcall
#    si   =-12
#    env  = ((f6513 . 0))
#    expr = (funcall (primitive-ref string->symbol) "boolean?")
# emit-expr (primitive-ref string->symbol)
    .extern mrc_string$m$gsymbol
    movl mrc_string$m$gsymbol,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_39588"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_39588":
   movl %eax,  -20(%esp)  # stash funcall-oper in closure slot
# emit-expr "boolean?"
# string literal
    jmp _L_39590
    .align 8,0x90
_L_39589 :
    .int 32
    .ascii "boolean?"
_L_39590:
    movl $_L_39589, %eax
    orl $6, %eax
    mov %eax, -24(%esp)  # arg boolean?
    movl -20(%esp), %edi   # load new closure to %edi
    add $-12, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $12, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    movl %eax, -12(%esp)
# emit-expr (vector-ref f6513 0)
# emit-expr f6513
# emit-variable-ref
# env=((f6513 . 0))
# var=f6513
    movl 0(%esp), %eax  # stack load f6513
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_39591
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_39591:
    movl %eax, -16(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_39592"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_39592:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_39594
    cmp  $0,%eax
    jge _L_39593
_L_39594:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_39593:
    movl -16(%esp), %esi
    movl -1(%eax,%esi), %eax
    movl %eax, 4(%ebp)
    movl -12(%esp), %eax
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    or   $1, %al
    add  $8, %ebp
# cons end
    movl -4(%esp), %ebx
    movl -8(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "eof-object") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "eof-object?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f6513 0))) (closure () (f6513) (let () (vector-ref f6513 0))))
# emit-begin
#   expr=(begin (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "eof-object") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "eof-object?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f6513 0))) (closure () (f6513) (let () (vector-ref f6513 0))))
#   env=((f6513 . 0))
# emit-expr (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f6513 0)))
# emit-expr f6513
# emit-variable-ref
# env=((f6513 . 0))
# var=f6513
    movl 0(%esp), %eax  # stack load f6513
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_39595
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_39595:
    movl %eax, -4(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_39596"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_39596:
# check bounds on vector index
    movl -4(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_39598
    cmp  $0,%eax
    jge _L_39597
_L_39598:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_39597:
    movl %eax, -8(%esp)
# emit-expr (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f6513 0))
# cons arg1=((primitive-ref string->symbol) "fixnum?") arg2=(vector-ref f6513 0)
# emit-expr ((primitive-ref string->symbol) "fixnum?")
# funcall
#    si   =-12
#    env  = ((f6513 . 0))
#    expr = (funcall (primitive-ref string->symbol) "fixnum?")
# emit-expr (primitive-ref string->symbol)
    .extern mrc_string$m$gsymbol
    movl mrc_string$m$gsymbol,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_39599"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_39599":
   movl %eax,  -20(%esp)  # stash funcall-oper in closure slot
# emit-expr "fixnum?"
# string literal
    jmp _L_39601
    .align 8,0x90
_L_39600 :
    .int 28
    .ascii "fixnum?"
_L_39601:
    movl $_L_39600, %eax
    orl $6, %eax
    mov %eax, -24(%esp)  # arg fixnum?
    movl -20(%esp), %edi   # load new closure to %edi
    add $-12, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $12, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    movl %eax, -12(%esp)
# emit-expr (vector-ref f6513 0)
# emit-expr f6513
# emit-variable-ref
# env=((f6513 . 0))
# var=f6513
    movl 0(%esp), %eax  # stack load f6513
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_39602
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_39602:
    movl %eax, -16(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_39603"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_39603:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_39605
    cmp  $0,%eax
    jge _L_39604
_L_39605:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_39604:
    movl -16(%esp), %esi
    movl -1(%eax,%esi), %eax
    movl %eax, 4(%ebp)
    movl -12(%esp), %eax
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    or   $1, %al
    add  $8, %ebp
# cons end
    movl -4(%esp), %ebx
    movl -8(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "eof-object") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "eof-object?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f6513 0))) (closure () (f6513) (let () (vector-ref f6513 0))))
# emit-begin
#   expr=(begin (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "eof-object") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "eof-object?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f6513 0))) (closure () (f6513) (let () (vector-ref f6513 0))))
#   env=((f6513 . 0))
# emit-expr (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f6513 0)))
# emit-expr f6513
# emit-variable-ref
# env=((f6513 . 0))
# var=f6513
    movl 0(%esp), %eax  # stack load f6513
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_39606
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_39606:
    movl %eax, -4(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_39607"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_39607:
# check bounds on vector index
    movl -4(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_39609
    cmp  $0,%eax
    jge _L_39608
_L_39609:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_39608:
    movl %eax, -8(%esp)
# emit-expr (cons ((primitive-ref string->symbol) "char?") (vector-ref f6513 0))
# cons arg1=((primitive-ref string->symbol) "char?") arg2=(vector-ref f6513 0)
# emit-expr ((primitive-ref string->symbol) "char?")
# funcall
#    si   =-12
#    env  = ((f6513 . 0))
#    expr = (funcall (primitive-ref string->symbol) "char?")
# emit-expr (primitive-ref string->symbol)
    .extern mrc_string$m$gsymbol
    movl mrc_string$m$gsymbol,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_39610"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_39610":
   movl %eax,  -20(%esp)  # stash funcall-oper in closure slot
# emit-expr "char?"
# string literal
    jmp _L_39612
    .align 8,0x90
_L_39611 :
    .int 20
    .ascii "char?"
_L_39612:
    movl $_L_39611, %eax
    orl $6, %eax
    mov %eax, -24(%esp)  # arg char?
    movl -20(%esp), %edi   # load new closure to %edi
    add $-12, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $12, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    movl %eax, -12(%esp)
# emit-expr (vector-ref f6513 0)
# emit-expr f6513
# emit-variable-ref
# env=((f6513 . 0))
# var=f6513
    movl 0(%esp), %eax  # stack load f6513
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_39613
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_39613:
    movl %eax, -16(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_39614"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_39614:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_39616
    cmp  $0,%eax
    jge _L_39615
_L_39616:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_39615:
    movl -16(%esp), %esi
    movl -1(%eax,%esi), %eax
    movl %eax, 4(%ebp)
    movl -12(%esp), %eax
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    or   $1, %al
    add  $8, %ebp
# cons end
    movl -4(%esp), %ebx
    movl -8(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "eof-object") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "eof-object?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f6513 0))) (closure () (f6513) (let () (vector-ref f6513 0))))
# emit-begin
#   expr=(begin (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "eof-object") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "eof-object?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f6513 0))) (closure () (f6513) (let () (vector-ref f6513 0))))
#   env=((f6513 . 0))
# emit-expr (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "eof-object") (vector-ref f6513 0)))
# emit-expr f6513
# emit-variable-ref
# env=((f6513 . 0))
# var=f6513
    movl 0(%esp), %eax  # stack load f6513
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_39617
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_39617:
    movl %eax, -4(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_39618"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_39618:
# check bounds on vector index
    movl -4(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_39620
    cmp  $0,%eax
    jge _L_39619
_L_39620:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_39619:
    movl %eax, -8(%esp)
# emit-expr (cons ((primitive-ref string->symbol) "eof-object") (vector-ref f6513 0))
# cons arg1=((primitive-ref string->symbol) "eof-object") arg2=(vector-ref f6513 0)
# emit-expr ((primitive-ref string->symbol) "eof-object")
# funcall
#    si   =-12
#    env  = ((f6513 . 0))
#    expr = (funcall (primitive-ref string->symbol) "eof-object")
# emit-expr (primitive-ref string->symbol)
    .extern mrc_string$m$gsymbol
    movl mrc_string$m$gsymbol,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_39621"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_39621":
   movl %eax,  -20(%esp)  # stash funcall-oper in closure slot
# emit-expr "eof-object"
# string literal
    jmp _L_39623
    .align 8,0x90
_L_39622 :
    .int 40
    .ascii "eof-object"
_L_39623:
    movl $_L_39622, %eax
    orl $6, %eax
    mov %eax, -24(%esp)  # arg eof-object
    movl -20(%esp), %edi   # load new closure to %edi
    add $-12, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $12, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    movl %eax, -12(%esp)
# emit-expr (vector-ref f6513 0)
# emit-expr f6513
# emit-variable-ref
# env=((f6513 . 0))
# var=f6513
    movl 0(%esp), %eax  # stack load f6513
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_39624
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_39624:
    movl %eax, -16(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_39625"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_39625:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_39627
    cmp  $0,%eax
    jge _L_39626
_L_39627:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_39626:
    movl -16(%esp), %esi
    movl -1(%eax,%esi), %eax
    movl %eax, 4(%ebp)
    movl -12(%esp), %eax
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    or   $1, %al
    add  $8, %ebp
# cons end
    movl -4(%esp), %ebx
    movl -8(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "eof-object?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f6513 0))) (closure () (f6513) (let () (vector-ref f6513 0))))
# emit-begin
#   expr=(begin (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "eof-object?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f6513 0))) (closure () (f6513) (let () (vector-ref f6513 0))))
#   env=((f6513 . 0))
# emit-expr (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "eof-object?") (vector-ref f6513 0)))
# emit-expr f6513
# emit-variable-ref
# env=((f6513 . 0))
# var=f6513
    movl 0(%esp), %eax  # stack load f6513
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_39628
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_39628:
    movl %eax, -4(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_39629"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_39629:
# check bounds on vector index
    movl -4(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_39631
    cmp  $0,%eax
    jge _L_39630
_L_39631:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_39630:
    movl %eax, -8(%esp)
# emit-expr (cons ((primitive-ref string->symbol) "eof-object?") (vector-ref f6513 0))
# cons arg1=((primitive-ref string->symbol) "eof-object?") arg2=(vector-ref f6513 0)
# emit-expr ((primitive-ref string->symbol) "eof-object?")
# funcall
#    si   =-12
#    env  = ((f6513 . 0))
#    expr = (funcall (primitive-ref string->symbol) "eof-object?")
# emit-expr (primitive-ref string->symbol)
    .extern mrc_string$m$gsymbol
    movl mrc_string$m$gsymbol,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_39632"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_39632":
   movl %eax,  -20(%esp)  # stash funcall-oper in closure slot
# emit-expr "eof-object?"
# string literal
    jmp _L_39634
    .align 8,0x90
_L_39633 :
    .int 44
    .ascii "eof-object?"
_L_39634:
    movl $_L_39633, %eax
    orl $6, %eax
    mov %eax, -24(%esp)  # arg eof-object?
    movl -20(%esp), %edi   # load new closure to %edi
    add $-12, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $12, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    movl %eax, -12(%esp)
# emit-expr (vector-ref f6513 0)
# emit-expr f6513
# emit-variable-ref
# env=((f6513 . 0))
# var=f6513
    movl 0(%esp), %eax  # stack load f6513
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_39635
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_39635:
    movl %eax, -16(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_39636"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_39636:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_39638
    cmp  $0,%eax
    jge _L_39637
_L_39638:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_39637:
    movl -16(%esp), %esi
    movl -1(%eax,%esi), %eax
    movl %eax, 4(%ebp)
    movl -12(%esp), %eax
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    or   $1, %al
    add  $8, %ebp
# cons end
    movl -4(%esp), %ebx
    movl -8(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f6513 0))) (closure () (f6513) (let () (vector-ref f6513 0))))
# emit-begin
#   expr=(begin (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f6513 0))) (closure () (f6513) (let () (vector-ref f6513 0))))
#   env=((f6513 . 0))
# emit-expr (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f6513 0)))
# emit-expr f6513
# emit-variable-ref
# env=((f6513 . 0))
# var=f6513
    movl 0(%esp), %eax  # stack load f6513
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_39639
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_39639:
    movl %eax, -4(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_39640"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_39640:
# check bounds on vector index
    movl -4(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_39642
    cmp  $0,%eax
    jge _L_39641
_L_39642:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_39641:
    movl %eax, -8(%esp)
# emit-expr (cons ((primitive-ref string->symbol) "null?") (vector-ref f6513 0))
# cons arg1=((primitive-ref string->symbol) "null?") arg2=(vector-ref f6513 0)
# emit-expr ((primitive-ref string->symbol) "null?")
# funcall
#    si   =-12
#    env  = ((f6513 . 0))
#    expr = (funcall (primitive-ref string->symbol) "null?")
# emit-expr (primitive-ref string->symbol)
    .extern mrc_string$m$gsymbol
    movl mrc_string$m$gsymbol,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_39643"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_39643":
   movl %eax,  -20(%esp)  # stash funcall-oper in closure slot
# emit-expr "null?"
# string literal
    jmp _L_39645
    .align 8,0x90
_L_39644 :
    .int 20
    .ascii "null?"
_L_39645:
    movl $_L_39644, %eax
    orl $6, %eax
    mov %eax, -24(%esp)  # arg null?
    movl -20(%esp), %edi   # load new closure to %edi
    add $-12, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $12, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    movl %eax, -12(%esp)
# emit-expr (vector-ref f6513 0)
# emit-expr f6513
# emit-variable-ref
# env=((f6513 . 0))
# var=f6513
    movl 0(%esp), %eax  # stack load f6513
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_39646
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_39646:
    movl %eax, -16(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_39647"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_39647:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_39649
    cmp  $0,%eax
    jge _L_39648
_L_39649:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_39648:
    movl -16(%esp), %esi
    movl -1(%eax,%esi), %eax
    movl %eax, 4(%ebp)
    movl -12(%esp), %eax
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    or   $1, %al
    add  $8, %ebp
# cons end
    movl -4(%esp), %ebx
    movl -8(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f6513 0))) (closure () (f6513) (let () (vector-ref f6513 0))))
# emit-begin
#   expr=(begin (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f6513 0))) (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f6513 0))) (closure () (f6513) (let () (vector-ref f6513 0))))
#   env=((f6513 . 0))
# emit-expr (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f6513 0)))
# emit-expr f6513
# emit-variable-ref
# env=((f6513 . 0))
# var=f6513
    movl 0(%esp), %eax  # stack load f6513
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_39650
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_39650:
    movl %eax, -4(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_39651"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_39651:
# check bounds on vector index
    movl -4(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_39653
    cmp  $0,%eax
    jge _L_39652
_L_39653:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_39652:
    movl %eax, -8(%esp)
# emit-expr (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f6513 0))
# cons arg1=((primitive-ref string->symbol) "char->fixnum") arg2=(vector-ref f6513 0)
# emit-expr ((primitive-ref string->symbol) "char->fixnum")
# funcall
#    si   =-12
#    env  = ((f6513 . 0))
#    expr = (funcall (primitive-ref string->symbol) "char->fixnum")
# emit-expr (primitive-ref string->symbol)
    .extern mrc_string$m$gsymbol
    movl mrc_string$m$gsymbol,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_39654"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_39654":
   movl %eax,  -20(%esp)  # stash funcall-oper in closure slot
# emit-expr "char->fixnum"
# string literal
    jmp _L_39656
    .align 8,0x90
_L_39655 :
    .int 48
    .ascii "char->fixnum"
_L_39656:
    movl $_L_39655, %eax
    orl $6, %eax
    mov %eax, -24(%esp)  # arg char->fixnum
    movl -20(%esp), %edi   # load new closure to %edi
    add $-12, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $12, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    movl %eax, -12(%esp)
# emit-expr (vector-ref f6513 0)
# emit-expr f6513
# emit-variable-ref
# env=((f6513 . 0))
# var=f6513
    movl 0(%esp), %eax  # stack load f6513
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_39657
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_39657:
    movl %eax, -16(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_39658"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_39658:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_39660
    cmp  $0,%eax
    jge _L_39659
_L_39660:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_39659:
    movl -16(%esp), %esi
    movl -1(%eax,%esi), %eax
    movl %eax, 4(%ebp)
    movl -12(%esp), %eax
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    or   $1, %al
    add  $8, %ebp
# cons end
    movl -4(%esp), %ebx
    movl -8(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f6513 0))) (closure () (f6513) (let () (vector-ref f6513 0))))
# emit-begin
#   expr=(begin (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f6513 0))) (closure () (f6513) (let () (vector-ref f6513 0))))
#   env=((f6513 . 0))
# emit-expr (vector-set! f6513 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f6513 0)))
# emit-expr f6513
# emit-variable-ref
# env=((f6513 . 0))
# var=f6513
    movl 0(%esp), %eax  # stack load f6513
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_39661
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_39661:
    movl %eax, -4(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_39662"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_39662:
# check bounds on vector index
    movl -4(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_39664
    cmp  $0,%eax
    jge _L_39663
_L_39664:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_39663:
    movl %eax, -8(%esp)
# emit-expr (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f6513 0))
# cons arg1=((primitive-ref string->symbol) "fixnum->char") arg2=(vector-ref f6513 0)
# emit-expr ((primitive-ref string->symbol) "fixnum->char")
# funcall
#    si   =-12
#    env  = ((f6513 . 0))
#    expr = (funcall (primitive-ref string->symbol) "fixnum->char")
# emit-expr (primitive-ref string->symbol)
    .extern mrc_string$m$gsymbol
    movl mrc_string$m$gsymbol,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_39665"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_39665":
   movl %eax,  -20(%esp)  # stash funcall-oper in closure slot
# emit-expr "fixnum->char"
# string literal
    jmp _L_39667
    .align 8,0x90
_L_39666 :
    .int 48
    .ascii "fixnum->char"
_L_39667:
    movl $_L_39666, %eax
    orl $6, %eax
    mov %eax, -24(%esp)  # arg fixnum->char
    movl -20(%esp), %edi   # load new closure to %edi
    add $-12, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $12, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    movl %eax, -12(%esp)
# emit-expr (vector-ref f6513 0)
# emit-expr f6513
# emit-variable-ref
# env=((f6513 . 0))
# var=f6513
    movl 0(%esp), %eax  # stack load f6513
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_39668
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_39668:
    movl %eax, -16(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_39669"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_39669:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_39671
    cmp  $0,%eax
    jge _L_39670
_L_39671:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_39670:
    movl -16(%esp), %esi
    movl -1(%eax,%esi), %eax
    movl %eax, 4(%ebp)
    movl -12(%esp), %eax
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    or   $1, %al
    add  $8, %ebp
# cons end
    movl -4(%esp), %ebx
    movl -8(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin (closure () (f6513) (let () (vector-ref f6513 0))))
# emit-begin
#   expr=(begin (closure () (f6513) (let () (vector-ref f6513 0))))
#   env=((f6513 . 0))
# emit-expr (closure () (f6513) (let () (vector-ref f6513 0)))
# emit-closure
# si = -4
# env = ((f6513 . 0))
# expr = (closure () (f6513) (let () (vector-ref f6513 0)))
    movl $_L_39672, 0(%ebp)  # closure label
# emit-variable-ref
# env=((f6513 . 0))
# var=f6513
    movl 0(%esp), %eax  # stack load f6513
# end emit-variable-ref
   movl  %eax, 4(%ebp)  # f6513
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $8, %ebp     # bump ebp
    jmp _L_39673            # jump around closure body
_L_39672:
# check argument count
    cmp $0,%eax
    je _L_39674
# invoke error handler eh_argcount
    .extern mrc_eh$uargcount
    movl mrc_eh$uargcount, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_39674:
# emit-tail-expr
# si=-8
# env=((f6513 . 4) (f6513 . 0))
# expr=(let () (vector-ref f6513 0))
# emit-tail-let
#  si   = -8
#  env  = ((f6513 . 4) (f6513 . 0))
#  bindings = ()
#  body = (vector-ref f6513 0)
# emit-tail-expr
# si=-8
# env=((f6513 . 4) (f6513 . 0))
# expr=(vector-ref f6513 0)
# tail primcall
# emit-expr f6513
# emit-variable-ref
# env=((f6513 . 4) (f6513 . 0))
# var=f6513
    movl 2(%edi), %eax  # frame load f6513
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_39675
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_39675:
    movl %eax, -8(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_39676"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_39676:
# check bounds on vector index
    movl -8(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_39678
    cmp  $0,%eax
    jge _L_39677
_L_39678:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_39677:
    movl -8(%esp), %esi
    movl -1(%eax,%esi), %eax
#return from tail (vector-ref f6513 0)
    ret
    .align 4,0x90
_L_39673:
# emit-expr (begin)
# emit-begin
#   expr=(begin)
#   env=((f6513 . 0))
     movl %eax, mrc_primitives
# == explicit-begins  ==>
# (lambda () (error (quote funcall) "arg 1 must be a procedure"))
# == eliminate-let*  ==>
# (lambda () (error (quote funcall) "arg 1 must be a procedure"))
# == uniquify-variables  ==>
# (lambda () (error (quote funcall) "arg 1 must be a procedure"))
# == vectorize-letrec  ==>
# (lambda () (error (quote funcall) "arg 1 must be a procedure"))
# == eliminate-set!  ==>
# (lambda () (let () (error (quote funcall) "arg 1 must be a procedure")))
# == close-free-variables  ==>
# (closure () (error funcall) (let () (error (quote funcall) "arg 1 must be a procedure")))
# == eliminate-quote  ==>
# (closure () (error funcall) (let () (error (string->symbol "funcall") "arg 1 must be a procedure")))
# == eliminate-when/unless  ==>
# (closure () (error funcall) (let () (error (string->symbol "funcall") "arg 1 must be a procedure")))
# == eliminate-cond  ==>
# (closure () (error funcall) (let () (error (string->symbol "funcall") "arg 1 must be a procedure")))
# == external-symbols  ==>
# (closure () ((primitive-ref error) funcall) (let () ((primitive-ref error) ((primitive-ref string->symbol) "funcall") "arg 1 must be a procedure")))
# emit-expr (closure () ((primitive-ref error) funcall) (let () ((primitive-ref error) ((primitive-ref string->symbol) "funcall") "arg 1 must be a procedure")))
# emit-closure
# si = 0
# env = ()
# expr = (closure () ((primitive-ref error) funcall) (let () ((primitive-ref error) ((primitive-ref string->symbol) "funcall") "arg 1 must be a procedure")))
    movl $_L_39679, 0(%ebp)  # closure label
# WARNING: free var (primitive-ref error) not defined in the environmnet
# WARNING: free var funcall not defined in the environmnet
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $16, %ebp     # bump ebp
    jmp _L_39680            # jump around closure body
_L_39679:
# check argument count
    cmp $0,%eax
    je _L_39681
# invoke error handler eh_argcount
    .extern mrc_eh$uargcount
    movl mrc_eh$uargcount, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_39681:
# emit-tail-expr
# si=-8
# env=((funcall . 8) ((primitive-ref error) . 4))
# expr=(let () ((primitive-ref error) ((primitive-ref string->symbol) "funcall") "arg 1 must be a procedure"))
# emit-tail-let
#  si   = -8
#  env  = ((funcall . 8) ((primitive-ref error) . 4))
#  bindings = ()
#  body = ((primitive-ref error) ((primitive-ref string->symbol) "funcall") "arg 1 must be a procedure")
# emit-tail-expr
# si=-8
# env=((funcall . 8) ((primitive-ref error) . 4))
# expr=((primitive-ref error) ((primitive-ref string->symbol) "funcall") "arg 1 must be a procedure")
# emit-tail-funcall
#    si   =-8
#    env  = ((funcall . 8) ((primitive-ref error) . 4))
#    expr = (funcall (primitive-ref error) ((primitive-ref string->symbol) "funcall") "arg 1 must be a procedure")
# emit-expr (primitive-ref error)
    .extern mrc_error
    movl mrc_error,%eax
   movl %eax,  -8(%esp)  # stash funcall-oper in next closure slot
# emit-expr ((primitive-ref string->symbol) "funcall")
# funcall
#    si   =-12
#    env  = ((funcall . 8) ((primitive-ref error) . 4))
#    expr = (funcall (primitive-ref string->symbol) "funcall")
# emit-expr (primitive-ref string->symbol)
    .extern mrc_string$m$gsymbol
    movl mrc_string$m$gsymbol,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_39682"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_39682":
   movl %eax,  -20(%esp)  # stash funcall-oper in closure slot
# emit-expr "funcall"
# string literal
    jmp _L_39684
    .align 8,0x90
_L_39683 :
    .int 28
    .ascii "funcall"
_L_39684:
    movl $_L_39683, %eax
    orl $6, %eax
    mov %eax, -24(%esp)  # arg funcall
    movl -20(%esp), %edi   # load new closure to %edi
    add $-12, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $12, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    mov %eax, -12(%esp)    # arg ((primitive-ref string->symbol) funcall)
# emit-expr "arg 1 must be a procedure"
# string literal
    jmp _L_39686
    .align 8,0x90
_L_39685 :
    .int 100
    .ascii "arg 1 must be a procedure"
_L_39686:
    movl $_L_39685, %eax
    orl $6, %eax
    mov %eax, -16(%esp)    # arg arg 1 must be a procedure
    movl -8(%esp), %edi   # load new closure to %edi
# emit-shift-args:  size=3   si=-8  delta=4
    mov -8(%esp), %ebx  # shift frame cell
    mov %ebx, -4(%esp)  # down to base
# emit-shift-args:  size=2   si=-12  delta=4
    mov -12(%esp), %ebx  # shift frame cell
    mov %ebx, -8(%esp)  # down to base
# emit-shift-args:  size=1   si=-16  delta=4
    mov -16(%esp), %ebx  # shift frame cell
    mov %ebx, -12(%esp)  # down to base
# emit-shift-args:  size=0   si=-20  delta=4
    movl $8,%eax   # save arg count
    jmp *-2(%edi)  # tail-funcall
    .align 4,0x90
_L_39680:
     movl %eax, mrc_eh$uprocedure
# == explicit-begins  ==>
# (lambda () (error (quote funcall) "wrong number of args"))
# == eliminate-let*  ==>
# (lambda () (error (quote funcall) "wrong number of args"))
# == uniquify-variables  ==>
# (lambda () (error (quote funcall) "wrong number of args"))
# == vectorize-letrec  ==>
# (lambda () (error (quote funcall) "wrong number of args"))
# == eliminate-set!  ==>
# (lambda () (let () (error (quote funcall) "wrong number of args")))
# == close-free-variables  ==>
# (closure () (error funcall) (let () (error (quote funcall) "wrong number of args")))
# == eliminate-quote  ==>
# (closure () (error funcall) (let () (error (string->symbol "funcall") "wrong number of args")))
# == eliminate-when/unless  ==>
# (closure () (error funcall) (let () (error (string->symbol "funcall") "wrong number of args")))
# == eliminate-cond  ==>
# (closure () (error funcall) (let () (error (string->symbol "funcall") "wrong number of args")))
# == external-symbols  ==>
# (closure () ((primitive-ref error) funcall) (let () ((primitive-ref error) ((primitive-ref string->symbol) "funcall") "wrong number of args")))
# emit-expr (closure () ((primitive-ref error) funcall) (let () ((primitive-ref error) ((primitive-ref string->symbol) "funcall") "wrong number of args")))
# emit-closure
# si = 0
# env = ()
# expr = (closure () ((primitive-ref error) funcall) (let () ((primitive-ref error) ((primitive-ref string->symbol) "funcall") "wrong number of args")))
    movl $_L_39687, 0(%ebp)  # closure label
# WARNING: free var (primitive-ref error) not defined in the environmnet
# WARNING: free var funcall not defined in the environmnet
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $16, %ebp     # bump ebp
    jmp _L_39688            # jump around closure body
_L_39687:
# check argument count
    cmp $0,%eax
    je _L_39689
# invoke error handler eh_argcount
    .extern mrc_eh$uargcount
    movl mrc_eh$uargcount, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_39689:
# emit-tail-expr
# si=-8
# env=((funcall . 8) ((primitive-ref error) . 4))
# expr=(let () ((primitive-ref error) ((primitive-ref string->symbol) "funcall") "wrong number of args"))
# emit-tail-let
#  si   = -8
#  env  = ((funcall . 8) ((primitive-ref error) . 4))
#  bindings = ()
#  body = ((primitive-ref error) ((primitive-ref string->symbol) "funcall") "wrong number of args")
# emit-tail-expr
# si=-8
# env=((funcall . 8) ((primitive-ref error) . 4))
# expr=((primitive-ref error) ((primitive-ref string->symbol) "funcall") "wrong number of args")
# emit-tail-funcall
#    si   =-8
#    env  = ((funcall . 8) ((primitive-ref error) . 4))
#    expr = (funcall (primitive-ref error) ((primitive-ref string->symbol) "funcall") "wrong number of args")
# emit-expr (primitive-ref error)
    .extern mrc_error
    movl mrc_error,%eax
   movl %eax,  -8(%esp)  # stash funcall-oper in next closure slot
# emit-expr ((primitive-ref string->symbol) "funcall")
# funcall
#    si   =-12
#    env  = ((funcall . 8) ((primitive-ref error) . 4))
#    expr = (funcall (primitive-ref string->symbol) "funcall")
# emit-expr (primitive-ref string->symbol)
    .extern mrc_string$m$gsymbol
    movl mrc_string$m$gsymbol,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_39690"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_39690":
   movl %eax,  -20(%esp)  # stash funcall-oper in closure slot
# emit-expr "funcall"
# string literal
    jmp _L_39692
    .align 8,0x90
_L_39691 :
    .int 28
    .ascii "funcall"
_L_39692:
    movl $_L_39691, %eax
    orl $6, %eax
    mov %eax, -24(%esp)  # arg funcall
    movl -20(%esp), %edi   # load new closure to %edi
    add $-12, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $12, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    mov %eax, -12(%esp)    # arg ((primitive-ref string->symbol) funcall)
# emit-expr "wrong number of args"
# string literal
    jmp _L_39694
    .align 8,0x90
_L_39693 :
    .int 80
    .ascii "wrong number of args"
_L_39694:
    movl $_L_39693, %eax
    orl $6, %eax
    mov %eax, -16(%esp)    # arg wrong number of args
    movl -8(%esp), %edi   # load new closure to %edi
# emit-shift-args:  size=3   si=-8  delta=4
    mov -8(%esp), %ebx  # shift frame cell
    mov %ebx, -4(%esp)  # down to base
# emit-shift-args:  size=2   si=-12  delta=4
    mov -12(%esp), %ebx  # shift frame cell
    mov %ebx, -8(%esp)  # down to base
# emit-shift-args:  size=1   si=-16  delta=4
    mov -16(%esp), %ebx  # shift frame cell
    mov %ebx, -12(%esp)  # down to base
# emit-shift-args:  size=0   si=-20  delta=4
    movl $8,%eax   # save arg count
    jmp *-2(%edi)  # tail-funcall
    .align 4,0x90
_L_39688:
     movl %eax, mrc_eh$uargcount
# == explicit-begins  ==>
# (lambda () (error (quote funcall) "too few args"))
# == eliminate-let*  ==>
# (lambda () (error (quote funcall) "too few args"))
# == uniquify-variables  ==>
# (lambda () (error (quote funcall) "too few args"))
# == vectorize-letrec  ==>
# (lambda () (error (quote funcall) "too few args"))
# == eliminate-set!  ==>
# (lambda () (let () (error (quote funcall) "too few args")))
# == close-free-variables  ==>
# (closure () (error funcall) (let () (error (quote funcall) "too few args")))
# == eliminate-quote  ==>
# (closure () (error funcall) (let () (error (string->symbol "funcall") "too few args")))
# == eliminate-when/unless  ==>
# (closure () (error funcall) (let () (error (string->symbol "funcall") "too few args")))
# == eliminate-cond  ==>
# (closure () (error funcall) (let () (error (string->symbol "funcall") "too few args")))
# == external-symbols  ==>
# (closure () ((primitive-ref error) funcall) (let () ((primitive-ref error) ((primitive-ref string->symbol) "funcall") "too few args")))
# emit-expr (closure () ((primitive-ref error) funcall) (let () ((primitive-ref error) ((primitive-ref string->symbol) "funcall") "too few args")))
# emit-closure
# si = 0
# env = ()
# expr = (closure () ((primitive-ref error) funcall) (let () ((primitive-ref error) ((primitive-ref string->symbol) "funcall") "too few args")))
    movl $_L_39695, 0(%ebp)  # closure label
# WARNING: free var (primitive-ref error) not defined in the environmnet
# WARNING: free var funcall not defined in the environmnet
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $16, %ebp     # bump ebp
    jmp _L_39696            # jump around closure body
_L_39695:
# check argument count
    cmp $0,%eax
    je _L_39697
# invoke error handler eh_argcount
    .extern mrc_eh$uargcount
    movl mrc_eh$uargcount, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_39697:
# emit-tail-expr
# si=-8
# env=((funcall . 8) ((primitive-ref error) . 4))
# expr=(let () ((primitive-ref error) ((primitive-ref string->symbol) "funcall") "too few args"))
# emit-tail-let
#  si   = -8
#  env  = ((funcall . 8) ((primitive-ref error) . 4))
#  bindings = ()
#  body = ((primitive-ref error) ((primitive-ref string->symbol) "funcall") "too few args")
# emit-tail-expr
# si=-8
# env=((funcall . 8) ((primitive-ref error) . 4))
# expr=((primitive-ref error) ((primitive-ref string->symbol) "funcall") "too few args")
# emit-tail-funcall
#    si   =-8
#    env  = ((funcall . 8) ((primitive-ref error) . 4))
#    expr = (funcall (primitive-ref error) ((primitive-ref string->symbol) "funcall") "too few args")
# emit-expr (primitive-ref error)
    .extern mrc_error
    movl mrc_error,%eax
   movl %eax,  -8(%esp)  # stash funcall-oper in next closure slot
# emit-expr ((primitive-ref string->symbol) "funcall")
# funcall
#    si   =-12
#    env  = ((funcall . 8) ((primitive-ref error) . 4))
#    expr = (funcall (primitive-ref string->symbol) "funcall")
# emit-expr (primitive-ref string->symbol)
    .extern mrc_string$m$gsymbol
    movl mrc_string$m$gsymbol,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_39698"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_39698":
   movl %eax,  -20(%esp)  # stash funcall-oper in closure slot
# emit-expr "funcall"
# string literal
    jmp _L_39700
    .align 8,0x90
_L_39699 :
    .int 28
    .ascii "funcall"
_L_39700:
    movl $_L_39699, %eax
    orl $6, %eax
    mov %eax, -24(%esp)  # arg funcall
    movl -20(%esp), %edi   # load new closure to %edi
    add $-12, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $12, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    mov %eax, -12(%esp)    # arg ((primitive-ref string->symbol) funcall)
# emit-expr "too few args"
# string literal
    jmp _L_39702
    .align 8,0x90
_L_39701 :
    .int 48
    .ascii "too few args"
_L_39702:
    movl $_L_39701, %eax
    orl $6, %eax
    mov %eax, -16(%esp)    # arg too few args
    movl -8(%esp), %edi   # load new closure to %edi
# emit-shift-args:  size=3   si=-8  delta=4
    mov -8(%esp), %ebx  # shift frame cell
    mov %ebx, -4(%esp)  # down to base
# emit-shift-args:  size=2   si=-12  delta=4
    mov -12(%esp), %ebx  # shift frame cell
    mov %ebx, -8(%esp)  # down to base
# emit-shift-args:  size=1   si=-16  delta=4
    mov -16(%esp), %ebx  # shift frame cell
    mov %ebx, -12(%esp)  # down to base
# emit-shift-args:  size=0   si=-20  delta=4
    movl $8,%eax   # save arg count
    jmp *-2(%edi)  # tail-funcall
    .align 4,0x90
_L_39696:
     movl %eax, mrc_eh$uargcount$umin
# == explicit-begins  ==>
# (lambda (i) (error (list-ref (primitives) i) "arg must be a fixnum"))
# == eliminate-let*  ==>
# (lambda (i) (error (list-ref (primitives) i) "arg must be a fixnum"))
# == uniquify-variables  ==>
# (lambda (f6514) (error (list-ref (primitives) f6514) "arg must be a fixnum"))
# == vectorize-letrec  ==>
# (lambda (f6514) (error (list-ref (primitives) f6514) "arg must be a fixnum"))
# == eliminate-set!  ==>
# (lambda (f6514) (let ((f6514 f6514)) (error (list-ref (primitives) f6514) "arg must be a fixnum")))
# == close-free-variables  ==>
# (closure (f6514) (error list-ref primitives) (let ((f6514 f6514)) (error (list-ref (primitives) f6514) "arg must be a fixnum")))
# == eliminate-quote  ==>
# (closure (f6514) (error list-ref primitives) (let ((f6514 f6514)) (error (list-ref (primitives) f6514) "arg must be a fixnum")))
# == eliminate-when/unless  ==>
# (closure (f6514) (error list-ref primitives) (let ((f6514 f6514)) (error (list-ref (primitives) f6514) "arg must be a fixnum")))
# == eliminate-cond  ==>
# (closure (f6514) (error list-ref primitives) (let ((f6514 f6514)) (error (list-ref (primitives) f6514) "arg must be a fixnum")))
# == external-symbols  ==>
# (closure (f6514) ((primitive-ref error) (primitive-ref list-ref) (primitive-ref primitives)) (let ((f6514 f6514)) ((primitive-ref error) ((primitive-ref list-ref) ((primitive-ref primitives)) f6514) "arg must be a fixnum")))
# emit-expr (closure (f6514) ((primitive-ref error) (primitive-ref list-ref) (primitive-ref primitives)) (let ((f6514 f6514)) ((primitive-ref error) ((primitive-ref list-ref) ((primitive-ref primitives)) f6514) "arg must be a fixnum")))
# emit-closure
# si = 0
# env = ()
# expr = (closure (f6514) ((primitive-ref error) (primitive-ref list-ref) (primitive-ref primitives)) (let ((f6514 f6514)) ((primitive-ref error) ((primitive-ref list-ref) ((primitive-ref primitives)) f6514) "arg must be a fixnum")))
    movl $_L_39703, 0(%ebp)  # closure label
# WARNING: free var (primitive-ref error) not defined in the environmnet
# WARNING: free var (primitive-ref list-ref) not defined in the environmnet
# WARNING: free var (primitive-ref primitives) not defined in the environmnet
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $16, %ebp     # bump ebp
    jmp _L_39704            # jump around closure body
_L_39703:
# check argument count
    cmp $4,%eax
    je _L_39705
# invoke error handler eh_argcount
    .extern mrc_eh$uargcount
    movl mrc_eh$uargcount, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_39705:
# emit-tail-expr
# si=-12
# env=((f6514 . -8) ((primitive-ref primitives) . 12) ((primitive-ref list-ref) . 8) ((primitive-ref error) . 4))
# expr=(let ((f6514 f6514)) ((primitive-ref error) ((primitive-ref list-ref) ((primitive-ref primitives)) f6514) "arg must be a fixnum"))
# emit-tail-let
#  si   = -12
#  env  = ((f6514 . -8) ((primitive-ref primitives) . 12) ((primitive-ref list-ref) . 8) ((primitive-ref error) . 4))
#  bindings = ((f6514 f6514))
#  body = ((primitive-ref error) ((primitive-ref list-ref) ((primitive-ref primitives)) f6514) "arg must be a fixnum")
# emit-expr f6514
# emit-variable-ref
# env=((f6514 . -8) ((primitive-ref primitives) . 12) ((primitive-ref list-ref) . 8) ((primitive-ref error) . 4))
# var=f6514
    movl -8(%esp), %eax  # stack load f6514
# end emit-variable-ref
    movl %eax, -12(%esp)  # stack save
# emit-tail-expr
# si=-16
# env=((f6514 . -12) (f6514 . -8) ((primitive-ref primitives) . 12) ((primitive-ref list-ref) . 8) ((primitive-ref error) . 4))
# expr=((primitive-ref error) ((primitive-ref list-ref) ((primitive-ref primitives)) f6514) "arg must be a fixnum")
# emit-tail-funcall
#    si   =-16
#    env  = ((f6514 . -12) (f6514 . -8) ((primitive-ref primitives) . 12) ((primitive-ref list-ref) . 8) ((primitive-ref error) . 4))
#    expr = (funcall (primitive-ref error) ((primitive-ref list-ref) ((primitive-ref primitives)) f6514) "arg must be a fixnum")
# emit-expr (primitive-ref error)
    .extern mrc_error
    movl mrc_error,%eax
   movl %eax,  -16(%esp)  # stash funcall-oper in next closure slot
# emit-expr ((primitive-ref list-ref) ((primitive-ref primitives)) f6514)
# funcall
#    si   =-20
#    env  = ((f6514 . -12) (f6514 . -8) ((primitive-ref primitives) . 12) ((primitive-ref list-ref) . 8) ((primitive-ref error) . 4))
#    expr = (funcall (primitive-ref list-ref) ((primitive-ref primitives)) f6514)
# emit-expr (primitive-ref list-ref)
    .extern mrc_list$mref
    movl mrc_list$mref,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_39706"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_39706":
   movl %eax,  -28(%esp)  # stash funcall-oper in closure slot
# emit-expr ((primitive-ref primitives))
# funcall
#    si   =-32
#    env  = ((f6514 . -12) (f6514 . -8) ((primitive-ref primitives) . 12) ((primitive-ref list-ref) . 8) ((primitive-ref error) . 4))
#    expr = (funcall (primitive-ref primitives))
# emit-expr (primitive-ref primitives)
    .extern mrc_primitives
    movl mrc_primitives,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_39707"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_39707":
   movl %eax,  -40(%esp)  # stash funcall-oper in closure slot
    movl -40(%esp), %edi   # load new closure to %edi
    add $-32, %esp   # adjust base
    movl $0,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $32, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    mov %eax, -32(%esp)  # arg ((primitive-ref primitives))
# emit-expr f6514
# emit-variable-ref
# env=((f6514 . -12) (f6514 . -8) ((primitive-ref primitives) . 12) ((primitive-ref list-ref) . 8) ((primitive-ref error) . 4))
# var=f6514
    movl -12(%esp), %eax  # stack load f6514
# end emit-variable-ref
    mov %eax, -36(%esp)  # arg f6514
    movl -28(%esp), %edi   # load new closure to %edi
    add $-20, %esp   # adjust base
    movl $8,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $20, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    mov %eax, -20(%esp)    # arg ((primitive-ref list-ref) ((primitive-ref primitives)) f6514)
# emit-expr "arg must be a fixnum"
# string literal
    jmp _L_39709
    .align 8,0x90
_L_39708 :
    .int 80
    .ascii "arg must be a fixnum"
_L_39709:
    movl $_L_39708, %eax
    orl $6, %eax
    mov %eax, -24(%esp)    # arg arg must be a fixnum
    movl -16(%esp), %edi   # load new closure to %edi
# emit-shift-args:  size=3   si=-16  delta=12
    mov -16(%esp), %ebx  # shift frame cell
    mov %ebx, -4(%esp)  # down to base
# emit-shift-args:  size=2   si=-20  delta=12
    mov -20(%esp), %ebx  # shift frame cell
    mov %ebx, -8(%esp)  # down to base
# emit-shift-args:  size=1   si=-24  delta=12
    mov -24(%esp), %ebx  # shift frame cell
    mov %ebx, -12(%esp)  # down to base
# emit-shift-args:  size=0   si=-28  delta=12
    movl $8,%eax   # save arg count
    jmp *-2(%edi)  # tail-funcall
    .align 4,0x90
_L_39704:
     movl %eax, mrc_eh$ufixnum
# == explicit-begins  ==>
# (lambda (i) (error (list-ref (primitives) i) "arg must be a string"))
# == eliminate-let*  ==>
# (lambda (i) (error (list-ref (primitives) i) "arg must be a string"))
# == uniquify-variables  ==>
# (lambda (f6515) (error (list-ref (primitives) f6515) "arg must be a string"))
# == vectorize-letrec  ==>
# (lambda (f6515) (error (list-ref (primitives) f6515) "arg must be a string"))
# == eliminate-set!  ==>
# (lambda (f6515) (let ((f6515 f6515)) (error (list-ref (primitives) f6515) "arg must be a string")))
# == close-free-variables  ==>
# (closure (f6515) (error list-ref primitives) (let ((f6515 f6515)) (error (list-ref (primitives) f6515) "arg must be a string")))
# == eliminate-quote  ==>
# (closure (f6515) (error list-ref primitives) (let ((f6515 f6515)) (error (list-ref (primitives) f6515) "arg must be a string")))
# == eliminate-when/unless  ==>
# (closure (f6515) (error list-ref primitives) (let ((f6515 f6515)) (error (list-ref (primitives) f6515) "arg must be a string")))
# == eliminate-cond  ==>
# (closure (f6515) (error list-ref primitives) (let ((f6515 f6515)) (error (list-ref (primitives) f6515) "arg must be a string")))
# == external-symbols  ==>
# (closure (f6515) ((primitive-ref error) (primitive-ref list-ref) (primitive-ref primitives)) (let ((f6515 f6515)) ((primitive-ref error) ((primitive-ref list-ref) ((primitive-ref primitives)) f6515) "arg must be a string")))
# emit-expr (closure (f6515) ((primitive-ref error) (primitive-ref list-ref) (primitive-ref primitives)) (let ((f6515 f6515)) ((primitive-ref error) ((primitive-ref list-ref) ((primitive-ref primitives)) f6515) "arg must be a string")))
# emit-closure
# si = 0
# env = ()
# expr = (closure (f6515) ((primitive-ref error) (primitive-ref list-ref) (primitive-ref primitives)) (let ((f6515 f6515)) ((primitive-ref error) ((primitive-ref list-ref) ((primitive-ref primitives)) f6515) "arg must be a string")))
    movl $_L_39710, 0(%ebp)  # closure label
# WARNING: free var (primitive-ref error) not defined in the environmnet
# WARNING: free var (primitive-ref list-ref) not defined in the environmnet
# WARNING: free var (primitive-ref primitives) not defined in the environmnet
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $16, %ebp     # bump ebp
    jmp _L_39711            # jump around closure body
_L_39710:
# check argument count
    cmp $4,%eax
    je _L_39712
# invoke error handler eh_argcount
    .extern mrc_eh$uargcount
    movl mrc_eh$uargcount, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_39712:
# emit-tail-expr
# si=-12
# env=((f6515 . -8) ((primitive-ref primitives) . 12) ((primitive-ref list-ref) . 8) ((primitive-ref error) . 4))
# expr=(let ((f6515 f6515)) ((primitive-ref error) ((primitive-ref list-ref) ((primitive-ref primitives)) f6515) "arg must be a string"))
# emit-tail-let
#  si   = -12
#  env  = ((f6515 . -8) ((primitive-ref primitives) . 12) ((primitive-ref list-ref) . 8) ((primitive-ref error) . 4))
#  bindings = ((f6515 f6515))
#  body = ((primitive-ref error) ((primitive-ref list-ref) ((primitive-ref primitives)) f6515) "arg must be a string")
# emit-expr f6515
# emit-variable-ref
# env=((f6515 . -8) ((primitive-ref primitives) . 12) ((primitive-ref list-ref) . 8) ((primitive-ref error) . 4))
# var=f6515
    movl -8(%esp), %eax  # stack load f6515
# end emit-variable-ref
    movl %eax, -12(%esp)  # stack save
# emit-tail-expr
# si=-16
# env=((f6515 . -12) (f6515 . -8) ((primitive-ref primitives) . 12) ((primitive-ref list-ref) . 8) ((primitive-ref error) . 4))
# expr=((primitive-ref error) ((primitive-ref list-ref) ((primitive-ref primitives)) f6515) "arg must be a string")
# emit-tail-funcall
#    si   =-16
#    env  = ((f6515 . -12) (f6515 . -8) ((primitive-ref primitives) . 12) ((primitive-ref list-ref) . 8) ((primitive-ref error) . 4))
#    expr = (funcall (primitive-ref error) ((primitive-ref list-ref) ((primitive-ref primitives)) f6515) "arg must be a string")
# emit-expr (primitive-ref error)
    .extern mrc_error
    movl mrc_error,%eax
   movl %eax,  -16(%esp)  # stash funcall-oper in next closure slot
# emit-expr ((primitive-ref list-ref) ((primitive-ref primitives)) f6515)
# funcall
#    si   =-20
#    env  = ((f6515 . -12) (f6515 . -8) ((primitive-ref primitives) . 12) ((primitive-ref list-ref) . 8) ((primitive-ref error) . 4))
#    expr = (funcall (primitive-ref list-ref) ((primitive-ref primitives)) f6515)
# emit-expr (primitive-ref list-ref)
    .extern mrc_list$mref
    movl mrc_list$mref,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_39713"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_39713":
   movl %eax,  -28(%esp)  # stash funcall-oper in closure slot
# emit-expr ((primitive-ref primitives))
# funcall
#    si   =-32
#    env  = ((f6515 . -12) (f6515 . -8) ((primitive-ref primitives) . 12) ((primitive-ref list-ref) . 8) ((primitive-ref error) . 4))
#    expr = (funcall (primitive-ref primitives))
# emit-expr (primitive-ref primitives)
    .extern mrc_primitives
    movl mrc_primitives,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_39714"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_39714":
   movl %eax,  -40(%esp)  # stash funcall-oper in closure slot
    movl -40(%esp), %edi   # load new closure to %edi
    add $-32, %esp   # adjust base
    movl $0,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $32, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    mov %eax, -32(%esp)  # arg ((primitive-ref primitives))
# emit-expr f6515
# emit-variable-ref
# env=((f6515 . -12) (f6515 . -8) ((primitive-ref primitives) . 12) ((primitive-ref list-ref) . 8) ((primitive-ref error) . 4))
# var=f6515
    movl -12(%esp), %eax  # stack load f6515
# end emit-variable-ref
    mov %eax, -36(%esp)  # arg f6515
    movl -28(%esp), %edi   # load new closure to %edi
    add $-20, %esp   # adjust base
    movl $8,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $20, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    mov %eax, -20(%esp)    # arg ((primitive-ref list-ref) ((primitive-ref primitives)) f6515)
# emit-expr "arg must be a string"
# string literal
    jmp _L_39716
    .align 8,0x90
_L_39715 :
    .int 80
    .ascii "arg must be a string"
_L_39716:
    movl $_L_39715, %eax
    orl $6, %eax
    mov %eax, -24(%esp)    # arg arg must be a string
    movl -16(%esp), %edi   # load new closure to %edi
# emit-shift-args:  size=3   si=-16  delta=12
    mov -16(%esp), %ebx  # shift frame cell
    mov %ebx, -4(%esp)  # down to base
# emit-shift-args:  size=2   si=-20  delta=12
    mov -20(%esp), %ebx  # shift frame cell
    mov %ebx, -8(%esp)  # down to base
# emit-shift-args:  size=1   si=-24  delta=12
    mov -24(%esp), %ebx  # shift frame cell
    mov %ebx, -12(%esp)  # down to base
# emit-shift-args:  size=0   si=-28  delta=12
    movl $8,%eax   # save arg count
    jmp *-2(%edi)  # tail-funcall
    .align 4,0x90
_L_39711:
     movl %eax, mrc_eh$ustring
# == explicit-begins  ==>
# (lambda (i) (error (list-ref (primitives) i) "arg must be a character"))
# == eliminate-let*  ==>
# (lambda (i) (error (list-ref (primitives) i) "arg must be a character"))
# == uniquify-variables  ==>
# (lambda (f6516) (error (list-ref (primitives) f6516) "arg must be a character"))
# == vectorize-letrec  ==>
# (lambda (f6516) (error (list-ref (primitives) f6516) "arg must be a character"))
# == eliminate-set!  ==>
# (lambda (f6516) (let ((f6516 f6516)) (error (list-ref (primitives) f6516) "arg must be a character")))
# == close-free-variables  ==>
# (closure (f6516) (error list-ref primitives) (let ((f6516 f6516)) (error (list-ref (primitives) f6516) "arg must be a character")))
# == eliminate-quote  ==>
# (closure (f6516) (error list-ref primitives) (let ((f6516 f6516)) (error (list-ref (primitives) f6516) "arg must be a character")))
# == eliminate-when/unless  ==>
# (closure (f6516) (error list-ref primitives) (let ((f6516 f6516)) (error (list-ref (primitives) f6516) "arg must be a character")))
# == eliminate-cond  ==>
# (closure (f6516) (error list-ref primitives) (let ((f6516 f6516)) (error (list-ref (primitives) f6516) "arg must be a character")))
# == external-symbols  ==>
# (closure (f6516) ((primitive-ref error) (primitive-ref list-ref) (primitive-ref primitives)) (let ((f6516 f6516)) ((primitive-ref error) ((primitive-ref list-ref) ((primitive-ref primitives)) f6516) "arg must be a character")))
# emit-expr (closure (f6516) ((primitive-ref error) (primitive-ref list-ref) (primitive-ref primitives)) (let ((f6516 f6516)) ((primitive-ref error) ((primitive-ref list-ref) ((primitive-ref primitives)) f6516) "arg must be a character")))
# emit-closure
# si = 0
# env = ()
# expr = (closure (f6516) ((primitive-ref error) (primitive-ref list-ref) (primitive-ref primitives)) (let ((f6516 f6516)) ((primitive-ref error) ((primitive-ref list-ref) ((primitive-ref primitives)) f6516) "arg must be a character")))
    movl $_L_39717, 0(%ebp)  # closure label
# WARNING: free var (primitive-ref error) not defined in the environmnet
# WARNING: free var (primitive-ref list-ref) not defined in the environmnet
# WARNING: free var (primitive-ref primitives) not defined in the environmnet
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $16, %ebp     # bump ebp
    jmp _L_39718            # jump around closure body
_L_39717:
# check argument count
    cmp $4,%eax
    je _L_39719
# invoke error handler eh_argcount
    .extern mrc_eh$uargcount
    movl mrc_eh$uargcount, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_39719:
# emit-tail-expr
# si=-12
# env=((f6516 . -8) ((primitive-ref primitives) . 12) ((primitive-ref list-ref) . 8) ((primitive-ref error) . 4))
# expr=(let ((f6516 f6516)) ((primitive-ref error) ((primitive-ref list-ref) ((primitive-ref primitives)) f6516) "arg must be a character"))
# emit-tail-let
#  si   = -12
#  env  = ((f6516 . -8) ((primitive-ref primitives) . 12) ((primitive-ref list-ref) . 8) ((primitive-ref error) . 4))
#  bindings = ((f6516 f6516))
#  body = ((primitive-ref error) ((primitive-ref list-ref) ((primitive-ref primitives)) f6516) "arg must be a character")
# emit-expr f6516
# emit-variable-ref
# env=((f6516 . -8) ((primitive-ref primitives) . 12) ((primitive-ref list-ref) . 8) ((primitive-ref error) . 4))
# var=f6516
    movl -8(%esp), %eax  # stack load f6516
# end emit-variable-ref
    movl %eax, -12(%esp)  # stack save
# emit-tail-expr
# si=-16
# env=((f6516 . -12) (f6516 . -8) ((primitive-ref primitives) . 12) ((primitive-ref list-ref) . 8) ((primitive-ref error) . 4))
# expr=((primitive-ref error) ((primitive-ref list-ref) ((primitive-ref primitives)) f6516) "arg must be a character")
# emit-tail-funcall
#    si   =-16
#    env  = ((f6516 . -12) (f6516 . -8) ((primitive-ref primitives) . 12) ((primitive-ref list-ref) . 8) ((primitive-ref error) . 4))
#    expr = (funcall (primitive-ref error) ((primitive-ref list-ref) ((primitive-ref primitives)) f6516) "arg must be a character")
# emit-expr (primitive-ref error)
    .extern mrc_error
    movl mrc_error,%eax
   movl %eax,  -16(%esp)  # stash funcall-oper in next closure slot
# emit-expr ((primitive-ref list-ref) ((primitive-ref primitives)) f6516)
# funcall
#    si   =-20
#    env  = ((f6516 . -12) (f6516 . -8) ((primitive-ref primitives) . 12) ((primitive-ref list-ref) . 8) ((primitive-ref error) . 4))
#    expr = (funcall (primitive-ref list-ref) ((primitive-ref primitives)) f6516)
# emit-expr (primitive-ref list-ref)
    .extern mrc_list$mref
    movl mrc_list$mref,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_39720"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_39720":
   movl %eax,  -28(%esp)  # stash funcall-oper in closure slot
# emit-expr ((primitive-ref primitives))
# funcall
#    si   =-32
#    env  = ((f6516 . -12) (f6516 . -8) ((primitive-ref primitives) . 12) ((primitive-ref list-ref) . 8) ((primitive-ref error) . 4))
#    expr = (funcall (primitive-ref primitives))
# emit-expr (primitive-ref primitives)
    .extern mrc_primitives
    movl mrc_primitives,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_39721"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_39721":
   movl %eax,  -40(%esp)  # stash funcall-oper in closure slot
    movl -40(%esp), %edi   # load new closure to %edi
    add $-32, %esp   # adjust base
    movl $0,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $32, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    mov %eax, -32(%esp)  # arg ((primitive-ref primitives))
# emit-expr f6516
# emit-variable-ref
# env=((f6516 . -12) (f6516 . -8) ((primitive-ref primitives) . 12) ((primitive-ref list-ref) . 8) ((primitive-ref error) . 4))
# var=f6516
    movl -12(%esp), %eax  # stack load f6516
# end emit-variable-ref
    mov %eax, -36(%esp)  # arg f6516
    movl -28(%esp), %edi   # load new closure to %edi
    add $-20, %esp   # adjust base
    movl $8,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $20, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    mov %eax, -20(%esp)    # arg ((primitive-ref list-ref) ((primitive-ref primitives)) f6516)
# emit-expr "arg must be a character"
# string literal
    jmp _L_39723
    .align 8,0x90
_L_39722 :
    .int 92
    .ascii "arg must be a character"
_L_39723:
    movl $_L_39722, %eax
    orl $6, %eax
    mov %eax, -24(%esp)    # arg arg must be a character
    movl -16(%esp), %edi   # load new closure to %edi
# emit-shift-args:  size=3   si=-16  delta=12
    mov -16(%esp), %ebx  # shift frame cell
    mov %ebx, -4(%esp)  # down to base
# emit-shift-args:  size=2   si=-20  delta=12
    mov -20(%esp), %ebx  # shift frame cell
    mov %ebx, -8(%esp)  # down to base
# emit-shift-args:  size=1   si=-24  delta=12
    mov -24(%esp), %ebx  # shift frame cell
    mov %ebx, -12(%esp)  # down to base
# emit-shift-args:  size=0   si=-28  delta=12
    movl $8,%eax   # save arg count
    jmp *-2(%edi)  # tail-funcall
    .align 4,0x90
_L_39718:
     movl %eax, mrc_eh$ucharacter
# == explicit-begins  ==>
# (lambda (i) (error (list-ref (primitives) i) "arg must be a pair"))
# == eliminate-let*  ==>
# (lambda (i) (error (list-ref (primitives) i) "arg must be a pair"))
# == uniquify-variables  ==>
# (lambda (f6517) (error (list-ref (primitives) f6517) "arg must be a pair"))
# == vectorize-letrec  ==>
# (lambda (f6517) (error (list-ref (primitives) f6517) "arg must be a pair"))
# == eliminate-set!  ==>
# (lambda (f6517) (let ((f6517 f6517)) (error (list-ref (primitives) f6517) "arg must be a pair")))
# == close-free-variables  ==>
# (closure (f6517) (error list-ref primitives) (let ((f6517 f6517)) (error (list-ref (primitives) f6517) "arg must be a pair")))
# == eliminate-quote  ==>
# (closure (f6517) (error list-ref primitives) (let ((f6517 f6517)) (error (list-ref (primitives) f6517) "arg must be a pair")))
# == eliminate-when/unless  ==>
# (closure (f6517) (error list-ref primitives) (let ((f6517 f6517)) (error (list-ref (primitives) f6517) "arg must be a pair")))
# == eliminate-cond  ==>
# (closure (f6517) (error list-ref primitives) (let ((f6517 f6517)) (error (list-ref (primitives) f6517) "arg must be a pair")))
# == external-symbols  ==>
# (closure (f6517) ((primitive-ref error) (primitive-ref list-ref) (primitive-ref primitives)) (let ((f6517 f6517)) ((primitive-ref error) ((primitive-ref list-ref) ((primitive-ref primitives)) f6517) "arg must be a pair")))
# emit-expr (closure (f6517) ((primitive-ref error) (primitive-ref list-ref) (primitive-ref primitives)) (let ((f6517 f6517)) ((primitive-ref error) ((primitive-ref list-ref) ((primitive-ref primitives)) f6517) "arg must be a pair")))
# emit-closure
# si = 0
# env = ()
# expr = (closure (f6517) ((primitive-ref error) (primitive-ref list-ref) (primitive-ref primitives)) (let ((f6517 f6517)) ((primitive-ref error) ((primitive-ref list-ref) ((primitive-ref primitives)) f6517) "arg must be a pair")))
    movl $_L_39724, 0(%ebp)  # closure label
# WARNING: free var (primitive-ref error) not defined in the environmnet
# WARNING: free var (primitive-ref list-ref) not defined in the environmnet
# WARNING: free var (primitive-ref primitives) not defined in the environmnet
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $16, %ebp     # bump ebp
    jmp _L_39725            # jump around closure body
_L_39724:
# check argument count
    cmp $4,%eax
    je _L_39726
# invoke error handler eh_argcount
    .extern mrc_eh$uargcount
    movl mrc_eh$uargcount, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_39726:
# emit-tail-expr
# si=-12
# env=((f6517 . -8) ((primitive-ref primitives) . 12) ((primitive-ref list-ref) . 8) ((primitive-ref error) . 4))
# expr=(let ((f6517 f6517)) ((primitive-ref error) ((primitive-ref list-ref) ((primitive-ref primitives)) f6517) "arg must be a pair"))
# emit-tail-let
#  si   = -12
#  env  = ((f6517 . -8) ((primitive-ref primitives) . 12) ((primitive-ref list-ref) . 8) ((primitive-ref error) . 4))
#  bindings = ((f6517 f6517))
#  body = ((primitive-ref error) ((primitive-ref list-ref) ((primitive-ref primitives)) f6517) "arg must be a pair")
# emit-expr f6517
# emit-variable-ref
# env=((f6517 . -8) ((primitive-ref primitives) . 12) ((primitive-ref list-ref) . 8) ((primitive-ref error) . 4))
# var=f6517
    movl -8(%esp), %eax  # stack load f6517
# end emit-variable-ref
    movl %eax, -12(%esp)  # stack save
# emit-tail-expr
# si=-16
# env=((f6517 . -12) (f6517 . -8) ((primitive-ref primitives) . 12) ((primitive-ref list-ref) . 8) ((primitive-ref error) . 4))
# expr=((primitive-ref error) ((primitive-ref list-ref) ((primitive-ref primitives)) f6517) "arg must be a pair")
# emit-tail-funcall
#    si   =-16
#    env  = ((f6517 . -12) (f6517 . -8) ((primitive-ref primitives) . 12) ((primitive-ref list-ref) . 8) ((primitive-ref error) . 4))
#    expr = (funcall (primitive-ref error) ((primitive-ref list-ref) ((primitive-ref primitives)) f6517) "arg must be a pair")
# emit-expr (primitive-ref error)
    .extern mrc_error
    movl mrc_error,%eax
   movl %eax,  -16(%esp)  # stash funcall-oper in next closure slot
# emit-expr ((primitive-ref list-ref) ((primitive-ref primitives)) f6517)
# funcall
#    si   =-20
#    env  = ((f6517 . -12) (f6517 . -8) ((primitive-ref primitives) . 12) ((primitive-ref list-ref) . 8) ((primitive-ref error) . 4))
#    expr = (funcall (primitive-ref list-ref) ((primitive-ref primitives)) f6517)
# emit-expr (primitive-ref list-ref)
    .extern mrc_list$mref
    movl mrc_list$mref,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_39727"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_39727":
   movl %eax,  -28(%esp)  # stash funcall-oper in closure slot
# emit-expr ((primitive-ref primitives))
# funcall
#    si   =-32
#    env  = ((f6517 . -12) (f6517 . -8) ((primitive-ref primitives) . 12) ((primitive-ref list-ref) . 8) ((primitive-ref error) . 4))
#    expr = (funcall (primitive-ref primitives))
# emit-expr (primitive-ref primitives)
    .extern mrc_primitives
    movl mrc_primitives,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_39728"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_39728":
   movl %eax,  -40(%esp)  # stash funcall-oper in closure slot
    movl -40(%esp), %edi   # load new closure to %edi
    add $-32, %esp   # adjust base
    movl $0,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $32, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    mov %eax, -32(%esp)  # arg ((primitive-ref primitives))
# emit-expr f6517
# emit-variable-ref
# env=((f6517 . -12) (f6517 . -8) ((primitive-ref primitives) . 12) ((primitive-ref list-ref) . 8) ((primitive-ref error) . 4))
# var=f6517
    movl -12(%esp), %eax  # stack load f6517
# end emit-variable-ref
    mov %eax, -36(%esp)  # arg f6517
    movl -28(%esp), %edi   # load new closure to %edi
    add $-20, %esp   # adjust base
    movl $8,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $20, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    mov %eax, -20(%esp)    # arg ((primitive-ref list-ref) ((primitive-ref primitives)) f6517)
# emit-expr "arg must be a pair"
# string literal
    jmp _L_39730
    .align 8,0x90
_L_39729 :
    .int 72
    .ascii "arg must be a pair"
_L_39730:
    movl $_L_39729, %eax
    orl $6, %eax
    mov %eax, -24(%esp)    # arg arg must be a pair
    movl -16(%esp), %edi   # load new closure to %edi
# emit-shift-args:  size=3   si=-16  delta=12
    mov -16(%esp), %ebx  # shift frame cell
    mov %ebx, -4(%esp)  # down to base
# emit-shift-args:  size=2   si=-20  delta=12
    mov -20(%esp), %ebx  # shift frame cell
    mov %ebx, -8(%esp)  # down to base
# emit-shift-args:  size=1   si=-24  delta=12
    mov -24(%esp), %ebx  # shift frame cell
    mov %ebx, -12(%esp)  # down to base
# emit-shift-args:  size=0   si=-28  delta=12
    movl $8,%eax   # save arg count
    jmp *-2(%edi)  # tail-funcall
    .align 4,0x90
_L_39725:
     movl %eax, mrc_eh$upair
# == explicit-begins  ==>
# (lambda (i) (error (list-ref (primitives) i) "arg must be a vector"))
# == eliminate-let*  ==>
# (lambda (i) (error (list-ref (primitives) i) "arg must be a vector"))
# == uniquify-variables  ==>
# (lambda (f6518) (error (list-ref (primitives) f6518) "arg must be a vector"))
# == vectorize-letrec  ==>
# (lambda (f6518) (error (list-ref (primitives) f6518) "arg must be a vector"))
# == eliminate-set!  ==>
# (lambda (f6518) (let ((f6518 f6518)) (error (list-ref (primitives) f6518) "arg must be a vector")))
# == close-free-variables  ==>
# (closure (f6518) (error list-ref primitives) (let ((f6518 f6518)) (error (list-ref (primitives) f6518) "arg must be a vector")))
# == eliminate-quote  ==>
# (closure (f6518) (error list-ref primitives) (let ((f6518 f6518)) (error (list-ref (primitives) f6518) "arg must be a vector")))
# == eliminate-when/unless  ==>
# (closure (f6518) (error list-ref primitives) (let ((f6518 f6518)) (error (list-ref (primitives) f6518) "arg must be a vector")))
# == eliminate-cond  ==>
# (closure (f6518) (error list-ref primitives) (let ((f6518 f6518)) (error (list-ref (primitives) f6518) "arg must be a vector")))
# == external-symbols  ==>
# (closure (f6518) ((primitive-ref error) (primitive-ref list-ref) (primitive-ref primitives)) (let ((f6518 f6518)) ((primitive-ref error) ((primitive-ref list-ref) ((primitive-ref primitives)) f6518) "arg must be a vector")))
# emit-expr (closure (f6518) ((primitive-ref error) (primitive-ref list-ref) (primitive-ref primitives)) (let ((f6518 f6518)) ((primitive-ref error) ((primitive-ref list-ref) ((primitive-ref primitives)) f6518) "arg must be a vector")))
# emit-closure
# si = 0
# env = ()
# expr = (closure (f6518) ((primitive-ref error) (primitive-ref list-ref) (primitive-ref primitives)) (let ((f6518 f6518)) ((primitive-ref error) ((primitive-ref list-ref) ((primitive-ref primitives)) f6518) "arg must be a vector")))
    movl $_L_39731, 0(%ebp)  # closure label
# WARNING: free var (primitive-ref error) not defined in the environmnet
# WARNING: free var (primitive-ref list-ref) not defined in the environmnet
# WARNING: free var (primitive-ref primitives) not defined in the environmnet
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $16, %ebp     # bump ebp
    jmp _L_39732            # jump around closure body
_L_39731:
# check argument count
    cmp $4,%eax
    je _L_39733
# invoke error handler eh_argcount
    .extern mrc_eh$uargcount
    movl mrc_eh$uargcount, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_39733:
# emit-tail-expr
# si=-12
# env=((f6518 . -8) ((primitive-ref primitives) . 12) ((primitive-ref list-ref) . 8) ((primitive-ref error) . 4))
# expr=(let ((f6518 f6518)) ((primitive-ref error) ((primitive-ref list-ref) ((primitive-ref primitives)) f6518) "arg must be a vector"))
# emit-tail-let
#  si   = -12
#  env  = ((f6518 . -8) ((primitive-ref primitives) . 12) ((primitive-ref list-ref) . 8) ((primitive-ref error) . 4))
#  bindings = ((f6518 f6518))
#  body = ((primitive-ref error) ((primitive-ref list-ref) ((primitive-ref primitives)) f6518) "arg must be a vector")
# emit-expr f6518
# emit-variable-ref
# env=((f6518 . -8) ((primitive-ref primitives) . 12) ((primitive-ref list-ref) . 8) ((primitive-ref error) . 4))
# var=f6518
    movl -8(%esp), %eax  # stack load f6518
# end emit-variable-ref
    movl %eax, -12(%esp)  # stack save
# emit-tail-expr
# si=-16
# env=((f6518 . -12) (f6518 . -8) ((primitive-ref primitives) . 12) ((primitive-ref list-ref) . 8) ((primitive-ref error) . 4))
# expr=((primitive-ref error) ((primitive-ref list-ref) ((primitive-ref primitives)) f6518) "arg must be a vector")
# emit-tail-funcall
#    si   =-16
#    env  = ((f6518 . -12) (f6518 . -8) ((primitive-ref primitives) . 12) ((primitive-ref list-ref) . 8) ((primitive-ref error) . 4))
#    expr = (funcall (primitive-ref error) ((primitive-ref list-ref) ((primitive-ref primitives)) f6518) "arg must be a vector")
# emit-expr (primitive-ref error)
    .extern mrc_error
    movl mrc_error,%eax
   movl %eax,  -16(%esp)  # stash funcall-oper in next closure slot
# emit-expr ((primitive-ref list-ref) ((primitive-ref primitives)) f6518)
# funcall
#    si   =-20
#    env  = ((f6518 . -12) (f6518 . -8) ((primitive-ref primitives) . 12) ((primitive-ref list-ref) . 8) ((primitive-ref error) . 4))
#    expr = (funcall (primitive-ref list-ref) ((primitive-ref primitives)) f6518)
# emit-expr (primitive-ref list-ref)
    .extern mrc_list$mref
    movl mrc_list$mref,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_39734"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_39734":
   movl %eax,  -28(%esp)  # stash funcall-oper in closure slot
# emit-expr ((primitive-ref primitives))
# funcall
#    si   =-32
#    env  = ((f6518 . -12) (f6518 . -8) ((primitive-ref primitives) . 12) ((primitive-ref list-ref) . 8) ((primitive-ref error) . 4))
#    expr = (funcall (primitive-ref primitives))
# emit-expr (primitive-ref primitives)
    .extern mrc_primitives
    movl mrc_primitives,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_39735"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_39735":
   movl %eax,  -40(%esp)  # stash funcall-oper in closure slot
    movl -40(%esp), %edi   # load new closure to %edi
    add $-32, %esp   # adjust base
    movl $0,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $32, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    mov %eax, -32(%esp)  # arg ((primitive-ref primitives))
# emit-expr f6518
# emit-variable-ref
# env=((f6518 . -12) (f6518 . -8) ((primitive-ref primitives) . 12) ((primitive-ref list-ref) . 8) ((primitive-ref error) . 4))
# var=f6518
    movl -12(%esp), %eax  # stack load f6518
# end emit-variable-ref
    mov %eax, -36(%esp)  # arg f6518
    movl -28(%esp), %edi   # load new closure to %edi
    add $-20, %esp   # adjust base
    movl $8,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $20, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    mov %eax, -20(%esp)    # arg ((primitive-ref list-ref) ((primitive-ref primitives)) f6518)
# emit-expr "arg must be a vector"
# string literal
    jmp _L_39737
    .align 8,0x90
_L_39736 :
    .int 80
    .ascii "arg must be a vector"
_L_39737:
    movl $_L_39736, %eax
    orl $6, %eax
    mov %eax, -24(%esp)    # arg arg must be a vector
    movl -16(%esp), %edi   # load new closure to %edi
# emit-shift-args:  size=3   si=-16  delta=12
    mov -16(%esp), %ebx  # shift frame cell
    mov %ebx, -4(%esp)  # down to base
# emit-shift-args:  size=2   si=-20  delta=12
    mov -20(%esp), %ebx  # shift frame cell
    mov %ebx, -8(%esp)  # down to base
# emit-shift-args:  size=1   si=-24  delta=12
    mov -24(%esp), %ebx  # shift frame cell
    mov %ebx, -12(%esp)  # down to base
# emit-shift-args:  size=0   si=-28  delta=12
    movl $8,%eax   # save arg count
    jmp *-2(%edi)  # tail-funcall
    .align 4,0x90
_L_39732:
     movl %eax, mrc_eh$uvector
# == explicit-begins  ==>
# (lambda (i) (error (list-ref (primitives) i) "length must be a fixnum >= 0"))
# == eliminate-let*  ==>
# (lambda (i) (error (list-ref (primitives) i) "length must be a fixnum >= 0"))
# == uniquify-variables  ==>
# (lambda (f6519) (error (list-ref (primitives) f6519) "length must be a fixnum >= 0"))
# == vectorize-letrec  ==>
# (lambda (f6519) (error (list-ref (primitives) f6519) "length must be a fixnum >= 0"))
# == eliminate-set!  ==>
# (lambda (f6519) (let ((f6519 f6519)) (error (list-ref (primitives) f6519) "length must be a fixnum >= 0")))
# == close-free-variables  ==>
# (closure (f6519) (error list-ref primitives) (let ((f6519 f6519)) (error (list-ref (primitives) f6519) "length must be a fixnum >= 0")))
# == eliminate-quote  ==>
# (closure (f6519) (error list-ref primitives) (let ((f6519 f6519)) (error (list-ref (primitives) f6519) "length must be a fixnum >= 0")))
# == eliminate-when/unless  ==>
# (closure (f6519) (error list-ref primitives) (let ((f6519 f6519)) (error (list-ref (primitives) f6519) "length must be a fixnum >= 0")))
# == eliminate-cond  ==>
# (closure (f6519) (error list-ref primitives) (let ((f6519 f6519)) (error (list-ref (primitives) f6519) "length must be a fixnum >= 0")))
# == external-symbols  ==>
# (closure (f6519) ((primitive-ref error) (primitive-ref list-ref) (primitive-ref primitives)) (let ((f6519 f6519)) ((primitive-ref error) ((primitive-ref list-ref) ((primitive-ref primitives)) f6519) "length must be a fixnum >= 0")))
# emit-expr (closure (f6519) ((primitive-ref error) (primitive-ref list-ref) (primitive-ref primitives)) (let ((f6519 f6519)) ((primitive-ref error) ((primitive-ref list-ref) ((primitive-ref primitives)) f6519) "length must be a fixnum >= 0")))
# emit-closure
# si = 0
# env = ()
# expr = (closure (f6519) ((primitive-ref error) (primitive-ref list-ref) (primitive-ref primitives)) (let ((f6519 f6519)) ((primitive-ref error) ((primitive-ref list-ref) ((primitive-ref primitives)) f6519) "length must be a fixnum >= 0")))
    movl $_L_39738, 0(%ebp)  # closure label
# WARNING: free var (primitive-ref error) not defined in the environmnet
# WARNING: free var (primitive-ref list-ref) not defined in the environmnet
# WARNING: free var (primitive-ref primitives) not defined in the environmnet
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $16, %ebp     # bump ebp
    jmp _L_39739            # jump around closure body
_L_39738:
# check argument count
    cmp $4,%eax
    je _L_39740
# invoke error handler eh_argcount
    .extern mrc_eh$uargcount
    movl mrc_eh$uargcount, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_39740:
# emit-tail-expr
# si=-12
# env=((f6519 . -8) ((primitive-ref primitives) . 12) ((primitive-ref list-ref) . 8) ((primitive-ref error) . 4))
# expr=(let ((f6519 f6519)) ((primitive-ref error) ((primitive-ref list-ref) ((primitive-ref primitives)) f6519) "length must be a fixnum >= 0"))
# emit-tail-let
#  si   = -12
#  env  = ((f6519 . -8) ((primitive-ref primitives) . 12) ((primitive-ref list-ref) . 8) ((primitive-ref error) . 4))
#  bindings = ((f6519 f6519))
#  body = ((primitive-ref error) ((primitive-ref list-ref) ((primitive-ref primitives)) f6519) "length must be a fixnum >= 0")
# emit-expr f6519
# emit-variable-ref
# env=((f6519 . -8) ((primitive-ref primitives) . 12) ((primitive-ref list-ref) . 8) ((primitive-ref error) . 4))
# var=f6519
    movl -8(%esp), %eax  # stack load f6519
# end emit-variable-ref
    movl %eax, -12(%esp)  # stack save
# emit-tail-expr
# si=-16
# env=((f6519 . -12) (f6519 . -8) ((primitive-ref primitives) . 12) ((primitive-ref list-ref) . 8) ((primitive-ref error) . 4))
# expr=((primitive-ref error) ((primitive-ref list-ref) ((primitive-ref primitives)) f6519) "length must be a fixnum >= 0")
# emit-tail-funcall
#    si   =-16
#    env  = ((f6519 . -12) (f6519 . -8) ((primitive-ref primitives) . 12) ((primitive-ref list-ref) . 8) ((primitive-ref error) . 4))
#    expr = (funcall (primitive-ref error) ((primitive-ref list-ref) ((primitive-ref primitives)) f6519) "length must be a fixnum >= 0")
# emit-expr (primitive-ref error)
    .extern mrc_error
    movl mrc_error,%eax
   movl %eax,  -16(%esp)  # stash funcall-oper in next closure slot
# emit-expr ((primitive-ref list-ref) ((primitive-ref primitives)) f6519)
# funcall
#    si   =-20
#    env  = ((f6519 . -12) (f6519 . -8) ((primitive-ref primitives) . 12) ((primitive-ref list-ref) . 8) ((primitive-ref error) . 4))
#    expr = (funcall (primitive-ref list-ref) ((primitive-ref primitives)) f6519)
# emit-expr (primitive-ref list-ref)
    .extern mrc_list$mref
    movl mrc_list$mref,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_39741"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_39741":
   movl %eax,  -28(%esp)  # stash funcall-oper in closure slot
# emit-expr ((primitive-ref primitives))
# funcall
#    si   =-32
#    env  = ((f6519 . -12) (f6519 . -8) ((primitive-ref primitives) . 12) ((primitive-ref list-ref) . 8) ((primitive-ref error) . 4))
#    expr = (funcall (primitive-ref primitives))
# emit-expr (primitive-ref primitives)
    .extern mrc_primitives
    movl mrc_primitives,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_39742"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_39742":
   movl %eax,  -40(%esp)  # stash funcall-oper in closure slot
    movl -40(%esp), %edi   # load new closure to %edi
    add $-32, %esp   # adjust base
    movl $0,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $32, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    mov %eax, -32(%esp)  # arg ((primitive-ref primitives))
# emit-expr f6519
# emit-variable-ref
# env=((f6519 . -12) (f6519 . -8) ((primitive-ref primitives) . 12) ((primitive-ref list-ref) . 8) ((primitive-ref error) . 4))
# var=f6519
    movl -12(%esp), %eax  # stack load f6519
# end emit-variable-ref
    mov %eax, -36(%esp)  # arg f6519
    movl -28(%esp), %edi   # load new closure to %edi
    add $-20, %esp   # adjust base
    movl $8,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $20, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    mov %eax, -20(%esp)    # arg ((primitive-ref list-ref) ((primitive-ref primitives)) f6519)
# emit-expr "length must be a fixnum >= 0"
# string literal
    jmp _L_39744
    .align 8,0x90
_L_39743 :
    .int 112
    .ascii "length must be a fixnum >= 0"
_L_39744:
    movl $_L_39743, %eax
    orl $6, %eax
    mov %eax, -24(%esp)    # arg length must be a fixnum >= 0
    movl -16(%esp), %edi   # load new closure to %edi
# emit-shift-args:  size=3   si=-16  delta=12
    mov -16(%esp), %ebx  # shift frame cell
    mov %ebx, -4(%esp)  # down to base
# emit-shift-args:  size=2   si=-20  delta=12
    mov -20(%esp), %ebx  # shift frame cell
    mov %ebx, -8(%esp)  # down to base
# emit-shift-args:  size=1   si=-24  delta=12
    mov -24(%esp), %ebx  # shift frame cell
    mov %ebx, -12(%esp)  # down to base
# emit-shift-args:  size=0   si=-28  delta=12
    movl $8,%eax   # save arg count
    jmp *-2(%edi)  # tail-funcall
    .align 4,0x90
_L_39739:
     movl %eax, mrc_eh$ulength
# == explicit-begins  ==>
# (lambda (i) (error (list-ref (primitives) i) "index out of bounds"))
# == eliminate-let*  ==>
# (lambda (i) (error (list-ref (primitives) i) "index out of bounds"))
# == uniquify-variables  ==>
# (lambda (f6520) (error (list-ref (primitives) f6520) "index out of bounds"))
# == vectorize-letrec  ==>
# (lambda (f6520) (error (list-ref (primitives) f6520) "index out of bounds"))
# == eliminate-set!  ==>
# (lambda (f6520) (let ((f6520 f6520)) (error (list-ref (primitives) f6520) "index out of bounds")))
# == close-free-variables  ==>
# (closure (f6520) (error list-ref primitives) (let ((f6520 f6520)) (error (list-ref (primitives) f6520) "index out of bounds")))
# == eliminate-quote  ==>
# (closure (f6520) (error list-ref primitives) (let ((f6520 f6520)) (error (list-ref (primitives) f6520) "index out of bounds")))
# == eliminate-when/unless  ==>
# (closure (f6520) (error list-ref primitives) (let ((f6520 f6520)) (error (list-ref (primitives) f6520) "index out of bounds")))
# == eliminate-cond  ==>
# (closure (f6520) (error list-ref primitives) (let ((f6520 f6520)) (error (list-ref (primitives) f6520) "index out of bounds")))
# == external-symbols  ==>
# (closure (f6520) ((primitive-ref error) (primitive-ref list-ref) (primitive-ref primitives)) (let ((f6520 f6520)) ((primitive-ref error) ((primitive-ref list-ref) ((primitive-ref primitives)) f6520) "index out of bounds")))
# emit-expr (closure (f6520) ((primitive-ref error) (primitive-ref list-ref) (primitive-ref primitives)) (let ((f6520 f6520)) ((primitive-ref error) ((primitive-ref list-ref) ((primitive-ref primitives)) f6520) "index out of bounds")))
# emit-closure
# si = 0
# env = ()
# expr = (closure (f6520) ((primitive-ref error) (primitive-ref list-ref) (primitive-ref primitives)) (let ((f6520 f6520)) ((primitive-ref error) ((primitive-ref list-ref) ((primitive-ref primitives)) f6520) "index out of bounds")))
    movl $_L_39745, 0(%ebp)  # closure label
# WARNING: free var (primitive-ref error) not defined in the environmnet
# WARNING: free var (primitive-ref list-ref) not defined in the environmnet
# WARNING: free var (primitive-ref primitives) not defined in the environmnet
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $16, %ebp     # bump ebp
    jmp _L_39746            # jump around closure body
_L_39745:
# check argument count
    cmp $4,%eax
    je _L_39747
# invoke error handler eh_argcount
    .extern mrc_eh$uargcount
    movl mrc_eh$uargcount, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_39747:
# emit-tail-expr
# si=-12
# env=((f6520 . -8) ((primitive-ref primitives) . 12) ((primitive-ref list-ref) . 8) ((primitive-ref error) . 4))
# expr=(let ((f6520 f6520)) ((primitive-ref error) ((primitive-ref list-ref) ((primitive-ref primitives)) f6520) "index out of bounds"))
# emit-tail-let
#  si   = -12
#  env  = ((f6520 . -8) ((primitive-ref primitives) . 12) ((primitive-ref list-ref) . 8) ((primitive-ref error) . 4))
#  bindings = ((f6520 f6520))
#  body = ((primitive-ref error) ((primitive-ref list-ref) ((primitive-ref primitives)) f6520) "index out of bounds")
# emit-expr f6520
# emit-variable-ref
# env=((f6520 . -8) ((primitive-ref primitives) . 12) ((primitive-ref list-ref) . 8) ((primitive-ref error) . 4))
# var=f6520
    movl -8(%esp), %eax  # stack load f6520
# end emit-variable-ref
    movl %eax, -12(%esp)  # stack save
# emit-tail-expr
# si=-16
# env=((f6520 . -12) (f6520 . -8) ((primitive-ref primitives) . 12) ((primitive-ref list-ref) . 8) ((primitive-ref error) . 4))
# expr=((primitive-ref error) ((primitive-ref list-ref) ((primitive-ref primitives)) f6520) "index out of bounds")
# emit-tail-funcall
#    si   =-16
#    env  = ((f6520 . -12) (f6520 . -8) ((primitive-ref primitives) . 12) ((primitive-ref list-ref) . 8) ((primitive-ref error) . 4))
#    expr = (funcall (primitive-ref error) ((primitive-ref list-ref) ((primitive-ref primitives)) f6520) "index out of bounds")
# emit-expr (primitive-ref error)
    .extern mrc_error
    movl mrc_error,%eax
   movl %eax,  -16(%esp)  # stash funcall-oper in next closure slot
# emit-expr ((primitive-ref list-ref) ((primitive-ref primitives)) f6520)
# funcall
#    si   =-20
#    env  = ((f6520 . -12) (f6520 . -8) ((primitive-ref primitives) . 12) ((primitive-ref list-ref) . 8) ((primitive-ref error) . 4))
#    expr = (funcall (primitive-ref list-ref) ((primitive-ref primitives)) f6520)
# emit-expr (primitive-ref list-ref)
    .extern mrc_list$mref
    movl mrc_list$mref,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_39748"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_39748":
   movl %eax,  -28(%esp)  # stash funcall-oper in closure slot
# emit-expr ((primitive-ref primitives))
# funcall
#    si   =-32
#    env  = ((f6520 . -12) (f6520 . -8) ((primitive-ref primitives) . 12) ((primitive-ref list-ref) . 8) ((primitive-ref error) . 4))
#    expr = (funcall (primitive-ref primitives))
# emit-expr (primitive-ref primitives)
    .extern mrc_primitives
    movl mrc_primitives,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_39749"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_39749":
   movl %eax,  -40(%esp)  # stash funcall-oper in closure slot
    movl -40(%esp), %edi   # load new closure to %edi
    add $-32, %esp   # adjust base
    movl $0,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $32, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    mov %eax, -32(%esp)  # arg ((primitive-ref primitives))
# emit-expr f6520
# emit-variable-ref
# env=((f6520 . -12) (f6520 . -8) ((primitive-ref primitives) . 12) ((primitive-ref list-ref) . 8) ((primitive-ref error) . 4))
# var=f6520
    movl -12(%esp), %eax  # stack load f6520
# end emit-variable-ref
    mov %eax, -36(%esp)  # arg f6520
    movl -28(%esp), %edi   # load new closure to %edi
    add $-20, %esp   # adjust base
    movl $8,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $20, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    mov %eax, -20(%esp)    # arg ((primitive-ref list-ref) ((primitive-ref primitives)) f6520)
# emit-expr "index out of bounds"
# string literal
    jmp _L_39751
    .align 8,0x90
_L_39750 :
    .int 76
    .ascii "index out of bounds"
_L_39751:
    movl $_L_39750, %eax
    orl $6, %eax
    mov %eax, -24(%esp)    # arg index out of bounds
    movl -16(%esp), %edi   # load new closure to %edi
# emit-shift-args:  size=3   si=-16  delta=12
    mov -16(%esp), %ebx  # shift frame cell
    mov %ebx, -4(%esp)  # down to base
# emit-shift-args:  size=2   si=-20  delta=12
    mov -20(%esp), %ebx  # shift frame cell
    mov %ebx, -8(%esp)  # down to base
# emit-shift-args:  size=1   si=-24  delta=12
    mov -24(%esp), %ebx  # shift frame cell
    mov %ebx, -12(%esp)  # down to base
# emit-shift-args:  size=0   si=-28  delta=12
    movl $8,%eax   # save arg count
    jmp *-2(%edi)  # tail-funcall
    .align 4,0x90
_L_39746:
     movl %eax, mrc_eh$uvector$uindex
# == explicit-begins  ==>
# (lambda (i) (error (list-ref (primitives) i) "index out of bounds"))
# == eliminate-let*  ==>
# (lambda (i) (error (list-ref (primitives) i) "index out of bounds"))
# == uniquify-variables  ==>
# (lambda (f6521) (error (list-ref (primitives) f6521) "index out of bounds"))
# == vectorize-letrec  ==>
# (lambda (f6521) (error (list-ref (primitives) f6521) "index out of bounds"))
# == eliminate-set!  ==>
# (lambda (f6521) (let ((f6521 f6521)) (error (list-ref (primitives) f6521) "index out of bounds")))
# == close-free-variables  ==>
# (closure (f6521) (error list-ref primitives) (let ((f6521 f6521)) (error (list-ref (primitives) f6521) "index out of bounds")))
# == eliminate-quote  ==>
# (closure (f6521) (error list-ref primitives) (let ((f6521 f6521)) (error (list-ref (primitives) f6521) "index out of bounds")))
# == eliminate-when/unless  ==>
# (closure (f6521) (error list-ref primitives) (let ((f6521 f6521)) (error (list-ref (primitives) f6521) "index out of bounds")))
# == eliminate-cond  ==>
# (closure (f6521) (error list-ref primitives) (let ((f6521 f6521)) (error (list-ref (primitives) f6521) "index out of bounds")))
# == external-symbols  ==>
# (closure (f6521) ((primitive-ref error) (primitive-ref list-ref) (primitive-ref primitives)) (let ((f6521 f6521)) ((primitive-ref error) ((primitive-ref list-ref) ((primitive-ref primitives)) f6521) "index out of bounds")))
# emit-expr (closure (f6521) ((primitive-ref error) (primitive-ref list-ref) (primitive-ref primitives)) (let ((f6521 f6521)) ((primitive-ref error) ((primitive-ref list-ref) ((primitive-ref primitives)) f6521) "index out of bounds")))
# emit-closure
# si = 0
# env = ()
# expr = (closure (f6521) ((primitive-ref error) (primitive-ref list-ref) (primitive-ref primitives)) (let ((f6521 f6521)) ((primitive-ref error) ((primitive-ref list-ref) ((primitive-ref primitives)) f6521) "index out of bounds")))
    movl $_L_39752, 0(%ebp)  # closure label
# WARNING: free var (primitive-ref error) not defined in the environmnet
# WARNING: free var (primitive-ref list-ref) not defined in the environmnet
# WARNING: free var (primitive-ref primitives) not defined in the environmnet
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $16, %ebp     # bump ebp
    jmp _L_39753            # jump around closure body
_L_39752:
# check argument count
    cmp $4,%eax
    je _L_39754
# invoke error handler eh_argcount
    .extern mrc_eh$uargcount
    movl mrc_eh$uargcount, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_39754:
# emit-tail-expr
# si=-12
# env=((f6521 . -8) ((primitive-ref primitives) . 12) ((primitive-ref list-ref) . 8) ((primitive-ref error) . 4))
# expr=(let ((f6521 f6521)) ((primitive-ref error) ((primitive-ref list-ref) ((primitive-ref primitives)) f6521) "index out of bounds"))
# emit-tail-let
#  si   = -12
#  env  = ((f6521 . -8) ((primitive-ref primitives) . 12) ((primitive-ref list-ref) . 8) ((primitive-ref error) . 4))
#  bindings = ((f6521 f6521))
#  body = ((primitive-ref error) ((primitive-ref list-ref) ((primitive-ref primitives)) f6521) "index out of bounds")
# emit-expr f6521
# emit-variable-ref
# env=((f6521 . -8) ((primitive-ref primitives) . 12) ((primitive-ref list-ref) . 8) ((primitive-ref error) . 4))
# var=f6521
    movl -8(%esp), %eax  # stack load f6521
# end emit-variable-ref
    movl %eax, -12(%esp)  # stack save
# emit-tail-expr
# si=-16
# env=((f6521 . -12) (f6521 . -8) ((primitive-ref primitives) . 12) ((primitive-ref list-ref) . 8) ((primitive-ref error) . 4))
# expr=((primitive-ref error) ((primitive-ref list-ref) ((primitive-ref primitives)) f6521) "index out of bounds")
# emit-tail-funcall
#    si   =-16
#    env  = ((f6521 . -12) (f6521 . -8) ((primitive-ref primitives) . 12) ((primitive-ref list-ref) . 8) ((primitive-ref error) . 4))
#    expr = (funcall (primitive-ref error) ((primitive-ref list-ref) ((primitive-ref primitives)) f6521) "index out of bounds")
# emit-expr (primitive-ref error)
    .extern mrc_error
    movl mrc_error,%eax
   movl %eax,  -16(%esp)  # stash funcall-oper in next closure slot
# emit-expr ((primitive-ref list-ref) ((primitive-ref primitives)) f6521)
# funcall
#    si   =-20
#    env  = ((f6521 . -12) (f6521 . -8) ((primitive-ref primitives) . 12) ((primitive-ref list-ref) . 8) ((primitive-ref error) . 4))
#    expr = (funcall (primitive-ref list-ref) ((primitive-ref primitives)) f6521)
# emit-expr (primitive-ref list-ref)
    .extern mrc_list$mref
    movl mrc_list$mref,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_39755"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_39755":
   movl %eax,  -28(%esp)  # stash funcall-oper in closure slot
# emit-expr ((primitive-ref primitives))
# funcall
#    si   =-32
#    env  = ((f6521 . -12) (f6521 . -8) ((primitive-ref primitives) . 12) ((primitive-ref list-ref) . 8) ((primitive-ref error) . 4))
#    expr = (funcall (primitive-ref primitives))
# emit-expr (primitive-ref primitives)
    .extern mrc_primitives
    movl mrc_primitives,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_39756"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_39756":
   movl %eax,  -40(%esp)  # stash funcall-oper in closure slot
    movl -40(%esp), %edi   # load new closure to %edi
    add $-32, %esp   # adjust base
    movl $0,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $32, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    mov %eax, -32(%esp)  # arg ((primitive-ref primitives))
# emit-expr f6521
# emit-variable-ref
# env=((f6521 . -12) (f6521 . -8) ((primitive-ref primitives) . 12) ((primitive-ref list-ref) . 8) ((primitive-ref error) . 4))
# var=f6521
    movl -12(%esp), %eax  # stack load f6521
# end emit-variable-ref
    mov %eax, -36(%esp)  # arg f6521
    movl -28(%esp), %edi   # load new closure to %edi
    add $-20, %esp   # adjust base
    movl $8,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $20, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    mov %eax, -20(%esp)    # arg ((primitive-ref list-ref) ((primitive-ref primitives)) f6521)
# emit-expr "index out of bounds"
# string literal
    jmp _L_39758
    .align 8,0x90
_L_39757 :
    .int 76
    .ascii "index out of bounds"
_L_39758:
    movl $_L_39757, %eax
    orl $6, %eax
    mov %eax, -24(%esp)    # arg index out of bounds
    movl -16(%esp), %edi   # load new closure to %edi
# emit-shift-args:  size=3   si=-16  delta=12
    mov -16(%esp), %ebx  # shift frame cell
    mov %ebx, -4(%esp)  # down to base
# emit-shift-args:  size=2   si=-20  delta=12
    mov -20(%esp), %ebx  # shift frame cell
    mov %ebx, -8(%esp)  # down to base
# emit-shift-args:  size=1   si=-24  delta=12
    mov -24(%esp), %ebx  # shift frame cell
    mov %ebx, -12(%esp)  # down to base
# emit-shift-args:  size=0   si=-28  delta=12
    movl $8,%eax   # save arg count
    jmp *-2(%edi)  # tail-funcall
    .align 4,0x90
_L_39753:
     movl %eax, mrc_eh$ustring$uindex
# == explicit-begins  ==>
# (lambda (z) (fxzero? z))
# == eliminate-let*  ==>
# (lambda (z) (fxzero? z))
# == uniquify-variables  ==>
# (lambda (f6522) (fxzero? f6522))
# == vectorize-letrec  ==>
# (lambda (f6522) (fxzero? f6522))
# == eliminate-set!  ==>
# (lambda (f6522) (let ((f6522 f6522)) (fxzero? f6522)))
# == close-free-variables  ==>
# (closure (f6522) () (let ((f6522 f6522)) (fxzero? f6522)))
# == eliminate-quote  ==>
# (closure (f6522) () (let ((f6522 f6522)) (fxzero? f6522)))
# == eliminate-when/unless  ==>
# (closure (f6522) () (let ((f6522 f6522)) (fxzero? f6522)))
# == eliminate-cond  ==>
# (closure (f6522) () (let ((f6522 f6522)) (fxzero? f6522)))
# == external-symbols  ==>
# (closure (f6522) () (let ((f6522 f6522)) (fxzero? f6522)))
# emit-expr (closure (f6522) () (let ((f6522 f6522)) (fxzero? f6522)))
# emit-closure
# si = 0
# env = ()
# expr = (closure (f6522) () (let ((f6522 f6522)) (fxzero? f6522)))
    movl $_L_39759, 0(%ebp)  # closure label
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $8, %ebp     # bump ebp
    jmp _L_39760            # jump around closure body
_L_39759:
# check argument count
    cmp $4,%eax
    je _L_39761
# invoke error handler eh_argcount
    .extern mrc_eh$uargcount
    movl mrc_eh$uargcount, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_39761:
# emit-tail-expr
# si=-12
# env=((f6522 . -8))
# expr=(let ((f6522 f6522)) (fxzero? f6522))
# emit-tail-let
#  si   = -12
#  env  = ((f6522 . -8))
#  bindings = ((f6522 f6522))
#  body = (fxzero? f6522)
# emit-expr f6522
# emit-variable-ref
# env=((f6522 . -8))
# var=f6522
    movl -8(%esp), %eax  # stack load f6522
# end emit-variable-ref
    movl %eax, -12(%esp)  # stack save
# emit-tail-expr
# si=-16
# env=((f6522 . -12) (f6522 . -8))
# expr=(fxzero? f6522)
# tail primcall
# emit-expr f6522
# emit-variable-ref
# env=((f6522 . -12) (f6522 . -8))
# var=f6522
    movl -12(%esp), %eax  # stack load f6522
# end emit-variable-ref
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_39762"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $64,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_39762:
    cmp $0, %eax
    sete %al
    movzbl %al, %eax
    sal $6, %al
    or $47, %al
#return from tail (fxzero? f6522)
    ret
    .align 4,0x90
_L_39760:
     movl %eax, mrc_zero$q
# == explicit-begins  ==>
# (lambda (x) (fx> x 0))
# == eliminate-let*  ==>
# (lambda (x) (fx> x 0))
# == uniquify-variables  ==>
# (lambda (f6523) (fx> f6523 0))
# == vectorize-letrec  ==>
# (lambda (f6523) (fx> f6523 0))
# == eliminate-set!  ==>
# (lambda (f6523) (let ((f6523 f6523)) (fx> f6523 0)))
# == close-free-variables  ==>
# (closure (f6523) () (let ((f6523 f6523)) (fx> f6523 0)))
# == eliminate-quote  ==>
# (closure (f6523) () (let ((f6523 f6523)) (fx> f6523 0)))
# == eliminate-when/unless  ==>
# (closure (f6523) () (let ((f6523 f6523)) (fx> f6523 0)))
# == eliminate-cond  ==>
# (closure (f6523) () (let ((f6523 f6523)) (fx> f6523 0)))
# == external-symbols  ==>
# (closure (f6523) () (let ((f6523 f6523)) (fx> f6523 0)))
# emit-expr (closure (f6523) () (let ((f6523 f6523)) (fx> f6523 0)))
# emit-closure
# si = 0
# env = ()
# expr = (closure (f6523) () (let ((f6523 f6523)) (fx> f6523 0)))
    movl $_L_39763, 0(%ebp)  # closure label
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $8, %ebp     # bump ebp
    jmp _L_39764            # jump around closure body
_L_39763:
# check argument count
    cmp $4,%eax
    je _L_39765
# invoke error handler eh_argcount
    .extern mrc_eh$uargcount
    movl mrc_eh$uargcount, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_39765:
# emit-tail-expr
# si=-12
# env=((f6523 . -8))
# expr=(let ((f6523 f6523)) (fx> f6523 0))
# emit-tail-let
#  si   = -12
#  env  = ((f6523 . -8))
#  bindings = ((f6523 f6523))
#  body = (fx> f6523 0)
# emit-expr f6523
# emit-variable-ref
# env=((f6523 . -8))
# var=f6523
    movl -8(%esp), %eax  # stack load f6523
# end emit-variable-ref
    movl %eax, -12(%esp)  # stack save
# emit-tail-expr
# si=-16
# env=((f6523 . -12) (f6523 . -8))
# expr=(fx> f6523 0)
# tail primcall
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_39766"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $80,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_39766:
    movl %eax, -16(%esp)
# emit-expr f6523
# emit-variable-ref
# env=((f6523 . -12) (f6523 . -8))
# var=f6523
    movl -12(%esp), %eax  # stack load f6523
# end emit-variable-ref
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_39767"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $80,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_39767:
    cmp -16(%esp), %eax
    setg %al
    movzbl %al, %eax
    sal $6, %al
    or $47, %al
#return from tail (fx> f6523 0)
    ret
    .align 4,0x90
_L_39764:
     movl %eax, mrc_positive$q
# == explicit-begins  ==>
# (lambda (x) (fx< x 0))
# == eliminate-let*  ==>
# (lambda (x) (fx< x 0))
# == uniquify-variables  ==>
# (lambda (f6524) (fx< f6524 0))
# == vectorize-letrec  ==>
# (lambda (f6524) (fx< f6524 0))
# == eliminate-set!  ==>
# (lambda (f6524) (let ((f6524 f6524)) (fx< f6524 0)))
# == close-free-variables  ==>
# (closure (f6524) () (let ((f6524 f6524)) (fx< f6524 0)))
# == eliminate-quote  ==>
# (closure (f6524) () (let ((f6524 f6524)) (fx< f6524 0)))
# == eliminate-when/unless  ==>
# (closure (f6524) () (let ((f6524 f6524)) (fx< f6524 0)))
# == eliminate-cond  ==>
# (closure (f6524) () (let ((f6524 f6524)) (fx< f6524 0)))
# == external-symbols  ==>
# (closure (f6524) () (let ((f6524 f6524)) (fx< f6524 0)))
# emit-expr (closure (f6524) () (let ((f6524 f6524)) (fx< f6524 0)))
# emit-closure
# si = 0
# env = ()
# expr = (closure (f6524) () (let ((f6524 f6524)) (fx< f6524 0)))
    movl $_L_39768, 0(%ebp)  # closure label
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $8, %ebp     # bump ebp
    jmp _L_39769            # jump around closure body
_L_39768:
# check argument count
    cmp $4,%eax
    je _L_39770
# invoke error handler eh_argcount
    .extern mrc_eh$uargcount
    movl mrc_eh$uargcount, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_39770:
# emit-tail-expr
# si=-12
# env=((f6524 . -8))
# expr=(let ((f6524 f6524)) (fx< f6524 0))
# emit-tail-let
#  si   = -12
#  env  = ((f6524 . -8))
#  bindings = ((f6524 f6524))
#  body = (fx< f6524 0)
# emit-expr f6524
# emit-variable-ref
# env=((f6524 . -8))
# var=f6524
    movl -8(%esp), %eax  # stack load f6524
# end emit-variable-ref
    movl %eax, -12(%esp)  # stack save
# emit-tail-expr
# si=-16
# env=((f6524 . -12) (f6524 . -8))
# expr=(fx< f6524 0)
# tail primcall
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_39771"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $72,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_39771:
    movl %eax, -16(%esp)
# emit-expr f6524
# emit-variable-ref
# env=((f6524 . -12) (f6524 . -8))
# var=f6524
    movl -12(%esp), %eax  # stack load f6524
# end emit-variable-ref
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_39772"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $72,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_39772:
    cmp -16(%esp), %eax
    setl %al
    movzbl %al, %eax
    sal $6, %al
    or $47, %al
#return from tail (fx< f6524 0)
    ret
    .align 4,0x90
_L_39769:
     movl %eax, mrc_negative$q
# == explicit-begins  ==>
# (lambda (x) (fxzero? (fxremainder x 2)))
# == eliminate-let*  ==>
# (lambda (x) (fxzero? (fxremainder x 2)))
# == uniquify-variables  ==>
# (lambda (f6525) (fxzero? (fxremainder f6525 2)))
# == vectorize-letrec  ==>
# (lambda (f6525) (fxzero? (fxremainder f6525 2)))
# == eliminate-set!  ==>
# (lambda (f6525) (let ((f6525 f6525)) (fxzero? (fxremainder f6525 2))))
# == close-free-variables  ==>
# (closure (f6525) () (let ((f6525 f6525)) (fxzero? (fxremainder f6525 2))))
# == eliminate-quote  ==>
# (closure (f6525) () (let ((f6525 f6525)) (fxzero? (fxremainder f6525 2))))
# == eliminate-when/unless  ==>
# (closure (f6525) () (let ((f6525 f6525)) (fxzero? (fxremainder f6525 2))))
# == eliminate-cond  ==>
# (closure (f6525) () (let ((f6525 f6525)) (fxzero? (fxremainder f6525 2))))
# == external-symbols  ==>
# (closure (f6525) () (let ((f6525 f6525)) (fxzero? (fxremainder f6525 2))))
# emit-expr (closure (f6525) () (let ((f6525 f6525)) (fxzero? (fxremainder f6525 2))))
# emit-closure
# si = 0
# env = ()
# expr = (closure (f6525) () (let ((f6525 f6525)) (fxzero? (fxremainder f6525 2))))
    movl $_L_39773, 0(%ebp)  # closure label
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $8, %ebp     # bump ebp
    jmp _L_39774            # jump around closure body
_L_39773:
# check argument count
    cmp $4,%eax
    je _L_39775
# invoke error handler eh_argcount
    .extern mrc_eh$uargcount
    movl mrc_eh$uargcount, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_39775:
# emit-tail-expr
# si=-12
# env=((f6525 . -8))
# expr=(let ((f6525 f6525)) (fxzero? (fxremainder f6525 2)))
# emit-tail-let
#  si   = -12
#  env  = ((f6525 . -8))
#  bindings = ((f6525 f6525))
#  body = (fxzero? (fxremainder f6525 2))
# emit-expr f6525
# emit-variable-ref
# env=((f6525 . -8))
# var=f6525
    movl -8(%esp), %eax  # stack load f6525
# end emit-variable-ref
    movl %eax, -12(%esp)  # stack save
# emit-tail-expr
# si=-16
# env=((f6525 . -12) (f6525 . -8))
# expr=(fxzero? (fxremainder f6525 2))
# tail primcall
# emit-expr (fxremainder f6525 2)
# emit-expr 2
    movl $8, %eax     # immed 2
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_39777"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $100,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_39777:
    movl %eax, -16(%esp)  # denominator
# emit-expr f6525
# emit-variable-ref
# env=((f6525 . -12) (f6525 . -8))
# var=f6525
    movl -12(%esp), %eax  # stack load f6525
# end emit-variable-ref
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_39778"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $100,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_39778:
    movl -16(%esp),%ebx   # ebx <- denominator
    xor %edx,%edx        # edx <- 0
    cmp $0,%eax
    jge _L_39776
    not %edx
_L_39776:
    idiv %ebx            # edx <- edx:eax/ebx  remainder
    movl %edx,%eax
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_39779"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $64,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_39779:
    cmp $0, %eax
    sete %al
    movzbl %al, %eax
    sal $6, %al
    or $47, %al
#return from tail (fxzero? (fxremainder f6525 2))
    ret
    .align 4,0x90
_L_39774:
     movl %eax, mrc_even$q
# == explicit-begins  ==>
# (lambda (x) (not (even? x)))
# == eliminate-let*  ==>
# (lambda (x) (not (even? x)))
# == uniquify-variables  ==>
# (lambda (f6526) (not (even? f6526)))
# == vectorize-letrec  ==>
# (lambda (f6526) (not (even? f6526)))
# == eliminate-set!  ==>
# (lambda (f6526) (let ((f6526 f6526)) (not (even? f6526))))
# == close-free-variables  ==>
# (closure (f6526) (even?) (let ((f6526 f6526)) (not (even? f6526))))
# == eliminate-quote  ==>
# (closure (f6526) (even?) (let ((f6526 f6526)) (not (even? f6526))))
# == eliminate-when/unless  ==>
# (closure (f6526) (even?) (let ((f6526 f6526)) (not (even? f6526))))
# == eliminate-cond  ==>
# (closure (f6526) (even?) (let ((f6526 f6526)) (not (even? f6526))))
# == external-symbols  ==>
# (closure (f6526) ((primitive-ref even?)) (let ((f6526 f6526)) (not ((primitive-ref even?) f6526))))
# emit-expr (closure (f6526) ((primitive-ref even?)) (let ((f6526 f6526)) (not ((primitive-ref even?) f6526))))
# emit-closure
# si = 0
# env = ()
# expr = (closure (f6526) ((primitive-ref even?)) (let ((f6526 f6526)) (not ((primitive-ref even?) f6526))))
    movl $_L_39780, 0(%ebp)  # closure label
# WARNING: free var (primitive-ref even?) not defined in the environmnet
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $8, %ebp     # bump ebp
    jmp _L_39781            # jump around closure body
_L_39780:
# check argument count
    cmp $4,%eax
    je _L_39782
# invoke error handler eh_argcount
    .extern mrc_eh$uargcount
    movl mrc_eh$uargcount, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_39782:
# emit-tail-expr
# si=-12
# env=((f6526 . -8) ((primitive-ref even?) . 4))
# expr=(let ((f6526 f6526)) (not ((primitive-ref even?) f6526)))
# emit-tail-let
#  si   = -12
#  env  = ((f6526 . -8) ((primitive-ref even?) . 4))
#  bindings = ((f6526 f6526))
#  body = (not ((primitive-ref even?) f6526))
# emit-expr f6526
# emit-variable-ref
# env=((f6526 . -8) ((primitive-ref even?) . 4))
# var=f6526
    movl -8(%esp), %eax  # stack load f6526
# end emit-variable-ref
    movl %eax, -12(%esp)  # stack save
# emit-tail-expr
# si=-16
# env=((f6526 . -12) (f6526 . -8) ((primitive-ref even?) . 4))
# expr=(not ((primitive-ref even?) f6526))
# tail primcall
# emit-expr ((primitive-ref even?) f6526)
# funcall
#    si   =-16
#    env  = ((f6526 . -12) (f6526 . -8) ((primitive-ref even?) . 4))
#    expr = (funcall (primitive-ref even?) f6526)
# emit-expr (primitive-ref even?)
    .extern mrc_even$q
    movl mrc_even$q,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_39783"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_39783":
   movl %eax,  -24(%esp)  # stash funcall-oper in closure slot
# emit-expr f6526
# emit-variable-ref
# env=((f6526 . -12) (f6526 . -8) ((primitive-ref even?) . 4))
# var=f6526
    movl -12(%esp), %eax  # stack load f6526
# end emit-variable-ref
    mov %eax, -28(%esp)  # arg f6526
    movl -24(%esp), %edi   # load new closure to %edi
    add $-16, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $16, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    cmp $47, %eax
    sete %al
    movzbl %al, %eax
    sal $6, %al
    or $47, %al
#return from tail (not ((primitive-ref even?) f6526))
    ret
    .align 4,0x90
_L_39781:
     movl %eax, mrc_odd$q
# == explicit-begins  ==>
# (lambda (f l) (if (null? l) (quote ()) (cons (f (car l)) (map f (cdr l)))))
# == eliminate-let*  ==>
# (lambda (f l) (if (null? l) (quote ()) (cons (f (car l)) (map f (cdr l)))))
# == uniquify-variables  ==>
# (lambda (f6527 f6528) (if (null? f6528) (quote ()) (cons (f6527 (car f6528)) (map f6527 (cdr f6528)))))
# == vectorize-letrec  ==>
# (lambda (f6527 f6528) (if (null? f6528) (quote ()) (cons (f6527 (car f6528)) (map f6527 (cdr f6528)))))
# == eliminate-set!  ==>
# (lambda (f6527 f6528) (let ((f6527 f6527) (f6528 f6528)) (if (null? f6528) (quote ()) (cons (f6527 (car f6528)) (map f6527 (cdr f6528))))))
# == close-free-variables  ==>
# (closure (f6527 f6528) (map) (let ((f6527 f6527) (f6528 f6528)) (if (null? f6528) (quote ()) (cons (f6527 (car f6528)) (map f6527 (cdr f6528))))))
# == eliminate-quote  ==>
# (closure (f6527 f6528) (map) (let ((f6527 f6527) (f6528 f6528)) (if (null? f6528) () (cons (f6527 (car f6528)) (map f6527 (cdr f6528))))))
# == eliminate-when/unless  ==>
# (closure (f6527 f6528) (map) (let ((f6527 f6527) (f6528 f6528)) (if (null? f6528) () (cons (f6527 (car f6528)) (map f6527 (cdr f6528))))))
# == eliminate-cond  ==>
# (closure (f6527 f6528) (map) (let ((f6527 f6527) (f6528 f6528)) (if (null? f6528) () (cons (f6527 (car f6528)) (map f6527 (cdr f6528))))))
# == external-symbols  ==>
# (closure (f6527 f6528) ((primitive-ref map)) (let ((f6527 f6527) (f6528 f6528)) (if (null? f6528) () (cons (f6527 (car f6528)) ((primitive-ref map) f6527 (cdr f6528))))))
# emit-expr (closure (f6527 f6528) ((primitive-ref map)) (let ((f6527 f6527) (f6528 f6528)) (if (null? f6528) () (cons (f6527 (car f6528)) ((primitive-ref map) f6527 (cdr f6528))))))
# emit-closure
# si = 0
# env = ()
# expr = (closure (f6527 f6528) ((primitive-ref map)) (let ((f6527 f6527) (f6528 f6528)) (if (null? f6528) () (cons (f6527 (car f6528)) ((primitive-ref map) f6527 (cdr f6528))))))
    movl $_L_39784, 0(%ebp)  # closure label
# WARNING: free var (primitive-ref map) not defined in the environmnet
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $8, %ebp     # bump ebp
    jmp _L_39785            # jump around closure body
_L_39784:
# check argument count
    cmp $8,%eax
    je _L_39786
# invoke error handler eh_argcount
    .extern mrc_eh$uargcount
    movl mrc_eh$uargcount, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_39786:
# emit-tail-expr
# si=-16
# env=((f6528 . -12) (f6527 . -8) ((primitive-ref map) . 4))
# expr=(let ((f6527 f6527) (f6528 f6528)) (if (null? f6528) () (cons (f6527 (car f6528)) ((primitive-ref map) f6527 (cdr f6528)))))
# emit-tail-let
#  si   = -16
#  env  = ((f6528 . -12) (f6527 . -8) ((primitive-ref map) . 4))
#  bindings = ((f6527 f6527) (f6528 f6528))
#  body = (if (null? f6528) () (cons (f6527 (car f6528)) ((primitive-ref map) f6527 (cdr f6528))))
# emit-expr f6527
# emit-variable-ref
# env=((f6528 . -12) (f6527 . -8) ((primitive-ref map) . 4))
# var=f6527
    movl -8(%esp), %eax  # stack load f6527
# end emit-variable-ref
    movl %eax, -16(%esp)  # stack save
# emit-expr f6528
# emit-variable-ref
# env=((f6528 . -12) (f6527 . -8) ((primitive-ref map) . 4))
# var=f6528
    movl -12(%esp), %eax  # stack load f6528
# end emit-variable-ref
    movl %eax, -20(%esp)  # stack save
# emit-tail-expr
# si=-24
# env=((f6528 . -20) (f6527 . -16) (f6528 . -12) (f6527 . -8) ((primitive-ref map) . 4))
# expr=(if (null? f6528) () (cons (f6527 (car f6528)) ((primitive-ref map) f6527 (cdr f6528))))
# emit-expr (null? f6528)
# emit-expr f6528
# emit-variable-ref
# env=((f6528 . -20) (f6527 . -16) (f6528 . -12) (f6527 . -8) ((primitive-ref map) . 4))
# var=f6528
    movl -20(%esp), %eax  # stack load f6528
# end emit-variable-ref
    cmp $63, %eax
    mov $0, %eax
    sete %al
    movzbl %al, %eax
    sal $6, %al
    or $47, %al
    cmp $47, %al
    je _L_39787
# emit-tail-expr
# si=-24
# env=((f6528 . -20) (f6527 . -16) (f6528 . -12) (f6527 . -8) ((primitive-ref map) . 4))
# expr=()
    movl $63, %eax     # immed ()
    ret                  # immediate tail return
    jmp _L_39788
_L_39787:
# emit-tail-expr
# si=-24
# env=((f6528 . -20) (f6527 . -16) (f6528 . -12) (f6527 . -8) ((primitive-ref map) . 4))
# expr=(cons (f6527 (car f6528)) ((primitive-ref map) f6527 (cdr f6528)))
# tail primcall
# cons arg1=(f6527 (car f6528)) arg2=((primitive-ref map) f6527 (cdr f6528))
# emit-expr (f6527 (car f6528))
# funcall
#    si   =-24
#    env  = ((f6528 . -20) (f6527 . -16) (f6528 . -12) (f6527 . -8) ((primitive-ref map) . 4))
#    expr = (funcall f6527 (car f6528))
# emit-expr f6527
# emit-variable-ref
# env=((f6528 . -20) (f6527 . -16) (f6528 . -12) (f6527 . -8) ((primitive-ref map) . 4))
# var=f6527
    movl -16(%esp), %eax  # stack load f6527
# end emit-variable-ref
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_39789"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_39789":
   movl %eax,  -32(%esp)  # stash funcall-oper in closure slot
# emit-expr (car f6528)
# emit-expr f6528
# emit-variable-ref
# env=((f6528 . -20) (f6527 . -16) (f6528 . -12) (f6527 . -8) ((primitive-ref map) . 4))
# var=f6528
    movl -20(%esp), %eax  # stack load f6528
# end emit-variable-ref
# check the argument is a pair
    movl %eax,%ebx
    and $7, %bl
    cmp $1, %bl
    je _L_39790
# invoke error handler eh_pair
    .extern mrc_eh$upair
    movl mrc_eh$upair, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $116,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_39790:
    movl -1(%eax), %eax
    mov %eax, -36(%esp)  # arg (car f6528)
    movl -32(%esp), %edi   # load new closure to %edi
    add $-24, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $24, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    movl %eax, -24(%esp)
# emit-expr ((primitive-ref map) f6527 (cdr f6528))
# funcall
#    si   =-28
#    env  = ((f6528 . -20) (f6527 . -16) (f6528 . -12) (f6527 . -8) ((primitive-ref map) . 4))
#    expr = (funcall (primitive-ref map) f6527 (cdr f6528))
# emit-expr (primitive-ref map)
    .extern mrc_map
    movl mrc_map,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_39791"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_39791":
   movl %eax,  -36(%esp)  # stash funcall-oper in closure slot
# emit-expr f6527
# emit-variable-ref
# env=((f6528 . -20) (f6527 . -16) (f6528 . -12) (f6527 . -8) ((primitive-ref map) . 4))
# var=f6527
    movl -16(%esp), %eax  # stack load f6527
# end emit-variable-ref
    mov %eax, -40(%esp)  # arg f6527
# emit-expr (cdr f6528)
# emit-expr f6528
# emit-variable-ref
# env=((f6528 . -20) (f6527 . -16) (f6528 . -12) (f6527 . -8) ((primitive-ref map) . 4))
# var=f6528
    movl -20(%esp), %eax  # stack load f6528
# end emit-variable-ref
# check the argument is a pair
    movl %eax,%ebx
    and $7, %bl
    cmp $1, %bl
    je _L_39792
# invoke error handler eh_pair
    .extern mrc_eh$upair
    movl mrc_eh$upair, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $120,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_39792:
    movl 3(%eax), %eax
    mov %eax, -44(%esp)  # arg (cdr f6528)
    movl -36(%esp), %edi   # load new closure to %edi
    add $-28, %esp   # adjust base
    movl $8,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $28, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    movl %eax, 4(%ebp)
    movl -24(%esp), %eax
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    or   $1, %al
    add  $8, %ebp
# cons end
#return from tail (cons (f6527 (car f6528)) ((primitive-ref map) f6527 (cdr f6528)))
    ret
_L_39788:
    .align 4,0x90
_L_39785:
     movl %eax, mrc_map
# == explicit-begins  ==>
# (lambda (f l) (unless (null? l) (begin (f (car l)) (for-each f (cdr l)))))
# == eliminate-let*  ==>
# (lambda (f l) (unless (null? l) (begin (f (car l)) (for-each f (cdr l)))))
# == uniquify-variables  ==>
# (lambda (f6529 f6530) (unless (null? f6530) (begin (f6529 (car f6530)) (for-each f6529 (cdr f6530)))))
# == vectorize-letrec  ==>
# (lambda (f6529 f6530) (unless (null? f6530) (begin (f6529 (car f6530)) (for-each f6529 (cdr f6530)))))
# == eliminate-set!  ==>
# (lambda (f6529 f6530) (let ((f6529 f6529) (f6530 f6530)) (unless (null? f6530) (begin (f6529 (car f6530)) (for-each f6529 (cdr f6530))))))
# == close-free-variables  ==>
# (closure (f6529 f6530) (unless for-each) (let ((f6529 f6529) (f6530 f6530)) (unless (null? f6530) (begin (f6529 (car f6530)) (for-each f6529 (cdr f6530))))))
# == eliminate-quote  ==>
# (closure (f6529 f6530) (unless for-each) (let ((f6529 f6529) (f6530 f6530)) (unless (null? f6530) (begin (f6529 (car f6530)) (for-each f6529 (cdr f6530))))))
# == eliminate-when/unless  ==>
# (closure (f6529 f6530) (if (not for-each) (begin) #f) (let ((f6529 f6529) (f6530 f6530)) (if (not (null? f6530)) (begin (begin (f6529 (car f6530)) (for-each f6529 (cdr f6530)))) #f)))
# == eliminate-cond  ==>
# (closure (f6529 f6530) (if (not for-each) (begin) #f) (let ((f6529 f6529) (f6530 f6530)) (if (not (null? f6530)) (begin (begin (f6529 (car f6530)) (for-each f6529 (cdr f6530)))) #f)))
# == external-symbols  ==>
# (closure (f6529 f6530) (if (not (primitive-ref for-each)) (begin) #f) (let ((f6529 f6529) (f6530 f6530)) (if (not (null? f6530)) (begin (begin (f6529 (car f6530)) ((primitive-ref for-each) f6529 (cdr f6530)))) #f)))
# emit-expr (closure (f6529 f6530) (if (not (primitive-ref for-each)) (begin) #f) (let ((f6529 f6529) (f6530 f6530)) (if (not (null? f6530)) (begin (begin (f6529 (car f6530)) ((primitive-ref for-each) f6529 (cdr f6530)))) #f)))
# emit-closure
# si = 0
# env = ()
# expr = (closure (f6529 f6530) (if (not (primitive-ref for-each)) (begin) #f) (let ((f6529 f6529) (f6530 f6530)) (if (not (null? f6530)) (begin (begin (f6529 (car f6530)) ((primitive-ref for-each) f6529 (cdr f6530)))) #f)))
    movl $_L_39793, 0(%ebp)  # closure label
# WARNING: free var if not defined in the environmnet
# WARNING: free var (not (primitive-ref for-each)) not defined in the environmnet
# WARNING: free var (begin) not defined in the environmnet
# WARNING: free var #f not defined in the environmnet
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $24, %ebp     # bump ebp
    jmp _L_39794            # jump around closure body
_L_39793:
# check argument count
    cmp $8,%eax
    je _L_39795
# invoke error handler eh_argcount
    .extern mrc_eh$uargcount
    movl mrc_eh$uargcount, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_39795:
# emit-tail-expr
# si=-16
# env=((f6530 . -12) (f6529 . -8) (#f . 16) ((begin) . 12) ((not (primitive-ref for-each)) . 8) (if . 4))
# expr=(let ((f6529 f6529) (f6530 f6530)) (if (not (null? f6530)) (begin (begin (f6529 (car f6530)) ((primitive-ref for-each) f6529 (cdr f6530)))) #f))
# emit-tail-let
#  si   = -16
#  env  = ((f6530 . -12) (f6529 . -8) (#f . 16) ((begin) . 12) ((not (primitive-ref for-each)) . 8) (if . 4))
#  bindings = ((f6529 f6529) (f6530 f6530))
#  body = (if (not (null? f6530)) (begin (begin (f6529 (car f6530)) ((primitive-ref for-each) f6529 (cdr f6530)))) #f)
# emit-expr f6529
# emit-variable-ref
# env=((f6530 . -12) (f6529 . -8) (#f . 16) ((begin) . 12) ((not (primitive-ref for-each)) . 8) (if . 4))
# var=f6529
    movl -8(%esp), %eax  # stack load f6529
# end emit-variable-ref
    movl %eax, -16(%esp)  # stack save
# emit-expr f6530
# emit-variable-ref
# env=((f6530 . -12) (f6529 . -8) (#f . 16) ((begin) . 12) ((not (primitive-ref for-each)) . 8) (if . 4))
# var=f6530
    movl -12(%esp), %eax  # stack load f6530
# end emit-variable-ref
    movl %eax, -20(%esp)  # stack save
# emit-tail-expr
# si=-24
# env=((f6530 . -20) (f6529 . -16) (f6530 . -12) (f6529 . -8) (#f . 16) ((begin) . 12) ((not (primitive-ref for-each)) . 8) (if . 4))
# expr=(if (not (null? f6530)) (begin (begin (f6529 (car f6530)) ((primitive-ref for-each) f6529 (cdr f6530)))) #f)
# emit-expr (not (null? f6530))
# emit-expr (null? f6530)
# emit-expr f6530
# emit-variable-ref
# env=((f6530 . -20) (f6529 . -16) (f6530 . -12) (f6529 . -8) (#f . 16) ((begin) . 12) ((not (primitive-ref for-each)) . 8) (if . 4))
# var=f6530
    movl -20(%esp), %eax  # stack load f6530
# end emit-variable-ref
    cmp $63, %eax
    mov $0, %eax
    sete %al
    movzbl %al, %eax
    sal $6, %al
    or $47, %al
    cmp $47, %eax
    sete %al
    movzbl %al, %eax
    sal $6, %al
    or $47, %al
    cmp $47, %al
    je _L_39796
# emit-tail-expr
# si=-24
# env=((f6530 . -20) (f6529 . -16) (f6530 . -12) (f6529 . -8) (#f . 16) ((begin) . 12) ((not (primitive-ref for-each)) . 8) (if . 4))
# expr=(begin (begin (f6529 (car f6530)) ((primitive-ref for-each) f6529 (cdr f6530))))
# tail-begin (begin (begin (f6529 (car f6530)) ((primitive-ref for-each) f6529 (cdr f6530))))
#   env=((f6530 . -20) (f6529 . -16) (f6530 . -12) (f6529 . -8) (#f . 16) ((begin) . 12) ((not (primitive-ref for-each)) . 8) (if . 4))
# emit-tail-expr
# si=-24
# env=((f6530 . -20) (f6529 . -16) (f6530 . -12) (f6529 . -8) (#f . 16) ((begin) . 12) ((not (primitive-ref for-each)) . 8) (if . 4))
# expr=(begin (f6529 (car f6530)) ((primitive-ref for-each) f6529 (cdr f6530)))
# tail-begin (begin (f6529 (car f6530)) ((primitive-ref for-each) f6529 (cdr f6530)))
#   env=((f6530 . -20) (f6529 . -16) (f6530 . -12) (f6529 . -8) (#f . 16) ((begin) . 12) ((not (primitive-ref for-each)) . 8) (if . 4))
# emit-expr (f6529 (car f6530))
# funcall
#    si   =-24
#    env  = ((f6530 . -20) (f6529 . -16) (f6530 . -12) (f6529 . -8) (#f . 16) ((begin) . 12) ((not (primitive-ref for-each)) . 8) (if . 4))
#    expr = (funcall f6529 (car f6530))
# emit-expr f6529
# emit-variable-ref
# env=((f6530 . -20) (f6529 . -16) (f6530 . -12) (f6529 . -8) (#f . 16) ((begin) . 12) ((not (primitive-ref for-each)) . 8) (if . 4))
# var=f6529
    movl -16(%esp), %eax  # stack load f6529
# end emit-variable-ref
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_39798"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_39798":
   movl %eax,  -32(%esp)  # stash funcall-oper in closure slot
# emit-expr (car f6530)
# emit-expr f6530
# emit-variable-ref
# env=((f6530 . -20) (f6529 . -16) (f6530 . -12) (f6529 . -8) (#f . 16) ((begin) . 12) ((not (primitive-ref for-each)) . 8) (if . 4))
# var=f6530
    movl -20(%esp), %eax  # stack load f6530
# end emit-variable-ref
# check the argument is a pair
    movl %eax,%ebx
    and $7, %bl
    cmp $1, %bl
    je _L_39799
# invoke error handler eh_pair
    .extern mrc_eh$upair
    movl mrc_eh$upair, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $116,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_39799:
    movl -1(%eax), %eax
    mov %eax, -36(%esp)  # arg (car f6530)
    movl -32(%esp), %edi   # load new closure to %edi
    add $-24, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $24, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
# emit-tail-expr
# si=-24
# env=((f6530 . -20) (f6529 . -16) (f6530 . -12) (f6529 . -8) (#f . 16) ((begin) . 12) ((not (primitive-ref for-each)) . 8) (if . 4))
# expr=(begin ((primitive-ref for-each) f6529 (cdr f6530)))
# tail-begin (begin ((primitive-ref for-each) f6529 (cdr f6530)))
#   env=((f6530 . -20) (f6529 . -16) (f6530 . -12) (f6529 . -8) (#f . 16) ((begin) . 12) ((not (primitive-ref for-each)) . 8) (if . 4))
# emit-tail-expr
# si=-24
# env=((f6530 . -20) (f6529 . -16) (f6530 . -12) (f6529 . -8) (#f . 16) ((begin) . 12) ((not (primitive-ref for-each)) . 8) (if . 4))
# expr=((primitive-ref for-each) f6529 (cdr f6530))
# emit-tail-funcall
#    si   =-24
#    env  = ((f6530 . -20) (f6529 . -16) (f6530 . -12) (f6529 . -8) (#f . 16) ((begin) . 12) ((not (primitive-ref for-each)) . 8) (if . 4))
#    expr = (funcall (primitive-ref for-each) f6529 (cdr f6530))
# emit-expr (primitive-ref for-each)
    .extern mrc_for$meach
    movl mrc_for$meach,%eax
   movl %eax,  -24(%esp)  # stash funcall-oper in next closure slot
# emit-expr f6529
# emit-variable-ref
# env=((f6530 . -20) (f6529 . -16) (f6530 . -12) (f6529 . -8) (#f . 16) ((begin) . 12) ((not (primitive-ref for-each)) . 8) (if . 4))
# var=f6529
    movl -16(%esp), %eax  # stack load f6529
# end emit-variable-ref
    mov %eax, -28(%esp)    # arg f6529
# emit-expr (cdr f6530)
# emit-expr f6530
# emit-variable-ref
# env=((f6530 . -20) (f6529 . -16) (f6530 . -12) (f6529 . -8) (#f . 16) ((begin) . 12) ((not (primitive-ref for-each)) . 8) (if . 4))
# var=f6530
    movl -20(%esp), %eax  # stack load f6530
# end emit-variable-ref
# check the argument is a pair
    movl %eax,%ebx
    and $7, %bl
    cmp $1, %bl
    je _L_39800
# invoke error handler eh_pair
    .extern mrc_eh$upair
    movl mrc_eh$upair, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $120,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_39800:
    movl 3(%eax), %eax
    mov %eax, -32(%esp)    # arg (cdr f6530)
    movl -24(%esp), %edi   # load new closure to %edi
# emit-shift-args:  size=3   si=-24  delta=20
    mov -24(%esp), %ebx  # shift frame cell
    mov %ebx, -4(%esp)  # down to base
# emit-shift-args:  size=2   si=-28  delta=20
    mov -28(%esp), %ebx  # shift frame cell
    mov %ebx, -8(%esp)  # down to base
# emit-shift-args:  size=1   si=-32  delta=20
    mov -32(%esp), %ebx  # shift frame cell
    mov %ebx, -12(%esp)  # down to base
# emit-shift-args:  size=0   si=-36  delta=20
    movl $8,%eax   # save arg count
    jmp *-2(%edi)  # tail-funcall
     ret   # return thru stack
     ret   # return thru stack
    jmp _L_39797
_L_39796:
# emit-tail-expr
# si=-24
# env=((f6530 . -20) (f6529 . -16) (f6530 . -12) (f6529 . -8) (#f . 16) ((begin) . 12) ((not (primitive-ref for-each)) . 8) (if . 4))
# expr=#f
    movl $47, %eax     # immed #f
    ret                  # immediate tail return
_L_39797:
    .align 4,0x90
_L_39794:
     movl %eax, mrc_for$meach
# == explicit-begins  ==>
# (let ((p (make-vector 6)) (sz 1024)) (begin (vector-set! p 0 (quote output-port)) (vector-set! p 1 "/dev/stdout") (vector-set! p 2 1) (vector-set! p 3 (make-string sz)) (vector-set! p 4 0) (vector-set! p 5 sz) p))
# == eliminate-let*  ==>
# (let ((p (make-vector 6)) (sz 1024)) (begin (vector-set! p 0 (quote output-port)) (vector-set! p 1 "/dev/stdout") (vector-set! p 2 1) (vector-set! p 3 (make-string sz)) (vector-set! p 4 0) (vector-set! p 5 sz) p))
# == uniquify-variables  ==>
# (let ((f6532 (make-vector 6)) (f6531 1024)) (begin (vector-set! f6532 0 (quote output-port)) (vector-set! f6532 1 "/dev/stdout") (vector-set! f6532 2 1) (vector-set! f6532 3 (make-string f6531)) (vector-set! f6532 4 0) (vector-set! f6532 5 f6531) f6532))
# == vectorize-letrec  ==>
# (let ((f6532 (make-vector 6)) (f6531 1024)) (begin (vector-set! f6532 0 (quote output-port)) (vector-set! f6532 1 "/dev/stdout") (vector-set! f6532 2 1) (vector-set! f6532 3 (make-string f6531)) (vector-set! f6532 4 0) (vector-set! f6532 5 f6531) f6532))
# == eliminate-set!  ==>
# (let ((f6532 (make-vector 6)) (f6531 1024)) (begin (vector-set! f6532 0 (quote output-port)) (vector-set! f6532 1 "/dev/stdout") (vector-set! f6532 2 1) (vector-set! f6532 3 (make-string f6531)) (vector-set! f6532 4 0) (vector-set! f6532 5 f6531) f6532))
# == close-free-variables  ==>
# (let ((f6532 (make-vector 6)) (f6531 1024)) (begin (vector-set! f6532 0 (quote output-port)) (vector-set! f6532 1 "/dev/stdout") (vector-set! f6532 2 1) (vector-set! f6532 3 (make-string f6531)) (vector-set! f6532 4 0) (vector-set! f6532 5 f6531) f6532))
# == eliminate-quote  ==>
# (let ((f6532 (make-vector 6)) (f6531 1024)) (begin (vector-set! f6532 0 (string->symbol "output-port")) (vector-set! f6532 1 "/dev/stdout") (vector-set! f6532 2 1) (vector-set! f6532 3 (make-string f6531)) (vector-set! f6532 4 0) (vector-set! f6532 5 f6531) f6532))
# == eliminate-when/unless  ==>
# (let ((f6532 (make-vector 6)) (f6531 1024)) (begin (vector-set! f6532 0 (string->symbol "output-port")) (vector-set! f6532 1 "/dev/stdout") (vector-set! f6532 2 1) (vector-set! f6532 3 (make-string f6531)) (vector-set! f6532 4 0) (vector-set! f6532 5 f6531) f6532))
# == eliminate-cond  ==>
# (let ((f6532 (make-vector 6)) (f6531 1024)) (begin (vector-set! f6532 0 (string->symbol "output-port")) (vector-set! f6532 1 "/dev/stdout") (vector-set! f6532 2 1) (vector-set! f6532 3 (make-string f6531)) (vector-set! f6532 4 0) (vector-set! f6532 5 f6531) f6532))
# == external-symbols  ==>
# (let ((f6532 (make-vector 6)) (f6531 1024)) (begin (vector-set! f6532 0 ((primitive-ref string->symbol) "output-port")) (vector-set! f6532 1 "/dev/stdout") (vector-set! f6532 2 1) (vector-set! f6532 3 (make-string f6531)) (vector-set! f6532 4 0) (vector-set! f6532 5 f6531) f6532))
# emit-expr (let ((f6532 (make-vector 6)) (f6531 1024)) (begin (vector-set! f6532 0 ((primitive-ref string->symbol) "output-port")) (vector-set! f6532 1 "/dev/stdout") (vector-set! f6532 2 1) (vector-set! f6532 3 (make-string f6531)) (vector-set! f6532 4 0) (vector-set! f6532 5 f6531) f6532))
# emit-let
#  si   = 0
#  env  = ()
#  bindings = ((f6532 (make-vector 6)) (f6531 1024))
#  body = (begin (vector-set! f6532 0 ((primitive-ref string->symbol) "output-port")) (vector-set! f6532 1 "/dev/stdout") (vector-set! f6532 2 1) (vector-set! f6532 3 (make-string f6531)) (vector-set! f6532 4 0) (vector-set! f6532 5 f6531) f6532)
# emit-expr (make-vector 6)
# make-vector 6
# emit-expr 6
    movl $24, %eax     # immed 6
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_39801"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_39801:
# check the argument is a fixnum >= 0
    cmp $0,%eax
    jge _L_39802
# invoke error handler eh_length
    .extern mrc_eh$ulength
    movl mrc_eh$ulength, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_39802:
    movl %eax, %esi
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    orl  $5, %eax
    addl $4, %esi
    addl $4, %esi
    andl $-8, %esi
    addl %esi, %ebp
    movl %eax, 0(%esp)  # stack save
# emit-expr 1024
    movl $4096, %eax     # immed 1024
    movl %eax, -4(%esp)  # stack save
# emit-expr (begin (vector-set! f6532 0 ((primitive-ref string->symbol) "output-port")) (vector-set! f6532 1 "/dev/stdout") (vector-set! f6532 2 1) (vector-set! f6532 3 (make-string f6531)) (vector-set! f6532 4 0) (vector-set! f6532 5 f6531) f6532)
# emit-begin
#   expr=(begin (vector-set! f6532 0 ((primitive-ref string->symbol) "output-port")) (vector-set! f6532 1 "/dev/stdout") (vector-set! f6532 2 1) (vector-set! f6532 3 (make-string f6531)) (vector-set! f6532 4 0) (vector-set! f6532 5 f6531) f6532)
#   env=((f6531 . -4) (f6532 . 0))
# emit-expr (vector-set! f6532 0 ((primitive-ref string->symbol) "output-port"))
# emit-expr f6532
# emit-variable-ref
# env=((f6531 . -4) (f6532 . 0))
# var=f6532
    movl 0(%esp), %eax  # stack load f6532
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_39803
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_39803:
    movl %eax, -8(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_39804"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_39804:
# check bounds on vector index
    movl -8(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_39806
    cmp  $0,%eax
    jge _L_39805
_L_39806:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_39805:
    movl %eax, -12(%esp)
# emit-expr ((primitive-ref string->symbol) "output-port")
# funcall
#    si   =-16
#    env  = ((f6531 . -4) (f6532 . 0))
#    expr = (funcall (primitive-ref string->symbol) "output-port")
# emit-expr (primitive-ref string->symbol)
    .extern mrc_string$m$gsymbol
    movl mrc_string$m$gsymbol,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_39807"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_39807":
   movl %eax,  -24(%esp)  # stash funcall-oper in closure slot
# emit-expr "output-port"
# string literal
    jmp _L_39809
    .align 8,0x90
_L_39808 :
    .int 44
    .ascii "output-port"
_L_39809:
    movl $_L_39808, %eax
    orl $6, %eax
    mov %eax, -28(%esp)  # arg output-port
    movl -24(%esp), %edi   # load new closure to %edi
    add $-16, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $16, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    movl -8(%esp), %ebx
    movl -12(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin (vector-set! f6532 1 "/dev/stdout") (vector-set! f6532 2 1) (vector-set! f6532 3 (make-string f6531)) (vector-set! f6532 4 0) (vector-set! f6532 5 f6531) f6532)
# emit-begin
#   expr=(begin (vector-set! f6532 1 "/dev/stdout") (vector-set! f6532 2 1) (vector-set! f6532 3 (make-string f6531)) (vector-set! f6532 4 0) (vector-set! f6532 5 f6531) f6532)
#   env=((f6531 . -4) (f6532 . 0))
# emit-expr (vector-set! f6532 1 "/dev/stdout")
# emit-expr f6532
# emit-variable-ref
# env=((f6531 . -4) (f6532 . 0))
# var=f6532
    movl 0(%esp), %eax  # stack load f6532
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_39810
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_39810:
    movl %eax, -8(%esp)
# emit-expr 1
    movl $4, %eax     # immed 1
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_39811"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_39811:
# check bounds on vector index
    movl -8(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_39813
    cmp  $0,%eax
    jge _L_39812
_L_39813:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_39812:
    movl %eax, -12(%esp)
# emit-expr "/dev/stdout"
# string literal
    jmp _L_39815
    .align 8,0x90
_L_39814 :
    .int 44
    .ascii "/dev/stdout"
_L_39815:
    movl $_L_39814, %eax
    orl $6, %eax
    movl -8(%esp), %ebx
    movl -12(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin (vector-set! f6532 2 1) (vector-set! f6532 3 (make-string f6531)) (vector-set! f6532 4 0) (vector-set! f6532 5 f6531) f6532)
# emit-begin
#   expr=(begin (vector-set! f6532 2 1) (vector-set! f6532 3 (make-string f6531)) (vector-set! f6532 4 0) (vector-set! f6532 5 f6531) f6532)
#   env=((f6531 . -4) (f6532 . 0))
# emit-expr (vector-set! f6532 2 1)
# emit-expr f6532
# emit-variable-ref
# env=((f6531 . -4) (f6532 . 0))
# var=f6532
    movl 0(%esp), %eax  # stack load f6532
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_39816
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_39816:
    movl %eax, -8(%esp)
# emit-expr 2
    movl $8, %eax     # immed 2
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_39817"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_39817:
# check bounds on vector index
    movl -8(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_39819
    cmp  $0,%eax
    jge _L_39818
_L_39819:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_39818:
    movl %eax, -12(%esp)
# emit-expr 1
    movl $4, %eax     # immed 1
    movl -8(%esp), %ebx
    movl -12(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin (vector-set! f6532 3 (make-string f6531)) (vector-set! f6532 4 0) (vector-set! f6532 5 f6531) f6532)
# emit-begin
#   expr=(begin (vector-set! f6532 3 (make-string f6531)) (vector-set! f6532 4 0) (vector-set! f6532 5 f6531) f6532)
#   env=((f6531 . -4) (f6532 . 0))
# emit-expr (vector-set! f6532 3 (make-string f6531))
# emit-expr f6532
# emit-variable-ref
# env=((f6531 . -4) (f6532 . 0))
# var=f6532
    movl 0(%esp), %eax  # stack load f6532
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_39820
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_39820:
    movl %eax, -8(%esp)
# emit-expr 3
    movl $12, %eax     # immed 3
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_39821"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_39821:
# check bounds on vector index
    movl -8(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_39823
    cmp  $0,%eax
    jge _L_39822
_L_39823:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_39822:
    movl %eax, -12(%esp)
# emit-expr (make-string f6531)
# make-string len=f6531
# emit-expr f6531
# emit-variable-ref
# env=((f6531 . -4) (f6532 . 0))
# var=f6531
    movl -4(%esp), %eax  # stack load f6531
# end emit-variable-ref
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_39824"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $152,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_39824:
# check the argument is a fixnum >= 0
    cmp $0,%eax
    jge _L_39825
# invoke error handler eh_length
    .extern mrc_eh$ulength
    movl mrc_eh$ulength, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $152,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_39825:
    movl %eax, %esi
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    orl $6, %eax
    sar $2, %esi
    add $4, %esi
    add $7, %esi
    andl $-8, %esi
    add  %esi, %ebp
# make-string end
    movl -8(%esp), %ebx
    movl -12(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin (vector-set! f6532 4 0) (vector-set! f6532 5 f6531) f6532)
# emit-begin
#   expr=(begin (vector-set! f6532 4 0) (vector-set! f6532 5 f6531) f6532)
#   env=((f6531 . -4) (f6532 . 0))
# emit-expr (vector-set! f6532 4 0)
# emit-expr f6532
# emit-variable-ref
# env=((f6531 . -4) (f6532 . 0))
# var=f6532
    movl 0(%esp), %eax  # stack load f6532
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_39826
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_39826:
    movl %eax, -8(%esp)
# emit-expr 4
    movl $16, %eax     # immed 4
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_39827"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_39827:
# check bounds on vector index
    movl -8(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_39829
    cmp  $0,%eax
    jge _L_39828
_L_39829:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_39828:
    movl %eax, -12(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
    movl -8(%esp), %ebx
    movl -12(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin (vector-set! f6532 5 f6531) f6532)
# emit-begin
#   expr=(begin (vector-set! f6532 5 f6531) f6532)
#   env=((f6531 . -4) (f6532 . 0))
# emit-expr (vector-set! f6532 5 f6531)
# emit-expr f6532
# emit-variable-ref
# env=((f6531 . -4) (f6532 . 0))
# var=f6532
    movl 0(%esp), %eax  # stack load f6532
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_39830
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_39830:
    movl %eax, -8(%esp)
# emit-expr 5
    movl $20, %eax     # immed 5
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_39831"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_39831:
# check bounds on vector index
    movl -8(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_39833
    cmp  $0,%eax
    jge _L_39832
_L_39833:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_39832:
    movl %eax, -12(%esp)
# emit-expr f6531
# emit-variable-ref
# env=((f6531 . -4) (f6532 . 0))
# var=f6531
    movl -4(%esp), %eax  # stack load f6531
# end emit-variable-ref
    movl -8(%esp), %ebx
    movl -12(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin f6532)
# emit-begin
#   expr=(begin f6532)
#   env=((f6531 . -4) (f6532 . 0))
# emit-expr f6532
# emit-variable-ref
# env=((f6531 . -4) (f6532 . 0))
# var=f6532
    movl 0(%esp), %eax  # stack load f6532
# end emit-variable-ref
# emit-expr (begin)
# emit-begin
#   expr=(begin)
#   env=((f6531 . -4) (f6532 . 0))
     movl %eax, mrc_standard$mout
# == explicit-begins  ==>
# (let ((current-out standard-out)) (lambda () current-out))
# == eliminate-let*  ==>
# (let ((current-out standard-out)) (lambda () current-out))
# == uniquify-variables  ==>
# (let ((f6533 standard-out)) (lambda () f6533))
# == vectorize-letrec  ==>
# (let ((f6533 standard-out)) (lambda () f6533))
# == eliminate-set!  ==>
# (let ((f6533 standard-out)) (lambda () (let () f6533)))
# == close-free-variables  ==>
# (let ((f6533 standard-out)) (closure () (f6533) (let () f6533)))
# == eliminate-quote  ==>
# (let ((f6533 standard-out)) (closure () (f6533) (let () f6533)))
# == eliminate-when/unless  ==>
# (let ((f6533 standard-out)) (closure () (f6533) (let () f6533)))
# == eliminate-cond  ==>
# (let ((f6533 standard-out)) (closure () (f6533) (let () f6533)))
# == external-symbols  ==>
# (let ((f6533 (primitive-ref standard-out))) (closure () (f6533) (let () f6533)))
# emit-expr (let ((f6533 (primitive-ref standard-out))) (closure () (f6533) (let () f6533)))
# emit-let
#  si   = 0
#  env  = ()
#  bindings = ((f6533 (primitive-ref standard-out)))
#  body = (closure () (f6533) (let () f6533))
# emit-expr (primitive-ref standard-out)
    .extern mrc_standard$mout
    movl mrc_standard$mout,%eax
    movl %eax, 0(%esp)  # stack save
# emit-expr (closure () (f6533) (let () f6533))
# emit-closure
# si = -4
# env = ((f6533 . 0))
# expr = (closure () (f6533) (let () f6533))
    movl $_L_39834, 0(%ebp)  # closure label
# emit-variable-ref
# env=((f6533 . 0))
# var=f6533
    movl 0(%esp), %eax  # stack load f6533
# end emit-variable-ref
   movl  %eax, 4(%ebp)  # f6533
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $8, %ebp     # bump ebp
    jmp _L_39835            # jump around closure body
_L_39834:
# check argument count
    cmp $0,%eax
    je _L_39836
# invoke error handler eh_argcount
    .extern mrc_eh$uargcount
    movl mrc_eh$uargcount, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_39836:
# emit-tail-expr
# si=-8
# env=((f6533 . 4) (f6533 . 0))
# expr=(let () f6533)
# emit-tail-let
#  si   = -8
#  env  = ((f6533 . 4) (f6533 . 0))
#  bindings = ()
#  body = f6533
# emit-tail-expr
# si=-8
# env=((f6533 . 4) (f6533 . 0))
# expr=f6533
# emit-tail-variable-ref
# emit-variable-ref
# env=((f6533 . 4) (f6533 . 0))
# var=f6533
    movl 2(%edi), %eax  # frame load f6533
# end emit-variable-ref
    ret
# end emit-tail-variable ref
    .align 4,0x90
_L_39835:
     movl %eax, mrc_current$moutput$mport
# == explicit-begins  ==>
# (let ((current-in standard-in)) (lambda () current-in))
# == eliminate-let*  ==>
# (let ((current-in standard-in)) (lambda () current-in))
# == uniquify-variables  ==>
# (let ((f6534 standard-in)) (lambda () f6534))
# == vectorize-letrec  ==>
# (let ((f6534 standard-in)) (lambda () f6534))
# == eliminate-set!  ==>
# (let ((f6534 standard-in)) (lambda () (let () f6534)))
# == close-free-variables  ==>
# (let ((f6534 standard-in)) (closure () (f6534) (let () f6534)))
# == eliminate-quote  ==>
# (let ((f6534 standard-in)) (closure () (f6534) (let () f6534)))
# == eliminate-when/unless  ==>
# (let ((f6534 standard-in)) (closure () (f6534) (let () f6534)))
# == eliminate-cond  ==>
# (let ((f6534 standard-in)) (closure () (f6534) (let () f6534)))
# == external-symbols  ==>
# (let ((f6534 (primitive-ref standard-in))) (closure () (f6534) (let () f6534)))
# emit-expr (let ((f6534 (primitive-ref standard-in))) (closure () (f6534) (let () f6534)))
# emit-let
#  si   = 0
#  env  = ()
#  bindings = ((f6534 (primitive-ref standard-in)))
#  body = (closure () (f6534) (let () f6534))
# emit-expr (primitive-ref standard-in)
    .extern mrc_standard$min
    movl mrc_standard$min,%eax
    movl %eax, 0(%esp)  # stack save
# emit-expr (closure () (f6534) (let () f6534))
# emit-closure
# si = -4
# env = ((f6534 . 0))
# expr = (closure () (f6534) (let () f6534))
    movl $_L_39837, 0(%ebp)  # closure label
# emit-variable-ref
# env=((f6534 . 0))
# var=f6534
    movl 0(%esp), %eax  # stack load f6534
# end emit-variable-ref
   movl  %eax, 4(%ebp)  # f6534
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $8, %ebp     # bump ebp
    jmp _L_39838            # jump around closure body
_L_39837:
# check argument count
    cmp $0,%eax
    je _L_39839
# invoke error handler eh_argcount
    .extern mrc_eh$uargcount
    movl mrc_eh$uargcount, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_39839:
# emit-tail-expr
# si=-8
# env=((f6534 . 4) (f6534 . 0))
# expr=(let () f6534)
# emit-tail-let
#  si   = -8
#  env  = ((f6534 . 4) (f6534 . 0))
#  bindings = ()
#  body = f6534
# emit-tail-expr
# si=-8
# env=((f6534 . 4) (f6534 . 0))
# expr=f6534
# emit-tail-variable-ref
# emit-variable-ref
# env=((f6534 . 4) (f6534 . 0))
# var=f6534
    movl 2(%edi), %eax  # frame load f6534
# end emit-variable-ref
    ret
# end emit-tail-variable ref
    .align 4,0x90
_L_39838:
     movl %eax, mrc_current$minput$mport
# == explicit-begins  ==>
# (lambda (p) (vector-ref p 0))
# == eliminate-let*  ==>
# (lambda (p) (vector-ref p 0))
# == uniquify-variables  ==>
# (lambda (f6535) (vector-ref f6535 0))
# == vectorize-letrec  ==>
# (lambda (f6535) (vector-ref f6535 0))
# == eliminate-set!  ==>
# (lambda (f6535) (let ((f6535 f6535)) (vector-ref f6535 0)))
# == close-free-variables  ==>
# (closure (f6535) () (let ((f6535 f6535)) (vector-ref f6535 0)))
# == eliminate-quote  ==>
# (closure (f6535) () (let ((f6535 f6535)) (vector-ref f6535 0)))
# == eliminate-when/unless  ==>
# (closure (f6535) () (let ((f6535 f6535)) (vector-ref f6535 0)))
# == eliminate-cond  ==>
# (closure (f6535) () (let ((f6535 f6535)) (vector-ref f6535 0)))
# == external-symbols  ==>
# (closure (f6535) () (let ((f6535 f6535)) (vector-ref f6535 0)))
# emit-expr (closure (f6535) () (let ((f6535 f6535)) (vector-ref f6535 0)))
# emit-closure
# si = 0
# env = ()
# expr = (closure (f6535) () (let ((f6535 f6535)) (vector-ref f6535 0)))
    movl $_L_39840, 0(%ebp)  # closure label
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $8, %ebp     # bump ebp
    jmp _L_39841            # jump around closure body
_L_39840:
# check argument count
    cmp $4,%eax
    je _L_39842
# invoke error handler eh_argcount
    .extern mrc_eh$uargcount
    movl mrc_eh$uargcount, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_39842:
# emit-tail-expr
# si=-12
# env=((f6535 . -8))
# expr=(let ((f6535 f6535)) (vector-ref f6535 0))
# emit-tail-let
#  si   = -12
#  env  = ((f6535 . -8))
#  bindings = ((f6535 f6535))
#  body = (vector-ref f6535 0)
# emit-expr f6535
# emit-variable-ref
# env=((f6535 . -8))
# var=f6535
    movl -8(%esp), %eax  # stack load f6535
# end emit-variable-ref
    movl %eax, -12(%esp)  # stack save
# emit-tail-expr
# si=-16
# env=((f6535 . -12) (f6535 . -8))
# expr=(vector-ref f6535 0)
# tail primcall
# emit-expr f6535
# emit-variable-ref
# env=((f6535 . -12) (f6535 . -8))
# var=f6535
    movl -12(%esp), %eax  # stack load f6535
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_39843
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_39843:
    movl %eax, -16(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_39844"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_39844:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_39846
    cmp  $0,%eax
    jge _L_39845
_L_39846:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_39845:
    movl -16(%esp), %esi
    movl -1(%eax,%esi), %eax
#return from tail (vector-ref f6535 0)
    ret
    .align 4,0x90
_L_39841:
     movl %eax, mrc_port$mkind
# == explicit-begins  ==>
# (lambda (p) (vector-ref p 1))
# == eliminate-let*  ==>
# (lambda (p) (vector-ref p 1))
# == uniquify-variables  ==>
# (lambda (f6536) (vector-ref f6536 1))
# == vectorize-letrec  ==>
# (lambda (f6536) (vector-ref f6536 1))
# == eliminate-set!  ==>
# (lambda (f6536) (let ((f6536 f6536)) (vector-ref f6536 1)))
# == close-free-variables  ==>
# (closure (f6536) () (let ((f6536 f6536)) (vector-ref f6536 1)))
# == eliminate-quote  ==>
# (closure (f6536) () (let ((f6536 f6536)) (vector-ref f6536 1)))
# == eliminate-when/unless  ==>
# (closure (f6536) () (let ((f6536 f6536)) (vector-ref f6536 1)))
# == eliminate-cond  ==>
# (closure (f6536) () (let ((f6536 f6536)) (vector-ref f6536 1)))
# == external-symbols  ==>
# (closure (f6536) () (let ((f6536 f6536)) (vector-ref f6536 1)))
# emit-expr (closure (f6536) () (let ((f6536 f6536)) (vector-ref f6536 1)))
# emit-closure
# si = 0
# env = ()
# expr = (closure (f6536) () (let ((f6536 f6536)) (vector-ref f6536 1)))
    movl $_L_39847, 0(%ebp)  # closure label
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $8, %ebp     # bump ebp
    jmp _L_39848            # jump around closure body
_L_39847:
# check argument count
    cmp $4,%eax
    je _L_39849
# invoke error handler eh_argcount
    .extern mrc_eh$uargcount
    movl mrc_eh$uargcount, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_39849:
# emit-tail-expr
# si=-12
# env=((f6536 . -8))
# expr=(let ((f6536 f6536)) (vector-ref f6536 1))
# emit-tail-let
#  si   = -12
#  env  = ((f6536 . -8))
#  bindings = ((f6536 f6536))
#  body = (vector-ref f6536 1)
# emit-expr f6536
# emit-variable-ref
# env=((f6536 . -8))
# var=f6536
    movl -8(%esp), %eax  # stack load f6536
# end emit-variable-ref
    movl %eax, -12(%esp)  # stack save
# emit-tail-expr
# si=-16
# env=((f6536 . -12) (f6536 . -8))
# expr=(vector-ref f6536 1)
# tail primcall
# emit-expr f6536
# emit-variable-ref
# env=((f6536 . -12) (f6536 . -8))
# var=f6536
    movl -12(%esp), %eax  # stack load f6536
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_39850
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_39850:
    movl %eax, -16(%esp)
# emit-expr 1
    movl $4, %eax     # immed 1
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_39851"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_39851:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_39853
    cmp  $0,%eax
    jge _L_39852
_L_39853:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_39852:
    movl -16(%esp), %esi
    movl -1(%eax,%esi), %eax
#return from tail (vector-ref f6536 1)
    ret
    .align 4,0x90
_L_39848:
     movl %eax, mrc_port$mpath
# == explicit-begins  ==>
# (lambda (p) (vector-ref p 2))
# == eliminate-let*  ==>
# (lambda (p) (vector-ref p 2))
# == uniquify-variables  ==>
# (lambda (f6537) (vector-ref f6537 2))
# == vectorize-letrec  ==>
# (lambda (f6537) (vector-ref f6537 2))
# == eliminate-set!  ==>
# (lambda (f6537) (let ((f6537 f6537)) (vector-ref f6537 2)))
# == close-free-variables  ==>
# (closure (f6537) () (let ((f6537 f6537)) (vector-ref f6537 2)))
# == eliminate-quote  ==>
# (closure (f6537) () (let ((f6537 f6537)) (vector-ref f6537 2)))
# == eliminate-when/unless  ==>
# (closure (f6537) () (let ((f6537 f6537)) (vector-ref f6537 2)))
# == eliminate-cond  ==>
# (closure (f6537) () (let ((f6537 f6537)) (vector-ref f6537 2)))
# == external-symbols  ==>
# (closure (f6537) () (let ((f6537 f6537)) (vector-ref f6537 2)))
# emit-expr (closure (f6537) () (let ((f6537 f6537)) (vector-ref f6537 2)))
# emit-closure
# si = 0
# env = ()
# expr = (closure (f6537) () (let ((f6537 f6537)) (vector-ref f6537 2)))
    movl $_L_39854, 0(%ebp)  # closure label
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $8, %ebp     # bump ebp
    jmp _L_39855            # jump around closure body
_L_39854:
# check argument count
    cmp $4,%eax
    je _L_39856
# invoke error handler eh_argcount
    .extern mrc_eh$uargcount
    movl mrc_eh$uargcount, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_39856:
# emit-tail-expr
# si=-12
# env=((f6537 . -8))
# expr=(let ((f6537 f6537)) (vector-ref f6537 2))
# emit-tail-let
#  si   = -12
#  env  = ((f6537 . -8))
#  bindings = ((f6537 f6537))
#  body = (vector-ref f6537 2)
# emit-expr f6537
# emit-variable-ref
# env=((f6537 . -8))
# var=f6537
    movl -8(%esp), %eax  # stack load f6537
# end emit-variable-ref
    movl %eax, -12(%esp)  # stack save
# emit-tail-expr
# si=-16
# env=((f6537 . -12) (f6537 . -8))
# expr=(vector-ref f6537 2)
# tail primcall
# emit-expr f6537
# emit-variable-ref
# env=((f6537 . -12) (f6537 . -8))
# var=f6537
    movl -12(%esp), %eax  # stack load f6537
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_39857
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_39857:
    movl %eax, -16(%esp)
# emit-expr 2
    movl $8, %eax     # immed 2
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_39858"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_39858:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_39860
    cmp  $0,%eax
    jge _L_39859
_L_39860:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_39859:
    movl -16(%esp), %esi
    movl -1(%eax,%esi), %eax
#return from tail (vector-ref f6537 2)
    ret
    .align 4,0x90
_L_39855:
     movl %eax, mrc_port$mfd
# == explicit-begins  ==>
# (lambda (p) (vector-ref p 3))
# == eliminate-let*  ==>
# (lambda (p) (vector-ref p 3))
# == uniquify-variables  ==>
# (lambda (f6538) (vector-ref f6538 3))
# == vectorize-letrec  ==>
# (lambda (f6538) (vector-ref f6538 3))
# == eliminate-set!  ==>
# (lambda (f6538) (let ((f6538 f6538)) (vector-ref f6538 3)))
# == close-free-variables  ==>
# (closure (f6538) () (let ((f6538 f6538)) (vector-ref f6538 3)))
# == eliminate-quote  ==>
# (closure (f6538) () (let ((f6538 f6538)) (vector-ref f6538 3)))
# == eliminate-when/unless  ==>
# (closure (f6538) () (let ((f6538 f6538)) (vector-ref f6538 3)))
# == eliminate-cond  ==>
# (closure (f6538) () (let ((f6538 f6538)) (vector-ref f6538 3)))
# == external-symbols  ==>
# (closure (f6538) () (let ((f6538 f6538)) (vector-ref f6538 3)))
# emit-expr (closure (f6538) () (let ((f6538 f6538)) (vector-ref f6538 3)))
# emit-closure
# si = 0
# env = ()
# expr = (closure (f6538) () (let ((f6538 f6538)) (vector-ref f6538 3)))
    movl $_L_39861, 0(%ebp)  # closure label
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $8, %ebp     # bump ebp
    jmp _L_39862            # jump around closure body
_L_39861:
# check argument count
    cmp $4,%eax
    je _L_39863
# invoke error handler eh_argcount
    .extern mrc_eh$uargcount
    movl mrc_eh$uargcount, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_39863:
# emit-tail-expr
# si=-12
# env=((f6538 . -8))
# expr=(let ((f6538 f6538)) (vector-ref f6538 3))
# emit-tail-let
#  si   = -12
#  env  = ((f6538 . -8))
#  bindings = ((f6538 f6538))
#  body = (vector-ref f6538 3)
# emit-expr f6538
# emit-variable-ref
# env=((f6538 . -8))
# var=f6538
    movl -8(%esp), %eax  # stack load f6538
# end emit-variable-ref
    movl %eax, -12(%esp)  # stack save
# emit-tail-expr
# si=-16
# env=((f6538 . -12) (f6538 . -8))
# expr=(vector-ref f6538 3)
# tail primcall
# emit-expr f6538
# emit-variable-ref
# env=((f6538 . -12) (f6538 . -8))
# var=f6538
    movl -12(%esp), %eax  # stack load f6538
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_39864
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_39864:
    movl %eax, -16(%esp)
# emit-expr 3
    movl $12, %eax     # immed 3
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_39865"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_39865:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_39867
    cmp  $0,%eax
    jge _L_39866
_L_39867:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_39866:
    movl -16(%esp), %esi
    movl -1(%eax,%esi), %eax
#return from tail (vector-ref f6538 3)
    ret
    .align 4,0x90
_L_39862:
     movl %eax, mrc_port$mbuf
# == explicit-begins  ==>
# (lambda (p) (vector-ref p 4))
# == eliminate-let*  ==>
# (lambda (p) (vector-ref p 4))
# == uniquify-variables  ==>
# (lambda (f6539) (vector-ref f6539 4))
# == vectorize-letrec  ==>
# (lambda (f6539) (vector-ref f6539 4))
# == eliminate-set!  ==>
# (lambda (f6539) (let ((f6539 f6539)) (vector-ref f6539 4)))
# == close-free-variables  ==>
# (closure (f6539) () (let ((f6539 f6539)) (vector-ref f6539 4)))
# == eliminate-quote  ==>
# (closure (f6539) () (let ((f6539 f6539)) (vector-ref f6539 4)))
# == eliminate-when/unless  ==>
# (closure (f6539) () (let ((f6539 f6539)) (vector-ref f6539 4)))
# == eliminate-cond  ==>
# (closure (f6539) () (let ((f6539 f6539)) (vector-ref f6539 4)))
# == external-symbols  ==>
# (closure (f6539) () (let ((f6539 f6539)) (vector-ref f6539 4)))
# emit-expr (closure (f6539) () (let ((f6539 f6539)) (vector-ref f6539 4)))
# emit-closure
# si = 0
# env = ()
# expr = (closure (f6539) () (let ((f6539 f6539)) (vector-ref f6539 4)))
    movl $_L_39868, 0(%ebp)  # closure label
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $8, %ebp     # bump ebp
    jmp _L_39869            # jump around closure body
_L_39868:
# check argument count
    cmp $4,%eax
    je _L_39870
# invoke error handler eh_argcount
    .extern mrc_eh$uargcount
    movl mrc_eh$uargcount, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_39870:
# emit-tail-expr
# si=-12
# env=((f6539 . -8))
# expr=(let ((f6539 f6539)) (vector-ref f6539 4))
# emit-tail-let
#  si   = -12
#  env  = ((f6539 . -8))
#  bindings = ((f6539 f6539))
#  body = (vector-ref f6539 4)
# emit-expr f6539
# emit-variable-ref
# env=((f6539 . -8))
# var=f6539
    movl -8(%esp), %eax  # stack load f6539
# end emit-variable-ref
    movl %eax, -12(%esp)  # stack save
# emit-tail-expr
# si=-16
# env=((f6539 . -12) (f6539 . -8))
# expr=(vector-ref f6539 4)
# tail primcall
# emit-expr f6539
# emit-variable-ref
# env=((f6539 . -12) (f6539 . -8))
# var=f6539
    movl -12(%esp), %eax  # stack load f6539
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_39871
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_39871:
    movl %eax, -16(%esp)
# emit-expr 4
    movl $16, %eax     # immed 4
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_39872"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_39872:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_39874
    cmp  $0,%eax
    jge _L_39873
_L_39874:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_39873:
    movl -16(%esp), %esi
    movl -1(%eax,%esi), %eax
#return from tail (vector-ref f6539 4)
    ret
    .align 4,0x90
_L_39869:
     movl %eax, mrc_port$mndx
# == explicit-begins  ==>
# (lambda (p) (vector-set! p 4 (fxadd1 (vector-ref p 4))))
# == eliminate-let*  ==>
# (lambda (p) (vector-set! p 4 (fxadd1 (vector-ref p 4))))
# == uniquify-variables  ==>
# (lambda (f6540) (vector-set! f6540 4 (fxadd1 (vector-ref f6540 4))))
# == vectorize-letrec  ==>
# (lambda (f6540) (vector-set! f6540 4 (fxadd1 (vector-ref f6540 4))))
# == eliminate-set!  ==>
# (lambda (f6540) (let ((f6540 f6540)) (vector-set! f6540 4 (fxadd1 (vector-ref f6540 4)))))
# == close-free-variables  ==>
# (closure (f6540) () (let ((f6540 f6540)) (vector-set! f6540 4 (fxadd1 (vector-ref f6540 4)))))
# == eliminate-quote  ==>
# (closure (f6540) () (let ((f6540 f6540)) (vector-set! f6540 4 (fxadd1 (vector-ref f6540 4)))))
# == eliminate-when/unless  ==>
# (closure (f6540) () (let ((f6540 f6540)) (vector-set! f6540 4 (fxadd1 (vector-ref f6540 4)))))
# == eliminate-cond  ==>
# (closure (f6540) () (let ((f6540 f6540)) (vector-set! f6540 4 (fxadd1 (vector-ref f6540 4)))))
# == external-symbols  ==>
# (closure (f6540) () (let ((f6540 f6540)) (vector-set! f6540 4 (fxadd1 (vector-ref f6540 4)))))
# emit-expr (closure (f6540) () (let ((f6540 f6540)) (vector-set! f6540 4 (fxadd1 (vector-ref f6540 4)))))
# emit-closure
# si = 0
# env = ()
# expr = (closure (f6540) () (let ((f6540 f6540)) (vector-set! f6540 4 (fxadd1 (vector-ref f6540 4)))))
    movl $_L_39875, 0(%ebp)  # closure label
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $8, %ebp     # bump ebp
    jmp _L_39876            # jump around closure body
_L_39875:
# check argument count
    cmp $4,%eax
    je _L_39877
# invoke error handler eh_argcount
    .extern mrc_eh$uargcount
    movl mrc_eh$uargcount, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_39877:
# emit-tail-expr
# si=-12
# env=((f6540 . -8))
# expr=(let ((f6540 f6540)) (vector-set! f6540 4 (fxadd1 (vector-ref f6540 4))))
# emit-tail-let
#  si   = -12
#  env  = ((f6540 . -8))
#  bindings = ((f6540 f6540))
#  body = (vector-set! f6540 4 (fxadd1 (vector-ref f6540 4)))
# emit-expr f6540
# emit-variable-ref
# env=((f6540 . -8))
# var=f6540
    movl -8(%esp), %eax  # stack load f6540
# end emit-variable-ref
    movl %eax, -12(%esp)  # stack save
# emit-tail-expr
# si=-16
# env=((f6540 . -12) (f6540 . -8))
# expr=(vector-set! f6540 4 (fxadd1 (vector-ref f6540 4)))
# tail primcall
# emit-expr f6540
# emit-variable-ref
# env=((f6540 . -12) (f6540 . -8))
# var=f6540
    movl -12(%esp), %eax  # stack load f6540
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_39878
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_39878:
    movl %eax, -16(%esp)
# emit-expr 4
    movl $16, %eax     # immed 4
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_39879"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_39879:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_39881
    cmp  $0,%eax
    jge _L_39880
_L_39881:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_39880:
    movl %eax, -20(%esp)
# emit-expr (fxadd1 (vector-ref f6540 4))
# emit-expr (vector-ref f6540 4)
# emit-expr f6540
# emit-variable-ref
# env=((f6540 . -12) (f6540 . -8))
# var=f6540
    movl -12(%esp), %eax  # stack load f6540
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_39882
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_39882:
    movl %eax, -24(%esp)
# emit-expr 4
    movl $16, %eax     # immed 4
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_39883"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_39883:
# check bounds on vector index
    movl -24(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_39885
    cmp  $0,%eax
    jge _L_39884
_L_39885:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_39884:
    movl -24(%esp), %esi
    movl -1(%eax,%esi), %eax
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_39886"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $56,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_39886:
     addl $4, %eax
    movl -16(%esp), %ebx
    movl -20(%esp), %esi
    movl %eax, -1(%ebx,%esi)
#return from tail (vector-set! f6540 4 (fxadd1 (vector-ref f6540 4)))
    ret
    .align 4,0x90
_L_39876:
     movl %eax, mrc_port$mndx$madd1
# == explicit-begins  ==>
# (lambda (p) (vector-set! p 4 0))
# == eliminate-let*  ==>
# (lambda (p) (vector-set! p 4 0))
# == uniquify-variables  ==>
# (lambda (f6541) (vector-set! f6541 4 0))
# == vectorize-letrec  ==>
# (lambda (f6541) (vector-set! f6541 4 0))
# == eliminate-set!  ==>
# (lambda (f6541) (let ((f6541 f6541)) (vector-set! f6541 4 0)))
# == close-free-variables  ==>
# (closure (f6541) () (let ((f6541 f6541)) (vector-set! f6541 4 0)))
# == eliminate-quote  ==>
# (closure (f6541) () (let ((f6541 f6541)) (vector-set! f6541 4 0)))
# == eliminate-when/unless  ==>
# (closure (f6541) () (let ((f6541 f6541)) (vector-set! f6541 4 0)))
# == eliminate-cond  ==>
# (closure (f6541) () (let ((f6541 f6541)) (vector-set! f6541 4 0)))
# == external-symbols  ==>
# (closure (f6541) () (let ((f6541 f6541)) (vector-set! f6541 4 0)))
# emit-expr (closure (f6541) () (let ((f6541 f6541)) (vector-set! f6541 4 0)))
# emit-closure
# si = 0
# env = ()
# expr = (closure (f6541) () (let ((f6541 f6541)) (vector-set! f6541 4 0)))
    movl $_L_39887, 0(%ebp)  # closure label
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $8, %ebp     # bump ebp
    jmp _L_39888            # jump around closure body
_L_39887:
# check argument count
    cmp $4,%eax
    je _L_39889
# invoke error handler eh_argcount
    .extern mrc_eh$uargcount
    movl mrc_eh$uargcount, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_39889:
# emit-tail-expr
# si=-12
# env=((f6541 . -8))
# expr=(let ((f6541 f6541)) (vector-set! f6541 4 0))
# emit-tail-let
#  si   = -12
#  env  = ((f6541 . -8))
#  bindings = ((f6541 f6541))
#  body = (vector-set! f6541 4 0)
# emit-expr f6541
# emit-variable-ref
# env=((f6541 . -8))
# var=f6541
    movl -8(%esp), %eax  # stack load f6541
# end emit-variable-ref
    movl %eax, -12(%esp)  # stack save
# emit-tail-expr
# si=-16
# env=((f6541 . -12) (f6541 . -8))
# expr=(vector-set! f6541 4 0)
# tail primcall
# emit-expr f6541
# emit-variable-ref
# env=((f6541 . -12) (f6541 . -8))
# var=f6541
    movl -12(%esp), %eax  # stack load f6541
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_39890
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_39890:
    movl %eax, -16(%esp)
# emit-expr 4
    movl $16, %eax     # immed 4
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_39891"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_39891:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_39893
    cmp  $0,%eax
    jge _L_39892
_L_39893:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_39892:
    movl %eax, -20(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
    movl -16(%esp), %ebx
    movl -20(%esp), %esi
    movl %eax, -1(%ebx,%esi)
#return from tail (vector-set! f6541 4 0)
    ret
    .align 4,0x90
_L_39888:
     movl %eax, mrc_port$mndx$mreset
# == explicit-begins  ==>
# (lambda (p) (vector-ref p 5))
# == eliminate-let*  ==>
# (lambda (p) (vector-ref p 5))
# == uniquify-variables  ==>
# (lambda (f6542) (vector-ref f6542 5))
# == vectorize-letrec  ==>
# (lambda (f6542) (vector-ref f6542 5))
# == eliminate-set!  ==>
# (lambda (f6542) (let ((f6542 f6542)) (vector-ref f6542 5)))
# == close-free-variables  ==>
# (closure (f6542) () (let ((f6542 f6542)) (vector-ref f6542 5)))
# == eliminate-quote  ==>
# (closure (f6542) () (let ((f6542 f6542)) (vector-ref f6542 5)))
# == eliminate-when/unless  ==>
# (closure (f6542) () (let ((f6542 f6542)) (vector-ref f6542 5)))
# == eliminate-cond  ==>
# (closure (f6542) () (let ((f6542 f6542)) (vector-ref f6542 5)))
# == external-symbols  ==>
# (closure (f6542) () (let ((f6542 f6542)) (vector-ref f6542 5)))
# emit-expr (closure (f6542) () (let ((f6542 f6542)) (vector-ref f6542 5)))
# emit-closure
# si = 0
# env = ()
# expr = (closure (f6542) () (let ((f6542 f6542)) (vector-ref f6542 5)))
    movl $_L_39894, 0(%ebp)  # closure label
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $8, %ebp     # bump ebp
    jmp _L_39895            # jump around closure body
_L_39894:
# check argument count
    cmp $4,%eax
    je _L_39896
# invoke error handler eh_argcount
    .extern mrc_eh$uargcount
    movl mrc_eh$uargcount, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_39896:
# emit-tail-expr
# si=-12
# env=((f6542 . -8))
# expr=(let ((f6542 f6542)) (vector-ref f6542 5))
# emit-tail-let
#  si   = -12
#  env  = ((f6542 . -8))
#  bindings = ((f6542 f6542))
#  body = (vector-ref f6542 5)
# emit-expr f6542
# emit-variable-ref
# env=((f6542 . -8))
# var=f6542
    movl -8(%esp), %eax  # stack load f6542
# end emit-variable-ref
    movl %eax, -12(%esp)  # stack save
# emit-tail-expr
# si=-16
# env=((f6542 . -12) (f6542 . -8))
# expr=(vector-ref f6542 5)
# tail primcall
# emit-expr f6542
# emit-variable-ref
# env=((f6542 . -12) (f6542 . -8))
# var=f6542
    movl -12(%esp), %eax  # stack load f6542
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_39897
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_39897:
    movl %eax, -16(%esp)
# emit-expr 5
    movl $20, %eax     # immed 5
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_39898"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_39898:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_39900
    cmp  $0,%eax
    jge _L_39899
_L_39900:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_39899:
    movl -16(%esp), %esi
    movl -1(%eax,%esi), %eax
#return from tail (vector-ref f6542 5)
    ret
    .align 4,0x90
_L_39895:
     movl %eax, mrc_port$msize
# == explicit-begins  ==>
# (lambda (ch . args) (let ((p (if (null? args) (current-output-port) (car args)))) (begin (when (fx= (port-ndx p) (port-size p)) (flush-output-port p)) (string-set! (port-buf p) (port-ndx p) ch) (port-ndx-add1 p))))
# == eliminate-let*  ==>
# (lambda (ch . args) (let ((p (if (null? args) (current-output-port) (car args)))) (begin (when (fx= (port-ndx p) (port-size p)) (flush-output-port p)) (string-set! (port-buf p) (port-ndx p) ch) (port-ndx-add1 p))))
# == uniquify-variables  ==>
# (lambda (f6543 . f6544) (let ((f6546 (if (null? f6544) (current-output-port) (car f6544)))) (begin (when (fx= (port-ndx f6546) (port-size f6546)) (flush-output-port f6546)) (string-set! (port-buf f6546) (port-ndx f6546) f6543) (port-ndx-add1 f6546))))
# == vectorize-letrec  ==>
# (lambda (f6543 . f6544) (let ((f6546 (if (null? f6544) (current-output-port) (car f6544)))) (begin (when (fx= (port-ndx f6546) (port-size f6546)) (flush-output-port f6546)) (string-set! (port-buf f6546) (port-ndx f6546) f6543) (port-ndx-add1 f6546))))
# == eliminate-set!  ==>
# (lambda (f6543 . f6544) (let ((f6543 f6543)) (let ((f6546 (if (null? f6544) (current-output-port) (car f6544)))) (begin (when (fx= (port-ndx f6546) (port-size f6546)) (flush-output-port f6546)) (string-set! (port-buf f6546) (port-ndx f6546) f6543) (port-ndx-add1 f6546)))))
# == close-free-variables  ==>
# (closure (f6543 . f6544) (when port-ndx port-size flush-output-port port-buf port-ndx port-ndx-add1) (let ((f6543 f6543)) (let ((f6546 (if (null? f6544) (current-output-port) (car f6544)))) (begin (when (fx= (port-ndx f6546) (port-size f6546)) (flush-output-port f6546)) (string-set! (port-buf f6546) (port-ndx f6546) f6543) (port-ndx-add1 f6546)))))
# == eliminate-quote  ==>
# (closure (f6543 . f6544) (when port-ndx port-size flush-output-port port-buf port-ndx port-ndx-add1) (let ((f6543 f6543)) (let ((f6546 (if (null? f6544) (current-output-port) (car f6544)))) (begin (when (fx= (port-ndx f6546) (port-size f6546)) (flush-output-port f6546)) (string-set! (port-buf f6546) (port-ndx f6546) f6543) (port-ndx-add1 f6546)))))
# == eliminate-when/unless  ==>
# (closure (f6543 . f6544) (if port-ndx (begin port-size flush-output-port port-buf port-ndx port-ndx-add1) #f) (let ((f6543 f6543)) (let ((f6546 (if (null? f6544) (current-output-port) (car f6544)))) (begin (if (fx= (port-ndx f6546) (port-size f6546)) (begin (flush-output-port f6546)) #f) (string-set! (port-buf f6546) (port-ndx f6546) f6543) (port-ndx-add1 f6546)))))
# == eliminate-cond  ==>
# (closure (f6543 . f6544) (if port-ndx (begin port-size flush-output-port port-buf port-ndx port-ndx-add1) #f) (let ((f6543 f6543)) (let ((f6546 (if (null? f6544) (current-output-port) (car f6544)))) (begin (if (fx= (port-ndx f6546) (port-size f6546)) (begin (flush-output-port f6546)) #f) (string-set! (port-buf f6546) (port-ndx f6546) f6543) (port-ndx-add1 f6546)))))
# == external-symbols  ==>
# (closure (f6543 . f6544) (if (primitive-ref port-ndx) (begin (primitive-ref port-size) (primitive-ref flush-output-port) (primitive-ref port-buf) (primitive-ref port-ndx) (primitive-ref port-ndx-add1)) #f) (let ((f6543 f6543)) (let ((f6546 (if (null? f6544) ((primitive-ref current-output-port)) (car f6544)))) (begin (if (fx= ((primitive-ref port-ndx) f6546) ((primitive-ref port-size) f6546)) (begin ((primitive-ref flush-output-port) f6546)) #f) (string-set! ((primitive-ref port-buf) f6546) ((primitive-ref port-ndx) f6546) f6543) ((primitive-ref port-ndx-add1) f6546)))))
# emit-expr (closure (f6543 . f6544) (if (primitive-ref port-ndx) (begin (primitive-ref port-size) (primitive-ref flush-output-port) (primitive-ref port-buf) (primitive-ref port-ndx) (primitive-ref port-ndx-add1)) #f) (let ((f6543 f6543)) (let ((f6546 (if (null? f6544) ((primitive-ref current-output-port)) (car f6544)))) (begin (if (fx= ((primitive-ref port-ndx) f6546) ((primitive-ref port-size) f6546)) (begin ((primitive-ref flush-output-port) f6546)) #f) (string-set! ((primitive-ref port-buf) f6546) ((primitive-ref port-ndx) f6546) f6543) ((primitive-ref port-ndx-add1) f6546)))))
# emit-closure
# si = 0
# env = ()
# expr = (closure (f6543 . f6544) (if (primitive-ref port-ndx) (begin (primitive-ref port-size) (primitive-ref flush-output-port) (primitive-ref port-buf) (primitive-ref port-ndx) (primitive-ref port-ndx-add1)) #f) (let ((f6543 f6543)) (let ((f6546 (if (null? f6544) ((primitive-ref current-output-port)) (car f6544)))) (begin (if (fx= ((primitive-ref port-ndx) f6546) ((primitive-ref port-size) f6546)) (begin ((primitive-ref flush-output-port) f6546)) #f) (string-set! ((primitive-ref port-buf) f6546) ((primitive-ref port-ndx) f6546) f6543) ((primitive-ref port-ndx-add1) f6546)))))
    movl $_L_39901, 0(%ebp)  # closure label
# WARNING: free var if not defined in the environmnet
# WARNING: free var (primitive-ref port-ndx) not defined in the environmnet
# WARNING: free var (begin (primitive-ref port-size) (primitive-ref flush-output-port) (primitive-ref port-buf) (primitive-ref port-ndx) (primitive-ref port-ndx-add1)) not defined in the environmnet
# WARNING: free var #f not defined in the environmnet
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $24, %ebp     # bump ebp
    jmp _L_39902            # jump around closure body
_L_39901:
# check argument count
    cmp $4,%eax
    jge _L_39903
# invoke error handler eh_argcount_min
    .extern mrc_eh$uargcount$umin
    movl mrc_eh$uargcount$umin, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_39903:
# emit-build-varargs-list
    movl $63, %esi       # args <- () 
    lea -4(%esp),%edi    # edi <- esp-4
    subl %eax, %edi      # edi <- esp-4-eax    addr of arg[K+N] on stack
_L_39905:
    lea -8(%esp),%ebx    # addr of arg[K] on stack
    cmp %edi, %ebx       # while edi <> esp+(si+4)
    je _L_39904
    movl (%edi),%ebx     # arg i -> car
    movl %ebx, 0(%ebp)
    movl %esi, 4(%ebp)  # esi -> cdr
    movl %ebp, %esi
    addl $1, %esi       # tag as pair
    addl $8,%ebp         # bump heap ptr
    addl $4,%edi         # move to next previous arg from the end
    jmp _L_39905
_L_39904:
    movl %esi, -12(%esp)  # set args
# emit-tail-expr
# si=-16
# env=((f6544 . -12) (f6543 . -8) (#f . 16) ((begin (primitive-ref port-size) (primitive-ref flush-output-port) (primitive-ref port-buf) (primitive-ref port-ndx) (primitive-ref port-ndx-add1)) . 12) ((primitive-ref port-ndx) . 8) (if . 4))
# expr=(let ((f6543 f6543)) (let ((f6546 (if (null? f6544) ((primitive-ref current-output-port)) (car f6544)))) (begin (if (fx= ((primitive-ref port-ndx) f6546) ((primitive-ref port-size) f6546)) (begin ((primitive-ref flush-output-port) f6546)) #f) (string-set! ((primitive-ref port-buf) f6546) ((primitive-ref port-ndx) f6546) f6543) ((primitive-ref port-ndx-add1) f6546))))
# emit-tail-let
#  si   = -16
#  env  = ((f6544 . -12) (f6543 . -8) (#f . 16) ((begin (primitive-ref port-size) (primitive-ref flush-output-port) (primitive-ref port-buf) (primitive-ref port-ndx) (primitive-ref port-ndx-add1)) . 12) ((primitive-ref port-ndx) . 8) (if . 4))
#  bindings = ((f6543 f6543))
#  body = (let ((f6546 (if (null? f6544) ((primitive-ref current-output-port)) (car f6544)))) (begin (if (fx= ((primitive-ref port-ndx) f6546) ((primitive-ref port-size) f6546)) (begin ((primitive-ref flush-output-port) f6546)) #f) (string-set! ((primitive-ref port-buf) f6546) ((primitive-ref port-ndx) f6546) f6543) ((primitive-ref port-ndx-add1) f6546)))
# emit-expr f6543
# emit-variable-ref
# env=((f6544 . -12) (f6543 . -8) (#f . 16) ((begin (primitive-ref port-size) (primitive-ref flush-output-port) (primitive-ref port-buf) (primitive-ref port-ndx) (primitive-ref port-ndx-add1)) . 12) ((primitive-ref port-ndx) . 8) (if . 4))
# var=f6543
    movl -8(%esp), %eax  # stack load f6543
# end emit-variable-ref
    movl %eax, -16(%esp)  # stack save
# emit-tail-expr
# si=-20
# env=((f6543 . -16) (f6544 . -12) (f6543 . -8) (#f . 16) ((begin (primitive-ref port-size) (primitive-ref flush-output-port) (primitive-ref port-buf) (primitive-ref port-ndx) (primitive-ref port-ndx-add1)) . 12) ((primitive-ref port-ndx) . 8) (if . 4))
# expr=(let ((f6546 (if (null? f6544) ((primitive-ref current-output-port)) (car f6544)))) (begin (if (fx= ((primitive-ref port-ndx) f6546) ((primitive-ref port-size) f6546)) (begin ((primitive-ref flush-output-port) f6546)) #f) (string-set! ((primitive-ref port-buf) f6546) ((primitive-ref port-ndx) f6546) f6543) ((primitive-ref port-ndx-add1) f6546)))
# emit-tail-let
#  si   = -20
#  env  = ((f6543 . -16) (f6544 . -12) (f6543 . -8) (#f . 16) ((begin (primitive-ref port-size) (primitive-ref flush-output-port) (primitive-ref port-buf) (primitive-ref port-ndx) (primitive-ref port-ndx-add1)) . 12) ((primitive-ref port-ndx) . 8) (if . 4))
#  bindings = ((f6546 (if (null? f6544) ((primitive-ref current-output-port)) (car f6544))))
#  body = (begin (if (fx= ((primitive-ref port-ndx) f6546) ((primitive-ref port-size) f6546)) (begin ((primitive-ref flush-output-port) f6546)) #f) (string-set! ((primitive-ref port-buf) f6546) ((primitive-ref port-ndx) f6546) f6543) ((primitive-ref port-ndx-add1) f6546))
# emit-expr (if (null? f6544) ((primitive-ref current-output-port)) (car f6544))
# emit-expr (null? f6544)
# emit-expr f6544
# emit-variable-ref
# env=((f6543 . -16) (f6544 . -12) (f6543 . -8) (#f . 16) ((begin (primitive-ref port-size) (primitive-ref flush-output-port) (primitive-ref port-buf) (primitive-ref port-ndx) (primitive-ref port-ndx-add1)) . 12) ((primitive-ref port-ndx) . 8) (if . 4))
# var=f6544
    movl -12(%esp), %eax  # stack load f6544
# end emit-variable-ref
    cmp $63, %eax
    mov $0, %eax
    sete %al
    movzbl %al, %eax
    sal $6, %al
    or $47, %al
    cmp $47, %al
    je _L_39906
# emit-expr ((primitive-ref current-output-port))
# funcall
#    si   =-20
#    env  = ((f6543 . -16) (f6544 . -12) (f6543 . -8) (#f . 16) ((begin (primitive-ref port-size) (primitive-ref flush-output-port) (primitive-ref port-buf) (primitive-ref port-ndx) (primitive-ref port-ndx-add1)) . 12) ((primitive-ref port-ndx) . 8) (if . 4))
#    expr = (funcall (primitive-ref current-output-port))
# emit-expr (primitive-ref current-output-port)
    .extern mrc_current$moutput$mport
    movl mrc_current$moutput$mport,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_39908"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_39908":
   movl %eax,  -28(%esp)  # stash funcall-oper in closure slot
    movl -28(%esp), %edi   # load new closure to %edi
    add $-20, %esp   # adjust base
    movl $0,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $20, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    jmp _L_39907
_L_39906:
# emit-expr (car f6544)
# emit-expr f6544
# emit-variable-ref
# env=((f6543 . -16) (f6544 . -12) (f6543 . -8) (#f . 16) ((begin (primitive-ref port-size) (primitive-ref flush-output-port) (primitive-ref port-buf) (primitive-ref port-ndx) (primitive-ref port-ndx-add1)) . 12) ((primitive-ref port-ndx) . 8) (if . 4))
# var=f6544
    movl -12(%esp), %eax  # stack load f6544
# end emit-variable-ref
# check the argument is a pair
    movl %eax,%ebx
    and $7, %bl
    cmp $1, %bl
    je _L_39909
# invoke error handler eh_pair
    .extern mrc_eh$upair
    movl mrc_eh$upair, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $116,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_39909:
    movl -1(%eax), %eax
_L_39907:
    movl %eax, -20(%esp)  # stack save
# emit-tail-expr
# si=-24
# env=((f6546 . -20) (f6543 . -16) (f6544 . -12) (f6543 . -8) (#f . 16) ((begin (primitive-ref port-size) (primitive-ref flush-output-port) (primitive-ref port-buf) (primitive-ref port-ndx) (primitive-ref port-ndx-add1)) . 12) ((primitive-ref port-ndx) . 8) (if . 4))
# expr=(begin (if (fx= ((primitive-ref port-ndx) f6546) ((primitive-ref port-size) f6546)) (begin ((primitive-ref flush-output-port) f6546)) #f) (string-set! ((primitive-ref port-buf) f6546) ((primitive-ref port-ndx) f6546) f6543) ((primitive-ref port-ndx-add1) f6546))
# tail-begin (begin (if (fx= ((primitive-ref port-ndx) f6546) ((primitive-ref port-size) f6546)) (begin ((primitive-ref flush-output-port) f6546)) #f) (string-set! ((primitive-ref port-buf) f6546) ((primitive-ref port-ndx) f6546) f6543) ((primitive-ref port-ndx-add1) f6546))
#   env=((f6546 . -20) (f6543 . -16) (f6544 . -12) (f6543 . -8) (#f . 16) ((begin (primitive-ref port-size) (primitive-ref flush-output-port) (primitive-ref port-buf) (primitive-ref port-ndx) (primitive-ref port-ndx-add1)) . 12) ((primitive-ref port-ndx) . 8) (if . 4))
# emit-expr (if (fx= ((primitive-ref port-ndx) f6546) ((primitive-ref port-size) f6546)) (begin ((primitive-ref flush-output-port) f6546)) #f)
# emit-expr (fx= ((primitive-ref port-ndx) f6546) ((primitive-ref port-size) f6546))
# emit-expr ((primitive-ref port-size) f6546)
# funcall
#    si   =-24
#    env  = ((f6546 . -20) (f6543 . -16) (f6544 . -12) (f6543 . -8) (#f . 16) ((begin (primitive-ref port-size) (primitive-ref flush-output-port) (primitive-ref port-buf) (primitive-ref port-ndx) (primitive-ref port-ndx-add1)) . 12) ((primitive-ref port-ndx) . 8) (if . 4))
#    expr = (funcall (primitive-ref port-size) f6546)
# emit-expr (primitive-ref port-size)
    .extern mrc_port$msize
    movl mrc_port$msize,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_39912"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_39912":
   movl %eax,  -32(%esp)  # stash funcall-oper in closure slot
# emit-expr f6546
# emit-variable-ref
# env=((f6546 . -20) (f6543 . -16) (f6544 . -12) (f6543 . -8) (#f . 16) ((begin (primitive-ref port-size) (primitive-ref flush-output-port) (primitive-ref port-buf) (primitive-ref port-ndx) (primitive-ref port-ndx-add1)) . 12) ((primitive-ref port-ndx) . 8) (if . 4))
# var=f6546
    movl -20(%esp), %eax  # stack load f6546
# end emit-variable-ref
    mov %eax, -36(%esp)  # arg f6546
    movl -32(%esp), %edi   # load new closure to %edi
    add $-24, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $24, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_39913"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $68,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_39913:
    movl %eax, -24(%esp)
# emit-expr ((primitive-ref port-ndx) f6546)
# funcall
#    si   =-28
#    env  = ((f6546 . -20) (f6543 . -16) (f6544 . -12) (f6543 . -8) (#f . 16) ((begin (primitive-ref port-size) (primitive-ref flush-output-port) (primitive-ref port-buf) (primitive-ref port-ndx) (primitive-ref port-ndx-add1)) . 12) ((primitive-ref port-ndx) . 8) (if . 4))
#    expr = (funcall (primitive-ref port-ndx) f6546)
# emit-expr (primitive-ref port-ndx)
    .extern mrc_port$mndx
    movl mrc_port$mndx,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_39914"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_39914":
   movl %eax,  -36(%esp)  # stash funcall-oper in closure slot
# emit-expr f6546
# emit-variable-ref
# env=((f6546 . -20) (f6543 . -16) (f6544 . -12) (f6543 . -8) (#f . 16) ((begin (primitive-ref port-size) (primitive-ref flush-output-port) (primitive-ref port-buf) (primitive-ref port-ndx) (primitive-ref port-ndx-add1)) . 12) ((primitive-ref port-ndx) . 8) (if . 4))
# var=f6546
    movl -20(%esp), %eax  # stack load f6546
# end emit-variable-ref
    mov %eax, -40(%esp)  # arg f6546
    movl -36(%esp), %edi   # load new closure to %edi
    add $-28, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $28, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_39915"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $68,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_39915:
    cmp -24(%esp), %eax
    sete %al
    movzbl %al, %eax
    sal $6, %al
    or $47, %al
    cmp $47, %al
    je _L_39910
# emit-expr (begin ((primitive-ref flush-output-port) f6546))
# emit-begin
#   expr=(begin ((primitive-ref flush-output-port) f6546))
#   env=((f6546 . -20) (f6543 . -16) (f6544 . -12) (f6543 . -8) (#f . 16) ((begin (primitive-ref port-size) (primitive-ref flush-output-port) (primitive-ref port-buf) (primitive-ref port-ndx) (primitive-ref port-ndx-add1)) . 12) ((primitive-ref port-ndx) . 8) (if . 4))
# emit-expr ((primitive-ref flush-output-port) f6546)
# funcall
#    si   =-24
#    env  = ((f6546 . -20) (f6543 . -16) (f6544 . -12) (f6543 . -8) (#f . 16) ((begin (primitive-ref port-size) (primitive-ref flush-output-port) (primitive-ref port-buf) (primitive-ref port-ndx) (primitive-ref port-ndx-add1)) . 12) ((primitive-ref port-ndx) . 8) (if . 4))
#    expr = (funcall (primitive-ref flush-output-port) f6546)
# emit-expr (primitive-ref flush-output-port)
    .extern mrc_flush$moutput$mport
    movl mrc_flush$moutput$mport,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_39916"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_39916":
   movl %eax,  -32(%esp)  # stash funcall-oper in closure slot
# emit-expr f6546
# emit-variable-ref
# env=((f6546 . -20) (f6543 . -16) (f6544 . -12) (f6543 . -8) (#f . 16) ((begin (primitive-ref port-size) (primitive-ref flush-output-port) (primitive-ref port-buf) (primitive-ref port-ndx) (primitive-ref port-ndx-add1)) . 12) ((primitive-ref port-ndx) . 8) (if . 4))
# var=f6546
    movl -20(%esp), %eax  # stack load f6546
# end emit-variable-ref
    mov %eax, -36(%esp)  # arg f6546
    movl -32(%esp), %edi   # load new closure to %edi
    add $-24, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $24, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
# emit-expr (begin)
# emit-begin
#   expr=(begin)
#   env=((f6546 . -20) (f6543 . -16) (f6544 . -12) (f6543 . -8) (#f . 16) ((begin (primitive-ref port-size) (primitive-ref flush-output-port) (primitive-ref port-buf) (primitive-ref port-ndx) (primitive-ref port-ndx-add1)) . 12) ((primitive-ref port-ndx) . 8) (if . 4))
    jmp _L_39911
_L_39910:
# emit-expr #f
    movl $47, %eax     # immed #f
_L_39911:
# emit-tail-expr
# si=-24
# env=((f6546 . -20) (f6543 . -16) (f6544 . -12) (f6543 . -8) (#f . 16) ((begin (primitive-ref port-size) (primitive-ref flush-output-port) (primitive-ref port-buf) (primitive-ref port-ndx) (primitive-ref port-ndx-add1)) . 12) ((primitive-ref port-ndx) . 8) (if . 4))
# expr=(begin (string-set! ((primitive-ref port-buf) f6546) ((primitive-ref port-ndx) f6546) f6543) ((primitive-ref port-ndx-add1) f6546))
# tail-begin (begin (string-set! ((primitive-ref port-buf) f6546) ((primitive-ref port-ndx) f6546) f6543) ((primitive-ref port-ndx-add1) f6546))
#   env=((f6546 . -20) (f6543 . -16) (f6544 . -12) (f6543 . -8) (#f . 16) ((begin (primitive-ref port-size) (primitive-ref flush-output-port) (primitive-ref port-buf) (primitive-ref port-ndx) (primitive-ref port-ndx-add1)) . 12) ((primitive-ref port-ndx) . 8) (if . 4))
# emit-expr (string-set! ((primitive-ref port-buf) f6546) ((primitive-ref port-ndx) f6546) f6543)
# emit-expr ((primitive-ref port-buf) f6546)
# funcall
#    si   =-24
#    env  = ((f6546 . -20) (f6543 . -16) (f6544 . -12) (f6543 . -8) (#f . 16) ((begin (primitive-ref port-size) (primitive-ref flush-output-port) (primitive-ref port-buf) (primitive-ref port-ndx) (primitive-ref port-ndx-add1)) . 12) ((primitive-ref port-ndx) . 8) (if . 4))
#    expr = (funcall (primitive-ref port-buf) f6546)
# emit-expr (primitive-ref port-buf)
    .extern mrc_port$mbuf
    movl mrc_port$mbuf,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_39917"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_39917":
   movl %eax,  -32(%esp)  # stash funcall-oper in closure slot
# emit-expr f6546
# emit-variable-ref
# env=((f6546 . -20) (f6543 . -16) (f6544 . -12) (f6543 . -8) (#f . 16) ((begin (primitive-ref port-size) (primitive-ref flush-output-port) (primitive-ref port-buf) (primitive-ref port-ndx) (primitive-ref port-ndx-add1)) . 12) ((primitive-ref port-ndx) . 8) (if . 4))
# var=f6546
    movl -20(%esp), %eax  # stack load f6546
# end emit-variable-ref
    mov %eax, -36(%esp)  # arg f6546
    movl -32(%esp), %edi   # load new closure to %edi
    add $-24, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $24, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
# check the argument is a string
    movl %eax,%ebx
    and $7, %bl
    cmp $6, %bl
    je _L_39918
# invoke error handler eh_string
    .extern mrc_eh$ustring
    movl mrc_eh$ustring, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $168,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_39918:
    movl %eax, -24(%esp)
# emit-expr ((primitive-ref port-ndx) f6546)
# funcall
#    si   =-24
#    env  = ((f6546 . -20) (f6543 . -16) (f6544 . -12) (f6543 . -8) (#f . 16) ((begin (primitive-ref port-size) (primitive-ref flush-output-port) (primitive-ref port-buf) (primitive-ref port-ndx) (primitive-ref port-ndx-add1)) . 12) ((primitive-ref port-ndx) . 8) (if . 4))
#    expr = (funcall (primitive-ref port-ndx) f6546)
# emit-expr (primitive-ref port-ndx)
    .extern mrc_port$mndx
    movl mrc_port$mndx,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_39919"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_39919":
   movl %eax,  -32(%esp)  # stash funcall-oper in closure slot
# emit-expr f6546
# emit-variable-ref
# env=((f6546 . -20) (f6543 . -16) (f6544 . -12) (f6543 . -8) (#f . 16) ((begin (primitive-ref port-size) (primitive-ref flush-output-port) (primitive-ref port-buf) (primitive-ref port-ndx) (primitive-ref port-ndx-add1)) . 12) ((primitive-ref port-ndx) . 8) (if . 4))
# var=f6546
    movl -20(%esp), %eax  # stack load f6546
# end emit-variable-ref
    mov %eax, -36(%esp)  # arg f6546
    movl -32(%esp), %edi   # load new closure to %edi
    add $-24, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $24, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_39920"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $168,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_39920:
# check bounds on string index
    movl -24(%esp), %ebx
    cmp  %eax,-6(%ebx) 
    jle _L_39922
    cmp  $0,%eax
    jge _L_39921
_L_39922:
# invoke error handler eh_string_index
    .extern mrc_eh$ustring$uindex
    movl mrc_eh$ustring$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $168,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_39921:
    movl %eax, -28(%esp)
# emit-expr f6543
# emit-variable-ref
# env=((f6546 . -20) (f6543 . -16) (f6544 . -12) (f6543 . -8) (#f . 16) ((begin (primitive-ref port-size) (primitive-ref flush-output-port) (primitive-ref port-buf) (primitive-ref port-ndx) (primitive-ref port-ndx-add1)) . 12) ((primitive-ref port-ndx) . 8) (if . 4))
# var=f6543
    movl -16(%esp), %eax  # stack load f6543
# end emit-variable-ref
# check the argument is a char
    movl %eax,%ebx
    and $255, %bl
    cmp $15, %bl
    je "_L_39923"
# invoke error handler eh_character
    .extern mrc_eh$ucharacter
    movl mrc_eh$ucharacter, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $168,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_39923:
    movl -24(%esp), %ebx
    movl -28(%esp), %esi
    sar $2, %esi
    movb  %ah, -2(%ebx,%esi)
# emit-tail-expr
# si=-24
# env=((f6546 . -20) (f6543 . -16) (f6544 . -12) (f6543 . -8) (#f . 16) ((begin (primitive-ref port-size) (primitive-ref flush-output-port) (primitive-ref port-buf) (primitive-ref port-ndx) (primitive-ref port-ndx-add1)) . 12) ((primitive-ref port-ndx) . 8) (if . 4))
# expr=(begin ((primitive-ref port-ndx-add1) f6546))
# tail-begin (begin ((primitive-ref port-ndx-add1) f6546))
#   env=((f6546 . -20) (f6543 . -16) (f6544 . -12) (f6543 . -8) (#f . 16) ((begin (primitive-ref port-size) (primitive-ref flush-output-port) (primitive-ref port-buf) (primitive-ref port-ndx) (primitive-ref port-ndx-add1)) . 12) ((primitive-ref port-ndx) . 8) (if . 4))
# emit-tail-expr
# si=-24
# env=((f6546 . -20) (f6543 . -16) (f6544 . -12) (f6543 . -8) (#f . 16) ((begin (primitive-ref port-size) (primitive-ref flush-output-port) (primitive-ref port-buf) (primitive-ref port-ndx) (primitive-ref port-ndx-add1)) . 12) ((primitive-ref port-ndx) . 8) (if . 4))
# expr=((primitive-ref port-ndx-add1) f6546)
# emit-tail-funcall
#    si   =-24
#    env  = ((f6546 . -20) (f6543 . -16) (f6544 . -12) (f6543 . -8) (#f . 16) ((begin (primitive-ref port-size) (primitive-ref flush-output-port) (primitive-ref port-buf) (primitive-ref port-ndx) (primitive-ref port-ndx-add1)) . 12) ((primitive-ref port-ndx) . 8) (if . 4))
#    expr = (funcall (primitive-ref port-ndx-add1) f6546)
# emit-expr (primitive-ref port-ndx-add1)
    .extern mrc_port$mndx$madd1
    movl mrc_port$mndx$madd1,%eax
   movl %eax,  -24(%esp)  # stash funcall-oper in next closure slot
# emit-expr f6546
# emit-variable-ref
# env=((f6546 . -20) (f6543 . -16) (f6544 . -12) (f6543 . -8) (#f . 16) ((begin (primitive-ref port-size) (primitive-ref flush-output-port) (primitive-ref port-buf) (primitive-ref port-ndx) (primitive-ref port-ndx-add1)) . 12) ((primitive-ref port-ndx) . 8) (if . 4))
# var=f6546
    movl -20(%esp), %eax  # stack load f6546
# end emit-variable-ref
    mov %eax, -28(%esp)    # arg f6546
    movl -24(%esp), %edi   # load new closure to %edi
# emit-shift-args:  size=2   si=-24  delta=20
    mov -24(%esp), %ebx  # shift frame cell
    mov %ebx, -4(%esp)  # down to base
# emit-shift-args:  size=1   si=-28  delta=20
    mov -28(%esp), %ebx  # shift frame cell
    mov %ebx, -8(%esp)  # down to base
# emit-shift-args:  size=0   si=-32  delta=20
    movl $4,%eax   # save arg count
    jmp *-2(%edi)  # tail-funcall
     ret   # return thru stack
    .align 4,0x90
_L_39902:
     movl %eax, mrc_write$mchar
# == explicit-begins  ==>
# (lambda args (let ((p (if (null? args) (current-output-port) (car args)))) (begin (foreign-call "s_write" (port-fd p) (port-buf p) (port-ndx p)) (port-ndx-reset p))))
# == eliminate-let*  ==>
# (lambda args (let ((p (if (null? args) (current-output-port) (car args)))) (begin (foreign-call "s_write" (port-fd p) (port-buf p) (port-ndx p)) (port-ndx-reset p))))
# == uniquify-variables  ==>
# (lambda f6547 (let ((f6549 (if (null? f6547) (current-output-port) (car f6547)))) (begin (foreign-call "s_write" (port-fd f6549) (port-buf f6549) (port-ndx f6549)) (port-ndx-reset f6549))))
# == vectorize-letrec  ==>
# (lambda f6547 (let ((f6549 (if (null? f6547) (current-output-port) (car f6547)))) (begin (foreign-call "s_write" (port-fd f6549) (port-buf f6549) (port-ndx f6549)) (port-ndx-reset f6549))))
# == eliminate-set!  ==>
# (lambda f6547 (let () (let ((f6549 (if (null? f6547) (current-output-port) (car f6547)))) (begin (foreign-call "s_write" (port-fd f6549) (port-buf f6549) (port-ndx f6549)) (port-ndx-reset f6549)))))
# == close-free-variables  ==>
# (closure f6547 (port-fd port-buf port-ndx port-ndx-reset) (let () (let ((f6549 (if (null? f6547) (current-output-port) (car f6547)))) (begin (foreign-call "s_write" (port-fd f6549) (port-buf f6549) (port-ndx f6549)) (port-ndx-reset f6549)))))
# == eliminate-quote  ==>
# (closure f6547 (port-fd port-buf port-ndx port-ndx-reset) (let () (let ((f6549 (if (null? f6547) (current-output-port) (car f6547)))) (begin (foreign-call "s_write" (port-fd f6549) (port-buf f6549) (port-ndx f6549)) (port-ndx-reset f6549)))))
# == eliminate-when/unless  ==>
# (closure f6547 (port-fd port-buf port-ndx port-ndx-reset) (let () (let ((f6549 (if (null? f6547) (current-output-port) (car f6547)))) (begin (foreign-call "s_write" (port-fd f6549) (port-buf f6549) (port-ndx f6549)) (port-ndx-reset f6549)))))
# == eliminate-cond  ==>
# (closure f6547 (port-fd port-buf port-ndx port-ndx-reset) (let () (let ((f6549 (if (null? f6547) (current-output-port) (car f6547)))) (begin (foreign-call "s_write" (port-fd f6549) (port-buf f6549) (port-ndx f6549)) (port-ndx-reset f6549)))))
# == external-symbols  ==>
# (closure f6547 ((primitive-ref port-fd) (primitive-ref port-buf) (primitive-ref port-ndx) (primitive-ref port-ndx-reset)) (let () (let ((f6549 (if (null? f6547) ((primitive-ref current-output-port)) (car f6547)))) (begin (foreign-call "s_write" ((primitive-ref port-fd) f6549) ((primitive-ref port-buf) f6549) ((primitive-ref port-ndx) f6549)) ((primitive-ref port-ndx-reset) f6549)))))
# emit-expr (closure f6547 ((primitive-ref port-fd) (primitive-ref port-buf) (primitive-ref port-ndx) (primitive-ref port-ndx-reset)) (let () (let ((f6549 (if (null? f6547) ((primitive-ref current-output-port)) (car f6547)))) (begin (foreign-call "s_write" ((primitive-ref port-fd) f6549) ((primitive-ref port-buf) f6549) ((primitive-ref port-ndx) f6549)) ((primitive-ref port-ndx-reset) f6549)))))
# emit-closure
# si = 0
# env = ()
# expr = (closure f6547 ((primitive-ref port-fd) (primitive-ref port-buf) (primitive-ref port-ndx) (primitive-ref port-ndx-reset)) (let () (let ((f6549 (if (null? f6547) ((primitive-ref current-output-port)) (car f6547)))) (begin (foreign-call "s_write" ((primitive-ref port-fd) f6549) ((primitive-ref port-buf) f6549) ((primitive-ref port-ndx) f6549)) ((primitive-ref port-ndx-reset) f6549)))))
    movl $_L_39924, 0(%ebp)  # closure label
# WARNING: free var (primitive-ref port-fd) not defined in the environmnet
# WARNING: free var (primitive-ref port-buf) not defined in the environmnet
# WARNING: free var (primitive-ref port-ndx) not defined in the environmnet
# WARNING: free var (primitive-ref port-ndx-reset) not defined in the environmnet
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $24, %ebp     # bump ebp
    jmp _L_39925            # jump around closure body
_L_39924:
# check argument count
    cmp $0,%eax
    jge _L_39926
# invoke error handler eh_argcount_min
    .extern mrc_eh$uargcount$umin
    movl mrc_eh$uargcount$umin, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_39926:
# emit-build-varargs-list
    movl $63, %esi       # args <- () 
    lea -4(%esp),%edi    # edi <- esp-4
    subl %eax, %edi      # edi <- esp-4-eax    addr of arg[K+N] on stack
_L_39928:
    lea -4(%esp),%ebx    # addr of arg[K] on stack
    cmp %edi, %ebx       # while edi <> esp+(si+4)
    je _L_39927
    movl (%edi),%ebx     # arg i -> car
    movl %ebx, 0(%ebp)
    movl %esi, 4(%ebp)  # esi -> cdr
    movl %ebp, %esi
    addl $1, %esi       # tag as pair
    addl $8,%ebp         # bump heap ptr
    addl $4,%edi         # move to next previous arg from the end
    jmp _L_39928
_L_39927:
    movl %esi, -8(%esp)  # set args
# emit-tail-expr
# si=-12
# env=((f6547 . -8) ((primitive-ref port-ndx-reset) . 16) ((primitive-ref port-ndx) . 12) ((primitive-ref port-buf) . 8) ((primitive-ref port-fd) . 4))
# expr=(let () (let ((f6549 (if (null? f6547) ((primitive-ref current-output-port)) (car f6547)))) (begin (foreign-call "s_write" ((primitive-ref port-fd) f6549) ((primitive-ref port-buf) f6549) ((primitive-ref port-ndx) f6549)) ((primitive-ref port-ndx-reset) f6549))))
# emit-tail-let
#  si   = -12
#  env  = ((f6547 . -8) ((primitive-ref port-ndx-reset) . 16) ((primitive-ref port-ndx) . 12) ((primitive-ref port-buf) . 8) ((primitive-ref port-fd) . 4))
#  bindings = ()
#  body = (let ((f6549 (if (null? f6547) ((primitive-ref current-output-port)) (car f6547)))) (begin (foreign-call "s_write" ((primitive-ref port-fd) f6549) ((primitive-ref port-buf) f6549) ((primitive-ref port-ndx) f6549)) ((primitive-ref port-ndx-reset) f6549)))
# emit-tail-expr
# si=-12
# env=((f6547 . -8) ((primitive-ref port-ndx-reset) . 16) ((primitive-ref port-ndx) . 12) ((primitive-ref port-buf) . 8) ((primitive-ref port-fd) . 4))
# expr=(let ((f6549 (if (null? f6547) ((primitive-ref current-output-port)) (car f6547)))) (begin (foreign-call "s_write" ((primitive-ref port-fd) f6549) ((primitive-ref port-buf) f6549) ((primitive-ref port-ndx) f6549)) ((primitive-ref port-ndx-reset) f6549)))
# emit-tail-let
#  si   = -12
#  env  = ((f6547 . -8) ((primitive-ref port-ndx-reset) . 16) ((primitive-ref port-ndx) . 12) ((primitive-ref port-buf) . 8) ((primitive-ref port-fd) . 4))
#  bindings = ((f6549 (if (null? f6547) ((primitive-ref current-output-port)) (car f6547))))
#  body = (begin (foreign-call "s_write" ((primitive-ref port-fd) f6549) ((primitive-ref port-buf) f6549) ((primitive-ref port-ndx) f6549)) ((primitive-ref port-ndx-reset) f6549))
# emit-expr (if (null? f6547) ((primitive-ref current-output-port)) (car f6547))
# emit-expr (null? f6547)
# emit-expr f6547
# emit-variable-ref
# env=((f6547 . -8) ((primitive-ref port-ndx-reset) . 16) ((primitive-ref port-ndx) . 12) ((primitive-ref port-buf) . 8) ((primitive-ref port-fd) . 4))
# var=f6547
    movl -8(%esp), %eax  # stack load f6547
# end emit-variable-ref
    cmp $63, %eax
    mov $0, %eax
    sete %al
    movzbl %al, %eax
    sal $6, %al
    or $47, %al
    cmp $47, %al
    je _L_39929
# emit-expr ((primitive-ref current-output-port))
# funcall
#    si   =-12
#    env  = ((f6547 . -8) ((primitive-ref port-ndx-reset) . 16) ((primitive-ref port-ndx) . 12) ((primitive-ref port-buf) . 8) ((primitive-ref port-fd) . 4))
#    expr = (funcall (primitive-ref current-output-port))
# emit-expr (primitive-ref current-output-port)
    .extern mrc_current$moutput$mport
    movl mrc_current$moutput$mport,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_39931"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_39931":
   movl %eax,  -20(%esp)  # stash funcall-oper in closure slot
    movl -20(%esp), %edi   # load new closure to %edi
    add $-12, %esp   # adjust base
    movl $0,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $12, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    jmp _L_39930
_L_39929:
# emit-expr (car f6547)
# emit-expr f6547
# emit-variable-ref
# env=((f6547 . -8) ((primitive-ref port-ndx-reset) . 16) ((primitive-ref port-ndx) . 12) ((primitive-ref port-buf) . 8) ((primitive-ref port-fd) . 4))
# var=f6547
    movl -8(%esp), %eax  # stack load f6547
# end emit-variable-ref
# check the argument is a pair
    movl %eax,%ebx
    and $7, %bl
    cmp $1, %bl
    je _L_39932
# invoke error handler eh_pair
    .extern mrc_eh$upair
    movl mrc_eh$upair, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $116,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_39932:
    movl -1(%eax), %eax
_L_39930:
    movl %eax, -12(%esp)  # stack save
# emit-tail-expr
# si=-16
# env=((f6549 . -12) (f6547 . -8) ((primitive-ref port-ndx-reset) . 16) ((primitive-ref port-ndx) . 12) ((primitive-ref port-buf) . 8) ((primitive-ref port-fd) . 4))
# expr=(begin (foreign-call "s_write" ((primitive-ref port-fd) f6549) ((primitive-ref port-buf) f6549) ((primitive-ref port-ndx) f6549)) ((primitive-ref port-ndx-reset) f6549))
# tail-begin (begin (foreign-call "s_write" ((primitive-ref port-fd) f6549) ((primitive-ref port-buf) f6549) ((primitive-ref port-ndx) f6549)) ((primitive-ref port-ndx-reset) f6549))
#   env=((f6549 . -12) (f6547 . -8) ((primitive-ref port-ndx-reset) . 16) ((primitive-ref port-ndx) . 12) ((primitive-ref port-buf) . 8) ((primitive-ref port-fd) . 4))
# emit-expr (foreign-call "s_write" ((primitive-ref port-fd) f6549) ((primitive-ref port-buf) f6549) ((primitive-ref port-ndx) f6549))
    movl %ecx,-16(%esp)
    movl %esp,-20(%esp)
# emit-expr ((primitive-ref port-ndx) f6549)
# funcall
#    si   =-24
#    env  = ((f6549 . -12) (f6547 . -8) ((primitive-ref port-ndx-reset) . 16) ((primitive-ref port-ndx) . 12) ((primitive-ref port-buf) . 8) ((primitive-ref port-fd) . 4))
#    expr = (funcall (primitive-ref port-ndx) f6549)
# emit-expr (primitive-ref port-ndx)
    .extern mrc_port$mndx
    movl mrc_port$mndx,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_39933"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_39933":
   movl %eax,  -32(%esp)  # stash funcall-oper in closure slot
# emit-expr f6549
# emit-variable-ref
# env=((f6549 . -12) (f6547 . -8) ((primitive-ref port-ndx-reset) . 16) ((primitive-ref port-ndx) . 12) ((primitive-ref port-buf) . 8) ((primitive-ref port-fd) . 4))
# var=f6549
    movl -12(%esp), %eax  # stack load f6549
# end emit-variable-ref
    mov %eax, -36(%esp)  # arg f6549
    movl -32(%esp), %edi   # load new closure to %edi
    add $-24, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $24, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    movl %eax, -24(%esp)
# emit-expr ((primitive-ref port-buf) f6549)
# funcall
#    si   =-28
#    env  = ((f6549 . -12) (f6547 . -8) ((primitive-ref port-ndx-reset) . 16) ((primitive-ref port-ndx) . 12) ((primitive-ref port-buf) . 8) ((primitive-ref port-fd) . 4))
#    expr = (funcall (primitive-ref port-buf) f6549)
# emit-expr (primitive-ref port-buf)
    .extern mrc_port$mbuf
    movl mrc_port$mbuf,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_39934"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_39934":
   movl %eax,  -36(%esp)  # stash funcall-oper in closure slot
# emit-expr f6549
# emit-variable-ref
# env=((f6549 . -12) (f6547 . -8) ((primitive-ref port-ndx-reset) . 16) ((primitive-ref port-ndx) . 12) ((primitive-ref port-buf) . 8) ((primitive-ref port-fd) . 4))
# var=f6549
    movl -12(%esp), %eax  # stack load f6549
# end emit-variable-ref
    mov %eax, -40(%esp)  # arg f6549
    movl -36(%esp), %edi   # load new closure to %edi
    add $-28, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $28, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    movl %eax, -28(%esp)
# emit-expr ((primitive-ref port-fd) f6549)
# funcall
#    si   =-32
#    env  = ((f6549 . -12) (f6547 . -8) ((primitive-ref port-ndx-reset) . 16) ((primitive-ref port-ndx) . 12) ((primitive-ref port-buf) . 8) ((primitive-ref port-fd) . 4))
#    expr = (funcall (primitive-ref port-fd) f6549)
# emit-expr (primitive-ref port-fd)
    .extern mrc_port$mfd
    movl mrc_port$mfd,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_39935"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_39935":
   movl %eax,  -40(%esp)  # stash funcall-oper in closure slot
# emit-expr f6549
# emit-variable-ref
# env=((f6549 . -12) (f6547 . -8) ((primitive-ref port-ndx-reset) . 16) ((primitive-ref port-ndx) . 12) ((primitive-ref port-buf) . 8) ((primitive-ref port-fd) . 4))
# var=f6549
    movl -12(%esp), %eax  # stack load f6549
# end emit-variable-ref
    mov %eax, -44(%esp)  # arg f6549
    movl -40(%esp), %edi   # load new closure to %edi
    add $-32, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $32, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    movl %eax, -32(%esp)
    leal -32(%esp),%edi
    movl %edi,%esi
    andl $-16,%esi
    movl 0(%edi),%eax
    movl %eax,0(%esi)
    movl 4(%edi),%eax
    movl %eax,4(%esi)
    movl 8(%edi),%eax
    movl %eax,8(%esi)
    movl 12(%edi),%eax
    movl %eax,12(%esi)
    movl %esi,%esp
    .extern _s_write
    call _s_write
    movl 12(%esi),%esp
    movl -16(%esp),%ecx
# emit-tail-expr
# si=-16
# env=((f6549 . -12) (f6547 . -8) ((primitive-ref port-ndx-reset) . 16) ((primitive-ref port-ndx) . 12) ((primitive-ref port-buf) . 8) ((primitive-ref port-fd) . 4))
# expr=(begin ((primitive-ref port-ndx-reset) f6549))
# tail-begin (begin ((primitive-ref port-ndx-reset) f6549))
#   env=((f6549 . -12) (f6547 . -8) ((primitive-ref port-ndx-reset) . 16) ((primitive-ref port-ndx) . 12) ((primitive-ref port-buf) . 8) ((primitive-ref port-fd) . 4))
# emit-tail-expr
# si=-16
# env=((f6549 . -12) (f6547 . -8) ((primitive-ref port-ndx-reset) . 16) ((primitive-ref port-ndx) . 12) ((primitive-ref port-buf) . 8) ((primitive-ref port-fd) . 4))
# expr=((primitive-ref port-ndx-reset) f6549)
# emit-tail-funcall
#    si   =-16
#    env  = ((f6549 . -12) (f6547 . -8) ((primitive-ref port-ndx-reset) . 16) ((primitive-ref port-ndx) . 12) ((primitive-ref port-buf) . 8) ((primitive-ref port-fd) . 4))
#    expr = (funcall (primitive-ref port-ndx-reset) f6549)
# emit-expr (primitive-ref port-ndx-reset)
    .extern mrc_port$mndx$mreset
    movl mrc_port$mndx$mreset,%eax
   movl %eax,  -16(%esp)  # stash funcall-oper in next closure slot
# emit-expr f6549
# emit-variable-ref
# env=((f6549 . -12) (f6547 . -8) ((primitive-ref port-ndx-reset) . 16) ((primitive-ref port-ndx) . 12) ((primitive-ref port-buf) . 8) ((primitive-ref port-fd) . 4))
# var=f6549
    movl -12(%esp), %eax  # stack load f6549
# end emit-variable-ref
    mov %eax, -20(%esp)    # arg f6549
    movl -16(%esp), %edi   # load new closure to %edi
# emit-shift-args:  size=2   si=-16  delta=12
    mov -16(%esp), %ebx  # shift frame cell
    mov %ebx, -4(%esp)  # down to base
# emit-shift-args:  size=1   si=-20  delta=12
    mov -20(%esp), %ebx  # shift frame cell
    mov %ebx, -8(%esp)  # down to base
# emit-shift-args:  size=0   si=-24  delta=12
    movl $4,%eax   # save arg count
    jmp *-2(%edi)  # tail-funcall
     ret   # return thru stack
    .align 4,0x90
_L_39925:
     movl %eax, mrc_flush$moutput$mport
# == explicit-begins  ==>
# (lambda () (begin (flush-output-port) (foreign-call "s_exit")))
# == eliminate-let*  ==>
# (lambda () (begin (flush-output-port) (foreign-call "s_exit")))
# == uniquify-variables  ==>
# (lambda () (begin (flush-output-port) (foreign-call "s_exit")))
# == vectorize-letrec  ==>
# (lambda () (begin (flush-output-port) (foreign-call "s_exit")))
# == eliminate-set!  ==>
# (lambda () (let () (begin (flush-output-port) (foreign-call "s_exit"))))
# == close-free-variables  ==>
# (closure () (flush-output-port) (let () (begin (flush-output-port) (foreign-call "s_exit"))))
# == eliminate-quote  ==>
# (closure () (flush-output-port) (let () (begin (flush-output-port) (foreign-call "s_exit"))))
# == eliminate-when/unless  ==>
# (closure () (flush-output-port) (let () (begin (flush-output-port) (foreign-call "s_exit"))))
# == eliminate-cond  ==>
# (closure () (flush-output-port) (let () (begin (flush-output-port) (foreign-call "s_exit"))))
# == external-symbols  ==>
# (closure () ((primitive-ref flush-output-port)) (let () (begin ((primitive-ref flush-output-port)) (foreign-call "s_exit"))))
# emit-expr (closure () ((primitive-ref flush-output-port)) (let () (begin ((primitive-ref flush-output-port)) (foreign-call "s_exit"))))
# emit-closure
# si = 0
# env = ()
# expr = (closure () ((primitive-ref flush-output-port)) (let () (begin ((primitive-ref flush-output-port)) (foreign-call "s_exit"))))
    movl $_L_39936, 0(%ebp)  # closure label
# WARNING: free var (primitive-ref flush-output-port) not defined in the environmnet
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $8, %ebp     # bump ebp
    jmp _L_39937            # jump around closure body
_L_39936:
# check argument count
    cmp $0,%eax
    je _L_39938
# invoke error handler eh_argcount
    .extern mrc_eh$uargcount
    movl mrc_eh$uargcount, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_39938:
# emit-tail-expr
# si=-8
# env=(((primitive-ref flush-output-port) . 4))
# expr=(let () (begin ((primitive-ref flush-output-port)) (foreign-call "s_exit")))
# emit-tail-let
#  si   = -8
#  env  = (((primitive-ref flush-output-port) . 4))
#  bindings = ()
#  body = (begin ((primitive-ref flush-output-port)) (foreign-call "s_exit"))
# emit-tail-expr
# si=-8
# env=(((primitive-ref flush-output-port) . 4))
# expr=(begin ((primitive-ref flush-output-port)) (foreign-call "s_exit"))
# tail-begin (begin ((primitive-ref flush-output-port)) (foreign-call "s_exit"))
#   env=(((primitive-ref flush-output-port) . 4))
# emit-expr ((primitive-ref flush-output-port))
# funcall
#    si   =-8
#    env  = (((primitive-ref flush-output-port) . 4))
#    expr = (funcall (primitive-ref flush-output-port))
# emit-expr (primitive-ref flush-output-port)
    .extern mrc_flush$moutput$mport
    movl mrc_flush$moutput$mport,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_39939"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_39939":
   movl %eax,  -16(%esp)  # stash funcall-oper in closure slot
    movl -16(%esp), %edi   # load new closure to %edi
    add $-8, %esp   # adjust base
    movl $0,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $8, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
# emit-tail-expr
# si=-8
# env=(((primitive-ref flush-output-port) . 4))
# expr=(begin (foreign-call "s_exit"))
# tail-begin (begin (foreign-call "s_exit"))
#   env=(((primitive-ref flush-output-port) . 4))
# emit-tail-expr
# si=-8
# env=(((primitive-ref flush-output-port) . 4))
# expr=(foreign-call "s_exit")
    movl %ecx,-8(%esp)
    movl %esp,-12(%esp)
    leal -12(%esp),%edi
    movl %edi,%esi
    andl $-16,%esi
    movl 0(%edi),%eax
    movl %eax,0(%esi)
    movl %esi,%esp
    .extern _s_exit
    call _s_exit
    movl 0(%esi),%esp
    movl -8(%esp),%ecx
     ret
     ret   # return thru stack
    .align 4,0x90
_L_39937:
     movl %eax, mrc_exit
# == explicit-begins  ==>
# (lambda (filename) (begin (unless (string? filename) (error (quote open-output-file) "filename must be a string")) (let ((fd (foreign-call "s_open" filename))) (begin (when (negative? fd) (error (quote open-output-file) "open failed")) (let ((p (make-vector 6)) (sz 1024)) (begin (vector-set! p 0 (quote output-port)) (vector-set! p 1 filename) (vector-set! p 2 fd) (vector-set! p 3 (make-string sz)) (vector-set! p 4 0) (vector-set! p 5 sz) p))))))
# == eliminate-let*  ==>
# (lambda (filename) (begin (unless (string? filename) (error (quote open-output-file) "filename must be a string")) (let ((fd (foreign-call "s_open" filename))) (begin (when (negative? fd) (error (quote open-output-file) "open failed")) (let ((p (make-vector 6)) (sz 1024)) (begin (vector-set! p 0 (quote output-port)) (vector-set! p 1 filename) (vector-set! p 2 fd) (vector-set! p 3 (make-string sz)) (vector-set! p 4 0) (vector-set! p 5 sz) p))))))
# == uniquify-variables  ==>
# (lambda (f6550) (begin (unless (string? f6550) (error (quote open-output-file) "filename must be a string")) (let ((f6556 (foreign-call "s_open" f6550))) (begin (when (negative? f6556) (error (quote open-output-file) "open failed")) (let ((f6560 (make-vector 6)) (f6559 1024)) (begin (vector-set! f6560 0 (quote output-port)) (vector-set! f6560 1 f6550) (vector-set! f6560 2 f6556) (vector-set! f6560 3 (make-string f6559)) (vector-set! f6560 4 0) (vector-set! f6560 5 f6559) f6560))))))
# == vectorize-letrec  ==>
# (lambda (f6550) (begin (unless (string? f6550) (error (quote open-output-file) "filename must be a string")) (let ((f6556 (foreign-call "s_open" f6550))) (begin (when (negative? f6556) (error (quote open-output-file) "open failed")) (let ((f6560 (make-vector 6)) (f6559 1024)) (begin (vector-set! f6560 0 (quote output-port)) (vector-set! f6560 1 f6550) (vector-set! f6560 2 f6556) (vector-set! f6560 3 (make-string f6559)) (vector-set! f6560 4 0) (vector-set! f6560 5 f6559) f6560))))))
# == eliminate-set!  ==>
# (lambda (f6550) (let ((f6550 f6550)) (begin (unless (string? f6550) (error (quote open-output-file) "filename must be a string")) (let ((f6556 (foreign-call "s_open" f6550))) (begin (when (negative? f6556) (error (quote open-output-file) "open failed")) (let ((f6560 (make-vector 6)) (f6559 1024)) (begin (vector-set! f6560 0 (quote output-port)) (vector-set! f6560 1 f6550) (vector-set! f6560 2 f6556) (vector-set! f6560 3 (make-string f6559)) (vector-set! f6560 4 0) (vector-set! f6560 5 f6559) f6560)))))))
# == close-free-variables  ==>
# (closure (f6550) (unless error open-output-file when negative? error open-output-file output-port) (let ((f6550 f6550)) (begin (unless (string? f6550) (error (quote open-output-file) "filename must be a string")) (let ((f6556 (foreign-call "s_open" f6550))) (begin (when (negative? f6556) (error (quote open-output-file) "open failed")) (let ((f6560 (make-vector 6)) (f6559 1024)) (begin (vector-set! f6560 0 (quote output-port)) (vector-set! f6560 1 f6550) (vector-set! f6560 2 f6556) (vector-set! f6560 3 (make-string f6559)) (vector-set! f6560 4 0) (vector-set! f6560 5 f6559) f6560)))))))
# == eliminate-quote  ==>
# (closure (f6550) (unless error open-output-file when negative? error open-output-file output-port) (let ((f6550 f6550)) (begin (unless (string? f6550) (error (string->symbol "open-output-file") "filename must be a string")) (let ((f6556 (foreign-call "s_open" f6550))) (begin (when (negative? f6556) (error (string->symbol "open-output-file") "open failed")) (let ((f6560 (make-vector 6)) (f6559 1024)) (begin (vector-set! f6560 0 (string->symbol "output-port")) (vector-set! f6560 1 f6550) (vector-set! f6560 2 f6556) (vector-set! f6560 3 (make-string f6559)) (vector-set! f6560 4 0) (vector-set! f6560 5 f6559) f6560)))))))
# == eliminate-when/unless  ==>
# (closure (f6550) (if (not error) (begin open-output-file if negative? (begin error open-output-file output-port) #f) #f) (let ((f6550 f6550)) (begin (if (not (string? f6550)) (begin (error (string->symbol "open-output-file") "filename must be a string")) #f) (let ((f6556 (foreign-call "s_open" f6550))) (begin (if (negative? f6556) (begin (error (string->symbol "open-output-file") "open failed")) #f) (let ((f6560 (make-vector 6)) (f6559 1024)) (begin (vector-set! f6560 0 (string->symbol "output-port")) (vector-set! f6560 1 f6550) (vector-set! f6560 2 f6556) (vector-set! f6560 3 (make-string f6559)) (vector-set! f6560 4 0) (vector-set! f6560 5 f6559) f6560)))))))
# == eliminate-cond  ==>
# (closure (f6550) (if (not error) (begin open-output-file if negative? (begin error open-output-file output-port) #f) #f) (let ((f6550 f6550)) (begin (if (not (string? f6550)) (begin (error (string->symbol "open-output-file") "filename must be a string")) #f) (let ((f6556 (foreign-call "s_open" f6550))) (begin (if (negative? f6556) (begin (error (string->symbol "open-output-file") "open failed")) #f) (let ((f6560 (make-vector 6)) (f6559 1024)) (begin (vector-set! f6560 0 (string->symbol "output-port")) (vector-set! f6560 1 f6550) (vector-set! f6560 2 f6556) (vector-set! f6560 3 (make-string f6559)) (vector-set! f6560 4 0) (vector-set! f6560 5 f6559) f6560)))))))
# == external-symbols  ==>
# (closure (f6550) (if (not (primitive-ref error)) (begin (primitive-ref open-output-file) if (primitive-ref negative?) (begin (primitive-ref error) (primitive-ref open-output-file) output-port) #f) #f) (let ((f6550 f6550)) (begin (if (not (string? f6550)) (begin ((primitive-ref error) ((primitive-ref string->symbol) "open-output-file") "filename must be a string")) #f) (let ((f6556 (foreign-call "s_open" f6550))) (begin (if ((primitive-ref negative?) f6556) (begin ((primitive-ref error) ((primitive-ref string->symbol) "open-output-file") "open failed")) #f) (let ((f6560 (make-vector 6)) (f6559 1024)) (begin (vector-set! f6560 0 ((primitive-ref string->symbol) "output-port")) (vector-set! f6560 1 f6550) (vector-set! f6560 2 f6556) (vector-set! f6560 3 (make-string f6559)) (vector-set! f6560 4 0) (vector-set! f6560 5 f6559) f6560)))))))
# emit-expr (closure (f6550) (if (not (primitive-ref error)) (begin (primitive-ref open-output-file) if (primitive-ref negative?) (begin (primitive-ref error) (primitive-ref open-output-file) output-port) #f) #f) (let ((f6550 f6550)) (begin (if (not (string? f6550)) (begin ((primitive-ref error) ((primitive-ref string->symbol) "open-output-file") "filename must be a string")) #f) (let ((f6556 (foreign-call "s_open" f6550))) (begin (if ((primitive-ref negative?) f6556) (begin ((primitive-ref error) ((primitive-ref string->symbol) "open-output-file") "open failed")) #f) (let ((f6560 (make-vector 6)) (f6559 1024)) (begin (vector-set! f6560 0 ((primitive-ref string->symbol) "output-port")) (vector-set! f6560 1 f6550) (vector-set! f6560 2 f6556) (vector-set! f6560 3 (make-string f6559)) (vector-set! f6560 4 0) (vector-set! f6560 5 f6559) f6560)))))))
# emit-closure
# si = 0
# env = ()
# expr = (closure (f6550) (if (not (primitive-ref error)) (begin (primitive-ref open-output-file) if (primitive-ref negative?) (begin (primitive-ref error) (primitive-ref open-output-file) output-port) #f) #f) (let ((f6550 f6550)) (begin (if (not (string? f6550)) (begin ((primitive-ref error) ((primitive-ref string->symbol) "open-output-file") "filename must be a string")) #f) (let ((f6556 (foreign-call "s_open" f6550))) (begin (if ((primitive-ref negative?) f6556) (begin ((primitive-ref error) ((primitive-ref string->symbol) "open-output-file") "open failed")) #f) (let ((f6560 (make-vector 6)) (f6559 1024)) (begin (vector-set! f6560 0 ((primitive-ref string->symbol) "output-port")) (vector-set! f6560 1 f6550) (vector-set! f6560 2 f6556) (vector-set! f6560 3 (make-string f6559)) (vector-set! f6560 4 0) (vector-set! f6560 5 f6559) f6560)))))))
    movl $_L_39940, 0(%ebp)  # closure label
# WARNING: free var if not defined in the environmnet
# WARNING: free var (not (primitive-ref error)) not defined in the environmnet
# WARNING: free var (begin (primitive-ref open-output-file) if (primitive-ref negative?) (begin (primitive-ref error) (primitive-ref open-output-file) output-port) #f) not defined in the environmnet
# WARNING: free var #f not defined in the environmnet
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $24, %ebp     # bump ebp
    jmp _L_39941            # jump around closure body
_L_39940:
# check argument count
    cmp $4,%eax
    je _L_39942
# invoke error handler eh_argcount
    .extern mrc_eh$uargcount
    movl mrc_eh$uargcount, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_39942:
# emit-tail-expr
# si=-12
# env=((f6550 . -8) (#f . 16) ((begin (primitive-ref open-output-file) if (primitive-ref negative?) (begin (primitive-ref error) (primitive-ref open-output-file) output-port) #f) . 12) ((not (primitive-ref error)) . 8) (if . 4))
# expr=(let ((f6550 f6550)) (begin (if (not (string? f6550)) (begin ((primitive-ref error) ((primitive-ref string->symbol) "open-output-file") "filename must be a string")) #f) (let ((f6556 (foreign-call "s_open" f6550))) (begin (if ((primitive-ref negative?) f6556) (begin ((primitive-ref error) ((primitive-ref string->symbol) "open-output-file") "open failed")) #f) (let ((f6560 (make-vector 6)) (f6559 1024)) (begin (vector-set! f6560 0 ((primitive-ref string->symbol) "output-port")) (vector-set! f6560 1 f6550) (vector-set! f6560 2 f6556) (vector-set! f6560 3 (make-string f6559)) (vector-set! f6560 4 0) (vector-set! f6560 5 f6559) f6560))))))
# emit-tail-let
#  si   = -12
#  env  = ((f6550 . -8) (#f . 16) ((begin (primitive-ref open-output-file) if (primitive-ref negative?) (begin (primitive-ref error) (primitive-ref open-output-file) output-port) #f) . 12) ((not (primitive-ref error)) . 8) (if . 4))
#  bindings = ((f6550 f6550))
#  body = (begin (if (not (string? f6550)) (begin ((primitive-ref error) ((primitive-ref string->symbol) "open-output-file") "filename must be a string")) #f) (let ((f6556 (foreign-call "s_open" f6550))) (begin (if ((primitive-ref negative?) f6556) (begin ((primitive-ref error) ((primitive-ref string->symbol) "open-output-file") "open failed")) #f) (let ((f6560 (make-vector 6)) (f6559 1024)) (begin (vector-set! f6560 0 ((primitive-ref string->symbol) "output-port")) (vector-set! f6560 1 f6550) (vector-set! f6560 2 f6556) (vector-set! f6560 3 (make-string f6559)) (vector-set! f6560 4 0) (vector-set! f6560 5 f6559) f6560)))))
# emit-expr f6550
# emit-variable-ref
# env=((f6550 . -8) (#f . 16) ((begin (primitive-ref open-output-file) if (primitive-ref negative?) (begin (primitive-ref error) (primitive-ref open-output-file) output-port) #f) . 12) ((not (primitive-ref error)) . 8) (if . 4))
# var=f6550
    movl -8(%esp), %eax  # stack load f6550
# end emit-variable-ref
    movl %eax, -12(%esp)  # stack save
# emit-tail-expr
# si=-16
# env=((f6550 . -12) (f6550 . -8) (#f . 16) ((begin (primitive-ref open-output-file) if (primitive-ref negative?) (begin (primitive-ref error) (primitive-ref open-output-file) output-port) #f) . 12) ((not (primitive-ref error)) . 8) (if . 4))
# expr=(begin (if (not (string? f6550)) (begin ((primitive-ref error) ((primitive-ref string->symbol) "open-output-file") "filename must be a string")) #f) (let ((f6556 (foreign-call "s_open" f6550))) (begin (if ((primitive-ref negative?) f6556) (begin ((primitive-ref error) ((primitive-ref string->symbol) "open-output-file") "open failed")) #f) (let ((f6560 (make-vector 6)) (f6559 1024)) (begin (vector-set! f6560 0 ((primitive-ref string->symbol) "output-port")) (vector-set! f6560 1 f6550) (vector-set! f6560 2 f6556) (vector-set! f6560 3 (make-string f6559)) (vector-set! f6560 4 0) (vector-set! f6560 5 f6559) f6560)))))
# tail-begin (begin (if (not (string? f6550)) (begin ((primitive-ref error) ((primitive-ref string->symbol) "open-output-file") "filename must be a string")) #f) (let ((f6556 (foreign-call "s_open" f6550))) (begin (if ((primitive-ref negative?) f6556) (begin ((primitive-ref error) ((primitive-ref string->symbol) "open-output-file") "open failed")) #f) (let ((f6560 (make-vector 6)) (f6559 1024)) (begin (vector-set! f6560 0 ((primitive-ref string->symbol) "output-port")) (vector-set! f6560 1 f6550) (vector-set! f6560 2 f6556) (vector-set! f6560 3 (make-string f6559)) (vector-set! f6560 4 0) (vector-set! f6560 5 f6559) f6560)))))
#   env=((f6550 . -12) (f6550 . -8) (#f . 16) ((begin (primitive-ref open-output-file) if (primitive-ref negative?) (begin (primitive-ref error) (primitive-ref open-output-file) output-port) #f) . 12) ((not (primitive-ref error)) . 8) (if . 4))
# emit-expr (if (not (string? f6550)) (begin ((primitive-ref error) ((primitive-ref string->symbol) "open-output-file") "filename must be a string")) #f)
# emit-expr (not (string? f6550))
# emit-expr (string? f6550)
# emit-expr f6550
# emit-variable-ref
# env=((f6550 . -12) (f6550 . -8) (#f . 16) ((begin (primitive-ref open-output-file) if (primitive-ref negative?) (begin (primitive-ref error) (primitive-ref open-output-file) output-port) #f) . 12) ((not (primitive-ref error)) . 8) (if . 4))
# var=f6550
    movl -12(%esp), %eax  # stack load f6550
# end emit-variable-ref
    and $7, %al
    cmp $6, %al
    sete %al
    movzbl %al, %eax
    sal $6, %al
    or $47, %al
    cmp $47, %eax
    sete %al
    movzbl %al, %eax
    sal $6, %al
    or $47, %al
    cmp $47, %al
    je _L_39943
# emit-expr (begin ((primitive-ref error) ((primitive-ref string->symbol) "open-output-file") "filename must be a string"))
# emit-begin
#   expr=(begin ((primitive-ref error) ((primitive-ref string->symbol) "open-output-file") "filename must be a string"))
#   env=((f6550 . -12) (f6550 . -8) (#f . 16) ((begin (primitive-ref open-output-file) if (primitive-ref negative?) (begin (primitive-ref error) (primitive-ref open-output-file) output-port) #f) . 12) ((not (primitive-ref error)) . 8) (if . 4))
# emit-expr ((primitive-ref error) ((primitive-ref string->symbol) "open-output-file") "filename must be a string")
# funcall
#    si   =-16
#    env  = ((f6550 . -12) (f6550 . -8) (#f . 16) ((begin (primitive-ref open-output-file) if (primitive-ref negative?) (begin (primitive-ref error) (primitive-ref open-output-file) output-port) #f) . 12) ((not (primitive-ref error)) . 8) (if . 4))
#    expr = (funcall (primitive-ref error) ((primitive-ref string->symbol) "open-output-file") "filename must be a string")
# emit-expr (primitive-ref error)
    .extern mrc_error
    movl mrc_error,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_39945"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_39945":
   movl %eax,  -24(%esp)  # stash funcall-oper in closure slot
# emit-expr ((primitive-ref string->symbol) "open-output-file")
# funcall
#    si   =-28
#    env  = ((f6550 . -12) (f6550 . -8) (#f . 16) ((begin (primitive-ref open-output-file) if (primitive-ref negative?) (begin (primitive-ref error) (primitive-ref open-output-file) output-port) #f) . 12) ((not (primitive-ref error)) . 8) (if . 4))
#    expr = (funcall (primitive-ref string->symbol) "open-output-file")
# emit-expr (primitive-ref string->symbol)
    .extern mrc_string$m$gsymbol
    movl mrc_string$m$gsymbol,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_39946"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_39946":
   movl %eax,  -36(%esp)  # stash funcall-oper in closure slot
# emit-expr "open-output-file"
# string literal
    jmp _L_39948
    .align 8,0x90
_L_39947 :
    .int 64
    .ascii "open-output-file"
_L_39948:
    movl $_L_39947, %eax
    orl $6, %eax
    mov %eax, -40(%esp)  # arg open-output-file
    movl -36(%esp), %edi   # load new closure to %edi
    add $-28, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $28, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    mov %eax, -28(%esp)  # arg ((primitive-ref string->symbol) open-output-file)
# emit-expr "filename must be a string"
# string literal
    jmp _L_39950
    .align 8,0x90
_L_39949 :
    .int 100
    .ascii "filename must be a string"
_L_39950:
    movl $_L_39949, %eax
    orl $6, %eax
    mov %eax, -32(%esp)  # arg filename must be a string
    movl -24(%esp), %edi   # load new closure to %edi
    add $-16, %esp   # adjust base
    movl $8,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $16, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
# emit-expr (begin)
# emit-begin
#   expr=(begin)
#   env=((f6550 . -12) (f6550 . -8) (#f . 16) ((begin (primitive-ref open-output-file) if (primitive-ref negative?) (begin (primitive-ref error) (primitive-ref open-output-file) output-port) #f) . 12) ((not (primitive-ref error)) . 8) (if . 4))
    jmp _L_39944
_L_39943:
# emit-expr #f
    movl $47, %eax     # immed #f
_L_39944:
# emit-tail-expr
# si=-16
# env=((f6550 . -12) (f6550 . -8) (#f . 16) ((begin (primitive-ref open-output-file) if (primitive-ref negative?) (begin (primitive-ref error) (primitive-ref open-output-file) output-port) #f) . 12) ((not (primitive-ref error)) . 8) (if . 4))
# expr=(begin (let ((f6556 (foreign-call "s_open" f6550))) (begin (if ((primitive-ref negative?) f6556) (begin ((primitive-ref error) ((primitive-ref string->symbol) "open-output-file") "open failed")) #f) (let ((f6560 (make-vector 6)) (f6559 1024)) (begin (vector-set! f6560 0 ((primitive-ref string->symbol) "output-port")) (vector-set! f6560 1 f6550) (vector-set! f6560 2 f6556) (vector-set! f6560 3 (make-string f6559)) (vector-set! f6560 4 0) (vector-set! f6560 5 f6559) f6560)))))
# tail-begin (begin (let ((f6556 (foreign-call "s_open" f6550))) (begin (if ((primitive-ref negative?) f6556) (begin ((primitive-ref error) ((primitive-ref string->symbol) "open-output-file") "open failed")) #f) (let ((f6560 (make-vector 6)) (f6559 1024)) (begin (vector-set! f6560 0 ((primitive-ref string->symbol) "output-port")) (vector-set! f6560 1 f6550) (vector-set! f6560 2 f6556) (vector-set! f6560 3 (make-string f6559)) (vector-set! f6560 4 0) (vector-set! f6560 5 f6559) f6560)))))
#   env=((f6550 . -12) (f6550 . -8) (#f . 16) ((begin (primitive-ref open-output-file) if (primitive-ref negative?) (begin (primitive-ref error) (primitive-ref open-output-file) output-port) #f) . 12) ((not (primitive-ref error)) . 8) (if . 4))
# emit-tail-expr
# si=-16
# env=((f6550 . -12) (f6550 . -8) (#f . 16) ((begin (primitive-ref open-output-file) if (primitive-ref negative?) (begin (primitive-ref error) (primitive-ref open-output-file) output-port) #f) . 12) ((not (primitive-ref error)) . 8) (if . 4))
# expr=(let ((f6556 (foreign-call "s_open" f6550))) (begin (if ((primitive-ref negative?) f6556) (begin ((primitive-ref error) ((primitive-ref string->symbol) "open-output-file") "open failed")) #f) (let ((f6560 (make-vector 6)) (f6559 1024)) (begin (vector-set! f6560 0 ((primitive-ref string->symbol) "output-port")) (vector-set! f6560 1 f6550) (vector-set! f6560 2 f6556) (vector-set! f6560 3 (make-string f6559)) (vector-set! f6560 4 0) (vector-set! f6560 5 f6559) f6560))))
# emit-tail-let
#  si   = -16
#  env  = ((f6550 . -12) (f6550 . -8) (#f . 16) ((begin (primitive-ref open-output-file) if (primitive-ref negative?) (begin (primitive-ref error) (primitive-ref open-output-file) output-port) #f) . 12) ((not (primitive-ref error)) . 8) (if . 4))
#  bindings = ((f6556 (foreign-call "s_open" f6550)))
#  body = (begin (if ((primitive-ref negative?) f6556) (begin ((primitive-ref error) ((primitive-ref string->symbol) "open-output-file") "open failed")) #f) (let ((f6560 (make-vector 6)) (f6559 1024)) (begin (vector-set! f6560 0 ((primitive-ref string->symbol) "output-port")) (vector-set! f6560 1 f6550) (vector-set! f6560 2 f6556) (vector-set! f6560 3 (make-string f6559)) (vector-set! f6560 4 0) (vector-set! f6560 5 f6559) f6560)))
# emit-expr (foreign-call "s_open" f6550)
    movl %ecx,-16(%esp)
    movl %esp,-20(%esp)
# emit-expr f6550
# emit-variable-ref
# env=((f6550 . -12) (f6550 . -8) (#f . 16) ((begin (primitive-ref open-output-file) if (primitive-ref negative?) (begin (primitive-ref error) (primitive-ref open-output-file) output-port) #f) . 12) ((not (primitive-ref error)) . 8) (if . 4))
# var=f6550
    movl -12(%esp), %eax  # stack load f6550
# end emit-variable-ref
    movl %eax, -24(%esp)
    leal -24(%esp),%edi
    movl %edi,%esi
    andl $-16,%esi
    movl 0(%edi),%eax
    movl %eax,0(%esi)
    movl 4(%edi),%eax
    movl %eax,4(%esi)
    movl %esi,%esp
    .extern _s_open
    call _s_open
    movl 4(%esi),%esp
    movl -16(%esp),%ecx
    movl %eax, -16(%esp)  # stack save
# emit-tail-expr
# si=-20
# env=((f6556 . -16) (f6550 . -12) (f6550 . -8) (#f . 16) ((begin (primitive-ref open-output-file) if (primitive-ref negative?) (begin (primitive-ref error) (primitive-ref open-output-file) output-port) #f) . 12) ((not (primitive-ref error)) . 8) (if . 4))
# expr=(begin (if ((primitive-ref negative?) f6556) (begin ((primitive-ref error) ((primitive-ref string->symbol) "open-output-file") "open failed")) #f) (let ((f6560 (make-vector 6)) (f6559 1024)) (begin (vector-set! f6560 0 ((primitive-ref string->symbol) "output-port")) (vector-set! f6560 1 f6550) (vector-set! f6560 2 f6556) (vector-set! f6560 3 (make-string f6559)) (vector-set! f6560 4 0) (vector-set! f6560 5 f6559) f6560)))
# tail-begin (begin (if ((primitive-ref negative?) f6556) (begin ((primitive-ref error) ((primitive-ref string->symbol) "open-output-file") "open failed")) #f) (let ((f6560 (make-vector 6)) (f6559 1024)) (begin (vector-set! f6560 0 ((primitive-ref string->symbol) "output-port")) (vector-set! f6560 1 f6550) (vector-set! f6560 2 f6556) (vector-set! f6560 3 (make-string f6559)) (vector-set! f6560 4 0) (vector-set! f6560 5 f6559) f6560)))
#   env=((f6556 . -16) (f6550 . -12) (f6550 . -8) (#f . 16) ((begin (primitive-ref open-output-file) if (primitive-ref negative?) (begin (primitive-ref error) (primitive-ref open-output-file) output-port) #f) . 12) ((not (primitive-ref error)) . 8) (if . 4))
# emit-expr (if ((primitive-ref negative?) f6556) (begin ((primitive-ref error) ((primitive-ref string->symbol) "open-output-file") "open failed")) #f)
# emit-expr ((primitive-ref negative?) f6556)
# funcall
#    si   =-20
#    env  = ((f6556 . -16) (f6550 . -12) (f6550 . -8) (#f . 16) ((begin (primitive-ref open-output-file) if (primitive-ref negative?) (begin (primitive-ref error) (primitive-ref open-output-file) output-port) #f) . 12) ((not (primitive-ref error)) . 8) (if . 4))
#    expr = (funcall (primitive-ref negative?) f6556)
# emit-expr (primitive-ref negative?)
    .extern mrc_negative$q
    movl mrc_negative$q,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_39953"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_39953":
   movl %eax,  -28(%esp)  # stash funcall-oper in closure slot
# emit-expr f6556
# emit-variable-ref
# env=((f6556 . -16) (f6550 . -12) (f6550 . -8) (#f . 16) ((begin (primitive-ref open-output-file) if (primitive-ref negative?) (begin (primitive-ref error) (primitive-ref open-output-file) output-port) #f) . 12) ((not (primitive-ref error)) . 8) (if . 4))
# var=f6556
    movl -16(%esp), %eax  # stack load f6556
# end emit-variable-ref
    mov %eax, -32(%esp)  # arg f6556
    movl -28(%esp), %edi   # load new closure to %edi
    add $-20, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $20, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    cmp $47, %al
    je _L_39951
# emit-expr (begin ((primitive-ref error) ((primitive-ref string->symbol) "open-output-file") "open failed"))
# emit-begin
#   expr=(begin ((primitive-ref error) ((primitive-ref string->symbol) "open-output-file") "open failed"))
#   env=((f6556 . -16) (f6550 . -12) (f6550 . -8) (#f . 16) ((begin (primitive-ref open-output-file) if (primitive-ref negative?) (begin (primitive-ref error) (primitive-ref open-output-file) output-port) #f) . 12) ((not (primitive-ref error)) . 8) (if . 4))
# emit-expr ((primitive-ref error) ((primitive-ref string->symbol) "open-output-file") "open failed")
# funcall
#    si   =-20
#    env  = ((f6556 . -16) (f6550 . -12) (f6550 . -8) (#f . 16) ((begin (primitive-ref open-output-file) if (primitive-ref negative?) (begin (primitive-ref error) (primitive-ref open-output-file) output-port) #f) . 12) ((not (primitive-ref error)) . 8) (if . 4))
#    expr = (funcall (primitive-ref error) ((primitive-ref string->symbol) "open-output-file") "open failed")
# emit-expr (primitive-ref error)
    .extern mrc_error
    movl mrc_error,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_39954"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_39954":
   movl %eax,  -28(%esp)  # stash funcall-oper in closure slot
# emit-expr ((primitive-ref string->symbol) "open-output-file")
# funcall
#    si   =-32
#    env  = ((f6556 . -16) (f6550 . -12) (f6550 . -8) (#f . 16) ((begin (primitive-ref open-output-file) if (primitive-ref negative?) (begin (primitive-ref error) (primitive-ref open-output-file) output-port) #f) . 12) ((not (primitive-ref error)) . 8) (if . 4))
#    expr = (funcall (primitive-ref string->symbol) "open-output-file")
# emit-expr (primitive-ref string->symbol)
    .extern mrc_string$m$gsymbol
    movl mrc_string$m$gsymbol,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_39955"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_39955":
   movl %eax,  -40(%esp)  # stash funcall-oper in closure slot
# emit-expr "open-output-file"
# string literal
    jmp _L_39957
    .align 8,0x90
_L_39956 :
    .int 64
    .ascii "open-output-file"
_L_39957:
    movl $_L_39956, %eax
    orl $6, %eax
    mov %eax, -44(%esp)  # arg open-output-file
    movl -40(%esp), %edi   # load new closure to %edi
    add $-32, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $32, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    mov %eax, -32(%esp)  # arg ((primitive-ref string->symbol) open-output-file)
# emit-expr "open failed"
# string literal
    jmp _L_39959
    .align 8,0x90
_L_39958 :
    .int 44
    .ascii "open failed"
_L_39959:
    movl $_L_39958, %eax
    orl $6, %eax
    mov %eax, -36(%esp)  # arg open failed
    movl -28(%esp), %edi   # load new closure to %edi
    add $-20, %esp   # adjust base
    movl $8,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $20, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
# emit-expr (begin)
# emit-begin
#   expr=(begin)
#   env=((f6556 . -16) (f6550 . -12) (f6550 . -8) (#f . 16) ((begin (primitive-ref open-output-file) if (primitive-ref negative?) (begin (primitive-ref error) (primitive-ref open-output-file) output-port) #f) . 12) ((not (primitive-ref error)) . 8) (if . 4))
    jmp _L_39952
_L_39951:
# emit-expr #f
    movl $47, %eax     # immed #f
_L_39952:
# emit-tail-expr
# si=-20
# env=((f6556 . -16) (f6550 . -12) (f6550 . -8) (#f . 16) ((begin (primitive-ref open-output-file) if (primitive-ref negative?) (begin (primitive-ref error) (primitive-ref open-output-file) output-port) #f) . 12) ((not (primitive-ref error)) . 8) (if . 4))
# expr=(begin (let ((f6560 (make-vector 6)) (f6559 1024)) (begin (vector-set! f6560 0 ((primitive-ref string->symbol) "output-port")) (vector-set! f6560 1 f6550) (vector-set! f6560 2 f6556) (vector-set! f6560 3 (make-string f6559)) (vector-set! f6560 4 0) (vector-set! f6560 5 f6559) f6560)))
# tail-begin (begin (let ((f6560 (make-vector 6)) (f6559 1024)) (begin (vector-set! f6560 0 ((primitive-ref string->symbol) "output-port")) (vector-set! f6560 1 f6550) (vector-set! f6560 2 f6556) (vector-set! f6560 3 (make-string f6559)) (vector-set! f6560 4 0) (vector-set! f6560 5 f6559) f6560)))
#   env=((f6556 . -16) (f6550 . -12) (f6550 . -8) (#f . 16) ((begin (primitive-ref open-output-file) if (primitive-ref negative?) (begin (primitive-ref error) (primitive-ref open-output-file) output-port) #f) . 12) ((not (primitive-ref error)) . 8) (if . 4))
# emit-tail-expr
# si=-20
# env=((f6556 . -16) (f6550 . -12) (f6550 . -8) (#f . 16) ((begin (primitive-ref open-output-file) if (primitive-ref negative?) (begin (primitive-ref error) (primitive-ref open-output-file) output-port) #f) . 12) ((not (primitive-ref error)) . 8) (if . 4))
# expr=(let ((f6560 (make-vector 6)) (f6559 1024)) (begin (vector-set! f6560 0 ((primitive-ref string->symbol) "output-port")) (vector-set! f6560 1 f6550) (vector-set! f6560 2 f6556) (vector-set! f6560 3 (make-string f6559)) (vector-set! f6560 4 0) (vector-set! f6560 5 f6559) f6560))
# emit-tail-let
#  si   = -20
#  env  = ((f6556 . -16) (f6550 . -12) (f6550 . -8) (#f . 16) ((begin (primitive-ref open-output-file) if (primitive-ref negative?) (begin (primitive-ref error) (primitive-ref open-output-file) output-port) #f) . 12) ((not (primitive-ref error)) . 8) (if . 4))
#  bindings = ((f6560 (make-vector 6)) (f6559 1024))
#  body = (begin (vector-set! f6560 0 ((primitive-ref string->symbol) "output-port")) (vector-set! f6560 1 f6550) (vector-set! f6560 2 f6556) (vector-set! f6560 3 (make-string f6559)) (vector-set! f6560 4 0) (vector-set! f6560 5 f6559) f6560)
# emit-expr (make-vector 6)
# make-vector 6
# emit-expr 6
    movl $24, %eax     # immed 6
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_39960"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_39960:
# check the argument is a fixnum >= 0
    cmp $0,%eax
    jge _L_39961
# invoke error handler eh_length
    .extern mrc_eh$ulength
    movl mrc_eh$ulength, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_39961:
    movl %eax, %esi
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    orl  $5, %eax
    addl $4, %esi
    addl $4, %esi
    andl $-8, %esi
    addl %esi, %ebp
    movl %eax, -20(%esp)  # stack save
# emit-expr 1024
    movl $4096, %eax     # immed 1024
    movl %eax, -24(%esp)  # stack save
# emit-tail-expr
# si=-28
# env=((f6559 . -24) (f6560 . -20) (f6556 . -16) (f6550 . -12) (f6550 . -8) (#f . 16) ((begin (primitive-ref open-output-file) if (primitive-ref negative?) (begin (primitive-ref error) (primitive-ref open-output-file) output-port) #f) . 12) ((not (primitive-ref error)) . 8) (if . 4))
# expr=(begin (vector-set! f6560 0 ((primitive-ref string->symbol) "output-port")) (vector-set! f6560 1 f6550) (vector-set! f6560 2 f6556) (vector-set! f6560 3 (make-string f6559)) (vector-set! f6560 4 0) (vector-set! f6560 5 f6559) f6560)
# tail-begin (begin (vector-set! f6560 0 ((primitive-ref string->symbol) "output-port")) (vector-set! f6560 1 f6550) (vector-set! f6560 2 f6556) (vector-set! f6560 3 (make-string f6559)) (vector-set! f6560 4 0) (vector-set! f6560 5 f6559) f6560)
#   env=((f6559 . -24) (f6560 . -20) (f6556 . -16) (f6550 . -12) (f6550 . -8) (#f . 16) ((begin (primitive-ref open-output-file) if (primitive-ref negative?) (begin (primitive-ref error) (primitive-ref open-output-file) output-port) #f) . 12) ((not (primitive-ref error)) . 8) (if . 4))
# emit-expr (vector-set! f6560 0 ((primitive-ref string->symbol) "output-port"))
# emit-expr f6560
# emit-variable-ref
# env=((f6559 . -24) (f6560 . -20) (f6556 . -16) (f6550 . -12) (f6550 . -8) (#f . 16) ((begin (primitive-ref open-output-file) if (primitive-ref negative?) (begin (primitive-ref error) (primitive-ref open-output-file) output-port) #f) . 12) ((not (primitive-ref error)) . 8) (if . 4))
# var=f6560
    movl -20(%esp), %eax  # stack load f6560
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_39962
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_39962:
    movl %eax, -28(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_39963"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_39963:
# check bounds on vector index
    movl -28(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_39965
    cmp  $0,%eax
    jge _L_39964
_L_39965:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_39964:
    movl %eax, -32(%esp)
# emit-expr ((primitive-ref string->symbol) "output-port")
# funcall
#    si   =-36
#    env  = ((f6559 . -24) (f6560 . -20) (f6556 . -16) (f6550 . -12) (f6550 . -8) (#f . 16) ((begin (primitive-ref open-output-file) if (primitive-ref negative?) (begin (primitive-ref error) (primitive-ref open-output-file) output-port) #f) . 12) ((not (primitive-ref error)) . 8) (if . 4))
#    expr = (funcall (primitive-ref string->symbol) "output-port")
# emit-expr (primitive-ref string->symbol)
    .extern mrc_string$m$gsymbol
    movl mrc_string$m$gsymbol,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_39966"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_39966":
   movl %eax,  -44(%esp)  # stash funcall-oper in closure slot
# emit-expr "output-port"
# string literal
    jmp _L_39968
    .align 8,0x90
_L_39967 :
    .int 44
    .ascii "output-port"
_L_39968:
    movl $_L_39967, %eax
    orl $6, %eax
    mov %eax, -48(%esp)  # arg output-port
    movl -44(%esp), %edi   # load new closure to %edi
    add $-36, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $36, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    movl -28(%esp), %ebx
    movl -32(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-tail-expr
# si=-28
# env=((f6559 . -24) (f6560 . -20) (f6556 . -16) (f6550 . -12) (f6550 . -8) (#f . 16) ((begin (primitive-ref open-output-file) if (primitive-ref negative?) (begin (primitive-ref error) (primitive-ref open-output-file) output-port) #f) . 12) ((not (primitive-ref error)) . 8) (if . 4))
# expr=(begin (vector-set! f6560 1 f6550) (vector-set! f6560 2 f6556) (vector-set! f6560 3 (make-string f6559)) (vector-set! f6560 4 0) (vector-set! f6560 5 f6559) f6560)
# tail-begin (begin (vector-set! f6560 1 f6550) (vector-set! f6560 2 f6556) (vector-set! f6560 3 (make-string f6559)) (vector-set! f6560 4 0) (vector-set! f6560 5 f6559) f6560)
#   env=((f6559 . -24) (f6560 . -20) (f6556 . -16) (f6550 . -12) (f6550 . -8) (#f . 16) ((begin (primitive-ref open-output-file) if (primitive-ref negative?) (begin (primitive-ref error) (primitive-ref open-output-file) output-port) #f) . 12) ((not (primitive-ref error)) . 8) (if . 4))
# emit-expr (vector-set! f6560 1 f6550)
# emit-expr f6560
# emit-variable-ref
# env=((f6559 . -24) (f6560 . -20) (f6556 . -16) (f6550 . -12) (f6550 . -8) (#f . 16) ((begin (primitive-ref open-output-file) if (primitive-ref negative?) (begin (primitive-ref error) (primitive-ref open-output-file) output-port) #f) . 12) ((not (primitive-ref error)) . 8) (if . 4))
# var=f6560
    movl -20(%esp), %eax  # stack load f6560
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_39969
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_39969:
    movl %eax, -28(%esp)
# emit-expr 1
    movl $4, %eax     # immed 1
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_39970"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_39970:
# check bounds on vector index
    movl -28(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_39972
    cmp  $0,%eax
    jge _L_39971
_L_39972:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_39971:
    movl %eax, -32(%esp)
# emit-expr f6550
# emit-variable-ref
# env=((f6559 . -24) (f6560 . -20) (f6556 . -16) (f6550 . -12) (f6550 . -8) (#f . 16) ((begin (primitive-ref open-output-file) if (primitive-ref negative?) (begin (primitive-ref error) (primitive-ref open-output-file) output-port) #f) . 12) ((not (primitive-ref error)) . 8) (if . 4))
# var=f6550
    movl -12(%esp), %eax  # stack load f6550
# end emit-variable-ref
    movl -28(%esp), %ebx
    movl -32(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-tail-expr
# si=-28
# env=((f6559 . -24) (f6560 . -20) (f6556 . -16) (f6550 . -12) (f6550 . -8) (#f . 16) ((begin (primitive-ref open-output-file) if (primitive-ref negative?) (begin (primitive-ref error) (primitive-ref open-output-file) output-port) #f) . 12) ((not (primitive-ref error)) . 8) (if . 4))
# expr=(begin (vector-set! f6560 2 f6556) (vector-set! f6560 3 (make-string f6559)) (vector-set! f6560 4 0) (vector-set! f6560 5 f6559) f6560)
# tail-begin (begin (vector-set! f6560 2 f6556) (vector-set! f6560 3 (make-string f6559)) (vector-set! f6560 4 0) (vector-set! f6560 5 f6559) f6560)
#   env=((f6559 . -24) (f6560 . -20) (f6556 . -16) (f6550 . -12) (f6550 . -8) (#f . 16) ((begin (primitive-ref open-output-file) if (primitive-ref negative?) (begin (primitive-ref error) (primitive-ref open-output-file) output-port) #f) . 12) ((not (primitive-ref error)) . 8) (if . 4))
# emit-expr (vector-set! f6560 2 f6556)
# emit-expr f6560
# emit-variable-ref
# env=((f6559 . -24) (f6560 . -20) (f6556 . -16) (f6550 . -12) (f6550 . -8) (#f . 16) ((begin (primitive-ref open-output-file) if (primitive-ref negative?) (begin (primitive-ref error) (primitive-ref open-output-file) output-port) #f) . 12) ((not (primitive-ref error)) . 8) (if . 4))
# var=f6560
    movl -20(%esp), %eax  # stack load f6560
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_39973
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_39973:
    movl %eax, -28(%esp)
# emit-expr 2
    movl $8, %eax     # immed 2
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_39974"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_39974:
# check bounds on vector index
    movl -28(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_39976
    cmp  $0,%eax
    jge _L_39975
_L_39976:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_39975:
    movl %eax, -32(%esp)
# emit-expr f6556
# emit-variable-ref
# env=((f6559 . -24) (f6560 . -20) (f6556 . -16) (f6550 . -12) (f6550 . -8) (#f . 16) ((begin (primitive-ref open-output-file) if (primitive-ref negative?) (begin (primitive-ref error) (primitive-ref open-output-file) output-port) #f) . 12) ((not (primitive-ref error)) . 8) (if . 4))
# var=f6556
    movl -16(%esp), %eax  # stack load f6556
# end emit-variable-ref
    movl -28(%esp), %ebx
    movl -32(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-tail-expr
# si=-28
# env=((f6559 . -24) (f6560 . -20) (f6556 . -16) (f6550 . -12) (f6550 . -8) (#f . 16) ((begin (primitive-ref open-output-file) if (primitive-ref negative?) (begin (primitive-ref error) (primitive-ref open-output-file) output-port) #f) . 12) ((not (primitive-ref error)) . 8) (if . 4))
# expr=(begin (vector-set! f6560 3 (make-string f6559)) (vector-set! f6560 4 0) (vector-set! f6560 5 f6559) f6560)
# tail-begin (begin (vector-set! f6560 3 (make-string f6559)) (vector-set! f6560 4 0) (vector-set! f6560 5 f6559) f6560)
#   env=((f6559 . -24) (f6560 . -20) (f6556 . -16) (f6550 . -12) (f6550 . -8) (#f . 16) ((begin (primitive-ref open-output-file) if (primitive-ref negative?) (begin (primitive-ref error) (primitive-ref open-output-file) output-port) #f) . 12) ((not (primitive-ref error)) . 8) (if . 4))
# emit-expr (vector-set! f6560 3 (make-string f6559))
# emit-expr f6560
# emit-variable-ref
# env=((f6559 . -24) (f6560 . -20) (f6556 . -16) (f6550 . -12) (f6550 . -8) (#f . 16) ((begin (primitive-ref open-output-file) if (primitive-ref negative?) (begin (primitive-ref error) (primitive-ref open-output-file) output-port) #f) . 12) ((not (primitive-ref error)) . 8) (if . 4))
# var=f6560
    movl -20(%esp), %eax  # stack load f6560
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_39977
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_39977:
    movl %eax, -28(%esp)
# emit-expr 3
    movl $12, %eax     # immed 3
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_39978"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_39978:
# check bounds on vector index
    movl -28(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_39980
    cmp  $0,%eax
    jge _L_39979
_L_39980:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_39979:
    movl %eax, -32(%esp)
# emit-expr (make-string f6559)
# make-string len=f6559
# emit-expr f6559
# emit-variable-ref
# env=((f6559 . -24) (f6560 . -20) (f6556 . -16) (f6550 . -12) (f6550 . -8) (#f . 16) ((begin (primitive-ref open-output-file) if (primitive-ref negative?) (begin (primitive-ref error) (primitive-ref open-output-file) output-port) #f) . 12) ((not (primitive-ref error)) . 8) (if . 4))
# var=f6559
    movl -24(%esp), %eax  # stack load f6559
# end emit-variable-ref
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_39981"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $152,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_39981:
# check the argument is a fixnum >= 0
    cmp $0,%eax
    jge _L_39982
# invoke error handler eh_length
    .extern mrc_eh$ulength
    movl mrc_eh$ulength, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $152,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_39982:
    movl %eax, %esi
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    orl $6, %eax
    sar $2, %esi
    add $4, %esi
    add $7, %esi
    andl $-8, %esi
    add  %esi, %ebp
# make-string end
    movl -28(%esp), %ebx
    movl -32(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-tail-expr
# si=-28
# env=((f6559 . -24) (f6560 . -20) (f6556 . -16) (f6550 . -12) (f6550 . -8) (#f . 16) ((begin (primitive-ref open-output-file) if (primitive-ref negative?) (begin (primitive-ref error) (primitive-ref open-output-file) output-port) #f) . 12) ((not (primitive-ref error)) . 8) (if . 4))
# expr=(begin (vector-set! f6560 4 0) (vector-set! f6560 5 f6559) f6560)
# tail-begin (begin (vector-set! f6560 4 0) (vector-set! f6560 5 f6559) f6560)
#   env=((f6559 . -24) (f6560 . -20) (f6556 . -16) (f6550 . -12) (f6550 . -8) (#f . 16) ((begin (primitive-ref open-output-file) if (primitive-ref negative?) (begin (primitive-ref error) (primitive-ref open-output-file) output-port) #f) . 12) ((not (primitive-ref error)) . 8) (if . 4))
# emit-expr (vector-set! f6560 4 0)
# emit-expr f6560
# emit-variable-ref
# env=((f6559 . -24) (f6560 . -20) (f6556 . -16) (f6550 . -12) (f6550 . -8) (#f . 16) ((begin (primitive-ref open-output-file) if (primitive-ref negative?) (begin (primitive-ref error) (primitive-ref open-output-file) output-port) #f) . 12) ((not (primitive-ref error)) . 8) (if . 4))
# var=f6560
    movl -20(%esp), %eax  # stack load f6560
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_39983
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_39983:
    movl %eax, -28(%esp)
# emit-expr 4
    movl $16, %eax     # immed 4
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_39984"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_39984:
# check bounds on vector index
    movl -28(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_39986
    cmp  $0,%eax
    jge _L_39985
_L_39986:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_39985:
    movl %eax, -32(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
    movl -28(%esp), %ebx
    movl -32(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-tail-expr
# si=-28
# env=((f6559 . -24) (f6560 . -20) (f6556 . -16) (f6550 . -12) (f6550 . -8) (#f . 16) ((begin (primitive-ref open-output-file) if (primitive-ref negative?) (begin (primitive-ref error) (primitive-ref open-output-file) output-port) #f) . 12) ((not (primitive-ref error)) . 8) (if . 4))
# expr=(begin (vector-set! f6560 5 f6559) f6560)
# tail-begin (begin (vector-set! f6560 5 f6559) f6560)
#   env=((f6559 . -24) (f6560 . -20) (f6556 . -16) (f6550 . -12) (f6550 . -8) (#f . 16) ((begin (primitive-ref open-output-file) if (primitive-ref negative?) (begin (primitive-ref error) (primitive-ref open-output-file) output-port) #f) . 12) ((not (primitive-ref error)) . 8) (if . 4))
# emit-expr (vector-set! f6560 5 f6559)
# emit-expr f6560
# emit-variable-ref
# env=((f6559 . -24) (f6560 . -20) (f6556 . -16) (f6550 . -12) (f6550 . -8) (#f . 16) ((begin (primitive-ref open-output-file) if (primitive-ref negative?) (begin (primitive-ref error) (primitive-ref open-output-file) output-port) #f) . 12) ((not (primitive-ref error)) . 8) (if . 4))
# var=f6560
    movl -20(%esp), %eax  # stack load f6560
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_39987
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_39987:
    movl %eax, -28(%esp)
# emit-expr 5
    movl $20, %eax     # immed 5
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_39988"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_39988:
# check bounds on vector index
    movl -28(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_39990
    cmp  $0,%eax
    jge _L_39989
_L_39990:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_39989:
    movl %eax, -32(%esp)
# emit-expr f6559
# emit-variable-ref
# env=((f6559 . -24) (f6560 . -20) (f6556 . -16) (f6550 . -12) (f6550 . -8) (#f . 16) ((begin (primitive-ref open-output-file) if (primitive-ref negative?) (begin (primitive-ref error) (primitive-ref open-output-file) output-port) #f) . 12) ((not (primitive-ref error)) . 8) (if . 4))
# var=f6559
    movl -24(%esp), %eax  # stack load f6559
# end emit-variable-ref
    movl -28(%esp), %ebx
    movl -32(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-tail-expr
# si=-28
# env=((f6559 . -24) (f6560 . -20) (f6556 . -16) (f6550 . -12) (f6550 . -8) (#f . 16) ((begin (primitive-ref open-output-file) if (primitive-ref negative?) (begin (primitive-ref error) (primitive-ref open-output-file) output-port) #f) . 12) ((not (primitive-ref error)) . 8) (if . 4))
# expr=(begin f6560)
# tail-begin (begin f6560)
#   env=((f6559 . -24) (f6560 . -20) (f6556 . -16) (f6550 . -12) (f6550 . -8) (#f . 16) ((begin (primitive-ref open-output-file) if (primitive-ref negative?) (begin (primitive-ref error) (primitive-ref open-output-file) output-port) #f) . 12) ((not (primitive-ref error)) . 8) (if . 4))
# emit-tail-expr
# si=-28
# env=((f6559 . -24) (f6560 . -20) (f6556 . -16) (f6550 . -12) (f6550 . -8) (#f . 16) ((begin (primitive-ref open-output-file) if (primitive-ref negative?) (begin (primitive-ref error) (primitive-ref open-output-file) output-port) #f) . 12) ((not (primitive-ref error)) . 8) (if . 4))
# expr=f6560
# emit-tail-variable-ref
# emit-variable-ref
# env=((f6559 . -24) (f6560 . -20) (f6556 . -16) (f6550 . -12) (f6550 . -8) (#f . 16) ((begin (primitive-ref open-output-file) if (primitive-ref negative?) (begin (primitive-ref error) (primitive-ref open-output-file) output-port) #f) . 12) ((not (primitive-ref error)) . 8) (if . 4))
# var=f6560
    movl -20(%esp), %eax  # stack load f6560
# end emit-variable-ref
    ret
# end emit-tail-variable ref
     ret   # return thru stack
     ret   # return thru stack
     ret   # return thru stack
    .align 4,0x90
_L_39941:
     movl %eax, mrc_open$moutput$mfile
# == explicit-begins  ==>
# (lambda (p) (begin (flush-output-port p) (foreign-call "s_close" (port-fd p))))
# == eliminate-let*  ==>
# (lambda (p) (begin (flush-output-port p) (foreign-call "s_close" (port-fd p))))
# == uniquify-variables  ==>
# (lambda (f6561) (begin (flush-output-port f6561) (foreign-call "s_close" (port-fd f6561))))
# == vectorize-letrec  ==>
# (lambda (f6561) (begin (flush-output-port f6561) (foreign-call "s_close" (port-fd f6561))))
# == eliminate-set!  ==>
# (lambda (f6561) (let ((f6561 f6561)) (begin (flush-output-port f6561) (foreign-call "s_close" (port-fd f6561)))))
# == close-free-variables  ==>
# (closure (f6561) (flush-output-port port-fd) (let ((f6561 f6561)) (begin (flush-output-port f6561) (foreign-call "s_close" (port-fd f6561)))))
# == eliminate-quote  ==>
# (closure (f6561) (flush-output-port port-fd) (let ((f6561 f6561)) (begin (flush-output-port f6561) (foreign-call "s_close" (port-fd f6561)))))
# == eliminate-when/unless  ==>
# (closure (f6561) (flush-output-port port-fd) (let ((f6561 f6561)) (begin (flush-output-port f6561) (foreign-call "s_close" (port-fd f6561)))))
# == eliminate-cond  ==>
# (closure (f6561) (flush-output-port port-fd) (let ((f6561 f6561)) (begin (flush-output-port f6561) (foreign-call "s_close" (port-fd f6561)))))
# == external-symbols  ==>
# (closure (f6561) ((primitive-ref flush-output-port) (primitive-ref port-fd)) (let ((f6561 f6561)) (begin ((primitive-ref flush-output-port) f6561) (foreign-call "s_close" ((primitive-ref port-fd) f6561)))))
# emit-expr (closure (f6561) ((primitive-ref flush-output-port) (primitive-ref port-fd)) (let ((f6561 f6561)) (begin ((primitive-ref flush-output-port) f6561) (foreign-call "s_close" ((primitive-ref port-fd) f6561)))))
# emit-closure
# si = 0
# env = ()
# expr = (closure (f6561) ((primitive-ref flush-output-port) (primitive-ref port-fd)) (let ((f6561 f6561)) (begin ((primitive-ref flush-output-port) f6561) (foreign-call "s_close" ((primitive-ref port-fd) f6561)))))
    movl $_L_39991, 0(%ebp)  # closure label
# WARNING: free var (primitive-ref flush-output-port) not defined in the environmnet
# WARNING: free var (primitive-ref port-fd) not defined in the environmnet
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $16, %ebp     # bump ebp
    jmp _L_39992            # jump around closure body
_L_39991:
# check argument count
    cmp $4,%eax
    je _L_39993
# invoke error handler eh_argcount
    .extern mrc_eh$uargcount
    movl mrc_eh$uargcount, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_39993:
# emit-tail-expr
# si=-12
# env=((f6561 . -8) ((primitive-ref port-fd) . 8) ((primitive-ref flush-output-port) . 4))
# expr=(let ((f6561 f6561)) (begin ((primitive-ref flush-output-port) f6561) (foreign-call "s_close" ((primitive-ref port-fd) f6561))))
# emit-tail-let
#  si   = -12
#  env  = ((f6561 . -8) ((primitive-ref port-fd) . 8) ((primitive-ref flush-output-port) . 4))
#  bindings = ((f6561 f6561))
#  body = (begin ((primitive-ref flush-output-port) f6561) (foreign-call "s_close" ((primitive-ref port-fd) f6561)))
# emit-expr f6561
# emit-variable-ref
# env=((f6561 . -8) ((primitive-ref port-fd) . 8) ((primitive-ref flush-output-port) . 4))
# var=f6561
    movl -8(%esp), %eax  # stack load f6561
# end emit-variable-ref
    movl %eax, -12(%esp)  # stack save
# emit-tail-expr
# si=-16
# env=((f6561 . -12) (f6561 . -8) ((primitive-ref port-fd) . 8) ((primitive-ref flush-output-port) . 4))
# expr=(begin ((primitive-ref flush-output-port) f6561) (foreign-call "s_close" ((primitive-ref port-fd) f6561)))
# tail-begin (begin ((primitive-ref flush-output-port) f6561) (foreign-call "s_close" ((primitive-ref port-fd) f6561)))
#   env=((f6561 . -12) (f6561 . -8) ((primitive-ref port-fd) . 8) ((primitive-ref flush-output-port) . 4))
# emit-expr ((primitive-ref flush-output-port) f6561)
# funcall
#    si   =-16
#    env  = ((f6561 . -12) (f6561 . -8) ((primitive-ref port-fd) . 8) ((primitive-ref flush-output-port) . 4))
#    expr = (funcall (primitive-ref flush-output-port) f6561)
# emit-expr (primitive-ref flush-output-port)
    .extern mrc_flush$moutput$mport
    movl mrc_flush$moutput$mport,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_39994"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_39994":
   movl %eax,  -24(%esp)  # stash funcall-oper in closure slot
# emit-expr f6561
# emit-variable-ref
# env=((f6561 . -12) (f6561 . -8) ((primitive-ref port-fd) . 8) ((primitive-ref flush-output-port) . 4))
# var=f6561
    movl -12(%esp), %eax  # stack load f6561
# end emit-variable-ref
    mov %eax, -28(%esp)  # arg f6561
    movl -24(%esp), %edi   # load new closure to %edi
    add $-16, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $16, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
# emit-tail-expr
# si=-16
# env=((f6561 . -12) (f6561 . -8) ((primitive-ref port-fd) . 8) ((primitive-ref flush-output-port) . 4))
# expr=(begin (foreign-call "s_close" ((primitive-ref port-fd) f6561)))
# tail-begin (begin (foreign-call "s_close" ((primitive-ref port-fd) f6561)))
#   env=((f6561 . -12) (f6561 . -8) ((primitive-ref port-fd) . 8) ((primitive-ref flush-output-port) . 4))
# emit-tail-expr
# si=-16
# env=((f6561 . -12) (f6561 . -8) ((primitive-ref port-fd) . 8) ((primitive-ref flush-output-port) . 4))
# expr=(foreign-call "s_close" ((primitive-ref port-fd) f6561))
    movl %ecx,-16(%esp)
    movl %esp,-20(%esp)
# emit-expr ((primitive-ref port-fd) f6561)
# funcall
#    si   =-24
#    env  = ((f6561 . -12) (f6561 . -8) ((primitive-ref port-fd) . 8) ((primitive-ref flush-output-port) . 4))
#    expr = (funcall (primitive-ref port-fd) f6561)
# emit-expr (primitive-ref port-fd)
    .extern mrc_port$mfd
    movl mrc_port$mfd,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_39995"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_39995":
   movl %eax,  -32(%esp)  # stash funcall-oper in closure slot
# emit-expr f6561
# emit-variable-ref
# env=((f6561 . -12) (f6561 . -8) ((primitive-ref port-fd) . 8) ((primitive-ref flush-output-port) . 4))
# var=f6561
    movl -12(%esp), %eax  # stack load f6561
# end emit-variable-ref
    mov %eax, -36(%esp)  # arg f6561
    movl -32(%esp), %edi   # load new closure to %edi
    add $-24, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $24, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    movl %eax, -24(%esp)
    leal -24(%esp),%edi
    movl %edi,%esi
    andl $-16,%esi
    movl 0(%edi),%eax
    movl %eax,0(%esi)
    movl 4(%edi),%eax
    movl %eax,4(%esi)
    movl %esi,%esp
    .extern _s_close
    call _s_close
    movl 4(%esi),%esp
    movl -16(%esp),%ecx
     ret
     ret   # return thru stack
    .align 4,0x90
_L_39992:
     movl %eax, mrc_close$moutput$mport
# == explicit-begins  ==>
# (letrec ((print-boolean (lambda (expr p) (begin (write-char #\# p) (if expr (write-char #\t p) (write-char #\f p))))) (print-null (lambda (p) (begin (write-char #\( p) (write-char #\) p)))) (print-char (lambda (expr p) (begin (write-char #\# p) (write-char #\\ p) (write-char expr p)))) (print-fixnum (lambda (i p) (if (negative? i) (begin (write-char #\- p) (print-fixnum (fx* -1 i) p)) (map (lambda (x) (write-char (fixnum->char (fx+ (char->fixnum #\0) x)) p)) (integer->list i))))) (print-string (lambda (s p) (begin (write-char #\" p) (for-each (lambda (c) (write-char c p)) (string->list s)) (write-char #\" p)))) (print-string-alpha (lambda (s p) (for-each (lambda (c) (write-char c p)) (string->list s)))) (print-pair (lambda (pr p) (begin (write-char #\( p) (print-pairs pr p) (write-char #\) p)))) (print-pairs (lambda (pr p) (begin (write (car pr) p) (cond ((null? (cdr pr)) #t) ((pair? (cdr pr)) (begin (write-char #\space p) (print-pairs (cdr pr) p))) (else (begin (write-char #\space p) (write-char #\. p) (write-char #\space p) (write (cdr pr) p)))))))) (lambda (expr p alpha) (cond ((boolean? expr) (print-boolean expr p)) ((null? expr) (print-null p)) ((char? expr) (if alpha (write-char expr p) (print-char expr p))) ((fixnum? expr) (print-fixnum expr p)) ((string? expr) (if alpha (print-string-alpha expr p) (print-string expr p))) ((pair? expr) (print-pair expr p)) (else (error (quote write) "unrecognized expression")))))
# == eliminate-let*  ==>
# (letrec ((print-boolean (lambda (expr p) (begin (write-char #\# p) (if expr (write-char #\t p) (write-char #\f p))))) (print-null (lambda (p) (begin (write-char #\( p) (write-char #\) p)))) (print-char (lambda (expr p) (begin (write-char #\# p) (write-char #\\ p) (write-char expr p)))) (print-fixnum (lambda (i p) (if (negative? i) (begin (write-char #\- p) (print-fixnum (fx* -1 i) p)) (map (lambda (x) (write-char (fixnum->char (fx+ (char->fixnum #\0) x)) p)) (integer->list i))))) (print-string (lambda (s p) (begin (write-char #\" p) (for-each (lambda (c) (write-char c p)) (string->list s)) (write-char #\" p)))) (print-string-alpha (lambda (s p) (for-each (lambda (c) (write-char c p)) (string->list s)))) (print-pair (lambda (pr p) (begin (write-char #\( p) (print-pairs pr p) (write-char #\) p)))) (print-pairs (lambda (pr p) (begin (write (car pr) p) (cond ((null? (cdr pr)) #t) ((pair? (cdr pr)) (begin (write-char #\space p) (print-pairs (cdr pr) p))) (else (begin (write-char #\space p) (write-char #\. p) (write-char #\space p) (write (cdr pr) p)))))))) (lambda (expr p alpha) (cond ((boolean? expr) (print-boolean expr p)) ((null? expr) (print-null p)) ((char? expr) (if alpha (write-char expr p) (print-char expr p))) ((fixnum? expr) (print-fixnum expr p)) ((string? expr) (if alpha (print-string-alpha expr p) (print-string expr p))) ((pair? expr) (print-pair expr p)) (else (error (quote write) "unrecognized expression")))))
# == uniquify-variables  ==>
# (letrec ((f6569 (lambda (f6610 f6611) (begin (write-char #\# f6611) (if f6610 (write-char #\t f6611) (write-char #\f f6611))))) (f6568 (lambda (f6609) (begin (write-char #\( f6609) (write-char #\) f6609)))) (f6567 (lambda (f6607 f6608) (begin (write-char #\# f6608) (write-char #\\ f6608) (write-char f6607 f6608)))) (f6566 (lambda (f6603 f6604) (if (negative? f6603) (begin (write-char #\- f6604) (f6566 (fx* -1 f6603) f6604)) (map (lambda (f6606) (write-char (fixnum->char (fx+ (char->fixnum #\0) f6606)) f6604)) (integer->list f6603))))) (f6565 (lambda (f6599 f6600) (begin (write-char #\" f6600) (for-each (lambda (f6602) (write-char f6602 f6600)) (string->list f6599)) (write-char #\" f6600)))) (f6564 (lambda (f6595 f6596) (for-each (lambda (f6598) (write-char f6598 f6596)) (string->list f6595)))) (f6563 (lambda (f6593 f6594) (begin (write-char #\( f6594) (f6562 f6593 f6594) (write-char #\) f6594)))) (f6562 (lambda (f6591 f6592) (begin (write (car f6591) f6592) (cond ((null? (cdr f6591)) #t) ((pair? (cdr f6591)) (begin (write-char #\space f6592) (f6562 (cdr f6591) f6592))) (else (begin (write-char #\space f6592) (write-char #\. f6592) (write-char #\space f6592) (write (cdr f6591) f6592)))))))) (lambda (f6615 f6616 f6617) (cond ((boolean? f6615) (f6569 f6615 f6616)) ((null? f6615) (f6568 f6616)) ((char? f6615) (if f6617 (write-char f6615 f6616) (f6567 f6615 f6616))) ((fixnum? f6615) (f6566 f6615 f6616)) ((string? f6615) (if f6617 (f6564 f6615 f6616) (f6565 f6615 f6616))) ((pair? f6615) (f6563 f6615 f6616)) (else (error (quote write) "unrecognized expression")))))
# == vectorize-letrec  ==>
# (let ((f6569 (make-vector 1)) (f6568 (make-vector 1)) (f6567 (make-vector 1)) (f6566 (make-vector 1)) (f6565 (make-vector 1)) (f6564 (make-vector 1)) (f6563 (make-vector 1)) (f6562 (make-vector 1))) (begin (begin (vector-set! f6569 0 (lambda (f6610 f6611) (begin (write-char #\# f6611) (if f6610 (write-char #\t f6611) (write-char #\f f6611))))) (vector-set! f6568 0 (lambda (f6609) (begin (write-char #\( f6609) (write-char #\) f6609)))) (vector-set! f6567 0 (lambda (f6607 f6608) (begin (write-char #\# f6608) (write-char #\\ f6608) (write-char f6607 f6608)))) (vector-set! f6566 0 (lambda (f6603 f6604) (if (negative? f6603) (begin (write-char #\- f6604) ((vector-ref f6566 0) (fx* -1 f6603) f6604)) (map (lambda (f6606) (write-char (fixnum->char (fx+ (char->fixnum #\0) f6606)) f6604)) (integer->list f6603))))) (vector-set! f6565 0 (lambda (f6599 f6600) (begin (write-char #\" f6600) (for-each (lambda (f6602) (write-char f6602 f6600)) (string->list f6599)) (write-char #\" f6600)))) (vector-set! f6564 0 (lambda (f6595 f6596) (for-each (lambda (f6598) (write-char f6598 f6596)) (string->list f6595)))) (vector-set! f6563 0 (lambda (f6593 f6594) (begin (write-char #\( f6594) ((vector-ref f6562 0) f6593 f6594) (write-char #\) f6594)))) (vector-set! f6562 0 (lambda (f6591 f6592) (begin (write (car f6591) f6592) (cond ((null? (cdr f6591)) #t) ((pair? (cdr f6591)) (begin (write-char #\space f6592) ((vector-ref f6562 0) (cdr f6591) f6592))) (else (begin (write-char #\space f6592) (write-char #\. f6592) (write-char #\space f6592) (write (cdr f6591) f6592)))))))) (lambda (f6615 f6616 f6617) (cond ((boolean? f6615) ((vector-ref f6569 0) f6615 f6616)) ((null? f6615) ((vector-ref f6568 0) f6616)) ((char? f6615) (if f6617 (write-char f6615 f6616) ((vector-ref f6567 0) f6615 f6616))) ((fixnum? f6615) ((vector-ref f6566 0) f6615 f6616)) ((string? f6615) (if f6617 ((vector-ref f6564 0) f6615 f6616) ((vector-ref f6565 0) f6615 f6616))) ((pair? f6615) ((vector-ref f6563 0) f6615 f6616)) (else (error (quote write) "unrecognized expression"))))))
# == eliminate-set!  ==>
# (let ((f6569 (make-vector 1)) (f6568 (make-vector 1)) (f6567 (make-vector 1)) (f6566 (make-vector 1)) (f6565 (make-vector 1)) (f6564 (make-vector 1)) (f6563 (make-vector 1)) (f6562 (make-vector 1))) (begin (begin (vector-set! f6569 0 (lambda (f6610 f6611) (let ((f6610 f6610) (f6611 f6611)) (begin (write-char #\# f6611) (if f6610 (write-char #\t f6611) (write-char #\f f6611)))))) (vector-set! f6568 0 (lambda (f6609) (let ((f6609 f6609)) (begin (write-char #\( f6609) (write-char #\) f6609))))) (vector-set! f6567 0 (lambda (f6607 f6608) (let ((f6607 f6607) (f6608 f6608)) (begin (write-char #\# f6608) (write-char #\\ f6608) (write-char f6607 f6608))))) (vector-set! f6566 0 (lambda (f6603 f6604) (let ((f6603 f6603) (f6604 f6604)) (if (negative? f6603) (begin (write-char #\- f6604) ((vector-ref f6566 0) (fx* -1 f6603) f6604)) (map (lambda (f6606) (let ((f6606 f6606)) (write-char (fixnum->char (fx+ (char->fixnum #\0) f6606)) f6604))) (integer->list f6603)))))) (vector-set! f6565 0 (lambda (f6599 f6600) (let ((f6599 f6599) (f6600 f6600)) (begin (write-char #\" f6600) (for-each (lambda (f6602) (let ((f6602 f6602)) (write-char f6602 f6600))) (string->list f6599)) (write-char #\" f6600))))) (vector-set! f6564 0 (lambda (f6595 f6596) (let ((f6595 f6595) (f6596 f6596)) (for-each (lambda (f6598) (let ((f6598 f6598)) (write-char f6598 f6596))) (string->list f6595))))) (vector-set! f6563 0 (lambda (f6593 f6594) (let ((f6593 f6593) (f6594 f6594)) (begin (write-char #\( f6594) ((vector-ref f6562 0) f6593 f6594) (write-char #\) f6594))))) (vector-set! f6562 0 (lambda (f6591 f6592) (let ((f6591 f6591) (f6592 f6592)) (begin (write (car f6591) f6592) (cond ((null? (cdr f6591)) #t) ((pair? (cdr f6591)) (begin (write-char #\space f6592) ((vector-ref f6562 0) (cdr f6591) f6592))) (else (begin (write-char #\space f6592) (write-char #\. f6592) (write-char #\space f6592) (write (cdr f6591) f6592))))))))) (lambda (f6615 f6616 f6617) (let ((f6615 f6615) (f6616 f6616) (f6617 f6617)) (cond ((boolean? f6615) ((vector-ref f6569 0) f6615 f6616)) ((null? f6615) ((vector-ref f6568 0) f6616)) ((char? f6615) (if f6617 (write-char f6615 f6616) ((vector-ref f6567 0) f6615 f6616))) ((fixnum? f6615) ((vector-ref f6566 0) f6615 f6616)) ((string? f6615) (if f6617 ((vector-ref f6564 0) f6615 f6616) ((vector-ref f6565 0) f6615 f6616))) ((pair? f6615) ((vector-ref f6563 0) f6615 f6616)) (else (error (quote write) "unrecognized expression")))))))
# == close-free-variables  ==>
# (let ((f6569 (make-vector 1)) (f6568 (make-vector 1)) (f6567 (make-vector 1)) (f6566 (make-vector 1)) (f6565 (make-vector 1)) (f6564 (make-vector 1)) (f6563 (make-vector 1)) (f6562 (make-vector 1))) (begin (begin (vector-set! f6569 0 (closure (f6610 f6611) (write-char write-char write-char) (let ((f6610 f6610) (f6611 f6611)) (begin (write-char #\# f6611) (if f6610 (write-char #\t f6611) (write-char #\f f6611)))))) (vector-set! f6568 0 (closure (f6609) (write-char write-char) (let ((f6609 f6609)) (begin (write-char #\( f6609) (write-char #\) f6609))))) (vector-set! f6567 0 (closure (f6607 f6608) (write-char write-char write-char) (let ((f6607 f6607) (f6608 f6608)) (begin (write-char #\# f6608) (write-char #\\ f6608) (write-char f6607 f6608))))) (vector-set! f6566 0 (closure (f6603 f6604) (negative? write-char f6566 map write-char integer->list) (let ((f6603 f6603) (f6604 f6604)) (if (negative? f6603) (begin (write-char #\- f6604) ((vector-ref f6566 0) (fx* -1 f6603) f6604)) (map (closure (f6606) (write-char f6604) (let ((f6606 f6606)) (write-char (fixnum->char (fx+ (char->fixnum #\0) f6606)) f6604))) (integer->list f6603)))))) (vector-set! f6565 0 (closure (f6599 f6600) (write-char for-each write-char string->list write-char) (let ((f6599 f6599) (f6600 f6600)) (begin (write-char #\" f6600) (for-each (closure (f6602) (write-char f6600) (let ((f6602 f6602)) (write-char f6602 f6600))) (string->list f6599)) (write-char #\" f6600))))) (vector-set! f6564 0 (closure (f6595 f6596) (for-each write-char string->list) (let ((f6595 f6595) (f6596 f6596)) (for-each (closure (f6598) (write-char f6596) (let ((f6598 f6598)) (write-char f6598 f6596))) (string->list f6595))))) (vector-set! f6563 0 (closure (f6593 f6594) (write-char f6562 write-char) (let ((f6593 f6593) (f6594 f6594)) (begin (write-char #\( f6594) ((vector-ref f6562 0) f6593 f6594) (write-char #\) f6594))))) (vector-set! f6562 0 (closure (f6591 f6592) (write write-char f6562 else write-char write-char write-char write) (let ((f6591 f6591) (f6592 f6592)) (begin (write (car f6591) f6592) (cond ((null? (cdr f6591)) #t) ((pair? (cdr f6591)) (begin (write-char #\space f6592) ((vector-ref f6562 0) (cdr f6591) f6592))) (else (begin (write-char #\space f6592) (write-char #\. f6592) (write-char #\space f6592) (write (cdr f6591) f6592))))))))) (closure (f6615 f6616 f6617) (f6569 f6568 write-char f6567 f6566 f6564 f6565 f6563 else error write) (let ((f6615 f6615) (f6616 f6616) (f6617 f6617)) (cond ((boolean? f6615) ((vector-ref f6569 0) f6615 f6616)) ((null? f6615) ((vector-ref f6568 0) f6616)) ((char? f6615) (if f6617 (write-char f6615 f6616) ((vector-ref f6567 0) f6615 f6616))) ((fixnum? f6615) ((vector-ref f6566 0) f6615 f6616)) ((string? f6615) (if f6617 ((vector-ref f6564 0) f6615 f6616) ((vector-ref f6565 0) f6615 f6616))) ((pair? f6615) ((vector-ref f6563 0) f6615 f6616)) (else (error (quote write) "unrecognized expression")))))))
# == eliminate-quote  ==>
# (let ((f6569 (make-vector 1)) (f6568 (make-vector 1)) (f6567 (make-vector 1)) (f6566 (make-vector 1)) (f6565 (make-vector 1)) (f6564 (make-vector 1)) (f6563 (make-vector 1)) (f6562 (make-vector 1))) (begin (begin (vector-set! f6569 0 (closure (f6610 f6611) (write-char write-char write-char) (let ((f6610 f6610) (f6611 f6611)) (begin (write-char #\# f6611) (if f6610 (write-char #\t f6611) (write-char #\f f6611)))))) (vector-set! f6568 0 (closure (f6609) (write-char write-char) (let ((f6609 f6609)) (begin (write-char #\( f6609) (write-char #\) f6609))))) (vector-set! f6567 0 (closure (f6607 f6608) (write-char write-char write-char) (let ((f6607 f6607) (f6608 f6608)) (begin (write-char #\# f6608) (write-char #\\ f6608) (write-char f6607 f6608))))) (vector-set! f6566 0 (closure (f6603 f6604) (negative? write-char f6566 map write-char integer->list) (let ((f6603 f6603) (f6604 f6604)) (if (negative? f6603) (begin (write-char #\- f6604) ((vector-ref f6566 0) (fx* -1 f6603) f6604)) (map (closure (f6606) (write-char f6604) (let ((f6606 f6606)) (write-char (fixnum->char (fx+ (char->fixnum #\0) f6606)) f6604))) (integer->list f6603)))))) (vector-set! f6565 0 (closure (f6599 f6600) (write-char for-each write-char string->list write-char) (let ((f6599 f6599) (f6600 f6600)) (begin (write-char #\" f6600) (for-each (closure (f6602) (write-char f6600) (let ((f6602 f6602)) (write-char f6602 f6600))) (string->list f6599)) (write-char #\" f6600))))) (vector-set! f6564 0 (closure (f6595 f6596) (for-each write-char string->list) (let ((f6595 f6595) (f6596 f6596)) (for-each (closure (f6598) (write-char f6596) (let ((f6598 f6598)) (write-char f6598 f6596))) (string->list f6595))))) (vector-set! f6563 0 (closure (f6593 f6594) (write-char f6562 write-char) (let ((f6593 f6593) (f6594 f6594)) (begin (write-char #\( f6594) ((vector-ref f6562 0) f6593 f6594) (write-char #\) f6594))))) (vector-set! f6562 0 (closure (f6591 f6592) (write write-char f6562 else write-char write-char write-char write) (let ((f6591 f6591) (f6592 f6592)) (begin (write (car f6591) f6592) (cond ((null? (cdr f6591)) #t) ((pair? (cdr f6591)) (begin (write-char #\space f6592) ((vector-ref f6562 0) (cdr f6591) f6592))) (else (begin (write-char #\space f6592) (write-char #\. f6592) (write-char #\space f6592) (write (cdr f6591) f6592))))))))) (closure (f6615 f6616 f6617) (f6569 f6568 write-char f6567 f6566 f6564 f6565 f6563 else error write) (let ((f6615 f6615) (f6616 f6616) (f6617 f6617)) (cond ((boolean? f6615) ((vector-ref f6569 0) f6615 f6616)) ((null? f6615) ((vector-ref f6568 0) f6616)) ((char? f6615) (if f6617 (write-char f6615 f6616) ((vector-ref f6567 0) f6615 f6616))) ((fixnum? f6615) ((vector-ref f6566 0) f6615 f6616)) ((string? f6615) (if f6617 ((vector-ref f6564 0) f6615 f6616) ((vector-ref f6565 0) f6615 f6616))) ((pair? f6615) ((vector-ref f6563 0) f6615 f6616)) (else (error (string->symbol "write") "unrecognized expression")))))))
# == eliminate-when/unless  ==>
# (let ((f6569 (make-vector 1)) (f6568 (make-vector 1)) (f6567 (make-vector 1)) (f6566 (make-vector 1)) (f6565 (make-vector 1)) (f6564 (make-vector 1)) (f6563 (make-vector 1)) (f6562 (make-vector 1))) (begin (begin (vector-set! f6569 0 (closure (f6610 f6611) (write-char write-char write-char) (let ((f6610 f6610) (f6611 f6611)) (begin (write-char #\# f6611) (if f6610 (write-char #\t f6611) (write-char #\f f6611)))))) (vector-set! f6568 0 (closure (f6609) (write-char write-char) (let ((f6609 f6609)) (begin (write-char #\( f6609) (write-char #\) f6609))))) (vector-set! f6567 0 (closure (f6607 f6608) (write-char write-char write-char) (let ((f6607 f6607) (f6608 f6608)) (begin (write-char #\# f6608) (write-char #\\ f6608) (write-char f6607 f6608))))) (vector-set! f6566 0 (closure (f6603 f6604) (negative? write-char f6566 map write-char integer->list) (let ((f6603 f6603) (f6604 f6604)) (if (negative? f6603) (begin (write-char #\- f6604) ((vector-ref f6566 0) (fx* -1 f6603) f6604)) (map (closure (f6606) (write-char f6604) (let ((f6606 f6606)) (write-char (fixnum->char (fx+ (char->fixnum #\0) f6606)) f6604))) (integer->list f6603)))))) (vector-set! f6565 0 (closure (f6599 f6600) (write-char for-each write-char string->list write-char) (let ((f6599 f6599) (f6600 f6600)) (begin (write-char #\" f6600) (for-each (closure (f6602) (write-char f6600) (let ((f6602 f6602)) (write-char f6602 f6600))) (string->list f6599)) (write-char #\" f6600))))) (vector-set! f6564 0 (closure (f6595 f6596) (for-each write-char string->list) (let ((f6595 f6595) (f6596 f6596)) (for-each (closure (f6598) (write-char f6596) (let ((f6598 f6598)) (write-char f6598 f6596))) (string->list f6595))))) (vector-set! f6563 0 (closure (f6593 f6594) (write-char f6562 write-char) (let ((f6593 f6593) (f6594 f6594)) (begin (write-char #\( f6594) ((vector-ref f6562 0) f6593 f6594) (write-char #\) f6594))))) (vector-set! f6562 0 (closure (f6591 f6592) (write write-char f6562 else write-char write-char write-char write) (let ((f6591 f6591) (f6592 f6592)) (begin (write (car f6591) f6592) (cond ((null? (cdr f6591)) #t) ((pair? (cdr f6591)) (begin (write-char #\space f6592) ((vector-ref f6562 0) (cdr f6591) f6592))) (else (begin (write-char #\space f6592) (write-char #\. f6592) (write-char #\space f6592) (write (cdr f6591) f6592))))))))) (closure (f6615 f6616 f6617) (f6569 f6568 write-char f6567 f6566 f6564 f6565 f6563 else error write) (let ((f6615 f6615) (f6616 f6616) (f6617 f6617)) (cond ((boolean? f6615) ((vector-ref f6569 0) f6615 f6616)) ((null? f6615) ((vector-ref f6568 0) f6616)) ((char? f6615) (if f6617 (write-char f6615 f6616) ((vector-ref f6567 0) f6615 f6616))) ((fixnum? f6615) ((vector-ref f6566 0) f6615 f6616)) ((string? f6615) (if f6617 ((vector-ref f6564 0) f6615 f6616) ((vector-ref f6565 0) f6615 f6616))) ((pair? f6615) ((vector-ref f6563 0) f6615 f6616)) (else (error (string->symbol "write") "unrecognized expression")))))))
# == eliminate-cond  ==>
# (let ((f6569 (make-vector 1)) (f6568 (make-vector 1)) (f6567 (make-vector 1)) (f6566 (make-vector 1)) (f6565 (make-vector 1)) (f6564 (make-vector 1)) (f6563 (make-vector 1)) (f6562 (make-vector 1))) (begin (begin (vector-set! f6569 0 (closure (f6610 f6611) (write-char write-char write-char) (let ((f6610 f6610) (f6611 f6611)) (begin (write-char #\# f6611) (if f6610 (write-char #\t f6611) (write-char #\f f6611)))))) (vector-set! f6568 0 (closure (f6609) (write-char write-char) (let ((f6609 f6609)) (begin (write-char #\( f6609) (write-char #\) f6609))))) (vector-set! f6567 0 (closure (f6607 f6608) (write-char write-char write-char) (let ((f6607 f6607) (f6608 f6608)) (begin (write-char #\# f6608) (write-char #\\ f6608) (write-char f6607 f6608))))) (vector-set! f6566 0 (closure (f6603 f6604) (negative? write-char f6566 map write-char integer->list) (let ((f6603 f6603) (f6604 f6604)) (if (negative? f6603) (begin (write-char #\- f6604) ((vector-ref f6566 0) (fx* -1 f6603) f6604)) (map (closure (f6606) (write-char f6604) (let ((f6606 f6606)) (write-char (fixnum->char (fx+ (char->fixnum #\0) f6606)) f6604))) (integer->list f6603)))))) (vector-set! f6565 0 (closure (f6599 f6600) (write-char for-each write-char string->list write-char) (let ((f6599 f6599) (f6600 f6600)) (begin (write-char #\" f6600) (for-each (closure (f6602) (write-char f6600) (let ((f6602 f6602)) (write-char f6602 f6600))) (string->list f6599)) (write-char #\" f6600))))) (vector-set! f6564 0 (closure (f6595 f6596) (for-each write-char string->list) (let ((f6595 f6595) (f6596 f6596)) (for-each (closure (f6598) (write-char f6596) (let ((f6598 f6598)) (write-char f6598 f6596))) (string->list f6595))))) (vector-set! f6563 0 (closure (f6593 f6594) (write-char f6562 write-char) (let ((f6593 f6593) (f6594 f6594)) (begin (write-char #\( f6594) ((vector-ref f6562 0) f6593 f6594) (write-char #\) f6594))))) (vector-set! f6562 0 (closure (f6591 f6592) (write write-char f6562 else write-char write-char write-char write) (let ((f6591 f6591) (f6592 f6592)) (begin (write (car f6591) f6592) (if (null? (cdr f6591)) #t (if (pair? (cdr f6591)) (begin (write-char #\space f6592) ((vector-ref f6562 0) (cdr f6591) f6592)) (begin (write-char #\space f6592) (write-char #\. f6592) (write-char #\space f6592) (write (cdr f6591) f6592))))))))) (closure (f6615 f6616 f6617) (f6569 f6568 write-char f6567 f6566 f6564 f6565 f6563 else error write) (let ((f6615 f6615) (f6616 f6616) (f6617 f6617)) (if (boolean? f6615) ((vector-ref f6569 0) f6615 f6616) (if (null? f6615) ((vector-ref f6568 0) f6616) (if (char? f6615) (if f6617 (write-char f6615 f6616) ((vector-ref f6567 0) f6615 f6616)) (if (fixnum? f6615) ((vector-ref f6566 0) f6615 f6616) (if (string? f6615) (if f6617 ((vector-ref f6564 0) f6615 f6616) ((vector-ref f6565 0) f6615 f6616)) (if (pair? f6615) ((vector-ref f6563 0) f6615 f6616) (error (string->symbol "write") "unrecognized expression")))))))))))
# == external-symbols  ==>
# (let ((f6569 (make-vector 1)) (f6568 (make-vector 1)) (f6567 (make-vector 1)) (f6566 (make-vector 1)) (f6565 (make-vector 1)) (f6564 (make-vector 1)) (f6563 (make-vector 1)) (f6562 (make-vector 1))) (begin (begin (vector-set! f6569 0 (closure (f6610 f6611) ((primitive-ref write-char) (primitive-ref write-char) (primitive-ref write-char)) (let ((f6610 f6610) (f6611 f6611)) (begin ((primitive-ref write-char) #\# f6611) (if f6610 ((primitive-ref write-char) #\t f6611) ((primitive-ref write-char) #\f f6611)))))) (vector-set! f6568 0 (closure (f6609) ((primitive-ref write-char) (primitive-ref write-char)) (let ((f6609 f6609)) (begin ((primitive-ref write-char) #\( f6609) ((primitive-ref write-char) #\) f6609))))) (vector-set! f6567 0 (closure (f6607 f6608) ((primitive-ref write-char) (primitive-ref write-char) (primitive-ref write-char)) (let ((f6607 f6607) (f6608 f6608)) (begin ((primitive-ref write-char) #\# f6608) ((primitive-ref write-char) #\\ f6608) ((primitive-ref write-char) f6607 f6608))))) (vector-set! f6566 0 (closure (f6603 f6604) ((primitive-ref negative?) (primitive-ref write-char) f6566 (primitive-ref map) (primitive-ref write-char) (primitive-ref integer->list)) (let ((f6603 f6603) (f6604 f6604)) (if ((primitive-ref negative?) f6603) (begin ((primitive-ref write-char) #\- f6604) ((vector-ref f6566 0) (fx* -1 f6603) f6604)) ((primitive-ref map) (closure (f6606) ((primitive-ref write-char) f6604) (let ((f6606 f6606)) ((primitive-ref write-char) (fixnum->char (fx+ (char->fixnum #\0) f6606)) f6604))) ((primitive-ref integer->list) f6603)))))) (vector-set! f6565 0 (closure (f6599 f6600) ((primitive-ref write-char) (primitive-ref for-each) (primitive-ref write-char) (primitive-ref string->list) (primitive-ref write-char)) (let ((f6599 f6599) (f6600 f6600)) (begin ((primitive-ref write-char) #\" f6600) ((primitive-ref for-each) (closure (f6602) ((primitive-ref write-char) f6600) (let ((f6602 f6602)) ((primitive-ref write-char) f6602 f6600))) ((primitive-ref string->list) f6599)) ((primitive-ref write-char) #\" f6600))))) (vector-set! f6564 0 (closure (f6595 f6596) ((primitive-ref for-each) (primitive-ref write-char) (primitive-ref string->list)) (let ((f6595 f6595) (f6596 f6596)) ((primitive-ref for-each) (closure (f6598) ((primitive-ref write-char) f6596) (let ((f6598 f6598)) ((primitive-ref write-char) f6598 f6596))) ((primitive-ref string->list) f6595))))) (vector-set! f6563 0 (closure (f6593 f6594) ((primitive-ref write-char) f6562 (primitive-ref write-char)) (let ((f6593 f6593) (f6594 f6594)) (begin ((primitive-ref write-char) #\( f6594) ((vector-ref f6562 0) f6593 f6594) ((primitive-ref write-char) #\) f6594))))) (vector-set! f6562 0 (closure (f6591 f6592) ((primitive-ref write) (primitive-ref write-char) f6562 else (primitive-ref write-char) (primitive-ref write-char) (primitive-ref write-char) (primitive-ref write)) (let ((f6591 f6591) (f6592 f6592)) (begin ((primitive-ref write) (car f6591) f6592) (if (null? (cdr f6591)) #t (if (pair? (cdr f6591)) (begin ((primitive-ref write-char) #\space f6592) ((vector-ref f6562 0) (cdr f6591) f6592)) (begin ((primitive-ref write-char) #\space f6592) ((primitive-ref write-char) #\. f6592) ((primitive-ref write-char) #\space f6592) ((primitive-ref write) (cdr f6591) f6592))))))))) (closure (f6615 f6616 f6617) (f6569 f6568 (primitive-ref write-char) f6567 f6566 f6564 f6565 f6563 else (primitive-ref error) (primitive-ref write)) (let ((f6615 f6615) (f6616 f6616) (f6617 f6617)) (if (boolean? f6615) ((vector-ref f6569 0) f6615 f6616) (if (null? f6615) ((vector-ref f6568 0) f6616) (if (char? f6615) (if f6617 ((primitive-ref write-char) f6615 f6616) ((vector-ref f6567 0) f6615 f6616)) (if (fixnum? f6615) ((vector-ref f6566 0) f6615 f6616) (if (string? f6615) (if f6617 ((vector-ref f6564 0) f6615 f6616) ((vector-ref f6565 0) f6615 f6616)) (if (pair? f6615) ((vector-ref f6563 0) f6615 f6616) ((primitive-ref error) ((primitive-ref string->symbol) "write") "unrecognized expression")))))))))))
# emit-expr (let ((f6569 (make-vector 1)) (f6568 (make-vector 1)) (f6567 (make-vector 1)) (f6566 (make-vector 1)) (f6565 (make-vector 1)) (f6564 (make-vector 1)) (f6563 (make-vector 1)) (f6562 (make-vector 1))) (begin (begin (vector-set! f6569 0 (closure (f6610 f6611) ((primitive-ref write-char) (primitive-ref write-char) (primitive-ref write-char)) (let ((f6610 f6610) (f6611 f6611)) (begin ((primitive-ref write-char) #\# f6611) (if f6610 ((primitive-ref write-char) #\t f6611) ((primitive-ref write-char) #\f f6611)))))) (vector-set! f6568 0 (closure (f6609) ((primitive-ref write-char) (primitive-ref write-char)) (let ((f6609 f6609)) (begin ((primitive-ref write-char) #\( f6609) ((primitive-ref write-char) #\) f6609))))) (vector-set! f6567 0 (closure (f6607 f6608) ((primitive-ref write-char) (primitive-ref write-char) (primitive-ref write-char)) (let ((f6607 f6607) (f6608 f6608)) (begin ((primitive-ref write-char) #\# f6608) ((primitive-ref write-char) #\\ f6608) ((primitive-ref write-char) f6607 f6608))))) (vector-set! f6566 0 (closure (f6603 f6604) ((primitive-ref negative?) (primitive-ref write-char) f6566 (primitive-ref map) (primitive-ref write-char) (primitive-ref integer->list)) (let ((f6603 f6603) (f6604 f6604)) (if ((primitive-ref negative?) f6603) (begin ((primitive-ref write-char) #\- f6604) ((vector-ref f6566 0) (fx* -1 f6603) f6604)) ((primitive-ref map) (closure (f6606) ((primitive-ref write-char) f6604) (let ((f6606 f6606)) ((primitive-ref write-char) (fixnum->char (fx+ (char->fixnum #\0) f6606)) f6604))) ((primitive-ref integer->list) f6603)))))) (vector-set! f6565 0 (closure (f6599 f6600) ((primitive-ref write-char) (primitive-ref for-each) (primitive-ref write-char) (primitive-ref string->list) (primitive-ref write-char)) (let ((f6599 f6599) (f6600 f6600)) (begin ((primitive-ref write-char) #\" f6600) ((primitive-ref for-each) (closure (f6602) ((primitive-ref write-char) f6600) (let ((f6602 f6602)) ((primitive-ref write-char) f6602 f6600))) ((primitive-ref string->list) f6599)) ((primitive-ref write-char) #\" f6600))))) (vector-set! f6564 0 (closure (f6595 f6596) ((primitive-ref for-each) (primitive-ref write-char) (primitive-ref string->list)) (let ((f6595 f6595) (f6596 f6596)) ((primitive-ref for-each) (closure (f6598) ((primitive-ref write-char) f6596) (let ((f6598 f6598)) ((primitive-ref write-char) f6598 f6596))) ((primitive-ref string->list) f6595))))) (vector-set! f6563 0 (closure (f6593 f6594) ((primitive-ref write-char) f6562 (primitive-ref write-char)) (let ((f6593 f6593) (f6594 f6594)) (begin ((primitive-ref write-char) #\( f6594) ((vector-ref f6562 0) f6593 f6594) ((primitive-ref write-char) #\) f6594))))) (vector-set! f6562 0 (closure (f6591 f6592) ((primitive-ref write) (primitive-ref write-char) f6562 else (primitive-ref write-char) (primitive-ref write-char) (primitive-ref write-char) (primitive-ref write)) (let ((f6591 f6591) (f6592 f6592)) (begin ((primitive-ref write) (car f6591) f6592) (if (null? (cdr f6591)) #t (if (pair? (cdr f6591)) (begin ((primitive-ref write-char) #\space f6592) ((vector-ref f6562 0) (cdr f6591) f6592)) (begin ((primitive-ref write-char) #\space f6592) ((primitive-ref write-char) #\. f6592) ((primitive-ref write-char) #\space f6592) ((primitive-ref write) (cdr f6591) f6592))))))))) (closure (f6615 f6616 f6617) (f6569 f6568 (primitive-ref write-char) f6567 f6566 f6564 f6565 f6563 else (primitive-ref error) (primitive-ref write)) (let ((f6615 f6615) (f6616 f6616) (f6617 f6617)) (if (boolean? f6615) ((vector-ref f6569 0) f6615 f6616) (if (null? f6615) ((vector-ref f6568 0) f6616) (if (char? f6615) (if f6617 ((primitive-ref write-char) f6615 f6616) ((vector-ref f6567 0) f6615 f6616)) (if (fixnum? f6615) ((vector-ref f6566 0) f6615 f6616) (if (string? f6615) (if f6617 ((vector-ref f6564 0) f6615 f6616) ((vector-ref f6565 0) f6615 f6616)) (if (pair? f6615) ((vector-ref f6563 0) f6615 f6616) ((primitive-ref error) ((primitive-ref string->symbol) "write") "unrecognized expression")))))))))))
# emit-let
#  si   = 0
#  env  = ()
#  bindings = ((f6569 (make-vector 1)) (f6568 (make-vector 1)) (f6567 (make-vector 1)) (f6566 (make-vector 1)) (f6565 (make-vector 1)) (f6564 (make-vector 1)) (f6563 (make-vector 1)) (f6562 (make-vector 1)))
#  body = (begin (begin (vector-set! f6569 0 (closure (f6610 f6611) ((primitive-ref write-char) (primitive-ref write-char) (primitive-ref write-char)) (let ((f6610 f6610) (f6611 f6611)) (begin ((primitive-ref write-char) #\# f6611) (if f6610 ((primitive-ref write-char) #\t f6611) ((primitive-ref write-char) #\f f6611)))))) (vector-set! f6568 0 (closure (f6609) ((primitive-ref write-char) (primitive-ref write-char)) (let ((f6609 f6609)) (begin ((primitive-ref write-char) #\( f6609) ((primitive-ref write-char) #\) f6609))))) (vector-set! f6567 0 (closure (f6607 f6608) ((primitive-ref write-char) (primitive-ref write-char) (primitive-ref write-char)) (let ((f6607 f6607) (f6608 f6608)) (begin ((primitive-ref write-char) #\# f6608) ((primitive-ref write-char) #\\ f6608) ((primitive-ref write-char) f6607 f6608))))) (vector-set! f6566 0 (closure (f6603 f6604) ((primitive-ref negative?) (primitive-ref write-char) f6566 (primitive-ref map) (primitive-ref write-char) (primitive-ref integer->list)) (let ((f6603 f6603) (f6604 f6604)) (if ((primitive-ref negative?) f6603) (begin ((primitive-ref write-char) #\- f6604) ((vector-ref f6566 0) (fx* -1 f6603) f6604)) ((primitive-ref map) (closure (f6606) ((primitive-ref write-char) f6604) (let ((f6606 f6606)) ((primitive-ref write-char) (fixnum->char (fx+ (char->fixnum #\0) f6606)) f6604))) ((primitive-ref integer->list) f6603)))))) (vector-set! f6565 0 (closure (f6599 f6600) ((primitive-ref write-char) (primitive-ref for-each) (primitive-ref write-char) (primitive-ref string->list) (primitive-ref write-char)) (let ((f6599 f6599) (f6600 f6600)) (begin ((primitive-ref write-char) #\" f6600) ((primitive-ref for-each) (closure (f6602) ((primitive-ref write-char) f6600) (let ((f6602 f6602)) ((primitive-ref write-char) f6602 f6600))) ((primitive-ref string->list) f6599)) ((primitive-ref write-char) #\" f6600))))) (vector-set! f6564 0 (closure (f6595 f6596) ((primitive-ref for-each) (primitive-ref write-char) (primitive-ref string->list)) (let ((f6595 f6595) (f6596 f6596)) ((primitive-ref for-each) (closure (f6598) ((primitive-ref write-char) f6596) (let ((f6598 f6598)) ((primitive-ref write-char) f6598 f6596))) ((primitive-ref string->list) f6595))))) (vector-set! f6563 0 (closure (f6593 f6594) ((primitive-ref write-char) f6562 (primitive-ref write-char)) (let ((f6593 f6593) (f6594 f6594)) (begin ((primitive-ref write-char) #\( f6594) ((vector-ref f6562 0) f6593 f6594) ((primitive-ref write-char) #\) f6594))))) (vector-set! f6562 0 (closure (f6591 f6592) ((primitive-ref write) (primitive-ref write-char) f6562 else (primitive-ref write-char) (primitive-ref write-char) (primitive-ref write-char) (primitive-ref write)) (let ((f6591 f6591) (f6592 f6592)) (begin ((primitive-ref write) (car f6591) f6592) (if (null? (cdr f6591)) #t (if (pair? (cdr f6591)) (begin ((primitive-ref write-char) #\space f6592) ((vector-ref f6562 0) (cdr f6591) f6592)) (begin ((primitive-ref write-char) #\space f6592) ((primitive-ref write-char) #\. f6592) ((primitive-ref write-char) #\space f6592) ((primitive-ref write) (cdr f6591) f6592))))))))) (closure (f6615 f6616 f6617) (f6569 f6568 (primitive-ref write-char) f6567 f6566 f6564 f6565 f6563 else (primitive-ref error) (primitive-ref write)) (let ((f6615 f6615) (f6616 f6616) (f6617 f6617)) (if (boolean? f6615) ((vector-ref f6569 0) f6615 f6616) (if (null? f6615) ((vector-ref f6568 0) f6616) (if (char? f6615) (if f6617 ((primitive-ref write-char) f6615 f6616) ((vector-ref f6567 0) f6615 f6616)) (if (fixnum? f6615) ((vector-ref f6566 0) f6615 f6616) (if (string? f6615) (if f6617 ((vector-ref f6564 0) f6615 f6616) ((vector-ref f6565 0) f6615 f6616)) (if (pair? f6615) ((vector-ref f6563 0) f6615 f6616) ((primitive-ref error) ((primitive-ref string->symbol) "write") "unrecognized expression"))))))))))
# emit-expr (make-vector 1)
# make-vector 1
# emit-expr 1
    movl $4, %eax     # immed 1
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_39996"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_39996:
# check the argument is a fixnum >= 0
    cmp $0,%eax
    jge _L_39997
# invoke error handler eh_length
    .extern mrc_eh$ulength
    movl mrc_eh$ulength, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_39997:
    movl %eax, %esi
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    orl  $5, %eax
    addl $4, %esi
    addl $4, %esi
    andl $-8, %esi
    addl %esi, %ebp
    movl %eax, 0(%esp)  # stack save
# emit-expr (make-vector 1)
# make-vector 1
# emit-expr 1
    movl $4, %eax     # immed 1
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_39998"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_39998:
# check the argument is a fixnum >= 0
    cmp $0,%eax
    jge _L_39999
# invoke error handler eh_length
    .extern mrc_eh$ulength
    movl mrc_eh$ulength, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_39999:
    movl %eax, %esi
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    orl  $5, %eax
    addl $4, %esi
    addl $4, %esi
    andl $-8, %esi
    addl %esi, %ebp
    movl %eax, -4(%esp)  # stack save
# emit-expr (make-vector 1)
# make-vector 1
# emit-expr 1
    movl $4, %eax     # immed 1
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_40000"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_40000:
# check the argument is a fixnum >= 0
    cmp $0,%eax
    jge _L_40001
# invoke error handler eh_length
    .extern mrc_eh$ulength
    movl mrc_eh$ulength, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_40001:
    movl %eax, %esi
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    orl  $5, %eax
    addl $4, %esi
    addl $4, %esi
    andl $-8, %esi
    addl %esi, %ebp
    movl %eax, -8(%esp)  # stack save
# emit-expr (make-vector 1)
# make-vector 1
# emit-expr 1
    movl $4, %eax     # immed 1
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_40002"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_40002:
# check the argument is a fixnum >= 0
    cmp $0,%eax
    jge _L_40003
# invoke error handler eh_length
    .extern mrc_eh$ulength
    movl mrc_eh$ulength, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_40003:
    movl %eax, %esi
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    orl  $5, %eax
    addl $4, %esi
    addl $4, %esi
    andl $-8, %esi
    addl %esi, %ebp
    movl %eax, -12(%esp)  # stack save
# emit-expr (make-vector 1)
# make-vector 1
# emit-expr 1
    movl $4, %eax     # immed 1
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_40004"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_40004:
# check the argument is a fixnum >= 0
    cmp $0,%eax
    jge _L_40005
# invoke error handler eh_length
    .extern mrc_eh$ulength
    movl mrc_eh$ulength, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_40005:
    movl %eax, %esi
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    orl  $5, %eax
    addl $4, %esi
    addl $4, %esi
    andl $-8, %esi
    addl %esi, %ebp
    movl %eax, -16(%esp)  # stack save
# emit-expr (make-vector 1)
# make-vector 1
# emit-expr 1
    movl $4, %eax     # immed 1
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_40006"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_40006:
# check the argument is a fixnum >= 0
    cmp $0,%eax
    jge _L_40007
# invoke error handler eh_length
    .extern mrc_eh$ulength
    movl mrc_eh$ulength, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_40007:
    movl %eax, %esi
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    orl  $5, %eax
    addl $4, %esi
    addl $4, %esi
    andl $-8, %esi
    addl %esi, %ebp
    movl %eax, -20(%esp)  # stack save
# emit-expr (make-vector 1)
# make-vector 1
# emit-expr 1
    movl $4, %eax     # immed 1
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_40008"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_40008:
# check the argument is a fixnum >= 0
    cmp $0,%eax
    jge _L_40009
# invoke error handler eh_length
    .extern mrc_eh$ulength
    movl mrc_eh$ulength, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_40009:
    movl %eax, %esi
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    orl  $5, %eax
    addl $4, %esi
    addl $4, %esi
    andl $-8, %esi
    addl %esi, %ebp
    movl %eax, -24(%esp)  # stack save
# emit-expr (make-vector 1)
# make-vector 1
# emit-expr 1
    movl $4, %eax     # immed 1
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_40010"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_40010:
# check the argument is a fixnum >= 0
    cmp $0,%eax
    jge _L_40011
# invoke error handler eh_length
    .extern mrc_eh$ulength
    movl mrc_eh$ulength, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_40011:
    movl %eax, %esi
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    orl  $5, %eax
    addl $4, %esi
    addl $4, %esi
    andl $-8, %esi
    addl %esi, %ebp
    movl %eax, -28(%esp)  # stack save
# emit-expr (begin (begin (vector-set! f6569 0 (closure (f6610 f6611) ((primitive-ref write-char) (primitive-ref write-char) (primitive-ref write-char)) (let ((f6610 f6610) (f6611 f6611)) (begin ((primitive-ref write-char) #\# f6611) (if f6610 ((primitive-ref write-char) #\t f6611) ((primitive-ref write-char) #\f f6611)))))) (vector-set! f6568 0 (closure (f6609) ((primitive-ref write-char) (primitive-ref write-char)) (let ((f6609 f6609)) (begin ((primitive-ref write-char) #\( f6609) ((primitive-ref write-char) #\) f6609))))) (vector-set! f6567 0 (closure (f6607 f6608) ((primitive-ref write-char) (primitive-ref write-char) (primitive-ref write-char)) (let ((f6607 f6607) (f6608 f6608)) (begin ((primitive-ref write-char) #\# f6608) ((primitive-ref write-char) #\\ f6608) ((primitive-ref write-char) f6607 f6608))))) (vector-set! f6566 0 (closure (f6603 f6604) ((primitive-ref negative?) (primitive-ref write-char) f6566 (primitive-ref map) (primitive-ref write-char) (primitive-ref integer->list)) (let ((f6603 f6603) (f6604 f6604)) (if ((primitive-ref negative?) f6603) (begin ((primitive-ref write-char) #\- f6604) ((vector-ref f6566 0) (fx* -1 f6603) f6604)) ((primitive-ref map) (closure (f6606) ((primitive-ref write-char) f6604) (let ((f6606 f6606)) ((primitive-ref write-char) (fixnum->char (fx+ (char->fixnum #\0) f6606)) f6604))) ((primitive-ref integer->list) f6603)))))) (vector-set! f6565 0 (closure (f6599 f6600) ((primitive-ref write-char) (primitive-ref for-each) (primitive-ref write-char) (primitive-ref string->list) (primitive-ref write-char)) (let ((f6599 f6599) (f6600 f6600)) (begin ((primitive-ref write-char) #\" f6600) ((primitive-ref for-each) (closure (f6602) ((primitive-ref write-char) f6600) (let ((f6602 f6602)) ((primitive-ref write-char) f6602 f6600))) ((primitive-ref string->list) f6599)) ((primitive-ref write-char) #\" f6600))))) (vector-set! f6564 0 (closure (f6595 f6596) ((primitive-ref for-each) (primitive-ref write-char) (primitive-ref string->list)) (let ((f6595 f6595) (f6596 f6596)) ((primitive-ref for-each) (closure (f6598) ((primitive-ref write-char) f6596) (let ((f6598 f6598)) ((primitive-ref write-char) f6598 f6596))) ((primitive-ref string->list) f6595))))) (vector-set! f6563 0 (closure (f6593 f6594) ((primitive-ref write-char) f6562 (primitive-ref write-char)) (let ((f6593 f6593) (f6594 f6594)) (begin ((primitive-ref write-char) #\( f6594) ((vector-ref f6562 0) f6593 f6594) ((primitive-ref write-char) #\) f6594))))) (vector-set! f6562 0 (closure (f6591 f6592) ((primitive-ref write) (primitive-ref write-char) f6562 else (primitive-ref write-char) (primitive-ref write-char) (primitive-ref write-char) (primitive-ref write)) (let ((f6591 f6591) (f6592 f6592)) (begin ((primitive-ref write) (car f6591) f6592) (if (null? (cdr f6591)) #t (if (pair? (cdr f6591)) (begin ((primitive-ref write-char) #\space f6592) ((vector-ref f6562 0) (cdr f6591) f6592)) (begin ((primitive-ref write-char) #\space f6592) ((primitive-ref write-char) #\. f6592) ((primitive-ref write-char) #\space f6592) ((primitive-ref write) (cdr f6591) f6592))))))))) (closure (f6615 f6616 f6617) (f6569 f6568 (primitive-ref write-char) f6567 f6566 f6564 f6565 f6563 else (primitive-ref error) (primitive-ref write)) (let ((f6615 f6615) (f6616 f6616) (f6617 f6617)) (if (boolean? f6615) ((vector-ref f6569 0) f6615 f6616) (if (null? f6615) ((vector-ref f6568 0) f6616) (if (char? f6615) (if f6617 ((primitive-ref write-char) f6615 f6616) ((vector-ref f6567 0) f6615 f6616)) (if (fixnum? f6615) ((vector-ref f6566 0) f6615 f6616) (if (string? f6615) (if f6617 ((vector-ref f6564 0) f6615 f6616) ((vector-ref f6565 0) f6615 f6616)) (if (pair? f6615) ((vector-ref f6563 0) f6615 f6616) ((primitive-ref error) ((primitive-ref string->symbol) "write") "unrecognized expression"))))))))))
# emit-begin
#   expr=(begin (begin (vector-set! f6569 0 (closure (f6610 f6611) ((primitive-ref write-char) (primitive-ref write-char) (primitive-ref write-char)) (let ((f6610 f6610) (f6611 f6611)) (begin ((primitive-ref write-char) #\# f6611) (if f6610 ((primitive-ref write-char) #\t f6611) ((primitive-ref write-char) #\f f6611)))))) (vector-set! f6568 0 (closure (f6609) ((primitive-ref write-char) (primitive-ref write-char)) (let ((f6609 f6609)) (begin ((primitive-ref write-char) #\( f6609) ((primitive-ref write-char) #\) f6609))))) (vector-set! f6567 0 (closure (f6607 f6608) ((primitive-ref write-char) (primitive-ref write-char) (primitive-ref write-char)) (let ((f6607 f6607) (f6608 f6608)) (begin ((primitive-ref write-char) #\# f6608) ((primitive-ref write-char) #\\ f6608) ((primitive-ref write-char) f6607 f6608))))) (vector-set! f6566 0 (closure (f6603 f6604) ((primitive-ref negative?) (primitive-ref write-char) f6566 (primitive-ref map) (primitive-ref write-char) (primitive-ref integer->list)) (let ((f6603 f6603) (f6604 f6604)) (if ((primitive-ref negative?) f6603) (begin ((primitive-ref write-char) #\- f6604) ((vector-ref f6566 0) (fx* -1 f6603) f6604)) ((primitive-ref map) (closure (f6606) ((primitive-ref write-char) f6604) (let ((f6606 f6606)) ((primitive-ref write-char) (fixnum->char (fx+ (char->fixnum #\0) f6606)) f6604))) ((primitive-ref integer->list) f6603)))))) (vector-set! f6565 0 (closure (f6599 f6600) ((primitive-ref write-char) (primitive-ref for-each) (primitive-ref write-char) (primitive-ref string->list) (primitive-ref write-char)) (let ((f6599 f6599) (f6600 f6600)) (begin ((primitive-ref write-char) #\" f6600) ((primitive-ref for-each) (closure (f6602) ((primitive-ref write-char) f6600) (let ((f6602 f6602)) ((primitive-ref write-char) f6602 f6600))) ((primitive-ref string->list) f6599)) ((primitive-ref write-char) #\" f6600))))) (vector-set! f6564 0 (closure (f6595 f6596) ((primitive-ref for-each) (primitive-ref write-char) (primitive-ref string->list)) (let ((f6595 f6595) (f6596 f6596)) ((primitive-ref for-each) (closure (f6598) ((primitive-ref write-char) f6596) (let ((f6598 f6598)) ((primitive-ref write-char) f6598 f6596))) ((primitive-ref string->list) f6595))))) (vector-set! f6563 0 (closure (f6593 f6594) ((primitive-ref write-char) f6562 (primitive-ref write-char)) (let ((f6593 f6593) (f6594 f6594)) (begin ((primitive-ref write-char) #\( f6594) ((vector-ref f6562 0) f6593 f6594) ((primitive-ref write-char) #\) f6594))))) (vector-set! f6562 0 (closure (f6591 f6592) ((primitive-ref write) (primitive-ref write-char) f6562 else (primitive-ref write-char) (primitive-ref write-char) (primitive-ref write-char) (primitive-ref write)) (let ((f6591 f6591) (f6592 f6592)) (begin ((primitive-ref write) (car f6591) f6592) (if (null? (cdr f6591)) #t (if (pair? (cdr f6591)) (begin ((primitive-ref write-char) #\space f6592) ((vector-ref f6562 0) (cdr f6591) f6592)) (begin ((primitive-ref write-char) #\space f6592) ((primitive-ref write-char) #\. f6592) ((primitive-ref write-char) #\space f6592) ((primitive-ref write) (cdr f6591) f6592))))))))) (closure (f6615 f6616 f6617) (f6569 f6568 (primitive-ref write-char) f6567 f6566 f6564 f6565 f6563 else (primitive-ref error) (primitive-ref write)) (let ((f6615 f6615) (f6616 f6616) (f6617 f6617)) (if (boolean? f6615) ((vector-ref f6569 0) f6615 f6616) (if (null? f6615) ((vector-ref f6568 0) f6616) (if (char? f6615) (if f6617 ((primitive-ref write-char) f6615 f6616) ((vector-ref f6567 0) f6615 f6616)) (if (fixnum? f6615) ((vector-ref f6566 0) f6615 f6616) (if (string? f6615) (if f6617 ((vector-ref f6564 0) f6615 f6616) ((vector-ref f6565 0) f6615 f6616)) (if (pair? f6615) ((vector-ref f6563 0) f6615 f6616) ((primitive-ref error) ((primitive-ref string->symbol) "write") "unrecognized expression"))))))))))
#   env=((f6562 . -28) (f6563 . -24) (f6564 . -20) (f6565 . -16) (f6566 . -12) (f6567 . -8) (f6568 . -4) (f6569 . 0))
# emit-expr (begin (vector-set! f6569 0 (closure (f6610 f6611) ((primitive-ref write-char) (primitive-ref write-char) (primitive-ref write-char)) (let ((f6610 f6610) (f6611 f6611)) (begin ((primitive-ref write-char) #\# f6611) (if f6610 ((primitive-ref write-char) #\t f6611) ((primitive-ref write-char) #\f f6611)))))) (vector-set! f6568 0 (closure (f6609) ((primitive-ref write-char) (primitive-ref write-char)) (let ((f6609 f6609)) (begin ((primitive-ref write-char) #\( f6609) ((primitive-ref write-char) #\) f6609))))) (vector-set! f6567 0 (closure (f6607 f6608) ((primitive-ref write-char) (primitive-ref write-char) (primitive-ref write-char)) (let ((f6607 f6607) (f6608 f6608)) (begin ((primitive-ref write-char) #\# f6608) ((primitive-ref write-char) #\\ f6608) ((primitive-ref write-char) f6607 f6608))))) (vector-set! f6566 0 (closure (f6603 f6604) ((primitive-ref negative?) (primitive-ref write-char) f6566 (primitive-ref map) (primitive-ref write-char) (primitive-ref integer->list)) (let ((f6603 f6603) (f6604 f6604)) (if ((primitive-ref negative?) f6603) (begin ((primitive-ref write-char) #\- f6604) ((vector-ref f6566 0) (fx* -1 f6603) f6604)) ((primitive-ref map) (closure (f6606) ((primitive-ref write-char) f6604) (let ((f6606 f6606)) ((primitive-ref write-char) (fixnum->char (fx+ (char->fixnum #\0) f6606)) f6604))) ((primitive-ref integer->list) f6603)))))) (vector-set! f6565 0 (closure (f6599 f6600) ((primitive-ref write-char) (primitive-ref for-each) (primitive-ref write-char) (primitive-ref string->list) (primitive-ref write-char)) (let ((f6599 f6599) (f6600 f6600)) (begin ((primitive-ref write-char) #\" f6600) ((primitive-ref for-each) (closure (f6602) ((primitive-ref write-char) f6600) (let ((f6602 f6602)) ((primitive-ref write-char) f6602 f6600))) ((primitive-ref string->list) f6599)) ((primitive-ref write-char) #\" f6600))))) (vector-set! f6564 0 (closure (f6595 f6596) ((primitive-ref for-each) (primitive-ref write-char) (primitive-ref string->list)) (let ((f6595 f6595) (f6596 f6596)) ((primitive-ref for-each) (closure (f6598) ((primitive-ref write-char) f6596) (let ((f6598 f6598)) ((primitive-ref write-char) f6598 f6596))) ((primitive-ref string->list) f6595))))) (vector-set! f6563 0 (closure (f6593 f6594) ((primitive-ref write-char) f6562 (primitive-ref write-char)) (let ((f6593 f6593) (f6594 f6594)) (begin ((primitive-ref write-char) #\( f6594) ((vector-ref f6562 0) f6593 f6594) ((primitive-ref write-char) #\) f6594))))) (vector-set! f6562 0 (closure (f6591 f6592) ((primitive-ref write) (primitive-ref write-char) f6562 else (primitive-ref write-char) (primitive-ref write-char) (primitive-ref write-char) (primitive-ref write)) (let ((f6591 f6591) (f6592 f6592)) (begin ((primitive-ref write) (car f6591) f6592) (if (null? (cdr f6591)) #t (if (pair? (cdr f6591)) (begin ((primitive-ref write-char) #\space f6592) ((vector-ref f6562 0) (cdr f6591) f6592)) (begin ((primitive-ref write-char) #\space f6592) ((primitive-ref write-char) #\. f6592) ((primitive-ref write-char) #\space f6592) ((primitive-ref write) (cdr f6591) f6592)))))))))
# emit-begin
#   expr=(begin (vector-set! f6569 0 (closure (f6610 f6611) ((primitive-ref write-char) (primitive-ref write-char) (primitive-ref write-char)) (let ((f6610 f6610) (f6611 f6611)) (begin ((primitive-ref write-char) #\# f6611) (if f6610 ((primitive-ref write-char) #\t f6611) ((primitive-ref write-char) #\f f6611)))))) (vector-set! f6568 0 (closure (f6609) ((primitive-ref write-char) (primitive-ref write-char)) (let ((f6609 f6609)) (begin ((primitive-ref write-char) #\( f6609) ((primitive-ref write-char) #\) f6609))))) (vector-set! f6567 0 (closure (f6607 f6608) ((primitive-ref write-char) (primitive-ref write-char) (primitive-ref write-char)) (let ((f6607 f6607) (f6608 f6608)) (begin ((primitive-ref write-char) #\# f6608) ((primitive-ref write-char) #\\ f6608) ((primitive-ref write-char) f6607 f6608))))) (vector-set! f6566 0 (closure (f6603 f6604) ((primitive-ref negative?) (primitive-ref write-char) f6566 (primitive-ref map) (primitive-ref write-char) (primitive-ref integer->list)) (let ((f6603 f6603) (f6604 f6604)) (if ((primitive-ref negative?) f6603) (begin ((primitive-ref write-char) #\- f6604) ((vector-ref f6566 0) (fx* -1 f6603) f6604)) ((primitive-ref map) (closure (f6606) ((primitive-ref write-char) f6604) (let ((f6606 f6606)) ((primitive-ref write-char) (fixnum->char (fx+ (char->fixnum #\0) f6606)) f6604))) ((primitive-ref integer->list) f6603)))))) (vector-set! f6565 0 (closure (f6599 f6600) ((primitive-ref write-char) (primitive-ref for-each) (primitive-ref write-char) (primitive-ref string->list) (primitive-ref write-char)) (let ((f6599 f6599) (f6600 f6600)) (begin ((primitive-ref write-char) #\" f6600) ((primitive-ref for-each) (closure (f6602) ((primitive-ref write-char) f6600) (let ((f6602 f6602)) ((primitive-ref write-char) f6602 f6600))) ((primitive-ref string->list) f6599)) ((primitive-ref write-char) #\" f6600))))) (vector-set! f6564 0 (closure (f6595 f6596) ((primitive-ref for-each) (primitive-ref write-char) (primitive-ref string->list)) (let ((f6595 f6595) (f6596 f6596)) ((primitive-ref for-each) (closure (f6598) ((primitive-ref write-char) f6596) (let ((f6598 f6598)) ((primitive-ref write-char) f6598 f6596))) ((primitive-ref string->list) f6595))))) (vector-set! f6563 0 (closure (f6593 f6594) ((primitive-ref write-char) f6562 (primitive-ref write-char)) (let ((f6593 f6593) (f6594 f6594)) (begin ((primitive-ref write-char) #\( f6594) ((vector-ref f6562 0) f6593 f6594) ((primitive-ref write-char) #\) f6594))))) (vector-set! f6562 0 (closure (f6591 f6592) ((primitive-ref write) (primitive-ref write-char) f6562 else (primitive-ref write-char) (primitive-ref write-char) (primitive-ref write-char) (primitive-ref write)) (let ((f6591 f6591) (f6592 f6592)) (begin ((primitive-ref write) (car f6591) f6592) (if (null? (cdr f6591)) #t (if (pair? (cdr f6591)) (begin ((primitive-ref write-char) #\space f6592) ((vector-ref f6562 0) (cdr f6591) f6592)) (begin ((primitive-ref write-char) #\space f6592) ((primitive-ref write-char) #\. f6592) ((primitive-ref write-char) #\space f6592) ((primitive-ref write) (cdr f6591) f6592)))))))))
#   env=((f6562 . -28) (f6563 . -24) (f6564 . -20) (f6565 . -16) (f6566 . -12) (f6567 . -8) (f6568 . -4) (f6569 . 0))
# emit-expr (vector-set! f6569 0 (closure (f6610 f6611) ((primitive-ref write-char) (primitive-ref write-char) (primitive-ref write-char)) (let ((f6610 f6610) (f6611 f6611)) (begin ((primitive-ref write-char) #\# f6611) (if f6610 ((primitive-ref write-char) #\t f6611) ((primitive-ref write-char) #\f f6611))))))
# emit-expr f6569
# emit-variable-ref
# env=((f6562 . -28) (f6563 . -24) (f6564 . -20) (f6565 . -16) (f6566 . -12) (f6567 . -8) (f6568 . -4) (f6569 . 0))
# var=f6569
    movl 0(%esp), %eax  # stack load f6569
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_40012
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_40012:
    movl %eax, -32(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_40013"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_40013:
# check bounds on vector index
    movl -32(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_40015
    cmp  $0,%eax
    jge _L_40014
_L_40015:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_40014:
    movl %eax, -36(%esp)
# emit-expr (closure (f6610 f6611) ((primitive-ref write-char) (primitive-ref write-char) (primitive-ref write-char)) (let ((f6610 f6610) (f6611 f6611)) (begin ((primitive-ref write-char) #\# f6611) (if f6610 ((primitive-ref write-char) #\t f6611) ((primitive-ref write-char) #\f f6611)))))
# emit-closure
# si = -40
# env = ((f6562 . -28) (f6563 . -24) (f6564 . -20) (f6565 . -16) (f6566 . -12) (f6567 . -8) (f6568 . -4) (f6569 . 0))
# expr = (closure (f6610 f6611) ((primitive-ref write-char) (primitive-ref write-char) (primitive-ref write-char)) (let ((f6610 f6610) (f6611 f6611)) (begin ((primitive-ref write-char) #\# f6611) (if f6610 ((primitive-ref write-char) #\t f6611) ((primitive-ref write-char) #\f f6611)))))
    movl $_L_40016, 0(%ebp)  # closure label
# WARNING: free var (primitive-ref write-char) not defined in the environmnet
# WARNING: free var (primitive-ref write-char) not defined in the environmnet
# WARNING: free var (primitive-ref write-char) not defined in the environmnet
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $16, %ebp     # bump ebp
    jmp _L_40017            # jump around closure body
_L_40016:
# check argument count
    cmp $8,%eax
    je _L_40018
# invoke error handler eh_argcount
    .extern mrc_eh$uargcount
    movl mrc_eh$uargcount, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_40018:
# emit-tail-expr
# si=-16
# env=((f6611 . -12) (f6610 . -8) ((primitive-ref write-char) . 12) ((primitive-ref write-char) . 8) ((primitive-ref write-char) . 4) (f6562 . -28) (f6563 . -24) (f6564 . -20) (f6565 . -16) (f6566 . -12) (f6567 . -8) (f6568 . -4) (f6569 . 0))
# expr=(let ((f6610 f6610) (f6611 f6611)) (begin ((primitive-ref write-char) #\# f6611) (if f6610 ((primitive-ref write-char) #\t f6611) ((primitive-ref write-char) #\f f6611))))
# emit-tail-let
#  si   = -16
#  env  = ((f6611 . -12) (f6610 . -8) ((primitive-ref write-char) . 12) ((primitive-ref write-char) . 8) ((primitive-ref write-char) . 4) (f6562 . -28) (f6563 . -24) (f6564 . -20) (f6565 . -16) (f6566 . -12) (f6567 . -8) (f6568 . -4) (f6569 . 0))
#  bindings = ((f6610 f6610) (f6611 f6611))
#  body = (begin ((primitive-ref write-char) #\# f6611) (if f6610 ((primitive-ref write-char) #\t f6611) ((primitive-ref write-char) #\f f6611)))
# emit-expr f6610
# emit-variable-ref
# env=((f6611 . -12) (f6610 . -8) ((primitive-ref write-char) . 12) ((primitive-ref write-char) . 8) ((primitive-ref write-char) . 4) (f6562 . -28) (f6563 . -24) (f6564 . -20) (f6565 . -16) (f6566 . -12) (f6567 . -8) (f6568 . -4) (f6569 . 0))
# var=f6610
    movl -8(%esp), %eax  # stack load f6610
# end emit-variable-ref
    movl %eax, -16(%esp)  # stack save
# emit-expr f6611
# emit-variable-ref
# env=((f6611 . -12) (f6610 . -8) ((primitive-ref write-char) . 12) ((primitive-ref write-char) . 8) ((primitive-ref write-char) . 4) (f6562 . -28) (f6563 . -24) (f6564 . -20) (f6565 . -16) (f6566 . -12) (f6567 . -8) (f6568 . -4) (f6569 . 0))
# var=f6611
    movl -12(%esp), %eax  # stack load f6611
# end emit-variable-ref
    movl %eax, -20(%esp)  # stack save
# emit-tail-expr
# si=-24
# env=((f6611 . -20) (f6610 . -16) (f6611 . -12) (f6610 . -8) ((primitive-ref write-char) . 12) ((primitive-ref write-char) . 8) ((primitive-ref write-char) . 4) (f6562 . -28) (f6563 . -24) (f6564 . -20) (f6565 . -16) (f6566 . -12) (f6567 . -8) (f6568 . -4) (f6569 . 0))
# expr=(begin ((primitive-ref write-char) #\# f6611) (if f6610 ((primitive-ref write-char) #\t f6611) ((primitive-ref write-char) #\f f6611)))
# tail-begin (begin ((primitive-ref write-char) #\# f6611) (if f6610 ((primitive-ref write-char) #\t f6611) ((primitive-ref write-char) #\f f6611)))
#   env=((f6611 . -20) (f6610 . -16) (f6611 . -12) (f6610 . -8) ((primitive-ref write-char) . 12) ((primitive-ref write-char) . 8) ((primitive-ref write-char) . 4) (f6562 . -28) (f6563 . -24) (f6564 . -20) (f6565 . -16) (f6566 . -12) (f6567 . -8) (f6568 . -4) (f6569 . 0))
# emit-expr ((primitive-ref write-char) #\# f6611)
# funcall
#    si   =-24
#    env  = ((f6611 . -20) (f6610 . -16) (f6611 . -12) (f6610 . -8) ((primitive-ref write-char) . 12) ((primitive-ref write-char) . 8) ((primitive-ref write-char) . 4) (f6562 . -28) (f6563 . -24) (f6564 . -20) (f6565 . -16) (f6566 . -12) (f6567 . -8) (f6568 . -4) (f6569 . 0))
#    expr = (funcall (primitive-ref write-char) #\# f6611)
# emit-expr (primitive-ref write-char)
    .extern mrc_write$mchar
    movl mrc_write$mchar,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_40019"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_40019":
   movl %eax,  -32(%esp)  # stash funcall-oper in closure slot
# emit-expr #\#
    movl $8975, %eax     # immed #\#
    mov %eax, -36(%esp)  # arg #
# emit-expr f6611
# emit-variable-ref
# env=((f6611 . -20) (f6610 . -16) (f6611 . -12) (f6610 . -8) ((primitive-ref write-char) . 12) ((primitive-ref write-char) . 8) ((primitive-ref write-char) . 4) (f6562 . -28) (f6563 . -24) (f6564 . -20) (f6565 . -16) (f6566 . -12) (f6567 . -8) (f6568 . -4) (f6569 . 0))
# var=f6611
    movl -20(%esp), %eax  # stack load f6611
# end emit-variable-ref
    mov %eax, -40(%esp)  # arg f6611
    movl -32(%esp), %edi   # load new closure to %edi
    add $-24, %esp   # adjust base
    movl $8,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $24, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
# emit-tail-expr
# si=-24
# env=((f6611 . -20) (f6610 . -16) (f6611 . -12) (f6610 . -8) ((primitive-ref write-char) . 12) ((primitive-ref write-char) . 8) ((primitive-ref write-char) . 4) (f6562 . -28) (f6563 . -24) (f6564 . -20) (f6565 . -16) (f6566 . -12) (f6567 . -8) (f6568 . -4) (f6569 . 0))
# expr=(begin (if f6610 ((primitive-ref write-char) #\t f6611) ((primitive-ref write-char) #\f f6611)))
# tail-begin (begin (if f6610 ((primitive-ref write-char) #\t f6611) ((primitive-ref write-char) #\f f6611)))
#   env=((f6611 . -20) (f6610 . -16) (f6611 . -12) (f6610 . -8) ((primitive-ref write-char) . 12) ((primitive-ref write-char) . 8) ((primitive-ref write-char) . 4) (f6562 . -28) (f6563 . -24) (f6564 . -20) (f6565 . -16) (f6566 . -12) (f6567 . -8) (f6568 . -4) (f6569 . 0))
# emit-tail-expr
# si=-24
# env=((f6611 . -20) (f6610 . -16) (f6611 . -12) (f6610 . -8) ((primitive-ref write-char) . 12) ((primitive-ref write-char) . 8) ((primitive-ref write-char) . 4) (f6562 . -28) (f6563 . -24) (f6564 . -20) (f6565 . -16) (f6566 . -12) (f6567 . -8) (f6568 . -4) (f6569 . 0))
# expr=(if f6610 ((primitive-ref write-char) #\t f6611) ((primitive-ref write-char) #\f f6611))
# emit-expr f6610
# emit-variable-ref
# env=((f6611 . -20) (f6610 . -16) (f6611 . -12) (f6610 . -8) ((primitive-ref write-char) . 12) ((primitive-ref write-char) . 8) ((primitive-ref write-char) . 4) (f6562 . -28) (f6563 . -24) (f6564 . -20) (f6565 . -16) (f6566 . -12) (f6567 . -8) (f6568 . -4) (f6569 . 0))
# var=f6610
    movl -16(%esp), %eax  # stack load f6610
# end emit-variable-ref
    cmp $47, %al
    je _L_40020
# emit-tail-expr
# si=-24
# env=((f6611 . -20) (f6610 . -16) (f6611 . -12) (f6610 . -8) ((primitive-ref write-char) . 12) ((primitive-ref write-char) . 8) ((primitive-ref write-char) . 4) (f6562 . -28) (f6563 . -24) (f6564 . -20) (f6565 . -16) (f6566 . -12) (f6567 . -8) (f6568 . -4) (f6569 . 0))
# expr=((primitive-ref write-char) #\t f6611)
# emit-tail-funcall
#    si   =-24
#    env  = ((f6611 . -20) (f6610 . -16) (f6611 . -12) (f6610 . -8) ((primitive-ref write-char) . 12) ((primitive-ref write-char) . 8) ((primitive-ref write-char) . 4) (f6562 . -28) (f6563 . -24) (f6564 . -20) (f6565 . -16) (f6566 . -12) (f6567 . -8) (f6568 . -4) (f6569 . 0))
#    expr = (funcall (primitive-ref write-char) #\t f6611)
# emit-expr (primitive-ref write-char)
    .extern mrc_write$mchar
    movl mrc_write$mchar,%eax
   movl %eax,  -24(%esp)  # stash funcall-oper in next closure slot
# emit-expr #\t
    movl $29711, %eax     # immed #\t
    mov %eax, -28(%esp)    # arg t
# emit-expr f6611
# emit-variable-ref
# env=((f6611 . -20) (f6610 . -16) (f6611 . -12) (f6610 . -8) ((primitive-ref write-char) . 12) ((primitive-ref write-char) . 8) ((primitive-ref write-char) . 4) (f6562 . -28) (f6563 . -24) (f6564 . -20) (f6565 . -16) (f6566 . -12) (f6567 . -8) (f6568 . -4) (f6569 . 0))
# var=f6611
    movl -20(%esp), %eax  # stack load f6611
# end emit-variable-ref
    mov %eax, -32(%esp)    # arg f6611
    movl -24(%esp), %edi   # load new closure to %edi
# emit-shift-args:  size=3   si=-24  delta=20
    mov -24(%esp), %ebx  # shift frame cell
    mov %ebx, -4(%esp)  # down to base
# emit-shift-args:  size=2   si=-28  delta=20
    mov -28(%esp), %ebx  # shift frame cell
    mov %ebx, -8(%esp)  # down to base
# emit-shift-args:  size=1   si=-32  delta=20
    mov -32(%esp), %ebx  # shift frame cell
    mov %ebx, -12(%esp)  # down to base
# emit-shift-args:  size=0   si=-36  delta=20
    movl $8,%eax   # save arg count
    jmp *-2(%edi)  # tail-funcall
    jmp _L_40021
_L_40020:
# emit-tail-expr
# si=-24
# env=((f6611 . -20) (f6610 . -16) (f6611 . -12) (f6610 . -8) ((primitive-ref write-char) . 12) ((primitive-ref write-char) . 8) ((primitive-ref write-char) . 4) (f6562 . -28) (f6563 . -24) (f6564 . -20) (f6565 . -16) (f6566 . -12) (f6567 . -8) (f6568 . -4) (f6569 . 0))
# expr=((primitive-ref write-char) #\f f6611)
# emit-tail-funcall
#    si   =-24
#    env  = ((f6611 . -20) (f6610 . -16) (f6611 . -12) (f6610 . -8) ((primitive-ref write-char) . 12) ((primitive-ref write-char) . 8) ((primitive-ref write-char) . 4) (f6562 . -28) (f6563 . -24) (f6564 . -20) (f6565 . -16) (f6566 . -12) (f6567 . -8) (f6568 . -4) (f6569 . 0))
#    expr = (funcall (primitive-ref write-char) #\f f6611)
# emit-expr (primitive-ref write-char)
    .extern mrc_write$mchar
    movl mrc_write$mchar,%eax
   movl %eax,  -24(%esp)  # stash funcall-oper in next closure slot
# emit-expr #\f
    movl $26127, %eax     # immed #\f
    mov %eax, -28(%esp)    # arg f
# emit-expr f6611
# emit-variable-ref
# env=((f6611 . -20) (f6610 . -16) (f6611 . -12) (f6610 . -8) ((primitive-ref write-char) . 12) ((primitive-ref write-char) . 8) ((primitive-ref write-char) . 4) (f6562 . -28) (f6563 . -24) (f6564 . -20) (f6565 . -16) (f6566 . -12) (f6567 . -8) (f6568 . -4) (f6569 . 0))
# var=f6611
    movl -20(%esp), %eax  # stack load f6611
# end emit-variable-ref
    mov %eax, -32(%esp)    # arg f6611
    movl -24(%esp), %edi   # load new closure to %edi
# emit-shift-args:  size=3   si=-24  delta=20
    mov -24(%esp), %ebx  # shift frame cell
    mov %ebx, -4(%esp)  # down to base
# emit-shift-args:  size=2   si=-28  delta=20
    mov -28(%esp), %ebx  # shift frame cell
    mov %ebx, -8(%esp)  # down to base
# emit-shift-args:  size=1   si=-32  delta=20
    mov -32(%esp), %ebx  # shift frame cell
    mov %ebx, -12(%esp)  # down to base
# emit-shift-args:  size=0   si=-36  delta=20
    movl $8,%eax   # save arg count
    jmp *-2(%edi)  # tail-funcall
_L_40021:
     ret   # return thru stack
    .align 4,0x90
_L_40017:
    movl -32(%esp), %ebx
    movl -36(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin (vector-set! f6568 0 (closure (f6609) ((primitive-ref write-char) (primitive-ref write-char)) (let ((f6609 f6609)) (begin ((primitive-ref write-char) #\( f6609) ((primitive-ref write-char) #\) f6609))))) (vector-set! f6567 0 (closure (f6607 f6608) ((primitive-ref write-char) (primitive-ref write-char) (primitive-ref write-char)) (let ((f6607 f6607) (f6608 f6608)) (begin ((primitive-ref write-char) #\# f6608) ((primitive-ref write-char) #\\ f6608) ((primitive-ref write-char) f6607 f6608))))) (vector-set! f6566 0 (closure (f6603 f6604) ((primitive-ref negative?) (primitive-ref write-char) f6566 (primitive-ref map) (primitive-ref write-char) (primitive-ref integer->list)) (let ((f6603 f6603) (f6604 f6604)) (if ((primitive-ref negative?) f6603) (begin ((primitive-ref write-char) #\- f6604) ((vector-ref f6566 0) (fx* -1 f6603) f6604)) ((primitive-ref map) (closure (f6606) ((primitive-ref write-char) f6604) (let ((f6606 f6606)) ((primitive-ref write-char) (fixnum->char (fx+ (char->fixnum #\0) f6606)) f6604))) ((primitive-ref integer->list) f6603)))))) (vector-set! f6565 0 (closure (f6599 f6600) ((primitive-ref write-char) (primitive-ref for-each) (primitive-ref write-char) (primitive-ref string->list) (primitive-ref write-char)) (let ((f6599 f6599) (f6600 f6600)) (begin ((primitive-ref write-char) #\" f6600) ((primitive-ref for-each) (closure (f6602) ((primitive-ref write-char) f6600) (let ((f6602 f6602)) ((primitive-ref write-char) f6602 f6600))) ((primitive-ref string->list) f6599)) ((primitive-ref write-char) #\" f6600))))) (vector-set! f6564 0 (closure (f6595 f6596) ((primitive-ref for-each) (primitive-ref write-char) (primitive-ref string->list)) (let ((f6595 f6595) (f6596 f6596)) ((primitive-ref for-each) (closure (f6598) ((primitive-ref write-char) f6596) (let ((f6598 f6598)) ((primitive-ref write-char) f6598 f6596))) ((primitive-ref string->list) f6595))))) (vector-set! f6563 0 (closure (f6593 f6594) ((primitive-ref write-char) f6562 (primitive-ref write-char)) (let ((f6593 f6593) (f6594 f6594)) (begin ((primitive-ref write-char) #\( f6594) ((vector-ref f6562 0) f6593 f6594) ((primitive-ref write-char) #\) f6594))))) (vector-set! f6562 0 (closure (f6591 f6592) ((primitive-ref write) (primitive-ref write-char) f6562 else (primitive-ref write-char) (primitive-ref write-char) (primitive-ref write-char) (primitive-ref write)) (let ((f6591 f6591) (f6592 f6592)) (begin ((primitive-ref write) (car f6591) f6592) (if (null? (cdr f6591)) #t (if (pair? (cdr f6591)) (begin ((primitive-ref write-char) #\space f6592) ((vector-ref f6562 0) (cdr f6591) f6592)) (begin ((primitive-ref write-char) #\space f6592) ((primitive-ref write-char) #\. f6592) ((primitive-ref write-char) #\space f6592) ((primitive-ref write) (cdr f6591) f6592)))))))))
# emit-begin
#   expr=(begin (vector-set! f6568 0 (closure (f6609) ((primitive-ref write-char) (primitive-ref write-char)) (let ((f6609 f6609)) (begin ((primitive-ref write-char) #\( f6609) ((primitive-ref write-char) #\) f6609))))) (vector-set! f6567 0 (closure (f6607 f6608) ((primitive-ref write-char) (primitive-ref write-char) (primitive-ref write-char)) (let ((f6607 f6607) (f6608 f6608)) (begin ((primitive-ref write-char) #\# f6608) ((primitive-ref write-char) #\\ f6608) ((primitive-ref write-char) f6607 f6608))))) (vector-set! f6566 0 (closure (f6603 f6604) ((primitive-ref negative?) (primitive-ref write-char) f6566 (primitive-ref map) (primitive-ref write-char) (primitive-ref integer->list)) (let ((f6603 f6603) (f6604 f6604)) (if ((primitive-ref negative?) f6603) (begin ((primitive-ref write-char) #\- f6604) ((vector-ref f6566 0) (fx* -1 f6603) f6604)) ((primitive-ref map) (closure (f6606) ((primitive-ref write-char) f6604) (let ((f6606 f6606)) ((primitive-ref write-char) (fixnum->char (fx+ (char->fixnum #\0) f6606)) f6604))) ((primitive-ref integer->list) f6603)))))) (vector-set! f6565 0 (closure (f6599 f6600) ((primitive-ref write-char) (primitive-ref for-each) (primitive-ref write-char) (primitive-ref string->list) (primitive-ref write-char)) (let ((f6599 f6599) (f6600 f6600)) (begin ((primitive-ref write-char) #\" f6600) ((primitive-ref for-each) (closure (f6602) ((primitive-ref write-char) f6600) (let ((f6602 f6602)) ((primitive-ref write-char) f6602 f6600))) ((primitive-ref string->list) f6599)) ((primitive-ref write-char) #\" f6600))))) (vector-set! f6564 0 (closure (f6595 f6596) ((primitive-ref for-each) (primitive-ref write-char) (primitive-ref string->list)) (let ((f6595 f6595) (f6596 f6596)) ((primitive-ref for-each) (closure (f6598) ((primitive-ref write-char) f6596) (let ((f6598 f6598)) ((primitive-ref write-char) f6598 f6596))) ((primitive-ref string->list) f6595))))) (vector-set! f6563 0 (closure (f6593 f6594) ((primitive-ref write-char) f6562 (primitive-ref write-char)) (let ((f6593 f6593) (f6594 f6594)) (begin ((primitive-ref write-char) #\( f6594) ((vector-ref f6562 0) f6593 f6594) ((primitive-ref write-char) #\) f6594))))) (vector-set! f6562 0 (closure (f6591 f6592) ((primitive-ref write) (primitive-ref write-char) f6562 else (primitive-ref write-char) (primitive-ref write-char) (primitive-ref write-char) (primitive-ref write)) (let ((f6591 f6591) (f6592 f6592)) (begin ((primitive-ref write) (car f6591) f6592) (if (null? (cdr f6591)) #t (if (pair? (cdr f6591)) (begin ((primitive-ref write-char) #\space f6592) ((vector-ref f6562 0) (cdr f6591) f6592)) (begin ((primitive-ref write-char) #\space f6592) ((primitive-ref write-char) #\. f6592) ((primitive-ref write-char) #\space f6592) ((primitive-ref write) (cdr f6591) f6592)))))))))
#   env=((f6562 . -28) (f6563 . -24) (f6564 . -20) (f6565 . -16) (f6566 . -12) (f6567 . -8) (f6568 . -4) (f6569 . 0))
# emit-expr (vector-set! f6568 0 (closure (f6609) ((primitive-ref write-char) (primitive-ref write-char)) (let ((f6609 f6609)) (begin ((primitive-ref write-char) #\( f6609) ((primitive-ref write-char) #\) f6609)))))
# emit-expr f6568
# emit-variable-ref
# env=((f6562 . -28) (f6563 . -24) (f6564 . -20) (f6565 . -16) (f6566 . -12) (f6567 . -8) (f6568 . -4) (f6569 . 0))
# var=f6568
    movl -4(%esp), %eax  # stack load f6568
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_40022
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_40022:
    movl %eax, -32(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_40023"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_40023:
# check bounds on vector index
    movl -32(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_40025
    cmp  $0,%eax
    jge _L_40024
_L_40025:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_40024:
    movl %eax, -36(%esp)
# emit-expr (closure (f6609) ((primitive-ref write-char) (primitive-ref write-char)) (let ((f6609 f6609)) (begin ((primitive-ref write-char) #\( f6609) ((primitive-ref write-char) #\) f6609))))
# emit-closure
# si = -40
# env = ((f6562 . -28) (f6563 . -24) (f6564 . -20) (f6565 . -16) (f6566 . -12) (f6567 . -8) (f6568 . -4) (f6569 . 0))
# expr = (closure (f6609) ((primitive-ref write-char) (primitive-ref write-char)) (let ((f6609 f6609)) (begin ((primitive-ref write-char) #\( f6609) ((primitive-ref write-char) #\) f6609))))
    movl $_L_40026, 0(%ebp)  # closure label
# WARNING: free var (primitive-ref write-char) not defined in the environmnet
# WARNING: free var (primitive-ref write-char) not defined in the environmnet
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $16, %ebp     # bump ebp
    jmp _L_40027            # jump around closure body
_L_40026:
# check argument count
    cmp $4,%eax
    je _L_40028
# invoke error handler eh_argcount
    .extern mrc_eh$uargcount
    movl mrc_eh$uargcount, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_40028:
# emit-tail-expr
# si=-12
# env=((f6609 . -8) ((primitive-ref write-char) . 8) ((primitive-ref write-char) . 4) (f6562 . -28) (f6563 . -24) (f6564 . -20) (f6565 . -16) (f6566 . -12) (f6567 . -8) (f6568 . -4) (f6569 . 0))
# expr=(let ((f6609 f6609)) (begin ((primitive-ref write-char) #\( f6609) ((primitive-ref write-char) #\) f6609)))
# emit-tail-let
#  si   = -12
#  env  = ((f6609 . -8) ((primitive-ref write-char) . 8) ((primitive-ref write-char) . 4) (f6562 . -28) (f6563 . -24) (f6564 . -20) (f6565 . -16) (f6566 . -12) (f6567 . -8) (f6568 . -4) (f6569 . 0))
#  bindings = ((f6609 f6609))
#  body = (begin ((primitive-ref write-char) #\( f6609) ((primitive-ref write-char) #\) f6609))
# emit-expr f6609
# emit-variable-ref
# env=((f6609 . -8) ((primitive-ref write-char) . 8) ((primitive-ref write-char) . 4) (f6562 . -28) (f6563 . -24) (f6564 . -20) (f6565 . -16) (f6566 . -12) (f6567 . -8) (f6568 . -4) (f6569 . 0))
# var=f6609
    movl -8(%esp), %eax  # stack load f6609
# end emit-variable-ref
    movl %eax, -12(%esp)  # stack save
# emit-tail-expr
# si=-16
# env=((f6609 . -12) (f6609 . -8) ((primitive-ref write-char) . 8) ((primitive-ref write-char) . 4) (f6562 . -28) (f6563 . -24) (f6564 . -20) (f6565 . -16) (f6566 . -12) (f6567 . -8) (f6568 . -4) (f6569 . 0))
# expr=(begin ((primitive-ref write-char) #\( f6609) ((primitive-ref write-char) #\) f6609))
# tail-begin (begin ((primitive-ref write-char) #\( f6609) ((primitive-ref write-char) #\) f6609))
#   env=((f6609 . -12) (f6609 . -8) ((primitive-ref write-char) . 8) ((primitive-ref write-char) . 4) (f6562 . -28) (f6563 . -24) (f6564 . -20) (f6565 . -16) (f6566 . -12) (f6567 . -8) (f6568 . -4) (f6569 . 0))
# emit-expr ((primitive-ref write-char) #\( f6609)
# funcall
#    si   =-16
#    env  = ((f6609 . -12) (f6609 . -8) ((primitive-ref write-char) . 8) ((primitive-ref write-char) . 4) (f6562 . -28) (f6563 . -24) (f6564 . -20) (f6565 . -16) (f6566 . -12) (f6567 . -8) (f6568 . -4) (f6569 . 0))
#    expr = (funcall (primitive-ref write-char) #\( f6609)
# emit-expr (primitive-ref write-char)
    .extern mrc_write$mchar
    movl mrc_write$mchar,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_40029"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_40029":
   movl %eax,  -24(%esp)  # stash funcall-oper in closure slot
# emit-expr #\(
    movl $10255, %eax     # immed #\(
    mov %eax, -28(%esp)  # arg (
# emit-expr f6609
# emit-variable-ref
# env=((f6609 . -12) (f6609 . -8) ((primitive-ref write-char) . 8) ((primitive-ref write-char) . 4) (f6562 . -28) (f6563 . -24) (f6564 . -20) (f6565 . -16) (f6566 . -12) (f6567 . -8) (f6568 . -4) (f6569 . 0))
# var=f6609
    movl -12(%esp), %eax  # stack load f6609
# end emit-variable-ref
    mov %eax, -32(%esp)  # arg f6609
    movl -24(%esp), %edi   # load new closure to %edi
    add $-16, %esp   # adjust base
    movl $8,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $16, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
# emit-tail-expr
# si=-16
# env=((f6609 . -12) (f6609 . -8) ((primitive-ref write-char) . 8) ((primitive-ref write-char) . 4) (f6562 . -28) (f6563 . -24) (f6564 . -20) (f6565 . -16) (f6566 . -12) (f6567 . -8) (f6568 . -4) (f6569 . 0))
# expr=(begin ((primitive-ref write-char) #\) f6609))
# tail-begin (begin ((primitive-ref write-char) #\) f6609))
#   env=((f6609 . -12) (f6609 . -8) ((primitive-ref write-char) . 8) ((primitive-ref write-char) . 4) (f6562 . -28) (f6563 . -24) (f6564 . -20) (f6565 . -16) (f6566 . -12) (f6567 . -8) (f6568 . -4) (f6569 . 0))
# emit-tail-expr
# si=-16
# env=((f6609 . -12) (f6609 . -8) ((primitive-ref write-char) . 8) ((primitive-ref write-char) . 4) (f6562 . -28) (f6563 . -24) (f6564 . -20) (f6565 . -16) (f6566 . -12) (f6567 . -8) (f6568 . -4) (f6569 . 0))
# expr=((primitive-ref write-char) #\) f6609)
# emit-tail-funcall
#    si   =-16
#    env  = ((f6609 . -12) (f6609 . -8) ((primitive-ref write-char) . 8) ((primitive-ref write-char) . 4) (f6562 . -28) (f6563 . -24) (f6564 . -20) (f6565 . -16) (f6566 . -12) (f6567 . -8) (f6568 . -4) (f6569 . 0))
#    expr = (funcall (primitive-ref write-char) #\) f6609)
# emit-expr (primitive-ref write-char)
    .extern mrc_write$mchar
    movl mrc_write$mchar,%eax
   movl %eax,  -16(%esp)  # stash funcall-oper in next closure slot
# emit-expr #\)
    movl $10511, %eax     # immed #\)
    mov %eax, -20(%esp)    # arg )
# emit-expr f6609
# emit-variable-ref
# env=((f6609 . -12) (f6609 . -8) ((primitive-ref write-char) . 8) ((primitive-ref write-char) . 4) (f6562 . -28) (f6563 . -24) (f6564 . -20) (f6565 . -16) (f6566 . -12) (f6567 . -8) (f6568 . -4) (f6569 . 0))
# var=f6609
    movl -12(%esp), %eax  # stack load f6609
# end emit-variable-ref
    mov %eax, -24(%esp)    # arg f6609
    movl -16(%esp), %edi   # load new closure to %edi
# emit-shift-args:  size=3   si=-16  delta=12
    mov -16(%esp), %ebx  # shift frame cell
    mov %ebx, -4(%esp)  # down to base
# emit-shift-args:  size=2   si=-20  delta=12
    mov -20(%esp), %ebx  # shift frame cell
    mov %ebx, -8(%esp)  # down to base
# emit-shift-args:  size=1   si=-24  delta=12
    mov -24(%esp), %ebx  # shift frame cell
    mov %ebx, -12(%esp)  # down to base
# emit-shift-args:  size=0   si=-28  delta=12
    movl $8,%eax   # save arg count
    jmp *-2(%edi)  # tail-funcall
     ret   # return thru stack
    .align 4,0x90
_L_40027:
    movl -32(%esp), %ebx
    movl -36(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin (vector-set! f6567 0 (closure (f6607 f6608) ((primitive-ref write-char) (primitive-ref write-char) (primitive-ref write-char)) (let ((f6607 f6607) (f6608 f6608)) (begin ((primitive-ref write-char) #\# f6608) ((primitive-ref write-char) #\\ f6608) ((primitive-ref write-char) f6607 f6608))))) (vector-set! f6566 0 (closure (f6603 f6604) ((primitive-ref negative?) (primitive-ref write-char) f6566 (primitive-ref map) (primitive-ref write-char) (primitive-ref integer->list)) (let ((f6603 f6603) (f6604 f6604)) (if ((primitive-ref negative?) f6603) (begin ((primitive-ref write-char) #\- f6604) ((vector-ref f6566 0) (fx* -1 f6603) f6604)) ((primitive-ref map) (closure (f6606) ((primitive-ref write-char) f6604) (let ((f6606 f6606)) ((primitive-ref write-char) (fixnum->char (fx+ (char->fixnum #\0) f6606)) f6604))) ((primitive-ref integer->list) f6603)))))) (vector-set! f6565 0 (closure (f6599 f6600) ((primitive-ref write-char) (primitive-ref for-each) (primitive-ref write-char) (primitive-ref string->list) (primitive-ref write-char)) (let ((f6599 f6599) (f6600 f6600)) (begin ((primitive-ref write-char) #\" f6600) ((primitive-ref for-each) (closure (f6602) ((primitive-ref write-char) f6600) (let ((f6602 f6602)) ((primitive-ref write-char) f6602 f6600))) ((primitive-ref string->list) f6599)) ((primitive-ref write-char) #\" f6600))))) (vector-set! f6564 0 (closure (f6595 f6596) ((primitive-ref for-each) (primitive-ref write-char) (primitive-ref string->list)) (let ((f6595 f6595) (f6596 f6596)) ((primitive-ref for-each) (closure (f6598) ((primitive-ref write-char) f6596) (let ((f6598 f6598)) ((primitive-ref write-char) f6598 f6596))) ((primitive-ref string->list) f6595))))) (vector-set! f6563 0 (closure (f6593 f6594) ((primitive-ref write-char) f6562 (primitive-ref write-char)) (let ((f6593 f6593) (f6594 f6594)) (begin ((primitive-ref write-char) #\( f6594) ((vector-ref f6562 0) f6593 f6594) ((primitive-ref write-char) #\) f6594))))) (vector-set! f6562 0 (closure (f6591 f6592) ((primitive-ref write) (primitive-ref write-char) f6562 else (primitive-ref write-char) (primitive-ref write-char) (primitive-ref write-char) (primitive-ref write)) (let ((f6591 f6591) (f6592 f6592)) (begin ((primitive-ref write) (car f6591) f6592) (if (null? (cdr f6591)) #t (if (pair? (cdr f6591)) (begin ((primitive-ref write-char) #\space f6592) ((vector-ref f6562 0) (cdr f6591) f6592)) (begin ((primitive-ref write-char) #\space f6592) ((primitive-ref write-char) #\. f6592) ((primitive-ref write-char) #\space f6592) ((primitive-ref write) (cdr f6591) f6592)))))))))
# emit-begin
#   expr=(begin (vector-set! f6567 0 (closure (f6607 f6608) ((primitive-ref write-char) (primitive-ref write-char) (primitive-ref write-char)) (let ((f6607 f6607) (f6608 f6608)) (begin ((primitive-ref write-char) #\# f6608) ((primitive-ref write-char) #\\ f6608) ((primitive-ref write-char) f6607 f6608))))) (vector-set! f6566 0 (closure (f6603 f6604) ((primitive-ref negative?) (primitive-ref write-char) f6566 (primitive-ref map) (primitive-ref write-char) (primitive-ref integer->list)) (let ((f6603 f6603) (f6604 f6604)) (if ((primitive-ref negative?) f6603) (begin ((primitive-ref write-char) #\- f6604) ((vector-ref f6566 0) (fx* -1 f6603) f6604)) ((primitive-ref map) (closure (f6606) ((primitive-ref write-char) f6604) (let ((f6606 f6606)) ((primitive-ref write-char) (fixnum->char (fx+ (char->fixnum #\0) f6606)) f6604))) ((primitive-ref integer->list) f6603)))))) (vector-set! f6565 0 (closure (f6599 f6600) ((primitive-ref write-char) (primitive-ref for-each) (primitive-ref write-char) (primitive-ref string->list) (primitive-ref write-char)) (let ((f6599 f6599) (f6600 f6600)) (begin ((primitive-ref write-char) #\" f6600) ((primitive-ref for-each) (closure (f6602) ((primitive-ref write-char) f6600) (let ((f6602 f6602)) ((primitive-ref write-char) f6602 f6600))) ((primitive-ref string->list) f6599)) ((primitive-ref write-char) #\" f6600))))) (vector-set! f6564 0 (closure (f6595 f6596) ((primitive-ref for-each) (primitive-ref write-char) (primitive-ref string->list)) (let ((f6595 f6595) (f6596 f6596)) ((primitive-ref for-each) (closure (f6598) ((primitive-ref write-char) f6596) (let ((f6598 f6598)) ((primitive-ref write-char) f6598 f6596))) ((primitive-ref string->list) f6595))))) (vector-set! f6563 0 (closure (f6593 f6594) ((primitive-ref write-char) f6562 (primitive-ref write-char)) (let ((f6593 f6593) (f6594 f6594)) (begin ((primitive-ref write-char) #\( f6594) ((vector-ref f6562 0) f6593 f6594) ((primitive-ref write-char) #\) f6594))))) (vector-set! f6562 0 (closure (f6591 f6592) ((primitive-ref write) (primitive-ref write-char) f6562 else (primitive-ref write-char) (primitive-ref write-char) (primitive-ref write-char) (primitive-ref write)) (let ((f6591 f6591) (f6592 f6592)) (begin ((primitive-ref write) (car f6591) f6592) (if (null? (cdr f6591)) #t (if (pair? (cdr f6591)) (begin ((primitive-ref write-char) #\space f6592) ((vector-ref f6562 0) (cdr f6591) f6592)) (begin ((primitive-ref write-char) #\space f6592) ((primitive-ref write-char) #\. f6592) ((primitive-ref write-char) #\space f6592) ((primitive-ref write) (cdr f6591) f6592)))))))))
#   env=((f6562 . -28) (f6563 . -24) (f6564 . -20) (f6565 . -16) (f6566 . -12) (f6567 . -8) (f6568 . -4) (f6569 . 0))
# emit-expr (vector-set! f6567 0 (closure (f6607 f6608) ((primitive-ref write-char) (primitive-ref write-char) (primitive-ref write-char)) (let ((f6607 f6607) (f6608 f6608)) (begin ((primitive-ref write-char) #\# f6608) ((primitive-ref write-char) #\\ f6608) ((primitive-ref write-char) f6607 f6608)))))
# emit-expr f6567
# emit-variable-ref
# env=((f6562 . -28) (f6563 . -24) (f6564 . -20) (f6565 . -16) (f6566 . -12) (f6567 . -8) (f6568 . -4) (f6569 . 0))
# var=f6567
    movl -8(%esp), %eax  # stack load f6567
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_40030
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_40030:
    movl %eax, -32(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_40031"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_40031:
# check bounds on vector index
    movl -32(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_40033
    cmp  $0,%eax
    jge _L_40032
_L_40033:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_40032:
    movl %eax, -36(%esp)
# emit-expr (closure (f6607 f6608) ((primitive-ref write-char) (primitive-ref write-char) (primitive-ref write-char)) (let ((f6607 f6607) (f6608 f6608)) (begin ((primitive-ref write-char) #\# f6608) ((primitive-ref write-char) #\\ f6608) ((primitive-ref write-char) f6607 f6608))))
# emit-closure
# si = -40
# env = ((f6562 . -28) (f6563 . -24) (f6564 . -20) (f6565 . -16) (f6566 . -12) (f6567 . -8) (f6568 . -4) (f6569 . 0))
# expr = (closure (f6607 f6608) ((primitive-ref write-char) (primitive-ref write-char) (primitive-ref write-char)) (let ((f6607 f6607) (f6608 f6608)) (begin ((primitive-ref write-char) #\# f6608) ((primitive-ref write-char) #\\ f6608) ((primitive-ref write-char) f6607 f6608))))
    movl $_L_40034, 0(%ebp)  # closure label
# WARNING: free var (primitive-ref write-char) not defined in the environmnet
# WARNING: free var (primitive-ref write-char) not defined in the environmnet
# WARNING: free var (primitive-ref write-char) not defined in the environmnet
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $16, %ebp     # bump ebp
    jmp _L_40035            # jump around closure body
_L_40034:
# check argument count
    cmp $8,%eax
    je _L_40036
# invoke error handler eh_argcount
    .extern mrc_eh$uargcount
    movl mrc_eh$uargcount, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_40036:
# emit-tail-expr
# si=-16
# env=((f6608 . -12) (f6607 . -8) ((primitive-ref write-char) . 12) ((primitive-ref write-char) . 8) ((primitive-ref write-char) . 4) (f6562 . -28) (f6563 . -24) (f6564 . -20) (f6565 . -16) (f6566 . -12) (f6567 . -8) (f6568 . -4) (f6569 . 0))
# expr=(let ((f6607 f6607) (f6608 f6608)) (begin ((primitive-ref write-char) #\# f6608) ((primitive-ref write-char) #\\ f6608) ((primitive-ref write-char) f6607 f6608)))
# emit-tail-let
#  si   = -16
#  env  = ((f6608 . -12) (f6607 . -8) ((primitive-ref write-char) . 12) ((primitive-ref write-char) . 8) ((primitive-ref write-char) . 4) (f6562 . -28) (f6563 . -24) (f6564 . -20) (f6565 . -16) (f6566 . -12) (f6567 . -8) (f6568 . -4) (f6569 . 0))
#  bindings = ((f6607 f6607) (f6608 f6608))
#  body = (begin ((primitive-ref write-char) #\# f6608) ((primitive-ref write-char) #\\ f6608) ((primitive-ref write-char) f6607 f6608))
# emit-expr f6607
# emit-variable-ref
# env=((f6608 . -12) (f6607 . -8) ((primitive-ref write-char) . 12) ((primitive-ref write-char) . 8) ((primitive-ref write-char) . 4) (f6562 . -28) (f6563 . -24) (f6564 . -20) (f6565 . -16) (f6566 . -12) (f6567 . -8) (f6568 . -4) (f6569 . 0))
# var=f6607
    movl -8(%esp), %eax  # stack load f6607
# end emit-variable-ref
    movl %eax, -16(%esp)  # stack save
# emit-expr f6608
# emit-variable-ref
# env=((f6608 . -12) (f6607 . -8) ((primitive-ref write-char) . 12) ((primitive-ref write-char) . 8) ((primitive-ref write-char) . 4) (f6562 . -28) (f6563 . -24) (f6564 . -20) (f6565 . -16) (f6566 . -12) (f6567 . -8) (f6568 . -4) (f6569 . 0))
# var=f6608
    movl -12(%esp), %eax  # stack load f6608
# end emit-variable-ref
    movl %eax, -20(%esp)  # stack save
# emit-tail-expr
# si=-24
# env=((f6608 . -20) (f6607 . -16) (f6608 . -12) (f6607 . -8) ((primitive-ref write-char) . 12) ((primitive-ref write-char) . 8) ((primitive-ref write-char) . 4) (f6562 . -28) (f6563 . -24) (f6564 . -20) (f6565 . -16) (f6566 . -12) (f6567 . -8) (f6568 . -4) (f6569 . 0))
# expr=(begin ((primitive-ref write-char) #\# f6608) ((primitive-ref write-char) #\\ f6608) ((primitive-ref write-char) f6607 f6608))
# tail-begin (begin ((primitive-ref write-char) #\# f6608) ((primitive-ref write-char) #\\ f6608) ((primitive-ref write-char) f6607 f6608))
#   env=((f6608 . -20) (f6607 . -16) (f6608 . -12) (f6607 . -8) ((primitive-ref write-char) . 12) ((primitive-ref write-char) . 8) ((primitive-ref write-char) . 4) (f6562 . -28) (f6563 . -24) (f6564 . -20) (f6565 . -16) (f6566 . -12) (f6567 . -8) (f6568 . -4) (f6569 . 0))
# emit-expr ((primitive-ref write-char) #\# f6608)
# funcall
#    si   =-24
#    env  = ((f6608 . -20) (f6607 . -16) (f6608 . -12) (f6607 . -8) ((primitive-ref write-char) . 12) ((primitive-ref write-char) . 8) ((primitive-ref write-char) . 4) (f6562 . -28) (f6563 . -24) (f6564 . -20) (f6565 . -16) (f6566 . -12) (f6567 . -8) (f6568 . -4) (f6569 . 0))
#    expr = (funcall (primitive-ref write-char) #\# f6608)
# emit-expr (primitive-ref write-char)
    .extern mrc_write$mchar
    movl mrc_write$mchar,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_40037"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_40037":
   movl %eax,  -32(%esp)  # stash funcall-oper in closure slot
# emit-expr #\#
    movl $8975, %eax     # immed #\#
    mov %eax, -36(%esp)  # arg #
# emit-expr f6608
# emit-variable-ref
# env=((f6608 . -20) (f6607 . -16) (f6608 . -12) (f6607 . -8) ((primitive-ref write-char) . 12) ((primitive-ref write-char) . 8) ((primitive-ref write-char) . 4) (f6562 . -28) (f6563 . -24) (f6564 . -20) (f6565 . -16) (f6566 . -12) (f6567 . -8) (f6568 . -4) (f6569 . 0))
# var=f6608
    movl -20(%esp), %eax  # stack load f6608
# end emit-variable-ref
    mov %eax, -40(%esp)  # arg f6608
    movl -32(%esp), %edi   # load new closure to %edi
    add $-24, %esp   # adjust base
    movl $8,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $24, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
# emit-tail-expr
# si=-24
# env=((f6608 . -20) (f6607 . -16) (f6608 . -12) (f6607 . -8) ((primitive-ref write-char) . 12) ((primitive-ref write-char) . 8) ((primitive-ref write-char) . 4) (f6562 . -28) (f6563 . -24) (f6564 . -20) (f6565 . -16) (f6566 . -12) (f6567 . -8) (f6568 . -4) (f6569 . 0))
# expr=(begin ((primitive-ref write-char) #\\ f6608) ((primitive-ref write-char) f6607 f6608))
# tail-begin (begin ((primitive-ref write-char) #\\ f6608) ((primitive-ref write-char) f6607 f6608))
#   env=((f6608 . -20) (f6607 . -16) (f6608 . -12) (f6607 . -8) ((primitive-ref write-char) . 12) ((primitive-ref write-char) . 8) ((primitive-ref write-char) . 4) (f6562 . -28) (f6563 . -24) (f6564 . -20) (f6565 . -16) (f6566 . -12) (f6567 . -8) (f6568 . -4) (f6569 . 0))
# emit-expr ((primitive-ref write-char) #\\ f6608)
# funcall
#    si   =-24
#    env  = ((f6608 . -20) (f6607 . -16) (f6608 . -12) (f6607 . -8) ((primitive-ref write-char) . 12) ((primitive-ref write-char) . 8) ((primitive-ref write-char) . 4) (f6562 . -28) (f6563 . -24) (f6564 . -20) (f6565 . -16) (f6566 . -12) (f6567 . -8) (f6568 . -4) (f6569 . 0))
#    expr = (funcall (primitive-ref write-char) #\\ f6608)
# emit-expr (primitive-ref write-char)
    .extern mrc_write$mchar
    movl mrc_write$mchar,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_40038"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_40038":
   movl %eax,  -32(%esp)  # stash funcall-oper in closure slot
# emit-expr #\\
    movl $23567, %eax     # immed #\\
    mov %eax, -36(%esp)  # arg \
# emit-expr f6608
# emit-variable-ref
# env=((f6608 . -20) (f6607 . -16) (f6608 . -12) (f6607 . -8) ((primitive-ref write-char) . 12) ((primitive-ref write-char) . 8) ((primitive-ref write-char) . 4) (f6562 . -28) (f6563 . -24) (f6564 . -20) (f6565 . -16) (f6566 . -12) (f6567 . -8) (f6568 . -4) (f6569 . 0))
# var=f6608
    movl -20(%esp), %eax  # stack load f6608
# end emit-variable-ref
    mov %eax, -40(%esp)  # arg f6608
    movl -32(%esp), %edi   # load new closure to %edi
    add $-24, %esp   # adjust base
    movl $8,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $24, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
# emit-tail-expr
# si=-24
# env=((f6608 . -20) (f6607 . -16) (f6608 . -12) (f6607 . -8) ((primitive-ref write-char) . 12) ((primitive-ref write-char) . 8) ((primitive-ref write-char) . 4) (f6562 . -28) (f6563 . -24) (f6564 . -20) (f6565 . -16) (f6566 . -12) (f6567 . -8) (f6568 . -4) (f6569 . 0))
# expr=(begin ((primitive-ref write-char) f6607 f6608))
# tail-begin (begin ((primitive-ref write-char) f6607 f6608))
#   env=((f6608 . -20) (f6607 . -16) (f6608 . -12) (f6607 . -8) ((primitive-ref write-char) . 12) ((primitive-ref write-char) . 8) ((primitive-ref write-char) . 4) (f6562 . -28) (f6563 . -24) (f6564 . -20) (f6565 . -16) (f6566 . -12) (f6567 . -8) (f6568 . -4) (f6569 . 0))
# emit-tail-expr
# si=-24
# env=((f6608 . -20) (f6607 . -16) (f6608 . -12) (f6607 . -8) ((primitive-ref write-char) . 12) ((primitive-ref write-char) . 8) ((primitive-ref write-char) . 4) (f6562 . -28) (f6563 . -24) (f6564 . -20) (f6565 . -16) (f6566 . -12) (f6567 . -8) (f6568 . -4) (f6569 . 0))
# expr=((primitive-ref write-char) f6607 f6608)
# emit-tail-funcall
#    si   =-24
#    env  = ((f6608 . -20) (f6607 . -16) (f6608 . -12) (f6607 . -8) ((primitive-ref write-char) . 12) ((primitive-ref write-char) . 8) ((primitive-ref write-char) . 4) (f6562 . -28) (f6563 . -24) (f6564 . -20) (f6565 . -16) (f6566 . -12) (f6567 . -8) (f6568 . -4) (f6569 . 0))
#    expr = (funcall (primitive-ref write-char) f6607 f6608)
# emit-expr (primitive-ref write-char)
    .extern mrc_write$mchar
    movl mrc_write$mchar,%eax
   movl %eax,  -24(%esp)  # stash funcall-oper in next closure slot
# emit-expr f6607
# emit-variable-ref
# env=((f6608 . -20) (f6607 . -16) (f6608 . -12) (f6607 . -8) ((primitive-ref write-char) . 12) ((primitive-ref write-char) . 8) ((primitive-ref write-char) . 4) (f6562 . -28) (f6563 . -24) (f6564 . -20) (f6565 . -16) (f6566 . -12) (f6567 . -8) (f6568 . -4) (f6569 . 0))
# var=f6607
    movl -16(%esp), %eax  # stack load f6607
# end emit-variable-ref
    mov %eax, -28(%esp)    # arg f6607
# emit-expr f6608
# emit-variable-ref
# env=((f6608 . -20) (f6607 . -16) (f6608 . -12) (f6607 . -8) ((primitive-ref write-char) . 12) ((primitive-ref write-char) . 8) ((primitive-ref write-char) . 4) (f6562 . -28) (f6563 . -24) (f6564 . -20) (f6565 . -16) (f6566 . -12) (f6567 . -8) (f6568 . -4) (f6569 . 0))
# var=f6608
    movl -20(%esp), %eax  # stack load f6608
# end emit-variable-ref
    mov %eax, -32(%esp)    # arg f6608
    movl -24(%esp), %edi   # load new closure to %edi
# emit-shift-args:  size=3   si=-24  delta=20
    mov -24(%esp), %ebx  # shift frame cell
    mov %ebx, -4(%esp)  # down to base
# emit-shift-args:  size=2   si=-28  delta=20
    mov -28(%esp), %ebx  # shift frame cell
    mov %ebx, -8(%esp)  # down to base
# emit-shift-args:  size=1   si=-32  delta=20
    mov -32(%esp), %ebx  # shift frame cell
    mov %ebx, -12(%esp)  # down to base
# emit-shift-args:  size=0   si=-36  delta=20
    movl $8,%eax   # save arg count
    jmp *-2(%edi)  # tail-funcall
     ret   # return thru stack
    .align 4,0x90
_L_40035:
    movl -32(%esp), %ebx
    movl -36(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin (vector-set! f6566 0 (closure (f6603 f6604) ((primitive-ref negative?) (primitive-ref write-char) f6566 (primitive-ref map) (primitive-ref write-char) (primitive-ref integer->list)) (let ((f6603 f6603) (f6604 f6604)) (if ((primitive-ref negative?) f6603) (begin ((primitive-ref write-char) #\- f6604) ((vector-ref f6566 0) (fx* -1 f6603) f6604)) ((primitive-ref map) (closure (f6606) ((primitive-ref write-char) f6604) (let ((f6606 f6606)) ((primitive-ref write-char) (fixnum->char (fx+ (char->fixnum #\0) f6606)) f6604))) ((primitive-ref integer->list) f6603)))))) (vector-set! f6565 0 (closure (f6599 f6600) ((primitive-ref write-char) (primitive-ref for-each) (primitive-ref write-char) (primitive-ref string->list) (primitive-ref write-char)) (let ((f6599 f6599) (f6600 f6600)) (begin ((primitive-ref write-char) #\" f6600) ((primitive-ref for-each) (closure (f6602) ((primitive-ref write-char) f6600) (let ((f6602 f6602)) ((primitive-ref write-char) f6602 f6600))) ((primitive-ref string->list) f6599)) ((primitive-ref write-char) #\" f6600))))) (vector-set! f6564 0 (closure (f6595 f6596) ((primitive-ref for-each) (primitive-ref write-char) (primitive-ref string->list)) (let ((f6595 f6595) (f6596 f6596)) ((primitive-ref for-each) (closure (f6598) ((primitive-ref write-char) f6596) (let ((f6598 f6598)) ((primitive-ref write-char) f6598 f6596))) ((primitive-ref string->list) f6595))))) (vector-set! f6563 0 (closure (f6593 f6594) ((primitive-ref write-char) f6562 (primitive-ref write-char)) (let ((f6593 f6593) (f6594 f6594)) (begin ((primitive-ref write-char) #\( f6594) ((vector-ref f6562 0) f6593 f6594) ((primitive-ref write-char) #\) f6594))))) (vector-set! f6562 0 (closure (f6591 f6592) ((primitive-ref write) (primitive-ref write-char) f6562 else (primitive-ref write-char) (primitive-ref write-char) (primitive-ref write-char) (primitive-ref write)) (let ((f6591 f6591) (f6592 f6592)) (begin ((primitive-ref write) (car f6591) f6592) (if (null? (cdr f6591)) #t (if (pair? (cdr f6591)) (begin ((primitive-ref write-char) #\space f6592) ((vector-ref f6562 0) (cdr f6591) f6592)) (begin ((primitive-ref write-char) #\space f6592) ((primitive-ref write-char) #\. f6592) ((primitive-ref write-char) #\space f6592) ((primitive-ref write) (cdr f6591) f6592)))))))))
# emit-begin
#   expr=(begin (vector-set! f6566 0 (closure (f6603 f6604) ((primitive-ref negative?) (primitive-ref write-char) f6566 (primitive-ref map) (primitive-ref write-char) (primitive-ref integer->list)) (let ((f6603 f6603) (f6604 f6604)) (if ((primitive-ref negative?) f6603) (begin ((primitive-ref write-char) #\- f6604) ((vector-ref f6566 0) (fx* -1 f6603) f6604)) ((primitive-ref map) (closure (f6606) ((primitive-ref write-char) f6604) (let ((f6606 f6606)) ((primitive-ref write-char) (fixnum->char (fx+ (char->fixnum #\0) f6606)) f6604))) ((primitive-ref integer->list) f6603)))))) (vector-set! f6565 0 (closure (f6599 f6600) ((primitive-ref write-char) (primitive-ref for-each) (primitive-ref write-char) (primitive-ref string->list) (primitive-ref write-char)) (let ((f6599 f6599) (f6600 f6600)) (begin ((primitive-ref write-char) #\" f6600) ((primitive-ref for-each) (closure (f6602) ((primitive-ref write-char) f6600) (let ((f6602 f6602)) ((primitive-ref write-char) f6602 f6600))) ((primitive-ref string->list) f6599)) ((primitive-ref write-char) #\" f6600))))) (vector-set! f6564 0 (closure (f6595 f6596) ((primitive-ref for-each) (primitive-ref write-char) (primitive-ref string->list)) (let ((f6595 f6595) (f6596 f6596)) ((primitive-ref for-each) (closure (f6598) ((primitive-ref write-char) f6596) (let ((f6598 f6598)) ((primitive-ref write-char) f6598 f6596))) ((primitive-ref string->list) f6595))))) (vector-set! f6563 0 (closure (f6593 f6594) ((primitive-ref write-char) f6562 (primitive-ref write-char)) (let ((f6593 f6593) (f6594 f6594)) (begin ((primitive-ref write-char) #\( f6594) ((vector-ref f6562 0) f6593 f6594) ((primitive-ref write-char) #\) f6594))))) (vector-set! f6562 0 (closure (f6591 f6592) ((primitive-ref write) (primitive-ref write-char) f6562 else (primitive-ref write-char) (primitive-ref write-char) (primitive-ref write-char) (primitive-ref write)) (let ((f6591 f6591) (f6592 f6592)) (begin ((primitive-ref write) (car f6591) f6592) (if (null? (cdr f6591)) #t (if (pair? (cdr f6591)) (begin ((primitive-ref write-char) #\space f6592) ((vector-ref f6562 0) (cdr f6591) f6592)) (begin ((primitive-ref write-char) #\space f6592) ((primitive-ref write-char) #\. f6592) ((primitive-ref write-char) #\space f6592) ((primitive-ref write) (cdr f6591) f6592)))))))))
#   env=((f6562 . -28) (f6563 . -24) (f6564 . -20) (f6565 . -16) (f6566 . -12) (f6567 . -8) (f6568 . -4) (f6569 . 0))
# emit-expr (vector-set! f6566 0 (closure (f6603 f6604) ((primitive-ref negative?) (primitive-ref write-char) f6566 (primitive-ref map) (primitive-ref write-char) (primitive-ref integer->list)) (let ((f6603 f6603) (f6604 f6604)) (if ((primitive-ref negative?) f6603) (begin ((primitive-ref write-char) #\- f6604) ((vector-ref f6566 0) (fx* -1 f6603) f6604)) ((primitive-ref map) (closure (f6606) ((primitive-ref write-char) f6604) (let ((f6606 f6606)) ((primitive-ref write-char) (fixnum->char (fx+ (char->fixnum #\0) f6606)) f6604))) ((primitive-ref integer->list) f6603))))))
# emit-expr f6566
# emit-variable-ref
# env=((f6562 . -28) (f6563 . -24) (f6564 . -20) (f6565 . -16) (f6566 . -12) (f6567 . -8) (f6568 . -4) (f6569 . 0))
# var=f6566
    movl -12(%esp), %eax  # stack load f6566
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_40039
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_40039:
    movl %eax, -32(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_40040"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_40040:
# check bounds on vector index
    movl -32(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_40042
    cmp  $0,%eax
    jge _L_40041
_L_40042:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_40041:
    movl %eax, -36(%esp)
# emit-expr (closure (f6603 f6604) ((primitive-ref negative?) (primitive-ref write-char) f6566 (primitive-ref map) (primitive-ref write-char) (primitive-ref integer->list)) (let ((f6603 f6603) (f6604 f6604)) (if ((primitive-ref negative?) f6603) (begin ((primitive-ref write-char) #\- f6604) ((vector-ref f6566 0) (fx* -1 f6603) f6604)) ((primitive-ref map) (closure (f6606) ((primitive-ref write-char) f6604) (let ((f6606 f6606)) ((primitive-ref write-char) (fixnum->char (fx+ (char->fixnum #\0) f6606)) f6604))) ((primitive-ref integer->list) f6603)))))
# emit-closure
# si = -40
# env = ((f6562 . -28) (f6563 . -24) (f6564 . -20) (f6565 . -16) (f6566 . -12) (f6567 . -8) (f6568 . -4) (f6569 . 0))
# expr = (closure (f6603 f6604) ((primitive-ref negative?) (primitive-ref write-char) f6566 (primitive-ref map) (primitive-ref write-char) (primitive-ref integer->list)) (let ((f6603 f6603) (f6604 f6604)) (if ((primitive-ref negative?) f6603) (begin ((primitive-ref write-char) #\- f6604) ((vector-ref f6566 0) (fx* -1 f6603) f6604)) ((primitive-ref map) (closure (f6606) ((primitive-ref write-char) f6604) (let ((f6606 f6606)) ((primitive-ref write-char) (fixnum->char (fx+ (char->fixnum #\0) f6606)) f6604))) ((primitive-ref integer->list) f6603)))))
    movl $_L_40043, 0(%ebp)  # closure label
# WARNING: free var (primitive-ref negative?) not defined in the environmnet
# WARNING: free var (primitive-ref write-char) not defined in the environmnet
# emit-variable-ref
# env=((f6562 . -28) (f6563 . -24) (f6564 . -20) (f6565 . -16) (f6566 . -12) (f6567 . -8) (f6568 . -4) (f6569 . 0))
# var=f6566
    movl -12(%esp), %eax  # stack load f6566
# end emit-variable-ref
   movl  %eax, 12(%ebp)  # f6566
# WARNING: free var (primitive-ref map) not defined in the environmnet
# WARNING: free var (primitive-ref write-char) not defined in the environmnet
# WARNING: free var (primitive-ref integer->list) not defined in the environmnet
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $32, %ebp     # bump ebp
    jmp _L_40044            # jump around closure body
_L_40043:
# check argument count
    cmp $8,%eax
    je _L_40045
# invoke error handler eh_argcount
    .extern mrc_eh$uargcount
    movl mrc_eh$uargcount, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_40045:
# emit-tail-expr
# si=-16
# env=((f6604 . -12) (f6603 . -8) ((primitive-ref integer->list) . 24) ((primitive-ref write-char) . 20) ((primitive-ref map) . 16) (f6566 . 12) ((primitive-ref write-char) . 8) ((primitive-ref negative?) . 4) (f6562 . -28) (f6563 . -24) (f6564 . -20) (f6565 . -16) (f6566 . -12) (f6567 . -8) (f6568 . -4) (f6569 . 0))
# expr=(let ((f6603 f6603) (f6604 f6604)) (if ((primitive-ref negative?) f6603) (begin ((primitive-ref write-char) #\- f6604) ((vector-ref f6566 0) (fx* -1 f6603) f6604)) ((primitive-ref map) (closure (f6606) ((primitive-ref write-char) f6604) (let ((f6606 f6606)) ((primitive-ref write-char) (fixnum->char (fx+ (char->fixnum #\0) f6606)) f6604))) ((primitive-ref integer->list) f6603))))
# emit-tail-let
#  si   = -16
#  env  = ((f6604 . -12) (f6603 . -8) ((primitive-ref integer->list) . 24) ((primitive-ref write-char) . 20) ((primitive-ref map) . 16) (f6566 . 12) ((primitive-ref write-char) . 8) ((primitive-ref negative?) . 4) (f6562 . -28) (f6563 . -24) (f6564 . -20) (f6565 . -16) (f6566 . -12) (f6567 . -8) (f6568 . -4) (f6569 . 0))
#  bindings = ((f6603 f6603) (f6604 f6604))
#  body = (if ((primitive-ref negative?) f6603) (begin ((primitive-ref write-char) #\- f6604) ((vector-ref f6566 0) (fx* -1 f6603) f6604)) ((primitive-ref map) (closure (f6606) ((primitive-ref write-char) f6604) (let ((f6606 f6606)) ((primitive-ref write-char) (fixnum->char (fx+ (char->fixnum #\0) f6606)) f6604))) ((primitive-ref integer->list) f6603)))
# emit-expr f6603
# emit-variable-ref
# env=((f6604 . -12) (f6603 . -8) ((primitive-ref integer->list) . 24) ((primitive-ref write-char) . 20) ((primitive-ref map) . 16) (f6566 . 12) ((primitive-ref write-char) . 8) ((primitive-ref negative?) . 4) (f6562 . -28) (f6563 . -24) (f6564 . -20) (f6565 . -16) (f6566 . -12) (f6567 . -8) (f6568 . -4) (f6569 . 0))
# var=f6603
    movl -8(%esp), %eax  # stack load f6603
# end emit-variable-ref
    movl %eax, -16(%esp)  # stack save
# emit-expr f6604
# emit-variable-ref
# env=((f6604 . -12) (f6603 . -8) ((primitive-ref integer->list) . 24) ((primitive-ref write-char) . 20) ((primitive-ref map) . 16) (f6566 . 12) ((primitive-ref write-char) . 8) ((primitive-ref negative?) . 4) (f6562 . -28) (f6563 . -24) (f6564 . -20) (f6565 . -16) (f6566 . -12) (f6567 . -8) (f6568 . -4) (f6569 . 0))
# var=f6604
    movl -12(%esp), %eax  # stack load f6604
# end emit-variable-ref
    movl %eax, -20(%esp)  # stack save
# emit-tail-expr
# si=-24
# env=((f6604 . -20) (f6603 . -16) (f6604 . -12) (f6603 . -8) ((primitive-ref integer->list) . 24) ((primitive-ref write-char) . 20) ((primitive-ref map) . 16) (f6566 . 12) ((primitive-ref write-char) . 8) ((primitive-ref negative?) . 4) (f6562 . -28) (f6563 . -24) (f6564 . -20) (f6565 . -16) (f6566 . -12) (f6567 . -8) (f6568 . -4) (f6569 . 0))
# expr=(if ((primitive-ref negative?) f6603) (begin ((primitive-ref write-char) #\- f6604) ((vector-ref f6566 0) (fx* -1 f6603) f6604)) ((primitive-ref map) (closure (f6606) ((primitive-ref write-char) f6604) (let ((f6606 f6606)) ((primitive-ref write-char) (fixnum->char (fx+ (char->fixnum #\0) f6606)) f6604))) ((primitive-ref integer->list) f6603)))
# emit-expr ((primitive-ref negative?) f6603)
# funcall
#    si   =-24
#    env  = ((f6604 . -20) (f6603 . -16) (f6604 . -12) (f6603 . -8) ((primitive-ref integer->list) . 24) ((primitive-ref write-char) . 20) ((primitive-ref map) . 16) (f6566 . 12) ((primitive-ref write-char) . 8) ((primitive-ref negative?) . 4) (f6562 . -28) (f6563 . -24) (f6564 . -20) (f6565 . -16) (f6566 . -12) (f6567 . -8) (f6568 . -4) (f6569 . 0))
#    expr = (funcall (primitive-ref negative?) f6603)
# emit-expr (primitive-ref negative?)
    .extern mrc_negative$q
    movl mrc_negative$q,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_40048"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_40048":
   movl %eax,  -32(%esp)  # stash funcall-oper in closure slot
# emit-expr f6603
# emit-variable-ref
# env=((f6604 . -20) (f6603 . -16) (f6604 . -12) (f6603 . -8) ((primitive-ref integer->list) . 24) ((primitive-ref write-char) . 20) ((primitive-ref map) . 16) (f6566 . 12) ((primitive-ref write-char) . 8) ((primitive-ref negative?) . 4) (f6562 . -28) (f6563 . -24) (f6564 . -20) (f6565 . -16) (f6566 . -12) (f6567 . -8) (f6568 . -4) (f6569 . 0))
# var=f6603
    movl -16(%esp), %eax  # stack load f6603
# end emit-variable-ref
    mov %eax, -36(%esp)  # arg f6603
    movl -32(%esp), %edi   # load new closure to %edi
    add $-24, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $24, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    cmp $47, %al
    je _L_40046
# emit-tail-expr
# si=-24
# env=((f6604 . -20) (f6603 . -16) (f6604 . -12) (f6603 . -8) ((primitive-ref integer->list) . 24) ((primitive-ref write-char) . 20) ((primitive-ref map) . 16) (f6566 . 12) ((primitive-ref write-char) . 8) ((primitive-ref negative?) . 4) (f6562 . -28) (f6563 . -24) (f6564 . -20) (f6565 . -16) (f6566 . -12) (f6567 . -8) (f6568 . -4) (f6569 . 0))
# expr=(begin ((primitive-ref write-char) #\- f6604) ((vector-ref f6566 0) (fx* -1 f6603) f6604))
# tail-begin (begin ((primitive-ref write-char) #\- f6604) ((vector-ref f6566 0) (fx* -1 f6603) f6604))
#   env=((f6604 . -20) (f6603 . -16) (f6604 . -12) (f6603 . -8) ((primitive-ref integer->list) . 24) ((primitive-ref write-char) . 20) ((primitive-ref map) . 16) (f6566 . 12) ((primitive-ref write-char) . 8) ((primitive-ref negative?) . 4) (f6562 . -28) (f6563 . -24) (f6564 . -20) (f6565 . -16) (f6566 . -12) (f6567 . -8) (f6568 . -4) (f6569 . 0))
# emit-expr ((primitive-ref write-char) #\- f6604)
# funcall
#    si   =-24
#    env  = ((f6604 . -20) (f6603 . -16) (f6604 . -12) (f6603 . -8) ((primitive-ref integer->list) . 24) ((primitive-ref write-char) . 20) ((primitive-ref map) . 16) (f6566 . 12) ((primitive-ref write-char) . 8) ((primitive-ref negative?) . 4) (f6562 . -28) (f6563 . -24) (f6564 . -20) (f6565 . -16) (f6566 . -12) (f6567 . -8) (f6568 . -4) (f6569 . 0))
#    expr = (funcall (primitive-ref write-char) #\- f6604)
# emit-expr (primitive-ref write-char)
    .extern mrc_write$mchar
    movl mrc_write$mchar,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_40049"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_40049":
   movl %eax,  -32(%esp)  # stash funcall-oper in closure slot
# emit-expr #\-
    movl $11535, %eax     # immed #\-
    mov %eax, -36(%esp)  # arg -
# emit-expr f6604
# emit-variable-ref
# env=((f6604 . -20) (f6603 . -16) (f6604 . -12) (f6603 . -8) ((primitive-ref integer->list) . 24) ((primitive-ref write-char) . 20) ((primitive-ref map) . 16) (f6566 . 12) ((primitive-ref write-char) . 8) ((primitive-ref negative?) . 4) (f6562 . -28) (f6563 . -24) (f6564 . -20) (f6565 . -16) (f6566 . -12) (f6567 . -8) (f6568 . -4) (f6569 . 0))
# var=f6604
    movl -20(%esp), %eax  # stack load f6604
# end emit-variable-ref
    mov %eax, -40(%esp)  # arg f6604
    movl -32(%esp), %edi   # load new closure to %edi
    add $-24, %esp   # adjust base
    movl $8,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $24, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
# emit-tail-expr
# si=-24
# env=((f6604 . -20) (f6603 . -16) (f6604 . -12) (f6603 . -8) ((primitive-ref integer->list) . 24) ((primitive-ref write-char) . 20) ((primitive-ref map) . 16) (f6566 . 12) ((primitive-ref write-char) . 8) ((primitive-ref negative?) . 4) (f6562 . -28) (f6563 . -24) (f6564 . -20) (f6565 . -16) (f6566 . -12) (f6567 . -8) (f6568 . -4) (f6569 . 0))
# expr=(begin ((vector-ref f6566 0) (fx* -1 f6603) f6604))
# tail-begin (begin ((vector-ref f6566 0) (fx* -1 f6603) f6604))
#   env=((f6604 . -20) (f6603 . -16) (f6604 . -12) (f6603 . -8) ((primitive-ref integer->list) . 24) ((primitive-ref write-char) . 20) ((primitive-ref map) . 16) (f6566 . 12) ((primitive-ref write-char) . 8) ((primitive-ref negative?) . 4) (f6562 . -28) (f6563 . -24) (f6564 . -20) (f6565 . -16) (f6566 . -12) (f6567 . -8) (f6568 . -4) (f6569 . 0))
# emit-tail-expr
# si=-24
# env=((f6604 . -20) (f6603 . -16) (f6604 . -12) (f6603 . -8) ((primitive-ref integer->list) . 24) ((primitive-ref write-char) . 20) ((primitive-ref map) . 16) (f6566 . 12) ((primitive-ref write-char) . 8) ((primitive-ref negative?) . 4) (f6562 . -28) (f6563 . -24) (f6564 . -20) (f6565 . -16) (f6566 . -12) (f6567 . -8) (f6568 . -4) (f6569 . 0))
# expr=((vector-ref f6566 0) (fx* -1 f6603) f6604)
# emit-tail-funcall
#    si   =-24
#    env  = ((f6604 . -20) (f6603 . -16) (f6604 . -12) (f6603 . -8) ((primitive-ref integer->list) . 24) ((primitive-ref write-char) . 20) ((primitive-ref map) . 16) (f6566 . 12) ((primitive-ref write-char) . 8) ((primitive-ref negative?) . 4) (f6562 . -28) (f6563 . -24) (f6564 . -20) (f6565 . -16) (f6566 . -12) (f6567 . -8) (f6568 . -4) (f6569 . 0))
#    expr = (funcall (vector-ref f6566 0) (fx* -1 f6603) f6604)
# emit-expr (vector-ref f6566 0)
# emit-expr f6566
# emit-variable-ref
# env=((f6604 . -20) (f6603 . -16) (f6604 . -12) (f6603 . -8) ((primitive-ref integer->list) . 24) ((primitive-ref write-char) . 20) ((primitive-ref map) . 16) (f6566 . 12) ((primitive-ref write-char) . 8) ((primitive-ref negative?) . 4) (f6562 . -28) (f6563 . -24) (f6564 . -20) (f6565 . -16) (f6566 . -12) (f6567 . -8) (f6568 . -4) (f6569 . 0))
# var=f6566
    movl 10(%edi), %eax  # frame load f6566
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_40050
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_40050:
    movl %eax, -24(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_40051"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_40051:
# check bounds on vector index
    movl -24(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_40053
    cmp  $0,%eax
    jge _L_40052
_L_40053:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_40052:
    movl -24(%esp), %esi
    movl -1(%eax,%esi), %eax
   movl %eax,  -24(%esp)  # stash funcall-oper in next closure slot
# emit-expr (fx* -1 f6603)
# emit-expr f6603
# emit-variable-ref
# env=((f6604 . -20) (f6603 . -16) (f6604 . -12) (f6603 . -8) ((primitive-ref integer->list) . 24) ((primitive-ref write-char) . 20) ((primitive-ref map) . 16) (f6566 . 12) ((primitive-ref write-char) . 8) ((primitive-ref negative?) . 4) (f6562 . -28) (f6563 . -24) (f6564 . -20) (f6565 . -16) (f6566 . -12) (f6567 . -8) (f6568 . -4) (f6569 . 0))
# var=f6603
    movl -16(%esp), %eax  # stack load f6603
# end emit-variable-ref
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_40054"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $96,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_40054:
    sar $2, %eax
    movl %eax, -28(%esp)
# emit-expr -1
    movl $-4, %eax     # immed -1
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_40055"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $96,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_40055:
    imul -28(%esp), %eax
    mov %eax, -28(%esp)    # arg (fx* -1 f6603)
# emit-expr f6604
# emit-variable-ref
# env=((f6604 . -20) (f6603 . -16) (f6604 . -12) (f6603 . -8) ((primitive-ref integer->list) . 24) ((primitive-ref write-char) . 20) ((primitive-ref map) . 16) (f6566 . 12) ((primitive-ref write-char) . 8) ((primitive-ref negative?) . 4) (f6562 . -28) (f6563 . -24) (f6564 . -20) (f6565 . -16) (f6566 . -12) (f6567 . -8) (f6568 . -4) (f6569 . 0))
# var=f6604
    movl -20(%esp), %eax  # stack load f6604
# end emit-variable-ref
    mov %eax, -32(%esp)    # arg f6604
    movl -24(%esp), %edi   # load new closure to %edi
# emit-shift-args:  size=3   si=-24  delta=20
    mov -24(%esp), %ebx  # shift frame cell
    mov %ebx, -4(%esp)  # down to base
# emit-shift-args:  size=2   si=-28  delta=20
    mov -28(%esp), %ebx  # shift frame cell
    mov %ebx, -8(%esp)  # down to base
# emit-shift-args:  size=1   si=-32  delta=20
    mov -32(%esp), %ebx  # shift frame cell
    mov %ebx, -12(%esp)  # down to base
# emit-shift-args:  size=0   si=-36  delta=20
    movl $8,%eax   # save arg count
    jmp *-2(%edi)  # tail-funcall
     ret   # return thru stack
    jmp _L_40047
_L_40046:
# emit-tail-expr
# si=-24
# env=((f6604 . -20) (f6603 . -16) (f6604 . -12) (f6603 . -8) ((primitive-ref integer->list) . 24) ((primitive-ref write-char) . 20) ((primitive-ref map) . 16) (f6566 . 12) ((primitive-ref write-char) . 8) ((primitive-ref negative?) . 4) (f6562 . -28) (f6563 . -24) (f6564 . -20) (f6565 . -16) (f6566 . -12) (f6567 . -8) (f6568 . -4) (f6569 . 0))
# expr=((primitive-ref map) (closure (f6606) ((primitive-ref write-char) f6604) (let ((f6606 f6606)) ((primitive-ref write-char) (fixnum->char (fx+ (char->fixnum #\0) f6606)) f6604))) ((primitive-ref integer->list) f6603))
# emit-tail-funcall
#    si   =-24
#    env  = ((f6604 . -20) (f6603 . -16) (f6604 . -12) (f6603 . -8) ((primitive-ref integer->list) . 24) ((primitive-ref write-char) . 20) ((primitive-ref map) . 16) (f6566 . 12) ((primitive-ref write-char) . 8) ((primitive-ref negative?) . 4) (f6562 . -28) (f6563 . -24) (f6564 . -20) (f6565 . -16) (f6566 . -12) (f6567 . -8) (f6568 . -4) (f6569 . 0))
#    expr = (funcall (primitive-ref map) (closure (f6606) ((primitive-ref write-char) f6604) (let ((f6606 f6606)) ((primitive-ref write-char) (fixnum->char (fx+ (char->fixnum #\0) f6606)) f6604))) ((primitive-ref integer->list) f6603))
# emit-expr (primitive-ref map)
    .extern mrc_map
    movl mrc_map,%eax
   movl %eax,  -24(%esp)  # stash funcall-oper in next closure slot
# emit-expr (closure (f6606) ((primitive-ref write-char) f6604) (let ((f6606 f6606)) ((primitive-ref write-char) (fixnum->char (fx+ (char->fixnum #\0) f6606)) f6604)))
# emit-closure
# si = -28
# env = ((f6604 . -20) (f6603 . -16) (f6604 . -12) (f6603 . -8) ((primitive-ref integer->list) . 24) ((primitive-ref write-char) . 20) ((primitive-ref map) . 16) (f6566 . 12) ((primitive-ref write-char) . 8) ((primitive-ref negative?) . 4) (f6562 . -28) (f6563 . -24) (f6564 . -20) (f6565 . -16) (f6566 . -12) (f6567 . -8) (f6568 . -4) (f6569 . 0))
# expr = (closure (f6606) ((primitive-ref write-char) f6604) (let ((f6606 f6606)) ((primitive-ref write-char) (fixnum->char (fx+ (char->fixnum #\0) f6606)) f6604)))
    movl $_L_40056, 0(%ebp)  # closure label
# emit-variable-ref
# env=((f6604 . -20) (f6603 . -16) (f6604 . -12) (f6603 . -8) ((primitive-ref integer->list) . 24) ((primitive-ref write-char) . 20) ((primitive-ref map) . 16) (f6566 . 12) ((primitive-ref write-char) . 8) ((primitive-ref negative?) . 4) (f6562 . -28) (f6563 . -24) (f6564 . -20) (f6565 . -16) (f6566 . -12) (f6567 . -8) (f6568 . -4) (f6569 . 0))
# var=(primitive-ref write-char)
    movl 18(%edi), %eax  # frame load (primitive-ref write-char)
# end emit-variable-ref
   movl  %eax, 4(%ebp)  # (primitive-ref write-char)
# emit-variable-ref
# env=((f6604 . -20) (f6603 . -16) (f6604 . -12) (f6603 . -8) ((primitive-ref integer->list) . 24) ((primitive-ref write-char) . 20) ((primitive-ref map) . 16) (f6566 . 12) ((primitive-ref write-char) . 8) ((primitive-ref negative?) . 4) (f6562 . -28) (f6563 . -24) (f6564 . -20) (f6565 . -16) (f6566 . -12) (f6567 . -8) (f6568 . -4) (f6569 . 0))
# var=f6604
    movl -20(%esp), %eax  # stack load f6604
# end emit-variable-ref
   movl  %eax, 8(%ebp)  # f6604
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $16, %ebp     # bump ebp
    jmp _L_40057            # jump around closure body
_L_40056:
# check argument count
    cmp $4,%eax
    je _L_40058
# invoke error handler eh_argcount
    .extern mrc_eh$uargcount
    movl mrc_eh$uargcount, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_40058:
# emit-tail-expr
# si=-12
# env=((f6606 . -8) (f6604 . 8) ((primitive-ref write-char) . 4) (f6604 . -20) (f6603 . -16) (f6604 . -12) (f6603 . -8) ((primitive-ref integer->list) . 24) ((primitive-ref write-char) . 20) ((primitive-ref map) . 16) (f6566 . 12) ((primitive-ref write-char) . 8) ((primitive-ref negative?) . 4) (f6562 . -28) (f6563 . -24) (f6564 . -20) (f6565 . -16) (f6566 . -12) (f6567 . -8) (f6568 . -4) (f6569 . 0))
# expr=(let ((f6606 f6606)) ((primitive-ref write-char) (fixnum->char (fx+ (char->fixnum #\0) f6606)) f6604))
# emit-tail-let
#  si   = -12
#  env  = ((f6606 . -8) (f6604 . 8) ((primitive-ref write-char) . 4) (f6604 . -20) (f6603 . -16) (f6604 . -12) (f6603 . -8) ((primitive-ref integer->list) . 24) ((primitive-ref write-char) . 20) ((primitive-ref map) . 16) (f6566 . 12) ((primitive-ref write-char) . 8) ((primitive-ref negative?) . 4) (f6562 . -28) (f6563 . -24) (f6564 . -20) (f6565 . -16) (f6566 . -12) (f6567 . -8) (f6568 . -4) (f6569 . 0))
#  bindings = ((f6606 f6606))
#  body = ((primitive-ref write-char) (fixnum->char (fx+ (char->fixnum #\0) f6606)) f6604)
# emit-expr f6606
# emit-variable-ref
# env=((f6606 . -8) (f6604 . 8) ((primitive-ref write-char) . 4) (f6604 . -20) (f6603 . -16) (f6604 . -12) (f6603 . -8) ((primitive-ref integer->list) . 24) ((primitive-ref write-char) . 20) ((primitive-ref map) . 16) (f6566 . 12) ((primitive-ref write-char) . 8) ((primitive-ref negative?) . 4) (f6562 . -28) (f6563 . -24) (f6564 . -20) (f6565 . -16) (f6566 . -12) (f6567 . -8) (f6568 . -4) (f6569 . 0))
# var=f6606
    movl -8(%esp), %eax  # stack load f6606
# end emit-variable-ref
    movl %eax, -12(%esp)  # stack save
# emit-tail-expr
# si=-16
# env=((f6606 . -12) (f6606 . -8) (f6604 . 8) ((primitive-ref write-char) . 4) (f6604 . -20) (f6603 . -16) (f6604 . -12) (f6603 . -8) ((primitive-ref integer->list) . 24) ((primitive-ref write-char) . 20) ((primitive-ref map) . 16) (f6566 . 12) ((primitive-ref write-char) . 8) ((primitive-ref negative?) . 4) (f6562 . -28) (f6563 . -24) (f6564 . -20) (f6565 . -16) (f6566 . -12) (f6567 . -8) (f6568 . -4) (f6569 . 0))
# expr=((primitive-ref write-char) (fixnum->char (fx+ (char->fixnum #\0) f6606)) f6604)
# emit-tail-funcall
#    si   =-16
#    env  = ((f6606 . -12) (f6606 . -8) (f6604 . 8) ((primitive-ref write-char) . 4) (f6604 . -20) (f6603 . -16) (f6604 . -12) (f6603 . -8) ((primitive-ref integer->list) . 24) ((primitive-ref write-char) . 20) ((primitive-ref map) . 16) (f6566 . 12) ((primitive-ref write-char) . 8) ((primitive-ref negative?) . 4) (f6562 . -28) (f6563 . -24) (f6564 . -20) (f6565 . -16) (f6566 . -12) (f6567 . -8) (f6568 . -4) (f6569 . 0))
#    expr = (funcall (primitive-ref write-char) (fixnum->char (fx+ (char->fixnum #\0) f6606)) f6604)
# emit-expr (primitive-ref write-char)
    .extern mrc_write$mchar
    movl mrc_write$mchar,%eax
   movl %eax,  -16(%esp)  # stash funcall-oper in next closure slot
# emit-expr (fixnum->char (fx+ (char->fixnum #\0) f6606))
# emit-expr (fx+ (char->fixnum #\0) f6606)
# emit-expr f6606
# emit-variable-ref
# env=((f6606 . -12) (f6606 . -8) (f6604 . 8) ((primitive-ref write-char) . 4) (f6604 . -20) (f6603 . -16) (f6604 . -12) (f6603 . -8) ((primitive-ref integer->list) . 24) ((primitive-ref write-char) . 20) ((primitive-ref map) . 16) (f6566 . 12) ((primitive-ref write-char) . 8) ((primitive-ref negative?) . 4) (f6562 . -28) (f6563 . -24) (f6564 . -20) (f6565 . -16) (f6566 . -12) (f6567 . -8) (f6568 . -4) (f6569 . 0))
# var=f6606
    movl -12(%esp), %eax  # stack load f6606
# end emit-variable-ref
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_40059"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $88,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_40059:
    movl %eax, -20(%esp)  # fx+ push arg1
# emit-expr (char->fixnum #\0)
# emit-expr #\0
    movl $12303, %eax     # immed #\0
# check the argument is a char
    movl %eax,%ebx
    and $255, %bl
    cmp $15, %bl
    je "_L_40060"
# invoke error handler eh_character
    .extern mrc_eh$ucharacter
    movl mrc_eh$ucharacter, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $4,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_40060:
   shrl $8, %eax
   shll $2, %eax
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_40061"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $88,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_40061:
    addl -20(%esp), %eax  # fx+ arg1 arg2
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_40062"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $0,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_40062:
    shll $6, %eax
    orl $15, %eax
    mov %eax, -20(%esp)    # arg (fixnum->char (fx+ (char->fixnum 0) f6606))
# emit-expr f6604
# emit-variable-ref
# env=((f6606 . -12) (f6606 . -8) (f6604 . 8) ((primitive-ref write-char) . 4) (f6604 . -20) (f6603 . -16) (f6604 . -12) (f6603 . -8) ((primitive-ref integer->list) . 24) ((primitive-ref write-char) . 20) ((primitive-ref map) . 16) (f6566 . 12) ((primitive-ref write-char) . 8) ((primitive-ref negative?) . 4) (f6562 . -28) (f6563 . -24) (f6564 . -20) (f6565 . -16) (f6566 . -12) (f6567 . -8) (f6568 . -4) (f6569 . 0))
# var=f6604
    movl 6(%edi), %eax  # frame load f6604
# end emit-variable-ref
    mov %eax, -24(%esp)    # arg f6604
    movl -16(%esp), %edi   # load new closure to %edi
# emit-shift-args:  size=3   si=-16  delta=12
    mov -16(%esp), %ebx  # shift frame cell
    mov %ebx, -4(%esp)  # down to base
# emit-shift-args:  size=2   si=-20  delta=12
    mov -20(%esp), %ebx  # shift frame cell
    mov %ebx, -8(%esp)  # down to base
# emit-shift-args:  size=1   si=-24  delta=12
    mov -24(%esp), %ebx  # shift frame cell
    mov %ebx, -12(%esp)  # down to base
# emit-shift-args:  size=0   si=-28  delta=12
    movl $8,%eax   # save arg count
    jmp *-2(%edi)  # tail-funcall
    .align 4,0x90
_L_40057:
    mov %eax, -28(%esp)    # arg (closure (f6606) ((primitive-ref write-char) f6604) (let ((f6606 f6606)) ((primitive-ref write-char) (fixnum->char (fx+ (char->fixnum 0) f6606)) f6604)))
# emit-expr ((primitive-ref integer->list) f6603)
# funcall
#    si   =-32
#    env  = ((f6604 . -20) (f6603 . -16) (f6604 . -12) (f6603 . -8) ((primitive-ref integer->list) . 24) ((primitive-ref write-char) . 20) ((primitive-ref map) . 16) (f6566 . 12) ((primitive-ref write-char) . 8) ((primitive-ref negative?) . 4) (f6562 . -28) (f6563 . -24) (f6564 . -20) (f6565 . -16) (f6566 . -12) (f6567 . -8) (f6568 . -4) (f6569 . 0))
#    expr = (funcall (primitive-ref integer->list) f6603)
# emit-expr (primitive-ref integer->list)
    .extern mrc_integer$m$glist
    movl mrc_integer$m$glist,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_40063"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_40063":
   movl %eax,  -40(%esp)  # stash funcall-oper in closure slot
# emit-expr f6603
# emit-variable-ref
# env=((f6604 . -20) (f6603 . -16) (f6604 . -12) (f6603 . -8) ((primitive-ref integer->list) . 24) ((primitive-ref write-char) . 20) ((primitive-ref map) . 16) (f6566 . 12) ((primitive-ref write-char) . 8) ((primitive-ref negative?) . 4) (f6562 . -28) (f6563 . -24) (f6564 . -20) (f6565 . -16) (f6566 . -12) (f6567 . -8) (f6568 . -4) (f6569 . 0))
# var=f6603
    movl -16(%esp), %eax  # stack load f6603
# end emit-variable-ref
    mov %eax, -44(%esp)  # arg f6603
    movl -40(%esp), %edi   # load new closure to %edi
    add $-32, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $32, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    mov %eax, -32(%esp)    # arg ((primitive-ref integer->list) f6603)
    movl -24(%esp), %edi   # load new closure to %edi
# emit-shift-args:  size=3   si=-24  delta=20
    mov -24(%esp), %ebx  # shift frame cell
    mov %ebx, -4(%esp)  # down to base
# emit-shift-args:  size=2   si=-28  delta=20
    mov -28(%esp), %ebx  # shift frame cell
    mov %ebx, -8(%esp)  # down to base
# emit-shift-args:  size=1   si=-32  delta=20
    mov -32(%esp), %ebx  # shift frame cell
    mov %ebx, -12(%esp)  # down to base
# emit-shift-args:  size=0   si=-36  delta=20
    movl $8,%eax   # save arg count
    jmp *-2(%edi)  # tail-funcall
_L_40047:
    .align 4,0x90
_L_40044:
    movl -32(%esp), %ebx
    movl -36(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin (vector-set! f6565 0 (closure (f6599 f6600) ((primitive-ref write-char) (primitive-ref for-each) (primitive-ref write-char) (primitive-ref string->list) (primitive-ref write-char)) (let ((f6599 f6599) (f6600 f6600)) (begin ((primitive-ref write-char) #\" f6600) ((primitive-ref for-each) (closure (f6602) ((primitive-ref write-char) f6600) (let ((f6602 f6602)) ((primitive-ref write-char) f6602 f6600))) ((primitive-ref string->list) f6599)) ((primitive-ref write-char) #\" f6600))))) (vector-set! f6564 0 (closure (f6595 f6596) ((primitive-ref for-each) (primitive-ref write-char) (primitive-ref string->list)) (let ((f6595 f6595) (f6596 f6596)) ((primitive-ref for-each) (closure (f6598) ((primitive-ref write-char) f6596) (let ((f6598 f6598)) ((primitive-ref write-char) f6598 f6596))) ((primitive-ref string->list) f6595))))) (vector-set! f6563 0 (closure (f6593 f6594) ((primitive-ref write-char) f6562 (primitive-ref write-char)) (let ((f6593 f6593) (f6594 f6594)) (begin ((primitive-ref write-char) #\( f6594) ((vector-ref f6562 0) f6593 f6594) ((primitive-ref write-char) #\) f6594))))) (vector-set! f6562 0 (closure (f6591 f6592) ((primitive-ref write) (primitive-ref write-char) f6562 else (primitive-ref write-char) (primitive-ref write-char) (primitive-ref write-char) (primitive-ref write)) (let ((f6591 f6591) (f6592 f6592)) (begin ((primitive-ref write) (car f6591) f6592) (if (null? (cdr f6591)) #t (if (pair? (cdr f6591)) (begin ((primitive-ref write-char) #\space f6592) ((vector-ref f6562 0) (cdr f6591) f6592)) (begin ((primitive-ref write-char) #\space f6592) ((primitive-ref write-char) #\. f6592) ((primitive-ref write-char) #\space f6592) ((primitive-ref write) (cdr f6591) f6592)))))))))
# emit-begin
#   expr=(begin (vector-set! f6565 0 (closure (f6599 f6600) ((primitive-ref write-char) (primitive-ref for-each) (primitive-ref write-char) (primitive-ref string->list) (primitive-ref write-char)) (let ((f6599 f6599) (f6600 f6600)) (begin ((primitive-ref write-char) #\" f6600) ((primitive-ref for-each) (closure (f6602) ((primitive-ref write-char) f6600) (let ((f6602 f6602)) ((primitive-ref write-char) f6602 f6600))) ((primitive-ref string->list) f6599)) ((primitive-ref write-char) #\" f6600))))) (vector-set! f6564 0 (closure (f6595 f6596) ((primitive-ref for-each) (primitive-ref write-char) (primitive-ref string->list)) (let ((f6595 f6595) (f6596 f6596)) ((primitive-ref for-each) (closure (f6598) ((primitive-ref write-char) f6596) (let ((f6598 f6598)) ((primitive-ref write-char) f6598 f6596))) ((primitive-ref string->list) f6595))))) (vector-set! f6563 0 (closure (f6593 f6594) ((primitive-ref write-char) f6562 (primitive-ref write-char)) (let ((f6593 f6593) (f6594 f6594)) (begin ((primitive-ref write-char) #\( f6594) ((vector-ref f6562 0) f6593 f6594) ((primitive-ref write-char) #\) f6594))))) (vector-set! f6562 0 (closure (f6591 f6592) ((primitive-ref write) (primitive-ref write-char) f6562 else (primitive-ref write-char) (primitive-ref write-char) (primitive-ref write-char) (primitive-ref write)) (let ((f6591 f6591) (f6592 f6592)) (begin ((primitive-ref write) (car f6591) f6592) (if (null? (cdr f6591)) #t (if (pair? (cdr f6591)) (begin ((primitive-ref write-char) #\space f6592) ((vector-ref f6562 0) (cdr f6591) f6592)) (begin ((primitive-ref write-char) #\space f6592) ((primitive-ref write-char) #\. f6592) ((primitive-ref write-char) #\space f6592) ((primitive-ref write) (cdr f6591) f6592)))))))))
#   env=((f6562 . -28) (f6563 . -24) (f6564 . -20) (f6565 . -16) (f6566 . -12) (f6567 . -8) (f6568 . -4) (f6569 . 0))
# emit-expr (vector-set! f6565 0 (closure (f6599 f6600) ((primitive-ref write-char) (primitive-ref for-each) (primitive-ref write-char) (primitive-ref string->list) (primitive-ref write-char)) (let ((f6599 f6599) (f6600 f6600)) (begin ((primitive-ref write-char) #\" f6600) ((primitive-ref for-each) (closure (f6602) ((primitive-ref write-char) f6600) (let ((f6602 f6602)) ((primitive-ref write-char) f6602 f6600))) ((primitive-ref string->list) f6599)) ((primitive-ref write-char) #\" f6600)))))
# emit-expr f6565
# emit-variable-ref
# env=((f6562 . -28) (f6563 . -24) (f6564 . -20) (f6565 . -16) (f6566 . -12) (f6567 . -8) (f6568 . -4) (f6569 . 0))
# var=f6565
    movl -16(%esp), %eax  # stack load f6565
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_40064
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_40064:
    movl %eax, -32(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_40065"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_40065:
# check bounds on vector index
    movl -32(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_40067
    cmp  $0,%eax
    jge _L_40066
_L_40067:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_40066:
    movl %eax, -36(%esp)
# emit-expr (closure (f6599 f6600) ((primitive-ref write-char) (primitive-ref for-each) (primitive-ref write-char) (primitive-ref string->list) (primitive-ref write-char)) (let ((f6599 f6599) (f6600 f6600)) (begin ((primitive-ref write-char) #\" f6600) ((primitive-ref for-each) (closure (f6602) ((primitive-ref write-char) f6600) (let ((f6602 f6602)) ((primitive-ref write-char) f6602 f6600))) ((primitive-ref string->list) f6599)) ((primitive-ref write-char) #\" f6600))))
# emit-closure
# si = -40
# env = ((f6562 . -28) (f6563 . -24) (f6564 . -20) (f6565 . -16) (f6566 . -12) (f6567 . -8) (f6568 . -4) (f6569 . 0))
# expr = (closure (f6599 f6600) ((primitive-ref write-char) (primitive-ref for-each) (primitive-ref write-char) (primitive-ref string->list) (primitive-ref write-char)) (let ((f6599 f6599) (f6600 f6600)) (begin ((primitive-ref write-char) #\" f6600) ((primitive-ref for-each) (closure (f6602) ((primitive-ref write-char) f6600) (let ((f6602 f6602)) ((primitive-ref write-char) f6602 f6600))) ((primitive-ref string->list) f6599)) ((primitive-ref write-char) #\" f6600))))
    movl $_L_40068, 0(%ebp)  # closure label
# WARNING: free var (primitive-ref write-char) not defined in the environmnet
# WARNING: free var (primitive-ref for-each) not defined in the environmnet
# WARNING: free var (primitive-ref write-char) not defined in the environmnet
# WARNING: free var (primitive-ref string->list) not defined in the environmnet
# WARNING: free var (primitive-ref write-char) not defined in the environmnet
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $24, %ebp     # bump ebp
    jmp _L_40069            # jump around closure body
_L_40068:
# check argument count
    cmp $8,%eax
    je _L_40070
# invoke error handler eh_argcount
    .extern mrc_eh$uargcount
    movl mrc_eh$uargcount, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_40070:
# emit-tail-expr
# si=-16
# env=((f6600 . -12) (f6599 . -8) ((primitive-ref write-char) . 20) ((primitive-ref string->list) . 16) ((primitive-ref write-char) . 12) ((primitive-ref for-each) . 8) ((primitive-ref write-char) . 4) (f6562 . -28) (f6563 . -24) (f6564 . -20) (f6565 . -16) (f6566 . -12) (f6567 . -8) (f6568 . -4) (f6569 . 0))
# expr=(let ((f6599 f6599) (f6600 f6600)) (begin ((primitive-ref write-char) #\" f6600) ((primitive-ref for-each) (closure (f6602) ((primitive-ref write-char) f6600) (let ((f6602 f6602)) ((primitive-ref write-char) f6602 f6600))) ((primitive-ref string->list) f6599)) ((primitive-ref write-char) #\" f6600)))
# emit-tail-let
#  si   = -16
#  env  = ((f6600 . -12) (f6599 . -8) ((primitive-ref write-char) . 20) ((primitive-ref string->list) . 16) ((primitive-ref write-char) . 12) ((primitive-ref for-each) . 8) ((primitive-ref write-char) . 4) (f6562 . -28) (f6563 . -24) (f6564 . -20) (f6565 . -16) (f6566 . -12) (f6567 . -8) (f6568 . -4) (f6569 . 0))
#  bindings = ((f6599 f6599) (f6600 f6600))
#  body = (begin ((primitive-ref write-char) #\" f6600) ((primitive-ref for-each) (closure (f6602) ((primitive-ref write-char) f6600) (let ((f6602 f6602)) ((primitive-ref write-char) f6602 f6600))) ((primitive-ref string->list) f6599)) ((primitive-ref write-char) #\" f6600))
# emit-expr f6599
# emit-variable-ref
# env=((f6600 . -12) (f6599 . -8) ((primitive-ref write-char) . 20) ((primitive-ref string->list) . 16) ((primitive-ref write-char) . 12) ((primitive-ref for-each) . 8) ((primitive-ref write-char) . 4) (f6562 . -28) (f6563 . -24) (f6564 . -20) (f6565 . -16) (f6566 . -12) (f6567 . -8) (f6568 . -4) (f6569 . 0))
# var=f6599
    movl -8(%esp), %eax  # stack load f6599
# end emit-variable-ref
    movl %eax, -16(%esp)  # stack save
# emit-expr f6600
# emit-variable-ref
# env=((f6600 . -12) (f6599 . -8) ((primitive-ref write-char) . 20) ((primitive-ref string->list) . 16) ((primitive-ref write-char) . 12) ((primitive-ref for-each) . 8) ((primitive-ref write-char) . 4) (f6562 . -28) (f6563 . -24) (f6564 . -20) (f6565 . -16) (f6566 . -12) (f6567 . -8) (f6568 . -4) (f6569 . 0))
# var=f6600
    movl -12(%esp), %eax  # stack load f6600
# end emit-variable-ref
    movl %eax, -20(%esp)  # stack save
# emit-tail-expr
# si=-24
# env=((f6600 . -20) (f6599 . -16) (f6600 . -12) (f6599 . -8) ((primitive-ref write-char) . 20) ((primitive-ref string->list) . 16) ((primitive-ref write-char) . 12) ((primitive-ref for-each) . 8) ((primitive-ref write-char) . 4) (f6562 . -28) (f6563 . -24) (f6564 . -20) (f6565 . -16) (f6566 . -12) (f6567 . -8) (f6568 . -4) (f6569 . 0))
# expr=(begin ((primitive-ref write-char) #\" f6600) ((primitive-ref for-each) (closure (f6602) ((primitive-ref write-char) f6600) (let ((f6602 f6602)) ((primitive-ref write-char) f6602 f6600))) ((primitive-ref string->list) f6599)) ((primitive-ref write-char) #\" f6600))
# tail-begin (begin ((primitive-ref write-char) #\" f6600) ((primitive-ref for-each) (closure (f6602) ((primitive-ref write-char) f6600) (let ((f6602 f6602)) ((primitive-ref write-char) f6602 f6600))) ((primitive-ref string->list) f6599)) ((primitive-ref write-char) #\" f6600))
#   env=((f6600 . -20) (f6599 . -16) (f6600 . -12) (f6599 . -8) ((primitive-ref write-char) . 20) ((primitive-ref string->list) . 16) ((primitive-ref write-char) . 12) ((primitive-ref for-each) . 8) ((primitive-ref write-char) . 4) (f6562 . -28) (f6563 . -24) (f6564 . -20) (f6565 . -16) (f6566 . -12) (f6567 . -8) (f6568 . -4) (f6569 . 0))
# emit-expr ((primitive-ref write-char) #\" f6600)
# funcall
#    si   =-24
#    env  = ((f6600 . -20) (f6599 . -16) (f6600 . -12) (f6599 . -8) ((primitive-ref write-char) . 20) ((primitive-ref string->list) . 16) ((primitive-ref write-char) . 12) ((primitive-ref for-each) . 8) ((primitive-ref write-char) . 4) (f6562 . -28) (f6563 . -24) (f6564 . -20) (f6565 . -16) (f6566 . -12) (f6567 . -8) (f6568 . -4) (f6569 . 0))
#    expr = (funcall (primitive-ref write-char) #\" f6600)
# emit-expr (primitive-ref write-char)
    .extern mrc_write$mchar
    movl mrc_write$mchar,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_40071"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_40071":
   movl %eax,  -32(%esp)  # stash funcall-oper in closure slot
# emit-expr #\"
    movl $8719, %eax     # immed #\"
    mov %eax, -36(%esp)  # arg "
# emit-expr f6600
# emit-variable-ref
# env=((f6600 . -20) (f6599 . -16) (f6600 . -12) (f6599 . -8) ((primitive-ref write-char) . 20) ((primitive-ref string->list) . 16) ((primitive-ref write-char) . 12) ((primitive-ref for-each) . 8) ((primitive-ref write-char) . 4) (f6562 . -28) (f6563 . -24) (f6564 . -20) (f6565 . -16) (f6566 . -12) (f6567 . -8) (f6568 . -4) (f6569 . 0))
# var=f6600
    movl -20(%esp), %eax  # stack load f6600
# end emit-variable-ref
    mov %eax, -40(%esp)  # arg f6600
    movl -32(%esp), %edi   # load new closure to %edi
    add $-24, %esp   # adjust base
    movl $8,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $24, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
# emit-tail-expr
# si=-24
# env=((f6600 . -20) (f6599 . -16) (f6600 . -12) (f6599 . -8) ((primitive-ref write-char) . 20) ((primitive-ref string->list) . 16) ((primitive-ref write-char) . 12) ((primitive-ref for-each) . 8) ((primitive-ref write-char) . 4) (f6562 . -28) (f6563 . -24) (f6564 . -20) (f6565 . -16) (f6566 . -12) (f6567 . -8) (f6568 . -4) (f6569 . 0))
# expr=(begin ((primitive-ref for-each) (closure (f6602) ((primitive-ref write-char) f6600) (let ((f6602 f6602)) ((primitive-ref write-char) f6602 f6600))) ((primitive-ref string->list) f6599)) ((primitive-ref write-char) #\" f6600))
# tail-begin (begin ((primitive-ref for-each) (closure (f6602) ((primitive-ref write-char) f6600) (let ((f6602 f6602)) ((primitive-ref write-char) f6602 f6600))) ((primitive-ref string->list) f6599)) ((primitive-ref write-char) #\" f6600))
#   env=((f6600 . -20) (f6599 . -16) (f6600 . -12) (f6599 . -8) ((primitive-ref write-char) . 20) ((primitive-ref string->list) . 16) ((primitive-ref write-char) . 12) ((primitive-ref for-each) . 8) ((primitive-ref write-char) . 4) (f6562 . -28) (f6563 . -24) (f6564 . -20) (f6565 . -16) (f6566 . -12) (f6567 . -8) (f6568 . -4) (f6569 . 0))
# emit-expr ((primitive-ref for-each) (closure (f6602) ((primitive-ref write-char) f6600) (let ((f6602 f6602)) ((primitive-ref write-char) f6602 f6600))) ((primitive-ref string->list) f6599))
# funcall
#    si   =-24
#    env  = ((f6600 . -20) (f6599 . -16) (f6600 . -12) (f6599 . -8) ((primitive-ref write-char) . 20) ((primitive-ref string->list) . 16) ((primitive-ref write-char) . 12) ((primitive-ref for-each) . 8) ((primitive-ref write-char) . 4) (f6562 . -28) (f6563 . -24) (f6564 . -20) (f6565 . -16) (f6566 . -12) (f6567 . -8) (f6568 . -4) (f6569 . 0))
#    expr = (funcall (primitive-ref for-each) (closure (f6602) ((primitive-ref write-char) f6600) (let ((f6602 f6602)) ((primitive-ref write-char) f6602 f6600))) ((primitive-ref string->list) f6599))
# emit-expr (primitive-ref for-each)
    .extern mrc_for$meach
    movl mrc_for$meach,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_40072"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_40072":
   movl %eax,  -32(%esp)  # stash funcall-oper in closure slot
# emit-expr (closure (f6602) ((primitive-ref write-char) f6600) (let ((f6602 f6602)) ((primitive-ref write-char) f6602 f6600)))
# emit-closure
# si = -36
# env = ((f6600 . -20) (f6599 . -16) (f6600 . -12) (f6599 . -8) ((primitive-ref write-char) . 20) ((primitive-ref string->list) . 16) ((primitive-ref write-char) . 12) ((primitive-ref for-each) . 8) ((primitive-ref write-char) . 4) (f6562 . -28) (f6563 . -24) (f6564 . -20) (f6565 . -16) (f6566 . -12) (f6567 . -8) (f6568 . -4) (f6569 . 0))
# expr = (closure (f6602) ((primitive-ref write-char) f6600) (let ((f6602 f6602)) ((primitive-ref write-char) f6602 f6600)))
    movl $_L_40073, 0(%ebp)  # closure label
# emit-variable-ref
# env=((f6600 . -20) (f6599 . -16) (f6600 . -12) (f6599 . -8) ((primitive-ref write-char) . 20) ((primitive-ref string->list) . 16) ((primitive-ref write-char) . 12) ((primitive-ref for-each) . 8) ((primitive-ref write-char) . 4) (f6562 . -28) (f6563 . -24) (f6564 . -20) (f6565 . -16) (f6566 . -12) (f6567 . -8) (f6568 . -4) (f6569 . 0))
# var=(primitive-ref write-char)
    movl 18(%edi), %eax  # frame load (primitive-ref write-char)
# end emit-variable-ref
   movl  %eax, 4(%ebp)  # (primitive-ref write-char)
# emit-variable-ref
# env=((f6600 . -20) (f6599 . -16) (f6600 . -12) (f6599 . -8) ((primitive-ref write-char) . 20) ((primitive-ref string->list) . 16) ((primitive-ref write-char) . 12) ((primitive-ref for-each) . 8) ((primitive-ref write-char) . 4) (f6562 . -28) (f6563 . -24) (f6564 . -20) (f6565 . -16) (f6566 . -12) (f6567 . -8) (f6568 . -4) (f6569 . 0))
# var=f6600
    movl -20(%esp), %eax  # stack load f6600
# end emit-variable-ref
   movl  %eax, 8(%ebp)  # f6600
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $16, %ebp     # bump ebp
    jmp _L_40074            # jump around closure body
_L_40073:
# check argument count
    cmp $4,%eax
    je _L_40075
# invoke error handler eh_argcount
    .extern mrc_eh$uargcount
    movl mrc_eh$uargcount, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_40075:
# emit-tail-expr
# si=-12
# env=((f6602 . -8) (f6600 . 8) ((primitive-ref write-char) . 4) (f6600 . -20) (f6599 . -16) (f6600 . -12) (f6599 . -8) ((primitive-ref write-char) . 20) ((primitive-ref string->list) . 16) ((primitive-ref write-char) . 12) ((primitive-ref for-each) . 8) ((primitive-ref write-char) . 4) (f6562 . -28) (f6563 . -24) (f6564 . -20) (f6565 . -16) (f6566 . -12) (f6567 . -8) (f6568 . -4) (f6569 . 0))
# expr=(let ((f6602 f6602)) ((primitive-ref write-char) f6602 f6600))
# emit-tail-let
#  si   = -12
#  env  = ((f6602 . -8) (f6600 . 8) ((primitive-ref write-char) . 4) (f6600 . -20) (f6599 . -16) (f6600 . -12) (f6599 . -8) ((primitive-ref write-char) . 20) ((primitive-ref string->list) . 16) ((primitive-ref write-char) . 12) ((primitive-ref for-each) . 8) ((primitive-ref write-char) . 4) (f6562 . -28) (f6563 . -24) (f6564 . -20) (f6565 . -16) (f6566 . -12) (f6567 . -8) (f6568 . -4) (f6569 . 0))
#  bindings = ((f6602 f6602))
#  body = ((primitive-ref write-char) f6602 f6600)
# emit-expr f6602
# emit-variable-ref
# env=((f6602 . -8) (f6600 . 8) ((primitive-ref write-char) . 4) (f6600 . -20) (f6599 . -16) (f6600 . -12) (f6599 . -8) ((primitive-ref write-char) . 20) ((primitive-ref string->list) . 16) ((primitive-ref write-char) . 12) ((primitive-ref for-each) . 8) ((primitive-ref write-char) . 4) (f6562 . -28) (f6563 . -24) (f6564 . -20) (f6565 . -16) (f6566 . -12) (f6567 . -8) (f6568 . -4) (f6569 . 0))
# var=f6602
    movl -8(%esp), %eax  # stack load f6602
# end emit-variable-ref
    movl %eax, -12(%esp)  # stack save
# emit-tail-expr
# si=-16
# env=((f6602 . -12) (f6602 . -8) (f6600 . 8) ((primitive-ref write-char) . 4) (f6600 . -20) (f6599 . -16) (f6600 . -12) (f6599 . -8) ((primitive-ref write-char) . 20) ((primitive-ref string->list) . 16) ((primitive-ref write-char) . 12) ((primitive-ref for-each) . 8) ((primitive-ref write-char) . 4) (f6562 . -28) (f6563 . -24) (f6564 . -20) (f6565 . -16) (f6566 . -12) (f6567 . -8) (f6568 . -4) (f6569 . 0))
# expr=((primitive-ref write-char) f6602 f6600)
# emit-tail-funcall
#    si   =-16
#    env  = ((f6602 . -12) (f6602 . -8) (f6600 . 8) ((primitive-ref write-char) . 4) (f6600 . -20) (f6599 . -16) (f6600 . -12) (f6599 . -8) ((primitive-ref write-char) . 20) ((primitive-ref string->list) . 16) ((primitive-ref write-char) . 12) ((primitive-ref for-each) . 8) ((primitive-ref write-char) . 4) (f6562 . -28) (f6563 . -24) (f6564 . -20) (f6565 . -16) (f6566 . -12) (f6567 . -8) (f6568 . -4) (f6569 . 0))
#    expr = (funcall (primitive-ref write-char) f6602 f6600)
# emit-expr (primitive-ref write-char)
    .extern mrc_write$mchar
    movl mrc_write$mchar,%eax
   movl %eax,  -16(%esp)  # stash funcall-oper in next closure slot
# emit-expr f6602
# emit-variable-ref
# env=((f6602 . -12) (f6602 . -8) (f6600 . 8) ((primitive-ref write-char) . 4) (f6600 . -20) (f6599 . -16) (f6600 . -12) (f6599 . -8) ((primitive-ref write-char) . 20) ((primitive-ref string->list) . 16) ((primitive-ref write-char) . 12) ((primitive-ref for-each) . 8) ((primitive-ref write-char) . 4) (f6562 . -28) (f6563 . -24) (f6564 . -20) (f6565 . -16) (f6566 . -12) (f6567 . -8) (f6568 . -4) (f6569 . 0))
# var=f6602
    movl -12(%esp), %eax  # stack load f6602
# end emit-variable-ref
    mov %eax, -20(%esp)    # arg f6602
# emit-expr f6600
# emit-variable-ref
# env=((f6602 . -12) (f6602 . -8) (f6600 . 8) ((primitive-ref write-char) . 4) (f6600 . -20) (f6599 . -16) (f6600 . -12) (f6599 . -8) ((primitive-ref write-char) . 20) ((primitive-ref string->list) . 16) ((primitive-ref write-char) . 12) ((primitive-ref for-each) . 8) ((primitive-ref write-char) . 4) (f6562 . -28) (f6563 . -24) (f6564 . -20) (f6565 . -16) (f6566 . -12) (f6567 . -8) (f6568 . -4) (f6569 . 0))
# var=f6600
    movl 6(%edi), %eax  # frame load f6600
# end emit-variable-ref
    mov %eax, -24(%esp)    # arg f6600
    movl -16(%esp), %edi   # load new closure to %edi
# emit-shift-args:  size=3   si=-16  delta=12
    mov -16(%esp), %ebx  # shift frame cell
    mov %ebx, -4(%esp)  # down to base
# emit-shift-args:  size=2   si=-20  delta=12
    mov -20(%esp), %ebx  # shift frame cell
    mov %ebx, -8(%esp)  # down to base
# emit-shift-args:  size=1   si=-24  delta=12
    mov -24(%esp), %ebx  # shift frame cell
    mov %ebx, -12(%esp)  # down to base
# emit-shift-args:  size=0   si=-28  delta=12
    movl $8,%eax   # save arg count
    jmp *-2(%edi)  # tail-funcall
    .align 4,0x90
_L_40074:
    mov %eax, -36(%esp)  # arg (closure (f6602) ((primitive-ref write-char) f6600) (let ((f6602 f6602)) ((primitive-ref write-char) f6602 f6600)))
# emit-expr ((primitive-ref string->list) f6599)
# funcall
#    si   =-40
#    env  = ((f6600 . -20) (f6599 . -16) (f6600 . -12) (f6599 . -8) ((primitive-ref write-char) . 20) ((primitive-ref string->list) . 16) ((primitive-ref write-char) . 12) ((primitive-ref for-each) . 8) ((primitive-ref write-char) . 4) (f6562 . -28) (f6563 . -24) (f6564 . -20) (f6565 . -16) (f6566 . -12) (f6567 . -8) (f6568 . -4) (f6569 . 0))
#    expr = (funcall (primitive-ref string->list) f6599)
# emit-expr (primitive-ref string->list)
    .extern mrc_string$m$glist
    movl mrc_string$m$glist,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_40076"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_40076":
   movl %eax,  -48(%esp)  # stash funcall-oper in closure slot
# emit-expr f6599
# emit-variable-ref
# env=((f6600 . -20) (f6599 . -16) (f6600 . -12) (f6599 . -8) ((primitive-ref write-char) . 20) ((primitive-ref string->list) . 16) ((primitive-ref write-char) . 12) ((primitive-ref for-each) . 8) ((primitive-ref write-char) . 4) (f6562 . -28) (f6563 . -24) (f6564 . -20) (f6565 . -16) (f6566 . -12) (f6567 . -8) (f6568 . -4) (f6569 . 0))
# var=f6599
    movl -16(%esp), %eax  # stack load f6599
# end emit-variable-ref
    mov %eax, -52(%esp)  # arg f6599
    movl -48(%esp), %edi   # load new closure to %edi
    add $-40, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $40, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    mov %eax, -40(%esp)  # arg ((primitive-ref string->list) f6599)
    movl -32(%esp), %edi   # load new closure to %edi
    add $-24, %esp   # adjust base
    movl $8,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $24, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
# emit-tail-expr
# si=-24
# env=((f6600 . -20) (f6599 . -16) (f6600 . -12) (f6599 . -8) ((primitive-ref write-char) . 20) ((primitive-ref string->list) . 16) ((primitive-ref write-char) . 12) ((primitive-ref for-each) . 8) ((primitive-ref write-char) . 4) (f6562 . -28) (f6563 . -24) (f6564 . -20) (f6565 . -16) (f6566 . -12) (f6567 . -8) (f6568 . -4) (f6569 . 0))
# expr=(begin ((primitive-ref write-char) #\" f6600))
# tail-begin (begin ((primitive-ref write-char) #\" f6600))
#   env=((f6600 . -20) (f6599 . -16) (f6600 . -12) (f6599 . -8) ((primitive-ref write-char) . 20) ((primitive-ref string->list) . 16) ((primitive-ref write-char) . 12) ((primitive-ref for-each) . 8) ((primitive-ref write-char) . 4) (f6562 . -28) (f6563 . -24) (f6564 . -20) (f6565 . -16) (f6566 . -12) (f6567 . -8) (f6568 . -4) (f6569 . 0))
# emit-tail-expr
# si=-24
# env=((f6600 . -20) (f6599 . -16) (f6600 . -12) (f6599 . -8) ((primitive-ref write-char) . 20) ((primitive-ref string->list) . 16) ((primitive-ref write-char) . 12) ((primitive-ref for-each) . 8) ((primitive-ref write-char) . 4) (f6562 . -28) (f6563 . -24) (f6564 . -20) (f6565 . -16) (f6566 . -12) (f6567 . -8) (f6568 . -4) (f6569 . 0))
# expr=((primitive-ref write-char) #\" f6600)
# emit-tail-funcall
#    si   =-24
#    env  = ((f6600 . -20) (f6599 . -16) (f6600 . -12) (f6599 . -8) ((primitive-ref write-char) . 20) ((primitive-ref string->list) . 16) ((primitive-ref write-char) . 12) ((primitive-ref for-each) . 8) ((primitive-ref write-char) . 4) (f6562 . -28) (f6563 . -24) (f6564 . -20) (f6565 . -16) (f6566 . -12) (f6567 . -8) (f6568 . -4) (f6569 . 0))
#    expr = (funcall (primitive-ref write-char) #\" f6600)
# emit-expr (primitive-ref write-char)
    .extern mrc_write$mchar
    movl mrc_write$mchar,%eax
   movl %eax,  -24(%esp)  # stash funcall-oper in next closure slot
# emit-expr #\"
    movl $8719, %eax     # immed #\"
    mov %eax, -28(%esp)    # arg "
# emit-expr f6600
# emit-variable-ref
# env=((f6600 . -20) (f6599 . -16) (f6600 . -12) (f6599 . -8) ((primitive-ref write-char) . 20) ((primitive-ref string->list) . 16) ((primitive-ref write-char) . 12) ((primitive-ref for-each) . 8) ((primitive-ref write-char) . 4) (f6562 . -28) (f6563 . -24) (f6564 . -20) (f6565 . -16) (f6566 . -12) (f6567 . -8) (f6568 . -4) (f6569 . 0))
# var=f6600
    movl -20(%esp), %eax  # stack load f6600
# end emit-variable-ref
    mov %eax, -32(%esp)    # arg f6600
    movl -24(%esp), %edi   # load new closure to %edi
# emit-shift-args:  size=3   si=-24  delta=20
    mov -24(%esp), %ebx  # shift frame cell
    mov %ebx, -4(%esp)  # down to base
# emit-shift-args:  size=2   si=-28  delta=20
    mov -28(%esp), %ebx  # shift frame cell
    mov %ebx, -8(%esp)  # down to base
# emit-shift-args:  size=1   si=-32  delta=20
    mov -32(%esp), %ebx  # shift frame cell
    mov %ebx, -12(%esp)  # down to base
# emit-shift-args:  size=0   si=-36  delta=20
    movl $8,%eax   # save arg count
    jmp *-2(%edi)  # tail-funcall
     ret   # return thru stack
    .align 4,0x90
_L_40069:
    movl -32(%esp), %ebx
    movl -36(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin (vector-set! f6564 0 (closure (f6595 f6596) ((primitive-ref for-each) (primitive-ref write-char) (primitive-ref string->list)) (let ((f6595 f6595) (f6596 f6596)) ((primitive-ref for-each) (closure (f6598) ((primitive-ref write-char) f6596) (let ((f6598 f6598)) ((primitive-ref write-char) f6598 f6596))) ((primitive-ref string->list) f6595))))) (vector-set! f6563 0 (closure (f6593 f6594) ((primitive-ref write-char) f6562 (primitive-ref write-char)) (let ((f6593 f6593) (f6594 f6594)) (begin ((primitive-ref write-char) #\( f6594) ((vector-ref f6562 0) f6593 f6594) ((primitive-ref write-char) #\) f6594))))) (vector-set! f6562 0 (closure (f6591 f6592) ((primitive-ref write) (primitive-ref write-char) f6562 else (primitive-ref write-char) (primitive-ref write-char) (primitive-ref write-char) (primitive-ref write)) (let ((f6591 f6591) (f6592 f6592)) (begin ((primitive-ref write) (car f6591) f6592) (if (null? (cdr f6591)) #t (if (pair? (cdr f6591)) (begin ((primitive-ref write-char) #\space f6592) ((vector-ref f6562 0) (cdr f6591) f6592)) (begin ((primitive-ref write-char) #\space f6592) ((primitive-ref write-char) #\. f6592) ((primitive-ref write-char) #\space f6592) ((primitive-ref write) (cdr f6591) f6592)))))))))
# emit-begin
#   expr=(begin (vector-set! f6564 0 (closure (f6595 f6596) ((primitive-ref for-each) (primitive-ref write-char) (primitive-ref string->list)) (let ((f6595 f6595) (f6596 f6596)) ((primitive-ref for-each) (closure (f6598) ((primitive-ref write-char) f6596) (let ((f6598 f6598)) ((primitive-ref write-char) f6598 f6596))) ((primitive-ref string->list) f6595))))) (vector-set! f6563 0 (closure (f6593 f6594) ((primitive-ref write-char) f6562 (primitive-ref write-char)) (let ((f6593 f6593) (f6594 f6594)) (begin ((primitive-ref write-char) #\( f6594) ((vector-ref f6562 0) f6593 f6594) ((primitive-ref write-char) #\) f6594))))) (vector-set! f6562 0 (closure (f6591 f6592) ((primitive-ref write) (primitive-ref write-char) f6562 else (primitive-ref write-char) (primitive-ref write-char) (primitive-ref write-char) (primitive-ref write)) (let ((f6591 f6591) (f6592 f6592)) (begin ((primitive-ref write) (car f6591) f6592) (if (null? (cdr f6591)) #t (if (pair? (cdr f6591)) (begin ((primitive-ref write-char) #\space f6592) ((vector-ref f6562 0) (cdr f6591) f6592)) (begin ((primitive-ref write-char) #\space f6592) ((primitive-ref write-char) #\. f6592) ((primitive-ref write-char) #\space f6592) ((primitive-ref write) (cdr f6591) f6592)))))))))
#   env=((f6562 . -28) (f6563 . -24) (f6564 . -20) (f6565 . -16) (f6566 . -12) (f6567 . -8) (f6568 . -4) (f6569 . 0))
# emit-expr (vector-set! f6564 0 (closure (f6595 f6596) ((primitive-ref for-each) (primitive-ref write-char) (primitive-ref string->list)) (let ((f6595 f6595) (f6596 f6596)) ((primitive-ref for-each) (closure (f6598) ((primitive-ref write-char) f6596) (let ((f6598 f6598)) ((primitive-ref write-char) f6598 f6596))) ((primitive-ref string->list) f6595)))))
# emit-expr f6564
# emit-variable-ref
# env=((f6562 . -28) (f6563 . -24) (f6564 . -20) (f6565 . -16) (f6566 . -12) (f6567 . -8) (f6568 . -4) (f6569 . 0))
# var=f6564
    movl -20(%esp), %eax  # stack load f6564
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_40077
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_40077:
    movl %eax, -32(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_40078"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_40078:
# check bounds on vector index
    movl -32(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_40080
    cmp  $0,%eax
    jge _L_40079
_L_40080:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_40079:
    movl %eax, -36(%esp)
# emit-expr (closure (f6595 f6596) ((primitive-ref for-each) (primitive-ref write-char) (primitive-ref string->list)) (let ((f6595 f6595) (f6596 f6596)) ((primitive-ref for-each) (closure (f6598) ((primitive-ref write-char) f6596) (let ((f6598 f6598)) ((primitive-ref write-char) f6598 f6596))) ((primitive-ref string->list) f6595))))
# emit-closure
# si = -40
# env = ((f6562 . -28) (f6563 . -24) (f6564 . -20) (f6565 . -16) (f6566 . -12) (f6567 . -8) (f6568 . -4) (f6569 . 0))
# expr = (closure (f6595 f6596) ((primitive-ref for-each) (primitive-ref write-char) (primitive-ref string->list)) (let ((f6595 f6595) (f6596 f6596)) ((primitive-ref for-each) (closure (f6598) ((primitive-ref write-char) f6596) (let ((f6598 f6598)) ((primitive-ref write-char) f6598 f6596))) ((primitive-ref string->list) f6595))))
    movl $_L_40081, 0(%ebp)  # closure label
# WARNING: free var (primitive-ref for-each) not defined in the environmnet
# WARNING: free var (primitive-ref write-char) not defined in the environmnet
# WARNING: free var (primitive-ref string->list) not defined in the environmnet
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $16, %ebp     # bump ebp
    jmp _L_40082            # jump around closure body
_L_40081:
# check argument count
    cmp $8,%eax
    je _L_40083
# invoke error handler eh_argcount
    .extern mrc_eh$uargcount
    movl mrc_eh$uargcount, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_40083:
# emit-tail-expr
# si=-16
# env=((f6596 . -12) (f6595 . -8) ((primitive-ref string->list) . 12) ((primitive-ref write-char) . 8) ((primitive-ref for-each) . 4) (f6562 . -28) (f6563 . -24) (f6564 . -20) (f6565 . -16) (f6566 . -12) (f6567 . -8) (f6568 . -4) (f6569 . 0))
# expr=(let ((f6595 f6595) (f6596 f6596)) ((primitive-ref for-each) (closure (f6598) ((primitive-ref write-char) f6596) (let ((f6598 f6598)) ((primitive-ref write-char) f6598 f6596))) ((primitive-ref string->list) f6595)))
# emit-tail-let
#  si   = -16
#  env  = ((f6596 . -12) (f6595 . -8) ((primitive-ref string->list) . 12) ((primitive-ref write-char) . 8) ((primitive-ref for-each) . 4) (f6562 . -28) (f6563 . -24) (f6564 . -20) (f6565 . -16) (f6566 . -12) (f6567 . -8) (f6568 . -4) (f6569 . 0))
#  bindings = ((f6595 f6595) (f6596 f6596))
#  body = ((primitive-ref for-each) (closure (f6598) ((primitive-ref write-char) f6596) (let ((f6598 f6598)) ((primitive-ref write-char) f6598 f6596))) ((primitive-ref string->list) f6595))
# emit-expr f6595
# emit-variable-ref
# env=((f6596 . -12) (f6595 . -8) ((primitive-ref string->list) . 12) ((primitive-ref write-char) . 8) ((primitive-ref for-each) . 4) (f6562 . -28) (f6563 . -24) (f6564 . -20) (f6565 . -16) (f6566 . -12) (f6567 . -8) (f6568 . -4) (f6569 . 0))
# var=f6595
    movl -8(%esp), %eax  # stack load f6595
# end emit-variable-ref
    movl %eax, -16(%esp)  # stack save
# emit-expr f6596
# emit-variable-ref
# env=((f6596 . -12) (f6595 . -8) ((primitive-ref string->list) . 12) ((primitive-ref write-char) . 8) ((primitive-ref for-each) . 4) (f6562 . -28) (f6563 . -24) (f6564 . -20) (f6565 . -16) (f6566 . -12) (f6567 . -8) (f6568 . -4) (f6569 . 0))
# var=f6596
    movl -12(%esp), %eax  # stack load f6596
# end emit-variable-ref
    movl %eax, -20(%esp)  # stack save
# emit-tail-expr
# si=-24
# env=((f6596 . -20) (f6595 . -16) (f6596 . -12) (f6595 . -8) ((primitive-ref string->list) . 12) ((primitive-ref write-char) . 8) ((primitive-ref for-each) . 4) (f6562 . -28) (f6563 . -24) (f6564 . -20) (f6565 . -16) (f6566 . -12) (f6567 . -8) (f6568 . -4) (f6569 . 0))
# expr=((primitive-ref for-each) (closure (f6598) ((primitive-ref write-char) f6596) (let ((f6598 f6598)) ((primitive-ref write-char) f6598 f6596))) ((primitive-ref string->list) f6595))
# emit-tail-funcall
#    si   =-24
#    env  = ((f6596 . -20) (f6595 . -16) (f6596 . -12) (f6595 . -8) ((primitive-ref string->list) . 12) ((primitive-ref write-char) . 8) ((primitive-ref for-each) . 4) (f6562 . -28) (f6563 . -24) (f6564 . -20) (f6565 . -16) (f6566 . -12) (f6567 . -8) (f6568 . -4) (f6569 . 0))
#    expr = (funcall (primitive-ref for-each) (closure (f6598) ((primitive-ref write-char) f6596) (let ((f6598 f6598)) ((primitive-ref write-char) f6598 f6596))) ((primitive-ref string->list) f6595))
# emit-expr (primitive-ref for-each)
    .extern mrc_for$meach
    movl mrc_for$meach,%eax
   movl %eax,  -24(%esp)  # stash funcall-oper in next closure slot
# emit-expr (closure (f6598) ((primitive-ref write-char) f6596) (let ((f6598 f6598)) ((primitive-ref write-char) f6598 f6596)))
# emit-closure
# si = -28
# env = ((f6596 . -20) (f6595 . -16) (f6596 . -12) (f6595 . -8) ((primitive-ref string->list) . 12) ((primitive-ref write-char) . 8) ((primitive-ref for-each) . 4) (f6562 . -28) (f6563 . -24) (f6564 . -20) (f6565 . -16) (f6566 . -12) (f6567 . -8) (f6568 . -4) (f6569 . 0))
# expr = (closure (f6598) ((primitive-ref write-char) f6596) (let ((f6598 f6598)) ((primitive-ref write-char) f6598 f6596)))
    movl $_L_40084, 0(%ebp)  # closure label
# emit-variable-ref
# env=((f6596 . -20) (f6595 . -16) (f6596 . -12) (f6595 . -8) ((primitive-ref string->list) . 12) ((primitive-ref write-char) . 8) ((primitive-ref for-each) . 4) (f6562 . -28) (f6563 . -24) (f6564 . -20) (f6565 . -16) (f6566 . -12) (f6567 . -8) (f6568 . -4) (f6569 . 0))
# var=(primitive-ref write-char)
    movl 6(%edi), %eax  # frame load (primitive-ref write-char)
# end emit-variable-ref
   movl  %eax, 4(%ebp)  # (primitive-ref write-char)
# emit-variable-ref
# env=((f6596 . -20) (f6595 . -16) (f6596 . -12) (f6595 . -8) ((primitive-ref string->list) . 12) ((primitive-ref write-char) . 8) ((primitive-ref for-each) . 4) (f6562 . -28) (f6563 . -24) (f6564 . -20) (f6565 . -16) (f6566 . -12) (f6567 . -8) (f6568 . -4) (f6569 . 0))
# var=f6596
    movl -20(%esp), %eax  # stack load f6596
# end emit-variable-ref
   movl  %eax, 8(%ebp)  # f6596
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $16, %ebp     # bump ebp
    jmp _L_40085            # jump around closure body
_L_40084:
# check argument count
    cmp $4,%eax
    je _L_40086
# invoke error handler eh_argcount
    .extern mrc_eh$uargcount
    movl mrc_eh$uargcount, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_40086:
# emit-tail-expr
# si=-12
# env=((f6598 . -8) (f6596 . 8) ((primitive-ref write-char) . 4) (f6596 . -20) (f6595 . -16) (f6596 . -12) (f6595 . -8) ((primitive-ref string->list) . 12) ((primitive-ref write-char) . 8) ((primitive-ref for-each) . 4) (f6562 . -28) (f6563 . -24) (f6564 . -20) (f6565 . -16) (f6566 . -12) (f6567 . -8) (f6568 . -4) (f6569 . 0))
# expr=(let ((f6598 f6598)) ((primitive-ref write-char) f6598 f6596))
# emit-tail-let
#  si   = -12
#  env  = ((f6598 . -8) (f6596 . 8) ((primitive-ref write-char) . 4) (f6596 . -20) (f6595 . -16) (f6596 . -12) (f6595 . -8) ((primitive-ref string->list) . 12) ((primitive-ref write-char) . 8) ((primitive-ref for-each) . 4) (f6562 . -28) (f6563 . -24) (f6564 . -20) (f6565 . -16) (f6566 . -12) (f6567 . -8) (f6568 . -4) (f6569 . 0))
#  bindings = ((f6598 f6598))
#  body = ((primitive-ref write-char) f6598 f6596)
# emit-expr f6598
# emit-variable-ref
# env=((f6598 . -8) (f6596 . 8) ((primitive-ref write-char) . 4) (f6596 . -20) (f6595 . -16) (f6596 . -12) (f6595 . -8) ((primitive-ref string->list) . 12) ((primitive-ref write-char) . 8) ((primitive-ref for-each) . 4) (f6562 . -28) (f6563 . -24) (f6564 . -20) (f6565 . -16) (f6566 . -12) (f6567 . -8) (f6568 . -4) (f6569 . 0))
# var=f6598
    movl -8(%esp), %eax  # stack load f6598
# end emit-variable-ref
    movl %eax, -12(%esp)  # stack save
# emit-tail-expr
# si=-16
# env=((f6598 . -12) (f6598 . -8) (f6596 . 8) ((primitive-ref write-char) . 4) (f6596 . -20) (f6595 . -16) (f6596 . -12) (f6595 . -8) ((primitive-ref string->list) . 12) ((primitive-ref write-char) . 8) ((primitive-ref for-each) . 4) (f6562 . -28) (f6563 . -24) (f6564 . -20) (f6565 . -16) (f6566 . -12) (f6567 . -8) (f6568 . -4) (f6569 . 0))
# expr=((primitive-ref write-char) f6598 f6596)
# emit-tail-funcall
#    si   =-16
#    env  = ((f6598 . -12) (f6598 . -8) (f6596 . 8) ((primitive-ref write-char) . 4) (f6596 . -20) (f6595 . -16) (f6596 . -12) (f6595 . -8) ((primitive-ref string->list) . 12) ((primitive-ref write-char) . 8) ((primitive-ref for-each) . 4) (f6562 . -28) (f6563 . -24) (f6564 . -20) (f6565 . -16) (f6566 . -12) (f6567 . -8) (f6568 . -4) (f6569 . 0))
#    expr = (funcall (primitive-ref write-char) f6598 f6596)
# emit-expr (primitive-ref write-char)
    .extern mrc_write$mchar
    movl mrc_write$mchar,%eax
   movl %eax,  -16(%esp)  # stash funcall-oper in next closure slot
# emit-expr f6598
# emit-variable-ref
# env=((f6598 . -12) (f6598 . -8) (f6596 . 8) ((primitive-ref write-char) . 4) (f6596 . -20) (f6595 . -16) (f6596 . -12) (f6595 . -8) ((primitive-ref string->list) . 12) ((primitive-ref write-char) . 8) ((primitive-ref for-each) . 4) (f6562 . -28) (f6563 . -24) (f6564 . -20) (f6565 . -16) (f6566 . -12) (f6567 . -8) (f6568 . -4) (f6569 . 0))
# var=f6598
    movl -12(%esp), %eax  # stack load f6598
# end emit-variable-ref
    mov %eax, -20(%esp)    # arg f6598
# emit-expr f6596
# emit-variable-ref
# env=((f6598 . -12) (f6598 . -8) (f6596 . 8) ((primitive-ref write-char) . 4) (f6596 . -20) (f6595 . -16) (f6596 . -12) (f6595 . -8) ((primitive-ref string->list) . 12) ((primitive-ref write-char) . 8) ((primitive-ref for-each) . 4) (f6562 . -28) (f6563 . -24) (f6564 . -20) (f6565 . -16) (f6566 . -12) (f6567 . -8) (f6568 . -4) (f6569 . 0))
# var=f6596
    movl 6(%edi), %eax  # frame load f6596
# end emit-variable-ref
    mov %eax, -24(%esp)    # arg f6596
    movl -16(%esp), %edi   # load new closure to %edi
# emit-shift-args:  size=3   si=-16  delta=12
    mov -16(%esp), %ebx  # shift frame cell
    mov %ebx, -4(%esp)  # down to base
# emit-shift-args:  size=2   si=-20  delta=12
    mov -20(%esp), %ebx  # shift frame cell
    mov %ebx, -8(%esp)  # down to base
# emit-shift-args:  size=1   si=-24  delta=12
    mov -24(%esp), %ebx  # shift frame cell
    mov %ebx, -12(%esp)  # down to base
# emit-shift-args:  size=0   si=-28  delta=12
    movl $8,%eax   # save arg count
    jmp *-2(%edi)  # tail-funcall
    .align 4,0x90
_L_40085:
    mov %eax, -28(%esp)    # arg (closure (f6598) ((primitive-ref write-char) f6596) (let ((f6598 f6598)) ((primitive-ref write-char) f6598 f6596)))
# emit-expr ((primitive-ref string->list) f6595)
# funcall
#    si   =-32
#    env  = ((f6596 . -20) (f6595 . -16) (f6596 . -12) (f6595 . -8) ((primitive-ref string->list) . 12) ((primitive-ref write-char) . 8) ((primitive-ref for-each) . 4) (f6562 . -28) (f6563 . -24) (f6564 . -20) (f6565 . -16) (f6566 . -12) (f6567 . -8) (f6568 . -4) (f6569 . 0))
#    expr = (funcall (primitive-ref string->list) f6595)
# emit-expr (primitive-ref string->list)
    .extern mrc_string$m$glist
    movl mrc_string$m$glist,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_40087"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_40087":
   movl %eax,  -40(%esp)  # stash funcall-oper in closure slot
# emit-expr f6595
# emit-variable-ref
# env=((f6596 . -20) (f6595 . -16) (f6596 . -12) (f6595 . -8) ((primitive-ref string->list) . 12) ((primitive-ref write-char) . 8) ((primitive-ref for-each) . 4) (f6562 . -28) (f6563 . -24) (f6564 . -20) (f6565 . -16) (f6566 . -12) (f6567 . -8) (f6568 . -4) (f6569 . 0))
# var=f6595
    movl -16(%esp), %eax  # stack load f6595
# end emit-variable-ref
    mov %eax, -44(%esp)  # arg f6595
    movl -40(%esp), %edi   # load new closure to %edi
    add $-32, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $32, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    mov %eax, -32(%esp)    # arg ((primitive-ref string->list) f6595)
    movl -24(%esp), %edi   # load new closure to %edi
# emit-shift-args:  size=3   si=-24  delta=20
    mov -24(%esp), %ebx  # shift frame cell
    mov %ebx, -4(%esp)  # down to base
# emit-shift-args:  size=2   si=-28  delta=20
    mov -28(%esp), %ebx  # shift frame cell
    mov %ebx, -8(%esp)  # down to base
# emit-shift-args:  size=1   si=-32  delta=20
    mov -32(%esp), %ebx  # shift frame cell
    mov %ebx, -12(%esp)  # down to base
# emit-shift-args:  size=0   si=-36  delta=20
    movl $8,%eax   # save arg count
    jmp *-2(%edi)  # tail-funcall
    .align 4,0x90
_L_40082:
    movl -32(%esp), %ebx
    movl -36(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin (vector-set! f6563 0 (closure (f6593 f6594) ((primitive-ref write-char) f6562 (primitive-ref write-char)) (let ((f6593 f6593) (f6594 f6594)) (begin ((primitive-ref write-char) #\( f6594) ((vector-ref f6562 0) f6593 f6594) ((primitive-ref write-char) #\) f6594))))) (vector-set! f6562 0 (closure (f6591 f6592) ((primitive-ref write) (primitive-ref write-char) f6562 else (primitive-ref write-char) (primitive-ref write-char) (primitive-ref write-char) (primitive-ref write)) (let ((f6591 f6591) (f6592 f6592)) (begin ((primitive-ref write) (car f6591) f6592) (if (null? (cdr f6591)) #t (if (pair? (cdr f6591)) (begin ((primitive-ref write-char) #\space f6592) ((vector-ref f6562 0) (cdr f6591) f6592)) (begin ((primitive-ref write-char) #\space f6592) ((primitive-ref write-char) #\. f6592) ((primitive-ref write-char) #\space f6592) ((primitive-ref write) (cdr f6591) f6592)))))))))
# emit-begin
#   expr=(begin (vector-set! f6563 0 (closure (f6593 f6594) ((primitive-ref write-char) f6562 (primitive-ref write-char)) (let ((f6593 f6593) (f6594 f6594)) (begin ((primitive-ref write-char) #\( f6594) ((vector-ref f6562 0) f6593 f6594) ((primitive-ref write-char) #\) f6594))))) (vector-set! f6562 0 (closure (f6591 f6592) ((primitive-ref write) (primitive-ref write-char) f6562 else (primitive-ref write-char) (primitive-ref write-char) (primitive-ref write-char) (primitive-ref write)) (let ((f6591 f6591) (f6592 f6592)) (begin ((primitive-ref write) (car f6591) f6592) (if (null? (cdr f6591)) #t (if (pair? (cdr f6591)) (begin ((primitive-ref write-char) #\space f6592) ((vector-ref f6562 0) (cdr f6591) f6592)) (begin ((primitive-ref write-char) #\space f6592) ((primitive-ref write-char) #\. f6592) ((primitive-ref write-char) #\space f6592) ((primitive-ref write) (cdr f6591) f6592)))))))))
#   env=((f6562 . -28) (f6563 . -24) (f6564 . -20) (f6565 . -16) (f6566 . -12) (f6567 . -8) (f6568 . -4) (f6569 . 0))
# emit-expr (vector-set! f6563 0 (closure (f6593 f6594) ((primitive-ref write-char) f6562 (primitive-ref write-char)) (let ((f6593 f6593) (f6594 f6594)) (begin ((primitive-ref write-char) #\( f6594) ((vector-ref f6562 0) f6593 f6594) ((primitive-ref write-char) #\) f6594)))))
# emit-expr f6563
# emit-variable-ref
# env=((f6562 . -28) (f6563 . -24) (f6564 . -20) (f6565 . -16) (f6566 . -12) (f6567 . -8) (f6568 . -4) (f6569 . 0))
# var=f6563
    movl -24(%esp), %eax  # stack load f6563
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_40088
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_40088:
    movl %eax, -32(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_40089"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_40089:
# check bounds on vector index
    movl -32(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_40091
    cmp  $0,%eax
    jge _L_40090
_L_40091:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_40090:
    movl %eax, -36(%esp)
# emit-expr (closure (f6593 f6594) ((primitive-ref write-char) f6562 (primitive-ref write-char)) (let ((f6593 f6593) (f6594 f6594)) (begin ((primitive-ref write-char) #\( f6594) ((vector-ref f6562 0) f6593 f6594) ((primitive-ref write-char) #\) f6594))))
# emit-closure
# si = -40
# env = ((f6562 . -28) (f6563 . -24) (f6564 . -20) (f6565 . -16) (f6566 . -12) (f6567 . -8) (f6568 . -4) (f6569 . 0))
# expr = (closure (f6593 f6594) ((primitive-ref write-char) f6562 (primitive-ref write-char)) (let ((f6593 f6593) (f6594 f6594)) (begin ((primitive-ref write-char) #\( f6594) ((vector-ref f6562 0) f6593 f6594) ((primitive-ref write-char) #\) f6594))))
    movl $_L_40092, 0(%ebp)  # closure label
# WARNING: free var (primitive-ref write-char) not defined in the environmnet
# emit-variable-ref
# env=((f6562 . -28) (f6563 . -24) (f6564 . -20) (f6565 . -16) (f6566 . -12) (f6567 . -8) (f6568 . -4) (f6569 . 0))
# var=f6562
    movl -28(%esp), %eax  # stack load f6562
# end emit-variable-ref
   movl  %eax, 8(%ebp)  # f6562
# WARNING: free var (primitive-ref write-char) not defined in the environmnet
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $16, %ebp     # bump ebp
    jmp _L_40093            # jump around closure body
_L_40092:
# check argument count
    cmp $8,%eax
    je _L_40094
# invoke error handler eh_argcount
    .extern mrc_eh$uargcount
    movl mrc_eh$uargcount, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_40094:
# emit-tail-expr
# si=-16
# env=((f6594 . -12) (f6593 . -8) ((primitive-ref write-char) . 12) (f6562 . 8) ((primitive-ref write-char) . 4) (f6562 . -28) (f6563 . -24) (f6564 . -20) (f6565 . -16) (f6566 . -12) (f6567 . -8) (f6568 . -4) (f6569 . 0))
# expr=(let ((f6593 f6593) (f6594 f6594)) (begin ((primitive-ref write-char) #\( f6594) ((vector-ref f6562 0) f6593 f6594) ((primitive-ref write-char) #\) f6594)))
# emit-tail-let
#  si   = -16
#  env  = ((f6594 . -12) (f6593 . -8) ((primitive-ref write-char) . 12) (f6562 . 8) ((primitive-ref write-char) . 4) (f6562 . -28) (f6563 . -24) (f6564 . -20) (f6565 . -16) (f6566 . -12) (f6567 . -8) (f6568 . -4) (f6569 . 0))
#  bindings = ((f6593 f6593) (f6594 f6594))
#  body = (begin ((primitive-ref write-char) #\( f6594) ((vector-ref f6562 0) f6593 f6594) ((primitive-ref write-char) #\) f6594))
# emit-expr f6593
# emit-variable-ref
# env=((f6594 . -12) (f6593 . -8) ((primitive-ref write-char) . 12) (f6562 . 8) ((primitive-ref write-char) . 4) (f6562 . -28) (f6563 . -24) (f6564 . -20) (f6565 . -16) (f6566 . -12) (f6567 . -8) (f6568 . -4) (f6569 . 0))
# var=f6593
    movl -8(%esp), %eax  # stack load f6593
# end emit-variable-ref
    movl %eax, -16(%esp)  # stack save
# emit-expr f6594
# emit-variable-ref
# env=((f6594 . -12) (f6593 . -8) ((primitive-ref write-char) . 12) (f6562 . 8) ((primitive-ref write-char) . 4) (f6562 . -28) (f6563 . -24) (f6564 . -20) (f6565 . -16) (f6566 . -12) (f6567 . -8) (f6568 . -4) (f6569 . 0))
# var=f6594
    movl -12(%esp), %eax  # stack load f6594
# end emit-variable-ref
    movl %eax, -20(%esp)  # stack save
# emit-tail-expr
# si=-24
# env=((f6594 . -20) (f6593 . -16) (f6594 . -12) (f6593 . -8) ((primitive-ref write-char) . 12) (f6562 . 8) ((primitive-ref write-char) . 4) (f6562 . -28) (f6563 . -24) (f6564 . -20) (f6565 . -16) (f6566 . -12) (f6567 . -8) (f6568 . -4) (f6569 . 0))
# expr=(begin ((primitive-ref write-char) #\( f6594) ((vector-ref f6562 0) f6593 f6594) ((primitive-ref write-char) #\) f6594))
# tail-begin (begin ((primitive-ref write-char) #\( f6594) ((vector-ref f6562 0) f6593 f6594) ((primitive-ref write-char) #\) f6594))
#   env=((f6594 . -20) (f6593 . -16) (f6594 . -12) (f6593 . -8) ((primitive-ref write-char) . 12) (f6562 . 8) ((primitive-ref write-char) . 4) (f6562 . -28) (f6563 . -24) (f6564 . -20) (f6565 . -16) (f6566 . -12) (f6567 . -8) (f6568 . -4) (f6569 . 0))
# emit-expr ((primitive-ref write-char) #\( f6594)
# funcall
#    si   =-24
#    env  = ((f6594 . -20) (f6593 . -16) (f6594 . -12) (f6593 . -8) ((primitive-ref write-char) . 12) (f6562 . 8) ((primitive-ref write-char) . 4) (f6562 . -28) (f6563 . -24) (f6564 . -20) (f6565 . -16) (f6566 . -12) (f6567 . -8) (f6568 . -4) (f6569 . 0))
#    expr = (funcall (primitive-ref write-char) #\( f6594)
# emit-expr (primitive-ref write-char)
    .extern mrc_write$mchar
    movl mrc_write$mchar,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_40095"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_40095":
   movl %eax,  -32(%esp)  # stash funcall-oper in closure slot
# emit-expr #\(
    movl $10255, %eax     # immed #\(
    mov %eax, -36(%esp)  # arg (
# emit-expr f6594
# emit-variable-ref
# env=((f6594 . -20) (f6593 . -16) (f6594 . -12) (f6593 . -8) ((primitive-ref write-char) . 12) (f6562 . 8) ((primitive-ref write-char) . 4) (f6562 . -28) (f6563 . -24) (f6564 . -20) (f6565 . -16) (f6566 . -12) (f6567 . -8) (f6568 . -4) (f6569 . 0))
# var=f6594
    movl -20(%esp), %eax  # stack load f6594
# end emit-variable-ref
    mov %eax, -40(%esp)  # arg f6594
    movl -32(%esp), %edi   # load new closure to %edi
    add $-24, %esp   # adjust base
    movl $8,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $24, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
# emit-tail-expr
# si=-24
# env=((f6594 . -20) (f6593 . -16) (f6594 . -12) (f6593 . -8) ((primitive-ref write-char) . 12) (f6562 . 8) ((primitive-ref write-char) . 4) (f6562 . -28) (f6563 . -24) (f6564 . -20) (f6565 . -16) (f6566 . -12) (f6567 . -8) (f6568 . -4) (f6569 . 0))
# expr=(begin ((vector-ref f6562 0) f6593 f6594) ((primitive-ref write-char) #\) f6594))
# tail-begin (begin ((vector-ref f6562 0) f6593 f6594) ((primitive-ref write-char) #\) f6594))
#   env=((f6594 . -20) (f6593 . -16) (f6594 . -12) (f6593 . -8) ((primitive-ref write-char) . 12) (f6562 . 8) ((primitive-ref write-char) . 4) (f6562 . -28) (f6563 . -24) (f6564 . -20) (f6565 . -16) (f6566 . -12) (f6567 . -8) (f6568 . -4) (f6569 . 0))
# emit-expr ((vector-ref f6562 0) f6593 f6594)
# funcall
#    si   =-24
#    env  = ((f6594 . -20) (f6593 . -16) (f6594 . -12) (f6593 . -8) ((primitive-ref write-char) . 12) (f6562 . 8) ((primitive-ref write-char) . 4) (f6562 . -28) (f6563 . -24) (f6564 . -20) (f6565 . -16) (f6566 . -12) (f6567 . -8) (f6568 . -4) (f6569 . 0))
#    expr = (funcall (vector-ref f6562 0) f6593 f6594)
# emit-expr (vector-ref f6562 0)
# emit-expr f6562
# emit-variable-ref
# env=((f6594 . -20) (f6593 . -16) (f6594 . -12) (f6593 . -8) ((primitive-ref write-char) . 12) (f6562 . 8) ((primitive-ref write-char) . 4) (f6562 . -28) (f6563 . -24) (f6564 . -20) (f6565 . -16) (f6566 . -12) (f6567 . -8) (f6568 . -4) (f6569 . 0))
# var=f6562
    movl 6(%edi), %eax  # frame load f6562
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_40096
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_40096:
    movl %eax, -32(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_40097"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_40097:
# check bounds on vector index
    movl -32(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_40099
    cmp  $0,%eax
    jge _L_40098
_L_40099:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_40098:
    movl -32(%esp), %esi
    movl -1(%eax,%esi), %eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_40100"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_40100":
   movl %eax,  -32(%esp)  # stash funcall-oper in closure slot
# emit-expr f6593
# emit-variable-ref
# env=((f6594 . -20) (f6593 . -16) (f6594 . -12) (f6593 . -8) ((primitive-ref write-char) . 12) (f6562 . 8) ((primitive-ref write-char) . 4) (f6562 . -28) (f6563 . -24) (f6564 . -20) (f6565 . -16) (f6566 . -12) (f6567 . -8) (f6568 . -4) (f6569 . 0))
# var=f6593
    movl -16(%esp), %eax  # stack load f6593
# end emit-variable-ref
    mov %eax, -36(%esp)  # arg f6593
# emit-expr f6594
# emit-variable-ref
# env=((f6594 . -20) (f6593 . -16) (f6594 . -12) (f6593 . -8) ((primitive-ref write-char) . 12) (f6562 . 8) ((primitive-ref write-char) . 4) (f6562 . -28) (f6563 . -24) (f6564 . -20) (f6565 . -16) (f6566 . -12) (f6567 . -8) (f6568 . -4) (f6569 . 0))
# var=f6594
    movl -20(%esp), %eax  # stack load f6594
# end emit-variable-ref
    mov %eax, -40(%esp)  # arg f6594
    movl -32(%esp), %edi   # load new closure to %edi
    add $-24, %esp   # adjust base
    movl $8,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $24, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
# emit-tail-expr
# si=-24
# env=((f6594 . -20) (f6593 . -16) (f6594 . -12) (f6593 . -8) ((primitive-ref write-char) . 12) (f6562 . 8) ((primitive-ref write-char) . 4) (f6562 . -28) (f6563 . -24) (f6564 . -20) (f6565 . -16) (f6566 . -12) (f6567 . -8) (f6568 . -4) (f6569 . 0))
# expr=(begin ((primitive-ref write-char) #\) f6594))
# tail-begin (begin ((primitive-ref write-char) #\) f6594))
#   env=((f6594 . -20) (f6593 . -16) (f6594 . -12) (f6593 . -8) ((primitive-ref write-char) . 12) (f6562 . 8) ((primitive-ref write-char) . 4) (f6562 . -28) (f6563 . -24) (f6564 . -20) (f6565 . -16) (f6566 . -12) (f6567 . -8) (f6568 . -4) (f6569 . 0))
# emit-tail-expr
# si=-24
# env=((f6594 . -20) (f6593 . -16) (f6594 . -12) (f6593 . -8) ((primitive-ref write-char) . 12) (f6562 . 8) ((primitive-ref write-char) . 4) (f6562 . -28) (f6563 . -24) (f6564 . -20) (f6565 . -16) (f6566 . -12) (f6567 . -8) (f6568 . -4) (f6569 . 0))
# expr=((primitive-ref write-char) #\) f6594)
# emit-tail-funcall
#    si   =-24
#    env  = ((f6594 . -20) (f6593 . -16) (f6594 . -12) (f6593 . -8) ((primitive-ref write-char) . 12) (f6562 . 8) ((primitive-ref write-char) . 4) (f6562 . -28) (f6563 . -24) (f6564 . -20) (f6565 . -16) (f6566 . -12) (f6567 . -8) (f6568 . -4) (f6569 . 0))
#    expr = (funcall (primitive-ref write-char) #\) f6594)
# emit-expr (primitive-ref write-char)
    .extern mrc_write$mchar
    movl mrc_write$mchar,%eax
   movl %eax,  -24(%esp)  # stash funcall-oper in next closure slot
# emit-expr #\)
    movl $10511, %eax     # immed #\)
    mov %eax, -28(%esp)    # arg )
# emit-expr f6594
# emit-variable-ref
# env=((f6594 . -20) (f6593 . -16) (f6594 . -12) (f6593 . -8) ((primitive-ref write-char) . 12) (f6562 . 8) ((primitive-ref write-char) . 4) (f6562 . -28) (f6563 . -24) (f6564 . -20) (f6565 . -16) (f6566 . -12) (f6567 . -8) (f6568 . -4) (f6569 . 0))
# var=f6594
    movl -20(%esp), %eax  # stack load f6594
# end emit-variable-ref
    mov %eax, -32(%esp)    # arg f6594
    movl -24(%esp), %edi   # load new closure to %edi
# emit-shift-args:  size=3   si=-24  delta=20
    mov -24(%esp), %ebx  # shift frame cell
    mov %ebx, -4(%esp)  # down to base
# emit-shift-args:  size=2   si=-28  delta=20
    mov -28(%esp), %ebx  # shift frame cell
    mov %ebx, -8(%esp)  # down to base
# emit-shift-args:  size=1   si=-32  delta=20
    mov -32(%esp), %ebx  # shift frame cell
    mov %ebx, -12(%esp)  # down to base
# emit-shift-args:  size=0   si=-36  delta=20
    movl $8,%eax   # save arg count
    jmp *-2(%edi)  # tail-funcall
     ret   # return thru stack
    .align 4,0x90
_L_40093:
    movl -32(%esp), %ebx
    movl -36(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin (vector-set! f6562 0 (closure (f6591 f6592) ((primitive-ref write) (primitive-ref write-char) f6562 else (primitive-ref write-char) (primitive-ref write-char) (primitive-ref write-char) (primitive-ref write)) (let ((f6591 f6591) (f6592 f6592)) (begin ((primitive-ref write) (car f6591) f6592) (if (null? (cdr f6591)) #t (if (pair? (cdr f6591)) (begin ((primitive-ref write-char) #\space f6592) ((vector-ref f6562 0) (cdr f6591) f6592)) (begin ((primitive-ref write-char) #\space f6592) ((primitive-ref write-char) #\. f6592) ((primitive-ref write-char) #\space f6592) ((primitive-ref write) (cdr f6591) f6592)))))))))
# emit-begin
#   expr=(begin (vector-set! f6562 0 (closure (f6591 f6592) ((primitive-ref write) (primitive-ref write-char) f6562 else (primitive-ref write-char) (primitive-ref write-char) (primitive-ref write-char) (primitive-ref write)) (let ((f6591 f6591) (f6592 f6592)) (begin ((primitive-ref write) (car f6591) f6592) (if (null? (cdr f6591)) #t (if (pair? (cdr f6591)) (begin ((primitive-ref write-char) #\space f6592) ((vector-ref f6562 0) (cdr f6591) f6592)) (begin ((primitive-ref write-char) #\space f6592) ((primitive-ref write-char) #\. f6592) ((primitive-ref write-char) #\space f6592) ((primitive-ref write) (cdr f6591) f6592)))))))))
#   env=((f6562 . -28) (f6563 . -24) (f6564 . -20) (f6565 . -16) (f6566 . -12) (f6567 . -8) (f6568 . -4) (f6569 . 0))
# emit-expr (vector-set! f6562 0 (closure (f6591 f6592) ((primitive-ref write) (primitive-ref write-char) f6562 else (primitive-ref write-char) (primitive-ref write-char) (primitive-ref write-char) (primitive-ref write)) (let ((f6591 f6591) (f6592 f6592)) (begin ((primitive-ref write) (car f6591) f6592) (if (null? (cdr f6591)) #t (if (pair? (cdr f6591)) (begin ((primitive-ref write-char) #\space f6592) ((vector-ref f6562 0) (cdr f6591) f6592)) (begin ((primitive-ref write-char) #\space f6592) ((primitive-ref write-char) #\. f6592) ((primitive-ref write-char) #\space f6592) ((primitive-ref write) (cdr f6591) f6592))))))))
# emit-expr f6562
# emit-variable-ref
# env=((f6562 . -28) (f6563 . -24) (f6564 . -20) (f6565 . -16) (f6566 . -12) (f6567 . -8) (f6568 . -4) (f6569 . 0))
# var=f6562
    movl -28(%esp), %eax  # stack load f6562
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_40101
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_40101:
    movl %eax, -32(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_40102"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_40102:
# check bounds on vector index
    movl -32(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_40104
    cmp  $0,%eax
    jge _L_40103
_L_40104:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_40103:
    movl %eax, -36(%esp)
# emit-expr (closure (f6591 f6592) ((primitive-ref write) (primitive-ref write-char) f6562 else (primitive-ref write-char) (primitive-ref write-char) (primitive-ref write-char) (primitive-ref write)) (let ((f6591 f6591) (f6592 f6592)) (begin ((primitive-ref write) (car f6591) f6592) (if (null? (cdr f6591)) #t (if (pair? (cdr f6591)) (begin ((primitive-ref write-char) #\space f6592) ((vector-ref f6562 0) (cdr f6591) f6592)) (begin ((primitive-ref write-char) #\space f6592) ((primitive-ref write-char) #\. f6592) ((primitive-ref write-char) #\space f6592) ((primitive-ref write) (cdr f6591) f6592)))))))
# emit-closure
# si = -40
# env = ((f6562 . -28) (f6563 . -24) (f6564 . -20) (f6565 . -16) (f6566 . -12) (f6567 . -8) (f6568 . -4) (f6569 . 0))
# expr = (closure (f6591 f6592) ((primitive-ref write) (primitive-ref write-char) f6562 else (primitive-ref write-char) (primitive-ref write-char) (primitive-ref write-char) (primitive-ref write)) (let ((f6591 f6591) (f6592 f6592)) (begin ((primitive-ref write) (car f6591) f6592) (if (null? (cdr f6591)) #t (if (pair? (cdr f6591)) (begin ((primitive-ref write-char) #\space f6592) ((vector-ref f6562 0) (cdr f6591) f6592)) (begin ((primitive-ref write-char) #\space f6592) ((primitive-ref write-char) #\. f6592) ((primitive-ref write-char) #\space f6592) ((primitive-ref write) (cdr f6591) f6592)))))))
    movl $_L_40105, 0(%ebp)  # closure label
# WARNING: free var (primitive-ref write) not defined in the environmnet
# WARNING: free var (primitive-ref write-char) not defined in the environmnet
# emit-variable-ref
# env=((f6562 . -28) (f6563 . -24) (f6564 . -20) (f6565 . -16) (f6566 . -12) (f6567 . -8) (f6568 . -4) (f6569 . 0))
# var=f6562
    movl -28(%esp), %eax  # stack load f6562
# end emit-variable-ref
   movl  %eax, 12(%ebp)  # f6562
# WARNING: free var else not defined in the environmnet
# WARNING: free var (primitive-ref write-char) not defined in the environmnet
# WARNING: free var (primitive-ref write-char) not defined in the environmnet
# WARNING: free var (primitive-ref write-char) not defined in the environmnet
# WARNING: free var (primitive-ref write) not defined in the environmnet
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $40, %ebp     # bump ebp
    jmp _L_40106            # jump around closure body
_L_40105:
# check argument count
    cmp $8,%eax
    je _L_40107
# invoke error handler eh_argcount
    .extern mrc_eh$uargcount
    movl mrc_eh$uargcount, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_40107:
# emit-tail-expr
# si=-16
# env=((f6592 . -12) (f6591 . -8) ((primitive-ref write) . 32) ((primitive-ref write-char) . 28) ((primitive-ref write-char) . 24) ((primitive-ref write-char) . 20) (else . 16) (f6562 . 12) ((primitive-ref write-char) . 8) ((primitive-ref write) . 4) (f6562 . -28) (f6563 . -24) (f6564 . -20) (f6565 . -16) (f6566 . -12) (f6567 . -8) (f6568 . -4) (f6569 . 0))
# expr=(let ((f6591 f6591) (f6592 f6592)) (begin ((primitive-ref write) (car f6591) f6592) (if (null? (cdr f6591)) #t (if (pair? (cdr f6591)) (begin ((primitive-ref write-char) #\space f6592) ((vector-ref f6562 0) (cdr f6591) f6592)) (begin ((primitive-ref write-char) #\space f6592) ((primitive-ref write-char) #\. f6592) ((primitive-ref write-char) #\space f6592) ((primitive-ref write) (cdr f6591) f6592))))))
# emit-tail-let
#  si   = -16
#  env  = ((f6592 . -12) (f6591 . -8) ((primitive-ref write) . 32) ((primitive-ref write-char) . 28) ((primitive-ref write-char) . 24) ((primitive-ref write-char) . 20) (else . 16) (f6562 . 12) ((primitive-ref write-char) . 8) ((primitive-ref write) . 4) (f6562 . -28) (f6563 . -24) (f6564 . -20) (f6565 . -16) (f6566 . -12) (f6567 . -8) (f6568 . -4) (f6569 . 0))
#  bindings = ((f6591 f6591) (f6592 f6592))
#  body = (begin ((primitive-ref write) (car f6591) f6592) (if (null? (cdr f6591)) #t (if (pair? (cdr f6591)) (begin ((primitive-ref write-char) #\space f6592) ((vector-ref f6562 0) (cdr f6591) f6592)) (begin ((primitive-ref write-char) #\space f6592) ((primitive-ref write-char) #\. f6592) ((primitive-ref write-char) #\space f6592) ((primitive-ref write) (cdr f6591) f6592)))))
# emit-expr f6591
# emit-variable-ref
# env=((f6592 . -12) (f6591 . -8) ((primitive-ref write) . 32) ((primitive-ref write-char) . 28) ((primitive-ref write-char) . 24) ((primitive-ref write-char) . 20) (else . 16) (f6562 . 12) ((primitive-ref write-char) . 8) ((primitive-ref write) . 4) (f6562 . -28) (f6563 . -24) (f6564 . -20) (f6565 . -16) (f6566 . -12) (f6567 . -8) (f6568 . -4) (f6569 . 0))
# var=f6591
    movl -8(%esp), %eax  # stack load f6591
# end emit-variable-ref
    movl %eax, -16(%esp)  # stack save
# emit-expr f6592
# emit-variable-ref
# env=((f6592 . -12) (f6591 . -8) ((primitive-ref write) . 32) ((primitive-ref write-char) . 28) ((primitive-ref write-char) . 24) ((primitive-ref write-char) . 20) (else . 16) (f6562 . 12) ((primitive-ref write-char) . 8) ((primitive-ref write) . 4) (f6562 . -28) (f6563 . -24) (f6564 . -20) (f6565 . -16) (f6566 . -12) (f6567 . -8) (f6568 . -4) (f6569 . 0))
# var=f6592
    movl -12(%esp), %eax  # stack load f6592
# end emit-variable-ref
    movl %eax, -20(%esp)  # stack save
# emit-tail-expr
# si=-24
# env=((f6592 . -20) (f6591 . -16) (f6592 . -12) (f6591 . -8) ((primitive-ref write) . 32) ((primitive-ref write-char) . 28) ((primitive-ref write-char) . 24) ((primitive-ref write-char) . 20) (else . 16) (f6562 . 12) ((primitive-ref write-char) . 8) ((primitive-ref write) . 4) (f6562 . -28) (f6563 . -24) (f6564 . -20) (f6565 . -16) (f6566 . -12) (f6567 . -8) (f6568 . -4) (f6569 . 0))
# expr=(begin ((primitive-ref write) (car f6591) f6592) (if (null? (cdr f6591)) #t (if (pair? (cdr f6591)) (begin ((primitive-ref write-char) #\space f6592) ((vector-ref f6562 0) (cdr f6591) f6592)) (begin ((primitive-ref write-char) #\space f6592) ((primitive-ref write-char) #\. f6592) ((primitive-ref write-char) #\space f6592) ((primitive-ref write) (cdr f6591) f6592)))))
# tail-begin (begin ((primitive-ref write) (car f6591) f6592) (if (null? (cdr f6591)) #t (if (pair? (cdr f6591)) (begin ((primitive-ref write-char) #\space f6592) ((vector-ref f6562 0) (cdr f6591) f6592)) (begin ((primitive-ref write-char) #\space f6592) ((primitive-ref write-char) #\. f6592) ((primitive-ref write-char) #\space f6592) ((primitive-ref write) (cdr f6591) f6592)))))
#   env=((f6592 . -20) (f6591 . -16) (f6592 . -12) (f6591 . -8) ((primitive-ref write) . 32) ((primitive-ref write-char) . 28) ((primitive-ref write-char) . 24) ((primitive-ref write-char) . 20) (else . 16) (f6562 . 12) ((primitive-ref write-char) . 8) ((primitive-ref write) . 4) (f6562 . -28) (f6563 . -24) (f6564 . -20) (f6565 . -16) (f6566 . -12) (f6567 . -8) (f6568 . -4) (f6569 . 0))
# emit-expr ((primitive-ref write) (car f6591) f6592)
# funcall
#    si   =-24
#    env  = ((f6592 . -20) (f6591 . -16) (f6592 . -12) (f6591 . -8) ((primitive-ref write) . 32) ((primitive-ref write-char) . 28) ((primitive-ref write-char) . 24) ((primitive-ref write-char) . 20) (else . 16) (f6562 . 12) ((primitive-ref write-char) . 8) ((primitive-ref write) . 4) (f6562 . -28) (f6563 . -24) (f6564 . -20) (f6565 . -16) (f6566 . -12) (f6567 . -8) (f6568 . -4) (f6569 . 0))
#    expr = (funcall (primitive-ref write) (car f6591) f6592)
# emit-expr (primitive-ref write)
    .extern mrc_write
    movl mrc_write,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_40108"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_40108":
   movl %eax,  -32(%esp)  # stash funcall-oper in closure slot
# emit-expr (car f6591)
# emit-expr f6591
# emit-variable-ref
# env=((f6592 . -20) (f6591 . -16) (f6592 . -12) (f6591 . -8) ((primitive-ref write) . 32) ((primitive-ref write-char) . 28) ((primitive-ref write-char) . 24) ((primitive-ref write-char) . 20) (else . 16) (f6562 . 12) ((primitive-ref write-char) . 8) ((primitive-ref write) . 4) (f6562 . -28) (f6563 . -24) (f6564 . -20) (f6565 . -16) (f6566 . -12) (f6567 . -8) (f6568 . -4) (f6569 . 0))
# var=f6591
    movl -16(%esp), %eax  # stack load f6591
# end emit-variable-ref
# check the argument is a pair
    movl %eax,%ebx
    and $7, %bl
    cmp $1, %bl
    je _L_40109
# invoke error handler eh_pair
    .extern mrc_eh$upair
    movl mrc_eh$upair, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $116,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_40109:
    movl -1(%eax), %eax
    mov %eax, -36(%esp)  # arg (car f6591)
# emit-expr f6592
# emit-variable-ref
# env=((f6592 . -20) (f6591 . -16) (f6592 . -12) (f6591 . -8) ((primitive-ref write) . 32) ((primitive-ref write-char) . 28) ((primitive-ref write-char) . 24) ((primitive-ref write-char) . 20) (else . 16) (f6562 . 12) ((primitive-ref write-char) . 8) ((primitive-ref write) . 4) (f6562 . -28) (f6563 . -24) (f6564 . -20) (f6565 . -16) (f6566 . -12) (f6567 . -8) (f6568 . -4) (f6569 . 0))
# var=f6592
    movl -20(%esp), %eax  # stack load f6592
# end emit-variable-ref
    mov %eax, -40(%esp)  # arg f6592
    movl -32(%esp), %edi   # load new closure to %edi
    add $-24, %esp   # adjust base
    movl $8,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $24, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
# emit-tail-expr
# si=-24
# env=((f6592 . -20) (f6591 . -16) (f6592 . -12) (f6591 . -8) ((primitive-ref write) . 32) ((primitive-ref write-char) . 28) ((primitive-ref write-char) . 24) ((primitive-ref write-char) . 20) (else . 16) (f6562 . 12) ((primitive-ref write-char) . 8) ((primitive-ref write) . 4) (f6562 . -28) (f6563 . -24) (f6564 . -20) (f6565 . -16) (f6566 . -12) (f6567 . -8) (f6568 . -4) (f6569 . 0))
# expr=(begin (if (null? (cdr f6591)) #t (if (pair? (cdr f6591)) (begin ((primitive-ref write-char) #\space f6592) ((vector-ref f6562 0) (cdr f6591) f6592)) (begin ((primitive-ref write-char) #\space f6592) ((primitive-ref write-char) #\. f6592) ((primitive-ref write-char) #\space f6592) ((primitive-ref write) (cdr f6591) f6592)))))
# tail-begin (begin (if (null? (cdr f6591)) #t (if (pair? (cdr f6591)) (begin ((primitive-ref write-char) #\space f6592) ((vector-ref f6562 0) (cdr f6591) f6592)) (begin ((primitive-ref write-char) #\space f6592) ((primitive-ref write-char) #\. f6592) ((primitive-ref write-char) #\space f6592) ((primitive-ref write) (cdr f6591) f6592)))))
#   env=((f6592 . -20) (f6591 . -16) (f6592 . -12) (f6591 . -8) ((primitive-ref write) . 32) ((primitive-ref write-char) . 28) ((primitive-ref write-char) . 24) ((primitive-ref write-char) . 20) (else . 16) (f6562 . 12) ((primitive-ref write-char) . 8) ((primitive-ref write) . 4) (f6562 . -28) (f6563 . -24) (f6564 . -20) (f6565 . -16) (f6566 . -12) (f6567 . -8) (f6568 . -4) (f6569 . 0))
# emit-tail-expr
# si=-24
# env=((f6592 . -20) (f6591 . -16) (f6592 . -12) (f6591 . -8) ((primitive-ref write) . 32) ((primitive-ref write-char) . 28) ((primitive-ref write-char) . 24) ((primitive-ref write-char) . 20) (else . 16) (f6562 . 12) ((primitive-ref write-char) . 8) ((primitive-ref write) . 4) (f6562 . -28) (f6563 . -24) (f6564 . -20) (f6565 . -16) (f6566 . -12) (f6567 . -8) (f6568 . -4) (f6569 . 0))
# expr=(if (null? (cdr f6591)) #t (if (pair? (cdr f6591)) (begin ((primitive-ref write-char) #\space f6592) ((vector-ref f6562 0) (cdr f6591) f6592)) (begin ((primitive-ref write-char) #\space f6592) ((primitive-ref write-char) #\. f6592) ((primitive-ref write-char) #\space f6592) ((primitive-ref write) (cdr f6591) f6592))))
# emit-expr (null? (cdr f6591))
# emit-expr (cdr f6591)
# emit-expr f6591
# emit-variable-ref
# env=((f6592 . -20) (f6591 . -16) (f6592 . -12) (f6591 . -8) ((primitive-ref write) . 32) ((primitive-ref write-char) . 28) ((primitive-ref write-char) . 24) ((primitive-ref write-char) . 20) (else . 16) (f6562 . 12) ((primitive-ref write-char) . 8) ((primitive-ref write) . 4) (f6562 . -28) (f6563 . -24) (f6564 . -20) (f6565 . -16) (f6566 . -12) (f6567 . -8) (f6568 . -4) (f6569 . 0))
# var=f6591
    movl -16(%esp), %eax  # stack load f6591
# end emit-variable-ref
# check the argument is a pair
    movl %eax,%ebx
    and $7, %bl
    cmp $1, %bl
    je _L_40112
# invoke error handler eh_pair
    .extern mrc_eh$upair
    movl mrc_eh$upair, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $120,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_40112:
    movl 3(%eax), %eax
    cmp $63, %eax
    mov $0, %eax
    sete %al
    movzbl %al, %eax
    sal $6, %al
    or $47, %al
    cmp $47, %al
    je _L_40110
# emit-tail-expr
# si=-24
# env=((f6592 . -20) (f6591 . -16) (f6592 . -12) (f6591 . -8) ((primitive-ref write) . 32) ((primitive-ref write-char) . 28) ((primitive-ref write-char) . 24) ((primitive-ref write-char) . 20) (else . 16) (f6562 . 12) ((primitive-ref write-char) . 8) ((primitive-ref write) . 4) (f6562 . -28) (f6563 . -24) (f6564 . -20) (f6565 . -16) (f6566 . -12) (f6567 . -8) (f6568 . -4) (f6569 . 0))
# expr=#t
    movl $111, %eax     # immed #t
    ret                  # immediate tail return
    jmp _L_40111
_L_40110:
# emit-tail-expr
# si=-24
# env=((f6592 . -20) (f6591 . -16) (f6592 . -12) (f6591 . -8) ((primitive-ref write) . 32) ((primitive-ref write-char) . 28) ((primitive-ref write-char) . 24) ((primitive-ref write-char) . 20) (else . 16) (f6562 . 12) ((primitive-ref write-char) . 8) ((primitive-ref write) . 4) (f6562 . -28) (f6563 . -24) (f6564 . -20) (f6565 . -16) (f6566 . -12) (f6567 . -8) (f6568 . -4) (f6569 . 0))
# expr=(if (pair? (cdr f6591)) (begin ((primitive-ref write-char) #\space f6592) ((vector-ref f6562 0) (cdr f6591) f6592)) (begin ((primitive-ref write-char) #\space f6592) ((primitive-ref write-char) #\. f6592) ((primitive-ref write-char) #\space f6592) ((primitive-ref write) (cdr f6591) f6592)))
# emit-expr (pair? (cdr f6591))
# emit-expr (cdr f6591)
# emit-expr f6591
# emit-variable-ref
# env=((f6592 . -20) (f6591 . -16) (f6592 . -12) (f6591 . -8) ((primitive-ref write) . 32) ((primitive-ref write-char) . 28) ((primitive-ref write-char) . 24) ((primitive-ref write-char) . 20) (else . 16) (f6562 . 12) ((primitive-ref write-char) . 8) ((primitive-ref write) . 4) (f6562 . -28) (f6563 . -24) (f6564 . -20) (f6565 . -16) (f6566 . -12) (f6567 . -8) (f6568 . -4) (f6569 . 0))
# var=f6591
    movl -16(%esp), %eax  # stack load f6591
# end emit-variable-ref
# check the argument is a pair
    movl %eax,%ebx
    and $7, %bl
    cmp $1, %bl
    je _L_40115
# invoke error handler eh_pair
    .extern mrc_eh$upair
    movl mrc_eh$upair, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $120,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_40115:
    movl 3(%eax), %eax
    and $7, %al
    cmp $1, %al
    sete %al
    movzbl %al, %eax
    sal $6, %al
    or $47, %al
    cmp $47, %al
    je _L_40113
# emit-tail-expr
# si=-24
# env=((f6592 . -20) (f6591 . -16) (f6592 . -12) (f6591 . -8) ((primitive-ref write) . 32) ((primitive-ref write-char) . 28) ((primitive-ref write-char) . 24) ((primitive-ref write-char) . 20) (else . 16) (f6562 . 12) ((primitive-ref write-char) . 8) ((primitive-ref write) . 4) (f6562 . -28) (f6563 . -24) (f6564 . -20) (f6565 . -16) (f6566 . -12) (f6567 . -8) (f6568 . -4) (f6569 . 0))
# expr=(begin ((primitive-ref write-char) #\space f6592) ((vector-ref f6562 0) (cdr f6591) f6592))
# tail-begin (begin ((primitive-ref write-char) #\space f6592) ((vector-ref f6562 0) (cdr f6591) f6592))
#   env=((f6592 . -20) (f6591 . -16) (f6592 . -12) (f6591 . -8) ((primitive-ref write) . 32) ((primitive-ref write-char) . 28) ((primitive-ref write-char) . 24) ((primitive-ref write-char) . 20) (else . 16) (f6562 . 12) ((primitive-ref write-char) . 8) ((primitive-ref write) . 4) (f6562 . -28) (f6563 . -24) (f6564 . -20) (f6565 . -16) (f6566 . -12) (f6567 . -8) (f6568 . -4) (f6569 . 0))
# emit-expr ((primitive-ref write-char) #\space f6592)
# funcall
#    si   =-24
#    env  = ((f6592 . -20) (f6591 . -16) (f6592 . -12) (f6591 . -8) ((primitive-ref write) . 32) ((primitive-ref write-char) . 28) ((primitive-ref write-char) . 24) ((primitive-ref write-char) . 20) (else . 16) (f6562 . 12) ((primitive-ref write-char) . 8) ((primitive-ref write) . 4) (f6562 . -28) (f6563 . -24) (f6564 . -20) (f6565 . -16) (f6566 . -12) (f6567 . -8) (f6568 . -4) (f6569 . 0))
#    expr = (funcall (primitive-ref write-char) #\space f6592)
# emit-expr (primitive-ref write-char)
    .extern mrc_write$mchar
    movl mrc_write$mchar,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_40116"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_40116":
   movl %eax,  -32(%esp)  # stash funcall-oper in closure slot
# emit-expr #\space
    movl $8207, %eax     # immed #\space
    mov %eax, -36(%esp)  # arg  
# emit-expr f6592
# emit-variable-ref
# env=((f6592 . -20) (f6591 . -16) (f6592 . -12) (f6591 . -8) ((primitive-ref write) . 32) ((primitive-ref write-char) . 28) ((primitive-ref write-char) . 24) ((primitive-ref write-char) . 20) (else . 16) (f6562 . 12) ((primitive-ref write-char) . 8) ((primitive-ref write) . 4) (f6562 . -28) (f6563 . -24) (f6564 . -20) (f6565 . -16) (f6566 . -12) (f6567 . -8) (f6568 . -4) (f6569 . 0))
# var=f6592
    movl -20(%esp), %eax  # stack load f6592
# end emit-variable-ref
    mov %eax, -40(%esp)  # arg f6592
    movl -32(%esp), %edi   # load new closure to %edi
    add $-24, %esp   # adjust base
    movl $8,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $24, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
# emit-tail-expr
# si=-24
# env=((f6592 . -20) (f6591 . -16) (f6592 . -12) (f6591 . -8) ((primitive-ref write) . 32) ((primitive-ref write-char) . 28) ((primitive-ref write-char) . 24) ((primitive-ref write-char) . 20) (else . 16) (f6562 . 12) ((primitive-ref write-char) . 8) ((primitive-ref write) . 4) (f6562 . -28) (f6563 . -24) (f6564 . -20) (f6565 . -16) (f6566 . -12) (f6567 . -8) (f6568 . -4) (f6569 . 0))
# expr=(begin ((vector-ref f6562 0) (cdr f6591) f6592))
# tail-begin (begin ((vector-ref f6562 0) (cdr f6591) f6592))
#   env=((f6592 . -20) (f6591 . -16) (f6592 . -12) (f6591 . -8) ((primitive-ref write) . 32) ((primitive-ref write-char) . 28) ((primitive-ref write-char) . 24) ((primitive-ref write-char) . 20) (else . 16) (f6562 . 12) ((primitive-ref write-char) . 8) ((primitive-ref write) . 4) (f6562 . -28) (f6563 . -24) (f6564 . -20) (f6565 . -16) (f6566 . -12) (f6567 . -8) (f6568 . -4) (f6569 . 0))
# emit-tail-expr
# si=-24
# env=((f6592 . -20) (f6591 . -16) (f6592 . -12) (f6591 . -8) ((primitive-ref write) . 32) ((primitive-ref write-char) . 28) ((primitive-ref write-char) . 24) ((primitive-ref write-char) . 20) (else . 16) (f6562 . 12) ((primitive-ref write-char) . 8) ((primitive-ref write) . 4) (f6562 . -28) (f6563 . -24) (f6564 . -20) (f6565 . -16) (f6566 . -12) (f6567 . -8) (f6568 . -4) (f6569 . 0))
# expr=((vector-ref f6562 0) (cdr f6591) f6592)
# emit-tail-funcall
#    si   =-24
#    env  = ((f6592 . -20) (f6591 . -16) (f6592 . -12) (f6591 . -8) ((primitive-ref write) . 32) ((primitive-ref write-char) . 28) ((primitive-ref write-char) . 24) ((primitive-ref write-char) . 20) (else . 16) (f6562 . 12) ((primitive-ref write-char) . 8) ((primitive-ref write) . 4) (f6562 . -28) (f6563 . -24) (f6564 . -20) (f6565 . -16) (f6566 . -12) (f6567 . -8) (f6568 . -4) (f6569 . 0))
#    expr = (funcall (vector-ref f6562 0) (cdr f6591) f6592)
# emit-expr (vector-ref f6562 0)
# emit-expr f6562
# emit-variable-ref
# env=((f6592 . -20) (f6591 . -16) (f6592 . -12) (f6591 . -8) ((primitive-ref write) . 32) ((primitive-ref write-char) . 28) ((primitive-ref write-char) . 24) ((primitive-ref write-char) . 20) (else . 16) (f6562 . 12) ((primitive-ref write-char) . 8) ((primitive-ref write) . 4) (f6562 . -28) (f6563 . -24) (f6564 . -20) (f6565 . -16) (f6566 . -12) (f6567 . -8) (f6568 . -4) (f6569 . 0))
# var=f6562
    movl 10(%edi), %eax  # frame load f6562
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_40117
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_40117:
    movl %eax, -24(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_40118"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_40118:
# check bounds on vector index
    movl -24(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_40120
    cmp  $0,%eax
    jge _L_40119
_L_40120:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_40119:
    movl -24(%esp), %esi
    movl -1(%eax,%esi), %eax
   movl %eax,  -24(%esp)  # stash funcall-oper in next closure slot
# emit-expr (cdr f6591)
# emit-expr f6591
# emit-variable-ref
# env=((f6592 . -20) (f6591 . -16) (f6592 . -12) (f6591 . -8) ((primitive-ref write) . 32) ((primitive-ref write-char) . 28) ((primitive-ref write-char) . 24) ((primitive-ref write-char) . 20) (else . 16) (f6562 . 12) ((primitive-ref write-char) . 8) ((primitive-ref write) . 4) (f6562 . -28) (f6563 . -24) (f6564 . -20) (f6565 . -16) (f6566 . -12) (f6567 . -8) (f6568 . -4) (f6569 . 0))
# var=f6591
    movl -16(%esp), %eax  # stack load f6591
# end emit-variable-ref
# check the argument is a pair
    movl %eax,%ebx
    and $7, %bl
    cmp $1, %bl
    je _L_40121
# invoke error handler eh_pair
    .extern mrc_eh$upair
    movl mrc_eh$upair, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $120,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_40121:
    movl 3(%eax), %eax
    mov %eax, -28(%esp)    # arg (cdr f6591)
# emit-expr f6592
# emit-variable-ref
# env=((f6592 . -20) (f6591 . -16) (f6592 . -12) (f6591 . -8) ((primitive-ref write) . 32) ((primitive-ref write-char) . 28) ((primitive-ref write-char) . 24) ((primitive-ref write-char) . 20) (else . 16) (f6562 . 12) ((primitive-ref write-char) . 8) ((primitive-ref write) . 4) (f6562 . -28) (f6563 . -24) (f6564 . -20) (f6565 . -16) (f6566 . -12) (f6567 . -8) (f6568 . -4) (f6569 . 0))
# var=f6592
    movl -20(%esp), %eax  # stack load f6592
# end emit-variable-ref
    mov %eax, -32(%esp)    # arg f6592
    movl -24(%esp), %edi   # load new closure to %edi
# emit-shift-args:  size=3   si=-24  delta=20
    mov -24(%esp), %ebx  # shift frame cell
    mov %ebx, -4(%esp)  # down to base
# emit-shift-args:  size=2   si=-28  delta=20
    mov -28(%esp), %ebx  # shift frame cell
    mov %ebx, -8(%esp)  # down to base
# emit-shift-args:  size=1   si=-32  delta=20
    mov -32(%esp), %ebx  # shift frame cell
    mov %ebx, -12(%esp)  # down to base
# emit-shift-args:  size=0   si=-36  delta=20
    movl $8,%eax   # save arg count
    jmp *-2(%edi)  # tail-funcall
     ret   # return thru stack
    jmp _L_40114
_L_40113:
# emit-tail-expr
# si=-24
# env=((f6592 . -20) (f6591 . -16) (f6592 . -12) (f6591 . -8) ((primitive-ref write) . 32) ((primitive-ref write-char) . 28) ((primitive-ref write-char) . 24) ((primitive-ref write-char) . 20) (else . 16) (f6562 . 12) ((primitive-ref write-char) . 8) ((primitive-ref write) . 4) (f6562 . -28) (f6563 . -24) (f6564 . -20) (f6565 . -16) (f6566 . -12) (f6567 . -8) (f6568 . -4) (f6569 . 0))
# expr=(begin ((primitive-ref write-char) #\space f6592) ((primitive-ref write-char) #\. f6592) ((primitive-ref write-char) #\space f6592) ((primitive-ref write) (cdr f6591) f6592))
# tail-begin (begin ((primitive-ref write-char) #\space f6592) ((primitive-ref write-char) #\. f6592) ((primitive-ref write-char) #\space f6592) ((primitive-ref write) (cdr f6591) f6592))
#   env=((f6592 . -20) (f6591 . -16) (f6592 . -12) (f6591 . -8) ((primitive-ref write) . 32) ((primitive-ref write-char) . 28) ((primitive-ref write-char) . 24) ((primitive-ref write-char) . 20) (else . 16) (f6562 . 12) ((primitive-ref write-char) . 8) ((primitive-ref write) . 4) (f6562 . -28) (f6563 . -24) (f6564 . -20) (f6565 . -16) (f6566 . -12) (f6567 . -8) (f6568 . -4) (f6569 . 0))
# emit-expr ((primitive-ref write-char) #\space f6592)
# funcall
#    si   =-24
#    env  = ((f6592 . -20) (f6591 . -16) (f6592 . -12) (f6591 . -8) ((primitive-ref write) . 32) ((primitive-ref write-char) . 28) ((primitive-ref write-char) . 24) ((primitive-ref write-char) . 20) (else . 16) (f6562 . 12) ((primitive-ref write-char) . 8) ((primitive-ref write) . 4) (f6562 . -28) (f6563 . -24) (f6564 . -20) (f6565 . -16) (f6566 . -12) (f6567 . -8) (f6568 . -4) (f6569 . 0))
#    expr = (funcall (primitive-ref write-char) #\space f6592)
# emit-expr (primitive-ref write-char)
    .extern mrc_write$mchar
    movl mrc_write$mchar,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_40122"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_40122":
   movl %eax,  -32(%esp)  # stash funcall-oper in closure slot
# emit-expr #\space
    movl $8207, %eax     # immed #\space
    mov %eax, -36(%esp)  # arg  
# emit-expr f6592
# emit-variable-ref
# env=((f6592 . -20) (f6591 . -16) (f6592 . -12) (f6591 . -8) ((primitive-ref write) . 32) ((primitive-ref write-char) . 28) ((primitive-ref write-char) . 24) ((primitive-ref write-char) . 20) (else . 16) (f6562 . 12) ((primitive-ref write-char) . 8) ((primitive-ref write) . 4) (f6562 . -28) (f6563 . -24) (f6564 . -20) (f6565 . -16) (f6566 . -12) (f6567 . -8) (f6568 . -4) (f6569 . 0))
# var=f6592
    movl -20(%esp), %eax  # stack load f6592
# end emit-variable-ref
    mov %eax, -40(%esp)  # arg f6592
    movl -32(%esp), %edi   # load new closure to %edi
    add $-24, %esp   # adjust base
    movl $8,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $24, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
# emit-tail-expr
# si=-24
# env=((f6592 . -20) (f6591 . -16) (f6592 . -12) (f6591 . -8) ((primitive-ref write) . 32) ((primitive-ref write-char) . 28) ((primitive-ref write-char) . 24) ((primitive-ref write-char) . 20) (else . 16) (f6562 . 12) ((primitive-ref write-char) . 8) ((primitive-ref write) . 4) (f6562 . -28) (f6563 . -24) (f6564 . -20) (f6565 . -16) (f6566 . -12) (f6567 . -8) (f6568 . -4) (f6569 . 0))
# expr=(begin ((primitive-ref write-char) #\. f6592) ((primitive-ref write-char) #\space f6592) ((primitive-ref write) (cdr f6591) f6592))
# tail-begin (begin ((primitive-ref write-char) #\. f6592) ((primitive-ref write-char) #\space f6592) ((primitive-ref write) (cdr f6591) f6592))
#   env=((f6592 . -20) (f6591 . -16) (f6592 . -12) (f6591 . -8) ((primitive-ref write) . 32) ((primitive-ref write-char) . 28) ((primitive-ref write-char) . 24) ((primitive-ref write-char) . 20) (else . 16) (f6562 . 12) ((primitive-ref write-char) . 8) ((primitive-ref write) . 4) (f6562 . -28) (f6563 . -24) (f6564 . -20) (f6565 . -16) (f6566 . -12) (f6567 . -8) (f6568 . -4) (f6569 . 0))
# emit-expr ((primitive-ref write-char) #\. f6592)
# funcall
#    si   =-24
#    env  = ((f6592 . -20) (f6591 . -16) (f6592 . -12) (f6591 . -8) ((primitive-ref write) . 32) ((primitive-ref write-char) . 28) ((primitive-ref write-char) . 24) ((primitive-ref write-char) . 20) (else . 16) (f6562 . 12) ((primitive-ref write-char) . 8) ((primitive-ref write) . 4) (f6562 . -28) (f6563 . -24) (f6564 . -20) (f6565 . -16) (f6566 . -12) (f6567 . -8) (f6568 . -4) (f6569 . 0))
#    expr = (funcall (primitive-ref write-char) #\. f6592)
# emit-expr (primitive-ref write-char)
    .extern mrc_write$mchar
    movl mrc_write$mchar,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_40123"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_40123":
   movl %eax,  -32(%esp)  # stash funcall-oper in closure slot
# emit-expr #\.
    movl $11791, %eax     # immed #\.
    mov %eax, -36(%esp)  # arg .
# emit-expr f6592
# emit-variable-ref
# env=((f6592 . -20) (f6591 . -16) (f6592 . -12) (f6591 . -8) ((primitive-ref write) . 32) ((primitive-ref write-char) . 28) ((primitive-ref write-char) . 24) ((primitive-ref write-char) . 20) (else . 16) (f6562 . 12) ((primitive-ref write-char) . 8) ((primitive-ref write) . 4) (f6562 . -28) (f6563 . -24) (f6564 . -20) (f6565 . -16) (f6566 . -12) (f6567 . -8) (f6568 . -4) (f6569 . 0))
# var=f6592
    movl -20(%esp), %eax  # stack load f6592
# end emit-variable-ref
    mov %eax, -40(%esp)  # arg f6592
    movl -32(%esp), %edi   # load new closure to %edi
    add $-24, %esp   # adjust base
    movl $8,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $24, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
# emit-tail-expr
# si=-24
# env=((f6592 . -20) (f6591 . -16) (f6592 . -12) (f6591 . -8) ((primitive-ref write) . 32) ((primitive-ref write-char) . 28) ((primitive-ref write-char) . 24) ((primitive-ref write-char) . 20) (else . 16) (f6562 . 12) ((primitive-ref write-char) . 8) ((primitive-ref write) . 4) (f6562 . -28) (f6563 . -24) (f6564 . -20) (f6565 . -16) (f6566 . -12) (f6567 . -8) (f6568 . -4) (f6569 . 0))
# expr=(begin ((primitive-ref write-char) #\space f6592) ((primitive-ref write) (cdr f6591) f6592))
# tail-begin (begin ((primitive-ref write-char) #\space f6592) ((primitive-ref write) (cdr f6591) f6592))
#   env=((f6592 . -20) (f6591 . -16) (f6592 . -12) (f6591 . -8) ((primitive-ref write) . 32) ((primitive-ref write-char) . 28) ((primitive-ref write-char) . 24) ((primitive-ref write-char) . 20) (else . 16) (f6562 . 12) ((primitive-ref write-char) . 8) ((primitive-ref write) . 4) (f6562 . -28) (f6563 . -24) (f6564 . -20) (f6565 . -16) (f6566 . -12) (f6567 . -8) (f6568 . -4) (f6569 . 0))
# emit-expr ((primitive-ref write-char) #\space f6592)
# funcall
#    si   =-24
#    env  = ((f6592 . -20) (f6591 . -16) (f6592 . -12) (f6591 . -8) ((primitive-ref write) . 32) ((primitive-ref write-char) . 28) ((primitive-ref write-char) . 24) ((primitive-ref write-char) . 20) (else . 16) (f6562 . 12) ((primitive-ref write-char) . 8) ((primitive-ref write) . 4) (f6562 . -28) (f6563 . -24) (f6564 . -20) (f6565 . -16) (f6566 . -12) (f6567 . -8) (f6568 . -4) (f6569 . 0))
#    expr = (funcall (primitive-ref write-char) #\space f6592)
# emit-expr (primitive-ref write-char)
    .extern mrc_write$mchar
    movl mrc_write$mchar,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_40124"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_40124":
   movl %eax,  -32(%esp)  # stash funcall-oper in closure slot
# emit-expr #\space
    movl $8207, %eax     # immed #\space
    mov %eax, -36(%esp)  # arg  
# emit-expr f6592
# emit-variable-ref
# env=((f6592 . -20) (f6591 . -16) (f6592 . -12) (f6591 . -8) ((primitive-ref write) . 32) ((primitive-ref write-char) . 28) ((primitive-ref write-char) . 24) ((primitive-ref write-char) . 20) (else . 16) (f6562 . 12) ((primitive-ref write-char) . 8) ((primitive-ref write) . 4) (f6562 . -28) (f6563 . -24) (f6564 . -20) (f6565 . -16) (f6566 . -12) (f6567 . -8) (f6568 . -4) (f6569 . 0))
# var=f6592
    movl -20(%esp), %eax  # stack load f6592
# end emit-variable-ref
    mov %eax, -40(%esp)  # arg f6592
    movl -32(%esp), %edi   # load new closure to %edi
    add $-24, %esp   # adjust base
    movl $8,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $24, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
# emit-tail-expr
# si=-24
# env=((f6592 . -20) (f6591 . -16) (f6592 . -12) (f6591 . -8) ((primitive-ref write) . 32) ((primitive-ref write-char) . 28) ((primitive-ref write-char) . 24) ((primitive-ref write-char) . 20) (else . 16) (f6562 . 12) ((primitive-ref write-char) . 8) ((primitive-ref write) . 4) (f6562 . -28) (f6563 . -24) (f6564 . -20) (f6565 . -16) (f6566 . -12) (f6567 . -8) (f6568 . -4) (f6569 . 0))
# expr=(begin ((primitive-ref write) (cdr f6591) f6592))
# tail-begin (begin ((primitive-ref write) (cdr f6591) f6592))
#   env=((f6592 . -20) (f6591 . -16) (f6592 . -12) (f6591 . -8) ((primitive-ref write) . 32) ((primitive-ref write-char) . 28) ((primitive-ref write-char) . 24) ((primitive-ref write-char) . 20) (else . 16) (f6562 . 12) ((primitive-ref write-char) . 8) ((primitive-ref write) . 4) (f6562 . -28) (f6563 . -24) (f6564 . -20) (f6565 . -16) (f6566 . -12) (f6567 . -8) (f6568 . -4) (f6569 . 0))
# emit-tail-expr
# si=-24
# env=((f6592 . -20) (f6591 . -16) (f6592 . -12) (f6591 . -8) ((primitive-ref write) . 32) ((primitive-ref write-char) . 28) ((primitive-ref write-char) . 24) ((primitive-ref write-char) . 20) (else . 16) (f6562 . 12) ((primitive-ref write-char) . 8) ((primitive-ref write) . 4) (f6562 . -28) (f6563 . -24) (f6564 . -20) (f6565 . -16) (f6566 . -12) (f6567 . -8) (f6568 . -4) (f6569 . 0))
# expr=((primitive-ref write) (cdr f6591) f6592)
# emit-tail-funcall
#    si   =-24
#    env  = ((f6592 . -20) (f6591 . -16) (f6592 . -12) (f6591 . -8) ((primitive-ref write) . 32) ((primitive-ref write-char) . 28) ((primitive-ref write-char) . 24) ((primitive-ref write-char) . 20) (else . 16) (f6562 . 12) ((primitive-ref write-char) . 8) ((primitive-ref write) . 4) (f6562 . -28) (f6563 . -24) (f6564 . -20) (f6565 . -16) (f6566 . -12) (f6567 . -8) (f6568 . -4) (f6569 . 0))
#    expr = (funcall (primitive-ref write) (cdr f6591) f6592)
# emit-expr (primitive-ref write)
    .extern mrc_write
    movl mrc_write,%eax
   movl %eax,  -24(%esp)  # stash funcall-oper in next closure slot
# emit-expr (cdr f6591)
# emit-expr f6591
# emit-variable-ref
# env=((f6592 . -20) (f6591 . -16) (f6592 . -12) (f6591 . -8) ((primitive-ref write) . 32) ((primitive-ref write-char) . 28) ((primitive-ref write-char) . 24) ((primitive-ref write-char) . 20) (else . 16) (f6562 . 12) ((primitive-ref write-char) . 8) ((primitive-ref write) . 4) (f6562 . -28) (f6563 . -24) (f6564 . -20) (f6565 . -16) (f6566 . -12) (f6567 . -8) (f6568 . -4) (f6569 . 0))
# var=f6591
    movl -16(%esp), %eax  # stack load f6591
# end emit-variable-ref
# check the argument is a pair
    movl %eax,%ebx
    and $7, %bl
    cmp $1, %bl
    je _L_40125
# invoke error handler eh_pair
    .extern mrc_eh$upair
    movl mrc_eh$upair, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $120,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_40125:
    movl 3(%eax), %eax
    mov %eax, -28(%esp)    # arg (cdr f6591)
# emit-expr f6592
# emit-variable-ref
# env=((f6592 . -20) (f6591 . -16) (f6592 . -12) (f6591 . -8) ((primitive-ref write) . 32) ((primitive-ref write-char) . 28) ((primitive-ref write-char) . 24) ((primitive-ref write-char) . 20) (else . 16) (f6562 . 12) ((primitive-ref write-char) . 8) ((primitive-ref write) . 4) (f6562 . -28) (f6563 . -24) (f6564 . -20) (f6565 . -16) (f6566 . -12) (f6567 . -8) (f6568 . -4) (f6569 . 0))
# var=f6592
    movl -20(%esp), %eax  # stack load f6592
# end emit-variable-ref
    mov %eax, -32(%esp)    # arg f6592
    movl -24(%esp), %edi   # load new closure to %edi
# emit-shift-args:  size=3   si=-24  delta=20
    mov -24(%esp), %ebx  # shift frame cell
    mov %ebx, -4(%esp)  # down to base
# emit-shift-args:  size=2   si=-28  delta=20
    mov -28(%esp), %ebx  # shift frame cell
    mov %ebx, -8(%esp)  # down to base
# emit-shift-args:  size=1   si=-32  delta=20
    mov -32(%esp), %ebx  # shift frame cell
    mov %ebx, -12(%esp)  # down to base
# emit-shift-args:  size=0   si=-36  delta=20
    movl $8,%eax   # save arg count
    jmp *-2(%edi)  # tail-funcall
     ret   # return thru stack
_L_40114:
_L_40111:
     ret   # return thru stack
    .align 4,0x90
_L_40106:
    movl -32(%esp), %ebx
    movl -36(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin)
# emit-begin
#   expr=(begin)
#   env=((f6562 . -28) (f6563 . -24) (f6564 . -20) (f6565 . -16) (f6566 . -12) (f6567 . -8) (f6568 . -4) (f6569 . 0))
# emit-expr (begin (closure (f6615 f6616 f6617) (f6569 f6568 (primitive-ref write-char) f6567 f6566 f6564 f6565 f6563 else (primitive-ref error) (primitive-ref write)) (let ((f6615 f6615) (f6616 f6616) (f6617 f6617)) (if (boolean? f6615) ((vector-ref f6569 0) f6615 f6616) (if (null? f6615) ((vector-ref f6568 0) f6616) (if (char? f6615) (if f6617 ((primitive-ref write-char) f6615 f6616) ((vector-ref f6567 0) f6615 f6616)) (if (fixnum? f6615) ((vector-ref f6566 0) f6615 f6616) (if (string? f6615) (if f6617 ((vector-ref f6564 0) f6615 f6616) ((vector-ref f6565 0) f6615 f6616)) (if (pair? f6615) ((vector-ref f6563 0) f6615 f6616) ((primitive-ref error) ((primitive-ref string->symbol) "write") "unrecognized expression"))))))))))
# emit-begin
#   expr=(begin (closure (f6615 f6616 f6617) (f6569 f6568 (primitive-ref write-char) f6567 f6566 f6564 f6565 f6563 else (primitive-ref error) (primitive-ref write)) (let ((f6615 f6615) (f6616 f6616) (f6617 f6617)) (if (boolean? f6615) ((vector-ref f6569 0) f6615 f6616) (if (null? f6615) ((vector-ref f6568 0) f6616) (if (char? f6615) (if f6617 ((primitive-ref write-char) f6615 f6616) ((vector-ref f6567 0) f6615 f6616)) (if (fixnum? f6615) ((vector-ref f6566 0) f6615 f6616) (if (string? f6615) (if f6617 ((vector-ref f6564 0) f6615 f6616) ((vector-ref f6565 0) f6615 f6616)) (if (pair? f6615) ((vector-ref f6563 0) f6615 f6616) ((primitive-ref error) ((primitive-ref string->symbol) "write") "unrecognized expression"))))))))))
#   env=((f6562 . -28) (f6563 . -24) (f6564 . -20) (f6565 . -16) (f6566 . -12) (f6567 . -8) (f6568 . -4) (f6569 . 0))
# emit-expr (closure (f6615 f6616 f6617) (f6569 f6568 (primitive-ref write-char) f6567 f6566 f6564 f6565 f6563 else (primitive-ref error) (primitive-ref write)) (let ((f6615 f6615) (f6616 f6616) (f6617 f6617)) (if (boolean? f6615) ((vector-ref f6569 0) f6615 f6616) (if (null? f6615) ((vector-ref f6568 0) f6616) (if (char? f6615) (if f6617 ((primitive-ref write-char) f6615 f6616) ((vector-ref f6567 0) f6615 f6616)) (if (fixnum? f6615) ((vector-ref f6566 0) f6615 f6616) (if (string? f6615) (if f6617 ((vector-ref f6564 0) f6615 f6616) ((vector-ref f6565 0) f6615 f6616)) (if (pair? f6615) ((vector-ref f6563 0) f6615 f6616) ((primitive-ref error) ((primitive-ref string->symbol) "write") "unrecognized expression")))))))))
# emit-closure
# si = -32
# env = ((f6562 . -28) (f6563 . -24) (f6564 . -20) (f6565 . -16) (f6566 . -12) (f6567 . -8) (f6568 . -4) (f6569 . 0))
# expr = (closure (f6615 f6616 f6617) (f6569 f6568 (primitive-ref write-char) f6567 f6566 f6564 f6565 f6563 else (primitive-ref error) (primitive-ref write)) (let ((f6615 f6615) (f6616 f6616) (f6617 f6617)) (if (boolean? f6615) ((vector-ref f6569 0) f6615 f6616) (if (null? f6615) ((vector-ref f6568 0) f6616) (if (char? f6615) (if f6617 ((primitive-ref write-char) f6615 f6616) ((vector-ref f6567 0) f6615 f6616)) (if (fixnum? f6615) ((vector-ref f6566 0) f6615 f6616) (if (string? f6615) (if f6617 ((vector-ref f6564 0) f6615 f6616) ((vector-ref f6565 0) f6615 f6616)) (if (pair? f6615) ((vector-ref f6563 0) f6615 f6616) ((primitive-ref error) ((primitive-ref string->symbol) "write") "unrecognized expression")))))))))
    movl $_L_40126, 0(%ebp)  # closure label
# emit-variable-ref
# env=((f6562 . -28) (f6563 . -24) (f6564 . -20) (f6565 . -16) (f6566 . -12) (f6567 . -8) (f6568 . -4) (f6569 . 0))
# var=f6569
    movl 0(%esp), %eax  # stack load f6569
# end emit-variable-ref
   movl  %eax, 4(%ebp)  # f6569
# emit-variable-ref
# env=((f6562 . -28) (f6563 . -24) (f6564 . -20) (f6565 . -16) (f6566 . -12) (f6567 . -8) (f6568 . -4) (f6569 . 0))
# var=f6568
    movl -4(%esp), %eax  # stack load f6568
# end emit-variable-ref
   movl  %eax, 8(%ebp)  # f6568
# WARNING: free var (primitive-ref write-char) not defined in the environmnet
# emit-variable-ref
# env=((f6562 . -28) (f6563 . -24) (f6564 . -20) (f6565 . -16) (f6566 . -12) (f6567 . -8) (f6568 . -4) (f6569 . 0))
# var=f6567
    movl -8(%esp), %eax  # stack load f6567
# end emit-variable-ref
   movl  %eax, 16(%ebp)  # f6567
# emit-variable-ref
# env=((f6562 . -28) (f6563 . -24) (f6564 . -20) (f6565 . -16) (f6566 . -12) (f6567 . -8) (f6568 . -4) (f6569 . 0))
# var=f6566
    movl -12(%esp), %eax  # stack load f6566
# end emit-variable-ref
   movl  %eax, 20(%ebp)  # f6566
# emit-variable-ref
# env=((f6562 . -28) (f6563 . -24) (f6564 . -20) (f6565 . -16) (f6566 . -12) (f6567 . -8) (f6568 . -4) (f6569 . 0))
# var=f6564
    movl -20(%esp), %eax  # stack load f6564
# end emit-variable-ref
   movl  %eax, 24(%ebp)  # f6564
# emit-variable-ref
# env=((f6562 . -28) (f6563 . -24) (f6564 . -20) (f6565 . -16) (f6566 . -12) (f6567 . -8) (f6568 . -4) (f6569 . 0))
# var=f6565
    movl -16(%esp), %eax  # stack load f6565
# end emit-variable-ref
   movl  %eax, 28(%ebp)  # f6565
# emit-variable-ref
# env=((f6562 . -28) (f6563 . -24) (f6564 . -20) (f6565 . -16) (f6566 . -12) (f6567 . -8) (f6568 . -4) (f6569 . 0))
# var=f6563
    movl -24(%esp), %eax  # stack load f6563
# end emit-variable-ref
   movl  %eax, 32(%ebp)  # f6563
# WARNING: free var else not defined in the environmnet
# WARNING: free var (primitive-ref error) not defined in the environmnet
# WARNING: free var (primitive-ref write) not defined in the environmnet
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $48, %ebp     # bump ebp
    jmp _L_40127            # jump around closure body
_L_40126:
# check argument count
    cmp $12,%eax
    je _L_40128
# invoke error handler eh_argcount
    .extern mrc_eh$uargcount
    movl mrc_eh$uargcount, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_40128:
# emit-tail-expr
# si=-20
# env=((f6617 . -16) (f6616 . -12) (f6615 . -8) ((primitive-ref write) . 44) ((primitive-ref error) . 40) (else . 36) (f6563 . 32) (f6565 . 28) (f6564 . 24) (f6566 . 20) (f6567 . 16) ((primitive-ref write-char) . 12) (f6568 . 8) (f6569 . 4) (f6562 . -28) (f6563 . -24) (f6564 . -20) (f6565 . -16) (f6566 . -12) (f6567 . -8) (f6568 . -4) (f6569 . 0))
# expr=(let ((f6615 f6615) (f6616 f6616) (f6617 f6617)) (if (boolean? f6615) ((vector-ref f6569 0) f6615 f6616) (if (null? f6615) ((vector-ref f6568 0) f6616) (if (char? f6615) (if f6617 ((primitive-ref write-char) f6615 f6616) ((vector-ref f6567 0) f6615 f6616)) (if (fixnum? f6615) ((vector-ref f6566 0) f6615 f6616) (if (string? f6615) (if f6617 ((vector-ref f6564 0) f6615 f6616) ((vector-ref f6565 0) f6615 f6616)) (if (pair? f6615) ((vector-ref f6563 0) f6615 f6616) ((primitive-ref error) ((primitive-ref string->symbol) "write") "unrecognized expression"))))))))
# emit-tail-let
#  si   = -20
#  env  = ((f6617 . -16) (f6616 . -12) (f6615 . -8) ((primitive-ref write) . 44) ((primitive-ref error) . 40) (else . 36) (f6563 . 32) (f6565 . 28) (f6564 . 24) (f6566 . 20) (f6567 . 16) ((primitive-ref write-char) . 12) (f6568 . 8) (f6569 . 4) (f6562 . -28) (f6563 . -24) (f6564 . -20) (f6565 . -16) (f6566 . -12) (f6567 . -8) (f6568 . -4) (f6569 . 0))
#  bindings = ((f6615 f6615) (f6616 f6616) (f6617 f6617))
#  body = (if (boolean? f6615) ((vector-ref f6569 0) f6615 f6616) (if (null? f6615) ((vector-ref f6568 0) f6616) (if (char? f6615) (if f6617 ((primitive-ref write-char) f6615 f6616) ((vector-ref f6567 0) f6615 f6616)) (if (fixnum? f6615) ((vector-ref f6566 0) f6615 f6616) (if (string? f6615) (if f6617 ((vector-ref f6564 0) f6615 f6616) ((vector-ref f6565 0) f6615 f6616)) (if (pair? f6615) ((vector-ref f6563 0) f6615 f6616) ((primitive-ref error) ((primitive-ref string->symbol) "write") "unrecognized expression")))))))
# emit-expr f6615
# emit-variable-ref
# env=((f6617 . -16) (f6616 . -12) (f6615 . -8) ((primitive-ref write) . 44) ((primitive-ref error) . 40) (else . 36) (f6563 . 32) (f6565 . 28) (f6564 . 24) (f6566 . 20) (f6567 . 16) ((primitive-ref write-char) . 12) (f6568 . 8) (f6569 . 4) (f6562 . -28) (f6563 . -24) (f6564 . -20) (f6565 . -16) (f6566 . -12) (f6567 . -8) (f6568 . -4) (f6569 . 0))
# var=f6615
    movl -8(%esp), %eax  # stack load f6615
# end emit-variable-ref
    movl %eax, -20(%esp)  # stack save
# emit-expr f6616
# emit-variable-ref
# env=((f6617 . -16) (f6616 . -12) (f6615 . -8) ((primitive-ref write) . 44) ((primitive-ref error) . 40) (else . 36) (f6563 . 32) (f6565 . 28) (f6564 . 24) (f6566 . 20) (f6567 . 16) ((primitive-ref write-char) . 12) (f6568 . 8) (f6569 . 4) (f6562 . -28) (f6563 . -24) (f6564 . -20) (f6565 . -16) (f6566 . -12) (f6567 . -8) (f6568 . -4) (f6569 . 0))
# var=f6616
    movl -12(%esp), %eax  # stack load f6616
# end emit-variable-ref
    movl %eax, -24(%esp)  # stack save
# emit-expr f6617
# emit-variable-ref
# env=((f6617 . -16) (f6616 . -12) (f6615 . -8) ((primitive-ref write) . 44) ((primitive-ref error) . 40) (else . 36) (f6563 . 32) (f6565 . 28) (f6564 . 24) (f6566 . 20) (f6567 . 16) ((primitive-ref write-char) . 12) (f6568 . 8) (f6569 . 4) (f6562 . -28) (f6563 . -24) (f6564 . -20) (f6565 . -16) (f6566 . -12) (f6567 . -8) (f6568 . -4) (f6569 . 0))
# var=f6617
    movl -16(%esp), %eax  # stack load f6617
# end emit-variable-ref
    movl %eax, -28(%esp)  # stack save
# emit-tail-expr
# si=-32
# env=((f6617 . -28) (f6616 . -24) (f6615 . -20) (f6617 . -16) (f6616 . -12) (f6615 . -8) ((primitive-ref write) . 44) ((primitive-ref error) . 40) (else . 36) (f6563 . 32) (f6565 . 28) (f6564 . 24) (f6566 . 20) (f6567 . 16) ((primitive-ref write-char) . 12) (f6568 . 8) (f6569 . 4) (f6562 . -28) (f6563 . -24) (f6564 . -20) (f6565 . -16) (f6566 . -12) (f6567 . -8) (f6568 . -4) (f6569 . 0))
# expr=(if (boolean? f6615) ((vector-ref f6569 0) f6615 f6616) (if (null? f6615) ((vector-ref f6568 0) f6616) (if (char? f6615) (if f6617 ((primitive-ref write-char) f6615 f6616) ((vector-ref f6567 0) f6615 f6616)) (if (fixnum? f6615) ((vector-ref f6566 0) f6615 f6616) (if (string? f6615) (if f6617 ((vector-ref f6564 0) f6615 f6616) ((vector-ref f6565 0) f6615 f6616)) (if (pair? f6615) ((vector-ref f6563 0) f6615 f6616) ((primitive-ref error) ((primitive-ref string->symbol) "write") "unrecognized expression")))))))
# emit-expr (boolean? f6615)
# emit-expr f6615
# emit-variable-ref
# env=((f6617 . -28) (f6616 . -24) (f6615 . -20) (f6617 . -16) (f6616 . -12) (f6615 . -8) ((primitive-ref write) . 44) ((primitive-ref error) . 40) (else . 36) (f6563 . 32) (f6565 . 28) (f6564 . 24) (f6566 . 20) (f6567 . 16) ((primitive-ref write-char) . 12) (f6568 . 8) (f6569 . 4) (f6562 . -28) (f6563 . -24) (f6564 . -20) (f6565 . -16) (f6566 . -12) (f6567 . -8) (f6568 . -4) (f6569 . 0))
# var=f6615
    movl -20(%esp), %eax  # stack load f6615
# end emit-variable-ref
    and $191, %eax
    cmp $47, %eax
    sete %al
    movzbl %al, %eax
    sal $6, %al
    or $47, %al
    cmp $47, %al
    je _L_40129
# emit-tail-expr
# si=-32
# env=((f6617 . -28) (f6616 . -24) (f6615 . -20) (f6617 . -16) (f6616 . -12) (f6615 . -8) ((primitive-ref write) . 44) ((primitive-ref error) . 40) (else . 36) (f6563 . 32) (f6565 . 28) (f6564 . 24) (f6566 . 20) (f6567 . 16) ((primitive-ref write-char) . 12) (f6568 . 8) (f6569 . 4) (f6562 . -28) (f6563 . -24) (f6564 . -20) (f6565 . -16) (f6566 . -12) (f6567 . -8) (f6568 . -4) (f6569 . 0))
# expr=((vector-ref f6569 0) f6615 f6616)
# emit-tail-funcall
#    si   =-32
#    env  = ((f6617 . -28) (f6616 . -24) (f6615 . -20) (f6617 . -16) (f6616 . -12) (f6615 . -8) ((primitive-ref write) . 44) ((primitive-ref error) . 40) (else . 36) (f6563 . 32) (f6565 . 28) (f6564 . 24) (f6566 . 20) (f6567 . 16) ((primitive-ref write-char) . 12) (f6568 . 8) (f6569 . 4) (f6562 . -28) (f6563 . -24) (f6564 . -20) (f6565 . -16) (f6566 . -12) (f6567 . -8) (f6568 . -4) (f6569 . 0))
#    expr = (funcall (vector-ref f6569 0) f6615 f6616)
# emit-expr (vector-ref f6569 0)
# emit-expr f6569
# emit-variable-ref
# env=((f6617 . -28) (f6616 . -24) (f6615 . -20) (f6617 . -16) (f6616 . -12) (f6615 . -8) ((primitive-ref write) . 44) ((primitive-ref error) . 40) (else . 36) (f6563 . 32) (f6565 . 28) (f6564 . 24) (f6566 . 20) (f6567 . 16) ((primitive-ref write-char) . 12) (f6568 . 8) (f6569 . 4) (f6562 . -28) (f6563 . -24) (f6564 . -20) (f6565 . -16) (f6566 . -12) (f6567 . -8) (f6568 . -4) (f6569 . 0))
# var=f6569
    movl 2(%edi), %eax  # frame load f6569
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_40131
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_40131:
    movl %eax, -32(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_40132"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_40132:
# check bounds on vector index
    movl -32(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_40134
    cmp  $0,%eax
    jge _L_40133
_L_40134:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_40133:
    movl -32(%esp), %esi
    movl -1(%eax,%esi), %eax
   movl %eax,  -32(%esp)  # stash funcall-oper in next closure slot
# emit-expr f6615
# emit-variable-ref
# env=((f6617 . -28) (f6616 . -24) (f6615 . -20) (f6617 . -16) (f6616 . -12) (f6615 . -8) ((primitive-ref write) . 44) ((primitive-ref error) . 40) (else . 36) (f6563 . 32) (f6565 . 28) (f6564 . 24) (f6566 . 20) (f6567 . 16) ((primitive-ref write-char) . 12) (f6568 . 8) (f6569 . 4) (f6562 . -28) (f6563 . -24) (f6564 . -20) (f6565 . -16) (f6566 . -12) (f6567 . -8) (f6568 . -4) (f6569 . 0))
# var=f6615
    movl -20(%esp), %eax  # stack load f6615
# end emit-variable-ref
    mov %eax, -36(%esp)    # arg f6615
# emit-expr f6616
# emit-variable-ref
# env=((f6617 . -28) (f6616 . -24) (f6615 . -20) (f6617 . -16) (f6616 . -12) (f6615 . -8) ((primitive-ref write) . 44) ((primitive-ref error) . 40) (else . 36) (f6563 . 32) (f6565 . 28) (f6564 . 24) (f6566 . 20) (f6567 . 16) ((primitive-ref write-char) . 12) (f6568 . 8) (f6569 . 4) (f6562 . -28) (f6563 . -24) (f6564 . -20) (f6565 . -16) (f6566 . -12) (f6567 . -8) (f6568 . -4) (f6569 . 0))
# var=f6616
    movl -24(%esp), %eax  # stack load f6616
# end emit-variable-ref
    mov %eax, -40(%esp)    # arg f6616
    movl -32(%esp), %edi   # load new closure to %edi
# emit-shift-args:  size=3   si=-32  delta=28
    mov -32(%esp), %ebx  # shift frame cell
    mov %ebx, -4(%esp)  # down to base
# emit-shift-args:  size=2   si=-36  delta=28
    mov -36(%esp), %ebx  # shift frame cell
    mov %ebx, -8(%esp)  # down to base
# emit-shift-args:  size=1   si=-40  delta=28
    mov -40(%esp), %ebx  # shift frame cell
    mov %ebx, -12(%esp)  # down to base
# emit-shift-args:  size=0   si=-44  delta=28
    movl $8,%eax   # save arg count
    jmp *-2(%edi)  # tail-funcall
    jmp _L_40130
_L_40129:
# emit-tail-expr
# si=-32
# env=((f6617 . -28) (f6616 . -24) (f6615 . -20) (f6617 . -16) (f6616 . -12) (f6615 . -8) ((primitive-ref write) . 44) ((primitive-ref error) . 40) (else . 36) (f6563 . 32) (f6565 . 28) (f6564 . 24) (f6566 . 20) (f6567 . 16) ((primitive-ref write-char) . 12) (f6568 . 8) (f6569 . 4) (f6562 . -28) (f6563 . -24) (f6564 . -20) (f6565 . -16) (f6566 . -12) (f6567 . -8) (f6568 . -4) (f6569 . 0))
# expr=(if (null? f6615) ((vector-ref f6568 0) f6616) (if (char? f6615) (if f6617 ((primitive-ref write-char) f6615 f6616) ((vector-ref f6567 0) f6615 f6616)) (if (fixnum? f6615) ((vector-ref f6566 0) f6615 f6616) (if (string? f6615) (if f6617 ((vector-ref f6564 0) f6615 f6616) ((vector-ref f6565 0) f6615 f6616)) (if (pair? f6615) ((vector-ref f6563 0) f6615 f6616) ((primitive-ref error) ((primitive-ref string->symbol) "write") "unrecognized expression"))))))
# emit-expr (null? f6615)
# emit-expr f6615
# emit-variable-ref
# env=((f6617 . -28) (f6616 . -24) (f6615 . -20) (f6617 . -16) (f6616 . -12) (f6615 . -8) ((primitive-ref write) . 44) ((primitive-ref error) . 40) (else . 36) (f6563 . 32) (f6565 . 28) (f6564 . 24) (f6566 . 20) (f6567 . 16) ((primitive-ref write-char) . 12) (f6568 . 8) (f6569 . 4) (f6562 . -28) (f6563 . -24) (f6564 . -20) (f6565 . -16) (f6566 . -12) (f6567 . -8) (f6568 . -4) (f6569 . 0))
# var=f6615
    movl -20(%esp), %eax  # stack load f6615
# end emit-variable-ref
    cmp $63, %eax
    mov $0, %eax
    sete %al
    movzbl %al, %eax
    sal $6, %al
    or $47, %al
    cmp $47, %al
    je _L_40135
# emit-tail-expr
# si=-32
# env=((f6617 . -28) (f6616 . -24) (f6615 . -20) (f6617 . -16) (f6616 . -12) (f6615 . -8) ((primitive-ref write) . 44) ((primitive-ref error) . 40) (else . 36) (f6563 . 32) (f6565 . 28) (f6564 . 24) (f6566 . 20) (f6567 . 16) ((primitive-ref write-char) . 12) (f6568 . 8) (f6569 . 4) (f6562 . -28) (f6563 . -24) (f6564 . -20) (f6565 . -16) (f6566 . -12) (f6567 . -8) (f6568 . -4) (f6569 . 0))
# expr=((vector-ref f6568 0) f6616)
# emit-tail-funcall
#    si   =-32
#    env  = ((f6617 . -28) (f6616 . -24) (f6615 . -20) (f6617 . -16) (f6616 . -12) (f6615 . -8) ((primitive-ref write) . 44) ((primitive-ref error) . 40) (else . 36) (f6563 . 32) (f6565 . 28) (f6564 . 24) (f6566 . 20) (f6567 . 16) ((primitive-ref write-char) . 12) (f6568 . 8) (f6569 . 4) (f6562 . -28) (f6563 . -24) (f6564 . -20) (f6565 . -16) (f6566 . -12) (f6567 . -8) (f6568 . -4) (f6569 . 0))
#    expr = (funcall (vector-ref f6568 0) f6616)
# emit-expr (vector-ref f6568 0)
# emit-expr f6568
# emit-variable-ref
# env=((f6617 . -28) (f6616 . -24) (f6615 . -20) (f6617 . -16) (f6616 . -12) (f6615 . -8) ((primitive-ref write) . 44) ((primitive-ref error) . 40) (else . 36) (f6563 . 32) (f6565 . 28) (f6564 . 24) (f6566 . 20) (f6567 . 16) ((primitive-ref write-char) . 12) (f6568 . 8) (f6569 . 4) (f6562 . -28) (f6563 . -24) (f6564 . -20) (f6565 . -16) (f6566 . -12) (f6567 . -8) (f6568 . -4) (f6569 . 0))
# var=f6568
    movl 6(%edi), %eax  # frame load f6568
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_40137
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_40137:
    movl %eax, -32(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_40138"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_40138:
# check bounds on vector index
    movl -32(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_40140
    cmp  $0,%eax
    jge _L_40139
_L_40140:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_40139:
    movl -32(%esp), %esi
    movl -1(%eax,%esi), %eax
   movl %eax,  -32(%esp)  # stash funcall-oper in next closure slot
# emit-expr f6616
# emit-variable-ref
# env=((f6617 . -28) (f6616 . -24) (f6615 . -20) (f6617 . -16) (f6616 . -12) (f6615 . -8) ((primitive-ref write) . 44) ((primitive-ref error) . 40) (else . 36) (f6563 . 32) (f6565 . 28) (f6564 . 24) (f6566 . 20) (f6567 . 16) ((primitive-ref write-char) . 12) (f6568 . 8) (f6569 . 4) (f6562 . -28) (f6563 . -24) (f6564 . -20) (f6565 . -16) (f6566 . -12) (f6567 . -8) (f6568 . -4) (f6569 . 0))
# var=f6616
    movl -24(%esp), %eax  # stack load f6616
# end emit-variable-ref
    mov %eax, -36(%esp)    # arg f6616
    movl -32(%esp), %edi   # load new closure to %edi
# emit-shift-args:  size=2   si=-32  delta=28
    mov -32(%esp), %ebx  # shift frame cell
    mov %ebx, -4(%esp)  # down to base
# emit-shift-args:  size=1   si=-36  delta=28
    mov -36(%esp), %ebx  # shift frame cell
    mov %ebx, -8(%esp)  # down to base
# emit-shift-args:  size=0   si=-40  delta=28
    movl $4,%eax   # save arg count
    jmp *-2(%edi)  # tail-funcall
    jmp _L_40136
_L_40135:
# emit-tail-expr
# si=-32
# env=((f6617 . -28) (f6616 . -24) (f6615 . -20) (f6617 . -16) (f6616 . -12) (f6615 . -8) ((primitive-ref write) . 44) ((primitive-ref error) . 40) (else . 36) (f6563 . 32) (f6565 . 28) (f6564 . 24) (f6566 . 20) (f6567 . 16) ((primitive-ref write-char) . 12) (f6568 . 8) (f6569 . 4) (f6562 . -28) (f6563 . -24) (f6564 . -20) (f6565 . -16) (f6566 . -12) (f6567 . -8) (f6568 . -4) (f6569 . 0))
# expr=(if (char? f6615) (if f6617 ((primitive-ref write-char) f6615 f6616) ((vector-ref f6567 0) f6615 f6616)) (if (fixnum? f6615) ((vector-ref f6566 0) f6615 f6616) (if (string? f6615) (if f6617 ((vector-ref f6564 0) f6615 f6616) ((vector-ref f6565 0) f6615 f6616)) (if (pair? f6615) ((vector-ref f6563 0) f6615 f6616) ((primitive-ref error) ((primitive-ref string->symbol) "write") "unrecognized expression")))))
# emit-expr (char? f6615)
# emit-expr f6615
# emit-variable-ref
# env=((f6617 . -28) (f6616 . -24) (f6615 . -20) (f6617 . -16) (f6616 . -12) (f6615 . -8) ((primitive-ref write) . 44) ((primitive-ref error) . 40) (else . 36) (f6563 . 32) (f6565 . 28) (f6564 . 24) (f6566 . 20) (f6567 . 16) ((primitive-ref write-char) . 12) (f6568 . 8) (f6569 . 4) (f6562 . -28) (f6563 . -24) (f6564 . -20) (f6565 . -16) (f6566 . -12) (f6567 . -8) (f6568 . -4) (f6569 . 0))
# var=f6615
    movl -20(%esp), %eax  # stack load f6615
# end emit-variable-ref
    and $255, %eax
    cmp $15, %eax
    sete %al
    movzbl %al, %eax
    sal $6, %al
    or $47, %al
    cmp $47, %al
    je _L_40141
# emit-tail-expr
# si=-32
# env=((f6617 . -28) (f6616 . -24) (f6615 . -20) (f6617 . -16) (f6616 . -12) (f6615 . -8) ((primitive-ref write) . 44) ((primitive-ref error) . 40) (else . 36) (f6563 . 32) (f6565 . 28) (f6564 . 24) (f6566 . 20) (f6567 . 16) ((primitive-ref write-char) . 12) (f6568 . 8) (f6569 . 4) (f6562 . -28) (f6563 . -24) (f6564 . -20) (f6565 . -16) (f6566 . -12) (f6567 . -8) (f6568 . -4) (f6569 . 0))
# expr=(if f6617 ((primitive-ref write-char) f6615 f6616) ((vector-ref f6567 0) f6615 f6616))
# emit-expr f6617
# emit-variable-ref
# env=((f6617 . -28) (f6616 . -24) (f6615 . -20) (f6617 . -16) (f6616 . -12) (f6615 . -8) ((primitive-ref write) . 44) ((primitive-ref error) . 40) (else . 36) (f6563 . 32) (f6565 . 28) (f6564 . 24) (f6566 . 20) (f6567 . 16) ((primitive-ref write-char) . 12) (f6568 . 8) (f6569 . 4) (f6562 . -28) (f6563 . -24) (f6564 . -20) (f6565 . -16) (f6566 . -12) (f6567 . -8) (f6568 . -4) (f6569 . 0))
# var=f6617
    movl -28(%esp), %eax  # stack load f6617
# end emit-variable-ref
    cmp $47, %al
    je _L_40143
# emit-tail-expr
# si=-32
# env=((f6617 . -28) (f6616 . -24) (f6615 . -20) (f6617 . -16) (f6616 . -12) (f6615 . -8) ((primitive-ref write) . 44) ((primitive-ref error) . 40) (else . 36) (f6563 . 32) (f6565 . 28) (f6564 . 24) (f6566 . 20) (f6567 . 16) ((primitive-ref write-char) . 12) (f6568 . 8) (f6569 . 4) (f6562 . -28) (f6563 . -24) (f6564 . -20) (f6565 . -16) (f6566 . -12) (f6567 . -8) (f6568 . -4) (f6569 . 0))
# expr=((primitive-ref write-char) f6615 f6616)
# emit-tail-funcall
#    si   =-32
#    env  = ((f6617 . -28) (f6616 . -24) (f6615 . -20) (f6617 . -16) (f6616 . -12) (f6615 . -8) ((primitive-ref write) . 44) ((primitive-ref error) . 40) (else . 36) (f6563 . 32) (f6565 . 28) (f6564 . 24) (f6566 . 20) (f6567 . 16) ((primitive-ref write-char) . 12) (f6568 . 8) (f6569 . 4) (f6562 . -28) (f6563 . -24) (f6564 . -20) (f6565 . -16) (f6566 . -12) (f6567 . -8) (f6568 . -4) (f6569 . 0))
#    expr = (funcall (primitive-ref write-char) f6615 f6616)
# emit-expr (primitive-ref write-char)
    .extern mrc_write$mchar
    movl mrc_write$mchar,%eax
   movl %eax,  -32(%esp)  # stash funcall-oper in next closure slot
# emit-expr f6615
# emit-variable-ref
# env=((f6617 . -28) (f6616 . -24) (f6615 . -20) (f6617 . -16) (f6616 . -12) (f6615 . -8) ((primitive-ref write) . 44) ((primitive-ref error) . 40) (else . 36) (f6563 . 32) (f6565 . 28) (f6564 . 24) (f6566 . 20) (f6567 . 16) ((primitive-ref write-char) . 12) (f6568 . 8) (f6569 . 4) (f6562 . -28) (f6563 . -24) (f6564 . -20) (f6565 . -16) (f6566 . -12) (f6567 . -8) (f6568 . -4) (f6569 . 0))
# var=f6615
    movl -20(%esp), %eax  # stack load f6615
# end emit-variable-ref
    mov %eax, -36(%esp)    # arg f6615
# emit-expr f6616
# emit-variable-ref
# env=((f6617 . -28) (f6616 . -24) (f6615 . -20) (f6617 . -16) (f6616 . -12) (f6615 . -8) ((primitive-ref write) . 44) ((primitive-ref error) . 40) (else . 36) (f6563 . 32) (f6565 . 28) (f6564 . 24) (f6566 . 20) (f6567 . 16) ((primitive-ref write-char) . 12) (f6568 . 8) (f6569 . 4) (f6562 . -28) (f6563 . -24) (f6564 . -20) (f6565 . -16) (f6566 . -12) (f6567 . -8) (f6568 . -4) (f6569 . 0))
# var=f6616
    movl -24(%esp), %eax  # stack load f6616
# end emit-variable-ref
    mov %eax, -40(%esp)    # arg f6616
    movl -32(%esp), %edi   # load new closure to %edi
# emit-shift-args:  size=3   si=-32  delta=28
    mov -32(%esp), %ebx  # shift frame cell
    mov %ebx, -4(%esp)  # down to base
# emit-shift-args:  size=2   si=-36  delta=28
    mov -36(%esp), %ebx  # shift frame cell
    mov %ebx, -8(%esp)  # down to base
# emit-shift-args:  size=1   si=-40  delta=28
    mov -40(%esp), %ebx  # shift frame cell
    mov %ebx, -12(%esp)  # down to base
# emit-shift-args:  size=0   si=-44  delta=28
    movl $8,%eax   # save arg count
    jmp *-2(%edi)  # tail-funcall
    jmp _L_40144
_L_40143:
# emit-tail-expr
# si=-32
# env=((f6617 . -28) (f6616 . -24) (f6615 . -20) (f6617 . -16) (f6616 . -12) (f6615 . -8) ((primitive-ref write) . 44) ((primitive-ref error) . 40) (else . 36) (f6563 . 32) (f6565 . 28) (f6564 . 24) (f6566 . 20) (f6567 . 16) ((primitive-ref write-char) . 12) (f6568 . 8) (f6569 . 4) (f6562 . -28) (f6563 . -24) (f6564 . -20) (f6565 . -16) (f6566 . -12) (f6567 . -8) (f6568 . -4) (f6569 . 0))
# expr=((vector-ref f6567 0) f6615 f6616)
# emit-tail-funcall
#    si   =-32
#    env  = ((f6617 . -28) (f6616 . -24) (f6615 . -20) (f6617 . -16) (f6616 . -12) (f6615 . -8) ((primitive-ref write) . 44) ((primitive-ref error) . 40) (else . 36) (f6563 . 32) (f6565 . 28) (f6564 . 24) (f6566 . 20) (f6567 . 16) ((primitive-ref write-char) . 12) (f6568 . 8) (f6569 . 4) (f6562 . -28) (f6563 . -24) (f6564 . -20) (f6565 . -16) (f6566 . -12) (f6567 . -8) (f6568 . -4) (f6569 . 0))
#    expr = (funcall (vector-ref f6567 0) f6615 f6616)
# emit-expr (vector-ref f6567 0)
# emit-expr f6567
# emit-variable-ref
# env=((f6617 . -28) (f6616 . -24) (f6615 . -20) (f6617 . -16) (f6616 . -12) (f6615 . -8) ((primitive-ref write) . 44) ((primitive-ref error) . 40) (else . 36) (f6563 . 32) (f6565 . 28) (f6564 . 24) (f6566 . 20) (f6567 . 16) ((primitive-ref write-char) . 12) (f6568 . 8) (f6569 . 4) (f6562 . -28) (f6563 . -24) (f6564 . -20) (f6565 . -16) (f6566 . -12) (f6567 . -8) (f6568 . -4) (f6569 . 0))
# var=f6567
    movl 14(%edi), %eax  # frame load f6567
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_40145
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_40145:
    movl %eax, -32(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_40146"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_40146:
# check bounds on vector index
    movl -32(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_40148
    cmp  $0,%eax
    jge _L_40147
_L_40148:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_40147:
    movl -32(%esp), %esi
    movl -1(%eax,%esi), %eax
   movl %eax,  -32(%esp)  # stash funcall-oper in next closure slot
# emit-expr f6615
# emit-variable-ref
# env=((f6617 . -28) (f6616 . -24) (f6615 . -20) (f6617 . -16) (f6616 . -12) (f6615 . -8) ((primitive-ref write) . 44) ((primitive-ref error) . 40) (else . 36) (f6563 . 32) (f6565 . 28) (f6564 . 24) (f6566 . 20) (f6567 . 16) ((primitive-ref write-char) . 12) (f6568 . 8) (f6569 . 4) (f6562 . -28) (f6563 . -24) (f6564 . -20) (f6565 . -16) (f6566 . -12) (f6567 . -8) (f6568 . -4) (f6569 . 0))
# var=f6615
    movl -20(%esp), %eax  # stack load f6615
# end emit-variable-ref
    mov %eax, -36(%esp)    # arg f6615
# emit-expr f6616
# emit-variable-ref
# env=((f6617 . -28) (f6616 . -24) (f6615 . -20) (f6617 . -16) (f6616 . -12) (f6615 . -8) ((primitive-ref write) . 44) ((primitive-ref error) . 40) (else . 36) (f6563 . 32) (f6565 . 28) (f6564 . 24) (f6566 . 20) (f6567 . 16) ((primitive-ref write-char) . 12) (f6568 . 8) (f6569 . 4) (f6562 . -28) (f6563 . -24) (f6564 . -20) (f6565 . -16) (f6566 . -12) (f6567 . -8) (f6568 . -4) (f6569 . 0))
# var=f6616
    movl -24(%esp), %eax  # stack load f6616
# end emit-variable-ref
    mov %eax, -40(%esp)    # arg f6616
    movl -32(%esp), %edi   # load new closure to %edi
# emit-shift-args:  size=3   si=-32  delta=28
    mov -32(%esp), %ebx  # shift frame cell
    mov %ebx, -4(%esp)  # down to base
# emit-shift-args:  size=2   si=-36  delta=28
    mov -36(%esp), %ebx  # shift frame cell
    mov %ebx, -8(%esp)  # down to base
# emit-shift-args:  size=1   si=-40  delta=28
    mov -40(%esp), %ebx  # shift frame cell
    mov %ebx, -12(%esp)  # down to base
# emit-shift-args:  size=0   si=-44  delta=28
    movl $8,%eax   # save arg count
    jmp *-2(%edi)  # tail-funcall
_L_40144:
    jmp _L_40142
_L_40141:
# emit-tail-expr
# si=-32
# env=((f6617 . -28) (f6616 . -24) (f6615 . -20) (f6617 . -16) (f6616 . -12) (f6615 . -8) ((primitive-ref write) . 44) ((primitive-ref error) . 40) (else . 36) (f6563 . 32) (f6565 . 28) (f6564 . 24) (f6566 . 20) (f6567 . 16) ((primitive-ref write-char) . 12) (f6568 . 8) (f6569 . 4) (f6562 . -28) (f6563 . -24) (f6564 . -20) (f6565 . -16) (f6566 . -12) (f6567 . -8) (f6568 . -4) (f6569 . 0))
# expr=(if (fixnum? f6615) ((vector-ref f6566 0) f6615 f6616) (if (string? f6615) (if f6617 ((vector-ref f6564 0) f6615 f6616) ((vector-ref f6565 0) f6615 f6616)) (if (pair? f6615) ((vector-ref f6563 0) f6615 f6616) ((primitive-ref error) ((primitive-ref string->symbol) "write") "unrecognized expression"))))
# emit-expr (fixnum? f6615)
# emit-expr f6615
# emit-variable-ref
# env=((f6617 . -28) (f6616 . -24) (f6615 . -20) (f6617 . -16) (f6616 . -12) (f6615 . -8) ((primitive-ref write) . 44) ((primitive-ref error) . 40) (else . 36) (f6563 . 32) (f6565 . 28) (f6564 . 24) (f6566 . 20) (f6567 . 16) ((primitive-ref write-char) . 12) (f6568 . 8) (f6569 . 4) (f6562 . -28) (f6563 . -24) (f6564 . -20) (f6565 . -16) (f6566 . -12) (f6567 . -8) (f6568 . -4) (f6569 . 0))
# var=f6615
    movl -20(%esp), %eax  # stack load f6615
# end emit-variable-ref
    and $3, %al
    cmp $0, %al
    sete %al
    movzbl %al, %eax
    sal $6, %al
    or $47, %al
    cmp $47, %al
    je _L_40149
# emit-tail-expr
# si=-32
# env=((f6617 . -28) (f6616 . -24) (f6615 . -20) (f6617 . -16) (f6616 . -12) (f6615 . -8) ((primitive-ref write) . 44) ((primitive-ref error) . 40) (else . 36) (f6563 . 32) (f6565 . 28) (f6564 . 24) (f6566 . 20) (f6567 . 16) ((primitive-ref write-char) . 12) (f6568 . 8) (f6569 . 4) (f6562 . -28) (f6563 . -24) (f6564 . -20) (f6565 . -16) (f6566 . -12) (f6567 . -8) (f6568 . -4) (f6569 . 0))
# expr=((vector-ref f6566 0) f6615 f6616)
# emit-tail-funcall
#    si   =-32
#    env  = ((f6617 . -28) (f6616 . -24) (f6615 . -20) (f6617 . -16) (f6616 . -12) (f6615 . -8) ((primitive-ref write) . 44) ((primitive-ref error) . 40) (else . 36) (f6563 . 32) (f6565 . 28) (f6564 . 24) (f6566 . 20) (f6567 . 16) ((primitive-ref write-char) . 12) (f6568 . 8) (f6569 . 4) (f6562 . -28) (f6563 . -24) (f6564 . -20) (f6565 . -16) (f6566 . -12) (f6567 . -8) (f6568 . -4) (f6569 . 0))
#    expr = (funcall (vector-ref f6566 0) f6615 f6616)
# emit-expr (vector-ref f6566 0)
# emit-expr f6566
# emit-variable-ref
# env=((f6617 . -28) (f6616 . -24) (f6615 . -20) (f6617 . -16) (f6616 . -12) (f6615 . -8) ((primitive-ref write) . 44) ((primitive-ref error) . 40) (else . 36) (f6563 . 32) (f6565 . 28) (f6564 . 24) (f6566 . 20) (f6567 . 16) ((primitive-ref write-char) . 12) (f6568 . 8) (f6569 . 4) (f6562 . -28) (f6563 . -24) (f6564 . -20) (f6565 . -16) (f6566 . -12) (f6567 . -8) (f6568 . -4) (f6569 . 0))
# var=f6566
    movl 18(%edi), %eax  # frame load f6566
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_40151
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_40151:
    movl %eax, -32(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_40152"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_40152:
# check bounds on vector index
    movl -32(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_40154
    cmp  $0,%eax
    jge _L_40153
_L_40154:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_40153:
    movl -32(%esp), %esi
    movl -1(%eax,%esi), %eax
   movl %eax,  -32(%esp)  # stash funcall-oper in next closure slot
# emit-expr f6615
# emit-variable-ref
# env=((f6617 . -28) (f6616 . -24) (f6615 . -20) (f6617 . -16) (f6616 . -12) (f6615 . -8) ((primitive-ref write) . 44) ((primitive-ref error) . 40) (else . 36) (f6563 . 32) (f6565 . 28) (f6564 . 24) (f6566 . 20) (f6567 . 16) ((primitive-ref write-char) . 12) (f6568 . 8) (f6569 . 4) (f6562 . -28) (f6563 . -24) (f6564 . -20) (f6565 . -16) (f6566 . -12) (f6567 . -8) (f6568 . -4) (f6569 . 0))
# var=f6615
    movl -20(%esp), %eax  # stack load f6615
# end emit-variable-ref
    mov %eax, -36(%esp)    # arg f6615
# emit-expr f6616
# emit-variable-ref
# env=((f6617 . -28) (f6616 . -24) (f6615 . -20) (f6617 . -16) (f6616 . -12) (f6615 . -8) ((primitive-ref write) . 44) ((primitive-ref error) . 40) (else . 36) (f6563 . 32) (f6565 . 28) (f6564 . 24) (f6566 . 20) (f6567 . 16) ((primitive-ref write-char) . 12) (f6568 . 8) (f6569 . 4) (f6562 . -28) (f6563 . -24) (f6564 . -20) (f6565 . -16) (f6566 . -12) (f6567 . -8) (f6568 . -4) (f6569 . 0))
# var=f6616
    movl -24(%esp), %eax  # stack load f6616
# end emit-variable-ref
    mov %eax, -40(%esp)    # arg f6616
    movl -32(%esp), %edi   # load new closure to %edi
# emit-shift-args:  size=3   si=-32  delta=28
    mov -32(%esp), %ebx  # shift frame cell
    mov %ebx, -4(%esp)  # down to base
# emit-shift-args:  size=2   si=-36  delta=28
    mov -36(%esp), %ebx  # shift frame cell
    mov %ebx, -8(%esp)  # down to base
# emit-shift-args:  size=1   si=-40  delta=28
    mov -40(%esp), %ebx  # shift frame cell
    mov %ebx, -12(%esp)  # down to base
# emit-shift-args:  size=0   si=-44  delta=28
    movl $8,%eax   # save arg count
    jmp *-2(%edi)  # tail-funcall
    jmp _L_40150
_L_40149:
# emit-tail-expr
# si=-32
# env=((f6617 . -28) (f6616 . -24) (f6615 . -20) (f6617 . -16) (f6616 . -12) (f6615 . -8) ((primitive-ref write) . 44) ((primitive-ref error) . 40) (else . 36) (f6563 . 32) (f6565 . 28) (f6564 . 24) (f6566 . 20) (f6567 . 16) ((primitive-ref write-char) . 12) (f6568 . 8) (f6569 . 4) (f6562 . -28) (f6563 . -24) (f6564 . -20) (f6565 . -16) (f6566 . -12) (f6567 . -8) (f6568 . -4) (f6569 . 0))
# expr=(if (string? f6615) (if f6617 ((vector-ref f6564 0) f6615 f6616) ((vector-ref f6565 0) f6615 f6616)) (if (pair? f6615) ((vector-ref f6563 0) f6615 f6616) ((primitive-ref error) ((primitive-ref string->symbol) "write") "unrecognized expression")))
# emit-expr (string? f6615)
# emit-expr f6615
# emit-variable-ref
# env=((f6617 . -28) (f6616 . -24) (f6615 . -20) (f6617 . -16) (f6616 . -12) (f6615 . -8) ((primitive-ref write) . 44) ((primitive-ref error) . 40) (else . 36) (f6563 . 32) (f6565 . 28) (f6564 . 24) (f6566 . 20) (f6567 . 16) ((primitive-ref write-char) . 12) (f6568 . 8) (f6569 . 4) (f6562 . -28) (f6563 . -24) (f6564 . -20) (f6565 . -16) (f6566 . -12) (f6567 . -8) (f6568 . -4) (f6569 . 0))
# var=f6615
    movl -20(%esp), %eax  # stack load f6615
# end emit-variable-ref
    and $7, %al
    cmp $6, %al
    sete %al
    movzbl %al, %eax
    sal $6, %al
    or $47, %al
    cmp $47, %al
    je _L_40155
# emit-tail-expr
# si=-32
# env=((f6617 . -28) (f6616 . -24) (f6615 . -20) (f6617 . -16) (f6616 . -12) (f6615 . -8) ((primitive-ref write) . 44) ((primitive-ref error) . 40) (else . 36) (f6563 . 32) (f6565 . 28) (f6564 . 24) (f6566 . 20) (f6567 . 16) ((primitive-ref write-char) . 12) (f6568 . 8) (f6569 . 4) (f6562 . -28) (f6563 . -24) (f6564 . -20) (f6565 . -16) (f6566 . -12) (f6567 . -8) (f6568 . -4) (f6569 . 0))
# expr=(if f6617 ((vector-ref f6564 0) f6615 f6616) ((vector-ref f6565 0) f6615 f6616))
# emit-expr f6617
# emit-variable-ref
# env=((f6617 . -28) (f6616 . -24) (f6615 . -20) (f6617 . -16) (f6616 . -12) (f6615 . -8) ((primitive-ref write) . 44) ((primitive-ref error) . 40) (else . 36) (f6563 . 32) (f6565 . 28) (f6564 . 24) (f6566 . 20) (f6567 . 16) ((primitive-ref write-char) . 12) (f6568 . 8) (f6569 . 4) (f6562 . -28) (f6563 . -24) (f6564 . -20) (f6565 . -16) (f6566 . -12) (f6567 . -8) (f6568 . -4) (f6569 . 0))
# var=f6617
    movl -28(%esp), %eax  # stack load f6617
# end emit-variable-ref
    cmp $47, %al
    je _L_40157
# emit-tail-expr
# si=-32
# env=((f6617 . -28) (f6616 . -24) (f6615 . -20) (f6617 . -16) (f6616 . -12) (f6615 . -8) ((primitive-ref write) . 44) ((primitive-ref error) . 40) (else . 36) (f6563 . 32) (f6565 . 28) (f6564 . 24) (f6566 . 20) (f6567 . 16) ((primitive-ref write-char) . 12) (f6568 . 8) (f6569 . 4) (f6562 . -28) (f6563 . -24) (f6564 . -20) (f6565 . -16) (f6566 . -12) (f6567 . -8) (f6568 . -4) (f6569 . 0))
# expr=((vector-ref f6564 0) f6615 f6616)
# emit-tail-funcall
#    si   =-32
#    env  = ((f6617 . -28) (f6616 . -24) (f6615 . -20) (f6617 . -16) (f6616 . -12) (f6615 . -8) ((primitive-ref write) . 44) ((primitive-ref error) . 40) (else . 36) (f6563 . 32) (f6565 . 28) (f6564 . 24) (f6566 . 20) (f6567 . 16) ((primitive-ref write-char) . 12) (f6568 . 8) (f6569 . 4) (f6562 . -28) (f6563 . -24) (f6564 . -20) (f6565 . -16) (f6566 . -12) (f6567 . -8) (f6568 . -4) (f6569 . 0))
#    expr = (funcall (vector-ref f6564 0) f6615 f6616)
# emit-expr (vector-ref f6564 0)
# emit-expr f6564
# emit-variable-ref
# env=((f6617 . -28) (f6616 . -24) (f6615 . -20) (f6617 . -16) (f6616 . -12) (f6615 . -8) ((primitive-ref write) . 44) ((primitive-ref error) . 40) (else . 36) (f6563 . 32) (f6565 . 28) (f6564 . 24) (f6566 . 20) (f6567 . 16) ((primitive-ref write-char) . 12) (f6568 . 8) (f6569 . 4) (f6562 . -28) (f6563 . -24) (f6564 . -20) (f6565 . -16) (f6566 . -12) (f6567 . -8) (f6568 . -4) (f6569 . 0))
# var=f6564
    movl 22(%edi), %eax  # frame load f6564
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_40159
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_40159:
    movl %eax, -32(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_40160"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_40160:
# check bounds on vector index
    movl -32(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_40162
    cmp  $0,%eax
    jge _L_40161
_L_40162:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_40161:
    movl -32(%esp), %esi
    movl -1(%eax,%esi), %eax
   movl %eax,  -32(%esp)  # stash funcall-oper in next closure slot
# emit-expr f6615
# emit-variable-ref
# env=((f6617 . -28) (f6616 . -24) (f6615 . -20) (f6617 . -16) (f6616 . -12) (f6615 . -8) ((primitive-ref write) . 44) ((primitive-ref error) . 40) (else . 36) (f6563 . 32) (f6565 . 28) (f6564 . 24) (f6566 . 20) (f6567 . 16) ((primitive-ref write-char) . 12) (f6568 . 8) (f6569 . 4) (f6562 . -28) (f6563 . -24) (f6564 . -20) (f6565 . -16) (f6566 . -12) (f6567 . -8) (f6568 . -4) (f6569 . 0))
# var=f6615
    movl -20(%esp), %eax  # stack load f6615
# end emit-variable-ref
    mov %eax, -36(%esp)    # arg f6615
# emit-expr f6616
# emit-variable-ref
# env=((f6617 . -28) (f6616 . -24) (f6615 . -20) (f6617 . -16) (f6616 . -12) (f6615 . -8) ((primitive-ref write) . 44) ((primitive-ref error) . 40) (else . 36) (f6563 . 32) (f6565 . 28) (f6564 . 24) (f6566 . 20) (f6567 . 16) ((primitive-ref write-char) . 12) (f6568 . 8) (f6569 . 4) (f6562 . -28) (f6563 . -24) (f6564 . -20) (f6565 . -16) (f6566 . -12) (f6567 . -8) (f6568 . -4) (f6569 . 0))
# var=f6616
    movl -24(%esp), %eax  # stack load f6616
# end emit-variable-ref
    mov %eax, -40(%esp)    # arg f6616
    movl -32(%esp), %edi   # load new closure to %edi
# emit-shift-args:  size=3   si=-32  delta=28
    mov -32(%esp), %ebx  # shift frame cell
    mov %ebx, -4(%esp)  # down to base
# emit-shift-args:  size=2   si=-36  delta=28
    mov -36(%esp), %ebx  # shift frame cell
    mov %ebx, -8(%esp)  # down to base
# emit-shift-args:  size=1   si=-40  delta=28
    mov -40(%esp), %ebx  # shift frame cell
    mov %ebx, -12(%esp)  # down to base
# emit-shift-args:  size=0   si=-44  delta=28
    movl $8,%eax   # save arg count
    jmp *-2(%edi)  # tail-funcall
    jmp _L_40158
_L_40157:
# emit-tail-expr
# si=-32
# env=((f6617 . -28) (f6616 . -24) (f6615 . -20) (f6617 . -16) (f6616 . -12) (f6615 . -8) ((primitive-ref write) . 44) ((primitive-ref error) . 40) (else . 36) (f6563 . 32) (f6565 . 28) (f6564 . 24) (f6566 . 20) (f6567 . 16) ((primitive-ref write-char) . 12) (f6568 . 8) (f6569 . 4) (f6562 . -28) (f6563 . -24) (f6564 . -20) (f6565 . -16) (f6566 . -12) (f6567 . -8) (f6568 . -4) (f6569 . 0))
# expr=((vector-ref f6565 0) f6615 f6616)
# emit-tail-funcall
#    si   =-32
#    env  = ((f6617 . -28) (f6616 . -24) (f6615 . -20) (f6617 . -16) (f6616 . -12) (f6615 . -8) ((primitive-ref write) . 44) ((primitive-ref error) . 40) (else . 36) (f6563 . 32) (f6565 . 28) (f6564 . 24) (f6566 . 20) (f6567 . 16) ((primitive-ref write-char) . 12) (f6568 . 8) (f6569 . 4) (f6562 . -28) (f6563 . -24) (f6564 . -20) (f6565 . -16) (f6566 . -12) (f6567 . -8) (f6568 . -4) (f6569 . 0))
#    expr = (funcall (vector-ref f6565 0) f6615 f6616)
# emit-expr (vector-ref f6565 0)
# emit-expr f6565
# emit-variable-ref
# env=((f6617 . -28) (f6616 . -24) (f6615 . -20) (f6617 . -16) (f6616 . -12) (f6615 . -8) ((primitive-ref write) . 44) ((primitive-ref error) . 40) (else . 36) (f6563 . 32) (f6565 . 28) (f6564 . 24) (f6566 . 20) (f6567 . 16) ((primitive-ref write-char) . 12) (f6568 . 8) (f6569 . 4) (f6562 . -28) (f6563 . -24) (f6564 . -20) (f6565 . -16) (f6566 . -12) (f6567 . -8) (f6568 . -4) (f6569 . 0))
# var=f6565
    movl 26(%edi), %eax  # frame load f6565
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_40163
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_40163:
    movl %eax, -32(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_40164"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_40164:
# check bounds on vector index
    movl -32(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_40166
    cmp  $0,%eax
    jge _L_40165
_L_40166:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_40165:
    movl -32(%esp), %esi
    movl -1(%eax,%esi), %eax
   movl %eax,  -32(%esp)  # stash funcall-oper in next closure slot
# emit-expr f6615
# emit-variable-ref
# env=((f6617 . -28) (f6616 . -24) (f6615 . -20) (f6617 . -16) (f6616 . -12) (f6615 . -8) ((primitive-ref write) . 44) ((primitive-ref error) . 40) (else . 36) (f6563 . 32) (f6565 . 28) (f6564 . 24) (f6566 . 20) (f6567 . 16) ((primitive-ref write-char) . 12) (f6568 . 8) (f6569 . 4) (f6562 . -28) (f6563 . -24) (f6564 . -20) (f6565 . -16) (f6566 . -12) (f6567 . -8) (f6568 . -4) (f6569 . 0))
# var=f6615
    movl -20(%esp), %eax  # stack load f6615
# end emit-variable-ref
    mov %eax, -36(%esp)    # arg f6615
# emit-expr f6616
# emit-variable-ref
# env=((f6617 . -28) (f6616 . -24) (f6615 . -20) (f6617 . -16) (f6616 . -12) (f6615 . -8) ((primitive-ref write) . 44) ((primitive-ref error) . 40) (else . 36) (f6563 . 32) (f6565 . 28) (f6564 . 24) (f6566 . 20) (f6567 . 16) ((primitive-ref write-char) . 12) (f6568 . 8) (f6569 . 4) (f6562 . -28) (f6563 . -24) (f6564 . -20) (f6565 . -16) (f6566 . -12) (f6567 . -8) (f6568 . -4) (f6569 . 0))
# var=f6616
    movl -24(%esp), %eax  # stack load f6616
# end emit-variable-ref
    mov %eax, -40(%esp)    # arg f6616
    movl -32(%esp), %edi   # load new closure to %edi
# emit-shift-args:  size=3   si=-32  delta=28
    mov -32(%esp), %ebx  # shift frame cell
    mov %ebx, -4(%esp)  # down to base
# emit-shift-args:  size=2   si=-36  delta=28
    mov -36(%esp), %ebx  # shift frame cell
    mov %ebx, -8(%esp)  # down to base
# emit-shift-args:  size=1   si=-40  delta=28
    mov -40(%esp), %ebx  # shift frame cell
    mov %ebx, -12(%esp)  # down to base
# emit-shift-args:  size=0   si=-44  delta=28
    movl $8,%eax   # save arg count
    jmp *-2(%edi)  # tail-funcall
_L_40158:
    jmp _L_40156
_L_40155:
# emit-tail-expr
# si=-32
# env=((f6617 . -28) (f6616 . -24) (f6615 . -20) (f6617 . -16) (f6616 . -12) (f6615 . -8) ((primitive-ref write) . 44) ((primitive-ref error) . 40) (else . 36) (f6563 . 32) (f6565 . 28) (f6564 . 24) (f6566 . 20) (f6567 . 16) ((primitive-ref write-char) . 12) (f6568 . 8) (f6569 . 4) (f6562 . -28) (f6563 . -24) (f6564 . -20) (f6565 . -16) (f6566 . -12) (f6567 . -8) (f6568 . -4) (f6569 . 0))
# expr=(if (pair? f6615) ((vector-ref f6563 0) f6615 f6616) ((primitive-ref error) ((primitive-ref string->symbol) "write") "unrecognized expression"))
# emit-expr (pair? f6615)
# emit-expr f6615
# emit-variable-ref
# env=((f6617 . -28) (f6616 . -24) (f6615 . -20) (f6617 . -16) (f6616 . -12) (f6615 . -8) ((primitive-ref write) . 44) ((primitive-ref error) . 40) (else . 36) (f6563 . 32) (f6565 . 28) (f6564 . 24) (f6566 . 20) (f6567 . 16) ((primitive-ref write-char) . 12) (f6568 . 8) (f6569 . 4) (f6562 . -28) (f6563 . -24) (f6564 . -20) (f6565 . -16) (f6566 . -12) (f6567 . -8) (f6568 . -4) (f6569 . 0))
# var=f6615
    movl -20(%esp), %eax  # stack load f6615
# end emit-variable-ref
    and $7, %al
    cmp $1, %al
    sete %al
    movzbl %al, %eax
    sal $6, %al
    or $47, %al
    cmp $47, %al
    je _L_40167
# emit-tail-expr
# si=-32
# env=((f6617 . -28) (f6616 . -24) (f6615 . -20) (f6617 . -16) (f6616 . -12) (f6615 . -8) ((primitive-ref write) . 44) ((primitive-ref error) . 40) (else . 36) (f6563 . 32) (f6565 . 28) (f6564 . 24) (f6566 . 20) (f6567 . 16) ((primitive-ref write-char) . 12) (f6568 . 8) (f6569 . 4) (f6562 . -28) (f6563 . -24) (f6564 . -20) (f6565 . -16) (f6566 . -12) (f6567 . -8) (f6568 . -4) (f6569 . 0))
# expr=((vector-ref f6563 0) f6615 f6616)
# emit-tail-funcall
#    si   =-32
#    env  = ((f6617 . -28) (f6616 . -24) (f6615 . -20) (f6617 . -16) (f6616 . -12) (f6615 . -8) ((primitive-ref write) . 44) ((primitive-ref error) . 40) (else . 36) (f6563 . 32) (f6565 . 28) (f6564 . 24) (f6566 . 20) (f6567 . 16) ((primitive-ref write-char) . 12) (f6568 . 8) (f6569 . 4) (f6562 . -28) (f6563 . -24) (f6564 . -20) (f6565 . -16) (f6566 . -12) (f6567 . -8) (f6568 . -4) (f6569 . 0))
#    expr = (funcall (vector-ref f6563 0) f6615 f6616)
# emit-expr (vector-ref f6563 0)
# emit-expr f6563
# emit-variable-ref
# env=((f6617 . -28) (f6616 . -24) (f6615 . -20) (f6617 . -16) (f6616 . -12) (f6615 . -8) ((primitive-ref write) . 44) ((primitive-ref error) . 40) (else . 36) (f6563 . 32) (f6565 . 28) (f6564 . 24) (f6566 . 20) (f6567 . 16) ((primitive-ref write-char) . 12) (f6568 . 8) (f6569 . 4) (f6562 . -28) (f6563 . -24) (f6564 . -20) (f6565 . -16) (f6566 . -12) (f6567 . -8) (f6568 . -4) (f6569 . 0))
# var=f6563
    movl 30(%edi), %eax  # frame load f6563
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_40169
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_40169:
    movl %eax, -32(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_40170"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_40170:
# check bounds on vector index
    movl -32(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_40172
    cmp  $0,%eax
    jge _L_40171
_L_40172:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_40171:
    movl -32(%esp), %esi
    movl -1(%eax,%esi), %eax
   movl %eax,  -32(%esp)  # stash funcall-oper in next closure slot
# emit-expr f6615
# emit-variable-ref
# env=((f6617 . -28) (f6616 . -24) (f6615 . -20) (f6617 . -16) (f6616 . -12) (f6615 . -8) ((primitive-ref write) . 44) ((primitive-ref error) . 40) (else . 36) (f6563 . 32) (f6565 . 28) (f6564 . 24) (f6566 . 20) (f6567 . 16) ((primitive-ref write-char) . 12) (f6568 . 8) (f6569 . 4) (f6562 . -28) (f6563 . -24) (f6564 . -20) (f6565 . -16) (f6566 . -12) (f6567 . -8) (f6568 . -4) (f6569 . 0))
# var=f6615
    movl -20(%esp), %eax  # stack load f6615
# end emit-variable-ref
    mov %eax, -36(%esp)    # arg f6615
# emit-expr f6616
# emit-variable-ref
# env=((f6617 . -28) (f6616 . -24) (f6615 . -20) (f6617 . -16) (f6616 . -12) (f6615 . -8) ((primitive-ref write) . 44) ((primitive-ref error) . 40) (else . 36) (f6563 . 32) (f6565 . 28) (f6564 . 24) (f6566 . 20) (f6567 . 16) ((primitive-ref write-char) . 12) (f6568 . 8) (f6569 . 4) (f6562 . -28) (f6563 . -24) (f6564 . -20) (f6565 . -16) (f6566 . -12) (f6567 . -8) (f6568 . -4) (f6569 . 0))
# var=f6616
    movl -24(%esp), %eax  # stack load f6616
# end emit-variable-ref
    mov %eax, -40(%esp)    # arg f6616
    movl -32(%esp), %edi   # load new closure to %edi
# emit-shift-args:  size=3   si=-32  delta=28
    mov -32(%esp), %ebx  # shift frame cell
    mov %ebx, -4(%esp)  # down to base
# emit-shift-args:  size=2   si=-36  delta=28
    mov -36(%esp), %ebx  # shift frame cell
    mov %ebx, -8(%esp)  # down to base
# emit-shift-args:  size=1   si=-40  delta=28
    mov -40(%esp), %ebx  # shift frame cell
    mov %ebx, -12(%esp)  # down to base
# emit-shift-args:  size=0   si=-44  delta=28
    movl $8,%eax   # save arg count
    jmp *-2(%edi)  # tail-funcall
    jmp _L_40168
_L_40167:
# emit-tail-expr
# si=-32
# env=((f6617 . -28) (f6616 . -24) (f6615 . -20) (f6617 . -16) (f6616 . -12) (f6615 . -8) ((primitive-ref write) . 44) ((primitive-ref error) . 40) (else . 36) (f6563 . 32) (f6565 . 28) (f6564 . 24) (f6566 . 20) (f6567 . 16) ((primitive-ref write-char) . 12) (f6568 . 8) (f6569 . 4) (f6562 . -28) (f6563 . -24) (f6564 . -20) (f6565 . -16) (f6566 . -12) (f6567 . -8) (f6568 . -4) (f6569 . 0))
# expr=((primitive-ref error) ((primitive-ref string->symbol) "write") "unrecognized expression")
# emit-tail-funcall
#    si   =-32
#    env  = ((f6617 . -28) (f6616 . -24) (f6615 . -20) (f6617 . -16) (f6616 . -12) (f6615 . -8) ((primitive-ref write) . 44) ((primitive-ref error) . 40) (else . 36) (f6563 . 32) (f6565 . 28) (f6564 . 24) (f6566 . 20) (f6567 . 16) ((primitive-ref write-char) . 12) (f6568 . 8) (f6569 . 4) (f6562 . -28) (f6563 . -24) (f6564 . -20) (f6565 . -16) (f6566 . -12) (f6567 . -8) (f6568 . -4) (f6569 . 0))
#    expr = (funcall (primitive-ref error) ((primitive-ref string->symbol) "write") "unrecognized expression")
# emit-expr (primitive-ref error)
    .extern mrc_error
    movl mrc_error,%eax
   movl %eax,  -32(%esp)  # stash funcall-oper in next closure slot
# emit-expr ((primitive-ref string->symbol) "write")
# funcall
#    si   =-36
#    env  = ((f6617 . -28) (f6616 . -24) (f6615 . -20) (f6617 . -16) (f6616 . -12) (f6615 . -8) ((primitive-ref write) . 44) ((primitive-ref error) . 40) (else . 36) (f6563 . 32) (f6565 . 28) (f6564 . 24) (f6566 . 20) (f6567 . 16) ((primitive-ref write-char) . 12) (f6568 . 8) (f6569 . 4) (f6562 . -28) (f6563 . -24) (f6564 . -20) (f6565 . -16) (f6566 . -12) (f6567 . -8) (f6568 . -4) (f6569 . 0))
#    expr = (funcall (primitive-ref string->symbol) "write")
# emit-expr (primitive-ref string->symbol)
    .extern mrc_string$m$gsymbol
    movl mrc_string$m$gsymbol,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_40173"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_40173":
   movl %eax,  -44(%esp)  # stash funcall-oper in closure slot
# emit-expr "write"
# string literal
    jmp _L_40175
    .align 8,0x90
_L_40174 :
    .int 20
    .ascii "write"
_L_40175:
    movl $_L_40174, %eax
    orl $6, %eax
    mov %eax, -48(%esp)  # arg write
    movl -44(%esp), %edi   # load new closure to %edi
    add $-36, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $36, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    mov %eax, -36(%esp)    # arg ((primitive-ref string->symbol) write)
# emit-expr "unrecognized expression"
# string literal
    jmp _L_40177
    .align 8,0x90
_L_40176 :
    .int 92
    .ascii "unrecognized expression"
_L_40177:
    movl $_L_40176, %eax
    orl $6, %eax
    mov %eax, -40(%esp)    # arg unrecognized expression
    movl -32(%esp), %edi   # load new closure to %edi
# emit-shift-args:  size=3   si=-32  delta=28
    mov -32(%esp), %ebx  # shift frame cell
    mov %ebx, -4(%esp)  # down to base
# emit-shift-args:  size=2   si=-36  delta=28
    mov -36(%esp), %ebx  # shift frame cell
    mov %ebx, -8(%esp)  # down to base
# emit-shift-args:  size=1   si=-40  delta=28
    mov -40(%esp), %ebx  # shift frame cell
    mov %ebx, -12(%esp)  # down to base
# emit-shift-args:  size=0   si=-44  delta=28
    movl $8,%eax   # save arg count
    jmp *-2(%edi)  # tail-funcall
_L_40168:
_L_40156:
_L_40150:
_L_40142:
_L_40136:
_L_40130:
    .align 4,0x90
_L_40127:
# emit-expr (begin)
# emit-begin
#   expr=(begin)
#   env=((f6562 . -28) (f6563 . -24) (f6564 . -20) (f6565 . -16) (f6566 . -12) (f6567 . -8) (f6568 . -4) (f6569 . 0))
     movl %eax, mrc_base$mwrite
# == explicit-begins  ==>
# (lambda (expr . args) (let ((p (if (null? args) (current-output-port) (car args)))) (base-write expr p #f)))
# == eliminate-let*  ==>
# (lambda (expr . args) (let ((p (if (null? args) (current-output-port) (car args)))) (base-write expr p #f)))
# == uniquify-variables  ==>
# (lambda (f6618 . f6619) (let ((f6621 (if (null? f6619) (current-output-port) (car f6619)))) (base-write f6618 f6621 #f)))
# == vectorize-letrec  ==>
# (lambda (f6618 . f6619) (let ((f6621 (if (null? f6619) (current-output-port) (car f6619)))) (base-write f6618 f6621 #f)))
# == eliminate-set!  ==>
# (lambda (f6618 . f6619) (let ((f6618 f6618)) (let ((f6621 (if (null? f6619) (current-output-port) (car f6619)))) (base-write f6618 f6621 #f))))
# == close-free-variables  ==>
# (closure (f6618 . f6619) (base-write) (let ((f6618 f6618)) (let ((f6621 (if (null? f6619) (current-output-port) (car f6619)))) (base-write f6618 f6621 #f))))
# == eliminate-quote  ==>
# (closure (f6618 . f6619) (base-write) (let ((f6618 f6618)) (let ((f6621 (if (null? f6619) (current-output-port) (car f6619)))) (base-write f6618 f6621 #f))))
# == eliminate-when/unless  ==>
# (closure (f6618 . f6619) (base-write) (let ((f6618 f6618)) (let ((f6621 (if (null? f6619) (current-output-port) (car f6619)))) (base-write f6618 f6621 #f))))
# == eliminate-cond  ==>
# (closure (f6618 . f6619) (base-write) (let ((f6618 f6618)) (let ((f6621 (if (null? f6619) (current-output-port) (car f6619)))) (base-write f6618 f6621 #f))))
# == external-symbols  ==>
# (closure (f6618 . f6619) ((primitive-ref base-write)) (let ((f6618 f6618)) (let ((f6621 (if (null? f6619) ((primitive-ref current-output-port)) (car f6619)))) ((primitive-ref base-write) f6618 f6621 #f))))
# emit-expr (closure (f6618 . f6619) ((primitive-ref base-write)) (let ((f6618 f6618)) (let ((f6621 (if (null? f6619) ((primitive-ref current-output-port)) (car f6619)))) ((primitive-ref base-write) f6618 f6621 #f))))
# emit-closure
# si = 0
# env = ()
# expr = (closure (f6618 . f6619) ((primitive-ref base-write)) (let ((f6618 f6618)) (let ((f6621 (if (null? f6619) ((primitive-ref current-output-port)) (car f6619)))) ((primitive-ref base-write) f6618 f6621 #f))))
    movl $_L_40178, 0(%ebp)  # closure label
# WARNING: free var (primitive-ref base-write) not defined in the environmnet
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $8, %ebp     # bump ebp
    jmp _L_40179            # jump around closure body
_L_40178:
# check argument count
    cmp $4,%eax
    jge _L_40180
# invoke error handler eh_argcount_min
    .extern mrc_eh$uargcount$umin
    movl mrc_eh$uargcount$umin, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_40180:
# emit-build-varargs-list
    movl $63, %esi       # args <- () 
    lea -4(%esp),%edi    # edi <- esp-4
    subl %eax, %edi      # edi <- esp-4-eax    addr of arg[K+N] on stack
_L_40182:
    lea -8(%esp),%ebx    # addr of arg[K] on stack
    cmp %edi, %ebx       # while edi <> esp+(si+4)
    je _L_40181
    movl (%edi),%ebx     # arg i -> car
    movl %ebx, 0(%ebp)
    movl %esi, 4(%ebp)  # esi -> cdr
    movl %ebp, %esi
    addl $1, %esi       # tag as pair
    addl $8,%ebp         # bump heap ptr
    addl $4,%edi         # move to next previous arg from the end
    jmp _L_40182
_L_40181:
    movl %esi, -12(%esp)  # set args
# emit-tail-expr
# si=-16
# env=((f6619 . -12) (f6618 . -8) ((primitive-ref base-write) . 4))
# expr=(let ((f6618 f6618)) (let ((f6621 (if (null? f6619) ((primitive-ref current-output-port)) (car f6619)))) ((primitive-ref base-write) f6618 f6621 #f)))
# emit-tail-let
#  si   = -16
#  env  = ((f6619 . -12) (f6618 . -8) ((primitive-ref base-write) . 4))
#  bindings = ((f6618 f6618))
#  body = (let ((f6621 (if (null? f6619) ((primitive-ref current-output-port)) (car f6619)))) ((primitive-ref base-write) f6618 f6621 #f))
# emit-expr f6618
# emit-variable-ref
# env=((f6619 . -12) (f6618 . -8) ((primitive-ref base-write) . 4))
# var=f6618
    movl -8(%esp), %eax  # stack load f6618
# end emit-variable-ref
    movl %eax, -16(%esp)  # stack save
# emit-tail-expr
# si=-20
# env=((f6618 . -16) (f6619 . -12) (f6618 . -8) ((primitive-ref base-write) . 4))
# expr=(let ((f6621 (if (null? f6619) ((primitive-ref current-output-port)) (car f6619)))) ((primitive-ref base-write) f6618 f6621 #f))
# emit-tail-let
#  si   = -20
#  env  = ((f6618 . -16) (f6619 . -12) (f6618 . -8) ((primitive-ref base-write) . 4))
#  bindings = ((f6621 (if (null? f6619) ((primitive-ref current-output-port)) (car f6619))))
#  body = ((primitive-ref base-write) f6618 f6621 #f)
# emit-expr (if (null? f6619) ((primitive-ref current-output-port)) (car f6619))
# emit-expr (null? f6619)
# emit-expr f6619
# emit-variable-ref
# env=((f6618 . -16) (f6619 . -12) (f6618 . -8) ((primitive-ref base-write) . 4))
# var=f6619
    movl -12(%esp), %eax  # stack load f6619
# end emit-variable-ref
    cmp $63, %eax
    mov $0, %eax
    sete %al
    movzbl %al, %eax
    sal $6, %al
    or $47, %al
    cmp $47, %al
    je _L_40183
# emit-expr ((primitive-ref current-output-port))
# funcall
#    si   =-20
#    env  = ((f6618 . -16) (f6619 . -12) (f6618 . -8) ((primitive-ref base-write) . 4))
#    expr = (funcall (primitive-ref current-output-port))
# emit-expr (primitive-ref current-output-port)
    .extern mrc_current$moutput$mport
    movl mrc_current$moutput$mport,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_40185"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_40185":
   movl %eax,  -28(%esp)  # stash funcall-oper in closure slot
    movl -28(%esp), %edi   # load new closure to %edi
    add $-20, %esp   # adjust base
    movl $0,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $20, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    jmp _L_40184
_L_40183:
# emit-expr (car f6619)
# emit-expr f6619
# emit-variable-ref
# env=((f6618 . -16) (f6619 . -12) (f6618 . -8) ((primitive-ref base-write) . 4))
# var=f6619
    movl -12(%esp), %eax  # stack load f6619
# end emit-variable-ref
# check the argument is a pair
    movl %eax,%ebx
    and $7, %bl
    cmp $1, %bl
    je _L_40186
# invoke error handler eh_pair
    .extern mrc_eh$upair
    movl mrc_eh$upair, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $116,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_40186:
    movl -1(%eax), %eax
_L_40184:
    movl %eax, -20(%esp)  # stack save
# emit-tail-expr
# si=-24
# env=((f6621 . -20) (f6618 . -16) (f6619 . -12) (f6618 . -8) ((primitive-ref base-write) . 4))
# expr=((primitive-ref base-write) f6618 f6621 #f)
# emit-tail-funcall
#    si   =-24
#    env  = ((f6621 . -20) (f6618 . -16) (f6619 . -12) (f6618 . -8) ((primitive-ref base-write) . 4))
#    expr = (funcall (primitive-ref base-write) f6618 f6621 #f)
# emit-expr (primitive-ref base-write)
    .extern mrc_base$mwrite
    movl mrc_base$mwrite,%eax
   movl %eax,  -24(%esp)  # stash funcall-oper in next closure slot
# emit-expr f6618
# emit-variable-ref
# env=((f6621 . -20) (f6618 . -16) (f6619 . -12) (f6618 . -8) ((primitive-ref base-write) . 4))
# var=f6618
    movl -16(%esp), %eax  # stack load f6618
# end emit-variable-ref
    mov %eax, -28(%esp)    # arg f6618
# emit-expr f6621
# emit-variable-ref
# env=((f6621 . -20) (f6618 . -16) (f6619 . -12) (f6618 . -8) ((primitive-ref base-write) . 4))
# var=f6621
    movl -20(%esp), %eax  # stack load f6621
# end emit-variable-ref
    mov %eax, -32(%esp)    # arg f6621
# emit-expr #f
    movl $47, %eax     # immed #f
    mov %eax, -36(%esp)    # arg #f
    movl -24(%esp), %edi   # load new closure to %edi
# emit-shift-args:  size=4   si=-24  delta=20
    mov -24(%esp), %ebx  # shift frame cell
    mov %ebx, -4(%esp)  # down to base
# emit-shift-args:  size=3   si=-28  delta=20
    mov -28(%esp), %ebx  # shift frame cell
    mov %ebx, -8(%esp)  # down to base
# emit-shift-args:  size=2   si=-32  delta=20
    mov -32(%esp), %ebx  # shift frame cell
    mov %ebx, -12(%esp)  # down to base
# emit-shift-args:  size=1   si=-36  delta=20
    mov -36(%esp), %ebx  # shift frame cell
    mov %ebx, -16(%esp)  # down to base
# emit-shift-args:  size=0   si=-40  delta=20
    movl $12,%eax   # save arg count
    jmp *-2(%edi)  # tail-funcall
    .align 4,0x90
_L_40179:
     movl %eax, mrc_write
# == explicit-begins  ==>
# (lambda (expr . args) (let ((p (if (null? args) (current-output-port) (car args)))) (base-write expr p #t)))
# == eliminate-let*  ==>
# (lambda (expr . args) (let ((p (if (null? args) (current-output-port) (car args)))) (base-write expr p #t)))
# == uniquify-variables  ==>
# (lambda (f6622 . f6623) (let ((f6625 (if (null? f6623) (current-output-port) (car f6623)))) (base-write f6622 f6625 #t)))
# == vectorize-letrec  ==>
# (lambda (f6622 . f6623) (let ((f6625 (if (null? f6623) (current-output-port) (car f6623)))) (base-write f6622 f6625 #t)))
# == eliminate-set!  ==>
# (lambda (f6622 . f6623) (let ((f6622 f6622)) (let ((f6625 (if (null? f6623) (current-output-port) (car f6623)))) (base-write f6622 f6625 #t))))
# == close-free-variables  ==>
# (closure (f6622 . f6623) (base-write) (let ((f6622 f6622)) (let ((f6625 (if (null? f6623) (current-output-port) (car f6623)))) (base-write f6622 f6625 #t))))
# == eliminate-quote  ==>
# (closure (f6622 . f6623) (base-write) (let ((f6622 f6622)) (let ((f6625 (if (null? f6623) (current-output-port) (car f6623)))) (base-write f6622 f6625 #t))))
# == eliminate-when/unless  ==>
# (closure (f6622 . f6623) (base-write) (let ((f6622 f6622)) (let ((f6625 (if (null? f6623) (current-output-port) (car f6623)))) (base-write f6622 f6625 #t))))
# == eliminate-cond  ==>
# (closure (f6622 . f6623) (base-write) (let ((f6622 f6622)) (let ((f6625 (if (null? f6623) (current-output-port) (car f6623)))) (base-write f6622 f6625 #t))))
# == external-symbols  ==>
# (closure (f6622 . f6623) ((primitive-ref base-write)) (let ((f6622 f6622)) (let ((f6625 (if (null? f6623) ((primitive-ref current-output-port)) (car f6623)))) ((primitive-ref base-write) f6622 f6625 #t))))
# emit-expr (closure (f6622 . f6623) ((primitive-ref base-write)) (let ((f6622 f6622)) (let ((f6625 (if (null? f6623) ((primitive-ref current-output-port)) (car f6623)))) ((primitive-ref base-write) f6622 f6625 #t))))
# emit-closure
# si = 0
# env = ()
# expr = (closure (f6622 . f6623) ((primitive-ref base-write)) (let ((f6622 f6622)) (let ((f6625 (if (null? f6623) ((primitive-ref current-output-port)) (car f6623)))) ((primitive-ref base-write) f6622 f6625 #t))))
    movl $_L_40187, 0(%ebp)  # closure label
# WARNING: free var (primitive-ref base-write) not defined in the environmnet
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $8, %ebp     # bump ebp
    jmp _L_40188            # jump around closure body
_L_40187:
# check argument count
    cmp $4,%eax
    jge _L_40189
# invoke error handler eh_argcount_min
    .extern mrc_eh$uargcount$umin
    movl mrc_eh$uargcount$umin, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_40189:
# emit-build-varargs-list
    movl $63, %esi       # args <- () 
    lea -4(%esp),%edi    # edi <- esp-4
    subl %eax, %edi      # edi <- esp-4-eax    addr of arg[K+N] on stack
_L_40191:
    lea -8(%esp),%ebx    # addr of arg[K] on stack
    cmp %edi, %ebx       # while edi <> esp+(si+4)
    je _L_40190
    movl (%edi),%ebx     # arg i -> car
    movl %ebx, 0(%ebp)
    movl %esi, 4(%ebp)  # esi -> cdr
    movl %ebp, %esi
    addl $1, %esi       # tag as pair
    addl $8,%ebp         # bump heap ptr
    addl $4,%edi         # move to next previous arg from the end
    jmp _L_40191
_L_40190:
    movl %esi, -12(%esp)  # set args
# emit-tail-expr
# si=-16
# env=((f6623 . -12) (f6622 . -8) ((primitive-ref base-write) . 4))
# expr=(let ((f6622 f6622)) (let ((f6625 (if (null? f6623) ((primitive-ref current-output-port)) (car f6623)))) ((primitive-ref base-write) f6622 f6625 #t)))
# emit-tail-let
#  si   = -16
#  env  = ((f6623 . -12) (f6622 . -8) ((primitive-ref base-write) . 4))
#  bindings = ((f6622 f6622))
#  body = (let ((f6625 (if (null? f6623) ((primitive-ref current-output-port)) (car f6623)))) ((primitive-ref base-write) f6622 f6625 #t))
# emit-expr f6622
# emit-variable-ref
# env=((f6623 . -12) (f6622 . -8) ((primitive-ref base-write) . 4))
# var=f6622
    movl -8(%esp), %eax  # stack load f6622
# end emit-variable-ref
    movl %eax, -16(%esp)  # stack save
# emit-tail-expr
# si=-20
# env=((f6622 . -16) (f6623 . -12) (f6622 . -8) ((primitive-ref base-write) . 4))
# expr=(let ((f6625 (if (null? f6623) ((primitive-ref current-output-port)) (car f6623)))) ((primitive-ref base-write) f6622 f6625 #t))
# emit-tail-let
#  si   = -20
#  env  = ((f6622 . -16) (f6623 . -12) (f6622 . -8) ((primitive-ref base-write) . 4))
#  bindings = ((f6625 (if (null? f6623) ((primitive-ref current-output-port)) (car f6623))))
#  body = ((primitive-ref base-write) f6622 f6625 #t)
# emit-expr (if (null? f6623) ((primitive-ref current-output-port)) (car f6623))
# emit-expr (null? f6623)
# emit-expr f6623
# emit-variable-ref
# env=((f6622 . -16) (f6623 . -12) (f6622 . -8) ((primitive-ref base-write) . 4))
# var=f6623
    movl -12(%esp), %eax  # stack load f6623
# end emit-variable-ref
    cmp $63, %eax
    mov $0, %eax
    sete %al
    movzbl %al, %eax
    sal $6, %al
    or $47, %al
    cmp $47, %al
    je _L_40192
# emit-expr ((primitive-ref current-output-port))
# funcall
#    si   =-20
#    env  = ((f6622 . -16) (f6623 . -12) (f6622 . -8) ((primitive-ref base-write) . 4))
#    expr = (funcall (primitive-ref current-output-port))
# emit-expr (primitive-ref current-output-port)
    .extern mrc_current$moutput$mport
    movl mrc_current$moutput$mport,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_40194"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_40194":
   movl %eax,  -28(%esp)  # stash funcall-oper in closure slot
    movl -28(%esp), %edi   # load new closure to %edi
    add $-20, %esp   # adjust base
    movl $0,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $20, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    jmp _L_40193
_L_40192:
# emit-expr (car f6623)
# emit-expr f6623
# emit-variable-ref
# env=((f6622 . -16) (f6623 . -12) (f6622 . -8) ((primitive-ref base-write) . 4))
# var=f6623
    movl -12(%esp), %eax  # stack load f6623
# end emit-variable-ref
# check the argument is a pair
    movl %eax,%ebx
    and $7, %bl
    cmp $1, %bl
    je _L_40195
# invoke error handler eh_pair
    .extern mrc_eh$upair
    movl mrc_eh$upair, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $116,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_40195:
    movl -1(%eax), %eax
_L_40193:
    movl %eax, -20(%esp)  # stack save
# emit-tail-expr
# si=-24
# env=((f6625 . -20) (f6622 . -16) (f6623 . -12) (f6622 . -8) ((primitive-ref base-write) . 4))
# expr=((primitive-ref base-write) f6622 f6625 #t)
# emit-tail-funcall
#    si   =-24
#    env  = ((f6625 . -20) (f6622 . -16) (f6623 . -12) (f6622 . -8) ((primitive-ref base-write) . 4))
#    expr = (funcall (primitive-ref base-write) f6622 f6625 #t)
# emit-expr (primitive-ref base-write)
    .extern mrc_base$mwrite
    movl mrc_base$mwrite,%eax
   movl %eax,  -24(%esp)  # stash funcall-oper in next closure slot
# emit-expr f6622
# emit-variable-ref
# env=((f6625 . -20) (f6622 . -16) (f6623 . -12) (f6622 . -8) ((primitive-ref base-write) . 4))
# var=f6622
    movl -16(%esp), %eax  # stack load f6622
# end emit-variable-ref
    mov %eax, -28(%esp)    # arg f6622
# emit-expr f6625
# emit-variable-ref
# env=((f6625 . -20) (f6622 . -16) (f6623 . -12) (f6622 . -8) ((primitive-ref base-write) . 4))
# var=f6625
    movl -20(%esp), %eax  # stack load f6625
# end emit-variable-ref
    mov %eax, -32(%esp)    # arg f6625
# emit-expr #t
    movl $111, %eax     # immed #t
    mov %eax, -36(%esp)    # arg #t
    movl -24(%esp), %edi   # load new closure to %edi
# emit-shift-args:  size=4   si=-24  delta=20
    mov -24(%esp), %ebx  # shift frame cell
    mov %ebx, -4(%esp)  # down to base
# emit-shift-args:  size=3   si=-28  delta=20
    mov -28(%esp), %ebx  # shift frame cell
    mov %ebx, -8(%esp)  # down to base
# emit-shift-args:  size=2   si=-32  delta=20
    mov -32(%esp), %ebx  # shift frame cell
    mov %ebx, -12(%esp)  # down to base
# emit-shift-args:  size=1   si=-36  delta=20
    mov -36(%esp), %ebx  # shift frame cell
    mov %ebx, -16(%esp)  # down to base
# emit-shift-args:  size=0   si=-40  delta=20
    movl $12,%eax   # save arg count
    jmp *-2(%edi)  # tail-funcall
    .align 4,0x90
_L_40188:
     movl %eax, mrc_display
# == explicit-begins  ==>
# (lambda (i) (fixnum->char i))
# == eliminate-let*  ==>
# (lambda (i) (fixnum->char i))
# == uniquify-variables  ==>
# (lambda (f6626) (fixnum->char f6626))
# == vectorize-letrec  ==>
# (lambda (f6626) (fixnum->char f6626))
# == eliminate-set!  ==>
# (lambda (f6626) (let ((f6626 f6626)) (fixnum->char f6626)))
# == close-free-variables  ==>
# (closure (f6626) () (let ((f6626 f6626)) (fixnum->char f6626)))
# == eliminate-quote  ==>
# (closure (f6626) () (let ((f6626 f6626)) (fixnum->char f6626)))
# == eliminate-when/unless  ==>
# (closure (f6626) () (let ((f6626 f6626)) (fixnum->char f6626)))
# == eliminate-cond  ==>
# (closure (f6626) () (let ((f6626 f6626)) (fixnum->char f6626)))
# == external-symbols  ==>
# (closure (f6626) () (let ((f6626 f6626)) (fixnum->char f6626)))
# emit-expr (closure (f6626) () (let ((f6626 f6626)) (fixnum->char f6626)))
# emit-closure
# si = 0
# env = ()
# expr = (closure (f6626) () (let ((f6626 f6626)) (fixnum->char f6626)))
    movl $_L_40196, 0(%ebp)  # closure label
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $8, %ebp     # bump ebp
    jmp _L_40197            # jump around closure body
_L_40196:
# check argument count
    cmp $4,%eax
    je _L_40198
# invoke error handler eh_argcount
    .extern mrc_eh$uargcount
    movl mrc_eh$uargcount, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_40198:
# emit-tail-expr
# si=-12
# env=((f6626 . -8))
# expr=(let ((f6626 f6626)) (fixnum->char f6626))
# emit-tail-let
#  si   = -12
#  env  = ((f6626 . -8))
#  bindings = ((f6626 f6626))
#  body = (fixnum->char f6626)
# emit-expr f6626
# emit-variable-ref
# env=((f6626 . -8))
# var=f6626
    movl -8(%esp), %eax  # stack load f6626
# end emit-variable-ref
    movl %eax, -12(%esp)  # stack save
# emit-tail-expr
# si=-16
# env=((f6626 . -12) (f6626 . -8))
# expr=(fixnum->char f6626)
# tail primcall
# emit-expr f6626
# emit-variable-ref
# env=((f6626 . -12) (f6626 . -8))
# var=f6626
    movl -12(%esp), %eax  # stack load f6626
# end emit-variable-ref
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_40199"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $0,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_40199:
    shll $6, %eax
    orl $15, %eax
#return from tail (fixnum->char f6626)
    ret
    .align 4,0x90
_L_40197:
     movl %eax, mrc_integer$m$gchar
# == explicit-begins  ==>
# (let* ((p (make-vector 8)) (sz 1024)) (begin (vector-set! p 0 (quote input-port)) (vector-set! p 1 "/dev/stdin") (vector-set! p 2 0) (vector-set! p 3 (make-string sz)) (vector-set! p 4 0) (vector-set! p 5 sz) (vector-set! p 6 #f) (vector-set! p 7 -1) p))
# == eliminate-let*  ==>
# (let ((p (make-vector 8))) (let ((sz 1024)) (begin (vector-set! p 0 (quote input-port)) (vector-set! p 1 "/dev/stdin") (vector-set! p 2 0) (vector-set! p 3 (make-string sz)) (vector-set! p 4 0) (vector-set! p 5 sz) (vector-set! p 6 #f) (vector-set! p 7 -1) p)))
# == uniquify-variables  ==>
# (let ((f6627 (make-vector 8))) (let ((f6629 1024)) (begin (vector-set! f6627 0 (quote input-port)) (vector-set! f6627 1 "/dev/stdin") (vector-set! f6627 2 0) (vector-set! f6627 3 (make-string f6629)) (vector-set! f6627 4 0) (vector-set! f6627 5 f6629) (vector-set! f6627 6 #f) (vector-set! f6627 7 -1) f6627)))
# == vectorize-letrec  ==>
# (let ((f6627 (make-vector 8))) (let ((f6629 1024)) (begin (vector-set! f6627 0 (quote input-port)) (vector-set! f6627 1 "/dev/stdin") (vector-set! f6627 2 0) (vector-set! f6627 3 (make-string f6629)) (vector-set! f6627 4 0) (vector-set! f6627 5 f6629) (vector-set! f6627 6 #f) (vector-set! f6627 7 -1) f6627)))
# == eliminate-set!  ==>
# (let ((f6627 (make-vector 8))) (let ((f6629 1024)) (begin (vector-set! f6627 0 (quote input-port)) (vector-set! f6627 1 "/dev/stdin") (vector-set! f6627 2 0) (vector-set! f6627 3 (make-string f6629)) (vector-set! f6627 4 0) (vector-set! f6627 5 f6629) (vector-set! f6627 6 #f) (vector-set! f6627 7 -1) f6627)))
# == close-free-variables  ==>
# (let ((f6627 (make-vector 8))) (let ((f6629 1024)) (begin (vector-set! f6627 0 (quote input-port)) (vector-set! f6627 1 "/dev/stdin") (vector-set! f6627 2 0) (vector-set! f6627 3 (make-string f6629)) (vector-set! f6627 4 0) (vector-set! f6627 5 f6629) (vector-set! f6627 6 #f) (vector-set! f6627 7 -1) f6627)))
# == eliminate-quote  ==>
# (let ((f6627 (make-vector 8))) (let ((f6629 1024)) (begin (vector-set! f6627 0 (string->symbol "input-port")) (vector-set! f6627 1 "/dev/stdin") (vector-set! f6627 2 0) (vector-set! f6627 3 (make-string f6629)) (vector-set! f6627 4 0) (vector-set! f6627 5 f6629) (vector-set! f6627 6 #f) (vector-set! f6627 7 -1) f6627)))
# == eliminate-when/unless  ==>
# (let ((f6627 (make-vector 8))) (let ((f6629 1024)) (begin (vector-set! f6627 0 (string->symbol "input-port")) (vector-set! f6627 1 "/dev/stdin") (vector-set! f6627 2 0) (vector-set! f6627 3 (make-string f6629)) (vector-set! f6627 4 0) (vector-set! f6627 5 f6629) (vector-set! f6627 6 #f) (vector-set! f6627 7 -1) f6627)))
# == eliminate-cond  ==>
# (let ((f6627 (make-vector 8))) (let ((f6629 1024)) (begin (vector-set! f6627 0 (string->symbol "input-port")) (vector-set! f6627 1 "/dev/stdin") (vector-set! f6627 2 0) (vector-set! f6627 3 (make-string f6629)) (vector-set! f6627 4 0) (vector-set! f6627 5 f6629) (vector-set! f6627 6 #f) (vector-set! f6627 7 -1) f6627)))
# == external-symbols  ==>
# (let ((f6627 (make-vector 8))) (let ((f6629 1024)) (begin (vector-set! f6627 0 ((primitive-ref string->symbol) "input-port")) (vector-set! f6627 1 "/dev/stdin") (vector-set! f6627 2 0) (vector-set! f6627 3 (make-string f6629)) (vector-set! f6627 4 0) (vector-set! f6627 5 f6629) (vector-set! f6627 6 #f) (vector-set! f6627 7 -1) f6627)))
# emit-expr (let ((f6627 (make-vector 8))) (let ((f6629 1024)) (begin (vector-set! f6627 0 ((primitive-ref string->symbol) "input-port")) (vector-set! f6627 1 "/dev/stdin") (vector-set! f6627 2 0) (vector-set! f6627 3 (make-string f6629)) (vector-set! f6627 4 0) (vector-set! f6627 5 f6629) (vector-set! f6627 6 #f) (vector-set! f6627 7 -1) f6627)))
# emit-let
#  si   = 0
#  env  = ()
#  bindings = ((f6627 (make-vector 8)))
#  body = (let ((f6629 1024)) (begin (vector-set! f6627 0 ((primitive-ref string->symbol) "input-port")) (vector-set! f6627 1 "/dev/stdin") (vector-set! f6627 2 0) (vector-set! f6627 3 (make-string f6629)) (vector-set! f6627 4 0) (vector-set! f6627 5 f6629) (vector-set! f6627 6 #f) (vector-set! f6627 7 -1) f6627))
# emit-expr (make-vector 8)
# make-vector 8
# emit-expr 8
    movl $32, %eax     # immed 8
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_40200"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_40200:
# check the argument is a fixnum >= 0
    cmp $0,%eax
    jge _L_40201
# invoke error handler eh_length
    .extern mrc_eh$ulength
    movl mrc_eh$ulength, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_40201:
    movl %eax, %esi
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    orl  $5, %eax
    addl $4, %esi
    addl $4, %esi
    andl $-8, %esi
    addl %esi, %ebp
    movl %eax, 0(%esp)  # stack save
# emit-expr (let ((f6629 1024)) (begin (vector-set! f6627 0 ((primitive-ref string->symbol) "input-port")) (vector-set! f6627 1 "/dev/stdin") (vector-set! f6627 2 0) (vector-set! f6627 3 (make-string f6629)) (vector-set! f6627 4 0) (vector-set! f6627 5 f6629) (vector-set! f6627 6 #f) (vector-set! f6627 7 -1) f6627))
# emit-let
#  si   = -4
#  env  = ((f6627 . 0))
#  bindings = ((f6629 1024))
#  body = (begin (vector-set! f6627 0 ((primitive-ref string->symbol) "input-port")) (vector-set! f6627 1 "/dev/stdin") (vector-set! f6627 2 0) (vector-set! f6627 3 (make-string f6629)) (vector-set! f6627 4 0) (vector-set! f6627 5 f6629) (vector-set! f6627 6 #f) (vector-set! f6627 7 -1) f6627)
# emit-expr 1024
    movl $4096, %eax     # immed 1024
    movl %eax, -4(%esp)  # stack save
# emit-expr (begin (vector-set! f6627 0 ((primitive-ref string->symbol) "input-port")) (vector-set! f6627 1 "/dev/stdin") (vector-set! f6627 2 0) (vector-set! f6627 3 (make-string f6629)) (vector-set! f6627 4 0) (vector-set! f6627 5 f6629) (vector-set! f6627 6 #f) (vector-set! f6627 7 -1) f6627)
# emit-begin
#   expr=(begin (vector-set! f6627 0 ((primitive-ref string->symbol) "input-port")) (vector-set! f6627 1 "/dev/stdin") (vector-set! f6627 2 0) (vector-set! f6627 3 (make-string f6629)) (vector-set! f6627 4 0) (vector-set! f6627 5 f6629) (vector-set! f6627 6 #f) (vector-set! f6627 7 -1) f6627)
#   env=((f6629 . -4) (f6627 . 0))
# emit-expr (vector-set! f6627 0 ((primitive-ref string->symbol) "input-port"))
# emit-expr f6627
# emit-variable-ref
# env=((f6629 . -4) (f6627 . 0))
# var=f6627
    movl 0(%esp), %eax  # stack load f6627
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_40202
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_40202:
    movl %eax, -8(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_40203"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_40203:
# check bounds on vector index
    movl -8(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_40205
    cmp  $0,%eax
    jge _L_40204
_L_40205:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_40204:
    movl %eax, -12(%esp)
# emit-expr ((primitive-ref string->symbol) "input-port")
# funcall
#    si   =-16
#    env  = ((f6629 . -4) (f6627 . 0))
#    expr = (funcall (primitive-ref string->symbol) "input-port")
# emit-expr (primitive-ref string->symbol)
    .extern mrc_string$m$gsymbol
    movl mrc_string$m$gsymbol,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_40206"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_40206":
   movl %eax,  -24(%esp)  # stash funcall-oper in closure slot
# emit-expr "input-port"
# string literal
    jmp _L_40208
    .align 8,0x90
_L_40207 :
    .int 40
    .ascii "input-port"
_L_40208:
    movl $_L_40207, %eax
    orl $6, %eax
    mov %eax, -28(%esp)  # arg input-port
    movl -24(%esp), %edi   # load new closure to %edi
    add $-16, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $16, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    movl -8(%esp), %ebx
    movl -12(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin (vector-set! f6627 1 "/dev/stdin") (vector-set! f6627 2 0) (vector-set! f6627 3 (make-string f6629)) (vector-set! f6627 4 0) (vector-set! f6627 5 f6629) (vector-set! f6627 6 #f) (vector-set! f6627 7 -1) f6627)
# emit-begin
#   expr=(begin (vector-set! f6627 1 "/dev/stdin") (vector-set! f6627 2 0) (vector-set! f6627 3 (make-string f6629)) (vector-set! f6627 4 0) (vector-set! f6627 5 f6629) (vector-set! f6627 6 #f) (vector-set! f6627 7 -1) f6627)
#   env=((f6629 . -4) (f6627 . 0))
# emit-expr (vector-set! f6627 1 "/dev/stdin")
# emit-expr f6627
# emit-variable-ref
# env=((f6629 . -4) (f6627 . 0))
# var=f6627
    movl 0(%esp), %eax  # stack load f6627
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_40209
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_40209:
    movl %eax, -8(%esp)
# emit-expr 1
    movl $4, %eax     # immed 1
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_40210"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_40210:
# check bounds on vector index
    movl -8(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_40212
    cmp  $0,%eax
    jge _L_40211
_L_40212:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_40211:
    movl %eax, -12(%esp)
# emit-expr "/dev/stdin"
# string literal
    jmp _L_40214
    .align 8,0x90
_L_40213 :
    .int 40
    .ascii "/dev/stdin"
_L_40214:
    movl $_L_40213, %eax
    orl $6, %eax
    movl -8(%esp), %ebx
    movl -12(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin (vector-set! f6627 2 0) (vector-set! f6627 3 (make-string f6629)) (vector-set! f6627 4 0) (vector-set! f6627 5 f6629) (vector-set! f6627 6 #f) (vector-set! f6627 7 -1) f6627)
# emit-begin
#   expr=(begin (vector-set! f6627 2 0) (vector-set! f6627 3 (make-string f6629)) (vector-set! f6627 4 0) (vector-set! f6627 5 f6629) (vector-set! f6627 6 #f) (vector-set! f6627 7 -1) f6627)
#   env=((f6629 . -4) (f6627 . 0))
# emit-expr (vector-set! f6627 2 0)
# emit-expr f6627
# emit-variable-ref
# env=((f6629 . -4) (f6627 . 0))
# var=f6627
    movl 0(%esp), %eax  # stack load f6627
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_40215
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_40215:
    movl %eax, -8(%esp)
# emit-expr 2
    movl $8, %eax     # immed 2
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_40216"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_40216:
# check bounds on vector index
    movl -8(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_40218
    cmp  $0,%eax
    jge _L_40217
_L_40218:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_40217:
    movl %eax, -12(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
    movl -8(%esp), %ebx
    movl -12(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin (vector-set! f6627 3 (make-string f6629)) (vector-set! f6627 4 0) (vector-set! f6627 5 f6629) (vector-set! f6627 6 #f) (vector-set! f6627 7 -1) f6627)
# emit-begin
#   expr=(begin (vector-set! f6627 3 (make-string f6629)) (vector-set! f6627 4 0) (vector-set! f6627 5 f6629) (vector-set! f6627 6 #f) (vector-set! f6627 7 -1) f6627)
#   env=((f6629 . -4) (f6627 . 0))
# emit-expr (vector-set! f6627 3 (make-string f6629))
# emit-expr f6627
# emit-variable-ref
# env=((f6629 . -4) (f6627 . 0))
# var=f6627
    movl 0(%esp), %eax  # stack load f6627
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_40219
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_40219:
    movl %eax, -8(%esp)
# emit-expr 3
    movl $12, %eax     # immed 3
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_40220"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_40220:
# check bounds on vector index
    movl -8(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_40222
    cmp  $0,%eax
    jge _L_40221
_L_40222:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_40221:
    movl %eax, -12(%esp)
# emit-expr (make-string f6629)
# make-string len=f6629
# emit-expr f6629
# emit-variable-ref
# env=((f6629 . -4) (f6627 . 0))
# var=f6629
    movl -4(%esp), %eax  # stack load f6629
# end emit-variable-ref
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_40223"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $152,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_40223:
# check the argument is a fixnum >= 0
    cmp $0,%eax
    jge _L_40224
# invoke error handler eh_length
    .extern mrc_eh$ulength
    movl mrc_eh$ulength, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $152,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_40224:
    movl %eax, %esi
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    orl $6, %eax
    sar $2, %esi
    add $4, %esi
    add $7, %esi
    andl $-8, %esi
    add  %esi, %ebp
# make-string end
    movl -8(%esp), %ebx
    movl -12(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin (vector-set! f6627 4 0) (vector-set! f6627 5 f6629) (vector-set! f6627 6 #f) (vector-set! f6627 7 -1) f6627)
# emit-begin
#   expr=(begin (vector-set! f6627 4 0) (vector-set! f6627 5 f6629) (vector-set! f6627 6 #f) (vector-set! f6627 7 -1) f6627)
#   env=((f6629 . -4) (f6627 . 0))
# emit-expr (vector-set! f6627 4 0)
# emit-expr f6627
# emit-variable-ref
# env=((f6629 . -4) (f6627 . 0))
# var=f6627
    movl 0(%esp), %eax  # stack load f6627
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_40225
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_40225:
    movl %eax, -8(%esp)
# emit-expr 4
    movl $16, %eax     # immed 4
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_40226"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_40226:
# check bounds on vector index
    movl -8(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_40228
    cmp  $0,%eax
    jge _L_40227
_L_40228:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_40227:
    movl %eax, -12(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
    movl -8(%esp), %ebx
    movl -12(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin (vector-set! f6627 5 f6629) (vector-set! f6627 6 #f) (vector-set! f6627 7 -1) f6627)
# emit-begin
#   expr=(begin (vector-set! f6627 5 f6629) (vector-set! f6627 6 #f) (vector-set! f6627 7 -1) f6627)
#   env=((f6629 . -4) (f6627 . 0))
# emit-expr (vector-set! f6627 5 f6629)
# emit-expr f6627
# emit-variable-ref
# env=((f6629 . -4) (f6627 . 0))
# var=f6627
    movl 0(%esp), %eax  # stack load f6627
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_40229
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_40229:
    movl %eax, -8(%esp)
# emit-expr 5
    movl $20, %eax     # immed 5
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_40230"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_40230:
# check bounds on vector index
    movl -8(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_40232
    cmp  $0,%eax
    jge _L_40231
_L_40232:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_40231:
    movl %eax, -12(%esp)
# emit-expr f6629
# emit-variable-ref
# env=((f6629 . -4) (f6627 . 0))
# var=f6629
    movl -4(%esp), %eax  # stack load f6629
# end emit-variable-ref
    movl -8(%esp), %ebx
    movl -12(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin (vector-set! f6627 6 #f) (vector-set! f6627 7 -1) f6627)
# emit-begin
#   expr=(begin (vector-set! f6627 6 #f) (vector-set! f6627 7 -1) f6627)
#   env=((f6629 . -4) (f6627 . 0))
# emit-expr (vector-set! f6627 6 #f)
# emit-expr f6627
# emit-variable-ref
# env=((f6629 . -4) (f6627 . 0))
# var=f6627
    movl 0(%esp), %eax  # stack load f6627
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_40233
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_40233:
    movl %eax, -8(%esp)
# emit-expr 6
    movl $24, %eax     # immed 6
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_40234"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_40234:
# check bounds on vector index
    movl -8(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_40236
    cmp  $0,%eax
    jge _L_40235
_L_40236:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_40235:
    movl %eax, -12(%esp)
# emit-expr #f
    movl $47, %eax     # immed #f
    movl -8(%esp), %ebx
    movl -12(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin (vector-set! f6627 7 -1) f6627)
# emit-begin
#   expr=(begin (vector-set! f6627 7 -1) f6627)
#   env=((f6629 . -4) (f6627 . 0))
# emit-expr (vector-set! f6627 7 -1)
# emit-expr f6627
# emit-variable-ref
# env=((f6629 . -4) (f6627 . 0))
# var=f6627
    movl 0(%esp), %eax  # stack load f6627
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_40237
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_40237:
    movl %eax, -8(%esp)
# emit-expr 7
    movl $28, %eax     # immed 7
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_40238"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_40238:
# check bounds on vector index
    movl -8(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_40240
    cmp  $0,%eax
    jge _L_40239
_L_40240:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_40239:
    movl %eax, -12(%esp)
# emit-expr -1
    movl $-4, %eax     # immed -1
    movl -8(%esp), %ebx
    movl -12(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin f6627)
# emit-begin
#   expr=(begin f6627)
#   env=((f6629 . -4) (f6627 . 0))
# emit-expr f6627
# emit-variable-ref
# env=((f6629 . -4) (f6627 . 0))
# var=f6627
    movl 0(%esp), %eax  # stack load f6627
# end emit-variable-ref
# emit-expr (begin)
# emit-begin
#   expr=(begin)
#   env=((f6629 . -4) (f6627 . 0))
     movl %eax, mrc_standard$min
# == explicit-begins  ==>
# (lambda (p) (vector-ref p 6))
# == eliminate-let*  ==>
# (lambda (p) (vector-ref p 6))
# == uniquify-variables  ==>
# (lambda (f6630) (vector-ref f6630 6))
# == vectorize-letrec  ==>
# (lambda (f6630) (vector-ref f6630 6))
# == eliminate-set!  ==>
# (lambda (f6630) (let ((f6630 f6630)) (vector-ref f6630 6)))
# == close-free-variables  ==>
# (closure (f6630) () (let ((f6630 f6630)) (vector-ref f6630 6)))
# == eliminate-quote  ==>
# (closure (f6630) () (let ((f6630 f6630)) (vector-ref f6630 6)))
# == eliminate-when/unless  ==>
# (closure (f6630) () (let ((f6630 f6630)) (vector-ref f6630 6)))
# == eliminate-cond  ==>
# (closure (f6630) () (let ((f6630 f6630)) (vector-ref f6630 6)))
# == external-symbols  ==>
# (closure (f6630) () (let ((f6630 f6630)) (vector-ref f6630 6)))
# emit-expr (closure (f6630) () (let ((f6630 f6630)) (vector-ref f6630 6)))
# emit-closure
# si = 0
# env = ()
# expr = (closure (f6630) () (let ((f6630 f6630)) (vector-ref f6630 6)))
    movl $_L_40241, 0(%ebp)  # closure label
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $8, %ebp     # bump ebp
    jmp _L_40242            # jump around closure body
_L_40241:
# check argument count
    cmp $4,%eax
    je _L_40243
# invoke error handler eh_argcount
    .extern mrc_eh$uargcount
    movl mrc_eh$uargcount, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_40243:
# emit-tail-expr
# si=-12
# env=((f6630 . -8))
# expr=(let ((f6630 f6630)) (vector-ref f6630 6))
# emit-tail-let
#  si   = -12
#  env  = ((f6630 . -8))
#  bindings = ((f6630 f6630))
#  body = (vector-ref f6630 6)
# emit-expr f6630
# emit-variable-ref
# env=((f6630 . -8))
# var=f6630
    movl -8(%esp), %eax  # stack load f6630
# end emit-variable-ref
    movl %eax, -12(%esp)  # stack save
# emit-tail-expr
# si=-16
# env=((f6630 . -12) (f6630 . -8))
# expr=(vector-ref f6630 6)
# tail primcall
# emit-expr f6630
# emit-variable-ref
# env=((f6630 . -12) (f6630 . -8))
# var=f6630
    movl -12(%esp), %eax  # stack load f6630
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_40244
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_40244:
    movl %eax, -16(%esp)
# emit-expr 6
    movl $24, %eax     # immed 6
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_40245"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_40245:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_40247
    cmp  $0,%eax
    jge _L_40246
_L_40247:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_40246:
    movl -16(%esp), %esi
    movl -1(%eax,%esi), %eax
#return from tail (vector-ref f6630 6)
    ret
    .align 4,0x90
_L_40242:
     movl %eax, mrc_port$munread
# == explicit-begins  ==>
# (lambda (p) (vector-set! p 6 #f))
# == eliminate-let*  ==>
# (lambda (p) (vector-set! p 6 #f))
# == uniquify-variables  ==>
# (lambda (f6631) (vector-set! f6631 6 #f))
# == vectorize-letrec  ==>
# (lambda (f6631) (vector-set! f6631 6 #f))
# == eliminate-set!  ==>
# (lambda (f6631) (let ((f6631 f6631)) (vector-set! f6631 6 #f)))
# == close-free-variables  ==>
# (closure (f6631) () (let ((f6631 f6631)) (vector-set! f6631 6 #f)))
# == eliminate-quote  ==>
# (closure (f6631) () (let ((f6631 f6631)) (vector-set! f6631 6 #f)))
# == eliminate-when/unless  ==>
# (closure (f6631) () (let ((f6631 f6631)) (vector-set! f6631 6 #f)))
# == eliminate-cond  ==>
# (closure (f6631) () (let ((f6631 f6631)) (vector-set! f6631 6 #f)))
# == external-symbols  ==>
# (closure (f6631) () (let ((f6631 f6631)) (vector-set! f6631 6 #f)))
# emit-expr (closure (f6631) () (let ((f6631 f6631)) (vector-set! f6631 6 #f)))
# emit-closure
# si = 0
# env = ()
# expr = (closure (f6631) () (let ((f6631 f6631)) (vector-set! f6631 6 #f)))
    movl $_L_40248, 0(%ebp)  # closure label
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $8, %ebp     # bump ebp
    jmp _L_40249            # jump around closure body
_L_40248:
# check argument count
    cmp $4,%eax
    je _L_40250
# invoke error handler eh_argcount
    .extern mrc_eh$uargcount
    movl mrc_eh$uargcount, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_40250:
# emit-tail-expr
# si=-12
# env=((f6631 . -8))
# expr=(let ((f6631 f6631)) (vector-set! f6631 6 #f))
# emit-tail-let
#  si   = -12
#  env  = ((f6631 . -8))
#  bindings = ((f6631 f6631))
#  body = (vector-set! f6631 6 #f)
# emit-expr f6631
# emit-variable-ref
# env=((f6631 . -8))
# var=f6631
    movl -8(%esp), %eax  # stack load f6631
# end emit-variable-ref
    movl %eax, -12(%esp)  # stack save
# emit-tail-expr
# si=-16
# env=((f6631 . -12) (f6631 . -8))
# expr=(vector-set! f6631 6 #f)
# tail primcall
# emit-expr f6631
# emit-variable-ref
# env=((f6631 . -12) (f6631 . -8))
# var=f6631
    movl -12(%esp), %eax  # stack load f6631
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_40251
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_40251:
    movl %eax, -16(%esp)
# emit-expr 6
    movl $24, %eax     # immed 6
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_40252"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_40252:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_40254
    cmp  $0,%eax
    jge _L_40253
_L_40254:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_40253:
    movl %eax, -20(%esp)
# emit-expr #f
    movl $47, %eax     # immed #f
    movl -16(%esp), %ebx
    movl -20(%esp), %esi
    movl %eax, -1(%ebx,%esi)
#return from tail (vector-set! f6631 6 #f)
    ret
    .align 4,0x90
_L_40249:
     movl %eax, mrc_port$munread$mclear
# == explicit-begins  ==>
# (lambda (p x) (vector-set! p 6 x))
# == eliminate-let*  ==>
# (lambda (p x) (vector-set! p 6 x))
# == uniquify-variables  ==>
# (lambda (f6632 f6633) (vector-set! f6632 6 f6633))
# == vectorize-letrec  ==>
# (lambda (f6632 f6633) (vector-set! f6632 6 f6633))
# == eliminate-set!  ==>
# (lambda (f6632 f6633) (let ((f6632 f6632) (f6633 f6633)) (vector-set! f6632 6 f6633)))
# == close-free-variables  ==>
# (closure (f6632 f6633) () (let ((f6632 f6632) (f6633 f6633)) (vector-set! f6632 6 f6633)))
# == eliminate-quote  ==>
# (closure (f6632 f6633) () (let ((f6632 f6632) (f6633 f6633)) (vector-set! f6632 6 f6633)))
# == eliminate-when/unless  ==>
# (closure (f6632 f6633) () (let ((f6632 f6632) (f6633 f6633)) (vector-set! f6632 6 f6633)))
# == eliminate-cond  ==>
# (closure (f6632 f6633) () (let ((f6632 f6632) (f6633 f6633)) (vector-set! f6632 6 f6633)))
# == external-symbols  ==>
# (closure (f6632 f6633) () (let ((f6632 f6632) (f6633 f6633)) (vector-set! f6632 6 f6633)))
# emit-expr (closure (f6632 f6633) () (let ((f6632 f6632) (f6633 f6633)) (vector-set! f6632 6 f6633)))
# emit-closure
# si = 0
# env = ()
# expr = (closure (f6632 f6633) () (let ((f6632 f6632) (f6633 f6633)) (vector-set! f6632 6 f6633)))
    movl $_L_40255, 0(%ebp)  # closure label
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $8, %ebp     # bump ebp
    jmp _L_40256            # jump around closure body
_L_40255:
# check argument count
    cmp $8,%eax
    je _L_40257
# invoke error handler eh_argcount
    .extern mrc_eh$uargcount
    movl mrc_eh$uargcount, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_40257:
# emit-tail-expr
# si=-16
# env=((f6633 . -12) (f6632 . -8))
# expr=(let ((f6632 f6632) (f6633 f6633)) (vector-set! f6632 6 f6633))
# emit-tail-let
#  si   = -16
#  env  = ((f6633 . -12) (f6632 . -8))
#  bindings = ((f6632 f6632) (f6633 f6633))
#  body = (vector-set! f6632 6 f6633)
# emit-expr f6632
# emit-variable-ref
# env=((f6633 . -12) (f6632 . -8))
# var=f6632
    movl -8(%esp), %eax  # stack load f6632
# end emit-variable-ref
    movl %eax, -16(%esp)  # stack save
# emit-expr f6633
# emit-variable-ref
# env=((f6633 . -12) (f6632 . -8))
# var=f6633
    movl -12(%esp), %eax  # stack load f6633
# end emit-variable-ref
    movl %eax, -20(%esp)  # stack save
# emit-tail-expr
# si=-24
# env=((f6633 . -20) (f6632 . -16) (f6633 . -12) (f6632 . -8))
# expr=(vector-set! f6632 6 f6633)
# tail primcall
# emit-expr f6632
# emit-variable-ref
# env=((f6633 . -20) (f6632 . -16) (f6633 . -12) (f6632 . -8))
# var=f6632
    movl -16(%esp), %eax  # stack load f6632
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_40258
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_40258:
    movl %eax, -24(%esp)
# emit-expr 6
    movl $24, %eax     # immed 6
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_40259"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_40259:
# check bounds on vector index
    movl -24(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_40261
    cmp  $0,%eax
    jge _L_40260
_L_40261:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_40260:
    movl %eax, -28(%esp)
# emit-expr f6633
# emit-variable-ref
# env=((f6633 . -20) (f6632 . -16) (f6633 . -12) (f6632 . -8))
# var=f6633
    movl -20(%esp), %eax  # stack load f6633
# end emit-variable-ref
    movl -24(%esp), %ebx
    movl -28(%esp), %esi
    movl %eax, -1(%ebx,%esi)
#return from tail (vector-set! f6632 6 f6633)
    ret
    .align 4,0x90
_L_40256:
     movl %eax, mrc_port$munread$mset$b
# == explicit-begins  ==>
# (lambda (p) (vector-ref p 7))
# == eliminate-let*  ==>
# (lambda (p) (vector-ref p 7))
# == uniquify-variables  ==>
# (lambda (f6634) (vector-ref f6634 7))
# == vectorize-letrec  ==>
# (lambda (f6634) (vector-ref f6634 7))
# == eliminate-set!  ==>
# (lambda (f6634) (let ((f6634 f6634)) (vector-ref f6634 7)))
# == close-free-variables  ==>
# (closure (f6634) () (let ((f6634 f6634)) (vector-ref f6634 7)))
# == eliminate-quote  ==>
# (closure (f6634) () (let ((f6634 f6634)) (vector-ref f6634 7)))
# == eliminate-when/unless  ==>
# (closure (f6634) () (let ((f6634 f6634)) (vector-ref f6634 7)))
# == eliminate-cond  ==>
# (closure (f6634) () (let ((f6634 f6634)) (vector-ref f6634 7)))
# == external-symbols  ==>
# (closure (f6634) () (let ((f6634 f6634)) (vector-ref f6634 7)))
# emit-expr (closure (f6634) () (let ((f6634 f6634)) (vector-ref f6634 7)))
# emit-closure
# si = 0
# env = ()
# expr = (closure (f6634) () (let ((f6634 f6634)) (vector-ref f6634 7)))
    movl $_L_40262, 0(%ebp)  # closure label
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $8, %ebp     # bump ebp
    jmp _L_40263            # jump around closure body
_L_40262:
# check argument count
    cmp $4,%eax
    je _L_40264
# invoke error handler eh_argcount
    .extern mrc_eh$uargcount
    movl mrc_eh$uargcount, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_40264:
# emit-tail-expr
# si=-12
# env=((f6634 . -8))
# expr=(let ((f6634 f6634)) (vector-ref f6634 7))
# emit-tail-let
#  si   = -12
#  env  = ((f6634 . -8))
#  bindings = ((f6634 f6634))
#  body = (vector-ref f6634 7)
# emit-expr f6634
# emit-variable-ref
# env=((f6634 . -8))
# var=f6634
    movl -8(%esp), %eax  # stack load f6634
# end emit-variable-ref
    movl %eax, -12(%esp)  # stack save
# emit-tail-expr
# si=-16
# env=((f6634 . -12) (f6634 . -8))
# expr=(vector-ref f6634 7)
# tail primcall
# emit-expr f6634
# emit-variable-ref
# env=((f6634 . -12) (f6634 . -8))
# var=f6634
    movl -12(%esp), %eax  # stack load f6634
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_40265
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_40265:
    movl %eax, -16(%esp)
# emit-expr 7
    movl $28, %eax     # immed 7
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_40266"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_40266:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_40268
    cmp  $0,%eax
    jge _L_40267
_L_40268:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_40267:
    movl -16(%esp), %esi
    movl -1(%eax,%esi), %eax
#return from tail (vector-ref f6634 7)
    ret
    .align 4,0x90
_L_40263:
     movl %eax, mrc_port$mlast
# == explicit-begins  ==>
# (lambda (p i) (vector-set! p 7 i))
# == eliminate-let*  ==>
# (lambda (p i) (vector-set! p 7 i))
# == uniquify-variables  ==>
# (lambda (f6635 f6636) (vector-set! f6635 7 f6636))
# == vectorize-letrec  ==>
# (lambda (f6635 f6636) (vector-set! f6635 7 f6636))
# == eliminate-set!  ==>
# (lambda (f6635 f6636) (let ((f6635 f6635) (f6636 f6636)) (vector-set! f6635 7 f6636)))
# == close-free-variables  ==>
# (closure (f6635 f6636) () (let ((f6635 f6635) (f6636 f6636)) (vector-set! f6635 7 f6636)))
# == eliminate-quote  ==>
# (closure (f6635 f6636) () (let ((f6635 f6635) (f6636 f6636)) (vector-set! f6635 7 f6636)))
# == eliminate-when/unless  ==>
# (closure (f6635 f6636) () (let ((f6635 f6635) (f6636 f6636)) (vector-set! f6635 7 f6636)))
# == eliminate-cond  ==>
# (closure (f6635 f6636) () (let ((f6635 f6635) (f6636 f6636)) (vector-set! f6635 7 f6636)))
# == external-symbols  ==>
# (closure (f6635 f6636) () (let ((f6635 f6635) (f6636 f6636)) (vector-set! f6635 7 f6636)))
# emit-expr (closure (f6635 f6636) () (let ((f6635 f6635) (f6636 f6636)) (vector-set! f6635 7 f6636)))
# emit-closure
# si = 0
# env = ()
# expr = (closure (f6635 f6636) () (let ((f6635 f6635) (f6636 f6636)) (vector-set! f6635 7 f6636)))
    movl $_L_40269, 0(%ebp)  # closure label
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $8, %ebp     # bump ebp
    jmp _L_40270            # jump around closure body
_L_40269:
# check argument count
    cmp $8,%eax
    je _L_40271
# invoke error handler eh_argcount
    .extern mrc_eh$uargcount
    movl mrc_eh$uargcount, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_40271:
# emit-tail-expr
# si=-16
# env=((f6636 . -12) (f6635 . -8))
# expr=(let ((f6635 f6635) (f6636 f6636)) (vector-set! f6635 7 f6636))
# emit-tail-let
#  si   = -16
#  env  = ((f6636 . -12) (f6635 . -8))
#  bindings = ((f6635 f6635) (f6636 f6636))
#  body = (vector-set! f6635 7 f6636)
# emit-expr f6635
# emit-variable-ref
# env=((f6636 . -12) (f6635 . -8))
# var=f6635
    movl -8(%esp), %eax  # stack load f6635
# end emit-variable-ref
    movl %eax, -16(%esp)  # stack save
# emit-expr f6636
# emit-variable-ref
# env=((f6636 . -12) (f6635 . -8))
# var=f6636
    movl -12(%esp), %eax  # stack load f6636
# end emit-variable-ref
    movl %eax, -20(%esp)  # stack save
# emit-tail-expr
# si=-24
# env=((f6636 . -20) (f6635 . -16) (f6636 . -12) (f6635 . -8))
# expr=(vector-set! f6635 7 f6636)
# tail primcall
# emit-expr f6635
# emit-variable-ref
# env=((f6636 . -20) (f6635 . -16) (f6636 . -12) (f6635 . -8))
# var=f6635
    movl -16(%esp), %eax  # stack load f6635
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_40272
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_40272:
    movl %eax, -24(%esp)
# emit-expr 7
    movl $28, %eax     # immed 7
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_40273"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_40273:
# check bounds on vector index
    movl -24(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_40275
    cmp  $0,%eax
    jge _L_40274
_L_40275:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_40274:
    movl %eax, -28(%esp)
# emit-expr f6636
# emit-variable-ref
# env=((f6636 . -20) (f6635 . -16) (f6636 . -12) (f6635 . -8))
# var=f6636
    movl -20(%esp), %eax  # stack load f6636
# end emit-variable-ref
    movl -24(%esp), %ebx
    movl -28(%esp), %esi
    movl %eax, -1(%ebx,%esi)
#return from tail (vector-set! f6635 7 f6636)
    ret
    .align 4,0x90
_L_40270:
     movl %eax, mrc_port$mlast$mset$b
# == explicit-begins  ==>
# (lambda (p) (and (vector? p) (and (fx= (vector-length p) 8) (eq? (port-kind p) (quote input-port)))))
# == eliminate-let*  ==>
# (lambda (p) (and (vector? p) (and (fx= (vector-length p) 8) (eq? (port-kind p) (quote input-port)))))
# == uniquify-variables  ==>
# (lambda (f6637) (and (vector? f6637) (and (fx= (vector-length f6637) 8) (eq? (port-kind f6637) (quote input-port)))))
# == vectorize-letrec  ==>
# (lambda (f6637) (and (vector? f6637) (and (fx= (vector-length f6637) 8) (eq? (port-kind f6637) (quote input-port)))))
# == eliminate-set!  ==>
# (lambda (f6637) (let ((f6637 f6637)) (and (vector? f6637) (and (fx= (vector-length f6637) 8) (eq? (port-kind f6637) (quote input-port))))))
# == close-free-variables  ==>
# (closure (f6637) (and and port-kind input-port) (let ((f6637 f6637)) (and (vector? f6637) (and (fx= (vector-length f6637) 8) (eq? (port-kind f6637) (quote input-port))))))
# == eliminate-quote  ==>
# (closure (f6637) (and and port-kind input-port) (let ((f6637 f6637)) (and (vector? f6637) (and (fx= (vector-length f6637) 8) (eq? (port-kind f6637) (string->symbol "input-port"))))))
# == eliminate-when/unless  ==>
# (closure (f6637) (and and port-kind input-port) (let ((f6637 f6637)) (and (vector? f6637) (and (fx= (vector-length f6637) 8) (eq? (port-kind f6637) (string->symbol "input-port"))))))
# == eliminate-cond  ==>
# (closure (f6637) (and and port-kind input-port) (let ((f6637 f6637)) (and (vector? f6637) (and (fx= (vector-length f6637) 8) (eq? (port-kind f6637) (string->symbol "input-port"))))))
# == external-symbols  ==>
# (closure (f6637) (and and (primitive-ref port-kind) input-port) (let ((f6637 f6637)) (and (vector? f6637) (and (fx= (vector-length f6637) 8) (eq? ((primitive-ref port-kind) f6637) ((primitive-ref string->symbol) "input-port"))))))
# emit-expr (closure (f6637) (and and (primitive-ref port-kind) input-port) (let ((f6637 f6637)) (and (vector? f6637) (and (fx= (vector-length f6637) 8) (eq? ((primitive-ref port-kind) f6637) ((primitive-ref string->symbol) "input-port"))))))
# emit-closure
# si = 0
# env = ()
# expr = (closure (f6637) (and and (primitive-ref port-kind) input-port) (let ((f6637 f6637)) (and (vector? f6637) (and (fx= (vector-length f6637) 8) (eq? ((primitive-ref port-kind) f6637) ((primitive-ref string->symbol) "input-port"))))))
    movl $_L_40276, 0(%ebp)  # closure label
# WARNING: free var and not defined in the environmnet
# WARNING: free var and not defined in the environmnet
# WARNING: free var (primitive-ref port-kind) not defined in the environmnet
# WARNING: free var input-port not defined in the environmnet
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $24, %ebp     # bump ebp
    jmp _L_40277            # jump around closure body
_L_40276:
# check argument count
    cmp $4,%eax
    je _L_40278
# invoke error handler eh_argcount
    .extern mrc_eh$uargcount
    movl mrc_eh$uargcount, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_40278:
# emit-tail-expr
# si=-12
# env=((f6637 . -8) (input-port . 16) ((primitive-ref port-kind) . 12) (and . 8) (and . 4))
# expr=(let ((f6637 f6637)) (and (vector? f6637) (and (fx= (vector-length f6637) 8) (eq? ((primitive-ref port-kind) f6637) ((primitive-ref string->symbol) "input-port")))))
# emit-tail-let
#  si   = -12
#  env  = ((f6637 . -8) (input-port . 16) ((primitive-ref port-kind) . 12) (and . 8) (and . 4))
#  bindings = ((f6637 f6637))
#  body = (and (vector? f6637) (and (fx= (vector-length f6637) 8) (eq? ((primitive-ref port-kind) f6637) ((primitive-ref string->symbol) "input-port"))))
# emit-expr f6637
# emit-variable-ref
# env=((f6637 . -8) (input-port . 16) ((primitive-ref port-kind) . 12) (and . 8) (and . 4))
# var=f6637
    movl -8(%esp), %eax  # stack load f6637
# end emit-variable-ref
    movl %eax, -12(%esp)  # stack save
# emit-tail-expr
# si=-16
# env=((f6637 . -12) (f6637 . -8) (input-port . 16) ((primitive-ref port-kind) . 12) (and . 8) (and . 4))
# expr=(and (vector? f6637) (and (fx= (vector-length f6637) 8) (eq? ((primitive-ref port-kind) f6637) ((primitive-ref string->symbol) "input-port"))))
# emit-tail-expr
# si=-16
# env=((f6637 . -12) (f6637 . -8) (input-port . 16) ((primitive-ref port-kind) . 12) (and . 8) (and . 4))
# expr=(if (vector? f6637) (and (and (fx= (vector-length f6637) 8) (eq? ((primitive-ref port-kind) f6637) ((primitive-ref string->symbol) "input-port")))) #f)
# emit-expr (vector? f6637)
# emit-expr f6637
# emit-variable-ref
# env=((f6637 . -12) (f6637 . -8) (input-port . 16) ((primitive-ref port-kind) . 12) (and . 8) (and . 4))
# var=f6637
    movl -12(%esp), %eax  # stack load f6637
# end emit-variable-ref
    and $7, %al
    cmp $5, %al
    sete %al
    movzbl %al, %eax
    sal $6, %al
    or $47, %al
    cmp $47, %al
    je _L_40279
# emit-tail-expr
# si=-16
# env=((f6637 . -12) (f6637 . -8) (input-port . 16) ((primitive-ref port-kind) . 12) (and . 8) (and . 4))
# expr=(and (and (fx= (vector-length f6637) 8) (eq? ((primitive-ref port-kind) f6637) ((primitive-ref string->symbol) "input-port"))))
# emit-tail-expr
# si=-16
# env=((f6637 . -12) (f6637 . -8) (input-port . 16) ((primitive-ref port-kind) . 12) (and . 8) (and . 4))
# expr=(and (fx= (vector-length f6637) 8) (eq? ((primitive-ref port-kind) f6637) ((primitive-ref string->symbol) "input-port")))
# emit-tail-expr
# si=-16
# env=((f6637 . -12) (f6637 . -8) (input-port . 16) ((primitive-ref port-kind) . 12) (and . 8) (and . 4))
# expr=(if (fx= (vector-length f6637) 8) (and (eq? ((primitive-ref port-kind) f6637) ((primitive-ref string->symbol) "input-port"))) #f)
# emit-expr (fx= (vector-length f6637) 8)
# emit-expr 8
    movl $32, %eax     # immed 8
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_40283"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $68,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_40283:
    movl %eax, -16(%esp)
# emit-expr (vector-length f6637)
# emit-expr f6637
# emit-variable-ref
# env=((f6637 . -12) (f6637 . -8) (input-port . 16) ((primitive-ref port-kind) . 12) (and . 8) (and . 4))
# var=f6637
    movl -12(%esp), %eax  # stack load f6637
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_40284
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_40284:
andl $-8, %eax
movl 0(%eax), %eax
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_40285"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $68,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_40285:
    cmp -16(%esp), %eax
    sete %al
    movzbl %al, %eax
    sal $6, %al
    or $47, %al
    cmp $47, %al
    je _L_40281
# emit-tail-expr
# si=-16
# env=((f6637 . -12) (f6637 . -8) (input-port . 16) ((primitive-ref port-kind) . 12) (and . 8) (and . 4))
# expr=(and (eq? ((primitive-ref port-kind) f6637) ((primitive-ref string->symbol) "input-port")))
# emit-tail-expr
# si=-16
# env=((f6637 . -12) (f6637 . -8) (input-port . 16) ((primitive-ref port-kind) . 12) (and . 8) (and . 4))
# expr=(eq? ((primitive-ref port-kind) f6637) ((primitive-ref string->symbol) "input-port"))
# tail primcall
# eq? arg1=((primitive-ref port-kind) f6637) arg2=((primitive-ref string->symbol) "input-port")
# emit-expr ((primitive-ref port-kind) f6637)
# funcall
#    si   =-16
#    env  = ((f6637 . -12) (f6637 . -8) (input-port . 16) ((primitive-ref port-kind) . 12) (and . 8) (and . 4))
#    expr = (funcall (primitive-ref port-kind) f6637)
# emit-expr (primitive-ref port-kind)
    .extern mrc_port$mkind
    movl mrc_port$mkind,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_40286"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_40286":
   movl %eax,  -24(%esp)  # stash funcall-oper in closure slot
# emit-expr f6637
# emit-variable-ref
# env=((f6637 . -12) (f6637 . -8) (input-port . 16) ((primitive-ref port-kind) . 12) (and . 8) (and . 4))
# var=f6637
    movl -12(%esp), %eax  # stack load f6637
# end emit-variable-ref
    mov %eax, -28(%esp)  # arg f6637
    movl -24(%esp), %edi   # load new closure to %edi
    add $-16, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $16, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    movl %eax, -16(%esp)
# emit-expr ((primitive-ref string->symbol) "input-port")
# funcall
#    si   =-20
#    env  = ((f6637 . -12) (f6637 . -8) (input-port . 16) ((primitive-ref port-kind) . 12) (and . 8) (and . 4))
#    expr = (funcall (primitive-ref string->symbol) "input-port")
# emit-expr (primitive-ref string->symbol)
    .extern mrc_string$m$gsymbol
    movl mrc_string$m$gsymbol,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_40287"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_40287":
   movl %eax,  -28(%esp)  # stash funcall-oper in closure slot
# emit-expr "input-port"
# string literal
    jmp _L_40289
    .align 8,0x90
_L_40288 :
    .int 40
    .ascii "input-port"
_L_40289:
    movl $_L_40288, %eax
    orl $6, %eax
    mov %eax, -32(%esp)  # arg input-port
    movl -28(%esp), %edi   # load new closure to %edi
    add $-20, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $20, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    cmp %eax, -16(%esp)
    sete %al
    movzbl %al, %eax
    sal $6, %al
    or $47, %al
#return from tail (eq? ((primitive-ref port-kind) f6637) ((primitive-ref string->symbol) input-port))
    ret
    jmp _L_40282
_L_40281:
# emit-tail-expr
# si=-16
# env=((f6637 . -12) (f6637 . -8) (input-port . 16) ((primitive-ref port-kind) . 12) (and . 8) (and . 4))
# expr=#f
    movl $47, %eax     # immed #f
    ret                  # immediate tail return
_L_40282:
    jmp _L_40280
_L_40279:
# emit-tail-expr
# si=-16
# env=((f6637 . -12) (f6637 . -8) (input-port . 16) ((primitive-ref port-kind) . 12) (and . 8) (and . 4))
# expr=#f
    movl $47, %eax     # immed #f
    ret                  # immediate tail return
_L_40280:
    .align 4,0x90
_L_40277:
     movl %eax, mrc_input$mport$q
# == explicit-begins  ==>
# (lambda (p) (and (vector? p) (and (fx= (vector-length p) 6) (eq? (port-kind p) (quote output-port)))))
# == eliminate-let*  ==>
# (lambda (p) (and (vector? p) (and (fx= (vector-length p) 6) (eq? (port-kind p) (quote output-port)))))
# == uniquify-variables  ==>
# (lambda (f6638) (and (vector? f6638) (and (fx= (vector-length f6638) 6) (eq? (port-kind f6638) (quote output-port)))))
# == vectorize-letrec  ==>
# (lambda (f6638) (and (vector? f6638) (and (fx= (vector-length f6638) 6) (eq? (port-kind f6638) (quote output-port)))))
# == eliminate-set!  ==>
# (lambda (f6638) (let ((f6638 f6638)) (and (vector? f6638) (and (fx= (vector-length f6638) 6) (eq? (port-kind f6638) (quote output-port))))))
# == close-free-variables  ==>
# (closure (f6638) (and and port-kind output-port) (let ((f6638 f6638)) (and (vector? f6638) (and (fx= (vector-length f6638) 6) (eq? (port-kind f6638) (quote output-port))))))
# == eliminate-quote  ==>
# (closure (f6638) (and and port-kind output-port) (let ((f6638 f6638)) (and (vector? f6638) (and (fx= (vector-length f6638) 6) (eq? (port-kind f6638) (string->symbol "output-port"))))))
# == eliminate-when/unless  ==>
# (closure (f6638) (and and port-kind output-port) (let ((f6638 f6638)) (and (vector? f6638) (and (fx= (vector-length f6638) 6) (eq? (port-kind f6638) (string->symbol "output-port"))))))
# == eliminate-cond  ==>
# (closure (f6638) (and and port-kind output-port) (let ((f6638 f6638)) (and (vector? f6638) (and (fx= (vector-length f6638) 6) (eq? (port-kind f6638) (string->symbol "output-port"))))))
# == external-symbols  ==>
# (closure (f6638) (and and (primitive-ref port-kind) output-port) (let ((f6638 f6638)) (and (vector? f6638) (and (fx= (vector-length f6638) 6) (eq? ((primitive-ref port-kind) f6638) ((primitive-ref string->symbol) "output-port"))))))
# emit-expr (closure (f6638) (and and (primitive-ref port-kind) output-port) (let ((f6638 f6638)) (and (vector? f6638) (and (fx= (vector-length f6638) 6) (eq? ((primitive-ref port-kind) f6638) ((primitive-ref string->symbol) "output-port"))))))
# emit-closure
# si = 0
# env = ()
# expr = (closure (f6638) (and and (primitive-ref port-kind) output-port) (let ((f6638 f6638)) (and (vector? f6638) (and (fx= (vector-length f6638) 6) (eq? ((primitive-ref port-kind) f6638) ((primitive-ref string->symbol) "output-port"))))))
    movl $_L_40290, 0(%ebp)  # closure label
# WARNING: free var and not defined in the environmnet
# WARNING: free var and not defined in the environmnet
# WARNING: free var (primitive-ref port-kind) not defined in the environmnet
# WARNING: free var output-port not defined in the environmnet
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $24, %ebp     # bump ebp
    jmp _L_40291            # jump around closure body
_L_40290:
# check argument count
    cmp $4,%eax
    je _L_40292
# invoke error handler eh_argcount
    .extern mrc_eh$uargcount
    movl mrc_eh$uargcount, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_40292:
# emit-tail-expr
# si=-12
# env=((f6638 . -8) (output-port . 16) ((primitive-ref port-kind) . 12) (and . 8) (and . 4))
# expr=(let ((f6638 f6638)) (and (vector? f6638) (and (fx= (vector-length f6638) 6) (eq? ((primitive-ref port-kind) f6638) ((primitive-ref string->symbol) "output-port")))))
# emit-tail-let
#  si   = -12
#  env  = ((f6638 . -8) (output-port . 16) ((primitive-ref port-kind) . 12) (and . 8) (and . 4))
#  bindings = ((f6638 f6638))
#  body = (and (vector? f6638) (and (fx= (vector-length f6638) 6) (eq? ((primitive-ref port-kind) f6638) ((primitive-ref string->symbol) "output-port"))))
# emit-expr f6638
# emit-variable-ref
# env=((f6638 . -8) (output-port . 16) ((primitive-ref port-kind) . 12) (and . 8) (and . 4))
# var=f6638
    movl -8(%esp), %eax  # stack load f6638
# end emit-variable-ref
    movl %eax, -12(%esp)  # stack save
# emit-tail-expr
# si=-16
# env=((f6638 . -12) (f6638 . -8) (output-port . 16) ((primitive-ref port-kind) . 12) (and . 8) (and . 4))
# expr=(and (vector? f6638) (and (fx= (vector-length f6638) 6) (eq? ((primitive-ref port-kind) f6638) ((primitive-ref string->symbol) "output-port"))))
# emit-tail-expr
# si=-16
# env=((f6638 . -12) (f6638 . -8) (output-port . 16) ((primitive-ref port-kind) . 12) (and . 8) (and . 4))
# expr=(if (vector? f6638) (and (and (fx= (vector-length f6638) 6) (eq? ((primitive-ref port-kind) f6638) ((primitive-ref string->symbol) "output-port")))) #f)
# emit-expr (vector? f6638)
# emit-expr f6638
# emit-variable-ref
# env=((f6638 . -12) (f6638 . -8) (output-port . 16) ((primitive-ref port-kind) . 12) (and . 8) (and . 4))
# var=f6638
    movl -12(%esp), %eax  # stack load f6638
# end emit-variable-ref
    and $7, %al
    cmp $5, %al
    sete %al
    movzbl %al, %eax
    sal $6, %al
    or $47, %al
    cmp $47, %al
    je _L_40293
# emit-tail-expr
# si=-16
# env=((f6638 . -12) (f6638 . -8) (output-port . 16) ((primitive-ref port-kind) . 12) (and . 8) (and . 4))
# expr=(and (and (fx= (vector-length f6638) 6) (eq? ((primitive-ref port-kind) f6638) ((primitive-ref string->symbol) "output-port"))))
# emit-tail-expr
# si=-16
# env=((f6638 . -12) (f6638 . -8) (output-port . 16) ((primitive-ref port-kind) . 12) (and . 8) (and . 4))
# expr=(and (fx= (vector-length f6638) 6) (eq? ((primitive-ref port-kind) f6638) ((primitive-ref string->symbol) "output-port")))
# emit-tail-expr
# si=-16
# env=((f6638 . -12) (f6638 . -8) (output-port . 16) ((primitive-ref port-kind) . 12) (and . 8) (and . 4))
# expr=(if (fx= (vector-length f6638) 6) (and (eq? ((primitive-ref port-kind) f6638) ((primitive-ref string->symbol) "output-port"))) #f)
# emit-expr (fx= (vector-length f6638) 6)
# emit-expr 6
    movl $24, %eax     # immed 6
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_40297"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $68,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_40297:
    movl %eax, -16(%esp)
# emit-expr (vector-length f6638)
# emit-expr f6638
# emit-variable-ref
# env=((f6638 . -12) (f6638 . -8) (output-port . 16) ((primitive-ref port-kind) . 12) (and . 8) (and . 4))
# var=f6638
    movl -12(%esp), %eax  # stack load f6638
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_40298
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_40298:
andl $-8, %eax
movl 0(%eax), %eax
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_40299"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $68,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_40299:
    cmp -16(%esp), %eax
    sete %al
    movzbl %al, %eax
    sal $6, %al
    or $47, %al
    cmp $47, %al
    je _L_40295
# emit-tail-expr
# si=-16
# env=((f6638 . -12) (f6638 . -8) (output-port . 16) ((primitive-ref port-kind) . 12) (and . 8) (and . 4))
# expr=(and (eq? ((primitive-ref port-kind) f6638) ((primitive-ref string->symbol) "output-port")))
# emit-tail-expr
# si=-16
# env=((f6638 . -12) (f6638 . -8) (output-port . 16) ((primitive-ref port-kind) . 12) (and . 8) (and . 4))
# expr=(eq? ((primitive-ref port-kind) f6638) ((primitive-ref string->symbol) "output-port"))
# tail primcall
# eq? arg1=((primitive-ref port-kind) f6638) arg2=((primitive-ref string->symbol) "output-port")
# emit-expr ((primitive-ref port-kind) f6638)
# funcall
#    si   =-16
#    env  = ((f6638 . -12) (f6638 . -8) (output-port . 16) ((primitive-ref port-kind) . 12) (and . 8) (and . 4))
#    expr = (funcall (primitive-ref port-kind) f6638)
# emit-expr (primitive-ref port-kind)
    .extern mrc_port$mkind
    movl mrc_port$mkind,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_40300"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_40300":
   movl %eax,  -24(%esp)  # stash funcall-oper in closure slot
# emit-expr f6638
# emit-variable-ref
# env=((f6638 . -12) (f6638 . -8) (output-port . 16) ((primitive-ref port-kind) . 12) (and . 8) (and . 4))
# var=f6638
    movl -12(%esp), %eax  # stack load f6638
# end emit-variable-ref
    mov %eax, -28(%esp)  # arg f6638
    movl -24(%esp), %edi   # load new closure to %edi
    add $-16, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $16, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    movl %eax, -16(%esp)
# emit-expr ((primitive-ref string->symbol) "output-port")
# funcall
#    si   =-20
#    env  = ((f6638 . -12) (f6638 . -8) (output-port . 16) ((primitive-ref port-kind) . 12) (and . 8) (and . 4))
#    expr = (funcall (primitive-ref string->symbol) "output-port")
# emit-expr (primitive-ref string->symbol)
    .extern mrc_string$m$gsymbol
    movl mrc_string$m$gsymbol,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_40301"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_40301":
   movl %eax,  -28(%esp)  # stash funcall-oper in closure slot
# emit-expr "output-port"
# string literal
    jmp _L_40303
    .align 8,0x90
_L_40302 :
    .int 44
    .ascii "output-port"
_L_40303:
    movl $_L_40302, %eax
    orl $6, %eax
    mov %eax, -32(%esp)  # arg output-port
    movl -28(%esp), %edi   # load new closure to %edi
    add $-20, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $20, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    cmp %eax, -16(%esp)
    sete %al
    movzbl %al, %eax
    sal $6, %al
    or $47, %al
#return from tail (eq? ((primitive-ref port-kind) f6638) ((primitive-ref string->symbol) output-port))
    ret
    jmp _L_40296
_L_40295:
# emit-tail-expr
# si=-16
# env=((f6638 . -12) (f6638 . -8) (output-port . 16) ((primitive-ref port-kind) . 12) (and . 8) (and . 4))
# expr=#f
    movl $47, %eax     # immed #f
    ret                  # immediate tail return
_L_40296:
    jmp _L_40294
_L_40293:
# emit-tail-expr
# si=-16
# env=((f6638 . -12) (f6638 . -8) (output-port . 16) ((primitive-ref port-kind) . 12) (and . 8) (and . 4))
# expr=#f
    movl $47, %eax     # immed #f
    ret                  # immediate tail return
_L_40294:
    .align 4,0x90
_L_40291:
     movl %eax, mrc_output$mport$q
# == explicit-begins  ==>
# (lambda (filename) (begin (unless (string? filename) (error (quote open-input-file) "filename must be a string")) (let ((fd (foreign-call "s_open" filename))) (begin (when (negative? fd) (error (quote open-input-file) "open failed")) (let ((p (make-vector 8)) (sz 1024)) (begin (vector-set! p 0 (quote input-port)) (vector-set! p 1 filename) (vector-set! p 2 fd) (vector-set! p 3 (make-string sz)) (vector-set! p 4 0) (vector-set! p 5 sz) (vector-set! p 6 #f) (vector-set! p 7 0) p))))))
# == eliminate-let*  ==>
# (lambda (filename) (begin (unless (string? filename) (error (quote open-input-file) "filename must be a string")) (let ((fd (foreign-call "s_open" filename))) (begin (when (negative? fd) (error (quote open-input-file) "open failed")) (let ((p (make-vector 8)) (sz 1024)) (begin (vector-set! p 0 (quote input-port)) (vector-set! p 1 filename) (vector-set! p 2 fd) (vector-set! p 3 (make-string sz)) (vector-set! p 4 0) (vector-set! p 5 sz) (vector-set! p 6 #f) (vector-set! p 7 0) p))))))
# == uniquify-variables  ==>
# (lambda (f6639) (begin (unless (string? f6639) (error (quote open-input-file) "filename must be a string")) (let ((f6645 (foreign-call "s_open" f6639))) (begin (when (negative? f6645) (error (quote open-input-file) "open failed")) (let ((f6649 (make-vector 8)) (f6648 1024)) (begin (vector-set! f6649 0 (quote input-port)) (vector-set! f6649 1 f6639) (vector-set! f6649 2 f6645) (vector-set! f6649 3 (make-string f6648)) (vector-set! f6649 4 0) (vector-set! f6649 5 f6648) (vector-set! f6649 6 #f) (vector-set! f6649 7 0) f6649))))))
# == vectorize-letrec  ==>
# (lambda (f6639) (begin (unless (string? f6639) (error (quote open-input-file) "filename must be a string")) (let ((f6645 (foreign-call "s_open" f6639))) (begin (when (negative? f6645) (error (quote open-input-file) "open failed")) (let ((f6649 (make-vector 8)) (f6648 1024)) (begin (vector-set! f6649 0 (quote input-port)) (vector-set! f6649 1 f6639) (vector-set! f6649 2 f6645) (vector-set! f6649 3 (make-string f6648)) (vector-set! f6649 4 0) (vector-set! f6649 5 f6648) (vector-set! f6649 6 #f) (vector-set! f6649 7 0) f6649))))))
# == eliminate-set!  ==>
# (lambda (f6639) (let ((f6639 f6639)) (begin (unless (string? f6639) (error (quote open-input-file) "filename must be a string")) (let ((f6645 (foreign-call "s_open" f6639))) (begin (when (negative? f6645) (error (quote open-input-file) "open failed")) (let ((f6649 (make-vector 8)) (f6648 1024)) (begin (vector-set! f6649 0 (quote input-port)) (vector-set! f6649 1 f6639) (vector-set! f6649 2 f6645) (vector-set! f6649 3 (make-string f6648)) (vector-set! f6649 4 0) (vector-set! f6649 5 f6648) (vector-set! f6649 6 #f) (vector-set! f6649 7 0) f6649)))))))
# == close-free-variables  ==>
# (closure (f6639) (unless error open-input-file when negative? error open-input-file input-port) (let ((f6639 f6639)) (begin (unless (string? f6639) (error (quote open-input-file) "filename must be a string")) (let ((f6645 (foreign-call "s_open" f6639))) (begin (when (negative? f6645) (error (quote open-input-file) "open failed")) (let ((f6649 (make-vector 8)) (f6648 1024)) (begin (vector-set! f6649 0 (quote input-port)) (vector-set! f6649 1 f6639) (vector-set! f6649 2 f6645) (vector-set! f6649 3 (make-string f6648)) (vector-set! f6649 4 0) (vector-set! f6649 5 f6648) (vector-set! f6649 6 #f) (vector-set! f6649 7 0) f6649)))))))
# == eliminate-quote  ==>
# (closure (f6639) (unless error open-input-file when negative? error open-input-file input-port) (let ((f6639 f6639)) (begin (unless (string? f6639) (error (string->symbol "open-input-file") "filename must be a string")) (let ((f6645 (foreign-call "s_open" f6639))) (begin (when (negative? f6645) (error (string->symbol "open-input-file") "open failed")) (let ((f6649 (make-vector 8)) (f6648 1024)) (begin (vector-set! f6649 0 (string->symbol "input-port")) (vector-set! f6649 1 f6639) (vector-set! f6649 2 f6645) (vector-set! f6649 3 (make-string f6648)) (vector-set! f6649 4 0) (vector-set! f6649 5 f6648) (vector-set! f6649 6 #f) (vector-set! f6649 7 0) f6649)))))))
# == eliminate-when/unless  ==>
# (closure (f6639) (if (not error) (begin open-input-file if negative? (begin error open-input-file input-port) #f) #f) (let ((f6639 f6639)) (begin (if (not (string? f6639)) (begin (error (string->symbol "open-input-file") "filename must be a string")) #f) (let ((f6645 (foreign-call "s_open" f6639))) (begin (if (negative? f6645) (begin (error (string->symbol "open-input-file") "open failed")) #f) (let ((f6649 (make-vector 8)) (f6648 1024)) (begin (vector-set! f6649 0 (string->symbol "input-port")) (vector-set! f6649 1 f6639) (vector-set! f6649 2 f6645) (vector-set! f6649 3 (make-string f6648)) (vector-set! f6649 4 0) (vector-set! f6649 5 f6648) (vector-set! f6649 6 #f) (vector-set! f6649 7 0) f6649)))))))
# == eliminate-cond  ==>
# (closure (f6639) (if (not error) (begin open-input-file if negative? (begin error open-input-file input-port) #f) #f) (let ((f6639 f6639)) (begin (if (not (string? f6639)) (begin (error (string->symbol "open-input-file") "filename must be a string")) #f) (let ((f6645 (foreign-call "s_open" f6639))) (begin (if (negative? f6645) (begin (error (string->symbol "open-input-file") "open failed")) #f) (let ((f6649 (make-vector 8)) (f6648 1024)) (begin (vector-set! f6649 0 (string->symbol "input-port")) (vector-set! f6649 1 f6639) (vector-set! f6649 2 f6645) (vector-set! f6649 3 (make-string f6648)) (vector-set! f6649 4 0) (vector-set! f6649 5 f6648) (vector-set! f6649 6 #f) (vector-set! f6649 7 0) f6649)))))))
# == external-symbols  ==>
# (closure (f6639) (if (not (primitive-ref error)) (begin (primitive-ref open-input-file) if (primitive-ref negative?) (begin (primitive-ref error) (primitive-ref open-input-file) input-port) #f) #f) (let ((f6639 f6639)) (begin (if (not (string? f6639)) (begin ((primitive-ref error) ((primitive-ref string->symbol) "open-input-file") "filename must be a string")) #f) (let ((f6645 (foreign-call "s_open" f6639))) (begin (if ((primitive-ref negative?) f6645) (begin ((primitive-ref error) ((primitive-ref string->symbol) "open-input-file") "open failed")) #f) (let ((f6649 (make-vector 8)) (f6648 1024)) (begin (vector-set! f6649 0 ((primitive-ref string->symbol) "input-port")) (vector-set! f6649 1 f6639) (vector-set! f6649 2 f6645) (vector-set! f6649 3 (make-string f6648)) (vector-set! f6649 4 0) (vector-set! f6649 5 f6648) (vector-set! f6649 6 #f) (vector-set! f6649 7 0) f6649)))))))
# emit-expr (closure (f6639) (if (not (primitive-ref error)) (begin (primitive-ref open-input-file) if (primitive-ref negative?) (begin (primitive-ref error) (primitive-ref open-input-file) input-port) #f) #f) (let ((f6639 f6639)) (begin (if (not (string? f6639)) (begin ((primitive-ref error) ((primitive-ref string->symbol) "open-input-file") "filename must be a string")) #f) (let ((f6645 (foreign-call "s_open" f6639))) (begin (if ((primitive-ref negative?) f6645) (begin ((primitive-ref error) ((primitive-ref string->symbol) "open-input-file") "open failed")) #f) (let ((f6649 (make-vector 8)) (f6648 1024)) (begin (vector-set! f6649 0 ((primitive-ref string->symbol) "input-port")) (vector-set! f6649 1 f6639) (vector-set! f6649 2 f6645) (vector-set! f6649 3 (make-string f6648)) (vector-set! f6649 4 0) (vector-set! f6649 5 f6648) (vector-set! f6649 6 #f) (vector-set! f6649 7 0) f6649)))))))
# emit-closure
# si = 0
# env = ()
# expr = (closure (f6639) (if (not (primitive-ref error)) (begin (primitive-ref open-input-file) if (primitive-ref negative?) (begin (primitive-ref error) (primitive-ref open-input-file) input-port) #f) #f) (let ((f6639 f6639)) (begin (if (not (string? f6639)) (begin ((primitive-ref error) ((primitive-ref string->symbol) "open-input-file") "filename must be a string")) #f) (let ((f6645 (foreign-call "s_open" f6639))) (begin (if ((primitive-ref negative?) f6645) (begin ((primitive-ref error) ((primitive-ref string->symbol) "open-input-file") "open failed")) #f) (let ((f6649 (make-vector 8)) (f6648 1024)) (begin (vector-set! f6649 0 ((primitive-ref string->symbol) "input-port")) (vector-set! f6649 1 f6639) (vector-set! f6649 2 f6645) (vector-set! f6649 3 (make-string f6648)) (vector-set! f6649 4 0) (vector-set! f6649 5 f6648) (vector-set! f6649 6 #f) (vector-set! f6649 7 0) f6649)))))))
    movl $_L_40304, 0(%ebp)  # closure label
# WARNING: free var if not defined in the environmnet
# WARNING: free var (not (primitive-ref error)) not defined in the environmnet
# WARNING: free var (begin (primitive-ref open-input-file) if (primitive-ref negative?) (begin (primitive-ref error) (primitive-ref open-input-file) input-port) #f) not defined in the environmnet
# WARNING: free var #f not defined in the environmnet
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $24, %ebp     # bump ebp
    jmp _L_40305            # jump around closure body
_L_40304:
# check argument count
    cmp $4,%eax
    je _L_40306
# invoke error handler eh_argcount
    .extern mrc_eh$uargcount
    movl mrc_eh$uargcount, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_40306:
# emit-tail-expr
# si=-12
# env=((f6639 . -8) (#f . 16) ((begin (primitive-ref open-input-file) if (primitive-ref negative?) (begin (primitive-ref error) (primitive-ref open-input-file) input-port) #f) . 12) ((not (primitive-ref error)) . 8) (if . 4))
# expr=(let ((f6639 f6639)) (begin (if (not (string? f6639)) (begin ((primitive-ref error) ((primitive-ref string->symbol) "open-input-file") "filename must be a string")) #f) (let ((f6645 (foreign-call "s_open" f6639))) (begin (if ((primitive-ref negative?) f6645) (begin ((primitive-ref error) ((primitive-ref string->symbol) "open-input-file") "open failed")) #f) (let ((f6649 (make-vector 8)) (f6648 1024)) (begin (vector-set! f6649 0 ((primitive-ref string->symbol) "input-port")) (vector-set! f6649 1 f6639) (vector-set! f6649 2 f6645) (vector-set! f6649 3 (make-string f6648)) (vector-set! f6649 4 0) (vector-set! f6649 5 f6648) (vector-set! f6649 6 #f) (vector-set! f6649 7 0) f6649))))))
# emit-tail-let
#  si   = -12
#  env  = ((f6639 . -8) (#f . 16) ((begin (primitive-ref open-input-file) if (primitive-ref negative?) (begin (primitive-ref error) (primitive-ref open-input-file) input-port) #f) . 12) ((not (primitive-ref error)) . 8) (if . 4))
#  bindings = ((f6639 f6639))
#  body = (begin (if (not (string? f6639)) (begin ((primitive-ref error) ((primitive-ref string->symbol) "open-input-file") "filename must be a string")) #f) (let ((f6645 (foreign-call "s_open" f6639))) (begin (if ((primitive-ref negative?) f6645) (begin ((primitive-ref error) ((primitive-ref string->symbol) "open-input-file") "open failed")) #f) (let ((f6649 (make-vector 8)) (f6648 1024)) (begin (vector-set! f6649 0 ((primitive-ref string->symbol) "input-port")) (vector-set! f6649 1 f6639) (vector-set! f6649 2 f6645) (vector-set! f6649 3 (make-string f6648)) (vector-set! f6649 4 0) (vector-set! f6649 5 f6648) (vector-set! f6649 6 #f) (vector-set! f6649 7 0) f6649)))))
# emit-expr f6639
# emit-variable-ref
# env=((f6639 . -8) (#f . 16) ((begin (primitive-ref open-input-file) if (primitive-ref negative?) (begin (primitive-ref error) (primitive-ref open-input-file) input-port) #f) . 12) ((not (primitive-ref error)) . 8) (if . 4))
# var=f6639
    movl -8(%esp), %eax  # stack load f6639
# end emit-variable-ref
    movl %eax, -12(%esp)  # stack save
# emit-tail-expr
# si=-16
# env=((f6639 . -12) (f6639 . -8) (#f . 16) ((begin (primitive-ref open-input-file) if (primitive-ref negative?) (begin (primitive-ref error) (primitive-ref open-input-file) input-port) #f) . 12) ((not (primitive-ref error)) . 8) (if . 4))
# expr=(begin (if (not (string? f6639)) (begin ((primitive-ref error) ((primitive-ref string->symbol) "open-input-file") "filename must be a string")) #f) (let ((f6645 (foreign-call "s_open" f6639))) (begin (if ((primitive-ref negative?) f6645) (begin ((primitive-ref error) ((primitive-ref string->symbol) "open-input-file") "open failed")) #f) (let ((f6649 (make-vector 8)) (f6648 1024)) (begin (vector-set! f6649 0 ((primitive-ref string->symbol) "input-port")) (vector-set! f6649 1 f6639) (vector-set! f6649 2 f6645) (vector-set! f6649 3 (make-string f6648)) (vector-set! f6649 4 0) (vector-set! f6649 5 f6648) (vector-set! f6649 6 #f) (vector-set! f6649 7 0) f6649)))))
# tail-begin (begin (if (not (string? f6639)) (begin ((primitive-ref error) ((primitive-ref string->symbol) "open-input-file") "filename must be a string")) #f) (let ((f6645 (foreign-call "s_open" f6639))) (begin (if ((primitive-ref negative?) f6645) (begin ((primitive-ref error) ((primitive-ref string->symbol) "open-input-file") "open failed")) #f) (let ((f6649 (make-vector 8)) (f6648 1024)) (begin (vector-set! f6649 0 ((primitive-ref string->symbol) "input-port")) (vector-set! f6649 1 f6639) (vector-set! f6649 2 f6645) (vector-set! f6649 3 (make-string f6648)) (vector-set! f6649 4 0) (vector-set! f6649 5 f6648) (vector-set! f6649 6 #f) (vector-set! f6649 7 0) f6649)))))
#   env=((f6639 . -12) (f6639 . -8) (#f . 16) ((begin (primitive-ref open-input-file) if (primitive-ref negative?) (begin (primitive-ref error) (primitive-ref open-input-file) input-port) #f) . 12) ((not (primitive-ref error)) . 8) (if . 4))
# emit-expr (if (not (string? f6639)) (begin ((primitive-ref error) ((primitive-ref string->symbol) "open-input-file") "filename must be a string")) #f)
# emit-expr (not (string? f6639))
# emit-expr (string? f6639)
# emit-expr f6639
# emit-variable-ref
# env=((f6639 . -12) (f6639 . -8) (#f . 16) ((begin (primitive-ref open-input-file) if (primitive-ref negative?) (begin (primitive-ref error) (primitive-ref open-input-file) input-port) #f) . 12) ((not (primitive-ref error)) . 8) (if . 4))
# var=f6639
    movl -12(%esp), %eax  # stack load f6639
# end emit-variable-ref
    and $7, %al
    cmp $6, %al
    sete %al
    movzbl %al, %eax
    sal $6, %al
    or $47, %al
    cmp $47, %eax
    sete %al
    movzbl %al, %eax
    sal $6, %al
    or $47, %al
    cmp $47, %al
    je _L_40307
# emit-expr (begin ((primitive-ref error) ((primitive-ref string->symbol) "open-input-file") "filename must be a string"))
# emit-begin
#   expr=(begin ((primitive-ref error) ((primitive-ref string->symbol) "open-input-file") "filename must be a string"))
#   env=((f6639 . -12) (f6639 . -8) (#f . 16) ((begin (primitive-ref open-input-file) if (primitive-ref negative?) (begin (primitive-ref error) (primitive-ref open-input-file) input-port) #f) . 12) ((not (primitive-ref error)) . 8) (if . 4))
# emit-expr ((primitive-ref error) ((primitive-ref string->symbol) "open-input-file") "filename must be a string")
# funcall
#    si   =-16
#    env  = ((f6639 . -12) (f6639 . -8) (#f . 16) ((begin (primitive-ref open-input-file) if (primitive-ref negative?) (begin (primitive-ref error) (primitive-ref open-input-file) input-port) #f) . 12) ((not (primitive-ref error)) . 8) (if . 4))
#    expr = (funcall (primitive-ref error) ((primitive-ref string->symbol) "open-input-file") "filename must be a string")
# emit-expr (primitive-ref error)
    .extern mrc_error
    movl mrc_error,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_40309"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_40309":
   movl %eax,  -24(%esp)  # stash funcall-oper in closure slot
# emit-expr ((primitive-ref string->symbol) "open-input-file")
# funcall
#    si   =-28
#    env  = ((f6639 . -12) (f6639 . -8) (#f . 16) ((begin (primitive-ref open-input-file) if (primitive-ref negative?) (begin (primitive-ref error) (primitive-ref open-input-file) input-port) #f) . 12) ((not (primitive-ref error)) . 8) (if . 4))
#    expr = (funcall (primitive-ref string->symbol) "open-input-file")
# emit-expr (primitive-ref string->symbol)
    .extern mrc_string$m$gsymbol
    movl mrc_string$m$gsymbol,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_40310"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_40310":
   movl %eax,  -36(%esp)  # stash funcall-oper in closure slot
# emit-expr "open-input-file"
# string literal
    jmp _L_40312
    .align 8,0x90
_L_40311 :
    .int 60
    .ascii "open-input-file"
_L_40312:
    movl $_L_40311, %eax
    orl $6, %eax
    mov %eax, -40(%esp)  # arg open-input-file
    movl -36(%esp), %edi   # load new closure to %edi
    add $-28, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $28, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    mov %eax, -28(%esp)  # arg ((primitive-ref string->symbol) open-input-file)
# emit-expr "filename must be a string"
# string literal
    jmp _L_40314
    .align 8,0x90
_L_40313 :
    .int 100
    .ascii "filename must be a string"
_L_40314:
    movl $_L_40313, %eax
    orl $6, %eax
    mov %eax, -32(%esp)  # arg filename must be a string
    movl -24(%esp), %edi   # load new closure to %edi
    add $-16, %esp   # adjust base
    movl $8,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $16, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
# emit-expr (begin)
# emit-begin
#   expr=(begin)
#   env=((f6639 . -12) (f6639 . -8) (#f . 16) ((begin (primitive-ref open-input-file) if (primitive-ref negative?) (begin (primitive-ref error) (primitive-ref open-input-file) input-port) #f) . 12) ((not (primitive-ref error)) . 8) (if . 4))
    jmp _L_40308
_L_40307:
# emit-expr #f
    movl $47, %eax     # immed #f
_L_40308:
# emit-tail-expr
# si=-16
# env=((f6639 . -12) (f6639 . -8) (#f . 16) ((begin (primitive-ref open-input-file) if (primitive-ref negative?) (begin (primitive-ref error) (primitive-ref open-input-file) input-port) #f) . 12) ((not (primitive-ref error)) . 8) (if . 4))
# expr=(begin (let ((f6645 (foreign-call "s_open" f6639))) (begin (if ((primitive-ref negative?) f6645) (begin ((primitive-ref error) ((primitive-ref string->symbol) "open-input-file") "open failed")) #f) (let ((f6649 (make-vector 8)) (f6648 1024)) (begin (vector-set! f6649 0 ((primitive-ref string->symbol) "input-port")) (vector-set! f6649 1 f6639) (vector-set! f6649 2 f6645) (vector-set! f6649 3 (make-string f6648)) (vector-set! f6649 4 0) (vector-set! f6649 5 f6648) (vector-set! f6649 6 #f) (vector-set! f6649 7 0) f6649)))))
# tail-begin (begin (let ((f6645 (foreign-call "s_open" f6639))) (begin (if ((primitive-ref negative?) f6645) (begin ((primitive-ref error) ((primitive-ref string->symbol) "open-input-file") "open failed")) #f) (let ((f6649 (make-vector 8)) (f6648 1024)) (begin (vector-set! f6649 0 ((primitive-ref string->symbol) "input-port")) (vector-set! f6649 1 f6639) (vector-set! f6649 2 f6645) (vector-set! f6649 3 (make-string f6648)) (vector-set! f6649 4 0) (vector-set! f6649 5 f6648) (vector-set! f6649 6 #f) (vector-set! f6649 7 0) f6649)))))
#   env=((f6639 . -12) (f6639 . -8) (#f . 16) ((begin (primitive-ref open-input-file) if (primitive-ref negative?) (begin (primitive-ref error) (primitive-ref open-input-file) input-port) #f) . 12) ((not (primitive-ref error)) . 8) (if . 4))
# emit-tail-expr
# si=-16
# env=((f6639 . -12) (f6639 . -8) (#f . 16) ((begin (primitive-ref open-input-file) if (primitive-ref negative?) (begin (primitive-ref error) (primitive-ref open-input-file) input-port) #f) . 12) ((not (primitive-ref error)) . 8) (if . 4))
# expr=(let ((f6645 (foreign-call "s_open" f6639))) (begin (if ((primitive-ref negative?) f6645) (begin ((primitive-ref error) ((primitive-ref string->symbol) "open-input-file") "open failed")) #f) (let ((f6649 (make-vector 8)) (f6648 1024)) (begin (vector-set! f6649 0 ((primitive-ref string->symbol) "input-port")) (vector-set! f6649 1 f6639) (vector-set! f6649 2 f6645) (vector-set! f6649 3 (make-string f6648)) (vector-set! f6649 4 0) (vector-set! f6649 5 f6648) (vector-set! f6649 6 #f) (vector-set! f6649 7 0) f6649))))
# emit-tail-let
#  si   = -16
#  env  = ((f6639 . -12) (f6639 . -8) (#f . 16) ((begin (primitive-ref open-input-file) if (primitive-ref negative?) (begin (primitive-ref error) (primitive-ref open-input-file) input-port) #f) . 12) ((not (primitive-ref error)) . 8) (if . 4))
#  bindings = ((f6645 (foreign-call "s_open" f6639)))
#  body = (begin (if ((primitive-ref negative?) f6645) (begin ((primitive-ref error) ((primitive-ref string->symbol) "open-input-file") "open failed")) #f) (let ((f6649 (make-vector 8)) (f6648 1024)) (begin (vector-set! f6649 0 ((primitive-ref string->symbol) "input-port")) (vector-set! f6649 1 f6639) (vector-set! f6649 2 f6645) (vector-set! f6649 3 (make-string f6648)) (vector-set! f6649 4 0) (vector-set! f6649 5 f6648) (vector-set! f6649 6 #f) (vector-set! f6649 7 0) f6649)))
# emit-expr (foreign-call "s_open" f6639)
    movl %ecx,-16(%esp)
    movl %esp,-20(%esp)
# emit-expr f6639
# emit-variable-ref
# env=((f6639 . -12) (f6639 . -8) (#f . 16) ((begin (primitive-ref open-input-file) if (primitive-ref negative?) (begin (primitive-ref error) (primitive-ref open-input-file) input-port) #f) . 12) ((not (primitive-ref error)) . 8) (if . 4))
# var=f6639
    movl -12(%esp), %eax  # stack load f6639
# end emit-variable-ref
    movl %eax, -24(%esp)
    leal -24(%esp),%edi
    movl %edi,%esi
    andl $-16,%esi
    movl 0(%edi),%eax
    movl %eax,0(%esi)
    movl 4(%edi),%eax
    movl %eax,4(%esi)
    movl %esi,%esp
    .extern _s_open
    call _s_open
    movl 4(%esi),%esp
    movl -16(%esp),%ecx
    movl %eax, -16(%esp)  # stack save
# emit-tail-expr
# si=-20
# env=((f6645 . -16) (f6639 . -12) (f6639 . -8) (#f . 16) ((begin (primitive-ref open-input-file) if (primitive-ref negative?) (begin (primitive-ref error) (primitive-ref open-input-file) input-port) #f) . 12) ((not (primitive-ref error)) . 8) (if . 4))
# expr=(begin (if ((primitive-ref negative?) f6645) (begin ((primitive-ref error) ((primitive-ref string->symbol) "open-input-file") "open failed")) #f) (let ((f6649 (make-vector 8)) (f6648 1024)) (begin (vector-set! f6649 0 ((primitive-ref string->symbol) "input-port")) (vector-set! f6649 1 f6639) (vector-set! f6649 2 f6645) (vector-set! f6649 3 (make-string f6648)) (vector-set! f6649 4 0) (vector-set! f6649 5 f6648) (vector-set! f6649 6 #f) (vector-set! f6649 7 0) f6649)))
# tail-begin (begin (if ((primitive-ref negative?) f6645) (begin ((primitive-ref error) ((primitive-ref string->symbol) "open-input-file") "open failed")) #f) (let ((f6649 (make-vector 8)) (f6648 1024)) (begin (vector-set! f6649 0 ((primitive-ref string->symbol) "input-port")) (vector-set! f6649 1 f6639) (vector-set! f6649 2 f6645) (vector-set! f6649 3 (make-string f6648)) (vector-set! f6649 4 0) (vector-set! f6649 5 f6648) (vector-set! f6649 6 #f) (vector-set! f6649 7 0) f6649)))
#   env=((f6645 . -16) (f6639 . -12) (f6639 . -8) (#f . 16) ((begin (primitive-ref open-input-file) if (primitive-ref negative?) (begin (primitive-ref error) (primitive-ref open-input-file) input-port) #f) . 12) ((not (primitive-ref error)) . 8) (if . 4))
# emit-expr (if ((primitive-ref negative?) f6645) (begin ((primitive-ref error) ((primitive-ref string->symbol) "open-input-file") "open failed")) #f)
# emit-expr ((primitive-ref negative?) f6645)
# funcall
#    si   =-20
#    env  = ((f6645 . -16) (f6639 . -12) (f6639 . -8) (#f . 16) ((begin (primitive-ref open-input-file) if (primitive-ref negative?) (begin (primitive-ref error) (primitive-ref open-input-file) input-port) #f) . 12) ((not (primitive-ref error)) . 8) (if . 4))
#    expr = (funcall (primitive-ref negative?) f6645)
# emit-expr (primitive-ref negative?)
    .extern mrc_negative$q
    movl mrc_negative$q,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_40317"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_40317":
   movl %eax,  -28(%esp)  # stash funcall-oper in closure slot
# emit-expr f6645
# emit-variable-ref
# env=((f6645 . -16) (f6639 . -12) (f6639 . -8) (#f . 16) ((begin (primitive-ref open-input-file) if (primitive-ref negative?) (begin (primitive-ref error) (primitive-ref open-input-file) input-port) #f) . 12) ((not (primitive-ref error)) . 8) (if . 4))
# var=f6645
    movl -16(%esp), %eax  # stack load f6645
# end emit-variable-ref
    mov %eax, -32(%esp)  # arg f6645
    movl -28(%esp), %edi   # load new closure to %edi
    add $-20, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $20, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    cmp $47, %al
    je _L_40315
# emit-expr (begin ((primitive-ref error) ((primitive-ref string->symbol) "open-input-file") "open failed"))
# emit-begin
#   expr=(begin ((primitive-ref error) ((primitive-ref string->symbol) "open-input-file") "open failed"))
#   env=((f6645 . -16) (f6639 . -12) (f6639 . -8) (#f . 16) ((begin (primitive-ref open-input-file) if (primitive-ref negative?) (begin (primitive-ref error) (primitive-ref open-input-file) input-port) #f) . 12) ((not (primitive-ref error)) . 8) (if . 4))
# emit-expr ((primitive-ref error) ((primitive-ref string->symbol) "open-input-file") "open failed")
# funcall
#    si   =-20
#    env  = ((f6645 . -16) (f6639 . -12) (f6639 . -8) (#f . 16) ((begin (primitive-ref open-input-file) if (primitive-ref negative?) (begin (primitive-ref error) (primitive-ref open-input-file) input-port) #f) . 12) ((not (primitive-ref error)) . 8) (if . 4))
#    expr = (funcall (primitive-ref error) ((primitive-ref string->symbol) "open-input-file") "open failed")
# emit-expr (primitive-ref error)
    .extern mrc_error
    movl mrc_error,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_40318"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_40318":
   movl %eax,  -28(%esp)  # stash funcall-oper in closure slot
# emit-expr ((primitive-ref string->symbol) "open-input-file")
# funcall
#    si   =-32
#    env  = ((f6645 . -16) (f6639 . -12) (f6639 . -8) (#f . 16) ((begin (primitive-ref open-input-file) if (primitive-ref negative?) (begin (primitive-ref error) (primitive-ref open-input-file) input-port) #f) . 12) ((not (primitive-ref error)) . 8) (if . 4))
#    expr = (funcall (primitive-ref string->symbol) "open-input-file")
# emit-expr (primitive-ref string->symbol)
    .extern mrc_string$m$gsymbol
    movl mrc_string$m$gsymbol,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_40319"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_40319":
   movl %eax,  -40(%esp)  # stash funcall-oper in closure slot
# emit-expr "open-input-file"
# string literal
    jmp _L_40321
    .align 8,0x90
_L_40320 :
    .int 60
    .ascii "open-input-file"
_L_40321:
    movl $_L_40320, %eax
    orl $6, %eax
    mov %eax, -44(%esp)  # arg open-input-file
    movl -40(%esp), %edi   # load new closure to %edi
    add $-32, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $32, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    mov %eax, -32(%esp)  # arg ((primitive-ref string->symbol) open-input-file)
# emit-expr "open failed"
# string literal
    jmp _L_40323
    .align 8,0x90
_L_40322 :
    .int 44
    .ascii "open failed"
_L_40323:
    movl $_L_40322, %eax
    orl $6, %eax
    mov %eax, -36(%esp)  # arg open failed
    movl -28(%esp), %edi   # load new closure to %edi
    add $-20, %esp   # adjust base
    movl $8,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $20, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
# emit-expr (begin)
# emit-begin
#   expr=(begin)
#   env=((f6645 . -16) (f6639 . -12) (f6639 . -8) (#f . 16) ((begin (primitive-ref open-input-file) if (primitive-ref negative?) (begin (primitive-ref error) (primitive-ref open-input-file) input-port) #f) . 12) ((not (primitive-ref error)) . 8) (if . 4))
    jmp _L_40316
_L_40315:
# emit-expr #f
    movl $47, %eax     # immed #f
_L_40316:
# emit-tail-expr
# si=-20
# env=((f6645 . -16) (f6639 . -12) (f6639 . -8) (#f . 16) ((begin (primitive-ref open-input-file) if (primitive-ref negative?) (begin (primitive-ref error) (primitive-ref open-input-file) input-port) #f) . 12) ((not (primitive-ref error)) . 8) (if . 4))
# expr=(begin (let ((f6649 (make-vector 8)) (f6648 1024)) (begin (vector-set! f6649 0 ((primitive-ref string->symbol) "input-port")) (vector-set! f6649 1 f6639) (vector-set! f6649 2 f6645) (vector-set! f6649 3 (make-string f6648)) (vector-set! f6649 4 0) (vector-set! f6649 5 f6648) (vector-set! f6649 6 #f) (vector-set! f6649 7 0) f6649)))
# tail-begin (begin (let ((f6649 (make-vector 8)) (f6648 1024)) (begin (vector-set! f6649 0 ((primitive-ref string->symbol) "input-port")) (vector-set! f6649 1 f6639) (vector-set! f6649 2 f6645) (vector-set! f6649 3 (make-string f6648)) (vector-set! f6649 4 0) (vector-set! f6649 5 f6648) (vector-set! f6649 6 #f) (vector-set! f6649 7 0) f6649)))
#   env=((f6645 . -16) (f6639 . -12) (f6639 . -8) (#f . 16) ((begin (primitive-ref open-input-file) if (primitive-ref negative?) (begin (primitive-ref error) (primitive-ref open-input-file) input-port) #f) . 12) ((not (primitive-ref error)) . 8) (if . 4))
# emit-tail-expr
# si=-20
# env=((f6645 . -16) (f6639 . -12) (f6639 . -8) (#f . 16) ((begin (primitive-ref open-input-file) if (primitive-ref negative?) (begin (primitive-ref error) (primitive-ref open-input-file) input-port) #f) . 12) ((not (primitive-ref error)) . 8) (if . 4))
# expr=(let ((f6649 (make-vector 8)) (f6648 1024)) (begin (vector-set! f6649 0 ((primitive-ref string->symbol) "input-port")) (vector-set! f6649 1 f6639) (vector-set! f6649 2 f6645) (vector-set! f6649 3 (make-string f6648)) (vector-set! f6649 4 0) (vector-set! f6649 5 f6648) (vector-set! f6649 6 #f) (vector-set! f6649 7 0) f6649))
# emit-tail-let
#  si   = -20
#  env  = ((f6645 . -16) (f6639 . -12) (f6639 . -8) (#f . 16) ((begin (primitive-ref open-input-file) if (primitive-ref negative?) (begin (primitive-ref error) (primitive-ref open-input-file) input-port) #f) . 12) ((not (primitive-ref error)) . 8) (if . 4))
#  bindings = ((f6649 (make-vector 8)) (f6648 1024))
#  body = (begin (vector-set! f6649 0 ((primitive-ref string->symbol) "input-port")) (vector-set! f6649 1 f6639) (vector-set! f6649 2 f6645) (vector-set! f6649 3 (make-string f6648)) (vector-set! f6649 4 0) (vector-set! f6649 5 f6648) (vector-set! f6649 6 #f) (vector-set! f6649 7 0) f6649)
# emit-expr (make-vector 8)
# make-vector 8
# emit-expr 8
    movl $32, %eax     # immed 8
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_40324"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_40324:
# check the argument is a fixnum >= 0
    cmp $0,%eax
    jge _L_40325
# invoke error handler eh_length
    .extern mrc_eh$ulength
    movl mrc_eh$ulength, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_40325:
    movl %eax, %esi
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    orl  $5, %eax
    addl $4, %esi
    addl $4, %esi
    andl $-8, %esi
    addl %esi, %ebp
    movl %eax, -20(%esp)  # stack save
# emit-expr 1024
    movl $4096, %eax     # immed 1024
    movl %eax, -24(%esp)  # stack save
# emit-tail-expr
# si=-28
# env=((f6648 . -24) (f6649 . -20) (f6645 . -16) (f6639 . -12) (f6639 . -8) (#f . 16) ((begin (primitive-ref open-input-file) if (primitive-ref negative?) (begin (primitive-ref error) (primitive-ref open-input-file) input-port) #f) . 12) ((not (primitive-ref error)) . 8) (if . 4))
# expr=(begin (vector-set! f6649 0 ((primitive-ref string->symbol) "input-port")) (vector-set! f6649 1 f6639) (vector-set! f6649 2 f6645) (vector-set! f6649 3 (make-string f6648)) (vector-set! f6649 4 0) (vector-set! f6649 5 f6648) (vector-set! f6649 6 #f) (vector-set! f6649 7 0) f6649)
# tail-begin (begin (vector-set! f6649 0 ((primitive-ref string->symbol) "input-port")) (vector-set! f6649 1 f6639) (vector-set! f6649 2 f6645) (vector-set! f6649 3 (make-string f6648)) (vector-set! f6649 4 0) (vector-set! f6649 5 f6648) (vector-set! f6649 6 #f) (vector-set! f6649 7 0) f6649)
#   env=((f6648 . -24) (f6649 . -20) (f6645 . -16) (f6639 . -12) (f6639 . -8) (#f . 16) ((begin (primitive-ref open-input-file) if (primitive-ref negative?) (begin (primitive-ref error) (primitive-ref open-input-file) input-port) #f) . 12) ((not (primitive-ref error)) . 8) (if . 4))
# emit-expr (vector-set! f6649 0 ((primitive-ref string->symbol) "input-port"))
# emit-expr f6649
# emit-variable-ref
# env=((f6648 . -24) (f6649 . -20) (f6645 . -16) (f6639 . -12) (f6639 . -8) (#f . 16) ((begin (primitive-ref open-input-file) if (primitive-ref negative?) (begin (primitive-ref error) (primitive-ref open-input-file) input-port) #f) . 12) ((not (primitive-ref error)) . 8) (if . 4))
# var=f6649
    movl -20(%esp), %eax  # stack load f6649
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_40326
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_40326:
    movl %eax, -28(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_40327"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_40327:
# check bounds on vector index
    movl -28(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_40329
    cmp  $0,%eax
    jge _L_40328
_L_40329:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_40328:
    movl %eax, -32(%esp)
# emit-expr ((primitive-ref string->symbol) "input-port")
# funcall
#    si   =-36
#    env  = ((f6648 . -24) (f6649 . -20) (f6645 . -16) (f6639 . -12) (f6639 . -8) (#f . 16) ((begin (primitive-ref open-input-file) if (primitive-ref negative?) (begin (primitive-ref error) (primitive-ref open-input-file) input-port) #f) . 12) ((not (primitive-ref error)) . 8) (if . 4))
#    expr = (funcall (primitive-ref string->symbol) "input-port")
# emit-expr (primitive-ref string->symbol)
    .extern mrc_string$m$gsymbol
    movl mrc_string$m$gsymbol,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_40330"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_40330":
   movl %eax,  -44(%esp)  # stash funcall-oper in closure slot
# emit-expr "input-port"
# string literal
    jmp _L_40332
    .align 8,0x90
_L_40331 :
    .int 40
    .ascii "input-port"
_L_40332:
    movl $_L_40331, %eax
    orl $6, %eax
    mov %eax, -48(%esp)  # arg input-port
    movl -44(%esp), %edi   # load new closure to %edi
    add $-36, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $36, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    movl -28(%esp), %ebx
    movl -32(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-tail-expr
# si=-28
# env=((f6648 . -24) (f6649 . -20) (f6645 . -16) (f6639 . -12) (f6639 . -8) (#f . 16) ((begin (primitive-ref open-input-file) if (primitive-ref negative?) (begin (primitive-ref error) (primitive-ref open-input-file) input-port) #f) . 12) ((not (primitive-ref error)) . 8) (if . 4))
# expr=(begin (vector-set! f6649 1 f6639) (vector-set! f6649 2 f6645) (vector-set! f6649 3 (make-string f6648)) (vector-set! f6649 4 0) (vector-set! f6649 5 f6648) (vector-set! f6649 6 #f) (vector-set! f6649 7 0) f6649)
# tail-begin (begin (vector-set! f6649 1 f6639) (vector-set! f6649 2 f6645) (vector-set! f6649 3 (make-string f6648)) (vector-set! f6649 4 0) (vector-set! f6649 5 f6648) (vector-set! f6649 6 #f) (vector-set! f6649 7 0) f6649)
#   env=((f6648 . -24) (f6649 . -20) (f6645 . -16) (f6639 . -12) (f6639 . -8) (#f . 16) ((begin (primitive-ref open-input-file) if (primitive-ref negative?) (begin (primitive-ref error) (primitive-ref open-input-file) input-port) #f) . 12) ((not (primitive-ref error)) . 8) (if . 4))
# emit-expr (vector-set! f6649 1 f6639)
# emit-expr f6649
# emit-variable-ref
# env=((f6648 . -24) (f6649 . -20) (f6645 . -16) (f6639 . -12) (f6639 . -8) (#f . 16) ((begin (primitive-ref open-input-file) if (primitive-ref negative?) (begin (primitive-ref error) (primitive-ref open-input-file) input-port) #f) . 12) ((not (primitive-ref error)) . 8) (if . 4))
# var=f6649
    movl -20(%esp), %eax  # stack load f6649
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_40333
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_40333:
    movl %eax, -28(%esp)
# emit-expr 1
    movl $4, %eax     # immed 1
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_40334"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_40334:
# check bounds on vector index
    movl -28(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_40336
    cmp  $0,%eax
    jge _L_40335
_L_40336:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_40335:
    movl %eax, -32(%esp)
# emit-expr f6639
# emit-variable-ref
# env=((f6648 . -24) (f6649 . -20) (f6645 . -16) (f6639 . -12) (f6639 . -8) (#f . 16) ((begin (primitive-ref open-input-file) if (primitive-ref negative?) (begin (primitive-ref error) (primitive-ref open-input-file) input-port) #f) . 12) ((not (primitive-ref error)) . 8) (if . 4))
# var=f6639
    movl -12(%esp), %eax  # stack load f6639
# end emit-variable-ref
    movl -28(%esp), %ebx
    movl -32(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-tail-expr
# si=-28
# env=((f6648 . -24) (f6649 . -20) (f6645 . -16) (f6639 . -12) (f6639 . -8) (#f . 16) ((begin (primitive-ref open-input-file) if (primitive-ref negative?) (begin (primitive-ref error) (primitive-ref open-input-file) input-port) #f) . 12) ((not (primitive-ref error)) . 8) (if . 4))
# expr=(begin (vector-set! f6649 2 f6645) (vector-set! f6649 3 (make-string f6648)) (vector-set! f6649 4 0) (vector-set! f6649 5 f6648) (vector-set! f6649 6 #f) (vector-set! f6649 7 0) f6649)
# tail-begin (begin (vector-set! f6649 2 f6645) (vector-set! f6649 3 (make-string f6648)) (vector-set! f6649 4 0) (vector-set! f6649 5 f6648) (vector-set! f6649 6 #f) (vector-set! f6649 7 0) f6649)
#   env=((f6648 . -24) (f6649 . -20) (f6645 . -16) (f6639 . -12) (f6639 . -8) (#f . 16) ((begin (primitive-ref open-input-file) if (primitive-ref negative?) (begin (primitive-ref error) (primitive-ref open-input-file) input-port) #f) . 12) ((not (primitive-ref error)) . 8) (if . 4))
# emit-expr (vector-set! f6649 2 f6645)
# emit-expr f6649
# emit-variable-ref
# env=((f6648 . -24) (f6649 . -20) (f6645 . -16) (f6639 . -12) (f6639 . -8) (#f . 16) ((begin (primitive-ref open-input-file) if (primitive-ref negative?) (begin (primitive-ref error) (primitive-ref open-input-file) input-port) #f) . 12) ((not (primitive-ref error)) . 8) (if . 4))
# var=f6649
    movl -20(%esp), %eax  # stack load f6649
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_40337
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_40337:
    movl %eax, -28(%esp)
# emit-expr 2
    movl $8, %eax     # immed 2
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_40338"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_40338:
# check bounds on vector index
    movl -28(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_40340
    cmp  $0,%eax
    jge _L_40339
_L_40340:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_40339:
    movl %eax, -32(%esp)
# emit-expr f6645
# emit-variable-ref
# env=((f6648 . -24) (f6649 . -20) (f6645 . -16) (f6639 . -12) (f6639 . -8) (#f . 16) ((begin (primitive-ref open-input-file) if (primitive-ref negative?) (begin (primitive-ref error) (primitive-ref open-input-file) input-port) #f) . 12) ((not (primitive-ref error)) . 8) (if . 4))
# var=f6645
    movl -16(%esp), %eax  # stack load f6645
# end emit-variable-ref
    movl -28(%esp), %ebx
    movl -32(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-tail-expr
# si=-28
# env=((f6648 . -24) (f6649 . -20) (f6645 . -16) (f6639 . -12) (f6639 . -8) (#f . 16) ((begin (primitive-ref open-input-file) if (primitive-ref negative?) (begin (primitive-ref error) (primitive-ref open-input-file) input-port) #f) . 12) ((not (primitive-ref error)) . 8) (if . 4))
# expr=(begin (vector-set! f6649 3 (make-string f6648)) (vector-set! f6649 4 0) (vector-set! f6649 5 f6648) (vector-set! f6649 6 #f) (vector-set! f6649 7 0) f6649)
# tail-begin (begin (vector-set! f6649 3 (make-string f6648)) (vector-set! f6649 4 0) (vector-set! f6649 5 f6648) (vector-set! f6649 6 #f) (vector-set! f6649 7 0) f6649)
#   env=((f6648 . -24) (f6649 . -20) (f6645 . -16) (f6639 . -12) (f6639 . -8) (#f . 16) ((begin (primitive-ref open-input-file) if (primitive-ref negative?) (begin (primitive-ref error) (primitive-ref open-input-file) input-port) #f) . 12) ((not (primitive-ref error)) . 8) (if . 4))
# emit-expr (vector-set! f6649 3 (make-string f6648))
# emit-expr f6649
# emit-variable-ref
# env=((f6648 . -24) (f6649 . -20) (f6645 . -16) (f6639 . -12) (f6639 . -8) (#f . 16) ((begin (primitive-ref open-input-file) if (primitive-ref negative?) (begin (primitive-ref error) (primitive-ref open-input-file) input-port) #f) . 12) ((not (primitive-ref error)) . 8) (if . 4))
# var=f6649
    movl -20(%esp), %eax  # stack load f6649
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_40341
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_40341:
    movl %eax, -28(%esp)
# emit-expr 3
    movl $12, %eax     # immed 3
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_40342"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_40342:
# check bounds on vector index
    movl -28(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_40344
    cmp  $0,%eax
    jge _L_40343
_L_40344:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_40343:
    movl %eax, -32(%esp)
# emit-expr (make-string f6648)
# make-string len=f6648
# emit-expr f6648
# emit-variable-ref
# env=((f6648 . -24) (f6649 . -20) (f6645 . -16) (f6639 . -12) (f6639 . -8) (#f . 16) ((begin (primitive-ref open-input-file) if (primitive-ref negative?) (begin (primitive-ref error) (primitive-ref open-input-file) input-port) #f) . 12) ((not (primitive-ref error)) . 8) (if . 4))
# var=f6648
    movl -24(%esp), %eax  # stack load f6648
# end emit-variable-ref
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_40345"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $152,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_40345:
# check the argument is a fixnum >= 0
    cmp $0,%eax
    jge _L_40346
# invoke error handler eh_length
    .extern mrc_eh$ulength
    movl mrc_eh$ulength, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $152,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_40346:
    movl %eax, %esi
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    orl $6, %eax
    sar $2, %esi
    add $4, %esi
    add $7, %esi
    andl $-8, %esi
    add  %esi, %ebp
# make-string end
    movl -28(%esp), %ebx
    movl -32(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-tail-expr
# si=-28
# env=((f6648 . -24) (f6649 . -20) (f6645 . -16) (f6639 . -12) (f6639 . -8) (#f . 16) ((begin (primitive-ref open-input-file) if (primitive-ref negative?) (begin (primitive-ref error) (primitive-ref open-input-file) input-port) #f) . 12) ((not (primitive-ref error)) . 8) (if . 4))
# expr=(begin (vector-set! f6649 4 0) (vector-set! f6649 5 f6648) (vector-set! f6649 6 #f) (vector-set! f6649 7 0) f6649)
# tail-begin (begin (vector-set! f6649 4 0) (vector-set! f6649 5 f6648) (vector-set! f6649 6 #f) (vector-set! f6649 7 0) f6649)
#   env=((f6648 . -24) (f6649 . -20) (f6645 . -16) (f6639 . -12) (f6639 . -8) (#f . 16) ((begin (primitive-ref open-input-file) if (primitive-ref negative?) (begin (primitive-ref error) (primitive-ref open-input-file) input-port) #f) . 12) ((not (primitive-ref error)) . 8) (if . 4))
# emit-expr (vector-set! f6649 4 0)
# emit-expr f6649
# emit-variable-ref
# env=((f6648 . -24) (f6649 . -20) (f6645 . -16) (f6639 . -12) (f6639 . -8) (#f . 16) ((begin (primitive-ref open-input-file) if (primitive-ref negative?) (begin (primitive-ref error) (primitive-ref open-input-file) input-port) #f) . 12) ((not (primitive-ref error)) . 8) (if . 4))
# var=f6649
    movl -20(%esp), %eax  # stack load f6649
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_40347
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_40347:
    movl %eax, -28(%esp)
# emit-expr 4
    movl $16, %eax     # immed 4
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_40348"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_40348:
# check bounds on vector index
    movl -28(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_40350
    cmp  $0,%eax
    jge _L_40349
_L_40350:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_40349:
    movl %eax, -32(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
    movl -28(%esp), %ebx
    movl -32(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-tail-expr
# si=-28
# env=((f6648 . -24) (f6649 . -20) (f6645 . -16) (f6639 . -12) (f6639 . -8) (#f . 16) ((begin (primitive-ref open-input-file) if (primitive-ref negative?) (begin (primitive-ref error) (primitive-ref open-input-file) input-port) #f) . 12) ((not (primitive-ref error)) . 8) (if . 4))
# expr=(begin (vector-set! f6649 5 f6648) (vector-set! f6649 6 #f) (vector-set! f6649 7 0) f6649)
# tail-begin (begin (vector-set! f6649 5 f6648) (vector-set! f6649 6 #f) (vector-set! f6649 7 0) f6649)
#   env=((f6648 . -24) (f6649 . -20) (f6645 . -16) (f6639 . -12) (f6639 . -8) (#f . 16) ((begin (primitive-ref open-input-file) if (primitive-ref negative?) (begin (primitive-ref error) (primitive-ref open-input-file) input-port) #f) . 12) ((not (primitive-ref error)) . 8) (if . 4))
# emit-expr (vector-set! f6649 5 f6648)
# emit-expr f6649
# emit-variable-ref
# env=((f6648 . -24) (f6649 . -20) (f6645 . -16) (f6639 . -12) (f6639 . -8) (#f . 16) ((begin (primitive-ref open-input-file) if (primitive-ref negative?) (begin (primitive-ref error) (primitive-ref open-input-file) input-port) #f) . 12) ((not (primitive-ref error)) . 8) (if . 4))
# var=f6649
    movl -20(%esp), %eax  # stack load f6649
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_40351
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_40351:
    movl %eax, -28(%esp)
# emit-expr 5
    movl $20, %eax     # immed 5
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_40352"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_40352:
# check bounds on vector index
    movl -28(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_40354
    cmp  $0,%eax
    jge _L_40353
_L_40354:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_40353:
    movl %eax, -32(%esp)
# emit-expr f6648
# emit-variable-ref
# env=((f6648 . -24) (f6649 . -20) (f6645 . -16) (f6639 . -12) (f6639 . -8) (#f . 16) ((begin (primitive-ref open-input-file) if (primitive-ref negative?) (begin (primitive-ref error) (primitive-ref open-input-file) input-port) #f) . 12) ((not (primitive-ref error)) . 8) (if . 4))
# var=f6648
    movl -24(%esp), %eax  # stack load f6648
# end emit-variable-ref
    movl -28(%esp), %ebx
    movl -32(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-tail-expr
# si=-28
# env=((f6648 . -24) (f6649 . -20) (f6645 . -16) (f6639 . -12) (f6639 . -8) (#f . 16) ((begin (primitive-ref open-input-file) if (primitive-ref negative?) (begin (primitive-ref error) (primitive-ref open-input-file) input-port) #f) . 12) ((not (primitive-ref error)) . 8) (if . 4))
# expr=(begin (vector-set! f6649 6 #f) (vector-set! f6649 7 0) f6649)
# tail-begin (begin (vector-set! f6649 6 #f) (vector-set! f6649 7 0) f6649)
#   env=((f6648 . -24) (f6649 . -20) (f6645 . -16) (f6639 . -12) (f6639 . -8) (#f . 16) ((begin (primitive-ref open-input-file) if (primitive-ref negative?) (begin (primitive-ref error) (primitive-ref open-input-file) input-port) #f) . 12) ((not (primitive-ref error)) . 8) (if . 4))
# emit-expr (vector-set! f6649 6 #f)
# emit-expr f6649
# emit-variable-ref
# env=((f6648 . -24) (f6649 . -20) (f6645 . -16) (f6639 . -12) (f6639 . -8) (#f . 16) ((begin (primitive-ref open-input-file) if (primitive-ref negative?) (begin (primitive-ref error) (primitive-ref open-input-file) input-port) #f) . 12) ((not (primitive-ref error)) . 8) (if . 4))
# var=f6649
    movl -20(%esp), %eax  # stack load f6649
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_40355
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_40355:
    movl %eax, -28(%esp)
# emit-expr 6
    movl $24, %eax     # immed 6
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_40356"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_40356:
# check bounds on vector index
    movl -28(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_40358
    cmp  $0,%eax
    jge _L_40357
_L_40358:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_40357:
    movl %eax, -32(%esp)
# emit-expr #f
    movl $47, %eax     # immed #f
    movl -28(%esp), %ebx
    movl -32(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-tail-expr
# si=-28
# env=((f6648 . -24) (f6649 . -20) (f6645 . -16) (f6639 . -12) (f6639 . -8) (#f . 16) ((begin (primitive-ref open-input-file) if (primitive-ref negative?) (begin (primitive-ref error) (primitive-ref open-input-file) input-port) #f) . 12) ((not (primitive-ref error)) . 8) (if . 4))
# expr=(begin (vector-set! f6649 7 0) f6649)
# tail-begin (begin (vector-set! f6649 7 0) f6649)
#   env=((f6648 . -24) (f6649 . -20) (f6645 . -16) (f6639 . -12) (f6639 . -8) (#f . 16) ((begin (primitive-ref open-input-file) if (primitive-ref negative?) (begin (primitive-ref error) (primitive-ref open-input-file) input-port) #f) . 12) ((not (primitive-ref error)) . 8) (if . 4))
# emit-expr (vector-set! f6649 7 0)
# emit-expr f6649
# emit-variable-ref
# env=((f6648 . -24) (f6649 . -20) (f6645 . -16) (f6639 . -12) (f6639 . -8) (#f . 16) ((begin (primitive-ref open-input-file) if (primitive-ref negative?) (begin (primitive-ref error) (primitive-ref open-input-file) input-port) #f) . 12) ((not (primitive-ref error)) . 8) (if . 4))
# var=f6649
    movl -20(%esp), %eax  # stack load f6649
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_40359
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_40359:
    movl %eax, -28(%esp)
# emit-expr 7
    movl $28, %eax     # immed 7
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_40360"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_40360:
# check bounds on vector index
    movl -28(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_40362
    cmp  $0,%eax
    jge _L_40361
_L_40362:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_40361:
    movl %eax, -32(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
    movl -28(%esp), %ebx
    movl -32(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-tail-expr
# si=-28
# env=((f6648 . -24) (f6649 . -20) (f6645 . -16) (f6639 . -12) (f6639 . -8) (#f . 16) ((begin (primitive-ref open-input-file) if (primitive-ref negative?) (begin (primitive-ref error) (primitive-ref open-input-file) input-port) #f) . 12) ((not (primitive-ref error)) . 8) (if . 4))
# expr=(begin f6649)
# tail-begin (begin f6649)
#   env=((f6648 . -24) (f6649 . -20) (f6645 . -16) (f6639 . -12) (f6639 . -8) (#f . 16) ((begin (primitive-ref open-input-file) if (primitive-ref negative?) (begin (primitive-ref error) (primitive-ref open-input-file) input-port) #f) . 12) ((not (primitive-ref error)) . 8) (if . 4))
# emit-tail-expr
# si=-28
# env=((f6648 . -24) (f6649 . -20) (f6645 . -16) (f6639 . -12) (f6639 . -8) (#f . 16) ((begin (primitive-ref open-input-file) if (primitive-ref negative?) (begin (primitive-ref error) (primitive-ref open-input-file) input-port) #f) . 12) ((not (primitive-ref error)) . 8) (if . 4))
# expr=f6649
# emit-tail-variable-ref
# emit-variable-ref
# env=((f6648 . -24) (f6649 . -20) (f6645 . -16) (f6639 . -12) (f6639 . -8) (#f . 16) ((begin (primitive-ref open-input-file) if (primitive-ref negative?) (begin (primitive-ref error) (primitive-ref open-input-file) input-port) #f) . 12) ((not (primitive-ref error)) . 8) (if . 4))
# var=f6649
    movl -20(%esp), %eax  # stack load f6649
# end emit-variable-ref
    ret
# end emit-tail-variable ref
     ret   # return thru stack
     ret   # return thru stack
     ret   # return thru stack
    .align 4,0x90
_L_40305:
     movl %eax, mrc_open$minput$mfile
# == explicit-begins  ==>
# (lambda args (let ((p (if (null? args) (current-input-port) (car args)))) (cond ((port-unread p) (let ((ch (port-unread p))) (unless (eof-object? (port-unread p)) (port-unread-clear p)) ch)) (else (begin (when (fx= (port-last p) (port-ndx p)) (fill-input-buffer p)) (if (port-unread p) (port-unread p) (let ((ch (string-ref (port-buf p) (port-ndx p)))) (port-ndx-add1 p) ch)))))))
# == eliminate-let*  ==>
# (lambda args (let ((p (if (null? args) (current-input-port) (car args)))) (cond ((port-unread p) (let ((ch (port-unread p))) (unless (eof-object? (port-unread p)) (port-unread-clear p)) ch)) (else (begin (when (fx= (port-last p) (port-ndx p)) (fill-input-buffer p)) (if (port-unread p) (port-unread p) (let ((ch (string-ref (port-buf p) (port-ndx p)))) (port-ndx-add1 p) ch)))))))
# == uniquify-variables  ==>
# (lambda f6650 (let ((f6656 (if (null? f6650) (current-input-port) (car f6650)))) (cond ((port-unread f6656) (let ((f6659 (port-unread f6656))) (unless (eof-object? (port-unread f6656)) (port-unread-clear f6656)))) (else (begin (when (fx= (port-last f6656) (port-ndx f6656)) (fill-input-buffer f6656)) (if (port-unread f6656) (port-unread f6656) (let ((f6660 (string-ref (port-buf f6656) (port-ndx f6656)))) (port-ndx-add1 f6656))))))))
# == vectorize-letrec  ==>
# (lambda f6650 (let ((f6656 (if (null? f6650) (current-input-port) (car f6650)))) (cond ((port-unread f6656) (let ((f6659 (port-unread f6656))) (unless (eof-object? (port-unread f6656)) (port-unread-clear f6656)))) (else (begin (when (fx= (port-last f6656) (port-ndx f6656)) (fill-input-buffer f6656)) (if (port-unread f6656) (port-unread f6656) (let ((f6660 (string-ref (port-buf f6656) (port-ndx f6656)))) (port-ndx-add1 f6656))))))))
# == eliminate-set!  ==>
# (lambda f6650 (let () (let ((f6656 (if (null? f6650) (current-input-port) (car f6650)))) (cond ((port-unread f6656) (let ((f6659 (port-unread f6656))) (unless (eof-object? (port-unread f6656)) (port-unread-clear f6656)))) (else (begin (when (fx= (port-last f6656) (port-ndx f6656)) (fill-input-buffer f6656)) (if (port-unread f6656) (port-unread f6656) (let ((f6660 (string-ref (port-buf f6656) (port-ndx f6656)))) (port-ndx-add1 f6656)))))))))
# == close-free-variables  ==>
# (closure f6650 (port-unread unless port-unread port-unread-clear else when port-last port-ndx fill-input-buffer port-unread port-unread port-ndx-add1) (let () (let ((f6656 (if (null? f6650) (current-input-port) (car f6650)))) (cond ((port-unread f6656) (let ((f6659 (port-unread f6656))) (unless (eof-object? (port-unread f6656)) (port-unread-clear f6656)))) (else (begin (when (fx= (port-last f6656) (port-ndx f6656)) (fill-input-buffer f6656)) (if (port-unread f6656) (port-unread f6656) (let ((f6660 (string-ref (port-buf f6656) (port-ndx f6656)))) (port-ndx-add1 f6656)))))))))
# == eliminate-quote  ==>
# (closure f6650 (port-unread unless port-unread port-unread-clear else when port-last port-ndx fill-input-buffer port-unread port-unread port-ndx-add1) (let () (let ((f6656 (if (null? f6650) (current-input-port) (car f6650)))) (cond ((port-unread f6656) (let ((f6659 (port-unread f6656))) (unless (eof-object? (port-unread f6656)) (port-unread-clear f6656)))) (else (begin (when (fx= (port-last f6656) (port-ndx f6656)) (fill-input-buffer f6656)) (if (port-unread f6656) (port-unread f6656) (let ((f6660 (string-ref (port-buf f6656) (port-ndx f6656)))) (port-ndx-add1 f6656)))))))))
# == eliminate-when/unless  ==>
# (closure f6650 (port-unread if (not port-unread) (begin port-unread-clear else if port-last (begin port-ndx fill-input-buffer port-unread port-unread port-ndx-add1) #f) #f) (let () (let ((f6656 (if (null? f6650) (current-input-port) (car f6650)))) (cond ((port-unread f6656) (let ((f6659 (port-unread f6656))) (if (not (eof-object? (port-unread f6656))) (begin (port-unread-clear f6656)) #f))) (else (begin (if (fx= (port-last f6656) (port-ndx f6656)) (begin (fill-input-buffer f6656)) #f) (if (port-unread f6656) (port-unread f6656) (let ((f6660 (string-ref (port-buf f6656) (port-ndx f6656)))) (port-ndx-add1 f6656)))))))))
# == eliminate-cond  ==>
# (closure f6650 (port-unread if (not port-unread) (begin port-unread-clear else if port-last (begin port-ndx fill-input-buffer port-unread port-unread port-ndx-add1) #f) #f) (let () (let ((f6656 (if (null? f6650) (current-input-port) (car f6650)))) (if (port-unread f6656) (let ((f6659 (port-unread f6656))) (if (not (eof-object? (port-unread f6656))) (begin (port-unread-clear f6656)) #f)) (begin (if (fx= (port-last f6656) (port-ndx f6656)) (begin (fill-input-buffer f6656)) #f) (if (port-unread f6656) (port-unread f6656) (let ((f6660 (string-ref (port-buf f6656) (port-ndx f6656)))) (port-ndx-add1 f6656))))))))
# == external-symbols  ==>
# (closure f6650 ((primitive-ref port-unread) if (not (primitive-ref port-unread)) (begin (primitive-ref port-unread-clear) else if (primitive-ref port-last) (begin (primitive-ref port-ndx) (primitive-ref fill-input-buffer) (primitive-ref port-unread) (primitive-ref port-unread) (primitive-ref port-ndx-add1)) #f) #f) (let () (let ((f6656 (if (null? f6650) ((primitive-ref current-input-port)) (car f6650)))) (if ((primitive-ref port-unread) f6656) (let ((f6659 ((primitive-ref port-unread) f6656))) (if (not (eof-object? ((primitive-ref port-unread) f6656))) (begin ((primitive-ref port-unread-clear) f6656)) #f)) (begin (if (fx= ((primitive-ref port-last) f6656) ((primitive-ref port-ndx) f6656)) (begin ((primitive-ref fill-input-buffer) f6656)) #f) (if ((primitive-ref port-unread) f6656) ((primitive-ref port-unread) f6656) (let ((f6660 (string-ref ((primitive-ref port-buf) f6656) ((primitive-ref port-ndx) f6656)))) ((primitive-ref port-ndx-add1) f6656))))))))
# emit-expr (closure f6650 ((primitive-ref port-unread) if (not (primitive-ref port-unread)) (begin (primitive-ref port-unread-clear) else if (primitive-ref port-last) (begin (primitive-ref port-ndx) (primitive-ref fill-input-buffer) (primitive-ref port-unread) (primitive-ref port-unread) (primitive-ref port-ndx-add1)) #f) #f) (let () (let ((f6656 (if (null? f6650) ((primitive-ref current-input-port)) (car f6650)))) (if ((primitive-ref port-unread) f6656) (let ((f6659 ((primitive-ref port-unread) f6656))) (if (not (eof-object? ((primitive-ref port-unread) f6656))) (begin ((primitive-ref port-unread-clear) f6656)) #f)) (begin (if (fx= ((primitive-ref port-last) f6656) ((primitive-ref port-ndx) f6656)) (begin ((primitive-ref fill-input-buffer) f6656)) #f) (if ((primitive-ref port-unread) f6656) ((primitive-ref port-unread) f6656) (let ((f6660 (string-ref ((primitive-ref port-buf) f6656) ((primitive-ref port-ndx) f6656)))) ((primitive-ref port-ndx-add1) f6656))))))))
# emit-closure
# si = 0
# env = ()
# expr = (closure f6650 ((primitive-ref port-unread) if (not (primitive-ref port-unread)) (begin (primitive-ref port-unread-clear) else if (primitive-ref port-last) (begin (primitive-ref port-ndx) (primitive-ref fill-input-buffer) (primitive-ref port-unread) (primitive-ref port-unread) (primitive-ref port-ndx-add1)) #f) #f) (let () (let ((f6656 (if (null? f6650) ((primitive-ref current-input-port)) (car f6650)))) (if ((primitive-ref port-unread) f6656) (let ((f6659 ((primitive-ref port-unread) f6656))) (if (not (eof-object? ((primitive-ref port-unread) f6656))) (begin ((primitive-ref port-unread-clear) f6656)) #f)) (begin (if (fx= ((primitive-ref port-last) f6656) ((primitive-ref port-ndx) f6656)) (begin ((primitive-ref fill-input-buffer) f6656)) #f) (if ((primitive-ref port-unread) f6656) ((primitive-ref port-unread) f6656) (let ((f6660 (string-ref ((primitive-ref port-buf) f6656) ((primitive-ref port-ndx) f6656)))) ((primitive-ref port-ndx-add1) f6656))))))))
    movl $_L_40363, 0(%ebp)  # closure label
# WARNING: free var (primitive-ref port-unread) not defined in the environmnet
# WARNING: free var if not defined in the environmnet
# WARNING: free var (not (primitive-ref port-unread)) not defined in the environmnet
# WARNING: free var (begin (primitive-ref port-unread-clear) else if (primitive-ref port-last) (begin (primitive-ref port-ndx) (primitive-ref fill-input-buffer) (primitive-ref port-unread) (primitive-ref port-unread) (primitive-ref port-ndx-add1)) #f) not defined in the environmnet
# WARNING: free var #f not defined in the environmnet
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $24, %ebp     # bump ebp
    jmp _L_40364            # jump around closure body
_L_40363:
# check argument count
    cmp $0,%eax
    jge _L_40365
# invoke error handler eh_argcount_min
    .extern mrc_eh$uargcount$umin
    movl mrc_eh$uargcount$umin, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_40365:
# emit-build-varargs-list
    movl $63, %esi       # args <- () 
    lea -4(%esp),%edi    # edi <- esp-4
    subl %eax, %edi      # edi <- esp-4-eax    addr of arg[K+N] on stack
_L_40367:
    lea -4(%esp),%ebx    # addr of arg[K] on stack
    cmp %edi, %ebx       # while edi <> esp+(si+4)
    je _L_40366
    movl (%edi),%ebx     # arg i -> car
    movl %ebx, 0(%ebp)
    movl %esi, 4(%ebp)  # esi -> cdr
    movl %ebp, %esi
    addl $1, %esi       # tag as pair
    addl $8,%ebp         # bump heap ptr
    addl $4,%edi         # move to next previous arg from the end
    jmp _L_40367
_L_40366:
    movl %esi, -8(%esp)  # set args
# emit-tail-expr
# si=-12
# env=((f6650 . -8) (#f . 20) ((begin (primitive-ref port-unread-clear) else if (primitive-ref port-last) (begin (primitive-ref port-ndx) (primitive-ref fill-input-buffer) (primitive-ref port-unread) (primitive-ref port-unread) (primitive-ref port-ndx-add1)) #f) . 16) ((not (primitive-ref port-unread)) . 12) (if . 8) ((primitive-ref port-unread) . 4))
# expr=(let () (let ((f6656 (if (null? f6650) ((primitive-ref current-input-port)) (car f6650)))) (if ((primitive-ref port-unread) f6656) (let ((f6659 ((primitive-ref port-unread) f6656))) (if (not (eof-object? ((primitive-ref port-unread) f6656))) (begin ((primitive-ref port-unread-clear) f6656)) #f)) (begin (if (fx= ((primitive-ref port-last) f6656) ((primitive-ref port-ndx) f6656)) (begin ((primitive-ref fill-input-buffer) f6656)) #f) (if ((primitive-ref port-unread) f6656) ((primitive-ref port-unread) f6656) (let ((f6660 (string-ref ((primitive-ref port-buf) f6656) ((primitive-ref port-ndx) f6656)))) ((primitive-ref port-ndx-add1) f6656)))))))
# emit-tail-let
#  si   = -12
#  env  = ((f6650 . -8) (#f . 20) ((begin (primitive-ref port-unread-clear) else if (primitive-ref port-last) (begin (primitive-ref port-ndx) (primitive-ref fill-input-buffer) (primitive-ref port-unread) (primitive-ref port-unread) (primitive-ref port-ndx-add1)) #f) . 16) ((not (primitive-ref port-unread)) . 12) (if . 8) ((primitive-ref port-unread) . 4))
#  bindings = ()
#  body = (let ((f6656 (if (null? f6650) ((primitive-ref current-input-port)) (car f6650)))) (if ((primitive-ref port-unread) f6656) (let ((f6659 ((primitive-ref port-unread) f6656))) (if (not (eof-object? ((primitive-ref port-unread) f6656))) (begin ((primitive-ref port-unread-clear) f6656)) #f)) (begin (if (fx= ((primitive-ref port-last) f6656) ((primitive-ref port-ndx) f6656)) (begin ((primitive-ref fill-input-buffer) f6656)) #f) (if ((primitive-ref port-unread) f6656) ((primitive-ref port-unread) f6656) (let ((f6660 (string-ref ((primitive-ref port-buf) f6656) ((primitive-ref port-ndx) f6656)))) ((primitive-ref port-ndx-add1) f6656))))))
# emit-tail-expr
# si=-12
# env=((f6650 . -8) (#f . 20) ((begin (primitive-ref port-unread-clear) else if (primitive-ref port-last) (begin (primitive-ref port-ndx) (primitive-ref fill-input-buffer) (primitive-ref port-unread) (primitive-ref port-unread) (primitive-ref port-ndx-add1)) #f) . 16) ((not (primitive-ref port-unread)) . 12) (if . 8) ((primitive-ref port-unread) . 4))
# expr=(let ((f6656 (if (null? f6650) ((primitive-ref current-input-port)) (car f6650)))) (if ((primitive-ref port-unread) f6656) (let ((f6659 ((primitive-ref port-unread) f6656))) (if (not (eof-object? ((primitive-ref port-unread) f6656))) (begin ((primitive-ref port-unread-clear) f6656)) #f)) (begin (if (fx= ((primitive-ref port-last) f6656) ((primitive-ref port-ndx) f6656)) (begin ((primitive-ref fill-input-buffer) f6656)) #f) (if ((primitive-ref port-unread) f6656) ((primitive-ref port-unread) f6656) (let ((f6660 (string-ref ((primitive-ref port-buf) f6656) ((primitive-ref port-ndx) f6656)))) ((primitive-ref port-ndx-add1) f6656))))))
# emit-tail-let
#  si   = -12
#  env  = ((f6650 . -8) (#f . 20) ((begin (primitive-ref port-unread-clear) else if (primitive-ref port-last) (begin (primitive-ref port-ndx) (primitive-ref fill-input-buffer) (primitive-ref port-unread) (primitive-ref port-unread) (primitive-ref port-ndx-add1)) #f) . 16) ((not (primitive-ref port-unread)) . 12) (if . 8) ((primitive-ref port-unread) . 4))
#  bindings = ((f6656 (if (null? f6650) ((primitive-ref current-input-port)) (car f6650))))
#  body = (if ((primitive-ref port-unread) f6656) (let ((f6659 ((primitive-ref port-unread) f6656))) (if (not (eof-object? ((primitive-ref port-unread) f6656))) (begin ((primitive-ref port-unread-clear) f6656)) #f)) (begin (if (fx= ((primitive-ref port-last) f6656) ((primitive-ref port-ndx) f6656)) (begin ((primitive-ref fill-input-buffer) f6656)) #f) (if ((primitive-ref port-unread) f6656) ((primitive-ref port-unread) f6656) (let ((f6660 (string-ref ((primitive-ref port-buf) f6656) ((primitive-ref port-ndx) f6656)))) ((primitive-ref port-ndx-add1) f6656)))))
# emit-expr (if (null? f6650) ((primitive-ref current-input-port)) (car f6650))
# emit-expr (null? f6650)
# emit-expr f6650
# emit-variable-ref
# env=((f6650 . -8) (#f . 20) ((begin (primitive-ref port-unread-clear) else if (primitive-ref port-last) (begin (primitive-ref port-ndx) (primitive-ref fill-input-buffer) (primitive-ref port-unread) (primitive-ref port-unread) (primitive-ref port-ndx-add1)) #f) . 16) ((not (primitive-ref port-unread)) . 12) (if . 8) ((primitive-ref port-unread) . 4))
# var=f6650
    movl -8(%esp), %eax  # stack load f6650
# end emit-variable-ref
    cmp $63, %eax
    mov $0, %eax
    sete %al
    movzbl %al, %eax
    sal $6, %al
    or $47, %al
    cmp $47, %al
    je _L_40368
# emit-expr ((primitive-ref current-input-port))
# funcall
#    si   =-12
#    env  = ((f6650 . -8) (#f . 20) ((begin (primitive-ref port-unread-clear) else if (primitive-ref port-last) (begin (primitive-ref port-ndx) (primitive-ref fill-input-buffer) (primitive-ref port-unread) (primitive-ref port-unread) (primitive-ref port-ndx-add1)) #f) . 16) ((not (primitive-ref port-unread)) . 12) (if . 8) ((primitive-ref port-unread) . 4))
#    expr = (funcall (primitive-ref current-input-port))
# emit-expr (primitive-ref current-input-port)
    .extern mrc_current$minput$mport
    movl mrc_current$minput$mport,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_40370"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_40370":
   movl %eax,  -20(%esp)  # stash funcall-oper in closure slot
    movl -20(%esp), %edi   # load new closure to %edi
    add $-12, %esp   # adjust base
    movl $0,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $12, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    jmp _L_40369
_L_40368:
# emit-expr (car f6650)
# emit-expr f6650
# emit-variable-ref
# env=((f6650 . -8) (#f . 20) ((begin (primitive-ref port-unread-clear) else if (primitive-ref port-last) (begin (primitive-ref port-ndx) (primitive-ref fill-input-buffer) (primitive-ref port-unread) (primitive-ref port-unread) (primitive-ref port-ndx-add1)) #f) . 16) ((not (primitive-ref port-unread)) . 12) (if . 8) ((primitive-ref port-unread) . 4))
# var=f6650
    movl -8(%esp), %eax  # stack load f6650
# end emit-variable-ref
# check the argument is a pair
    movl %eax,%ebx
    and $7, %bl
    cmp $1, %bl
    je _L_40371
# invoke error handler eh_pair
    .extern mrc_eh$upair
    movl mrc_eh$upair, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $116,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_40371:
    movl -1(%eax), %eax
_L_40369:
    movl %eax, -12(%esp)  # stack save
# emit-tail-expr
# si=-16
# env=((f6656 . -12) (f6650 . -8) (#f . 20) ((begin (primitive-ref port-unread-clear) else if (primitive-ref port-last) (begin (primitive-ref port-ndx) (primitive-ref fill-input-buffer) (primitive-ref port-unread) (primitive-ref port-unread) (primitive-ref port-ndx-add1)) #f) . 16) ((not (primitive-ref port-unread)) . 12) (if . 8) ((primitive-ref port-unread) . 4))
# expr=(if ((primitive-ref port-unread) f6656) (let ((f6659 ((primitive-ref port-unread) f6656))) (if (not (eof-object? ((primitive-ref port-unread) f6656))) (begin ((primitive-ref port-unread-clear) f6656)) #f)) (begin (if (fx= ((primitive-ref port-last) f6656) ((primitive-ref port-ndx) f6656)) (begin ((primitive-ref fill-input-buffer) f6656)) #f) (if ((primitive-ref port-unread) f6656) ((primitive-ref port-unread) f6656) (let ((f6660 (string-ref ((primitive-ref port-buf) f6656) ((primitive-ref port-ndx) f6656)))) ((primitive-ref port-ndx-add1) f6656)))))
# emit-expr ((primitive-ref port-unread) f6656)
# funcall
#    si   =-16
#    env  = ((f6656 . -12) (f6650 . -8) (#f . 20) ((begin (primitive-ref port-unread-clear) else if (primitive-ref port-last) (begin (primitive-ref port-ndx) (primitive-ref fill-input-buffer) (primitive-ref port-unread) (primitive-ref port-unread) (primitive-ref port-ndx-add1)) #f) . 16) ((not (primitive-ref port-unread)) . 12) (if . 8) ((primitive-ref port-unread) . 4))
#    expr = (funcall (primitive-ref port-unread) f6656)
# emit-expr (primitive-ref port-unread)
    .extern mrc_port$munread
    movl mrc_port$munread,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_40374"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_40374":
   movl %eax,  -24(%esp)  # stash funcall-oper in closure slot
# emit-expr f6656
# emit-variable-ref
# env=((f6656 . -12) (f6650 . -8) (#f . 20) ((begin (primitive-ref port-unread-clear) else if (primitive-ref port-last) (begin (primitive-ref port-ndx) (primitive-ref fill-input-buffer) (primitive-ref port-unread) (primitive-ref port-unread) (primitive-ref port-ndx-add1)) #f) . 16) ((not (primitive-ref port-unread)) . 12) (if . 8) ((primitive-ref port-unread) . 4))
# var=f6656
    movl -12(%esp), %eax  # stack load f6656
# end emit-variable-ref
    mov %eax, -28(%esp)  # arg f6656
    movl -24(%esp), %edi   # load new closure to %edi
    add $-16, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $16, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    cmp $47, %al
    je _L_40372
# emit-tail-expr
# si=-16
# env=((f6656 . -12) (f6650 . -8) (#f . 20) ((begin (primitive-ref port-unread-clear) else if (primitive-ref port-last) (begin (primitive-ref port-ndx) (primitive-ref fill-input-buffer) (primitive-ref port-unread) (primitive-ref port-unread) (primitive-ref port-ndx-add1)) #f) . 16) ((not (primitive-ref port-unread)) . 12) (if . 8) ((primitive-ref port-unread) . 4))
# expr=(let ((f6659 ((primitive-ref port-unread) f6656))) (if (not (eof-object? ((primitive-ref port-unread) f6656))) (begin ((primitive-ref port-unread-clear) f6656)) #f))
# emit-tail-let
#  si   = -16
#  env  = ((f6656 . -12) (f6650 . -8) (#f . 20) ((begin (primitive-ref port-unread-clear) else if (primitive-ref port-last) (begin (primitive-ref port-ndx) (primitive-ref fill-input-buffer) (primitive-ref port-unread) (primitive-ref port-unread) (primitive-ref port-ndx-add1)) #f) . 16) ((not (primitive-ref port-unread)) . 12) (if . 8) ((primitive-ref port-unread) . 4))
#  bindings = ((f6659 ((primitive-ref port-unread) f6656)))
#  body = (if (not (eof-object? ((primitive-ref port-unread) f6656))) (begin ((primitive-ref port-unread-clear) f6656)) #f)
# emit-expr ((primitive-ref port-unread) f6656)
# funcall
#    si   =-16
#    env  = ((f6656 . -12) (f6650 . -8) (#f . 20) ((begin (primitive-ref port-unread-clear) else if (primitive-ref port-last) (begin (primitive-ref port-ndx) (primitive-ref fill-input-buffer) (primitive-ref port-unread) (primitive-ref port-unread) (primitive-ref port-ndx-add1)) #f) . 16) ((not (primitive-ref port-unread)) . 12) (if . 8) ((primitive-ref port-unread) . 4))
#    expr = (funcall (primitive-ref port-unread) f6656)
# emit-expr (primitive-ref port-unread)
    .extern mrc_port$munread
    movl mrc_port$munread,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_40375"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_40375":
   movl %eax,  -24(%esp)  # stash funcall-oper in closure slot
# emit-expr f6656
# emit-variable-ref
# env=((f6656 . -12) (f6650 . -8) (#f . 20) ((begin (primitive-ref port-unread-clear) else if (primitive-ref port-last) (begin (primitive-ref port-ndx) (primitive-ref fill-input-buffer) (primitive-ref port-unread) (primitive-ref port-unread) (primitive-ref port-ndx-add1)) #f) . 16) ((not (primitive-ref port-unread)) . 12) (if . 8) ((primitive-ref port-unread) . 4))
# var=f6656
    movl -12(%esp), %eax  # stack load f6656
# end emit-variable-ref
    mov %eax, -28(%esp)  # arg f6656
    movl -24(%esp), %edi   # load new closure to %edi
    add $-16, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $16, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    movl %eax, -16(%esp)  # stack save
# emit-tail-expr
# si=-20
# env=((f6659 . -16) (f6656 . -12) (f6650 . -8) (#f . 20) ((begin (primitive-ref port-unread-clear) else if (primitive-ref port-last) (begin (primitive-ref port-ndx) (primitive-ref fill-input-buffer) (primitive-ref port-unread) (primitive-ref port-unread) (primitive-ref port-ndx-add1)) #f) . 16) ((not (primitive-ref port-unread)) . 12) (if . 8) ((primitive-ref port-unread) . 4))
# expr=(if (not (eof-object? ((primitive-ref port-unread) f6656))) (begin ((primitive-ref port-unread-clear) f6656)) #f)
# emit-expr (not (eof-object? ((primitive-ref port-unread) f6656)))
# emit-expr (eof-object? ((primitive-ref port-unread) f6656))
# emit-expr ((primitive-ref port-unread) f6656)
# funcall
#    si   =-20
#    env  = ((f6659 . -16) (f6656 . -12) (f6650 . -8) (#f . 20) ((begin (primitive-ref port-unread-clear) else if (primitive-ref port-last) (begin (primitive-ref port-ndx) (primitive-ref fill-input-buffer) (primitive-ref port-unread) (primitive-ref port-unread) (primitive-ref port-ndx-add1)) #f) . 16) ((not (primitive-ref port-unread)) . 12) (if . 8) ((primitive-ref port-unread) . 4))
#    expr = (funcall (primitive-ref port-unread) f6656)
# emit-expr (primitive-ref port-unread)
    .extern mrc_port$munread
    movl mrc_port$munread,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_40378"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_40378":
   movl %eax,  -28(%esp)  # stash funcall-oper in closure slot
# emit-expr f6656
# emit-variable-ref
# env=((f6659 . -16) (f6656 . -12) (f6650 . -8) (#f . 20) ((begin (primitive-ref port-unread-clear) else if (primitive-ref port-last) (begin (primitive-ref port-ndx) (primitive-ref fill-input-buffer) (primitive-ref port-unread) (primitive-ref port-unread) (primitive-ref port-ndx-add1)) #f) . 16) ((not (primitive-ref port-unread)) . 12) (if . 8) ((primitive-ref port-unread) . 4))
# var=f6656
    movl -12(%esp), %eax  # stack load f6656
# end emit-variable-ref
    mov %eax, -32(%esp)  # arg f6656
    movl -28(%esp), %edi   # load new closure to %edi
    add $-20, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $20, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    cmp $95, %eax
    mov $0, %eax
    sete %al
    movzbl %al, %eax
    sal $6, %al
    or $47, %al
    cmp $47, %eax
    sete %al
    movzbl %al, %eax
    sal $6, %al
    or $47, %al
    cmp $47, %al
    je _L_40376
# emit-tail-expr
# si=-20
# env=((f6659 . -16) (f6656 . -12) (f6650 . -8) (#f . 20) ((begin (primitive-ref port-unread-clear) else if (primitive-ref port-last) (begin (primitive-ref port-ndx) (primitive-ref fill-input-buffer) (primitive-ref port-unread) (primitive-ref port-unread) (primitive-ref port-ndx-add1)) #f) . 16) ((not (primitive-ref port-unread)) . 12) (if . 8) ((primitive-ref port-unread) . 4))
# expr=(begin ((primitive-ref port-unread-clear) f6656))
# tail-begin (begin ((primitive-ref port-unread-clear) f6656))
#   env=((f6659 . -16) (f6656 . -12) (f6650 . -8) (#f . 20) ((begin (primitive-ref port-unread-clear) else if (primitive-ref port-last) (begin (primitive-ref port-ndx) (primitive-ref fill-input-buffer) (primitive-ref port-unread) (primitive-ref port-unread) (primitive-ref port-ndx-add1)) #f) . 16) ((not (primitive-ref port-unread)) . 12) (if . 8) ((primitive-ref port-unread) . 4))
# emit-tail-expr
# si=-20
# env=((f6659 . -16) (f6656 . -12) (f6650 . -8) (#f . 20) ((begin (primitive-ref port-unread-clear) else if (primitive-ref port-last) (begin (primitive-ref port-ndx) (primitive-ref fill-input-buffer) (primitive-ref port-unread) (primitive-ref port-unread) (primitive-ref port-ndx-add1)) #f) . 16) ((not (primitive-ref port-unread)) . 12) (if . 8) ((primitive-ref port-unread) . 4))
# expr=((primitive-ref port-unread-clear) f6656)
# emit-tail-funcall
#    si   =-20
#    env  = ((f6659 . -16) (f6656 . -12) (f6650 . -8) (#f . 20) ((begin (primitive-ref port-unread-clear) else if (primitive-ref port-last) (begin (primitive-ref port-ndx) (primitive-ref fill-input-buffer) (primitive-ref port-unread) (primitive-ref port-unread) (primitive-ref port-ndx-add1)) #f) . 16) ((not (primitive-ref port-unread)) . 12) (if . 8) ((primitive-ref port-unread) . 4))
#    expr = (funcall (primitive-ref port-unread-clear) f6656)
# emit-expr (primitive-ref port-unread-clear)
    .extern mrc_port$munread$mclear
    movl mrc_port$munread$mclear,%eax
   movl %eax,  -20(%esp)  # stash funcall-oper in next closure slot
# emit-expr f6656
# emit-variable-ref
# env=((f6659 . -16) (f6656 . -12) (f6650 . -8) (#f . 20) ((begin (primitive-ref port-unread-clear) else if (primitive-ref port-last) (begin (primitive-ref port-ndx) (primitive-ref fill-input-buffer) (primitive-ref port-unread) (primitive-ref port-unread) (primitive-ref port-ndx-add1)) #f) . 16) ((not (primitive-ref port-unread)) . 12) (if . 8) ((primitive-ref port-unread) . 4))
# var=f6656
    movl -12(%esp), %eax  # stack load f6656
# end emit-variable-ref
    mov %eax, -24(%esp)    # arg f6656
    movl -20(%esp), %edi   # load new closure to %edi
# emit-shift-args:  size=2   si=-20  delta=16
    mov -20(%esp), %ebx  # shift frame cell
    mov %ebx, -4(%esp)  # down to base
# emit-shift-args:  size=1   si=-24  delta=16
    mov -24(%esp), %ebx  # shift frame cell
    mov %ebx, -8(%esp)  # down to base
# emit-shift-args:  size=0   si=-28  delta=16
    movl $4,%eax   # save arg count
    jmp *-2(%edi)  # tail-funcall
     ret   # return thru stack
    jmp _L_40377
_L_40376:
# emit-tail-expr
# si=-20
# env=((f6659 . -16) (f6656 . -12) (f6650 . -8) (#f . 20) ((begin (primitive-ref port-unread-clear) else if (primitive-ref port-last) (begin (primitive-ref port-ndx) (primitive-ref fill-input-buffer) (primitive-ref port-unread) (primitive-ref port-unread) (primitive-ref port-ndx-add1)) #f) . 16) ((not (primitive-ref port-unread)) . 12) (if . 8) ((primitive-ref port-unread) . 4))
# expr=#f
    movl $47, %eax     # immed #f
    ret                  # immediate tail return
_L_40377:
    jmp _L_40373
_L_40372:
# emit-tail-expr
# si=-16
# env=((f6656 . -12) (f6650 . -8) (#f . 20) ((begin (primitive-ref port-unread-clear) else if (primitive-ref port-last) (begin (primitive-ref port-ndx) (primitive-ref fill-input-buffer) (primitive-ref port-unread) (primitive-ref port-unread) (primitive-ref port-ndx-add1)) #f) . 16) ((not (primitive-ref port-unread)) . 12) (if . 8) ((primitive-ref port-unread) . 4))
# expr=(begin (if (fx= ((primitive-ref port-last) f6656) ((primitive-ref port-ndx) f6656)) (begin ((primitive-ref fill-input-buffer) f6656)) #f) (if ((primitive-ref port-unread) f6656) ((primitive-ref port-unread) f6656) (let ((f6660 (string-ref ((primitive-ref port-buf) f6656) ((primitive-ref port-ndx) f6656)))) ((primitive-ref port-ndx-add1) f6656))))
# tail-begin (begin (if (fx= ((primitive-ref port-last) f6656) ((primitive-ref port-ndx) f6656)) (begin ((primitive-ref fill-input-buffer) f6656)) #f) (if ((primitive-ref port-unread) f6656) ((primitive-ref port-unread) f6656) (let ((f6660 (string-ref ((primitive-ref port-buf) f6656) ((primitive-ref port-ndx) f6656)))) ((primitive-ref port-ndx-add1) f6656))))
#   env=((f6656 . -12) (f6650 . -8) (#f . 20) ((begin (primitive-ref port-unread-clear) else if (primitive-ref port-last) (begin (primitive-ref port-ndx) (primitive-ref fill-input-buffer) (primitive-ref port-unread) (primitive-ref port-unread) (primitive-ref port-ndx-add1)) #f) . 16) ((not (primitive-ref port-unread)) . 12) (if . 8) ((primitive-ref port-unread) . 4))
# emit-expr (if (fx= ((primitive-ref port-last) f6656) ((primitive-ref port-ndx) f6656)) (begin ((primitive-ref fill-input-buffer) f6656)) #f)
# emit-expr (fx= ((primitive-ref port-last) f6656) ((primitive-ref port-ndx) f6656))
# emit-expr ((primitive-ref port-ndx) f6656)
# funcall
#    si   =-16
#    env  = ((f6656 . -12) (f6650 . -8) (#f . 20) ((begin (primitive-ref port-unread-clear) else if (primitive-ref port-last) (begin (primitive-ref port-ndx) (primitive-ref fill-input-buffer) (primitive-ref port-unread) (primitive-ref port-unread) (primitive-ref port-ndx-add1)) #f) . 16) ((not (primitive-ref port-unread)) . 12) (if . 8) ((primitive-ref port-unread) . 4))
#    expr = (funcall (primitive-ref port-ndx) f6656)
# emit-expr (primitive-ref port-ndx)
    .extern mrc_port$mndx
    movl mrc_port$mndx,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_40381"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_40381":
   movl %eax,  -24(%esp)  # stash funcall-oper in closure slot
# emit-expr f6656
# emit-variable-ref
# env=((f6656 . -12) (f6650 . -8) (#f . 20) ((begin (primitive-ref port-unread-clear) else if (primitive-ref port-last) (begin (primitive-ref port-ndx) (primitive-ref fill-input-buffer) (primitive-ref port-unread) (primitive-ref port-unread) (primitive-ref port-ndx-add1)) #f) . 16) ((not (primitive-ref port-unread)) . 12) (if . 8) ((primitive-ref port-unread) . 4))
# var=f6656
    movl -12(%esp), %eax  # stack load f6656
# end emit-variable-ref
    mov %eax, -28(%esp)  # arg f6656
    movl -24(%esp), %edi   # load new closure to %edi
    add $-16, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $16, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_40382"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $68,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_40382:
    movl %eax, -16(%esp)
# emit-expr ((primitive-ref port-last) f6656)
# funcall
#    si   =-20
#    env  = ((f6656 . -12) (f6650 . -8) (#f . 20) ((begin (primitive-ref port-unread-clear) else if (primitive-ref port-last) (begin (primitive-ref port-ndx) (primitive-ref fill-input-buffer) (primitive-ref port-unread) (primitive-ref port-unread) (primitive-ref port-ndx-add1)) #f) . 16) ((not (primitive-ref port-unread)) . 12) (if . 8) ((primitive-ref port-unread) . 4))
#    expr = (funcall (primitive-ref port-last) f6656)
# emit-expr (primitive-ref port-last)
    .extern mrc_port$mlast
    movl mrc_port$mlast,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_40383"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_40383":
   movl %eax,  -28(%esp)  # stash funcall-oper in closure slot
# emit-expr f6656
# emit-variable-ref
# env=((f6656 . -12) (f6650 . -8) (#f . 20) ((begin (primitive-ref port-unread-clear) else if (primitive-ref port-last) (begin (primitive-ref port-ndx) (primitive-ref fill-input-buffer) (primitive-ref port-unread) (primitive-ref port-unread) (primitive-ref port-ndx-add1)) #f) . 16) ((not (primitive-ref port-unread)) . 12) (if . 8) ((primitive-ref port-unread) . 4))
# var=f6656
    movl -12(%esp), %eax  # stack load f6656
# end emit-variable-ref
    mov %eax, -32(%esp)  # arg f6656
    movl -28(%esp), %edi   # load new closure to %edi
    add $-20, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $20, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_40384"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $68,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_40384:
    cmp -16(%esp), %eax
    sete %al
    movzbl %al, %eax
    sal $6, %al
    or $47, %al
    cmp $47, %al
    je _L_40379
# emit-expr (begin ((primitive-ref fill-input-buffer) f6656))
# emit-begin
#   expr=(begin ((primitive-ref fill-input-buffer) f6656))
#   env=((f6656 . -12) (f6650 . -8) (#f . 20) ((begin (primitive-ref port-unread-clear) else if (primitive-ref port-last) (begin (primitive-ref port-ndx) (primitive-ref fill-input-buffer) (primitive-ref port-unread) (primitive-ref port-unread) (primitive-ref port-ndx-add1)) #f) . 16) ((not (primitive-ref port-unread)) . 12) (if . 8) ((primitive-ref port-unread) . 4))
# emit-expr ((primitive-ref fill-input-buffer) f6656)
# funcall
#    si   =-16
#    env  = ((f6656 . -12) (f6650 . -8) (#f . 20) ((begin (primitive-ref port-unread-clear) else if (primitive-ref port-last) (begin (primitive-ref port-ndx) (primitive-ref fill-input-buffer) (primitive-ref port-unread) (primitive-ref port-unread) (primitive-ref port-ndx-add1)) #f) . 16) ((not (primitive-ref port-unread)) . 12) (if . 8) ((primitive-ref port-unread) . 4))
#    expr = (funcall (primitive-ref fill-input-buffer) f6656)
# emit-expr (primitive-ref fill-input-buffer)
    .extern mrc_fill$minput$mbuffer
    movl mrc_fill$minput$mbuffer,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_40385"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_40385":
   movl %eax,  -24(%esp)  # stash funcall-oper in closure slot
# emit-expr f6656
# emit-variable-ref
# env=((f6656 . -12) (f6650 . -8) (#f . 20) ((begin (primitive-ref port-unread-clear) else if (primitive-ref port-last) (begin (primitive-ref port-ndx) (primitive-ref fill-input-buffer) (primitive-ref port-unread) (primitive-ref port-unread) (primitive-ref port-ndx-add1)) #f) . 16) ((not (primitive-ref port-unread)) . 12) (if . 8) ((primitive-ref port-unread) . 4))
# var=f6656
    movl -12(%esp), %eax  # stack load f6656
# end emit-variable-ref
    mov %eax, -28(%esp)  # arg f6656
    movl -24(%esp), %edi   # load new closure to %edi
    add $-16, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $16, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
# emit-expr (begin)
# emit-begin
#   expr=(begin)
#   env=((f6656 . -12) (f6650 . -8) (#f . 20) ((begin (primitive-ref port-unread-clear) else if (primitive-ref port-last) (begin (primitive-ref port-ndx) (primitive-ref fill-input-buffer) (primitive-ref port-unread) (primitive-ref port-unread) (primitive-ref port-ndx-add1)) #f) . 16) ((not (primitive-ref port-unread)) . 12) (if . 8) ((primitive-ref port-unread) . 4))
    jmp _L_40380
_L_40379:
# emit-expr #f
    movl $47, %eax     # immed #f
_L_40380:
# emit-tail-expr
# si=-16
# env=((f6656 . -12) (f6650 . -8) (#f . 20) ((begin (primitive-ref port-unread-clear) else if (primitive-ref port-last) (begin (primitive-ref port-ndx) (primitive-ref fill-input-buffer) (primitive-ref port-unread) (primitive-ref port-unread) (primitive-ref port-ndx-add1)) #f) . 16) ((not (primitive-ref port-unread)) . 12) (if . 8) ((primitive-ref port-unread) . 4))
# expr=(begin (if ((primitive-ref port-unread) f6656) ((primitive-ref port-unread) f6656) (let ((f6660 (string-ref ((primitive-ref port-buf) f6656) ((primitive-ref port-ndx) f6656)))) ((primitive-ref port-ndx-add1) f6656))))
# tail-begin (begin (if ((primitive-ref port-unread) f6656) ((primitive-ref port-unread) f6656) (let ((f6660 (string-ref ((primitive-ref port-buf) f6656) ((primitive-ref port-ndx) f6656)))) ((primitive-ref port-ndx-add1) f6656))))
#   env=((f6656 . -12) (f6650 . -8) (#f . 20) ((begin (primitive-ref port-unread-clear) else if (primitive-ref port-last) (begin (primitive-ref port-ndx) (primitive-ref fill-input-buffer) (primitive-ref port-unread) (primitive-ref port-unread) (primitive-ref port-ndx-add1)) #f) . 16) ((not (primitive-ref port-unread)) . 12) (if . 8) ((primitive-ref port-unread) . 4))
# emit-tail-expr
# si=-16
# env=((f6656 . -12) (f6650 . -8) (#f . 20) ((begin (primitive-ref port-unread-clear) else if (primitive-ref port-last) (begin (primitive-ref port-ndx) (primitive-ref fill-input-buffer) (primitive-ref port-unread) (primitive-ref port-unread) (primitive-ref port-ndx-add1)) #f) . 16) ((not (primitive-ref port-unread)) . 12) (if . 8) ((primitive-ref port-unread) . 4))
# expr=(if ((primitive-ref port-unread) f6656) ((primitive-ref port-unread) f6656) (let ((f6660 (string-ref ((primitive-ref port-buf) f6656) ((primitive-ref port-ndx) f6656)))) ((primitive-ref port-ndx-add1) f6656)))
# emit-expr ((primitive-ref port-unread) f6656)
# funcall
#    si   =-16
#    env  = ((f6656 . -12) (f6650 . -8) (#f . 20) ((begin (primitive-ref port-unread-clear) else if (primitive-ref port-last) (begin (primitive-ref port-ndx) (primitive-ref fill-input-buffer) (primitive-ref port-unread) (primitive-ref port-unread) (primitive-ref port-ndx-add1)) #f) . 16) ((not (primitive-ref port-unread)) . 12) (if . 8) ((primitive-ref port-unread) . 4))
#    expr = (funcall (primitive-ref port-unread) f6656)
# emit-expr (primitive-ref port-unread)
    .extern mrc_port$munread
    movl mrc_port$munread,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_40388"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_40388":
   movl %eax,  -24(%esp)  # stash funcall-oper in closure slot
# emit-expr f6656
# emit-variable-ref
# env=((f6656 . -12) (f6650 . -8) (#f . 20) ((begin (primitive-ref port-unread-clear) else if (primitive-ref port-last) (begin (primitive-ref port-ndx) (primitive-ref fill-input-buffer) (primitive-ref port-unread) (primitive-ref port-unread) (primitive-ref port-ndx-add1)) #f) . 16) ((not (primitive-ref port-unread)) . 12) (if . 8) ((primitive-ref port-unread) . 4))
# var=f6656
    movl -12(%esp), %eax  # stack load f6656
# end emit-variable-ref
    mov %eax, -28(%esp)  # arg f6656
    movl -24(%esp), %edi   # load new closure to %edi
    add $-16, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $16, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    cmp $47, %al
    je _L_40386
# emit-tail-expr
# si=-16
# env=((f6656 . -12) (f6650 . -8) (#f . 20) ((begin (primitive-ref port-unread-clear) else if (primitive-ref port-last) (begin (primitive-ref port-ndx) (primitive-ref fill-input-buffer) (primitive-ref port-unread) (primitive-ref port-unread) (primitive-ref port-ndx-add1)) #f) . 16) ((not (primitive-ref port-unread)) . 12) (if . 8) ((primitive-ref port-unread) . 4))
# expr=((primitive-ref port-unread) f6656)
# emit-tail-funcall
#    si   =-16
#    env  = ((f6656 . -12) (f6650 . -8) (#f . 20) ((begin (primitive-ref port-unread-clear) else if (primitive-ref port-last) (begin (primitive-ref port-ndx) (primitive-ref fill-input-buffer) (primitive-ref port-unread) (primitive-ref port-unread) (primitive-ref port-ndx-add1)) #f) . 16) ((not (primitive-ref port-unread)) . 12) (if . 8) ((primitive-ref port-unread) . 4))
#    expr = (funcall (primitive-ref port-unread) f6656)
# emit-expr (primitive-ref port-unread)
    .extern mrc_port$munread
    movl mrc_port$munread,%eax
   movl %eax,  -16(%esp)  # stash funcall-oper in next closure slot
# emit-expr f6656
# emit-variable-ref
# env=((f6656 . -12) (f6650 . -8) (#f . 20) ((begin (primitive-ref port-unread-clear) else if (primitive-ref port-last) (begin (primitive-ref port-ndx) (primitive-ref fill-input-buffer) (primitive-ref port-unread) (primitive-ref port-unread) (primitive-ref port-ndx-add1)) #f) . 16) ((not (primitive-ref port-unread)) . 12) (if . 8) ((primitive-ref port-unread) . 4))
# var=f6656
    movl -12(%esp), %eax  # stack load f6656
# end emit-variable-ref
    mov %eax, -20(%esp)    # arg f6656
    movl -16(%esp), %edi   # load new closure to %edi
# emit-shift-args:  size=2   si=-16  delta=12
    mov -16(%esp), %ebx  # shift frame cell
    mov %ebx, -4(%esp)  # down to base
# emit-shift-args:  size=1   si=-20  delta=12
    mov -20(%esp), %ebx  # shift frame cell
    mov %ebx, -8(%esp)  # down to base
# emit-shift-args:  size=0   si=-24  delta=12
    movl $4,%eax   # save arg count
    jmp *-2(%edi)  # tail-funcall
    jmp _L_40387
_L_40386:
# emit-tail-expr
# si=-16
# env=((f6656 . -12) (f6650 . -8) (#f . 20) ((begin (primitive-ref port-unread-clear) else if (primitive-ref port-last) (begin (primitive-ref port-ndx) (primitive-ref fill-input-buffer) (primitive-ref port-unread) (primitive-ref port-unread) (primitive-ref port-ndx-add1)) #f) . 16) ((not (primitive-ref port-unread)) . 12) (if . 8) ((primitive-ref port-unread) . 4))
# expr=(let ((f6660 (string-ref ((primitive-ref port-buf) f6656) ((primitive-ref port-ndx) f6656)))) ((primitive-ref port-ndx-add1) f6656))
# emit-tail-let
#  si   = -16
#  env  = ((f6656 . -12) (f6650 . -8) (#f . 20) ((begin (primitive-ref port-unread-clear) else if (primitive-ref port-last) (begin (primitive-ref port-ndx) (primitive-ref fill-input-buffer) (primitive-ref port-unread) (primitive-ref port-unread) (primitive-ref port-ndx-add1)) #f) . 16) ((not (primitive-ref port-unread)) . 12) (if . 8) ((primitive-ref port-unread) . 4))
#  bindings = ((f6660 (string-ref ((primitive-ref port-buf) f6656) ((primitive-ref port-ndx) f6656))))
#  body = ((primitive-ref port-ndx-add1) f6656)
# emit-expr (string-ref ((primitive-ref port-buf) f6656) ((primitive-ref port-ndx) f6656))
# emit-expr ((primitive-ref port-buf) f6656)
# funcall
#    si   =-16
#    env  = ((f6656 . -12) (f6650 . -8) (#f . 20) ((begin (primitive-ref port-unread-clear) else if (primitive-ref port-last) (begin (primitive-ref port-ndx) (primitive-ref fill-input-buffer) (primitive-ref port-unread) (primitive-ref port-unread) (primitive-ref port-ndx-add1)) #f) . 16) ((not (primitive-ref port-unread)) . 12) (if . 8) ((primitive-ref port-unread) . 4))
#    expr = (funcall (primitive-ref port-buf) f6656)
# emit-expr (primitive-ref port-buf)
    .extern mrc_port$mbuf
    movl mrc_port$mbuf,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_40389"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_40389":
   movl %eax,  -24(%esp)  # stash funcall-oper in closure slot
# emit-expr f6656
# emit-variable-ref
# env=((f6656 . -12) (f6650 . -8) (#f . 20) ((begin (primitive-ref port-unread-clear) else if (primitive-ref port-last) (begin (primitive-ref port-ndx) (primitive-ref fill-input-buffer) (primitive-ref port-unread) (primitive-ref port-unread) (primitive-ref port-ndx-add1)) #f) . 16) ((not (primitive-ref port-unread)) . 12) (if . 8) ((primitive-ref port-unread) . 4))
# var=f6656
    movl -12(%esp), %eax  # stack load f6656
# end emit-variable-ref
    mov %eax, -28(%esp)  # arg f6656
    movl -24(%esp), %edi   # load new closure to %edi
    add $-16, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $16, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
# check the argument is a string
    movl %eax,%ebx
    and $7, %bl
    cmp $6, %bl
    je _L_40390
# invoke error handler eh_string
    .extern mrc_eh$ustring
    movl mrc_eh$ustring, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $164,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_40390:
    movl %eax, -16(%esp)
# emit-expr ((primitive-ref port-ndx) f6656)
# funcall
#    si   =-16
#    env  = ((f6656 . -12) (f6650 . -8) (#f . 20) ((begin (primitive-ref port-unread-clear) else if (primitive-ref port-last) (begin (primitive-ref port-ndx) (primitive-ref fill-input-buffer) (primitive-ref port-unread) (primitive-ref port-unread) (primitive-ref port-ndx-add1)) #f) . 16) ((not (primitive-ref port-unread)) . 12) (if . 8) ((primitive-ref port-unread) . 4))
#    expr = (funcall (primitive-ref port-ndx) f6656)
# emit-expr (primitive-ref port-ndx)
    .extern mrc_port$mndx
    movl mrc_port$mndx,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_40391"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_40391":
   movl %eax,  -24(%esp)  # stash funcall-oper in closure slot
# emit-expr f6656
# emit-variable-ref
# env=((f6656 . -12) (f6650 . -8) (#f . 20) ((begin (primitive-ref port-unread-clear) else if (primitive-ref port-last) (begin (primitive-ref port-ndx) (primitive-ref fill-input-buffer) (primitive-ref port-unread) (primitive-ref port-unread) (primitive-ref port-ndx-add1)) #f) . 16) ((not (primitive-ref port-unread)) . 12) (if . 8) ((primitive-ref port-unread) . 4))
# var=f6656
    movl -12(%esp), %eax  # stack load f6656
# end emit-variable-ref
    mov %eax, -28(%esp)  # arg f6656
    movl -24(%esp), %edi   # load new closure to %edi
    add $-16, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $16, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_40392"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $164,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_40392:
# check bounds on string index
    movl -16(%esp), %ebx
    cmp  %eax,-6(%ebx) 
    jle _L_40394
    cmp  $0,%eax
    jge _L_40393
_L_40394:
# invoke error handler eh_string_index
    .extern mrc_eh$ustring$uindex
    movl mrc_eh$ustring$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $164,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_40393:
    sar $2, %eax
    movl -16(%esp), %esi
    movl -2(%eax,%esi), %eax
    sal $8, %eax
    or  $15, %eax
    movl %eax, -16(%esp)  # stack save
# emit-tail-expr
# si=-20
# env=((f6660 . -16) (f6656 . -12) (f6650 . -8) (#f . 20) ((begin (primitive-ref port-unread-clear) else if (primitive-ref port-last) (begin (primitive-ref port-ndx) (primitive-ref fill-input-buffer) (primitive-ref port-unread) (primitive-ref port-unread) (primitive-ref port-ndx-add1)) #f) . 16) ((not (primitive-ref port-unread)) . 12) (if . 8) ((primitive-ref port-unread) . 4))
# expr=((primitive-ref port-ndx-add1) f6656)
# emit-tail-funcall
#    si   =-20
#    env  = ((f6660 . -16) (f6656 . -12) (f6650 . -8) (#f . 20) ((begin (primitive-ref port-unread-clear) else if (primitive-ref port-last) (begin (primitive-ref port-ndx) (primitive-ref fill-input-buffer) (primitive-ref port-unread) (primitive-ref port-unread) (primitive-ref port-ndx-add1)) #f) . 16) ((not (primitive-ref port-unread)) . 12) (if . 8) ((primitive-ref port-unread) . 4))
#    expr = (funcall (primitive-ref port-ndx-add1) f6656)
# emit-expr (primitive-ref port-ndx-add1)
    .extern mrc_port$mndx$madd1
    movl mrc_port$mndx$madd1,%eax
   movl %eax,  -20(%esp)  # stash funcall-oper in next closure slot
# emit-expr f6656
# emit-variable-ref
# env=((f6660 . -16) (f6656 . -12) (f6650 . -8) (#f . 20) ((begin (primitive-ref port-unread-clear) else if (primitive-ref port-last) (begin (primitive-ref port-ndx) (primitive-ref fill-input-buffer) (primitive-ref port-unread) (primitive-ref port-unread) (primitive-ref port-ndx-add1)) #f) . 16) ((not (primitive-ref port-unread)) . 12) (if . 8) ((primitive-ref port-unread) . 4))
# var=f6656
    movl -12(%esp), %eax  # stack load f6656
# end emit-variable-ref
    mov %eax, -24(%esp)    # arg f6656
    movl -20(%esp), %edi   # load new closure to %edi
# emit-shift-args:  size=2   si=-20  delta=16
    mov -20(%esp), %ebx  # shift frame cell
    mov %ebx, -4(%esp)  # down to base
# emit-shift-args:  size=1   si=-24  delta=16
    mov -24(%esp), %ebx  # shift frame cell
    mov %ebx, -8(%esp)  # down to base
# emit-shift-args:  size=0   si=-28  delta=16
    movl $4,%eax   # save arg count
    jmp *-2(%edi)  # tail-funcall
_L_40387:
     ret   # return thru stack
_L_40373:
    .align 4,0x90
_L_40364:
     movl %eax, mrc_read$mchar
# == explicit-begins  ==>
# (lambda (p) (let ((nbytes (foreign-call "s_read" (port-fd p) (port-buf p) (port-size p)))) (begin (port-ndx-reset p) (port-last-set! p nbytes) (when (fxzero? nbytes) (port-unread-set! p (eof-object))))))
# == eliminate-let*  ==>
# (lambda (p) (let ((nbytes (foreign-call "s_read" (port-fd p) (port-buf p) (port-size p)))) (begin (port-ndx-reset p) (port-last-set! p nbytes) (when (fxzero? nbytes) (port-unread-set! p (eof-object))))))
# == uniquify-variables  ==>
# (lambda (f6661) (let ((f6663 (foreign-call "s_read" (port-fd f6661) (port-buf f6661) (port-size f6661)))) (begin (port-ndx-reset f6661) (port-last-set! f6661 f6663) (when (fxzero? f6663) (port-unread-set! f6661 (eof-object))))))
# == vectorize-letrec  ==>
# (lambda (f6661) (let ((f6663 (foreign-call "s_read" (port-fd f6661) (port-buf f6661) (port-size f6661)))) (begin (port-ndx-reset f6661) (port-last-set! f6661 f6663) (when (fxzero? f6663) (port-unread-set! f6661 (eof-object))))))
# == eliminate-set!  ==>
# (lambda (f6661) (let ((f6661 f6661)) (let ((f6663 (foreign-call "s_read" (port-fd f6661) (port-buf f6661) (port-size f6661)))) (begin (port-ndx-reset f6661) (port-last-set! f6661 f6663) (when (fxzero? f6663) (port-unread-set! f6661 (eof-object)))))))
# == close-free-variables  ==>
# (closure (f6661) (port-ndx-reset port-last-set! when port-unread-set!) (let ((f6661 f6661)) (let ((f6663 (foreign-call "s_read" (port-fd f6661) (port-buf f6661) (port-size f6661)))) (begin (port-ndx-reset f6661) (port-last-set! f6661 f6663) (when (fxzero? f6663) (port-unread-set! f6661 (eof-object)))))))
# == eliminate-quote  ==>
# (closure (f6661) (port-ndx-reset port-last-set! when port-unread-set!) (let ((f6661 f6661)) (let ((f6663 (foreign-call "s_read" (port-fd f6661) (port-buf f6661) (port-size f6661)))) (begin (port-ndx-reset f6661) (port-last-set! f6661 f6663) (when (fxzero? f6663) (port-unread-set! f6661 (eof-object)))))))
# == eliminate-when/unless  ==>
# (closure (f6661) (port-ndx-reset port-last-set! if port-unread-set! (begin) #f) (let ((f6661 f6661)) (let ((f6663 (foreign-call "s_read" (port-fd f6661) (port-buf f6661) (port-size f6661)))) (begin (port-ndx-reset f6661) (port-last-set! f6661 f6663) (if (fxzero? f6663) (begin (port-unread-set! f6661 (eof-object))) #f)))))
# == eliminate-cond  ==>
# (closure (f6661) (port-ndx-reset port-last-set! if port-unread-set! (begin) #f) (let ((f6661 f6661)) (let ((f6663 (foreign-call "s_read" (port-fd f6661) (port-buf f6661) (port-size f6661)))) (begin (port-ndx-reset f6661) (port-last-set! f6661 f6663) (if (fxzero? f6663) (begin (port-unread-set! f6661 (eof-object))) #f)))))
# == external-symbols  ==>
# (closure (f6661) ((primitive-ref port-ndx-reset) (primitive-ref port-last-set!) if (primitive-ref port-unread-set!) (begin) #f) (let ((f6661 f6661)) (let ((f6663 (foreign-call "s_read" ((primitive-ref port-fd) f6661) ((primitive-ref port-buf) f6661) ((primitive-ref port-size) f6661)))) (begin ((primitive-ref port-ndx-reset) f6661) ((primitive-ref port-last-set!) f6661 f6663) (if (fxzero? f6663) (begin ((primitive-ref port-unread-set!) f6661 (eof-object))) #f)))))
# emit-expr (closure (f6661) ((primitive-ref port-ndx-reset) (primitive-ref port-last-set!) if (primitive-ref port-unread-set!) (begin) #f) (let ((f6661 f6661)) (let ((f6663 (foreign-call "s_read" ((primitive-ref port-fd) f6661) ((primitive-ref port-buf) f6661) ((primitive-ref port-size) f6661)))) (begin ((primitive-ref port-ndx-reset) f6661) ((primitive-ref port-last-set!) f6661 f6663) (if (fxzero? f6663) (begin ((primitive-ref port-unread-set!) f6661 (eof-object))) #f)))))
# emit-closure
# si = 0
# env = ()
# expr = (closure (f6661) ((primitive-ref port-ndx-reset) (primitive-ref port-last-set!) if (primitive-ref port-unread-set!) (begin) #f) (let ((f6661 f6661)) (let ((f6663 (foreign-call "s_read" ((primitive-ref port-fd) f6661) ((primitive-ref port-buf) f6661) ((primitive-ref port-size) f6661)))) (begin ((primitive-ref port-ndx-reset) f6661) ((primitive-ref port-last-set!) f6661 f6663) (if (fxzero? f6663) (begin ((primitive-ref port-unread-set!) f6661 (eof-object))) #f)))))
    movl $_L_40395, 0(%ebp)  # closure label
# WARNING: free var (primitive-ref port-ndx-reset) not defined in the environmnet
# WARNING: free var (primitive-ref port-last-set!) not defined in the environmnet
# WARNING: free var if not defined in the environmnet
# WARNING: free var (primitive-ref port-unread-set!) not defined in the environmnet
# WARNING: free var (begin) not defined in the environmnet
# WARNING: free var #f not defined in the environmnet
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $32, %ebp     # bump ebp
    jmp _L_40396            # jump around closure body
_L_40395:
# check argument count
    cmp $4,%eax
    je _L_40397
# invoke error handler eh_argcount
    .extern mrc_eh$uargcount
    movl mrc_eh$uargcount, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_40397:
# emit-tail-expr
# si=-12
# env=((f6661 . -8) (#f . 24) ((begin) . 20) ((primitive-ref port-unread-set!) . 16) (if . 12) ((primitive-ref port-last-set!) . 8) ((primitive-ref port-ndx-reset) . 4))
# expr=(let ((f6661 f6661)) (let ((f6663 (foreign-call "s_read" ((primitive-ref port-fd) f6661) ((primitive-ref port-buf) f6661) ((primitive-ref port-size) f6661)))) (begin ((primitive-ref port-ndx-reset) f6661) ((primitive-ref port-last-set!) f6661 f6663) (if (fxzero? f6663) (begin ((primitive-ref port-unread-set!) f6661 (eof-object))) #f))))
# emit-tail-let
#  si   = -12
#  env  = ((f6661 . -8) (#f . 24) ((begin) . 20) ((primitive-ref port-unread-set!) . 16) (if . 12) ((primitive-ref port-last-set!) . 8) ((primitive-ref port-ndx-reset) . 4))
#  bindings = ((f6661 f6661))
#  body = (let ((f6663 (foreign-call "s_read" ((primitive-ref port-fd) f6661) ((primitive-ref port-buf) f6661) ((primitive-ref port-size) f6661)))) (begin ((primitive-ref port-ndx-reset) f6661) ((primitive-ref port-last-set!) f6661 f6663) (if (fxzero? f6663) (begin ((primitive-ref port-unread-set!) f6661 (eof-object))) #f)))
# emit-expr f6661
# emit-variable-ref
# env=((f6661 . -8) (#f . 24) ((begin) . 20) ((primitive-ref port-unread-set!) . 16) (if . 12) ((primitive-ref port-last-set!) . 8) ((primitive-ref port-ndx-reset) . 4))
# var=f6661
    movl -8(%esp), %eax  # stack load f6661
# end emit-variable-ref
    movl %eax, -12(%esp)  # stack save
# emit-tail-expr
# si=-16
# env=((f6661 . -12) (f6661 . -8) (#f . 24) ((begin) . 20) ((primitive-ref port-unread-set!) . 16) (if . 12) ((primitive-ref port-last-set!) . 8) ((primitive-ref port-ndx-reset) . 4))
# expr=(let ((f6663 (foreign-call "s_read" ((primitive-ref port-fd) f6661) ((primitive-ref port-buf) f6661) ((primitive-ref port-size) f6661)))) (begin ((primitive-ref port-ndx-reset) f6661) ((primitive-ref port-last-set!) f6661 f6663) (if (fxzero? f6663) (begin ((primitive-ref port-unread-set!) f6661 (eof-object))) #f)))
# emit-tail-let
#  si   = -16
#  env  = ((f6661 . -12) (f6661 . -8) (#f . 24) ((begin) . 20) ((primitive-ref port-unread-set!) . 16) (if . 12) ((primitive-ref port-last-set!) . 8) ((primitive-ref port-ndx-reset) . 4))
#  bindings = ((f6663 (foreign-call "s_read" ((primitive-ref port-fd) f6661) ((primitive-ref port-buf) f6661) ((primitive-ref port-size) f6661))))
#  body = (begin ((primitive-ref port-ndx-reset) f6661) ((primitive-ref port-last-set!) f6661 f6663) (if (fxzero? f6663) (begin ((primitive-ref port-unread-set!) f6661 (eof-object))) #f))
# emit-expr (foreign-call "s_read" ((primitive-ref port-fd) f6661) ((primitive-ref port-buf) f6661) ((primitive-ref port-size) f6661))
    movl %ecx,-16(%esp)
    movl %esp,-20(%esp)
# emit-expr ((primitive-ref port-size) f6661)
# funcall
#    si   =-24
#    env  = ((f6661 . -12) (f6661 . -8) (#f . 24) ((begin) . 20) ((primitive-ref port-unread-set!) . 16) (if . 12) ((primitive-ref port-last-set!) . 8) ((primitive-ref port-ndx-reset) . 4))
#    expr = (funcall (primitive-ref port-size) f6661)
# emit-expr (primitive-ref port-size)
    .extern mrc_port$msize
    movl mrc_port$msize,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_40398"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_40398":
   movl %eax,  -32(%esp)  # stash funcall-oper in closure slot
# emit-expr f6661
# emit-variable-ref
# env=((f6661 . -12) (f6661 . -8) (#f . 24) ((begin) . 20) ((primitive-ref port-unread-set!) . 16) (if . 12) ((primitive-ref port-last-set!) . 8) ((primitive-ref port-ndx-reset) . 4))
# var=f6661
    movl -12(%esp), %eax  # stack load f6661
# end emit-variable-ref
    mov %eax, -36(%esp)  # arg f6661
    movl -32(%esp), %edi   # load new closure to %edi
    add $-24, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $24, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    movl %eax, -24(%esp)
# emit-expr ((primitive-ref port-buf) f6661)
# funcall
#    si   =-28
#    env  = ((f6661 . -12) (f6661 . -8) (#f . 24) ((begin) . 20) ((primitive-ref port-unread-set!) . 16) (if . 12) ((primitive-ref port-last-set!) . 8) ((primitive-ref port-ndx-reset) . 4))
#    expr = (funcall (primitive-ref port-buf) f6661)
# emit-expr (primitive-ref port-buf)
    .extern mrc_port$mbuf
    movl mrc_port$mbuf,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_40399"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_40399":
   movl %eax,  -36(%esp)  # stash funcall-oper in closure slot
# emit-expr f6661
# emit-variable-ref
# env=((f6661 . -12) (f6661 . -8) (#f . 24) ((begin) . 20) ((primitive-ref port-unread-set!) . 16) (if . 12) ((primitive-ref port-last-set!) . 8) ((primitive-ref port-ndx-reset) . 4))
# var=f6661
    movl -12(%esp), %eax  # stack load f6661
# end emit-variable-ref
    mov %eax, -40(%esp)  # arg f6661
    movl -36(%esp), %edi   # load new closure to %edi
    add $-28, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $28, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    movl %eax, -28(%esp)
# emit-expr ((primitive-ref port-fd) f6661)
# funcall
#    si   =-32
#    env  = ((f6661 . -12) (f6661 . -8) (#f . 24) ((begin) . 20) ((primitive-ref port-unread-set!) . 16) (if . 12) ((primitive-ref port-last-set!) . 8) ((primitive-ref port-ndx-reset) . 4))
#    expr = (funcall (primitive-ref port-fd) f6661)
# emit-expr (primitive-ref port-fd)
    .extern mrc_port$mfd
    movl mrc_port$mfd,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_40400"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_40400":
   movl %eax,  -40(%esp)  # stash funcall-oper in closure slot
# emit-expr f6661
# emit-variable-ref
# env=((f6661 . -12) (f6661 . -8) (#f . 24) ((begin) . 20) ((primitive-ref port-unread-set!) . 16) (if . 12) ((primitive-ref port-last-set!) . 8) ((primitive-ref port-ndx-reset) . 4))
# var=f6661
    movl -12(%esp), %eax  # stack load f6661
# end emit-variable-ref
    mov %eax, -44(%esp)  # arg f6661
    movl -40(%esp), %edi   # load new closure to %edi
    add $-32, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $32, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    movl %eax, -32(%esp)
    leal -32(%esp),%edi
    movl %edi,%esi
    andl $-16,%esi
    movl 0(%edi),%eax
    movl %eax,0(%esi)
    movl 4(%edi),%eax
    movl %eax,4(%esi)
    movl 8(%edi),%eax
    movl %eax,8(%esi)
    movl 12(%edi),%eax
    movl %eax,12(%esi)
    movl %esi,%esp
    .extern _s_read
    call _s_read
    movl 12(%esi),%esp
    movl -16(%esp),%ecx
    movl %eax, -16(%esp)  # stack save
# emit-tail-expr
# si=-20
# env=((f6663 . -16) (f6661 . -12) (f6661 . -8) (#f . 24) ((begin) . 20) ((primitive-ref port-unread-set!) . 16) (if . 12) ((primitive-ref port-last-set!) . 8) ((primitive-ref port-ndx-reset) . 4))
# expr=(begin ((primitive-ref port-ndx-reset) f6661) ((primitive-ref port-last-set!) f6661 f6663) (if (fxzero? f6663) (begin ((primitive-ref port-unread-set!) f6661 (eof-object))) #f))
# tail-begin (begin ((primitive-ref port-ndx-reset) f6661) ((primitive-ref port-last-set!) f6661 f6663) (if (fxzero? f6663) (begin ((primitive-ref port-unread-set!) f6661 (eof-object))) #f))
#   env=((f6663 . -16) (f6661 . -12) (f6661 . -8) (#f . 24) ((begin) . 20) ((primitive-ref port-unread-set!) . 16) (if . 12) ((primitive-ref port-last-set!) . 8) ((primitive-ref port-ndx-reset) . 4))
# emit-expr ((primitive-ref port-ndx-reset) f6661)
# funcall
#    si   =-20
#    env  = ((f6663 . -16) (f6661 . -12) (f6661 . -8) (#f . 24) ((begin) . 20) ((primitive-ref port-unread-set!) . 16) (if . 12) ((primitive-ref port-last-set!) . 8) ((primitive-ref port-ndx-reset) . 4))
#    expr = (funcall (primitive-ref port-ndx-reset) f6661)
# emit-expr (primitive-ref port-ndx-reset)
    .extern mrc_port$mndx$mreset
    movl mrc_port$mndx$mreset,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_40401"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_40401":
   movl %eax,  -28(%esp)  # stash funcall-oper in closure slot
# emit-expr f6661
# emit-variable-ref
# env=((f6663 . -16) (f6661 . -12) (f6661 . -8) (#f . 24) ((begin) . 20) ((primitive-ref port-unread-set!) . 16) (if . 12) ((primitive-ref port-last-set!) . 8) ((primitive-ref port-ndx-reset) . 4))
# var=f6661
    movl -12(%esp), %eax  # stack load f6661
# end emit-variable-ref
    mov %eax, -32(%esp)  # arg f6661
    movl -28(%esp), %edi   # load new closure to %edi
    add $-20, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $20, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
# emit-tail-expr
# si=-20
# env=((f6663 . -16) (f6661 . -12) (f6661 . -8) (#f . 24) ((begin) . 20) ((primitive-ref port-unread-set!) . 16) (if . 12) ((primitive-ref port-last-set!) . 8) ((primitive-ref port-ndx-reset) . 4))
# expr=(begin ((primitive-ref port-last-set!) f6661 f6663) (if (fxzero? f6663) (begin ((primitive-ref port-unread-set!) f6661 (eof-object))) #f))
# tail-begin (begin ((primitive-ref port-last-set!) f6661 f6663) (if (fxzero? f6663) (begin ((primitive-ref port-unread-set!) f6661 (eof-object))) #f))
#   env=((f6663 . -16) (f6661 . -12) (f6661 . -8) (#f . 24) ((begin) . 20) ((primitive-ref port-unread-set!) . 16) (if . 12) ((primitive-ref port-last-set!) . 8) ((primitive-ref port-ndx-reset) . 4))
# emit-expr ((primitive-ref port-last-set!) f6661 f6663)
# funcall
#    si   =-20
#    env  = ((f6663 . -16) (f6661 . -12) (f6661 . -8) (#f . 24) ((begin) . 20) ((primitive-ref port-unread-set!) . 16) (if . 12) ((primitive-ref port-last-set!) . 8) ((primitive-ref port-ndx-reset) . 4))
#    expr = (funcall (primitive-ref port-last-set!) f6661 f6663)
# emit-expr (primitive-ref port-last-set!)
    .extern mrc_port$mlast$mset$b
    movl mrc_port$mlast$mset$b,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_40402"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_40402":
   movl %eax,  -28(%esp)  # stash funcall-oper in closure slot
# emit-expr f6661
# emit-variable-ref
# env=((f6663 . -16) (f6661 . -12) (f6661 . -8) (#f . 24) ((begin) . 20) ((primitive-ref port-unread-set!) . 16) (if . 12) ((primitive-ref port-last-set!) . 8) ((primitive-ref port-ndx-reset) . 4))
# var=f6661
    movl -12(%esp), %eax  # stack load f6661
# end emit-variable-ref
    mov %eax, -32(%esp)  # arg f6661
# emit-expr f6663
# emit-variable-ref
# env=((f6663 . -16) (f6661 . -12) (f6661 . -8) (#f . 24) ((begin) . 20) ((primitive-ref port-unread-set!) . 16) (if . 12) ((primitive-ref port-last-set!) . 8) ((primitive-ref port-ndx-reset) . 4))
# var=f6663
    movl -16(%esp), %eax  # stack load f6663
# end emit-variable-ref
    mov %eax, -36(%esp)  # arg f6663
    movl -28(%esp), %edi   # load new closure to %edi
    add $-20, %esp   # adjust base
    movl $8,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $20, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
# emit-tail-expr
# si=-20
# env=((f6663 . -16) (f6661 . -12) (f6661 . -8) (#f . 24) ((begin) . 20) ((primitive-ref port-unread-set!) . 16) (if . 12) ((primitive-ref port-last-set!) . 8) ((primitive-ref port-ndx-reset) . 4))
# expr=(begin (if (fxzero? f6663) (begin ((primitive-ref port-unread-set!) f6661 (eof-object))) #f))
# tail-begin (begin (if (fxzero? f6663) (begin ((primitive-ref port-unread-set!) f6661 (eof-object))) #f))
#   env=((f6663 . -16) (f6661 . -12) (f6661 . -8) (#f . 24) ((begin) . 20) ((primitive-ref port-unread-set!) . 16) (if . 12) ((primitive-ref port-last-set!) . 8) ((primitive-ref port-ndx-reset) . 4))
# emit-tail-expr
# si=-20
# env=((f6663 . -16) (f6661 . -12) (f6661 . -8) (#f . 24) ((begin) . 20) ((primitive-ref port-unread-set!) . 16) (if . 12) ((primitive-ref port-last-set!) . 8) ((primitive-ref port-ndx-reset) . 4))
# expr=(if (fxzero? f6663) (begin ((primitive-ref port-unread-set!) f6661 (eof-object))) #f)
# emit-expr (fxzero? f6663)
# emit-expr f6663
# emit-variable-ref
# env=((f6663 . -16) (f6661 . -12) (f6661 . -8) (#f . 24) ((begin) . 20) ((primitive-ref port-unread-set!) . 16) (if . 12) ((primitive-ref port-last-set!) . 8) ((primitive-ref port-ndx-reset) . 4))
# var=f6663
    movl -16(%esp), %eax  # stack load f6663
# end emit-variable-ref
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_40405"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $64,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_40405:
    cmp $0, %eax
    sete %al
    movzbl %al, %eax
    sal $6, %al
    or $47, %al
    cmp $47, %al
    je _L_40403
# emit-tail-expr
# si=-20
# env=((f6663 . -16) (f6661 . -12) (f6661 . -8) (#f . 24) ((begin) . 20) ((primitive-ref port-unread-set!) . 16) (if . 12) ((primitive-ref port-last-set!) . 8) ((primitive-ref port-ndx-reset) . 4))
# expr=(begin ((primitive-ref port-unread-set!) f6661 (eof-object)))
# tail-begin (begin ((primitive-ref port-unread-set!) f6661 (eof-object)))
#   env=((f6663 . -16) (f6661 . -12) (f6661 . -8) (#f . 24) ((begin) . 20) ((primitive-ref port-unread-set!) . 16) (if . 12) ((primitive-ref port-last-set!) . 8) ((primitive-ref port-ndx-reset) . 4))
# emit-tail-expr
# si=-20
# env=((f6663 . -16) (f6661 . -12) (f6661 . -8) (#f . 24) ((begin) . 20) ((primitive-ref port-unread-set!) . 16) (if . 12) ((primitive-ref port-last-set!) . 8) ((primitive-ref port-ndx-reset) . 4))
# expr=((primitive-ref port-unread-set!) f6661 (eof-object))
# emit-tail-funcall
#    si   =-20
#    env  = ((f6663 . -16) (f6661 . -12) (f6661 . -8) (#f . 24) ((begin) . 20) ((primitive-ref port-unread-set!) . 16) (if . 12) ((primitive-ref port-last-set!) . 8) ((primitive-ref port-ndx-reset) . 4))
#    expr = (funcall (primitive-ref port-unread-set!) f6661 (eof-object))
# emit-expr (primitive-ref port-unread-set!)
    .extern mrc_port$munread$mset$b
    movl mrc_port$munread$mset$b,%eax
   movl %eax,  -20(%esp)  # stash funcall-oper in next closure slot
# emit-expr f6661
# emit-variable-ref
# env=((f6663 . -16) (f6661 . -12) (f6661 . -8) (#f . 24) ((begin) . 20) ((primitive-ref port-unread-set!) . 16) (if . 12) ((primitive-ref port-last-set!) . 8) ((primitive-ref port-ndx-reset) . 4))
# var=f6661
    movl -12(%esp), %eax  # stack load f6661
# end emit-variable-ref
    mov %eax, -24(%esp)    # arg f6661
# emit-expr (eof-object)
    movl $95,%eax
    mov %eax, -28(%esp)    # arg (eof-object)
    movl -20(%esp), %edi   # load new closure to %edi
# emit-shift-args:  size=3   si=-20  delta=16
    mov -20(%esp), %ebx  # shift frame cell
    mov %ebx, -4(%esp)  # down to base
# emit-shift-args:  size=2   si=-24  delta=16
    mov -24(%esp), %ebx  # shift frame cell
    mov %ebx, -8(%esp)  # down to base
# emit-shift-args:  size=1   si=-28  delta=16
    mov -28(%esp), %ebx  # shift frame cell
    mov %ebx, -12(%esp)  # down to base
# emit-shift-args:  size=0   si=-32  delta=16
    movl $8,%eax   # save arg count
    jmp *-2(%edi)  # tail-funcall
     ret   # return thru stack
    jmp _L_40404
_L_40403:
# emit-tail-expr
# si=-20
# env=((f6663 . -16) (f6661 . -12) (f6661 . -8) (#f . 24) ((begin) . 20) ((primitive-ref port-unread-set!) . 16) (if . 12) ((primitive-ref port-last-set!) . 8) ((primitive-ref port-ndx-reset) . 4))
# expr=#f
    movl $47, %eax     # immed #f
    ret                  # immediate tail return
_L_40404:
     ret   # return thru stack
    .align 4,0x90
_L_40396:
     movl %eax, mrc_fill$minput$mbuffer
# == explicit-begins  ==>
# (quote TBD)
# == eliminate-let*  ==>
# (quote TBD)
# == uniquify-variables  ==>
# (quote TBD)
# == vectorize-letrec  ==>
# (quote TBD)
# == eliminate-set!  ==>
# (quote TBD)
# == close-free-variables  ==>
# (quote TBD)
# == eliminate-quote  ==>
# (string->symbol "TBD")
# == eliminate-when/unless  ==>
# (string->symbol "TBD")
# == eliminate-cond  ==>
# (string->symbol "TBD")
# == external-symbols  ==>
# ((primitive-ref string->symbol) "TBD")
# emit-expr ((primitive-ref string->symbol) "TBD")
# funcall
#    si   =0
#    env  = ()
#    expr = (funcall (primitive-ref string->symbol) "TBD")
# emit-expr (primitive-ref string->symbol)
    .extern mrc_string$m$gsymbol
    movl mrc_string$m$gsymbol,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_40406"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_40406":
   movl %eax,  -8(%esp)  # stash funcall-oper in closure slot
# emit-expr "TBD"
# string literal
    jmp _L_40408
    .align 8,0x90
_L_40407 :
    .int 12
    .ascii "TBD"
_L_40408:
    movl $_L_40407, %eax
    orl $6, %eax
    mov %eax, -12(%esp)  # arg TBD
    movl -8(%esp), %edi   # load new closure to %edi
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    movl -4(%esp), %edi   # restore closure frame ptr
     movl %eax, mrc_unread$mchar
# emit-expr (begin #t)
# emit-begin
#   expr=(begin #t)
#   env=()
# emit-expr #t
    movl $111, %eax     # immed #t
# emit-expr (begin)
# emit-begin
#   expr=(begin)
#   env=()
    .extern base_init_callback
    jmp base_init_callback
