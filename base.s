     .data
     .global "mrc_symbols"
     .align 8
mrc_symbols:
     .int 0xFF
     .global "mrc_string$e$q"
     .align 8
mrc_string$e$q:
     .int 0xFF
     .global "mrc_string$m$gsymbol"
     .align 8
mrc_string$m$gsymbol:
     .int 0xFF
     .global "mrc_append1"
     .align 8
mrc_append1:
     .int 0xFF
     .global "mrc_list$mref"
     .align 8
mrc_list$mref:
     .int 0xFF
     .global "mrc_list$mlength"
     .align 8
mrc_list$mlength:
     .int 0xFF
     .global "mrc_reverse"
     .align 8
mrc_reverse:
     .int 0xFF
     .global "mrc_list"
     .align 8
mrc_list:
     .int 0xFF
     .global "mrc_vector"
     .align 8
mrc_vector:
     .int 0xFF
     .global "mrc_string"
     .align 8
mrc_string:
     .int 0xFF
     .global "mrc_string$m$glist"
     .align 8
mrc_string$m$glist:
     .int 0xFF
     .global "mrc_integer$m$glist"
     .align 8
mrc_integer$m$glist:
     .int 0xFF
     .global "mrc_error"
     .align 8
mrc_error:
     .int 0xFF
     .global "mrc_primitives"
     .align 8
mrc_primitives:
     .int 0xFF
     .global "mrc_eh$uprocedure"
     .align 8
mrc_eh$uprocedure:
     .int 0xFF
     .global "mrc_eh$uargcount"
     .align 8
mrc_eh$uargcount:
     .int 0xFF
     .global "mrc_eh$uargcount$umin"
     .align 8
mrc_eh$uargcount$umin:
     .int 0xFF
     .global "mrc_eh$ufixnum"
     .align 8
mrc_eh$ufixnum:
     .int 0xFF
     .global "mrc_eh$ustring"
     .align 8
mrc_eh$ustring:
     .int 0xFF
     .global "mrc_eh$ucharacter"
     .align 8
mrc_eh$ucharacter:
     .int 0xFF
     .global "mrc_eh$upair"
     .align 8
mrc_eh$upair:
     .int 0xFF
     .global "mrc_eh$uvector"
     .align 8
mrc_eh$uvector:
     .int 0xFF
     .global "mrc_eh$ulength"
     .align 8
mrc_eh$ulength:
     .int 0xFF
     .global "mrc_eh$uvector$uindex"
     .align 8
mrc_eh$uvector$uindex:
     .int 0xFF
     .global "mrc_eh$ustring$uindex"
     .align 8
mrc_eh$ustring$uindex:
     .int 0xFF
     .global "mrc_zero$q"
     .align 8
mrc_zero$q:
     .int 0xFF
     .global "mrc_positive$q"
     .align 8
mrc_positive$q:
     .int 0xFF
     .global "mrc_negative$q"
     .align 8
mrc_negative$q:
     .int 0xFF
     .global "mrc_even$q"
     .align 8
mrc_even$q:
     .int 0xFF
     .global "mrc_odd$q"
     .align 8
mrc_odd$q:
     .int 0xFF
     .global "mrc_map"
     .align 8
mrc_map:
     .int 0xFF
     .global "mrc_for$meach"
     .align 8
mrc_for$meach:
     .int 0xFF
     .global "mrc_standard$mout"
     .align 8
mrc_standard$mout:
     .int 0xFF
     .global "mrc_current$moutput$mport"
     .align 8
mrc_current$moutput$mport:
     .int 0xFF
     .global "mrc_current$minput$mport"
     .align 8
mrc_current$minput$mport:
     .int 0xFF
     .global "mrc_port$mkind"
     .align 8
mrc_port$mkind:
     .int 0xFF
     .global "mrc_port$mpath"
     .align 8
mrc_port$mpath:
     .int 0xFF
     .global "mrc_port$mfd"
     .align 8
mrc_port$mfd:
     .int 0xFF
     .global "mrc_port$mbuf"
     .align 8
mrc_port$mbuf:
     .int 0xFF
     .global "mrc_port$mndx"
     .align 8
mrc_port$mndx:
     .int 0xFF
     .global "mrc_port$mndx$madd1"
     .align 8
mrc_port$mndx$madd1:
     .int 0xFF
     .global "mrc_port$mndx$mreset"
     .align 8
mrc_port$mndx$mreset:
     .int 0xFF
     .global "mrc_port$msize"
     .align 8
mrc_port$msize:
     .int 0xFF
     .global "mrc_write$mchar"
     .align 8
mrc_write$mchar:
     .int 0xFF
     .global "mrc_flush$moutput$mport"
     .align 8
mrc_flush$moutput$mport:
     .int 0xFF
     .global "mrc_exit"
     .align 8
mrc_exit:
     .int 0xFF
     .global "mrc_open$moutput$mfile"
     .align 8
mrc_open$moutput$mfile:
     .int 0xFF
     .global "mrc_close$minput$mport"
     .align 8
mrc_close$minput$mport:
     .int 0xFF
     .global "mrc_close$moutput$mport"
     .align 8
mrc_close$moutput$mport:
     .int 0xFF
     .global "mrc_base$mwrite"
     .align 8
mrc_base$mwrite:
     .int 0xFF
     .global "mrc_write"
     .align 8
mrc_write:
     .int 0xFF
     .global "mrc_display"
     .align 8
mrc_display:
     .int 0xFF
     .global "mrc_integer$m$gchar"
     .align 8
mrc_integer$m$gchar:
     .int 0xFF
     .global "mrc_standard$min"
     .align 8
mrc_standard$min:
     .int 0xFF
     .global "mrc_port$munread"
     .align 8
mrc_port$munread:
     .int 0xFF
     .global "mrc_port$munread$mclear"
     .align 8
mrc_port$munread$mclear:
     .int 0xFF
     .global "mrc_port$munread$mset$b"
     .align 8
mrc_port$munread$mset$b:
     .int 0xFF
     .global "mrc_port$mlast"
     .align 8
mrc_port$mlast:
     .int 0xFF
     .global "mrc_port$mlast$mset$b"
     .align 8
mrc_port$mlast$mset$b:
     .int 0xFF
     .global "mrc_input$mport$q"
     .align 8
mrc_input$mport$q:
     .int 0xFF
     .global "mrc_output$mport$q"
     .align 8
mrc_output$mport$q:
     .int 0xFF
     .global "mrc_open$minput$mfile"
     .align 8
mrc_open$minput$mfile:
     .int 0xFF
     .global "mrc_read$mchar"
     .align 8
mrc_read$mchar:
     .int 0xFF
     .global "mrc_fill$minput$mbuffer"
     .align 8
mrc_fill$minput$mbuffer:
     .int 0xFF
     .global "mrc_unread$mchar"
     .align 8
mrc_unread$mchar:
     .int 0xFF
     .text
     .global base_init
     .align 4
base_init:
# == explicit-begins  ==>
# (let ((interned-symbols (cons (make-symbol "nil" ()) ()))) (lambda () interned-symbols))
# == eliminate-let*  ==>
# (let ((interned-symbols (cons (make-symbol "nil" ()) ()))) (lambda () interned-symbols))
# == uniquify-variables  ==>
# (let ((f94174 (cons (make-symbol "nil" ()) ()))) (lambda () f94174))
# == vectorize-letrec  ==>
# (let ((f94174 (cons (make-symbol "nil" ()) ()))) (lambda () f94174))
# == eliminate-set!  ==>
# (let ((f94174 (cons (make-symbol "nil" ()) ()))) (lambda () (let () f94174)))
# == close-free-variables  ==>
# (let ((f94174 (cons (make-symbol "nil" ()) ()))) (closure () (f94174) (let () f94174)))
# == eliminate-quote  ==>
# (let ((f94174 (cons (make-symbol "nil" ()) ()))) (closure () (f94174) (let () f94174)))
# == eliminate-when/unless  ==>
# (let ((f94174 (cons (make-symbol "nil" ()) ()))) (closure () (f94174) (let () f94174)))
# == eliminate-cond  ==>
# (let ((f94174 (cons (make-symbol "nil" ()) ()))) (closure () (f94174) (let () f94174)))
# == external-symbols  ==>
# (let ((f94174 (cons (make-symbol "nil" ()) ()))) (closure () (f94174) (let () f94174)))
# emit-expr (let ((f94174 (cons (make-symbol "nil" ()) ()))) (closure () (f94174) (let () f94174)))
# emit-let
#  si   = 0
#  env  = ()
#  bindings = ((f94174 (cons (make-symbol "nil" ()) ())))
#  body = (closure () (f94174) (let () f94174))
# emit-expr (cons (make-symbol "nil" ()) ())
# cons arg1=(make-symbol "nil" ()) arg2=()
# emit-expr (make-symbol "nil" ())
# make-symbol arg1="nil" arg2=()
# emit-expr "nil"
# string literal
    jmp _L_570460
    .align 8,0x90
_L_570459 :
    .int 12
    .ascii "nil"
_L_570460:
    movl $_L_570459, %eax
    orl $6, %eax
    movl %eax, 0(%esp)
# emit-expr ()
    movl $63, %eax     # immed ()
    movl %eax, 4(%ebp)
    movl 0(%esp), %eax
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    orl  $3, %eax
    add  $8, %ebp
# make-symbol end
    movl %eax, 0(%esp)
# emit-expr ()
    movl $63, %eax     # immed ()
    movl %eax, 4(%ebp)
    movl 0(%esp), %eax
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    or   $1, %al
    add  $8, %ebp
# cons end
    movl %eax, 0(%esp)  # stack save
# emit-expr (closure () (f94174) (let () f94174))
# emit-closure
# si = -4
# env = ((f94174 . 0))
# expr = (closure () (f94174) (let () f94174))
    movl $_L_570461, 0(%ebp)  # closure label
# emit-variable-ref
# env=((f94174 . 0))
# var=f94174
    movl 0(%esp), %eax  # stack load f94174
# end emit-variable-ref
   movl  %eax, 4(%ebp)  # f94174
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $8, %ebp     # bump ebp
    jmp _L_570462            # jump around closure body
_L_570461:
# check argument count
    cmp $0,%eax
    je _L_570463
# invoke error handler eh_argcount
    .extern mrc_eh$uargcount
    movl mrc_eh$uargcount, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_570463:
# emit-tail-expr
# si=-8
# env=((f94174 . 4) (f94174 . 0))
# expr=(let () f94174)
# emit-tail-let
#  si   = -8
#  env  = ((f94174 . 4) (f94174 . 0))
#  bindings = ()
#  body = f94174
# emit-tail-expr
# si=-8
# env=((f94174 . 4) (f94174 . 0))
# expr=f94174
# emit-tail-variable-ref
# emit-variable-ref
# env=((f94174 . 4) (f94174 . 0))
# var=f94174
    movl 2(%edi), %eax  # frame load f94174
# end emit-variable-ref
    ret
# end emit-tail-variable ref
    .align 4,0x90
_L_570462:
     movl %eax, mrc_symbols
# == explicit-begins  ==>
# (letrec ((slen= (lambda (s1 s2) (fx= (string-length s1) (string-length s2)))) (si= (lambda (s1 s2 i) (char=? (string-ref s1 i) (string-ref s2 i)))) (si<n= (lambda (s1 s2 i n) (if (fx= i n) #t (if (si= s1 s2 i) (si<n= s1 s2 (fx+ i 1) n) #f)))) (ss= (lambda (s1 s2) (if (slen= s1 s2) (si<n= s1 s2 0 (string-length s1)) #f)))) ss=)
# == eliminate-let*  ==>
# (letrec ((slen= (lambda (s1 s2) (fx= (string-length s1) (string-length s2)))) (si= (lambda (s1 s2 i) (char=? (string-ref s1 i) (string-ref s2 i)))) (si<n= (lambda (s1 s2 i n) (if (fx= i n) #t (if (si= s1 s2 i) (si<n= s1 s2 (fx+ i 1) n) #f)))) (ss= (lambda (s1 s2) (if (slen= s1 s2) (si<n= s1 s2 0 (string-length s1)) #f)))) ss=)
# == uniquify-variables  ==>
# (letrec ((f94178 (lambda (f94199 f94200) (fx= (string-length f94199) (string-length f94200)))) (f94177 (lambda (f94196 f94197 f94198) (char=? (string-ref f94196 f94198) (string-ref f94197 f94198)))) (f94176 (lambda (f94192 f94193 f94194 f94195) (if (fx= f94194 f94195) #t (if (f94177 f94192 f94193 f94194) (f94176 f94192 f94193 (fx+ f94194 1) f94195) #f)))) (f94175 (lambda (f94190 f94191) (if (f94178 f94190 f94191) (f94176 f94190 f94191 0 (string-length f94190)) #f)))) f94175)
# == vectorize-letrec  ==>
# (let ((f94178 (make-vector 1)) (f94177 (make-vector 1)) (f94176 (make-vector 1)) (f94175 (make-vector 1))) (begin (begin (vector-set! f94178 0 (lambda (f94199 f94200) (fx= (string-length f94199) (string-length f94200)))) (vector-set! f94177 0 (lambda (f94196 f94197 f94198) (char=? (string-ref f94196 f94198) (string-ref f94197 f94198)))) (vector-set! f94176 0 (lambda (f94192 f94193 f94194 f94195) (if (fx= f94194 f94195) #t (if ((vector-ref f94177 0) f94192 f94193 f94194) ((vector-ref f94176 0) f94192 f94193 (fx+ f94194 1) f94195) #f)))) (vector-set! f94175 0 (lambda (f94190 f94191) (if ((vector-ref f94178 0) f94190 f94191) ((vector-ref f94176 0) f94190 f94191 0 (string-length f94190)) #f)))) (vector-ref f94175 0)))
# == eliminate-set!  ==>
# (let ((f94178 (make-vector 1)) (f94177 (make-vector 1)) (f94176 (make-vector 1)) (f94175 (make-vector 1))) (begin (begin (vector-set! f94178 0 (lambda (f94199 f94200) (let ((f94199 f94199) (f94200 f94200)) (fx= (string-length f94199) (string-length f94200))))) (vector-set! f94177 0 (lambda (f94196 f94197 f94198) (let ((f94196 f94196) (f94197 f94197) (f94198 f94198)) (char=? (string-ref f94196 f94198) (string-ref f94197 f94198))))) (vector-set! f94176 0 (lambda (f94192 f94193 f94194 f94195) (let ((f94192 f94192) (f94193 f94193) (f94194 f94194) (f94195 f94195)) (if (fx= f94194 f94195) #t (if ((vector-ref f94177 0) f94192 f94193 f94194) ((vector-ref f94176 0) f94192 f94193 (fx+ f94194 1) f94195) #f))))) (vector-set! f94175 0 (lambda (f94190 f94191) (let ((f94190 f94190) (f94191 f94191)) (if ((vector-ref f94178 0) f94190 f94191) ((vector-ref f94176 0) f94190 f94191 0 (string-length f94190)) #f))))) (vector-ref f94175 0)))
# == close-free-variables  ==>
# (let ((f94178 (make-vector 1)) (f94177 (make-vector 1)) (f94176 (make-vector 1)) (f94175 (make-vector 1))) (begin (begin (vector-set! f94178 0 (closure (f94199 f94200) () (let ((f94199 f94199) (f94200 f94200)) (fx= (string-length f94199) (string-length f94200))))) (vector-set! f94177 0 (closure (f94196 f94197 f94198) () (let ((f94196 f94196) (f94197 f94197) (f94198 f94198)) (char=? (string-ref f94196 f94198) (string-ref f94197 f94198))))) (vector-set! f94176 0 (closure (f94192 f94193 f94194 f94195) (f94177 f94176) (let ((f94192 f94192) (f94193 f94193) (f94194 f94194) (f94195 f94195)) (if (fx= f94194 f94195) #t (if ((vector-ref f94177 0) f94192 f94193 f94194) ((vector-ref f94176 0) f94192 f94193 (fx+ f94194 1) f94195) #f))))) (vector-set! f94175 0 (closure (f94190 f94191) (f94178 f94176) (let ((f94190 f94190) (f94191 f94191)) (if ((vector-ref f94178 0) f94190 f94191) ((vector-ref f94176 0) f94190 f94191 0 (string-length f94190)) #f))))) (vector-ref f94175 0)))
# == eliminate-quote  ==>
# (let ((f94178 (make-vector 1)) (f94177 (make-vector 1)) (f94176 (make-vector 1)) (f94175 (make-vector 1))) (begin (begin (vector-set! f94178 0 (closure (f94199 f94200) () (let ((f94199 f94199) (f94200 f94200)) (fx= (string-length f94199) (string-length f94200))))) (vector-set! f94177 0 (closure (f94196 f94197 f94198) () (let ((f94196 f94196) (f94197 f94197) (f94198 f94198)) (char=? (string-ref f94196 f94198) (string-ref f94197 f94198))))) (vector-set! f94176 0 (closure (f94192 f94193 f94194 f94195) (f94177 f94176) (let ((f94192 f94192) (f94193 f94193) (f94194 f94194) (f94195 f94195)) (if (fx= f94194 f94195) #t (if ((vector-ref f94177 0) f94192 f94193 f94194) ((vector-ref f94176 0) f94192 f94193 (fx+ f94194 1) f94195) #f))))) (vector-set! f94175 0 (closure (f94190 f94191) (f94178 f94176) (let ((f94190 f94190) (f94191 f94191)) (if ((vector-ref f94178 0) f94190 f94191) ((vector-ref f94176 0) f94190 f94191 0 (string-length f94190)) #f))))) (vector-ref f94175 0)))
# == eliminate-when/unless  ==>
# (let ((f94178 (make-vector 1)) (f94177 (make-vector 1)) (f94176 (make-vector 1)) (f94175 (make-vector 1))) (begin (begin (vector-set! f94178 0 (closure (f94199 f94200) () (let ((f94199 f94199) (f94200 f94200)) (fx= (string-length f94199) (string-length f94200))))) (vector-set! f94177 0 (closure (f94196 f94197 f94198) () (let ((f94196 f94196) (f94197 f94197) (f94198 f94198)) (char=? (string-ref f94196 f94198) (string-ref f94197 f94198))))) (vector-set! f94176 0 (closure (f94192 f94193 f94194 f94195) (f94177 f94176) (let ((f94192 f94192) (f94193 f94193) (f94194 f94194) (f94195 f94195)) (if (fx= f94194 f94195) #t (if ((vector-ref f94177 0) f94192 f94193 f94194) ((vector-ref f94176 0) f94192 f94193 (fx+ f94194 1) f94195) #f))))) (vector-set! f94175 0 (closure (f94190 f94191) (f94178 f94176) (let ((f94190 f94190) (f94191 f94191)) (if ((vector-ref f94178 0) f94190 f94191) ((vector-ref f94176 0) f94190 f94191 0 (string-length f94190)) #f))))) (vector-ref f94175 0)))
# == eliminate-cond  ==>
# (let ((f94178 (make-vector 1)) (f94177 (make-vector 1)) (f94176 (make-vector 1)) (f94175 (make-vector 1))) (begin (begin (vector-set! f94178 0 (closure (f94199 f94200) () (let ((f94199 f94199) (f94200 f94200)) (fx= (string-length f94199) (string-length f94200))))) (vector-set! f94177 0 (closure (f94196 f94197 f94198) () (let ((f94196 f94196) (f94197 f94197) (f94198 f94198)) (char=? (string-ref f94196 f94198) (string-ref f94197 f94198))))) (vector-set! f94176 0 (closure (f94192 f94193 f94194 f94195) (f94177 f94176) (let ((f94192 f94192) (f94193 f94193) (f94194 f94194) (f94195 f94195)) (if (fx= f94194 f94195) #t (if ((vector-ref f94177 0) f94192 f94193 f94194) ((vector-ref f94176 0) f94192 f94193 (fx+ f94194 1) f94195) #f))))) (vector-set! f94175 0 (closure (f94190 f94191) (f94178 f94176) (let ((f94190 f94190) (f94191 f94191)) (if ((vector-ref f94178 0) f94190 f94191) ((vector-ref f94176 0) f94190 f94191 0 (string-length f94190)) #f))))) (vector-ref f94175 0)))
# == external-symbols  ==>
# (let ((f94178 (make-vector 1)) (f94177 (make-vector 1)) (f94176 (make-vector 1)) (f94175 (make-vector 1))) (begin (begin (vector-set! f94178 0 (closure (f94199 f94200) () (let ((f94199 f94199) (f94200 f94200)) (fx= (string-length f94199) (string-length f94200))))) (vector-set! f94177 0 (closure (f94196 f94197 f94198) () (let ((f94196 f94196) (f94197 f94197) (f94198 f94198)) (char=? (string-ref f94196 f94198) (string-ref f94197 f94198))))) (vector-set! f94176 0 (closure (f94192 f94193 f94194 f94195) (f94177 f94176) (let ((f94192 f94192) (f94193 f94193) (f94194 f94194) (f94195 f94195)) (if (fx= f94194 f94195) #t (if ((vector-ref f94177 0) f94192 f94193 f94194) ((vector-ref f94176 0) f94192 f94193 (fx+ f94194 1) f94195) #f))))) (vector-set! f94175 0 (closure (f94190 f94191) (f94178 f94176) (let ((f94190 f94190) (f94191 f94191)) (if ((vector-ref f94178 0) f94190 f94191) ((vector-ref f94176 0) f94190 f94191 0 (string-length f94190)) #f))))) (vector-ref f94175 0)))
# emit-expr (let ((f94178 (make-vector 1)) (f94177 (make-vector 1)) (f94176 (make-vector 1)) (f94175 (make-vector 1))) (begin (begin (vector-set! f94178 0 (closure (f94199 f94200) () (let ((f94199 f94199) (f94200 f94200)) (fx= (string-length f94199) (string-length f94200))))) (vector-set! f94177 0 (closure (f94196 f94197 f94198) () (let ((f94196 f94196) (f94197 f94197) (f94198 f94198)) (char=? (string-ref f94196 f94198) (string-ref f94197 f94198))))) (vector-set! f94176 0 (closure (f94192 f94193 f94194 f94195) (f94177 f94176) (let ((f94192 f94192) (f94193 f94193) (f94194 f94194) (f94195 f94195)) (if (fx= f94194 f94195) #t (if ((vector-ref f94177 0) f94192 f94193 f94194) ((vector-ref f94176 0) f94192 f94193 (fx+ f94194 1) f94195) #f))))) (vector-set! f94175 0 (closure (f94190 f94191) (f94178 f94176) (let ((f94190 f94190) (f94191 f94191)) (if ((vector-ref f94178 0) f94190 f94191) ((vector-ref f94176 0) f94190 f94191 0 (string-length f94190)) #f))))) (vector-ref f94175 0)))
# emit-let
#  si   = 0
#  env  = ()
#  bindings = ((f94178 (make-vector 1)) (f94177 (make-vector 1)) (f94176 (make-vector 1)) (f94175 (make-vector 1)))
#  body = (begin (begin (vector-set! f94178 0 (closure (f94199 f94200) () (let ((f94199 f94199) (f94200 f94200)) (fx= (string-length f94199) (string-length f94200))))) (vector-set! f94177 0 (closure (f94196 f94197 f94198) () (let ((f94196 f94196) (f94197 f94197) (f94198 f94198)) (char=? (string-ref f94196 f94198) (string-ref f94197 f94198))))) (vector-set! f94176 0 (closure (f94192 f94193 f94194 f94195) (f94177 f94176) (let ((f94192 f94192) (f94193 f94193) (f94194 f94194) (f94195 f94195)) (if (fx= f94194 f94195) #t (if ((vector-ref f94177 0) f94192 f94193 f94194) ((vector-ref f94176 0) f94192 f94193 (fx+ f94194 1) f94195) #f))))) (vector-set! f94175 0 (closure (f94190 f94191) (f94178 f94176) (let ((f94190 f94190) (f94191 f94191)) (if ((vector-ref f94178 0) f94190 f94191) ((vector-ref f94176 0) f94190 f94191 0 (string-length f94190)) #f))))) (vector-ref f94175 0))
# emit-expr (make-vector 1)
# make-vector 1
# emit-expr 1
    movl $4, %eax     # immed 1
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_570464"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_570464:
# check the argument is a fixnum >= 0
    cmp $0,%eax
    jge _L_570465
# invoke error handler eh_length
    .extern mrc_eh$ulength
    movl mrc_eh$ulength, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_570465:
    movl %eax, %esi
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    orl  $5, %eax
    addl $4, %esi
    addl $4, %esi
    andl $-8, %esi
    addl %esi, %ebp
    movl %eax, 0(%esp)  # stack save
# emit-expr (make-vector 1)
# make-vector 1
# emit-expr 1
    movl $4, %eax     # immed 1
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_570466"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_570466:
# check the argument is a fixnum >= 0
    cmp $0,%eax
    jge _L_570467
# invoke error handler eh_length
    .extern mrc_eh$ulength
    movl mrc_eh$ulength, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_570467:
    movl %eax, %esi
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    orl  $5, %eax
    addl $4, %esi
    addl $4, %esi
    andl $-8, %esi
    addl %esi, %ebp
    movl %eax, -4(%esp)  # stack save
# emit-expr (make-vector 1)
# make-vector 1
# emit-expr 1
    movl $4, %eax     # immed 1
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_570468"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_570468:
# check the argument is a fixnum >= 0
    cmp $0,%eax
    jge _L_570469
# invoke error handler eh_length
    .extern mrc_eh$ulength
    movl mrc_eh$ulength, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_570469:
    movl %eax, %esi
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    orl  $5, %eax
    addl $4, %esi
    addl $4, %esi
    andl $-8, %esi
    addl %esi, %ebp
    movl %eax, -8(%esp)  # stack save
# emit-expr (make-vector 1)
# make-vector 1
# emit-expr 1
    movl $4, %eax     # immed 1
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_570470"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_570470:
# check the argument is a fixnum >= 0
    cmp $0,%eax
    jge _L_570471
# invoke error handler eh_length
    .extern mrc_eh$ulength
    movl mrc_eh$ulength, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_570471:
    movl %eax, %esi
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    orl  $5, %eax
    addl $4, %esi
    addl $4, %esi
    andl $-8, %esi
    addl %esi, %ebp
    movl %eax, -12(%esp)  # stack save
# emit-expr (begin (begin (vector-set! f94178 0 (closure (f94199 f94200) () (let ((f94199 f94199) (f94200 f94200)) (fx= (string-length f94199) (string-length f94200))))) (vector-set! f94177 0 (closure (f94196 f94197 f94198) () (let ((f94196 f94196) (f94197 f94197) (f94198 f94198)) (char=? (string-ref f94196 f94198) (string-ref f94197 f94198))))) (vector-set! f94176 0 (closure (f94192 f94193 f94194 f94195) (f94177 f94176) (let ((f94192 f94192) (f94193 f94193) (f94194 f94194) (f94195 f94195)) (if (fx= f94194 f94195) #t (if ((vector-ref f94177 0) f94192 f94193 f94194) ((vector-ref f94176 0) f94192 f94193 (fx+ f94194 1) f94195) #f))))) (vector-set! f94175 0 (closure (f94190 f94191) (f94178 f94176) (let ((f94190 f94190) (f94191 f94191)) (if ((vector-ref f94178 0) f94190 f94191) ((vector-ref f94176 0) f94190 f94191 0 (string-length f94190)) #f))))) (vector-ref f94175 0))
# emit-begin
#   expr=(begin (begin (vector-set! f94178 0 (closure (f94199 f94200) () (let ((f94199 f94199) (f94200 f94200)) (fx= (string-length f94199) (string-length f94200))))) (vector-set! f94177 0 (closure (f94196 f94197 f94198) () (let ((f94196 f94196) (f94197 f94197) (f94198 f94198)) (char=? (string-ref f94196 f94198) (string-ref f94197 f94198))))) (vector-set! f94176 0 (closure (f94192 f94193 f94194 f94195) (f94177 f94176) (let ((f94192 f94192) (f94193 f94193) (f94194 f94194) (f94195 f94195)) (if (fx= f94194 f94195) #t (if ((vector-ref f94177 0) f94192 f94193 f94194) ((vector-ref f94176 0) f94192 f94193 (fx+ f94194 1) f94195) #f))))) (vector-set! f94175 0 (closure (f94190 f94191) (f94178 f94176) (let ((f94190 f94190) (f94191 f94191)) (if ((vector-ref f94178 0) f94190 f94191) ((vector-ref f94176 0) f94190 f94191 0 (string-length f94190)) #f))))) (vector-ref f94175 0))
#   env=((f94175 . -12) (f94176 . -8) (f94177 . -4) (f94178 . 0))
# emit-expr (begin (vector-set! f94178 0 (closure (f94199 f94200) () (let ((f94199 f94199) (f94200 f94200)) (fx= (string-length f94199) (string-length f94200))))) (vector-set! f94177 0 (closure (f94196 f94197 f94198) () (let ((f94196 f94196) (f94197 f94197) (f94198 f94198)) (char=? (string-ref f94196 f94198) (string-ref f94197 f94198))))) (vector-set! f94176 0 (closure (f94192 f94193 f94194 f94195) (f94177 f94176) (let ((f94192 f94192) (f94193 f94193) (f94194 f94194) (f94195 f94195)) (if (fx= f94194 f94195) #t (if ((vector-ref f94177 0) f94192 f94193 f94194) ((vector-ref f94176 0) f94192 f94193 (fx+ f94194 1) f94195) #f))))) (vector-set! f94175 0 (closure (f94190 f94191) (f94178 f94176) (let ((f94190 f94190) (f94191 f94191)) (if ((vector-ref f94178 0) f94190 f94191) ((vector-ref f94176 0) f94190 f94191 0 (string-length f94190)) #f)))))
# emit-begin
#   expr=(begin (vector-set! f94178 0 (closure (f94199 f94200) () (let ((f94199 f94199) (f94200 f94200)) (fx= (string-length f94199) (string-length f94200))))) (vector-set! f94177 0 (closure (f94196 f94197 f94198) () (let ((f94196 f94196) (f94197 f94197) (f94198 f94198)) (char=? (string-ref f94196 f94198) (string-ref f94197 f94198))))) (vector-set! f94176 0 (closure (f94192 f94193 f94194 f94195) (f94177 f94176) (let ((f94192 f94192) (f94193 f94193) (f94194 f94194) (f94195 f94195)) (if (fx= f94194 f94195) #t (if ((vector-ref f94177 0) f94192 f94193 f94194) ((vector-ref f94176 0) f94192 f94193 (fx+ f94194 1) f94195) #f))))) (vector-set! f94175 0 (closure (f94190 f94191) (f94178 f94176) (let ((f94190 f94190) (f94191 f94191)) (if ((vector-ref f94178 0) f94190 f94191) ((vector-ref f94176 0) f94190 f94191 0 (string-length f94190)) #f)))))
#   env=((f94175 . -12) (f94176 . -8) (f94177 . -4) (f94178 . 0))
# emit-expr (vector-set! f94178 0 (closure (f94199 f94200) () (let ((f94199 f94199) (f94200 f94200)) (fx= (string-length f94199) (string-length f94200)))))
# emit-expr f94178
# emit-variable-ref
# env=((f94175 . -12) (f94176 . -8) (f94177 . -4) (f94178 . 0))
# var=f94178
    movl 0(%esp), %eax  # stack load f94178
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_570472
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_570472:
    movl %eax, -16(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_570473"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_570473:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_570475
    cmp  $0,%eax
    jge _L_570474
_L_570475:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_570474:
    movl %eax, -20(%esp)
# emit-expr (closure (f94199 f94200) () (let ((f94199 f94199) (f94200 f94200)) (fx= (string-length f94199) (string-length f94200))))
# emit-closure
# si = -24
# env = ((f94175 . -12) (f94176 . -8) (f94177 . -4) (f94178 . 0))
# expr = (closure (f94199 f94200) () (let ((f94199 f94199) (f94200 f94200)) (fx= (string-length f94199) (string-length f94200))))
    movl $_L_570476, 0(%ebp)  # closure label
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $8, %ebp     # bump ebp
    jmp _L_570477            # jump around closure body
_L_570476:
# check argument count
    cmp $8,%eax
    je _L_570478
# invoke error handler eh_argcount
    .extern mrc_eh$uargcount
    movl mrc_eh$uargcount, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_570478:
# emit-tail-expr
# si=-16
# env=((f94200 . -12) (f94199 . -8) (f94175 . -12) (f94176 . -8) (f94177 . -4) (f94178 . 0))
# expr=(let ((f94199 f94199) (f94200 f94200)) (fx= (string-length f94199) (string-length f94200)))
# emit-tail-let
#  si   = -16
#  env  = ((f94200 . -12) (f94199 . -8) (f94175 . -12) (f94176 . -8) (f94177 . -4) (f94178 . 0))
#  bindings = ((f94199 f94199) (f94200 f94200))
#  body = (fx= (string-length f94199) (string-length f94200))
# emit-expr f94199
# emit-variable-ref
# env=((f94200 . -12) (f94199 . -8) (f94175 . -12) (f94176 . -8) (f94177 . -4) (f94178 . 0))
# var=f94199
    movl -8(%esp), %eax  # stack load f94199
# end emit-variable-ref
    movl %eax, -16(%esp)  # stack save
# emit-expr f94200
# emit-variable-ref
# env=((f94200 . -12) (f94199 . -8) (f94175 . -12) (f94176 . -8) (f94177 . -4) (f94178 . 0))
# var=f94200
    movl -12(%esp), %eax  # stack load f94200
# end emit-variable-ref
    movl %eax, -20(%esp)  # stack save
# emit-tail-expr
# si=-24
# env=((f94200 . -20) (f94199 . -16) (f94200 . -12) (f94199 . -8) (f94175 . -12) (f94176 . -8) (f94177 . -4) (f94178 . 0))
# expr=(fx= (string-length f94199) (string-length f94200))
# tail primcall
# emit-expr (string-length f94200)
# emit-expr f94200
# emit-variable-ref
# env=((f94200 . -20) (f94199 . -16) (f94200 . -12) (f94199 . -8) (f94175 . -12) (f94176 . -8) (f94177 . -4) (f94178 . 0))
# var=f94200
    movl -20(%esp), %eax  # stack load f94200
# end emit-variable-ref
# check the argument is a string
    movl %eax,%ebx
    and $7, %bl
    cmp $6, %bl
    je _L_570479
# invoke error handler eh_string
    .extern mrc_eh$ustring
    movl mrc_eh$ustring, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $160,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_570479:
    movl -6(%eax), %eax
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_570480"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $68,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_570480:
    movl %eax, -24(%esp)
# emit-expr (string-length f94199)
# emit-expr f94199
# emit-variable-ref
# env=((f94200 . -20) (f94199 . -16) (f94200 . -12) (f94199 . -8) (f94175 . -12) (f94176 . -8) (f94177 . -4) (f94178 . 0))
# var=f94199
    movl -16(%esp), %eax  # stack load f94199
# end emit-variable-ref
# check the argument is a string
    movl %eax,%ebx
    and $7, %bl
    cmp $6, %bl
    je _L_570481
# invoke error handler eh_string
    .extern mrc_eh$ustring
    movl mrc_eh$ustring, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $160,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_570481:
    movl -6(%eax), %eax
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_570482"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $68,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_570482:
    cmp -24(%esp), %eax
    sete %al
    movzbl %al, %eax
    sal $6, %al
    or $47, %al
#return from tail (fx= (string-length f94199) (string-length f94200))
    ret
    .align 4,0x90
_L_570477:
    movl -16(%esp), %ebx
    movl -20(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin (vector-set! f94177 0 (closure (f94196 f94197 f94198) () (let ((f94196 f94196) (f94197 f94197) (f94198 f94198)) (char=? (string-ref f94196 f94198) (string-ref f94197 f94198))))) (vector-set! f94176 0 (closure (f94192 f94193 f94194 f94195) (f94177 f94176) (let ((f94192 f94192) (f94193 f94193) (f94194 f94194) (f94195 f94195)) (if (fx= f94194 f94195) #t (if ((vector-ref f94177 0) f94192 f94193 f94194) ((vector-ref f94176 0) f94192 f94193 (fx+ f94194 1) f94195) #f))))) (vector-set! f94175 0 (closure (f94190 f94191) (f94178 f94176) (let ((f94190 f94190) (f94191 f94191)) (if ((vector-ref f94178 0) f94190 f94191) ((vector-ref f94176 0) f94190 f94191 0 (string-length f94190)) #f)))))
# emit-begin
#   expr=(begin (vector-set! f94177 0 (closure (f94196 f94197 f94198) () (let ((f94196 f94196) (f94197 f94197) (f94198 f94198)) (char=? (string-ref f94196 f94198) (string-ref f94197 f94198))))) (vector-set! f94176 0 (closure (f94192 f94193 f94194 f94195) (f94177 f94176) (let ((f94192 f94192) (f94193 f94193) (f94194 f94194) (f94195 f94195)) (if (fx= f94194 f94195) #t (if ((vector-ref f94177 0) f94192 f94193 f94194) ((vector-ref f94176 0) f94192 f94193 (fx+ f94194 1) f94195) #f))))) (vector-set! f94175 0 (closure (f94190 f94191) (f94178 f94176) (let ((f94190 f94190) (f94191 f94191)) (if ((vector-ref f94178 0) f94190 f94191) ((vector-ref f94176 0) f94190 f94191 0 (string-length f94190)) #f)))))
#   env=((f94175 . -12) (f94176 . -8) (f94177 . -4) (f94178 . 0))
# emit-expr (vector-set! f94177 0 (closure (f94196 f94197 f94198) () (let ((f94196 f94196) (f94197 f94197) (f94198 f94198)) (char=? (string-ref f94196 f94198) (string-ref f94197 f94198)))))
# emit-expr f94177
# emit-variable-ref
# env=((f94175 . -12) (f94176 . -8) (f94177 . -4) (f94178 . 0))
# var=f94177
    movl -4(%esp), %eax  # stack load f94177
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_570483
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_570483:
    movl %eax, -16(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_570484"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_570484:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_570486
    cmp  $0,%eax
    jge _L_570485
_L_570486:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_570485:
    movl %eax, -20(%esp)
# emit-expr (closure (f94196 f94197 f94198) () (let ((f94196 f94196) (f94197 f94197) (f94198 f94198)) (char=? (string-ref f94196 f94198) (string-ref f94197 f94198))))
# emit-closure
# si = -24
# env = ((f94175 . -12) (f94176 . -8) (f94177 . -4) (f94178 . 0))
# expr = (closure (f94196 f94197 f94198) () (let ((f94196 f94196) (f94197 f94197) (f94198 f94198)) (char=? (string-ref f94196 f94198) (string-ref f94197 f94198))))
    movl $_L_570487, 0(%ebp)  # closure label
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $8, %ebp     # bump ebp
    jmp _L_570488            # jump around closure body
_L_570487:
# check argument count
    cmp $12,%eax
    je _L_570489
# invoke error handler eh_argcount
    .extern mrc_eh$uargcount
    movl mrc_eh$uargcount, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_570489:
# emit-tail-expr
# si=-20
# env=((f94198 . -16) (f94197 . -12) (f94196 . -8) (f94175 . -12) (f94176 . -8) (f94177 . -4) (f94178 . 0))
# expr=(let ((f94196 f94196) (f94197 f94197) (f94198 f94198)) (char=? (string-ref f94196 f94198) (string-ref f94197 f94198)))
# emit-tail-let
#  si   = -20
#  env  = ((f94198 . -16) (f94197 . -12) (f94196 . -8) (f94175 . -12) (f94176 . -8) (f94177 . -4) (f94178 . 0))
#  bindings = ((f94196 f94196) (f94197 f94197) (f94198 f94198))
#  body = (char=? (string-ref f94196 f94198) (string-ref f94197 f94198))
# emit-expr f94196
# emit-variable-ref
# env=((f94198 . -16) (f94197 . -12) (f94196 . -8) (f94175 . -12) (f94176 . -8) (f94177 . -4) (f94178 . 0))
# var=f94196
    movl -8(%esp), %eax  # stack load f94196
# end emit-variable-ref
    movl %eax, -20(%esp)  # stack save
# emit-expr f94197
# emit-variable-ref
# env=((f94198 . -16) (f94197 . -12) (f94196 . -8) (f94175 . -12) (f94176 . -8) (f94177 . -4) (f94178 . 0))
# var=f94197
    movl -12(%esp), %eax  # stack load f94197
# end emit-variable-ref
    movl %eax, -24(%esp)  # stack save
# emit-expr f94198
# emit-variable-ref
# env=((f94198 . -16) (f94197 . -12) (f94196 . -8) (f94175 . -12) (f94176 . -8) (f94177 . -4) (f94178 . 0))
# var=f94198
    movl -16(%esp), %eax  # stack load f94198
# end emit-variable-ref
    movl %eax, -28(%esp)  # stack save
# emit-tail-expr
# si=-32
# env=((f94198 . -28) (f94197 . -24) (f94196 . -20) (f94198 . -16) (f94197 . -12) (f94196 . -8) (f94175 . -12) (f94176 . -8) (f94177 . -4) (f94178 . 0))
# expr=(char=? (string-ref f94196 f94198) (string-ref f94197 f94198))
# tail primcall
# char= c1=(string-ref f94196 f94198) c2=(string-ref f94197 f94198)
# emit-expr (string-ref f94196 f94198)
# emit-expr f94196
# emit-variable-ref
# env=((f94198 . -28) (f94197 . -24) (f94196 . -20) (f94198 . -16) (f94197 . -12) (f94196 . -8) (f94175 . -12) (f94176 . -8) (f94177 . -4) (f94178 . 0))
# var=f94196
    movl -20(%esp), %eax  # stack load f94196
# end emit-variable-ref
# check the argument is a string
    movl %eax,%ebx
    and $7, %bl
    cmp $6, %bl
    je _L_570490
# invoke error handler eh_string
    .extern mrc_eh$ustring
    movl mrc_eh$ustring, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $164,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_570490:
    movl %eax, -32(%esp)
# emit-expr f94198
# emit-variable-ref
# env=((f94198 . -28) (f94197 . -24) (f94196 . -20) (f94198 . -16) (f94197 . -12) (f94196 . -8) (f94175 . -12) (f94176 . -8) (f94177 . -4) (f94178 . 0))
# var=f94198
    movl -28(%esp), %eax  # stack load f94198
# end emit-variable-ref
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_570491"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $164,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_570491:
# check bounds on string index
    movl -32(%esp), %ebx
    cmp  %eax,-6(%ebx) 
    jle _L_570493
    cmp  $0,%eax
    jge _L_570492
_L_570493:
# invoke error handler eh_string_index
    .extern mrc_eh$ustring$uindex
    movl mrc_eh$ustring$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $164,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_570492:
    sar $2, %eax
    movl -32(%esp), %esi
    movl -2(%eax,%esi), %eax
    sal $8, %eax
    or  $15, %eax
# check the argument is a char
    movl %eax,%ebx
    and $255, %bl
    cmp $15, %bl
    je "_L_570494"
# invoke error handler eh_character
    .extern mrc_eh$ucharacter
    movl mrc_eh$ucharacter, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $40,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_570494:
    movb %ah, -32(%esp)
# emit-expr (string-ref f94197 f94198)
# emit-expr f94197
# emit-variable-ref
# env=((f94198 . -28) (f94197 . -24) (f94196 . -20) (f94198 . -16) (f94197 . -12) (f94196 . -8) (f94175 . -12) (f94176 . -8) (f94177 . -4) (f94178 . 0))
# var=f94197
    movl -24(%esp), %eax  # stack load f94197
# end emit-variable-ref
# check the argument is a string
    movl %eax,%ebx
    and $7, %bl
    cmp $6, %bl
    je _L_570495
# invoke error handler eh_string
    .extern mrc_eh$ustring
    movl mrc_eh$ustring, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $164,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_570495:
    movl %eax, -36(%esp)
# emit-expr f94198
# emit-variable-ref
# env=((f94198 . -28) (f94197 . -24) (f94196 . -20) (f94198 . -16) (f94197 . -12) (f94196 . -8) (f94175 . -12) (f94176 . -8) (f94177 . -4) (f94178 . 0))
# var=f94198
    movl -28(%esp), %eax  # stack load f94198
# end emit-variable-ref
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_570496"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $164,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_570496:
# check bounds on string index
    movl -36(%esp), %ebx
    cmp  %eax,-6(%ebx) 
    jle _L_570498
    cmp  $0,%eax
    jge _L_570497
_L_570498:
# invoke error handler eh_string_index
    .extern mrc_eh$ustring$uindex
    movl mrc_eh$ustring$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $164,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_570497:
    sar $2, %eax
    movl -36(%esp), %esi
    movl -2(%eax,%esi), %eax
    sal $8, %eax
    or  $15, %eax
# check the argument is a char
    movl %eax,%ebx
    and $255, %bl
    cmp $15, %bl
    je "_L_570499"
# invoke error handler eh_character
    .extern mrc_eh$ucharacter
    movl mrc_eh$ucharacter, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $40,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_570499:
    cmp %ah, -32(%esp)
    sete %al
    movzbl %al, %eax
    sal $6, %al
    or $47, %al
#return from tail (char=? (string-ref f94196 f94198) (string-ref f94197 f94198))
    ret
    .align 4,0x90
_L_570488:
    movl -16(%esp), %ebx
    movl -20(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin (vector-set! f94176 0 (closure (f94192 f94193 f94194 f94195) (f94177 f94176) (let ((f94192 f94192) (f94193 f94193) (f94194 f94194) (f94195 f94195)) (if (fx= f94194 f94195) #t (if ((vector-ref f94177 0) f94192 f94193 f94194) ((vector-ref f94176 0) f94192 f94193 (fx+ f94194 1) f94195) #f))))) (vector-set! f94175 0 (closure (f94190 f94191) (f94178 f94176) (let ((f94190 f94190) (f94191 f94191)) (if ((vector-ref f94178 0) f94190 f94191) ((vector-ref f94176 0) f94190 f94191 0 (string-length f94190)) #f)))))
# emit-begin
#   expr=(begin (vector-set! f94176 0 (closure (f94192 f94193 f94194 f94195) (f94177 f94176) (let ((f94192 f94192) (f94193 f94193) (f94194 f94194) (f94195 f94195)) (if (fx= f94194 f94195) #t (if ((vector-ref f94177 0) f94192 f94193 f94194) ((vector-ref f94176 0) f94192 f94193 (fx+ f94194 1) f94195) #f))))) (vector-set! f94175 0 (closure (f94190 f94191) (f94178 f94176) (let ((f94190 f94190) (f94191 f94191)) (if ((vector-ref f94178 0) f94190 f94191) ((vector-ref f94176 0) f94190 f94191 0 (string-length f94190)) #f)))))
#   env=((f94175 . -12) (f94176 . -8) (f94177 . -4) (f94178 . 0))
# emit-expr (vector-set! f94176 0 (closure (f94192 f94193 f94194 f94195) (f94177 f94176) (let ((f94192 f94192) (f94193 f94193) (f94194 f94194) (f94195 f94195)) (if (fx= f94194 f94195) #t (if ((vector-ref f94177 0) f94192 f94193 f94194) ((vector-ref f94176 0) f94192 f94193 (fx+ f94194 1) f94195) #f)))))
# emit-expr f94176
# emit-variable-ref
# env=((f94175 . -12) (f94176 . -8) (f94177 . -4) (f94178 . 0))
# var=f94176
    movl -8(%esp), %eax  # stack load f94176
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_570500
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_570500:
    movl %eax, -16(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_570501"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_570501:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_570503
    cmp  $0,%eax
    jge _L_570502
_L_570503:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_570502:
    movl %eax, -20(%esp)
# emit-expr (closure (f94192 f94193 f94194 f94195) (f94177 f94176) (let ((f94192 f94192) (f94193 f94193) (f94194 f94194) (f94195 f94195)) (if (fx= f94194 f94195) #t (if ((vector-ref f94177 0) f94192 f94193 f94194) ((vector-ref f94176 0) f94192 f94193 (fx+ f94194 1) f94195) #f))))
# emit-closure
# si = -24
# env = ((f94175 . -12) (f94176 . -8) (f94177 . -4) (f94178 . 0))
# expr = (closure (f94192 f94193 f94194 f94195) (f94177 f94176) (let ((f94192 f94192) (f94193 f94193) (f94194 f94194) (f94195 f94195)) (if (fx= f94194 f94195) #t (if ((vector-ref f94177 0) f94192 f94193 f94194) ((vector-ref f94176 0) f94192 f94193 (fx+ f94194 1) f94195) #f))))
    movl $_L_570504, 0(%ebp)  # closure label
# emit-variable-ref
# env=((f94175 . -12) (f94176 . -8) (f94177 . -4) (f94178 . 0))
# var=f94177
    movl -4(%esp), %eax  # stack load f94177
# end emit-variable-ref
   movl  %eax, 4(%ebp)  # f94177
# emit-variable-ref
# env=((f94175 . -12) (f94176 . -8) (f94177 . -4) (f94178 . 0))
# var=f94176
    movl -8(%esp), %eax  # stack load f94176
# end emit-variable-ref
   movl  %eax, 8(%ebp)  # f94176
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $16, %ebp     # bump ebp
    jmp _L_570505            # jump around closure body
_L_570504:
# check argument count
    cmp $16,%eax
    je _L_570506
# invoke error handler eh_argcount
    .extern mrc_eh$uargcount
    movl mrc_eh$uargcount, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_570506:
# emit-tail-expr
# si=-24
# env=((f94195 . -20) (f94194 . -16) (f94193 . -12) (f94192 . -8) (f94176 . 8) (f94177 . 4) (f94175 . -12) (f94176 . -8) (f94177 . -4) (f94178 . 0))
# expr=(let ((f94192 f94192) (f94193 f94193) (f94194 f94194) (f94195 f94195)) (if (fx= f94194 f94195) #t (if ((vector-ref f94177 0) f94192 f94193 f94194) ((vector-ref f94176 0) f94192 f94193 (fx+ f94194 1) f94195) #f)))
# emit-tail-let
#  si   = -24
#  env  = ((f94195 . -20) (f94194 . -16) (f94193 . -12) (f94192 . -8) (f94176 . 8) (f94177 . 4) (f94175 . -12) (f94176 . -8) (f94177 . -4) (f94178 . 0))
#  bindings = ((f94192 f94192) (f94193 f94193) (f94194 f94194) (f94195 f94195))
#  body = (if (fx= f94194 f94195) #t (if ((vector-ref f94177 0) f94192 f94193 f94194) ((vector-ref f94176 0) f94192 f94193 (fx+ f94194 1) f94195) #f))
# emit-expr f94192
# emit-variable-ref
# env=((f94195 . -20) (f94194 . -16) (f94193 . -12) (f94192 . -8) (f94176 . 8) (f94177 . 4) (f94175 . -12) (f94176 . -8) (f94177 . -4) (f94178 . 0))
# var=f94192
    movl -8(%esp), %eax  # stack load f94192
# end emit-variable-ref
    movl %eax, -24(%esp)  # stack save
# emit-expr f94193
# emit-variable-ref
# env=((f94195 . -20) (f94194 . -16) (f94193 . -12) (f94192 . -8) (f94176 . 8) (f94177 . 4) (f94175 . -12) (f94176 . -8) (f94177 . -4) (f94178 . 0))
# var=f94193
    movl -12(%esp), %eax  # stack load f94193
# end emit-variable-ref
    movl %eax, -28(%esp)  # stack save
# emit-expr f94194
# emit-variable-ref
# env=((f94195 . -20) (f94194 . -16) (f94193 . -12) (f94192 . -8) (f94176 . 8) (f94177 . 4) (f94175 . -12) (f94176 . -8) (f94177 . -4) (f94178 . 0))
# var=f94194
    movl -16(%esp), %eax  # stack load f94194
# end emit-variable-ref
    movl %eax, -32(%esp)  # stack save
# emit-expr f94195
# emit-variable-ref
# env=((f94195 . -20) (f94194 . -16) (f94193 . -12) (f94192 . -8) (f94176 . 8) (f94177 . 4) (f94175 . -12) (f94176 . -8) (f94177 . -4) (f94178 . 0))
# var=f94195
    movl -20(%esp), %eax  # stack load f94195
# end emit-variable-ref
    movl %eax, -36(%esp)  # stack save
# emit-tail-expr
# si=-40
# env=((f94195 . -36) (f94194 . -32) (f94193 . -28) (f94192 . -24) (f94195 . -20) (f94194 . -16) (f94193 . -12) (f94192 . -8) (f94176 . 8) (f94177 . 4) (f94175 . -12) (f94176 . -8) (f94177 . -4) (f94178 . 0))
# expr=(if (fx= f94194 f94195) #t (if ((vector-ref f94177 0) f94192 f94193 f94194) ((vector-ref f94176 0) f94192 f94193 (fx+ f94194 1) f94195) #f))
# emit-expr (fx= f94194 f94195)
# emit-expr f94195
# emit-variable-ref
# env=((f94195 . -36) (f94194 . -32) (f94193 . -28) (f94192 . -24) (f94195 . -20) (f94194 . -16) (f94193 . -12) (f94192 . -8) (f94176 . 8) (f94177 . 4) (f94175 . -12) (f94176 . -8) (f94177 . -4) (f94178 . 0))
# var=f94195
    movl -36(%esp), %eax  # stack load f94195
# end emit-variable-ref
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_570509"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $68,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_570509:
    movl %eax, -40(%esp)
# emit-expr f94194
# emit-variable-ref
# env=((f94195 . -36) (f94194 . -32) (f94193 . -28) (f94192 . -24) (f94195 . -20) (f94194 . -16) (f94193 . -12) (f94192 . -8) (f94176 . 8) (f94177 . 4) (f94175 . -12) (f94176 . -8) (f94177 . -4) (f94178 . 0))
# var=f94194
    movl -32(%esp), %eax  # stack load f94194
# end emit-variable-ref
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_570510"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $68,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_570510:
    cmp -40(%esp), %eax
    sete %al
    movzbl %al, %eax
    sal $6, %al
    or $47, %al
    cmp $47, %al
    je _L_570507
# emit-tail-expr
# si=-40
# env=((f94195 . -36) (f94194 . -32) (f94193 . -28) (f94192 . -24) (f94195 . -20) (f94194 . -16) (f94193 . -12) (f94192 . -8) (f94176 . 8) (f94177 . 4) (f94175 . -12) (f94176 . -8) (f94177 . -4) (f94178 . 0))
# expr=#t
    movl $111, %eax     # immed #t
    ret                  # immediate tail return
    jmp _L_570508
_L_570507:
# emit-tail-expr
# si=-40
# env=((f94195 . -36) (f94194 . -32) (f94193 . -28) (f94192 . -24) (f94195 . -20) (f94194 . -16) (f94193 . -12) (f94192 . -8) (f94176 . 8) (f94177 . 4) (f94175 . -12) (f94176 . -8) (f94177 . -4) (f94178 . 0))
# expr=(if ((vector-ref f94177 0) f94192 f94193 f94194) ((vector-ref f94176 0) f94192 f94193 (fx+ f94194 1) f94195) #f)
# emit-expr ((vector-ref f94177 0) f94192 f94193 f94194)
# funcall
#    si   =-40
#    env  = ((f94195 . -36) (f94194 . -32) (f94193 . -28) (f94192 . -24) (f94195 . -20) (f94194 . -16) (f94193 . -12) (f94192 . -8) (f94176 . 8) (f94177 . 4) (f94175 . -12) (f94176 . -8) (f94177 . -4) (f94178 . 0))
#    expr = (funcall (vector-ref f94177 0) f94192 f94193 f94194)
# emit-expr (vector-ref f94177 0)
# emit-expr f94177
# emit-variable-ref
# env=((f94195 . -36) (f94194 . -32) (f94193 . -28) (f94192 . -24) (f94195 . -20) (f94194 . -16) (f94193 . -12) (f94192 . -8) (f94176 . 8) (f94177 . 4) (f94175 . -12) (f94176 . -8) (f94177 . -4) (f94178 . 0))
# var=f94177
    movl 2(%edi), %eax  # frame load f94177
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_570513
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_570513:
    movl %eax, -48(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_570514"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_570514:
# check bounds on vector index
    movl -48(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_570516
    cmp  $0,%eax
    jge _L_570515
_L_570516:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_570515:
    movl -48(%esp), %esi
    movl -1(%eax,%esi), %eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_570517"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_570517":
   movl %eax,  -48(%esp)  # stash funcall-oper in closure slot
# emit-expr f94192
# emit-variable-ref
# env=((f94195 . -36) (f94194 . -32) (f94193 . -28) (f94192 . -24) (f94195 . -20) (f94194 . -16) (f94193 . -12) (f94192 . -8) (f94176 . 8) (f94177 . 4) (f94175 . -12) (f94176 . -8) (f94177 . -4) (f94178 . 0))
# var=f94192
    movl -24(%esp), %eax  # stack load f94192
# end emit-variable-ref
    mov %eax, -52(%esp)  # arg f94192
# emit-expr f94193
# emit-variable-ref
# env=((f94195 . -36) (f94194 . -32) (f94193 . -28) (f94192 . -24) (f94195 . -20) (f94194 . -16) (f94193 . -12) (f94192 . -8) (f94176 . 8) (f94177 . 4) (f94175 . -12) (f94176 . -8) (f94177 . -4) (f94178 . 0))
# var=f94193
    movl -28(%esp), %eax  # stack load f94193
# end emit-variable-ref
    mov %eax, -56(%esp)  # arg f94193
# emit-expr f94194
# emit-variable-ref
# env=((f94195 . -36) (f94194 . -32) (f94193 . -28) (f94192 . -24) (f94195 . -20) (f94194 . -16) (f94193 . -12) (f94192 . -8) (f94176 . 8) (f94177 . 4) (f94175 . -12) (f94176 . -8) (f94177 . -4) (f94178 . 0))
# var=f94194
    movl -32(%esp), %eax  # stack load f94194
# end emit-variable-ref
    mov %eax, -60(%esp)  # arg f94194
    movl -48(%esp), %edi   # load new closure to %edi
    add $-40, %esp   # adjust base
    movl $12,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $40, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    cmp $47, %al
    je _L_570511
# emit-tail-expr
# si=-40
# env=((f94195 . -36) (f94194 . -32) (f94193 . -28) (f94192 . -24) (f94195 . -20) (f94194 . -16) (f94193 . -12) (f94192 . -8) (f94176 . 8) (f94177 . 4) (f94175 . -12) (f94176 . -8) (f94177 . -4) (f94178 . 0))
# expr=((vector-ref f94176 0) f94192 f94193 (fx+ f94194 1) f94195)
# emit-tail-funcall
#    si   =-40
#    env  = ((f94195 . -36) (f94194 . -32) (f94193 . -28) (f94192 . -24) (f94195 . -20) (f94194 . -16) (f94193 . -12) (f94192 . -8) (f94176 . 8) (f94177 . 4) (f94175 . -12) (f94176 . -8) (f94177 . -4) (f94178 . 0))
#    expr = (funcall (vector-ref f94176 0) f94192 f94193 (fx+ f94194 1) f94195)
# emit-expr (vector-ref f94176 0)
# emit-expr f94176
# emit-variable-ref
# env=((f94195 . -36) (f94194 . -32) (f94193 . -28) (f94192 . -24) (f94195 . -20) (f94194 . -16) (f94193 . -12) (f94192 . -8) (f94176 . 8) (f94177 . 4) (f94175 . -12) (f94176 . -8) (f94177 . -4) (f94178 . 0))
# var=f94176
    movl 6(%edi), %eax  # frame load f94176
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_570518
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_570518:
    movl %eax, -40(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_570519"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_570519:
# check bounds on vector index
    movl -40(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_570521
    cmp  $0,%eax
    jge _L_570520
_L_570521:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_570520:
    movl -40(%esp), %esi
    movl -1(%eax,%esi), %eax
   movl %eax,  -40(%esp)  # stash funcall-oper in next closure slot
# emit-expr f94192
# emit-variable-ref
# env=((f94195 . -36) (f94194 . -32) (f94193 . -28) (f94192 . -24) (f94195 . -20) (f94194 . -16) (f94193 . -12) (f94192 . -8) (f94176 . 8) (f94177 . 4) (f94175 . -12) (f94176 . -8) (f94177 . -4) (f94178 . 0))
# var=f94192
    movl -24(%esp), %eax  # stack load f94192
# end emit-variable-ref
    mov %eax, -44(%esp)    # arg f94192
# emit-expr f94193
# emit-variable-ref
# env=((f94195 . -36) (f94194 . -32) (f94193 . -28) (f94192 . -24) (f94195 . -20) (f94194 . -16) (f94193 . -12) (f94192 . -8) (f94176 . 8) (f94177 . 4) (f94175 . -12) (f94176 . -8) (f94177 . -4) (f94178 . 0))
# var=f94193
    movl -28(%esp), %eax  # stack load f94193
# end emit-variable-ref
    mov %eax, -48(%esp)    # arg f94193
# emit-expr (fx+ f94194 1)
# emit-expr 1
    movl $4, %eax     # immed 1
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_570522"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $88,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_570522:
    movl %eax, -52(%esp)  # fx+ push arg1
# emit-expr f94194
# emit-variable-ref
# env=((f94195 . -36) (f94194 . -32) (f94193 . -28) (f94192 . -24) (f94195 . -20) (f94194 . -16) (f94193 . -12) (f94192 . -8) (f94176 . 8) (f94177 . 4) (f94175 . -12) (f94176 . -8) (f94177 . -4) (f94178 . 0))
# var=f94194
    movl -32(%esp), %eax  # stack load f94194
# end emit-variable-ref
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_570523"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $88,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_570523:
    addl -52(%esp), %eax  # fx+ arg1 arg2
    mov %eax, -52(%esp)    # arg (fx+ f94194 1)
# emit-expr f94195
# emit-variable-ref
# env=((f94195 . -36) (f94194 . -32) (f94193 . -28) (f94192 . -24) (f94195 . -20) (f94194 . -16) (f94193 . -12) (f94192 . -8) (f94176 . 8) (f94177 . 4) (f94175 . -12) (f94176 . -8) (f94177 . -4) (f94178 . 0))
# var=f94195
    movl -36(%esp), %eax  # stack load f94195
# end emit-variable-ref
    mov %eax, -56(%esp)    # arg f94195
    movl -40(%esp), %edi   # load new closure to %edi
# emit-shift-args:  size=5   si=-40  delta=36
    mov -40(%esp), %ebx  # shift frame cell
    mov %ebx, -4(%esp)  # down to base
# emit-shift-args:  size=4   si=-44  delta=36
    mov -44(%esp), %ebx  # shift frame cell
    mov %ebx, -8(%esp)  # down to base
# emit-shift-args:  size=3   si=-48  delta=36
    mov -48(%esp), %ebx  # shift frame cell
    mov %ebx, -12(%esp)  # down to base
# emit-shift-args:  size=2   si=-52  delta=36
    mov -52(%esp), %ebx  # shift frame cell
    mov %ebx, -16(%esp)  # down to base
# emit-shift-args:  size=1   si=-56  delta=36
    mov -56(%esp), %ebx  # shift frame cell
    mov %ebx, -20(%esp)  # down to base
# emit-shift-args:  size=0   si=-60  delta=36
    movl $16,%eax   # save arg count
    jmp *-2(%edi)  # tail-funcall
    jmp _L_570512
_L_570511:
# emit-tail-expr
# si=-40
# env=((f94195 . -36) (f94194 . -32) (f94193 . -28) (f94192 . -24) (f94195 . -20) (f94194 . -16) (f94193 . -12) (f94192 . -8) (f94176 . 8) (f94177 . 4) (f94175 . -12) (f94176 . -8) (f94177 . -4) (f94178 . 0))
# expr=#f
    movl $47, %eax     # immed #f
    ret                  # immediate tail return
_L_570512:
_L_570508:
    .align 4,0x90
_L_570505:
    movl -16(%esp), %ebx
    movl -20(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin (vector-set! f94175 0 (closure (f94190 f94191) (f94178 f94176) (let ((f94190 f94190) (f94191 f94191)) (if ((vector-ref f94178 0) f94190 f94191) ((vector-ref f94176 0) f94190 f94191 0 (string-length f94190)) #f)))))
# emit-begin
#   expr=(begin (vector-set! f94175 0 (closure (f94190 f94191) (f94178 f94176) (let ((f94190 f94190) (f94191 f94191)) (if ((vector-ref f94178 0) f94190 f94191) ((vector-ref f94176 0) f94190 f94191 0 (string-length f94190)) #f)))))
#   env=((f94175 . -12) (f94176 . -8) (f94177 . -4) (f94178 . 0))
# emit-expr (vector-set! f94175 0 (closure (f94190 f94191) (f94178 f94176) (let ((f94190 f94190) (f94191 f94191)) (if ((vector-ref f94178 0) f94190 f94191) ((vector-ref f94176 0) f94190 f94191 0 (string-length f94190)) #f))))
# emit-expr f94175
# emit-variable-ref
# env=((f94175 . -12) (f94176 . -8) (f94177 . -4) (f94178 . 0))
# var=f94175
    movl -12(%esp), %eax  # stack load f94175
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_570524
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_570524:
    movl %eax, -16(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_570525"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_570525:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_570527
    cmp  $0,%eax
    jge _L_570526
_L_570527:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_570526:
    movl %eax, -20(%esp)
# emit-expr (closure (f94190 f94191) (f94178 f94176) (let ((f94190 f94190) (f94191 f94191)) (if ((vector-ref f94178 0) f94190 f94191) ((vector-ref f94176 0) f94190 f94191 0 (string-length f94190)) #f)))
# emit-closure
# si = -24
# env = ((f94175 . -12) (f94176 . -8) (f94177 . -4) (f94178 . 0))
# expr = (closure (f94190 f94191) (f94178 f94176) (let ((f94190 f94190) (f94191 f94191)) (if ((vector-ref f94178 0) f94190 f94191) ((vector-ref f94176 0) f94190 f94191 0 (string-length f94190)) #f)))
    movl $_L_570528, 0(%ebp)  # closure label
# emit-variable-ref
# env=((f94175 . -12) (f94176 . -8) (f94177 . -4) (f94178 . 0))
# var=f94178
    movl 0(%esp), %eax  # stack load f94178
# end emit-variable-ref
   movl  %eax, 4(%ebp)  # f94178
# emit-variable-ref
# env=((f94175 . -12) (f94176 . -8) (f94177 . -4) (f94178 . 0))
# var=f94176
    movl -8(%esp), %eax  # stack load f94176
# end emit-variable-ref
   movl  %eax, 8(%ebp)  # f94176
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $16, %ebp     # bump ebp
    jmp _L_570529            # jump around closure body
_L_570528:
# check argument count
    cmp $8,%eax
    je _L_570530
# invoke error handler eh_argcount
    .extern mrc_eh$uargcount
    movl mrc_eh$uargcount, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_570530:
# emit-tail-expr
# si=-16
# env=((f94191 . -12) (f94190 . -8) (f94176 . 8) (f94178 . 4) (f94175 . -12) (f94176 . -8) (f94177 . -4) (f94178 . 0))
# expr=(let ((f94190 f94190) (f94191 f94191)) (if ((vector-ref f94178 0) f94190 f94191) ((vector-ref f94176 0) f94190 f94191 0 (string-length f94190)) #f))
# emit-tail-let
#  si   = -16
#  env  = ((f94191 . -12) (f94190 . -8) (f94176 . 8) (f94178 . 4) (f94175 . -12) (f94176 . -8) (f94177 . -4) (f94178 . 0))
#  bindings = ((f94190 f94190) (f94191 f94191))
#  body = (if ((vector-ref f94178 0) f94190 f94191) ((vector-ref f94176 0) f94190 f94191 0 (string-length f94190)) #f)
# emit-expr f94190
# emit-variable-ref
# env=((f94191 . -12) (f94190 . -8) (f94176 . 8) (f94178 . 4) (f94175 . -12) (f94176 . -8) (f94177 . -4) (f94178 . 0))
# var=f94190
    movl -8(%esp), %eax  # stack load f94190
# end emit-variable-ref
    movl %eax, -16(%esp)  # stack save
# emit-expr f94191
# emit-variable-ref
# env=((f94191 . -12) (f94190 . -8) (f94176 . 8) (f94178 . 4) (f94175 . -12) (f94176 . -8) (f94177 . -4) (f94178 . 0))
# var=f94191
    movl -12(%esp), %eax  # stack load f94191
# end emit-variable-ref
    movl %eax, -20(%esp)  # stack save
# emit-tail-expr
# si=-24
# env=((f94191 . -20) (f94190 . -16) (f94191 . -12) (f94190 . -8) (f94176 . 8) (f94178 . 4) (f94175 . -12) (f94176 . -8) (f94177 . -4) (f94178 . 0))
# expr=(if ((vector-ref f94178 0) f94190 f94191) ((vector-ref f94176 0) f94190 f94191 0 (string-length f94190)) #f)
# emit-expr ((vector-ref f94178 0) f94190 f94191)
# funcall
#    si   =-24
#    env  = ((f94191 . -20) (f94190 . -16) (f94191 . -12) (f94190 . -8) (f94176 . 8) (f94178 . 4) (f94175 . -12) (f94176 . -8) (f94177 . -4) (f94178 . 0))
#    expr = (funcall (vector-ref f94178 0) f94190 f94191)
# emit-expr (vector-ref f94178 0)
# emit-expr f94178
# emit-variable-ref
# env=((f94191 . -20) (f94190 . -16) (f94191 . -12) (f94190 . -8) (f94176 . 8) (f94178 . 4) (f94175 . -12) (f94176 . -8) (f94177 . -4) (f94178 . 0))
# var=f94178
    movl 2(%edi), %eax  # frame load f94178
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_570533
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_570533:
    movl %eax, -32(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_570534"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_570534:
# check bounds on vector index
    movl -32(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_570536
    cmp  $0,%eax
    jge _L_570535
_L_570536:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_570535:
    movl -32(%esp), %esi
    movl -1(%eax,%esi), %eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_570537"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_570537":
   movl %eax,  -32(%esp)  # stash funcall-oper in closure slot
# emit-expr f94190
# emit-variable-ref
# env=((f94191 . -20) (f94190 . -16) (f94191 . -12) (f94190 . -8) (f94176 . 8) (f94178 . 4) (f94175 . -12) (f94176 . -8) (f94177 . -4) (f94178 . 0))
# var=f94190
    movl -16(%esp), %eax  # stack load f94190
# end emit-variable-ref
    mov %eax, -36(%esp)  # arg f94190
# emit-expr f94191
# emit-variable-ref
# env=((f94191 . -20) (f94190 . -16) (f94191 . -12) (f94190 . -8) (f94176 . 8) (f94178 . 4) (f94175 . -12) (f94176 . -8) (f94177 . -4) (f94178 . 0))
# var=f94191
    movl -20(%esp), %eax  # stack load f94191
# end emit-variable-ref
    mov %eax, -40(%esp)  # arg f94191
    movl -32(%esp), %edi   # load new closure to %edi
    add $-24, %esp   # adjust base
    movl $8,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $24, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    cmp $47, %al
    je _L_570531
# emit-tail-expr
# si=-24
# env=((f94191 . -20) (f94190 . -16) (f94191 . -12) (f94190 . -8) (f94176 . 8) (f94178 . 4) (f94175 . -12) (f94176 . -8) (f94177 . -4) (f94178 . 0))
# expr=((vector-ref f94176 0) f94190 f94191 0 (string-length f94190))
# emit-tail-funcall
#    si   =-24
#    env  = ((f94191 . -20) (f94190 . -16) (f94191 . -12) (f94190 . -8) (f94176 . 8) (f94178 . 4) (f94175 . -12) (f94176 . -8) (f94177 . -4) (f94178 . 0))
#    expr = (funcall (vector-ref f94176 0) f94190 f94191 0 (string-length f94190))
# emit-expr (vector-ref f94176 0)
# emit-expr f94176
# emit-variable-ref
# env=((f94191 . -20) (f94190 . -16) (f94191 . -12) (f94190 . -8) (f94176 . 8) (f94178 . 4) (f94175 . -12) (f94176 . -8) (f94177 . -4) (f94178 . 0))
# var=f94176
    movl 6(%edi), %eax  # frame load f94176
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_570538
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_570538:
    movl %eax, -24(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_570539"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_570539:
# check bounds on vector index
    movl -24(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_570541
    cmp  $0,%eax
    jge _L_570540
_L_570541:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_570540:
    movl -24(%esp), %esi
    movl -1(%eax,%esi), %eax
   movl %eax,  -24(%esp)  # stash funcall-oper in next closure slot
# emit-expr f94190
# emit-variable-ref
# env=((f94191 . -20) (f94190 . -16) (f94191 . -12) (f94190 . -8) (f94176 . 8) (f94178 . 4) (f94175 . -12) (f94176 . -8) (f94177 . -4) (f94178 . 0))
# var=f94190
    movl -16(%esp), %eax  # stack load f94190
# end emit-variable-ref
    mov %eax, -28(%esp)    # arg f94190
# emit-expr f94191
# emit-variable-ref
# env=((f94191 . -20) (f94190 . -16) (f94191 . -12) (f94190 . -8) (f94176 . 8) (f94178 . 4) (f94175 . -12) (f94176 . -8) (f94177 . -4) (f94178 . 0))
# var=f94191
    movl -20(%esp), %eax  # stack load f94191
# end emit-variable-ref
    mov %eax, -32(%esp)    # arg f94191
# emit-expr 0
    movl $0, %eax     # immed 0
    mov %eax, -36(%esp)    # arg 0
# emit-expr (string-length f94190)
# emit-expr f94190
# emit-variable-ref
# env=((f94191 . -20) (f94190 . -16) (f94191 . -12) (f94190 . -8) (f94176 . 8) (f94178 . 4) (f94175 . -12) (f94176 . -8) (f94177 . -4) (f94178 . 0))
# var=f94190
    movl -16(%esp), %eax  # stack load f94190
# end emit-variable-ref
# check the argument is a string
    movl %eax,%ebx
    and $7, %bl
    cmp $6, %bl
    je _L_570542
# invoke error handler eh_string
    .extern mrc_eh$ustring
    movl mrc_eh$ustring, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $160,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_570542:
    movl -6(%eax), %eax
    mov %eax, -40(%esp)    # arg (string-length f94190)
    movl -24(%esp), %edi   # load new closure to %edi
# emit-shift-args:  size=5   si=-24  delta=20
    mov -24(%esp), %ebx  # shift frame cell
    mov %ebx, -4(%esp)  # down to base
# emit-shift-args:  size=4   si=-28  delta=20
    mov -28(%esp), %ebx  # shift frame cell
    mov %ebx, -8(%esp)  # down to base
# emit-shift-args:  size=3   si=-32  delta=20
    mov -32(%esp), %ebx  # shift frame cell
    mov %ebx, -12(%esp)  # down to base
# emit-shift-args:  size=2   si=-36  delta=20
    mov -36(%esp), %ebx  # shift frame cell
    mov %ebx, -16(%esp)  # down to base
# emit-shift-args:  size=1   si=-40  delta=20
    mov -40(%esp), %ebx  # shift frame cell
    mov %ebx, -20(%esp)  # down to base
# emit-shift-args:  size=0   si=-44  delta=20
    movl $16,%eax   # save arg count
    jmp *-2(%edi)  # tail-funcall
    jmp _L_570532
_L_570531:
# emit-tail-expr
# si=-24
# env=((f94191 . -20) (f94190 . -16) (f94191 . -12) (f94190 . -8) (f94176 . 8) (f94178 . 4) (f94175 . -12) (f94176 . -8) (f94177 . -4) (f94178 . 0))
# expr=#f
    movl $47, %eax     # immed #f
    ret                  # immediate tail return
_L_570532:
    .align 4,0x90
_L_570529:
    movl -16(%esp), %ebx
    movl -20(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin)
# emit-begin
#   expr=(begin)
#   env=((f94175 . -12) (f94176 . -8) (f94177 . -4) (f94178 . 0))
# emit-expr (begin (vector-ref f94175 0))
# emit-begin
#   expr=(begin (vector-ref f94175 0))
#   env=((f94175 . -12) (f94176 . -8) (f94177 . -4) (f94178 . 0))
# emit-expr (vector-ref f94175 0)
# emit-expr f94175
# emit-variable-ref
# env=((f94175 . -12) (f94176 . -8) (f94177 . -4) (f94178 . 0))
# var=f94175
    movl -12(%esp), %eax  # stack load f94175
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_570543
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_570543:
    movl %eax, -16(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_570544"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_570544:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_570546
    cmp  $0,%eax
    jge _L_570545
_L_570546:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_570545:
    movl -16(%esp), %esi
    movl -1(%eax,%esi), %eax
# emit-expr (begin)
# emit-begin
#   expr=(begin)
#   env=((f94175 . -12) (f94176 . -8) (f94177 . -4) (f94178 . 0))
     movl %eax, mrc_string$e$q
# == explicit-begins  ==>
# (letrec ((str->sym (lambda (str symlist) (if (string=? str (symbol->string (car symlist))) (car symlist) (if (null? (cdr symlist)) (let* ((new-sym (make-symbol str #f)) (new-cdr (cons new-sym ()))) (begin (set-cdr! symlist new-cdr) new-sym)) (str->sym str (cdr symlist))))))) (lambda (str) (str->sym str (symbols))))
# == eliminate-let*  ==>
# (letrec ((str->sym (lambda (str symlist) (if (string=? str (symbol->string (car symlist))) (car symlist) (if (null? (cdr symlist)) (let ((new-sym (make-symbol str #f))) (let ((new-cdr (cons new-sym ()))) (begin (set-cdr! symlist new-cdr) new-sym))) (str->sym str (cdr symlist))))))) (lambda (str) (str->sym str (symbols))))
# == uniquify-variables  ==>
# (letrec ((f94201 (lambda (f94210 f94211) (if (string=? f94210 (symbol->string (car f94211))) (car f94211) (if (null? (cdr f94211)) (let ((f94215 (make-symbol f94210 #f))) (let ((f94217 (cons f94215 ()))) (begin (set-cdr! f94211 f94217) f94215))) (f94201 f94210 (cdr f94211))))))) (lambda (f94219) (f94201 f94219 (symbols))))
# == vectorize-letrec  ==>
# (let ((f94201 (make-vector 1))) (begin (begin (vector-set! f94201 0 (lambda (f94210 f94211) (if (string=? f94210 (symbol->string (car f94211))) (car f94211) (if (null? (cdr f94211)) (let ((f94215 (make-symbol f94210 #f))) (let ((f94217 (cons f94215 ()))) (begin (set-cdr! f94211 f94217) f94215))) ((vector-ref f94201 0) f94210 (cdr f94211))))))) (lambda (f94219) ((vector-ref f94201 0) f94219 (symbols)))))
# == eliminate-set!  ==>
# (let ((f94201 (make-vector 1))) (begin (begin (vector-set! f94201 0 (lambda (f94210 f94211) (let ((f94210 f94210) (f94211 f94211)) (if (string=? f94210 (symbol->string (car f94211))) (car f94211) (if (null? (cdr f94211)) (let ((f94215 (make-symbol f94210 #f))) (let ((f94217 (cons f94215 ()))) (begin (set-cdr! f94211 f94217) f94215))) ((vector-ref f94201 0) f94210 (cdr f94211)))))))) (lambda (f94219) (let ((f94219 f94219)) ((vector-ref f94201 0) f94219 (symbols))))))
# == close-free-variables  ==>
# (let ((f94201 (make-vector 1))) (begin (begin (vector-set! f94201 0 (closure (f94210 f94211) (f94201) (let ((f94210 f94210) (f94211 f94211)) (if (string=? f94210 (symbol->string (car f94211))) (car f94211) (if (null? (cdr f94211)) (let ((f94215 (make-symbol f94210 #f))) (let ((f94217 (cons f94215 ()))) (begin (set-cdr! f94211 f94217) f94215))) ((vector-ref f94201 0) f94210 (cdr f94211)))))))) (closure (f94219) (f94201) (let ((f94219 f94219)) ((vector-ref f94201 0) f94219 (symbols))))))
# == eliminate-quote  ==>
# (let ((f94201 (make-vector 1))) (begin (begin (vector-set! f94201 0 (closure (f94210 f94211) (f94201) (let ((f94210 f94210) (f94211 f94211)) (if (string=? f94210 (symbol->string (car f94211))) (car f94211) (if (null? (cdr f94211)) (let ((f94215 (make-symbol f94210 #f))) (let ((f94217 (cons f94215 ()))) (begin (set-cdr! f94211 f94217) f94215))) ((vector-ref f94201 0) f94210 (cdr f94211)))))))) (closure (f94219) (f94201) (let ((f94219 f94219)) ((vector-ref f94201 0) f94219 (symbols))))))
# == eliminate-when/unless  ==>
# (let ((f94201 (make-vector 1))) (begin (begin (vector-set! f94201 0 (closure (f94210 f94211) (f94201) (let ((f94210 f94210) (f94211 f94211)) (if (string=? f94210 (symbol->string (car f94211))) (car f94211) (if (null? (cdr f94211)) (let ((f94215 (make-symbol f94210 #f))) (let ((f94217 (cons f94215 ()))) (begin (set-cdr! f94211 f94217) f94215))) ((vector-ref f94201 0) f94210 (cdr f94211)))))))) (closure (f94219) (f94201) (let ((f94219 f94219)) ((vector-ref f94201 0) f94219 (symbols))))))
# == eliminate-cond  ==>
# (let ((f94201 (make-vector 1))) (begin (begin (vector-set! f94201 0 (closure (f94210 f94211) (f94201) (let ((f94210 f94210) (f94211 f94211)) (if (string=? f94210 (symbol->string (car f94211))) (car f94211) (if (null? (cdr f94211)) (let ((f94215 (make-symbol f94210 #f))) (let ((f94217 (cons f94215 ()))) (begin (set-cdr! f94211 f94217) f94215))) ((vector-ref f94201 0) f94210 (cdr f94211)))))))) (closure (f94219) (f94201) (let ((f94219 f94219)) ((vector-ref f94201 0) f94219 (symbols))))))
# == external-symbols  ==>
# (let ((f94201 (make-vector 1))) (begin (begin (vector-set! f94201 0 (closure (f94210 f94211) (f94201) (let ((f94210 f94210) (f94211 f94211)) (if ((primitive-ref string=?) f94210 (symbol->string (car f94211))) (car f94211) (if (null? (cdr f94211)) (let ((f94215 (make-symbol f94210 #f))) (let ((f94217 (cons f94215 ()))) (begin (set-cdr! f94211 f94217) f94215))) ((vector-ref f94201 0) f94210 (cdr f94211)))))))) (closure (f94219) (f94201) (let ((f94219 f94219)) ((vector-ref f94201 0) f94219 ((primitive-ref symbols)))))))
# emit-expr (let ((f94201 (make-vector 1))) (begin (begin (vector-set! f94201 0 (closure (f94210 f94211) (f94201) (let ((f94210 f94210) (f94211 f94211)) (if ((primitive-ref string=?) f94210 (symbol->string (car f94211))) (car f94211) (if (null? (cdr f94211)) (let ((f94215 (make-symbol f94210 #f))) (let ((f94217 (cons f94215 ()))) (begin (set-cdr! f94211 f94217) f94215))) ((vector-ref f94201 0) f94210 (cdr f94211)))))))) (closure (f94219) (f94201) (let ((f94219 f94219)) ((vector-ref f94201 0) f94219 ((primitive-ref symbols)))))))
# emit-let
#  si   = 0
#  env  = ()
#  bindings = ((f94201 (make-vector 1)))
#  body = (begin (begin (vector-set! f94201 0 (closure (f94210 f94211) (f94201) (let ((f94210 f94210) (f94211 f94211)) (if ((primitive-ref string=?) f94210 (symbol->string (car f94211))) (car f94211) (if (null? (cdr f94211)) (let ((f94215 (make-symbol f94210 #f))) (let ((f94217 (cons f94215 ()))) (begin (set-cdr! f94211 f94217) f94215))) ((vector-ref f94201 0) f94210 (cdr f94211)))))))) (closure (f94219) (f94201) (let ((f94219 f94219)) ((vector-ref f94201 0) f94219 ((primitive-ref symbols))))))
# emit-expr (make-vector 1)
# make-vector 1
# emit-expr 1
    movl $4, %eax     # immed 1
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_570547"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_570547:
# check the argument is a fixnum >= 0
    cmp $0,%eax
    jge _L_570548
# invoke error handler eh_length
    .extern mrc_eh$ulength
    movl mrc_eh$ulength, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_570548:
    movl %eax, %esi
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    orl  $5, %eax
    addl $4, %esi
    addl $4, %esi
    andl $-8, %esi
    addl %esi, %ebp
    movl %eax, 0(%esp)  # stack save
# emit-expr (begin (begin (vector-set! f94201 0 (closure (f94210 f94211) (f94201) (let ((f94210 f94210) (f94211 f94211)) (if ((primitive-ref string=?) f94210 (symbol->string (car f94211))) (car f94211) (if (null? (cdr f94211)) (let ((f94215 (make-symbol f94210 #f))) (let ((f94217 (cons f94215 ()))) (begin (set-cdr! f94211 f94217) f94215))) ((vector-ref f94201 0) f94210 (cdr f94211)))))))) (closure (f94219) (f94201) (let ((f94219 f94219)) ((vector-ref f94201 0) f94219 ((primitive-ref symbols))))))
# emit-begin
#   expr=(begin (begin (vector-set! f94201 0 (closure (f94210 f94211) (f94201) (let ((f94210 f94210) (f94211 f94211)) (if ((primitive-ref string=?) f94210 (symbol->string (car f94211))) (car f94211) (if (null? (cdr f94211)) (let ((f94215 (make-symbol f94210 #f))) (let ((f94217 (cons f94215 ()))) (begin (set-cdr! f94211 f94217) f94215))) ((vector-ref f94201 0) f94210 (cdr f94211)))))))) (closure (f94219) (f94201) (let ((f94219 f94219)) ((vector-ref f94201 0) f94219 ((primitive-ref symbols))))))
#   env=((f94201 . 0))
# emit-expr (begin (vector-set! f94201 0 (closure (f94210 f94211) (f94201) (let ((f94210 f94210) (f94211 f94211)) (if ((primitive-ref string=?) f94210 (symbol->string (car f94211))) (car f94211) (if (null? (cdr f94211)) (let ((f94215 (make-symbol f94210 #f))) (let ((f94217 (cons f94215 ()))) (begin (set-cdr! f94211 f94217) f94215))) ((vector-ref f94201 0) f94210 (cdr f94211))))))))
# emit-begin
#   expr=(begin (vector-set! f94201 0 (closure (f94210 f94211) (f94201) (let ((f94210 f94210) (f94211 f94211)) (if ((primitive-ref string=?) f94210 (symbol->string (car f94211))) (car f94211) (if (null? (cdr f94211)) (let ((f94215 (make-symbol f94210 #f))) (let ((f94217 (cons f94215 ()))) (begin (set-cdr! f94211 f94217) f94215))) ((vector-ref f94201 0) f94210 (cdr f94211))))))))
#   env=((f94201 . 0))
# emit-expr (vector-set! f94201 0 (closure (f94210 f94211) (f94201) (let ((f94210 f94210) (f94211 f94211)) (if ((primitive-ref string=?) f94210 (symbol->string (car f94211))) (car f94211) (if (null? (cdr f94211)) (let ((f94215 (make-symbol f94210 #f))) (let ((f94217 (cons f94215 ()))) (begin (set-cdr! f94211 f94217) f94215))) ((vector-ref f94201 0) f94210 (cdr f94211)))))))
# emit-expr f94201
# emit-variable-ref
# env=((f94201 . 0))
# var=f94201
    movl 0(%esp), %eax  # stack load f94201
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_570549
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_570549:
    movl %eax, -4(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_570550"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_570550:
# check bounds on vector index
    movl -4(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_570552
    cmp  $0,%eax
    jge _L_570551
_L_570552:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_570551:
    movl %eax, -8(%esp)
# emit-expr (closure (f94210 f94211) (f94201) (let ((f94210 f94210) (f94211 f94211)) (if ((primitive-ref string=?) f94210 (symbol->string (car f94211))) (car f94211) (if (null? (cdr f94211)) (let ((f94215 (make-symbol f94210 #f))) (let ((f94217 (cons f94215 ()))) (begin (set-cdr! f94211 f94217) f94215))) ((vector-ref f94201 0) f94210 (cdr f94211))))))
# emit-closure
# si = -12
# env = ((f94201 . 0))
# expr = (closure (f94210 f94211) (f94201) (let ((f94210 f94210) (f94211 f94211)) (if ((primitive-ref string=?) f94210 (symbol->string (car f94211))) (car f94211) (if (null? (cdr f94211)) (let ((f94215 (make-symbol f94210 #f))) (let ((f94217 (cons f94215 ()))) (begin (set-cdr! f94211 f94217) f94215))) ((vector-ref f94201 0) f94210 (cdr f94211))))))
    movl $_L_570553, 0(%ebp)  # closure label
# emit-variable-ref
# env=((f94201 . 0))
# var=f94201
    movl 0(%esp), %eax  # stack load f94201
# end emit-variable-ref
   movl  %eax, 4(%ebp)  # f94201
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $8, %ebp     # bump ebp
    jmp _L_570554            # jump around closure body
_L_570553:
# check argument count
    cmp $8,%eax
    je _L_570555
# invoke error handler eh_argcount
    .extern mrc_eh$uargcount
    movl mrc_eh$uargcount, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_570555:
# emit-tail-expr
# si=-16
# env=((f94211 . -12) (f94210 . -8) (f94201 . 4) (f94201 . 0))
# expr=(let ((f94210 f94210) (f94211 f94211)) (if ((primitive-ref string=?) f94210 (symbol->string (car f94211))) (car f94211) (if (null? (cdr f94211)) (let ((f94215 (make-symbol f94210 #f))) (let ((f94217 (cons f94215 ()))) (begin (set-cdr! f94211 f94217) f94215))) ((vector-ref f94201 0) f94210 (cdr f94211)))))
# emit-tail-let
#  si   = -16
#  env  = ((f94211 . -12) (f94210 . -8) (f94201 . 4) (f94201 . 0))
#  bindings = ((f94210 f94210) (f94211 f94211))
#  body = (if ((primitive-ref string=?) f94210 (symbol->string (car f94211))) (car f94211) (if (null? (cdr f94211)) (let ((f94215 (make-symbol f94210 #f))) (let ((f94217 (cons f94215 ()))) (begin (set-cdr! f94211 f94217) f94215))) ((vector-ref f94201 0) f94210 (cdr f94211))))
# emit-expr f94210
# emit-variable-ref
# env=((f94211 . -12) (f94210 . -8) (f94201 . 4) (f94201 . 0))
# var=f94210
    movl -8(%esp), %eax  # stack load f94210
# end emit-variable-ref
    movl %eax, -16(%esp)  # stack save
# emit-expr f94211
# emit-variable-ref
# env=((f94211 . -12) (f94210 . -8) (f94201 . 4) (f94201 . 0))
# var=f94211
    movl -12(%esp), %eax  # stack load f94211
# end emit-variable-ref
    movl %eax, -20(%esp)  # stack save
# emit-tail-expr
# si=-24
# env=((f94211 . -20) (f94210 . -16) (f94211 . -12) (f94210 . -8) (f94201 . 4) (f94201 . 0))
# expr=(if ((primitive-ref string=?) f94210 (symbol->string (car f94211))) (car f94211) (if (null? (cdr f94211)) (let ((f94215 (make-symbol f94210 #f))) (let ((f94217 (cons f94215 ()))) (begin (set-cdr! f94211 f94217) f94215))) ((vector-ref f94201 0) f94210 (cdr f94211))))
# emit-expr ((primitive-ref string=?) f94210 (symbol->string (car f94211)))
# funcall
#    si   =-24
#    env  = ((f94211 . -20) (f94210 . -16) (f94211 . -12) (f94210 . -8) (f94201 . 4) (f94201 . 0))
#    expr = (funcall (primitive-ref string=?) f94210 (symbol->string (car f94211)))
# emit-expr (primitive-ref string=?)
    .extern mrc_string$e$q
    movl mrc_string$e$q,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_570558"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_570558":
   movl %eax,  -32(%esp)  # stash funcall-oper in closure slot
# emit-expr f94210
# emit-variable-ref
# env=((f94211 . -20) (f94210 . -16) (f94211 . -12) (f94210 . -8) (f94201 . 4) (f94201 . 0))
# var=f94210
    movl -16(%esp), %eax  # stack load f94210
# end emit-variable-ref
    mov %eax, -36(%esp)  # arg f94210
# emit-expr (symbol->string (car f94211))
# symbol->string (car f94211)
# emit-expr (car f94211)
# emit-expr f94211
# emit-variable-ref
# env=((f94211 . -20) (f94210 . -16) (f94211 . -12) (f94210 . -8) (f94201 . 4) (f94201 . 0))
# var=f94211
    movl -20(%esp), %eax  # stack load f94211
# end emit-variable-ref
# check the argument is a pair
    movl %eax,%ebx
    and $7, %bl
    cmp $1, %bl
    je _L_570559
# invoke error handler eh_pair
    .extern mrc_eh$upair
    movl mrc_eh$upair, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $116,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_570559:
    movl -1(%eax), %eax
    movl -3(%eax), %eax
    mov %eax, -40(%esp)  # arg (symbol->string (car f94211))
    movl -32(%esp), %edi   # load new closure to %edi
    add $-24, %esp   # adjust base
    movl $8,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $24, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    cmp $47, %al
    je _L_570556
# emit-tail-expr
# si=-24
# env=((f94211 . -20) (f94210 . -16) (f94211 . -12) (f94210 . -8) (f94201 . 4) (f94201 . 0))
# expr=(car f94211)
# tail primcall
# emit-expr f94211
# emit-variable-ref
# env=((f94211 . -20) (f94210 . -16) (f94211 . -12) (f94210 . -8) (f94201 . 4) (f94201 . 0))
# var=f94211
    movl -20(%esp), %eax  # stack load f94211
# end emit-variable-ref
# check the argument is a pair
    movl %eax,%ebx
    and $7, %bl
    cmp $1, %bl
    je _L_570560
# invoke error handler eh_pair
    .extern mrc_eh$upair
    movl mrc_eh$upair, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $116,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_570560:
    movl -1(%eax), %eax
#return from tail (car f94211)
    ret
    jmp _L_570557
_L_570556:
# emit-tail-expr
# si=-24
# env=((f94211 . -20) (f94210 . -16) (f94211 . -12) (f94210 . -8) (f94201 . 4) (f94201 . 0))
# expr=(if (null? (cdr f94211)) (let ((f94215 (make-symbol f94210 #f))) (let ((f94217 (cons f94215 ()))) (begin (set-cdr! f94211 f94217) f94215))) ((vector-ref f94201 0) f94210 (cdr f94211)))
# emit-expr (null? (cdr f94211))
# emit-expr (cdr f94211)
# emit-expr f94211
# emit-variable-ref
# env=((f94211 . -20) (f94210 . -16) (f94211 . -12) (f94210 . -8) (f94201 . 4) (f94201 . 0))
# var=f94211
    movl -20(%esp), %eax  # stack load f94211
# end emit-variable-ref
# check the argument is a pair
    movl %eax,%ebx
    and $7, %bl
    cmp $1, %bl
    je _L_570563
# invoke error handler eh_pair
    .extern mrc_eh$upair
    movl mrc_eh$upair, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $120,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_570563:
    movl 3(%eax), %eax
    cmp $63, %eax
    mov $0, %eax
    sete %al
    movzbl %al, %eax
    sal $6, %al
    or $47, %al
    cmp $47, %al
    je _L_570561
# emit-tail-expr
# si=-24
# env=((f94211 . -20) (f94210 . -16) (f94211 . -12) (f94210 . -8) (f94201 . 4) (f94201 . 0))
# expr=(let ((f94215 (make-symbol f94210 #f))) (let ((f94217 (cons f94215 ()))) (begin (set-cdr! f94211 f94217) f94215)))
# emit-tail-let
#  si   = -24
#  env  = ((f94211 . -20) (f94210 . -16) (f94211 . -12) (f94210 . -8) (f94201 . 4) (f94201 . 0))
#  bindings = ((f94215 (make-symbol f94210 #f)))
#  body = (let ((f94217 (cons f94215 ()))) (begin (set-cdr! f94211 f94217) f94215))
# emit-expr (make-symbol f94210 #f)
# make-symbol arg1=f94210 arg2=#f
# emit-expr f94210
# emit-variable-ref
# env=((f94211 . -20) (f94210 . -16) (f94211 . -12) (f94210 . -8) (f94201 . 4) (f94201 . 0))
# var=f94210
    movl -16(%esp), %eax  # stack load f94210
# end emit-variable-ref
    movl %eax, -24(%esp)
# emit-expr #f
    movl $47, %eax     # immed #f
    movl %eax, 4(%ebp)
    movl -24(%esp), %eax
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    orl  $3, %eax
    add  $8, %ebp
# make-symbol end
    movl %eax, -24(%esp)  # stack save
# emit-tail-expr
# si=-28
# env=((f94215 . -24) (f94211 . -20) (f94210 . -16) (f94211 . -12) (f94210 . -8) (f94201 . 4) (f94201 . 0))
# expr=(let ((f94217 (cons f94215 ()))) (begin (set-cdr! f94211 f94217) f94215))
# emit-tail-let
#  si   = -28
#  env  = ((f94215 . -24) (f94211 . -20) (f94210 . -16) (f94211 . -12) (f94210 . -8) (f94201 . 4) (f94201 . 0))
#  bindings = ((f94217 (cons f94215 ())))
#  body = (begin (set-cdr! f94211 f94217) f94215)
# emit-expr (cons f94215 ())
# cons arg1=f94215 arg2=()
# emit-expr f94215
# emit-variable-ref
# env=((f94215 . -24) (f94211 . -20) (f94210 . -16) (f94211 . -12) (f94210 . -8) (f94201 . 4) (f94201 . 0))
# var=f94215
    movl -24(%esp), %eax  # stack load f94215
# end emit-variable-ref
    movl %eax, -28(%esp)
# emit-expr ()
    movl $63, %eax     # immed ()
    movl %eax, 4(%ebp)
    movl -28(%esp), %eax
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    or   $1, %al
    add  $8, %ebp
# cons end
    movl %eax, -28(%esp)  # stack save
# emit-tail-expr
# si=-32
# env=((f94217 . -28) (f94215 . -24) (f94211 . -20) (f94210 . -16) (f94211 . -12) (f94210 . -8) (f94201 . 4) (f94201 . 0))
# expr=(begin (set-cdr! f94211 f94217) f94215)
# tail-begin (begin (set-cdr! f94211 f94217) f94215)
#   env=((f94217 . -28) (f94215 . -24) (f94211 . -20) (f94210 . -16) (f94211 . -12) (f94210 . -8) (f94201 . 4) (f94201 . 0))
# emit-expr (set-cdr! f94211 f94217)
# emit-expr f94211
# emit-variable-ref
# env=((f94217 . -28) (f94215 . -24) (f94211 . -20) (f94210 . -16) (f94211 . -12) (f94210 . -8) (f94201 . 4) (f94201 . 0))
# var=f94211
    movl -20(%esp), %eax  # stack load f94211
# end emit-variable-ref
# check the argument is a pair
    movl %eax,%ebx
    and $7, %bl
    cmp $1, %bl
    je _L_570564
# invoke error handler eh_pair
    .extern mrc_eh$upair
    movl mrc_eh$upair, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $128,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_570564:
    movl %eax, -32(%esp)
# emit-expr f94217
# emit-variable-ref
# env=((f94217 . -28) (f94215 . -24) (f94211 . -20) (f94210 . -16) (f94211 . -12) (f94210 . -8) (f94201 . 4) (f94201 . 0))
# var=f94217
    movl -28(%esp), %eax  # stack load f94217
# end emit-variable-ref
    movl -32(%esp), %ebx
    movl %eax, 3(%ebx)
# emit-tail-expr
# si=-32
# env=((f94217 . -28) (f94215 . -24) (f94211 . -20) (f94210 . -16) (f94211 . -12) (f94210 . -8) (f94201 . 4) (f94201 . 0))
# expr=(begin f94215)
# tail-begin (begin f94215)
#   env=((f94217 . -28) (f94215 . -24) (f94211 . -20) (f94210 . -16) (f94211 . -12) (f94210 . -8) (f94201 . 4) (f94201 . 0))
# emit-tail-expr
# si=-32
# env=((f94217 . -28) (f94215 . -24) (f94211 . -20) (f94210 . -16) (f94211 . -12) (f94210 . -8) (f94201 . 4) (f94201 . 0))
# expr=f94215
# emit-tail-variable-ref
# emit-variable-ref
# env=((f94217 . -28) (f94215 . -24) (f94211 . -20) (f94210 . -16) (f94211 . -12) (f94210 . -8) (f94201 . 4) (f94201 . 0))
# var=f94215
    movl -24(%esp), %eax  # stack load f94215
# end emit-variable-ref
    ret
# end emit-tail-variable ref
     ret   # return thru stack
    jmp _L_570562
_L_570561:
# emit-tail-expr
# si=-24
# env=((f94211 . -20) (f94210 . -16) (f94211 . -12) (f94210 . -8) (f94201 . 4) (f94201 . 0))
# expr=((vector-ref f94201 0) f94210 (cdr f94211))
# emit-tail-funcall
#    si   =-24
#    env  = ((f94211 . -20) (f94210 . -16) (f94211 . -12) (f94210 . -8) (f94201 . 4) (f94201 . 0))
#    expr = (funcall (vector-ref f94201 0) f94210 (cdr f94211))
# emit-expr (vector-ref f94201 0)
# emit-expr f94201
# emit-variable-ref
# env=((f94211 . -20) (f94210 . -16) (f94211 . -12) (f94210 . -8) (f94201 . 4) (f94201 . 0))
# var=f94201
    movl 2(%edi), %eax  # frame load f94201
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_570565
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_570565:
    movl %eax, -24(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_570566"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_570566:
# check bounds on vector index
    movl -24(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_570568
    cmp  $0,%eax
    jge _L_570567
_L_570568:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_570567:
    movl -24(%esp), %esi
    movl -1(%eax,%esi), %eax
   movl %eax,  -24(%esp)  # stash funcall-oper in next closure slot
# emit-expr f94210
# emit-variable-ref
# env=((f94211 . -20) (f94210 . -16) (f94211 . -12) (f94210 . -8) (f94201 . 4) (f94201 . 0))
# var=f94210
    movl -16(%esp), %eax  # stack load f94210
# end emit-variable-ref
    mov %eax, -28(%esp)    # arg f94210
# emit-expr (cdr f94211)
# emit-expr f94211
# emit-variable-ref
# env=((f94211 . -20) (f94210 . -16) (f94211 . -12) (f94210 . -8) (f94201 . 4) (f94201 . 0))
# var=f94211
    movl -20(%esp), %eax  # stack load f94211
# end emit-variable-ref
# check the argument is a pair
    movl %eax,%ebx
    and $7, %bl
    cmp $1, %bl
    je _L_570569
# invoke error handler eh_pair
    .extern mrc_eh$upair
    movl mrc_eh$upair, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $120,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_570569:
    movl 3(%eax), %eax
    mov %eax, -32(%esp)    # arg (cdr f94211)
    movl -24(%esp), %edi   # load new closure to %edi
# emit-shift-args:  size=3   si=-24  delta=20
    mov -24(%esp), %ebx  # shift frame cell
    mov %ebx, -4(%esp)  # down to base
# emit-shift-args:  size=2   si=-28  delta=20
    mov -28(%esp), %ebx  # shift frame cell
    mov %ebx, -8(%esp)  # down to base
# emit-shift-args:  size=1   si=-32  delta=20
    mov -32(%esp), %ebx  # shift frame cell
    mov %ebx, -12(%esp)  # down to base
# emit-shift-args:  size=0   si=-36  delta=20
    movl $8,%eax   # save arg count
    jmp *-2(%edi)  # tail-funcall
_L_570562:
_L_570557:
    .align 4,0x90
_L_570554:
    movl -4(%esp), %ebx
    movl -8(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin)
# emit-begin
#   expr=(begin)
#   env=((f94201 . 0))
# emit-expr (begin (closure (f94219) (f94201) (let ((f94219 f94219)) ((vector-ref f94201 0) f94219 ((primitive-ref symbols))))))
# emit-begin
#   expr=(begin (closure (f94219) (f94201) (let ((f94219 f94219)) ((vector-ref f94201 0) f94219 ((primitive-ref symbols))))))
#   env=((f94201 . 0))
# emit-expr (closure (f94219) (f94201) (let ((f94219 f94219)) ((vector-ref f94201 0) f94219 ((primitive-ref symbols)))))
# emit-closure
# si = -4
# env = ((f94201 . 0))
# expr = (closure (f94219) (f94201) (let ((f94219 f94219)) ((vector-ref f94201 0) f94219 ((primitive-ref symbols)))))
    movl $_L_570570, 0(%ebp)  # closure label
# emit-variable-ref
# env=((f94201 . 0))
# var=f94201
    movl 0(%esp), %eax  # stack load f94201
# end emit-variable-ref
   movl  %eax, 4(%ebp)  # f94201
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $8, %ebp     # bump ebp
    jmp _L_570571            # jump around closure body
_L_570570:
# check argument count
    cmp $4,%eax
    je _L_570572
# invoke error handler eh_argcount
    .extern mrc_eh$uargcount
    movl mrc_eh$uargcount, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_570572:
# emit-tail-expr
# si=-12
# env=((f94219 . -8) (f94201 . 4) (f94201 . 0))
# expr=(let ((f94219 f94219)) ((vector-ref f94201 0) f94219 ((primitive-ref symbols))))
# emit-tail-let
#  si   = -12
#  env  = ((f94219 . -8) (f94201 . 4) (f94201 . 0))
#  bindings = ((f94219 f94219))
#  body = ((vector-ref f94201 0) f94219 ((primitive-ref symbols)))
# emit-expr f94219
# emit-variable-ref
# env=((f94219 . -8) (f94201 . 4) (f94201 . 0))
# var=f94219
    movl -8(%esp), %eax  # stack load f94219
# end emit-variable-ref
    movl %eax, -12(%esp)  # stack save
# emit-tail-expr
# si=-16
# env=((f94219 . -12) (f94219 . -8) (f94201 . 4) (f94201 . 0))
# expr=((vector-ref f94201 0) f94219 ((primitive-ref symbols)))
# emit-tail-funcall
#    si   =-16
#    env  = ((f94219 . -12) (f94219 . -8) (f94201 . 4) (f94201 . 0))
#    expr = (funcall (vector-ref f94201 0) f94219 ((primitive-ref symbols)))
# emit-expr (vector-ref f94201 0)
# emit-expr f94201
# emit-variable-ref
# env=((f94219 . -12) (f94219 . -8) (f94201 . 4) (f94201 . 0))
# var=f94201
    movl 2(%edi), %eax  # frame load f94201
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_570573
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_570573:
    movl %eax, -16(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_570574"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_570574:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_570576
    cmp  $0,%eax
    jge _L_570575
_L_570576:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_570575:
    movl -16(%esp), %esi
    movl -1(%eax,%esi), %eax
   movl %eax,  -16(%esp)  # stash funcall-oper in next closure slot
# emit-expr f94219
# emit-variable-ref
# env=((f94219 . -12) (f94219 . -8) (f94201 . 4) (f94201 . 0))
# var=f94219
    movl -12(%esp), %eax  # stack load f94219
# end emit-variable-ref
    mov %eax, -20(%esp)    # arg f94219
# emit-expr ((primitive-ref symbols))
# funcall
#    si   =-24
#    env  = ((f94219 . -12) (f94219 . -8) (f94201 . 4) (f94201 . 0))
#    expr = (funcall (primitive-ref symbols))
# emit-expr (primitive-ref symbols)
    .extern mrc_symbols
    movl mrc_symbols,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_570577"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_570577":
   movl %eax,  -32(%esp)  # stash funcall-oper in closure slot
    movl -32(%esp), %edi   # load new closure to %edi
    add $-24, %esp   # adjust base
    movl $0,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $24, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    mov %eax, -24(%esp)    # arg ((primitive-ref symbols))
    movl -16(%esp), %edi   # load new closure to %edi
# emit-shift-args:  size=3   si=-16  delta=12
    mov -16(%esp), %ebx  # shift frame cell
    mov %ebx, -4(%esp)  # down to base
# emit-shift-args:  size=2   si=-20  delta=12
    mov -20(%esp), %ebx  # shift frame cell
    mov %ebx, -8(%esp)  # down to base
# emit-shift-args:  size=1   si=-24  delta=12
    mov -24(%esp), %ebx  # shift frame cell
    mov %ebx, -12(%esp)  # down to base
# emit-shift-args:  size=0   si=-28  delta=12
    movl $8,%eax   # save arg count
    jmp *-2(%edi)  # tail-funcall
    .align 4,0x90
_L_570571:
# emit-expr (begin)
# emit-begin
#   expr=(begin)
#   env=((f94201 . 0))
     movl %eax, mrc_string$m$gsymbol
# == explicit-begins  ==>
# (lambda (lst elt) (if (null? lst) (cons elt nil) (cons (car lst) (append1 (cdr lst) elt))))
# == eliminate-let*  ==>
# (lambda (lst elt) (if (null? lst) (cons elt nil) (cons (car lst) (append1 (cdr lst) elt))))
# == uniquify-variables  ==>
# (lambda (f94220 f94221) (if (null? f94220) (cons f94221 nil) (cons (car f94220) (append1 (cdr f94220) f94221))))
# == vectorize-letrec  ==>
# (lambda (f94220 f94221) (if (null? f94220) (cons f94221 nil) (cons (car f94220) (append1 (cdr f94220) f94221))))
# == eliminate-set!  ==>
# (lambda (f94220 f94221) (let ((f94220 f94220) (f94221 f94221)) (if (null? f94220) (cons f94221 nil) (cons (car f94220) (append1 (cdr f94220) f94221)))))
# == close-free-variables  ==>
# (closure (f94220 f94221) (nil) (let ((f94220 f94220) (f94221 f94221)) (if (null? f94220) (cons f94221 nil) (cons (car f94220) (append1 (cdr f94220) f94221)))))
# == eliminate-quote  ==>
# (closure (f94220 f94221) (nil) (let ((f94220 f94220) (f94221 f94221)) (if (null? f94220) (cons f94221 nil) (cons (car f94220) (append1 (cdr f94220) f94221)))))
# == eliminate-when/unless  ==>
# (closure (f94220 f94221) (nil) (let ((f94220 f94220) (f94221 f94221)) (if (null? f94220) (cons f94221 nil) (cons (car f94220) (append1 (cdr f94220) f94221)))))
# == eliminate-cond  ==>
# (closure (f94220 f94221) (nil) (let ((f94220 f94220) (f94221 f94221)) (if (null? f94220) (cons f94221 nil) (cons (car f94220) (append1 (cdr f94220) f94221)))))
# == external-symbols  ==>
# (closure (f94220 f94221) (nil) (let ((f94220 f94220) (f94221 f94221)) (if (null? f94220) (cons f94221 nil) (cons (car f94220) ((primitive-ref append1) (cdr f94220) f94221)))))
# emit-expr (closure (f94220 f94221) (nil) (let ((f94220 f94220) (f94221 f94221)) (if (null? f94220) (cons f94221 nil) (cons (car f94220) ((primitive-ref append1) (cdr f94220) f94221)))))
# emit-closure
# si = 0
# env = ()
# expr = (closure (f94220 f94221) (nil) (let ((f94220 f94220) (f94221 f94221)) (if (null? f94220) (cons f94221 nil) (cons (car f94220) ((primitive-ref append1) (cdr f94220) f94221)))))
    movl $_L_570578, 0(%ebp)  # closure label
# WARNING: free var nil not defined in the environmnet
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $8, %ebp     # bump ebp
    jmp _L_570579            # jump around closure body
_L_570578:
# check argument count
    cmp $8,%eax
    je _L_570580
# invoke error handler eh_argcount
    .extern mrc_eh$uargcount
    movl mrc_eh$uargcount, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_570580:
# emit-tail-expr
# si=-16
# env=((f94221 . -12) (f94220 . -8) (nil . 4))
# expr=(let ((f94220 f94220) (f94221 f94221)) (if (null? f94220) (cons f94221 nil) (cons (car f94220) ((primitive-ref append1) (cdr f94220) f94221))))
# emit-tail-let
#  si   = -16
#  env  = ((f94221 . -12) (f94220 . -8) (nil . 4))
#  bindings = ((f94220 f94220) (f94221 f94221))
#  body = (if (null? f94220) (cons f94221 nil) (cons (car f94220) ((primitive-ref append1) (cdr f94220) f94221)))
# emit-expr f94220
# emit-variable-ref
# env=((f94221 . -12) (f94220 . -8) (nil . 4))
# var=f94220
    movl -8(%esp), %eax  # stack load f94220
# end emit-variable-ref
    movl %eax, -16(%esp)  # stack save
# emit-expr f94221
# emit-variable-ref
# env=((f94221 . -12) (f94220 . -8) (nil . 4))
# var=f94221
    movl -12(%esp), %eax  # stack load f94221
# end emit-variable-ref
    movl %eax, -20(%esp)  # stack save
# emit-tail-expr
# si=-24
# env=((f94221 . -20) (f94220 . -16) (f94221 . -12) (f94220 . -8) (nil . 4))
# expr=(if (null? f94220) (cons f94221 nil) (cons (car f94220) ((primitive-ref append1) (cdr f94220) f94221)))
# emit-expr (null? f94220)
# emit-expr f94220
# emit-variable-ref
# env=((f94221 . -20) (f94220 . -16) (f94221 . -12) (f94220 . -8) (nil . 4))
# var=f94220
    movl -16(%esp), %eax  # stack load f94220
# end emit-variable-ref
    cmp $63, %eax
    mov $0, %eax
    sete %al
    movzbl %al, %eax
    sal $6, %al
    or $47, %al
    cmp $47, %al
    je _L_570581
# emit-tail-expr
# si=-24
# env=((f94221 . -20) (f94220 . -16) (f94221 . -12) (f94220 . -8) (nil . 4))
# expr=(cons f94221 nil)
# tail primcall
# cons arg1=f94221 arg2=nil
# emit-expr f94221
# emit-variable-ref
# env=((f94221 . -20) (f94220 . -16) (f94221 . -12) (f94220 . -8) (nil . 4))
# var=f94221
    movl -20(%esp), %eax  # stack load f94221
# end emit-variable-ref
    movl %eax, -24(%esp)
# emit-expr nil
# emit-variable-ref
# env=((f94221 . -20) (f94220 . -16) (f94221 . -12) (f94220 . -8) (nil . 4))
# var=nil
    movl 2(%edi), %eax  # frame load nil
# end emit-variable-ref
    movl %eax, 4(%ebp)
    movl -24(%esp), %eax
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    or   $1, %al
    add  $8, %ebp
# cons end
#return from tail (cons f94221 nil)
    ret
    jmp _L_570582
_L_570581:
# emit-tail-expr
# si=-24
# env=((f94221 . -20) (f94220 . -16) (f94221 . -12) (f94220 . -8) (nil . 4))
# expr=(cons (car f94220) ((primitive-ref append1) (cdr f94220) f94221))
# tail primcall
# cons arg1=(car f94220) arg2=((primitive-ref append1) (cdr f94220) f94221)
# emit-expr (car f94220)
# emit-expr f94220
# emit-variable-ref
# env=((f94221 . -20) (f94220 . -16) (f94221 . -12) (f94220 . -8) (nil . 4))
# var=f94220
    movl -16(%esp), %eax  # stack load f94220
# end emit-variable-ref
# check the argument is a pair
    movl %eax,%ebx
    and $7, %bl
    cmp $1, %bl
    je _L_570583
# invoke error handler eh_pair
    .extern mrc_eh$upair
    movl mrc_eh$upair, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $116,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_570583:
    movl -1(%eax), %eax
    movl %eax, -24(%esp)
# emit-expr ((primitive-ref append1) (cdr f94220) f94221)
# funcall
#    si   =-28
#    env  = ((f94221 . -20) (f94220 . -16) (f94221 . -12) (f94220 . -8) (nil . 4))
#    expr = (funcall (primitive-ref append1) (cdr f94220) f94221)
# emit-expr (primitive-ref append1)
    .extern mrc_append1
    movl mrc_append1,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_570584"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_570584":
   movl %eax,  -36(%esp)  # stash funcall-oper in closure slot
# emit-expr (cdr f94220)
# emit-expr f94220
# emit-variable-ref
# env=((f94221 . -20) (f94220 . -16) (f94221 . -12) (f94220 . -8) (nil . 4))
# var=f94220
    movl -16(%esp), %eax  # stack load f94220
# end emit-variable-ref
# check the argument is a pair
    movl %eax,%ebx
    and $7, %bl
    cmp $1, %bl
    je _L_570585
# invoke error handler eh_pair
    .extern mrc_eh$upair
    movl mrc_eh$upair, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $120,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_570585:
    movl 3(%eax), %eax
    mov %eax, -40(%esp)  # arg (cdr f94220)
# emit-expr f94221
# emit-variable-ref
# env=((f94221 . -20) (f94220 . -16) (f94221 . -12) (f94220 . -8) (nil . 4))
# var=f94221
    movl -20(%esp), %eax  # stack load f94221
# end emit-variable-ref
    mov %eax, -44(%esp)  # arg f94221
    movl -36(%esp), %edi   # load new closure to %edi
    add $-28, %esp   # adjust base
    movl $8,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $28, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    movl %eax, 4(%ebp)
    movl -24(%esp), %eax
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    or   $1, %al
    add  $8, %ebp
# cons end
#return from tail (cons (car f94220) ((primitive-ref append1) (cdr f94220) f94221))
    ret
_L_570582:
    .align 4,0x90
_L_570579:
     movl %eax, mrc_append1
# == explicit-begins  ==>
# (lambda (l k) (if (fx= k 0) (car l) (list-ref (cdr l) (fx- k 1))))
# == eliminate-let*  ==>
# (lambda (l k) (if (fx= k 0) (car l) (list-ref (cdr l) (fx- k 1))))
# == uniquify-variables  ==>
# (lambda (f94222 f94223) (if (fx= f94223 0) (car f94222) (list-ref (cdr f94222) (fx- f94223 1))))
# == vectorize-letrec  ==>
# (lambda (f94222 f94223) (if (fx= f94223 0) (car f94222) (list-ref (cdr f94222) (fx- f94223 1))))
# == eliminate-set!  ==>
# (lambda (f94222 f94223) (let ((f94222 f94222) (f94223 f94223)) (if (fx= f94223 0) (car f94222) (list-ref (cdr f94222) (fx- f94223 1)))))
# == close-free-variables  ==>
# (closure (f94222 f94223) () (let ((f94222 f94222) (f94223 f94223)) (if (fx= f94223 0) (car f94222) (list-ref (cdr f94222) (fx- f94223 1)))))
# == eliminate-quote  ==>
# (closure (f94222 f94223) () (let ((f94222 f94222) (f94223 f94223)) (if (fx= f94223 0) (car f94222) (list-ref (cdr f94222) (fx- f94223 1)))))
# == eliminate-when/unless  ==>
# (closure (f94222 f94223) () (let ((f94222 f94222) (f94223 f94223)) (if (fx= f94223 0) (car f94222) (list-ref (cdr f94222) (fx- f94223 1)))))
# == eliminate-cond  ==>
# (closure (f94222 f94223) () (let ((f94222 f94222) (f94223 f94223)) (if (fx= f94223 0) (car f94222) (list-ref (cdr f94222) (fx- f94223 1)))))
# == external-symbols  ==>
# (closure (f94222 f94223) () (let ((f94222 f94222) (f94223 f94223)) (if (fx= f94223 0) (car f94222) ((primitive-ref list-ref) (cdr f94222) (fx- f94223 1)))))
# emit-expr (closure (f94222 f94223) () (let ((f94222 f94222) (f94223 f94223)) (if (fx= f94223 0) (car f94222) ((primitive-ref list-ref) (cdr f94222) (fx- f94223 1)))))
# emit-closure
# si = 0
# env = ()
# expr = (closure (f94222 f94223) () (let ((f94222 f94222) (f94223 f94223)) (if (fx= f94223 0) (car f94222) ((primitive-ref list-ref) (cdr f94222) (fx- f94223 1)))))
    movl $_L_570586, 0(%ebp)  # closure label
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $8, %ebp     # bump ebp
    jmp _L_570587            # jump around closure body
_L_570586:
# check argument count
    cmp $8,%eax
    je _L_570588
# invoke error handler eh_argcount
    .extern mrc_eh$uargcount
    movl mrc_eh$uargcount, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_570588:
# emit-tail-expr
# si=-16
# env=((f94223 . -12) (f94222 . -8))
# expr=(let ((f94222 f94222) (f94223 f94223)) (if (fx= f94223 0) (car f94222) ((primitive-ref list-ref) (cdr f94222) (fx- f94223 1))))
# emit-tail-let
#  si   = -16
#  env  = ((f94223 . -12) (f94222 . -8))
#  bindings = ((f94222 f94222) (f94223 f94223))
#  body = (if (fx= f94223 0) (car f94222) ((primitive-ref list-ref) (cdr f94222) (fx- f94223 1)))
# emit-expr f94222
# emit-variable-ref
# env=((f94223 . -12) (f94222 . -8))
# var=f94222
    movl -8(%esp), %eax  # stack load f94222
# end emit-variable-ref
    movl %eax, -16(%esp)  # stack save
# emit-expr f94223
# emit-variable-ref
# env=((f94223 . -12) (f94222 . -8))
# var=f94223
    movl -12(%esp), %eax  # stack load f94223
# end emit-variable-ref
    movl %eax, -20(%esp)  # stack save
# emit-tail-expr
# si=-24
# env=((f94223 . -20) (f94222 . -16) (f94223 . -12) (f94222 . -8))
# expr=(if (fx= f94223 0) (car f94222) ((primitive-ref list-ref) (cdr f94222) (fx- f94223 1)))
# emit-expr (fx= f94223 0)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_570591"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $68,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_570591:
    movl %eax, -24(%esp)
# emit-expr f94223
# emit-variable-ref
# env=((f94223 . -20) (f94222 . -16) (f94223 . -12) (f94222 . -8))
# var=f94223
    movl -20(%esp), %eax  # stack load f94223
# end emit-variable-ref
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_570592"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $68,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_570592:
    cmp -24(%esp), %eax
    sete %al
    movzbl %al, %eax
    sal $6, %al
    or $47, %al
    cmp $47, %al
    je _L_570589
# emit-tail-expr
# si=-24
# env=((f94223 . -20) (f94222 . -16) (f94223 . -12) (f94222 . -8))
# expr=(car f94222)
# tail primcall
# emit-expr f94222
# emit-variable-ref
# env=((f94223 . -20) (f94222 . -16) (f94223 . -12) (f94222 . -8))
# var=f94222
    movl -16(%esp), %eax  # stack load f94222
# end emit-variable-ref
# check the argument is a pair
    movl %eax,%ebx
    and $7, %bl
    cmp $1, %bl
    je _L_570593
# invoke error handler eh_pair
    .extern mrc_eh$upair
    movl mrc_eh$upair, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $116,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_570593:
    movl -1(%eax), %eax
#return from tail (car f94222)
    ret
    jmp _L_570590
_L_570589:
# emit-tail-expr
# si=-24
# env=((f94223 . -20) (f94222 . -16) (f94223 . -12) (f94222 . -8))
# expr=((primitive-ref list-ref) (cdr f94222) (fx- f94223 1))
# emit-tail-funcall
#    si   =-24
#    env  = ((f94223 . -20) (f94222 . -16) (f94223 . -12) (f94222 . -8))
#    expr = (funcall (primitive-ref list-ref) (cdr f94222) (fx- f94223 1))
# emit-expr (primitive-ref list-ref)
    .extern mrc_list$mref
    movl mrc_list$mref,%eax
   movl %eax,  -24(%esp)  # stash funcall-oper in next closure slot
# emit-expr (cdr f94222)
# emit-expr f94222
# emit-variable-ref
# env=((f94223 . -20) (f94222 . -16) (f94223 . -12) (f94222 . -8))
# var=f94222
    movl -16(%esp), %eax  # stack load f94222
# end emit-variable-ref
# check the argument is a pair
    movl %eax,%ebx
    and $7, %bl
    cmp $1, %bl
    je _L_570594
# invoke error handler eh_pair
    .extern mrc_eh$upair
    movl mrc_eh$upair, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $120,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_570594:
    movl 3(%eax), %eax
    mov %eax, -28(%esp)    # arg (cdr f94222)
# emit-expr (fx- f94223 1)
# emit-expr 1
    movl $4, %eax     # immed 1
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_570595"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $92,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_570595:
    movl %eax, -32(%esp)
# emit-expr f94223
# emit-variable-ref
# env=((f94223 . -20) (f94222 . -16) (f94223 . -12) (f94222 . -8))
# var=f94223
    movl -20(%esp), %eax  # stack load f94223
# end emit-variable-ref
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_570596"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $92,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_570596:
    subl -32(%esp), %eax
    mov %eax, -32(%esp)    # arg (fx- f94223 1)
    movl -24(%esp), %edi   # load new closure to %edi
# emit-shift-args:  size=3   si=-24  delta=20
    mov -24(%esp), %ebx  # shift frame cell
    mov %ebx, -4(%esp)  # down to base
# emit-shift-args:  size=2   si=-28  delta=20
    mov -28(%esp), %ebx  # shift frame cell
    mov %ebx, -8(%esp)  # down to base
# emit-shift-args:  size=1   si=-32  delta=20
    mov -32(%esp), %ebx  # shift frame cell
    mov %ebx, -12(%esp)  # down to base
# emit-shift-args:  size=0   si=-36  delta=20
    movl $8,%eax   # save arg count
    jmp *-2(%edi)  # tail-funcall
_L_570590:
    .align 4,0x90
_L_570587:
     movl %eax, mrc_list$mref
# == explicit-begins  ==>
# (lambda (l) (if (null? l) 0 (fxadd1 (list-length (cdr l)))))
# == eliminate-let*  ==>
# (lambda (l) (if (null? l) 0 (fxadd1 (list-length (cdr l)))))
# == uniquify-variables  ==>
# (lambda (f94224) (if (null? f94224) 0 (fxadd1 (list-length (cdr f94224)))))
# == vectorize-letrec  ==>
# (lambda (f94224) (if (null? f94224) 0 (fxadd1 (list-length (cdr f94224)))))
# == eliminate-set!  ==>
# (lambda (f94224) (let ((f94224 f94224)) (if (null? f94224) 0 (fxadd1 (list-length (cdr f94224))))))
# == close-free-variables  ==>
# (closure (f94224) () (let ((f94224 f94224)) (if (null? f94224) 0 (fxadd1 (list-length (cdr f94224))))))
# == eliminate-quote  ==>
# (closure (f94224) () (let ((f94224 f94224)) (if (null? f94224) 0 (fxadd1 (list-length (cdr f94224))))))
# == eliminate-when/unless  ==>
# (closure (f94224) () (let ((f94224 f94224)) (if (null? f94224) 0 (fxadd1 (list-length (cdr f94224))))))
# == eliminate-cond  ==>
# (closure (f94224) () (let ((f94224 f94224)) (if (null? f94224) 0 (fxadd1 (list-length (cdr f94224))))))
# == external-symbols  ==>
# (closure (f94224) () (let ((f94224 f94224)) (if (null? f94224) 0 (fxadd1 ((primitive-ref list-length) (cdr f94224))))))
# emit-expr (closure (f94224) () (let ((f94224 f94224)) (if (null? f94224) 0 (fxadd1 ((primitive-ref list-length) (cdr f94224))))))
# emit-closure
# si = 0
# env = ()
# expr = (closure (f94224) () (let ((f94224 f94224)) (if (null? f94224) 0 (fxadd1 ((primitive-ref list-length) (cdr f94224))))))
    movl $_L_570597, 0(%ebp)  # closure label
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $8, %ebp     # bump ebp
    jmp _L_570598            # jump around closure body
_L_570597:
# check argument count
    cmp $4,%eax
    je _L_570599
# invoke error handler eh_argcount
    .extern mrc_eh$uargcount
    movl mrc_eh$uargcount, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_570599:
# emit-tail-expr
# si=-12
# env=((f94224 . -8))
# expr=(let ((f94224 f94224)) (if (null? f94224) 0 (fxadd1 ((primitive-ref list-length) (cdr f94224)))))
# emit-tail-let
#  si   = -12
#  env  = ((f94224 . -8))
#  bindings = ((f94224 f94224))
#  body = (if (null? f94224) 0 (fxadd1 ((primitive-ref list-length) (cdr f94224))))
# emit-expr f94224
# emit-variable-ref
# env=((f94224 . -8))
# var=f94224
    movl -8(%esp), %eax  # stack load f94224
# end emit-variable-ref
    movl %eax, -12(%esp)  # stack save
# emit-tail-expr
# si=-16
# env=((f94224 . -12) (f94224 . -8))
# expr=(if (null? f94224) 0 (fxadd1 ((primitive-ref list-length) (cdr f94224))))
# emit-expr (null? f94224)
# emit-expr f94224
# emit-variable-ref
# env=((f94224 . -12) (f94224 . -8))
# var=f94224
    movl -12(%esp), %eax  # stack load f94224
# end emit-variable-ref
    cmp $63, %eax
    mov $0, %eax
    sete %al
    movzbl %al, %eax
    sal $6, %al
    or $47, %al
    cmp $47, %al
    je _L_570600
# emit-tail-expr
# si=-16
# env=((f94224 . -12) (f94224 . -8))
# expr=0
    movl $0, %eax     # immed 0
    ret                  # immediate tail return
    jmp _L_570601
_L_570600:
# emit-tail-expr
# si=-16
# env=((f94224 . -12) (f94224 . -8))
# expr=(fxadd1 ((primitive-ref list-length) (cdr f94224)))
# tail primcall
# emit-expr ((primitive-ref list-length) (cdr f94224))
# funcall
#    si   =-16
#    env  = ((f94224 . -12) (f94224 . -8))
#    expr = (funcall (primitive-ref list-length) (cdr f94224))
# emit-expr (primitive-ref list-length)
    .extern mrc_list$mlength
    movl mrc_list$mlength,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_570602"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_570602":
   movl %eax,  -24(%esp)  # stash funcall-oper in closure slot
# emit-expr (cdr f94224)
# emit-expr f94224
# emit-variable-ref
# env=((f94224 . -12) (f94224 . -8))
# var=f94224
    movl -12(%esp), %eax  # stack load f94224
# end emit-variable-ref
# check the argument is a pair
    movl %eax,%ebx
    and $7, %bl
    cmp $1, %bl
    je _L_570603
# invoke error handler eh_pair
    .extern mrc_eh$upair
    movl mrc_eh$upair, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $120,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_570603:
    movl 3(%eax), %eax
    mov %eax, -28(%esp)  # arg (cdr f94224)
    movl -24(%esp), %edi   # load new closure to %edi
    add $-16, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $16, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_570604"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $56,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_570604:
     addl $4, %eax
#return from tail (fxadd1 ((primitive-ref list-length) (cdr f94224)))
    ret
_L_570601:
    .align 4,0x90
_L_570598:
     movl %eax, mrc_list$mlength
# == explicit-begins  ==>
# (letrec ((f (lambda (l lrev) (if (null? l) lrev (f (cdr l) (cons (car l) lrev)))))) (lambda (l) (f l (quote ()))))
# == eliminate-let*  ==>
# (letrec ((f (lambda (l lrev) (if (null? l) lrev (f (cdr l) (cons (car l) lrev)))))) (lambda (l) (f l (quote ()))))
# == uniquify-variables  ==>
# (letrec ((f94225 (lambda (f94228 f94229) (if (null? f94228) f94229 (f94225 (cdr f94228) (cons (car f94228) f94229)))))) (lambda (f94231) (f94225 f94231 (quote ()))))
# == vectorize-letrec  ==>
# (let ((f94225 (make-vector 1))) (begin (begin (vector-set! f94225 0 (lambda (f94228 f94229) (if (null? f94228) f94229 ((vector-ref f94225 0) (cdr f94228) (cons (car f94228) f94229)))))) (lambda (f94231) ((vector-ref f94225 0) f94231 (quote ())))))
# == eliminate-set!  ==>
# (let ((f94225 (make-vector 1))) (begin (begin (vector-set! f94225 0 (lambda (f94228 f94229) (let ((f94228 f94228) (f94229 f94229)) (if (null? f94228) f94229 ((vector-ref f94225 0) (cdr f94228) (cons (car f94228) f94229))))))) (lambda (f94231) (let ((f94231 f94231)) ((vector-ref f94225 0) f94231 (quote ()))))))
# == close-free-variables  ==>
# (let ((f94225 (make-vector 1))) (begin (begin (vector-set! f94225 0 (closure (f94228 f94229) (f94225) (let ((f94228 f94228) (f94229 f94229)) (if (null? f94228) f94229 ((vector-ref f94225 0) (cdr f94228) (cons (car f94228) f94229))))))) (closure (f94231) (f94225) (let ((f94231 f94231)) ((vector-ref f94225 0) f94231 (quote ()))))))
# == eliminate-quote  ==>
# (let ((f94225 (make-vector 1))) (begin (begin (vector-set! f94225 0 (closure (f94228 f94229) (f94225) (let ((f94228 f94228) (f94229 f94229)) (if (null? f94228) f94229 ((vector-ref f94225 0) (cdr f94228) (cons (car f94228) f94229))))))) (closure (f94231) (f94225) (let ((f94231 f94231)) ((vector-ref f94225 0) f94231 ())))))
# == eliminate-when/unless  ==>
# (let ((f94225 (make-vector 1))) (begin (begin (vector-set! f94225 0 (closure (f94228 f94229) (f94225) (let ((f94228 f94228) (f94229 f94229)) (if (null? f94228) f94229 ((vector-ref f94225 0) (cdr f94228) (cons (car f94228) f94229))))))) (closure (f94231) (f94225) (let ((f94231 f94231)) ((vector-ref f94225 0) f94231 ())))))
# == eliminate-cond  ==>
# (let ((f94225 (make-vector 1))) (begin (begin (vector-set! f94225 0 (closure (f94228 f94229) (f94225) (let ((f94228 f94228) (f94229 f94229)) (if (null? f94228) f94229 ((vector-ref f94225 0) (cdr f94228) (cons (car f94228) f94229))))))) (closure (f94231) (f94225) (let ((f94231 f94231)) ((vector-ref f94225 0) f94231 ())))))
# == external-symbols  ==>
# (let ((f94225 (make-vector 1))) (begin (begin (vector-set! f94225 0 (closure (f94228 f94229) (f94225) (let ((f94228 f94228) (f94229 f94229)) (if (null? f94228) f94229 ((vector-ref f94225 0) (cdr f94228) (cons (car f94228) f94229))))))) (closure (f94231) (f94225) (let ((f94231 f94231)) ((vector-ref f94225 0) f94231 ())))))
# emit-expr (let ((f94225 (make-vector 1))) (begin (begin (vector-set! f94225 0 (closure (f94228 f94229) (f94225) (let ((f94228 f94228) (f94229 f94229)) (if (null? f94228) f94229 ((vector-ref f94225 0) (cdr f94228) (cons (car f94228) f94229))))))) (closure (f94231) (f94225) (let ((f94231 f94231)) ((vector-ref f94225 0) f94231 ())))))
# emit-let
#  si   = 0
#  env  = ()
#  bindings = ((f94225 (make-vector 1)))
#  body = (begin (begin (vector-set! f94225 0 (closure (f94228 f94229) (f94225) (let ((f94228 f94228) (f94229 f94229)) (if (null? f94228) f94229 ((vector-ref f94225 0) (cdr f94228) (cons (car f94228) f94229))))))) (closure (f94231) (f94225) (let ((f94231 f94231)) ((vector-ref f94225 0) f94231 ()))))
# emit-expr (make-vector 1)
# make-vector 1
# emit-expr 1
    movl $4, %eax     # immed 1
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_570605"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_570605:
# check the argument is a fixnum >= 0
    cmp $0,%eax
    jge _L_570606
# invoke error handler eh_length
    .extern mrc_eh$ulength
    movl mrc_eh$ulength, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_570606:
    movl %eax, %esi
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    orl  $5, %eax
    addl $4, %esi
    addl $4, %esi
    andl $-8, %esi
    addl %esi, %ebp
    movl %eax, 0(%esp)  # stack save
# emit-expr (begin (begin (vector-set! f94225 0 (closure (f94228 f94229) (f94225) (let ((f94228 f94228) (f94229 f94229)) (if (null? f94228) f94229 ((vector-ref f94225 0) (cdr f94228) (cons (car f94228) f94229))))))) (closure (f94231) (f94225) (let ((f94231 f94231)) ((vector-ref f94225 0) f94231 ()))))
# emit-begin
#   expr=(begin (begin (vector-set! f94225 0 (closure (f94228 f94229) (f94225) (let ((f94228 f94228) (f94229 f94229)) (if (null? f94228) f94229 ((vector-ref f94225 0) (cdr f94228) (cons (car f94228) f94229))))))) (closure (f94231) (f94225) (let ((f94231 f94231)) ((vector-ref f94225 0) f94231 ()))))
#   env=((f94225 . 0))
# emit-expr (begin (vector-set! f94225 0 (closure (f94228 f94229) (f94225) (let ((f94228 f94228) (f94229 f94229)) (if (null? f94228) f94229 ((vector-ref f94225 0) (cdr f94228) (cons (car f94228) f94229)))))))
# emit-begin
#   expr=(begin (vector-set! f94225 0 (closure (f94228 f94229) (f94225) (let ((f94228 f94228) (f94229 f94229)) (if (null? f94228) f94229 ((vector-ref f94225 0) (cdr f94228) (cons (car f94228) f94229)))))))
#   env=((f94225 . 0))
# emit-expr (vector-set! f94225 0 (closure (f94228 f94229) (f94225) (let ((f94228 f94228) (f94229 f94229)) (if (null? f94228) f94229 ((vector-ref f94225 0) (cdr f94228) (cons (car f94228) f94229))))))
# emit-expr f94225
# emit-variable-ref
# env=((f94225 . 0))
# var=f94225
    movl 0(%esp), %eax  # stack load f94225
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_570607
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_570607:
    movl %eax, -4(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_570608"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_570608:
# check bounds on vector index
    movl -4(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_570610
    cmp  $0,%eax
    jge _L_570609
_L_570610:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_570609:
    movl %eax, -8(%esp)
# emit-expr (closure (f94228 f94229) (f94225) (let ((f94228 f94228) (f94229 f94229)) (if (null? f94228) f94229 ((vector-ref f94225 0) (cdr f94228) (cons (car f94228) f94229)))))
# emit-closure
# si = -12
# env = ((f94225 . 0))
# expr = (closure (f94228 f94229) (f94225) (let ((f94228 f94228) (f94229 f94229)) (if (null? f94228) f94229 ((vector-ref f94225 0) (cdr f94228) (cons (car f94228) f94229)))))
    movl $_L_570611, 0(%ebp)  # closure label
# emit-variable-ref
# env=((f94225 . 0))
# var=f94225
    movl 0(%esp), %eax  # stack load f94225
# end emit-variable-ref
   movl  %eax, 4(%ebp)  # f94225
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $8, %ebp     # bump ebp
    jmp _L_570612            # jump around closure body
_L_570611:
# check argument count
    cmp $8,%eax
    je _L_570613
# invoke error handler eh_argcount
    .extern mrc_eh$uargcount
    movl mrc_eh$uargcount, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_570613:
# emit-tail-expr
# si=-16
# env=((f94229 . -12) (f94228 . -8) (f94225 . 4) (f94225 . 0))
# expr=(let ((f94228 f94228) (f94229 f94229)) (if (null? f94228) f94229 ((vector-ref f94225 0) (cdr f94228) (cons (car f94228) f94229))))
# emit-tail-let
#  si   = -16
#  env  = ((f94229 . -12) (f94228 . -8) (f94225 . 4) (f94225 . 0))
#  bindings = ((f94228 f94228) (f94229 f94229))
#  body = (if (null? f94228) f94229 ((vector-ref f94225 0) (cdr f94228) (cons (car f94228) f94229)))
# emit-expr f94228
# emit-variable-ref
# env=((f94229 . -12) (f94228 . -8) (f94225 . 4) (f94225 . 0))
# var=f94228
    movl -8(%esp), %eax  # stack load f94228
# end emit-variable-ref
    movl %eax, -16(%esp)  # stack save
# emit-expr f94229
# emit-variable-ref
# env=((f94229 . -12) (f94228 . -8) (f94225 . 4) (f94225 . 0))
# var=f94229
    movl -12(%esp), %eax  # stack load f94229
# end emit-variable-ref
    movl %eax, -20(%esp)  # stack save
# emit-tail-expr
# si=-24
# env=((f94229 . -20) (f94228 . -16) (f94229 . -12) (f94228 . -8) (f94225 . 4) (f94225 . 0))
# expr=(if (null? f94228) f94229 ((vector-ref f94225 0) (cdr f94228) (cons (car f94228) f94229)))
# emit-expr (null? f94228)
# emit-expr f94228
# emit-variable-ref
# env=((f94229 . -20) (f94228 . -16) (f94229 . -12) (f94228 . -8) (f94225 . 4) (f94225 . 0))
# var=f94228
    movl -16(%esp), %eax  # stack load f94228
# end emit-variable-ref
    cmp $63, %eax
    mov $0, %eax
    sete %al
    movzbl %al, %eax
    sal $6, %al
    or $47, %al
    cmp $47, %al
    je _L_570614
# emit-tail-expr
# si=-24
# env=((f94229 . -20) (f94228 . -16) (f94229 . -12) (f94228 . -8) (f94225 . 4) (f94225 . 0))
# expr=f94229
# emit-tail-variable-ref
# emit-variable-ref
# env=((f94229 . -20) (f94228 . -16) (f94229 . -12) (f94228 . -8) (f94225 . 4) (f94225 . 0))
# var=f94229
    movl -20(%esp), %eax  # stack load f94229
# end emit-variable-ref
    ret
# end emit-tail-variable ref
    jmp _L_570615
_L_570614:
# emit-tail-expr
# si=-24
# env=((f94229 . -20) (f94228 . -16) (f94229 . -12) (f94228 . -8) (f94225 . 4) (f94225 . 0))
# expr=((vector-ref f94225 0) (cdr f94228) (cons (car f94228) f94229))
# emit-tail-funcall
#    si   =-24
#    env  = ((f94229 . -20) (f94228 . -16) (f94229 . -12) (f94228 . -8) (f94225 . 4) (f94225 . 0))
#    expr = (funcall (vector-ref f94225 0) (cdr f94228) (cons (car f94228) f94229))
# emit-expr (vector-ref f94225 0)
# emit-expr f94225
# emit-variable-ref
# env=((f94229 . -20) (f94228 . -16) (f94229 . -12) (f94228 . -8) (f94225 . 4) (f94225 . 0))
# var=f94225
    movl 2(%edi), %eax  # frame load f94225
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_570616
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_570616:
    movl %eax, -24(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_570617"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_570617:
# check bounds on vector index
    movl -24(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_570619
    cmp  $0,%eax
    jge _L_570618
_L_570619:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_570618:
    movl -24(%esp), %esi
    movl -1(%eax,%esi), %eax
   movl %eax,  -24(%esp)  # stash funcall-oper in next closure slot
# emit-expr (cdr f94228)
# emit-expr f94228
# emit-variable-ref
# env=((f94229 . -20) (f94228 . -16) (f94229 . -12) (f94228 . -8) (f94225 . 4) (f94225 . 0))
# var=f94228
    movl -16(%esp), %eax  # stack load f94228
# end emit-variable-ref
# check the argument is a pair
    movl %eax,%ebx
    and $7, %bl
    cmp $1, %bl
    je _L_570620
# invoke error handler eh_pair
    .extern mrc_eh$upair
    movl mrc_eh$upair, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $120,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_570620:
    movl 3(%eax), %eax
    mov %eax, -28(%esp)    # arg (cdr f94228)
# emit-expr (cons (car f94228) f94229)
# cons arg1=(car f94228) arg2=f94229
# emit-expr (car f94228)
# emit-expr f94228
# emit-variable-ref
# env=((f94229 . -20) (f94228 . -16) (f94229 . -12) (f94228 . -8) (f94225 . 4) (f94225 . 0))
# var=f94228
    movl -16(%esp), %eax  # stack load f94228
# end emit-variable-ref
# check the argument is a pair
    movl %eax,%ebx
    and $7, %bl
    cmp $1, %bl
    je _L_570621
# invoke error handler eh_pair
    .extern mrc_eh$upair
    movl mrc_eh$upair, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $116,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_570621:
    movl -1(%eax), %eax
    movl %eax, -32(%esp)
# emit-expr f94229
# emit-variable-ref
# env=((f94229 . -20) (f94228 . -16) (f94229 . -12) (f94228 . -8) (f94225 . 4) (f94225 . 0))
# var=f94229
    movl -20(%esp), %eax  # stack load f94229
# end emit-variable-ref
    movl %eax, 4(%ebp)
    movl -32(%esp), %eax
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    or   $1, %al
    add  $8, %ebp
# cons end
    mov %eax, -32(%esp)    # arg (cons (car f94228) f94229)
    movl -24(%esp), %edi   # load new closure to %edi
# emit-shift-args:  size=3   si=-24  delta=20
    mov -24(%esp), %ebx  # shift frame cell
    mov %ebx, -4(%esp)  # down to base
# emit-shift-args:  size=2   si=-28  delta=20
    mov -28(%esp), %ebx  # shift frame cell
    mov %ebx, -8(%esp)  # down to base
# emit-shift-args:  size=1   si=-32  delta=20
    mov -32(%esp), %ebx  # shift frame cell
    mov %ebx, -12(%esp)  # down to base
# emit-shift-args:  size=0   si=-36  delta=20
    movl $8,%eax   # save arg count
    jmp *-2(%edi)  # tail-funcall
_L_570615:
    .align 4,0x90
_L_570612:
    movl -4(%esp), %ebx
    movl -8(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin)
# emit-begin
#   expr=(begin)
#   env=((f94225 . 0))
# emit-expr (begin (closure (f94231) (f94225) (let ((f94231 f94231)) ((vector-ref f94225 0) f94231 ()))))
# emit-begin
#   expr=(begin (closure (f94231) (f94225) (let ((f94231 f94231)) ((vector-ref f94225 0) f94231 ()))))
#   env=((f94225 . 0))
# emit-expr (closure (f94231) (f94225) (let ((f94231 f94231)) ((vector-ref f94225 0) f94231 ())))
# emit-closure
# si = -4
# env = ((f94225 . 0))
# expr = (closure (f94231) (f94225) (let ((f94231 f94231)) ((vector-ref f94225 0) f94231 ())))
    movl $_L_570622, 0(%ebp)  # closure label
# emit-variable-ref
# env=((f94225 . 0))
# var=f94225
    movl 0(%esp), %eax  # stack load f94225
# end emit-variable-ref
   movl  %eax, 4(%ebp)  # f94225
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $8, %ebp     # bump ebp
    jmp _L_570623            # jump around closure body
_L_570622:
# check argument count
    cmp $4,%eax
    je _L_570624
# invoke error handler eh_argcount
    .extern mrc_eh$uargcount
    movl mrc_eh$uargcount, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_570624:
# emit-tail-expr
# si=-12
# env=((f94231 . -8) (f94225 . 4) (f94225 . 0))
# expr=(let ((f94231 f94231)) ((vector-ref f94225 0) f94231 ()))
# emit-tail-let
#  si   = -12
#  env  = ((f94231 . -8) (f94225 . 4) (f94225 . 0))
#  bindings = ((f94231 f94231))
#  body = ((vector-ref f94225 0) f94231 ())
# emit-expr f94231
# emit-variable-ref
# env=((f94231 . -8) (f94225 . 4) (f94225 . 0))
# var=f94231
    movl -8(%esp), %eax  # stack load f94231
# end emit-variable-ref
    movl %eax, -12(%esp)  # stack save
# emit-tail-expr
# si=-16
# env=((f94231 . -12) (f94231 . -8) (f94225 . 4) (f94225 . 0))
# expr=((vector-ref f94225 0) f94231 ())
# emit-tail-funcall
#    si   =-16
#    env  = ((f94231 . -12) (f94231 . -8) (f94225 . 4) (f94225 . 0))
#    expr = (funcall (vector-ref f94225 0) f94231 ())
# emit-expr (vector-ref f94225 0)
# emit-expr f94225
# emit-variable-ref
# env=((f94231 . -12) (f94231 . -8) (f94225 . 4) (f94225 . 0))
# var=f94225
    movl 2(%edi), %eax  # frame load f94225
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_570625
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_570625:
    movl %eax, -16(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_570626"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_570626:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_570628
    cmp  $0,%eax
    jge _L_570627
_L_570628:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_570627:
    movl -16(%esp), %esi
    movl -1(%eax,%esi), %eax
   movl %eax,  -16(%esp)  # stash funcall-oper in next closure slot
# emit-expr f94231
# emit-variable-ref
# env=((f94231 . -12) (f94231 . -8) (f94225 . 4) (f94225 . 0))
# var=f94231
    movl -12(%esp), %eax  # stack load f94231
# end emit-variable-ref
    mov %eax, -20(%esp)    # arg f94231
# emit-expr ()
    movl $63, %eax     # immed ()
    mov %eax, -24(%esp)    # arg ()
    movl -16(%esp), %edi   # load new closure to %edi
# emit-shift-args:  size=3   si=-16  delta=12
    mov -16(%esp), %ebx  # shift frame cell
    mov %ebx, -4(%esp)  # down to base
# emit-shift-args:  size=2   si=-20  delta=12
    mov -20(%esp), %ebx  # shift frame cell
    mov %ebx, -8(%esp)  # down to base
# emit-shift-args:  size=1   si=-24  delta=12
    mov -24(%esp), %ebx  # shift frame cell
    mov %ebx, -12(%esp)  # down to base
# emit-shift-args:  size=0   si=-28  delta=12
    movl $8,%eax   # save arg count
    jmp *-2(%edi)  # tail-funcall
    .align 4,0x90
_L_570623:
# emit-expr (begin)
# emit-begin
#   expr=(begin)
#   env=((f94225 . 0))
     movl %eax, mrc_reverse
# == explicit-begins  ==>
# (lambda args args)
# == eliminate-let*  ==>
# (lambda args args)
# == uniquify-variables  ==>
# (lambda f94232 f94232)
# == vectorize-letrec  ==>
# (lambda f94232 f94232)
# == eliminate-set!  ==>
# (lambda f94232 (let () f94232))
# == close-free-variables  ==>
# (closure f94232 () (let () f94232))
# == eliminate-quote  ==>
# (closure f94232 () (let () f94232))
# == eliminate-when/unless  ==>
# (closure f94232 () (let () f94232))
# == eliminate-cond  ==>
# (closure f94232 () (let () f94232))
# == external-symbols  ==>
# (closure f94232 () (let () f94232))
# emit-expr (closure f94232 () (let () f94232))
# emit-closure
# si = 0
# env = ()
# expr = (closure f94232 () (let () f94232))
    movl $_L_570629, 0(%ebp)  # closure label
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $8, %ebp     # bump ebp
    jmp _L_570630            # jump around closure body
_L_570629:
# check argument count
    cmp $0,%eax
    jge _L_570631
# invoke error handler eh_argcount_min
    .extern mrc_eh$uargcount$umin
    movl mrc_eh$uargcount$umin, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_570631:
# emit-build-varargs-list
    movl $63, %esi       # args <- () 
    lea -4(%esp),%edi    # edi <- esp-4
    subl %eax, %edi      # edi <- esp-4-eax    addr of arg[K+N] on stack
_L_570633:
    lea -4(%esp),%ebx    # addr of arg[K] on stack
    cmp %edi, %ebx       # while edi <> esp+(si+4)
    je _L_570632
    movl (%edi),%ebx     # arg i -> car
    movl %ebx, 0(%ebp)
    movl %esi, 4(%ebp)  # esi -> cdr
    movl %ebp, %esi
    addl $1, %esi       # tag as pair
    addl $8,%ebp         # bump heap ptr
    addl $4,%edi         # move to next previous arg from the end
    jmp _L_570633
_L_570632:
    movl %esi, -8(%esp)  # set args
# emit-tail-expr
# si=-12
# env=((f94232 . -8))
# expr=(let () f94232)
# emit-tail-let
#  si   = -12
#  env  = ((f94232 . -8))
#  bindings = ()
#  body = f94232
# emit-tail-expr
# si=-12
# env=((f94232 . -8))
# expr=f94232
# emit-tail-variable-ref
# emit-variable-ref
# env=((f94232 . -8))
# var=f94232
    movl -8(%esp), %eax  # stack load f94232
# end emit-variable-ref
    ret
# end emit-tail-variable ref
    .align 4,0x90
_L_570630:
     movl %eax, mrc_list
# == explicit-begins  ==>
# (letrec ((fill-vector (lambda (v k args) (if (null? args) v (begin (vector-set! v k (car args)) (fill-vector v (fxadd1 k) (cdr args))))))) (lambda args (let ((v (make-vector (list-length args)))) (fill-vector v 0 args))))
# == eliminate-let*  ==>
# (letrec ((fill-vector (lambda (v k args) (if (null? args) v (begin (vector-set! v k (car args)) (fill-vector v (fxadd1 k) (cdr args))))))) (lambda args (let ((v (make-vector (list-length args)))) (fill-vector v 0 args))))
# == uniquify-variables  ==>
# (letrec ((f94233 (lambda (f94237 f94238 f94239) (if (null? f94239) f94237 (begin (vector-set! f94237 f94238 (car f94239)) (f94233 f94237 (fxadd1 f94238) (cdr f94239))))))) (lambda f94243 (let ((f94245 (make-vector (list-length f94243)))) (f94233 f94245 0 f94243))))
# == vectorize-letrec  ==>
# (let ((f94233 (make-vector 1))) (begin (begin (vector-set! f94233 0 (lambda (f94237 f94238 f94239) (if (null? f94239) f94237 (begin (vector-set! f94237 f94238 (car f94239)) ((vector-ref f94233 0) f94237 (fxadd1 f94238) (cdr f94239))))))) (lambda f94243 (let ((f94245 (make-vector (list-length f94243)))) ((vector-ref f94233 0) f94245 0 f94243)))))
# == eliminate-set!  ==>
# (let ((f94233 (make-vector 1))) (begin (begin (vector-set! f94233 0 (lambda (f94237 f94238 f94239) (let ((f94237 f94237) (f94238 f94238) (f94239 f94239)) (if (null? f94239) f94237 (begin (vector-set! f94237 f94238 (car f94239)) ((vector-ref f94233 0) f94237 (fxadd1 f94238) (cdr f94239)))))))) (lambda f94243 (let () (let ((f94245 (make-vector (list-length f94243)))) ((vector-ref f94233 0) f94245 0 f94243))))))
# == close-free-variables  ==>
# (let ((f94233 (make-vector 1))) (begin (begin (vector-set! f94233 0 (closure (f94237 f94238 f94239) (f94233) (let ((f94237 f94237) (f94238 f94238) (f94239 f94239)) (if (null? f94239) f94237 (begin (vector-set! f94237 f94238 (car f94239)) ((vector-ref f94233 0) f94237 (fxadd1 f94238) (cdr f94239)))))))) (closure f94243 (f94233) (let () (let ((f94245 (make-vector (list-length f94243)))) ((vector-ref f94233 0) f94245 0 f94243))))))
# == eliminate-quote  ==>
# (let ((f94233 (make-vector 1))) (begin (begin (vector-set! f94233 0 (closure (f94237 f94238 f94239) (f94233) (let ((f94237 f94237) (f94238 f94238) (f94239 f94239)) (if (null? f94239) f94237 (begin (vector-set! f94237 f94238 (car f94239)) ((vector-ref f94233 0) f94237 (fxadd1 f94238) (cdr f94239)))))))) (closure f94243 (f94233) (let () (let ((f94245 (make-vector (list-length f94243)))) ((vector-ref f94233 0) f94245 0 f94243))))))
# == eliminate-when/unless  ==>
# (let ((f94233 (make-vector 1))) (begin (begin (vector-set! f94233 0 (closure (f94237 f94238 f94239) (f94233) (let ((f94237 f94237) (f94238 f94238) (f94239 f94239)) (if (null? f94239) f94237 (begin (vector-set! f94237 f94238 (car f94239)) ((vector-ref f94233 0) f94237 (fxadd1 f94238) (cdr f94239)))))))) (closure f94243 (f94233) (let () (let ((f94245 (make-vector (list-length f94243)))) ((vector-ref f94233 0) f94245 0 f94243))))))
# == eliminate-cond  ==>
# (let ((f94233 (make-vector 1))) (begin (begin (vector-set! f94233 0 (closure (f94237 f94238 f94239) (f94233) (let ((f94237 f94237) (f94238 f94238) (f94239 f94239)) (if (null? f94239) f94237 (begin (vector-set! f94237 f94238 (car f94239)) ((vector-ref f94233 0) f94237 (fxadd1 f94238) (cdr f94239)))))))) (closure f94243 (f94233) (let () (let ((f94245 (make-vector (list-length f94243)))) ((vector-ref f94233 0) f94245 0 f94243))))))
# == external-symbols  ==>
# (let ((f94233 (make-vector 1))) (begin (begin (vector-set! f94233 0 (closure (f94237 f94238 f94239) (f94233) (let ((f94237 f94237) (f94238 f94238) (f94239 f94239)) (if (null? f94239) f94237 (begin (vector-set! f94237 f94238 (car f94239)) ((vector-ref f94233 0) f94237 (fxadd1 f94238) (cdr f94239)))))))) (closure f94243 (f94233) (let () (let ((f94245 (make-vector ((primitive-ref list-length) f94243)))) ((vector-ref f94233 0) f94245 0 f94243))))))
# emit-expr (let ((f94233 (make-vector 1))) (begin (begin (vector-set! f94233 0 (closure (f94237 f94238 f94239) (f94233) (let ((f94237 f94237) (f94238 f94238) (f94239 f94239)) (if (null? f94239) f94237 (begin (vector-set! f94237 f94238 (car f94239)) ((vector-ref f94233 0) f94237 (fxadd1 f94238) (cdr f94239)))))))) (closure f94243 (f94233) (let () (let ((f94245 (make-vector ((primitive-ref list-length) f94243)))) ((vector-ref f94233 0) f94245 0 f94243))))))
# emit-let
#  si   = 0
#  env  = ()
#  bindings = ((f94233 (make-vector 1)))
#  body = (begin (begin (vector-set! f94233 0 (closure (f94237 f94238 f94239) (f94233) (let ((f94237 f94237) (f94238 f94238) (f94239 f94239)) (if (null? f94239) f94237 (begin (vector-set! f94237 f94238 (car f94239)) ((vector-ref f94233 0) f94237 (fxadd1 f94238) (cdr f94239)))))))) (closure f94243 (f94233) (let () (let ((f94245 (make-vector ((primitive-ref list-length) f94243)))) ((vector-ref f94233 0) f94245 0 f94243)))))
# emit-expr (make-vector 1)
# make-vector 1
# emit-expr 1
    movl $4, %eax     # immed 1
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_570634"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_570634:
# check the argument is a fixnum >= 0
    cmp $0,%eax
    jge _L_570635
# invoke error handler eh_length
    .extern mrc_eh$ulength
    movl mrc_eh$ulength, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_570635:
    movl %eax, %esi
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    orl  $5, %eax
    addl $4, %esi
    addl $4, %esi
    andl $-8, %esi
    addl %esi, %ebp
    movl %eax, 0(%esp)  # stack save
# emit-expr (begin (begin (vector-set! f94233 0 (closure (f94237 f94238 f94239) (f94233) (let ((f94237 f94237) (f94238 f94238) (f94239 f94239)) (if (null? f94239) f94237 (begin (vector-set! f94237 f94238 (car f94239)) ((vector-ref f94233 0) f94237 (fxadd1 f94238) (cdr f94239)))))))) (closure f94243 (f94233) (let () (let ((f94245 (make-vector ((primitive-ref list-length) f94243)))) ((vector-ref f94233 0) f94245 0 f94243)))))
# emit-begin
#   expr=(begin (begin (vector-set! f94233 0 (closure (f94237 f94238 f94239) (f94233) (let ((f94237 f94237) (f94238 f94238) (f94239 f94239)) (if (null? f94239) f94237 (begin (vector-set! f94237 f94238 (car f94239)) ((vector-ref f94233 0) f94237 (fxadd1 f94238) (cdr f94239)))))))) (closure f94243 (f94233) (let () (let ((f94245 (make-vector ((primitive-ref list-length) f94243)))) ((vector-ref f94233 0) f94245 0 f94243)))))
#   env=((f94233 . 0))
# emit-expr (begin (vector-set! f94233 0 (closure (f94237 f94238 f94239) (f94233) (let ((f94237 f94237) (f94238 f94238) (f94239 f94239)) (if (null? f94239) f94237 (begin (vector-set! f94237 f94238 (car f94239)) ((vector-ref f94233 0) f94237 (fxadd1 f94238) (cdr f94239))))))))
# emit-begin
#   expr=(begin (vector-set! f94233 0 (closure (f94237 f94238 f94239) (f94233) (let ((f94237 f94237) (f94238 f94238) (f94239 f94239)) (if (null? f94239) f94237 (begin (vector-set! f94237 f94238 (car f94239)) ((vector-ref f94233 0) f94237 (fxadd1 f94238) (cdr f94239))))))))
#   env=((f94233 . 0))
# emit-expr (vector-set! f94233 0 (closure (f94237 f94238 f94239) (f94233) (let ((f94237 f94237) (f94238 f94238) (f94239 f94239)) (if (null? f94239) f94237 (begin (vector-set! f94237 f94238 (car f94239)) ((vector-ref f94233 0) f94237 (fxadd1 f94238) (cdr f94239)))))))
# emit-expr f94233
# emit-variable-ref
# env=((f94233 . 0))
# var=f94233
    movl 0(%esp), %eax  # stack load f94233
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_570636
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_570636:
    movl %eax, -4(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_570637"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_570637:
# check bounds on vector index
    movl -4(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_570639
    cmp  $0,%eax
    jge _L_570638
_L_570639:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_570638:
    movl %eax, -8(%esp)
# emit-expr (closure (f94237 f94238 f94239) (f94233) (let ((f94237 f94237) (f94238 f94238) (f94239 f94239)) (if (null? f94239) f94237 (begin (vector-set! f94237 f94238 (car f94239)) ((vector-ref f94233 0) f94237 (fxadd1 f94238) (cdr f94239))))))
# emit-closure
# si = -12
# env = ((f94233 . 0))
# expr = (closure (f94237 f94238 f94239) (f94233) (let ((f94237 f94237) (f94238 f94238) (f94239 f94239)) (if (null? f94239) f94237 (begin (vector-set! f94237 f94238 (car f94239)) ((vector-ref f94233 0) f94237 (fxadd1 f94238) (cdr f94239))))))
    movl $_L_570640, 0(%ebp)  # closure label
# emit-variable-ref
# env=((f94233 . 0))
# var=f94233
    movl 0(%esp), %eax  # stack load f94233
# end emit-variable-ref
   movl  %eax, 4(%ebp)  # f94233
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $8, %ebp     # bump ebp
    jmp _L_570641            # jump around closure body
_L_570640:
# check argument count
    cmp $12,%eax
    je _L_570642
# invoke error handler eh_argcount
    .extern mrc_eh$uargcount
    movl mrc_eh$uargcount, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_570642:
# emit-tail-expr
# si=-20
# env=((f94239 . -16) (f94238 . -12) (f94237 . -8) (f94233 . 4) (f94233 . 0))
# expr=(let ((f94237 f94237) (f94238 f94238) (f94239 f94239)) (if (null? f94239) f94237 (begin (vector-set! f94237 f94238 (car f94239)) ((vector-ref f94233 0) f94237 (fxadd1 f94238) (cdr f94239)))))
# emit-tail-let
#  si   = -20
#  env  = ((f94239 . -16) (f94238 . -12) (f94237 . -8) (f94233 . 4) (f94233 . 0))
#  bindings = ((f94237 f94237) (f94238 f94238) (f94239 f94239))
#  body = (if (null? f94239) f94237 (begin (vector-set! f94237 f94238 (car f94239)) ((vector-ref f94233 0) f94237 (fxadd1 f94238) (cdr f94239))))
# emit-expr f94237
# emit-variable-ref
# env=((f94239 . -16) (f94238 . -12) (f94237 . -8) (f94233 . 4) (f94233 . 0))
# var=f94237
    movl -8(%esp), %eax  # stack load f94237
# end emit-variable-ref
    movl %eax, -20(%esp)  # stack save
# emit-expr f94238
# emit-variable-ref
# env=((f94239 . -16) (f94238 . -12) (f94237 . -8) (f94233 . 4) (f94233 . 0))
# var=f94238
    movl -12(%esp), %eax  # stack load f94238
# end emit-variable-ref
    movl %eax, -24(%esp)  # stack save
# emit-expr f94239
# emit-variable-ref
# env=((f94239 . -16) (f94238 . -12) (f94237 . -8) (f94233 . 4) (f94233 . 0))
# var=f94239
    movl -16(%esp), %eax  # stack load f94239
# end emit-variable-ref
    movl %eax, -28(%esp)  # stack save
# emit-tail-expr
# si=-32
# env=((f94239 . -28) (f94238 . -24) (f94237 . -20) (f94239 . -16) (f94238 . -12) (f94237 . -8) (f94233 . 4) (f94233 . 0))
# expr=(if (null? f94239) f94237 (begin (vector-set! f94237 f94238 (car f94239)) ((vector-ref f94233 0) f94237 (fxadd1 f94238) (cdr f94239))))
# emit-expr (null? f94239)
# emit-expr f94239
# emit-variable-ref
# env=((f94239 . -28) (f94238 . -24) (f94237 . -20) (f94239 . -16) (f94238 . -12) (f94237 . -8) (f94233 . 4) (f94233 . 0))
# var=f94239
    movl -28(%esp), %eax  # stack load f94239
# end emit-variable-ref
    cmp $63, %eax
    mov $0, %eax
    sete %al
    movzbl %al, %eax
    sal $6, %al
    or $47, %al
    cmp $47, %al
    je _L_570643
# emit-tail-expr
# si=-32
# env=((f94239 . -28) (f94238 . -24) (f94237 . -20) (f94239 . -16) (f94238 . -12) (f94237 . -8) (f94233 . 4) (f94233 . 0))
# expr=f94237
# emit-tail-variable-ref
# emit-variable-ref
# env=((f94239 . -28) (f94238 . -24) (f94237 . -20) (f94239 . -16) (f94238 . -12) (f94237 . -8) (f94233 . 4) (f94233 . 0))
# var=f94237
    movl -20(%esp), %eax  # stack load f94237
# end emit-variable-ref
    ret
# end emit-tail-variable ref
    jmp _L_570644
_L_570643:
# emit-tail-expr
# si=-32
# env=((f94239 . -28) (f94238 . -24) (f94237 . -20) (f94239 . -16) (f94238 . -12) (f94237 . -8) (f94233 . 4) (f94233 . 0))
# expr=(begin (vector-set! f94237 f94238 (car f94239)) ((vector-ref f94233 0) f94237 (fxadd1 f94238) (cdr f94239)))
# tail-begin (begin (vector-set! f94237 f94238 (car f94239)) ((vector-ref f94233 0) f94237 (fxadd1 f94238) (cdr f94239)))
#   env=((f94239 . -28) (f94238 . -24) (f94237 . -20) (f94239 . -16) (f94238 . -12) (f94237 . -8) (f94233 . 4) (f94233 . 0))
# emit-expr (vector-set! f94237 f94238 (car f94239))
# emit-expr f94237
# emit-variable-ref
# env=((f94239 . -28) (f94238 . -24) (f94237 . -20) (f94239 . -16) (f94238 . -12) (f94237 . -8) (f94233 . 4) (f94233 . 0))
# var=f94237
    movl -20(%esp), %eax  # stack load f94237
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_570645
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_570645:
    movl %eax, -32(%esp)
# emit-expr f94238
# emit-variable-ref
# env=((f94239 . -28) (f94238 . -24) (f94237 . -20) (f94239 . -16) (f94238 . -12) (f94237 . -8) (f94233 . 4) (f94233 . 0))
# var=f94238
    movl -24(%esp), %eax  # stack load f94238
# end emit-variable-ref
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_570646"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_570646:
# check bounds on vector index
    movl -32(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_570648
    cmp  $0,%eax
    jge _L_570647
_L_570648:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_570647:
    movl %eax, -36(%esp)
# emit-expr (car f94239)
# emit-expr f94239
# emit-variable-ref
# env=((f94239 . -28) (f94238 . -24) (f94237 . -20) (f94239 . -16) (f94238 . -12) (f94237 . -8) (f94233 . 4) (f94233 . 0))
# var=f94239
    movl -28(%esp), %eax  # stack load f94239
# end emit-variable-ref
# check the argument is a pair
    movl %eax,%ebx
    and $7, %bl
    cmp $1, %bl
    je _L_570649
# invoke error handler eh_pair
    .extern mrc_eh$upair
    movl mrc_eh$upair, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $116,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_570649:
    movl -1(%eax), %eax
    movl -32(%esp), %ebx
    movl -36(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-tail-expr
# si=-32
# env=((f94239 . -28) (f94238 . -24) (f94237 . -20) (f94239 . -16) (f94238 . -12) (f94237 . -8) (f94233 . 4) (f94233 . 0))
# expr=(begin ((vector-ref f94233 0) f94237 (fxadd1 f94238) (cdr f94239)))
# tail-begin (begin ((vector-ref f94233 0) f94237 (fxadd1 f94238) (cdr f94239)))
#   env=((f94239 . -28) (f94238 . -24) (f94237 . -20) (f94239 . -16) (f94238 . -12) (f94237 . -8) (f94233 . 4) (f94233 . 0))
# emit-tail-expr
# si=-32
# env=((f94239 . -28) (f94238 . -24) (f94237 . -20) (f94239 . -16) (f94238 . -12) (f94237 . -8) (f94233 . 4) (f94233 . 0))
# expr=((vector-ref f94233 0) f94237 (fxadd1 f94238) (cdr f94239))
# emit-tail-funcall
#    si   =-32
#    env  = ((f94239 . -28) (f94238 . -24) (f94237 . -20) (f94239 . -16) (f94238 . -12) (f94237 . -8) (f94233 . 4) (f94233 . 0))
#    expr = (funcall (vector-ref f94233 0) f94237 (fxadd1 f94238) (cdr f94239))
# emit-expr (vector-ref f94233 0)
# emit-expr f94233
# emit-variable-ref
# env=((f94239 . -28) (f94238 . -24) (f94237 . -20) (f94239 . -16) (f94238 . -12) (f94237 . -8) (f94233 . 4) (f94233 . 0))
# var=f94233
    movl 2(%edi), %eax  # frame load f94233
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_570650
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_570650:
    movl %eax, -32(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_570651"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_570651:
# check bounds on vector index
    movl -32(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_570653
    cmp  $0,%eax
    jge _L_570652
_L_570653:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_570652:
    movl -32(%esp), %esi
    movl -1(%eax,%esi), %eax
   movl %eax,  -32(%esp)  # stash funcall-oper in next closure slot
# emit-expr f94237
# emit-variable-ref
# env=((f94239 . -28) (f94238 . -24) (f94237 . -20) (f94239 . -16) (f94238 . -12) (f94237 . -8) (f94233 . 4) (f94233 . 0))
# var=f94237
    movl -20(%esp), %eax  # stack load f94237
# end emit-variable-ref
    mov %eax, -36(%esp)    # arg f94237
# emit-expr (fxadd1 f94238)
# emit-expr f94238
# emit-variable-ref
# env=((f94239 . -28) (f94238 . -24) (f94237 . -20) (f94239 . -16) (f94238 . -12) (f94237 . -8) (f94233 . 4) (f94233 . 0))
# var=f94238
    movl -24(%esp), %eax  # stack load f94238
# end emit-variable-ref
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_570654"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $56,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_570654:
     addl $4, %eax
    mov %eax, -40(%esp)    # arg (fxadd1 f94238)
# emit-expr (cdr f94239)
# emit-expr f94239
# emit-variable-ref
# env=((f94239 . -28) (f94238 . -24) (f94237 . -20) (f94239 . -16) (f94238 . -12) (f94237 . -8) (f94233 . 4) (f94233 . 0))
# var=f94239
    movl -28(%esp), %eax  # stack load f94239
# end emit-variable-ref
# check the argument is a pair
    movl %eax,%ebx
    and $7, %bl
    cmp $1, %bl
    je _L_570655
# invoke error handler eh_pair
    .extern mrc_eh$upair
    movl mrc_eh$upair, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $120,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_570655:
    movl 3(%eax), %eax
    mov %eax, -44(%esp)    # arg (cdr f94239)
    movl -32(%esp), %edi   # load new closure to %edi
# emit-shift-args:  size=4   si=-32  delta=28
    mov -32(%esp), %ebx  # shift frame cell
    mov %ebx, -4(%esp)  # down to base
# emit-shift-args:  size=3   si=-36  delta=28
    mov -36(%esp), %ebx  # shift frame cell
    mov %ebx, -8(%esp)  # down to base
# emit-shift-args:  size=2   si=-40  delta=28
    mov -40(%esp), %ebx  # shift frame cell
    mov %ebx, -12(%esp)  # down to base
# emit-shift-args:  size=1   si=-44  delta=28
    mov -44(%esp), %ebx  # shift frame cell
    mov %ebx, -16(%esp)  # down to base
# emit-shift-args:  size=0   si=-48  delta=28
    movl $12,%eax   # save arg count
    jmp *-2(%edi)  # tail-funcall
     ret   # return thru stack
_L_570644:
    .align 4,0x90
_L_570641:
    movl -4(%esp), %ebx
    movl -8(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin)
# emit-begin
#   expr=(begin)
#   env=((f94233 . 0))
# emit-expr (begin (closure f94243 (f94233) (let () (let ((f94245 (make-vector ((primitive-ref list-length) f94243)))) ((vector-ref f94233 0) f94245 0 f94243)))))
# emit-begin
#   expr=(begin (closure f94243 (f94233) (let () (let ((f94245 (make-vector ((primitive-ref list-length) f94243)))) ((vector-ref f94233 0) f94245 0 f94243)))))
#   env=((f94233 . 0))
# emit-expr (closure f94243 (f94233) (let () (let ((f94245 (make-vector ((primitive-ref list-length) f94243)))) ((vector-ref f94233 0) f94245 0 f94243))))
# emit-closure
# si = -4
# env = ((f94233 . 0))
# expr = (closure f94243 (f94233) (let () (let ((f94245 (make-vector ((primitive-ref list-length) f94243)))) ((vector-ref f94233 0) f94245 0 f94243))))
    movl $_L_570656, 0(%ebp)  # closure label
# emit-variable-ref
# env=((f94233 . 0))
# var=f94233
    movl 0(%esp), %eax  # stack load f94233
# end emit-variable-ref
   movl  %eax, 4(%ebp)  # f94233
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $8, %ebp     # bump ebp
    jmp _L_570657            # jump around closure body
_L_570656:
# check argument count
    cmp $0,%eax
    jge _L_570658
# invoke error handler eh_argcount_min
    .extern mrc_eh$uargcount$umin
    movl mrc_eh$uargcount$umin, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_570658:
# emit-build-varargs-list
    movl $63, %esi       # args <- () 
    lea -4(%esp),%edi    # edi <- esp-4
    subl %eax, %edi      # edi <- esp-4-eax    addr of arg[K+N] on stack
_L_570660:
    lea -4(%esp),%ebx    # addr of arg[K] on stack
    cmp %edi, %ebx       # while edi <> esp+(si+4)
    je _L_570659
    movl (%edi),%ebx     # arg i -> car
    movl %ebx, 0(%ebp)
    movl %esi, 4(%ebp)  # esi -> cdr
    movl %ebp, %esi
    addl $1, %esi       # tag as pair
    addl $8,%ebp         # bump heap ptr
    addl $4,%edi         # move to next previous arg from the end
    jmp _L_570660
_L_570659:
    movl %esi, -8(%esp)  # set args
# emit-tail-expr
# si=-12
# env=((f94243 . -8) (f94233 . 4) (f94233 . 0))
# expr=(let () (let ((f94245 (make-vector ((primitive-ref list-length) f94243)))) ((vector-ref f94233 0) f94245 0 f94243)))
# emit-tail-let
#  si   = -12
#  env  = ((f94243 . -8) (f94233 . 4) (f94233 . 0))
#  bindings = ()
#  body = (let ((f94245 (make-vector ((primitive-ref list-length) f94243)))) ((vector-ref f94233 0) f94245 0 f94243))
# emit-tail-expr
# si=-12
# env=((f94243 . -8) (f94233 . 4) (f94233 . 0))
# expr=(let ((f94245 (make-vector ((primitive-ref list-length) f94243)))) ((vector-ref f94233 0) f94245 0 f94243))
# emit-tail-let
#  si   = -12
#  env  = ((f94243 . -8) (f94233 . 4) (f94233 . 0))
#  bindings = ((f94245 (make-vector ((primitive-ref list-length) f94243))))
#  body = ((vector-ref f94233 0) f94245 0 f94243)
# emit-expr (make-vector ((primitive-ref list-length) f94243))
# make-vector ((primitive-ref list-length) f94243)
# emit-expr ((primitive-ref list-length) f94243)
# funcall
#    si   =-12
#    env  = ((f94243 . -8) (f94233 . 4) (f94233 . 0))
#    expr = (funcall (primitive-ref list-length) f94243)
# emit-expr (primitive-ref list-length)
    .extern mrc_list$mlength
    movl mrc_list$mlength,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_570661"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_570661":
   movl %eax,  -20(%esp)  # stash funcall-oper in closure slot
# emit-expr f94243
# emit-variable-ref
# env=((f94243 . -8) (f94233 . 4) (f94233 . 0))
# var=f94243
    movl -8(%esp), %eax  # stack load f94243
# end emit-variable-ref
    mov %eax, -24(%esp)  # arg f94243
    movl -20(%esp), %edi   # load new closure to %edi
    add $-12, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $12, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_570662"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_570662:
# check the argument is a fixnum >= 0
    cmp $0,%eax
    jge _L_570663
# invoke error handler eh_length
    .extern mrc_eh$ulength
    movl mrc_eh$ulength, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_570663:
    movl %eax, %esi
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    orl  $5, %eax
    addl $4, %esi
    addl $4, %esi
    andl $-8, %esi
    addl %esi, %ebp
    movl %eax, -12(%esp)  # stack save
# emit-tail-expr
# si=-16
# env=((f94245 . -12) (f94243 . -8) (f94233 . 4) (f94233 . 0))
# expr=((vector-ref f94233 0) f94245 0 f94243)
# emit-tail-funcall
#    si   =-16
#    env  = ((f94245 . -12) (f94243 . -8) (f94233 . 4) (f94233 . 0))
#    expr = (funcall (vector-ref f94233 0) f94245 0 f94243)
# emit-expr (vector-ref f94233 0)
# emit-expr f94233
# emit-variable-ref
# env=((f94245 . -12) (f94243 . -8) (f94233 . 4) (f94233 . 0))
# var=f94233
    movl 2(%edi), %eax  # frame load f94233
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_570664
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_570664:
    movl %eax, -16(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_570665"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_570665:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_570667
    cmp  $0,%eax
    jge _L_570666
_L_570667:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_570666:
    movl -16(%esp), %esi
    movl -1(%eax,%esi), %eax
   movl %eax,  -16(%esp)  # stash funcall-oper in next closure slot
# emit-expr f94245
# emit-variable-ref
# env=((f94245 . -12) (f94243 . -8) (f94233 . 4) (f94233 . 0))
# var=f94245
    movl -12(%esp), %eax  # stack load f94245
# end emit-variable-ref
    mov %eax, -20(%esp)    # arg f94245
# emit-expr 0
    movl $0, %eax     # immed 0
    mov %eax, -24(%esp)    # arg 0
# emit-expr f94243
# emit-variable-ref
# env=((f94245 . -12) (f94243 . -8) (f94233 . 4) (f94233 . 0))
# var=f94243
    movl -8(%esp), %eax  # stack load f94243
# end emit-variable-ref
    mov %eax, -28(%esp)    # arg f94243
    movl -16(%esp), %edi   # load new closure to %edi
# emit-shift-args:  size=4   si=-16  delta=12
    mov -16(%esp), %ebx  # shift frame cell
    mov %ebx, -4(%esp)  # down to base
# emit-shift-args:  size=3   si=-20  delta=12
    mov -20(%esp), %ebx  # shift frame cell
    mov %ebx, -8(%esp)  # down to base
# emit-shift-args:  size=2   si=-24  delta=12
    mov -24(%esp), %ebx  # shift frame cell
    mov %ebx, -12(%esp)  # down to base
# emit-shift-args:  size=1   si=-28  delta=12
    mov -28(%esp), %ebx  # shift frame cell
    mov %ebx, -16(%esp)  # down to base
# emit-shift-args:  size=0   si=-32  delta=12
    movl $12,%eax   # save arg count
    jmp *-2(%edi)  # tail-funcall
    .align 4,0x90
_L_570657:
# emit-expr (begin)
# emit-begin
#   expr=(begin)
#   env=((f94233 . 0))
     movl %eax, mrc_vector
# == explicit-begins  ==>
# (letrec ((fill-string (lambda (s k args) (if (null? args) s (begin (string-set! s k (car args)) (fill-string s (fxadd1 k) (cdr args))))))) (lambda args (let ((s (make-string (list-length args)))) (fill-string s 0 args))))
# == eliminate-let*  ==>
# (letrec ((fill-string (lambda (s k args) (if (null? args) s (begin (string-set! s k (car args)) (fill-string s (fxadd1 k) (cdr args))))))) (lambda args (let ((s (make-string (list-length args)))) (fill-string s 0 args))))
# == uniquify-variables  ==>
# (letrec ((f94246 (lambda (f94250 f94251 f94252) (if (null? f94252) f94250 (begin (string-set! f94250 f94251 (car f94252)) (f94246 f94250 (fxadd1 f94251) (cdr f94252))))))) (lambda f94256 (let ((f94258 (make-string (list-length f94256)))) (f94246 f94258 0 f94256))))
# == vectorize-letrec  ==>
# (let ((f94246 (make-vector 1))) (begin (begin (vector-set! f94246 0 (lambda (f94250 f94251 f94252) (if (null? f94252) f94250 (begin (string-set! f94250 f94251 (car f94252)) ((vector-ref f94246 0) f94250 (fxadd1 f94251) (cdr f94252))))))) (lambda f94256 (let ((f94258 (make-string (list-length f94256)))) ((vector-ref f94246 0) f94258 0 f94256)))))
# == eliminate-set!  ==>
# (let ((f94246 (make-vector 1))) (begin (begin (vector-set! f94246 0 (lambda (f94250 f94251 f94252) (let ((f94250 f94250) (f94251 f94251) (f94252 f94252)) (if (null? f94252) f94250 (begin (string-set! f94250 f94251 (car f94252)) ((vector-ref f94246 0) f94250 (fxadd1 f94251) (cdr f94252)))))))) (lambda f94256 (let () (let ((f94258 (make-string (list-length f94256)))) ((vector-ref f94246 0) f94258 0 f94256))))))
# == close-free-variables  ==>
# (let ((f94246 (make-vector 1))) (begin (begin (vector-set! f94246 0 (closure (f94250 f94251 f94252) (f94246) (let ((f94250 f94250) (f94251 f94251) (f94252 f94252)) (if (null? f94252) f94250 (begin (string-set! f94250 f94251 (car f94252)) ((vector-ref f94246 0) f94250 (fxadd1 f94251) (cdr f94252)))))))) (closure f94256 (f94246) (let () (let ((f94258 (make-string (list-length f94256)))) ((vector-ref f94246 0) f94258 0 f94256))))))
# == eliminate-quote  ==>
# (let ((f94246 (make-vector 1))) (begin (begin (vector-set! f94246 0 (closure (f94250 f94251 f94252) (f94246) (let ((f94250 f94250) (f94251 f94251) (f94252 f94252)) (if (null? f94252) f94250 (begin (string-set! f94250 f94251 (car f94252)) ((vector-ref f94246 0) f94250 (fxadd1 f94251) (cdr f94252)))))))) (closure f94256 (f94246) (let () (let ((f94258 (make-string (list-length f94256)))) ((vector-ref f94246 0) f94258 0 f94256))))))
# == eliminate-when/unless  ==>
# (let ((f94246 (make-vector 1))) (begin (begin (vector-set! f94246 0 (closure (f94250 f94251 f94252) (f94246) (let ((f94250 f94250) (f94251 f94251) (f94252 f94252)) (if (null? f94252) f94250 (begin (string-set! f94250 f94251 (car f94252)) ((vector-ref f94246 0) f94250 (fxadd1 f94251) (cdr f94252)))))))) (closure f94256 (f94246) (let () (let ((f94258 (make-string (list-length f94256)))) ((vector-ref f94246 0) f94258 0 f94256))))))
# == eliminate-cond  ==>
# (let ((f94246 (make-vector 1))) (begin (begin (vector-set! f94246 0 (closure (f94250 f94251 f94252) (f94246) (let ((f94250 f94250) (f94251 f94251) (f94252 f94252)) (if (null? f94252) f94250 (begin (string-set! f94250 f94251 (car f94252)) ((vector-ref f94246 0) f94250 (fxadd1 f94251) (cdr f94252)))))))) (closure f94256 (f94246) (let () (let ((f94258 (make-string (list-length f94256)))) ((vector-ref f94246 0) f94258 0 f94256))))))
# == external-symbols  ==>
# (let ((f94246 (make-vector 1))) (begin (begin (vector-set! f94246 0 (closure (f94250 f94251 f94252) (f94246) (let ((f94250 f94250) (f94251 f94251) (f94252 f94252)) (if (null? f94252) f94250 (begin (string-set! f94250 f94251 (car f94252)) ((vector-ref f94246 0) f94250 (fxadd1 f94251) (cdr f94252)))))))) (closure f94256 (f94246) (let () (let ((f94258 (make-string ((primitive-ref list-length) f94256)))) ((vector-ref f94246 0) f94258 0 f94256))))))
# emit-expr (let ((f94246 (make-vector 1))) (begin (begin (vector-set! f94246 0 (closure (f94250 f94251 f94252) (f94246) (let ((f94250 f94250) (f94251 f94251) (f94252 f94252)) (if (null? f94252) f94250 (begin (string-set! f94250 f94251 (car f94252)) ((vector-ref f94246 0) f94250 (fxadd1 f94251) (cdr f94252)))))))) (closure f94256 (f94246) (let () (let ((f94258 (make-string ((primitive-ref list-length) f94256)))) ((vector-ref f94246 0) f94258 0 f94256))))))
# emit-let
#  si   = 0
#  env  = ()
#  bindings = ((f94246 (make-vector 1)))
#  body = (begin (begin (vector-set! f94246 0 (closure (f94250 f94251 f94252) (f94246) (let ((f94250 f94250) (f94251 f94251) (f94252 f94252)) (if (null? f94252) f94250 (begin (string-set! f94250 f94251 (car f94252)) ((vector-ref f94246 0) f94250 (fxadd1 f94251) (cdr f94252)))))))) (closure f94256 (f94246) (let () (let ((f94258 (make-string ((primitive-ref list-length) f94256)))) ((vector-ref f94246 0) f94258 0 f94256)))))
# emit-expr (make-vector 1)
# make-vector 1
# emit-expr 1
    movl $4, %eax     # immed 1
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_570668"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_570668:
# check the argument is a fixnum >= 0
    cmp $0,%eax
    jge _L_570669
# invoke error handler eh_length
    .extern mrc_eh$ulength
    movl mrc_eh$ulength, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_570669:
    movl %eax, %esi
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    orl  $5, %eax
    addl $4, %esi
    addl $4, %esi
    andl $-8, %esi
    addl %esi, %ebp
    movl %eax, 0(%esp)  # stack save
# emit-expr (begin (begin (vector-set! f94246 0 (closure (f94250 f94251 f94252) (f94246) (let ((f94250 f94250) (f94251 f94251) (f94252 f94252)) (if (null? f94252) f94250 (begin (string-set! f94250 f94251 (car f94252)) ((vector-ref f94246 0) f94250 (fxadd1 f94251) (cdr f94252)))))))) (closure f94256 (f94246) (let () (let ((f94258 (make-string ((primitive-ref list-length) f94256)))) ((vector-ref f94246 0) f94258 0 f94256)))))
# emit-begin
#   expr=(begin (begin (vector-set! f94246 0 (closure (f94250 f94251 f94252) (f94246) (let ((f94250 f94250) (f94251 f94251) (f94252 f94252)) (if (null? f94252) f94250 (begin (string-set! f94250 f94251 (car f94252)) ((vector-ref f94246 0) f94250 (fxadd1 f94251) (cdr f94252)))))))) (closure f94256 (f94246) (let () (let ((f94258 (make-string ((primitive-ref list-length) f94256)))) ((vector-ref f94246 0) f94258 0 f94256)))))
#   env=((f94246 . 0))
# emit-expr (begin (vector-set! f94246 0 (closure (f94250 f94251 f94252) (f94246) (let ((f94250 f94250) (f94251 f94251) (f94252 f94252)) (if (null? f94252) f94250 (begin (string-set! f94250 f94251 (car f94252)) ((vector-ref f94246 0) f94250 (fxadd1 f94251) (cdr f94252))))))))
# emit-begin
#   expr=(begin (vector-set! f94246 0 (closure (f94250 f94251 f94252) (f94246) (let ((f94250 f94250) (f94251 f94251) (f94252 f94252)) (if (null? f94252) f94250 (begin (string-set! f94250 f94251 (car f94252)) ((vector-ref f94246 0) f94250 (fxadd1 f94251) (cdr f94252))))))))
#   env=((f94246 . 0))
# emit-expr (vector-set! f94246 0 (closure (f94250 f94251 f94252) (f94246) (let ((f94250 f94250) (f94251 f94251) (f94252 f94252)) (if (null? f94252) f94250 (begin (string-set! f94250 f94251 (car f94252)) ((vector-ref f94246 0) f94250 (fxadd1 f94251) (cdr f94252)))))))
# emit-expr f94246
# emit-variable-ref
# env=((f94246 . 0))
# var=f94246
    movl 0(%esp), %eax  # stack load f94246
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_570670
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_570670:
    movl %eax, -4(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_570671"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_570671:
# check bounds on vector index
    movl -4(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_570673
    cmp  $0,%eax
    jge _L_570672
_L_570673:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_570672:
    movl %eax, -8(%esp)
# emit-expr (closure (f94250 f94251 f94252) (f94246) (let ((f94250 f94250) (f94251 f94251) (f94252 f94252)) (if (null? f94252) f94250 (begin (string-set! f94250 f94251 (car f94252)) ((vector-ref f94246 0) f94250 (fxadd1 f94251) (cdr f94252))))))
# emit-closure
# si = -12
# env = ((f94246 . 0))
# expr = (closure (f94250 f94251 f94252) (f94246) (let ((f94250 f94250) (f94251 f94251) (f94252 f94252)) (if (null? f94252) f94250 (begin (string-set! f94250 f94251 (car f94252)) ((vector-ref f94246 0) f94250 (fxadd1 f94251) (cdr f94252))))))
    movl $_L_570674, 0(%ebp)  # closure label
# emit-variable-ref
# env=((f94246 . 0))
# var=f94246
    movl 0(%esp), %eax  # stack load f94246
# end emit-variable-ref
   movl  %eax, 4(%ebp)  # f94246
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $8, %ebp     # bump ebp
    jmp _L_570675            # jump around closure body
_L_570674:
# check argument count
    cmp $12,%eax
    je _L_570676
# invoke error handler eh_argcount
    .extern mrc_eh$uargcount
    movl mrc_eh$uargcount, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_570676:
# emit-tail-expr
# si=-20
# env=((f94252 . -16) (f94251 . -12) (f94250 . -8) (f94246 . 4) (f94246 . 0))
# expr=(let ((f94250 f94250) (f94251 f94251) (f94252 f94252)) (if (null? f94252) f94250 (begin (string-set! f94250 f94251 (car f94252)) ((vector-ref f94246 0) f94250 (fxadd1 f94251) (cdr f94252)))))
# emit-tail-let
#  si   = -20
#  env  = ((f94252 . -16) (f94251 . -12) (f94250 . -8) (f94246 . 4) (f94246 . 0))
#  bindings = ((f94250 f94250) (f94251 f94251) (f94252 f94252))
#  body = (if (null? f94252) f94250 (begin (string-set! f94250 f94251 (car f94252)) ((vector-ref f94246 0) f94250 (fxadd1 f94251) (cdr f94252))))
# emit-expr f94250
# emit-variable-ref
# env=((f94252 . -16) (f94251 . -12) (f94250 . -8) (f94246 . 4) (f94246 . 0))
# var=f94250
    movl -8(%esp), %eax  # stack load f94250
# end emit-variable-ref
    movl %eax, -20(%esp)  # stack save
# emit-expr f94251
# emit-variable-ref
# env=((f94252 . -16) (f94251 . -12) (f94250 . -8) (f94246 . 4) (f94246 . 0))
# var=f94251
    movl -12(%esp), %eax  # stack load f94251
# end emit-variable-ref
    movl %eax, -24(%esp)  # stack save
# emit-expr f94252
# emit-variable-ref
# env=((f94252 . -16) (f94251 . -12) (f94250 . -8) (f94246 . 4) (f94246 . 0))
# var=f94252
    movl -16(%esp), %eax  # stack load f94252
# end emit-variable-ref
    movl %eax, -28(%esp)  # stack save
# emit-tail-expr
# si=-32
# env=((f94252 . -28) (f94251 . -24) (f94250 . -20) (f94252 . -16) (f94251 . -12) (f94250 . -8) (f94246 . 4) (f94246 . 0))
# expr=(if (null? f94252) f94250 (begin (string-set! f94250 f94251 (car f94252)) ((vector-ref f94246 0) f94250 (fxadd1 f94251) (cdr f94252))))
# emit-expr (null? f94252)
# emit-expr f94252
# emit-variable-ref
# env=((f94252 . -28) (f94251 . -24) (f94250 . -20) (f94252 . -16) (f94251 . -12) (f94250 . -8) (f94246 . 4) (f94246 . 0))
# var=f94252
    movl -28(%esp), %eax  # stack load f94252
# end emit-variable-ref
    cmp $63, %eax
    mov $0, %eax
    sete %al
    movzbl %al, %eax
    sal $6, %al
    or $47, %al
    cmp $47, %al
    je _L_570677
# emit-tail-expr
# si=-32
# env=((f94252 . -28) (f94251 . -24) (f94250 . -20) (f94252 . -16) (f94251 . -12) (f94250 . -8) (f94246 . 4) (f94246 . 0))
# expr=f94250
# emit-tail-variable-ref
# emit-variable-ref
# env=((f94252 . -28) (f94251 . -24) (f94250 . -20) (f94252 . -16) (f94251 . -12) (f94250 . -8) (f94246 . 4) (f94246 . 0))
# var=f94250
    movl -20(%esp), %eax  # stack load f94250
# end emit-variable-ref
    ret
# end emit-tail-variable ref
    jmp _L_570678
_L_570677:
# emit-tail-expr
# si=-32
# env=((f94252 . -28) (f94251 . -24) (f94250 . -20) (f94252 . -16) (f94251 . -12) (f94250 . -8) (f94246 . 4) (f94246 . 0))
# expr=(begin (string-set! f94250 f94251 (car f94252)) ((vector-ref f94246 0) f94250 (fxadd1 f94251) (cdr f94252)))
# tail-begin (begin (string-set! f94250 f94251 (car f94252)) ((vector-ref f94246 0) f94250 (fxadd1 f94251) (cdr f94252)))
#   env=((f94252 . -28) (f94251 . -24) (f94250 . -20) (f94252 . -16) (f94251 . -12) (f94250 . -8) (f94246 . 4) (f94246 . 0))
# emit-expr (string-set! f94250 f94251 (car f94252))
# emit-expr f94250
# emit-variable-ref
# env=((f94252 . -28) (f94251 . -24) (f94250 . -20) (f94252 . -16) (f94251 . -12) (f94250 . -8) (f94246 . 4) (f94246 . 0))
# var=f94250
    movl -20(%esp), %eax  # stack load f94250
# end emit-variable-ref
# check the argument is a string
    movl %eax,%ebx
    and $7, %bl
    cmp $6, %bl
    je _L_570679
# invoke error handler eh_string
    .extern mrc_eh$ustring
    movl mrc_eh$ustring, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $168,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_570679:
    movl %eax, -32(%esp)
# emit-expr f94251
# emit-variable-ref
# env=((f94252 . -28) (f94251 . -24) (f94250 . -20) (f94252 . -16) (f94251 . -12) (f94250 . -8) (f94246 . 4) (f94246 . 0))
# var=f94251
    movl -24(%esp), %eax  # stack load f94251
# end emit-variable-ref
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_570680"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $168,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_570680:
# check bounds on string index
    movl -32(%esp), %ebx
    cmp  %eax,-6(%ebx) 
    jle _L_570682
    cmp  $0,%eax
    jge _L_570681
_L_570682:
# invoke error handler eh_string_index
    .extern mrc_eh$ustring$uindex
    movl mrc_eh$ustring$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $168,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_570681:
    movl %eax, -36(%esp)
# emit-expr (car f94252)
# emit-expr f94252
# emit-variable-ref
# env=((f94252 . -28) (f94251 . -24) (f94250 . -20) (f94252 . -16) (f94251 . -12) (f94250 . -8) (f94246 . 4) (f94246 . 0))
# var=f94252
    movl -28(%esp), %eax  # stack load f94252
# end emit-variable-ref
# check the argument is a pair
    movl %eax,%ebx
    and $7, %bl
    cmp $1, %bl
    je _L_570683
# invoke error handler eh_pair
    .extern mrc_eh$upair
    movl mrc_eh$upair, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $116,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_570683:
    movl -1(%eax), %eax
# check the argument is a char
    movl %eax,%ebx
    and $255, %bl
    cmp $15, %bl
    je "_L_570684"
# invoke error handler eh_character
    .extern mrc_eh$ucharacter
    movl mrc_eh$ucharacter, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $168,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_570684:
    movl -32(%esp), %ebx
    movl -36(%esp), %esi
    sar $2, %esi
    movb  %ah, -2(%ebx,%esi)
# emit-tail-expr
# si=-32
# env=((f94252 . -28) (f94251 . -24) (f94250 . -20) (f94252 . -16) (f94251 . -12) (f94250 . -8) (f94246 . 4) (f94246 . 0))
# expr=(begin ((vector-ref f94246 0) f94250 (fxadd1 f94251) (cdr f94252)))
# tail-begin (begin ((vector-ref f94246 0) f94250 (fxadd1 f94251) (cdr f94252)))
#   env=((f94252 . -28) (f94251 . -24) (f94250 . -20) (f94252 . -16) (f94251 . -12) (f94250 . -8) (f94246 . 4) (f94246 . 0))
# emit-tail-expr
# si=-32
# env=((f94252 . -28) (f94251 . -24) (f94250 . -20) (f94252 . -16) (f94251 . -12) (f94250 . -8) (f94246 . 4) (f94246 . 0))
# expr=((vector-ref f94246 0) f94250 (fxadd1 f94251) (cdr f94252))
# emit-tail-funcall
#    si   =-32
#    env  = ((f94252 . -28) (f94251 . -24) (f94250 . -20) (f94252 . -16) (f94251 . -12) (f94250 . -8) (f94246 . 4) (f94246 . 0))
#    expr = (funcall (vector-ref f94246 0) f94250 (fxadd1 f94251) (cdr f94252))
# emit-expr (vector-ref f94246 0)
# emit-expr f94246
# emit-variable-ref
# env=((f94252 . -28) (f94251 . -24) (f94250 . -20) (f94252 . -16) (f94251 . -12) (f94250 . -8) (f94246 . 4) (f94246 . 0))
# var=f94246
    movl 2(%edi), %eax  # frame load f94246
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_570685
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_570685:
    movl %eax, -32(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_570686"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_570686:
# check bounds on vector index
    movl -32(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_570688
    cmp  $0,%eax
    jge _L_570687
_L_570688:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_570687:
    movl -32(%esp), %esi
    movl -1(%eax,%esi), %eax
   movl %eax,  -32(%esp)  # stash funcall-oper in next closure slot
# emit-expr f94250
# emit-variable-ref
# env=((f94252 . -28) (f94251 . -24) (f94250 . -20) (f94252 . -16) (f94251 . -12) (f94250 . -8) (f94246 . 4) (f94246 . 0))
# var=f94250
    movl -20(%esp), %eax  # stack load f94250
# end emit-variable-ref
    mov %eax, -36(%esp)    # arg f94250
# emit-expr (fxadd1 f94251)
# emit-expr f94251
# emit-variable-ref
# env=((f94252 . -28) (f94251 . -24) (f94250 . -20) (f94252 . -16) (f94251 . -12) (f94250 . -8) (f94246 . 4) (f94246 . 0))
# var=f94251
    movl -24(%esp), %eax  # stack load f94251
# end emit-variable-ref
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_570689"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $56,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_570689:
     addl $4, %eax
    mov %eax, -40(%esp)    # arg (fxadd1 f94251)
# emit-expr (cdr f94252)
# emit-expr f94252
# emit-variable-ref
# env=((f94252 . -28) (f94251 . -24) (f94250 . -20) (f94252 . -16) (f94251 . -12) (f94250 . -8) (f94246 . 4) (f94246 . 0))
# var=f94252
    movl -28(%esp), %eax  # stack load f94252
# end emit-variable-ref
# check the argument is a pair
    movl %eax,%ebx
    and $7, %bl
    cmp $1, %bl
    je _L_570690
# invoke error handler eh_pair
    .extern mrc_eh$upair
    movl mrc_eh$upair, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $120,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_570690:
    movl 3(%eax), %eax
    mov %eax, -44(%esp)    # arg (cdr f94252)
    movl -32(%esp), %edi   # load new closure to %edi
# emit-shift-args:  size=4   si=-32  delta=28
    mov -32(%esp), %ebx  # shift frame cell
    mov %ebx, -4(%esp)  # down to base
# emit-shift-args:  size=3   si=-36  delta=28
    mov -36(%esp), %ebx  # shift frame cell
    mov %ebx, -8(%esp)  # down to base
# emit-shift-args:  size=2   si=-40  delta=28
    mov -40(%esp), %ebx  # shift frame cell
    mov %ebx, -12(%esp)  # down to base
# emit-shift-args:  size=1   si=-44  delta=28
    mov -44(%esp), %ebx  # shift frame cell
    mov %ebx, -16(%esp)  # down to base
# emit-shift-args:  size=0   si=-48  delta=28
    movl $12,%eax   # save arg count
    jmp *-2(%edi)  # tail-funcall
     ret   # return thru stack
_L_570678:
    .align 4,0x90
_L_570675:
    movl -4(%esp), %ebx
    movl -8(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin)
# emit-begin
#   expr=(begin)
#   env=((f94246 . 0))
# emit-expr (begin (closure f94256 (f94246) (let () (let ((f94258 (make-string ((primitive-ref list-length) f94256)))) ((vector-ref f94246 0) f94258 0 f94256)))))
# emit-begin
#   expr=(begin (closure f94256 (f94246) (let () (let ((f94258 (make-string ((primitive-ref list-length) f94256)))) ((vector-ref f94246 0) f94258 0 f94256)))))
#   env=((f94246 . 0))
# emit-expr (closure f94256 (f94246) (let () (let ((f94258 (make-string ((primitive-ref list-length) f94256)))) ((vector-ref f94246 0) f94258 0 f94256))))
# emit-closure
# si = -4
# env = ((f94246 . 0))
# expr = (closure f94256 (f94246) (let () (let ((f94258 (make-string ((primitive-ref list-length) f94256)))) ((vector-ref f94246 0) f94258 0 f94256))))
    movl $_L_570691, 0(%ebp)  # closure label
# emit-variable-ref
# env=((f94246 . 0))
# var=f94246
    movl 0(%esp), %eax  # stack load f94246
# end emit-variable-ref
   movl  %eax, 4(%ebp)  # f94246
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $8, %ebp     # bump ebp
    jmp _L_570692            # jump around closure body
_L_570691:
# check argument count
    cmp $0,%eax
    jge _L_570693
# invoke error handler eh_argcount_min
    .extern mrc_eh$uargcount$umin
    movl mrc_eh$uargcount$umin, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_570693:
# emit-build-varargs-list
    movl $63, %esi       # args <- () 
    lea -4(%esp),%edi    # edi <- esp-4
    subl %eax, %edi      # edi <- esp-4-eax    addr of arg[K+N] on stack
_L_570695:
    lea -4(%esp),%ebx    # addr of arg[K] on stack
    cmp %edi, %ebx       # while edi <> esp+(si+4)
    je _L_570694
    movl (%edi),%ebx     # arg i -> car
    movl %ebx, 0(%ebp)
    movl %esi, 4(%ebp)  # esi -> cdr
    movl %ebp, %esi
    addl $1, %esi       # tag as pair
    addl $8,%ebp         # bump heap ptr
    addl $4,%edi         # move to next previous arg from the end
    jmp _L_570695
_L_570694:
    movl %esi, -8(%esp)  # set args
# emit-tail-expr
# si=-12
# env=((f94256 . -8) (f94246 . 4) (f94246 . 0))
# expr=(let () (let ((f94258 (make-string ((primitive-ref list-length) f94256)))) ((vector-ref f94246 0) f94258 0 f94256)))
# emit-tail-let
#  si   = -12
#  env  = ((f94256 . -8) (f94246 . 4) (f94246 . 0))
#  bindings = ()
#  body = (let ((f94258 (make-string ((primitive-ref list-length) f94256)))) ((vector-ref f94246 0) f94258 0 f94256))
# emit-tail-expr
# si=-12
# env=((f94256 . -8) (f94246 . 4) (f94246 . 0))
# expr=(let ((f94258 (make-string ((primitive-ref list-length) f94256)))) ((vector-ref f94246 0) f94258 0 f94256))
# emit-tail-let
#  si   = -12
#  env  = ((f94256 . -8) (f94246 . 4) (f94246 . 0))
#  bindings = ((f94258 (make-string ((primitive-ref list-length) f94256))))
#  body = ((vector-ref f94246 0) f94258 0 f94256)
# emit-expr (make-string ((primitive-ref list-length) f94256))
# make-string len=((primitive-ref list-length) f94256)
# emit-expr ((primitive-ref list-length) f94256)
# funcall
#    si   =-12
#    env  = ((f94256 . -8) (f94246 . 4) (f94246 . 0))
#    expr = (funcall (primitive-ref list-length) f94256)
# emit-expr (primitive-ref list-length)
    .extern mrc_list$mlength
    movl mrc_list$mlength,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_570696"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_570696":
   movl %eax,  -20(%esp)  # stash funcall-oper in closure slot
# emit-expr f94256
# emit-variable-ref
# env=((f94256 . -8) (f94246 . 4) (f94246 . 0))
# var=f94256
    movl -8(%esp), %eax  # stack load f94256
# end emit-variable-ref
    mov %eax, -24(%esp)  # arg f94256
    movl -20(%esp), %edi   # load new closure to %edi
    add $-12, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $12, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_570697"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $152,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_570697:
# check the argument is a fixnum >= 0
    cmp $0,%eax
    jge _L_570698
# invoke error handler eh_length
    .extern mrc_eh$ulength
    movl mrc_eh$ulength, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $152,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_570698:
    movl %eax, %esi
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    orl $6, %eax
    sar $2, %esi
    add $4, %esi
    add $7, %esi
    andl $-8, %esi
    add  %esi, %ebp
# make-string end
    movl %eax, -12(%esp)  # stack save
# emit-tail-expr
# si=-16
# env=((f94258 . -12) (f94256 . -8) (f94246 . 4) (f94246 . 0))
# expr=((vector-ref f94246 0) f94258 0 f94256)
# emit-tail-funcall
#    si   =-16
#    env  = ((f94258 . -12) (f94256 . -8) (f94246 . 4) (f94246 . 0))
#    expr = (funcall (vector-ref f94246 0) f94258 0 f94256)
# emit-expr (vector-ref f94246 0)
# emit-expr f94246
# emit-variable-ref
# env=((f94258 . -12) (f94256 . -8) (f94246 . 4) (f94246 . 0))
# var=f94246
    movl 2(%edi), %eax  # frame load f94246
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_570699
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_570699:
    movl %eax, -16(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_570700"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_570700:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_570702
    cmp  $0,%eax
    jge _L_570701
_L_570702:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_570701:
    movl -16(%esp), %esi
    movl -1(%eax,%esi), %eax
   movl %eax,  -16(%esp)  # stash funcall-oper in next closure slot
# emit-expr f94258
# emit-variable-ref
# env=((f94258 . -12) (f94256 . -8) (f94246 . 4) (f94246 . 0))
# var=f94258
    movl -12(%esp), %eax  # stack load f94258
# end emit-variable-ref
    mov %eax, -20(%esp)    # arg f94258
# emit-expr 0
    movl $0, %eax     # immed 0
    mov %eax, -24(%esp)    # arg 0
# emit-expr f94256
# emit-variable-ref
# env=((f94258 . -12) (f94256 . -8) (f94246 . 4) (f94246 . 0))
# var=f94256
    movl -8(%esp), %eax  # stack load f94256
# end emit-variable-ref
    mov %eax, -28(%esp)    # arg f94256
    movl -16(%esp), %edi   # load new closure to %edi
# emit-shift-args:  size=4   si=-16  delta=12
    mov -16(%esp), %ebx  # shift frame cell
    mov %ebx, -4(%esp)  # down to base
# emit-shift-args:  size=3   si=-20  delta=12
    mov -20(%esp), %ebx  # shift frame cell
    mov %ebx, -8(%esp)  # down to base
# emit-shift-args:  size=2   si=-24  delta=12
    mov -24(%esp), %ebx  # shift frame cell
    mov %ebx, -12(%esp)  # down to base
# emit-shift-args:  size=1   si=-28  delta=12
    mov -28(%esp), %ebx  # shift frame cell
    mov %ebx, -16(%esp)  # down to base
# emit-shift-args:  size=0   si=-32  delta=12
    movl $12,%eax   # save arg count
    jmp *-2(%edi)  # tail-funcall
    .align 4,0x90
_L_570692:
# emit-expr (begin)
# emit-begin
#   expr=(begin)
#   env=((f94246 . 0))
     movl %eax, mrc_string
# == explicit-begins  ==>
# (letrec ((f (lambda (s i) (if (fx= i (string-length s)) (quote ()) (cons (string-ref s i) (f s (fxadd1 i))))))) (lambda (s) (f s 0)))
# == eliminate-let*  ==>
# (letrec ((f (lambda (s i) (if (fx= i (string-length s)) (quote ()) (cons (string-ref s i) (f s (fxadd1 i))))))) (lambda (s) (f s 0)))
# == uniquify-variables  ==>
# (letrec ((f94259 (lambda (f94262 f94263) (if (fx= f94263 (string-length f94262)) (quote ()) (cons (string-ref f94262 f94263) (f94259 f94262 (fxadd1 f94263))))))) (lambda (f94265) (f94259 f94265 0)))
# == vectorize-letrec  ==>
# (let ((f94259 (make-vector 1))) (begin (begin (vector-set! f94259 0 (lambda (f94262 f94263) (if (fx= f94263 (string-length f94262)) (quote ()) (cons (string-ref f94262 f94263) ((vector-ref f94259 0) f94262 (fxadd1 f94263))))))) (lambda (f94265) ((vector-ref f94259 0) f94265 0))))
# == eliminate-set!  ==>
# (let ((f94259 (make-vector 1))) (begin (begin (vector-set! f94259 0 (lambda (f94262 f94263) (let ((f94262 f94262) (f94263 f94263)) (if (fx= f94263 (string-length f94262)) (quote ()) (cons (string-ref f94262 f94263) ((vector-ref f94259 0) f94262 (fxadd1 f94263)))))))) (lambda (f94265) (let ((f94265 f94265)) ((vector-ref f94259 0) f94265 0)))))
# == close-free-variables  ==>
# (let ((f94259 (make-vector 1))) (begin (begin (vector-set! f94259 0 (closure (f94262 f94263) (f94259) (let ((f94262 f94262) (f94263 f94263)) (if (fx= f94263 (string-length f94262)) (quote ()) (cons (string-ref f94262 f94263) ((vector-ref f94259 0) f94262 (fxadd1 f94263)))))))) (closure (f94265) (f94259) (let ((f94265 f94265)) ((vector-ref f94259 0) f94265 0)))))
# == eliminate-quote  ==>
# (let ((f94259 (make-vector 1))) (begin (begin (vector-set! f94259 0 (closure (f94262 f94263) (f94259) (let ((f94262 f94262) (f94263 f94263)) (if (fx= f94263 (string-length f94262)) () (cons (string-ref f94262 f94263) ((vector-ref f94259 0) f94262 (fxadd1 f94263)))))))) (closure (f94265) (f94259) (let ((f94265 f94265)) ((vector-ref f94259 0) f94265 0)))))
# == eliminate-when/unless  ==>
# (let ((f94259 (make-vector 1))) (begin (begin (vector-set! f94259 0 (closure (f94262 f94263) (f94259) (let ((f94262 f94262) (f94263 f94263)) (if (fx= f94263 (string-length f94262)) () (cons (string-ref f94262 f94263) ((vector-ref f94259 0) f94262 (fxadd1 f94263)))))))) (closure (f94265) (f94259) (let ((f94265 f94265)) ((vector-ref f94259 0) f94265 0)))))
# == eliminate-cond  ==>
# (let ((f94259 (make-vector 1))) (begin (begin (vector-set! f94259 0 (closure (f94262 f94263) (f94259) (let ((f94262 f94262) (f94263 f94263)) (if (fx= f94263 (string-length f94262)) () (cons (string-ref f94262 f94263) ((vector-ref f94259 0) f94262 (fxadd1 f94263)))))))) (closure (f94265) (f94259) (let ((f94265 f94265)) ((vector-ref f94259 0) f94265 0)))))
# == external-symbols  ==>
# (let ((f94259 (make-vector 1))) (begin (begin (vector-set! f94259 0 (closure (f94262 f94263) (f94259) (let ((f94262 f94262) (f94263 f94263)) (if (fx= f94263 (string-length f94262)) () (cons (string-ref f94262 f94263) ((vector-ref f94259 0) f94262 (fxadd1 f94263)))))))) (closure (f94265) (f94259) (let ((f94265 f94265)) ((vector-ref f94259 0) f94265 0)))))
# emit-expr (let ((f94259 (make-vector 1))) (begin (begin (vector-set! f94259 0 (closure (f94262 f94263) (f94259) (let ((f94262 f94262) (f94263 f94263)) (if (fx= f94263 (string-length f94262)) () (cons (string-ref f94262 f94263) ((vector-ref f94259 0) f94262 (fxadd1 f94263)))))))) (closure (f94265) (f94259) (let ((f94265 f94265)) ((vector-ref f94259 0) f94265 0)))))
# emit-let
#  si   = 0
#  env  = ()
#  bindings = ((f94259 (make-vector 1)))
#  body = (begin (begin (vector-set! f94259 0 (closure (f94262 f94263) (f94259) (let ((f94262 f94262) (f94263 f94263)) (if (fx= f94263 (string-length f94262)) () (cons (string-ref f94262 f94263) ((vector-ref f94259 0) f94262 (fxadd1 f94263)))))))) (closure (f94265) (f94259) (let ((f94265 f94265)) ((vector-ref f94259 0) f94265 0))))
# emit-expr (make-vector 1)
# make-vector 1
# emit-expr 1
    movl $4, %eax     # immed 1
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_570703"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_570703:
# check the argument is a fixnum >= 0
    cmp $0,%eax
    jge _L_570704
# invoke error handler eh_length
    .extern mrc_eh$ulength
    movl mrc_eh$ulength, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_570704:
    movl %eax, %esi
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    orl  $5, %eax
    addl $4, %esi
    addl $4, %esi
    andl $-8, %esi
    addl %esi, %ebp
    movl %eax, 0(%esp)  # stack save
# emit-expr (begin (begin (vector-set! f94259 0 (closure (f94262 f94263) (f94259) (let ((f94262 f94262) (f94263 f94263)) (if (fx= f94263 (string-length f94262)) () (cons (string-ref f94262 f94263) ((vector-ref f94259 0) f94262 (fxadd1 f94263)))))))) (closure (f94265) (f94259) (let ((f94265 f94265)) ((vector-ref f94259 0) f94265 0))))
# emit-begin
#   expr=(begin (begin (vector-set! f94259 0 (closure (f94262 f94263) (f94259) (let ((f94262 f94262) (f94263 f94263)) (if (fx= f94263 (string-length f94262)) () (cons (string-ref f94262 f94263) ((vector-ref f94259 0) f94262 (fxadd1 f94263)))))))) (closure (f94265) (f94259) (let ((f94265 f94265)) ((vector-ref f94259 0) f94265 0))))
#   env=((f94259 . 0))
# emit-expr (begin (vector-set! f94259 0 (closure (f94262 f94263) (f94259) (let ((f94262 f94262) (f94263 f94263)) (if (fx= f94263 (string-length f94262)) () (cons (string-ref f94262 f94263) ((vector-ref f94259 0) f94262 (fxadd1 f94263))))))))
# emit-begin
#   expr=(begin (vector-set! f94259 0 (closure (f94262 f94263) (f94259) (let ((f94262 f94262) (f94263 f94263)) (if (fx= f94263 (string-length f94262)) () (cons (string-ref f94262 f94263) ((vector-ref f94259 0) f94262 (fxadd1 f94263))))))))
#   env=((f94259 . 0))
# emit-expr (vector-set! f94259 0 (closure (f94262 f94263) (f94259) (let ((f94262 f94262) (f94263 f94263)) (if (fx= f94263 (string-length f94262)) () (cons (string-ref f94262 f94263) ((vector-ref f94259 0) f94262 (fxadd1 f94263)))))))
# emit-expr f94259
# emit-variable-ref
# env=((f94259 . 0))
# var=f94259
    movl 0(%esp), %eax  # stack load f94259
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_570705
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_570705:
    movl %eax, -4(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_570706"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_570706:
# check bounds on vector index
    movl -4(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_570708
    cmp  $0,%eax
    jge _L_570707
_L_570708:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_570707:
    movl %eax, -8(%esp)
# emit-expr (closure (f94262 f94263) (f94259) (let ((f94262 f94262) (f94263 f94263)) (if (fx= f94263 (string-length f94262)) () (cons (string-ref f94262 f94263) ((vector-ref f94259 0) f94262 (fxadd1 f94263))))))
# emit-closure
# si = -12
# env = ((f94259 . 0))
# expr = (closure (f94262 f94263) (f94259) (let ((f94262 f94262) (f94263 f94263)) (if (fx= f94263 (string-length f94262)) () (cons (string-ref f94262 f94263) ((vector-ref f94259 0) f94262 (fxadd1 f94263))))))
    movl $_L_570709, 0(%ebp)  # closure label
# emit-variable-ref
# env=((f94259 . 0))
# var=f94259
    movl 0(%esp), %eax  # stack load f94259
# end emit-variable-ref
   movl  %eax, 4(%ebp)  # f94259
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $8, %ebp     # bump ebp
    jmp _L_570710            # jump around closure body
_L_570709:
# check argument count
    cmp $8,%eax
    je _L_570711
# invoke error handler eh_argcount
    .extern mrc_eh$uargcount
    movl mrc_eh$uargcount, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_570711:
# emit-tail-expr
# si=-16
# env=((f94263 . -12) (f94262 . -8) (f94259 . 4) (f94259 . 0))
# expr=(let ((f94262 f94262) (f94263 f94263)) (if (fx= f94263 (string-length f94262)) () (cons (string-ref f94262 f94263) ((vector-ref f94259 0) f94262 (fxadd1 f94263)))))
# emit-tail-let
#  si   = -16
#  env  = ((f94263 . -12) (f94262 . -8) (f94259 . 4) (f94259 . 0))
#  bindings = ((f94262 f94262) (f94263 f94263))
#  body = (if (fx= f94263 (string-length f94262)) () (cons (string-ref f94262 f94263) ((vector-ref f94259 0) f94262 (fxadd1 f94263))))
# emit-expr f94262
# emit-variable-ref
# env=((f94263 . -12) (f94262 . -8) (f94259 . 4) (f94259 . 0))
# var=f94262
    movl -8(%esp), %eax  # stack load f94262
# end emit-variable-ref
    movl %eax, -16(%esp)  # stack save
# emit-expr f94263
# emit-variable-ref
# env=((f94263 . -12) (f94262 . -8) (f94259 . 4) (f94259 . 0))
# var=f94263
    movl -12(%esp), %eax  # stack load f94263
# end emit-variable-ref
    movl %eax, -20(%esp)  # stack save
# emit-tail-expr
# si=-24
# env=((f94263 . -20) (f94262 . -16) (f94263 . -12) (f94262 . -8) (f94259 . 4) (f94259 . 0))
# expr=(if (fx= f94263 (string-length f94262)) () (cons (string-ref f94262 f94263) ((vector-ref f94259 0) f94262 (fxadd1 f94263))))
# emit-expr (fx= f94263 (string-length f94262))
# emit-expr (string-length f94262)
# emit-expr f94262
# emit-variable-ref
# env=((f94263 . -20) (f94262 . -16) (f94263 . -12) (f94262 . -8) (f94259 . 4) (f94259 . 0))
# var=f94262
    movl -16(%esp), %eax  # stack load f94262
# end emit-variable-ref
# check the argument is a string
    movl %eax,%ebx
    and $7, %bl
    cmp $6, %bl
    je _L_570714
# invoke error handler eh_string
    .extern mrc_eh$ustring
    movl mrc_eh$ustring, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $160,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_570714:
    movl -6(%eax), %eax
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_570715"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $68,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_570715:
    movl %eax, -24(%esp)
# emit-expr f94263
# emit-variable-ref
# env=((f94263 . -20) (f94262 . -16) (f94263 . -12) (f94262 . -8) (f94259 . 4) (f94259 . 0))
# var=f94263
    movl -20(%esp), %eax  # stack load f94263
# end emit-variable-ref
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_570716"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $68,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_570716:
    cmp -24(%esp), %eax
    sete %al
    movzbl %al, %eax
    sal $6, %al
    or $47, %al
    cmp $47, %al
    je _L_570712
# emit-tail-expr
# si=-24
# env=((f94263 . -20) (f94262 . -16) (f94263 . -12) (f94262 . -8) (f94259 . 4) (f94259 . 0))
# expr=()
    movl $63, %eax     # immed ()
    ret                  # immediate tail return
    jmp _L_570713
_L_570712:
# emit-tail-expr
# si=-24
# env=((f94263 . -20) (f94262 . -16) (f94263 . -12) (f94262 . -8) (f94259 . 4) (f94259 . 0))
# expr=(cons (string-ref f94262 f94263) ((vector-ref f94259 0) f94262 (fxadd1 f94263)))
# tail primcall
# cons arg1=(string-ref f94262 f94263) arg2=((vector-ref f94259 0) f94262 (fxadd1 f94263))
# emit-expr (string-ref f94262 f94263)
# emit-expr f94262
# emit-variable-ref
# env=((f94263 . -20) (f94262 . -16) (f94263 . -12) (f94262 . -8) (f94259 . 4) (f94259 . 0))
# var=f94262
    movl -16(%esp), %eax  # stack load f94262
# end emit-variable-ref
# check the argument is a string
    movl %eax,%ebx
    and $7, %bl
    cmp $6, %bl
    je _L_570717
# invoke error handler eh_string
    .extern mrc_eh$ustring
    movl mrc_eh$ustring, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $164,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_570717:
    movl %eax, -24(%esp)
# emit-expr f94263
# emit-variable-ref
# env=((f94263 . -20) (f94262 . -16) (f94263 . -12) (f94262 . -8) (f94259 . 4) (f94259 . 0))
# var=f94263
    movl -20(%esp), %eax  # stack load f94263
# end emit-variable-ref
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_570718"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $164,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_570718:
# check bounds on string index
    movl -24(%esp), %ebx
    cmp  %eax,-6(%ebx) 
    jle _L_570720
    cmp  $0,%eax
    jge _L_570719
_L_570720:
# invoke error handler eh_string_index
    .extern mrc_eh$ustring$uindex
    movl mrc_eh$ustring$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $164,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_570719:
    sar $2, %eax
    movl -24(%esp), %esi
    movl -2(%eax,%esi), %eax
    sal $8, %eax
    or  $15, %eax
    movl %eax, -24(%esp)
# emit-expr ((vector-ref f94259 0) f94262 (fxadd1 f94263))
# funcall
#    si   =-28
#    env  = ((f94263 . -20) (f94262 . -16) (f94263 . -12) (f94262 . -8) (f94259 . 4) (f94259 . 0))
#    expr = (funcall (vector-ref f94259 0) f94262 (fxadd1 f94263))
# emit-expr (vector-ref f94259 0)
# emit-expr f94259
# emit-variable-ref
# env=((f94263 . -20) (f94262 . -16) (f94263 . -12) (f94262 . -8) (f94259 . 4) (f94259 . 0))
# var=f94259
    movl 2(%edi), %eax  # frame load f94259
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_570721
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_570721:
    movl %eax, -36(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_570722"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_570722:
# check bounds on vector index
    movl -36(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_570724
    cmp  $0,%eax
    jge _L_570723
_L_570724:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_570723:
    movl -36(%esp), %esi
    movl -1(%eax,%esi), %eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_570725"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_570725":
   movl %eax,  -36(%esp)  # stash funcall-oper in closure slot
# emit-expr f94262
# emit-variable-ref
# env=((f94263 . -20) (f94262 . -16) (f94263 . -12) (f94262 . -8) (f94259 . 4) (f94259 . 0))
# var=f94262
    movl -16(%esp), %eax  # stack load f94262
# end emit-variable-ref
    mov %eax, -40(%esp)  # arg f94262
# emit-expr (fxadd1 f94263)
# emit-expr f94263
# emit-variable-ref
# env=((f94263 . -20) (f94262 . -16) (f94263 . -12) (f94262 . -8) (f94259 . 4) (f94259 . 0))
# var=f94263
    movl -20(%esp), %eax  # stack load f94263
# end emit-variable-ref
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_570726"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $56,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_570726:
     addl $4, %eax
    mov %eax, -44(%esp)  # arg (fxadd1 f94263)
    movl -36(%esp), %edi   # load new closure to %edi
    add $-28, %esp   # adjust base
    movl $8,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $28, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    movl %eax, 4(%ebp)
    movl -24(%esp), %eax
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    or   $1, %al
    add  $8, %ebp
# cons end
#return from tail (cons (string-ref f94262 f94263) ((vector-ref f94259 0) f94262 (fxadd1 f94263)))
    ret
_L_570713:
    .align 4,0x90
_L_570710:
    movl -4(%esp), %ebx
    movl -8(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin)
# emit-begin
#   expr=(begin)
#   env=((f94259 . 0))
# emit-expr (begin (closure (f94265) (f94259) (let ((f94265 f94265)) ((vector-ref f94259 0) f94265 0))))
# emit-begin
#   expr=(begin (closure (f94265) (f94259) (let ((f94265 f94265)) ((vector-ref f94259 0) f94265 0))))
#   env=((f94259 . 0))
# emit-expr (closure (f94265) (f94259) (let ((f94265 f94265)) ((vector-ref f94259 0) f94265 0)))
# emit-closure
# si = -4
# env = ((f94259 . 0))
# expr = (closure (f94265) (f94259) (let ((f94265 f94265)) ((vector-ref f94259 0) f94265 0)))
    movl $_L_570727, 0(%ebp)  # closure label
# emit-variable-ref
# env=((f94259 . 0))
# var=f94259
    movl 0(%esp), %eax  # stack load f94259
# end emit-variable-ref
   movl  %eax, 4(%ebp)  # f94259
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $8, %ebp     # bump ebp
    jmp _L_570728            # jump around closure body
_L_570727:
# check argument count
    cmp $4,%eax
    je _L_570729
# invoke error handler eh_argcount
    .extern mrc_eh$uargcount
    movl mrc_eh$uargcount, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_570729:
# emit-tail-expr
# si=-12
# env=((f94265 . -8) (f94259 . 4) (f94259 . 0))
# expr=(let ((f94265 f94265)) ((vector-ref f94259 0) f94265 0))
# emit-tail-let
#  si   = -12
#  env  = ((f94265 . -8) (f94259 . 4) (f94259 . 0))
#  bindings = ((f94265 f94265))
#  body = ((vector-ref f94259 0) f94265 0)
# emit-expr f94265
# emit-variable-ref
# env=((f94265 . -8) (f94259 . 4) (f94259 . 0))
# var=f94265
    movl -8(%esp), %eax  # stack load f94265
# end emit-variable-ref
    movl %eax, -12(%esp)  # stack save
# emit-tail-expr
# si=-16
# env=((f94265 . -12) (f94265 . -8) (f94259 . 4) (f94259 . 0))
# expr=((vector-ref f94259 0) f94265 0)
# emit-tail-funcall
#    si   =-16
#    env  = ((f94265 . -12) (f94265 . -8) (f94259 . 4) (f94259 . 0))
#    expr = (funcall (vector-ref f94259 0) f94265 0)
# emit-expr (vector-ref f94259 0)
# emit-expr f94259
# emit-variable-ref
# env=((f94265 . -12) (f94265 . -8) (f94259 . 4) (f94259 . 0))
# var=f94259
    movl 2(%edi), %eax  # frame load f94259
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_570730
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_570730:
    movl %eax, -16(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_570731"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_570731:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_570733
    cmp  $0,%eax
    jge _L_570732
_L_570733:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_570732:
    movl -16(%esp), %esi
    movl -1(%eax,%esi), %eax
   movl %eax,  -16(%esp)  # stash funcall-oper in next closure slot
# emit-expr f94265
# emit-variable-ref
# env=((f94265 . -12) (f94265 . -8) (f94259 . 4) (f94259 . 0))
# var=f94265
    movl -12(%esp), %eax  # stack load f94265
# end emit-variable-ref
    mov %eax, -20(%esp)    # arg f94265
# emit-expr 0
    movl $0, %eax     # immed 0
    mov %eax, -24(%esp)    # arg 0
    movl -16(%esp), %edi   # load new closure to %edi
# emit-shift-args:  size=3   si=-16  delta=12
    mov -16(%esp), %ebx  # shift frame cell
    mov %ebx, -4(%esp)  # down to base
# emit-shift-args:  size=2   si=-20  delta=12
    mov -20(%esp), %ebx  # shift frame cell
    mov %ebx, -8(%esp)  # down to base
# emit-shift-args:  size=1   si=-24  delta=12
    mov -24(%esp), %ebx  # shift frame cell
    mov %ebx, -12(%esp)  # down to base
# emit-shift-args:  size=0   si=-28  delta=12
    movl $8,%eax   # save arg count
    jmp *-2(%edi)  # tail-funcall
    .align 4,0x90
_L_570728:
# emit-expr (begin)
# emit-begin
#   expr=(begin)
#   env=((f94259 . 0))
     movl %eax, mrc_string$m$glist
# == explicit-begins  ==>
# (letrec ((f (lambda (i l) (cond ((fx< i 10) (cons i l)) (else (f (fxquotient i 10) (cons (fxremainder i 10) l))))))) (lambda (i) (f i (quote ()))))
# == eliminate-let*  ==>
# (letrec ((f (lambda (i l) (cond ((fx< i 10) (cons i l)) (else (f (fxquotient i 10) (cons (fxremainder i 10) l))))))) (lambda (i) (f i (quote ()))))
# == uniquify-variables  ==>
# (letrec ((f94266 (lambda (f94269 f94270) (cond ((fx< f94269 10) (cons f94269 f94270)) (else (f94266 (fxquotient f94269 10) (cons (fxremainder f94269 10) f94270))))))) (lambda (f94272) (f94266 f94272 (quote ()))))
# == vectorize-letrec  ==>
# (let ((f94266 (make-vector 1))) (begin (begin (vector-set! f94266 0 (lambda (f94269 f94270) (cond ((fx< f94269 10) (cons f94269 f94270)) (else ((vector-ref f94266 0) (fxquotient f94269 10) (cons (fxremainder f94269 10) f94270))))))) (lambda (f94272) ((vector-ref f94266 0) f94272 (quote ())))))
# == eliminate-set!  ==>
# (let ((f94266 (make-vector 1))) (begin (begin (vector-set! f94266 0 (lambda (f94269 f94270) (let ((f94269 f94269) (f94270 f94270)) (cond ((fx< f94269 10) (cons f94269 f94270)) (else ((vector-ref f94266 0) (fxquotient f94269 10) (cons (fxremainder f94269 10) f94270)))))))) (lambda (f94272) (let ((f94272 f94272)) ((vector-ref f94266 0) f94272 (quote ()))))))
# == close-free-variables  ==>
# (let ((f94266 (make-vector 1))) (begin (begin (vector-set! f94266 0 (closure (f94269 f94270) (f94266) (let ((f94269 f94269) (f94270 f94270)) (cond ((fx< f94269 10) (cons f94269 f94270)) (else ((vector-ref f94266 0) (fxquotient f94269 10) (cons (fxremainder f94269 10) f94270)))))))) (closure (f94272) (f94266) (let ((f94272 f94272)) ((vector-ref f94266 0) f94272 (quote ()))))))
# == eliminate-quote  ==>
# (let ((f94266 (make-vector 1))) (begin (begin (vector-set! f94266 0 (closure (f94269 f94270) (f94266) (let ((f94269 f94269) (f94270 f94270)) (cond ((fx< f94269 10) (cons f94269 f94270)) (else ((vector-ref f94266 0) (fxquotient f94269 10) (cons (fxremainder f94269 10) f94270)))))))) (closure (f94272) (f94266) (let ((f94272 f94272)) ((vector-ref f94266 0) f94272 ())))))
# == eliminate-when/unless  ==>
# (let ((f94266 (make-vector 1))) (begin (begin (vector-set! f94266 0 (closure (f94269 f94270) (f94266) (let ((f94269 f94269) (f94270 f94270)) (cond ((fx< f94269 10) (cons f94269 f94270)) (else ((vector-ref f94266 0) (fxquotient f94269 10) (cons (fxremainder f94269 10) f94270)))))))) (closure (f94272) (f94266) (let ((f94272 f94272)) ((vector-ref f94266 0) f94272 ())))))
# == eliminate-cond  ==>
# (let ((f94266 (make-vector 1))) (begin (begin (vector-set! f94266 0 (closure (f94269 f94270) (f94266) (let ((f94269 f94269) (f94270 f94270)) (if (fx< f94269 10) (cons f94269 f94270) ((vector-ref f94266 0) (fxquotient f94269 10) (cons (fxremainder f94269 10) f94270))))))) (closure (f94272) (f94266) (let ((f94272 f94272)) ((vector-ref f94266 0) f94272 ())))))
# == external-symbols  ==>
# (let ((f94266 (make-vector 1))) (begin (begin (vector-set! f94266 0 (closure (f94269 f94270) (f94266) (let ((f94269 f94269) (f94270 f94270)) (if (fx< f94269 10) (cons f94269 f94270) ((vector-ref f94266 0) (fxquotient f94269 10) (cons (fxremainder f94269 10) f94270))))))) (closure (f94272) (f94266) (let ((f94272 f94272)) ((vector-ref f94266 0) f94272 ())))))
# emit-expr (let ((f94266 (make-vector 1))) (begin (begin (vector-set! f94266 0 (closure (f94269 f94270) (f94266) (let ((f94269 f94269) (f94270 f94270)) (if (fx< f94269 10) (cons f94269 f94270) ((vector-ref f94266 0) (fxquotient f94269 10) (cons (fxremainder f94269 10) f94270))))))) (closure (f94272) (f94266) (let ((f94272 f94272)) ((vector-ref f94266 0) f94272 ())))))
# emit-let
#  si   = 0
#  env  = ()
#  bindings = ((f94266 (make-vector 1)))
#  body = (begin (begin (vector-set! f94266 0 (closure (f94269 f94270) (f94266) (let ((f94269 f94269) (f94270 f94270)) (if (fx< f94269 10) (cons f94269 f94270) ((vector-ref f94266 0) (fxquotient f94269 10) (cons (fxremainder f94269 10) f94270))))))) (closure (f94272) (f94266) (let ((f94272 f94272)) ((vector-ref f94266 0) f94272 ()))))
# emit-expr (make-vector 1)
# make-vector 1
# emit-expr 1
    movl $4, %eax     # immed 1
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_570734"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_570734:
# check the argument is a fixnum >= 0
    cmp $0,%eax
    jge _L_570735
# invoke error handler eh_length
    .extern mrc_eh$ulength
    movl mrc_eh$ulength, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_570735:
    movl %eax, %esi
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    orl  $5, %eax
    addl $4, %esi
    addl $4, %esi
    andl $-8, %esi
    addl %esi, %ebp
    movl %eax, 0(%esp)  # stack save
# emit-expr (begin (begin (vector-set! f94266 0 (closure (f94269 f94270) (f94266) (let ((f94269 f94269) (f94270 f94270)) (if (fx< f94269 10) (cons f94269 f94270) ((vector-ref f94266 0) (fxquotient f94269 10) (cons (fxremainder f94269 10) f94270))))))) (closure (f94272) (f94266) (let ((f94272 f94272)) ((vector-ref f94266 0) f94272 ()))))
# emit-begin
#   expr=(begin (begin (vector-set! f94266 0 (closure (f94269 f94270) (f94266) (let ((f94269 f94269) (f94270 f94270)) (if (fx< f94269 10) (cons f94269 f94270) ((vector-ref f94266 0) (fxquotient f94269 10) (cons (fxremainder f94269 10) f94270))))))) (closure (f94272) (f94266) (let ((f94272 f94272)) ((vector-ref f94266 0) f94272 ()))))
#   env=((f94266 . 0))
# emit-expr (begin (vector-set! f94266 0 (closure (f94269 f94270) (f94266) (let ((f94269 f94269) (f94270 f94270)) (if (fx< f94269 10) (cons f94269 f94270) ((vector-ref f94266 0) (fxquotient f94269 10) (cons (fxremainder f94269 10) f94270)))))))
# emit-begin
#   expr=(begin (vector-set! f94266 0 (closure (f94269 f94270) (f94266) (let ((f94269 f94269) (f94270 f94270)) (if (fx< f94269 10) (cons f94269 f94270) ((vector-ref f94266 0) (fxquotient f94269 10) (cons (fxremainder f94269 10) f94270)))))))
#   env=((f94266 . 0))
# emit-expr (vector-set! f94266 0 (closure (f94269 f94270) (f94266) (let ((f94269 f94269) (f94270 f94270)) (if (fx< f94269 10) (cons f94269 f94270) ((vector-ref f94266 0) (fxquotient f94269 10) (cons (fxremainder f94269 10) f94270))))))
# emit-expr f94266
# emit-variable-ref
# env=((f94266 . 0))
# var=f94266
    movl 0(%esp), %eax  # stack load f94266
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_570736
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_570736:
    movl %eax, -4(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_570737"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_570737:
# check bounds on vector index
    movl -4(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_570739
    cmp  $0,%eax
    jge _L_570738
_L_570739:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_570738:
    movl %eax, -8(%esp)
# emit-expr (closure (f94269 f94270) (f94266) (let ((f94269 f94269) (f94270 f94270)) (if (fx< f94269 10) (cons f94269 f94270) ((vector-ref f94266 0) (fxquotient f94269 10) (cons (fxremainder f94269 10) f94270)))))
# emit-closure
# si = -12
# env = ((f94266 . 0))
# expr = (closure (f94269 f94270) (f94266) (let ((f94269 f94269) (f94270 f94270)) (if (fx< f94269 10) (cons f94269 f94270) ((vector-ref f94266 0) (fxquotient f94269 10) (cons (fxremainder f94269 10) f94270)))))
    movl $_L_570740, 0(%ebp)  # closure label
# emit-variable-ref
# env=((f94266 . 0))
# var=f94266
    movl 0(%esp), %eax  # stack load f94266
# end emit-variable-ref
   movl  %eax, 4(%ebp)  # f94266
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $8, %ebp     # bump ebp
    jmp _L_570741            # jump around closure body
_L_570740:
# check argument count
    cmp $8,%eax
    je _L_570742
# invoke error handler eh_argcount
    .extern mrc_eh$uargcount
    movl mrc_eh$uargcount, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_570742:
# emit-tail-expr
# si=-16
# env=((f94270 . -12) (f94269 . -8) (f94266 . 4) (f94266 . 0))
# expr=(let ((f94269 f94269) (f94270 f94270)) (if (fx< f94269 10) (cons f94269 f94270) ((vector-ref f94266 0) (fxquotient f94269 10) (cons (fxremainder f94269 10) f94270))))
# emit-tail-let
#  si   = -16
#  env  = ((f94270 . -12) (f94269 . -8) (f94266 . 4) (f94266 . 0))
#  bindings = ((f94269 f94269) (f94270 f94270))
#  body = (if (fx< f94269 10) (cons f94269 f94270) ((vector-ref f94266 0) (fxquotient f94269 10) (cons (fxremainder f94269 10) f94270)))
# emit-expr f94269
# emit-variable-ref
# env=((f94270 . -12) (f94269 . -8) (f94266 . 4) (f94266 . 0))
# var=f94269
    movl -8(%esp), %eax  # stack load f94269
# end emit-variable-ref
    movl %eax, -16(%esp)  # stack save
# emit-expr f94270
# emit-variable-ref
# env=((f94270 . -12) (f94269 . -8) (f94266 . 4) (f94266 . 0))
# var=f94270
    movl -12(%esp), %eax  # stack load f94270
# end emit-variable-ref
    movl %eax, -20(%esp)  # stack save
# emit-tail-expr
# si=-24
# env=((f94270 . -20) (f94269 . -16) (f94270 . -12) (f94269 . -8) (f94266 . 4) (f94266 . 0))
# expr=(if (fx< f94269 10) (cons f94269 f94270) ((vector-ref f94266 0) (fxquotient f94269 10) (cons (fxremainder f94269 10) f94270)))
# emit-expr (fx< f94269 10)
# emit-expr 10
    movl $40, %eax     # immed 10
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_570745"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $72,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_570745:
    movl %eax, -24(%esp)
# emit-expr f94269
# emit-variable-ref
# env=((f94270 . -20) (f94269 . -16) (f94270 . -12) (f94269 . -8) (f94266 . 4) (f94266 . 0))
# var=f94269
    movl -16(%esp), %eax  # stack load f94269
# end emit-variable-ref
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_570746"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $72,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_570746:
    cmp -24(%esp), %eax
    setl %al
    movzbl %al, %eax
    sal $6, %al
    or $47, %al
    cmp $47, %al
    je _L_570743
# emit-tail-expr
# si=-24
# env=((f94270 . -20) (f94269 . -16) (f94270 . -12) (f94269 . -8) (f94266 . 4) (f94266 . 0))
# expr=(cons f94269 f94270)
# tail primcall
# cons arg1=f94269 arg2=f94270
# emit-expr f94269
# emit-variable-ref
# env=((f94270 . -20) (f94269 . -16) (f94270 . -12) (f94269 . -8) (f94266 . 4) (f94266 . 0))
# var=f94269
    movl -16(%esp), %eax  # stack load f94269
# end emit-variable-ref
    movl %eax, -24(%esp)
# emit-expr f94270
# emit-variable-ref
# env=((f94270 . -20) (f94269 . -16) (f94270 . -12) (f94269 . -8) (f94266 . 4) (f94266 . 0))
# var=f94270
    movl -20(%esp), %eax  # stack load f94270
# end emit-variable-ref
    movl %eax, 4(%ebp)
    movl -24(%esp), %eax
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    or   $1, %al
    add  $8, %ebp
# cons end
#return from tail (cons f94269 f94270)
    ret
    jmp _L_570744
_L_570743:
# emit-tail-expr
# si=-24
# env=((f94270 . -20) (f94269 . -16) (f94270 . -12) (f94269 . -8) (f94266 . 4) (f94266 . 0))
# expr=((vector-ref f94266 0) (fxquotient f94269 10) (cons (fxremainder f94269 10) f94270))
# emit-tail-funcall
#    si   =-24
#    env  = ((f94270 . -20) (f94269 . -16) (f94270 . -12) (f94269 . -8) (f94266 . 4) (f94266 . 0))
#    expr = (funcall (vector-ref f94266 0) (fxquotient f94269 10) (cons (fxremainder f94269 10) f94270))
# emit-expr (vector-ref f94266 0)
# emit-expr f94266
# emit-variable-ref
# env=((f94270 . -20) (f94269 . -16) (f94270 . -12) (f94269 . -8) (f94266 . 4) (f94266 . 0))
# var=f94266
    movl 2(%edi), %eax  # frame load f94266
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_570747
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_570747:
    movl %eax, -24(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_570748"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_570748:
# check bounds on vector index
    movl -24(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_570750
    cmp  $0,%eax
    jge _L_570749
_L_570750:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_570749:
    movl -24(%esp), %esi
    movl -1(%eax,%esi), %eax
   movl %eax,  -24(%esp)  # stash funcall-oper in next closure slot
# emit-expr (fxquotient f94269 10)
# emit-expr 10
    movl $40, %eax     # immed 10
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_570752"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $100,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_570752:
    movl %eax, -28(%esp)  # denominator
# emit-expr f94269
# emit-variable-ref
# env=((f94270 . -20) (f94269 . -16) (f94270 . -12) (f94269 . -8) (f94266 . 4) (f94266 . 0))
# var=f94269
    movl -16(%esp), %eax  # stack load f94269
# end emit-variable-ref
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_570753"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $100,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_570753:
    movl -28(%esp),%ebx   # ebx <- denominator
    xor %edx,%edx        # edx <- 0
    cmp $0,%eax
    jge _L_570751
    not %edx
_L_570751:
    idiv %ebx            # eax <- edx:eax/ebx
    sal $2,%eax          # eax <- eax*4 (since it was divided away)
    mov %eax, -28(%esp)    # arg (fxquotient f94269 10)
# emit-expr (cons (fxremainder f94269 10) f94270)
# cons arg1=(fxremainder f94269 10) arg2=f94270
# emit-expr (fxremainder f94269 10)
# emit-expr 10
    movl $40, %eax     # immed 10
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_570755"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $100,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_570755:
    movl %eax, -32(%esp)  # denominator
# emit-expr f94269
# emit-variable-ref
# env=((f94270 . -20) (f94269 . -16) (f94270 . -12) (f94269 . -8) (f94266 . 4) (f94266 . 0))
# var=f94269
    movl -16(%esp), %eax  # stack load f94269
# end emit-variable-ref
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_570756"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $100,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_570756:
    movl -32(%esp),%ebx   # ebx <- denominator
    xor %edx,%edx        # edx <- 0
    cmp $0,%eax
    jge _L_570754
    not %edx
_L_570754:
    idiv %ebx            # edx <- edx:eax/ebx  remainder
    movl %edx,%eax
    movl %eax, -32(%esp)
# emit-expr f94270
# emit-variable-ref
# env=((f94270 . -20) (f94269 . -16) (f94270 . -12) (f94269 . -8) (f94266 . 4) (f94266 . 0))
# var=f94270
    movl -20(%esp), %eax  # stack load f94270
# end emit-variable-ref
    movl %eax, 4(%ebp)
    movl -32(%esp), %eax
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    or   $1, %al
    add  $8, %ebp
# cons end
    mov %eax, -32(%esp)    # arg (cons (fxremainder f94269 10) f94270)
    movl -24(%esp), %edi   # load new closure to %edi
# emit-shift-args:  size=3   si=-24  delta=20
    mov -24(%esp), %ebx  # shift frame cell
    mov %ebx, -4(%esp)  # down to base
# emit-shift-args:  size=2   si=-28  delta=20
    mov -28(%esp), %ebx  # shift frame cell
    mov %ebx, -8(%esp)  # down to base
# emit-shift-args:  size=1   si=-32  delta=20
    mov -32(%esp), %ebx  # shift frame cell
    mov %ebx, -12(%esp)  # down to base
# emit-shift-args:  size=0   si=-36  delta=20
    movl $8,%eax   # save arg count
    jmp *-2(%edi)  # tail-funcall
_L_570744:
    .align 4,0x90
_L_570741:
    movl -4(%esp), %ebx
    movl -8(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin)
# emit-begin
#   expr=(begin)
#   env=((f94266 . 0))
# emit-expr (begin (closure (f94272) (f94266) (let ((f94272 f94272)) ((vector-ref f94266 0) f94272 ()))))
# emit-begin
#   expr=(begin (closure (f94272) (f94266) (let ((f94272 f94272)) ((vector-ref f94266 0) f94272 ()))))
#   env=((f94266 . 0))
# emit-expr (closure (f94272) (f94266) (let ((f94272 f94272)) ((vector-ref f94266 0) f94272 ())))
# emit-closure
# si = -4
# env = ((f94266 . 0))
# expr = (closure (f94272) (f94266) (let ((f94272 f94272)) ((vector-ref f94266 0) f94272 ())))
    movl $_L_570757, 0(%ebp)  # closure label
# emit-variable-ref
# env=((f94266 . 0))
# var=f94266
    movl 0(%esp), %eax  # stack load f94266
# end emit-variable-ref
   movl  %eax, 4(%ebp)  # f94266
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $8, %ebp     # bump ebp
    jmp _L_570758            # jump around closure body
_L_570757:
# check argument count
    cmp $4,%eax
    je _L_570759
# invoke error handler eh_argcount
    .extern mrc_eh$uargcount
    movl mrc_eh$uargcount, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_570759:
# emit-tail-expr
# si=-12
# env=((f94272 . -8) (f94266 . 4) (f94266 . 0))
# expr=(let ((f94272 f94272)) ((vector-ref f94266 0) f94272 ()))
# emit-tail-let
#  si   = -12
#  env  = ((f94272 . -8) (f94266 . 4) (f94266 . 0))
#  bindings = ((f94272 f94272))
#  body = ((vector-ref f94266 0) f94272 ())
# emit-expr f94272
# emit-variable-ref
# env=((f94272 . -8) (f94266 . 4) (f94266 . 0))
# var=f94272
    movl -8(%esp), %eax  # stack load f94272
# end emit-variable-ref
    movl %eax, -12(%esp)  # stack save
# emit-tail-expr
# si=-16
# env=((f94272 . -12) (f94272 . -8) (f94266 . 4) (f94266 . 0))
# expr=((vector-ref f94266 0) f94272 ())
# emit-tail-funcall
#    si   =-16
#    env  = ((f94272 . -12) (f94272 . -8) (f94266 . 4) (f94266 . 0))
#    expr = (funcall (vector-ref f94266 0) f94272 ())
# emit-expr (vector-ref f94266 0)
# emit-expr f94266
# emit-variable-ref
# env=((f94272 . -12) (f94272 . -8) (f94266 . 4) (f94266 . 0))
# var=f94266
    movl 2(%edi), %eax  # frame load f94266
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_570760
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_570760:
    movl %eax, -16(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_570761"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_570761:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_570763
    cmp  $0,%eax
    jge _L_570762
_L_570763:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_570762:
    movl -16(%esp), %esi
    movl -1(%eax,%esi), %eax
   movl %eax,  -16(%esp)  # stash funcall-oper in next closure slot
# emit-expr f94272
# emit-variable-ref
# env=((f94272 . -12) (f94272 . -8) (f94266 . 4) (f94266 . 0))
# var=f94272
    movl -12(%esp), %eax  # stack load f94272
# end emit-variable-ref
    mov %eax, -20(%esp)    # arg f94272
# emit-expr ()
    movl $63, %eax     # immed ()
    mov %eax, -24(%esp)    # arg ()
    movl -16(%esp), %edi   # load new closure to %edi
# emit-shift-args:  size=3   si=-16  delta=12
    mov -16(%esp), %ebx  # shift frame cell
    mov %ebx, -4(%esp)  # down to base
# emit-shift-args:  size=2   si=-20  delta=12
    mov -20(%esp), %ebx  # shift frame cell
    mov %ebx, -8(%esp)  # down to base
# emit-shift-args:  size=1   si=-24  delta=12
    mov -24(%esp), %ebx  # shift frame cell
    mov %ebx, -12(%esp)  # down to base
# emit-shift-args:  size=0   si=-28  delta=12
    movl $8,%eax   # save arg count
    jmp *-2(%edi)  # tail-funcall
    .align 4,0x90
_L_570758:
# emit-expr (begin)
# emit-begin
#   expr=(begin)
#   env=((f94266 . 0))
     movl %eax, mrc_integer$m$glist
# == explicit-begins  ==>
# (let* ((write-stderr (lambda (s) (foreign-call "s_write" 2 s (string-length s)))) (write-errmsg (lambda (sym emsg) (begin (write-stderr "error:") (write-stderr (symbol->string sym)) (write-stderr ": ") (write-stderr emsg) (write-stderr "\n"))))) (lambda (sym emsg) (begin (write-errmsg sym emsg) (foreign-call "s_exit" 1))))
# == eliminate-let*  ==>
# (let ((write-stderr (lambda (s) (foreign-call "s_write" 2 s (string-length s))))) (let ((write-errmsg (lambda (sym emsg) (begin (write-stderr "error:") (write-stderr (symbol->string sym)) (write-stderr ": ") (write-stderr emsg) (write-stderr "\n"))))) (lambda (sym emsg) (begin (write-errmsg sym emsg) (foreign-call "s_exit" 1)))))
# == uniquify-variables  ==>
# (let ((f94273 (lambda (f94274) (foreign-call "s_write" 2 f94274 (string-length f94274))))) (let ((f94282 (lambda (f94283 f94284) (begin (f94273 "error:") (f94273 (symbol->string f94283)) (f94273 ": ") (f94273 f94284) (f94273 "\n"))))) (lambda (f94287 f94288) (begin (f94282 f94287 f94288) (foreign-call "s_exit" 1)))))
# == vectorize-letrec  ==>
# (let ((f94273 (lambda (f94274) (foreign-call "s_write" 2 f94274 (string-length f94274))))) (let ((f94282 (lambda (f94283 f94284) (begin (f94273 "error:") (f94273 (symbol->string f94283)) (f94273 ": ") (f94273 f94284) (f94273 "\n"))))) (lambda (f94287 f94288) (begin (f94282 f94287 f94288) (foreign-call "s_exit" 1)))))
# == eliminate-set!  ==>
# (let ((f94273 (lambda (f94274) (let ((f94274 f94274)) (foreign-call "s_write" 2 f94274 (string-length f94274)))))) (let ((f94282 (lambda (f94283 f94284) (let ((f94283 f94283) (f94284 f94284)) (begin (f94273 "error:") (f94273 (symbol->string f94283)) (f94273 ": ") (f94273 f94284) (f94273 "\n")))))) (lambda (f94287 f94288) (let ((f94287 f94287) (f94288 f94288)) (begin (f94282 f94287 f94288) (foreign-call "s_exit" 1))))))
# == close-free-variables  ==>
# (let ((f94273 (closure (f94274) () (let ((f94274 f94274)) (foreign-call "s_write" 2 f94274 (string-length f94274)))))) (let ((f94282 (closure (f94283 f94284) (f94273 f94273 f94273 f94273 f94273) (let ((f94283 f94283) (f94284 f94284)) (begin (f94273 "error:") (f94273 (symbol->string f94283)) (f94273 ": ") (f94273 f94284) (f94273 "\n")))))) (closure (f94287 f94288) (f94282) (let ((f94287 f94287) (f94288 f94288)) (begin (f94282 f94287 f94288) (foreign-call "s_exit" 1))))))
# == eliminate-quote  ==>
# (let ((f94273 (closure (f94274) () (let ((f94274 f94274)) (foreign-call "s_write" 2 f94274 (string-length f94274)))))) (let ((f94282 (closure (f94283 f94284) (f94273 f94273 f94273 f94273 f94273) (let ((f94283 f94283) (f94284 f94284)) (begin (f94273 "error:") (f94273 (symbol->string f94283)) (f94273 ": ") (f94273 f94284) (f94273 "\n")))))) (closure (f94287 f94288) (f94282) (let ((f94287 f94287) (f94288 f94288)) (begin (f94282 f94287 f94288) (foreign-call "s_exit" 1))))))
# == eliminate-when/unless  ==>
# (let ((f94273 (closure (f94274) () (let ((f94274 f94274)) (foreign-call "s_write" 2 f94274 (string-length f94274)))))) (let ((f94282 (closure (f94283 f94284) (f94273 f94273 f94273 f94273 f94273) (let ((f94283 f94283) (f94284 f94284)) (begin (f94273 "error:") (f94273 (symbol->string f94283)) (f94273 ": ") (f94273 f94284) (f94273 "\n")))))) (closure (f94287 f94288) (f94282) (let ((f94287 f94287) (f94288 f94288)) (begin (f94282 f94287 f94288) (foreign-call "s_exit" 1))))))
# == eliminate-cond  ==>
# (let ((f94273 (closure (f94274) () (let ((f94274 f94274)) (foreign-call "s_write" 2 f94274 (string-length f94274)))))) (let ((f94282 (closure (f94283 f94284) (f94273 f94273 f94273 f94273 f94273) (let ((f94283 f94283) (f94284 f94284)) (begin (f94273 "error:") (f94273 (symbol->string f94283)) (f94273 ": ") (f94273 f94284) (f94273 "\n")))))) (closure (f94287 f94288) (f94282) (let ((f94287 f94287) (f94288 f94288)) (begin (f94282 f94287 f94288) (foreign-call "s_exit" 1))))))
# == external-symbols  ==>
# (let ((f94273 (closure (f94274) () (let ((f94274 f94274)) (foreign-call "s_write" 2 f94274 (string-length f94274)))))) (let ((f94282 (closure (f94283 f94284) (f94273 f94273 f94273 f94273 f94273) (let ((f94283 f94283) (f94284 f94284)) (begin (f94273 "error:") (f94273 (symbol->string f94283)) (f94273 ": ") (f94273 f94284) (f94273 "\n")))))) (closure (f94287 f94288) (f94282) (let ((f94287 f94287) (f94288 f94288)) (begin (f94282 f94287 f94288) (foreign-call "s_exit" 1))))))
# emit-expr (let ((f94273 (closure (f94274) () (let ((f94274 f94274)) (foreign-call "s_write" 2 f94274 (string-length f94274)))))) (let ((f94282 (closure (f94283 f94284) (f94273 f94273 f94273 f94273 f94273) (let ((f94283 f94283) (f94284 f94284)) (begin (f94273 "error:") (f94273 (symbol->string f94283)) (f94273 ": ") (f94273 f94284) (f94273 "\n")))))) (closure (f94287 f94288) (f94282) (let ((f94287 f94287) (f94288 f94288)) (begin (f94282 f94287 f94288) (foreign-call "s_exit" 1))))))
# emit-let
#  si   = 0
#  env  = ()
#  bindings = ((f94273 (closure (f94274) () (let ((f94274 f94274)) (foreign-call "s_write" 2 f94274 (string-length f94274))))))
#  body = (let ((f94282 (closure (f94283 f94284) (f94273 f94273 f94273 f94273 f94273) (let ((f94283 f94283) (f94284 f94284)) (begin (f94273 "error:") (f94273 (symbol->string f94283)) (f94273 ": ") (f94273 f94284) (f94273 "\n")))))) (closure (f94287 f94288) (f94282) (let ((f94287 f94287) (f94288 f94288)) (begin (f94282 f94287 f94288) (foreign-call "s_exit" 1)))))
# emit-expr (closure (f94274) () (let ((f94274 f94274)) (foreign-call "s_write" 2 f94274 (string-length f94274))))
# emit-closure
# si = 0
# env = ()
# expr = (closure (f94274) () (let ((f94274 f94274)) (foreign-call "s_write" 2 f94274 (string-length f94274))))
    movl $_L_570764, 0(%ebp)  # closure label
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $8, %ebp     # bump ebp
    jmp _L_570765            # jump around closure body
_L_570764:
# check argument count
    cmp $4,%eax
    je _L_570766
# invoke error handler eh_argcount
    .extern mrc_eh$uargcount
    movl mrc_eh$uargcount, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_570766:
# emit-tail-expr
# si=-12
# env=((f94274 . -8))
# expr=(let ((f94274 f94274)) (foreign-call "s_write" 2 f94274 (string-length f94274)))
# emit-tail-let
#  si   = -12
#  env  = ((f94274 . -8))
#  bindings = ((f94274 f94274))
#  body = (foreign-call "s_write" 2 f94274 (string-length f94274))
# emit-expr f94274
# emit-variable-ref
# env=((f94274 . -8))
# var=f94274
    movl -8(%esp), %eax  # stack load f94274
# end emit-variable-ref
    movl %eax, -12(%esp)  # stack save
# emit-tail-expr
# si=-16
# env=((f94274 . -12) (f94274 . -8))
# expr=(foreign-call "s_write" 2 f94274 (string-length f94274))
    movl %ecx,-16(%esp)
    movl %esp,-20(%esp)
# emit-expr (string-length f94274)
# emit-expr f94274
# emit-variable-ref
# env=((f94274 . -12) (f94274 . -8))
# var=f94274
    movl -12(%esp), %eax  # stack load f94274
# end emit-variable-ref
# check the argument is a string
    movl %eax,%ebx
    and $7, %bl
    cmp $6, %bl
    je _L_570767
# invoke error handler eh_string
    .extern mrc_eh$ustring
    movl mrc_eh$ustring, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $160,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_570767:
    movl -6(%eax), %eax
    movl %eax, -24(%esp)
# emit-expr f94274
# emit-variable-ref
# env=((f94274 . -12) (f94274 . -8))
# var=f94274
    movl -12(%esp), %eax  # stack load f94274
# end emit-variable-ref
    movl %eax, -28(%esp)
# emit-expr 2
    movl $8, %eax     # immed 2
    movl %eax, -32(%esp)
    leal -32(%esp),%edi
    movl %edi,%esi
    andl $-16,%esi
    movl 0(%edi),%eax
    movl %eax,0(%esi)
    movl 4(%edi),%eax
    movl %eax,4(%esi)
    movl 8(%edi),%eax
    movl %eax,8(%esi)
    movl 12(%edi),%eax
    movl %eax,12(%esi)
    movl %esi,%esp
    .extern _s_write
    call _s_write
    movl 12(%esi),%esp
    movl -16(%esp),%ecx
     ret
    .align 4,0x90
_L_570765:
    movl %eax, 0(%esp)  # stack save
# emit-expr (let ((f94282 (closure (f94283 f94284) (f94273 f94273 f94273 f94273 f94273) (let ((f94283 f94283) (f94284 f94284)) (begin (f94273 "error:") (f94273 (symbol->string f94283)) (f94273 ": ") (f94273 f94284) (f94273 "\n")))))) (closure (f94287 f94288) (f94282) (let ((f94287 f94287) (f94288 f94288)) (begin (f94282 f94287 f94288) (foreign-call "s_exit" 1)))))
# emit-let
#  si   = -4
#  env  = ((f94273 . 0))
#  bindings = ((f94282 (closure (f94283 f94284) (f94273 f94273 f94273 f94273 f94273) (let ((f94283 f94283) (f94284 f94284)) (begin (f94273 "error:") (f94273 (symbol->string f94283)) (f94273 ": ") (f94273 f94284) (f94273 "\n"))))))
#  body = (closure (f94287 f94288) (f94282) (let ((f94287 f94287) (f94288 f94288)) (begin (f94282 f94287 f94288) (foreign-call "s_exit" 1))))
# emit-expr (closure (f94283 f94284) (f94273 f94273 f94273 f94273 f94273) (let ((f94283 f94283) (f94284 f94284)) (begin (f94273 "error:") (f94273 (symbol->string f94283)) (f94273 ": ") (f94273 f94284) (f94273 "\n"))))
# emit-closure
# si = -4
# env = ((f94273 . 0))
# expr = (closure (f94283 f94284) (f94273 f94273 f94273 f94273 f94273) (let ((f94283 f94283) (f94284 f94284)) (begin (f94273 "error:") (f94273 (symbol->string f94283)) (f94273 ": ") (f94273 f94284) (f94273 "\n"))))
    movl $_L_570768, 0(%ebp)  # closure label
# emit-variable-ref
# env=((f94273 . 0))
# var=f94273
    movl 0(%esp), %eax  # stack load f94273
# end emit-variable-ref
   movl  %eax, 4(%ebp)  # f94273
# emit-variable-ref
# env=((f94273 . 0))
# var=f94273
    movl 0(%esp), %eax  # stack load f94273
# end emit-variable-ref
   movl  %eax, 8(%ebp)  # f94273
# emit-variable-ref
# env=((f94273 . 0))
# var=f94273
    movl 0(%esp), %eax  # stack load f94273
# end emit-variable-ref
   movl  %eax, 12(%ebp)  # f94273
# emit-variable-ref
# env=((f94273 . 0))
# var=f94273
    movl 0(%esp), %eax  # stack load f94273
# end emit-variable-ref
   movl  %eax, 16(%ebp)  # f94273
# emit-variable-ref
# env=((f94273 . 0))
# var=f94273
    movl 0(%esp), %eax  # stack load f94273
# end emit-variable-ref
   movl  %eax, 20(%ebp)  # f94273
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $24, %ebp     # bump ebp
    jmp _L_570769            # jump around closure body
_L_570768:
# check argument count
    cmp $8,%eax
    je _L_570770
# invoke error handler eh_argcount
    .extern mrc_eh$uargcount
    movl mrc_eh$uargcount, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_570770:
# emit-tail-expr
# si=-16
# env=((f94284 . -12) (f94283 . -8) (f94273 . 20) (f94273 . 16) (f94273 . 12) (f94273 . 8) (f94273 . 4) (f94273 . 0))
# expr=(let ((f94283 f94283) (f94284 f94284)) (begin (f94273 "error:") (f94273 (symbol->string f94283)) (f94273 ": ") (f94273 f94284) (f94273 "\n")))
# emit-tail-let
#  si   = -16
#  env  = ((f94284 . -12) (f94283 . -8) (f94273 . 20) (f94273 . 16) (f94273 . 12) (f94273 . 8) (f94273 . 4) (f94273 . 0))
#  bindings = ((f94283 f94283) (f94284 f94284))
#  body = (begin (f94273 "error:") (f94273 (symbol->string f94283)) (f94273 ": ") (f94273 f94284) (f94273 "\n"))
# emit-expr f94283
# emit-variable-ref
# env=((f94284 . -12) (f94283 . -8) (f94273 . 20) (f94273 . 16) (f94273 . 12) (f94273 . 8) (f94273 . 4) (f94273 . 0))
# var=f94283
    movl -8(%esp), %eax  # stack load f94283
# end emit-variable-ref
    movl %eax, -16(%esp)  # stack save
# emit-expr f94284
# emit-variable-ref
# env=((f94284 . -12) (f94283 . -8) (f94273 . 20) (f94273 . 16) (f94273 . 12) (f94273 . 8) (f94273 . 4) (f94273 . 0))
# var=f94284
    movl -12(%esp), %eax  # stack load f94284
# end emit-variable-ref
    movl %eax, -20(%esp)  # stack save
# emit-tail-expr
# si=-24
# env=((f94284 . -20) (f94283 . -16) (f94284 . -12) (f94283 . -8) (f94273 . 20) (f94273 . 16) (f94273 . 12) (f94273 . 8) (f94273 . 4) (f94273 . 0))
# expr=(begin (f94273 "error:") (f94273 (symbol->string f94283)) (f94273 ": ") (f94273 f94284) (f94273 "\n"))
# tail-begin (begin (f94273 "error:") (f94273 (symbol->string f94283)) (f94273 ": ") (f94273 f94284) (f94273 "\n"))
#   env=((f94284 . -20) (f94283 . -16) (f94284 . -12) (f94283 . -8) (f94273 . 20) (f94273 . 16) (f94273 . 12) (f94273 . 8) (f94273 . 4) (f94273 . 0))
# emit-expr (f94273 "error:")
# funcall
#    si   =-24
#    env  = ((f94284 . -20) (f94283 . -16) (f94284 . -12) (f94283 . -8) (f94273 . 20) (f94273 . 16) (f94273 . 12) (f94273 . 8) (f94273 . 4) (f94273 . 0))
#    expr = (funcall f94273 "error:")
# emit-expr f94273
# emit-variable-ref
# env=((f94284 . -20) (f94283 . -16) (f94284 . -12) (f94283 . -8) (f94273 . 20) (f94273 . 16) (f94273 . 12) (f94273 . 8) (f94273 . 4) (f94273 . 0))
# var=f94273
    movl 18(%edi), %eax  # frame load f94273
# end emit-variable-ref
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_570771"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_570771":
   movl %eax,  -32(%esp)  # stash funcall-oper in closure slot
# emit-expr "error:"
# string literal
    jmp _L_570773
    .align 8,0x90
_L_570772 :
    .int 24
    .ascii "error:"
_L_570773:
    movl $_L_570772, %eax
    orl $6, %eax
    mov %eax, -36(%esp)  # arg error:
    movl -32(%esp), %edi   # load new closure to %edi
    add $-24, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $24, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
# emit-tail-expr
# si=-24
# env=((f94284 . -20) (f94283 . -16) (f94284 . -12) (f94283 . -8) (f94273 . 20) (f94273 . 16) (f94273 . 12) (f94273 . 8) (f94273 . 4) (f94273 . 0))
# expr=(begin (f94273 (symbol->string f94283)) (f94273 ": ") (f94273 f94284) (f94273 "\n"))
# tail-begin (begin (f94273 (symbol->string f94283)) (f94273 ": ") (f94273 f94284) (f94273 "\n"))
#   env=((f94284 . -20) (f94283 . -16) (f94284 . -12) (f94283 . -8) (f94273 . 20) (f94273 . 16) (f94273 . 12) (f94273 . 8) (f94273 . 4) (f94273 . 0))
# emit-expr (f94273 (symbol->string f94283))
# funcall
#    si   =-24
#    env  = ((f94284 . -20) (f94283 . -16) (f94284 . -12) (f94283 . -8) (f94273 . 20) (f94273 . 16) (f94273 . 12) (f94273 . 8) (f94273 . 4) (f94273 . 0))
#    expr = (funcall f94273 (symbol->string f94283))
# emit-expr f94273
# emit-variable-ref
# env=((f94284 . -20) (f94283 . -16) (f94284 . -12) (f94283 . -8) (f94273 . 20) (f94273 . 16) (f94273 . 12) (f94273 . 8) (f94273 . 4) (f94273 . 0))
# var=f94273
    movl 18(%edi), %eax  # frame load f94273
# end emit-variable-ref
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_570774"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_570774":
   movl %eax,  -32(%esp)  # stash funcall-oper in closure slot
# emit-expr (symbol->string f94283)
# symbol->string f94283
# emit-expr f94283
# emit-variable-ref
# env=((f94284 . -20) (f94283 . -16) (f94284 . -12) (f94283 . -8) (f94273 . 20) (f94273 . 16) (f94273 . 12) (f94273 . 8) (f94273 . 4) (f94273 . 0))
# var=f94283
    movl -16(%esp), %eax  # stack load f94283
# end emit-variable-ref
    movl -3(%eax), %eax
    mov %eax, -36(%esp)  # arg (symbol->string f94283)
    movl -32(%esp), %edi   # load new closure to %edi
    add $-24, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $24, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
# emit-tail-expr
# si=-24
# env=((f94284 . -20) (f94283 . -16) (f94284 . -12) (f94283 . -8) (f94273 . 20) (f94273 . 16) (f94273 . 12) (f94273 . 8) (f94273 . 4) (f94273 . 0))
# expr=(begin (f94273 ": ") (f94273 f94284) (f94273 "\n"))
# tail-begin (begin (f94273 ": ") (f94273 f94284) (f94273 "\n"))
#   env=((f94284 . -20) (f94283 . -16) (f94284 . -12) (f94283 . -8) (f94273 . 20) (f94273 . 16) (f94273 . 12) (f94273 . 8) (f94273 . 4) (f94273 . 0))
# emit-expr (f94273 ": ")
# funcall
#    si   =-24
#    env  = ((f94284 . -20) (f94283 . -16) (f94284 . -12) (f94283 . -8) (f94273 . 20) (f94273 . 16) (f94273 . 12) (f94273 . 8) (f94273 . 4) (f94273 . 0))
#    expr = (funcall f94273 ": ")
# emit-expr f94273
# emit-variable-ref
# env=((f94284 . -20) (f94283 . -16) (f94284 . -12) (f94283 . -8) (f94273 . 20) (f94273 . 16) (f94273 . 12) (f94273 . 8) (f94273 . 4) (f94273 . 0))
# var=f94273
    movl 18(%edi), %eax  # frame load f94273
# end emit-variable-ref
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_570775"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_570775":
   movl %eax,  -32(%esp)  # stash funcall-oper in closure slot
# emit-expr ": "
# string literal
    jmp _L_570777
    .align 8,0x90
_L_570776 :
    .int 8
    .ascii ": "
_L_570777:
    movl $_L_570776, %eax
    orl $6, %eax
    mov %eax, -36(%esp)  # arg : 
    movl -32(%esp), %edi   # load new closure to %edi
    add $-24, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $24, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
# emit-tail-expr
# si=-24
# env=((f94284 . -20) (f94283 . -16) (f94284 . -12) (f94283 . -8) (f94273 . 20) (f94273 . 16) (f94273 . 12) (f94273 . 8) (f94273 . 4) (f94273 . 0))
# expr=(begin (f94273 f94284) (f94273 "\n"))
# tail-begin (begin (f94273 f94284) (f94273 "\n"))
#   env=((f94284 . -20) (f94283 . -16) (f94284 . -12) (f94283 . -8) (f94273 . 20) (f94273 . 16) (f94273 . 12) (f94273 . 8) (f94273 . 4) (f94273 . 0))
# emit-expr (f94273 f94284)
# funcall
#    si   =-24
#    env  = ((f94284 . -20) (f94283 . -16) (f94284 . -12) (f94283 . -8) (f94273 . 20) (f94273 . 16) (f94273 . 12) (f94273 . 8) (f94273 . 4) (f94273 . 0))
#    expr = (funcall f94273 f94284)
# emit-expr f94273
# emit-variable-ref
# env=((f94284 . -20) (f94283 . -16) (f94284 . -12) (f94283 . -8) (f94273 . 20) (f94273 . 16) (f94273 . 12) (f94273 . 8) (f94273 . 4) (f94273 . 0))
# var=f94273
    movl 18(%edi), %eax  # frame load f94273
# end emit-variable-ref
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_570778"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_570778":
   movl %eax,  -32(%esp)  # stash funcall-oper in closure slot
# emit-expr f94284
# emit-variable-ref
# env=((f94284 . -20) (f94283 . -16) (f94284 . -12) (f94283 . -8) (f94273 . 20) (f94273 . 16) (f94273 . 12) (f94273 . 8) (f94273 . 4) (f94273 . 0))
# var=f94284
    movl -20(%esp), %eax  # stack load f94284
# end emit-variable-ref
    mov %eax, -36(%esp)  # arg f94284
    movl -32(%esp), %edi   # load new closure to %edi
    add $-24, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $24, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
# emit-tail-expr
# si=-24
# env=((f94284 . -20) (f94283 . -16) (f94284 . -12) (f94283 . -8) (f94273 . 20) (f94273 . 16) (f94273 . 12) (f94273 . 8) (f94273 . 4) (f94273 . 0))
# expr=(begin (f94273 "\n"))
# tail-begin (begin (f94273 "\n"))
#   env=((f94284 . -20) (f94283 . -16) (f94284 . -12) (f94283 . -8) (f94273 . 20) (f94273 . 16) (f94273 . 12) (f94273 . 8) (f94273 . 4) (f94273 . 0))
# emit-tail-expr
# si=-24
# env=((f94284 . -20) (f94283 . -16) (f94284 . -12) (f94283 . -8) (f94273 . 20) (f94273 . 16) (f94273 . 12) (f94273 . 8) (f94273 . 4) (f94273 . 0))
# expr=(f94273 "\n")
# emit-tail-funcall
#    si   =-24
#    env  = ((f94284 . -20) (f94283 . -16) (f94284 . -12) (f94283 . -8) (f94273 . 20) (f94273 . 16) (f94273 . 12) (f94273 . 8) (f94273 . 4) (f94273 . 0))
#    expr = (funcall f94273 "\n")
# emit-expr f94273
# emit-variable-ref
# env=((f94284 . -20) (f94283 . -16) (f94284 . -12) (f94283 . -8) (f94273 . 20) (f94273 . 16) (f94273 . 12) (f94273 . 8) (f94273 . 4) (f94273 . 0))
# var=f94273
    movl 18(%edi), %eax  # frame load f94273
# end emit-variable-ref
   movl %eax,  -24(%esp)  # stash funcall-oper in next closure slot
# emit-expr "\n"
# string literal
    jmp _L_570780
    .align 8,0x90
_L_570779 :
    .int 4
    .ascii "\n"
_L_570780:
    movl $_L_570779, %eax
    orl $6, %eax
    mov %eax, -28(%esp)    # arg 

    movl -24(%esp), %edi   # load new closure to %edi
# emit-shift-args:  size=2   si=-24  delta=20
    mov -24(%esp), %ebx  # shift frame cell
    mov %ebx, -4(%esp)  # down to base
# emit-shift-args:  size=1   si=-28  delta=20
    mov -28(%esp), %ebx  # shift frame cell
    mov %ebx, -8(%esp)  # down to base
# emit-shift-args:  size=0   si=-32  delta=20
    movl $4,%eax   # save arg count
    jmp *-2(%edi)  # tail-funcall
     ret   # return thru stack
    .align 4,0x90
_L_570769:
    movl %eax, -4(%esp)  # stack save
# emit-expr (closure (f94287 f94288) (f94282) (let ((f94287 f94287) (f94288 f94288)) (begin (f94282 f94287 f94288) (foreign-call "s_exit" 1))))
# emit-closure
# si = -8
# env = ((f94282 . -4) (f94273 . 0))
# expr = (closure (f94287 f94288) (f94282) (let ((f94287 f94287) (f94288 f94288)) (begin (f94282 f94287 f94288) (foreign-call "s_exit" 1))))
    movl $_L_570781, 0(%ebp)  # closure label
# emit-variable-ref
# env=((f94282 . -4) (f94273 . 0))
# var=f94282
    movl -4(%esp), %eax  # stack load f94282
# end emit-variable-ref
   movl  %eax, 4(%ebp)  # f94282
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $8, %ebp     # bump ebp
    jmp _L_570782            # jump around closure body
_L_570781:
# check argument count
    cmp $8,%eax
    je _L_570783
# invoke error handler eh_argcount
    .extern mrc_eh$uargcount
    movl mrc_eh$uargcount, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_570783:
# emit-tail-expr
# si=-16
# env=((f94288 . -12) (f94287 . -8) (f94282 . 4) (f94282 . -4) (f94273 . 0))
# expr=(let ((f94287 f94287) (f94288 f94288)) (begin (f94282 f94287 f94288) (foreign-call "s_exit" 1)))
# emit-tail-let
#  si   = -16
#  env  = ((f94288 . -12) (f94287 . -8) (f94282 . 4) (f94282 . -4) (f94273 . 0))
#  bindings = ((f94287 f94287) (f94288 f94288))
#  body = (begin (f94282 f94287 f94288) (foreign-call "s_exit" 1))
# emit-expr f94287
# emit-variable-ref
# env=((f94288 . -12) (f94287 . -8) (f94282 . 4) (f94282 . -4) (f94273 . 0))
# var=f94287
    movl -8(%esp), %eax  # stack load f94287
# end emit-variable-ref
    movl %eax, -16(%esp)  # stack save
# emit-expr f94288
# emit-variable-ref
# env=((f94288 . -12) (f94287 . -8) (f94282 . 4) (f94282 . -4) (f94273 . 0))
# var=f94288
    movl -12(%esp), %eax  # stack load f94288
# end emit-variable-ref
    movl %eax, -20(%esp)  # stack save
# emit-tail-expr
# si=-24
# env=((f94288 . -20) (f94287 . -16) (f94288 . -12) (f94287 . -8) (f94282 . 4) (f94282 . -4) (f94273 . 0))
# expr=(begin (f94282 f94287 f94288) (foreign-call "s_exit" 1))
# tail-begin (begin (f94282 f94287 f94288) (foreign-call "s_exit" 1))
#   env=((f94288 . -20) (f94287 . -16) (f94288 . -12) (f94287 . -8) (f94282 . 4) (f94282 . -4) (f94273 . 0))
# emit-expr (f94282 f94287 f94288)
# funcall
#    si   =-24
#    env  = ((f94288 . -20) (f94287 . -16) (f94288 . -12) (f94287 . -8) (f94282 . 4) (f94282 . -4) (f94273 . 0))
#    expr = (funcall f94282 f94287 f94288)
# emit-expr f94282
# emit-variable-ref
# env=((f94288 . -20) (f94287 . -16) (f94288 . -12) (f94287 . -8) (f94282 . 4) (f94282 . -4) (f94273 . 0))
# var=f94282
    movl 2(%edi), %eax  # frame load f94282
# end emit-variable-ref
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_570784"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_570784":
   movl %eax,  -32(%esp)  # stash funcall-oper in closure slot
# emit-expr f94287
# emit-variable-ref
# env=((f94288 . -20) (f94287 . -16) (f94288 . -12) (f94287 . -8) (f94282 . 4) (f94282 . -4) (f94273 . 0))
# var=f94287
    movl -16(%esp), %eax  # stack load f94287
# end emit-variable-ref
    mov %eax, -36(%esp)  # arg f94287
# emit-expr f94288
# emit-variable-ref
# env=((f94288 . -20) (f94287 . -16) (f94288 . -12) (f94287 . -8) (f94282 . 4) (f94282 . -4) (f94273 . 0))
# var=f94288
    movl -20(%esp), %eax  # stack load f94288
# end emit-variable-ref
    mov %eax, -40(%esp)  # arg f94288
    movl -32(%esp), %edi   # load new closure to %edi
    add $-24, %esp   # adjust base
    movl $8,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $24, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
# emit-tail-expr
# si=-24
# env=((f94288 . -20) (f94287 . -16) (f94288 . -12) (f94287 . -8) (f94282 . 4) (f94282 . -4) (f94273 . 0))
# expr=(begin (foreign-call "s_exit" 1))
# tail-begin (begin (foreign-call "s_exit" 1))
#   env=((f94288 . -20) (f94287 . -16) (f94288 . -12) (f94287 . -8) (f94282 . 4) (f94282 . -4) (f94273 . 0))
# emit-tail-expr
# si=-24
# env=((f94288 . -20) (f94287 . -16) (f94288 . -12) (f94287 . -8) (f94282 . 4) (f94282 . -4) (f94273 . 0))
# expr=(foreign-call "s_exit" 1)
    movl %ecx,-24(%esp)
    movl %esp,-28(%esp)
# emit-expr 1
    movl $4, %eax     # immed 1
    movl %eax, -32(%esp)
    leal -32(%esp),%edi
    movl %edi,%esi
    andl $-16,%esi
    movl 0(%edi),%eax
    movl %eax,0(%esi)
    movl 4(%edi),%eax
    movl %eax,4(%esi)
    movl %esi,%esp
    .extern _s_exit
    call _s_exit
    movl 4(%esi),%esp
    movl -24(%esp),%ecx
     ret
     ret   # return thru stack
    .align 4,0x90
_L_570782:
     movl %eax, mrc_error
# == explicit-begins  ==>
# (let ((p (quote ()))) (begin (set! p (cons (quote procedure?) p)) (set! p (cons (quote cdr) p)) (set! p (cons (quote car) p)) (set! p (cons (quote symbol-value) p)) (set! p (cons (quote symbol->string) p)) (set! p (cons (quote make-symbol) p)) (set! p (cons (quote symbol?) p)) (set! p (cons (quote string-set!) p)) (set! p (cons (quote string-ref) p)) (set! p (cons (quote string-length) p)) (set! p (cons (quote string?) p)) (set! p (cons (quote make-string) p)) (set! p (cons (quote vector-ref) p)) (set! p (cons (quote vector-set!) p)) (set! p (cons (quote vector-length) p)) (set! p (cons (quote make-vector) p)) (set! p (cons (quote vector?) p)) (set! p (cons (quote set-cdr!) p)) (set! p (cons (quote set-car!) p)) (set! p (cons (quote cdr) p)) (set! p (cons (quote car) p)) (set! p (cons (quote cons) p)) (set! p (cons (quote pair?) p)) (set! p (cons (quote fxremainder) p)) (set! p (cons (quote fxquotient) p)) (set! p (cons (quote fx*) p)) (set! p (cons (quote fx-) p)) (set! p (cons (quote fx+) p)) (set! p (cons (quote fx>=) p)) (set! p (cons (quote fx>) p)) (set! p (cons (quote fx<=) p)) (set! p (cons (quote fx<) p)) (set! p (cons (quote fx=) p)) (set! p (cons (quote fxzero?) p)) (set! p (cons (quote fxsub1) p)) (set! p (cons (quote fxadd1) p)) (set! p (cons (quote fxlogor) p)) (set! p (cons (quote fxlogand) p)) (set! p (cons (quote fxlognot) p)) (set! p (cons (quote char=?) p)) (set! p (cons (quote eq?) p)) (set! p (cons (quote not) p)) (set! p (cons (quote boolean?) p)) (set! p (cons (quote fixnum?) p)) (set! p (cons (quote char?) p)) (set! p (cons (quote eof-object) p)) (set! p (cons (quote eof-object?) p)) (set! p (cons (quote null?) p)) (set! p (cons (quote char->fixnum) p)) (set! p (cons (quote fixnum->char) p)) (lambda () p)))
# == eliminate-let*  ==>
# (let ((p (quote ()))) (begin (set! p (cons (quote procedure?) p)) (set! p (cons (quote cdr) p)) (set! p (cons (quote car) p)) (set! p (cons (quote symbol-value) p)) (set! p (cons (quote symbol->string) p)) (set! p (cons (quote make-symbol) p)) (set! p (cons (quote symbol?) p)) (set! p (cons (quote string-set!) p)) (set! p (cons (quote string-ref) p)) (set! p (cons (quote string-length) p)) (set! p (cons (quote string?) p)) (set! p (cons (quote make-string) p)) (set! p (cons (quote vector-ref) p)) (set! p (cons (quote vector-set!) p)) (set! p (cons (quote vector-length) p)) (set! p (cons (quote make-vector) p)) (set! p (cons (quote vector?) p)) (set! p (cons (quote set-cdr!) p)) (set! p (cons (quote set-car!) p)) (set! p (cons (quote cdr) p)) (set! p (cons (quote car) p)) (set! p (cons (quote cons) p)) (set! p (cons (quote pair?) p)) (set! p (cons (quote fxremainder) p)) (set! p (cons (quote fxquotient) p)) (set! p (cons (quote fx*) p)) (set! p (cons (quote fx-) p)) (set! p (cons (quote fx+) p)) (set! p (cons (quote fx>=) p)) (set! p (cons (quote fx>) p)) (set! p (cons (quote fx<=) p)) (set! p (cons (quote fx<) p)) (set! p (cons (quote fx=) p)) (set! p (cons (quote fxzero?) p)) (set! p (cons (quote fxsub1) p)) (set! p (cons (quote fxadd1) p)) (set! p (cons (quote fxlogor) p)) (set! p (cons (quote fxlogand) p)) (set! p (cons (quote fxlognot) p)) (set! p (cons (quote char=?) p)) (set! p (cons (quote eq?) p)) (set! p (cons (quote not) p)) (set! p (cons (quote boolean?) p)) (set! p (cons (quote fixnum?) p)) (set! p (cons (quote char?) p)) (set! p (cons (quote eof-object) p)) (set! p (cons (quote eof-object?) p)) (set! p (cons (quote null?) p)) (set! p (cons (quote char->fixnum) p)) (set! p (cons (quote fixnum->char) p)) (lambda () p)))
# == uniquify-variables  ==>
# (let ((f94289 (quote ()))) (begin (set! f94289 (cons (quote procedure?) f94289)) (set! f94289 (cons (quote cdr) f94289)) (set! f94289 (cons (quote car) f94289)) (set! f94289 (cons (quote symbol-value) f94289)) (set! f94289 (cons (quote symbol->string) f94289)) (set! f94289 (cons (quote make-symbol) f94289)) (set! f94289 (cons (quote symbol?) f94289)) (set! f94289 (cons (quote string-set!) f94289)) (set! f94289 (cons (quote string-ref) f94289)) (set! f94289 (cons (quote string-length) f94289)) (set! f94289 (cons (quote string?) f94289)) (set! f94289 (cons (quote make-string) f94289)) (set! f94289 (cons (quote vector-ref) f94289)) (set! f94289 (cons (quote vector-set!) f94289)) (set! f94289 (cons (quote vector-length) f94289)) (set! f94289 (cons (quote make-vector) f94289)) (set! f94289 (cons (quote vector?) f94289)) (set! f94289 (cons (quote set-cdr!) f94289)) (set! f94289 (cons (quote set-car!) f94289)) (set! f94289 (cons (quote cdr) f94289)) (set! f94289 (cons (quote car) f94289)) (set! f94289 (cons (quote cons) f94289)) (set! f94289 (cons (quote pair?) f94289)) (set! f94289 (cons (quote fxremainder) f94289)) (set! f94289 (cons (quote fxquotient) f94289)) (set! f94289 (cons (quote fx*) f94289)) (set! f94289 (cons (quote fx-) f94289)) (set! f94289 (cons (quote fx+) f94289)) (set! f94289 (cons (quote fx>=) f94289)) (set! f94289 (cons (quote fx>) f94289)) (set! f94289 (cons (quote fx<=) f94289)) (set! f94289 (cons (quote fx<) f94289)) (set! f94289 (cons (quote fx=) f94289)) (set! f94289 (cons (quote fxzero?) f94289)) (set! f94289 (cons (quote fxsub1) f94289)) (set! f94289 (cons (quote fxadd1) f94289)) (set! f94289 (cons (quote fxlogor) f94289)) (set! f94289 (cons (quote fxlogand) f94289)) (set! f94289 (cons (quote fxlognot) f94289)) (set! f94289 (cons (quote char=?) f94289)) (set! f94289 (cons (quote eq?) f94289)) (set! f94289 (cons (quote not) f94289)) (set! f94289 (cons (quote boolean?) f94289)) (set! f94289 (cons (quote fixnum?) f94289)) (set! f94289 (cons (quote char?) f94289)) (set! f94289 (cons (quote eof-object) f94289)) (set! f94289 (cons (quote eof-object?) f94289)) (set! f94289 (cons (quote null?) f94289)) (set! f94289 (cons (quote char->fixnum) f94289)) (set! f94289 (cons (quote fixnum->char) f94289)) (lambda () f94289)))
# == vectorize-letrec  ==>
# (let ((f94289 (quote ()))) (begin (set! f94289 (cons (quote procedure?) f94289)) (set! f94289 (cons (quote cdr) f94289)) (set! f94289 (cons (quote car) f94289)) (set! f94289 (cons (quote symbol-value) f94289)) (set! f94289 (cons (quote symbol->string) f94289)) (set! f94289 (cons (quote make-symbol) f94289)) (set! f94289 (cons (quote symbol?) f94289)) (set! f94289 (cons (quote string-set!) f94289)) (set! f94289 (cons (quote string-ref) f94289)) (set! f94289 (cons (quote string-length) f94289)) (set! f94289 (cons (quote string?) f94289)) (set! f94289 (cons (quote make-string) f94289)) (set! f94289 (cons (quote vector-ref) f94289)) (set! f94289 (cons (quote vector-set!) f94289)) (set! f94289 (cons (quote vector-length) f94289)) (set! f94289 (cons (quote make-vector) f94289)) (set! f94289 (cons (quote vector?) f94289)) (set! f94289 (cons (quote set-cdr!) f94289)) (set! f94289 (cons (quote set-car!) f94289)) (set! f94289 (cons (quote cdr) f94289)) (set! f94289 (cons (quote car) f94289)) (set! f94289 (cons (quote cons) f94289)) (set! f94289 (cons (quote pair?) f94289)) (set! f94289 (cons (quote fxremainder) f94289)) (set! f94289 (cons (quote fxquotient) f94289)) (set! f94289 (cons (quote fx*) f94289)) (set! f94289 (cons (quote fx-) f94289)) (set! f94289 (cons (quote fx+) f94289)) (set! f94289 (cons (quote fx>=) f94289)) (set! f94289 (cons (quote fx>) f94289)) (set! f94289 (cons (quote fx<=) f94289)) (set! f94289 (cons (quote fx<) f94289)) (set! f94289 (cons (quote fx=) f94289)) (set! f94289 (cons (quote fxzero?) f94289)) (set! f94289 (cons (quote fxsub1) f94289)) (set! f94289 (cons (quote fxadd1) f94289)) (set! f94289 (cons (quote fxlogor) f94289)) (set! f94289 (cons (quote fxlogand) f94289)) (set! f94289 (cons (quote fxlognot) f94289)) (set! f94289 (cons (quote char=?) f94289)) (set! f94289 (cons (quote eq?) f94289)) (set! f94289 (cons (quote not) f94289)) (set! f94289 (cons (quote boolean?) f94289)) (set! f94289 (cons (quote fixnum?) f94289)) (set! f94289 (cons (quote char?) f94289)) (set! f94289 (cons (quote eof-object) f94289)) (set! f94289 (cons (quote eof-object?) f94289)) (set! f94289 (cons (quote null?) f94289)) (set! f94289 (cons (quote char->fixnum) f94289)) (set! f94289 (cons (quote fixnum->char) f94289)) (lambda () f94289)))
# == eliminate-set!  ==>
# (let ((f94289 (vector (quote ())))) (begin (vector-set! f94289 0 (cons (quote procedure?) (vector-ref f94289 0))) (vector-set! f94289 0 (cons (quote cdr) (vector-ref f94289 0))) (vector-set! f94289 0 (cons (quote car) (vector-ref f94289 0))) (vector-set! f94289 0 (cons (quote symbol-value) (vector-ref f94289 0))) (vector-set! f94289 0 (cons (quote symbol->string) (vector-ref f94289 0))) (vector-set! f94289 0 (cons (quote make-symbol) (vector-ref f94289 0))) (vector-set! f94289 0 (cons (quote symbol?) (vector-ref f94289 0))) (vector-set! f94289 0 (cons (quote string-set!) (vector-ref f94289 0))) (vector-set! f94289 0 (cons (quote string-ref) (vector-ref f94289 0))) (vector-set! f94289 0 (cons (quote string-length) (vector-ref f94289 0))) (vector-set! f94289 0 (cons (quote string?) (vector-ref f94289 0))) (vector-set! f94289 0 (cons (quote make-string) (vector-ref f94289 0))) (vector-set! f94289 0 (cons (quote vector-ref) (vector-ref f94289 0))) (vector-set! f94289 0 (cons (quote vector-set!) (vector-ref f94289 0))) (vector-set! f94289 0 (cons (quote vector-length) (vector-ref f94289 0))) (vector-set! f94289 0 (cons (quote make-vector) (vector-ref f94289 0))) (vector-set! f94289 0 (cons (quote vector?) (vector-ref f94289 0))) (vector-set! f94289 0 (cons (quote set-cdr!) (vector-ref f94289 0))) (vector-set! f94289 0 (cons (quote set-car!) (vector-ref f94289 0))) (vector-set! f94289 0 (cons (quote cdr) (vector-ref f94289 0))) (vector-set! f94289 0 (cons (quote car) (vector-ref f94289 0))) (vector-set! f94289 0 (cons (quote cons) (vector-ref f94289 0))) (vector-set! f94289 0 (cons (quote pair?) (vector-ref f94289 0))) (vector-set! f94289 0 (cons (quote fxremainder) (vector-ref f94289 0))) (vector-set! f94289 0 (cons (quote fxquotient) (vector-ref f94289 0))) (vector-set! f94289 0 (cons (quote fx*) (vector-ref f94289 0))) (vector-set! f94289 0 (cons (quote fx-) (vector-ref f94289 0))) (vector-set! f94289 0 (cons (quote fx+) (vector-ref f94289 0))) (vector-set! f94289 0 (cons (quote fx>=) (vector-ref f94289 0))) (vector-set! f94289 0 (cons (quote fx>) (vector-ref f94289 0))) (vector-set! f94289 0 (cons (quote fx<=) (vector-ref f94289 0))) (vector-set! f94289 0 (cons (quote fx<) (vector-ref f94289 0))) (vector-set! f94289 0 (cons (quote fx=) (vector-ref f94289 0))) (vector-set! f94289 0 (cons (quote fxzero?) (vector-ref f94289 0))) (vector-set! f94289 0 (cons (quote fxsub1) (vector-ref f94289 0))) (vector-set! f94289 0 (cons (quote fxadd1) (vector-ref f94289 0))) (vector-set! f94289 0 (cons (quote fxlogor) (vector-ref f94289 0))) (vector-set! f94289 0 (cons (quote fxlogand) (vector-ref f94289 0))) (vector-set! f94289 0 (cons (quote fxlognot) (vector-ref f94289 0))) (vector-set! f94289 0 (cons (quote char=?) (vector-ref f94289 0))) (vector-set! f94289 0 (cons (quote eq?) (vector-ref f94289 0))) (vector-set! f94289 0 (cons (quote not) (vector-ref f94289 0))) (vector-set! f94289 0 (cons (quote boolean?) (vector-ref f94289 0))) (vector-set! f94289 0 (cons (quote fixnum?) (vector-ref f94289 0))) (vector-set! f94289 0 (cons (quote char?) (vector-ref f94289 0))) (vector-set! f94289 0 (cons (quote eof-object) (vector-ref f94289 0))) (vector-set! f94289 0 (cons (quote eof-object?) (vector-ref f94289 0))) (vector-set! f94289 0 (cons (quote null?) (vector-ref f94289 0))) (vector-set! f94289 0 (cons (quote char->fixnum) (vector-ref f94289 0))) (vector-set! f94289 0 (cons (quote fixnum->char) (vector-ref f94289 0))) (lambda () (let () (vector-ref f94289 0)))))
# == close-free-variables  ==>
# (let ((f94289 (vector (quote ())))) (begin (vector-set! f94289 0 (cons (quote procedure?) (vector-ref f94289 0))) (vector-set! f94289 0 (cons (quote cdr) (vector-ref f94289 0))) (vector-set! f94289 0 (cons (quote car) (vector-ref f94289 0))) (vector-set! f94289 0 (cons (quote symbol-value) (vector-ref f94289 0))) (vector-set! f94289 0 (cons (quote symbol->string) (vector-ref f94289 0))) (vector-set! f94289 0 (cons (quote make-symbol) (vector-ref f94289 0))) (vector-set! f94289 0 (cons (quote symbol?) (vector-ref f94289 0))) (vector-set! f94289 0 (cons (quote string-set!) (vector-ref f94289 0))) (vector-set! f94289 0 (cons (quote string-ref) (vector-ref f94289 0))) (vector-set! f94289 0 (cons (quote string-length) (vector-ref f94289 0))) (vector-set! f94289 0 (cons (quote string?) (vector-ref f94289 0))) (vector-set! f94289 0 (cons (quote make-string) (vector-ref f94289 0))) (vector-set! f94289 0 (cons (quote vector-ref) (vector-ref f94289 0))) (vector-set! f94289 0 (cons (quote vector-set!) (vector-ref f94289 0))) (vector-set! f94289 0 (cons (quote vector-length) (vector-ref f94289 0))) (vector-set! f94289 0 (cons (quote make-vector) (vector-ref f94289 0))) (vector-set! f94289 0 (cons (quote vector?) (vector-ref f94289 0))) (vector-set! f94289 0 (cons (quote set-cdr!) (vector-ref f94289 0))) (vector-set! f94289 0 (cons (quote set-car!) (vector-ref f94289 0))) (vector-set! f94289 0 (cons (quote cdr) (vector-ref f94289 0))) (vector-set! f94289 0 (cons (quote car) (vector-ref f94289 0))) (vector-set! f94289 0 (cons (quote cons) (vector-ref f94289 0))) (vector-set! f94289 0 (cons (quote pair?) (vector-ref f94289 0))) (vector-set! f94289 0 (cons (quote fxremainder) (vector-ref f94289 0))) (vector-set! f94289 0 (cons (quote fxquotient) (vector-ref f94289 0))) (vector-set! f94289 0 (cons (quote fx*) (vector-ref f94289 0))) (vector-set! f94289 0 (cons (quote fx-) (vector-ref f94289 0))) (vector-set! f94289 0 (cons (quote fx+) (vector-ref f94289 0))) (vector-set! f94289 0 (cons (quote fx>=) (vector-ref f94289 0))) (vector-set! f94289 0 (cons (quote fx>) (vector-ref f94289 0))) (vector-set! f94289 0 (cons (quote fx<=) (vector-ref f94289 0))) (vector-set! f94289 0 (cons (quote fx<) (vector-ref f94289 0))) (vector-set! f94289 0 (cons (quote fx=) (vector-ref f94289 0))) (vector-set! f94289 0 (cons (quote fxzero?) (vector-ref f94289 0))) (vector-set! f94289 0 (cons (quote fxsub1) (vector-ref f94289 0))) (vector-set! f94289 0 (cons (quote fxadd1) (vector-ref f94289 0))) (vector-set! f94289 0 (cons (quote fxlogor) (vector-ref f94289 0))) (vector-set! f94289 0 (cons (quote fxlogand) (vector-ref f94289 0))) (vector-set! f94289 0 (cons (quote fxlognot) (vector-ref f94289 0))) (vector-set! f94289 0 (cons (quote char=?) (vector-ref f94289 0))) (vector-set! f94289 0 (cons (quote eq?) (vector-ref f94289 0))) (vector-set! f94289 0 (cons (quote not) (vector-ref f94289 0))) (vector-set! f94289 0 (cons (quote boolean?) (vector-ref f94289 0))) (vector-set! f94289 0 (cons (quote fixnum?) (vector-ref f94289 0))) (vector-set! f94289 0 (cons (quote char?) (vector-ref f94289 0))) (vector-set! f94289 0 (cons (quote eof-object) (vector-ref f94289 0))) (vector-set! f94289 0 (cons (quote eof-object?) (vector-ref f94289 0))) (vector-set! f94289 0 (cons (quote null?) (vector-ref f94289 0))) (vector-set! f94289 0 (cons (quote char->fixnum) (vector-ref f94289 0))) (vector-set! f94289 0 (cons (quote fixnum->char) (vector-ref f94289 0))) (closure () (f94289) (let () (vector-ref f94289 0)))))
# == eliminate-quote  ==>
# (let ((f94289 (vector ()))) (begin (vector-set! f94289 0 (cons (string->symbol "procedure?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons (string->symbol "cdr") (vector-ref f94289 0))) (vector-set! f94289 0 (cons (string->symbol "car") (vector-ref f94289 0))) (vector-set! f94289 0 (cons (string->symbol "symbol-value") (vector-ref f94289 0))) (vector-set! f94289 0 (cons (string->symbol "symbol->string") (vector-ref f94289 0))) (vector-set! f94289 0 (cons (string->symbol "make-symbol") (vector-ref f94289 0))) (vector-set! f94289 0 (cons (string->symbol "symbol?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons (string->symbol "string-set!") (vector-ref f94289 0))) (vector-set! f94289 0 (cons (string->symbol "string-ref") (vector-ref f94289 0))) (vector-set! f94289 0 (cons (string->symbol "string-length") (vector-ref f94289 0))) (vector-set! f94289 0 (cons (string->symbol "string?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons (string->symbol "make-string") (vector-ref f94289 0))) (vector-set! f94289 0 (cons (string->symbol "vector-ref") (vector-ref f94289 0))) (vector-set! f94289 0 (cons (string->symbol "vector-set!") (vector-ref f94289 0))) (vector-set! f94289 0 (cons (string->symbol "vector-length") (vector-ref f94289 0))) (vector-set! f94289 0 (cons (string->symbol "make-vector") (vector-ref f94289 0))) (vector-set! f94289 0 (cons (string->symbol "vector?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons (string->symbol "set-cdr!") (vector-ref f94289 0))) (vector-set! f94289 0 (cons (string->symbol "set-car!") (vector-ref f94289 0))) (vector-set! f94289 0 (cons (string->symbol "cdr") (vector-ref f94289 0))) (vector-set! f94289 0 (cons (string->symbol "car") (vector-ref f94289 0))) (vector-set! f94289 0 (cons (string->symbol "cons") (vector-ref f94289 0))) (vector-set! f94289 0 (cons (string->symbol "pair?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons (string->symbol "fxremainder") (vector-ref f94289 0))) (vector-set! f94289 0 (cons (string->symbol "fxquotient") (vector-ref f94289 0))) (vector-set! f94289 0 (cons (string->symbol "fx*") (vector-ref f94289 0))) (vector-set! f94289 0 (cons (string->symbol "fx-") (vector-ref f94289 0))) (vector-set! f94289 0 (cons (string->symbol "fx+") (vector-ref f94289 0))) (vector-set! f94289 0 (cons (string->symbol "fx>=") (vector-ref f94289 0))) (vector-set! f94289 0 (cons (string->symbol "fx>") (vector-ref f94289 0))) (vector-set! f94289 0 (cons (string->symbol "fx<=") (vector-ref f94289 0))) (vector-set! f94289 0 (cons (string->symbol "fx<") (vector-ref f94289 0))) (vector-set! f94289 0 (cons (string->symbol "fx=") (vector-ref f94289 0))) (vector-set! f94289 0 (cons (string->symbol "fxzero?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons (string->symbol "fxsub1") (vector-ref f94289 0))) (vector-set! f94289 0 (cons (string->symbol "fxadd1") (vector-ref f94289 0))) (vector-set! f94289 0 (cons (string->symbol "fxlogor") (vector-ref f94289 0))) (vector-set! f94289 0 (cons (string->symbol "fxlogand") (vector-ref f94289 0))) (vector-set! f94289 0 (cons (string->symbol "fxlognot") (vector-ref f94289 0))) (vector-set! f94289 0 (cons (string->symbol "char=?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons (string->symbol "eq?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons (string->symbol "not") (vector-ref f94289 0))) (vector-set! f94289 0 (cons (string->symbol "boolean?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons (string->symbol "fixnum?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons (string->symbol "char?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons (string->symbol "eof-object") (vector-ref f94289 0))) (vector-set! f94289 0 (cons (string->symbol "eof-object?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons (string->symbol "null?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons (string->symbol "char->fixnum") (vector-ref f94289 0))) (vector-set! f94289 0 (cons (string->symbol "fixnum->char") (vector-ref f94289 0))) (closure () (f94289) (let () (vector-ref f94289 0)))))
# == eliminate-when/unless  ==>
# (let ((f94289 (vector ()))) (begin (vector-set! f94289 0 (cons (string->symbol "procedure?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons (string->symbol "cdr") (vector-ref f94289 0))) (vector-set! f94289 0 (cons (string->symbol "car") (vector-ref f94289 0))) (vector-set! f94289 0 (cons (string->symbol "symbol-value") (vector-ref f94289 0))) (vector-set! f94289 0 (cons (string->symbol "symbol->string") (vector-ref f94289 0))) (vector-set! f94289 0 (cons (string->symbol "make-symbol") (vector-ref f94289 0))) (vector-set! f94289 0 (cons (string->symbol "symbol?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons (string->symbol "string-set!") (vector-ref f94289 0))) (vector-set! f94289 0 (cons (string->symbol "string-ref") (vector-ref f94289 0))) (vector-set! f94289 0 (cons (string->symbol "string-length") (vector-ref f94289 0))) (vector-set! f94289 0 (cons (string->symbol "string?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons (string->symbol "make-string") (vector-ref f94289 0))) (vector-set! f94289 0 (cons (string->symbol "vector-ref") (vector-ref f94289 0))) (vector-set! f94289 0 (cons (string->symbol "vector-set!") (vector-ref f94289 0))) (vector-set! f94289 0 (cons (string->symbol "vector-length") (vector-ref f94289 0))) (vector-set! f94289 0 (cons (string->symbol "make-vector") (vector-ref f94289 0))) (vector-set! f94289 0 (cons (string->symbol "vector?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons (string->symbol "set-cdr!") (vector-ref f94289 0))) (vector-set! f94289 0 (cons (string->symbol "set-car!") (vector-ref f94289 0))) (vector-set! f94289 0 (cons (string->symbol "cdr") (vector-ref f94289 0))) (vector-set! f94289 0 (cons (string->symbol "car") (vector-ref f94289 0))) (vector-set! f94289 0 (cons (string->symbol "cons") (vector-ref f94289 0))) (vector-set! f94289 0 (cons (string->symbol "pair?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons (string->symbol "fxremainder") (vector-ref f94289 0))) (vector-set! f94289 0 (cons (string->symbol "fxquotient") (vector-ref f94289 0))) (vector-set! f94289 0 (cons (string->symbol "fx*") (vector-ref f94289 0))) (vector-set! f94289 0 (cons (string->symbol "fx-") (vector-ref f94289 0))) (vector-set! f94289 0 (cons (string->symbol "fx+") (vector-ref f94289 0))) (vector-set! f94289 0 (cons (string->symbol "fx>=") (vector-ref f94289 0))) (vector-set! f94289 0 (cons (string->symbol "fx>") (vector-ref f94289 0))) (vector-set! f94289 0 (cons (string->symbol "fx<=") (vector-ref f94289 0))) (vector-set! f94289 0 (cons (string->symbol "fx<") (vector-ref f94289 0))) (vector-set! f94289 0 (cons (string->symbol "fx=") (vector-ref f94289 0))) (vector-set! f94289 0 (cons (string->symbol "fxzero?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons (string->symbol "fxsub1") (vector-ref f94289 0))) (vector-set! f94289 0 (cons (string->symbol "fxadd1") (vector-ref f94289 0))) (vector-set! f94289 0 (cons (string->symbol "fxlogor") (vector-ref f94289 0))) (vector-set! f94289 0 (cons (string->symbol "fxlogand") (vector-ref f94289 0))) (vector-set! f94289 0 (cons (string->symbol "fxlognot") (vector-ref f94289 0))) (vector-set! f94289 0 (cons (string->symbol "char=?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons (string->symbol "eq?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons (string->symbol "not") (vector-ref f94289 0))) (vector-set! f94289 0 (cons (string->symbol "boolean?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons (string->symbol "fixnum?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons (string->symbol "char?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons (string->symbol "eof-object") (vector-ref f94289 0))) (vector-set! f94289 0 (cons (string->symbol "eof-object?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons (string->symbol "null?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons (string->symbol "char->fixnum") (vector-ref f94289 0))) (vector-set! f94289 0 (cons (string->symbol "fixnum->char") (vector-ref f94289 0))) (closure () (f94289) (let () (vector-ref f94289 0)))))
# == eliminate-cond  ==>
# (let ((f94289 (vector ()))) (begin (vector-set! f94289 0 (cons (string->symbol "procedure?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons (string->symbol "cdr") (vector-ref f94289 0))) (vector-set! f94289 0 (cons (string->symbol "car") (vector-ref f94289 0))) (vector-set! f94289 0 (cons (string->symbol "symbol-value") (vector-ref f94289 0))) (vector-set! f94289 0 (cons (string->symbol "symbol->string") (vector-ref f94289 0))) (vector-set! f94289 0 (cons (string->symbol "make-symbol") (vector-ref f94289 0))) (vector-set! f94289 0 (cons (string->symbol "symbol?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons (string->symbol "string-set!") (vector-ref f94289 0))) (vector-set! f94289 0 (cons (string->symbol "string-ref") (vector-ref f94289 0))) (vector-set! f94289 0 (cons (string->symbol "string-length") (vector-ref f94289 0))) (vector-set! f94289 0 (cons (string->symbol "string?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons (string->symbol "make-string") (vector-ref f94289 0))) (vector-set! f94289 0 (cons (string->symbol "vector-ref") (vector-ref f94289 0))) (vector-set! f94289 0 (cons (string->symbol "vector-set!") (vector-ref f94289 0))) (vector-set! f94289 0 (cons (string->symbol "vector-length") (vector-ref f94289 0))) (vector-set! f94289 0 (cons (string->symbol "make-vector") (vector-ref f94289 0))) (vector-set! f94289 0 (cons (string->symbol "vector?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons (string->symbol "set-cdr!") (vector-ref f94289 0))) (vector-set! f94289 0 (cons (string->symbol "set-car!") (vector-ref f94289 0))) (vector-set! f94289 0 (cons (string->symbol "cdr") (vector-ref f94289 0))) (vector-set! f94289 0 (cons (string->symbol "car") (vector-ref f94289 0))) (vector-set! f94289 0 (cons (string->symbol "cons") (vector-ref f94289 0))) (vector-set! f94289 0 (cons (string->symbol "pair?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons (string->symbol "fxremainder") (vector-ref f94289 0))) (vector-set! f94289 0 (cons (string->symbol "fxquotient") (vector-ref f94289 0))) (vector-set! f94289 0 (cons (string->symbol "fx*") (vector-ref f94289 0))) (vector-set! f94289 0 (cons (string->symbol "fx-") (vector-ref f94289 0))) (vector-set! f94289 0 (cons (string->symbol "fx+") (vector-ref f94289 0))) (vector-set! f94289 0 (cons (string->symbol "fx>=") (vector-ref f94289 0))) (vector-set! f94289 0 (cons (string->symbol "fx>") (vector-ref f94289 0))) (vector-set! f94289 0 (cons (string->symbol "fx<=") (vector-ref f94289 0))) (vector-set! f94289 0 (cons (string->symbol "fx<") (vector-ref f94289 0))) (vector-set! f94289 0 (cons (string->symbol "fx=") (vector-ref f94289 0))) (vector-set! f94289 0 (cons (string->symbol "fxzero?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons (string->symbol "fxsub1") (vector-ref f94289 0))) (vector-set! f94289 0 (cons (string->symbol "fxadd1") (vector-ref f94289 0))) (vector-set! f94289 0 (cons (string->symbol "fxlogor") (vector-ref f94289 0))) (vector-set! f94289 0 (cons (string->symbol "fxlogand") (vector-ref f94289 0))) (vector-set! f94289 0 (cons (string->symbol "fxlognot") (vector-ref f94289 0))) (vector-set! f94289 0 (cons (string->symbol "char=?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons (string->symbol "eq?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons (string->symbol "not") (vector-ref f94289 0))) (vector-set! f94289 0 (cons (string->symbol "boolean?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons (string->symbol "fixnum?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons (string->symbol "char?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons (string->symbol "eof-object") (vector-ref f94289 0))) (vector-set! f94289 0 (cons (string->symbol "eof-object?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons (string->symbol "null?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons (string->symbol "char->fixnum") (vector-ref f94289 0))) (vector-set! f94289 0 (cons (string->symbol "fixnum->char") (vector-ref f94289 0))) (closure () (f94289) (let () (vector-ref f94289 0)))))
# == external-symbols  ==>
# (let ((f94289 ((primitive-ref vector) ()))) (begin (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "procedure?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "cdr") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "car") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "symbol-value") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "symbol->string") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "make-symbol") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "symbol?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "string-set!") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "string-ref") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "string-length") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "string?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "make-string") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "vector-ref") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "vector-set!") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "vector-length") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "make-vector") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "vector?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "set-cdr!") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "set-car!") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "cdr") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "car") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "cons") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "pair?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fxremainder") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fxquotient") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fx*") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fx-") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fx+") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fx>=") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fx>") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fx<=") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fx<") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fx=") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "eof-object") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "eof-object?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f94289 0))) (closure () (f94289) (let () (vector-ref f94289 0)))))
# emit-expr (let ((f94289 ((primitive-ref vector) ()))) (begin (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "procedure?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "cdr") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "car") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "symbol-value") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "symbol->string") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "make-symbol") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "symbol?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "string-set!") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "string-ref") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "string-length") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "string?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "make-string") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "vector-ref") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "vector-set!") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "vector-length") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "make-vector") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "vector?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "set-cdr!") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "set-car!") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "cdr") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "car") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "cons") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "pair?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fxremainder") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fxquotient") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fx*") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fx-") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fx+") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fx>=") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fx>") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fx<=") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fx<") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fx=") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "eof-object") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "eof-object?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f94289 0))) (closure () (f94289) (let () (vector-ref f94289 0)))))
# emit-let
#  si   = 0
#  env  = ()
#  bindings = ((f94289 ((primitive-ref vector) ())))
#  body = (begin (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "procedure?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "cdr") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "car") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "symbol-value") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "symbol->string") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "make-symbol") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "symbol?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "string-set!") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "string-ref") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "string-length") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "string?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "make-string") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "vector-ref") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "vector-set!") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "vector-length") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "make-vector") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "vector?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "set-cdr!") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "set-car!") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "cdr") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "car") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "cons") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "pair?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fxremainder") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fxquotient") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fx*") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fx-") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fx+") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fx>=") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fx>") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fx<=") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fx<") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fx=") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "eof-object") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "eof-object?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f94289 0))) (closure () (f94289) (let () (vector-ref f94289 0))))
# emit-expr ((primitive-ref vector) ())
# funcall
#    si   =0
#    env  = ()
#    expr = (funcall (primitive-ref vector) ())
# emit-expr (primitive-ref vector)
    .extern mrc_vector
    movl mrc_vector,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_570785"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_570785":
   movl %eax,  -8(%esp)  # stash funcall-oper in closure slot
# emit-expr ()
    movl $63, %eax     # immed ()
    mov %eax, -12(%esp)  # arg ()
    movl -8(%esp), %edi   # load new closure to %edi
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    movl -4(%esp), %edi   # restore closure frame ptr
    movl %eax, 0(%esp)  # stack save
# emit-expr (begin (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "procedure?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "cdr") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "car") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "symbol-value") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "symbol->string") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "make-symbol") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "symbol?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "string-set!") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "string-ref") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "string-length") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "string?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "make-string") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "vector-ref") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "vector-set!") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "vector-length") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "make-vector") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "vector?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "set-cdr!") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "set-car!") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "cdr") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "car") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "cons") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "pair?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fxremainder") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fxquotient") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fx*") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fx-") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fx+") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fx>=") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fx>") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fx<=") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fx<") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fx=") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "eof-object") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "eof-object?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f94289 0))) (closure () (f94289) (let () (vector-ref f94289 0))))
# emit-begin
#   expr=(begin (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "procedure?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "cdr") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "car") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "symbol-value") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "symbol->string") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "make-symbol") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "symbol?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "string-set!") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "string-ref") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "string-length") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "string?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "make-string") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "vector-ref") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "vector-set!") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "vector-length") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "make-vector") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "vector?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "set-cdr!") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "set-car!") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "cdr") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "car") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "cons") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "pair?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fxremainder") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fxquotient") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fx*") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fx-") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fx+") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fx>=") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fx>") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fx<=") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fx<") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fx=") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "eof-object") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "eof-object?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f94289 0))) (closure () (f94289) (let () (vector-ref f94289 0))))
#   env=((f94289 . 0))
# emit-expr (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "procedure?") (vector-ref f94289 0)))
# emit-expr f94289
# emit-variable-ref
# env=((f94289 . 0))
# var=f94289
    movl 0(%esp), %eax  # stack load f94289
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_570786
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_570786:
    movl %eax, -4(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_570787"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_570787:
# check bounds on vector index
    movl -4(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_570789
    cmp  $0,%eax
    jge _L_570788
_L_570789:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_570788:
    movl %eax, -8(%esp)
# emit-expr (cons ((primitive-ref string->symbol) "procedure?") (vector-ref f94289 0))
# cons arg1=((primitive-ref string->symbol) "procedure?") arg2=(vector-ref f94289 0)
# emit-expr ((primitive-ref string->symbol) "procedure?")
# funcall
#    si   =-12
#    env  = ((f94289 . 0))
#    expr = (funcall (primitive-ref string->symbol) "procedure?")
# emit-expr (primitive-ref string->symbol)
    .extern mrc_string$m$gsymbol
    movl mrc_string$m$gsymbol,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_570790"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_570790":
   movl %eax,  -20(%esp)  # stash funcall-oper in closure slot
# emit-expr "procedure?"
# string literal
    jmp _L_570792
    .align 8,0x90
_L_570791 :
    .int 40
    .ascii "procedure?"
_L_570792:
    movl $_L_570791, %eax
    orl $6, %eax
    mov %eax, -24(%esp)  # arg procedure?
    movl -20(%esp), %edi   # load new closure to %edi
    add $-12, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $12, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    movl %eax, -12(%esp)
# emit-expr (vector-ref f94289 0)
# emit-expr f94289
# emit-variable-ref
# env=((f94289 . 0))
# var=f94289
    movl 0(%esp), %eax  # stack load f94289
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_570793
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_570793:
    movl %eax, -16(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_570794"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_570794:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_570796
    cmp  $0,%eax
    jge _L_570795
_L_570796:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_570795:
    movl -16(%esp), %esi
    movl -1(%eax,%esi), %eax
    movl %eax, 4(%ebp)
    movl -12(%esp), %eax
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    or   $1, %al
    add  $8, %ebp
# cons end
    movl -4(%esp), %ebx
    movl -8(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "cdr") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "car") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "symbol-value") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "symbol->string") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "make-symbol") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "symbol?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "string-set!") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "string-ref") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "string-length") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "string?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "make-string") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "vector-ref") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "vector-set!") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "vector-length") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "make-vector") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "vector?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "set-cdr!") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "set-car!") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "cdr") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "car") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "cons") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "pair?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fxremainder") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fxquotient") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fx*") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fx-") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fx+") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fx>=") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fx>") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fx<=") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fx<") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fx=") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "eof-object") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "eof-object?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f94289 0))) (closure () (f94289) (let () (vector-ref f94289 0))))
# emit-begin
#   expr=(begin (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "cdr") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "car") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "symbol-value") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "symbol->string") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "make-symbol") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "symbol?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "string-set!") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "string-ref") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "string-length") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "string?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "make-string") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "vector-ref") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "vector-set!") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "vector-length") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "make-vector") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "vector?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "set-cdr!") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "set-car!") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "cdr") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "car") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "cons") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "pair?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fxremainder") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fxquotient") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fx*") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fx-") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fx+") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fx>=") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fx>") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fx<=") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fx<") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fx=") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "eof-object") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "eof-object?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f94289 0))) (closure () (f94289) (let () (vector-ref f94289 0))))
#   env=((f94289 . 0))
# emit-expr (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "cdr") (vector-ref f94289 0)))
# emit-expr f94289
# emit-variable-ref
# env=((f94289 . 0))
# var=f94289
    movl 0(%esp), %eax  # stack load f94289
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_570797
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_570797:
    movl %eax, -4(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_570798"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_570798:
# check bounds on vector index
    movl -4(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_570800
    cmp  $0,%eax
    jge _L_570799
_L_570800:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_570799:
    movl %eax, -8(%esp)
# emit-expr (cons ((primitive-ref string->symbol) "cdr") (vector-ref f94289 0))
# cons arg1=((primitive-ref string->symbol) "cdr") arg2=(vector-ref f94289 0)
# emit-expr ((primitive-ref string->symbol) "cdr")
# funcall
#    si   =-12
#    env  = ((f94289 . 0))
#    expr = (funcall (primitive-ref string->symbol) "cdr")
# emit-expr (primitive-ref string->symbol)
    .extern mrc_string$m$gsymbol
    movl mrc_string$m$gsymbol,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_570801"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_570801":
   movl %eax,  -20(%esp)  # stash funcall-oper in closure slot
# emit-expr "cdr"
# string literal
    jmp _L_570803
    .align 8,0x90
_L_570802 :
    .int 12
    .ascii "cdr"
_L_570803:
    movl $_L_570802, %eax
    orl $6, %eax
    mov %eax, -24(%esp)  # arg cdr
    movl -20(%esp), %edi   # load new closure to %edi
    add $-12, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $12, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    movl %eax, -12(%esp)
# emit-expr (vector-ref f94289 0)
# emit-expr f94289
# emit-variable-ref
# env=((f94289 . 0))
# var=f94289
    movl 0(%esp), %eax  # stack load f94289
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_570804
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_570804:
    movl %eax, -16(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_570805"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_570805:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_570807
    cmp  $0,%eax
    jge _L_570806
_L_570807:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_570806:
    movl -16(%esp), %esi
    movl -1(%eax,%esi), %eax
    movl %eax, 4(%ebp)
    movl -12(%esp), %eax
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    or   $1, %al
    add  $8, %ebp
# cons end
    movl -4(%esp), %ebx
    movl -8(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "car") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "symbol-value") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "symbol->string") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "make-symbol") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "symbol?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "string-set!") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "string-ref") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "string-length") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "string?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "make-string") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "vector-ref") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "vector-set!") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "vector-length") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "make-vector") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "vector?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "set-cdr!") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "set-car!") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "cdr") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "car") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "cons") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "pair?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fxremainder") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fxquotient") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fx*") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fx-") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fx+") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fx>=") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fx>") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fx<=") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fx<") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fx=") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "eof-object") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "eof-object?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f94289 0))) (closure () (f94289) (let () (vector-ref f94289 0))))
# emit-begin
#   expr=(begin (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "car") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "symbol-value") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "symbol->string") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "make-symbol") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "symbol?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "string-set!") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "string-ref") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "string-length") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "string?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "make-string") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "vector-ref") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "vector-set!") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "vector-length") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "make-vector") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "vector?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "set-cdr!") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "set-car!") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "cdr") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "car") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "cons") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "pair?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fxremainder") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fxquotient") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fx*") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fx-") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fx+") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fx>=") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fx>") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fx<=") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fx<") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fx=") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "eof-object") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "eof-object?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f94289 0))) (closure () (f94289) (let () (vector-ref f94289 0))))
#   env=((f94289 . 0))
# emit-expr (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "car") (vector-ref f94289 0)))
# emit-expr f94289
# emit-variable-ref
# env=((f94289 . 0))
# var=f94289
    movl 0(%esp), %eax  # stack load f94289
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_570808
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_570808:
    movl %eax, -4(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_570809"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_570809:
# check bounds on vector index
    movl -4(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_570811
    cmp  $0,%eax
    jge _L_570810
_L_570811:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_570810:
    movl %eax, -8(%esp)
# emit-expr (cons ((primitive-ref string->symbol) "car") (vector-ref f94289 0))
# cons arg1=((primitive-ref string->symbol) "car") arg2=(vector-ref f94289 0)
# emit-expr ((primitive-ref string->symbol) "car")
# funcall
#    si   =-12
#    env  = ((f94289 . 0))
#    expr = (funcall (primitive-ref string->symbol) "car")
# emit-expr (primitive-ref string->symbol)
    .extern mrc_string$m$gsymbol
    movl mrc_string$m$gsymbol,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_570812"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_570812":
   movl %eax,  -20(%esp)  # stash funcall-oper in closure slot
# emit-expr "car"
# string literal
    jmp _L_570814
    .align 8,0x90
_L_570813 :
    .int 12
    .ascii "car"
_L_570814:
    movl $_L_570813, %eax
    orl $6, %eax
    mov %eax, -24(%esp)  # arg car
    movl -20(%esp), %edi   # load new closure to %edi
    add $-12, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $12, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    movl %eax, -12(%esp)
# emit-expr (vector-ref f94289 0)
# emit-expr f94289
# emit-variable-ref
# env=((f94289 . 0))
# var=f94289
    movl 0(%esp), %eax  # stack load f94289
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_570815
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_570815:
    movl %eax, -16(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_570816"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_570816:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_570818
    cmp  $0,%eax
    jge _L_570817
_L_570818:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_570817:
    movl -16(%esp), %esi
    movl -1(%eax,%esi), %eax
    movl %eax, 4(%ebp)
    movl -12(%esp), %eax
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    or   $1, %al
    add  $8, %ebp
# cons end
    movl -4(%esp), %ebx
    movl -8(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "symbol-value") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "symbol->string") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "make-symbol") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "symbol?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "string-set!") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "string-ref") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "string-length") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "string?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "make-string") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "vector-ref") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "vector-set!") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "vector-length") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "make-vector") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "vector?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "set-cdr!") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "set-car!") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "cdr") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "car") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "cons") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "pair?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fxremainder") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fxquotient") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fx*") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fx-") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fx+") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fx>=") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fx>") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fx<=") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fx<") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fx=") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "eof-object") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "eof-object?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f94289 0))) (closure () (f94289) (let () (vector-ref f94289 0))))
# emit-begin
#   expr=(begin (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "symbol-value") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "symbol->string") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "make-symbol") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "symbol?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "string-set!") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "string-ref") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "string-length") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "string?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "make-string") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "vector-ref") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "vector-set!") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "vector-length") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "make-vector") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "vector?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "set-cdr!") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "set-car!") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "cdr") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "car") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "cons") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "pair?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fxremainder") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fxquotient") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fx*") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fx-") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fx+") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fx>=") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fx>") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fx<=") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fx<") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fx=") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "eof-object") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "eof-object?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f94289 0))) (closure () (f94289) (let () (vector-ref f94289 0))))
#   env=((f94289 . 0))
# emit-expr (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "symbol-value") (vector-ref f94289 0)))
# emit-expr f94289
# emit-variable-ref
# env=((f94289 . 0))
# var=f94289
    movl 0(%esp), %eax  # stack load f94289
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_570819
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_570819:
    movl %eax, -4(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_570820"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_570820:
# check bounds on vector index
    movl -4(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_570822
    cmp  $0,%eax
    jge _L_570821
_L_570822:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_570821:
    movl %eax, -8(%esp)
# emit-expr (cons ((primitive-ref string->symbol) "symbol-value") (vector-ref f94289 0))
# cons arg1=((primitive-ref string->symbol) "symbol-value") arg2=(vector-ref f94289 0)
# emit-expr ((primitive-ref string->symbol) "symbol-value")
# funcall
#    si   =-12
#    env  = ((f94289 . 0))
#    expr = (funcall (primitive-ref string->symbol) "symbol-value")
# emit-expr (primitive-ref string->symbol)
    .extern mrc_string$m$gsymbol
    movl mrc_string$m$gsymbol,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_570823"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_570823":
   movl %eax,  -20(%esp)  # stash funcall-oper in closure slot
# emit-expr "symbol-value"
# string literal
    jmp _L_570825
    .align 8,0x90
_L_570824 :
    .int 48
    .ascii "symbol-value"
_L_570825:
    movl $_L_570824, %eax
    orl $6, %eax
    mov %eax, -24(%esp)  # arg symbol-value
    movl -20(%esp), %edi   # load new closure to %edi
    add $-12, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $12, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    movl %eax, -12(%esp)
# emit-expr (vector-ref f94289 0)
# emit-expr f94289
# emit-variable-ref
# env=((f94289 . 0))
# var=f94289
    movl 0(%esp), %eax  # stack load f94289
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_570826
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_570826:
    movl %eax, -16(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_570827"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_570827:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_570829
    cmp  $0,%eax
    jge _L_570828
_L_570829:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_570828:
    movl -16(%esp), %esi
    movl -1(%eax,%esi), %eax
    movl %eax, 4(%ebp)
    movl -12(%esp), %eax
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    or   $1, %al
    add  $8, %ebp
# cons end
    movl -4(%esp), %ebx
    movl -8(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "symbol->string") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "make-symbol") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "symbol?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "string-set!") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "string-ref") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "string-length") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "string?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "make-string") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "vector-ref") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "vector-set!") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "vector-length") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "make-vector") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "vector?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "set-cdr!") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "set-car!") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "cdr") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "car") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "cons") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "pair?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fxremainder") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fxquotient") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fx*") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fx-") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fx+") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fx>=") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fx>") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fx<=") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fx<") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fx=") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "eof-object") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "eof-object?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f94289 0))) (closure () (f94289) (let () (vector-ref f94289 0))))
# emit-begin
#   expr=(begin (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "symbol->string") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "make-symbol") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "symbol?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "string-set!") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "string-ref") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "string-length") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "string?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "make-string") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "vector-ref") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "vector-set!") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "vector-length") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "make-vector") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "vector?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "set-cdr!") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "set-car!") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "cdr") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "car") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "cons") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "pair?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fxremainder") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fxquotient") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fx*") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fx-") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fx+") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fx>=") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fx>") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fx<=") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fx<") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fx=") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "eof-object") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "eof-object?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f94289 0))) (closure () (f94289) (let () (vector-ref f94289 0))))
#   env=((f94289 . 0))
# emit-expr (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "symbol->string") (vector-ref f94289 0)))
# emit-expr f94289
# emit-variable-ref
# env=((f94289 . 0))
# var=f94289
    movl 0(%esp), %eax  # stack load f94289
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_570830
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_570830:
    movl %eax, -4(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_570831"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_570831:
# check bounds on vector index
    movl -4(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_570833
    cmp  $0,%eax
    jge _L_570832
_L_570833:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_570832:
    movl %eax, -8(%esp)
# emit-expr (cons ((primitive-ref string->symbol) "symbol->string") (vector-ref f94289 0))
# cons arg1=((primitive-ref string->symbol) "symbol->string") arg2=(vector-ref f94289 0)
# emit-expr ((primitive-ref string->symbol) "symbol->string")
# funcall
#    si   =-12
#    env  = ((f94289 . 0))
#    expr = (funcall (primitive-ref string->symbol) "symbol->string")
# emit-expr (primitive-ref string->symbol)
    .extern mrc_string$m$gsymbol
    movl mrc_string$m$gsymbol,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_570834"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_570834":
   movl %eax,  -20(%esp)  # stash funcall-oper in closure slot
# emit-expr "symbol->string"
# string literal
    jmp _L_570836
    .align 8,0x90
_L_570835 :
    .int 56
    .ascii "symbol->string"
_L_570836:
    movl $_L_570835, %eax
    orl $6, %eax
    mov %eax, -24(%esp)  # arg symbol->string
    movl -20(%esp), %edi   # load new closure to %edi
    add $-12, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $12, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    movl %eax, -12(%esp)
# emit-expr (vector-ref f94289 0)
# emit-expr f94289
# emit-variable-ref
# env=((f94289 . 0))
# var=f94289
    movl 0(%esp), %eax  # stack load f94289
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_570837
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_570837:
    movl %eax, -16(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_570838"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_570838:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_570840
    cmp  $0,%eax
    jge _L_570839
_L_570840:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_570839:
    movl -16(%esp), %esi
    movl -1(%eax,%esi), %eax
    movl %eax, 4(%ebp)
    movl -12(%esp), %eax
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    or   $1, %al
    add  $8, %ebp
# cons end
    movl -4(%esp), %ebx
    movl -8(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "make-symbol") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "symbol?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "string-set!") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "string-ref") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "string-length") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "string?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "make-string") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "vector-ref") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "vector-set!") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "vector-length") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "make-vector") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "vector?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "set-cdr!") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "set-car!") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "cdr") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "car") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "cons") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "pair?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fxremainder") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fxquotient") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fx*") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fx-") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fx+") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fx>=") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fx>") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fx<=") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fx<") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fx=") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "eof-object") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "eof-object?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f94289 0))) (closure () (f94289) (let () (vector-ref f94289 0))))
# emit-begin
#   expr=(begin (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "make-symbol") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "symbol?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "string-set!") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "string-ref") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "string-length") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "string?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "make-string") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "vector-ref") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "vector-set!") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "vector-length") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "make-vector") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "vector?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "set-cdr!") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "set-car!") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "cdr") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "car") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "cons") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "pair?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fxremainder") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fxquotient") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fx*") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fx-") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fx+") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fx>=") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fx>") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fx<=") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fx<") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fx=") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "eof-object") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "eof-object?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f94289 0))) (closure () (f94289) (let () (vector-ref f94289 0))))
#   env=((f94289 . 0))
# emit-expr (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "make-symbol") (vector-ref f94289 0)))
# emit-expr f94289
# emit-variable-ref
# env=((f94289 . 0))
# var=f94289
    movl 0(%esp), %eax  # stack load f94289
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_570841
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_570841:
    movl %eax, -4(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_570842"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_570842:
# check bounds on vector index
    movl -4(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_570844
    cmp  $0,%eax
    jge _L_570843
_L_570844:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_570843:
    movl %eax, -8(%esp)
# emit-expr (cons ((primitive-ref string->symbol) "make-symbol") (vector-ref f94289 0))
# cons arg1=((primitive-ref string->symbol) "make-symbol") arg2=(vector-ref f94289 0)
# emit-expr ((primitive-ref string->symbol) "make-symbol")
# funcall
#    si   =-12
#    env  = ((f94289 . 0))
#    expr = (funcall (primitive-ref string->symbol) "make-symbol")
# emit-expr (primitive-ref string->symbol)
    .extern mrc_string$m$gsymbol
    movl mrc_string$m$gsymbol,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_570845"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_570845":
   movl %eax,  -20(%esp)  # stash funcall-oper in closure slot
# emit-expr "make-symbol"
# string literal
    jmp _L_570847
    .align 8,0x90
_L_570846 :
    .int 44
    .ascii "make-symbol"
_L_570847:
    movl $_L_570846, %eax
    orl $6, %eax
    mov %eax, -24(%esp)  # arg make-symbol
    movl -20(%esp), %edi   # load new closure to %edi
    add $-12, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $12, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    movl %eax, -12(%esp)
# emit-expr (vector-ref f94289 0)
# emit-expr f94289
# emit-variable-ref
# env=((f94289 . 0))
# var=f94289
    movl 0(%esp), %eax  # stack load f94289
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_570848
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_570848:
    movl %eax, -16(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_570849"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_570849:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_570851
    cmp  $0,%eax
    jge _L_570850
_L_570851:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_570850:
    movl -16(%esp), %esi
    movl -1(%eax,%esi), %eax
    movl %eax, 4(%ebp)
    movl -12(%esp), %eax
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    or   $1, %al
    add  $8, %ebp
# cons end
    movl -4(%esp), %ebx
    movl -8(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "symbol?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "string-set!") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "string-ref") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "string-length") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "string?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "make-string") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "vector-ref") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "vector-set!") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "vector-length") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "make-vector") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "vector?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "set-cdr!") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "set-car!") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "cdr") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "car") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "cons") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "pair?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fxremainder") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fxquotient") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fx*") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fx-") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fx+") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fx>=") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fx>") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fx<=") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fx<") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fx=") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "eof-object") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "eof-object?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f94289 0))) (closure () (f94289) (let () (vector-ref f94289 0))))
# emit-begin
#   expr=(begin (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "symbol?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "string-set!") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "string-ref") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "string-length") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "string?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "make-string") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "vector-ref") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "vector-set!") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "vector-length") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "make-vector") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "vector?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "set-cdr!") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "set-car!") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "cdr") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "car") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "cons") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "pair?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fxremainder") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fxquotient") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fx*") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fx-") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fx+") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fx>=") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fx>") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fx<=") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fx<") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fx=") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "eof-object") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "eof-object?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f94289 0))) (closure () (f94289) (let () (vector-ref f94289 0))))
#   env=((f94289 . 0))
# emit-expr (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "symbol?") (vector-ref f94289 0)))
# emit-expr f94289
# emit-variable-ref
# env=((f94289 . 0))
# var=f94289
    movl 0(%esp), %eax  # stack load f94289
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_570852
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_570852:
    movl %eax, -4(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_570853"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_570853:
# check bounds on vector index
    movl -4(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_570855
    cmp  $0,%eax
    jge _L_570854
_L_570855:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_570854:
    movl %eax, -8(%esp)
# emit-expr (cons ((primitive-ref string->symbol) "symbol?") (vector-ref f94289 0))
# cons arg1=((primitive-ref string->symbol) "symbol?") arg2=(vector-ref f94289 0)
# emit-expr ((primitive-ref string->symbol) "symbol?")
# funcall
#    si   =-12
#    env  = ((f94289 . 0))
#    expr = (funcall (primitive-ref string->symbol) "symbol?")
# emit-expr (primitive-ref string->symbol)
    .extern mrc_string$m$gsymbol
    movl mrc_string$m$gsymbol,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_570856"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_570856":
   movl %eax,  -20(%esp)  # stash funcall-oper in closure slot
# emit-expr "symbol?"
# string literal
    jmp _L_570858
    .align 8,0x90
_L_570857 :
    .int 28
    .ascii "symbol?"
_L_570858:
    movl $_L_570857, %eax
    orl $6, %eax
    mov %eax, -24(%esp)  # arg symbol?
    movl -20(%esp), %edi   # load new closure to %edi
    add $-12, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $12, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    movl %eax, -12(%esp)
# emit-expr (vector-ref f94289 0)
# emit-expr f94289
# emit-variable-ref
# env=((f94289 . 0))
# var=f94289
    movl 0(%esp), %eax  # stack load f94289
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_570859
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_570859:
    movl %eax, -16(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_570860"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_570860:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_570862
    cmp  $0,%eax
    jge _L_570861
_L_570862:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_570861:
    movl -16(%esp), %esi
    movl -1(%eax,%esi), %eax
    movl %eax, 4(%ebp)
    movl -12(%esp), %eax
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    or   $1, %al
    add  $8, %ebp
# cons end
    movl -4(%esp), %ebx
    movl -8(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "string-set!") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "string-ref") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "string-length") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "string?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "make-string") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "vector-ref") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "vector-set!") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "vector-length") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "make-vector") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "vector?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "set-cdr!") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "set-car!") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "cdr") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "car") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "cons") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "pair?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fxremainder") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fxquotient") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fx*") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fx-") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fx+") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fx>=") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fx>") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fx<=") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fx<") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fx=") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "eof-object") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "eof-object?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f94289 0))) (closure () (f94289) (let () (vector-ref f94289 0))))
# emit-begin
#   expr=(begin (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "string-set!") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "string-ref") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "string-length") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "string?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "make-string") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "vector-ref") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "vector-set!") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "vector-length") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "make-vector") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "vector?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "set-cdr!") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "set-car!") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "cdr") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "car") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "cons") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "pair?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fxremainder") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fxquotient") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fx*") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fx-") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fx+") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fx>=") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fx>") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fx<=") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fx<") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fx=") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "eof-object") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "eof-object?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f94289 0))) (closure () (f94289) (let () (vector-ref f94289 0))))
#   env=((f94289 . 0))
# emit-expr (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "string-set!") (vector-ref f94289 0)))
# emit-expr f94289
# emit-variable-ref
# env=((f94289 . 0))
# var=f94289
    movl 0(%esp), %eax  # stack load f94289
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_570863
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_570863:
    movl %eax, -4(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_570864"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_570864:
# check bounds on vector index
    movl -4(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_570866
    cmp  $0,%eax
    jge _L_570865
_L_570866:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_570865:
    movl %eax, -8(%esp)
# emit-expr (cons ((primitive-ref string->symbol) "string-set!") (vector-ref f94289 0))
# cons arg1=((primitive-ref string->symbol) "string-set!") arg2=(vector-ref f94289 0)
# emit-expr ((primitive-ref string->symbol) "string-set!")
# funcall
#    si   =-12
#    env  = ((f94289 . 0))
#    expr = (funcall (primitive-ref string->symbol) "string-set!")
# emit-expr (primitive-ref string->symbol)
    .extern mrc_string$m$gsymbol
    movl mrc_string$m$gsymbol,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_570867"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_570867":
   movl %eax,  -20(%esp)  # stash funcall-oper in closure slot
# emit-expr "string-set!"
# string literal
    jmp _L_570869
    .align 8,0x90
_L_570868 :
    .int 44
    .ascii "string-set!"
_L_570869:
    movl $_L_570868, %eax
    orl $6, %eax
    mov %eax, -24(%esp)  # arg string-set!
    movl -20(%esp), %edi   # load new closure to %edi
    add $-12, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $12, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    movl %eax, -12(%esp)
# emit-expr (vector-ref f94289 0)
# emit-expr f94289
# emit-variable-ref
# env=((f94289 . 0))
# var=f94289
    movl 0(%esp), %eax  # stack load f94289
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_570870
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_570870:
    movl %eax, -16(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_570871"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_570871:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_570873
    cmp  $0,%eax
    jge _L_570872
_L_570873:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_570872:
    movl -16(%esp), %esi
    movl -1(%eax,%esi), %eax
    movl %eax, 4(%ebp)
    movl -12(%esp), %eax
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    or   $1, %al
    add  $8, %ebp
# cons end
    movl -4(%esp), %ebx
    movl -8(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "string-ref") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "string-length") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "string?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "make-string") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "vector-ref") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "vector-set!") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "vector-length") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "make-vector") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "vector?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "set-cdr!") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "set-car!") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "cdr") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "car") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "cons") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "pair?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fxremainder") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fxquotient") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fx*") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fx-") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fx+") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fx>=") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fx>") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fx<=") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fx<") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fx=") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "eof-object") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "eof-object?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f94289 0))) (closure () (f94289) (let () (vector-ref f94289 0))))
# emit-begin
#   expr=(begin (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "string-ref") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "string-length") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "string?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "make-string") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "vector-ref") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "vector-set!") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "vector-length") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "make-vector") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "vector?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "set-cdr!") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "set-car!") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "cdr") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "car") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "cons") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "pair?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fxremainder") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fxquotient") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fx*") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fx-") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fx+") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fx>=") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fx>") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fx<=") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fx<") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fx=") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "eof-object") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "eof-object?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f94289 0))) (closure () (f94289) (let () (vector-ref f94289 0))))
#   env=((f94289 . 0))
# emit-expr (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "string-ref") (vector-ref f94289 0)))
# emit-expr f94289
# emit-variable-ref
# env=((f94289 . 0))
# var=f94289
    movl 0(%esp), %eax  # stack load f94289
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_570874
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_570874:
    movl %eax, -4(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_570875"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_570875:
# check bounds on vector index
    movl -4(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_570877
    cmp  $0,%eax
    jge _L_570876
_L_570877:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_570876:
    movl %eax, -8(%esp)
# emit-expr (cons ((primitive-ref string->symbol) "string-ref") (vector-ref f94289 0))
# cons arg1=((primitive-ref string->symbol) "string-ref") arg2=(vector-ref f94289 0)
# emit-expr ((primitive-ref string->symbol) "string-ref")
# funcall
#    si   =-12
#    env  = ((f94289 . 0))
#    expr = (funcall (primitive-ref string->symbol) "string-ref")
# emit-expr (primitive-ref string->symbol)
    .extern mrc_string$m$gsymbol
    movl mrc_string$m$gsymbol,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_570878"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_570878":
   movl %eax,  -20(%esp)  # stash funcall-oper in closure slot
# emit-expr "string-ref"
# string literal
    jmp _L_570880
    .align 8,0x90
_L_570879 :
    .int 40
    .ascii "string-ref"
_L_570880:
    movl $_L_570879, %eax
    orl $6, %eax
    mov %eax, -24(%esp)  # arg string-ref
    movl -20(%esp), %edi   # load new closure to %edi
    add $-12, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $12, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    movl %eax, -12(%esp)
# emit-expr (vector-ref f94289 0)
# emit-expr f94289
# emit-variable-ref
# env=((f94289 . 0))
# var=f94289
    movl 0(%esp), %eax  # stack load f94289
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_570881
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_570881:
    movl %eax, -16(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_570882"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_570882:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_570884
    cmp  $0,%eax
    jge _L_570883
_L_570884:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_570883:
    movl -16(%esp), %esi
    movl -1(%eax,%esi), %eax
    movl %eax, 4(%ebp)
    movl -12(%esp), %eax
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    or   $1, %al
    add  $8, %ebp
# cons end
    movl -4(%esp), %ebx
    movl -8(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "string-length") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "string?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "make-string") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "vector-ref") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "vector-set!") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "vector-length") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "make-vector") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "vector?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "set-cdr!") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "set-car!") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "cdr") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "car") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "cons") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "pair?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fxremainder") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fxquotient") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fx*") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fx-") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fx+") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fx>=") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fx>") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fx<=") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fx<") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fx=") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "eof-object") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "eof-object?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f94289 0))) (closure () (f94289) (let () (vector-ref f94289 0))))
# emit-begin
#   expr=(begin (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "string-length") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "string?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "make-string") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "vector-ref") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "vector-set!") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "vector-length") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "make-vector") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "vector?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "set-cdr!") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "set-car!") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "cdr") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "car") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "cons") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "pair?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fxremainder") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fxquotient") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fx*") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fx-") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fx+") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fx>=") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fx>") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fx<=") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fx<") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fx=") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "eof-object") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "eof-object?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f94289 0))) (closure () (f94289) (let () (vector-ref f94289 0))))
#   env=((f94289 . 0))
# emit-expr (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "string-length") (vector-ref f94289 0)))
# emit-expr f94289
# emit-variable-ref
# env=((f94289 . 0))
# var=f94289
    movl 0(%esp), %eax  # stack load f94289
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_570885
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_570885:
    movl %eax, -4(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_570886"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_570886:
# check bounds on vector index
    movl -4(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_570888
    cmp  $0,%eax
    jge _L_570887
_L_570888:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_570887:
    movl %eax, -8(%esp)
# emit-expr (cons ((primitive-ref string->symbol) "string-length") (vector-ref f94289 0))
# cons arg1=((primitive-ref string->symbol) "string-length") arg2=(vector-ref f94289 0)
# emit-expr ((primitive-ref string->symbol) "string-length")
# funcall
#    si   =-12
#    env  = ((f94289 . 0))
#    expr = (funcall (primitive-ref string->symbol) "string-length")
# emit-expr (primitive-ref string->symbol)
    .extern mrc_string$m$gsymbol
    movl mrc_string$m$gsymbol,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_570889"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_570889":
   movl %eax,  -20(%esp)  # stash funcall-oper in closure slot
# emit-expr "string-length"
# string literal
    jmp _L_570891
    .align 8,0x90
_L_570890 :
    .int 52
    .ascii "string-length"
_L_570891:
    movl $_L_570890, %eax
    orl $6, %eax
    mov %eax, -24(%esp)  # arg string-length
    movl -20(%esp), %edi   # load new closure to %edi
    add $-12, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $12, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    movl %eax, -12(%esp)
# emit-expr (vector-ref f94289 0)
# emit-expr f94289
# emit-variable-ref
# env=((f94289 . 0))
# var=f94289
    movl 0(%esp), %eax  # stack load f94289
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_570892
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_570892:
    movl %eax, -16(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_570893"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_570893:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_570895
    cmp  $0,%eax
    jge _L_570894
_L_570895:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_570894:
    movl -16(%esp), %esi
    movl -1(%eax,%esi), %eax
    movl %eax, 4(%ebp)
    movl -12(%esp), %eax
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    or   $1, %al
    add  $8, %ebp
# cons end
    movl -4(%esp), %ebx
    movl -8(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "string?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "make-string") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "vector-ref") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "vector-set!") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "vector-length") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "make-vector") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "vector?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "set-cdr!") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "set-car!") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "cdr") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "car") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "cons") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "pair?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fxremainder") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fxquotient") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fx*") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fx-") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fx+") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fx>=") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fx>") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fx<=") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fx<") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fx=") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "eof-object") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "eof-object?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f94289 0))) (closure () (f94289) (let () (vector-ref f94289 0))))
# emit-begin
#   expr=(begin (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "string?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "make-string") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "vector-ref") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "vector-set!") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "vector-length") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "make-vector") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "vector?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "set-cdr!") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "set-car!") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "cdr") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "car") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "cons") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "pair?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fxremainder") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fxquotient") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fx*") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fx-") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fx+") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fx>=") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fx>") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fx<=") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fx<") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fx=") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "eof-object") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "eof-object?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f94289 0))) (closure () (f94289) (let () (vector-ref f94289 0))))
#   env=((f94289 . 0))
# emit-expr (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "string?") (vector-ref f94289 0)))
# emit-expr f94289
# emit-variable-ref
# env=((f94289 . 0))
# var=f94289
    movl 0(%esp), %eax  # stack load f94289
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_570896
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_570896:
    movl %eax, -4(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_570897"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_570897:
# check bounds on vector index
    movl -4(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_570899
    cmp  $0,%eax
    jge _L_570898
_L_570899:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_570898:
    movl %eax, -8(%esp)
# emit-expr (cons ((primitive-ref string->symbol) "string?") (vector-ref f94289 0))
# cons arg1=((primitive-ref string->symbol) "string?") arg2=(vector-ref f94289 0)
# emit-expr ((primitive-ref string->symbol) "string?")
# funcall
#    si   =-12
#    env  = ((f94289 . 0))
#    expr = (funcall (primitive-ref string->symbol) "string?")
# emit-expr (primitive-ref string->symbol)
    .extern mrc_string$m$gsymbol
    movl mrc_string$m$gsymbol,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_570900"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_570900":
   movl %eax,  -20(%esp)  # stash funcall-oper in closure slot
# emit-expr "string?"
# string literal
    jmp _L_570902
    .align 8,0x90
_L_570901 :
    .int 28
    .ascii "string?"
_L_570902:
    movl $_L_570901, %eax
    orl $6, %eax
    mov %eax, -24(%esp)  # arg string?
    movl -20(%esp), %edi   # load new closure to %edi
    add $-12, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $12, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    movl %eax, -12(%esp)
# emit-expr (vector-ref f94289 0)
# emit-expr f94289
# emit-variable-ref
# env=((f94289 . 0))
# var=f94289
    movl 0(%esp), %eax  # stack load f94289
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_570903
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_570903:
    movl %eax, -16(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_570904"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_570904:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_570906
    cmp  $0,%eax
    jge _L_570905
_L_570906:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_570905:
    movl -16(%esp), %esi
    movl -1(%eax,%esi), %eax
    movl %eax, 4(%ebp)
    movl -12(%esp), %eax
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    or   $1, %al
    add  $8, %ebp
# cons end
    movl -4(%esp), %ebx
    movl -8(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "make-string") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "vector-ref") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "vector-set!") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "vector-length") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "make-vector") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "vector?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "set-cdr!") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "set-car!") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "cdr") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "car") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "cons") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "pair?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fxremainder") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fxquotient") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fx*") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fx-") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fx+") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fx>=") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fx>") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fx<=") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fx<") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fx=") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "eof-object") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "eof-object?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f94289 0))) (closure () (f94289) (let () (vector-ref f94289 0))))
# emit-begin
#   expr=(begin (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "make-string") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "vector-ref") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "vector-set!") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "vector-length") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "make-vector") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "vector?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "set-cdr!") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "set-car!") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "cdr") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "car") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "cons") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "pair?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fxremainder") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fxquotient") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fx*") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fx-") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fx+") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fx>=") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fx>") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fx<=") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fx<") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fx=") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "eof-object") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "eof-object?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f94289 0))) (closure () (f94289) (let () (vector-ref f94289 0))))
#   env=((f94289 . 0))
# emit-expr (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "make-string") (vector-ref f94289 0)))
# emit-expr f94289
# emit-variable-ref
# env=((f94289 . 0))
# var=f94289
    movl 0(%esp), %eax  # stack load f94289
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_570907
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_570907:
    movl %eax, -4(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_570908"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_570908:
# check bounds on vector index
    movl -4(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_570910
    cmp  $0,%eax
    jge _L_570909
_L_570910:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_570909:
    movl %eax, -8(%esp)
# emit-expr (cons ((primitive-ref string->symbol) "make-string") (vector-ref f94289 0))
# cons arg1=((primitive-ref string->symbol) "make-string") arg2=(vector-ref f94289 0)
# emit-expr ((primitive-ref string->symbol) "make-string")
# funcall
#    si   =-12
#    env  = ((f94289 . 0))
#    expr = (funcall (primitive-ref string->symbol) "make-string")
# emit-expr (primitive-ref string->symbol)
    .extern mrc_string$m$gsymbol
    movl mrc_string$m$gsymbol,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_570911"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_570911":
   movl %eax,  -20(%esp)  # stash funcall-oper in closure slot
# emit-expr "make-string"
# string literal
    jmp _L_570913
    .align 8,0x90
_L_570912 :
    .int 44
    .ascii "make-string"
_L_570913:
    movl $_L_570912, %eax
    orl $6, %eax
    mov %eax, -24(%esp)  # arg make-string
    movl -20(%esp), %edi   # load new closure to %edi
    add $-12, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $12, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    movl %eax, -12(%esp)
# emit-expr (vector-ref f94289 0)
# emit-expr f94289
# emit-variable-ref
# env=((f94289 . 0))
# var=f94289
    movl 0(%esp), %eax  # stack load f94289
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_570914
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_570914:
    movl %eax, -16(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_570915"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_570915:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_570917
    cmp  $0,%eax
    jge _L_570916
_L_570917:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_570916:
    movl -16(%esp), %esi
    movl -1(%eax,%esi), %eax
    movl %eax, 4(%ebp)
    movl -12(%esp), %eax
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    or   $1, %al
    add  $8, %ebp
# cons end
    movl -4(%esp), %ebx
    movl -8(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "vector-ref") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "vector-set!") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "vector-length") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "make-vector") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "vector?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "set-cdr!") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "set-car!") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "cdr") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "car") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "cons") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "pair?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fxremainder") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fxquotient") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fx*") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fx-") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fx+") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fx>=") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fx>") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fx<=") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fx<") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fx=") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "eof-object") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "eof-object?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f94289 0))) (closure () (f94289) (let () (vector-ref f94289 0))))
# emit-begin
#   expr=(begin (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "vector-ref") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "vector-set!") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "vector-length") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "make-vector") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "vector?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "set-cdr!") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "set-car!") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "cdr") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "car") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "cons") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "pair?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fxremainder") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fxquotient") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fx*") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fx-") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fx+") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fx>=") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fx>") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fx<=") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fx<") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fx=") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "eof-object") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "eof-object?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f94289 0))) (closure () (f94289) (let () (vector-ref f94289 0))))
#   env=((f94289 . 0))
# emit-expr (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "vector-ref") (vector-ref f94289 0)))
# emit-expr f94289
# emit-variable-ref
# env=((f94289 . 0))
# var=f94289
    movl 0(%esp), %eax  # stack load f94289
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_570918
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_570918:
    movl %eax, -4(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_570919"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_570919:
# check bounds on vector index
    movl -4(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_570921
    cmp  $0,%eax
    jge _L_570920
_L_570921:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_570920:
    movl %eax, -8(%esp)
# emit-expr (cons ((primitive-ref string->symbol) "vector-ref") (vector-ref f94289 0))
# cons arg1=((primitive-ref string->symbol) "vector-ref") arg2=(vector-ref f94289 0)
# emit-expr ((primitive-ref string->symbol) "vector-ref")
# funcall
#    si   =-12
#    env  = ((f94289 . 0))
#    expr = (funcall (primitive-ref string->symbol) "vector-ref")
# emit-expr (primitive-ref string->symbol)
    .extern mrc_string$m$gsymbol
    movl mrc_string$m$gsymbol,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_570922"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_570922":
   movl %eax,  -20(%esp)  # stash funcall-oper in closure slot
# emit-expr "vector-ref"
# string literal
    jmp _L_570924
    .align 8,0x90
_L_570923 :
    .int 40
    .ascii "vector-ref"
_L_570924:
    movl $_L_570923, %eax
    orl $6, %eax
    mov %eax, -24(%esp)  # arg vector-ref
    movl -20(%esp), %edi   # load new closure to %edi
    add $-12, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $12, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    movl %eax, -12(%esp)
# emit-expr (vector-ref f94289 0)
# emit-expr f94289
# emit-variable-ref
# env=((f94289 . 0))
# var=f94289
    movl 0(%esp), %eax  # stack load f94289
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_570925
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_570925:
    movl %eax, -16(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_570926"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_570926:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_570928
    cmp  $0,%eax
    jge _L_570927
_L_570928:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_570927:
    movl -16(%esp), %esi
    movl -1(%eax,%esi), %eax
    movl %eax, 4(%ebp)
    movl -12(%esp), %eax
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    or   $1, %al
    add  $8, %ebp
# cons end
    movl -4(%esp), %ebx
    movl -8(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "vector-set!") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "vector-length") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "make-vector") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "vector?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "set-cdr!") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "set-car!") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "cdr") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "car") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "cons") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "pair?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fxremainder") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fxquotient") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fx*") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fx-") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fx+") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fx>=") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fx>") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fx<=") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fx<") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fx=") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "eof-object") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "eof-object?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f94289 0))) (closure () (f94289) (let () (vector-ref f94289 0))))
# emit-begin
#   expr=(begin (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "vector-set!") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "vector-length") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "make-vector") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "vector?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "set-cdr!") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "set-car!") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "cdr") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "car") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "cons") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "pair?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fxremainder") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fxquotient") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fx*") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fx-") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fx+") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fx>=") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fx>") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fx<=") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fx<") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fx=") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "eof-object") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "eof-object?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f94289 0))) (closure () (f94289) (let () (vector-ref f94289 0))))
#   env=((f94289 . 0))
# emit-expr (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "vector-set!") (vector-ref f94289 0)))
# emit-expr f94289
# emit-variable-ref
# env=((f94289 . 0))
# var=f94289
    movl 0(%esp), %eax  # stack load f94289
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_570929
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_570929:
    movl %eax, -4(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_570930"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_570930:
# check bounds on vector index
    movl -4(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_570932
    cmp  $0,%eax
    jge _L_570931
_L_570932:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_570931:
    movl %eax, -8(%esp)
# emit-expr (cons ((primitive-ref string->symbol) "vector-set!") (vector-ref f94289 0))
# cons arg1=((primitive-ref string->symbol) "vector-set!") arg2=(vector-ref f94289 0)
# emit-expr ((primitive-ref string->symbol) "vector-set!")
# funcall
#    si   =-12
#    env  = ((f94289 . 0))
#    expr = (funcall (primitive-ref string->symbol) "vector-set!")
# emit-expr (primitive-ref string->symbol)
    .extern mrc_string$m$gsymbol
    movl mrc_string$m$gsymbol,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_570933"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_570933":
   movl %eax,  -20(%esp)  # stash funcall-oper in closure slot
# emit-expr "vector-set!"
# string literal
    jmp _L_570935
    .align 8,0x90
_L_570934 :
    .int 44
    .ascii "vector-set!"
_L_570935:
    movl $_L_570934, %eax
    orl $6, %eax
    mov %eax, -24(%esp)  # arg vector-set!
    movl -20(%esp), %edi   # load new closure to %edi
    add $-12, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $12, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    movl %eax, -12(%esp)
# emit-expr (vector-ref f94289 0)
# emit-expr f94289
# emit-variable-ref
# env=((f94289 . 0))
# var=f94289
    movl 0(%esp), %eax  # stack load f94289
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_570936
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_570936:
    movl %eax, -16(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_570937"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_570937:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_570939
    cmp  $0,%eax
    jge _L_570938
_L_570939:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_570938:
    movl -16(%esp), %esi
    movl -1(%eax,%esi), %eax
    movl %eax, 4(%ebp)
    movl -12(%esp), %eax
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    or   $1, %al
    add  $8, %ebp
# cons end
    movl -4(%esp), %ebx
    movl -8(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "vector-length") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "make-vector") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "vector?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "set-cdr!") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "set-car!") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "cdr") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "car") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "cons") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "pair?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fxremainder") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fxquotient") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fx*") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fx-") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fx+") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fx>=") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fx>") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fx<=") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fx<") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fx=") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "eof-object") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "eof-object?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f94289 0))) (closure () (f94289) (let () (vector-ref f94289 0))))
# emit-begin
#   expr=(begin (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "vector-length") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "make-vector") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "vector?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "set-cdr!") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "set-car!") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "cdr") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "car") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "cons") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "pair?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fxremainder") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fxquotient") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fx*") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fx-") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fx+") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fx>=") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fx>") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fx<=") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fx<") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fx=") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "eof-object") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "eof-object?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f94289 0))) (closure () (f94289) (let () (vector-ref f94289 0))))
#   env=((f94289 . 0))
# emit-expr (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "vector-length") (vector-ref f94289 0)))
# emit-expr f94289
# emit-variable-ref
# env=((f94289 . 0))
# var=f94289
    movl 0(%esp), %eax  # stack load f94289
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_570940
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_570940:
    movl %eax, -4(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_570941"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_570941:
# check bounds on vector index
    movl -4(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_570943
    cmp  $0,%eax
    jge _L_570942
_L_570943:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_570942:
    movl %eax, -8(%esp)
# emit-expr (cons ((primitive-ref string->symbol) "vector-length") (vector-ref f94289 0))
# cons arg1=((primitive-ref string->symbol) "vector-length") arg2=(vector-ref f94289 0)
# emit-expr ((primitive-ref string->symbol) "vector-length")
# funcall
#    si   =-12
#    env  = ((f94289 . 0))
#    expr = (funcall (primitive-ref string->symbol) "vector-length")
# emit-expr (primitive-ref string->symbol)
    .extern mrc_string$m$gsymbol
    movl mrc_string$m$gsymbol,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_570944"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_570944":
   movl %eax,  -20(%esp)  # stash funcall-oper in closure slot
# emit-expr "vector-length"
# string literal
    jmp _L_570946
    .align 8,0x90
_L_570945 :
    .int 52
    .ascii "vector-length"
_L_570946:
    movl $_L_570945, %eax
    orl $6, %eax
    mov %eax, -24(%esp)  # arg vector-length
    movl -20(%esp), %edi   # load new closure to %edi
    add $-12, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $12, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    movl %eax, -12(%esp)
# emit-expr (vector-ref f94289 0)
# emit-expr f94289
# emit-variable-ref
# env=((f94289 . 0))
# var=f94289
    movl 0(%esp), %eax  # stack load f94289
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_570947
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_570947:
    movl %eax, -16(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_570948"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_570948:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_570950
    cmp  $0,%eax
    jge _L_570949
_L_570950:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_570949:
    movl -16(%esp), %esi
    movl -1(%eax,%esi), %eax
    movl %eax, 4(%ebp)
    movl -12(%esp), %eax
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    or   $1, %al
    add  $8, %ebp
# cons end
    movl -4(%esp), %ebx
    movl -8(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "make-vector") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "vector?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "set-cdr!") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "set-car!") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "cdr") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "car") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "cons") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "pair?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fxremainder") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fxquotient") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fx*") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fx-") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fx+") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fx>=") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fx>") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fx<=") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fx<") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fx=") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "eof-object") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "eof-object?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f94289 0))) (closure () (f94289) (let () (vector-ref f94289 0))))
# emit-begin
#   expr=(begin (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "make-vector") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "vector?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "set-cdr!") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "set-car!") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "cdr") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "car") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "cons") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "pair?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fxremainder") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fxquotient") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fx*") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fx-") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fx+") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fx>=") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fx>") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fx<=") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fx<") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fx=") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "eof-object") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "eof-object?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f94289 0))) (closure () (f94289) (let () (vector-ref f94289 0))))
#   env=((f94289 . 0))
# emit-expr (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "make-vector") (vector-ref f94289 0)))
# emit-expr f94289
# emit-variable-ref
# env=((f94289 . 0))
# var=f94289
    movl 0(%esp), %eax  # stack load f94289
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_570951
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_570951:
    movl %eax, -4(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_570952"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_570952:
# check bounds on vector index
    movl -4(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_570954
    cmp  $0,%eax
    jge _L_570953
_L_570954:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_570953:
    movl %eax, -8(%esp)
# emit-expr (cons ((primitive-ref string->symbol) "make-vector") (vector-ref f94289 0))
# cons arg1=((primitive-ref string->symbol) "make-vector") arg2=(vector-ref f94289 0)
# emit-expr ((primitive-ref string->symbol) "make-vector")
# funcall
#    si   =-12
#    env  = ((f94289 . 0))
#    expr = (funcall (primitive-ref string->symbol) "make-vector")
# emit-expr (primitive-ref string->symbol)
    .extern mrc_string$m$gsymbol
    movl mrc_string$m$gsymbol,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_570955"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_570955":
   movl %eax,  -20(%esp)  # stash funcall-oper in closure slot
# emit-expr "make-vector"
# string literal
    jmp _L_570957
    .align 8,0x90
_L_570956 :
    .int 44
    .ascii "make-vector"
_L_570957:
    movl $_L_570956, %eax
    orl $6, %eax
    mov %eax, -24(%esp)  # arg make-vector
    movl -20(%esp), %edi   # load new closure to %edi
    add $-12, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $12, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    movl %eax, -12(%esp)
# emit-expr (vector-ref f94289 0)
# emit-expr f94289
# emit-variable-ref
# env=((f94289 . 0))
# var=f94289
    movl 0(%esp), %eax  # stack load f94289
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_570958
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_570958:
    movl %eax, -16(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_570959"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_570959:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_570961
    cmp  $0,%eax
    jge _L_570960
_L_570961:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_570960:
    movl -16(%esp), %esi
    movl -1(%eax,%esi), %eax
    movl %eax, 4(%ebp)
    movl -12(%esp), %eax
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    or   $1, %al
    add  $8, %ebp
# cons end
    movl -4(%esp), %ebx
    movl -8(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "vector?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "set-cdr!") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "set-car!") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "cdr") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "car") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "cons") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "pair?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fxremainder") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fxquotient") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fx*") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fx-") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fx+") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fx>=") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fx>") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fx<=") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fx<") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fx=") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "eof-object") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "eof-object?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f94289 0))) (closure () (f94289) (let () (vector-ref f94289 0))))
# emit-begin
#   expr=(begin (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "vector?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "set-cdr!") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "set-car!") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "cdr") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "car") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "cons") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "pair?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fxremainder") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fxquotient") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fx*") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fx-") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fx+") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fx>=") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fx>") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fx<=") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fx<") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fx=") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "eof-object") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "eof-object?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f94289 0))) (closure () (f94289) (let () (vector-ref f94289 0))))
#   env=((f94289 . 0))
# emit-expr (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "vector?") (vector-ref f94289 0)))
# emit-expr f94289
# emit-variable-ref
# env=((f94289 . 0))
# var=f94289
    movl 0(%esp), %eax  # stack load f94289
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_570962
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_570962:
    movl %eax, -4(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_570963"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_570963:
# check bounds on vector index
    movl -4(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_570965
    cmp  $0,%eax
    jge _L_570964
_L_570965:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_570964:
    movl %eax, -8(%esp)
# emit-expr (cons ((primitive-ref string->symbol) "vector?") (vector-ref f94289 0))
# cons arg1=((primitive-ref string->symbol) "vector?") arg2=(vector-ref f94289 0)
# emit-expr ((primitive-ref string->symbol) "vector?")
# funcall
#    si   =-12
#    env  = ((f94289 . 0))
#    expr = (funcall (primitive-ref string->symbol) "vector?")
# emit-expr (primitive-ref string->symbol)
    .extern mrc_string$m$gsymbol
    movl mrc_string$m$gsymbol,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_570966"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_570966":
   movl %eax,  -20(%esp)  # stash funcall-oper in closure slot
# emit-expr "vector?"
# string literal
    jmp _L_570968
    .align 8,0x90
_L_570967 :
    .int 28
    .ascii "vector?"
_L_570968:
    movl $_L_570967, %eax
    orl $6, %eax
    mov %eax, -24(%esp)  # arg vector?
    movl -20(%esp), %edi   # load new closure to %edi
    add $-12, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $12, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    movl %eax, -12(%esp)
# emit-expr (vector-ref f94289 0)
# emit-expr f94289
# emit-variable-ref
# env=((f94289 . 0))
# var=f94289
    movl 0(%esp), %eax  # stack load f94289
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_570969
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_570969:
    movl %eax, -16(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_570970"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_570970:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_570972
    cmp  $0,%eax
    jge _L_570971
_L_570972:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_570971:
    movl -16(%esp), %esi
    movl -1(%eax,%esi), %eax
    movl %eax, 4(%ebp)
    movl -12(%esp), %eax
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    or   $1, %al
    add  $8, %ebp
# cons end
    movl -4(%esp), %ebx
    movl -8(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "set-cdr!") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "set-car!") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "cdr") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "car") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "cons") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "pair?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fxremainder") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fxquotient") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fx*") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fx-") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fx+") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fx>=") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fx>") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fx<=") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fx<") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fx=") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "eof-object") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "eof-object?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f94289 0))) (closure () (f94289) (let () (vector-ref f94289 0))))
# emit-begin
#   expr=(begin (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "set-cdr!") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "set-car!") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "cdr") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "car") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "cons") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "pair?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fxremainder") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fxquotient") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fx*") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fx-") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fx+") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fx>=") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fx>") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fx<=") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fx<") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fx=") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "eof-object") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "eof-object?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f94289 0))) (closure () (f94289) (let () (vector-ref f94289 0))))
#   env=((f94289 . 0))
# emit-expr (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "set-cdr!") (vector-ref f94289 0)))
# emit-expr f94289
# emit-variable-ref
# env=((f94289 . 0))
# var=f94289
    movl 0(%esp), %eax  # stack load f94289
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_570973
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_570973:
    movl %eax, -4(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_570974"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_570974:
# check bounds on vector index
    movl -4(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_570976
    cmp  $0,%eax
    jge _L_570975
_L_570976:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_570975:
    movl %eax, -8(%esp)
# emit-expr (cons ((primitive-ref string->symbol) "set-cdr!") (vector-ref f94289 0))
# cons arg1=((primitive-ref string->symbol) "set-cdr!") arg2=(vector-ref f94289 0)
# emit-expr ((primitive-ref string->symbol) "set-cdr!")
# funcall
#    si   =-12
#    env  = ((f94289 . 0))
#    expr = (funcall (primitive-ref string->symbol) "set-cdr!")
# emit-expr (primitive-ref string->symbol)
    .extern mrc_string$m$gsymbol
    movl mrc_string$m$gsymbol,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_570977"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_570977":
   movl %eax,  -20(%esp)  # stash funcall-oper in closure slot
# emit-expr "set-cdr!"
# string literal
    jmp _L_570979
    .align 8,0x90
_L_570978 :
    .int 32
    .ascii "set-cdr!"
_L_570979:
    movl $_L_570978, %eax
    orl $6, %eax
    mov %eax, -24(%esp)  # arg set-cdr!
    movl -20(%esp), %edi   # load new closure to %edi
    add $-12, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $12, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    movl %eax, -12(%esp)
# emit-expr (vector-ref f94289 0)
# emit-expr f94289
# emit-variable-ref
# env=((f94289 . 0))
# var=f94289
    movl 0(%esp), %eax  # stack load f94289
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_570980
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_570980:
    movl %eax, -16(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_570981"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_570981:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_570983
    cmp  $0,%eax
    jge _L_570982
_L_570983:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_570982:
    movl -16(%esp), %esi
    movl -1(%eax,%esi), %eax
    movl %eax, 4(%ebp)
    movl -12(%esp), %eax
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    or   $1, %al
    add  $8, %ebp
# cons end
    movl -4(%esp), %ebx
    movl -8(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "set-car!") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "cdr") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "car") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "cons") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "pair?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fxremainder") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fxquotient") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fx*") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fx-") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fx+") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fx>=") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fx>") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fx<=") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fx<") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fx=") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "eof-object") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "eof-object?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f94289 0))) (closure () (f94289) (let () (vector-ref f94289 0))))
# emit-begin
#   expr=(begin (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "set-car!") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "cdr") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "car") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "cons") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "pair?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fxremainder") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fxquotient") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fx*") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fx-") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fx+") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fx>=") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fx>") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fx<=") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fx<") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fx=") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "eof-object") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "eof-object?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f94289 0))) (closure () (f94289) (let () (vector-ref f94289 0))))
#   env=((f94289 . 0))
# emit-expr (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "set-car!") (vector-ref f94289 0)))
# emit-expr f94289
# emit-variable-ref
# env=((f94289 . 0))
# var=f94289
    movl 0(%esp), %eax  # stack load f94289
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_570984
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_570984:
    movl %eax, -4(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_570985"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_570985:
# check bounds on vector index
    movl -4(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_570987
    cmp  $0,%eax
    jge _L_570986
_L_570987:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_570986:
    movl %eax, -8(%esp)
# emit-expr (cons ((primitive-ref string->symbol) "set-car!") (vector-ref f94289 0))
# cons arg1=((primitive-ref string->symbol) "set-car!") arg2=(vector-ref f94289 0)
# emit-expr ((primitive-ref string->symbol) "set-car!")
# funcall
#    si   =-12
#    env  = ((f94289 . 0))
#    expr = (funcall (primitive-ref string->symbol) "set-car!")
# emit-expr (primitive-ref string->symbol)
    .extern mrc_string$m$gsymbol
    movl mrc_string$m$gsymbol,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_570988"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_570988":
   movl %eax,  -20(%esp)  # stash funcall-oper in closure slot
# emit-expr "set-car!"
# string literal
    jmp _L_570990
    .align 8,0x90
_L_570989 :
    .int 32
    .ascii "set-car!"
_L_570990:
    movl $_L_570989, %eax
    orl $6, %eax
    mov %eax, -24(%esp)  # arg set-car!
    movl -20(%esp), %edi   # load new closure to %edi
    add $-12, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $12, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    movl %eax, -12(%esp)
# emit-expr (vector-ref f94289 0)
# emit-expr f94289
# emit-variable-ref
# env=((f94289 . 0))
# var=f94289
    movl 0(%esp), %eax  # stack load f94289
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_570991
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_570991:
    movl %eax, -16(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_570992"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_570992:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_570994
    cmp  $0,%eax
    jge _L_570993
_L_570994:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_570993:
    movl -16(%esp), %esi
    movl -1(%eax,%esi), %eax
    movl %eax, 4(%ebp)
    movl -12(%esp), %eax
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    or   $1, %al
    add  $8, %ebp
# cons end
    movl -4(%esp), %ebx
    movl -8(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "cdr") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "car") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "cons") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "pair?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fxremainder") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fxquotient") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fx*") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fx-") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fx+") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fx>=") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fx>") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fx<=") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fx<") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fx=") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "eof-object") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "eof-object?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f94289 0))) (closure () (f94289) (let () (vector-ref f94289 0))))
# emit-begin
#   expr=(begin (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "cdr") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "car") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "cons") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "pair?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fxremainder") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fxquotient") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fx*") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fx-") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fx+") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fx>=") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fx>") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fx<=") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fx<") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fx=") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "eof-object") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "eof-object?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f94289 0))) (closure () (f94289) (let () (vector-ref f94289 0))))
#   env=((f94289 . 0))
# emit-expr (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "cdr") (vector-ref f94289 0)))
# emit-expr f94289
# emit-variable-ref
# env=((f94289 . 0))
# var=f94289
    movl 0(%esp), %eax  # stack load f94289
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_570995
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_570995:
    movl %eax, -4(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_570996"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_570996:
# check bounds on vector index
    movl -4(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_570998
    cmp  $0,%eax
    jge _L_570997
_L_570998:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_570997:
    movl %eax, -8(%esp)
# emit-expr (cons ((primitive-ref string->symbol) "cdr") (vector-ref f94289 0))
# cons arg1=((primitive-ref string->symbol) "cdr") arg2=(vector-ref f94289 0)
# emit-expr ((primitive-ref string->symbol) "cdr")
# funcall
#    si   =-12
#    env  = ((f94289 . 0))
#    expr = (funcall (primitive-ref string->symbol) "cdr")
# emit-expr (primitive-ref string->symbol)
    .extern mrc_string$m$gsymbol
    movl mrc_string$m$gsymbol,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_570999"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_570999":
   movl %eax,  -20(%esp)  # stash funcall-oper in closure slot
# emit-expr "cdr"
# string literal
    jmp _L_571001
    .align 8,0x90
_L_571000 :
    .int 12
    .ascii "cdr"
_L_571001:
    movl $_L_571000, %eax
    orl $6, %eax
    mov %eax, -24(%esp)  # arg cdr
    movl -20(%esp), %edi   # load new closure to %edi
    add $-12, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $12, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    movl %eax, -12(%esp)
# emit-expr (vector-ref f94289 0)
# emit-expr f94289
# emit-variable-ref
# env=((f94289 . 0))
# var=f94289
    movl 0(%esp), %eax  # stack load f94289
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_571002
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_571002:
    movl %eax, -16(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_571003"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_571003:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_571005
    cmp  $0,%eax
    jge _L_571004
_L_571005:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_571004:
    movl -16(%esp), %esi
    movl -1(%eax,%esi), %eax
    movl %eax, 4(%ebp)
    movl -12(%esp), %eax
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    or   $1, %al
    add  $8, %ebp
# cons end
    movl -4(%esp), %ebx
    movl -8(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "car") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "cons") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "pair?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fxremainder") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fxquotient") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fx*") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fx-") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fx+") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fx>=") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fx>") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fx<=") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fx<") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fx=") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "eof-object") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "eof-object?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f94289 0))) (closure () (f94289) (let () (vector-ref f94289 0))))
# emit-begin
#   expr=(begin (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "car") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "cons") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "pair?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fxremainder") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fxquotient") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fx*") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fx-") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fx+") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fx>=") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fx>") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fx<=") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fx<") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fx=") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "eof-object") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "eof-object?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f94289 0))) (closure () (f94289) (let () (vector-ref f94289 0))))
#   env=((f94289 . 0))
# emit-expr (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "car") (vector-ref f94289 0)))
# emit-expr f94289
# emit-variable-ref
# env=((f94289 . 0))
# var=f94289
    movl 0(%esp), %eax  # stack load f94289
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_571006
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_571006:
    movl %eax, -4(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_571007"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_571007:
# check bounds on vector index
    movl -4(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_571009
    cmp  $0,%eax
    jge _L_571008
_L_571009:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_571008:
    movl %eax, -8(%esp)
# emit-expr (cons ((primitive-ref string->symbol) "car") (vector-ref f94289 0))
# cons arg1=((primitive-ref string->symbol) "car") arg2=(vector-ref f94289 0)
# emit-expr ((primitive-ref string->symbol) "car")
# funcall
#    si   =-12
#    env  = ((f94289 . 0))
#    expr = (funcall (primitive-ref string->symbol) "car")
# emit-expr (primitive-ref string->symbol)
    .extern mrc_string$m$gsymbol
    movl mrc_string$m$gsymbol,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_571010"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_571010":
   movl %eax,  -20(%esp)  # stash funcall-oper in closure slot
# emit-expr "car"
# string literal
    jmp _L_571012
    .align 8,0x90
_L_571011 :
    .int 12
    .ascii "car"
_L_571012:
    movl $_L_571011, %eax
    orl $6, %eax
    mov %eax, -24(%esp)  # arg car
    movl -20(%esp), %edi   # load new closure to %edi
    add $-12, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $12, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    movl %eax, -12(%esp)
# emit-expr (vector-ref f94289 0)
# emit-expr f94289
# emit-variable-ref
# env=((f94289 . 0))
# var=f94289
    movl 0(%esp), %eax  # stack load f94289
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_571013
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_571013:
    movl %eax, -16(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_571014"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_571014:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_571016
    cmp  $0,%eax
    jge _L_571015
_L_571016:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_571015:
    movl -16(%esp), %esi
    movl -1(%eax,%esi), %eax
    movl %eax, 4(%ebp)
    movl -12(%esp), %eax
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    or   $1, %al
    add  $8, %ebp
# cons end
    movl -4(%esp), %ebx
    movl -8(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "cons") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "pair?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fxremainder") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fxquotient") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fx*") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fx-") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fx+") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fx>=") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fx>") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fx<=") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fx<") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fx=") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "eof-object") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "eof-object?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f94289 0))) (closure () (f94289) (let () (vector-ref f94289 0))))
# emit-begin
#   expr=(begin (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "cons") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "pair?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fxremainder") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fxquotient") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fx*") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fx-") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fx+") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fx>=") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fx>") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fx<=") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fx<") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fx=") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "eof-object") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "eof-object?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f94289 0))) (closure () (f94289) (let () (vector-ref f94289 0))))
#   env=((f94289 . 0))
# emit-expr (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "cons") (vector-ref f94289 0)))
# emit-expr f94289
# emit-variable-ref
# env=((f94289 . 0))
# var=f94289
    movl 0(%esp), %eax  # stack load f94289
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_571017
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_571017:
    movl %eax, -4(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_571018"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_571018:
# check bounds on vector index
    movl -4(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_571020
    cmp  $0,%eax
    jge _L_571019
_L_571020:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_571019:
    movl %eax, -8(%esp)
# emit-expr (cons ((primitive-ref string->symbol) "cons") (vector-ref f94289 0))
# cons arg1=((primitive-ref string->symbol) "cons") arg2=(vector-ref f94289 0)
# emit-expr ((primitive-ref string->symbol) "cons")
# funcall
#    si   =-12
#    env  = ((f94289 . 0))
#    expr = (funcall (primitive-ref string->symbol) "cons")
# emit-expr (primitive-ref string->symbol)
    .extern mrc_string$m$gsymbol
    movl mrc_string$m$gsymbol,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_571021"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_571021":
   movl %eax,  -20(%esp)  # stash funcall-oper in closure slot
# emit-expr "cons"
# string literal
    jmp _L_571023
    .align 8,0x90
_L_571022 :
    .int 16
    .ascii "cons"
_L_571023:
    movl $_L_571022, %eax
    orl $6, %eax
    mov %eax, -24(%esp)  # arg cons
    movl -20(%esp), %edi   # load new closure to %edi
    add $-12, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $12, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    movl %eax, -12(%esp)
# emit-expr (vector-ref f94289 0)
# emit-expr f94289
# emit-variable-ref
# env=((f94289 . 0))
# var=f94289
    movl 0(%esp), %eax  # stack load f94289
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_571024
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_571024:
    movl %eax, -16(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_571025"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_571025:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_571027
    cmp  $0,%eax
    jge _L_571026
_L_571027:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_571026:
    movl -16(%esp), %esi
    movl -1(%eax,%esi), %eax
    movl %eax, 4(%ebp)
    movl -12(%esp), %eax
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    or   $1, %al
    add  $8, %ebp
# cons end
    movl -4(%esp), %ebx
    movl -8(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "pair?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fxremainder") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fxquotient") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fx*") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fx-") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fx+") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fx>=") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fx>") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fx<=") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fx<") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fx=") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "eof-object") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "eof-object?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f94289 0))) (closure () (f94289) (let () (vector-ref f94289 0))))
# emit-begin
#   expr=(begin (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "pair?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fxremainder") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fxquotient") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fx*") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fx-") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fx+") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fx>=") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fx>") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fx<=") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fx<") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fx=") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "eof-object") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "eof-object?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f94289 0))) (closure () (f94289) (let () (vector-ref f94289 0))))
#   env=((f94289 . 0))
# emit-expr (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "pair?") (vector-ref f94289 0)))
# emit-expr f94289
# emit-variable-ref
# env=((f94289 . 0))
# var=f94289
    movl 0(%esp), %eax  # stack load f94289
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_571028
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_571028:
    movl %eax, -4(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_571029"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_571029:
# check bounds on vector index
    movl -4(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_571031
    cmp  $0,%eax
    jge _L_571030
_L_571031:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_571030:
    movl %eax, -8(%esp)
# emit-expr (cons ((primitive-ref string->symbol) "pair?") (vector-ref f94289 0))
# cons arg1=((primitive-ref string->symbol) "pair?") arg2=(vector-ref f94289 0)
# emit-expr ((primitive-ref string->symbol) "pair?")
# funcall
#    si   =-12
#    env  = ((f94289 . 0))
#    expr = (funcall (primitive-ref string->symbol) "pair?")
# emit-expr (primitive-ref string->symbol)
    .extern mrc_string$m$gsymbol
    movl mrc_string$m$gsymbol,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_571032"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_571032":
   movl %eax,  -20(%esp)  # stash funcall-oper in closure slot
# emit-expr "pair?"
# string literal
    jmp _L_571034
    .align 8,0x90
_L_571033 :
    .int 20
    .ascii "pair?"
_L_571034:
    movl $_L_571033, %eax
    orl $6, %eax
    mov %eax, -24(%esp)  # arg pair?
    movl -20(%esp), %edi   # load new closure to %edi
    add $-12, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $12, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    movl %eax, -12(%esp)
# emit-expr (vector-ref f94289 0)
# emit-expr f94289
# emit-variable-ref
# env=((f94289 . 0))
# var=f94289
    movl 0(%esp), %eax  # stack load f94289
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_571035
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_571035:
    movl %eax, -16(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_571036"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_571036:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_571038
    cmp  $0,%eax
    jge _L_571037
_L_571038:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_571037:
    movl -16(%esp), %esi
    movl -1(%eax,%esi), %eax
    movl %eax, 4(%ebp)
    movl -12(%esp), %eax
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    or   $1, %al
    add  $8, %ebp
# cons end
    movl -4(%esp), %ebx
    movl -8(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fxremainder") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fxquotient") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fx*") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fx-") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fx+") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fx>=") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fx>") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fx<=") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fx<") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fx=") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "eof-object") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "eof-object?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f94289 0))) (closure () (f94289) (let () (vector-ref f94289 0))))
# emit-begin
#   expr=(begin (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fxremainder") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fxquotient") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fx*") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fx-") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fx+") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fx>=") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fx>") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fx<=") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fx<") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fx=") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "eof-object") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "eof-object?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f94289 0))) (closure () (f94289) (let () (vector-ref f94289 0))))
#   env=((f94289 . 0))
# emit-expr (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fxremainder") (vector-ref f94289 0)))
# emit-expr f94289
# emit-variable-ref
# env=((f94289 . 0))
# var=f94289
    movl 0(%esp), %eax  # stack load f94289
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_571039
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_571039:
    movl %eax, -4(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_571040"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_571040:
# check bounds on vector index
    movl -4(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_571042
    cmp  $0,%eax
    jge _L_571041
_L_571042:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_571041:
    movl %eax, -8(%esp)
# emit-expr (cons ((primitive-ref string->symbol) "fxremainder") (vector-ref f94289 0))
# cons arg1=((primitive-ref string->symbol) "fxremainder") arg2=(vector-ref f94289 0)
# emit-expr ((primitive-ref string->symbol) "fxremainder")
# funcall
#    si   =-12
#    env  = ((f94289 . 0))
#    expr = (funcall (primitive-ref string->symbol) "fxremainder")
# emit-expr (primitive-ref string->symbol)
    .extern mrc_string$m$gsymbol
    movl mrc_string$m$gsymbol,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_571043"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_571043":
   movl %eax,  -20(%esp)  # stash funcall-oper in closure slot
# emit-expr "fxremainder"
# string literal
    jmp _L_571045
    .align 8,0x90
_L_571044 :
    .int 44
    .ascii "fxremainder"
_L_571045:
    movl $_L_571044, %eax
    orl $6, %eax
    mov %eax, -24(%esp)  # arg fxremainder
    movl -20(%esp), %edi   # load new closure to %edi
    add $-12, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $12, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    movl %eax, -12(%esp)
# emit-expr (vector-ref f94289 0)
# emit-expr f94289
# emit-variable-ref
# env=((f94289 . 0))
# var=f94289
    movl 0(%esp), %eax  # stack load f94289
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_571046
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_571046:
    movl %eax, -16(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_571047"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_571047:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_571049
    cmp  $0,%eax
    jge _L_571048
_L_571049:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_571048:
    movl -16(%esp), %esi
    movl -1(%eax,%esi), %eax
    movl %eax, 4(%ebp)
    movl -12(%esp), %eax
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    or   $1, %al
    add  $8, %ebp
# cons end
    movl -4(%esp), %ebx
    movl -8(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fxquotient") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fx*") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fx-") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fx+") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fx>=") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fx>") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fx<=") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fx<") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fx=") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "eof-object") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "eof-object?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f94289 0))) (closure () (f94289) (let () (vector-ref f94289 0))))
# emit-begin
#   expr=(begin (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fxquotient") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fx*") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fx-") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fx+") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fx>=") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fx>") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fx<=") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fx<") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fx=") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "eof-object") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "eof-object?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f94289 0))) (closure () (f94289) (let () (vector-ref f94289 0))))
#   env=((f94289 . 0))
# emit-expr (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fxquotient") (vector-ref f94289 0)))
# emit-expr f94289
# emit-variable-ref
# env=((f94289 . 0))
# var=f94289
    movl 0(%esp), %eax  # stack load f94289
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_571050
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_571050:
    movl %eax, -4(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_571051"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_571051:
# check bounds on vector index
    movl -4(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_571053
    cmp  $0,%eax
    jge _L_571052
_L_571053:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_571052:
    movl %eax, -8(%esp)
# emit-expr (cons ((primitive-ref string->symbol) "fxquotient") (vector-ref f94289 0))
# cons arg1=((primitive-ref string->symbol) "fxquotient") arg2=(vector-ref f94289 0)
# emit-expr ((primitive-ref string->symbol) "fxquotient")
# funcall
#    si   =-12
#    env  = ((f94289 . 0))
#    expr = (funcall (primitive-ref string->symbol) "fxquotient")
# emit-expr (primitive-ref string->symbol)
    .extern mrc_string$m$gsymbol
    movl mrc_string$m$gsymbol,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_571054"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_571054":
   movl %eax,  -20(%esp)  # stash funcall-oper in closure slot
# emit-expr "fxquotient"
# string literal
    jmp _L_571056
    .align 8,0x90
_L_571055 :
    .int 40
    .ascii "fxquotient"
_L_571056:
    movl $_L_571055, %eax
    orl $6, %eax
    mov %eax, -24(%esp)  # arg fxquotient
    movl -20(%esp), %edi   # load new closure to %edi
    add $-12, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $12, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    movl %eax, -12(%esp)
# emit-expr (vector-ref f94289 0)
# emit-expr f94289
# emit-variable-ref
# env=((f94289 . 0))
# var=f94289
    movl 0(%esp), %eax  # stack load f94289
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_571057
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_571057:
    movl %eax, -16(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_571058"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_571058:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_571060
    cmp  $0,%eax
    jge _L_571059
_L_571060:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_571059:
    movl -16(%esp), %esi
    movl -1(%eax,%esi), %eax
    movl %eax, 4(%ebp)
    movl -12(%esp), %eax
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    or   $1, %al
    add  $8, %ebp
# cons end
    movl -4(%esp), %ebx
    movl -8(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fx*") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fx-") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fx+") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fx>=") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fx>") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fx<=") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fx<") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fx=") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "eof-object") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "eof-object?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f94289 0))) (closure () (f94289) (let () (vector-ref f94289 0))))
# emit-begin
#   expr=(begin (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fx*") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fx-") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fx+") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fx>=") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fx>") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fx<=") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fx<") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fx=") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "eof-object") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "eof-object?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f94289 0))) (closure () (f94289) (let () (vector-ref f94289 0))))
#   env=((f94289 . 0))
# emit-expr (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fx*") (vector-ref f94289 0)))
# emit-expr f94289
# emit-variable-ref
# env=((f94289 . 0))
# var=f94289
    movl 0(%esp), %eax  # stack load f94289
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_571061
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_571061:
    movl %eax, -4(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_571062"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_571062:
# check bounds on vector index
    movl -4(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_571064
    cmp  $0,%eax
    jge _L_571063
_L_571064:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_571063:
    movl %eax, -8(%esp)
# emit-expr (cons ((primitive-ref string->symbol) "fx*") (vector-ref f94289 0))
# cons arg1=((primitive-ref string->symbol) "fx*") arg2=(vector-ref f94289 0)
# emit-expr ((primitive-ref string->symbol) "fx*")
# funcall
#    si   =-12
#    env  = ((f94289 . 0))
#    expr = (funcall (primitive-ref string->symbol) "fx*")
# emit-expr (primitive-ref string->symbol)
    .extern mrc_string$m$gsymbol
    movl mrc_string$m$gsymbol,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_571065"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_571065":
   movl %eax,  -20(%esp)  # stash funcall-oper in closure slot
# emit-expr "fx*"
# string literal
    jmp _L_571067
    .align 8,0x90
_L_571066 :
    .int 12
    .ascii "fx*"
_L_571067:
    movl $_L_571066, %eax
    orl $6, %eax
    mov %eax, -24(%esp)  # arg fx*
    movl -20(%esp), %edi   # load new closure to %edi
    add $-12, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $12, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    movl %eax, -12(%esp)
# emit-expr (vector-ref f94289 0)
# emit-expr f94289
# emit-variable-ref
# env=((f94289 . 0))
# var=f94289
    movl 0(%esp), %eax  # stack load f94289
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_571068
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_571068:
    movl %eax, -16(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_571069"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_571069:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_571071
    cmp  $0,%eax
    jge _L_571070
_L_571071:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_571070:
    movl -16(%esp), %esi
    movl -1(%eax,%esi), %eax
    movl %eax, 4(%ebp)
    movl -12(%esp), %eax
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    or   $1, %al
    add  $8, %ebp
# cons end
    movl -4(%esp), %ebx
    movl -8(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fx-") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fx+") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fx>=") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fx>") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fx<=") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fx<") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fx=") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "eof-object") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "eof-object?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f94289 0))) (closure () (f94289) (let () (vector-ref f94289 0))))
# emit-begin
#   expr=(begin (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fx-") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fx+") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fx>=") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fx>") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fx<=") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fx<") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fx=") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "eof-object") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "eof-object?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f94289 0))) (closure () (f94289) (let () (vector-ref f94289 0))))
#   env=((f94289 . 0))
# emit-expr (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fx-") (vector-ref f94289 0)))
# emit-expr f94289
# emit-variable-ref
# env=((f94289 . 0))
# var=f94289
    movl 0(%esp), %eax  # stack load f94289
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_571072
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_571072:
    movl %eax, -4(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_571073"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_571073:
# check bounds on vector index
    movl -4(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_571075
    cmp  $0,%eax
    jge _L_571074
_L_571075:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_571074:
    movl %eax, -8(%esp)
# emit-expr (cons ((primitive-ref string->symbol) "fx-") (vector-ref f94289 0))
# cons arg1=((primitive-ref string->symbol) "fx-") arg2=(vector-ref f94289 0)
# emit-expr ((primitive-ref string->symbol) "fx-")
# funcall
#    si   =-12
#    env  = ((f94289 . 0))
#    expr = (funcall (primitive-ref string->symbol) "fx-")
# emit-expr (primitive-ref string->symbol)
    .extern mrc_string$m$gsymbol
    movl mrc_string$m$gsymbol,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_571076"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_571076":
   movl %eax,  -20(%esp)  # stash funcall-oper in closure slot
# emit-expr "fx-"
# string literal
    jmp _L_571078
    .align 8,0x90
_L_571077 :
    .int 12
    .ascii "fx-"
_L_571078:
    movl $_L_571077, %eax
    orl $6, %eax
    mov %eax, -24(%esp)  # arg fx-
    movl -20(%esp), %edi   # load new closure to %edi
    add $-12, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $12, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    movl %eax, -12(%esp)
# emit-expr (vector-ref f94289 0)
# emit-expr f94289
# emit-variable-ref
# env=((f94289 . 0))
# var=f94289
    movl 0(%esp), %eax  # stack load f94289
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_571079
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_571079:
    movl %eax, -16(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_571080"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_571080:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_571082
    cmp  $0,%eax
    jge _L_571081
_L_571082:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_571081:
    movl -16(%esp), %esi
    movl -1(%eax,%esi), %eax
    movl %eax, 4(%ebp)
    movl -12(%esp), %eax
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    or   $1, %al
    add  $8, %ebp
# cons end
    movl -4(%esp), %ebx
    movl -8(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fx+") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fx>=") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fx>") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fx<=") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fx<") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fx=") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "eof-object") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "eof-object?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f94289 0))) (closure () (f94289) (let () (vector-ref f94289 0))))
# emit-begin
#   expr=(begin (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fx+") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fx>=") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fx>") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fx<=") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fx<") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fx=") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "eof-object") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "eof-object?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f94289 0))) (closure () (f94289) (let () (vector-ref f94289 0))))
#   env=((f94289 . 0))
# emit-expr (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fx+") (vector-ref f94289 0)))
# emit-expr f94289
# emit-variable-ref
# env=((f94289 . 0))
# var=f94289
    movl 0(%esp), %eax  # stack load f94289
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_571083
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_571083:
    movl %eax, -4(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_571084"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_571084:
# check bounds on vector index
    movl -4(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_571086
    cmp  $0,%eax
    jge _L_571085
_L_571086:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_571085:
    movl %eax, -8(%esp)
# emit-expr (cons ((primitive-ref string->symbol) "fx+") (vector-ref f94289 0))
# cons arg1=((primitive-ref string->symbol) "fx+") arg2=(vector-ref f94289 0)
# emit-expr ((primitive-ref string->symbol) "fx+")
# funcall
#    si   =-12
#    env  = ((f94289 . 0))
#    expr = (funcall (primitive-ref string->symbol) "fx+")
# emit-expr (primitive-ref string->symbol)
    .extern mrc_string$m$gsymbol
    movl mrc_string$m$gsymbol,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_571087"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_571087":
   movl %eax,  -20(%esp)  # stash funcall-oper in closure slot
# emit-expr "fx+"
# string literal
    jmp _L_571089
    .align 8,0x90
_L_571088 :
    .int 12
    .ascii "fx+"
_L_571089:
    movl $_L_571088, %eax
    orl $6, %eax
    mov %eax, -24(%esp)  # arg fx+
    movl -20(%esp), %edi   # load new closure to %edi
    add $-12, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $12, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    movl %eax, -12(%esp)
# emit-expr (vector-ref f94289 0)
# emit-expr f94289
# emit-variable-ref
# env=((f94289 . 0))
# var=f94289
    movl 0(%esp), %eax  # stack load f94289
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_571090
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_571090:
    movl %eax, -16(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_571091"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_571091:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_571093
    cmp  $0,%eax
    jge _L_571092
_L_571093:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_571092:
    movl -16(%esp), %esi
    movl -1(%eax,%esi), %eax
    movl %eax, 4(%ebp)
    movl -12(%esp), %eax
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    or   $1, %al
    add  $8, %ebp
# cons end
    movl -4(%esp), %ebx
    movl -8(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fx>=") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fx>") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fx<=") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fx<") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fx=") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "eof-object") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "eof-object?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f94289 0))) (closure () (f94289) (let () (vector-ref f94289 0))))
# emit-begin
#   expr=(begin (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fx>=") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fx>") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fx<=") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fx<") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fx=") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "eof-object") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "eof-object?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f94289 0))) (closure () (f94289) (let () (vector-ref f94289 0))))
#   env=((f94289 . 0))
# emit-expr (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fx>=") (vector-ref f94289 0)))
# emit-expr f94289
# emit-variable-ref
# env=((f94289 . 0))
# var=f94289
    movl 0(%esp), %eax  # stack load f94289
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_571094
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_571094:
    movl %eax, -4(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_571095"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_571095:
# check bounds on vector index
    movl -4(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_571097
    cmp  $0,%eax
    jge _L_571096
_L_571097:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_571096:
    movl %eax, -8(%esp)
# emit-expr (cons ((primitive-ref string->symbol) "fx>=") (vector-ref f94289 0))
# cons arg1=((primitive-ref string->symbol) "fx>=") arg2=(vector-ref f94289 0)
# emit-expr ((primitive-ref string->symbol) "fx>=")
# funcall
#    si   =-12
#    env  = ((f94289 . 0))
#    expr = (funcall (primitive-ref string->symbol) "fx>=")
# emit-expr (primitive-ref string->symbol)
    .extern mrc_string$m$gsymbol
    movl mrc_string$m$gsymbol,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_571098"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_571098":
   movl %eax,  -20(%esp)  # stash funcall-oper in closure slot
# emit-expr "fx>="
# string literal
    jmp _L_571100
    .align 8,0x90
_L_571099 :
    .int 16
    .ascii "fx>="
_L_571100:
    movl $_L_571099, %eax
    orl $6, %eax
    mov %eax, -24(%esp)  # arg fx>=
    movl -20(%esp), %edi   # load new closure to %edi
    add $-12, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $12, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    movl %eax, -12(%esp)
# emit-expr (vector-ref f94289 0)
# emit-expr f94289
# emit-variable-ref
# env=((f94289 . 0))
# var=f94289
    movl 0(%esp), %eax  # stack load f94289
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_571101
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_571101:
    movl %eax, -16(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_571102"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_571102:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_571104
    cmp  $0,%eax
    jge _L_571103
_L_571104:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_571103:
    movl -16(%esp), %esi
    movl -1(%eax,%esi), %eax
    movl %eax, 4(%ebp)
    movl -12(%esp), %eax
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    or   $1, %al
    add  $8, %ebp
# cons end
    movl -4(%esp), %ebx
    movl -8(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fx>") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fx<=") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fx<") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fx=") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "eof-object") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "eof-object?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f94289 0))) (closure () (f94289) (let () (vector-ref f94289 0))))
# emit-begin
#   expr=(begin (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fx>") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fx<=") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fx<") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fx=") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "eof-object") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "eof-object?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f94289 0))) (closure () (f94289) (let () (vector-ref f94289 0))))
#   env=((f94289 . 0))
# emit-expr (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fx>") (vector-ref f94289 0)))
# emit-expr f94289
# emit-variable-ref
# env=((f94289 . 0))
# var=f94289
    movl 0(%esp), %eax  # stack load f94289
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_571105
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_571105:
    movl %eax, -4(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_571106"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_571106:
# check bounds on vector index
    movl -4(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_571108
    cmp  $0,%eax
    jge _L_571107
_L_571108:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_571107:
    movl %eax, -8(%esp)
# emit-expr (cons ((primitive-ref string->symbol) "fx>") (vector-ref f94289 0))
# cons arg1=((primitive-ref string->symbol) "fx>") arg2=(vector-ref f94289 0)
# emit-expr ((primitive-ref string->symbol) "fx>")
# funcall
#    si   =-12
#    env  = ((f94289 . 0))
#    expr = (funcall (primitive-ref string->symbol) "fx>")
# emit-expr (primitive-ref string->symbol)
    .extern mrc_string$m$gsymbol
    movl mrc_string$m$gsymbol,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_571109"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_571109":
   movl %eax,  -20(%esp)  # stash funcall-oper in closure slot
# emit-expr "fx>"
# string literal
    jmp _L_571111
    .align 8,0x90
_L_571110 :
    .int 12
    .ascii "fx>"
_L_571111:
    movl $_L_571110, %eax
    orl $6, %eax
    mov %eax, -24(%esp)  # arg fx>
    movl -20(%esp), %edi   # load new closure to %edi
    add $-12, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $12, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    movl %eax, -12(%esp)
# emit-expr (vector-ref f94289 0)
# emit-expr f94289
# emit-variable-ref
# env=((f94289 . 0))
# var=f94289
    movl 0(%esp), %eax  # stack load f94289
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_571112
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_571112:
    movl %eax, -16(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_571113"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_571113:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_571115
    cmp  $0,%eax
    jge _L_571114
_L_571115:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_571114:
    movl -16(%esp), %esi
    movl -1(%eax,%esi), %eax
    movl %eax, 4(%ebp)
    movl -12(%esp), %eax
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    or   $1, %al
    add  $8, %ebp
# cons end
    movl -4(%esp), %ebx
    movl -8(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fx<=") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fx<") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fx=") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "eof-object") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "eof-object?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f94289 0))) (closure () (f94289) (let () (vector-ref f94289 0))))
# emit-begin
#   expr=(begin (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fx<=") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fx<") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fx=") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "eof-object") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "eof-object?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f94289 0))) (closure () (f94289) (let () (vector-ref f94289 0))))
#   env=((f94289 . 0))
# emit-expr (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fx<=") (vector-ref f94289 0)))
# emit-expr f94289
# emit-variable-ref
# env=((f94289 . 0))
# var=f94289
    movl 0(%esp), %eax  # stack load f94289
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_571116
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_571116:
    movl %eax, -4(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_571117"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_571117:
# check bounds on vector index
    movl -4(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_571119
    cmp  $0,%eax
    jge _L_571118
_L_571119:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_571118:
    movl %eax, -8(%esp)
# emit-expr (cons ((primitive-ref string->symbol) "fx<=") (vector-ref f94289 0))
# cons arg1=((primitive-ref string->symbol) "fx<=") arg2=(vector-ref f94289 0)
# emit-expr ((primitive-ref string->symbol) "fx<=")
# funcall
#    si   =-12
#    env  = ((f94289 . 0))
#    expr = (funcall (primitive-ref string->symbol) "fx<=")
# emit-expr (primitive-ref string->symbol)
    .extern mrc_string$m$gsymbol
    movl mrc_string$m$gsymbol,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_571120"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_571120":
   movl %eax,  -20(%esp)  # stash funcall-oper in closure slot
# emit-expr "fx<="
# string literal
    jmp _L_571122
    .align 8,0x90
_L_571121 :
    .int 16
    .ascii "fx<="
_L_571122:
    movl $_L_571121, %eax
    orl $6, %eax
    mov %eax, -24(%esp)  # arg fx<=
    movl -20(%esp), %edi   # load new closure to %edi
    add $-12, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $12, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    movl %eax, -12(%esp)
# emit-expr (vector-ref f94289 0)
# emit-expr f94289
# emit-variable-ref
# env=((f94289 . 0))
# var=f94289
    movl 0(%esp), %eax  # stack load f94289
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_571123
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_571123:
    movl %eax, -16(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_571124"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_571124:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_571126
    cmp  $0,%eax
    jge _L_571125
_L_571126:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_571125:
    movl -16(%esp), %esi
    movl -1(%eax,%esi), %eax
    movl %eax, 4(%ebp)
    movl -12(%esp), %eax
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    or   $1, %al
    add  $8, %ebp
# cons end
    movl -4(%esp), %ebx
    movl -8(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fx<") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fx=") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "eof-object") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "eof-object?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f94289 0))) (closure () (f94289) (let () (vector-ref f94289 0))))
# emit-begin
#   expr=(begin (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fx<") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fx=") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "eof-object") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "eof-object?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f94289 0))) (closure () (f94289) (let () (vector-ref f94289 0))))
#   env=((f94289 . 0))
# emit-expr (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fx<") (vector-ref f94289 0)))
# emit-expr f94289
# emit-variable-ref
# env=((f94289 . 0))
# var=f94289
    movl 0(%esp), %eax  # stack load f94289
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_571127
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_571127:
    movl %eax, -4(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_571128"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_571128:
# check bounds on vector index
    movl -4(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_571130
    cmp  $0,%eax
    jge _L_571129
_L_571130:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_571129:
    movl %eax, -8(%esp)
# emit-expr (cons ((primitive-ref string->symbol) "fx<") (vector-ref f94289 0))
# cons arg1=((primitive-ref string->symbol) "fx<") arg2=(vector-ref f94289 0)
# emit-expr ((primitive-ref string->symbol) "fx<")
# funcall
#    si   =-12
#    env  = ((f94289 . 0))
#    expr = (funcall (primitive-ref string->symbol) "fx<")
# emit-expr (primitive-ref string->symbol)
    .extern mrc_string$m$gsymbol
    movl mrc_string$m$gsymbol,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_571131"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_571131":
   movl %eax,  -20(%esp)  # stash funcall-oper in closure slot
# emit-expr "fx<"
# string literal
    jmp _L_571133
    .align 8,0x90
_L_571132 :
    .int 12
    .ascii "fx<"
_L_571133:
    movl $_L_571132, %eax
    orl $6, %eax
    mov %eax, -24(%esp)  # arg fx<
    movl -20(%esp), %edi   # load new closure to %edi
    add $-12, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $12, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    movl %eax, -12(%esp)
# emit-expr (vector-ref f94289 0)
# emit-expr f94289
# emit-variable-ref
# env=((f94289 . 0))
# var=f94289
    movl 0(%esp), %eax  # stack load f94289
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_571134
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_571134:
    movl %eax, -16(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_571135"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_571135:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_571137
    cmp  $0,%eax
    jge _L_571136
_L_571137:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_571136:
    movl -16(%esp), %esi
    movl -1(%eax,%esi), %eax
    movl %eax, 4(%ebp)
    movl -12(%esp), %eax
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    or   $1, %al
    add  $8, %ebp
# cons end
    movl -4(%esp), %ebx
    movl -8(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fx=") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "eof-object") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "eof-object?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f94289 0))) (closure () (f94289) (let () (vector-ref f94289 0))))
# emit-begin
#   expr=(begin (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fx=") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "eof-object") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "eof-object?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f94289 0))) (closure () (f94289) (let () (vector-ref f94289 0))))
#   env=((f94289 . 0))
# emit-expr (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fx=") (vector-ref f94289 0)))
# emit-expr f94289
# emit-variable-ref
# env=((f94289 . 0))
# var=f94289
    movl 0(%esp), %eax  # stack load f94289
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_571138
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_571138:
    movl %eax, -4(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_571139"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_571139:
# check bounds on vector index
    movl -4(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_571141
    cmp  $0,%eax
    jge _L_571140
_L_571141:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_571140:
    movl %eax, -8(%esp)
# emit-expr (cons ((primitive-ref string->symbol) "fx=") (vector-ref f94289 0))
# cons arg1=((primitive-ref string->symbol) "fx=") arg2=(vector-ref f94289 0)
# emit-expr ((primitive-ref string->symbol) "fx=")
# funcall
#    si   =-12
#    env  = ((f94289 . 0))
#    expr = (funcall (primitive-ref string->symbol) "fx=")
# emit-expr (primitive-ref string->symbol)
    .extern mrc_string$m$gsymbol
    movl mrc_string$m$gsymbol,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_571142"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_571142":
   movl %eax,  -20(%esp)  # stash funcall-oper in closure slot
# emit-expr "fx="
# string literal
    jmp _L_571144
    .align 8,0x90
_L_571143 :
    .int 12
    .ascii "fx="
_L_571144:
    movl $_L_571143, %eax
    orl $6, %eax
    mov %eax, -24(%esp)  # arg fx=
    movl -20(%esp), %edi   # load new closure to %edi
    add $-12, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $12, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    movl %eax, -12(%esp)
# emit-expr (vector-ref f94289 0)
# emit-expr f94289
# emit-variable-ref
# env=((f94289 . 0))
# var=f94289
    movl 0(%esp), %eax  # stack load f94289
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_571145
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_571145:
    movl %eax, -16(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_571146"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_571146:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_571148
    cmp  $0,%eax
    jge _L_571147
_L_571148:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_571147:
    movl -16(%esp), %esi
    movl -1(%eax,%esi), %eax
    movl %eax, 4(%ebp)
    movl -12(%esp), %eax
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    or   $1, %al
    add  $8, %ebp
# cons end
    movl -4(%esp), %ebx
    movl -8(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "eof-object") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "eof-object?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f94289 0))) (closure () (f94289) (let () (vector-ref f94289 0))))
# emit-begin
#   expr=(begin (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "eof-object") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "eof-object?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f94289 0))) (closure () (f94289) (let () (vector-ref f94289 0))))
#   env=((f94289 . 0))
# emit-expr (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f94289 0)))
# emit-expr f94289
# emit-variable-ref
# env=((f94289 . 0))
# var=f94289
    movl 0(%esp), %eax  # stack load f94289
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_571149
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_571149:
    movl %eax, -4(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_571150"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_571150:
# check bounds on vector index
    movl -4(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_571152
    cmp  $0,%eax
    jge _L_571151
_L_571152:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_571151:
    movl %eax, -8(%esp)
# emit-expr (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f94289 0))
# cons arg1=((primitive-ref string->symbol) "fxzero?") arg2=(vector-ref f94289 0)
# emit-expr ((primitive-ref string->symbol) "fxzero?")
# funcall
#    si   =-12
#    env  = ((f94289 . 0))
#    expr = (funcall (primitive-ref string->symbol) "fxzero?")
# emit-expr (primitive-ref string->symbol)
    .extern mrc_string$m$gsymbol
    movl mrc_string$m$gsymbol,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_571153"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_571153":
   movl %eax,  -20(%esp)  # stash funcall-oper in closure slot
# emit-expr "fxzero?"
# string literal
    jmp _L_571155
    .align 8,0x90
_L_571154 :
    .int 28
    .ascii "fxzero?"
_L_571155:
    movl $_L_571154, %eax
    orl $6, %eax
    mov %eax, -24(%esp)  # arg fxzero?
    movl -20(%esp), %edi   # load new closure to %edi
    add $-12, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $12, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    movl %eax, -12(%esp)
# emit-expr (vector-ref f94289 0)
# emit-expr f94289
# emit-variable-ref
# env=((f94289 . 0))
# var=f94289
    movl 0(%esp), %eax  # stack load f94289
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_571156
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_571156:
    movl %eax, -16(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_571157"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_571157:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_571159
    cmp  $0,%eax
    jge _L_571158
_L_571159:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_571158:
    movl -16(%esp), %esi
    movl -1(%eax,%esi), %eax
    movl %eax, 4(%ebp)
    movl -12(%esp), %eax
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    or   $1, %al
    add  $8, %ebp
# cons end
    movl -4(%esp), %ebx
    movl -8(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "eof-object") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "eof-object?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f94289 0))) (closure () (f94289) (let () (vector-ref f94289 0))))
# emit-begin
#   expr=(begin (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "eof-object") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "eof-object?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f94289 0))) (closure () (f94289) (let () (vector-ref f94289 0))))
#   env=((f94289 . 0))
# emit-expr (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f94289 0)))
# emit-expr f94289
# emit-variable-ref
# env=((f94289 . 0))
# var=f94289
    movl 0(%esp), %eax  # stack load f94289
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_571160
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_571160:
    movl %eax, -4(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_571161"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_571161:
# check bounds on vector index
    movl -4(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_571163
    cmp  $0,%eax
    jge _L_571162
_L_571163:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_571162:
    movl %eax, -8(%esp)
# emit-expr (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f94289 0))
# cons arg1=((primitive-ref string->symbol) "fxsub1") arg2=(vector-ref f94289 0)
# emit-expr ((primitive-ref string->symbol) "fxsub1")
# funcall
#    si   =-12
#    env  = ((f94289 . 0))
#    expr = (funcall (primitive-ref string->symbol) "fxsub1")
# emit-expr (primitive-ref string->symbol)
    .extern mrc_string$m$gsymbol
    movl mrc_string$m$gsymbol,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_571164"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_571164":
   movl %eax,  -20(%esp)  # stash funcall-oper in closure slot
# emit-expr "fxsub1"
# string literal
    jmp _L_571166
    .align 8,0x90
_L_571165 :
    .int 24
    .ascii "fxsub1"
_L_571166:
    movl $_L_571165, %eax
    orl $6, %eax
    mov %eax, -24(%esp)  # arg fxsub1
    movl -20(%esp), %edi   # load new closure to %edi
    add $-12, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $12, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    movl %eax, -12(%esp)
# emit-expr (vector-ref f94289 0)
# emit-expr f94289
# emit-variable-ref
# env=((f94289 . 0))
# var=f94289
    movl 0(%esp), %eax  # stack load f94289
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_571167
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_571167:
    movl %eax, -16(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_571168"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_571168:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_571170
    cmp  $0,%eax
    jge _L_571169
_L_571170:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_571169:
    movl -16(%esp), %esi
    movl -1(%eax,%esi), %eax
    movl %eax, 4(%ebp)
    movl -12(%esp), %eax
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    or   $1, %al
    add  $8, %ebp
# cons end
    movl -4(%esp), %ebx
    movl -8(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "eof-object") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "eof-object?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f94289 0))) (closure () (f94289) (let () (vector-ref f94289 0))))
# emit-begin
#   expr=(begin (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "eof-object") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "eof-object?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f94289 0))) (closure () (f94289) (let () (vector-ref f94289 0))))
#   env=((f94289 . 0))
# emit-expr (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f94289 0)))
# emit-expr f94289
# emit-variable-ref
# env=((f94289 . 0))
# var=f94289
    movl 0(%esp), %eax  # stack load f94289
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_571171
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_571171:
    movl %eax, -4(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_571172"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_571172:
# check bounds on vector index
    movl -4(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_571174
    cmp  $0,%eax
    jge _L_571173
_L_571174:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_571173:
    movl %eax, -8(%esp)
# emit-expr (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f94289 0))
# cons arg1=((primitive-ref string->symbol) "fxadd1") arg2=(vector-ref f94289 0)
# emit-expr ((primitive-ref string->symbol) "fxadd1")
# funcall
#    si   =-12
#    env  = ((f94289 . 0))
#    expr = (funcall (primitive-ref string->symbol) "fxadd1")
# emit-expr (primitive-ref string->symbol)
    .extern mrc_string$m$gsymbol
    movl mrc_string$m$gsymbol,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_571175"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_571175":
   movl %eax,  -20(%esp)  # stash funcall-oper in closure slot
# emit-expr "fxadd1"
# string literal
    jmp _L_571177
    .align 8,0x90
_L_571176 :
    .int 24
    .ascii "fxadd1"
_L_571177:
    movl $_L_571176, %eax
    orl $6, %eax
    mov %eax, -24(%esp)  # arg fxadd1
    movl -20(%esp), %edi   # load new closure to %edi
    add $-12, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $12, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    movl %eax, -12(%esp)
# emit-expr (vector-ref f94289 0)
# emit-expr f94289
# emit-variable-ref
# env=((f94289 . 0))
# var=f94289
    movl 0(%esp), %eax  # stack load f94289
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_571178
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_571178:
    movl %eax, -16(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_571179"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_571179:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_571181
    cmp  $0,%eax
    jge _L_571180
_L_571181:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_571180:
    movl -16(%esp), %esi
    movl -1(%eax,%esi), %eax
    movl %eax, 4(%ebp)
    movl -12(%esp), %eax
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    or   $1, %al
    add  $8, %ebp
# cons end
    movl -4(%esp), %ebx
    movl -8(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "eof-object") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "eof-object?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f94289 0))) (closure () (f94289) (let () (vector-ref f94289 0))))
# emit-begin
#   expr=(begin (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "eof-object") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "eof-object?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f94289 0))) (closure () (f94289) (let () (vector-ref f94289 0))))
#   env=((f94289 . 0))
# emit-expr (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f94289 0)))
# emit-expr f94289
# emit-variable-ref
# env=((f94289 . 0))
# var=f94289
    movl 0(%esp), %eax  # stack load f94289
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_571182
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_571182:
    movl %eax, -4(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_571183"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_571183:
# check bounds on vector index
    movl -4(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_571185
    cmp  $0,%eax
    jge _L_571184
_L_571185:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_571184:
    movl %eax, -8(%esp)
# emit-expr (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f94289 0))
# cons arg1=((primitive-ref string->symbol) "fxlogor") arg2=(vector-ref f94289 0)
# emit-expr ((primitive-ref string->symbol) "fxlogor")
# funcall
#    si   =-12
#    env  = ((f94289 . 0))
#    expr = (funcall (primitive-ref string->symbol) "fxlogor")
# emit-expr (primitive-ref string->symbol)
    .extern mrc_string$m$gsymbol
    movl mrc_string$m$gsymbol,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_571186"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_571186":
   movl %eax,  -20(%esp)  # stash funcall-oper in closure slot
# emit-expr "fxlogor"
# string literal
    jmp _L_571188
    .align 8,0x90
_L_571187 :
    .int 28
    .ascii "fxlogor"
_L_571188:
    movl $_L_571187, %eax
    orl $6, %eax
    mov %eax, -24(%esp)  # arg fxlogor
    movl -20(%esp), %edi   # load new closure to %edi
    add $-12, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $12, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    movl %eax, -12(%esp)
# emit-expr (vector-ref f94289 0)
# emit-expr f94289
# emit-variable-ref
# env=((f94289 . 0))
# var=f94289
    movl 0(%esp), %eax  # stack load f94289
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_571189
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_571189:
    movl %eax, -16(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_571190"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_571190:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_571192
    cmp  $0,%eax
    jge _L_571191
_L_571192:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_571191:
    movl -16(%esp), %esi
    movl -1(%eax,%esi), %eax
    movl %eax, 4(%ebp)
    movl -12(%esp), %eax
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    or   $1, %al
    add  $8, %ebp
# cons end
    movl -4(%esp), %ebx
    movl -8(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "eof-object") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "eof-object?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f94289 0))) (closure () (f94289) (let () (vector-ref f94289 0))))
# emit-begin
#   expr=(begin (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "eof-object") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "eof-object?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f94289 0))) (closure () (f94289) (let () (vector-ref f94289 0))))
#   env=((f94289 . 0))
# emit-expr (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f94289 0)))
# emit-expr f94289
# emit-variable-ref
# env=((f94289 . 0))
# var=f94289
    movl 0(%esp), %eax  # stack load f94289
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_571193
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_571193:
    movl %eax, -4(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_571194"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_571194:
# check bounds on vector index
    movl -4(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_571196
    cmp  $0,%eax
    jge _L_571195
_L_571196:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_571195:
    movl %eax, -8(%esp)
# emit-expr (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f94289 0))
# cons arg1=((primitive-ref string->symbol) "fxlogand") arg2=(vector-ref f94289 0)
# emit-expr ((primitive-ref string->symbol) "fxlogand")
# funcall
#    si   =-12
#    env  = ((f94289 . 0))
#    expr = (funcall (primitive-ref string->symbol) "fxlogand")
# emit-expr (primitive-ref string->symbol)
    .extern mrc_string$m$gsymbol
    movl mrc_string$m$gsymbol,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_571197"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_571197":
   movl %eax,  -20(%esp)  # stash funcall-oper in closure slot
# emit-expr "fxlogand"
# string literal
    jmp _L_571199
    .align 8,0x90
_L_571198 :
    .int 32
    .ascii "fxlogand"
_L_571199:
    movl $_L_571198, %eax
    orl $6, %eax
    mov %eax, -24(%esp)  # arg fxlogand
    movl -20(%esp), %edi   # load new closure to %edi
    add $-12, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $12, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    movl %eax, -12(%esp)
# emit-expr (vector-ref f94289 0)
# emit-expr f94289
# emit-variable-ref
# env=((f94289 . 0))
# var=f94289
    movl 0(%esp), %eax  # stack load f94289
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_571200
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_571200:
    movl %eax, -16(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_571201"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_571201:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_571203
    cmp  $0,%eax
    jge _L_571202
_L_571203:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_571202:
    movl -16(%esp), %esi
    movl -1(%eax,%esi), %eax
    movl %eax, 4(%ebp)
    movl -12(%esp), %eax
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    or   $1, %al
    add  $8, %ebp
# cons end
    movl -4(%esp), %ebx
    movl -8(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "eof-object") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "eof-object?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f94289 0))) (closure () (f94289) (let () (vector-ref f94289 0))))
# emit-begin
#   expr=(begin (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "eof-object") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "eof-object?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f94289 0))) (closure () (f94289) (let () (vector-ref f94289 0))))
#   env=((f94289 . 0))
# emit-expr (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f94289 0)))
# emit-expr f94289
# emit-variable-ref
# env=((f94289 . 0))
# var=f94289
    movl 0(%esp), %eax  # stack load f94289
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_571204
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_571204:
    movl %eax, -4(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_571205"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_571205:
# check bounds on vector index
    movl -4(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_571207
    cmp  $0,%eax
    jge _L_571206
_L_571207:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_571206:
    movl %eax, -8(%esp)
# emit-expr (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f94289 0))
# cons arg1=((primitive-ref string->symbol) "fxlognot") arg2=(vector-ref f94289 0)
# emit-expr ((primitive-ref string->symbol) "fxlognot")
# funcall
#    si   =-12
#    env  = ((f94289 . 0))
#    expr = (funcall (primitive-ref string->symbol) "fxlognot")
# emit-expr (primitive-ref string->symbol)
    .extern mrc_string$m$gsymbol
    movl mrc_string$m$gsymbol,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_571208"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_571208":
   movl %eax,  -20(%esp)  # stash funcall-oper in closure slot
# emit-expr "fxlognot"
# string literal
    jmp _L_571210
    .align 8,0x90
_L_571209 :
    .int 32
    .ascii "fxlognot"
_L_571210:
    movl $_L_571209, %eax
    orl $6, %eax
    mov %eax, -24(%esp)  # arg fxlognot
    movl -20(%esp), %edi   # load new closure to %edi
    add $-12, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $12, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    movl %eax, -12(%esp)
# emit-expr (vector-ref f94289 0)
# emit-expr f94289
# emit-variable-ref
# env=((f94289 . 0))
# var=f94289
    movl 0(%esp), %eax  # stack load f94289
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_571211
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_571211:
    movl %eax, -16(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_571212"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_571212:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_571214
    cmp  $0,%eax
    jge _L_571213
_L_571214:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_571213:
    movl -16(%esp), %esi
    movl -1(%eax,%esi), %eax
    movl %eax, 4(%ebp)
    movl -12(%esp), %eax
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    or   $1, %al
    add  $8, %ebp
# cons end
    movl -4(%esp), %ebx
    movl -8(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "eof-object") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "eof-object?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f94289 0))) (closure () (f94289) (let () (vector-ref f94289 0))))
# emit-begin
#   expr=(begin (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "eof-object") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "eof-object?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f94289 0))) (closure () (f94289) (let () (vector-ref f94289 0))))
#   env=((f94289 . 0))
# emit-expr (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f94289 0)))
# emit-expr f94289
# emit-variable-ref
# env=((f94289 . 0))
# var=f94289
    movl 0(%esp), %eax  # stack load f94289
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_571215
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_571215:
    movl %eax, -4(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_571216"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_571216:
# check bounds on vector index
    movl -4(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_571218
    cmp  $0,%eax
    jge _L_571217
_L_571218:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_571217:
    movl %eax, -8(%esp)
# emit-expr (cons ((primitive-ref string->symbol) "char=?") (vector-ref f94289 0))
# cons arg1=((primitive-ref string->symbol) "char=?") arg2=(vector-ref f94289 0)
# emit-expr ((primitive-ref string->symbol) "char=?")
# funcall
#    si   =-12
#    env  = ((f94289 . 0))
#    expr = (funcall (primitive-ref string->symbol) "char=?")
# emit-expr (primitive-ref string->symbol)
    .extern mrc_string$m$gsymbol
    movl mrc_string$m$gsymbol,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_571219"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_571219":
   movl %eax,  -20(%esp)  # stash funcall-oper in closure slot
# emit-expr "char=?"
# string literal
    jmp _L_571221
    .align 8,0x90
_L_571220 :
    .int 24
    .ascii "char=?"
_L_571221:
    movl $_L_571220, %eax
    orl $6, %eax
    mov %eax, -24(%esp)  # arg char=?
    movl -20(%esp), %edi   # load new closure to %edi
    add $-12, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $12, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    movl %eax, -12(%esp)
# emit-expr (vector-ref f94289 0)
# emit-expr f94289
# emit-variable-ref
# env=((f94289 . 0))
# var=f94289
    movl 0(%esp), %eax  # stack load f94289
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_571222
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_571222:
    movl %eax, -16(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_571223"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_571223:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_571225
    cmp  $0,%eax
    jge _L_571224
_L_571225:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_571224:
    movl -16(%esp), %esi
    movl -1(%eax,%esi), %eax
    movl %eax, 4(%ebp)
    movl -12(%esp), %eax
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    or   $1, %al
    add  $8, %ebp
# cons end
    movl -4(%esp), %ebx
    movl -8(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "eof-object") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "eof-object?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f94289 0))) (closure () (f94289) (let () (vector-ref f94289 0))))
# emit-begin
#   expr=(begin (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "eof-object") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "eof-object?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f94289 0))) (closure () (f94289) (let () (vector-ref f94289 0))))
#   env=((f94289 . 0))
# emit-expr (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f94289 0)))
# emit-expr f94289
# emit-variable-ref
# env=((f94289 . 0))
# var=f94289
    movl 0(%esp), %eax  # stack load f94289
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_571226
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_571226:
    movl %eax, -4(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_571227"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_571227:
# check bounds on vector index
    movl -4(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_571229
    cmp  $0,%eax
    jge _L_571228
_L_571229:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_571228:
    movl %eax, -8(%esp)
# emit-expr (cons ((primitive-ref string->symbol) "eq?") (vector-ref f94289 0))
# cons arg1=((primitive-ref string->symbol) "eq?") arg2=(vector-ref f94289 0)
# emit-expr ((primitive-ref string->symbol) "eq?")
# funcall
#    si   =-12
#    env  = ((f94289 . 0))
#    expr = (funcall (primitive-ref string->symbol) "eq?")
# emit-expr (primitive-ref string->symbol)
    .extern mrc_string$m$gsymbol
    movl mrc_string$m$gsymbol,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_571230"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_571230":
   movl %eax,  -20(%esp)  # stash funcall-oper in closure slot
# emit-expr "eq?"
# string literal
    jmp _L_571232
    .align 8,0x90
_L_571231 :
    .int 12
    .ascii "eq?"
_L_571232:
    movl $_L_571231, %eax
    orl $6, %eax
    mov %eax, -24(%esp)  # arg eq?
    movl -20(%esp), %edi   # load new closure to %edi
    add $-12, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $12, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    movl %eax, -12(%esp)
# emit-expr (vector-ref f94289 0)
# emit-expr f94289
# emit-variable-ref
# env=((f94289 . 0))
# var=f94289
    movl 0(%esp), %eax  # stack load f94289
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_571233
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_571233:
    movl %eax, -16(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_571234"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_571234:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_571236
    cmp  $0,%eax
    jge _L_571235
_L_571236:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_571235:
    movl -16(%esp), %esi
    movl -1(%eax,%esi), %eax
    movl %eax, 4(%ebp)
    movl -12(%esp), %eax
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    or   $1, %al
    add  $8, %ebp
# cons end
    movl -4(%esp), %ebx
    movl -8(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "eof-object") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "eof-object?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f94289 0))) (closure () (f94289) (let () (vector-ref f94289 0))))
# emit-begin
#   expr=(begin (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "eof-object") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "eof-object?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f94289 0))) (closure () (f94289) (let () (vector-ref f94289 0))))
#   env=((f94289 . 0))
# emit-expr (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f94289 0)))
# emit-expr f94289
# emit-variable-ref
# env=((f94289 . 0))
# var=f94289
    movl 0(%esp), %eax  # stack load f94289
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_571237
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_571237:
    movl %eax, -4(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_571238"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_571238:
# check bounds on vector index
    movl -4(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_571240
    cmp  $0,%eax
    jge _L_571239
_L_571240:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_571239:
    movl %eax, -8(%esp)
# emit-expr (cons ((primitive-ref string->symbol) "not") (vector-ref f94289 0))
# cons arg1=((primitive-ref string->symbol) "not") arg2=(vector-ref f94289 0)
# emit-expr ((primitive-ref string->symbol) "not")
# funcall
#    si   =-12
#    env  = ((f94289 . 0))
#    expr = (funcall (primitive-ref string->symbol) "not")
# emit-expr (primitive-ref string->symbol)
    .extern mrc_string$m$gsymbol
    movl mrc_string$m$gsymbol,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_571241"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_571241":
   movl %eax,  -20(%esp)  # stash funcall-oper in closure slot
# emit-expr "not"
# string literal
    jmp _L_571243
    .align 8,0x90
_L_571242 :
    .int 12
    .ascii "not"
_L_571243:
    movl $_L_571242, %eax
    orl $6, %eax
    mov %eax, -24(%esp)  # arg not
    movl -20(%esp), %edi   # load new closure to %edi
    add $-12, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $12, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    movl %eax, -12(%esp)
# emit-expr (vector-ref f94289 0)
# emit-expr f94289
# emit-variable-ref
# env=((f94289 . 0))
# var=f94289
    movl 0(%esp), %eax  # stack load f94289
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_571244
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_571244:
    movl %eax, -16(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_571245"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_571245:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_571247
    cmp  $0,%eax
    jge _L_571246
_L_571247:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_571246:
    movl -16(%esp), %esi
    movl -1(%eax,%esi), %eax
    movl %eax, 4(%ebp)
    movl -12(%esp), %eax
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    or   $1, %al
    add  $8, %ebp
# cons end
    movl -4(%esp), %ebx
    movl -8(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "eof-object") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "eof-object?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f94289 0))) (closure () (f94289) (let () (vector-ref f94289 0))))
# emit-begin
#   expr=(begin (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "eof-object") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "eof-object?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f94289 0))) (closure () (f94289) (let () (vector-ref f94289 0))))
#   env=((f94289 . 0))
# emit-expr (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f94289 0)))
# emit-expr f94289
# emit-variable-ref
# env=((f94289 . 0))
# var=f94289
    movl 0(%esp), %eax  # stack load f94289
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_571248
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_571248:
    movl %eax, -4(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_571249"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_571249:
# check bounds on vector index
    movl -4(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_571251
    cmp  $0,%eax
    jge _L_571250
_L_571251:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_571250:
    movl %eax, -8(%esp)
# emit-expr (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f94289 0))
# cons arg1=((primitive-ref string->symbol) "boolean?") arg2=(vector-ref f94289 0)
# emit-expr ((primitive-ref string->symbol) "boolean?")
# funcall
#    si   =-12
#    env  = ((f94289 . 0))
#    expr = (funcall (primitive-ref string->symbol) "boolean?")
# emit-expr (primitive-ref string->symbol)
    .extern mrc_string$m$gsymbol
    movl mrc_string$m$gsymbol,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_571252"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_571252":
   movl %eax,  -20(%esp)  # stash funcall-oper in closure slot
# emit-expr "boolean?"
# string literal
    jmp _L_571254
    .align 8,0x90
_L_571253 :
    .int 32
    .ascii "boolean?"
_L_571254:
    movl $_L_571253, %eax
    orl $6, %eax
    mov %eax, -24(%esp)  # arg boolean?
    movl -20(%esp), %edi   # load new closure to %edi
    add $-12, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $12, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    movl %eax, -12(%esp)
# emit-expr (vector-ref f94289 0)
# emit-expr f94289
# emit-variable-ref
# env=((f94289 . 0))
# var=f94289
    movl 0(%esp), %eax  # stack load f94289
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_571255
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_571255:
    movl %eax, -16(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_571256"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_571256:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_571258
    cmp  $0,%eax
    jge _L_571257
_L_571258:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_571257:
    movl -16(%esp), %esi
    movl -1(%eax,%esi), %eax
    movl %eax, 4(%ebp)
    movl -12(%esp), %eax
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    or   $1, %al
    add  $8, %ebp
# cons end
    movl -4(%esp), %ebx
    movl -8(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "eof-object") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "eof-object?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f94289 0))) (closure () (f94289) (let () (vector-ref f94289 0))))
# emit-begin
#   expr=(begin (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "eof-object") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "eof-object?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f94289 0))) (closure () (f94289) (let () (vector-ref f94289 0))))
#   env=((f94289 . 0))
# emit-expr (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f94289 0)))
# emit-expr f94289
# emit-variable-ref
# env=((f94289 . 0))
# var=f94289
    movl 0(%esp), %eax  # stack load f94289
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_571259
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_571259:
    movl %eax, -4(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_571260"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_571260:
# check bounds on vector index
    movl -4(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_571262
    cmp  $0,%eax
    jge _L_571261
_L_571262:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_571261:
    movl %eax, -8(%esp)
# emit-expr (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f94289 0))
# cons arg1=((primitive-ref string->symbol) "fixnum?") arg2=(vector-ref f94289 0)
# emit-expr ((primitive-ref string->symbol) "fixnum?")
# funcall
#    si   =-12
#    env  = ((f94289 . 0))
#    expr = (funcall (primitive-ref string->symbol) "fixnum?")
# emit-expr (primitive-ref string->symbol)
    .extern mrc_string$m$gsymbol
    movl mrc_string$m$gsymbol,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_571263"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_571263":
   movl %eax,  -20(%esp)  # stash funcall-oper in closure slot
# emit-expr "fixnum?"
# string literal
    jmp _L_571265
    .align 8,0x90
_L_571264 :
    .int 28
    .ascii "fixnum?"
_L_571265:
    movl $_L_571264, %eax
    orl $6, %eax
    mov %eax, -24(%esp)  # arg fixnum?
    movl -20(%esp), %edi   # load new closure to %edi
    add $-12, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $12, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    movl %eax, -12(%esp)
# emit-expr (vector-ref f94289 0)
# emit-expr f94289
# emit-variable-ref
# env=((f94289 . 0))
# var=f94289
    movl 0(%esp), %eax  # stack load f94289
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_571266
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_571266:
    movl %eax, -16(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_571267"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_571267:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_571269
    cmp  $0,%eax
    jge _L_571268
_L_571269:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_571268:
    movl -16(%esp), %esi
    movl -1(%eax,%esi), %eax
    movl %eax, 4(%ebp)
    movl -12(%esp), %eax
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    or   $1, %al
    add  $8, %ebp
# cons end
    movl -4(%esp), %ebx
    movl -8(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "eof-object") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "eof-object?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f94289 0))) (closure () (f94289) (let () (vector-ref f94289 0))))
# emit-begin
#   expr=(begin (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "eof-object") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "eof-object?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f94289 0))) (closure () (f94289) (let () (vector-ref f94289 0))))
#   env=((f94289 . 0))
# emit-expr (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f94289 0)))
# emit-expr f94289
# emit-variable-ref
# env=((f94289 . 0))
# var=f94289
    movl 0(%esp), %eax  # stack load f94289
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_571270
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_571270:
    movl %eax, -4(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_571271"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_571271:
# check bounds on vector index
    movl -4(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_571273
    cmp  $0,%eax
    jge _L_571272
_L_571273:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_571272:
    movl %eax, -8(%esp)
# emit-expr (cons ((primitive-ref string->symbol) "char?") (vector-ref f94289 0))
# cons arg1=((primitive-ref string->symbol) "char?") arg2=(vector-ref f94289 0)
# emit-expr ((primitive-ref string->symbol) "char?")
# funcall
#    si   =-12
#    env  = ((f94289 . 0))
#    expr = (funcall (primitive-ref string->symbol) "char?")
# emit-expr (primitive-ref string->symbol)
    .extern mrc_string$m$gsymbol
    movl mrc_string$m$gsymbol,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_571274"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_571274":
   movl %eax,  -20(%esp)  # stash funcall-oper in closure slot
# emit-expr "char?"
# string literal
    jmp _L_571276
    .align 8,0x90
_L_571275 :
    .int 20
    .ascii "char?"
_L_571276:
    movl $_L_571275, %eax
    orl $6, %eax
    mov %eax, -24(%esp)  # arg char?
    movl -20(%esp), %edi   # load new closure to %edi
    add $-12, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $12, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    movl %eax, -12(%esp)
# emit-expr (vector-ref f94289 0)
# emit-expr f94289
# emit-variable-ref
# env=((f94289 . 0))
# var=f94289
    movl 0(%esp), %eax  # stack load f94289
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_571277
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_571277:
    movl %eax, -16(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_571278"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_571278:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_571280
    cmp  $0,%eax
    jge _L_571279
_L_571280:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_571279:
    movl -16(%esp), %esi
    movl -1(%eax,%esi), %eax
    movl %eax, 4(%ebp)
    movl -12(%esp), %eax
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    or   $1, %al
    add  $8, %ebp
# cons end
    movl -4(%esp), %ebx
    movl -8(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "eof-object") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "eof-object?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f94289 0))) (closure () (f94289) (let () (vector-ref f94289 0))))
# emit-begin
#   expr=(begin (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "eof-object") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "eof-object?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f94289 0))) (closure () (f94289) (let () (vector-ref f94289 0))))
#   env=((f94289 . 0))
# emit-expr (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "eof-object") (vector-ref f94289 0)))
# emit-expr f94289
# emit-variable-ref
# env=((f94289 . 0))
# var=f94289
    movl 0(%esp), %eax  # stack load f94289
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_571281
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_571281:
    movl %eax, -4(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_571282"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_571282:
# check bounds on vector index
    movl -4(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_571284
    cmp  $0,%eax
    jge _L_571283
_L_571284:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_571283:
    movl %eax, -8(%esp)
# emit-expr (cons ((primitive-ref string->symbol) "eof-object") (vector-ref f94289 0))
# cons arg1=((primitive-ref string->symbol) "eof-object") arg2=(vector-ref f94289 0)
# emit-expr ((primitive-ref string->symbol) "eof-object")
# funcall
#    si   =-12
#    env  = ((f94289 . 0))
#    expr = (funcall (primitive-ref string->symbol) "eof-object")
# emit-expr (primitive-ref string->symbol)
    .extern mrc_string$m$gsymbol
    movl mrc_string$m$gsymbol,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_571285"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_571285":
   movl %eax,  -20(%esp)  # stash funcall-oper in closure slot
# emit-expr "eof-object"
# string literal
    jmp _L_571287
    .align 8,0x90
_L_571286 :
    .int 40
    .ascii "eof-object"
_L_571287:
    movl $_L_571286, %eax
    orl $6, %eax
    mov %eax, -24(%esp)  # arg eof-object
    movl -20(%esp), %edi   # load new closure to %edi
    add $-12, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $12, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    movl %eax, -12(%esp)
# emit-expr (vector-ref f94289 0)
# emit-expr f94289
# emit-variable-ref
# env=((f94289 . 0))
# var=f94289
    movl 0(%esp), %eax  # stack load f94289
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_571288
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_571288:
    movl %eax, -16(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_571289"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_571289:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_571291
    cmp  $0,%eax
    jge _L_571290
_L_571291:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_571290:
    movl -16(%esp), %esi
    movl -1(%eax,%esi), %eax
    movl %eax, 4(%ebp)
    movl -12(%esp), %eax
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    or   $1, %al
    add  $8, %ebp
# cons end
    movl -4(%esp), %ebx
    movl -8(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "eof-object?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f94289 0))) (closure () (f94289) (let () (vector-ref f94289 0))))
# emit-begin
#   expr=(begin (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "eof-object?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f94289 0))) (closure () (f94289) (let () (vector-ref f94289 0))))
#   env=((f94289 . 0))
# emit-expr (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "eof-object?") (vector-ref f94289 0)))
# emit-expr f94289
# emit-variable-ref
# env=((f94289 . 0))
# var=f94289
    movl 0(%esp), %eax  # stack load f94289
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_571292
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_571292:
    movl %eax, -4(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_571293"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_571293:
# check bounds on vector index
    movl -4(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_571295
    cmp  $0,%eax
    jge _L_571294
_L_571295:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_571294:
    movl %eax, -8(%esp)
# emit-expr (cons ((primitive-ref string->symbol) "eof-object?") (vector-ref f94289 0))
# cons arg1=((primitive-ref string->symbol) "eof-object?") arg2=(vector-ref f94289 0)
# emit-expr ((primitive-ref string->symbol) "eof-object?")
# funcall
#    si   =-12
#    env  = ((f94289 . 0))
#    expr = (funcall (primitive-ref string->symbol) "eof-object?")
# emit-expr (primitive-ref string->symbol)
    .extern mrc_string$m$gsymbol
    movl mrc_string$m$gsymbol,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_571296"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_571296":
   movl %eax,  -20(%esp)  # stash funcall-oper in closure slot
# emit-expr "eof-object?"
# string literal
    jmp _L_571298
    .align 8,0x90
_L_571297 :
    .int 44
    .ascii "eof-object?"
_L_571298:
    movl $_L_571297, %eax
    orl $6, %eax
    mov %eax, -24(%esp)  # arg eof-object?
    movl -20(%esp), %edi   # load new closure to %edi
    add $-12, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $12, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    movl %eax, -12(%esp)
# emit-expr (vector-ref f94289 0)
# emit-expr f94289
# emit-variable-ref
# env=((f94289 . 0))
# var=f94289
    movl 0(%esp), %eax  # stack load f94289
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_571299
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_571299:
    movl %eax, -16(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_571300"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_571300:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_571302
    cmp  $0,%eax
    jge _L_571301
_L_571302:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_571301:
    movl -16(%esp), %esi
    movl -1(%eax,%esi), %eax
    movl %eax, 4(%ebp)
    movl -12(%esp), %eax
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    or   $1, %al
    add  $8, %ebp
# cons end
    movl -4(%esp), %ebx
    movl -8(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f94289 0))) (closure () (f94289) (let () (vector-ref f94289 0))))
# emit-begin
#   expr=(begin (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f94289 0))) (closure () (f94289) (let () (vector-ref f94289 0))))
#   env=((f94289 . 0))
# emit-expr (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f94289 0)))
# emit-expr f94289
# emit-variable-ref
# env=((f94289 . 0))
# var=f94289
    movl 0(%esp), %eax  # stack load f94289
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_571303
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_571303:
    movl %eax, -4(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_571304"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_571304:
# check bounds on vector index
    movl -4(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_571306
    cmp  $0,%eax
    jge _L_571305
_L_571306:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_571305:
    movl %eax, -8(%esp)
# emit-expr (cons ((primitive-ref string->symbol) "null?") (vector-ref f94289 0))
# cons arg1=((primitive-ref string->symbol) "null?") arg2=(vector-ref f94289 0)
# emit-expr ((primitive-ref string->symbol) "null?")
# funcall
#    si   =-12
#    env  = ((f94289 . 0))
#    expr = (funcall (primitive-ref string->symbol) "null?")
# emit-expr (primitive-ref string->symbol)
    .extern mrc_string$m$gsymbol
    movl mrc_string$m$gsymbol,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_571307"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_571307":
   movl %eax,  -20(%esp)  # stash funcall-oper in closure slot
# emit-expr "null?"
# string literal
    jmp _L_571309
    .align 8,0x90
_L_571308 :
    .int 20
    .ascii "null?"
_L_571309:
    movl $_L_571308, %eax
    orl $6, %eax
    mov %eax, -24(%esp)  # arg null?
    movl -20(%esp), %edi   # load new closure to %edi
    add $-12, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $12, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    movl %eax, -12(%esp)
# emit-expr (vector-ref f94289 0)
# emit-expr f94289
# emit-variable-ref
# env=((f94289 . 0))
# var=f94289
    movl 0(%esp), %eax  # stack load f94289
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_571310
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_571310:
    movl %eax, -16(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_571311"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_571311:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_571313
    cmp  $0,%eax
    jge _L_571312
_L_571313:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_571312:
    movl -16(%esp), %esi
    movl -1(%eax,%esi), %eax
    movl %eax, 4(%ebp)
    movl -12(%esp), %eax
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    or   $1, %al
    add  $8, %ebp
# cons end
    movl -4(%esp), %ebx
    movl -8(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f94289 0))) (closure () (f94289) (let () (vector-ref f94289 0))))
# emit-begin
#   expr=(begin (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f94289 0))) (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f94289 0))) (closure () (f94289) (let () (vector-ref f94289 0))))
#   env=((f94289 . 0))
# emit-expr (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f94289 0)))
# emit-expr f94289
# emit-variable-ref
# env=((f94289 . 0))
# var=f94289
    movl 0(%esp), %eax  # stack load f94289
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_571314
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_571314:
    movl %eax, -4(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_571315"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_571315:
# check bounds on vector index
    movl -4(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_571317
    cmp  $0,%eax
    jge _L_571316
_L_571317:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_571316:
    movl %eax, -8(%esp)
# emit-expr (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f94289 0))
# cons arg1=((primitive-ref string->symbol) "char->fixnum") arg2=(vector-ref f94289 0)
# emit-expr ((primitive-ref string->symbol) "char->fixnum")
# funcall
#    si   =-12
#    env  = ((f94289 . 0))
#    expr = (funcall (primitive-ref string->symbol) "char->fixnum")
# emit-expr (primitive-ref string->symbol)
    .extern mrc_string$m$gsymbol
    movl mrc_string$m$gsymbol,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_571318"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_571318":
   movl %eax,  -20(%esp)  # stash funcall-oper in closure slot
# emit-expr "char->fixnum"
# string literal
    jmp _L_571320
    .align 8,0x90
_L_571319 :
    .int 48
    .ascii "char->fixnum"
_L_571320:
    movl $_L_571319, %eax
    orl $6, %eax
    mov %eax, -24(%esp)  # arg char->fixnum
    movl -20(%esp), %edi   # load new closure to %edi
    add $-12, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $12, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    movl %eax, -12(%esp)
# emit-expr (vector-ref f94289 0)
# emit-expr f94289
# emit-variable-ref
# env=((f94289 . 0))
# var=f94289
    movl 0(%esp), %eax  # stack load f94289
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_571321
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_571321:
    movl %eax, -16(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_571322"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_571322:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_571324
    cmp  $0,%eax
    jge _L_571323
_L_571324:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_571323:
    movl -16(%esp), %esi
    movl -1(%eax,%esi), %eax
    movl %eax, 4(%ebp)
    movl -12(%esp), %eax
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    or   $1, %al
    add  $8, %ebp
# cons end
    movl -4(%esp), %ebx
    movl -8(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f94289 0))) (closure () (f94289) (let () (vector-ref f94289 0))))
# emit-begin
#   expr=(begin (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f94289 0))) (closure () (f94289) (let () (vector-ref f94289 0))))
#   env=((f94289 . 0))
# emit-expr (vector-set! f94289 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f94289 0)))
# emit-expr f94289
# emit-variable-ref
# env=((f94289 . 0))
# var=f94289
    movl 0(%esp), %eax  # stack load f94289
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_571325
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_571325:
    movl %eax, -4(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_571326"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_571326:
# check bounds on vector index
    movl -4(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_571328
    cmp  $0,%eax
    jge _L_571327
_L_571328:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_571327:
    movl %eax, -8(%esp)
# emit-expr (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f94289 0))
# cons arg1=((primitive-ref string->symbol) "fixnum->char") arg2=(vector-ref f94289 0)
# emit-expr ((primitive-ref string->symbol) "fixnum->char")
# funcall
#    si   =-12
#    env  = ((f94289 . 0))
#    expr = (funcall (primitive-ref string->symbol) "fixnum->char")
# emit-expr (primitive-ref string->symbol)
    .extern mrc_string$m$gsymbol
    movl mrc_string$m$gsymbol,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_571329"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_571329":
   movl %eax,  -20(%esp)  # stash funcall-oper in closure slot
# emit-expr "fixnum->char"
# string literal
    jmp _L_571331
    .align 8,0x90
_L_571330 :
    .int 48
    .ascii "fixnum->char"
_L_571331:
    movl $_L_571330, %eax
    orl $6, %eax
    mov %eax, -24(%esp)  # arg fixnum->char
    movl -20(%esp), %edi   # load new closure to %edi
    add $-12, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $12, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    movl %eax, -12(%esp)
# emit-expr (vector-ref f94289 0)
# emit-expr f94289
# emit-variable-ref
# env=((f94289 . 0))
# var=f94289
    movl 0(%esp), %eax  # stack load f94289
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_571332
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_571332:
    movl %eax, -16(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_571333"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_571333:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_571335
    cmp  $0,%eax
    jge _L_571334
_L_571335:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_571334:
    movl -16(%esp), %esi
    movl -1(%eax,%esi), %eax
    movl %eax, 4(%ebp)
    movl -12(%esp), %eax
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    or   $1, %al
    add  $8, %ebp
# cons end
    movl -4(%esp), %ebx
    movl -8(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin (closure () (f94289) (let () (vector-ref f94289 0))))
# emit-begin
#   expr=(begin (closure () (f94289) (let () (vector-ref f94289 0))))
#   env=((f94289 . 0))
# emit-expr (closure () (f94289) (let () (vector-ref f94289 0)))
# emit-closure
# si = -4
# env = ((f94289 . 0))
# expr = (closure () (f94289) (let () (vector-ref f94289 0)))
    movl $_L_571336, 0(%ebp)  # closure label
# emit-variable-ref
# env=((f94289 . 0))
# var=f94289
    movl 0(%esp), %eax  # stack load f94289
# end emit-variable-ref
   movl  %eax, 4(%ebp)  # f94289
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $8, %ebp     # bump ebp
    jmp _L_571337            # jump around closure body
_L_571336:
# check argument count
    cmp $0,%eax
    je _L_571338
# invoke error handler eh_argcount
    .extern mrc_eh$uargcount
    movl mrc_eh$uargcount, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_571338:
# emit-tail-expr
# si=-8
# env=((f94289 . 4) (f94289 . 0))
# expr=(let () (vector-ref f94289 0))
# emit-tail-let
#  si   = -8
#  env  = ((f94289 . 4) (f94289 . 0))
#  bindings = ()
#  body = (vector-ref f94289 0)
# emit-tail-expr
# si=-8
# env=((f94289 . 4) (f94289 . 0))
# expr=(vector-ref f94289 0)
# tail primcall
# emit-expr f94289
# emit-variable-ref
# env=((f94289 . 4) (f94289 . 0))
# var=f94289
    movl 2(%edi), %eax  # frame load f94289
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_571339
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_571339:
    movl %eax, -8(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_571340"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_571340:
# check bounds on vector index
    movl -8(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_571342
    cmp  $0,%eax
    jge _L_571341
_L_571342:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_571341:
    movl -8(%esp), %esi
    movl -1(%eax,%esi), %eax
#return from tail (vector-ref f94289 0)
    ret
    .align 4,0x90
_L_571337:
# emit-expr (begin)
# emit-begin
#   expr=(begin)
#   env=((f94289 . 0))
     movl %eax, mrc_primitives
# == explicit-begins  ==>
# (lambda () (error (quote funcall) "arg 1 must be a procedure"))
# == eliminate-let*  ==>
# (lambda () (error (quote funcall) "arg 1 must be a procedure"))
# == uniquify-variables  ==>
# (lambda () (error (quote funcall) "arg 1 must be a procedure"))
# == vectorize-letrec  ==>
# (lambda () (error (quote funcall) "arg 1 must be a procedure"))
# == eliminate-set!  ==>
# (lambda () (let () (error (quote funcall) "arg 1 must be a procedure")))
# == close-free-variables  ==>
# (closure () (funcall) (let () (error (quote funcall) "arg 1 must be a procedure")))
# == eliminate-quote  ==>
# (closure () (funcall) (let () (error (string->symbol "funcall") "arg 1 must be a procedure")))
# == eliminate-when/unless  ==>
# (closure () (funcall) (let () (error (string->symbol "funcall") "arg 1 must be a procedure")))
# == eliminate-cond  ==>
# (closure () (funcall) (let () (error (string->symbol "funcall") "arg 1 must be a procedure")))
# == external-symbols  ==>
# (closure () (funcall) (let () ((primitive-ref error) ((primitive-ref string->symbol) "funcall") "arg 1 must be a procedure")))
# emit-expr (closure () (funcall) (let () ((primitive-ref error) ((primitive-ref string->symbol) "funcall") "arg 1 must be a procedure")))
# emit-closure
# si = 0
# env = ()
# expr = (closure () (funcall) (let () ((primitive-ref error) ((primitive-ref string->symbol) "funcall") "arg 1 must be a procedure")))
    movl $_L_571343, 0(%ebp)  # closure label
# WARNING: free var funcall not defined in the environmnet
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $8, %ebp     # bump ebp
    jmp _L_571344            # jump around closure body
_L_571343:
# check argument count
    cmp $0,%eax
    je _L_571345
# invoke error handler eh_argcount
    .extern mrc_eh$uargcount
    movl mrc_eh$uargcount, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_571345:
# emit-tail-expr
# si=-8
# env=((funcall . 4))
# expr=(let () ((primitive-ref error) ((primitive-ref string->symbol) "funcall") "arg 1 must be a procedure"))
# emit-tail-let
#  si   = -8
#  env  = ((funcall . 4))
#  bindings = ()
#  body = ((primitive-ref error) ((primitive-ref string->symbol) "funcall") "arg 1 must be a procedure")
# emit-tail-expr
# si=-8
# env=((funcall . 4))
# expr=((primitive-ref error) ((primitive-ref string->symbol) "funcall") "arg 1 must be a procedure")
# emit-tail-funcall
#    si   =-8
#    env  = ((funcall . 4))
#    expr = (funcall (primitive-ref error) ((primitive-ref string->symbol) "funcall") "arg 1 must be a procedure")
# emit-expr (primitive-ref error)
    .extern mrc_error
    movl mrc_error,%eax
   movl %eax,  -8(%esp)  # stash funcall-oper in next closure slot
# emit-expr ((primitive-ref string->symbol) "funcall")
# funcall
#    si   =-12
#    env  = ((funcall . 4))
#    expr = (funcall (primitive-ref string->symbol) "funcall")
# emit-expr (primitive-ref string->symbol)
    .extern mrc_string$m$gsymbol
    movl mrc_string$m$gsymbol,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_571346"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_571346":
   movl %eax,  -20(%esp)  # stash funcall-oper in closure slot
# emit-expr "funcall"
# string literal
    jmp _L_571348
    .align 8,0x90
_L_571347 :
    .int 28
    .ascii "funcall"
_L_571348:
    movl $_L_571347, %eax
    orl $6, %eax
    mov %eax, -24(%esp)  # arg funcall
    movl -20(%esp), %edi   # load new closure to %edi
    add $-12, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $12, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    mov %eax, -12(%esp)    # arg ((primitive-ref string->symbol) funcall)
# emit-expr "arg 1 must be a procedure"
# string literal
    jmp _L_571350
    .align 8,0x90
_L_571349 :
    .int 100
    .ascii "arg 1 must be a procedure"
_L_571350:
    movl $_L_571349, %eax
    orl $6, %eax
    mov %eax, -16(%esp)    # arg arg 1 must be a procedure
    movl -8(%esp), %edi   # load new closure to %edi
# emit-shift-args:  size=3   si=-8  delta=4
    mov -8(%esp), %ebx  # shift frame cell
    mov %ebx, -4(%esp)  # down to base
# emit-shift-args:  size=2   si=-12  delta=4
    mov -12(%esp), %ebx  # shift frame cell
    mov %ebx, -8(%esp)  # down to base
# emit-shift-args:  size=1   si=-16  delta=4
    mov -16(%esp), %ebx  # shift frame cell
    mov %ebx, -12(%esp)  # down to base
# emit-shift-args:  size=0   si=-20  delta=4
    movl $8,%eax   # save arg count
    jmp *-2(%edi)  # tail-funcall
    .align 4,0x90
_L_571344:
     movl %eax, mrc_eh$uprocedure
# == explicit-begins  ==>
# (lambda () (error (quote funcall) "wrong number of args"))
# == eliminate-let*  ==>
# (lambda () (error (quote funcall) "wrong number of args"))
# == uniquify-variables  ==>
# (lambda () (error (quote funcall) "wrong number of args"))
# == vectorize-letrec  ==>
# (lambda () (error (quote funcall) "wrong number of args"))
# == eliminate-set!  ==>
# (lambda () (let () (error (quote funcall) "wrong number of args")))
# == close-free-variables  ==>
# (closure () (funcall) (let () (error (quote funcall) "wrong number of args")))
# == eliminate-quote  ==>
# (closure () (funcall) (let () (error (string->symbol "funcall") "wrong number of args")))
# == eliminate-when/unless  ==>
# (closure () (funcall) (let () (error (string->symbol "funcall") "wrong number of args")))
# == eliminate-cond  ==>
# (closure () (funcall) (let () (error (string->symbol "funcall") "wrong number of args")))
# == external-symbols  ==>
# (closure () (funcall) (let () ((primitive-ref error) ((primitive-ref string->symbol) "funcall") "wrong number of args")))
# emit-expr (closure () (funcall) (let () ((primitive-ref error) ((primitive-ref string->symbol) "funcall") "wrong number of args")))
# emit-closure
# si = 0
# env = ()
# expr = (closure () (funcall) (let () ((primitive-ref error) ((primitive-ref string->symbol) "funcall") "wrong number of args")))
    movl $_L_571351, 0(%ebp)  # closure label
# WARNING: free var funcall not defined in the environmnet
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $8, %ebp     # bump ebp
    jmp _L_571352            # jump around closure body
_L_571351:
# check argument count
    cmp $0,%eax
    je _L_571353
# invoke error handler eh_argcount
    .extern mrc_eh$uargcount
    movl mrc_eh$uargcount, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_571353:
# emit-tail-expr
# si=-8
# env=((funcall . 4))
# expr=(let () ((primitive-ref error) ((primitive-ref string->symbol) "funcall") "wrong number of args"))
# emit-tail-let
#  si   = -8
#  env  = ((funcall . 4))
#  bindings = ()
#  body = ((primitive-ref error) ((primitive-ref string->symbol) "funcall") "wrong number of args")
# emit-tail-expr
# si=-8
# env=((funcall . 4))
# expr=((primitive-ref error) ((primitive-ref string->symbol) "funcall") "wrong number of args")
# emit-tail-funcall
#    si   =-8
#    env  = ((funcall . 4))
#    expr = (funcall (primitive-ref error) ((primitive-ref string->symbol) "funcall") "wrong number of args")
# emit-expr (primitive-ref error)
    .extern mrc_error
    movl mrc_error,%eax
   movl %eax,  -8(%esp)  # stash funcall-oper in next closure slot
# emit-expr ((primitive-ref string->symbol) "funcall")
# funcall
#    si   =-12
#    env  = ((funcall . 4))
#    expr = (funcall (primitive-ref string->symbol) "funcall")
# emit-expr (primitive-ref string->symbol)
    .extern mrc_string$m$gsymbol
    movl mrc_string$m$gsymbol,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_571354"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_571354":
   movl %eax,  -20(%esp)  # stash funcall-oper in closure slot
# emit-expr "funcall"
# string literal
    jmp _L_571356
    .align 8,0x90
_L_571355 :
    .int 28
    .ascii "funcall"
_L_571356:
    movl $_L_571355, %eax
    orl $6, %eax
    mov %eax, -24(%esp)  # arg funcall
    movl -20(%esp), %edi   # load new closure to %edi
    add $-12, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $12, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    mov %eax, -12(%esp)    # arg ((primitive-ref string->symbol) funcall)
# emit-expr "wrong number of args"
# string literal
    jmp _L_571358
    .align 8,0x90
_L_571357 :
    .int 80
    .ascii "wrong number of args"
_L_571358:
    movl $_L_571357, %eax
    orl $6, %eax
    mov %eax, -16(%esp)    # arg wrong number of args
    movl -8(%esp), %edi   # load new closure to %edi
# emit-shift-args:  size=3   si=-8  delta=4
    mov -8(%esp), %ebx  # shift frame cell
    mov %ebx, -4(%esp)  # down to base
# emit-shift-args:  size=2   si=-12  delta=4
    mov -12(%esp), %ebx  # shift frame cell
    mov %ebx, -8(%esp)  # down to base
# emit-shift-args:  size=1   si=-16  delta=4
    mov -16(%esp), %ebx  # shift frame cell
    mov %ebx, -12(%esp)  # down to base
# emit-shift-args:  size=0   si=-20  delta=4
    movl $8,%eax   # save arg count
    jmp *-2(%edi)  # tail-funcall
    .align 4,0x90
_L_571352:
     movl %eax, mrc_eh$uargcount
# == explicit-begins  ==>
# (lambda () (error (quote funcall) "too few args"))
# == eliminate-let*  ==>
# (lambda () (error (quote funcall) "too few args"))
# == uniquify-variables  ==>
# (lambda () (error (quote funcall) "too few args"))
# == vectorize-letrec  ==>
# (lambda () (error (quote funcall) "too few args"))
# == eliminate-set!  ==>
# (lambda () (let () (error (quote funcall) "too few args")))
# == close-free-variables  ==>
# (closure () (funcall) (let () (error (quote funcall) "too few args")))
# == eliminate-quote  ==>
# (closure () (funcall) (let () (error (string->symbol "funcall") "too few args")))
# == eliminate-when/unless  ==>
# (closure () (funcall) (let () (error (string->symbol "funcall") "too few args")))
# == eliminate-cond  ==>
# (closure () (funcall) (let () (error (string->symbol "funcall") "too few args")))
# == external-symbols  ==>
# (closure () (funcall) (let () ((primitive-ref error) ((primitive-ref string->symbol) "funcall") "too few args")))
# emit-expr (closure () (funcall) (let () ((primitive-ref error) ((primitive-ref string->symbol) "funcall") "too few args")))
# emit-closure
# si = 0
# env = ()
# expr = (closure () (funcall) (let () ((primitive-ref error) ((primitive-ref string->symbol) "funcall") "too few args")))
    movl $_L_571359, 0(%ebp)  # closure label
# WARNING: free var funcall not defined in the environmnet
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $8, %ebp     # bump ebp
    jmp _L_571360            # jump around closure body
_L_571359:
# check argument count
    cmp $0,%eax
    je _L_571361
# invoke error handler eh_argcount
    .extern mrc_eh$uargcount
    movl mrc_eh$uargcount, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_571361:
# emit-tail-expr
# si=-8
# env=((funcall . 4))
# expr=(let () ((primitive-ref error) ((primitive-ref string->symbol) "funcall") "too few args"))
# emit-tail-let
#  si   = -8
#  env  = ((funcall . 4))
#  bindings = ()
#  body = ((primitive-ref error) ((primitive-ref string->symbol) "funcall") "too few args")
# emit-tail-expr
# si=-8
# env=((funcall . 4))
# expr=((primitive-ref error) ((primitive-ref string->symbol) "funcall") "too few args")
# emit-tail-funcall
#    si   =-8
#    env  = ((funcall . 4))
#    expr = (funcall (primitive-ref error) ((primitive-ref string->symbol) "funcall") "too few args")
# emit-expr (primitive-ref error)
    .extern mrc_error
    movl mrc_error,%eax
   movl %eax,  -8(%esp)  # stash funcall-oper in next closure slot
# emit-expr ((primitive-ref string->symbol) "funcall")
# funcall
#    si   =-12
#    env  = ((funcall . 4))
#    expr = (funcall (primitive-ref string->symbol) "funcall")
# emit-expr (primitive-ref string->symbol)
    .extern mrc_string$m$gsymbol
    movl mrc_string$m$gsymbol,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_571362"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_571362":
   movl %eax,  -20(%esp)  # stash funcall-oper in closure slot
# emit-expr "funcall"
# string literal
    jmp _L_571364
    .align 8,0x90
_L_571363 :
    .int 28
    .ascii "funcall"
_L_571364:
    movl $_L_571363, %eax
    orl $6, %eax
    mov %eax, -24(%esp)  # arg funcall
    movl -20(%esp), %edi   # load new closure to %edi
    add $-12, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $12, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    mov %eax, -12(%esp)    # arg ((primitive-ref string->symbol) funcall)
# emit-expr "too few args"
# string literal
    jmp _L_571366
    .align 8,0x90
_L_571365 :
    .int 48
    .ascii "too few args"
_L_571366:
    movl $_L_571365, %eax
    orl $6, %eax
    mov %eax, -16(%esp)    # arg too few args
    movl -8(%esp), %edi   # load new closure to %edi
# emit-shift-args:  size=3   si=-8  delta=4
    mov -8(%esp), %ebx  # shift frame cell
    mov %ebx, -4(%esp)  # down to base
# emit-shift-args:  size=2   si=-12  delta=4
    mov -12(%esp), %ebx  # shift frame cell
    mov %ebx, -8(%esp)  # down to base
# emit-shift-args:  size=1   si=-16  delta=4
    mov -16(%esp), %ebx  # shift frame cell
    mov %ebx, -12(%esp)  # down to base
# emit-shift-args:  size=0   si=-20  delta=4
    movl $8,%eax   # save arg count
    jmp *-2(%edi)  # tail-funcall
    .align 4,0x90
_L_571360:
     movl %eax, mrc_eh$uargcount$umin
# == explicit-begins  ==>
# (lambda (i) (error (list-ref (primitives) i) "arg must be a fixnum"))
# == eliminate-let*  ==>
# (lambda (i) (error (list-ref (primitives) i) "arg must be a fixnum"))
# == uniquify-variables  ==>
# (lambda (f94290) (error (list-ref (primitives) f94290) "arg must be a fixnum"))
# == vectorize-letrec  ==>
# (lambda (f94290) (error (list-ref (primitives) f94290) "arg must be a fixnum"))
# == eliminate-set!  ==>
# (lambda (f94290) (let ((f94290 f94290)) (error (list-ref (primitives) f94290) "arg must be a fixnum")))
# == close-free-variables  ==>
# (closure (f94290) () (let ((f94290 f94290)) (error (list-ref (primitives) f94290) "arg must be a fixnum")))
# == eliminate-quote  ==>
# (closure (f94290) () (let ((f94290 f94290)) (error (list-ref (primitives) f94290) "arg must be a fixnum")))
# == eliminate-when/unless  ==>
# (closure (f94290) () (let ((f94290 f94290)) (error (list-ref (primitives) f94290) "arg must be a fixnum")))
# == eliminate-cond  ==>
# (closure (f94290) () (let ((f94290 f94290)) (error (list-ref (primitives) f94290) "arg must be a fixnum")))
# == external-symbols  ==>
# (closure (f94290) () (let ((f94290 f94290)) ((primitive-ref error) ((primitive-ref list-ref) ((primitive-ref primitives)) f94290) "arg must be a fixnum")))
# emit-expr (closure (f94290) () (let ((f94290 f94290)) ((primitive-ref error) ((primitive-ref list-ref) ((primitive-ref primitives)) f94290) "arg must be a fixnum")))
# emit-closure
# si = 0
# env = ()
# expr = (closure (f94290) () (let ((f94290 f94290)) ((primitive-ref error) ((primitive-ref list-ref) ((primitive-ref primitives)) f94290) "arg must be a fixnum")))
    movl $_L_571367, 0(%ebp)  # closure label
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $8, %ebp     # bump ebp
    jmp _L_571368            # jump around closure body
_L_571367:
# check argument count
    cmp $4,%eax
    je _L_571369
# invoke error handler eh_argcount
    .extern mrc_eh$uargcount
    movl mrc_eh$uargcount, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_571369:
# emit-tail-expr
# si=-12
# env=((f94290 . -8))
# expr=(let ((f94290 f94290)) ((primitive-ref error) ((primitive-ref list-ref) ((primitive-ref primitives)) f94290) "arg must be a fixnum"))
# emit-tail-let
#  si   = -12
#  env  = ((f94290 . -8))
#  bindings = ((f94290 f94290))
#  body = ((primitive-ref error) ((primitive-ref list-ref) ((primitive-ref primitives)) f94290) "arg must be a fixnum")
# emit-expr f94290
# emit-variable-ref
# env=((f94290 . -8))
# var=f94290
    movl -8(%esp), %eax  # stack load f94290
# end emit-variable-ref
    movl %eax, -12(%esp)  # stack save
# emit-tail-expr
# si=-16
# env=((f94290 . -12) (f94290 . -8))
# expr=((primitive-ref error) ((primitive-ref list-ref) ((primitive-ref primitives)) f94290) "arg must be a fixnum")
# emit-tail-funcall
#    si   =-16
#    env  = ((f94290 . -12) (f94290 . -8))
#    expr = (funcall (primitive-ref error) ((primitive-ref list-ref) ((primitive-ref primitives)) f94290) "arg must be a fixnum")
# emit-expr (primitive-ref error)
    .extern mrc_error
    movl mrc_error,%eax
   movl %eax,  -16(%esp)  # stash funcall-oper in next closure slot
# emit-expr ((primitive-ref list-ref) ((primitive-ref primitives)) f94290)
# funcall
#    si   =-20
#    env  = ((f94290 . -12) (f94290 . -8))
#    expr = (funcall (primitive-ref list-ref) ((primitive-ref primitives)) f94290)
# emit-expr (primitive-ref list-ref)
    .extern mrc_list$mref
    movl mrc_list$mref,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_571370"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_571370":
   movl %eax,  -28(%esp)  # stash funcall-oper in closure slot
# emit-expr ((primitive-ref primitives))
# funcall
#    si   =-32
#    env  = ((f94290 . -12) (f94290 . -8))
#    expr = (funcall (primitive-ref primitives))
# emit-expr (primitive-ref primitives)
    .extern mrc_primitives
    movl mrc_primitives,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_571371"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_571371":
   movl %eax,  -40(%esp)  # stash funcall-oper in closure slot
    movl -40(%esp), %edi   # load new closure to %edi
    add $-32, %esp   # adjust base
    movl $0,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $32, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    mov %eax, -32(%esp)  # arg ((primitive-ref primitives))
# emit-expr f94290
# emit-variable-ref
# env=((f94290 . -12) (f94290 . -8))
# var=f94290
    movl -12(%esp), %eax  # stack load f94290
# end emit-variable-ref
    mov %eax, -36(%esp)  # arg f94290
    movl -28(%esp), %edi   # load new closure to %edi
    add $-20, %esp   # adjust base
    movl $8,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $20, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    mov %eax, -20(%esp)    # arg ((primitive-ref list-ref) ((primitive-ref primitives)) f94290)
# emit-expr "arg must be a fixnum"
# string literal
    jmp _L_571373
    .align 8,0x90
_L_571372 :
    .int 80
    .ascii "arg must be a fixnum"
_L_571373:
    movl $_L_571372, %eax
    orl $6, %eax
    mov %eax, -24(%esp)    # arg arg must be a fixnum
    movl -16(%esp), %edi   # load new closure to %edi
# emit-shift-args:  size=3   si=-16  delta=12
    mov -16(%esp), %ebx  # shift frame cell
    mov %ebx, -4(%esp)  # down to base
# emit-shift-args:  size=2   si=-20  delta=12
    mov -20(%esp), %ebx  # shift frame cell
    mov %ebx, -8(%esp)  # down to base
# emit-shift-args:  size=1   si=-24  delta=12
    mov -24(%esp), %ebx  # shift frame cell
    mov %ebx, -12(%esp)  # down to base
# emit-shift-args:  size=0   si=-28  delta=12
    movl $8,%eax   # save arg count
    jmp *-2(%edi)  # tail-funcall
    .align 4,0x90
_L_571368:
     movl %eax, mrc_eh$ufixnum
# == explicit-begins  ==>
# (lambda (i) (error (list-ref (primitives) i) "arg must be a string"))
# == eliminate-let*  ==>
# (lambda (i) (error (list-ref (primitives) i) "arg must be a string"))
# == uniquify-variables  ==>
# (lambda (f94291) (error (list-ref (primitives) f94291) "arg must be a string"))
# == vectorize-letrec  ==>
# (lambda (f94291) (error (list-ref (primitives) f94291) "arg must be a string"))
# == eliminate-set!  ==>
# (lambda (f94291) (let ((f94291 f94291)) (error (list-ref (primitives) f94291) "arg must be a string")))
# == close-free-variables  ==>
# (closure (f94291) () (let ((f94291 f94291)) (error (list-ref (primitives) f94291) "arg must be a string")))
# == eliminate-quote  ==>
# (closure (f94291) () (let ((f94291 f94291)) (error (list-ref (primitives) f94291) "arg must be a string")))
# == eliminate-when/unless  ==>
# (closure (f94291) () (let ((f94291 f94291)) (error (list-ref (primitives) f94291) "arg must be a string")))
# == eliminate-cond  ==>
# (closure (f94291) () (let ((f94291 f94291)) (error (list-ref (primitives) f94291) "arg must be a string")))
# == external-symbols  ==>
# (closure (f94291) () (let ((f94291 f94291)) ((primitive-ref error) ((primitive-ref list-ref) ((primitive-ref primitives)) f94291) "arg must be a string")))
# emit-expr (closure (f94291) () (let ((f94291 f94291)) ((primitive-ref error) ((primitive-ref list-ref) ((primitive-ref primitives)) f94291) "arg must be a string")))
# emit-closure
# si = 0
# env = ()
# expr = (closure (f94291) () (let ((f94291 f94291)) ((primitive-ref error) ((primitive-ref list-ref) ((primitive-ref primitives)) f94291) "arg must be a string")))
    movl $_L_571374, 0(%ebp)  # closure label
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $8, %ebp     # bump ebp
    jmp _L_571375            # jump around closure body
_L_571374:
# check argument count
    cmp $4,%eax
    je _L_571376
# invoke error handler eh_argcount
    .extern mrc_eh$uargcount
    movl mrc_eh$uargcount, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_571376:
# emit-tail-expr
# si=-12
# env=((f94291 . -8))
# expr=(let ((f94291 f94291)) ((primitive-ref error) ((primitive-ref list-ref) ((primitive-ref primitives)) f94291) "arg must be a string"))
# emit-tail-let
#  si   = -12
#  env  = ((f94291 . -8))
#  bindings = ((f94291 f94291))
#  body = ((primitive-ref error) ((primitive-ref list-ref) ((primitive-ref primitives)) f94291) "arg must be a string")
# emit-expr f94291
# emit-variable-ref
# env=((f94291 . -8))
# var=f94291
    movl -8(%esp), %eax  # stack load f94291
# end emit-variable-ref
    movl %eax, -12(%esp)  # stack save
# emit-tail-expr
# si=-16
# env=((f94291 . -12) (f94291 . -8))
# expr=((primitive-ref error) ((primitive-ref list-ref) ((primitive-ref primitives)) f94291) "arg must be a string")
# emit-tail-funcall
#    si   =-16
#    env  = ((f94291 . -12) (f94291 . -8))
#    expr = (funcall (primitive-ref error) ((primitive-ref list-ref) ((primitive-ref primitives)) f94291) "arg must be a string")
# emit-expr (primitive-ref error)
    .extern mrc_error
    movl mrc_error,%eax
   movl %eax,  -16(%esp)  # stash funcall-oper in next closure slot
# emit-expr ((primitive-ref list-ref) ((primitive-ref primitives)) f94291)
# funcall
#    si   =-20
#    env  = ((f94291 . -12) (f94291 . -8))
#    expr = (funcall (primitive-ref list-ref) ((primitive-ref primitives)) f94291)
# emit-expr (primitive-ref list-ref)
    .extern mrc_list$mref
    movl mrc_list$mref,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_571377"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_571377":
   movl %eax,  -28(%esp)  # stash funcall-oper in closure slot
# emit-expr ((primitive-ref primitives))
# funcall
#    si   =-32
#    env  = ((f94291 . -12) (f94291 . -8))
#    expr = (funcall (primitive-ref primitives))
# emit-expr (primitive-ref primitives)
    .extern mrc_primitives
    movl mrc_primitives,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_571378"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_571378":
   movl %eax,  -40(%esp)  # stash funcall-oper in closure slot
    movl -40(%esp), %edi   # load new closure to %edi
    add $-32, %esp   # adjust base
    movl $0,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $32, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    mov %eax, -32(%esp)  # arg ((primitive-ref primitives))
# emit-expr f94291
# emit-variable-ref
# env=((f94291 . -12) (f94291 . -8))
# var=f94291
    movl -12(%esp), %eax  # stack load f94291
# end emit-variable-ref
    mov %eax, -36(%esp)  # arg f94291
    movl -28(%esp), %edi   # load new closure to %edi
    add $-20, %esp   # adjust base
    movl $8,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $20, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    mov %eax, -20(%esp)    # arg ((primitive-ref list-ref) ((primitive-ref primitives)) f94291)
# emit-expr "arg must be a string"
# string literal
    jmp _L_571380
    .align 8,0x90
_L_571379 :
    .int 80
    .ascii "arg must be a string"
_L_571380:
    movl $_L_571379, %eax
    orl $6, %eax
    mov %eax, -24(%esp)    # arg arg must be a string
    movl -16(%esp), %edi   # load new closure to %edi
# emit-shift-args:  size=3   si=-16  delta=12
    mov -16(%esp), %ebx  # shift frame cell
    mov %ebx, -4(%esp)  # down to base
# emit-shift-args:  size=2   si=-20  delta=12
    mov -20(%esp), %ebx  # shift frame cell
    mov %ebx, -8(%esp)  # down to base
# emit-shift-args:  size=1   si=-24  delta=12
    mov -24(%esp), %ebx  # shift frame cell
    mov %ebx, -12(%esp)  # down to base
# emit-shift-args:  size=0   si=-28  delta=12
    movl $8,%eax   # save arg count
    jmp *-2(%edi)  # tail-funcall
    .align 4,0x90
_L_571375:
     movl %eax, mrc_eh$ustring
# == explicit-begins  ==>
# (lambda (i) (error (list-ref (primitives) i) "arg must be a character"))
# == eliminate-let*  ==>
# (lambda (i) (error (list-ref (primitives) i) "arg must be a character"))
# == uniquify-variables  ==>
# (lambda (f94292) (error (list-ref (primitives) f94292) "arg must be a character"))
# == vectorize-letrec  ==>
# (lambda (f94292) (error (list-ref (primitives) f94292) "arg must be a character"))
# == eliminate-set!  ==>
# (lambda (f94292) (let ((f94292 f94292)) (error (list-ref (primitives) f94292) "arg must be a character")))
# == close-free-variables  ==>
# (closure (f94292) () (let ((f94292 f94292)) (error (list-ref (primitives) f94292) "arg must be a character")))
# == eliminate-quote  ==>
# (closure (f94292) () (let ((f94292 f94292)) (error (list-ref (primitives) f94292) "arg must be a character")))
# == eliminate-when/unless  ==>
# (closure (f94292) () (let ((f94292 f94292)) (error (list-ref (primitives) f94292) "arg must be a character")))
# == eliminate-cond  ==>
# (closure (f94292) () (let ((f94292 f94292)) (error (list-ref (primitives) f94292) "arg must be a character")))
# == external-symbols  ==>
# (closure (f94292) () (let ((f94292 f94292)) ((primitive-ref error) ((primitive-ref list-ref) ((primitive-ref primitives)) f94292) "arg must be a character")))
# emit-expr (closure (f94292) () (let ((f94292 f94292)) ((primitive-ref error) ((primitive-ref list-ref) ((primitive-ref primitives)) f94292) "arg must be a character")))
# emit-closure
# si = 0
# env = ()
# expr = (closure (f94292) () (let ((f94292 f94292)) ((primitive-ref error) ((primitive-ref list-ref) ((primitive-ref primitives)) f94292) "arg must be a character")))
    movl $_L_571381, 0(%ebp)  # closure label
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $8, %ebp     # bump ebp
    jmp _L_571382            # jump around closure body
_L_571381:
# check argument count
    cmp $4,%eax
    je _L_571383
# invoke error handler eh_argcount
    .extern mrc_eh$uargcount
    movl mrc_eh$uargcount, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_571383:
# emit-tail-expr
# si=-12
# env=((f94292 . -8))
# expr=(let ((f94292 f94292)) ((primitive-ref error) ((primitive-ref list-ref) ((primitive-ref primitives)) f94292) "arg must be a character"))
# emit-tail-let
#  si   = -12
#  env  = ((f94292 . -8))
#  bindings = ((f94292 f94292))
#  body = ((primitive-ref error) ((primitive-ref list-ref) ((primitive-ref primitives)) f94292) "arg must be a character")
# emit-expr f94292
# emit-variable-ref
# env=((f94292 . -8))
# var=f94292
    movl -8(%esp), %eax  # stack load f94292
# end emit-variable-ref
    movl %eax, -12(%esp)  # stack save
# emit-tail-expr
# si=-16
# env=((f94292 . -12) (f94292 . -8))
# expr=((primitive-ref error) ((primitive-ref list-ref) ((primitive-ref primitives)) f94292) "arg must be a character")
# emit-tail-funcall
#    si   =-16
#    env  = ((f94292 . -12) (f94292 . -8))
#    expr = (funcall (primitive-ref error) ((primitive-ref list-ref) ((primitive-ref primitives)) f94292) "arg must be a character")
# emit-expr (primitive-ref error)
    .extern mrc_error
    movl mrc_error,%eax
   movl %eax,  -16(%esp)  # stash funcall-oper in next closure slot
# emit-expr ((primitive-ref list-ref) ((primitive-ref primitives)) f94292)
# funcall
#    si   =-20
#    env  = ((f94292 . -12) (f94292 . -8))
#    expr = (funcall (primitive-ref list-ref) ((primitive-ref primitives)) f94292)
# emit-expr (primitive-ref list-ref)
    .extern mrc_list$mref
    movl mrc_list$mref,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_571384"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_571384":
   movl %eax,  -28(%esp)  # stash funcall-oper in closure slot
# emit-expr ((primitive-ref primitives))
# funcall
#    si   =-32
#    env  = ((f94292 . -12) (f94292 . -8))
#    expr = (funcall (primitive-ref primitives))
# emit-expr (primitive-ref primitives)
    .extern mrc_primitives
    movl mrc_primitives,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_571385"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_571385":
   movl %eax,  -40(%esp)  # stash funcall-oper in closure slot
    movl -40(%esp), %edi   # load new closure to %edi
    add $-32, %esp   # adjust base
    movl $0,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $32, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    mov %eax, -32(%esp)  # arg ((primitive-ref primitives))
# emit-expr f94292
# emit-variable-ref
# env=((f94292 . -12) (f94292 . -8))
# var=f94292
    movl -12(%esp), %eax  # stack load f94292
# end emit-variable-ref
    mov %eax, -36(%esp)  # arg f94292
    movl -28(%esp), %edi   # load new closure to %edi
    add $-20, %esp   # adjust base
    movl $8,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $20, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    mov %eax, -20(%esp)    # arg ((primitive-ref list-ref) ((primitive-ref primitives)) f94292)
# emit-expr "arg must be a character"
# string literal
    jmp _L_571387
    .align 8,0x90
_L_571386 :
    .int 92
    .ascii "arg must be a character"
_L_571387:
    movl $_L_571386, %eax
    orl $6, %eax
    mov %eax, -24(%esp)    # arg arg must be a character
    movl -16(%esp), %edi   # load new closure to %edi
# emit-shift-args:  size=3   si=-16  delta=12
    mov -16(%esp), %ebx  # shift frame cell
    mov %ebx, -4(%esp)  # down to base
# emit-shift-args:  size=2   si=-20  delta=12
    mov -20(%esp), %ebx  # shift frame cell
    mov %ebx, -8(%esp)  # down to base
# emit-shift-args:  size=1   si=-24  delta=12
    mov -24(%esp), %ebx  # shift frame cell
    mov %ebx, -12(%esp)  # down to base
# emit-shift-args:  size=0   si=-28  delta=12
    movl $8,%eax   # save arg count
    jmp *-2(%edi)  # tail-funcall
    .align 4,0x90
_L_571382:
     movl %eax, mrc_eh$ucharacter
# == explicit-begins  ==>
# (lambda (i) (error (list-ref (primitives) i) "arg must be a pair"))
# == eliminate-let*  ==>
# (lambda (i) (error (list-ref (primitives) i) "arg must be a pair"))
# == uniquify-variables  ==>
# (lambda (f94293) (error (list-ref (primitives) f94293) "arg must be a pair"))
# == vectorize-letrec  ==>
# (lambda (f94293) (error (list-ref (primitives) f94293) "arg must be a pair"))
# == eliminate-set!  ==>
# (lambda (f94293) (let ((f94293 f94293)) (error (list-ref (primitives) f94293) "arg must be a pair")))
# == close-free-variables  ==>
# (closure (f94293) () (let ((f94293 f94293)) (error (list-ref (primitives) f94293) "arg must be a pair")))
# == eliminate-quote  ==>
# (closure (f94293) () (let ((f94293 f94293)) (error (list-ref (primitives) f94293) "arg must be a pair")))
# == eliminate-when/unless  ==>
# (closure (f94293) () (let ((f94293 f94293)) (error (list-ref (primitives) f94293) "arg must be a pair")))
# == eliminate-cond  ==>
# (closure (f94293) () (let ((f94293 f94293)) (error (list-ref (primitives) f94293) "arg must be a pair")))
# == external-symbols  ==>
# (closure (f94293) () (let ((f94293 f94293)) ((primitive-ref error) ((primitive-ref list-ref) ((primitive-ref primitives)) f94293) "arg must be a pair")))
# emit-expr (closure (f94293) () (let ((f94293 f94293)) ((primitive-ref error) ((primitive-ref list-ref) ((primitive-ref primitives)) f94293) "arg must be a pair")))
# emit-closure
# si = 0
# env = ()
# expr = (closure (f94293) () (let ((f94293 f94293)) ((primitive-ref error) ((primitive-ref list-ref) ((primitive-ref primitives)) f94293) "arg must be a pair")))
    movl $_L_571388, 0(%ebp)  # closure label
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $8, %ebp     # bump ebp
    jmp _L_571389            # jump around closure body
_L_571388:
# check argument count
    cmp $4,%eax
    je _L_571390
# invoke error handler eh_argcount
    .extern mrc_eh$uargcount
    movl mrc_eh$uargcount, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_571390:
# emit-tail-expr
# si=-12
# env=((f94293 . -8))
# expr=(let ((f94293 f94293)) ((primitive-ref error) ((primitive-ref list-ref) ((primitive-ref primitives)) f94293) "arg must be a pair"))
# emit-tail-let
#  si   = -12
#  env  = ((f94293 . -8))
#  bindings = ((f94293 f94293))
#  body = ((primitive-ref error) ((primitive-ref list-ref) ((primitive-ref primitives)) f94293) "arg must be a pair")
# emit-expr f94293
# emit-variable-ref
# env=((f94293 . -8))
# var=f94293
    movl -8(%esp), %eax  # stack load f94293
# end emit-variable-ref
    movl %eax, -12(%esp)  # stack save
# emit-tail-expr
# si=-16
# env=((f94293 . -12) (f94293 . -8))
# expr=((primitive-ref error) ((primitive-ref list-ref) ((primitive-ref primitives)) f94293) "arg must be a pair")
# emit-tail-funcall
#    si   =-16
#    env  = ((f94293 . -12) (f94293 . -8))
#    expr = (funcall (primitive-ref error) ((primitive-ref list-ref) ((primitive-ref primitives)) f94293) "arg must be a pair")
# emit-expr (primitive-ref error)
    .extern mrc_error
    movl mrc_error,%eax
   movl %eax,  -16(%esp)  # stash funcall-oper in next closure slot
# emit-expr ((primitive-ref list-ref) ((primitive-ref primitives)) f94293)
# funcall
#    si   =-20
#    env  = ((f94293 . -12) (f94293 . -8))
#    expr = (funcall (primitive-ref list-ref) ((primitive-ref primitives)) f94293)
# emit-expr (primitive-ref list-ref)
    .extern mrc_list$mref
    movl mrc_list$mref,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_571391"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_571391":
   movl %eax,  -28(%esp)  # stash funcall-oper in closure slot
# emit-expr ((primitive-ref primitives))
# funcall
#    si   =-32
#    env  = ((f94293 . -12) (f94293 . -8))
#    expr = (funcall (primitive-ref primitives))
# emit-expr (primitive-ref primitives)
    .extern mrc_primitives
    movl mrc_primitives,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_571392"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_571392":
   movl %eax,  -40(%esp)  # stash funcall-oper in closure slot
    movl -40(%esp), %edi   # load new closure to %edi
    add $-32, %esp   # adjust base
    movl $0,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $32, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    mov %eax, -32(%esp)  # arg ((primitive-ref primitives))
# emit-expr f94293
# emit-variable-ref
# env=((f94293 . -12) (f94293 . -8))
# var=f94293
    movl -12(%esp), %eax  # stack load f94293
# end emit-variable-ref
    mov %eax, -36(%esp)  # arg f94293
    movl -28(%esp), %edi   # load new closure to %edi
    add $-20, %esp   # adjust base
    movl $8,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $20, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    mov %eax, -20(%esp)    # arg ((primitive-ref list-ref) ((primitive-ref primitives)) f94293)
# emit-expr "arg must be a pair"
# string literal
    jmp _L_571394
    .align 8,0x90
_L_571393 :
    .int 72
    .ascii "arg must be a pair"
_L_571394:
    movl $_L_571393, %eax
    orl $6, %eax
    mov %eax, -24(%esp)    # arg arg must be a pair
    movl -16(%esp), %edi   # load new closure to %edi
# emit-shift-args:  size=3   si=-16  delta=12
    mov -16(%esp), %ebx  # shift frame cell
    mov %ebx, -4(%esp)  # down to base
# emit-shift-args:  size=2   si=-20  delta=12
    mov -20(%esp), %ebx  # shift frame cell
    mov %ebx, -8(%esp)  # down to base
# emit-shift-args:  size=1   si=-24  delta=12
    mov -24(%esp), %ebx  # shift frame cell
    mov %ebx, -12(%esp)  # down to base
# emit-shift-args:  size=0   si=-28  delta=12
    movl $8,%eax   # save arg count
    jmp *-2(%edi)  # tail-funcall
    .align 4,0x90
_L_571389:
     movl %eax, mrc_eh$upair
# == explicit-begins  ==>
# (lambda (i) (error (list-ref (primitives) i) "arg must be a vector"))
# == eliminate-let*  ==>
# (lambda (i) (error (list-ref (primitives) i) "arg must be a vector"))
# == uniquify-variables  ==>
# (lambda (f94294) (error (list-ref (primitives) f94294) "arg must be a vector"))
# == vectorize-letrec  ==>
# (lambda (f94294) (error (list-ref (primitives) f94294) "arg must be a vector"))
# == eliminate-set!  ==>
# (lambda (f94294) (let ((f94294 f94294)) (error (list-ref (primitives) f94294) "arg must be a vector")))
# == close-free-variables  ==>
# (closure (f94294) () (let ((f94294 f94294)) (error (list-ref (primitives) f94294) "arg must be a vector")))
# == eliminate-quote  ==>
# (closure (f94294) () (let ((f94294 f94294)) (error (list-ref (primitives) f94294) "arg must be a vector")))
# == eliminate-when/unless  ==>
# (closure (f94294) () (let ((f94294 f94294)) (error (list-ref (primitives) f94294) "arg must be a vector")))
# == eliminate-cond  ==>
# (closure (f94294) () (let ((f94294 f94294)) (error (list-ref (primitives) f94294) "arg must be a vector")))
# == external-symbols  ==>
# (closure (f94294) () (let ((f94294 f94294)) ((primitive-ref error) ((primitive-ref list-ref) ((primitive-ref primitives)) f94294) "arg must be a vector")))
# emit-expr (closure (f94294) () (let ((f94294 f94294)) ((primitive-ref error) ((primitive-ref list-ref) ((primitive-ref primitives)) f94294) "arg must be a vector")))
# emit-closure
# si = 0
# env = ()
# expr = (closure (f94294) () (let ((f94294 f94294)) ((primitive-ref error) ((primitive-ref list-ref) ((primitive-ref primitives)) f94294) "arg must be a vector")))
    movl $_L_571395, 0(%ebp)  # closure label
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $8, %ebp     # bump ebp
    jmp _L_571396            # jump around closure body
_L_571395:
# check argument count
    cmp $4,%eax
    je _L_571397
# invoke error handler eh_argcount
    .extern mrc_eh$uargcount
    movl mrc_eh$uargcount, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_571397:
# emit-tail-expr
# si=-12
# env=((f94294 . -8))
# expr=(let ((f94294 f94294)) ((primitive-ref error) ((primitive-ref list-ref) ((primitive-ref primitives)) f94294) "arg must be a vector"))
# emit-tail-let
#  si   = -12
#  env  = ((f94294 . -8))
#  bindings = ((f94294 f94294))
#  body = ((primitive-ref error) ((primitive-ref list-ref) ((primitive-ref primitives)) f94294) "arg must be a vector")
# emit-expr f94294
# emit-variable-ref
# env=((f94294 . -8))
# var=f94294
    movl -8(%esp), %eax  # stack load f94294
# end emit-variable-ref
    movl %eax, -12(%esp)  # stack save
# emit-tail-expr
# si=-16
# env=((f94294 . -12) (f94294 . -8))
# expr=((primitive-ref error) ((primitive-ref list-ref) ((primitive-ref primitives)) f94294) "arg must be a vector")
# emit-tail-funcall
#    si   =-16
#    env  = ((f94294 . -12) (f94294 . -8))
#    expr = (funcall (primitive-ref error) ((primitive-ref list-ref) ((primitive-ref primitives)) f94294) "arg must be a vector")
# emit-expr (primitive-ref error)
    .extern mrc_error
    movl mrc_error,%eax
   movl %eax,  -16(%esp)  # stash funcall-oper in next closure slot
# emit-expr ((primitive-ref list-ref) ((primitive-ref primitives)) f94294)
# funcall
#    si   =-20
#    env  = ((f94294 . -12) (f94294 . -8))
#    expr = (funcall (primitive-ref list-ref) ((primitive-ref primitives)) f94294)
# emit-expr (primitive-ref list-ref)
    .extern mrc_list$mref
    movl mrc_list$mref,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_571398"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_571398":
   movl %eax,  -28(%esp)  # stash funcall-oper in closure slot
# emit-expr ((primitive-ref primitives))
# funcall
#    si   =-32
#    env  = ((f94294 . -12) (f94294 . -8))
#    expr = (funcall (primitive-ref primitives))
# emit-expr (primitive-ref primitives)
    .extern mrc_primitives
    movl mrc_primitives,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_571399"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_571399":
   movl %eax,  -40(%esp)  # stash funcall-oper in closure slot
    movl -40(%esp), %edi   # load new closure to %edi
    add $-32, %esp   # adjust base
    movl $0,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $32, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    mov %eax, -32(%esp)  # arg ((primitive-ref primitives))
# emit-expr f94294
# emit-variable-ref
# env=((f94294 . -12) (f94294 . -8))
# var=f94294
    movl -12(%esp), %eax  # stack load f94294
# end emit-variable-ref
    mov %eax, -36(%esp)  # arg f94294
    movl -28(%esp), %edi   # load new closure to %edi
    add $-20, %esp   # adjust base
    movl $8,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $20, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    mov %eax, -20(%esp)    # arg ((primitive-ref list-ref) ((primitive-ref primitives)) f94294)
# emit-expr "arg must be a vector"
# string literal
    jmp _L_571401
    .align 8,0x90
_L_571400 :
    .int 80
    .ascii "arg must be a vector"
_L_571401:
    movl $_L_571400, %eax
    orl $6, %eax
    mov %eax, -24(%esp)    # arg arg must be a vector
    movl -16(%esp), %edi   # load new closure to %edi
# emit-shift-args:  size=3   si=-16  delta=12
    mov -16(%esp), %ebx  # shift frame cell
    mov %ebx, -4(%esp)  # down to base
# emit-shift-args:  size=2   si=-20  delta=12
    mov -20(%esp), %ebx  # shift frame cell
    mov %ebx, -8(%esp)  # down to base
# emit-shift-args:  size=1   si=-24  delta=12
    mov -24(%esp), %ebx  # shift frame cell
    mov %ebx, -12(%esp)  # down to base
# emit-shift-args:  size=0   si=-28  delta=12
    movl $8,%eax   # save arg count
    jmp *-2(%edi)  # tail-funcall
    .align 4,0x90
_L_571396:
     movl %eax, mrc_eh$uvector
# == explicit-begins  ==>
# (lambda (i) (error (list-ref (primitives) i) "length must be a fixnum >= 0"))
# == eliminate-let*  ==>
# (lambda (i) (error (list-ref (primitives) i) "length must be a fixnum >= 0"))
# == uniquify-variables  ==>
# (lambda (f94295) (error (list-ref (primitives) f94295) "length must be a fixnum >= 0"))
# == vectorize-letrec  ==>
# (lambda (f94295) (error (list-ref (primitives) f94295) "length must be a fixnum >= 0"))
# == eliminate-set!  ==>
# (lambda (f94295) (let ((f94295 f94295)) (error (list-ref (primitives) f94295) "length must be a fixnum >= 0")))
# == close-free-variables  ==>
# (closure (f94295) () (let ((f94295 f94295)) (error (list-ref (primitives) f94295) "length must be a fixnum >= 0")))
# == eliminate-quote  ==>
# (closure (f94295) () (let ((f94295 f94295)) (error (list-ref (primitives) f94295) "length must be a fixnum >= 0")))
# == eliminate-when/unless  ==>
# (closure (f94295) () (let ((f94295 f94295)) (error (list-ref (primitives) f94295) "length must be a fixnum >= 0")))
# == eliminate-cond  ==>
# (closure (f94295) () (let ((f94295 f94295)) (error (list-ref (primitives) f94295) "length must be a fixnum >= 0")))
# == external-symbols  ==>
# (closure (f94295) () (let ((f94295 f94295)) ((primitive-ref error) ((primitive-ref list-ref) ((primitive-ref primitives)) f94295) "length must be a fixnum >= 0")))
# emit-expr (closure (f94295) () (let ((f94295 f94295)) ((primitive-ref error) ((primitive-ref list-ref) ((primitive-ref primitives)) f94295) "length must be a fixnum >= 0")))
# emit-closure
# si = 0
# env = ()
# expr = (closure (f94295) () (let ((f94295 f94295)) ((primitive-ref error) ((primitive-ref list-ref) ((primitive-ref primitives)) f94295) "length must be a fixnum >= 0")))
    movl $_L_571402, 0(%ebp)  # closure label
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $8, %ebp     # bump ebp
    jmp _L_571403            # jump around closure body
_L_571402:
# check argument count
    cmp $4,%eax
    je _L_571404
# invoke error handler eh_argcount
    .extern mrc_eh$uargcount
    movl mrc_eh$uargcount, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_571404:
# emit-tail-expr
# si=-12
# env=((f94295 . -8))
# expr=(let ((f94295 f94295)) ((primitive-ref error) ((primitive-ref list-ref) ((primitive-ref primitives)) f94295) "length must be a fixnum >= 0"))
# emit-tail-let
#  si   = -12
#  env  = ((f94295 . -8))
#  bindings = ((f94295 f94295))
#  body = ((primitive-ref error) ((primitive-ref list-ref) ((primitive-ref primitives)) f94295) "length must be a fixnum >= 0")
# emit-expr f94295
# emit-variable-ref
# env=((f94295 . -8))
# var=f94295
    movl -8(%esp), %eax  # stack load f94295
# end emit-variable-ref
    movl %eax, -12(%esp)  # stack save
# emit-tail-expr
# si=-16
# env=((f94295 . -12) (f94295 . -8))
# expr=((primitive-ref error) ((primitive-ref list-ref) ((primitive-ref primitives)) f94295) "length must be a fixnum >= 0")
# emit-tail-funcall
#    si   =-16
#    env  = ((f94295 . -12) (f94295 . -8))
#    expr = (funcall (primitive-ref error) ((primitive-ref list-ref) ((primitive-ref primitives)) f94295) "length must be a fixnum >= 0")
# emit-expr (primitive-ref error)
    .extern mrc_error
    movl mrc_error,%eax
   movl %eax,  -16(%esp)  # stash funcall-oper in next closure slot
# emit-expr ((primitive-ref list-ref) ((primitive-ref primitives)) f94295)
# funcall
#    si   =-20
#    env  = ((f94295 . -12) (f94295 . -8))
#    expr = (funcall (primitive-ref list-ref) ((primitive-ref primitives)) f94295)
# emit-expr (primitive-ref list-ref)
    .extern mrc_list$mref
    movl mrc_list$mref,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_571405"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_571405":
   movl %eax,  -28(%esp)  # stash funcall-oper in closure slot
# emit-expr ((primitive-ref primitives))
# funcall
#    si   =-32
#    env  = ((f94295 . -12) (f94295 . -8))
#    expr = (funcall (primitive-ref primitives))
# emit-expr (primitive-ref primitives)
    .extern mrc_primitives
    movl mrc_primitives,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_571406"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_571406":
   movl %eax,  -40(%esp)  # stash funcall-oper in closure slot
    movl -40(%esp), %edi   # load new closure to %edi
    add $-32, %esp   # adjust base
    movl $0,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $32, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    mov %eax, -32(%esp)  # arg ((primitive-ref primitives))
# emit-expr f94295
# emit-variable-ref
# env=((f94295 . -12) (f94295 . -8))
# var=f94295
    movl -12(%esp), %eax  # stack load f94295
# end emit-variable-ref
    mov %eax, -36(%esp)  # arg f94295
    movl -28(%esp), %edi   # load new closure to %edi
    add $-20, %esp   # adjust base
    movl $8,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $20, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    mov %eax, -20(%esp)    # arg ((primitive-ref list-ref) ((primitive-ref primitives)) f94295)
# emit-expr "length must be a fixnum >= 0"
# string literal
    jmp _L_571408
    .align 8,0x90
_L_571407 :
    .int 112
    .ascii "length must be a fixnum >= 0"
_L_571408:
    movl $_L_571407, %eax
    orl $6, %eax
    mov %eax, -24(%esp)    # arg length must be a fixnum >= 0
    movl -16(%esp), %edi   # load new closure to %edi
# emit-shift-args:  size=3   si=-16  delta=12
    mov -16(%esp), %ebx  # shift frame cell
    mov %ebx, -4(%esp)  # down to base
# emit-shift-args:  size=2   si=-20  delta=12
    mov -20(%esp), %ebx  # shift frame cell
    mov %ebx, -8(%esp)  # down to base
# emit-shift-args:  size=1   si=-24  delta=12
    mov -24(%esp), %ebx  # shift frame cell
    mov %ebx, -12(%esp)  # down to base
# emit-shift-args:  size=0   si=-28  delta=12
    movl $8,%eax   # save arg count
    jmp *-2(%edi)  # tail-funcall
    .align 4,0x90
_L_571403:
     movl %eax, mrc_eh$ulength
# == explicit-begins  ==>
# (lambda (i) (error (list-ref (primitives) i) "index out of bounds"))
# == eliminate-let*  ==>
# (lambda (i) (error (list-ref (primitives) i) "index out of bounds"))
# == uniquify-variables  ==>
# (lambda (f94296) (error (list-ref (primitives) f94296) "index out of bounds"))
# == vectorize-letrec  ==>
# (lambda (f94296) (error (list-ref (primitives) f94296) "index out of bounds"))
# == eliminate-set!  ==>
# (lambda (f94296) (let ((f94296 f94296)) (error (list-ref (primitives) f94296) "index out of bounds")))
# == close-free-variables  ==>
# (closure (f94296) () (let ((f94296 f94296)) (error (list-ref (primitives) f94296) "index out of bounds")))
# == eliminate-quote  ==>
# (closure (f94296) () (let ((f94296 f94296)) (error (list-ref (primitives) f94296) "index out of bounds")))
# == eliminate-when/unless  ==>
# (closure (f94296) () (let ((f94296 f94296)) (error (list-ref (primitives) f94296) "index out of bounds")))
# == eliminate-cond  ==>
# (closure (f94296) () (let ((f94296 f94296)) (error (list-ref (primitives) f94296) "index out of bounds")))
# == external-symbols  ==>
# (closure (f94296) () (let ((f94296 f94296)) ((primitive-ref error) ((primitive-ref list-ref) ((primitive-ref primitives)) f94296) "index out of bounds")))
# emit-expr (closure (f94296) () (let ((f94296 f94296)) ((primitive-ref error) ((primitive-ref list-ref) ((primitive-ref primitives)) f94296) "index out of bounds")))
# emit-closure
# si = 0
# env = ()
# expr = (closure (f94296) () (let ((f94296 f94296)) ((primitive-ref error) ((primitive-ref list-ref) ((primitive-ref primitives)) f94296) "index out of bounds")))
    movl $_L_571409, 0(%ebp)  # closure label
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $8, %ebp     # bump ebp
    jmp _L_571410            # jump around closure body
_L_571409:
# check argument count
    cmp $4,%eax
    je _L_571411
# invoke error handler eh_argcount
    .extern mrc_eh$uargcount
    movl mrc_eh$uargcount, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_571411:
# emit-tail-expr
# si=-12
# env=((f94296 . -8))
# expr=(let ((f94296 f94296)) ((primitive-ref error) ((primitive-ref list-ref) ((primitive-ref primitives)) f94296) "index out of bounds"))
# emit-tail-let
#  si   = -12
#  env  = ((f94296 . -8))
#  bindings = ((f94296 f94296))
#  body = ((primitive-ref error) ((primitive-ref list-ref) ((primitive-ref primitives)) f94296) "index out of bounds")
# emit-expr f94296
# emit-variable-ref
# env=((f94296 . -8))
# var=f94296
    movl -8(%esp), %eax  # stack load f94296
# end emit-variable-ref
    movl %eax, -12(%esp)  # stack save
# emit-tail-expr
# si=-16
# env=((f94296 . -12) (f94296 . -8))
# expr=((primitive-ref error) ((primitive-ref list-ref) ((primitive-ref primitives)) f94296) "index out of bounds")
# emit-tail-funcall
#    si   =-16
#    env  = ((f94296 . -12) (f94296 . -8))
#    expr = (funcall (primitive-ref error) ((primitive-ref list-ref) ((primitive-ref primitives)) f94296) "index out of bounds")
# emit-expr (primitive-ref error)
    .extern mrc_error
    movl mrc_error,%eax
   movl %eax,  -16(%esp)  # stash funcall-oper in next closure slot
# emit-expr ((primitive-ref list-ref) ((primitive-ref primitives)) f94296)
# funcall
#    si   =-20
#    env  = ((f94296 . -12) (f94296 . -8))
#    expr = (funcall (primitive-ref list-ref) ((primitive-ref primitives)) f94296)
# emit-expr (primitive-ref list-ref)
    .extern mrc_list$mref
    movl mrc_list$mref,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_571412"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_571412":
   movl %eax,  -28(%esp)  # stash funcall-oper in closure slot
# emit-expr ((primitive-ref primitives))
# funcall
#    si   =-32
#    env  = ((f94296 . -12) (f94296 . -8))
#    expr = (funcall (primitive-ref primitives))
# emit-expr (primitive-ref primitives)
    .extern mrc_primitives
    movl mrc_primitives,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_571413"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_571413":
   movl %eax,  -40(%esp)  # stash funcall-oper in closure slot
    movl -40(%esp), %edi   # load new closure to %edi
    add $-32, %esp   # adjust base
    movl $0,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $32, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    mov %eax, -32(%esp)  # arg ((primitive-ref primitives))
# emit-expr f94296
# emit-variable-ref
# env=((f94296 . -12) (f94296 . -8))
# var=f94296
    movl -12(%esp), %eax  # stack load f94296
# end emit-variable-ref
    mov %eax, -36(%esp)  # arg f94296
    movl -28(%esp), %edi   # load new closure to %edi
    add $-20, %esp   # adjust base
    movl $8,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $20, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    mov %eax, -20(%esp)    # arg ((primitive-ref list-ref) ((primitive-ref primitives)) f94296)
# emit-expr "index out of bounds"
# string literal
    jmp _L_571415
    .align 8,0x90
_L_571414 :
    .int 76
    .ascii "index out of bounds"
_L_571415:
    movl $_L_571414, %eax
    orl $6, %eax
    mov %eax, -24(%esp)    # arg index out of bounds
    movl -16(%esp), %edi   # load new closure to %edi
# emit-shift-args:  size=3   si=-16  delta=12
    mov -16(%esp), %ebx  # shift frame cell
    mov %ebx, -4(%esp)  # down to base
# emit-shift-args:  size=2   si=-20  delta=12
    mov -20(%esp), %ebx  # shift frame cell
    mov %ebx, -8(%esp)  # down to base
# emit-shift-args:  size=1   si=-24  delta=12
    mov -24(%esp), %ebx  # shift frame cell
    mov %ebx, -12(%esp)  # down to base
# emit-shift-args:  size=0   si=-28  delta=12
    movl $8,%eax   # save arg count
    jmp *-2(%edi)  # tail-funcall
    .align 4,0x90
_L_571410:
     movl %eax, mrc_eh$uvector$uindex
# == explicit-begins  ==>
# (lambda (i) (error (list-ref (primitives) i) "index out of bounds"))
# == eliminate-let*  ==>
# (lambda (i) (error (list-ref (primitives) i) "index out of bounds"))
# == uniquify-variables  ==>
# (lambda (f94297) (error (list-ref (primitives) f94297) "index out of bounds"))
# == vectorize-letrec  ==>
# (lambda (f94297) (error (list-ref (primitives) f94297) "index out of bounds"))
# == eliminate-set!  ==>
# (lambda (f94297) (let ((f94297 f94297)) (error (list-ref (primitives) f94297) "index out of bounds")))
# == close-free-variables  ==>
# (closure (f94297) () (let ((f94297 f94297)) (error (list-ref (primitives) f94297) "index out of bounds")))
# == eliminate-quote  ==>
# (closure (f94297) () (let ((f94297 f94297)) (error (list-ref (primitives) f94297) "index out of bounds")))
# == eliminate-when/unless  ==>
# (closure (f94297) () (let ((f94297 f94297)) (error (list-ref (primitives) f94297) "index out of bounds")))
# == eliminate-cond  ==>
# (closure (f94297) () (let ((f94297 f94297)) (error (list-ref (primitives) f94297) "index out of bounds")))
# == external-symbols  ==>
# (closure (f94297) () (let ((f94297 f94297)) ((primitive-ref error) ((primitive-ref list-ref) ((primitive-ref primitives)) f94297) "index out of bounds")))
# emit-expr (closure (f94297) () (let ((f94297 f94297)) ((primitive-ref error) ((primitive-ref list-ref) ((primitive-ref primitives)) f94297) "index out of bounds")))
# emit-closure
# si = 0
# env = ()
# expr = (closure (f94297) () (let ((f94297 f94297)) ((primitive-ref error) ((primitive-ref list-ref) ((primitive-ref primitives)) f94297) "index out of bounds")))
    movl $_L_571416, 0(%ebp)  # closure label
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $8, %ebp     # bump ebp
    jmp _L_571417            # jump around closure body
_L_571416:
# check argument count
    cmp $4,%eax
    je _L_571418
# invoke error handler eh_argcount
    .extern mrc_eh$uargcount
    movl mrc_eh$uargcount, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_571418:
# emit-tail-expr
# si=-12
# env=((f94297 . -8))
# expr=(let ((f94297 f94297)) ((primitive-ref error) ((primitive-ref list-ref) ((primitive-ref primitives)) f94297) "index out of bounds"))
# emit-tail-let
#  si   = -12
#  env  = ((f94297 . -8))
#  bindings = ((f94297 f94297))
#  body = ((primitive-ref error) ((primitive-ref list-ref) ((primitive-ref primitives)) f94297) "index out of bounds")
# emit-expr f94297
# emit-variable-ref
# env=((f94297 . -8))
# var=f94297
    movl -8(%esp), %eax  # stack load f94297
# end emit-variable-ref
    movl %eax, -12(%esp)  # stack save
# emit-tail-expr
# si=-16
# env=((f94297 . -12) (f94297 . -8))
# expr=((primitive-ref error) ((primitive-ref list-ref) ((primitive-ref primitives)) f94297) "index out of bounds")
# emit-tail-funcall
#    si   =-16
#    env  = ((f94297 . -12) (f94297 . -8))
#    expr = (funcall (primitive-ref error) ((primitive-ref list-ref) ((primitive-ref primitives)) f94297) "index out of bounds")
# emit-expr (primitive-ref error)
    .extern mrc_error
    movl mrc_error,%eax
   movl %eax,  -16(%esp)  # stash funcall-oper in next closure slot
# emit-expr ((primitive-ref list-ref) ((primitive-ref primitives)) f94297)
# funcall
#    si   =-20
#    env  = ((f94297 . -12) (f94297 . -8))
#    expr = (funcall (primitive-ref list-ref) ((primitive-ref primitives)) f94297)
# emit-expr (primitive-ref list-ref)
    .extern mrc_list$mref
    movl mrc_list$mref,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_571419"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_571419":
   movl %eax,  -28(%esp)  # stash funcall-oper in closure slot
# emit-expr ((primitive-ref primitives))
# funcall
#    si   =-32
#    env  = ((f94297 . -12) (f94297 . -8))
#    expr = (funcall (primitive-ref primitives))
# emit-expr (primitive-ref primitives)
    .extern mrc_primitives
    movl mrc_primitives,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_571420"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_571420":
   movl %eax,  -40(%esp)  # stash funcall-oper in closure slot
    movl -40(%esp), %edi   # load new closure to %edi
    add $-32, %esp   # adjust base
    movl $0,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $32, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    mov %eax, -32(%esp)  # arg ((primitive-ref primitives))
# emit-expr f94297
# emit-variable-ref
# env=((f94297 . -12) (f94297 . -8))
# var=f94297
    movl -12(%esp), %eax  # stack load f94297
# end emit-variable-ref
    mov %eax, -36(%esp)  # arg f94297
    movl -28(%esp), %edi   # load new closure to %edi
    add $-20, %esp   # adjust base
    movl $8,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $20, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    mov %eax, -20(%esp)    # arg ((primitive-ref list-ref) ((primitive-ref primitives)) f94297)
# emit-expr "index out of bounds"
# string literal
    jmp _L_571422
    .align 8,0x90
_L_571421 :
    .int 76
    .ascii "index out of bounds"
_L_571422:
    movl $_L_571421, %eax
    orl $6, %eax
    mov %eax, -24(%esp)    # arg index out of bounds
    movl -16(%esp), %edi   # load new closure to %edi
# emit-shift-args:  size=3   si=-16  delta=12
    mov -16(%esp), %ebx  # shift frame cell
    mov %ebx, -4(%esp)  # down to base
# emit-shift-args:  size=2   si=-20  delta=12
    mov -20(%esp), %ebx  # shift frame cell
    mov %ebx, -8(%esp)  # down to base
# emit-shift-args:  size=1   si=-24  delta=12
    mov -24(%esp), %ebx  # shift frame cell
    mov %ebx, -12(%esp)  # down to base
# emit-shift-args:  size=0   si=-28  delta=12
    movl $8,%eax   # save arg count
    jmp *-2(%edi)  # tail-funcall
    .align 4,0x90
_L_571417:
     movl %eax, mrc_eh$ustring$uindex
# == explicit-begins  ==>
# (lambda (z) (fxzero? z))
# == eliminate-let*  ==>
# (lambda (z) (fxzero? z))
# == uniquify-variables  ==>
# (lambda (f94298) (fxzero? f94298))
# == vectorize-letrec  ==>
# (lambda (f94298) (fxzero? f94298))
# == eliminate-set!  ==>
# (lambda (f94298) (let ((f94298 f94298)) (fxzero? f94298)))
# == close-free-variables  ==>
# (closure (f94298) () (let ((f94298 f94298)) (fxzero? f94298)))
# == eliminate-quote  ==>
# (closure (f94298) () (let ((f94298 f94298)) (fxzero? f94298)))
# == eliminate-when/unless  ==>
# (closure (f94298) () (let ((f94298 f94298)) (fxzero? f94298)))
# == eliminate-cond  ==>
# (closure (f94298) () (let ((f94298 f94298)) (fxzero? f94298)))
# == external-symbols  ==>
# (closure (f94298) () (let ((f94298 f94298)) (fxzero? f94298)))
# emit-expr (closure (f94298) () (let ((f94298 f94298)) (fxzero? f94298)))
# emit-closure
# si = 0
# env = ()
# expr = (closure (f94298) () (let ((f94298 f94298)) (fxzero? f94298)))
    movl $_L_571423, 0(%ebp)  # closure label
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $8, %ebp     # bump ebp
    jmp _L_571424            # jump around closure body
_L_571423:
# check argument count
    cmp $4,%eax
    je _L_571425
# invoke error handler eh_argcount
    .extern mrc_eh$uargcount
    movl mrc_eh$uargcount, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_571425:
# emit-tail-expr
# si=-12
# env=((f94298 . -8))
# expr=(let ((f94298 f94298)) (fxzero? f94298))
# emit-tail-let
#  si   = -12
#  env  = ((f94298 . -8))
#  bindings = ((f94298 f94298))
#  body = (fxzero? f94298)
# emit-expr f94298
# emit-variable-ref
# env=((f94298 . -8))
# var=f94298
    movl -8(%esp), %eax  # stack load f94298
# end emit-variable-ref
    movl %eax, -12(%esp)  # stack save
# emit-tail-expr
# si=-16
# env=((f94298 . -12) (f94298 . -8))
# expr=(fxzero? f94298)
# tail primcall
# emit-expr f94298
# emit-variable-ref
# env=((f94298 . -12) (f94298 . -8))
# var=f94298
    movl -12(%esp), %eax  # stack load f94298
# end emit-variable-ref
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_571426"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $64,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_571426:
    cmp $0, %eax
    sete %al
    movzbl %al, %eax
    sal $6, %al
    or $47, %al
#return from tail (fxzero? f94298)
    ret
    .align 4,0x90
_L_571424:
     movl %eax, mrc_zero$q
# == explicit-begins  ==>
# (lambda (x) (fx> x 0))
# == eliminate-let*  ==>
# (lambda (x) (fx> x 0))
# == uniquify-variables  ==>
# (lambda (f94299) (fx> f94299 0))
# == vectorize-letrec  ==>
# (lambda (f94299) (fx> f94299 0))
# == eliminate-set!  ==>
# (lambda (f94299) (let ((f94299 f94299)) (fx> f94299 0)))
# == close-free-variables  ==>
# (closure (f94299) () (let ((f94299 f94299)) (fx> f94299 0)))
# == eliminate-quote  ==>
# (closure (f94299) () (let ((f94299 f94299)) (fx> f94299 0)))
# == eliminate-when/unless  ==>
# (closure (f94299) () (let ((f94299 f94299)) (fx> f94299 0)))
# == eliminate-cond  ==>
# (closure (f94299) () (let ((f94299 f94299)) (fx> f94299 0)))
# == external-symbols  ==>
# (closure (f94299) () (let ((f94299 f94299)) (fx> f94299 0)))
# emit-expr (closure (f94299) () (let ((f94299 f94299)) (fx> f94299 0)))
# emit-closure
# si = 0
# env = ()
# expr = (closure (f94299) () (let ((f94299 f94299)) (fx> f94299 0)))
    movl $_L_571427, 0(%ebp)  # closure label
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $8, %ebp     # bump ebp
    jmp _L_571428            # jump around closure body
_L_571427:
# check argument count
    cmp $4,%eax
    je _L_571429
# invoke error handler eh_argcount
    .extern mrc_eh$uargcount
    movl mrc_eh$uargcount, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_571429:
# emit-tail-expr
# si=-12
# env=((f94299 . -8))
# expr=(let ((f94299 f94299)) (fx> f94299 0))
# emit-tail-let
#  si   = -12
#  env  = ((f94299 . -8))
#  bindings = ((f94299 f94299))
#  body = (fx> f94299 0)
# emit-expr f94299
# emit-variable-ref
# env=((f94299 . -8))
# var=f94299
    movl -8(%esp), %eax  # stack load f94299
# end emit-variable-ref
    movl %eax, -12(%esp)  # stack save
# emit-tail-expr
# si=-16
# env=((f94299 . -12) (f94299 . -8))
# expr=(fx> f94299 0)
# tail primcall
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_571430"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $80,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_571430:
    movl %eax, -16(%esp)
# emit-expr f94299
# emit-variable-ref
# env=((f94299 . -12) (f94299 . -8))
# var=f94299
    movl -12(%esp), %eax  # stack load f94299
# end emit-variable-ref
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_571431"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $80,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_571431:
    cmp -16(%esp), %eax
    setg %al
    movzbl %al, %eax
    sal $6, %al
    or $47, %al
#return from tail (fx> f94299 0)
    ret
    .align 4,0x90
_L_571428:
     movl %eax, mrc_positive$q
# == explicit-begins  ==>
# (lambda (x) (fx< x 0))
# == eliminate-let*  ==>
# (lambda (x) (fx< x 0))
# == uniquify-variables  ==>
# (lambda (f94300) (fx< f94300 0))
# == vectorize-letrec  ==>
# (lambda (f94300) (fx< f94300 0))
# == eliminate-set!  ==>
# (lambda (f94300) (let ((f94300 f94300)) (fx< f94300 0)))
# == close-free-variables  ==>
# (closure (f94300) () (let ((f94300 f94300)) (fx< f94300 0)))
# == eliminate-quote  ==>
# (closure (f94300) () (let ((f94300 f94300)) (fx< f94300 0)))
# == eliminate-when/unless  ==>
# (closure (f94300) () (let ((f94300 f94300)) (fx< f94300 0)))
# == eliminate-cond  ==>
# (closure (f94300) () (let ((f94300 f94300)) (fx< f94300 0)))
# == external-symbols  ==>
# (closure (f94300) () (let ((f94300 f94300)) (fx< f94300 0)))
# emit-expr (closure (f94300) () (let ((f94300 f94300)) (fx< f94300 0)))
# emit-closure
# si = 0
# env = ()
# expr = (closure (f94300) () (let ((f94300 f94300)) (fx< f94300 0)))
    movl $_L_571432, 0(%ebp)  # closure label
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $8, %ebp     # bump ebp
    jmp _L_571433            # jump around closure body
_L_571432:
# check argument count
    cmp $4,%eax
    je _L_571434
# invoke error handler eh_argcount
    .extern mrc_eh$uargcount
    movl mrc_eh$uargcount, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_571434:
# emit-tail-expr
# si=-12
# env=((f94300 . -8))
# expr=(let ((f94300 f94300)) (fx< f94300 0))
# emit-tail-let
#  si   = -12
#  env  = ((f94300 . -8))
#  bindings = ((f94300 f94300))
#  body = (fx< f94300 0)
# emit-expr f94300
# emit-variable-ref
# env=((f94300 . -8))
# var=f94300
    movl -8(%esp), %eax  # stack load f94300
# end emit-variable-ref
    movl %eax, -12(%esp)  # stack save
# emit-tail-expr
# si=-16
# env=((f94300 . -12) (f94300 . -8))
# expr=(fx< f94300 0)
# tail primcall
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_571435"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $72,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_571435:
    movl %eax, -16(%esp)
# emit-expr f94300
# emit-variable-ref
# env=((f94300 . -12) (f94300 . -8))
# var=f94300
    movl -12(%esp), %eax  # stack load f94300
# end emit-variable-ref
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_571436"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $72,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_571436:
    cmp -16(%esp), %eax
    setl %al
    movzbl %al, %eax
    sal $6, %al
    or $47, %al
#return from tail (fx< f94300 0)
    ret
    .align 4,0x90
_L_571433:
     movl %eax, mrc_negative$q
# == explicit-begins  ==>
# (lambda (x) (fxzero? (fxremainder x 2)))
# == eliminate-let*  ==>
# (lambda (x) (fxzero? (fxremainder x 2)))
# == uniquify-variables  ==>
# (lambda (f94301) (fxzero? (fxremainder f94301 2)))
# == vectorize-letrec  ==>
# (lambda (f94301) (fxzero? (fxremainder f94301 2)))
# == eliminate-set!  ==>
# (lambda (f94301) (let ((f94301 f94301)) (fxzero? (fxremainder f94301 2))))
# == close-free-variables  ==>
# (closure (f94301) () (let ((f94301 f94301)) (fxzero? (fxremainder f94301 2))))
# == eliminate-quote  ==>
# (closure (f94301) () (let ((f94301 f94301)) (fxzero? (fxremainder f94301 2))))
# == eliminate-when/unless  ==>
# (closure (f94301) () (let ((f94301 f94301)) (fxzero? (fxremainder f94301 2))))
# == eliminate-cond  ==>
# (closure (f94301) () (let ((f94301 f94301)) (fxzero? (fxremainder f94301 2))))
# == external-symbols  ==>
# (closure (f94301) () (let ((f94301 f94301)) (fxzero? (fxremainder f94301 2))))
# emit-expr (closure (f94301) () (let ((f94301 f94301)) (fxzero? (fxremainder f94301 2))))
# emit-closure
# si = 0
# env = ()
# expr = (closure (f94301) () (let ((f94301 f94301)) (fxzero? (fxremainder f94301 2))))
    movl $_L_571437, 0(%ebp)  # closure label
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $8, %ebp     # bump ebp
    jmp _L_571438            # jump around closure body
_L_571437:
# check argument count
    cmp $4,%eax
    je _L_571439
# invoke error handler eh_argcount
    .extern mrc_eh$uargcount
    movl mrc_eh$uargcount, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_571439:
# emit-tail-expr
# si=-12
# env=((f94301 . -8))
# expr=(let ((f94301 f94301)) (fxzero? (fxremainder f94301 2)))
# emit-tail-let
#  si   = -12
#  env  = ((f94301 . -8))
#  bindings = ((f94301 f94301))
#  body = (fxzero? (fxremainder f94301 2))
# emit-expr f94301
# emit-variable-ref
# env=((f94301 . -8))
# var=f94301
    movl -8(%esp), %eax  # stack load f94301
# end emit-variable-ref
    movl %eax, -12(%esp)  # stack save
# emit-tail-expr
# si=-16
# env=((f94301 . -12) (f94301 . -8))
# expr=(fxzero? (fxremainder f94301 2))
# tail primcall
# emit-expr (fxremainder f94301 2)
# emit-expr 2
    movl $8, %eax     # immed 2
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_571441"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $100,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_571441:
    movl %eax, -16(%esp)  # denominator
# emit-expr f94301
# emit-variable-ref
# env=((f94301 . -12) (f94301 . -8))
# var=f94301
    movl -12(%esp), %eax  # stack load f94301
# end emit-variable-ref
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_571442"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $100,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_571442:
    movl -16(%esp),%ebx   # ebx <- denominator
    xor %edx,%edx        # edx <- 0
    cmp $0,%eax
    jge _L_571440
    not %edx
_L_571440:
    idiv %ebx            # edx <- edx:eax/ebx  remainder
    movl %edx,%eax
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_571443"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $64,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_571443:
    cmp $0, %eax
    sete %al
    movzbl %al, %eax
    sal $6, %al
    or $47, %al
#return from tail (fxzero? (fxremainder f94301 2))
    ret
    .align 4,0x90
_L_571438:
     movl %eax, mrc_even$q
# == explicit-begins  ==>
# (lambda (x) (not (even? x)))
# == eliminate-let*  ==>
# (lambda (x) (not (even? x)))
# == uniquify-variables  ==>
# (lambda (f94302) (not (even? f94302)))
# == vectorize-letrec  ==>
# (lambda (f94302) (not (even? f94302)))
# == eliminate-set!  ==>
# (lambda (f94302) (let ((f94302 f94302)) (not (even? f94302))))
# == close-free-variables  ==>
# (closure (f94302) () (let ((f94302 f94302)) (not (even? f94302))))
# == eliminate-quote  ==>
# (closure (f94302) () (let ((f94302 f94302)) (not (even? f94302))))
# == eliminate-when/unless  ==>
# (closure (f94302) () (let ((f94302 f94302)) (not (even? f94302))))
# == eliminate-cond  ==>
# (closure (f94302) () (let ((f94302 f94302)) (not (even? f94302))))
# == external-symbols  ==>
# (closure (f94302) () (let ((f94302 f94302)) (not ((primitive-ref even?) f94302))))
# emit-expr (closure (f94302) () (let ((f94302 f94302)) (not ((primitive-ref even?) f94302))))
# emit-closure
# si = 0
# env = ()
# expr = (closure (f94302) () (let ((f94302 f94302)) (not ((primitive-ref even?) f94302))))
    movl $_L_571444, 0(%ebp)  # closure label
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $8, %ebp     # bump ebp
    jmp _L_571445            # jump around closure body
_L_571444:
# check argument count
    cmp $4,%eax
    je _L_571446
# invoke error handler eh_argcount
    .extern mrc_eh$uargcount
    movl mrc_eh$uargcount, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_571446:
# emit-tail-expr
# si=-12
# env=((f94302 . -8))
# expr=(let ((f94302 f94302)) (not ((primitive-ref even?) f94302)))
# emit-tail-let
#  si   = -12
#  env  = ((f94302 . -8))
#  bindings = ((f94302 f94302))
#  body = (not ((primitive-ref even?) f94302))
# emit-expr f94302
# emit-variable-ref
# env=((f94302 . -8))
# var=f94302
    movl -8(%esp), %eax  # stack load f94302
# end emit-variable-ref
    movl %eax, -12(%esp)  # stack save
# emit-tail-expr
# si=-16
# env=((f94302 . -12) (f94302 . -8))
# expr=(not ((primitive-ref even?) f94302))
# tail primcall
# emit-expr ((primitive-ref even?) f94302)
# funcall
#    si   =-16
#    env  = ((f94302 . -12) (f94302 . -8))
#    expr = (funcall (primitive-ref even?) f94302)
# emit-expr (primitive-ref even?)
    .extern mrc_even$q
    movl mrc_even$q,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_571447"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_571447":
   movl %eax,  -24(%esp)  # stash funcall-oper in closure slot
# emit-expr f94302
# emit-variable-ref
# env=((f94302 . -12) (f94302 . -8))
# var=f94302
    movl -12(%esp), %eax  # stack load f94302
# end emit-variable-ref
    mov %eax, -28(%esp)  # arg f94302
    movl -24(%esp), %edi   # load new closure to %edi
    add $-16, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $16, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    cmp $47, %eax
    sete %al
    movzbl %al, %eax
    sal $6, %al
    or $47, %al
#return from tail (not ((primitive-ref even?) f94302))
    ret
    .align 4,0x90
_L_571445:
     movl %eax, mrc_odd$q
# == explicit-begins  ==>
# (lambda (f l) (if (null? l) (quote ()) (cons (f (car l)) (map f (cdr l)))))
# == eliminate-let*  ==>
# (lambda (f l) (if (null? l) (quote ()) (cons (f (car l)) (map f (cdr l)))))
# == uniquify-variables  ==>
# (lambda (f94303 f94304) (if (null? f94304) (quote ()) (cons (f94303 (car f94304)) (map f94303 (cdr f94304)))))
# == vectorize-letrec  ==>
# (lambda (f94303 f94304) (if (null? f94304) (quote ()) (cons (f94303 (car f94304)) (map f94303 (cdr f94304)))))
# == eliminate-set!  ==>
# (lambda (f94303 f94304) (let ((f94303 f94303) (f94304 f94304)) (if (null? f94304) (quote ()) (cons (f94303 (car f94304)) (map f94303 (cdr f94304))))))
# == close-free-variables  ==>
# (closure (f94303 f94304) () (let ((f94303 f94303) (f94304 f94304)) (if (null? f94304) (quote ()) (cons (f94303 (car f94304)) (map f94303 (cdr f94304))))))
# == eliminate-quote  ==>
# (closure (f94303 f94304) () (let ((f94303 f94303) (f94304 f94304)) (if (null? f94304) () (cons (f94303 (car f94304)) (map f94303 (cdr f94304))))))
# == eliminate-when/unless  ==>
# (closure (f94303 f94304) () (let ((f94303 f94303) (f94304 f94304)) (if (null? f94304) () (cons (f94303 (car f94304)) (map f94303 (cdr f94304))))))
# == eliminate-cond  ==>
# (closure (f94303 f94304) () (let ((f94303 f94303) (f94304 f94304)) (if (null? f94304) () (cons (f94303 (car f94304)) (map f94303 (cdr f94304))))))
# == external-symbols  ==>
# (closure (f94303 f94304) () (let ((f94303 f94303) (f94304 f94304)) (if (null? f94304) () (cons (f94303 (car f94304)) ((primitive-ref map) f94303 (cdr f94304))))))
# emit-expr (closure (f94303 f94304) () (let ((f94303 f94303) (f94304 f94304)) (if (null? f94304) () (cons (f94303 (car f94304)) ((primitive-ref map) f94303 (cdr f94304))))))
# emit-closure
# si = 0
# env = ()
# expr = (closure (f94303 f94304) () (let ((f94303 f94303) (f94304 f94304)) (if (null? f94304) () (cons (f94303 (car f94304)) ((primitive-ref map) f94303 (cdr f94304))))))
    movl $_L_571448, 0(%ebp)  # closure label
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $8, %ebp     # bump ebp
    jmp _L_571449            # jump around closure body
_L_571448:
# check argument count
    cmp $8,%eax
    je _L_571450
# invoke error handler eh_argcount
    .extern mrc_eh$uargcount
    movl mrc_eh$uargcount, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_571450:
# emit-tail-expr
# si=-16
# env=((f94304 . -12) (f94303 . -8))
# expr=(let ((f94303 f94303) (f94304 f94304)) (if (null? f94304) () (cons (f94303 (car f94304)) ((primitive-ref map) f94303 (cdr f94304)))))
# emit-tail-let
#  si   = -16
#  env  = ((f94304 . -12) (f94303 . -8))
#  bindings = ((f94303 f94303) (f94304 f94304))
#  body = (if (null? f94304) () (cons (f94303 (car f94304)) ((primitive-ref map) f94303 (cdr f94304))))
# emit-expr f94303
# emit-variable-ref
# env=((f94304 . -12) (f94303 . -8))
# var=f94303
    movl -8(%esp), %eax  # stack load f94303
# end emit-variable-ref
    movl %eax, -16(%esp)  # stack save
# emit-expr f94304
# emit-variable-ref
# env=((f94304 . -12) (f94303 . -8))
# var=f94304
    movl -12(%esp), %eax  # stack load f94304
# end emit-variable-ref
    movl %eax, -20(%esp)  # stack save
# emit-tail-expr
# si=-24
# env=((f94304 . -20) (f94303 . -16) (f94304 . -12) (f94303 . -8))
# expr=(if (null? f94304) () (cons (f94303 (car f94304)) ((primitive-ref map) f94303 (cdr f94304))))
# emit-expr (null? f94304)
# emit-expr f94304
# emit-variable-ref
# env=((f94304 . -20) (f94303 . -16) (f94304 . -12) (f94303 . -8))
# var=f94304
    movl -20(%esp), %eax  # stack load f94304
# end emit-variable-ref
    cmp $63, %eax
    mov $0, %eax
    sete %al
    movzbl %al, %eax
    sal $6, %al
    or $47, %al
    cmp $47, %al
    je _L_571451
# emit-tail-expr
# si=-24
# env=((f94304 . -20) (f94303 . -16) (f94304 . -12) (f94303 . -8))
# expr=()
    movl $63, %eax     # immed ()
    ret                  # immediate tail return
    jmp _L_571452
_L_571451:
# emit-tail-expr
# si=-24
# env=((f94304 . -20) (f94303 . -16) (f94304 . -12) (f94303 . -8))
# expr=(cons (f94303 (car f94304)) ((primitive-ref map) f94303 (cdr f94304)))
# tail primcall
# cons arg1=(f94303 (car f94304)) arg2=((primitive-ref map) f94303 (cdr f94304))
# emit-expr (f94303 (car f94304))
# funcall
#    si   =-24
#    env  = ((f94304 . -20) (f94303 . -16) (f94304 . -12) (f94303 . -8))
#    expr = (funcall f94303 (car f94304))
# emit-expr f94303
# emit-variable-ref
# env=((f94304 . -20) (f94303 . -16) (f94304 . -12) (f94303 . -8))
# var=f94303
    movl -16(%esp), %eax  # stack load f94303
# end emit-variable-ref
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_571453"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_571453":
   movl %eax,  -32(%esp)  # stash funcall-oper in closure slot
# emit-expr (car f94304)
# emit-expr f94304
# emit-variable-ref
# env=((f94304 . -20) (f94303 . -16) (f94304 . -12) (f94303 . -8))
# var=f94304
    movl -20(%esp), %eax  # stack load f94304
# end emit-variable-ref
# check the argument is a pair
    movl %eax,%ebx
    and $7, %bl
    cmp $1, %bl
    je _L_571454
# invoke error handler eh_pair
    .extern mrc_eh$upair
    movl mrc_eh$upair, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $116,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_571454:
    movl -1(%eax), %eax
    mov %eax, -36(%esp)  # arg (car f94304)
    movl -32(%esp), %edi   # load new closure to %edi
    add $-24, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $24, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    movl %eax, -24(%esp)
# emit-expr ((primitive-ref map) f94303 (cdr f94304))
# funcall
#    si   =-28
#    env  = ((f94304 . -20) (f94303 . -16) (f94304 . -12) (f94303 . -8))
#    expr = (funcall (primitive-ref map) f94303 (cdr f94304))
# emit-expr (primitive-ref map)
    .extern mrc_map
    movl mrc_map,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_571455"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_571455":
   movl %eax,  -36(%esp)  # stash funcall-oper in closure slot
# emit-expr f94303
# emit-variable-ref
# env=((f94304 . -20) (f94303 . -16) (f94304 . -12) (f94303 . -8))
# var=f94303
    movl -16(%esp), %eax  # stack load f94303
# end emit-variable-ref
    mov %eax, -40(%esp)  # arg f94303
# emit-expr (cdr f94304)
# emit-expr f94304
# emit-variable-ref
# env=((f94304 . -20) (f94303 . -16) (f94304 . -12) (f94303 . -8))
# var=f94304
    movl -20(%esp), %eax  # stack load f94304
# end emit-variable-ref
# check the argument is a pair
    movl %eax,%ebx
    and $7, %bl
    cmp $1, %bl
    je _L_571456
# invoke error handler eh_pair
    .extern mrc_eh$upair
    movl mrc_eh$upair, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $120,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_571456:
    movl 3(%eax), %eax
    mov %eax, -44(%esp)  # arg (cdr f94304)
    movl -36(%esp), %edi   # load new closure to %edi
    add $-28, %esp   # adjust base
    movl $8,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $28, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    movl %eax, 4(%ebp)
    movl -24(%esp), %eax
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    or   $1, %al
    add  $8, %ebp
# cons end
#return from tail (cons (f94303 (car f94304)) ((primitive-ref map) f94303 (cdr f94304)))
    ret
_L_571452:
    .align 4,0x90
_L_571449:
     movl %eax, mrc_map
# == explicit-begins  ==>
# (lambda (f l) (unless (null? l) (begin (f (car l)) (for-each f (cdr l)))))
# == eliminate-let*  ==>
# (lambda (f l) (unless (null? l) (begin (f (car l)) (for-each f (cdr l)))))
# == uniquify-variables  ==>
# (lambda (f94305 f94306) (unless (null? f94306) (begin (f94305 (car f94306)) (for-each f94305 (cdr f94306)))))
# == vectorize-letrec  ==>
# (lambda (f94305 f94306) (unless (null? f94306) (begin (f94305 (car f94306)) (for-each f94305 (cdr f94306)))))
# == eliminate-set!  ==>
# (lambda (f94305 f94306) (let ((f94305 f94305) (f94306 f94306)) (unless (null? f94306) (begin (f94305 (car f94306)) (for-each f94305 (cdr f94306))))))
# == close-free-variables  ==>
# (closure (f94305 f94306) () (let ((f94305 f94305) (f94306 f94306)) (unless (null? f94306) (begin (f94305 (car f94306)) (for-each f94305 (cdr f94306))))))
# == eliminate-quote  ==>
# (closure (f94305 f94306) () (let ((f94305 f94305) (f94306 f94306)) (unless (null? f94306) (begin (f94305 (car f94306)) (for-each f94305 (cdr f94306))))))
# == eliminate-when/unless  ==>
# (closure (f94305 f94306) () (let ((f94305 f94305) (f94306 f94306)) (if (not (null? f94306)) (begin (begin (f94305 (car f94306)) (for-each f94305 (cdr f94306)))) #f)))
# == eliminate-cond  ==>
# (closure (f94305 f94306) () (let ((f94305 f94305) (f94306 f94306)) (if (not (null? f94306)) (begin (begin (f94305 (car f94306)) (for-each f94305 (cdr f94306)))) #f)))
# == external-symbols  ==>
# (closure (f94305 f94306) () (let ((f94305 f94305) (f94306 f94306)) (if (not (null? f94306)) (begin (begin (f94305 (car f94306)) ((primitive-ref for-each) f94305 (cdr f94306)))) #f)))
# emit-expr (closure (f94305 f94306) () (let ((f94305 f94305) (f94306 f94306)) (if (not (null? f94306)) (begin (begin (f94305 (car f94306)) ((primitive-ref for-each) f94305 (cdr f94306)))) #f)))
# emit-closure
# si = 0
# env = ()
# expr = (closure (f94305 f94306) () (let ((f94305 f94305) (f94306 f94306)) (if (not (null? f94306)) (begin (begin (f94305 (car f94306)) ((primitive-ref for-each) f94305 (cdr f94306)))) #f)))
    movl $_L_571457, 0(%ebp)  # closure label
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $8, %ebp     # bump ebp
    jmp _L_571458            # jump around closure body
_L_571457:
# check argument count
    cmp $8,%eax
    je _L_571459
# invoke error handler eh_argcount
    .extern mrc_eh$uargcount
    movl mrc_eh$uargcount, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_571459:
# emit-tail-expr
# si=-16
# env=((f94306 . -12) (f94305 . -8))
# expr=(let ((f94305 f94305) (f94306 f94306)) (if (not (null? f94306)) (begin (begin (f94305 (car f94306)) ((primitive-ref for-each) f94305 (cdr f94306)))) #f))
# emit-tail-let
#  si   = -16
#  env  = ((f94306 . -12) (f94305 . -8))
#  bindings = ((f94305 f94305) (f94306 f94306))
#  body = (if (not (null? f94306)) (begin (begin (f94305 (car f94306)) ((primitive-ref for-each) f94305 (cdr f94306)))) #f)
# emit-expr f94305
# emit-variable-ref
# env=((f94306 . -12) (f94305 . -8))
# var=f94305
    movl -8(%esp), %eax  # stack load f94305
# end emit-variable-ref
    movl %eax, -16(%esp)  # stack save
# emit-expr f94306
# emit-variable-ref
# env=((f94306 . -12) (f94305 . -8))
# var=f94306
    movl -12(%esp), %eax  # stack load f94306
# end emit-variable-ref
    movl %eax, -20(%esp)  # stack save
# emit-tail-expr
# si=-24
# env=((f94306 . -20) (f94305 . -16) (f94306 . -12) (f94305 . -8))
# expr=(if (not (null? f94306)) (begin (begin (f94305 (car f94306)) ((primitive-ref for-each) f94305 (cdr f94306)))) #f)
# emit-expr (not (null? f94306))
# emit-expr (null? f94306)
# emit-expr f94306
# emit-variable-ref
# env=((f94306 . -20) (f94305 . -16) (f94306 . -12) (f94305 . -8))
# var=f94306
    movl -20(%esp), %eax  # stack load f94306
# end emit-variable-ref
    cmp $63, %eax
    mov $0, %eax
    sete %al
    movzbl %al, %eax
    sal $6, %al
    or $47, %al
    cmp $47, %eax
    sete %al
    movzbl %al, %eax
    sal $6, %al
    or $47, %al
    cmp $47, %al
    je _L_571460
# emit-tail-expr
# si=-24
# env=((f94306 . -20) (f94305 . -16) (f94306 . -12) (f94305 . -8))
# expr=(begin (begin (f94305 (car f94306)) ((primitive-ref for-each) f94305 (cdr f94306))))
# tail-begin (begin (begin (f94305 (car f94306)) ((primitive-ref for-each) f94305 (cdr f94306))))
#   env=((f94306 . -20) (f94305 . -16) (f94306 . -12) (f94305 . -8))
# emit-tail-expr
# si=-24
# env=((f94306 . -20) (f94305 . -16) (f94306 . -12) (f94305 . -8))
# expr=(begin (f94305 (car f94306)) ((primitive-ref for-each) f94305 (cdr f94306)))
# tail-begin (begin (f94305 (car f94306)) ((primitive-ref for-each) f94305 (cdr f94306)))
#   env=((f94306 . -20) (f94305 . -16) (f94306 . -12) (f94305 . -8))
# emit-expr (f94305 (car f94306))
# funcall
#    si   =-24
#    env  = ((f94306 . -20) (f94305 . -16) (f94306 . -12) (f94305 . -8))
#    expr = (funcall f94305 (car f94306))
# emit-expr f94305
# emit-variable-ref
# env=((f94306 . -20) (f94305 . -16) (f94306 . -12) (f94305 . -8))
# var=f94305
    movl -16(%esp), %eax  # stack load f94305
# end emit-variable-ref
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_571462"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_571462":
   movl %eax,  -32(%esp)  # stash funcall-oper in closure slot
# emit-expr (car f94306)
# emit-expr f94306
# emit-variable-ref
# env=((f94306 . -20) (f94305 . -16) (f94306 . -12) (f94305 . -8))
# var=f94306
    movl -20(%esp), %eax  # stack load f94306
# end emit-variable-ref
# check the argument is a pair
    movl %eax,%ebx
    and $7, %bl
    cmp $1, %bl
    je _L_571463
# invoke error handler eh_pair
    .extern mrc_eh$upair
    movl mrc_eh$upair, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $116,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_571463:
    movl -1(%eax), %eax
    mov %eax, -36(%esp)  # arg (car f94306)
    movl -32(%esp), %edi   # load new closure to %edi
    add $-24, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $24, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
# emit-tail-expr
# si=-24
# env=((f94306 . -20) (f94305 . -16) (f94306 . -12) (f94305 . -8))
# expr=(begin ((primitive-ref for-each) f94305 (cdr f94306)))
# tail-begin (begin ((primitive-ref for-each) f94305 (cdr f94306)))
#   env=((f94306 . -20) (f94305 . -16) (f94306 . -12) (f94305 . -8))
# emit-tail-expr
# si=-24
# env=((f94306 . -20) (f94305 . -16) (f94306 . -12) (f94305 . -8))
# expr=((primitive-ref for-each) f94305 (cdr f94306))
# emit-tail-funcall
#    si   =-24
#    env  = ((f94306 . -20) (f94305 . -16) (f94306 . -12) (f94305 . -8))
#    expr = (funcall (primitive-ref for-each) f94305 (cdr f94306))
# emit-expr (primitive-ref for-each)
    .extern mrc_for$meach
    movl mrc_for$meach,%eax
   movl %eax,  -24(%esp)  # stash funcall-oper in next closure slot
# emit-expr f94305
# emit-variable-ref
# env=((f94306 . -20) (f94305 . -16) (f94306 . -12) (f94305 . -8))
# var=f94305
    movl -16(%esp), %eax  # stack load f94305
# end emit-variable-ref
    mov %eax, -28(%esp)    # arg f94305
# emit-expr (cdr f94306)
# emit-expr f94306
# emit-variable-ref
# env=((f94306 . -20) (f94305 . -16) (f94306 . -12) (f94305 . -8))
# var=f94306
    movl -20(%esp), %eax  # stack load f94306
# end emit-variable-ref
# check the argument is a pair
    movl %eax,%ebx
    and $7, %bl
    cmp $1, %bl
    je _L_571464
# invoke error handler eh_pair
    .extern mrc_eh$upair
    movl mrc_eh$upair, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $120,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_571464:
    movl 3(%eax), %eax
    mov %eax, -32(%esp)    # arg (cdr f94306)
    movl -24(%esp), %edi   # load new closure to %edi
# emit-shift-args:  size=3   si=-24  delta=20
    mov -24(%esp), %ebx  # shift frame cell
    mov %ebx, -4(%esp)  # down to base
# emit-shift-args:  size=2   si=-28  delta=20
    mov -28(%esp), %ebx  # shift frame cell
    mov %ebx, -8(%esp)  # down to base
# emit-shift-args:  size=1   si=-32  delta=20
    mov -32(%esp), %ebx  # shift frame cell
    mov %ebx, -12(%esp)  # down to base
# emit-shift-args:  size=0   si=-36  delta=20
    movl $8,%eax   # save arg count
    jmp *-2(%edi)  # tail-funcall
     ret   # return thru stack
     ret   # return thru stack
    jmp _L_571461
_L_571460:
# emit-tail-expr
# si=-24
# env=((f94306 . -20) (f94305 . -16) (f94306 . -12) (f94305 . -8))
# expr=#f
    movl $47, %eax     # immed #f
    ret                  # immediate tail return
_L_571461:
    .align 4,0x90
_L_571458:
     movl %eax, mrc_for$meach
# == explicit-begins  ==>
# (let ((p (make-vector 6)) (sz 1024)) (begin (vector-set! p 0 (quote output-port)) (vector-set! p 1 "/dev/stdout") (vector-set! p 2 1) (vector-set! p 3 (make-string sz)) (vector-set! p 4 0) (vector-set! p 5 sz) p))
# == eliminate-let*  ==>
# (let ((p (make-vector 6)) (sz 1024)) (begin (vector-set! p 0 (quote output-port)) (vector-set! p 1 "/dev/stdout") (vector-set! p 2 1) (vector-set! p 3 (make-string sz)) (vector-set! p 4 0) (vector-set! p 5 sz) p))
# == uniquify-variables  ==>
# (let ((f94308 (make-vector 6)) (f94307 1024)) (begin (vector-set! f94308 0 (quote output-port)) (vector-set! f94308 1 "/dev/stdout") (vector-set! f94308 2 1) (vector-set! f94308 3 (make-string f94307)) (vector-set! f94308 4 0) (vector-set! f94308 5 f94307) f94308))
# == vectorize-letrec  ==>
# (let ((f94308 (make-vector 6)) (f94307 1024)) (begin (vector-set! f94308 0 (quote output-port)) (vector-set! f94308 1 "/dev/stdout") (vector-set! f94308 2 1) (vector-set! f94308 3 (make-string f94307)) (vector-set! f94308 4 0) (vector-set! f94308 5 f94307) f94308))
# == eliminate-set!  ==>
# (let ((f94308 (make-vector 6)) (f94307 1024)) (begin (vector-set! f94308 0 (quote output-port)) (vector-set! f94308 1 "/dev/stdout") (vector-set! f94308 2 1) (vector-set! f94308 3 (make-string f94307)) (vector-set! f94308 4 0) (vector-set! f94308 5 f94307) f94308))
# == close-free-variables  ==>
# (let ((f94308 (make-vector 6)) (f94307 1024)) (begin (vector-set! f94308 0 (quote output-port)) (vector-set! f94308 1 "/dev/stdout") (vector-set! f94308 2 1) (vector-set! f94308 3 (make-string f94307)) (vector-set! f94308 4 0) (vector-set! f94308 5 f94307) f94308))
# == eliminate-quote  ==>
# (let ((f94308 (make-vector 6)) (f94307 1024)) (begin (vector-set! f94308 0 (string->symbol "output-port")) (vector-set! f94308 1 "/dev/stdout") (vector-set! f94308 2 1) (vector-set! f94308 3 (make-string f94307)) (vector-set! f94308 4 0) (vector-set! f94308 5 f94307) f94308))
# == eliminate-when/unless  ==>
# (let ((f94308 (make-vector 6)) (f94307 1024)) (begin (vector-set! f94308 0 (string->symbol "output-port")) (vector-set! f94308 1 "/dev/stdout") (vector-set! f94308 2 1) (vector-set! f94308 3 (make-string f94307)) (vector-set! f94308 4 0) (vector-set! f94308 5 f94307) f94308))
# == eliminate-cond  ==>
# (let ((f94308 (make-vector 6)) (f94307 1024)) (begin (vector-set! f94308 0 (string->symbol "output-port")) (vector-set! f94308 1 "/dev/stdout") (vector-set! f94308 2 1) (vector-set! f94308 3 (make-string f94307)) (vector-set! f94308 4 0) (vector-set! f94308 5 f94307) f94308))
# == external-symbols  ==>
# (let ((f94308 (make-vector 6)) (f94307 1024)) (begin (vector-set! f94308 0 ((primitive-ref string->symbol) "output-port")) (vector-set! f94308 1 "/dev/stdout") (vector-set! f94308 2 1) (vector-set! f94308 3 (make-string f94307)) (vector-set! f94308 4 0) (vector-set! f94308 5 f94307) f94308))
# emit-expr (let ((f94308 (make-vector 6)) (f94307 1024)) (begin (vector-set! f94308 0 ((primitive-ref string->symbol) "output-port")) (vector-set! f94308 1 "/dev/stdout") (vector-set! f94308 2 1) (vector-set! f94308 3 (make-string f94307)) (vector-set! f94308 4 0) (vector-set! f94308 5 f94307) f94308))
# emit-let
#  si   = 0
#  env  = ()
#  bindings = ((f94308 (make-vector 6)) (f94307 1024))
#  body = (begin (vector-set! f94308 0 ((primitive-ref string->symbol) "output-port")) (vector-set! f94308 1 "/dev/stdout") (vector-set! f94308 2 1) (vector-set! f94308 3 (make-string f94307)) (vector-set! f94308 4 0) (vector-set! f94308 5 f94307) f94308)
# emit-expr (make-vector 6)
# make-vector 6
# emit-expr 6
    movl $24, %eax     # immed 6
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_571465"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_571465:
# check the argument is a fixnum >= 0
    cmp $0,%eax
    jge _L_571466
# invoke error handler eh_length
    .extern mrc_eh$ulength
    movl mrc_eh$ulength, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_571466:
    movl %eax, %esi
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    orl  $5, %eax
    addl $4, %esi
    addl $4, %esi
    andl $-8, %esi
    addl %esi, %ebp
    movl %eax, 0(%esp)  # stack save
# emit-expr 1024
    movl $4096, %eax     # immed 1024
    movl %eax, -4(%esp)  # stack save
# emit-expr (begin (vector-set! f94308 0 ((primitive-ref string->symbol) "output-port")) (vector-set! f94308 1 "/dev/stdout") (vector-set! f94308 2 1) (vector-set! f94308 3 (make-string f94307)) (vector-set! f94308 4 0) (vector-set! f94308 5 f94307) f94308)
# emit-begin
#   expr=(begin (vector-set! f94308 0 ((primitive-ref string->symbol) "output-port")) (vector-set! f94308 1 "/dev/stdout") (vector-set! f94308 2 1) (vector-set! f94308 3 (make-string f94307)) (vector-set! f94308 4 0) (vector-set! f94308 5 f94307) f94308)
#   env=((f94307 . -4) (f94308 . 0))
# emit-expr (vector-set! f94308 0 ((primitive-ref string->symbol) "output-port"))
# emit-expr f94308
# emit-variable-ref
# env=((f94307 . -4) (f94308 . 0))
# var=f94308
    movl 0(%esp), %eax  # stack load f94308
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_571467
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_571467:
    movl %eax, -8(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_571468"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_571468:
# check bounds on vector index
    movl -8(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_571470
    cmp  $0,%eax
    jge _L_571469
_L_571470:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_571469:
    movl %eax, -12(%esp)
# emit-expr ((primitive-ref string->symbol) "output-port")
# funcall
#    si   =-16
#    env  = ((f94307 . -4) (f94308 . 0))
#    expr = (funcall (primitive-ref string->symbol) "output-port")
# emit-expr (primitive-ref string->symbol)
    .extern mrc_string$m$gsymbol
    movl mrc_string$m$gsymbol,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_571471"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_571471":
   movl %eax,  -24(%esp)  # stash funcall-oper in closure slot
# emit-expr "output-port"
# string literal
    jmp _L_571473
    .align 8,0x90
_L_571472 :
    .int 44
    .ascii "output-port"
_L_571473:
    movl $_L_571472, %eax
    orl $6, %eax
    mov %eax, -28(%esp)  # arg output-port
    movl -24(%esp), %edi   # load new closure to %edi
    add $-16, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $16, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    movl -8(%esp), %ebx
    movl -12(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin (vector-set! f94308 1 "/dev/stdout") (vector-set! f94308 2 1) (vector-set! f94308 3 (make-string f94307)) (vector-set! f94308 4 0) (vector-set! f94308 5 f94307) f94308)
# emit-begin
#   expr=(begin (vector-set! f94308 1 "/dev/stdout") (vector-set! f94308 2 1) (vector-set! f94308 3 (make-string f94307)) (vector-set! f94308 4 0) (vector-set! f94308 5 f94307) f94308)
#   env=((f94307 . -4) (f94308 . 0))
# emit-expr (vector-set! f94308 1 "/dev/stdout")
# emit-expr f94308
# emit-variable-ref
# env=((f94307 . -4) (f94308 . 0))
# var=f94308
    movl 0(%esp), %eax  # stack load f94308
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_571474
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_571474:
    movl %eax, -8(%esp)
# emit-expr 1
    movl $4, %eax     # immed 1
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_571475"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_571475:
# check bounds on vector index
    movl -8(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_571477
    cmp  $0,%eax
    jge _L_571476
_L_571477:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_571476:
    movl %eax, -12(%esp)
# emit-expr "/dev/stdout"
# string literal
    jmp _L_571479
    .align 8,0x90
_L_571478 :
    .int 44
    .ascii "/dev/stdout"
_L_571479:
    movl $_L_571478, %eax
    orl $6, %eax
    movl -8(%esp), %ebx
    movl -12(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin (vector-set! f94308 2 1) (vector-set! f94308 3 (make-string f94307)) (vector-set! f94308 4 0) (vector-set! f94308 5 f94307) f94308)
# emit-begin
#   expr=(begin (vector-set! f94308 2 1) (vector-set! f94308 3 (make-string f94307)) (vector-set! f94308 4 0) (vector-set! f94308 5 f94307) f94308)
#   env=((f94307 . -4) (f94308 . 0))
# emit-expr (vector-set! f94308 2 1)
# emit-expr f94308
# emit-variable-ref
# env=((f94307 . -4) (f94308 . 0))
# var=f94308
    movl 0(%esp), %eax  # stack load f94308
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_571480
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_571480:
    movl %eax, -8(%esp)
# emit-expr 2
    movl $8, %eax     # immed 2
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_571481"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_571481:
# check bounds on vector index
    movl -8(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_571483
    cmp  $0,%eax
    jge _L_571482
_L_571483:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_571482:
    movl %eax, -12(%esp)
# emit-expr 1
    movl $4, %eax     # immed 1
    movl -8(%esp), %ebx
    movl -12(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin (vector-set! f94308 3 (make-string f94307)) (vector-set! f94308 4 0) (vector-set! f94308 5 f94307) f94308)
# emit-begin
#   expr=(begin (vector-set! f94308 3 (make-string f94307)) (vector-set! f94308 4 0) (vector-set! f94308 5 f94307) f94308)
#   env=((f94307 . -4) (f94308 . 0))
# emit-expr (vector-set! f94308 3 (make-string f94307))
# emit-expr f94308
# emit-variable-ref
# env=((f94307 . -4) (f94308 . 0))
# var=f94308
    movl 0(%esp), %eax  # stack load f94308
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_571484
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_571484:
    movl %eax, -8(%esp)
# emit-expr 3
    movl $12, %eax     # immed 3
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_571485"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_571485:
# check bounds on vector index
    movl -8(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_571487
    cmp  $0,%eax
    jge _L_571486
_L_571487:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_571486:
    movl %eax, -12(%esp)
# emit-expr (make-string f94307)
# make-string len=f94307
# emit-expr f94307
# emit-variable-ref
# env=((f94307 . -4) (f94308 . 0))
# var=f94307
    movl -4(%esp), %eax  # stack load f94307
# end emit-variable-ref
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_571488"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $152,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_571488:
# check the argument is a fixnum >= 0
    cmp $0,%eax
    jge _L_571489
# invoke error handler eh_length
    .extern mrc_eh$ulength
    movl mrc_eh$ulength, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $152,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_571489:
    movl %eax, %esi
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    orl $6, %eax
    sar $2, %esi
    add $4, %esi
    add $7, %esi
    andl $-8, %esi
    add  %esi, %ebp
# make-string end
    movl -8(%esp), %ebx
    movl -12(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin (vector-set! f94308 4 0) (vector-set! f94308 5 f94307) f94308)
# emit-begin
#   expr=(begin (vector-set! f94308 4 0) (vector-set! f94308 5 f94307) f94308)
#   env=((f94307 . -4) (f94308 . 0))
# emit-expr (vector-set! f94308 4 0)
# emit-expr f94308
# emit-variable-ref
# env=((f94307 . -4) (f94308 . 0))
# var=f94308
    movl 0(%esp), %eax  # stack load f94308
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_571490
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_571490:
    movl %eax, -8(%esp)
# emit-expr 4
    movl $16, %eax     # immed 4
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_571491"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_571491:
# check bounds on vector index
    movl -8(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_571493
    cmp  $0,%eax
    jge _L_571492
_L_571493:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_571492:
    movl %eax, -12(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
    movl -8(%esp), %ebx
    movl -12(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin (vector-set! f94308 5 f94307) f94308)
# emit-begin
#   expr=(begin (vector-set! f94308 5 f94307) f94308)
#   env=((f94307 . -4) (f94308 . 0))
# emit-expr (vector-set! f94308 5 f94307)
# emit-expr f94308
# emit-variable-ref
# env=((f94307 . -4) (f94308 . 0))
# var=f94308
    movl 0(%esp), %eax  # stack load f94308
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_571494
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_571494:
    movl %eax, -8(%esp)
# emit-expr 5
    movl $20, %eax     # immed 5
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_571495"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_571495:
# check bounds on vector index
    movl -8(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_571497
    cmp  $0,%eax
    jge _L_571496
_L_571497:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_571496:
    movl %eax, -12(%esp)
# emit-expr f94307
# emit-variable-ref
# env=((f94307 . -4) (f94308 . 0))
# var=f94307
    movl -4(%esp), %eax  # stack load f94307
# end emit-variable-ref
    movl -8(%esp), %ebx
    movl -12(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin f94308)
# emit-begin
#   expr=(begin f94308)
#   env=((f94307 . -4) (f94308 . 0))
# emit-expr f94308
# emit-variable-ref
# env=((f94307 . -4) (f94308 . 0))
# var=f94308
    movl 0(%esp), %eax  # stack load f94308
# end emit-variable-ref
# emit-expr (begin)
# emit-begin
#   expr=(begin)
#   env=((f94307 . -4) (f94308 . 0))
     movl %eax, mrc_standard$mout
# == explicit-begins  ==>
# (let ((current-out standard-out)) (lambda () current-out))
# == eliminate-let*  ==>
# (let ((current-out standard-out)) (lambda () current-out))
# == uniquify-variables  ==>
# (let ((f94309 standard-out)) (lambda () f94309))
# == vectorize-letrec  ==>
# (let ((f94309 standard-out)) (lambda () f94309))
# == eliminate-set!  ==>
# (let ((f94309 standard-out)) (lambda () (let () f94309)))
# == close-free-variables  ==>
# (let ((f94309 standard-out)) (closure () (f94309) (let () f94309)))
# == eliminate-quote  ==>
# (let ((f94309 standard-out)) (closure () (f94309) (let () f94309)))
# == eliminate-when/unless  ==>
# (let ((f94309 standard-out)) (closure () (f94309) (let () f94309)))
# == eliminate-cond  ==>
# (let ((f94309 standard-out)) (closure () (f94309) (let () f94309)))
# == external-symbols  ==>
# (let ((f94309 (primitive-ref standard-out))) (closure () (f94309) (let () f94309)))
# emit-expr (let ((f94309 (primitive-ref standard-out))) (closure () (f94309) (let () f94309)))
# emit-let
#  si   = 0
#  env  = ()
#  bindings = ((f94309 (primitive-ref standard-out)))
#  body = (closure () (f94309) (let () f94309))
# emit-expr (primitive-ref standard-out)
    .extern mrc_standard$mout
    movl mrc_standard$mout,%eax
    movl %eax, 0(%esp)  # stack save
# emit-expr (closure () (f94309) (let () f94309))
# emit-closure
# si = -4
# env = ((f94309 . 0))
# expr = (closure () (f94309) (let () f94309))
    movl $_L_571498, 0(%ebp)  # closure label
# emit-variable-ref
# env=((f94309 . 0))
# var=f94309
    movl 0(%esp), %eax  # stack load f94309
# end emit-variable-ref
   movl  %eax, 4(%ebp)  # f94309
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $8, %ebp     # bump ebp
    jmp _L_571499            # jump around closure body
_L_571498:
# check argument count
    cmp $0,%eax
    je _L_571500
# invoke error handler eh_argcount
    .extern mrc_eh$uargcount
    movl mrc_eh$uargcount, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_571500:
# emit-tail-expr
# si=-8
# env=((f94309 . 4) (f94309 . 0))
# expr=(let () f94309)
# emit-tail-let
#  si   = -8
#  env  = ((f94309 . 4) (f94309 . 0))
#  bindings = ()
#  body = f94309
# emit-tail-expr
# si=-8
# env=((f94309 . 4) (f94309 . 0))
# expr=f94309
# emit-tail-variable-ref
# emit-variable-ref
# env=((f94309 . 4) (f94309 . 0))
# var=f94309
    movl 2(%edi), %eax  # frame load f94309
# end emit-variable-ref
    ret
# end emit-tail-variable ref
    .align 4,0x90
_L_571499:
     movl %eax, mrc_current$moutput$mport
# == explicit-begins  ==>
# (let ((current-in standard-in)) (lambda () current-in))
# == eliminate-let*  ==>
# (let ((current-in standard-in)) (lambda () current-in))
# == uniquify-variables  ==>
# (let ((f94310 standard-in)) (lambda () f94310))
# == vectorize-letrec  ==>
# (let ((f94310 standard-in)) (lambda () f94310))
# == eliminate-set!  ==>
# (let ((f94310 standard-in)) (lambda () (let () f94310)))
# == close-free-variables  ==>
# (let ((f94310 standard-in)) (closure () (f94310) (let () f94310)))
# == eliminate-quote  ==>
# (let ((f94310 standard-in)) (closure () (f94310) (let () f94310)))
# == eliminate-when/unless  ==>
# (let ((f94310 standard-in)) (closure () (f94310) (let () f94310)))
# == eliminate-cond  ==>
# (let ((f94310 standard-in)) (closure () (f94310) (let () f94310)))
# == external-symbols  ==>
# (let ((f94310 (primitive-ref standard-in))) (closure () (f94310) (let () f94310)))
# emit-expr (let ((f94310 (primitive-ref standard-in))) (closure () (f94310) (let () f94310)))
# emit-let
#  si   = 0
#  env  = ()
#  bindings = ((f94310 (primitive-ref standard-in)))
#  body = (closure () (f94310) (let () f94310))
# emit-expr (primitive-ref standard-in)
    .extern mrc_standard$min
    movl mrc_standard$min,%eax
    movl %eax, 0(%esp)  # stack save
# emit-expr (closure () (f94310) (let () f94310))
# emit-closure
# si = -4
# env = ((f94310 . 0))
# expr = (closure () (f94310) (let () f94310))
    movl $_L_571501, 0(%ebp)  # closure label
# emit-variable-ref
# env=((f94310 . 0))
# var=f94310
    movl 0(%esp), %eax  # stack load f94310
# end emit-variable-ref
   movl  %eax, 4(%ebp)  # f94310
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $8, %ebp     # bump ebp
    jmp _L_571502            # jump around closure body
_L_571501:
# check argument count
    cmp $0,%eax
    je _L_571503
# invoke error handler eh_argcount
    .extern mrc_eh$uargcount
    movl mrc_eh$uargcount, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_571503:
# emit-tail-expr
# si=-8
# env=((f94310 . 4) (f94310 . 0))
# expr=(let () f94310)
# emit-tail-let
#  si   = -8
#  env  = ((f94310 . 4) (f94310 . 0))
#  bindings = ()
#  body = f94310
# emit-tail-expr
# si=-8
# env=((f94310 . 4) (f94310 . 0))
# expr=f94310
# emit-tail-variable-ref
# emit-variable-ref
# env=((f94310 . 4) (f94310 . 0))
# var=f94310
    movl 2(%edi), %eax  # frame load f94310
# end emit-variable-ref
    ret
# end emit-tail-variable ref
    .align 4,0x90
_L_571502:
     movl %eax, mrc_current$minput$mport
# == explicit-begins  ==>
# (lambda (p) (vector-ref p 0))
# == eliminate-let*  ==>
# (lambda (p) (vector-ref p 0))
# == uniquify-variables  ==>
# (lambda (f94311) (vector-ref f94311 0))
# == vectorize-letrec  ==>
# (lambda (f94311) (vector-ref f94311 0))
# == eliminate-set!  ==>
# (lambda (f94311) (let ((f94311 f94311)) (vector-ref f94311 0)))
# == close-free-variables  ==>
# (closure (f94311) () (let ((f94311 f94311)) (vector-ref f94311 0)))
# == eliminate-quote  ==>
# (closure (f94311) () (let ((f94311 f94311)) (vector-ref f94311 0)))
# == eliminate-when/unless  ==>
# (closure (f94311) () (let ((f94311 f94311)) (vector-ref f94311 0)))
# == eliminate-cond  ==>
# (closure (f94311) () (let ((f94311 f94311)) (vector-ref f94311 0)))
# == external-symbols  ==>
# (closure (f94311) () (let ((f94311 f94311)) (vector-ref f94311 0)))
# emit-expr (closure (f94311) () (let ((f94311 f94311)) (vector-ref f94311 0)))
# emit-closure
# si = 0
# env = ()
# expr = (closure (f94311) () (let ((f94311 f94311)) (vector-ref f94311 0)))
    movl $_L_571504, 0(%ebp)  # closure label
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $8, %ebp     # bump ebp
    jmp _L_571505            # jump around closure body
_L_571504:
# check argument count
    cmp $4,%eax
    je _L_571506
# invoke error handler eh_argcount
    .extern mrc_eh$uargcount
    movl mrc_eh$uargcount, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_571506:
# emit-tail-expr
# si=-12
# env=((f94311 . -8))
# expr=(let ((f94311 f94311)) (vector-ref f94311 0))
# emit-tail-let
#  si   = -12
#  env  = ((f94311 . -8))
#  bindings = ((f94311 f94311))
#  body = (vector-ref f94311 0)
# emit-expr f94311
# emit-variable-ref
# env=((f94311 . -8))
# var=f94311
    movl -8(%esp), %eax  # stack load f94311
# end emit-variable-ref
    movl %eax, -12(%esp)  # stack save
# emit-tail-expr
# si=-16
# env=((f94311 . -12) (f94311 . -8))
# expr=(vector-ref f94311 0)
# tail primcall
# emit-expr f94311
# emit-variable-ref
# env=((f94311 . -12) (f94311 . -8))
# var=f94311
    movl -12(%esp), %eax  # stack load f94311
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_571507
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_571507:
    movl %eax, -16(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_571508"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_571508:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_571510
    cmp  $0,%eax
    jge _L_571509
_L_571510:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_571509:
    movl -16(%esp), %esi
    movl -1(%eax,%esi), %eax
#return from tail (vector-ref f94311 0)
    ret
    .align 4,0x90
_L_571505:
     movl %eax, mrc_port$mkind
# == explicit-begins  ==>
# (lambda (p) (vector-ref p 1))
# == eliminate-let*  ==>
# (lambda (p) (vector-ref p 1))
# == uniquify-variables  ==>
# (lambda (f94312) (vector-ref f94312 1))
# == vectorize-letrec  ==>
# (lambda (f94312) (vector-ref f94312 1))
# == eliminate-set!  ==>
# (lambda (f94312) (let ((f94312 f94312)) (vector-ref f94312 1)))
# == close-free-variables  ==>
# (closure (f94312) () (let ((f94312 f94312)) (vector-ref f94312 1)))
# == eliminate-quote  ==>
# (closure (f94312) () (let ((f94312 f94312)) (vector-ref f94312 1)))
# == eliminate-when/unless  ==>
# (closure (f94312) () (let ((f94312 f94312)) (vector-ref f94312 1)))
# == eliminate-cond  ==>
# (closure (f94312) () (let ((f94312 f94312)) (vector-ref f94312 1)))
# == external-symbols  ==>
# (closure (f94312) () (let ((f94312 f94312)) (vector-ref f94312 1)))
# emit-expr (closure (f94312) () (let ((f94312 f94312)) (vector-ref f94312 1)))
# emit-closure
# si = 0
# env = ()
# expr = (closure (f94312) () (let ((f94312 f94312)) (vector-ref f94312 1)))
    movl $_L_571511, 0(%ebp)  # closure label
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $8, %ebp     # bump ebp
    jmp _L_571512            # jump around closure body
_L_571511:
# check argument count
    cmp $4,%eax
    je _L_571513
# invoke error handler eh_argcount
    .extern mrc_eh$uargcount
    movl mrc_eh$uargcount, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_571513:
# emit-tail-expr
# si=-12
# env=((f94312 . -8))
# expr=(let ((f94312 f94312)) (vector-ref f94312 1))
# emit-tail-let
#  si   = -12
#  env  = ((f94312 . -8))
#  bindings = ((f94312 f94312))
#  body = (vector-ref f94312 1)
# emit-expr f94312
# emit-variable-ref
# env=((f94312 . -8))
# var=f94312
    movl -8(%esp), %eax  # stack load f94312
# end emit-variable-ref
    movl %eax, -12(%esp)  # stack save
# emit-tail-expr
# si=-16
# env=((f94312 . -12) (f94312 . -8))
# expr=(vector-ref f94312 1)
# tail primcall
# emit-expr f94312
# emit-variable-ref
# env=((f94312 . -12) (f94312 . -8))
# var=f94312
    movl -12(%esp), %eax  # stack load f94312
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_571514
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_571514:
    movl %eax, -16(%esp)
# emit-expr 1
    movl $4, %eax     # immed 1
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_571515"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_571515:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_571517
    cmp  $0,%eax
    jge _L_571516
_L_571517:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_571516:
    movl -16(%esp), %esi
    movl -1(%eax,%esi), %eax
#return from tail (vector-ref f94312 1)
    ret
    .align 4,0x90
_L_571512:
     movl %eax, mrc_port$mpath
# == explicit-begins  ==>
# (lambda (p) (vector-ref p 2))
# == eliminate-let*  ==>
# (lambda (p) (vector-ref p 2))
# == uniquify-variables  ==>
# (lambda (f94313) (vector-ref f94313 2))
# == vectorize-letrec  ==>
# (lambda (f94313) (vector-ref f94313 2))
# == eliminate-set!  ==>
# (lambda (f94313) (let ((f94313 f94313)) (vector-ref f94313 2)))
# == close-free-variables  ==>
# (closure (f94313) () (let ((f94313 f94313)) (vector-ref f94313 2)))
# == eliminate-quote  ==>
# (closure (f94313) () (let ((f94313 f94313)) (vector-ref f94313 2)))
# == eliminate-when/unless  ==>
# (closure (f94313) () (let ((f94313 f94313)) (vector-ref f94313 2)))
# == eliminate-cond  ==>
# (closure (f94313) () (let ((f94313 f94313)) (vector-ref f94313 2)))
# == external-symbols  ==>
# (closure (f94313) () (let ((f94313 f94313)) (vector-ref f94313 2)))
# emit-expr (closure (f94313) () (let ((f94313 f94313)) (vector-ref f94313 2)))
# emit-closure
# si = 0
# env = ()
# expr = (closure (f94313) () (let ((f94313 f94313)) (vector-ref f94313 2)))
    movl $_L_571518, 0(%ebp)  # closure label
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $8, %ebp     # bump ebp
    jmp _L_571519            # jump around closure body
_L_571518:
# check argument count
    cmp $4,%eax
    je _L_571520
# invoke error handler eh_argcount
    .extern mrc_eh$uargcount
    movl mrc_eh$uargcount, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_571520:
# emit-tail-expr
# si=-12
# env=((f94313 . -8))
# expr=(let ((f94313 f94313)) (vector-ref f94313 2))
# emit-tail-let
#  si   = -12
#  env  = ((f94313 . -8))
#  bindings = ((f94313 f94313))
#  body = (vector-ref f94313 2)
# emit-expr f94313
# emit-variable-ref
# env=((f94313 . -8))
# var=f94313
    movl -8(%esp), %eax  # stack load f94313
# end emit-variable-ref
    movl %eax, -12(%esp)  # stack save
# emit-tail-expr
# si=-16
# env=((f94313 . -12) (f94313 . -8))
# expr=(vector-ref f94313 2)
# tail primcall
# emit-expr f94313
# emit-variable-ref
# env=((f94313 . -12) (f94313 . -8))
# var=f94313
    movl -12(%esp), %eax  # stack load f94313
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_571521
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_571521:
    movl %eax, -16(%esp)
# emit-expr 2
    movl $8, %eax     # immed 2
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_571522"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_571522:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_571524
    cmp  $0,%eax
    jge _L_571523
_L_571524:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_571523:
    movl -16(%esp), %esi
    movl -1(%eax,%esi), %eax
#return from tail (vector-ref f94313 2)
    ret
    .align 4,0x90
_L_571519:
     movl %eax, mrc_port$mfd
# == explicit-begins  ==>
# (lambda (p) (vector-ref p 3))
# == eliminate-let*  ==>
# (lambda (p) (vector-ref p 3))
# == uniquify-variables  ==>
# (lambda (f94314) (vector-ref f94314 3))
# == vectorize-letrec  ==>
# (lambda (f94314) (vector-ref f94314 3))
# == eliminate-set!  ==>
# (lambda (f94314) (let ((f94314 f94314)) (vector-ref f94314 3)))
# == close-free-variables  ==>
# (closure (f94314) () (let ((f94314 f94314)) (vector-ref f94314 3)))
# == eliminate-quote  ==>
# (closure (f94314) () (let ((f94314 f94314)) (vector-ref f94314 3)))
# == eliminate-when/unless  ==>
# (closure (f94314) () (let ((f94314 f94314)) (vector-ref f94314 3)))
# == eliminate-cond  ==>
# (closure (f94314) () (let ((f94314 f94314)) (vector-ref f94314 3)))
# == external-symbols  ==>
# (closure (f94314) () (let ((f94314 f94314)) (vector-ref f94314 3)))
# emit-expr (closure (f94314) () (let ((f94314 f94314)) (vector-ref f94314 3)))
# emit-closure
# si = 0
# env = ()
# expr = (closure (f94314) () (let ((f94314 f94314)) (vector-ref f94314 3)))
    movl $_L_571525, 0(%ebp)  # closure label
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $8, %ebp     # bump ebp
    jmp _L_571526            # jump around closure body
_L_571525:
# check argument count
    cmp $4,%eax
    je _L_571527
# invoke error handler eh_argcount
    .extern mrc_eh$uargcount
    movl mrc_eh$uargcount, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_571527:
# emit-tail-expr
# si=-12
# env=((f94314 . -8))
# expr=(let ((f94314 f94314)) (vector-ref f94314 3))
# emit-tail-let
#  si   = -12
#  env  = ((f94314 . -8))
#  bindings = ((f94314 f94314))
#  body = (vector-ref f94314 3)
# emit-expr f94314
# emit-variable-ref
# env=((f94314 . -8))
# var=f94314
    movl -8(%esp), %eax  # stack load f94314
# end emit-variable-ref
    movl %eax, -12(%esp)  # stack save
# emit-tail-expr
# si=-16
# env=((f94314 . -12) (f94314 . -8))
# expr=(vector-ref f94314 3)
# tail primcall
# emit-expr f94314
# emit-variable-ref
# env=((f94314 . -12) (f94314 . -8))
# var=f94314
    movl -12(%esp), %eax  # stack load f94314
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_571528
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_571528:
    movl %eax, -16(%esp)
# emit-expr 3
    movl $12, %eax     # immed 3
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_571529"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_571529:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_571531
    cmp  $0,%eax
    jge _L_571530
_L_571531:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_571530:
    movl -16(%esp), %esi
    movl -1(%eax,%esi), %eax
#return from tail (vector-ref f94314 3)
    ret
    .align 4,0x90
_L_571526:
     movl %eax, mrc_port$mbuf
# == explicit-begins  ==>
# (lambda (p) (vector-ref p 4))
# == eliminate-let*  ==>
# (lambda (p) (vector-ref p 4))
# == uniquify-variables  ==>
# (lambda (f94315) (vector-ref f94315 4))
# == vectorize-letrec  ==>
# (lambda (f94315) (vector-ref f94315 4))
# == eliminate-set!  ==>
# (lambda (f94315) (let ((f94315 f94315)) (vector-ref f94315 4)))
# == close-free-variables  ==>
# (closure (f94315) () (let ((f94315 f94315)) (vector-ref f94315 4)))
# == eliminate-quote  ==>
# (closure (f94315) () (let ((f94315 f94315)) (vector-ref f94315 4)))
# == eliminate-when/unless  ==>
# (closure (f94315) () (let ((f94315 f94315)) (vector-ref f94315 4)))
# == eliminate-cond  ==>
# (closure (f94315) () (let ((f94315 f94315)) (vector-ref f94315 4)))
# == external-symbols  ==>
# (closure (f94315) () (let ((f94315 f94315)) (vector-ref f94315 4)))
# emit-expr (closure (f94315) () (let ((f94315 f94315)) (vector-ref f94315 4)))
# emit-closure
# si = 0
# env = ()
# expr = (closure (f94315) () (let ((f94315 f94315)) (vector-ref f94315 4)))
    movl $_L_571532, 0(%ebp)  # closure label
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $8, %ebp     # bump ebp
    jmp _L_571533            # jump around closure body
_L_571532:
# check argument count
    cmp $4,%eax
    je _L_571534
# invoke error handler eh_argcount
    .extern mrc_eh$uargcount
    movl mrc_eh$uargcount, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_571534:
# emit-tail-expr
# si=-12
# env=((f94315 . -8))
# expr=(let ((f94315 f94315)) (vector-ref f94315 4))
# emit-tail-let
#  si   = -12
#  env  = ((f94315 . -8))
#  bindings = ((f94315 f94315))
#  body = (vector-ref f94315 4)
# emit-expr f94315
# emit-variable-ref
# env=((f94315 . -8))
# var=f94315
    movl -8(%esp), %eax  # stack load f94315
# end emit-variable-ref
    movl %eax, -12(%esp)  # stack save
# emit-tail-expr
# si=-16
# env=((f94315 . -12) (f94315 . -8))
# expr=(vector-ref f94315 4)
# tail primcall
# emit-expr f94315
# emit-variable-ref
# env=((f94315 . -12) (f94315 . -8))
# var=f94315
    movl -12(%esp), %eax  # stack load f94315
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_571535
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_571535:
    movl %eax, -16(%esp)
# emit-expr 4
    movl $16, %eax     # immed 4
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_571536"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_571536:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_571538
    cmp  $0,%eax
    jge _L_571537
_L_571538:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_571537:
    movl -16(%esp), %esi
    movl -1(%eax,%esi), %eax
#return from tail (vector-ref f94315 4)
    ret
    .align 4,0x90
_L_571533:
     movl %eax, mrc_port$mndx
# == explicit-begins  ==>
# (lambda (p) (vector-set! p 4 (fxadd1 (vector-ref p 4))))
# == eliminate-let*  ==>
# (lambda (p) (vector-set! p 4 (fxadd1 (vector-ref p 4))))
# == uniquify-variables  ==>
# (lambda (f94316) (vector-set! f94316 4 (fxadd1 (vector-ref f94316 4))))
# == vectorize-letrec  ==>
# (lambda (f94316) (vector-set! f94316 4 (fxadd1 (vector-ref f94316 4))))
# == eliminate-set!  ==>
# (lambda (f94316) (let ((f94316 f94316)) (vector-set! f94316 4 (fxadd1 (vector-ref f94316 4)))))
# == close-free-variables  ==>
# (closure (f94316) () (let ((f94316 f94316)) (vector-set! f94316 4 (fxadd1 (vector-ref f94316 4)))))
# == eliminate-quote  ==>
# (closure (f94316) () (let ((f94316 f94316)) (vector-set! f94316 4 (fxadd1 (vector-ref f94316 4)))))
# == eliminate-when/unless  ==>
# (closure (f94316) () (let ((f94316 f94316)) (vector-set! f94316 4 (fxadd1 (vector-ref f94316 4)))))
# == eliminate-cond  ==>
# (closure (f94316) () (let ((f94316 f94316)) (vector-set! f94316 4 (fxadd1 (vector-ref f94316 4)))))
# == external-symbols  ==>
# (closure (f94316) () (let ((f94316 f94316)) (vector-set! f94316 4 (fxadd1 (vector-ref f94316 4)))))
# emit-expr (closure (f94316) () (let ((f94316 f94316)) (vector-set! f94316 4 (fxadd1 (vector-ref f94316 4)))))
# emit-closure
# si = 0
# env = ()
# expr = (closure (f94316) () (let ((f94316 f94316)) (vector-set! f94316 4 (fxadd1 (vector-ref f94316 4)))))
    movl $_L_571539, 0(%ebp)  # closure label
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $8, %ebp     # bump ebp
    jmp _L_571540            # jump around closure body
_L_571539:
# check argument count
    cmp $4,%eax
    je _L_571541
# invoke error handler eh_argcount
    .extern mrc_eh$uargcount
    movl mrc_eh$uargcount, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_571541:
# emit-tail-expr
# si=-12
# env=((f94316 . -8))
# expr=(let ((f94316 f94316)) (vector-set! f94316 4 (fxadd1 (vector-ref f94316 4))))
# emit-tail-let
#  si   = -12
#  env  = ((f94316 . -8))
#  bindings = ((f94316 f94316))
#  body = (vector-set! f94316 4 (fxadd1 (vector-ref f94316 4)))
# emit-expr f94316
# emit-variable-ref
# env=((f94316 . -8))
# var=f94316
    movl -8(%esp), %eax  # stack load f94316
# end emit-variable-ref
    movl %eax, -12(%esp)  # stack save
# emit-tail-expr
# si=-16
# env=((f94316 . -12) (f94316 . -8))
# expr=(vector-set! f94316 4 (fxadd1 (vector-ref f94316 4)))
# tail primcall
# emit-expr f94316
# emit-variable-ref
# env=((f94316 . -12) (f94316 . -8))
# var=f94316
    movl -12(%esp), %eax  # stack load f94316
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_571542
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_571542:
    movl %eax, -16(%esp)
# emit-expr 4
    movl $16, %eax     # immed 4
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_571543"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_571543:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_571545
    cmp  $0,%eax
    jge _L_571544
_L_571545:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_571544:
    movl %eax, -20(%esp)
# emit-expr (fxadd1 (vector-ref f94316 4))
# emit-expr (vector-ref f94316 4)
# emit-expr f94316
# emit-variable-ref
# env=((f94316 . -12) (f94316 . -8))
# var=f94316
    movl -12(%esp), %eax  # stack load f94316
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_571546
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_571546:
    movl %eax, -24(%esp)
# emit-expr 4
    movl $16, %eax     # immed 4
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_571547"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_571547:
# check bounds on vector index
    movl -24(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_571549
    cmp  $0,%eax
    jge _L_571548
_L_571549:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_571548:
    movl -24(%esp), %esi
    movl -1(%eax,%esi), %eax
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_571550"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $56,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_571550:
     addl $4, %eax
    movl -16(%esp), %ebx
    movl -20(%esp), %esi
    movl %eax, -1(%ebx,%esi)
#return from tail (vector-set! f94316 4 (fxadd1 (vector-ref f94316 4)))
    ret
    .align 4,0x90
_L_571540:
     movl %eax, mrc_port$mndx$madd1
# == explicit-begins  ==>
# (lambda (p) (vector-set! p 4 0))
# == eliminate-let*  ==>
# (lambda (p) (vector-set! p 4 0))
# == uniquify-variables  ==>
# (lambda (f94317) (vector-set! f94317 4 0))
# == vectorize-letrec  ==>
# (lambda (f94317) (vector-set! f94317 4 0))
# == eliminate-set!  ==>
# (lambda (f94317) (let ((f94317 f94317)) (vector-set! f94317 4 0)))
# == close-free-variables  ==>
# (closure (f94317) () (let ((f94317 f94317)) (vector-set! f94317 4 0)))
# == eliminate-quote  ==>
# (closure (f94317) () (let ((f94317 f94317)) (vector-set! f94317 4 0)))
# == eliminate-when/unless  ==>
# (closure (f94317) () (let ((f94317 f94317)) (vector-set! f94317 4 0)))
# == eliminate-cond  ==>
# (closure (f94317) () (let ((f94317 f94317)) (vector-set! f94317 4 0)))
# == external-symbols  ==>
# (closure (f94317) () (let ((f94317 f94317)) (vector-set! f94317 4 0)))
# emit-expr (closure (f94317) () (let ((f94317 f94317)) (vector-set! f94317 4 0)))
# emit-closure
# si = 0
# env = ()
# expr = (closure (f94317) () (let ((f94317 f94317)) (vector-set! f94317 4 0)))
    movl $_L_571551, 0(%ebp)  # closure label
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $8, %ebp     # bump ebp
    jmp _L_571552            # jump around closure body
_L_571551:
# check argument count
    cmp $4,%eax
    je _L_571553
# invoke error handler eh_argcount
    .extern mrc_eh$uargcount
    movl mrc_eh$uargcount, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_571553:
# emit-tail-expr
# si=-12
# env=((f94317 . -8))
# expr=(let ((f94317 f94317)) (vector-set! f94317 4 0))
# emit-tail-let
#  si   = -12
#  env  = ((f94317 . -8))
#  bindings = ((f94317 f94317))
#  body = (vector-set! f94317 4 0)
# emit-expr f94317
# emit-variable-ref
# env=((f94317 . -8))
# var=f94317
    movl -8(%esp), %eax  # stack load f94317
# end emit-variable-ref
    movl %eax, -12(%esp)  # stack save
# emit-tail-expr
# si=-16
# env=((f94317 . -12) (f94317 . -8))
# expr=(vector-set! f94317 4 0)
# tail primcall
# emit-expr f94317
# emit-variable-ref
# env=((f94317 . -12) (f94317 . -8))
# var=f94317
    movl -12(%esp), %eax  # stack load f94317
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_571554
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_571554:
    movl %eax, -16(%esp)
# emit-expr 4
    movl $16, %eax     # immed 4
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_571555"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_571555:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_571557
    cmp  $0,%eax
    jge _L_571556
_L_571557:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_571556:
    movl %eax, -20(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
    movl -16(%esp), %ebx
    movl -20(%esp), %esi
    movl %eax, -1(%ebx,%esi)
#return from tail (vector-set! f94317 4 0)
    ret
    .align 4,0x90
_L_571552:
     movl %eax, mrc_port$mndx$mreset
# == explicit-begins  ==>
# (lambda (p) (vector-ref p 5))
# == eliminate-let*  ==>
# (lambda (p) (vector-ref p 5))
# == uniquify-variables  ==>
# (lambda (f94318) (vector-ref f94318 5))
# == vectorize-letrec  ==>
# (lambda (f94318) (vector-ref f94318 5))
# == eliminate-set!  ==>
# (lambda (f94318) (let ((f94318 f94318)) (vector-ref f94318 5)))
# == close-free-variables  ==>
# (closure (f94318) () (let ((f94318 f94318)) (vector-ref f94318 5)))
# == eliminate-quote  ==>
# (closure (f94318) () (let ((f94318 f94318)) (vector-ref f94318 5)))
# == eliminate-when/unless  ==>
# (closure (f94318) () (let ((f94318 f94318)) (vector-ref f94318 5)))
# == eliminate-cond  ==>
# (closure (f94318) () (let ((f94318 f94318)) (vector-ref f94318 5)))
# == external-symbols  ==>
# (closure (f94318) () (let ((f94318 f94318)) (vector-ref f94318 5)))
# emit-expr (closure (f94318) () (let ((f94318 f94318)) (vector-ref f94318 5)))
# emit-closure
# si = 0
# env = ()
# expr = (closure (f94318) () (let ((f94318 f94318)) (vector-ref f94318 5)))
    movl $_L_571558, 0(%ebp)  # closure label
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $8, %ebp     # bump ebp
    jmp _L_571559            # jump around closure body
_L_571558:
# check argument count
    cmp $4,%eax
    je _L_571560
# invoke error handler eh_argcount
    .extern mrc_eh$uargcount
    movl mrc_eh$uargcount, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_571560:
# emit-tail-expr
# si=-12
# env=((f94318 . -8))
# expr=(let ((f94318 f94318)) (vector-ref f94318 5))
# emit-tail-let
#  si   = -12
#  env  = ((f94318 . -8))
#  bindings = ((f94318 f94318))
#  body = (vector-ref f94318 5)
# emit-expr f94318
# emit-variable-ref
# env=((f94318 . -8))
# var=f94318
    movl -8(%esp), %eax  # stack load f94318
# end emit-variable-ref
    movl %eax, -12(%esp)  # stack save
# emit-tail-expr
# si=-16
# env=((f94318 . -12) (f94318 . -8))
# expr=(vector-ref f94318 5)
# tail primcall
# emit-expr f94318
# emit-variable-ref
# env=((f94318 . -12) (f94318 . -8))
# var=f94318
    movl -12(%esp), %eax  # stack load f94318
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_571561
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_571561:
    movl %eax, -16(%esp)
# emit-expr 5
    movl $20, %eax     # immed 5
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_571562"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_571562:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_571564
    cmp  $0,%eax
    jge _L_571563
_L_571564:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_571563:
    movl -16(%esp), %esi
    movl -1(%eax,%esi), %eax
#return from tail (vector-ref f94318 5)
    ret
    .align 4,0x90
_L_571559:
     movl %eax, mrc_port$msize
# == explicit-begins  ==>
# (lambda (ch . args) (let ((p (if (null? args) (current-output-port) (car args)))) (begin (when (fx= (port-ndx p) (port-size p)) (flush-output-port p)) (string-set! (port-buf p) (port-ndx p) ch) (port-ndx-add1 p))))
# == eliminate-let*  ==>
# (lambda (ch . args) (let ((p (if (null? args) (current-output-port) (car args)))) (begin (when (fx= (port-ndx p) (port-size p)) (flush-output-port p)) (string-set! (port-buf p) (port-ndx p) ch) (port-ndx-add1 p))))
# == uniquify-variables  ==>
# (lambda (f94319 . f94320) (let ((f94322 (if (null? f94320) (current-output-port) (car f94320)))) (begin (when (fx= (port-ndx f94322) (port-size f94322)) (flush-output-port f94322)) (string-set! (port-buf f94322) (port-ndx f94322) f94319) (port-ndx-add1 f94322))))
# == vectorize-letrec  ==>
# (lambda (f94319 . f94320) (let ((f94322 (if (null? f94320) (current-output-port) (car f94320)))) (begin (when (fx= (port-ndx f94322) (port-size f94322)) (flush-output-port f94322)) (string-set! (port-buf f94322) (port-ndx f94322) f94319) (port-ndx-add1 f94322))))
# == eliminate-set!  ==>
# (lambda (f94319 . f94320) (let ((f94319 f94319)) (let ((f94322 (if (null? f94320) (current-output-port) (car f94320)))) (begin (when (fx= (port-ndx f94322) (port-size f94322)) (flush-output-port f94322)) (string-set! (port-buf f94322) (port-ndx f94322) f94319) (port-ndx-add1 f94322)))))
# == close-free-variables  ==>
# (closure (f94319 . f94320) () (let ((f94319 f94319)) (let ((f94322 (if (null? f94320) (current-output-port) (car f94320)))) (begin (when (fx= (port-ndx f94322) (port-size f94322)) (flush-output-port f94322)) (string-set! (port-buf f94322) (port-ndx f94322) f94319) (port-ndx-add1 f94322)))))
# == eliminate-quote  ==>
# (closure (f94319 . f94320) () (let ((f94319 f94319)) (let ((f94322 (if (null? f94320) (current-output-port) (car f94320)))) (begin (when (fx= (port-ndx f94322) (port-size f94322)) (flush-output-port f94322)) (string-set! (port-buf f94322) (port-ndx f94322) f94319) (port-ndx-add1 f94322)))))
# == eliminate-when/unless  ==>
# (closure (f94319 . f94320) () (let ((f94319 f94319)) (let ((f94322 (if (null? f94320) (current-output-port) (car f94320)))) (begin (if (fx= (port-ndx f94322) (port-size f94322)) (begin (flush-output-port f94322)) #f) (string-set! (port-buf f94322) (port-ndx f94322) f94319) (port-ndx-add1 f94322)))))
# == eliminate-cond  ==>
# (closure (f94319 . f94320) () (let ((f94319 f94319)) (let ((f94322 (if (null? f94320) (current-output-port) (car f94320)))) (begin (if (fx= (port-ndx f94322) (port-size f94322)) (begin (flush-output-port f94322)) #f) (string-set! (port-buf f94322) (port-ndx f94322) f94319) (port-ndx-add1 f94322)))))
# == external-symbols  ==>
# (closure (f94319 . f94320) () (let ((f94319 f94319)) (let ((f94322 (if (null? f94320) ((primitive-ref current-output-port)) (car f94320)))) (begin (if (fx= ((primitive-ref port-ndx) f94322) ((primitive-ref port-size) f94322)) (begin ((primitive-ref flush-output-port) f94322)) #f) (string-set! ((primitive-ref port-buf) f94322) ((primitive-ref port-ndx) f94322) f94319) ((primitive-ref port-ndx-add1) f94322)))))
# emit-expr (closure (f94319 . f94320) () (let ((f94319 f94319)) (let ((f94322 (if (null? f94320) ((primitive-ref current-output-port)) (car f94320)))) (begin (if (fx= ((primitive-ref port-ndx) f94322) ((primitive-ref port-size) f94322)) (begin ((primitive-ref flush-output-port) f94322)) #f) (string-set! ((primitive-ref port-buf) f94322) ((primitive-ref port-ndx) f94322) f94319) ((primitive-ref port-ndx-add1) f94322)))))
# emit-closure
# si = 0
# env = ()
# expr = (closure (f94319 . f94320) () (let ((f94319 f94319)) (let ((f94322 (if (null? f94320) ((primitive-ref current-output-port)) (car f94320)))) (begin (if (fx= ((primitive-ref port-ndx) f94322) ((primitive-ref port-size) f94322)) (begin ((primitive-ref flush-output-port) f94322)) #f) (string-set! ((primitive-ref port-buf) f94322) ((primitive-ref port-ndx) f94322) f94319) ((primitive-ref port-ndx-add1) f94322)))))
    movl $_L_571565, 0(%ebp)  # closure label
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $8, %ebp     # bump ebp
    jmp _L_571566            # jump around closure body
_L_571565:
# check argument count
    cmp $4,%eax
    jge _L_571567
# invoke error handler eh_argcount_min
    .extern mrc_eh$uargcount$umin
    movl mrc_eh$uargcount$umin, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_571567:
# emit-build-varargs-list
    movl $63, %esi       # args <- () 
    lea -4(%esp),%edi    # edi <- esp-4
    subl %eax, %edi      # edi <- esp-4-eax    addr of arg[K+N] on stack
_L_571569:
    lea -8(%esp),%ebx    # addr of arg[K] on stack
    cmp %edi, %ebx       # while edi <> esp+(si+4)
    je _L_571568
    movl (%edi),%ebx     # arg i -> car
    movl %ebx, 0(%ebp)
    movl %esi, 4(%ebp)  # esi -> cdr
    movl %ebp, %esi
    addl $1, %esi       # tag as pair
    addl $8,%ebp         # bump heap ptr
    addl $4,%edi         # move to next previous arg from the end
    jmp _L_571569
_L_571568:
    movl %esi, -12(%esp)  # set args
# emit-tail-expr
# si=-16
# env=((f94320 . -12) (f94319 . -8))
# expr=(let ((f94319 f94319)) (let ((f94322 (if (null? f94320) ((primitive-ref current-output-port)) (car f94320)))) (begin (if (fx= ((primitive-ref port-ndx) f94322) ((primitive-ref port-size) f94322)) (begin ((primitive-ref flush-output-port) f94322)) #f) (string-set! ((primitive-ref port-buf) f94322) ((primitive-ref port-ndx) f94322) f94319) ((primitive-ref port-ndx-add1) f94322))))
# emit-tail-let
#  si   = -16
#  env  = ((f94320 . -12) (f94319 . -8))
#  bindings = ((f94319 f94319))
#  body = (let ((f94322 (if (null? f94320) ((primitive-ref current-output-port)) (car f94320)))) (begin (if (fx= ((primitive-ref port-ndx) f94322) ((primitive-ref port-size) f94322)) (begin ((primitive-ref flush-output-port) f94322)) #f) (string-set! ((primitive-ref port-buf) f94322) ((primitive-ref port-ndx) f94322) f94319) ((primitive-ref port-ndx-add1) f94322)))
# emit-expr f94319
# emit-variable-ref
# env=((f94320 . -12) (f94319 . -8))
# var=f94319
    movl -8(%esp), %eax  # stack load f94319
# end emit-variable-ref
    movl %eax, -16(%esp)  # stack save
# emit-tail-expr
# si=-20
# env=((f94319 . -16) (f94320 . -12) (f94319 . -8))
# expr=(let ((f94322 (if (null? f94320) ((primitive-ref current-output-port)) (car f94320)))) (begin (if (fx= ((primitive-ref port-ndx) f94322) ((primitive-ref port-size) f94322)) (begin ((primitive-ref flush-output-port) f94322)) #f) (string-set! ((primitive-ref port-buf) f94322) ((primitive-ref port-ndx) f94322) f94319) ((primitive-ref port-ndx-add1) f94322)))
# emit-tail-let
#  si   = -20
#  env  = ((f94319 . -16) (f94320 . -12) (f94319 . -8))
#  bindings = ((f94322 (if (null? f94320) ((primitive-ref current-output-port)) (car f94320))))
#  body = (begin (if (fx= ((primitive-ref port-ndx) f94322) ((primitive-ref port-size) f94322)) (begin ((primitive-ref flush-output-port) f94322)) #f) (string-set! ((primitive-ref port-buf) f94322) ((primitive-ref port-ndx) f94322) f94319) ((primitive-ref port-ndx-add1) f94322))
# emit-expr (if (null? f94320) ((primitive-ref current-output-port)) (car f94320))
# emit-expr (null? f94320)
# emit-expr f94320
# emit-variable-ref
# env=((f94319 . -16) (f94320 . -12) (f94319 . -8))
# var=f94320
    movl -12(%esp), %eax  # stack load f94320
# end emit-variable-ref
    cmp $63, %eax
    mov $0, %eax
    sete %al
    movzbl %al, %eax
    sal $6, %al
    or $47, %al
    cmp $47, %al
    je _L_571570
# emit-expr ((primitive-ref current-output-port))
# funcall
#    si   =-20
#    env  = ((f94319 . -16) (f94320 . -12) (f94319 . -8))
#    expr = (funcall (primitive-ref current-output-port))
# emit-expr (primitive-ref current-output-port)
    .extern mrc_current$moutput$mport
    movl mrc_current$moutput$mport,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_571572"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_571572":
   movl %eax,  -28(%esp)  # stash funcall-oper in closure slot
    movl -28(%esp), %edi   # load new closure to %edi
    add $-20, %esp   # adjust base
    movl $0,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $20, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    jmp _L_571571
_L_571570:
# emit-expr (car f94320)
# emit-expr f94320
# emit-variable-ref
# env=((f94319 . -16) (f94320 . -12) (f94319 . -8))
# var=f94320
    movl -12(%esp), %eax  # stack load f94320
# end emit-variable-ref
# check the argument is a pair
    movl %eax,%ebx
    and $7, %bl
    cmp $1, %bl
    je _L_571573
# invoke error handler eh_pair
    .extern mrc_eh$upair
    movl mrc_eh$upair, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $116,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_571573:
    movl -1(%eax), %eax
_L_571571:
    movl %eax, -20(%esp)  # stack save
# emit-tail-expr
# si=-24
# env=((f94322 . -20) (f94319 . -16) (f94320 . -12) (f94319 . -8))
# expr=(begin (if (fx= ((primitive-ref port-ndx) f94322) ((primitive-ref port-size) f94322)) (begin ((primitive-ref flush-output-port) f94322)) #f) (string-set! ((primitive-ref port-buf) f94322) ((primitive-ref port-ndx) f94322) f94319) ((primitive-ref port-ndx-add1) f94322))
# tail-begin (begin (if (fx= ((primitive-ref port-ndx) f94322) ((primitive-ref port-size) f94322)) (begin ((primitive-ref flush-output-port) f94322)) #f) (string-set! ((primitive-ref port-buf) f94322) ((primitive-ref port-ndx) f94322) f94319) ((primitive-ref port-ndx-add1) f94322))
#   env=((f94322 . -20) (f94319 . -16) (f94320 . -12) (f94319 . -8))
# emit-expr (if (fx= ((primitive-ref port-ndx) f94322) ((primitive-ref port-size) f94322)) (begin ((primitive-ref flush-output-port) f94322)) #f)
# emit-expr (fx= ((primitive-ref port-ndx) f94322) ((primitive-ref port-size) f94322))
# emit-expr ((primitive-ref port-size) f94322)
# funcall
#    si   =-24
#    env  = ((f94322 . -20) (f94319 . -16) (f94320 . -12) (f94319 . -8))
#    expr = (funcall (primitive-ref port-size) f94322)
# emit-expr (primitive-ref port-size)
    .extern mrc_port$msize
    movl mrc_port$msize,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_571576"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_571576":
   movl %eax,  -32(%esp)  # stash funcall-oper in closure slot
# emit-expr f94322
# emit-variable-ref
# env=((f94322 . -20) (f94319 . -16) (f94320 . -12) (f94319 . -8))
# var=f94322
    movl -20(%esp), %eax  # stack load f94322
# end emit-variable-ref
    mov %eax, -36(%esp)  # arg f94322
    movl -32(%esp), %edi   # load new closure to %edi
    add $-24, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $24, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_571577"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $68,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_571577:
    movl %eax, -24(%esp)
# emit-expr ((primitive-ref port-ndx) f94322)
# funcall
#    si   =-28
#    env  = ((f94322 . -20) (f94319 . -16) (f94320 . -12) (f94319 . -8))
#    expr = (funcall (primitive-ref port-ndx) f94322)
# emit-expr (primitive-ref port-ndx)
    .extern mrc_port$mndx
    movl mrc_port$mndx,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_571578"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_571578":
   movl %eax,  -36(%esp)  # stash funcall-oper in closure slot
# emit-expr f94322
# emit-variable-ref
# env=((f94322 . -20) (f94319 . -16) (f94320 . -12) (f94319 . -8))
# var=f94322
    movl -20(%esp), %eax  # stack load f94322
# end emit-variable-ref
    mov %eax, -40(%esp)  # arg f94322
    movl -36(%esp), %edi   # load new closure to %edi
    add $-28, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $28, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_571579"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $68,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_571579:
    cmp -24(%esp), %eax
    sete %al
    movzbl %al, %eax
    sal $6, %al
    or $47, %al
    cmp $47, %al
    je _L_571574
# emit-expr (begin ((primitive-ref flush-output-port) f94322))
# emit-begin
#   expr=(begin ((primitive-ref flush-output-port) f94322))
#   env=((f94322 . -20) (f94319 . -16) (f94320 . -12) (f94319 . -8))
# emit-expr ((primitive-ref flush-output-port) f94322)
# funcall
#    si   =-24
#    env  = ((f94322 . -20) (f94319 . -16) (f94320 . -12) (f94319 . -8))
#    expr = (funcall (primitive-ref flush-output-port) f94322)
# emit-expr (primitive-ref flush-output-port)
    .extern mrc_flush$moutput$mport
    movl mrc_flush$moutput$mport,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_571580"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_571580":
   movl %eax,  -32(%esp)  # stash funcall-oper in closure slot
# emit-expr f94322
# emit-variable-ref
# env=((f94322 . -20) (f94319 . -16) (f94320 . -12) (f94319 . -8))
# var=f94322
    movl -20(%esp), %eax  # stack load f94322
# end emit-variable-ref
    mov %eax, -36(%esp)  # arg f94322
    movl -32(%esp), %edi   # load new closure to %edi
    add $-24, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $24, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
# emit-expr (begin)
# emit-begin
#   expr=(begin)
#   env=((f94322 . -20) (f94319 . -16) (f94320 . -12) (f94319 . -8))
    jmp _L_571575
_L_571574:
# emit-expr #f
    movl $47, %eax     # immed #f
_L_571575:
# emit-tail-expr
# si=-24
# env=((f94322 . -20) (f94319 . -16) (f94320 . -12) (f94319 . -8))
# expr=(begin (string-set! ((primitive-ref port-buf) f94322) ((primitive-ref port-ndx) f94322) f94319) ((primitive-ref port-ndx-add1) f94322))
# tail-begin (begin (string-set! ((primitive-ref port-buf) f94322) ((primitive-ref port-ndx) f94322) f94319) ((primitive-ref port-ndx-add1) f94322))
#   env=((f94322 . -20) (f94319 . -16) (f94320 . -12) (f94319 . -8))
# emit-expr (string-set! ((primitive-ref port-buf) f94322) ((primitive-ref port-ndx) f94322) f94319)
# emit-expr ((primitive-ref port-buf) f94322)
# funcall
#    si   =-24
#    env  = ((f94322 . -20) (f94319 . -16) (f94320 . -12) (f94319 . -8))
#    expr = (funcall (primitive-ref port-buf) f94322)
# emit-expr (primitive-ref port-buf)
    .extern mrc_port$mbuf
    movl mrc_port$mbuf,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_571581"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_571581":
   movl %eax,  -32(%esp)  # stash funcall-oper in closure slot
# emit-expr f94322
# emit-variable-ref
# env=((f94322 . -20) (f94319 . -16) (f94320 . -12) (f94319 . -8))
# var=f94322
    movl -20(%esp), %eax  # stack load f94322
# end emit-variable-ref
    mov %eax, -36(%esp)  # arg f94322
    movl -32(%esp), %edi   # load new closure to %edi
    add $-24, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $24, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
# check the argument is a string
    movl %eax,%ebx
    and $7, %bl
    cmp $6, %bl
    je _L_571582
# invoke error handler eh_string
    .extern mrc_eh$ustring
    movl mrc_eh$ustring, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $168,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_571582:
    movl %eax, -24(%esp)
# emit-expr ((primitive-ref port-ndx) f94322)
# funcall
#    si   =-24
#    env  = ((f94322 . -20) (f94319 . -16) (f94320 . -12) (f94319 . -8))
#    expr = (funcall (primitive-ref port-ndx) f94322)
# emit-expr (primitive-ref port-ndx)
    .extern mrc_port$mndx
    movl mrc_port$mndx,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_571583"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_571583":
   movl %eax,  -32(%esp)  # stash funcall-oper in closure slot
# emit-expr f94322
# emit-variable-ref
# env=((f94322 . -20) (f94319 . -16) (f94320 . -12) (f94319 . -8))
# var=f94322
    movl -20(%esp), %eax  # stack load f94322
# end emit-variable-ref
    mov %eax, -36(%esp)  # arg f94322
    movl -32(%esp), %edi   # load new closure to %edi
    add $-24, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $24, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_571584"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $168,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_571584:
# check bounds on string index
    movl -24(%esp), %ebx
    cmp  %eax,-6(%ebx) 
    jle _L_571586
    cmp  $0,%eax
    jge _L_571585
_L_571586:
# invoke error handler eh_string_index
    .extern mrc_eh$ustring$uindex
    movl mrc_eh$ustring$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $168,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_571585:
    movl %eax, -28(%esp)
# emit-expr f94319
# emit-variable-ref
# env=((f94322 . -20) (f94319 . -16) (f94320 . -12) (f94319 . -8))
# var=f94319
    movl -16(%esp), %eax  # stack load f94319
# end emit-variable-ref
# check the argument is a char
    movl %eax,%ebx
    and $255, %bl
    cmp $15, %bl
    je "_L_571587"
# invoke error handler eh_character
    .extern mrc_eh$ucharacter
    movl mrc_eh$ucharacter, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $168,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_571587:
    movl -24(%esp), %ebx
    movl -28(%esp), %esi
    sar $2, %esi
    movb  %ah, -2(%ebx,%esi)
# emit-tail-expr
# si=-24
# env=((f94322 . -20) (f94319 . -16) (f94320 . -12) (f94319 . -8))
# expr=(begin ((primitive-ref port-ndx-add1) f94322))
# tail-begin (begin ((primitive-ref port-ndx-add1) f94322))
#   env=((f94322 . -20) (f94319 . -16) (f94320 . -12) (f94319 . -8))
# emit-tail-expr
# si=-24
# env=((f94322 . -20) (f94319 . -16) (f94320 . -12) (f94319 . -8))
# expr=((primitive-ref port-ndx-add1) f94322)
# emit-tail-funcall
#    si   =-24
#    env  = ((f94322 . -20) (f94319 . -16) (f94320 . -12) (f94319 . -8))
#    expr = (funcall (primitive-ref port-ndx-add1) f94322)
# emit-expr (primitive-ref port-ndx-add1)
    .extern mrc_port$mndx$madd1
    movl mrc_port$mndx$madd1,%eax
   movl %eax,  -24(%esp)  # stash funcall-oper in next closure slot
# emit-expr f94322
# emit-variable-ref
# env=((f94322 . -20) (f94319 . -16) (f94320 . -12) (f94319 . -8))
# var=f94322
    movl -20(%esp), %eax  # stack load f94322
# end emit-variable-ref
    mov %eax, -28(%esp)    # arg f94322
    movl -24(%esp), %edi   # load new closure to %edi
# emit-shift-args:  size=2   si=-24  delta=20
    mov -24(%esp), %ebx  # shift frame cell
    mov %ebx, -4(%esp)  # down to base
# emit-shift-args:  size=1   si=-28  delta=20
    mov -28(%esp), %ebx  # shift frame cell
    mov %ebx, -8(%esp)  # down to base
# emit-shift-args:  size=0   si=-32  delta=20
    movl $4,%eax   # save arg count
    jmp *-2(%edi)  # tail-funcall
     ret   # return thru stack
    .align 4,0x90
_L_571566:
     movl %eax, mrc_write$mchar
# == explicit-begins  ==>
# (lambda args (let ((p (if (null? args) (current-output-port) (car args)))) (begin (foreign-call "s_write" (port-fd p) (port-buf p) (port-ndx p)) (port-ndx-reset p))))
# == eliminate-let*  ==>
# (lambda args (let ((p (if (null? args) (current-output-port) (car args)))) (begin (foreign-call "s_write" (port-fd p) (port-buf p) (port-ndx p)) (port-ndx-reset p))))
# == uniquify-variables  ==>
# (lambda f94323 (let ((f94325 (if (null? f94323) (current-output-port) (car f94323)))) (begin (foreign-call "s_write" (port-fd f94325) (port-buf f94325) (port-ndx f94325)) (port-ndx-reset f94325))))
# == vectorize-letrec  ==>
# (lambda f94323 (let ((f94325 (if (null? f94323) (current-output-port) (car f94323)))) (begin (foreign-call "s_write" (port-fd f94325) (port-buf f94325) (port-ndx f94325)) (port-ndx-reset f94325))))
# == eliminate-set!  ==>
# (lambda f94323 (let () (let ((f94325 (if (null? f94323) (current-output-port) (car f94323)))) (begin (foreign-call "s_write" (port-fd f94325) (port-buf f94325) (port-ndx f94325)) (port-ndx-reset f94325)))))
# == close-free-variables  ==>
# (closure f94323 () (let () (let ((f94325 (if (null? f94323) (current-output-port) (car f94323)))) (begin (foreign-call "s_write" (port-fd f94325) (port-buf f94325) (port-ndx f94325)) (port-ndx-reset f94325)))))
# == eliminate-quote  ==>
# (closure f94323 () (let () (let ((f94325 (if (null? f94323) (current-output-port) (car f94323)))) (begin (foreign-call "s_write" (port-fd f94325) (port-buf f94325) (port-ndx f94325)) (port-ndx-reset f94325)))))
# == eliminate-when/unless  ==>
# (closure f94323 () (let () (let ((f94325 (if (null? f94323) (current-output-port) (car f94323)))) (begin (foreign-call "s_write" (port-fd f94325) (port-buf f94325) (port-ndx f94325)) (port-ndx-reset f94325)))))
# == eliminate-cond  ==>
# (closure f94323 () (let () (let ((f94325 (if (null? f94323) (current-output-port) (car f94323)))) (begin (foreign-call "s_write" (port-fd f94325) (port-buf f94325) (port-ndx f94325)) (port-ndx-reset f94325)))))
# == external-symbols  ==>
# (closure f94323 () (let () (let ((f94325 (if (null? f94323) ((primitive-ref current-output-port)) (car f94323)))) (begin (foreign-call "s_write" ((primitive-ref port-fd) f94325) ((primitive-ref port-buf) f94325) ((primitive-ref port-ndx) f94325)) ((primitive-ref port-ndx-reset) f94325)))))
# emit-expr (closure f94323 () (let () (let ((f94325 (if (null? f94323) ((primitive-ref current-output-port)) (car f94323)))) (begin (foreign-call "s_write" ((primitive-ref port-fd) f94325) ((primitive-ref port-buf) f94325) ((primitive-ref port-ndx) f94325)) ((primitive-ref port-ndx-reset) f94325)))))
# emit-closure
# si = 0
# env = ()
# expr = (closure f94323 () (let () (let ((f94325 (if (null? f94323) ((primitive-ref current-output-port)) (car f94323)))) (begin (foreign-call "s_write" ((primitive-ref port-fd) f94325) ((primitive-ref port-buf) f94325) ((primitive-ref port-ndx) f94325)) ((primitive-ref port-ndx-reset) f94325)))))
    movl $_L_571588, 0(%ebp)  # closure label
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $8, %ebp     # bump ebp
    jmp _L_571589            # jump around closure body
_L_571588:
# check argument count
    cmp $0,%eax
    jge _L_571590
# invoke error handler eh_argcount_min
    .extern mrc_eh$uargcount$umin
    movl mrc_eh$uargcount$umin, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_571590:
# emit-build-varargs-list
    movl $63, %esi       # args <- () 
    lea -4(%esp),%edi    # edi <- esp-4
    subl %eax, %edi      # edi <- esp-4-eax    addr of arg[K+N] on stack
_L_571592:
    lea -4(%esp),%ebx    # addr of arg[K] on stack
    cmp %edi, %ebx       # while edi <> esp+(si+4)
    je _L_571591
    movl (%edi),%ebx     # arg i -> car
    movl %ebx, 0(%ebp)
    movl %esi, 4(%ebp)  # esi -> cdr
    movl %ebp, %esi
    addl $1, %esi       # tag as pair
    addl $8,%ebp         # bump heap ptr
    addl $4,%edi         # move to next previous arg from the end
    jmp _L_571592
_L_571591:
    movl %esi, -8(%esp)  # set args
# emit-tail-expr
# si=-12
# env=((f94323 . -8))
# expr=(let () (let ((f94325 (if (null? f94323) ((primitive-ref current-output-port)) (car f94323)))) (begin (foreign-call "s_write" ((primitive-ref port-fd) f94325) ((primitive-ref port-buf) f94325) ((primitive-ref port-ndx) f94325)) ((primitive-ref port-ndx-reset) f94325))))
# emit-tail-let
#  si   = -12
#  env  = ((f94323 . -8))
#  bindings = ()
#  body = (let ((f94325 (if (null? f94323) ((primitive-ref current-output-port)) (car f94323)))) (begin (foreign-call "s_write" ((primitive-ref port-fd) f94325) ((primitive-ref port-buf) f94325) ((primitive-ref port-ndx) f94325)) ((primitive-ref port-ndx-reset) f94325)))
# emit-tail-expr
# si=-12
# env=((f94323 . -8))
# expr=(let ((f94325 (if (null? f94323) ((primitive-ref current-output-port)) (car f94323)))) (begin (foreign-call "s_write" ((primitive-ref port-fd) f94325) ((primitive-ref port-buf) f94325) ((primitive-ref port-ndx) f94325)) ((primitive-ref port-ndx-reset) f94325)))
# emit-tail-let
#  si   = -12
#  env  = ((f94323 . -8))
#  bindings = ((f94325 (if (null? f94323) ((primitive-ref current-output-port)) (car f94323))))
#  body = (begin (foreign-call "s_write" ((primitive-ref port-fd) f94325) ((primitive-ref port-buf) f94325) ((primitive-ref port-ndx) f94325)) ((primitive-ref port-ndx-reset) f94325))
# emit-expr (if (null? f94323) ((primitive-ref current-output-port)) (car f94323))
# emit-expr (null? f94323)
# emit-expr f94323
# emit-variable-ref
# env=((f94323 . -8))
# var=f94323
    movl -8(%esp), %eax  # stack load f94323
# end emit-variable-ref
    cmp $63, %eax
    mov $0, %eax
    sete %al
    movzbl %al, %eax
    sal $6, %al
    or $47, %al
    cmp $47, %al
    je _L_571593
# emit-expr ((primitive-ref current-output-port))
# funcall
#    si   =-12
#    env  = ((f94323 . -8))
#    expr = (funcall (primitive-ref current-output-port))
# emit-expr (primitive-ref current-output-port)
    .extern mrc_current$moutput$mport
    movl mrc_current$moutput$mport,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_571595"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_571595":
   movl %eax,  -20(%esp)  # stash funcall-oper in closure slot
    movl -20(%esp), %edi   # load new closure to %edi
    add $-12, %esp   # adjust base
    movl $0,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $12, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    jmp _L_571594
_L_571593:
# emit-expr (car f94323)
# emit-expr f94323
# emit-variable-ref
# env=((f94323 . -8))
# var=f94323
    movl -8(%esp), %eax  # stack load f94323
# end emit-variable-ref
# check the argument is a pair
    movl %eax,%ebx
    and $7, %bl
    cmp $1, %bl
    je _L_571596
# invoke error handler eh_pair
    .extern mrc_eh$upair
    movl mrc_eh$upair, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $116,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_571596:
    movl -1(%eax), %eax
_L_571594:
    movl %eax, -12(%esp)  # stack save
# emit-tail-expr
# si=-16
# env=((f94325 . -12) (f94323 . -8))
# expr=(begin (foreign-call "s_write" ((primitive-ref port-fd) f94325) ((primitive-ref port-buf) f94325) ((primitive-ref port-ndx) f94325)) ((primitive-ref port-ndx-reset) f94325))
# tail-begin (begin (foreign-call "s_write" ((primitive-ref port-fd) f94325) ((primitive-ref port-buf) f94325) ((primitive-ref port-ndx) f94325)) ((primitive-ref port-ndx-reset) f94325))
#   env=((f94325 . -12) (f94323 . -8))
# emit-expr (foreign-call "s_write" ((primitive-ref port-fd) f94325) ((primitive-ref port-buf) f94325) ((primitive-ref port-ndx) f94325))
    movl %ecx,-16(%esp)
    movl %esp,-20(%esp)
# emit-expr ((primitive-ref port-ndx) f94325)
# funcall
#    si   =-24
#    env  = ((f94325 . -12) (f94323 . -8))
#    expr = (funcall (primitive-ref port-ndx) f94325)
# emit-expr (primitive-ref port-ndx)
    .extern mrc_port$mndx
    movl mrc_port$mndx,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_571597"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_571597":
   movl %eax,  -32(%esp)  # stash funcall-oper in closure slot
# emit-expr f94325
# emit-variable-ref
# env=((f94325 . -12) (f94323 . -8))
# var=f94325
    movl -12(%esp), %eax  # stack load f94325
# end emit-variable-ref
    mov %eax, -36(%esp)  # arg f94325
    movl -32(%esp), %edi   # load new closure to %edi
    add $-24, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $24, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    movl %eax, -24(%esp)
# emit-expr ((primitive-ref port-buf) f94325)
# funcall
#    si   =-28
#    env  = ((f94325 . -12) (f94323 . -8))
#    expr = (funcall (primitive-ref port-buf) f94325)
# emit-expr (primitive-ref port-buf)
    .extern mrc_port$mbuf
    movl mrc_port$mbuf,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_571598"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_571598":
   movl %eax,  -36(%esp)  # stash funcall-oper in closure slot
# emit-expr f94325
# emit-variable-ref
# env=((f94325 . -12) (f94323 . -8))
# var=f94325
    movl -12(%esp), %eax  # stack load f94325
# end emit-variable-ref
    mov %eax, -40(%esp)  # arg f94325
    movl -36(%esp), %edi   # load new closure to %edi
    add $-28, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $28, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    movl %eax, -28(%esp)
# emit-expr ((primitive-ref port-fd) f94325)
# funcall
#    si   =-32
#    env  = ((f94325 . -12) (f94323 . -8))
#    expr = (funcall (primitive-ref port-fd) f94325)
# emit-expr (primitive-ref port-fd)
    .extern mrc_port$mfd
    movl mrc_port$mfd,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_571599"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_571599":
   movl %eax,  -40(%esp)  # stash funcall-oper in closure slot
# emit-expr f94325
# emit-variable-ref
# env=((f94325 . -12) (f94323 . -8))
# var=f94325
    movl -12(%esp), %eax  # stack load f94325
# end emit-variable-ref
    mov %eax, -44(%esp)  # arg f94325
    movl -40(%esp), %edi   # load new closure to %edi
    add $-32, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $32, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    movl %eax, -32(%esp)
    leal -32(%esp),%edi
    movl %edi,%esi
    andl $-16,%esi
    movl 0(%edi),%eax
    movl %eax,0(%esi)
    movl 4(%edi),%eax
    movl %eax,4(%esi)
    movl 8(%edi),%eax
    movl %eax,8(%esi)
    movl 12(%edi),%eax
    movl %eax,12(%esi)
    movl %esi,%esp
    .extern _s_write
    call _s_write
    movl 12(%esi),%esp
    movl -16(%esp),%ecx
# emit-tail-expr
# si=-16
# env=((f94325 . -12) (f94323 . -8))
# expr=(begin ((primitive-ref port-ndx-reset) f94325))
# tail-begin (begin ((primitive-ref port-ndx-reset) f94325))
#   env=((f94325 . -12) (f94323 . -8))
# emit-tail-expr
# si=-16
# env=((f94325 . -12) (f94323 . -8))
# expr=((primitive-ref port-ndx-reset) f94325)
# emit-tail-funcall
#    si   =-16
#    env  = ((f94325 . -12) (f94323 . -8))
#    expr = (funcall (primitive-ref port-ndx-reset) f94325)
# emit-expr (primitive-ref port-ndx-reset)
    .extern mrc_port$mndx$mreset
    movl mrc_port$mndx$mreset,%eax
   movl %eax,  -16(%esp)  # stash funcall-oper in next closure slot
# emit-expr f94325
# emit-variable-ref
# env=((f94325 . -12) (f94323 . -8))
# var=f94325
    movl -12(%esp), %eax  # stack load f94325
# end emit-variable-ref
    mov %eax, -20(%esp)    # arg f94325
    movl -16(%esp), %edi   # load new closure to %edi
# emit-shift-args:  size=2   si=-16  delta=12
    mov -16(%esp), %ebx  # shift frame cell
    mov %ebx, -4(%esp)  # down to base
# emit-shift-args:  size=1   si=-20  delta=12
    mov -20(%esp), %ebx  # shift frame cell
    mov %ebx, -8(%esp)  # down to base
# emit-shift-args:  size=0   si=-24  delta=12
    movl $4,%eax   # save arg count
    jmp *-2(%edi)  # tail-funcall
     ret   # return thru stack
    .align 4,0x90
_L_571589:
     movl %eax, mrc_flush$moutput$mport
# == explicit-begins  ==>
# (lambda () (begin (flush-output-port) (foreign-call "s_exit")))
# == eliminate-let*  ==>
# (lambda () (begin (flush-output-port) (foreign-call "s_exit")))
# == uniquify-variables  ==>
# (lambda () (begin (flush-output-port) (foreign-call "s_exit")))
# == vectorize-letrec  ==>
# (lambda () (begin (flush-output-port) (foreign-call "s_exit")))
# == eliminate-set!  ==>
# (lambda () (let () (begin (flush-output-port) (foreign-call "s_exit"))))
# == close-free-variables  ==>
# (closure () () (let () (begin (flush-output-port) (foreign-call "s_exit"))))
# == eliminate-quote  ==>
# (closure () () (let () (begin (flush-output-port) (foreign-call "s_exit"))))
# == eliminate-when/unless  ==>
# (closure () () (let () (begin (flush-output-port) (foreign-call "s_exit"))))
# == eliminate-cond  ==>
# (closure () () (let () (begin (flush-output-port) (foreign-call "s_exit"))))
# == external-symbols  ==>
# (closure () () (let () (begin ((primitive-ref flush-output-port)) (foreign-call "s_exit"))))
# emit-expr (closure () () (let () (begin ((primitive-ref flush-output-port)) (foreign-call "s_exit"))))
# emit-closure
# si = 0
# env = ()
# expr = (closure () () (let () (begin ((primitive-ref flush-output-port)) (foreign-call "s_exit"))))
    movl $_L_571600, 0(%ebp)  # closure label
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $8, %ebp     # bump ebp
    jmp _L_571601            # jump around closure body
_L_571600:
# check argument count
    cmp $0,%eax
    je _L_571602
# invoke error handler eh_argcount
    .extern mrc_eh$uargcount
    movl mrc_eh$uargcount, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_571602:
# emit-tail-expr
# si=-8
# env=()
# expr=(let () (begin ((primitive-ref flush-output-port)) (foreign-call "s_exit")))
# emit-tail-let
#  si   = -8
#  env  = ()
#  bindings = ()
#  body = (begin ((primitive-ref flush-output-port)) (foreign-call "s_exit"))
# emit-tail-expr
# si=-8
# env=()
# expr=(begin ((primitive-ref flush-output-port)) (foreign-call "s_exit"))
# tail-begin (begin ((primitive-ref flush-output-port)) (foreign-call "s_exit"))
#   env=()
# emit-expr ((primitive-ref flush-output-port))
# funcall
#    si   =-8
#    env  = ()
#    expr = (funcall (primitive-ref flush-output-port))
# emit-expr (primitive-ref flush-output-port)
    .extern mrc_flush$moutput$mport
    movl mrc_flush$moutput$mport,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_571603"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_571603":
   movl %eax,  -16(%esp)  # stash funcall-oper in closure slot
    movl -16(%esp), %edi   # load new closure to %edi
    add $-8, %esp   # adjust base
    movl $0,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $8, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
# emit-tail-expr
# si=-8
# env=()
# expr=(begin (foreign-call "s_exit"))
# tail-begin (begin (foreign-call "s_exit"))
#   env=()
# emit-tail-expr
# si=-8
# env=()
# expr=(foreign-call "s_exit")
    movl %ecx,-8(%esp)
    movl %esp,-12(%esp)
    leal -12(%esp),%edi
    movl %edi,%esi
    andl $-16,%esi
    movl 0(%edi),%eax
    movl %eax,0(%esi)
    movl %esi,%esp
    .extern _s_exit
    call _s_exit
    movl 0(%esi),%esp
    movl -8(%esp),%ecx
     ret
     ret   # return thru stack
    .align 4,0x90
_L_571601:
     movl %eax, mrc_exit
# == explicit-begins  ==>
# (lambda (filename) (begin (unless (string? filename) (error (quote open-output-file) "filename must be a string")) (let ((fd (foreign-call "s_open" filename))) (begin (when (negative? fd) (error (quote open-output-file) "open failed")) (let ((p (make-vector 6)) (sz 1024)) (begin (vector-set! p 0 (quote output-port)) (vector-set! p 1 filename) (vector-set! p 2 fd) (vector-set! p 3 (make-string sz)) (vector-set! p 4 0) (vector-set! p 5 sz) p))))))
# == eliminate-let*  ==>
# (lambda (filename) (begin (unless (string? filename) (error (quote open-output-file) "filename must be a string")) (let ((fd (foreign-call "s_open" filename))) (begin (when (negative? fd) (error (quote open-output-file) "open failed")) (let ((p (make-vector 6)) (sz 1024)) (begin (vector-set! p 0 (quote output-port)) (vector-set! p 1 filename) (vector-set! p 2 fd) (vector-set! p 3 (make-string sz)) (vector-set! p 4 0) (vector-set! p 5 sz) p))))))
# == uniquify-variables  ==>
# (lambda (f94326) (begin (unless (string? f94326) (error (quote open-output-file) "filename must be a string")) (let ((f94332 (foreign-call "s_open" f94326))) (begin (when (negative? f94332) (error (quote open-output-file) "open failed")) (let ((f94336 (make-vector 6)) (f94335 1024)) (begin (vector-set! f94336 0 (quote output-port)) (vector-set! f94336 1 f94326) (vector-set! f94336 2 f94332) (vector-set! f94336 3 (make-string f94335)) (vector-set! f94336 4 0) (vector-set! f94336 5 f94335) f94336))))))
# == vectorize-letrec  ==>
# (lambda (f94326) (begin (unless (string? f94326) (error (quote open-output-file) "filename must be a string")) (let ((f94332 (foreign-call "s_open" f94326))) (begin (when (negative? f94332) (error (quote open-output-file) "open failed")) (let ((f94336 (make-vector 6)) (f94335 1024)) (begin (vector-set! f94336 0 (quote output-port)) (vector-set! f94336 1 f94326) (vector-set! f94336 2 f94332) (vector-set! f94336 3 (make-string f94335)) (vector-set! f94336 4 0) (vector-set! f94336 5 f94335) f94336))))))
# == eliminate-set!  ==>
# (lambda (f94326) (let ((f94326 f94326)) (begin (unless (string? f94326) (error (quote open-output-file) "filename must be a string")) (let ((f94332 (foreign-call "s_open" f94326))) (begin (when (negative? f94332) (error (quote open-output-file) "open failed")) (let ((f94336 (make-vector 6)) (f94335 1024)) (begin (vector-set! f94336 0 (quote output-port)) (vector-set! f94336 1 f94326) (vector-set! f94336 2 f94332) (vector-set! f94336 3 (make-string f94335)) (vector-set! f94336 4 0) (vector-set! f94336 5 f94335) f94336)))))))
# == close-free-variables  ==>
# (closure (f94326) (output-port) (let ((f94326 f94326)) (begin (unless (string? f94326) (error (quote open-output-file) "filename must be a string")) (let ((f94332 (foreign-call "s_open" f94326))) (begin (when (negative? f94332) (error (quote open-output-file) "open failed")) (let ((f94336 (make-vector 6)) (f94335 1024)) (begin (vector-set! f94336 0 (quote output-port)) (vector-set! f94336 1 f94326) (vector-set! f94336 2 f94332) (vector-set! f94336 3 (make-string f94335)) (vector-set! f94336 4 0) (vector-set! f94336 5 f94335) f94336)))))))
# == eliminate-quote  ==>
# (closure (f94326) (output-port) (let ((f94326 f94326)) (begin (unless (string? f94326) (error (string->symbol "open-output-file") "filename must be a string")) (let ((f94332 (foreign-call "s_open" f94326))) (begin (when (negative? f94332) (error (string->symbol "open-output-file") "open failed")) (let ((f94336 (make-vector 6)) (f94335 1024)) (begin (vector-set! f94336 0 (string->symbol "output-port")) (vector-set! f94336 1 f94326) (vector-set! f94336 2 f94332) (vector-set! f94336 3 (make-string f94335)) (vector-set! f94336 4 0) (vector-set! f94336 5 f94335) f94336)))))))
# == eliminate-when/unless  ==>
# (closure (f94326) (output-port) (let ((f94326 f94326)) (begin (if (not (string? f94326)) (begin (error (string->symbol "open-output-file") "filename must be a string")) #f) (let ((f94332 (foreign-call "s_open" f94326))) (begin (if (negative? f94332) (begin (error (string->symbol "open-output-file") "open failed")) #f) (let ((f94336 (make-vector 6)) (f94335 1024)) (begin (vector-set! f94336 0 (string->symbol "output-port")) (vector-set! f94336 1 f94326) (vector-set! f94336 2 f94332) (vector-set! f94336 3 (make-string f94335)) (vector-set! f94336 4 0) (vector-set! f94336 5 f94335) f94336)))))))
# == eliminate-cond  ==>
# (closure (f94326) (output-port) (let ((f94326 f94326)) (begin (if (not (string? f94326)) (begin (error (string->symbol "open-output-file") "filename must be a string")) #f) (let ((f94332 (foreign-call "s_open" f94326))) (begin (if (negative? f94332) (begin (error (string->symbol "open-output-file") "open failed")) #f) (let ((f94336 (make-vector 6)) (f94335 1024)) (begin (vector-set! f94336 0 (string->symbol "output-port")) (vector-set! f94336 1 f94326) (vector-set! f94336 2 f94332) (vector-set! f94336 3 (make-string f94335)) (vector-set! f94336 4 0) (vector-set! f94336 5 f94335) f94336)))))))
# == external-symbols  ==>
# (closure (f94326) (output-port) (let ((f94326 f94326)) (begin (if (not (string? f94326)) (begin ((primitive-ref error) ((primitive-ref string->symbol) "open-output-file") "filename must be a string")) #f) (let ((f94332 (foreign-call "s_open" f94326))) (begin (if ((primitive-ref negative?) f94332) (begin ((primitive-ref error) ((primitive-ref string->symbol) "open-output-file") "open failed")) #f) (let ((f94336 (make-vector 6)) (f94335 1024)) (begin (vector-set! f94336 0 ((primitive-ref string->symbol) "output-port")) (vector-set! f94336 1 f94326) (vector-set! f94336 2 f94332) (vector-set! f94336 3 (make-string f94335)) (vector-set! f94336 4 0) (vector-set! f94336 5 f94335) f94336)))))))
# emit-expr (closure (f94326) (output-port) (let ((f94326 f94326)) (begin (if (not (string? f94326)) (begin ((primitive-ref error) ((primitive-ref string->symbol) "open-output-file") "filename must be a string")) #f) (let ((f94332 (foreign-call "s_open" f94326))) (begin (if ((primitive-ref negative?) f94332) (begin ((primitive-ref error) ((primitive-ref string->symbol) "open-output-file") "open failed")) #f) (let ((f94336 (make-vector 6)) (f94335 1024)) (begin (vector-set! f94336 0 ((primitive-ref string->symbol) "output-port")) (vector-set! f94336 1 f94326) (vector-set! f94336 2 f94332) (vector-set! f94336 3 (make-string f94335)) (vector-set! f94336 4 0) (vector-set! f94336 5 f94335) f94336)))))))
# emit-closure
# si = 0
# env = ()
# expr = (closure (f94326) (output-port) (let ((f94326 f94326)) (begin (if (not (string? f94326)) (begin ((primitive-ref error) ((primitive-ref string->symbol) "open-output-file") "filename must be a string")) #f) (let ((f94332 (foreign-call "s_open" f94326))) (begin (if ((primitive-ref negative?) f94332) (begin ((primitive-ref error) ((primitive-ref string->symbol) "open-output-file") "open failed")) #f) (let ((f94336 (make-vector 6)) (f94335 1024)) (begin (vector-set! f94336 0 ((primitive-ref string->symbol) "output-port")) (vector-set! f94336 1 f94326) (vector-set! f94336 2 f94332) (vector-set! f94336 3 (make-string f94335)) (vector-set! f94336 4 0) (vector-set! f94336 5 f94335) f94336)))))))
    movl $_L_571604, 0(%ebp)  # closure label
# WARNING: free var output-port not defined in the environmnet
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $8, %ebp     # bump ebp
    jmp _L_571605            # jump around closure body
_L_571604:
# check argument count
    cmp $4,%eax
    je _L_571606
# invoke error handler eh_argcount
    .extern mrc_eh$uargcount
    movl mrc_eh$uargcount, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_571606:
# emit-tail-expr
# si=-12
# env=((f94326 . -8) (output-port . 4))
# expr=(let ((f94326 f94326)) (begin (if (not (string? f94326)) (begin ((primitive-ref error) ((primitive-ref string->symbol) "open-output-file") "filename must be a string")) #f) (let ((f94332 (foreign-call "s_open" f94326))) (begin (if ((primitive-ref negative?) f94332) (begin ((primitive-ref error) ((primitive-ref string->symbol) "open-output-file") "open failed")) #f) (let ((f94336 (make-vector 6)) (f94335 1024)) (begin (vector-set! f94336 0 ((primitive-ref string->symbol) "output-port")) (vector-set! f94336 1 f94326) (vector-set! f94336 2 f94332) (vector-set! f94336 3 (make-string f94335)) (vector-set! f94336 4 0) (vector-set! f94336 5 f94335) f94336))))))
# emit-tail-let
#  si   = -12
#  env  = ((f94326 . -8) (output-port . 4))
#  bindings = ((f94326 f94326))
#  body = (begin (if (not (string? f94326)) (begin ((primitive-ref error) ((primitive-ref string->symbol) "open-output-file") "filename must be a string")) #f) (let ((f94332 (foreign-call "s_open" f94326))) (begin (if ((primitive-ref negative?) f94332) (begin ((primitive-ref error) ((primitive-ref string->symbol) "open-output-file") "open failed")) #f) (let ((f94336 (make-vector 6)) (f94335 1024)) (begin (vector-set! f94336 0 ((primitive-ref string->symbol) "output-port")) (vector-set! f94336 1 f94326) (vector-set! f94336 2 f94332) (vector-set! f94336 3 (make-string f94335)) (vector-set! f94336 4 0) (vector-set! f94336 5 f94335) f94336)))))
# emit-expr f94326
# emit-variable-ref
# env=((f94326 . -8) (output-port . 4))
# var=f94326
    movl -8(%esp), %eax  # stack load f94326
# end emit-variable-ref
    movl %eax, -12(%esp)  # stack save
# emit-tail-expr
# si=-16
# env=((f94326 . -12) (f94326 . -8) (output-port . 4))
# expr=(begin (if (not (string? f94326)) (begin ((primitive-ref error) ((primitive-ref string->symbol) "open-output-file") "filename must be a string")) #f) (let ((f94332 (foreign-call "s_open" f94326))) (begin (if ((primitive-ref negative?) f94332) (begin ((primitive-ref error) ((primitive-ref string->symbol) "open-output-file") "open failed")) #f) (let ((f94336 (make-vector 6)) (f94335 1024)) (begin (vector-set! f94336 0 ((primitive-ref string->symbol) "output-port")) (vector-set! f94336 1 f94326) (vector-set! f94336 2 f94332) (vector-set! f94336 3 (make-string f94335)) (vector-set! f94336 4 0) (vector-set! f94336 5 f94335) f94336)))))
# tail-begin (begin (if (not (string? f94326)) (begin ((primitive-ref error) ((primitive-ref string->symbol) "open-output-file") "filename must be a string")) #f) (let ((f94332 (foreign-call "s_open" f94326))) (begin (if ((primitive-ref negative?) f94332) (begin ((primitive-ref error) ((primitive-ref string->symbol) "open-output-file") "open failed")) #f) (let ((f94336 (make-vector 6)) (f94335 1024)) (begin (vector-set! f94336 0 ((primitive-ref string->symbol) "output-port")) (vector-set! f94336 1 f94326) (vector-set! f94336 2 f94332) (vector-set! f94336 3 (make-string f94335)) (vector-set! f94336 4 0) (vector-set! f94336 5 f94335) f94336)))))
#   env=((f94326 . -12) (f94326 . -8) (output-port . 4))
# emit-expr (if (not (string? f94326)) (begin ((primitive-ref error) ((primitive-ref string->symbol) "open-output-file") "filename must be a string")) #f)
# emit-expr (not (string? f94326))
# emit-expr (string? f94326)
# emit-expr f94326
# emit-variable-ref
# env=((f94326 . -12) (f94326 . -8) (output-port . 4))
# var=f94326
    movl -12(%esp), %eax  # stack load f94326
# end emit-variable-ref
    and $7, %al
    cmp $6, %al
    sete %al
    movzbl %al, %eax
    sal $6, %al
    or $47, %al
    cmp $47, %eax
    sete %al
    movzbl %al, %eax
    sal $6, %al
    or $47, %al
    cmp $47, %al
    je _L_571607
# emit-expr (begin ((primitive-ref error) ((primitive-ref string->symbol) "open-output-file") "filename must be a string"))
# emit-begin
#   expr=(begin ((primitive-ref error) ((primitive-ref string->symbol) "open-output-file") "filename must be a string"))
#   env=((f94326 . -12) (f94326 . -8) (output-port . 4))
# emit-expr ((primitive-ref error) ((primitive-ref string->symbol) "open-output-file") "filename must be a string")
# funcall
#    si   =-16
#    env  = ((f94326 . -12) (f94326 . -8) (output-port . 4))
#    expr = (funcall (primitive-ref error) ((primitive-ref string->symbol) "open-output-file") "filename must be a string")
# emit-expr (primitive-ref error)
    .extern mrc_error
    movl mrc_error,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_571609"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_571609":
   movl %eax,  -24(%esp)  # stash funcall-oper in closure slot
# emit-expr ((primitive-ref string->symbol) "open-output-file")
# funcall
#    si   =-28
#    env  = ((f94326 . -12) (f94326 . -8) (output-port . 4))
#    expr = (funcall (primitive-ref string->symbol) "open-output-file")
# emit-expr (primitive-ref string->symbol)
    .extern mrc_string$m$gsymbol
    movl mrc_string$m$gsymbol,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_571610"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_571610":
   movl %eax,  -36(%esp)  # stash funcall-oper in closure slot
# emit-expr "open-output-file"
# string literal
    jmp _L_571612
    .align 8,0x90
_L_571611 :
    .int 64
    .ascii "open-output-file"
_L_571612:
    movl $_L_571611, %eax
    orl $6, %eax
    mov %eax, -40(%esp)  # arg open-output-file
    movl -36(%esp), %edi   # load new closure to %edi
    add $-28, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $28, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    mov %eax, -28(%esp)  # arg ((primitive-ref string->symbol) open-output-file)
# emit-expr "filename must be a string"
# string literal
    jmp _L_571614
    .align 8,0x90
_L_571613 :
    .int 100
    .ascii "filename must be a string"
_L_571614:
    movl $_L_571613, %eax
    orl $6, %eax
    mov %eax, -32(%esp)  # arg filename must be a string
    movl -24(%esp), %edi   # load new closure to %edi
    add $-16, %esp   # adjust base
    movl $8,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $16, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
# emit-expr (begin)
# emit-begin
#   expr=(begin)
#   env=((f94326 . -12) (f94326 . -8) (output-port . 4))
    jmp _L_571608
_L_571607:
# emit-expr #f
    movl $47, %eax     # immed #f
_L_571608:
# emit-tail-expr
# si=-16
# env=((f94326 . -12) (f94326 . -8) (output-port . 4))
# expr=(begin (let ((f94332 (foreign-call "s_open" f94326))) (begin (if ((primitive-ref negative?) f94332) (begin ((primitive-ref error) ((primitive-ref string->symbol) "open-output-file") "open failed")) #f) (let ((f94336 (make-vector 6)) (f94335 1024)) (begin (vector-set! f94336 0 ((primitive-ref string->symbol) "output-port")) (vector-set! f94336 1 f94326) (vector-set! f94336 2 f94332) (vector-set! f94336 3 (make-string f94335)) (vector-set! f94336 4 0) (vector-set! f94336 5 f94335) f94336)))))
# tail-begin (begin (let ((f94332 (foreign-call "s_open" f94326))) (begin (if ((primitive-ref negative?) f94332) (begin ((primitive-ref error) ((primitive-ref string->symbol) "open-output-file") "open failed")) #f) (let ((f94336 (make-vector 6)) (f94335 1024)) (begin (vector-set! f94336 0 ((primitive-ref string->symbol) "output-port")) (vector-set! f94336 1 f94326) (vector-set! f94336 2 f94332) (vector-set! f94336 3 (make-string f94335)) (vector-set! f94336 4 0) (vector-set! f94336 5 f94335) f94336)))))
#   env=((f94326 . -12) (f94326 . -8) (output-port . 4))
# emit-tail-expr
# si=-16
# env=((f94326 . -12) (f94326 . -8) (output-port . 4))
# expr=(let ((f94332 (foreign-call "s_open" f94326))) (begin (if ((primitive-ref negative?) f94332) (begin ((primitive-ref error) ((primitive-ref string->symbol) "open-output-file") "open failed")) #f) (let ((f94336 (make-vector 6)) (f94335 1024)) (begin (vector-set! f94336 0 ((primitive-ref string->symbol) "output-port")) (vector-set! f94336 1 f94326) (vector-set! f94336 2 f94332) (vector-set! f94336 3 (make-string f94335)) (vector-set! f94336 4 0) (vector-set! f94336 5 f94335) f94336))))
# emit-tail-let
#  si   = -16
#  env  = ((f94326 . -12) (f94326 . -8) (output-port . 4))
#  bindings = ((f94332 (foreign-call "s_open" f94326)))
#  body = (begin (if ((primitive-ref negative?) f94332) (begin ((primitive-ref error) ((primitive-ref string->symbol) "open-output-file") "open failed")) #f) (let ((f94336 (make-vector 6)) (f94335 1024)) (begin (vector-set! f94336 0 ((primitive-ref string->symbol) "output-port")) (vector-set! f94336 1 f94326) (vector-set! f94336 2 f94332) (vector-set! f94336 3 (make-string f94335)) (vector-set! f94336 4 0) (vector-set! f94336 5 f94335) f94336)))
# emit-expr (foreign-call "s_open" f94326)
    movl %ecx,-16(%esp)
    movl %esp,-20(%esp)
# emit-expr f94326
# emit-variable-ref
# env=((f94326 . -12) (f94326 . -8) (output-port . 4))
# var=f94326
    movl -12(%esp), %eax  # stack load f94326
# end emit-variable-ref
    movl %eax, -24(%esp)
    leal -24(%esp),%edi
    movl %edi,%esi
    andl $-16,%esi
    movl 0(%edi),%eax
    movl %eax,0(%esi)
    movl 4(%edi),%eax
    movl %eax,4(%esi)
    movl %esi,%esp
    .extern _s_open
    call _s_open
    movl 4(%esi),%esp
    movl -16(%esp),%ecx
    movl %eax, -16(%esp)  # stack save
# emit-tail-expr
# si=-20
# env=((f94332 . -16) (f94326 . -12) (f94326 . -8) (output-port . 4))
# expr=(begin (if ((primitive-ref negative?) f94332) (begin ((primitive-ref error) ((primitive-ref string->symbol) "open-output-file") "open failed")) #f) (let ((f94336 (make-vector 6)) (f94335 1024)) (begin (vector-set! f94336 0 ((primitive-ref string->symbol) "output-port")) (vector-set! f94336 1 f94326) (vector-set! f94336 2 f94332) (vector-set! f94336 3 (make-string f94335)) (vector-set! f94336 4 0) (vector-set! f94336 5 f94335) f94336)))
# tail-begin (begin (if ((primitive-ref negative?) f94332) (begin ((primitive-ref error) ((primitive-ref string->symbol) "open-output-file") "open failed")) #f) (let ((f94336 (make-vector 6)) (f94335 1024)) (begin (vector-set! f94336 0 ((primitive-ref string->symbol) "output-port")) (vector-set! f94336 1 f94326) (vector-set! f94336 2 f94332) (vector-set! f94336 3 (make-string f94335)) (vector-set! f94336 4 0) (vector-set! f94336 5 f94335) f94336)))
#   env=((f94332 . -16) (f94326 . -12) (f94326 . -8) (output-port . 4))
# emit-expr (if ((primitive-ref negative?) f94332) (begin ((primitive-ref error) ((primitive-ref string->symbol) "open-output-file") "open failed")) #f)
# emit-expr ((primitive-ref negative?) f94332)
# funcall
#    si   =-20
#    env  = ((f94332 . -16) (f94326 . -12) (f94326 . -8) (output-port . 4))
#    expr = (funcall (primitive-ref negative?) f94332)
# emit-expr (primitive-ref negative?)
    .extern mrc_negative$q
    movl mrc_negative$q,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_571617"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_571617":
   movl %eax,  -28(%esp)  # stash funcall-oper in closure slot
# emit-expr f94332
# emit-variable-ref
# env=((f94332 . -16) (f94326 . -12) (f94326 . -8) (output-port . 4))
# var=f94332
    movl -16(%esp), %eax  # stack load f94332
# end emit-variable-ref
    mov %eax, -32(%esp)  # arg f94332
    movl -28(%esp), %edi   # load new closure to %edi
    add $-20, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $20, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    cmp $47, %al
    je _L_571615
# emit-expr (begin ((primitive-ref error) ((primitive-ref string->symbol) "open-output-file") "open failed"))
# emit-begin
#   expr=(begin ((primitive-ref error) ((primitive-ref string->symbol) "open-output-file") "open failed"))
#   env=((f94332 . -16) (f94326 . -12) (f94326 . -8) (output-port . 4))
# emit-expr ((primitive-ref error) ((primitive-ref string->symbol) "open-output-file") "open failed")
# funcall
#    si   =-20
#    env  = ((f94332 . -16) (f94326 . -12) (f94326 . -8) (output-port . 4))
#    expr = (funcall (primitive-ref error) ((primitive-ref string->symbol) "open-output-file") "open failed")
# emit-expr (primitive-ref error)
    .extern mrc_error
    movl mrc_error,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_571618"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_571618":
   movl %eax,  -28(%esp)  # stash funcall-oper in closure slot
# emit-expr ((primitive-ref string->symbol) "open-output-file")
# funcall
#    si   =-32
#    env  = ((f94332 . -16) (f94326 . -12) (f94326 . -8) (output-port . 4))
#    expr = (funcall (primitive-ref string->symbol) "open-output-file")
# emit-expr (primitive-ref string->symbol)
    .extern mrc_string$m$gsymbol
    movl mrc_string$m$gsymbol,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_571619"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_571619":
   movl %eax,  -40(%esp)  # stash funcall-oper in closure slot
# emit-expr "open-output-file"
# string literal
    jmp _L_571621
    .align 8,0x90
_L_571620 :
    .int 64
    .ascii "open-output-file"
_L_571621:
    movl $_L_571620, %eax
    orl $6, %eax
    mov %eax, -44(%esp)  # arg open-output-file
    movl -40(%esp), %edi   # load new closure to %edi
    add $-32, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $32, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    mov %eax, -32(%esp)  # arg ((primitive-ref string->symbol) open-output-file)
# emit-expr "open failed"
# string literal
    jmp _L_571623
    .align 8,0x90
_L_571622 :
    .int 44
    .ascii "open failed"
_L_571623:
    movl $_L_571622, %eax
    orl $6, %eax
    mov %eax, -36(%esp)  # arg open failed
    movl -28(%esp), %edi   # load new closure to %edi
    add $-20, %esp   # adjust base
    movl $8,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $20, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
# emit-expr (begin)
# emit-begin
#   expr=(begin)
#   env=((f94332 . -16) (f94326 . -12) (f94326 . -8) (output-port . 4))
    jmp _L_571616
_L_571615:
# emit-expr #f
    movl $47, %eax     # immed #f
_L_571616:
# emit-tail-expr
# si=-20
# env=((f94332 . -16) (f94326 . -12) (f94326 . -8) (output-port . 4))
# expr=(begin (let ((f94336 (make-vector 6)) (f94335 1024)) (begin (vector-set! f94336 0 ((primitive-ref string->symbol) "output-port")) (vector-set! f94336 1 f94326) (vector-set! f94336 2 f94332) (vector-set! f94336 3 (make-string f94335)) (vector-set! f94336 4 0) (vector-set! f94336 5 f94335) f94336)))
# tail-begin (begin (let ((f94336 (make-vector 6)) (f94335 1024)) (begin (vector-set! f94336 0 ((primitive-ref string->symbol) "output-port")) (vector-set! f94336 1 f94326) (vector-set! f94336 2 f94332) (vector-set! f94336 3 (make-string f94335)) (vector-set! f94336 4 0) (vector-set! f94336 5 f94335) f94336)))
#   env=((f94332 . -16) (f94326 . -12) (f94326 . -8) (output-port . 4))
# emit-tail-expr
# si=-20
# env=((f94332 . -16) (f94326 . -12) (f94326 . -8) (output-port . 4))
# expr=(let ((f94336 (make-vector 6)) (f94335 1024)) (begin (vector-set! f94336 0 ((primitive-ref string->symbol) "output-port")) (vector-set! f94336 1 f94326) (vector-set! f94336 2 f94332) (vector-set! f94336 3 (make-string f94335)) (vector-set! f94336 4 0) (vector-set! f94336 5 f94335) f94336))
# emit-tail-let
#  si   = -20
#  env  = ((f94332 . -16) (f94326 . -12) (f94326 . -8) (output-port . 4))
#  bindings = ((f94336 (make-vector 6)) (f94335 1024))
#  body = (begin (vector-set! f94336 0 ((primitive-ref string->symbol) "output-port")) (vector-set! f94336 1 f94326) (vector-set! f94336 2 f94332) (vector-set! f94336 3 (make-string f94335)) (vector-set! f94336 4 0) (vector-set! f94336 5 f94335) f94336)
# emit-expr (make-vector 6)
# make-vector 6
# emit-expr 6
    movl $24, %eax     # immed 6
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_571624"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_571624:
# check the argument is a fixnum >= 0
    cmp $0,%eax
    jge _L_571625
# invoke error handler eh_length
    .extern mrc_eh$ulength
    movl mrc_eh$ulength, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_571625:
    movl %eax, %esi
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    orl  $5, %eax
    addl $4, %esi
    addl $4, %esi
    andl $-8, %esi
    addl %esi, %ebp
    movl %eax, -20(%esp)  # stack save
# emit-expr 1024
    movl $4096, %eax     # immed 1024
    movl %eax, -24(%esp)  # stack save
# emit-tail-expr
# si=-28
# env=((f94335 . -24) (f94336 . -20) (f94332 . -16) (f94326 . -12) (f94326 . -8) (output-port . 4))
# expr=(begin (vector-set! f94336 0 ((primitive-ref string->symbol) "output-port")) (vector-set! f94336 1 f94326) (vector-set! f94336 2 f94332) (vector-set! f94336 3 (make-string f94335)) (vector-set! f94336 4 0) (vector-set! f94336 5 f94335) f94336)
# tail-begin (begin (vector-set! f94336 0 ((primitive-ref string->symbol) "output-port")) (vector-set! f94336 1 f94326) (vector-set! f94336 2 f94332) (vector-set! f94336 3 (make-string f94335)) (vector-set! f94336 4 0) (vector-set! f94336 5 f94335) f94336)
#   env=((f94335 . -24) (f94336 . -20) (f94332 . -16) (f94326 . -12) (f94326 . -8) (output-port . 4))
# emit-expr (vector-set! f94336 0 ((primitive-ref string->symbol) "output-port"))
# emit-expr f94336
# emit-variable-ref
# env=((f94335 . -24) (f94336 . -20) (f94332 . -16) (f94326 . -12) (f94326 . -8) (output-port . 4))
# var=f94336
    movl -20(%esp), %eax  # stack load f94336
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_571626
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_571626:
    movl %eax, -28(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_571627"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_571627:
# check bounds on vector index
    movl -28(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_571629
    cmp  $0,%eax
    jge _L_571628
_L_571629:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_571628:
    movl %eax, -32(%esp)
# emit-expr ((primitive-ref string->symbol) "output-port")
# funcall
#    si   =-36
#    env  = ((f94335 . -24) (f94336 . -20) (f94332 . -16) (f94326 . -12) (f94326 . -8) (output-port . 4))
#    expr = (funcall (primitive-ref string->symbol) "output-port")
# emit-expr (primitive-ref string->symbol)
    .extern mrc_string$m$gsymbol
    movl mrc_string$m$gsymbol,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_571630"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_571630":
   movl %eax,  -44(%esp)  # stash funcall-oper in closure slot
# emit-expr "output-port"
# string literal
    jmp _L_571632
    .align 8,0x90
_L_571631 :
    .int 44
    .ascii "output-port"
_L_571632:
    movl $_L_571631, %eax
    orl $6, %eax
    mov %eax, -48(%esp)  # arg output-port
    movl -44(%esp), %edi   # load new closure to %edi
    add $-36, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $36, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    movl -28(%esp), %ebx
    movl -32(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-tail-expr
# si=-28
# env=((f94335 . -24) (f94336 . -20) (f94332 . -16) (f94326 . -12) (f94326 . -8) (output-port . 4))
# expr=(begin (vector-set! f94336 1 f94326) (vector-set! f94336 2 f94332) (vector-set! f94336 3 (make-string f94335)) (vector-set! f94336 4 0) (vector-set! f94336 5 f94335) f94336)
# tail-begin (begin (vector-set! f94336 1 f94326) (vector-set! f94336 2 f94332) (vector-set! f94336 3 (make-string f94335)) (vector-set! f94336 4 0) (vector-set! f94336 5 f94335) f94336)
#   env=((f94335 . -24) (f94336 . -20) (f94332 . -16) (f94326 . -12) (f94326 . -8) (output-port . 4))
# emit-expr (vector-set! f94336 1 f94326)
# emit-expr f94336
# emit-variable-ref
# env=((f94335 . -24) (f94336 . -20) (f94332 . -16) (f94326 . -12) (f94326 . -8) (output-port . 4))
# var=f94336
    movl -20(%esp), %eax  # stack load f94336
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_571633
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_571633:
    movl %eax, -28(%esp)
# emit-expr 1
    movl $4, %eax     # immed 1
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_571634"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_571634:
# check bounds on vector index
    movl -28(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_571636
    cmp  $0,%eax
    jge _L_571635
_L_571636:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_571635:
    movl %eax, -32(%esp)
# emit-expr f94326
# emit-variable-ref
# env=((f94335 . -24) (f94336 . -20) (f94332 . -16) (f94326 . -12) (f94326 . -8) (output-port . 4))
# var=f94326
    movl -12(%esp), %eax  # stack load f94326
# end emit-variable-ref
    movl -28(%esp), %ebx
    movl -32(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-tail-expr
# si=-28
# env=((f94335 . -24) (f94336 . -20) (f94332 . -16) (f94326 . -12) (f94326 . -8) (output-port . 4))
# expr=(begin (vector-set! f94336 2 f94332) (vector-set! f94336 3 (make-string f94335)) (vector-set! f94336 4 0) (vector-set! f94336 5 f94335) f94336)
# tail-begin (begin (vector-set! f94336 2 f94332) (vector-set! f94336 3 (make-string f94335)) (vector-set! f94336 4 0) (vector-set! f94336 5 f94335) f94336)
#   env=((f94335 . -24) (f94336 . -20) (f94332 . -16) (f94326 . -12) (f94326 . -8) (output-port . 4))
# emit-expr (vector-set! f94336 2 f94332)
# emit-expr f94336
# emit-variable-ref
# env=((f94335 . -24) (f94336 . -20) (f94332 . -16) (f94326 . -12) (f94326 . -8) (output-port . 4))
# var=f94336
    movl -20(%esp), %eax  # stack load f94336
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_571637
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_571637:
    movl %eax, -28(%esp)
# emit-expr 2
    movl $8, %eax     # immed 2
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_571638"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_571638:
# check bounds on vector index
    movl -28(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_571640
    cmp  $0,%eax
    jge _L_571639
_L_571640:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_571639:
    movl %eax, -32(%esp)
# emit-expr f94332
# emit-variable-ref
# env=((f94335 . -24) (f94336 . -20) (f94332 . -16) (f94326 . -12) (f94326 . -8) (output-port . 4))
# var=f94332
    movl -16(%esp), %eax  # stack load f94332
# end emit-variable-ref
    movl -28(%esp), %ebx
    movl -32(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-tail-expr
# si=-28
# env=((f94335 . -24) (f94336 . -20) (f94332 . -16) (f94326 . -12) (f94326 . -8) (output-port . 4))
# expr=(begin (vector-set! f94336 3 (make-string f94335)) (vector-set! f94336 4 0) (vector-set! f94336 5 f94335) f94336)
# tail-begin (begin (vector-set! f94336 3 (make-string f94335)) (vector-set! f94336 4 0) (vector-set! f94336 5 f94335) f94336)
#   env=((f94335 . -24) (f94336 . -20) (f94332 . -16) (f94326 . -12) (f94326 . -8) (output-port . 4))
# emit-expr (vector-set! f94336 3 (make-string f94335))
# emit-expr f94336
# emit-variable-ref
# env=((f94335 . -24) (f94336 . -20) (f94332 . -16) (f94326 . -12) (f94326 . -8) (output-port . 4))
# var=f94336
    movl -20(%esp), %eax  # stack load f94336
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_571641
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_571641:
    movl %eax, -28(%esp)
# emit-expr 3
    movl $12, %eax     # immed 3
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_571642"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_571642:
# check bounds on vector index
    movl -28(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_571644
    cmp  $0,%eax
    jge _L_571643
_L_571644:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_571643:
    movl %eax, -32(%esp)
# emit-expr (make-string f94335)
# make-string len=f94335
# emit-expr f94335
# emit-variable-ref
# env=((f94335 . -24) (f94336 . -20) (f94332 . -16) (f94326 . -12) (f94326 . -8) (output-port . 4))
# var=f94335
    movl -24(%esp), %eax  # stack load f94335
# end emit-variable-ref
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_571645"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $152,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_571645:
# check the argument is a fixnum >= 0
    cmp $0,%eax
    jge _L_571646
# invoke error handler eh_length
    .extern mrc_eh$ulength
    movl mrc_eh$ulength, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $152,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_571646:
    movl %eax, %esi
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    orl $6, %eax
    sar $2, %esi
    add $4, %esi
    add $7, %esi
    andl $-8, %esi
    add  %esi, %ebp
# make-string end
    movl -28(%esp), %ebx
    movl -32(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-tail-expr
# si=-28
# env=((f94335 . -24) (f94336 . -20) (f94332 . -16) (f94326 . -12) (f94326 . -8) (output-port . 4))
# expr=(begin (vector-set! f94336 4 0) (vector-set! f94336 5 f94335) f94336)
# tail-begin (begin (vector-set! f94336 4 0) (vector-set! f94336 5 f94335) f94336)
#   env=((f94335 . -24) (f94336 . -20) (f94332 . -16) (f94326 . -12) (f94326 . -8) (output-port . 4))
# emit-expr (vector-set! f94336 4 0)
# emit-expr f94336
# emit-variable-ref
# env=((f94335 . -24) (f94336 . -20) (f94332 . -16) (f94326 . -12) (f94326 . -8) (output-port . 4))
# var=f94336
    movl -20(%esp), %eax  # stack load f94336
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_571647
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_571647:
    movl %eax, -28(%esp)
# emit-expr 4
    movl $16, %eax     # immed 4
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_571648"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_571648:
# check bounds on vector index
    movl -28(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_571650
    cmp  $0,%eax
    jge _L_571649
_L_571650:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_571649:
    movl %eax, -32(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
    movl -28(%esp), %ebx
    movl -32(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-tail-expr
# si=-28
# env=((f94335 . -24) (f94336 . -20) (f94332 . -16) (f94326 . -12) (f94326 . -8) (output-port . 4))
# expr=(begin (vector-set! f94336 5 f94335) f94336)
# tail-begin (begin (vector-set! f94336 5 f94335) f94336)
#   env=((f94335 . -24) (f94336 . -20) (f94332 . -16) (f94326 . -12) (f94326 . -8) (output-port . 4))
# emit-expr (vector-set! f94336 5 f94335)
# emit-expr f94336
# emit-variable-ref
# env=((f94335 . -24) (f94336 . -20) (f94332 . -16) (f94326 . -12) (f94326 . -8) (output-port . 4))
# var=f94336
    movl -20(%esp), %eax  # stack load f94336
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_571651
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_571651:
    movl %eax, -28(%esp)
# emit-expr 5
    movl $20, %eax     # immed 5
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_571652"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_571652:
# check bounds on vector index
    movl -28(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_571654
    cmp  $0,%eax
    jge _L_571653
_L_571654:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_571653:
    movl %eax, -32(%esp)
# emit-expr f94335
# emit-variable-ref
# env=((f94335 . -24) (f94336 . -20) (f94332 . -16) (f94326 . -12) (f94326 . -8) (output-port . 4))
# var=f94335
    movl -24(%esp), %eax  # stack load f94335
# end emit-variable-ref
    movl -28(%esp), %ebx
    movl -32(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-tail-expr
# si=-28
# env=((f94335 . -24) (f94336 . -20) (f94332 . -16) (f94326 . -12) (f94326 . -8) (output-port . 4))
# expr=(begin f94336)
# tail-begin (begin f94336)
#   env=((f94335 . -24) (f94336 . -20) (f94332 . -16) (f94326 . -12) (f94326 . -8) (output-port . 4))
# emit-tail-expr
# si=-28
# env=((f94335 . -24) (f94336 . -20) (f94332 . -16) (f94326 . -12) (f94326 . -8) (output-port . 4))
# expr=f94336
# emit-tail-variable-ref
# emit-variable-ref
# env=((f94335 . -24) (f94336 . -20) (f94332 . -16) (f94326 . -12) (f94326 . -8) (output-port . 4))
# var=f94336
    movl -20(%esp), %eax  # stack load f94336
# end emit-variable-ref
    ret
# end emit-tail-variable ref
     ret   # return thru stack
     ret   # return thru stack
     ret   # return thru stack
    .align 4,0x90
_L_571605:
     movl %eax, mrc_open$moutput$mfile
# == explicit-begins  ==>
# (lambda (p) (foreign-call "s_close" (port-fd p)))
# == eliminate-let*  ==>
# (lambda (p) (foreign-call "s_close" (port-fd p)))
# == uniquify-variables  ==>
# (lambda (f94337) (foreign-call "s_close" (port-fd f94337)))
# == vectorize-letrec  ==>
# (lambda (f94337) (foreign-call "s_close" (port-fd f94337)))
# == eliminate-set!  ==>
# (lambda (f94337) (let ((f94337 f94337)) (foreign-call "s_close" (port-fd f94337))))
# == close-free-variables  ==>
# (closure (f94337) () (let ((f94337 f94337)) (foreign-call "s_close" (port-fd f94337))))
# == eliminate-quote  ==>
# (closure (f94337) () (let ((f94337 f94337)) (foreign-call "s_close" (port-fd f94337))))
# == eliminate-when/unless  ==>
# (closure (f94337) () (let ((f94337 f94337)) (foreign-call "s_close" (port-fd f94337))))
# == eliminate-cond  ==>
# (closure (f94337) () (let ((f94337 f94337)) (foreign-call "s_close" (port-fd f94337))))
# == external-symbols  ==>
# (closure (f94337) () (let ((f94337 f94337)) (foreign-call "s_close" ((primitive-ref port-fd) f94337))))
# emit-expr (closure (f94337) () (let ((f94337 f94337)) (foreign-call "s_close" ((primitive-ref port-fd) f94337))))
# emit-closure
# si = 0
# env = ()
# expr = (closure (f94337) () (let ((f94337 f94337)) (foreign-call "s_close" ((primitive-ref port-fd) f94337))))
    movl $_L_571655, 0(%ebp)  # closure label
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $8, %ebp     # bump ebp
    jmp _L_571656            # jump around closure body
_L_571655:
# check argument count
    cmp $4,%eax
    je _L_571657
# invoke error handler eh_argcount
    .extern mrc_eh$uargcount
    movl mrc_eh$uargcount, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_571657:
# emit-tail-expr
# si=-12
# env=((f94337 . -8))
# expr=(let ((f94337 f94337)) (foreign-call "s_close" ((primitive-ref port-fd) f94337)))
# emit-tail-let
#  si   = -12
#  env  = ((f94337 . -8))
#  bindings = ((f94337 f94337))
#  body = (foreign-call "s_close" ((primitive-ref port-fd) f94337))
# emit-expr f94337
# emit-variable-ref
# env=((f94337 . -8))
# var=f94337
    movl -8(%esp), %eax  # stack load f94337
# end emit-variable-ref
    movl %eax, -12(%esp)  # stack save
# emit-tail-expr
# si=-16
# env=((f94337 . -12) (f94337 . -8))
# expr=(foreign-call "s_close" ((primitive-ref port-fd) f94337))
    movl %ecx,-16(%esp)
    movl %esp,-20(%esp)
# emit-expr ((primitive-ref port-fd) f94337)
# funcall
#    si   =-24
#    env  = ((f94337 . -12) (f94337 . -8))
#    expr = (funcall (primitive-ref port-fd) f94337)
# emit-expr (primitive-ref port-fd)
    .extern mrc_port$mfd
    movl mrc_port$mfd,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_571658"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_571658":
   movl %eax,  -32(%esp)  # stash funcall-oper in closure slot
# emit-expr f94337
# emit-variable-ref
# env=((f94337 . -12) (f94337 . -8))
# var=f94337
    movl -12(%esp), %eax  # stack load f94337
# end emit-variable-ref
    mov %eax, -36(%esp)  # arg f94337
    movl -32(%esp), %edi   # load new closure to %edi
    add $-24, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $24, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    movl %eax, -24(%esp)
    leal -24(%esp),%edi
    movl %edi,%esi
    andl $-16,%esi
    movl 0(%edi),%eax
    movl %eax,0(%esi)
    movl 4(%edi),%eax
    movl %eax,4(%esi)
    movl %esi,%esp
    .extern _s_close
    call _s_close
    movl 4(%esi),%esp
    movl -16(%esp),%ecx
     ret
    .align 4,0x90
_L_571656:
     movl %eax, mrc_close$minput$mport
# == explicit-begins  ==>
# (lambda (p) (begin (flush-output-port p) (foreign-call "s_close" (port-fd p))))
# == eliminate-let*  ==>
# (lambda (p) (begin (flush-output-port p) (foreign-call "s_close" (port-fd p))))
# == uniquify-variables  ==>
# (lambda (f94338) (begin (flush-output-port f94338) (foreign-call "s_close" (port-fd f94338))))
# == vectorize-letrec  ==>
# (lambda (f94338) (begin (flush-output-port f94338) (foreign-call "s_close" (port-fd f94338))))
# == eliminate-set!  ==>
# (lambda (f94338) (let ((f94338 f94338)) (begin (flush-output-port f94338) (foreign-call "s_close" (port-fd f94338)))))
# == close-free-variables  ==>
# (closure (f94338) () (let ((f94338 f94338)) (begin (flush-output-port f94338) (foreign-call "s_close" (port-fd f94338)))))
# == eliminate-quote  ==>
# (closure (f94338) () (let ((f94338 f94338)) (begin (flush-output-port f94338) (foreign-call "s_close" (port-fd f94338)))))
# == eliminate-when/unless  ==>
# (closure (f94338) () (let ((f94338 f94338)) (begin (flush-output-port f94338) (foreign-call "s_close" (port-fd f94338)))))
# == eliminate-cond  ==>
# (closure (f94338) () (let ((f94338 f94338)) (begin (flush-output-port f94338) (foreign-call "s_close" (port-fd f94338)))))
# == external-symbols  ==>
# (closure (f94338) () (let ((f94338 f94338)) (begin ((primitive-ref flush-output-port) f94338) (foreign-call "s_close" ((primitive-ref port-fd) f94338)))))
# emit-expr (closure (f94338) () (let ((f94338 f94338)) (begin ((primitive-ref flush-output-port) f94338) (foreign-call "s_close" ((primitive-ref port-fd) f94338)))))
# emit-closure
# si = 0
# env = ()
# expr = (closure (f94338) () (let ((f94338 f94338)) (begin ((primitive-ref flush-output-port) f94338) (foreign-call "s_close" ((primitive-ref port-fd) f94338)))))
    movl $_L_571659, 0(%ebp)  # closure label
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $8, %ebp     # bump ebp
    jmp _L_571660            # jump around closure body
_L_571659:
# check argument count
    cmp $4,%eax
    je _L_571661
# invoke error handler eh_argcount
    .extern mrc_eh$uargcount
    movl mrc_eh$uargcount, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_571661:
# emit-tail-expr
# si=-12
# env=((f94338 . -8))
# expr=(let ((f94338 f94338)) (begin ((primitive-ref flush-output-port) f94338) (foreign-call "s_close" ((primitive-ref port-fd) f94338))))
# emit-tail-let
#  si   = -12
#  env  = ((f94338 . -8))
#  bindings = ((f94338 f94338))
#  body = (begin ((primitive-ref flush-output-port) f94338) (foreign-call "s_close" ((primitive-ref port-fd) f94338)))
# emit-expr f94338
# emit-variable-ref
# env=((f94338 . -8))
# var=f94338
    movl -8(%esp), %eax  # stack load f94338
# end emit-variable-ref
    movl %eax, -12(%esp)  # stack save
# emit-tail-expr
# si=-16
# env=((f94338 . -12) (f94338 . -8))
# expr=(begin ((primitive-ref flush-output-port) f94338) (foreign-call "s_close" ((primitive-ref port-fd) f94338)))
# tail-begin (begin ((primitive-ref flush-output-port) f94338) (foreign-call "s_close" ((primitive-ref port-fd) f94338)))
#   env=((f94338 . -12) (f94338 . -8))
# emit-expr ((primitive-ref flush-output-port) f94338)
# funcall
#    si   =-16
#    env  = ((f94338 . -12) (f94338 . -8))
#    expr = (funcall (primitive-ref flush-output-port) f94338)
# emit-expr (primitive-ref flush-output-port)
    .extern mrc_flush$moutput$mport
    movl mrc_flush$moutput$mport,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_571662"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_571662":
   movl %eax,  -24(%esp)  # stash funcall-oper in closure slot
# emit-expr f94338
# emit-variable-ref
# env=((f94338 . -12) (f94338 . -8))
# var=f94338
    movl -12(%esp), %eax  # stack load f94338
# end emit-variable-ref
    mov %eax, -28(%esp)  # arg f94338
    movl -24(%esp), %edi   # load new closure to %edi
    add $-16, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $16, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
# emit-tail-expr
# si=-16
# env=((f94338 . -12) (f94338 . -8))
# expr=(begin (foreign-call "s_close" ((primitive-ref port-fd) f94338)))
# tail-begin (begin (foreign-call "s_close" ((primitive-ref port-fd) f94338)))
#   env=((f94338 . -12) (f94338 . -8))
# emit-tail-expr
# si=-16
# env=((f94338 . -12) (f94338 . -8))
# expr=(foreign-call "s_close" ((primitive-ref port-fd) f94338))
    movl %ecx,-16(%esp)
    movl %esp,-20(%esp)
# emit-expr ((primitive-ref port-fd) f94338)
# funcall
#    si   =-24
#    env  = ((f94338 . -12) (f94338 . -8))
#    expr = (funcall (primitive-ref port-fd) f94338)
# emit-expr (primitive-ref port-fd)
    .extern mrc_port$mfd
    movl mrc_port$mfd,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_571663"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_571663":
   movl %eax,  -32(%esp)  # stash funcall-oper in closure slot
# emit-expr f94338
# emit-variable-ref
# env=((f94338 . -12) (f94338 . -8))
# var=f94338
    movl -12(%esp), %eax  # stack load f94338
# end emit-variable-ref
    mov %eax, -36(%esp)  # arg f94338
    movl -32(%esp), %edi   # load new closure to %edi
    add $-24, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $24, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    movl %eax, -24(%esp)
    leal -24(%esp),%edi
    movl %edi,%esi
    andl $-16,%esi
    movl 0(%edi),%eax
    movl %eax,0(%esi)
    movl 4(%edi),%eax
    movl %eax,4(%esi)
    movl %esi,%esp
    .extern _s_close
    call _s_close
    movl 4(%esi),%esp
    movl -16(%esp),%ecx
     ret
     ret   # return thru stack
    .align 4,0x90
_L_571660:
     movl %eax, mrc_close$moutput$mport
# == explicit-begins  ==>
# (letrec ((print-boolean (lambda (expr p) (begin (write-char #\# p) (if expr (write-char #\t p) (write-char #\f p))))) (print-null (lambda (p) (begin (write-char #\( p) (write-char #\) p)))) (print-char (lambda (expr p) (begin (write-char #\# p) (write-char #\\ p) (write-char expr p)))) (print-fixnum (lambda (i p) (if (negative? i) (begin (write-char #\- p) (print-fixnum (fx* -1 i) p)) (map (lambda (x) (write-char (fixnum->char (fx+ (char->fixnum #\0) x)) p)) (integer->list i))))) (print-string (lambda (s p) (begin (write-char #\" p) (for-each (lambda (c) (write-char c p)) (string->list s)) (write-char #\" p)))) (print-string-alpha (lambda (s p) (for-each (lambda (c) (write-char c p)) (string->list s)))) (print-pair (lambda (pr p) (begin (write-char #\( p) (print-pairs pr p) (write-char #\) p)))) (print-pairs (lambda (pr p) (begin (write (car pr) p) (cond ((null? (cdr pr)) #t) ((pair? (cdr pr)) (begin (write-char #\space p) (print-pairs (cdr pr) p))) (else (begin (write-char #\space p) (write-char #\. p) (write-char #\space p) (write (cdr pr) p)))))))) (lambda (expr p alpha) (cond ((boolean? expr) (print-boolean expr p)) ((null? expr) (print-null p)) ((char? expr) (if alpha (write-char expr p) (print-char expr p))) ((fixnum? expr) (print-fixnum expr p)) ((string? expr) (if alpha (print-string-alpha expr p) (print-string expr p))) ((pair? expr) (print-pair expr p)) (else (error (quote write) "unrecognized expression")))))
# == eliminate-let*  ==>
# (letrec ((print-boolean (lambda (expr p) (begin (write-char #\# p) (if expr (write-char #\t p) (write-char #\f p))))) (print-null (lambda (p) (begin (write-char #\( p) (write-char #\) p)))) (print-char (lambda (expr p) (begin (write-char #\# p) (write-char #\\ p) (write-char expr p)))) (print-fixnum (lambda (i p) (if (negative? i) (begin (write-char #\- p) (print-fixnum (fx* -1 i) p)) (map (lambda (x) (write-char (fixnum->char (fx+ (char->fixnum #\0) x)) p)) (integer->list i))))) (print-string (lambda (s p) (begin (write-char #\" p) (for-each (lambda (c) (write-char c p)) (string->list s)) (write-char #\" p)))) (print-string-alpha (lambda (s p) (for-each (lambda (c) (write-char c p)) (string->list s)))) (print-pair (lambda (pr p) (begin (write-char #\( p) (print-pairs pr p) (write-char #\) p)))) (print-pairs (lambda (pr p) (begin (write (car pr) p) (cond ((null? (cdr pr)) #t) ((pair? (cdr pr)) (begin (write-char #\space p) (print-pairs (cdr pr) p))) (else (begin (write-char #\space p) (write-char #\. p) (write-char #\space p) (write (cdr pr) p)))))))) (lambda (expr p alpha) (cond ((boolean? expr) (print-boolean expr p)) ((null? expr) (print-null p)) ((char? expr) (if alpha (write-char expr p) (print-char expr p))) ((fixnum? expr) (print-fixnum expr p)) ((string? expr) (if alpha (print-string-alpha expr p) (print-string expr p))) ((pair? expr) (print-pair expr p)) (else (error (quote write) "unrecognized expression")))))
# == uniquify-variables  ==>
# (letrec ((f94346 (lambda (f94387 f94388) (begin (write-char #\# f94388) (if f94387 (write-char #\t f94388) (write-char #\f f94388))))) (f94345 (lambda (f94386) (begin (write-char #\( f94386) (write-char #\) f94386)))) (f94344 (lambda (f94384 f94385) (begin (write-char #\# f94385) (write-char #\\ f94385) (write-char f94384 f94385)))) (f94343 (lambda (f94380 f94381) (if (negative? f94380) (begin (write-char #\- f94381) (f94343 (fx* -1 f94380) f94381)) (map (lambda (f94383) (write-char (fixnum->char (fx+ (char->fixnum #\0) f94383)) f94381)) (integer->list f94380))))) (f94342 (lambda (f94376 f94377) (begin (write-char #\" f94377) (for-each (lambda (f94379) (write-char f94379 f94377)) (string->list f94376)) (write-char #\" f94377)))) (f94341 (lambda (f94372 f94373) (for-each (lambda (f94375) (write-char f94375 f94373)) (string->list f94372)))) (f94340 (lambda (f94370 f94371) (begin (write-char #\( f94371) (f94339 f94370 f94371) (write-char #\) f94371)))) (f94339 (lambda (f94368 f94369) (begin (write (car f94368) f94369) (cond ((null? (cdr f94368)) #t) ((pair? (cdr f94368)) (begin (write-char #\space f94369) (f94339 (cdr f94368) f94369))) (else (begin (write-char #\space f94369) (write-char #\. f94369) (write-char #\space f94369) (write (cdr f94368) f94369)))))))) (lambda (f94392 f94393 f94394) (cond ((boolean? f94392) (f94346 f94392 f94393)) ((null? f94392) (f94345 f94393)) ((char? f94392) (if f94394 (write-char f94392 f94393) (f94344 f94392 f94393))) ((fixnum? f94392) (f94343 f94392 f94393)) ((string? f94392) (if f94394 (f94341 f94392 f94393) (f94342 f94392 f94393))) ((pair? f94392) (f94340 f94392 f94393)) (else (error (quote write) "unrecognized expression")))))
# == vectorize-letrec  ==>
# (let ((f94346 (make-vector 1)) (f94345 (make-vector 1)) (f94344 (make-vector 1)) (f94343 (make-vector 1)) (f94342 (make-vector 1)) (f94341 (make-vector 1)) (f94340 (make-vector 1)) (f94339 (make-vector 1))) (begin (begin (vector-set! f94346 0 (lambda (f94387 f94388) (begin (write-char #\# f94388) (if f94387 (write-char #\t f94388) (write-char #\f f94388))))) (vector-set! f94345 0 (lambda (f94386) (begin (write-char #\( f94386) (write-char #\) f94386)))) (vector-set! f94344 0 (lambda (f94384 f94385) (begin (write-char #\# f94385) (write-char #\\ f94385) (write-char f94384 f94385)))) (vector-set! f94343 0 (lambda (f94380 f94381) (if (negative? f94380) (begin (write-char #\- f94381) ((vector-ref f94343 0) (fx* -1 f94380) f94381)) (map (lambda (f94383) (write-char (fixnum->char (fx+ (char->fixnum #\0) f94383)) f94381)) (integer->list f94380))))) (vector-set! f94342 0 (lambda (f94376 f94377) (begin (write-char #\" f94377) (for-each (lambda (f94379) (write-char f94379 f94377)) (string->list f94376)) (write-char #\" f94377)))) (vector-set! f94341 0 (lambda (f94372 f94373) (for-each (lambda (f94375) (write-char f94375 f94373)) (string->list f94372)))) (vector-set! f94340 0 (lambda (f94370 f94371) (begin (write-char #\( f94371) ((vector-ref f94339 0) f94370 f94371) (write-char #\) f94371)))) (vector-set! f94339 0 (lambda (f94368 f94369) (begin (write (car f94368) f94369) (cond ((null? (cdr f94368)) #t) ((pair? (cdr f94368)) (begin (write-char #\space f94369) ((vector-ref f94339 0) (cdr f94368) f94369))) (else (begin (write-char #\space f94369) (write-char #\. f94369) (write-char #\space f94369) (write (cdr f94368) f94369)))))))) (lambda (f94392 f94393 f94394) (cond ((boolean? f94392) ((vector-ref f94346 0) f94392 f94393)) ((null? f94392) ((vector-ref f94345 0) f94393)) ((char? f94392) (if f94394 (write-char f94392 f94393) ((vector-ref f94344 0) f94392 f94393))) ((fixnum? f94392) ((vector-ref f94343 0) f94392 f94393)) ((string? f94392) (if f94394 ((vector-ref f94341 0) f94392 f94393) ((vector-ref f94342 0) f94392 f94393))) ((pair? f94392) ((vector-ref f94340 0) f94392 f94393)) (else (error (quote write) "unrecognized expression"))))))
# == eliminate-set!  ==>
# (let ((f94346 (make-vector 1)) (f94345 (make-vector 1)) (f94344 (make-vector 1)) (f94343 (make-vector 1)) (f94342 (make-vector 1)) (f94341 (make-vector 1)) (f94340 (make-vector 1)) (f94339 (make-vector 1))) (begin (begin (vector-set! f94346 0 (lambda (f94387 f94388) (let ((f94387 f94387) (f94388 f94388)) (begin (write-char #\# f94388) (if f94387 (write-char #\t f94388) (write-char #\f f94388)))))) (vector-set! f94345 0 (lambda (f94386) (let ((f94386 f94386)) (begin (write-char #\( f94386) (write-char #\) f94386))))) (vector-set! f94344 0 (lambda (f94384 f94385) (let ((f94384 f94384) (f94385 f94385)) (begin (write-char #\# f94385) (write-char #\\ f94385) (write-char f94384 f94385))))) (vector-set! f94343 0 (lambda (f94380 f94381) (let ((f94380 f94380) (f94381 f94381)) (if (negative? f94380) (begin (write-char #\- f94381) ((vector-ref f94343 0) (fx* -1 f94380) f94381)) (map (lambda (f94383) (let ((f94383 f94383)) (write-char (fixnum->char (fx+ (char->fixnum #\0) f94383)) f94381))) (integer->list f94380)))))) (vector-set! f94342 0 (lambda (f94376 f94377) (let ((f94376 f94376) (f94377 f94377)) (begin (write-char #\" f94377) (for-each (lambda (f94379) (let ((f94379 f94379)) (write-char f94379 f94377))) (string->list f94376)) (write-char #\" f94377))))) (vector-set! f94341 0 (lambda (f94372 f94373) (let ((f94372 f94372) (f94373 f94373)) (for-each (lambda (f94375) (let ((f94375 f94375)) (write-char f94375 f94373))) (string->list f94372))))) (vector-set! f94340 0 (lambda (f94370 f94371) (let ((f94370 f94370) (f94371 f94371)) (begin (write-char #\( f94371) ((vector-ref f94339 0) f94370 f94371) (write-char #\) f94371))))) (vector-set! f94339 0 (lambda (f94368 f94369) (let ((f94368 f94368) (f94369 f94369)) (begin (write (car f94368) f94369) (cond ((null? (cdr f94368)) #t) ((pair? (cdr f94368)) (begin (write-char #\space f94369) ((vector-ref f94339 0) (cdr f94368) f94369))) (else (begin (write-char #\space f94369) (write-char #\. f94369) (write-char #\space f94369) (write (cdr f94368) f94369))))))))) (lambda (f94392 f94393 f94394) (let ((f94392 f94392) (f94393 f94393) (f94394 f94394)) (cond ((boolean? f94392) ((vector-ref f94346 0) f94392 f94393)) ((null? f94392) ((vector-ref f94345 0) f94393)) ((char? f94392) (if f94394 (write-char f94392 f94393) ((vector-ref f94344 0) f94392 f94393))) ((fixnum? f94392) ((vector-ref f94343 0) f94392 f94393)) ((string? f94392) (if f94394 ((vector-ref f94341 0) f94392 f94393) ((vector-ref f94342 0) f94392 f94393))) ((pair? f94392) ((vector-ref f94340 0) f94392 f94393)) (else (error (quote write) "unrecognized expression")))))))
# == close-free-variables  ==>
# (let ((f94346 (make-vector 1)) (f94345 (make-vector 1)) (f94344 (make-vector 1)) (f94343 (make-vector 1)) (f94342 (make-vector 1)) (f94341 (make-vector 1)) (f94340 (make-vector 1)) (f94339 (make-vector 1))) (begin (begin (vector-set! f94346 0 (closure (f94387 f94388) () (let ((f94387 f94387) (f94388 f94388)) (begin (write-char #\# f94388) (if f94387 (write-char #\t f94388) (write-char #\f f94388)))))) (vector-set! f94345 0 (closure (f94386) () (let ((f94386 f94386)) (begin (write-char #\( f94386) (write-char #\) f94386))))) (vector-set! f94344 0 (closure (f94384 f94385) () (let ((f94384 f94384) (f94385 f94385)) (begin (write-char #\# f94385) (write-char #\\ f94385) (write-char f94384 f94385))))) (vector-set! f94343 0 (closure (f94380 f94381) (f94343) (let ((f94380 f94380) (f94381 f94381)) (if (negative? f94380) (begin (write-char #\- f94381) ((vector-ref f94343 0) (fx* -1 f94380) f94381)) (map (closure (f94383) (f94381) (let ((f94383 f94383)) (write-char (fixnum->char (fx+ (char->fixnum #\0) f94383)) f94381))) (integer->list f94380)))))) (vector-set! f94342 0 (closure (f94376 f94377) () (let ((f94376 f94376) (f94377 f94377)) (begin (write-char #\" f94377) (for-each (closure (f94379) (f94377) (let ((f94379 f94379)) (write-char f94379 f94377))) (string->list f94376)) (write-char #\" f94377))))) (vector-set! f94341 0 (closure (f94372 f94373) () (let ((f94372 f94372) (f94373 f94373)) (for-each (closure (f94375) (f94373) (let ((f94375 f94375)) (write-char f94375 f94373))) (string->list f94372))))) (vector-set! f94340 0 (closure (f94370 f94371) (f94339) (let ((f94370 f94370) (f94371 f94371)) (begin (write-char #\( f94371) ((vector-ref f94339 0) f94370 f94371) (write-char #\) f94371))))) (vector-set! f94339 0 (closure (f94368 f94369) (f94339) (let ((f94368 f94368) (f94369 f94369)) (begin (write (car f94368) f94369) (cond ((null? (cdr f94368)) #t) ((pair? (cdr f94368)) (begin (write-char #\space f94369) ((vector-ref f94339 0) (cdr f94368) f94369))) (else (begin (write-char #\space f94369) (write-char #\. f94369) (write-char #\space f94369) (write (cdr f94368) f94369))))))))) (closure (f94392 f94393 f94394) (f94346 f94345 f94344 f94343 f94341 f94342 f94340) (let ((f94392 f94392) (f94393 f94393) (f94394 f94394)) (cond ((boolean? f94392) ((vector-ref f94346 0) f94392 f94393)) ((null? f94392) ((vector-ref f94345 0) f94393)) ((char? f94392) (if f94394 (write-char f94392 f94393) ((vector-ref f94344 0) f94392 f94393))) ((fixnum? f94392) ((vector-ref f94343 0) f94392 f94393)) ((string? f94392) (if f94394 ((vector-ref f94341 0) f94392 f94393) ((vector-ref f94342 0) f94392 f94393))) ((pair? f94392) ((vector-ref f94340 0) f94392 f94393)) (else (error (quote write) "unrecognized expression")))))))
# == eliminate-quote  ==>
# (let ((f94346 (make-vector 1)) (f94345 (make-vector 1)) (f94344 (make-vector 1)) (f94343 (make-vector 1)) (f94342 (make-vector 1)) (f94341 (make-vector 1)) (f94340 (make-vector 1)) (f94339 (make-vector 1))) (begin (begin (vector-set! f94346 0 (closure (f94387 f94388) () (let ((f94387 f94387) (f94388 f94388)) (begin (write-char #\# f94388) (if f94387 (write-char #\t f94388) (write-char #\f f94388)))))) (vector-set! f94345 0 (closure (f94386) () (let ((f94386 f94386)) (begin (write-char #\( f94386) (write-char #\) f94386))))) (vector-set! f94344 0 (closure (f94384 f94385) () (let ((f94384 f94384) (f94385 f94385)) (begin (write-char #\# f94385) (write-char #\\ f94385) (write-char f94384 f94385))))) (vector-set! f94343 0 (closure (f94380 f94381) (f94343) (let ((f94380 f94380) (f94381 f94381)) (if (negative? f94380) (begin (write-char #\- f94381) ((vector-ref f94343 0) (fx* -1 f94380) f94381)) (map (closure (f94383) (f94381) (let ((f94383 f94383)) (write-char (fixnum->char (fx+ (char->fixnum #\0) f94383)) f94381))) (integer->list f94380)))))) (vector-set! f94342 0 (closure (f94376 f94377) () (let ((f94376 f94376) (f94377 f94377)) (begin (write-char #\" f94377) (for-each (closure (f94379) (f94377) (let ((f94379 f94379)) (write-char f94379 f94377))) (string->list f94376)) (write-char #\" f94377))))) (vector-set! f94341 0 (closure (f94372 f94373) () (let ((f94372 f94372) (f94373 f94373)) (for-each (closure (f94375) (f94373) (let ((f94375 f94375)) (write-char f94375 f94373))) (string->list f94372))))) (vector-set! f94340 0 (closure (f94370 f94371) (f94339) (let ((f94370 f94370) (f94371 f94371)) (begin (write-char #\( f94371) ((vector-ref f94339 0) f94370 f94371) (write-char #\) f94371))))) (vector-set! f94339 0 (closure (f94368 f94369) (f94339) (let ((f94368 f94368) (f94369 f94369)) (begin (write (car f94368) f94369) (cond ((null? (cdr f94368)) #t) ((pair? (cdr f94368)) (begin (write-char #\space f94369) ((vector-ref f94339 0) (cdr f94368) f94369))) (else (begin (write-char #\space f94369) (write-char #\. f94369) (write-char #\space f94369) (write (cdr f94368) f94369))))))))) (closure (f94392 f94393 f94394) (f94346 f94345 f94344 f94343 f94341 f94342 f94340) (let ((f94392 f94392) (f94393 f94393) (f94394 f94394)) (cond ((boolean? f94392) ((vector-ref f94346 0) f94392 f94393)) ((null? f94392) ((vector-ref f94345 0) f94393)) ((char? f94392) (if f94394 (write-char f94392 f94393) ((vector-ref f94344 0) f94392 f94393))) ((fixnum? f94392) ((vector-ref f94343 0) f94392 f94393)) ((string? f94392) (if f94394 ((vector-ref f94341 0) f94392 f94393) ((vector-ref f94342 0) f94392 f94393))) ((pair? f94392) ((vector-ref f94340 0) f94392 f94393)) (else (error (string->symbol "write") "unrecognized expression")))))))
# == eliminate-when/unless  ==>
# (let ((f94346 (make-vector 1)) (f94345 (make-vector 1)) (f94344 (make-vector 1)) (f94343 (make-vector 1)) (f94342 (make-vector 1)) (f94341 (make-vector 1)) (f94340 (make-vector 1)) (f94339 (make-vector 1))) (begin (begin (vector-set! f94346 0 (closure (f94387 f94388) () (let ((f94387 f94387) (f94388 f94388)) (begin (write-char #\# f94388) (if f94387 (write-char #\t f94388) (write-char #\f f94388)))))) (vector-set! f94345 0 (closure (f94386) () (let ((f94386 f94386)) (begin (write-char #\( f94386) (write-char #\) f94386))))) (vector-set! f94344 0 (closure (f94384 f94385) () (let ((f94384 f94384) (f94385 f94385)) (begin (write-char #\# f94385) (write-char #\\ f94385) (write-char f94384 f94385))))) (vector-set! f94343 0 (closure (f94380 f94381) (f94343) (let ((f94380 f94380) (f94381 f94381)) (if (negative? f94380) (begin (write-char #\- f94381) ((vector-ref f94343 0) (fx* -1 f94380) f94381)) (map (closure (f94383) (f94381) (let ((f94383 f94383)) (write-char (fixnum->char (fx+ (char->fixnum #\0) f94383)) f94381))) (integer->list f94380)))))) (vector-set! f94342 0 (closure (f94376 f94377) () (let ((f94376 f94376) (f94377 f94377)) (begin (write-char #\" f94377) (for-each (closure (f94379) (f94377) (let ((f94379 f94379)) (write-char f94379 f94377))) (string->list f94376)) (write-char #\" f94377))))) (vector-set! f94341 0 (closure (f94372 f94373) () (let ((f94372 f94372) (f94373 f94373)) (for-each (closure (f94375) (f94373) (let ((f94375 f94375)) (write-char f94375 f94373))) (string->list f94372))))) (vector-set! f94340 0 (closure (f94370 f94371) (f94339) (let ((f94370 f94370) (f94371 f94371)) (begin (write-char #\( f94371) ((vector-ref f94339 0) f94370 f94371) (write-char #\) f94371))))) (vector-set! f94339 0 (closure (f94368 f94369) (f94339) (let ((f94368 f94368) (f94369 f94369)) (begin (write (car f94368) f94369) (cond ((null? (cdr f94368)) #t) ((pair? (cdr f94368)) (begin (write-char #\space f94369) ((vector-ref f94339 0) (cdr f94368) f94369))) (else (begin (write-char #\space f94369) (write-char #\. f94369) (write-char #\space f94369) (write (cdr f94368) f94369))))))))) (closure (f94392 f94393 f94394) (f94346 f94345 f94344 f94343 f94341 f94342 f94340) (let ((f94392 f94392) (f94393 f94393) (f94394 f94394)) (cond ((boolean? f94392) ((vector-ref f94346 0) f94392 f94393)) ((null? f94392) ((vector-ref f94345 0) f94393)) ((char? f94392) (if f94394 (write-char f94392 f94393) ((vector-ref f94344 0) f94392 f94393))) ((fixnum? f94392) ((vector-ref f94343 0) f94392 f94393)) ((string? f94392) (if f94394 ((vector-ref f94341 0) f94392 f94393) ((vector-ref f94342 0) f94392 f94393))) ((pair? f94392) ((vector-ref f94340 0) f94392 f94393)) (else (error (string->symbol "write") "unrecognized expression")))))))
# == eliminate-cond  ==>
# (let ((f94346 (make-vector 1)) (f94345 (make-vector 1)) (f94344 (make-vector 1)) (f94343 (make-vector 1)) (f94342 (make-vector 1)) (f94341 (make-vector 1)) (f94340 (make-vector 1)) (f94339 (make-vector 1))) (begin (begin (vector-set! f94346 0 (closure (f94387 f94388) () (let ((f94387 f94387) (f94388 f94388)) (begin (write-char #\# f94388) (if f94387 (write-char #\t f94388) (write-char #\f f94388)))))) (vector-set! f94345 0 (closure (f94386) () (let ((f94386 f94386)) (begin (write-char #\( f94386) (write-char #\) f94386))))) (vector-set! f94344 0 (closure (f94384 f94385) () (let ((f94384 f94384) (f94385 f94385)) (begin (write-char #\# f94385) (write-char #\\ f94385) (write-char f94384 f94385))))) (vector-set! f94343 0 (closure (f94380 f94381) (f94343) (let ((f94380 f94380) (f94381 f94381)) (if (negative? f94380) (begin (write-char #\- f94381) ((vector-ref f94343 0) (fx* -1 f94380) f94381)) (map (closure (f94383) (f94381) (let ((f94383 f94383)) (write-char (fixnum->char (fx+ (char->fixnum #\0) f94383)) f94381))) (integer->list f94380)))))) (vector-set! f94342 0 (closure (f94376 f94377) () (let ((f94376 f94376) (f94377 f94377)) (begin (write-char #\" f94377) (for-each (closure (f94379) (f94377) (let ((f94379 f94379)) (write-char f94379 f94377))) (string->list f94376)) (write-char #\" f94377))))) (vector-set! f94341 0 (closure (f94372 f94373) () (let ((f94372 f94372) (f94373 f94373)) (for-each (closure (f94375) (f94373) (let ((f94375 f94375)) (write-char f94375 f94373))) (string->list f94372))))) (vector-set! f94340 0 (closure (f94370 f94371) (f94339) (let ((f94370 f94370) (f94371 f94371)) (begin (write-char #\( f94371) ((vector-ref f94339 0) f94370 f94371) (write-char #\) f94371))))) (vector-set! f94339 0 (closure (f94368 f94369) (f94339) (let ((f94368 f94368) (f94369 f94369)) (begin (write (car f94368) f94369) (if (null? (cdr f94368)) #t (if (pair? (cdr f94368)) (begin (write-char #\space f94369) ((vector-ref f94339 0) (cdr f94368) f94369)) (begin (write-char #\space f94369) (write-char #\. f94369) (write-char #\space f94369) (write (cdr f94368) f94369))))))))) (closure (f94392 f94393 f94394) (f94346 f94345 f94344 f94343 f94341 f94342 f94340) (let ((f94392 f94392) (f94393 f94393) (f94394 f94394)) (if (boolean? f94392) ((vector-ref f94346 0) f94392 f94393) (if (null? f94392) ((vector-ref f94345 0) f94393) (if (char? f94392) (if f94394 (write-char f94392 f94393) ((vector-ref f94344 0) f94392 f94393)) (if (fixnum? f94392) ((vector-ref f94343 0) f94392 f94393) (if (string? f94392) (if f94394 ((vector-ref f94341 0) f94392 f94393) ((vector-ref f94342 0) f94392 f94393)) (if (pair? f94392) ((vector-ref f94340 0) f94392 f94393) (error (string->symbol "write") "unrecognized expression")))))))))))
# == external-symbols  ==>
# (let ((f94346 (make-vector 1)) (f94345 (make-vector 1)) (f94344 (make-vector 1)) (f94343 (make-vector 1)) (f94342 (make-vector 1)) (f94341 (make-vector 1)) (f94340 (make-vector 1)) (f94339 (make-vector 1))) (begin (begin (vector-set! f94346 0 (closure (f94387 f94388) () (let ((f94387 f94387) (f94388 f94388)) (begin ((primitive-ref write-char) #\# f94388) (if f94387 ((primitive-ref write-char) #\t f94388) ((primitive-ref write-char) #\f f94388)))))) (vector-set! f94345 0 (closure (f94386) () (let ((f94386 f94386)) (begin ((primitive-ref write-char) #\( f94386) ((primitive-ref write-char) #\) f94386))))) (vector-set! f94344 0 (closure (f94384 f94385) () (let ((f94384 f94384) (f94385 f94385)) (begin ((primitive-ref write-char) #\# f94385) ((primitive-ref write-char) #\\ f94385) ((primitive-ref write-char) f94384 f94385))))) (vector-set! f94343 0 (closure (f94380 f94381) (f94343) (let ((f94380 f94380) (f94381 f94381)) (if ((primitive-ref negative?) f94380) (begin ((primitive-ref write-char) #\- f94381) ((vector-ref f94343 0) (fx* -1 f94380) f94381)) ((primitive-ref map) (closure (f94383) (f94381) (let ((f94383 f94383)) ((primitive-ref write-char) (fixnum->char (fx+ (char->fixnum #\0) f94383)) f94381))) ((primitive-ref integer->list) f94380)))))) (vector-set! f94342 0 (closure (f94376 f94377) () (let ((f94376 f94376) (f94377 f94377)) (begin ((primitive-ref write-char) #\" f94377) ((primitive-ref for-each) (closure (f94379) (f94377) (let ((f94379 f94379)) ((primitive-ref write-char) f94379 f94377))) ((primitive-ref string->list) f94376)) ((primitive-ref write-char) #\" f94377))))) (vector-set! f94341 0 (closure (f94372 f94373) () (let ((f94372 f94372) (f94373 f94373)) ((primitive-ref for-each) (closure (f94375) (f94373) (let ((f94375 f94375)) ((primitive-ref write-char) f94375 f94373))) ((primitive-ref string->list) f94372))))) (vector-set! f94340 0 (closure (f94370 f94371) (f94339) (let ((f94370 f94370) (f94371 f94371)) (begin ((primitive-ref write-char) #\( f94371) ((vector-ref f94339 0) f94370 f94371) ((primitive-ref write-char) #\) f94371))))) (vector-set! f94339 0 (closure (f94368 f94369) (f94339) (let ((f94368 f94368) (f94369 f94369)) (begin ((primitive-ref write) (car f94368) f94369) (if (null? (cdr f94368)) #t (if (pair? (cdr f94368)) (begin ((primitive-ref write-char) #\space f94369) ((vector-ref f94339 0) (cdr f94368) f94369)) (begin ((primitive-ref write-char) #\space f94369) ((primitive-ref write-char) #\. f94369) ((primitive-ref write-char) #\space f94369) ((primitive-ref write) (cdr f94368) f94369))))))))) (closure (f94392 f94393 f94394) (f94346 f94345 f94344 f94343 f94341 f94342 f94340) (let ((f94392 f94392) (f94393 f94393) (f94394 f94394)) (if (boolean? f94392) ((vector-ref f94346 0) f94392 f94393) (if (null? f94392) ((vector-ref f94345 0) f94393) (if (char? f94392) (if f94394 ((primitive-ref write-char) f94392 f94393) ((vector-ref f94344 0) f94392 f94393)) (if (fixnum? f94392) ((vector-ref f94343 0) f94392 f94393) (if (string? f94392) (if f94394 ((vector-ref f94341 0) f94392 f94393) ((vector-ref f94342 0) f94392 f94393)) (if (pair? f94392) ((vector-ref f94340 0) f94392 f94393) ((primitive-ref error) ((primitive-ref string->symbol) "write") "unrecognized expression")))))))))))
# emit-expr (let ((f94346 (make-vector 1)) (f94345 (make-vector 1)) (f94344 (make-vector 1)) (f94343 (make-vector 1)) (f94342 (make-vector 1)) (f94341 (make-vector 1)) (f94340 (make-vector 1)) (f94339 (make-vector 1))) (begin (begin (vector-set! f94346 0 (closure (f94387 f94388) () (let ((f94387 f94387) (f94388 f94388)) (begin ((primitive-ref write-char) #\# f94388) (if f94387 ((primitive-ref write-char) #\t f94388) ((primitive-ref write-char) #\f f94388)))))) (vector-set! f94345 0 (closure (f94386) () (let ((f94386 f94386)) (begin ((primitive-ref write-char) #\( f94386) ((primitive-ref write-char) #\) f94386))))) (vector-set! f94344 0 (closure (f94384 f94385) () (let ((f94384 f94384) (f94385 f94385)) (begin ((primitive-ref write-char) #\# f94385) ((primitive-ref write-char) #\\ f94385) ((primitive-ref write-char) f94384 f94385))))) (vector-set! f94343 0 (closure (f94380 f94381) (f94343) (let ((f94380 f94380) (f94381 f94381)) (if ((primitive-ref negative?) f94380) (begin ((primitive-ref write-char) #\- f94381) ((vector-ref f94343 0) (fx* -1 f94380) f94381)) ((primitive-ref map) (closure (f94383) (f94381) (let ((f94383 f94383)) ((primitive-ref write-char) (fixnum->char (fx+ (char->fixnum #\0) f94383)) f94381))) ((primitive-ref integer->list) f94380)))))) (vector-set! f94342 0 (closure (f94376 f94377) () (let ((f94376 f94376) (f94377 f94377)) (begin ((primitive-ref write-char) #\" f94377) ((primitive-ref for-each) (closure (f94379) (f94377) (let ((f94379 f94379)) ((primitive-ref write-char) f94379 f94377))) ((primitive-ref string->list) f94376)) ((primitive-ref write-char) #\" f94377))))) (vector-set! f94341 0 (closure (f94372 f94373) () (let ((f94372 f94372) (f94373 f94373)) ((primitive-ref for-each) (closure (f94375) (f94373) (let ((f94375 f94375)) ((primitive-ref write-char) f94375 f94373))) ((primitive-ref string->list) f94372))))) (vector-set! f94340 0 (closure (f94370 f94371) (f94339) (let ((f94370 f94370) (f94371 f94371)) (begin ((primitive-ref write-char) #\( f94371) ((vector-ref f94339 0) f94370 f94371) ((primitive-ref write-char) #\) f94371))))) (vector-set! f94339 0 (closure (f94368 f94369) (f94339) (let ((f94368 f94368) (f94369 f94369)) (begin ((primitive-ref write) (car f94368) f94369) (if (null? (cdr f94368)) #t (if (pair? (cdr f94368)) (begin ((primitive-ref write-char) #\space f94369) ((vector-ref f94339 0) (cdr f94368) f94369)) (begin ((primitive-ref write-char) #\space f94369) ((primitive-ref write-char) #\. f94369) ((primitive-ref write-char) #\space f94369) ((primitive-ref write) (cdr f94368) f94369))))))))) (closure (f94392 f94393 f94394) (f94346 f94345 f94344 f94343 f94341 f94342 f94340) (let ((f94392 f94392) (f94393 f94393) (f94394 f94394)) (if (boolean? f94392) ((vector-ref f94346 0) f94392 f94393) (if (null? f94392) ((vector-ref f94345 0) f94393) (if (char? f94392) (if f94394 ((primitive-ref write-char) f94392 f94393) ((vector-ref f94344 0) f94392 f94393)) (if (fixnum? f94392) ((vector-ref f94343 0) f94392 f94393) (if (string? f94392) (if f94394 ((vector-ref f94341 0) f94392 f94393) ((vector-ref f94342 0) f94392 f94393)) (if (pair? f94392) ((vector-ref f94340 0) f94392 f94393) ((primitive-ref error) ((primitive-ref string->symbol) "write") "unrecognized expression")))))))))))
# emit-let
#  si   = 0
#  env  = ()
#  bindings = ((f94346 (make-vector 1)) (f94345 (make-vector 1)) (f94344 (make-vector 1)) (f94343 (make-vector 1)) (f94342 (make-vector 1)) (f94341 (make-vector 1)) (f94340 (make-vector 1)) (f94339 (make-vector 1)))
#  body = (begin (begin (vector-set! f94346 0 (closure (f94387 f94388) () (let ((f94387 f94387) (f94388 f94388)) (begin ((primitive-ref write-char) #\# f94388) (if f94387 ((primitive-ref write-char) #\t f94388) ((primitive-ref write-char) #\f f94388)))))) (vector-set! f94345 0 (closure (f94386) () (let ((f94386 f94386)) (begin ((primitive-ref write-char) #\( f94386) ((primitive-ref write-char) #\) f94386))))) (vector-set! f94344 0 (closure (f94384 f94385) () (let ((f94384 f94384) (f94385 f94385)) (begin ((primitive-ref write-char) #\# f94385) ((primitive-ref write-char) #\\ f94385) ((primitive-ref write-char) f94384 f94385))))) (vector-set! f94343 0 (closure (f94380 f94381) (f94343) (let ((f94380 f94380) (f94381 f94381)) (if ((primitive-ref negative?) f94380) (begin ((primitive-ref write-char) #\- f94381) ((vector-ref f94343 0) (fx* -1 f94380) f94381)) ((primitive-ref map) (closure (f94383) (f94381) (let ((f94383 f94383)) ((primitive-ref write-char) (fixnum->char (fx+ (char->fixnum #\0) f94383)) f94381))) ((primitive-ref integer->list) f94380)))))) (vector-set! f94342 0 (closure (f94376 f94377) () (let ((f94376 f94376) (f94377 f94377)) (begin ((primitive-ref write-char) #\" f94377) ((primitive-ref for-each) (closure (f94379) (f94377) (let ((f94379 f94379)) ((primitive-ref write-char) f94379 f94377))) ((primitive-ref string->list) f94376)) ((primitive-ref write-char) #\" f94377))))) (vector-set! f94341 0 (closure (f94372 f94373) () (let ((f94372 f94372) (f94373 f94373)) ((primitive-ref for-each) (closure (f94375) (f94373) (let ((f94375 f94375)) ((primitive-ref write-char) f94375 f94373))) ((primitive-ref string->list) f94372))))) (vector-set! f94340 0 (closure (f94370 f94371) (f94339) (let ((f94370 f94370) (f94371 f94371)) (begin ((primitive-ref write-char) #\( f94371) ((vector-ref f94339 0) f94370 f94371) ((primitive-ref write-char) #\) f94371))))) (vector-set! f94339 0 (closure (f94368 f94369) (f94339) (let ((f94368 f94368) (f94369 f94369)) (begin ((primitive-ref write) (car f94368) f94369) (if (null? (cdr f94368)) #t (if (pair? (cdr f94368)) (begin ((primitive-ref write-char) #\space f94369) ((vector-ref f94339 0) (cdr f94368) f94369)) (begin ((primitive-ref write-char) #\space f94369) ((primitive-ref write-char) #\. f94369) ((primitive-ref write-char) #\space f94369) ((primitive-ref write) (cdr f94368) f94369))))))))) (closure (f94392 f94393 f94394) (f94346 f94345 f94344 f94343 f94341 f94342 f94340) (let ((f94392 f94392) (f94393 f94393) (f94394 f94394)) (if (boolean? f94392) ((vector-ref f94346 0) f94392 f94393) (if (null? f94392) ((vector-ref f94345 0) f94393) (if (char? f94392) (if f94394 ((primitive-ref write-char) f94392 f94393) ((vector-ref f94344 0) f94392 f94393)) (if (fixnum? f94392) ((vector-ref f94343 0) f94392 f94393) (if (string? f94392) (if f94394 ((vector-ref f94341 0) f94392 f94393) ((vector-ref f94342 0) f94392 f94393)) (if (pair? f94392) ((vector-ref f94340 0) f94392 f94393) ((primitive-ref error) ((primitive-ref string->symbol) "write") "unrecognized expression"))))))))))
# emit-expr (make-vector 1)
# make-vector 1
# emit-expr 1
    movl $4, %eax     # immed 1
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_571664"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_571664:
# check the argument is a fixnum >= 0
    cmp $0,%eax
    jge _L_571665
# invoke error handler eh_length
    .extern mrc_eh$ulength
    movl mrc_eh$ulength, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_571665:
    movl %eax, %esi
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    orl  $5, %eax
    addl $4, %esi
    addl $4, %esi
    andl $-8, %esi
    addl %esi, %ebp
    movl %eax, 0(%esp)  # stack save
# emit-expr (make-vector 1)
# make-vector 1
# emit-expr 1
    movl $4, %eax     # immed 1
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_571666"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_571666:
# check the argument is a fixnum >= 0
    cmp $0,%eax
    jge _L_571667
# invoke error handler eh_length
    .extern mrc_eh$ulength
    movl mrc_eh$ulength, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_571667:
    movl %eax, %esi
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    orl  $5, %eax
    addl $4, %esi
    addl $4, %esi
    andl $-8, %esi
    addl %esi, %ebp
    movl %eax, -4(%esp)  # stack save
# emit-expr (make-vector 1)
# make-vector 1
# emit-expr 1
    movl $4, %eax     # immed 1
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_571668"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_571668:
# check the argument is a fixnum >= 0
    cmp $0,%eax
    jge _L_571669
# invoke error handler eh_length
    .extern mrc_eh$ulength
    movl mrc_eh$ulength, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_571669:
    movl %eax, %esi
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    orl  $5, %eax
    addl $4, %esi
    addl $4, %esi
    andl $-8, %esi
    addl %esi, %ebp
    movl %eax, -8(%esp)  # stack save
# emit-expr (make-vector 1)
# make-vector 1
# emit-expr 1
    movl $4, %eax     # immed 1
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_571670"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_571670:
# check the argument is a fixnum >= 0
    cmp $0,%eax
    jge _L_571671
# invoke error handler eh_length
    .extern mrc_eh$ulength
    movl mrc_eh$ulength, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_571671:
    movl %eax, %esi
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    orl  $5, %eax
    addl $4, %esi
    addl $4, %esi
    andl $-8, %esi
    addl %esi, %ebp
    movl %eax, -12(%esp)  # stack save
# emit-expr (make-vector 1)
# make-vector 1
# emit-expr 1
    movl $4, %eax     # immed 1
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_571672"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_571672:
# check the argument is a fixnum >= 0
    cmp $0,%eax
    jge _L_571673
# invoke error handler eh_length
    .extern mrc_eh$ulength
    movl mrc_eh$ulength, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_571673:
    movl %eax, %esi
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    orl  $5, %eax
    addl $4, %esi
    addl $4, %esi
    andl $-8, %esi
    addl %esi, %ebp
    movl %eax, -16(%esp)  # stack save
# emit-expr (make-vector 1)
# make-vector 1
# emit-expr 1
    movl $4, %eax     # immed 1
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_571674"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_571674:
# check the argument is a fixnum >= 0
    cmp $0,%eax
    jge _L_571675
# invoke error handler eh_length
    .extern mrc_eh$ulength
    movl mrc_eh$ulength, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_571675:
    movl %eax, %esi
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    orl  $5, %eax
    addl $4, %esi
    addl $4, %esi
    andl $-8, %esi
    addl %esi, %ebp
    movl %eax, -20(%esp)  # stack save
# emit-expr (make-vector 1)
# make-vector 1
# emit-expr 1
    movl $4, %eax     # immed 1
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_571676"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_571676:
# check the argument is a fixnum >= 0
    cmp $0,%eax
    jge _L_571677
# invoke error handler eh_length
    .extern mrc_eh$ulength
    movl mrc_eh$ulength, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_571677:
    movl %eax, %esi
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    orl  $5, %eax
    addl $4, %esi
    addl $4, %esi
    andl $-8, %esi
    addl %esi, %ebp
    movl %eax, -24(%esp)  # stack save
# emit-expr (make-vector 1)
# make-vector 1
# emit-expr 1
    movl $4, %eax     # immed 1
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_571678"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_571678:
# check the argument is a fixnum >= 0
    cmp $0,%eax
    jge _L_571679
# invoke error handler eh_length
    .extern mrc_eh$ulength
    movl mrc_eh$ulength, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_571679:
    movl %eax, %esi
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    orl  $5, %eax
    addl $4, %esi
    addl $4, %esi
    andl $-8, %esi
    addl %esi, %ebp
    movl %eax, -28(%esp)  # stack save
# emit-expr (begin (begin (vector-set! f94346 0 (closure (f94387 f94388) () (let ((f94387 f94387) (f94388 f94388)) (begin ((primitive-ref write-char) #\# f94388) (if f94387 ((primitive-ref write-char) #\t f94388) ((primitive-ref write-char) #\f f94388)))))) (vector-set! f94345 0 (closure (f94386) () (let ((f94386 f94386)) (begin ((primitive-ref write-char) #\( f94386) ((primitive-ref write-char) #\) f94386))))) (vector-set! f94344 0 (closure (f94384 f94385) () (let ((f94384 f94384) (f94385 f94385)) (begin ((primitive-ref write-char) #\# f94385) ((primitive-ref write-char) #\\ f94385) ((primitive-ref write-char) f94384 f94385))))) (vector-set! f94343 0 (closure (f94380 f94381) (f94343) (let ((f94380 f94380) (f94381 f94381)) (if ((primitive-ref negative?) f94380) (begin ((primitive-ref write-char) #\- f94381) ((vector-ref f94343 0) (fx* -1 f94380) f94381)) ((primitive-ref map) (closure (f94383) (f94381) (let ((f94383 f94383)) ((primitive-ref write-char) (fixnum->char (fx+ (char->fixnum #\0) f94383)) f94381))) ((primitive-ref integer->list) f94380)))))) (vector-set! f94342 0 (closure (f94376 f94377) () (let ((f94376 f94376) (f94377 f94377)) (begin ((primitive-ref write-char) #\" f94377) ((primitive-ref for-each) (closure (f94379) (f94377) (let ((f94379 f94379)) ((primitive-ref write-char) f94379 f94377))) ((primitive-ref string->list) f94376)) ((primitive-ref write-char) #\" f94377))))) (vector-set! f94341 0 (closure (f94372 f94373) () (let ((f94372 f94372) (f94373 f94373)) ((primitive-ref for-each) (closure (f94375) (f94373) (let ((f94375 f94375)) ((primitive-ref write-char) f94375 f94373))) ((primitive-ref string->list) f94372))))) (vector-set! f94340 0 (closure (f94370 f94371) (f94339) (let ((f94370 f94370) (f94371 f94371)) (begin ((primitive-ref write-char) #\( f94371) ((vector-ref f94339 0) f94370 f94371) ((primitive-ref write-char) #\) f94371))))) (vector-set! f94339 0 (closure (f94368 f94369) (f94339) (let ((f94368 f94368) (f94369 f94369)) (begin ((primitive-ref write) (car f94368) f94369) (if (null? (cdr f94368)) #t (if (pair? (cdr f94368)) (begin ((primitive-ref write-char) #\space f94369) ((vector-ref f94339 0) (cdr f94368) f94369)) (begin ((primitive-ref write-char) #\space f94369) ((primitive-ref write-char) #\. f94369) ((primitive-ref write-char) #\space f94369) ((primitive-ref write) (cdr f94368) f94369))))))))) (closure (f94392 f94393 f94394) (f94346 f94345 f94344 f94343 f94341 f94342 f94340) (let ((f94392 f94392) (f94393 f94393) (f94394 f94394)) (if (boolean? f94392) ((vector-ref f94346 0) f94392 f94393) (if (null? f94392) ((vector-ref f94345 0) f94393) (if (char? f94392) (if f94394 ((primitive-ref write-char) f94392 f94393) ((vector-ref f94344 0) f94392 f94393)) (if (fixnum? f94392) ((vector-ref f94343 0) f94392 f94393) (if (string? f94392) (if f94394 ((vector-ref f94341 0) f94392 f94393) ((vector-ref f94342 0) f94392 f94393)) (if (pair? f94392) ((vector-ref f94340 0) f94392 f94393) ((primitive-ref error) ((primitive-ref string->symbol) "write") "unrecognized expression"))))))))))
# emit-begin
#   expr=(begin (begin (vector-set! f94346 0 (closure (f94387 f94388) () (let ((f94387 f94387) (f94388 f94388)) (begin ((primitive-ref write-char) #\# f94388) (if f94387 ((primitive-ref write-char) #\t f94388) ((primitive-ref write-char) #\f f94388)))))) (vector-set! f94345 0 (closure (f94386) () (let ((f94386 f94386)) (begin ((primitive-ref write-char) #\( f94386) ((primitive-ref write-char) #\) f94386))))) (vector-set! f94344 0 (closure (f94384 f94385) () (let ((f94384 f94384) (f94385 f94385)) (begin ((primitive-ref write-char) #\# f94385) ((primitive-ref write-char) #\\ f94385) ((primitive-ref write-char) f94384 f94385))))) (vector-set! f94343 0 (closure (f94380 f94381) (f94343) (let ((f94380 f94380) (f94381 f94381)) (if ((primitive-ref negative?) f94380) (begin ((primitive-ref write-char) #\- f94381) ((vector-ref f94343 0) (fx* -1 f94380) f94381)) ((primitive-ref map) (closure (f94383) (f94381) (let ((f94383 f94383)) ((primitive-ref write-char) (fixnum->char (fx+ (char->fixnum #\0) f94383)) f94381))) ((primitive-ref integer->list) f94380)))))) (vector-set! f94342 0 (closure (f94376 f94377) () (let ((f94376 f94376) (f94377 f94377)) (begin ((primitive-ref write-char) #\" f94377) ((primitive-ref for-each) (closure (f94379) (f94377) (let ((f94379 f94379)) ((primitive-ref write-char) f94379 f94377))) ((primitive-ref string->list) f94376)) ((primitive-ref write-char) #\" f94377))))) (vector-set! f94341 0 (closure (f94372 f94373) () (let ((f94372 f94372) (f94373 f94373)) ((primitive-ref for-each) (closure (f94375) (f94373) (let ((f94375 f94375)) ((primitive-ref write-char) f94375 f94373))) ((primitive-ref string->list) f94372))))) (vector-set! f94340 0 (closure (f94370 f94371) (f94339) (let ((f94370 f94370) (f94371 f94371)) (begin ((primitive-ref write-char) #\( f94371) ((vector-ref f94339 0) f94370 f94371) ((primitive-ref write-char) #\) f94371))))) (vector-set! f94339 0 (closure (f94368 f94369) (f94339) (let ((f94368 f94368) (f94369 f94369)) (begin ((primitive-ref write) (car f94368) f94369) (if (null? (cdr f94368)) #t (if (pair? (cdr f94368)) (begin ((primitive-ref write-char) #\space f94369) ((vector-ref f94339 0) (cdr f94368) f94369)) (begin ((primitive-ref write-char) #\space f94369) ((primitive-ref write-char) #\. f94369) ((primitive-ref write-char) #\space f94369) ((primitive-ref write) (cdr f94368) f94369))))))))) (closure (f94392 f94393 f94394) (f94346 f94345 f94344 f94343 f94341 f94342 f94340) (let ((f94392 f94392) (f94393 f94393) (f94394 f94394)) (if (boolean? f94392) ((vector-ref f94346 0) f94392 f94393) (if (null? f94392) ((vector-ref f94345 0) f94393) (if (char? f94392) (if f94394 ((primitive-ref write-char) f94392 f94393) ((vector-ref f94344 0) f94392 f94393)) (if (fixnum? f94392) ((vector-ref f94343 0) f94392 f94393) (if (string? f94392) (if f94394 ((vector-ref f94341 0) f94392 f94393) ((vector-ref f94342 0) f94392 f94393)) (if (pair? f94392) ((vector-ref f94340 0) f94392 f94393) ((primitive-ref error) ((primitive-ref string->symbol) "write") "unrecognized expression"))))))))))
#   env=((f94339 . -28) (f94340 . -24) (f94341 . -20) (f94342 . -16) (f94343 . -12) (f94344 . -8) (f94345 . -4) (f94346 . 0))
# emit-expr (begin (vector-set! f94346 0 (closure (f94387 f94388) () (let ((f94387 f94387) (f94388 f94388)) (begin ((primitive-ref write-char) #\# f94388) (if f94387 ((primitive-ref write-char) #\t f94388) ((primitive-ref write-char) #\f f94388)))))) (vector-set! f94345 0 (closure (f94386) () (let ((f94386 f94386)) (begin ((primitive-ref write-char) #\( f94386) ((primitive-ref write-char) #\) f94386))))) (vector-set! f94344 0 (closure (f94384 f94385) () (let ((f94384 f94384) (f94385 f94385)) (begin ((primitive-ref write-char) #\# f94385) ((primitive-ref write-char) #\\ f94385) ((primitive-ref write-char) f94384 f94385))))) (vector-set! f94343 0 (closure (f94380 f94381) (f94343) (let ((f94380 f94380) (f94381 f94381)) (if ((primitive-ref negative?) f94380) (begin ((primitive-ref write-char) #\- f94381) ((vector-ref f94343 0) (fx* -1 f94380) f94381)) ((primitive-ref map) (closure (f94383) (f94381) (let ((f94383 f94383)) ((primitive-ref write-char) (fixnum->char (fx+ (char->fixnum #\0) f94383)) f94381))) ((primitive-ref integer->list) f94380)))))) (vector-set! f94342 0 (closure (f94376 f94377) () (let ((f94376 f94376) (f94377 f94377)) (begin ((primitive-ref write-char) #\" f94377) ((primitive-ref for-each) (closure (f94379) (f94377) (let ((f94379 f94379)) ((primitive-ref write-char) f94379 f94377))) ((primitive-ref string->list) f94376)) ((primitive-ref write-char) #\" f94377))))) (vector-set! f94341 0 (closure (f94372 f94373) () (let ((f94372 f94372) (f94373 f94373)) ((primitive-ref for-each) (closure (f94375) (f94373) (let ((f94375 f94375)) ((primitive-ref write-char) f94375 f94373))) ((primitive-ref string->list) f94372))))) (vector-set! f94340 0 (closure (f94370 f94371) (f94339) (let ((f94370 f94370) (f94371 f94371)) (begin ((primitive-ref write-char) #\( f94371) ((vector-ref f94339 0) f94370 f94371) ((primitive-ref write-char) #\) f94371))))) (vector-set! f94339 0 (closure (f94368 f94369) (f94339) (let ((f94368 f94368) (f94369 f94369)) (begin ((primitive-ref write) (car f94368) f94369) (if (null? (cdr f94368)) #t (if (pair? (cdr f94368)) (begin ((primitive-ref write-char) #\space f94369) ((vector-ref f94339 0) (cdr f94368) f94369)) (begin ((primitive-ref write-char) #\space f94369) ((primitive-ref write-char) #\. f94369) ((primitive-ref write-char) #\space f94369) ((primitive-ref write) (cdr f94368) f94369)))))))))
# emit-begin
#   expr=(begin (vector-set! f94346 0 (closure (f94387 f94388) () (let ((f94387 f94387) (f94388 f94388)) (begin ((primitive-ref write-char) #\# f94388) (if f94387 ((primitive-ref write-char) #\t f94388) ((primitive-ref write-char) #\f f94388)))))) (vector-set! f94345 0 (closure (f94386) () (let ((f94386 f94386)) (begin ((primitive-ref write-char) #\( f94386) ((primitive-ref write-char) #\) f94386))))) (vector-set! f94344 0 (closure (f94384 f94385) () (let ((f94384 f94384) (f94385 f94385)) (begin ((primitive-ref write-char) #\# f94385) ((primitive-ref write-char) #\\ f94385) ((primitive-ref write-char) f94384 f94385))))) (vector-set! f94343 0 (closure (f94380 f94381) (f94343) (let ((f94380 f94380) (f94381 f94381)) (if ((primitive-ref negative?) f94380) (begin ((primitive-ref write-char) #\- f94381) ((vector-ref f94343 0) (fx* -1 f94380) f94381)) ((primitive-ref map) (closure (f94383) (f94381) (let ((f94383 f94383)) ((primitive-ref write-char) (fixnum->char (fx+ (char->fixnum #\0) f94383)) f94381))) ((primitive-ref integer->list) f94380)))))) (vector-set! f94342 0 (closure (f94376 f94377) () (let ((f94376 f94376) (f94377 f94377)) (begin ((primitive-ref write-char) #\" f94377) ((primitive-ref for-each) (closure (f94379) (f94377) (let ((f94379 f94379)) ((primitive-ref write-char) f94379 f94377))) ((primitive-ref string->list) f94376)) ((primitive-ref write-char) #\" f94377))))) (vector-set! f94341 0 (closure (f94372 f94373) () (let ((f94372 f94372) (f94373 f94373)) ((primitive-ref for-each) (closure (f94375) (f94373) (let ((f94375 f94375)) ((primitive-ref write-char) f94375 f94373))) ((primitive-ref string->list) f94372))))) (vector-set! f94340 0 (closure (f94370 f94371) (f94339) (let ((f94370 f94370) (f94371 f94371)) (begin ((primitive-ref write-char) #\( f94371) ((vector-ref f94339 0) f94370 f94371) ((primitive-ref write-char) #\) f94371))))) (vector-set! f94339 0 (closure (f94368 f94369) (f94339) (let ((f94368 f94368) (f94369 f94369)) (begin ((primitive-ref write) (car f94368) f94369) (if (null? (cdr f94368)) #t (if (pair? (cdr f94368)) (begin ((primitive-ref write-char) #\space f94369) ((vector-ref f94339 0) (cdr f94368) f94369)) (begin ((primitive-ref write-char) #\space f94369) ((primitive-ref write-char) #\. f94369) ((primitive-ref write-char) #\space f94369) ((primitive-ref write) (cdr f94368) f94369)))))))))
#   env=((f94339 . -28) (f94340 . -24) (f94341 . -20) (f94342 . -16) (f94343 . -12) (f94344 . -8) (f94345 . -4) (f94346 . 0))
# emit-expr (vector-set! f94346 0 (closure (f94387 f94388) () (let ((f94387 f94387) (f94388 f94388)) (begin ((primitive-ref write-char) #\# f94388) (if f94387 ((primitive-ref write-char) #\t f94388) ((primitive-ref write-char) #\f f94388))))))
# emit-expr f94346
# emit-variable-ref
# env=((f94339 . -28) (f94340 . -24) (f94341 . -20) (f94342 . -16) (f94343 . -12) (f94344 . -8) (f94345 . -4) (f94346 . 0))
# var=f94346
    movl 0(%esp), %eax  # stack load f94346
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_571680
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_571680:
    movl %eax, -32(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_571681"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_571681:
# check bounds on vector index
    movl -32(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_571683
    cmp  $0,%eax
    jge _L_571682
_L_571683:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_571682:
    movl %eax, -36(%esp)
# emit-expr (closure (f94387 f94388) () (let ((f94387 f94387) (f94388 f94388)) (begin ((primitive-ref write-char) #\# f94388) (if f94387 ((primitive-ref write-char) #\t f94388) ((primitive-ref write-char) #\f f94388)))))
# emit-closure
# si = -40
# env = ((f94339 . -28) (f94340 . -24) (f94341 . -20) (f94342 . -16) (f94343 . -12) (f94344 . -8) (f94345 . -4) (f94346 . 0))
# expr = (closure (f94387 f94388) () (let ((f94387 f94387) (f94388 f94388)) (begin ((primitive-ref write-char) #\# f94388) (if f94387 ((primitive-ref write-char) #\t f94388) ((primitive-ref write-char) #\f f94388)))))
    movl $_L_571684, 0(%ebp)  # closure label
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $8, %ebp     # bump ebp
    jmp _L_571685            # jump around closure body
_L_571684:
# check argument count
    cmp $8,%eax
    je _L_571686
# invoke error handler eh_argcount
    .extern mrc_eh$uargcount
    movl mrc_eh$uargcount, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_571686:
# emit-tail-expr
# si=-16
# env=((f94388 . -12) (f94387 . -8) (f94339 . -28) (f94340 . -24) (f94341 . -20) (f94342 . -16) (f94343 . -12) (f94344 . -8) (f94345 . -4) (f94346 . 0))
# expr=(let ((f94387 f94387) (f94388 f94388)) (begin ((primitive-ref write-char) #\# f94388) (if f94387 ((primitive-ref write-char) #\t f94388) ((primitive-ref write-char) #\f f94388))))
# emit-tail-let
#  si   = -16
#  env  = ((f94388 . -12) (f94387 . -8) (f94339 . -28) (f94340 . -24) (f94341 . -20) (f94342 . -16) (f94343 . -12) (f94344 . -8) (f94345 . -4) (f94346 . 0))
#  bindings = ((f94387 f94387) (f94388 f94388))
#  body = (begin ((primitive-ref write-char) #\# f94388) (if f94387 ((primitive-ref write-char) #\t f94388) ((primitive-ref write-char) #\f f94388)))
# emit-expr f94387
# emit-variable-ref
# env=((f94388 . -12) (f94387 . -8) (f94339 . -28) (f94340 . -24) (f94341 . -20) (f94342 . -16) (f94343 . -12) (f94344 . -8) (f94345 . -4) (f94346 . 0))
# var=f94387
    movl -8(%esp), %eax  # stack load f94387
# end emit-variable-ref
    movl %eax, -16(%esp)  # stack save
# emit-expr f94388
# emit-variable-ref
# env=((f94388 . -12) (f94387 . -8) (f94339 . -28) (f94340 . -24) (f94341 . -20) (f94342 . -16) (f94343 . -12) (f94344 . -8) (f94345 . -4) (f94346 . 0))
# var=f94388
    movl -12(%esp), %eax  # stack load f94388
# end emit-variable-ref
    movl %eax, -20(%esp)  # stack save
# emit-tail-expr
# si=-24
# env=((f94388 . -20) (f94387 . -16) (f94388 . -12) (f94387 . -8) (f94339 . -28) (f94340 . -24) (f94341 . -20) (f94342 . -16) (f94343 . -12) (f94344 . -8) (f94345 . -4) (f94346 . 0))
# expr=(begin ((primitive-ref write-char) #\# f94388) (if f94387 ((primitive-ref write-char) #\t f94388) ((primitive-ref write-char) #\f f94388)))
# tail-begin (begin ((primitive-ref write-char) #\# f94388) (if f94387 ((primitive-ref write-char) #\t f94388) ((primitive-ref write-char) #\f f94388)))
#   env=((f94388 . -20) (f94387 . -16) (f94388 . -12) (f94387 . -8) (f94339 . -28) (f94340 . -24) (f94341 . -20) (f94342 . -16) (f94343 . -12) (f94344 . -8) (f94345 . -4) (f94346 . 0))
# emit-expr ((primitive-ref write-char) #\# f94388)
# funcall
#    si   =-24
#    env  = ((f94388 . -20) (f94387 . -16) (f94388 . -12) (f94387 . -8) (f94339 . -28) (f94340 . -24) (f94341 . -20) (f94342 . -16) (f94343 . -12) (f94344 . -8) (f94345 . -4) (f94346 . 0))
#    expr = (funcall (primitive-ref write-char) #\# f94388)
# emit-expr (primitive-ref write-char)
    .extern mrc_write$mchar
    movl mrc_write$mchar,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_571687"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_571687":
   movl %eax,  -32(%esp)  # stash funcall-oper in closure slot
# emit-expr #\#
    movl $8975, %eax     # immed #\#
    mov %eax, -36(%esp)  # arg #
# emit-expr f94388
# emit-variable-ref
# env=((f94388 . -20) (f94387 . -16) (f94388 . -12) (f94387 . -8) (f94339 . -28) (f94340 . -24) (f94341 . -20) (f94342 . -16) (f94343 . -12) (f94344 . -8) (f94345 . -4) (f94346 . 0))
# var=f94388
    movl -20(%esp), %eax  # stack load f94388
# end emit-variable-ref
    mov %eax, -40(%esp)  # arg f94388
    movl -32(%esp), %edi   # load new closure to %edi
    add $-24, %esp   # adjust base
    movl $8,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $24, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
# emit-tail-expr
# si=-24
# env=((f94388 . -20) (f94387 . -16) (f94388 . -12) (f94387 . -8) (f94339 . -28) (f94340 . -24) (f94341 . -20) (f94342 . -16) (f94343 . -12) (f94344 . -8) (f94345 . -4) (f94346 . 0))
# expr=(begin (if f94387 ((primitive-ref write-char) #\t f94388) ((primitive-ref write-char) #\f f94388)))
# tail-begin (begin (if f94387 ((primitive-ref write-char) #\t f94388) ((primitive-ref write-char) #\f f94388)))
#   env=((f94388 . -20) (f94387 . -16) (f94388 . -12) (f94387 . -8) (f94339 . -28) (f94340 . -24) (f94341 . -20) (f94342 . -16) (f94343 . -12) (f94344 . -8) (f94345 . -4) (f94346 . 0))
# emit-tail-expr
# si=-24
# env=((f94388 . -20) (f94387 . -16) (f94388 . -12) (f94387 . -8) (f94339 . -28) (f94340 . -24) (f94341 . -20) (f94342 . -16) (f94343 . -12) (f94344 . -8) (f94345 . -4) (f94346 . 0))
# expr=(if f94387 ((primitive-ref write-char) #\t f94388) ((primitive-ref write-char) #\f f94388))
# emit-expr f94387
# emit-variable-ref
# env=((f94388 . -20) (f94387 . -16) (f94388 . -12) (f94387 . -8) (f94339 . -28) (f94340 . -24) (f94341 . -20) (f94342 . -16) (f94343 . -12) (f94344 . -8) (f94345 . -4) (f94346 . 0))
# var=f94387
    movl -16(%esp), %eax  # stack load f94387
# end emit-variable-ref
    cmp $47, %al
    je _L_571688
# emit-tail-expr
# si=-24
# env=((f94388 . -20) (f94387 . -16) (f94388 . -12) (f94387 . -8) (f94339 . -28) (f94340 . -24) (f94341 . -20) (f94342 . -16) (f94343 . -12) (f94344 . -8) (f94345 . -4) (f94346 . 0))
# expr=((primitive-ref write-char) #\t f94388)
# emit-tail-funcall
#    si   =-24
#    env  = ((f94388 . -20) (f94387 . -16) (f94388 . -12) (f94387 . -8) (f94339 . -28) (f94340 . -24) (f94341 . -20) (f94342 . -16) (f94343 . -12) (f94344 . -8) (f94345 . -4) (f94346 . 0))
#    expr = (funcall (primitive-ref write-char) #\t f94388)
# emit-expr (primitive-ref write-char)
    .extern mrc_write$mchar
    movl mrc_write$mchar,%eax
   movl %eax,  -24(%esp)  # stash funcall-oper in next closure slot
# emit-expr #\t
    movl $29711, %eax     # immed #\t
    mov %eax, -28(%esp)    # arg t
# emit-expr f94388
# emit-variable-ref
# env=((f94388 . -20) (f94387 . -16) (f94388 . -12) (f94387 . -8) (f94339 . -28) (f94340 . -24) (f94341 . -20) (f94342 . -16) (f94343 . -12) (f94344 . -8) (f94345 . -4) (f94346 . 0))
# var=f94388
    movl -20(%esp), %eax  # stack load f94388
# end emit-variable-ref
    mov %eax, -32(%esp)    # arg f94388
    movl -24(%esp), %edi   # load new closure to %edi
# emit-shift-args:  size=3   si=-24  delta=20
    mov -24(%esp), %ebx  # shift frame cell
    mov %ebx, -4(%esp)  # down to base
# emit-shift-args:  size=2   si=-28  delta=20
    mov -28(%esp), %ebx  # shift frame cell
    mov %ebx, -8(%esp)  # down to base
# emit-shift-args:  size=1   si=-32  delta=20
    mov -32(%esp), %ebx  # shift frame cell
    mov %ebx, -12(%esp)  # down to base
# emit-shift-args:  size=0   si=-36  delta=20
    movl $8,%eax   # save arg count
    jmp *-2(%edi)  # tail-funcall
    jmp _L_571689
_L_571688:
# emit-tail-expr
# si=-24
# env=((f94388 . -20) (f94387 . -16) (f94388 . -12) (f94387 . -8) (f94339 . -28) (f94340 . -24) (f94341 . -20) (f94342 . -16) (f94343 . -12) (f94344 . -8) (f94345 . -4) (f94346 . 0))
# expr=((primitive-ref write-char) #\f f94388)
# emit-tail-funcall
#    si   =-24
#    env  = ((f94388 . -20) (f94387 . -16) (f94388 . -12) (f94387 . -8) (f94339 . -28) (f94340 . -24) (f94341 . -20) (f94342 . -16) (f94343 . -12) (f94344 . -8) (f94345 . -4) (f94346 . 0))
#    expr = (funcall (primitive-ref write-char) #\f f94388)
# emit-expr (primitive-ref write-char)
    .extern mrc_write$mchar
    movl mrc_write$mchar,%eax
   movl %eax,  -24(%esp)  # stash funcall-oper in next closure slot
# emit-expr #\f
    movl $26127, %eax     # immed #\f
    mov %eax, -28(%esp)    # arg f
# emit-expr f94388
# emit-variable-ref
# env=((f94388 . -20) (f94387 . -16) (f94388 . -12) (f94387 . -8) (f94339 . -28) (f94340 . -24) (f94341 . -20) (f94342 . -16) (f94343 . -12) (f94344 . -8) (f94345 . -4) (f94346 . 0))
# var=f94388
    movl -20(%esp), %eax  # stack load f94388
# end emit-variable-ref
    mov %eax, -32(%esp)    # arg f94388
    movl -24(%esp), %edi   # load new closure to %edi
# emit-shift-args:  size=3   si=-24  delta=20
    mov -24(%esp), %ebx  # shift frame cell
    mov %ebx, -4(%esp)  # down to base
# emit-shift-args:  size=2   si=-28  delta=20
    mov -28(%esp), %ebx  # shift frame cell
    mov %ebx, -8(%esp)  # down to base
# emit-shift-args:  size=1   si=-32  delta=20
    mov -32(%esp), %ebx  # shift frame cell
    mov %ebx, -12(%esp)  # down to base
# emit-shift-args:  size=0   si=-36  delta=20
    movl $8,%eax   # save arg count
    jmp *-2(%edi)  # tail-funcall
_L_571689:
     ret   # return thru stack
    .align 4,0x90
_L_571685:
    movl -32(%esp), %ebx
    movl -36(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin (vector-set! f94345 0 (closure (f94386) () (let ((f94386 f94386)) (begin ((primitive-ref write-char) #\( f94386) ((primitive-ref write-char) #\) f94386))))) (vector-set! f94344 0 (closure (f94384 f94385) () (let ((f94384 f94384) (f94385 f94385)) (begin ((primitive-ref write-char) #\# f94385) ((primitive-ref write-char) #\\ f94385) ((primitive-ref write-char) f94384 f94385))))) (vector-set! f94343 0 (closure (f94380 f94381) (f94343) (let ((f94380 f94380) (f94381 f94381)) (if ((primitive-ref negative?) f94380) (begin ((primitive-ref write-char) #\- f94381) ((vector-ref f94343 0) (fx* -1 f94380) f94381)) ((primitive-ref map) (closure (f94383) (f94381) (let ((f94383 f94383)) ((primitive-ref write-char) (fixnum->char (fx+ (char->fixnum #\0) f94383)) f94381))) ((primitive-ref integer->list) f94380)))))) (vector-set! f94342 0 (closure (f94376 f94377) () (let ((f94376 f94376) (f94377 f94377)) (begin ((primitive-ref write-char) #\" f94377) ((primitive-ref for-each) (closure (f94379) (f94377) (let ((f94379 f94379)) ((primitive-ref write-char) f94379 f94377))) ((primitive-ref string->list) f94376)) ((primitive-ref write-char) #\" f94377))))) (vector-set! f94341 0 (closure (f94372 f94373) () (let ((f94372 f94372) (f94373 f94373)) ((primitive-ref for-each) (closure (f94375) (f94373) (let ((f94375 f94375)) ((primitive-ref write-char) f94375 f94373))) ((primitive-ref string->list) f94372))))) (vector-set! f94340 0 (closure (f94370 f94371) (f94339) (let ((f94370 f94370) (f94371 f94371)) (begin ((primitive-ref write-char) #\( f94371) ((vector-ref f94339 0) f94370 f94371) ((primitive-ref write-char) #\) f94371))))) (vector-set! f94339 0 (closure (f94368 f94369) (f94339) (let ((f94368 f94368) (f94369 f94369)) (begin ((primitive-ref write) (car f94368) f94369) (if (null? (cdr f94368)) #t (if (pair? (cdr f94368)) (begin ((primitive-ref write-char) #\space f94369) ((vector-ref f94339 0) (cdr f94368) f94369)) (begin ((primitive-ref write-char) #\space f94369) ((primitive-ref write-char) #\. f94369) ((primitive-ref write-char) #\space f94369) ((primitive-ref write) (cdr f94368) f94369)))))))))
# emit-begin
#   expr=(begin (vector-set! f94345 0 (closure (f94386) () (let ((f94386 f94386)) (begin ((primitive-ref write-char) #\( f94386) ((primitive-ref write-char) #\) f94386))))) (vector-set! f94344 0 (closure (f94384 f94385) () (let ((f94384 f94384) (f94385 f94385)) (begin ((primitive-ref write-char) #\# f94385) ((primitive-ref write-char) #\\ f94385) ((primitive-ref write-char) f94384 f94385))))) (vector-set! f94343 0 (closure (f94380 f94381) (f94343) (let ((f94380 f94380) (f94381 f94381)) (if ((primitive-ref negative?) f94380) (begin ((primitive-ref write-char) #\- f94381) ((vector-ref f94343 0) (fx* -1 f94380) f94381)) ((primitive-ref map) (closure (f94383) (f94381) (let ((f94383 f94383)) ((primitive-ref write-char) (fixnum->char (fx+ (char->fixnum #\0) f94383)) f94381))) ((primitive-ref integer->list) f94380)))))) (vector-set! f94342 0 (closure (f94376 f94377) () (let ((f94376 f94376) (f94377 f94377)) (begin ((primitive-ref write-char) #\" f94377) ((primitive-ref for-each) (closure (f94379) (f94377) (let ((f94379 f94379)) ((primitive-ref write-char) f94379 f94377))) ((primitive-ref string->list) f94376)) ((primitive-ref write-char) #\" f94377))))) (vector-set! f94341 0 (closure (f94372 f94373) () (let ((f94372 f94372) (f94373 f94373)) ((primitive-ref for-each) (closure (f94375) (f94373) (let ((f94375 f94375)) ((primitive-ref write-char) f94375 f94373))) ((primitive-ref string->list) f94372))))) (vector-set! f94340 0 (closure (f94370 f94371) (f94339) (let ((f94370 f94370) (f94371 f94371)) (begin ((primitive-ref write-char) #\( f94371) ((vector-ref f94339 0) f94370 f94371) ((primitive-ref write-char) #\) f94371))))) (vector-set! f94339 0 (closure (f94368 f94369) (f94339) (let ((f94368 f94368) (f94369 f94369)) (begin ((primitive-ref write) (car f94368) f94369) (if (null? (cdr f94368)) #t (if (pair? (cdr f94368)) (begin ((primitive-ref write-char) #\space f94369) ((vector-ref f94339 0) (cdr f94368) f94369)) (begin ((primitive-ref write-char) #\space f94369) ((primitive-ref write-char) #\. f94369) ((primitive-ref write-char) #\space f94369) ((primitive-ref write) (cdr f94368) f94369)))))))))
#   env=((f94339 . -28) (f94340 . -24) (f94341 . -20) (f94342 . -16) (f94343 . -12) (f94344 . -8) (f94345 . -4) (f94346 . 0))
# emit-expr (vector-set! f94345 0 (closure (f94386) () (let ((f94386 f94386)) (begin ((primitive-ref write-char) #\( f94386) ((primitive-ref write-char) #\) f94386)))))
# emit-expr f94345
# emit-variable-ref
# env=((f94339 . -28) (f94340 . -24) (f94341 . -20) (f94342 . -16) (f94343 . -12) (f94344 . -8) (f94345 . -4) (f94346 . 0))
# var=f94345
    movl -4(%esp), %eax  # stack load f94345
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_571690
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_571690:
    movl %eax, -32(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_571691"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_571691:
# check bounds on vector index
    movl -32(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_571693
    cmp  $0,%eax
    jge _L_571692
_L_571693:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_571692:
    movl %eax, -36(%esp)
# emit-expr (closure (f94386) () (let ((f94386 f94386)) (begin ((primitive-ref write-char) #\( f94386) ((primitive-ref write-char) #\) f94386))))
# emit-closure
# si = -40
# env = ((f94339 . -28) (f94340 . -24) (f94341 . -20) (f94342 . -16) (f94343 . -12) (f94344 . -8) (f94345 . -4) (f94346 . 0))
# expr = (closure (f94386) () (let ((f94386 f94386)) (begin ((primitive-ref write-char) #\( f94386) ((primitive-ref write-char) #\) f94386))))
    movl $_L_571694, 0(%ebp)  # closure label
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $8, %ebp     # bump ebp
    jmp _L_571695            # jump around closure body
_L_571694:
# check argument count
    cmp $4,%eax
    je _L_571696
# invoke error handler eh_argcount
    .extern mrc_eh$uargcount
    movl mrc_eh$uargcount, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_571696:
# emit-tail-expr
# si=-12
# env=((f94386 . -8) (f94339 . -28) (f94340 . -24) (f94341 . -20) (f94342 . -16) (f94343 . -12) (f94344 . -8) (f94345 . -4) (f94346 . 0))
# expr=(let ((f94386 f94386)) (begin ((primitive-ref write-char) #\( f94386) ((primitive-ref write-char) #\) f94386)))
# emit-tail-let
#  si   = -12
#  env  = ((f94386 . -8) (f94339 . -28) (f94340 . -24) (f94341 . -20) (f94342 . -16) (f94343 . -12) (f94344 . -8) (f94345 . -4) (f94346 . 0))
#  bindings = ((f94386 f94386))
#  body = (begin ((primitive-ref write-char) #\( f94386) ((primitive-ref write-char) #\) f94386))
# emit-expr f94386
# emit-variable-ref
# env=((f94386 . -8) (f94339 . -28) (f94340 . -24) (f94341 . -20) (f94342 . -16) (f94343 . -12) (f94344 . -8) (f94345 . -4) (f94346 . 0))
# var=f94386
    movl -8(%esp), %eax  # stack load f94386
# end emit-variable-ref
    movl %eax, -12(%esp)  # stack save
# emit-tail-expr
# si=-16
# env=((f94386 . -12) (f94386 . -8) (f94339 . -28) (f94340 . -24) (f94341 . -20) (f94342 . -16) (f94343 . -12) (f94344 . -8) (f94345 . -4) (f94346 . 0))
# expr=(begin ((primitive-ref write-char) #\( f94386) ((primitive-ref write-char) #\) f94386))
# tail-begin (begin ((primitive-ref write-char) #\( f94386) ((primitive-ref write-char) #\) f94386))
#   env=((f94386 . -12) (f94386 . -8) (f94339 . -28) (f94340 . -24) (f94341 . -20) (f94342 . -16) (f94343 . -12) (f94344 . -8) (f94345 . -4) (f94346 . 0))
# emit-expr ((primitive-ref write-char) #\( f94386)
# funcall
#    si   =-16
#    env  = ((f94386 . -12) (f94386 . -8) (f94339 . -28) (f94340 . -24) (f94341 . -20) (f94342 . -16) (f94343 . -12) (f94344 . -8) (f94345 . -4) (f94346 . 0))
#    expr = (funcall (primitive-ref write-char) #\( f94386)
# emit-expr (primitive-ref write-char)
    .extern mrc_write$mchar
    movl mrc_write$mchar,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_571697"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_571697":
   movl %eax,  -24(%esp)  # stash funcall-oper in closure slot
# emit-expr #\(
    movl $10255, %eax     # immed #\(
    mov %eax, -28(%esp)  # arg (
# emit-expr f94386
# emit-variable-ref
# env=((f94386 . -12) (f94386 . -8) (f94339 . -28) (f94340 . -24) (f94341 . -20) (f94342 . -16) (f94343 . -12) (f94344 . -8) (f94345 . -4) (f94346 . 0))
# var=f94386
    movl -12(%esp), %eax  # stack load f94386
# end emit-variable-ref
    mov %eax, -32(%esp)  # arg f94386
    movl -24(%esp), %edi   # load new closure to %edi
    add $-16, %esp   # adjust base
    movl $8,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $16, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
# emit-tail-expr
# si=-16
# env=((f94386 . -12) (f94386 . -8) (f94339 . -28) (f94340 . -24) (f94341 . -20) (f94342 . -16) (f94343 . -12) (f94344 . -8) (f94345 . -4) (f94346 . 0))
# expr=(begin ((primitive-ref write-char) #\) f94386))
# tail-begin (begin ((primitive-ref write-char) #\) f94386))
#   env=((f94386 . -12) (f94386 . -8) (f94339 . -28) (f94340 . -24) (f94341 . -20) (f94342 . -16) (f94343 . -12) (f94344 . -8) (f94345 . -4) (f94346 . 0))
# emit-tail-expr
# si=-16
# env=((f94386 . -12) (f94386 . -8) (f94339 . -28) (f94340 . -24) (f94341 . -20) (f94342 . -16) (f94343 . -12) (f94344 . -8) (f94345 . -4) (f94346 . 0))
# expr=((primitive-ref write-char) #\) f94386)
# emit-tail-funcall
#    si   =-16
#    env  = ((f94386 . -12) (f94386 . -8) (f94339 . -28) (f94340 . -24) (f94341 . -20) (f94342 . -16) (f94343 . -12) (f94344 . -8) (f94345 . -4) (f94346 . 0))
#    expr = (funcall (primitive-ref write-char) #\) f94386)
# emit-expr (primitive-ref write-char)
    .extern mrc_write$mchar
    movl mrc_write$mchar,%eax
   movl %eax,  -16(%esp)  # stash funcall-oper in next closure slot
# emit-expr #\)
    movl $10511, %eax     # immed #\)
    mov %eax, -20(%esp)    # arg )
# emit-expr f94386
# emit-variable-ref
# env=((f94386 . -12) (f94386 . -8) (f94339 . -28) (f94340 . -24) (f94341 . -20) (f94342 . -16) (f94343 . -12) (f94344 . -8) (f94345 . -4) (f94346 . 0))
# var=f94386
    movl -12(%esp), %eax  # stack load f94386
# end emit-variable-ref
    mov %eax, -24(%esp)    # arg f94386
    movl -16(%esp), %edi   # load new closure to %edi
# emit-shift-args:  size=3   si=-16  delta=12
    mov -16(%esp), %ebx  # shift frame cell
    mov %ebx, -4(%esp)  # down to base
# emit-shift-args:  size=2   si=-20  delta=12
    mov -20(%esp), %ebx  # shift frame cell
    mov %ebx, -8(%esp)  # down to base
# emit-shift-args:  size=1   si=-24  delta=12
    mov -24(%esp), %ebx  # shift frame cell
    mov %ebx, -12(%esp)  # down to base
# emit-shift-args:  size=0   si=-28  delta=12
    movl $8,%eax   # save arg count
    jmp *-2(%edi)  # tail-funcall
     ret   # return thru stack
    .align 4,0x90
_L_571695:
    movl -32(%esp), %ebx
    movl -36(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin (vector-set! f94344 0 (closure (f94384 f94385) () (let ((f94384 f94384) (f94385 f94385)) (begin ((primitive-ref write-char) #\# f94385) ((primitive-ref write-char) #\\ f94385) ((primitive-ref write-char) f94384 f94385))))) (vector-set! f94343 0 (closure (f94380 f94381) (f94343) (let ((f94380 f94380) (f94381 f94381)) (if ((primitive-ref negative?) f94380) (begin ((primitive-ref write-char) #\- f94381) ((vector-ref f94343 0) (fx* -1 f94380) f94381)) ((primitive-ref map) (closure (f94383) (f94381) (let ((f94383 f94383)) ((primitive-ref write-char) (fixnum->char (fx+ (char->fixnum #\0) f94383)) f94381))) ((primitive-ref integer->list) f94380)))))) (vector-set! f94342 0 (closure (f94376 f94377) () (let ((f94376 f94376) (f94377 f94377)) (begin ((primitive-ref write-char) #\" f94377) ((primitive-ref for-each) (closure (f94379) (f94377) (let ((f94379 f94379)) ((primitive-ref write-char) f94379 f94377))) ((primitive-ref string->list) f94376)) ((primitive-ref write-char) #\" f94377))))) (vector-set! f94341 0 (closure (f94372 f94373) () (let ((f94372 f94372) (f94373 f94373)) ((primitive-ref for-each) (closure (f94375) (f94373) (let ((f94375 f94375)) ((primitive-ref write-char) f94375 f94373))) ((primitive-ref string->list) f94372))))) (vector-set! f94340 0 (closure (f94370 f94371) (f94339) (let ((f94370 f94370) (f94371 f94371)) (begin ((primitive-ref write-char) #\( f94371) ((vector-ref f94339 0) f94370 f94371) ((primitive-ref write-char) #\) f94371))))) (vector-set! f94339 0 (closure (f94368 f94369) (f94339) (let ((f94368 f94368) (f94369 f94369)) (begin ((primitive-ref write) (car f94368) f94369) (if (null? (cdr f94368)) #t (if (pair? (cdr f94368)) (begin ((primitive-ref write-char) #\space f94369) ((vector-ref f94339 0) (cdr f94368) f94369)) (begin ((primitive-ref write-char) #\space f94369) ((primitive-ref write-char) #\. f94369) ((primitive-ref write-char) #\space f94369) ((primitive-ref write) (cdr f94368) f94369)))))))))
# emit-begin
#   expr=(begin (vector-set! f94344 0 (closure (f94384 f94385) () (let ((f94384 f94384) (f94385 f94385)) (begin ((primitive-ref write-char) #\# f94385) ((primitive-ref write-char) #\\ f94385) ((primitive-ref write-char) f94384 f94385))))) (vector-set! f94343 0 (closure (f94380 f94381) (f94343) (let ((f94380 f94380) (f94381 f94381)) (if ((primitive-ref negative?) f94380) (begin ((primitive-ref write-char) #\- f94381) ((vector-ref f94343 0) (fx* -1 f94380) f94381)) ((primitive-ref map) (closure (f94383) (f94381) (let ((f94383 f94383)) ((primitive-ref write-char) (fixnum->char (fx+ (char->fixnum #\0) f94383)) f94381))) ((primitive-ref integer->list) f94380)))))) (vector-set! f94342 0 (closure (f94376 f94377) () (let ((f94376 f94376) (f94377 f94377)) (begin ((primitive-ref write-char) #\" f94377) ((primitive-ref for-each) (closure (f94379) (f94377) (let ((f94379 f94379)) ((primitive-ref write-char) f94379 f94377))) ((primitive-ref string->list) f94376)) ((primitive-ref write-char) #\" f94377))))) (vector-set! f94341 0 (closure (f94372 f94373) () (let ((f94372 f94372) (f94373 f94373)) ((primitive-ref for-each) (closure (f94375) (f94373) (let ((f94375 f94375)) ((primitive-ref write-char) f94375 f94373))) ((primitive-ref string->list) f94372))))) (vector-set! f94340 0 (closure (f94370 f94371) (f94339) (let ((f94370 f94370) (f94371 f94371)) (begin ((primitive-ref write-char) #\( f94371) ((vector-ref f94339 0) f94370 f94371) ((primitive-ref write-char) #\) f94371))))) (vector-set! f94339 0 (closure (f94368 f94369) (f94339) (let ((f94368 f94368) (f94369 f94369)) (begin ((primitive-ref write) (car f94368) f94369) (if (null? (cdr f94368)) #t (if (pair? (cdr f94368)) (begin ((primitive-ref write-char) #\space f94369) ((vector-ref f94339 0) (cdr f94368) f94369)) (begin ((primitive-ref write-char) #\space f94369) ((primitive-ref write-char) #\. f94369) ((primitive-ref write-char) #\space f94369) ((primitive-ref write) (cdr f94368) f94369)))))))))
#   env=((f94339 . -28) (f94340 . -24) (f94341 . -20) (f94342 . -16) (f94343 . -12) (f94344 . -8) (f94345 . -4) (f94346 . 0))
# emit-expr (vector-set! f94344 0 (closure (f94384 f94385) () (let ((f94384 f94384) (f94385 f94385)) (begin ((primitive-ref write-char) #\# f94385) ((primitive-ref write-char) #\\ f94385) ((primitive-ref write-char) f94384 f94385)))))
# emit-expr f94344
# emit-variable-ref
# env=((f94339 . -28) (f94340 . -24) (f94341 . -20) (f94342 . -16) (f94343 . -12) (f94344 . -8) (f94345 . -4) (f94346 . 0))
# var=f94344
    movl -8(%esp), %eax  # stack load f94344
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_571698
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_571698:
    movl %eax, -32(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_571699"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_571699:
# check bounds on vector index
    movl -32(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_571701
    cmp  $0,%eax
    jge _L_571700
_L_571701:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_571700:
    movl %eax, -36(%esp)
# emit-expr (closure (f94384 f94385) () (let ((f94384 f94384) (f94385 f94385)) (begin ((primitive-ref write-char) #\# f94385) ((primitive-ref write-char) #\\ f94385) ((primitive-ref write-char) f94384 f94385))))
# emit-closure
# si = -40
# env = ((f94339 . -28) (f94340 . -24) (f94341 . -20) (f94342 . -16) (f94343 . -12) (f94344 . -8) (f94345 . -4) (f94346 . 0))
# expr = (closure (f94384 f94385) () (let ((f94384 f94384) (f94385 f94385)) (begin ((primitive-ref write-char) #\# f94385) ((primitive-ref write-char) #\\ f94385) ((primitive-ref write-char) f94384 f94385))))
    movl $_L_571702, 0(%ebp)  # closure label
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $8, %ebp     # bump ebp
    jmp _L_571703            # jump around closure body
_L_571702:
# check argument count
    cmp $8,%eax
    je _L_571704
# invoke error handler eh_argcount
    .extern mrc_eh$uargcount
    movl mrc_eh$uargcount, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_571704:
# emit-tail-expr
# si=-16
# env=((f94385 . -12) (f94384 . -8) (f94339 . -28) (f94340 . -24) (f94341 . -20) (f94342 . -16) (f94343 . -12) (f94344 . -8) (f94345 . -4) (f94346 . 0))
# expr=(let ((f94384 f94384) (f94385 f94385)) (begin ((primitive-ref write-char) #\# f94385) ((primitive-ref write-char) #\\ f94385) ((primitive-ref write-char) f94384 f94385)))
# emit-tail-let
#  si   = -16
#  env  = ((f94385 . -12) (f94384 . -8) (f94339 . -28) (f94340 . -24) (f94341 . -20) (f94342 . -16) (f94343 . -12) (f94344 . -8) (f94345 . -4) (f94346 . 0))
#  bindings = ((f94384 f94384) (f94385 f94385))
#  body = (begin ((primitive-ref write-char) #\# f94385) ((primitive-ref write-char) #\\ f94385) ((primitive-ref write-char) f94384 f94385))
# emit-expr f94384
# emit-variable-ref
# env=((f94385 . -12) (f94384 . -8) (f94339 . -28) (f94340 . -24) (f94341 . -20) (f94342 . -16) (f94343 . -12) (f94344 . -8) (f94345 . -4) (f94346 . 0))
# var=f94384
    movl -8(%esp), %eax  # stack load f94384
# end emit-variable-ref
    movl %eax, -16(%esp)  # stack save
# emit-expr f94385
# emit-variable-ref
# env=((f94385 . -12) (f94384 . -8) (f94339 . -28) (f94340 . -24) (f94341 . -20) (f94342 . -16) (f94343 . -12) (f94344 . -8) (f94345 . -4) (f94346 . 0))
# var=f94385
    movl -12(%esp), %eax  # stack load f94385
# end emit-variable-ref
    movl %eax, -20(%esp)  # stack save
# emit-tail-expr
# si=-24
# env=((f94385 . -20) (f94384 . -16) (f94385 . -12) (f94384 . -8) (f94339 . -28) (f94340 . -24) (f94341 . -20) (f94342 . -16) (f94343 . -12) (f94344 . -8) (f94345 . -4) (f94346 . 0))
# expr=(begin ((primitive-ref write-char) #\# f94385) ((primitive-ref write-char) #\\ f94385) ((primitive-ref write-char) f94384 f94385))
# tail-begin (begin ((primitive-ref write-char) #\# f94385) ((primitive-ref write-char) #\\ f94385) ((primitive-ref write-char) f94384 f94385))
#   env=((f94385 . -20) (f94384 . -16) (f94385 . -12) (f94384 . -8) (f94339 . -28) (f94340 . -24) (f94341 . -20) (f94342 . -16) (f94343 . -12) (f94344 . -8) (f94345 . -4) (f94346 . 0))
# emit-expr ((primitive-ref write-char) #\# f94385)
# funcall
#    si   =-24
#    env  = ((f94385 . -20) (f94384 . -16) (f94385 . -12) (f94384 . -8) (f94339 . -28) (f94340 . -24) (f94341 . -20) (f94342 . -16) (f94343 . -12) (f94344 . -8) (f94345 . -4) (f94346 . 0))
#    expr = (funcall (primitive-ref write-char) #\# f94385)
# emit-expr (primitive-ref write-char)
    .extern mrc_write$mchar
    movl mrc_write$mchar,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_571705"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_571705":
   movl %eax,  -32(%esp)  # stash funcall-oper in closure slot
# emit-expr #\#
    movl $8975, %eax     # immed #\#
    mov %eax, -36(%esp)  # arg #
# emit-expr f94385
# emit-variable-ref
# env=((f94385 . -20) (f94384 . -16) (f94385 . -12) (f94384 . -8) (f94339 . -28) (f94340 . -24) (f94341 . -20) (f94342 . -16) (f94343 . -12) (f94344 . -8) (f94345 . -4) (f94346 . 0))
# var=f94385
    movl -20(%esp), %eax  # stack load f94385
# end emit-variable-ref
    mov %eax, -40(%esp)  # arg f94385
    movl -32(%esp), %edi   # load new closure to %edi
    add $-24, %esp   # adjust base
    movl $8,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $24, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
# emit-tail-expr
# si=-24
# env=((f94385 . -20) (f94384 . -16) (f94385 . -12) (f94384 . -8) (f94339 . -28) (f94340 . -24) (f94341 . -20) (f94342 . -16) (f94343 . -12) (f94344 . -8) (f94345 . -4) (f94346 . 0))
# expr=(begin ((primitive-ref write-char) #\\ f94385) ((primitive-ref write-char) f94384 f94385))
# tail-begin (begin ((primitive-ref write-char) #\\ f94385) ((primitive-ref write-char) f94384 f94385))
#   env=((f94385 . -20) (f94384 . -16) (f94385 . -12) (f94384 . -8) (f94339 . -28) (f94340 . -24) (f94341 . -20) (f94342 . -16) (f94343 . -12) (f94344 . -8) (f94345 . -4) (f94346 . 0))
# emit-expr ((primitive-ref write-char) #\\ f94385)
# funcall
#    si   =-24
#    env  = ((f94385 . -20) (f94384 . -16) (f94385 . -12) (f94384 . -8) (f94339 . -28) (f94340 . -24) (f94341 . -20) (f94342 . -16) (f94343 . -12) (f94344 . -8) (f94345 . -4) (f94346 . 0))
#    expr = (funcall (primitive-ref write-char) #\\ f94385)
# emit-expr (primitive-ref write-char)
    .extern mrc_write$mchar
    movl mrc_write$mchar,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_571706"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_571706":
   movl %eax,  -32(%esp)  # stash funcall-oper in closure slot
# emit-expr #\\
    movl $23567, %eax     # immed #\\
    mov %eax, -36(%esp)  # arg \
# emit-expr f94385
# emit-variable-ref
# env=((f94385 . -20) (f94384 . -16) (f94385 . -12) (f94384 . -8) (f94339 . -28) (f94340 . -24) (f94341 . -20) (f94342 . -16) (f94343 . -12) (f94344 . -8) (f94345 . -4) (f94346 . 0))
# var=f94385
    movl -20(%esp), %eax  # stack load f94385
# end emit-variable-ref
    mov %eax, -40(%esp)  # arg f94385
    movl -32(%esp), %edi   # load new closure to %edi
    add $-24, %esp   # adjust base
    movl $8,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $24, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
# emit-tail-expr
# si=-24
# env=((f94385 . -20) (f94384 . -16) (f94385 . -12) (f94384 . -8) (f94339 . -28) (f94340 . -24) (f94341 . -20) (f94342 . -16) (f94343 . -12) (f94344 . -8) (f94345 . -4) (f94346 . 0))
# expr=(begin ((primitive-ref write-char) f94384 f94385))
# tail-begin (begin ((primitive-ref write-char) f94384 f94385))
#   env=((f94385 . -20) (f94384 . -16) (f94385 . -12) (f94384 . -8) (f94339 . -28) (f94340 . -24) (f94341 . -20) (f94342 . -16) (f94343 . -12) (f94344 . -8) (f94345 . -4) (f94346 . 0))
# emit-tail-expr
# si=-24
# env=((f94385 . -20) (f94384 . -16) (f94385 . -12) (f94384 . -8) (f94339 . -28) (f94340 . -24) (f94341 . -20) (f94342 . -16) (f94343 . -12) (f94344 . -8) (f94345 . -4) (f94346 . 0))
# expr=((primitive-ref write-char) f94384 f94385)
# emit-tail-funcall
#    si   =-24
#    env  = ((f94385 . -20) (f94384 . -16) (f94385 . -12) (f94384 . -8) (f94339 . -28) (f94340 . -24) (f94341 . -20) (f94342 . -16) (f94343 . -12) (f94344 . -8) (f94345 . -4) (f94346 . 0))
#    expr = (funcall (primitive-ref write-char) f94384 f94385)
# emit-expr (primitive-ref write-char)
    .extern mrc_write$mchar
    movl mrc_write$mchar,%eax
   movl %eax,  -24(%esp)  # stash funcall-oper in next closure slot
# emit-expr f94384
# emit-variable-ref
# env=((f94385 . -20) (f94384 . -16) (f94385 . -12) (f94384 . -8) (f94339 . -28) (f94340 . -24) (f94341 . -20) (f94342 . -16) (f94343 . -12) (f94344 . -8) (f94345 . -4) (f94346 . 0))
# var=f94384
    movl -16(%esp), %eax  # stack load f94384
# end emit-variable-ref
    mov %eax, -28(%esp)    # arg f94384
# emit-expr f94385
# emit-variable-ref
# env=((f94385 . -20) (f94384 . -16) (f94385 . -12) (f94384 . -8) (f94339 . -28) (f94340 . -24) (f94341 . -20) (f94342 . -16) (f94343 . -12) (f94344 . -8) (f94345 . -4) (f94346 . 0))
# var=f94385
    movl -20(%esp), %eax  # stack load f94385
# end emit-variable-ref
    mov %eax, -32(%esp)    # arg f94385
    movl -24(%esp), %edi   # load new closure to %edi
# emit-shift-args:  size=3   si=-24  delta=20
    mov -24(%esp), %ebx  # shift frame cell
    mov %ebx, -4(%esp)  # down to base
# emit-shift-args:  size=2   si=-28  delta=20
    mov -28(%esp), %ebx  # shift frame cell
    mov %ebx, -8(%esp)  # down to base
# emit-shift-args:  size=1   si=-32  delta=20
    mov -32(%esp), %ebx  # shift frame cell
    mov %ebx, -12(%esp)  # down to base
# emit-shift-args:  size=0   si=-36  delta=20
    movl $8,%eax   # save arg count
    jmp *-2(%edi)  # tail-funcall
     ret   # return thru stack
    .align 4,0x90
_L_571703:
    movl -32(%esp), %ebx
    movl -36(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin (vector-set! f94343 0 (closure (f94380 f94381) (f94343) (let ((f94380 f94380) (f94381 f94381)) (if ((primitive-ref negative?) f94380) (begin ((primitive-ref write-char) #\- f94381) ((vector-ref f94343 0) (fx* -1 f94380) f94381)) ((primitive-ref map) (closure (f94383) (f94381) (let ((f94383 f94383)) ((primitive-ref write-char) (fixnum->char (fx+ (char->fixnum #\0) f94383)) f94381))) ((primitive-ref integer->list) f94380)))))) (vector-set! f94342 0 (closure (f94376 f94377) () (let ((f94376 f94376) (f94377 f94377)) (begin ((primitive-ref write-char) #\" f94377) ((primitive-ref for-each) (closure (f94379) (f94377) (let ((f94379 f94379)) ((primitive-ref write-char) f94379 f94377))) ((primitive-ref string->list) f94376)) ((primitive-ref write-char) #\" f94377))))) (vector-set! f94341 0 (closure (f94372 f94373) () (let ((f94372 f94372) (f94373 f94373)) ((primitive-ref for-each) (closure (f94375) (f94373) (let ((f94375 f94375)) ((primitive-ref write-char) f94375 f94373))) ((primitive-ref string->list) f94372))))) (vector-set! f94340 0 (closure (f94370 f94371) (f94339) (let ((f94370 f94370) (f94371 f94371)) (begin ((primitive-ref write-char) #\( f94371) ((vector-ref f94339 0) f94370 f94371) ((primitive-ref write-char) #\) f94371))))) (vector-set! f94339 0 (closure (f94368 f94369) (f94339) (let ((f94368 f94368) (f94369 f94369)) (begin ((primitive-ref write) (car f94368) f94369) (if (null? (cdr f94368)) #t (if (pair? (cdr f94368)) (begin ((primitive-ref write-char) #\space f94369) ((vector-ref f94339 0) (cdr f94368) f94369)) (begin ((primitive-ref write-char) #\space f94369) ((primitive-ref write-char) #\. f94369) ((primitive-ref write-char) #\space f94369) ((primitive-ref write) (cdr f94368) f94369)))))))))
# emit-begin
#   expr=(begin (vector-set! f94343 0 (closure (f94380 f94381) (f94343) (let ((f94380 f94380) (f94381 f94381)) (if ((primitive-ref negative?) f94380) (begin ((primitive-ref write-char) #\- f94381) ((vector-ref f94343 0) (fx* -1 f94380) f94381)) ((primitive-ref map) (closure (f94383) (f94381) (let ((f94383 f94383)) ((primitive-ref write-char) (fixnum->char (fx+ (char->fixnum #\0) f94383)) f94381))) ((primitive-ref integer->list) f94380)))))) (vector-set! f94342 0 (closure (f94376 f94377) () (let ((f94376 f94376) (f94377 f94377)) (begin ((primitive-ref write-char) #\" f94377) ((primitive-ref for-each) (closure (f94379) (f94377) (let ((f94379 f94379)) ((primitive-ref write-char) f94379 f94377))) ((primitive-ref string->list) f94376)) ((primitive-ref write-char) #\" f94377))))) (vector-set! f94341 0 (closure (f94372 f94373) () (let ((f94372 f94372) (f94373 f94373)) ((primitive-ref for-each) (closure (f94375) (f94373) (let ((f94375 f94375)) ((primitive-ref write-char) f94375 f94373))) ((primitive-ref string->list) f94372))))) (vector-set! f94340 0 (closure (f94370 f94371) (f94339) (let ((f94370 f94370) (f94371 f94371)) (begin ((primitive-ref write-char) #\( f94371) ((vector-ref f94339 0) f94370 f94371) ((primitive-ref write-char) #\) f94371))))) (vector-set! f94339 0 (closure (f94368 f94369) (f94339) (let ((f94368 f94368) (f94369 f94369)) (begin ((primitive-ref write) (car f94368) f94369) (if (null? (cdr f94368)) #t (if (pair? (cdr f94368)) (begin ((primitive-ref write-char) #\space f94369) ((vector-ref f94339 0) (cdr f94368) f94369)) (begin ((primitive-ref write-char) #\space f94369) ((primitive-ref write-char) #\. f94369) ((primitive-ref write-char) #\space f94369) ((primitive-ref write) (cdr f94368) f94369)))))))))
#   env=((f94339 . -28) (f94340 . -24) (f94341 . -20) (f94342 . -16) (f94343 . -12) (f94344 . -8) (f94345 . -4) (f94346 . 0))
# emit-expr (vector-set! f94343 0 (closure (f94380 f94381) (f94343) (let ((f94380 f94380) (f94381 f94381)) (if ((primitive-ref negative?) f94380) (begin ((primitive-ref write-char) #\- f94381) ((vector-ref f94343 0) (fx* -1 f94380) f94381)) ((primitive-ref map) (closure (f94383) (f94381) (let ((f94383 f94383)) ((primitive-ref write-char) (fixnum->char (fx+ (char->fixnum #\0) f94383)) f94381))) ((primitive-ref integer->list) f94380))))))
# emit-expr f94343
# emit-variable-ref
# env=((f94339 . -28) (f94340 . -24) (f94341 . -20) (f94342 . -16) (f94343 . -12) (f94344 . -8) (f94345 . -4) (f94346 . 0))
# var=f94343
    movl -12(%esp), %eax  # stack load f94343
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_571707
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_571707:
    movl %eax, -32(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_571708"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_571708:
# check bounds on vector index
    movl -32(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_571710
    cmp  $0,%eax
    jge _L_571709
_L_571710:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_571709:
    movl %eax, -36(%esp)
# emit-expr (closure (f94380 f94381) (f94343) (let ((f94380 f94380) (f94381 f94381)) (if ((primitive-ref negative?) f94380) (begin ((primitive-ref write-char) #\- f94381) ((vector-ref f94343 0) (fx* -1 f94380) f94381)) ((primitive-ref map) (closure (f94383) (f94381) (let ((f94383 f94383)) ((primitive-ref write-char) (fixnum->char (fx+ (char->fixnum #\0) f94383)) f94381))) ((primitive-ref integer->list) f94380)))))
# emit-closure
# si = -40
# env = ((f94339 . -28) (f94340 . -24) (f94341 . -20) (f94342 . -16) (f94343 . -12) (f94344 . -8) (f94345 . -4) (f94346 . 0))
# expr = (closure (f94380 f94381) (f94343) (let ((f94380 f94380) (f94381 f94381)) (if ((primitive-ref negative?) f94380) (begin ((primitive-ref write-char) #\- f94381) ((vector-ref f94343 0) (fx* -1 f94380) f94381)) ((primitive-ref map) (closure (f94383) (f94381) (let ((f94383 f94383)) ((primitive-ref write-char) (fixnum->char (fx+ (char->fixnum #\0) f94383)) f94381))) ((primitive-ref integer->list) f94380)))))
    movl $_L_571711, 0(%ebp)  # closure label
# emit-variable-ref
# env=((f94339 . -28) (f94340 . -24) (f94341 . -20) (f94342 . -16) (f94343 . -12) (f94344 . -8) (f94345 . -4) (f94346 . 0))
# var=f94343
    movl -12(%esp), %eax  # stack load f94343
# end emit-variable-ref
   movl  %eax, 4(%ebp)  # f94343
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $8, %ebp     # bump ebp
    jmp _L_571712            # jump around closure body
_L_571711:
# check argument count
    cmp $8,%eax
    je _L_571713
# invoke error handler eh_argcount
    .extern mrc_eh$uargcount
    movl mrc_eh$uargcount, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_571713:
# emit-tail-expr
# si=-16
# env=((f94381 . -12) (f94380 . -8) (f94343 . 4) (f94339 . -28) (f94340 . -24) (f94341 . -20) (f94342 . -16) (f94343 . -12) (f94344 . -8) (f94345 . -4) (f94346 . 0))
# expr=(let ((f94380 f94380) (f94381 f94381)) (if ((primitive-ref negative?) f94380) (begin ((primitive-ref write-char) #\- f94381) ((vector-ref f94343 0) (fx* -1 f94380) f94381)) ((primitive-ref map) (closure (f94383) (f94381) (let ((f94383 f94383)) ((primitive-ref write-char) (fixnum->char (fx+ (char->fixnum #\0) f94383)) f94381))) ((primitive-ref integer->list) f94380))))
# emit-tail-let
#  si   = -16
#  env  = ((f94381 . -12) (f94380 . -8) (f94343 . 4) (f94339 . -28) (f94340 . -24) (f94341 . -20) (f94342 . -16) (f94343 . -12) (f94344 . -8) (f94345 . -4) (f94346 . 0))
#  bindings = ((f94380 f94380) (f94381 f94381))
#  body = (if ((primitive-ref negative?) f94380) (begin ((primitive-ref write-char) #\- f94381) ((vector-ref f94343 0) (fx* -1 f94380) f94381)) ((primitive-ref map) (closure (f94383) (f94381) (let ((f94383 f94383)) ((primitive-ref write-char) (fixnum->char (fx+ (char->fixnum #\0) f94383)) f94381))) ((primitive-ref integer->list) f94380)))
# emit-expr f94380
# emit-variable-ref
# env=((f94381 . -12) (f94380 . -8) (f94343 . 4) (f94339 . -28) (f94340 . -24) (f94341 . -20) (f94342 . -16) (f94343 . -12) (f94344 . -8) (f94345 . -4) (f94346 . 0))
# var=f94380
    movl -8(%esp), %eax  # stack load f94380
# end emit-variable-ref
    movl %eax, -16(%esp)  # stack save
# emit-expr f94381
# emit-variable-ref
# env=((f94381 . -12) (f94380 . -8) (f94343 . 4) (f94339 . -28) (f94340 . -24) (f94341 . -20) (f94342 . -16) (f94343 . -12) (f94344 . -8) (f94345 . -4) (f94346 . 0))
# var=f94381
    movl -12(%esp), %eax  # stack load f94381
# end emit-variable-ref
    movl %eax, -20(%esp)  # stack save
# emit-tail-expr
# si=-24
# env=((f94381 . -20) (f94380 . -16) (f94381 . -12) (f94380 . -8) (f94343 . 4) (f94339 . -28) (f94340 . -24) (f94341 . -20) (f94342 . -16) (f94343 . -12) (f94344 . -8) (f94345 . -4) (f94346 . 0))
# expr=(if ((primitive-ref negative?) f94380) (begin ((primitive-ref write-char) #\- f94381) ((vector-ref f94343 0) (fx* -1 f94380) f94381)) ((primitive-ref map) (closure (f94383) (f94381) (let ((f94383 f94383)) ((primitive-ref write-char) (fixnum->char (fx+ (char->fixnum #\0) f94383)) f94381))) ((primitive-ref integer->list) f94380)))
# emit-expr ((primitive-ref negative?) f94380)
# funcall
#    si   =-24
#    env  = ((f94381 . -20) (f94380 . -16) (f94381 . -12) (f94380 . -8) (f94343 . 4) (f94339 . -28) (f94340 . -24) (f94341 . -20) (f94342 . -16) (f94343 . -12) (f94344 . -8) (f94345 . -4) (f94346 . 0))
#    expr = (funcall (primitive-ref negative?) f94380)
# emit-expr (primitive-ref negative?)
    .extern mrc_negative$q
    movl mrc_negative$q,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_571716"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_571716":
   movl %eax,  -32(%esp)  # stash funcall-oper in closure slot
# emit-expr f94380
# emit-variable-ref
# env=((f94381 . -20) (f94380 . -16) (f94381 . -12) (f94380 . -8) (f94343 . 4) (f94339 . -28) (f94340 . -24) (f94341 . -20) (f94342 . -16) (f94343 . -12) (f94344 . -8) (f94345 . -4) (f94346 . 0))
# var=f94380
    movl -16(%esp), %eax  # stack load f94380
# end emit-variable-ref
    mov %eax, -36(%esp)  # arg f94380
    movl -32(%esp), %edi   # load new closure to %edi
    add $-24, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $24, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    cmp $47, %al
    je _L_571714
# emit-tail-expr
# si=-24
# env=((f94381 . -20) (f94380 . -16) (f94381 . -12) (f94380 . -8) (f94343 . 4) (f94339 . -28) (f94340 . -24) (f94341 . -20) (f94342 . -16) (f94343 . -12) (f94344 . -8) (f94345 . -4) (f94346 . 0))
# expr=(begin ((primitive-ref write-char) #\- f94381) ((vector-ref f94343 0) (fx* -1 f94380) f94381))
# tail-begin (begin ((primitive-ref write-char) #\- f94381) ((vector-ref f94343 0) (fx* -1 f94380) f94381))
#   env=((f94381 . -20) (f94380 . -16) (f94381 . -12) (f94380 . -8) (f94343 . 4) (f94339 . -28) (f94340 . -24) (f94341 . -20) (f94342 . -16) (f94343 . -12) (f94344 . -8) (f94345 . -4) (f94346 . 0))
# emit-expr ((primitive-ref write-char) #\- f94381)
# funcall
#    si   =-24
#    env  = ((f94381 . -20) (f94380 . -16) (f94381 . -12) (f94380 . -8) (f94343 . 4) (f94339 . -28) (f94340 . -24) (f94341 . -20) (f94342 . -16) (f94343 . -12) (f94344 . -8) (f94345 . -4) (f94346 . 0))
#    expr = (funcall (primitive-ref write-char) #\- f94381)
# emit-expr (primitive-ref write-char)
    .extern mrc_write$mchar
    movl mrc_write$mchar,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_571717"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_571717":
   movl %eax,  -32(%esp)  # stash funcall-oper in closure slot
# emit-expr #\-
    movl $11535, %eax     # immed #\-
    mov %eax, -36(%esp)  # arg -
# emit-expr f94381
# emit-variable-ref
# env=((f94381 . -20) (f94380 . -16) (f94381 . -12) (f94380 . -8) (f94343 . 4) (f94339 . -28) (f94340 . -24) (f94341 . -20) (f94342 . -16) (f94343 . -12) (f94344 . -8) (f94345 . -4) (f94346 . 0))
# var=f94381
    movl -20(%esp), %eax  # stack load f94381
# end emit-variable-ref
    mov %eax, -40(%esp)  # arg f94381
    movl -32(%esp), %edi   # load new closure to %edi
    add $-24, %esp   # adjust base
    movl $8,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $24, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
# emit-tail-expr
# si=-24
# env=((f94381 . -20) (f94380 . -16) (f94381 . -12) (f94380 . -8) (f94343 . 4) (f94339 . -28) (f94340 . -24) (f94341 . -20) (f94342 . -16) (f94343 . -12) (f94344 . -8) (f94345 . -4) (f94346 . 0))
# expr=(begin ((vector-ref f94343 0) (fx* -1 f94380) f94381))
# tail-begin (begin ((vector-ref f94343 0) (fx* -1 f94380) f94381))
#   env=((f94381 . -20) (f94380 . -16) (f94381 . -12) (f94380 . -8) (f94343 . 4) (f94339 . -28) (f94340 . -24) (f94341 . -20) (f94342 . -16) (f94343 . -12) (f94344 . -8) (f94345 . -4) (f94346 . 0))
# emit-tail-expr
# si=-24
# env=((f94381 . -20) (f94380 . -16) (f94381 . -12) (f94380 . -8) (f94343 . 4) (f94339 . -28) (f94340 . -24) (f94341 . -20) (f94342 . -16) (f94343 . -12) (f94344 . -8) (f94345 . -4) (f94346 . 0))
# expr=((vector-ref f94343 0) (fx* -1 f94380) f94381)
# emit-tail-funcall
#    si   =-24
#    env  = ((f94381 . -20) (f94380 . -16) (f94381 . -12) (f94380 . -8) (f94343 . 4) (f94339 . -28) (f94340 . -24) (f94341 . -20) (f94342 . -16) (f94343 . -12) (f94344 . -8) (f94345 . -4) (f94346 . 0))
#    expr = (funcall (vector-ref f94343 0) (fx* -1 f94380) f94381)
# emit-expr (vector-ref f94343 0)
# emit-expr f94343
# emit-variable-ref
# env=((f94381 . -20) (f94380 . -16) (f94381 . -12) (f94380 . -8) (f94343 . 4) (f94339 . -28) (f94340 . -24) (f94341 . -20) (f94342 . -16) (f94343 . -12) (f94344 . -8) (f94345 . -4) (f94346 . 0))
# var=f94343
    movl 2(%edi), %eax  # frame load f94343
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_571718
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_571718:
    movl %eax, -24(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_571719"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_571719:
# check bounds on vector index
    movl -24(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_571721
    cmp  $0,%eax
    jge _L_571720
_L_571721:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_571720:
    movl -24(%esp), %esi
    movl -1(%eax,%esi), %eax
   movl %eax,  -24(%esp)  # stash funcall-oper in next closure slot
# emit-expr (fx* -1 f94380)
# emit-expr f94380
# emit-variable-ref
# env=((f94381 . -20) (f94380 . -16) (f94381 . -12) (f94380 . -8) (f94343 . 4) (f94339 . -28) (f94340 . -24) (f94341 . -20) (f94342 . -16) (f94343 . -12) (f94344 . -8) (f94345 . -4) (f94346 . 0))
# var=f94380
    movl -16(%esp), %eax  # stack load f94380
# end emit-variable-ref
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_571722"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $96,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_571722:
    sar $2, %eax
    movl %eax, -28(%esp)
# emit-expr -1
    movl $-4, %eax     # immed -1
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_571723"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $96,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_571723:
    imul -28(%esp), %eax
    mov %eax, -28(%esp)    # arg (fx* -1 f94380)
# emit-expr f94381
# emit-variable-ref
# env=((f94381 . -20) (f94380 . -16) (f94381 . -12) (f94380 . -8) (f94343 . 4) (f94339 . -28) (f94340 . -24) (f94341 . -20) (f94342 . -16) (f94343 . -12) (f94344 . -8) (f94345 . -4) (f94346 . 0))
# var=f94381
    movl -20(%esp), %eax  # stack load f94381
# end emit-variable-ref
    mov %eax, -32(%esp)    # arg f94381
    movl -24(%esp), %edi   # load new closure to %edi
# emit-shift-args:  size=3   si=-24  delta=20
    mov -24(%esp), %ebx  # shift frame cell
    mov %ebx, -4(%esp)  # down to base
# emit-shift-args:  size=2   si=-28  delta=20
    mov -28(%esp), %ebx  # shift frame cell
    mov %ebx, -8(%esp)  # down to base
# emit-shift-args:  size=1   si=-32  delta=20
    mov -32(%esp), %ebx  # shift frame cell
    mov %ebx, -12(%esp)  # down to base
# emit-shift-args:  size=0   si=-36  delta=20
    movl $8,%eax   # save arg count
    jmp *-2(%edi)  # tail-funcall
     ret   # return thru stack
    jmp _L_571715
_L_571714:
# emit-tail-expr
# si=-24
# env=((f94381 . -20) (f94380 . -16) (f94381 . -12) (f94380 . -8) (f94343 . 4) (f94339 . -28) (f94340 . -24) (f94341 . -20) (f94342 . -16) (f94343 . -12) (f94344 . -8) (f94345 . -4) (f94346 . 0))
# expr=((primitive-ref map) (closure (f94383) (f94381) (let ((f94383 f94383)) ((primitive-ref write-char) (fixnum->char (fx+ (char->fixnum #\0) f94383)) f94381))) ((primitive-ref integer->list) f94380))
# emit-tail-funcall
#    si   =-24
#    env  = ((f94381 . -20) (f94380 . -16) (f94381 . -12) (f94380 . -8) (f94343 . 4) (f94339 . -28) (f94340 . -24) (f94341 . -20) (f94342 . -16) (f94343 . -12) (f94344 . -8) (f94345 . -4) (f94346 . 0))
#    expr = (funcall (primitive-ref map) (closure (f94383) (f94381) (let ((f94383 f94383)) ((primitive-ref write-char) (fixnum->char (fx+ (char->fixnum #\0) f94383)) f94381))) ((primitive-ref integer->list) f94380))
# emit-expr (primitive-ref map)
    .extern mrc_map
    movl mrc_map,%eax
   movl %eax,  -24(%esp)  # stash funcall-oper in next closure slot
# emit-expr (closure (f94383) (f94381) (let ((f94383 f94383)) ((primitive-ref write-char) (fixnum->char (fx+ (char->fixnum #\0) f94383)) f94381)))
# emit-closure
# si = -28
# env = ((f94381 . -20) (f94380 . -16) (f94381 . -12) (f94380 . -8) (f94343 . 4) (f94339 . -28) (f94340 . -24) (f94341 . -20) (f94342 . -16) (f94343 . -12) (f94344 . -8) (f94345 . -4) (f94346 . 0))
# expr = (closure (f94383) (f94381) (let ((f94383 f94383)) ((primitive-ref write-char) (fixnum->char (fx+ (char->fixnum #\0) f94383)) f94381)))
    movl $_L_571724, 0(%ebp)  # closure label
# emit-variable-ref
# env=((f94381 . -20) (f94380 . -16) (f94381 . -12) (f94380 . -8) (f94343 . 4) (f94339 . -28) (f94340 . -24) (f94341 . -20) (f94342 . -16) (f94343 . -12) (f94344 . -8) (f94345 . -4) (f94346 . 0))
# var=f94381
    movl -20(%esp), %eax  # stack load f94381
# end emit-variable-ref
   movl  %eax, 4(%ebp)  # f94381
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $8, %ebp     # bump ebp
    jmp _L_571725            # jump around closure body
_L_571724:
# check argument count
    cmp $4,%eax
    je _L_571726
# invoke error handler eh_argcount
    .extern mrc_eh$uargcount
    movl mrc_eh$uargcount, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_571726:
# emit-tail-expr
# si=-12
# env=((f94383 . -8) (f94381 . 4) (f94381 . -20) (f94380 . -16) (f94381 . -12) (f94380 . -8) (f94343 . 4) (f94339 . -28) (f94340 . -24) (f94341 . -20) (f94342 . -16) (f94343 . -12) (f94344 . -8) (f94345 . -4) (f94346 . 0))
# expr=(let ((f94383 f94383)) ((primitive-ref write-char) (fixnum->char (fx+ (char->fixnum #\0) f94383)) f94381))
# emit-tail-let
#  si   = -12
#  env  = ((f94383 . -8) (f94381 . 4) (f94381 . -20) (f94380 . -16) (f94381 . -12) (f94380 . -8) (f94343 . 4) (f94339 . -28) (f94340 . -24) (f94341 . -20) (f94342 . -16) (f94343 . -12) (f94344 . -8) (f94345 . -4) (f94346 . 0))
#  bindings = ((f94383 f94383))
#  body = ((primitive-ref write-char) (fixnum->char (fx+ (char->fixnum #\0) f94383)) f94381)
# emit-expr f94383
# emit-variable-ref
# env=((f94383 . -8) (f94381 . 4) (f94381 . -20) (f94380 . -16) (f94381 . -12) (f94380 . -8) (f94343 . 4) (f94339 . -28) (f94340 . -24) (f94341 . -20) (f94342 . -16) (f94343 . -12) (f94344 . -8) (f94345 . -4) (f94346 . 0))
# var=f94383
    movl -8(%esp), %eax  # stack load f94383
# end emit-variable-ref
    movl %eax, -12(%esp)  # stack save
# emit-tail-expr
# si=-16
# env=((f94383 . -12) (f94383 . -8) (f94381 . 4) (f94381 . -20) (f94380 . -16) (f94381 . -12) (f94380 . -8) (f94343 . 4) (f94339 . -28) (f94340 . -24) (f94341 . -20) (f94342 . -16) (f94343 . -12) (f94344 . -8) (f94345 . -4) (f94346 . 0))
# expr=((primitive-ref write-char) (fixnum->char (fx+ (char->fixnum #\0) f94383)) f94381)
# emit-tail-funcall
#    si   =-16
#    env  = ((f94383 . -12) (f94383 . -8) (f94381 . 4) (f94381 . -20) (f94380 . -16) (f94381 . -12) (f94380 . -8) (f94343 . 4) (f94339 . -28) (f94340 . -24) (f94341 . -20) (f94342 . -16) (f94343 . -12) (f94344 . -8) (f94345 . -4) (f94346 . 0))
#    expr = (funcall (primitive-ref write-char) (fixnum->char (fx+ (char->fixnum #\0) f94383)) f94381)
# emit-expr (primitive-ref write-char)
    .extern mrc_write$mchar
    movl mrc_write$mchar,%eax
   movl %eax,  -16(%esp)  # stash funcall-oper in next closure slot
# emit-expr (fixnum->char (fx+ (char->fixnum #\0) f94383))
# emit-expr (fx+ (char->fixnum #\0) f94383)
# emit-expr f94383
# emit-variable-ref
# env=((f94383 . -12) (f94383 . -8) (f94381 . 4) (f94381 . -20) (f94380 . -16) (f94381 . -12) (f94380 . -8) (f94343 . 4) (f94339 . -28) (f94340 . -24) (f94341 . -20) (f94342 . -16) (f94343 . -12) (f94344 . -8) (f94345 . -4) (f94346 . 0))
# var=f94383
    movl -12(%esp), %eax  # stack load f94383
# end emit-variable-ref
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_571727"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $88,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_571727:
    movl %eax, -20(%esp)  # fx+ push arg1
# emit-expr (char->fixnum #\0)
# emit-expr #\0
    movl $12303, %eax     # immed #\0
# check the argument is a char
    movl %eax,%ebx
    and $255, %bl
    cmp $15, %bl
    je "_L_571728"
# invoke error handler eh_character
    .extern mrc_eh$ucharacter
    movl mrc_eh$ucharacter, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $4,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_571728:
   shrl $8, %eax
   shll $2, %eax
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_571729"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $88,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_571729:
    addl -20(%esp), %eax  # fx+ arg1 arg2
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_571730"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $0,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_571730:
    shll $6, %eax
    orl $15, %eax
    mov %eax, -20(%esp)    # arg (fixnum->char (fx+ (char->fixnum 0) f94383))
# emit-expr f94381
# emit-variable-ref
# env=((f94383 . -12) (f94383 . -8) (f94381 . 4) (f94381 . -20) (f94380 . -16) (f94381 . -12) (f94380 . -8) (f94343 . 4) (f94339 . -28) (f94340 . -24) (f94341 . -20) (f94342 . -16) (f94343 . -12) (f94344 . -8) (f94345 . -4) (f94346 . 0))
# var=f94381
    movl 2(%edi), %eax  # frame load f94381
# end emit-variable-ref
    mov %eax, -24(%esp)    # arg f94381
    movl -16(%esp), %edi   # load new closure to %edi
# emit-shift-args:  size=3   si=-16  delta=12
    mov -16(%esp), %ebx  # shift frame cell
    mov %ebx, -4(%esp)  # down to base
# emit-shift-args:  size=2   si=-20  delta=12
    mov -20(%esp), %ebx  # shift frame cell
    mov %ebx, -8(%esp)  # down to base
# emit-shift-args:  size=1   si=-24  delta=12
    mov -24(%esp), %ebx  # shift frame cell
    mov %ebx, -12(%esp)  # down to base
# emit-shift-args:  size=0   si=-28  delta=12
    movl $8,%eax   # save arg count
    jmp *-2(%edi)  # tail-funcall
    .align 4,0x90
_L_571725:
    mov %eax, -28(%esp)    # arg (closure (f94383) (f94381) (let ((f94383 f94383)) ((primitive-ref write-char) (fixnum->char (fx+ (char->fixnum 0) f94383)) f94381)))
# emit-expr ((primitive-ref integer->list) f94380)
# funcall
#    si   =-32
#    env  = ((f94381 . -20) (f94380 . -16) (f94381 . -12) (f94380 . -8) (f94343 . 4) (f94339 . -28) (f94340 . -24) (f94341 . -20) (f94342 . -16) (f94343 . -12) (f94344 . -8) (f94345 . -4) (f94346 . 0))
#    expr = (funcall (primitive-ref integer->list) f94380)
# emit-expr (primitive-ref integer->list)
    .extern mrc_integer$m$glist
    movl mrc_integer$m$glist,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_571731"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_571731":
   movl %eax,  -40(%esp)  # stash funcall-oper in closure slot
# emit-expr f94380
# emit-variable-ref
# env=((f94381 . -20) (f94380 . -16) (f94381 . -12) (f94380 . -8) (f94343 . 4) (f94339 . -28) (f94340 . -24) (f94341 . -20) (f94342 . -16) (f94343 . -12) (f94344 . -8) (f94345 . -4) (f94346 . 0))
# var=f94380
    movl -16(%esp), %eax  # stack load f94380
# end emit-variable-ref
    mov %eax, -44(%esp)  # arg f94380
    movl -40(%esp), %edi   # load new closure to %edi
    add $-32, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $32, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    mov %eax, -32(%esp)    # arg ((primitive-ref integer->list) f94380)
    movl -24(%esp), %edi   # load new closure to %edi
# emit-shift-args:  size=3   si=-24  delta=20
    mov -24(%esp), %ebx  # shift frame cell
    mov %ebx, -4(%esp)  # down to base
# emit-shift-args:  size=2   si=-28  delta=20
    mov -28(%esp), %ebx  # shift frame cell
    mov %ebx, -8(%esp)  # down to base
# emit-shift-args:  size=1   si=-32  delta=20
    mov -32(%esp), %ebx  # shift frame cell
    mov %ebx, -12(%esp)  # down to base
# emit-shift-args:  size=0   si=-36  delta=20
    movl $8,%eax   # save arg count
    jmp *-2(%edi)  # tail-funcall
_L_571715:
    .align 4,0x90
_L_571712:
    movl -32(%esp), %ebx
    movl -36(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin (vector-set! f94342 0 (closure (f94376 f94377) () (let ((f94376 f94376) (f94377 f94377)) (begin ((primitive-ref write-char) #\" f94377) ((primitive-ref for-each) (closure (f94379) (f94377) (let ((f94379 f94379)) ((primitive-ref write-char) f94379 f94377))) ((primitive-ref string->list) f94376)) ((primitive-ref write-char) #\" f94377))))) (vector-set! f94341 0 (closure (f94372 f94373) () (let ((f94372 f94372) (f94373 f94373)) ((primitive-ref for-each) (closure (f94375) (f94373) (let ((f94375 f94375)) ((primitive-ref write-char) f94375 f94373))) ((primitive-ref string->list) f94372))))) (vector-set! f94340 0 (closure (f94370 f94371) (f94339) (let ((f94370 f94370) (f94371 f94371)) (begin ((primitive-ref write-char) #\( f94371) ((vector-ref f94339 0) f94370 f94371) ((primitive-ref write-char) #\) f94371))))) (vector-set! f94339 0 (closure (f94368 f94369) (f94339) (let ((f94368 f94368) (f94369 f94369)) (begin ((primitive-ref write) (car f94368) f94369) (if (null? (cdr f94368)) #t (if (pair? (cdr f94368)) (begin ((primitive-ref write-char) #\space f94369) ((vector-ref f94339 0) (cdr f94368) f94369)) (begin ((primitive-ref write-char) #\space f94369) ((primitive-ref write-char) #\. f94369) ((primitive-ref write-char) #\space f94369) ((primitive-ref write) (cdr f94368) f94369)))))))))
# emit-begin
#   expr=(begin (vector-set! f94342 0 (closure (f94376 f94377) () (let ((f94376 f94376) (f94377 f94377)) (begin ((primitive-ref write-char) #\" f94377) ((primitive-ref for-each) (closure (f94379) (f94377) (let ((f94379 f94379)) ((primitive-ref write-char) f94379 f94377))) ((primitive-ref string->list) f94376)) ((primitive-ref write-char) #\" f94377))))) (vector-set! f94341 0 (closure (f94372 f94373) () (let ((f94372 f94372) (f94373 f94373)) ((primitive-ref for-each) (closure (f94375) (f94373) (let ((f94375 f94375)) ((primitive-ref write-char) f94375 f94373))) ((primitive-ref string->list) f94372))))) (vector-set! f94340 0 (closure (f94370 f94371) (f94339) (let ((f94370 f94370) (f94371 f94371)) (begin ((primitive-ref write-char) #\( f94371) ((vector-ref f94339 0) f94370 f94371) ((primitive-ref write-char) #\) f94371))))) (vector-set! f94339 0 (closure (f94368 f94369) (f94339) (let ((f94368 f94368) (f94369 f94369)) (begin ((primitive-ref write) (car f94368) f94369) (if (null? (cdr f94368)) #t (if (pair? (cdr f94368)) (begin ((primitive-ref write-char) #\space f94369) ((vector-ref f94339 0) (cdr f94368) f94369)) (begin ((primitive-ref write-char) #\space f94369) ((primitive-ref write-char) #\. f94369) ((primitive-ref write-char) #\space f94369) ((primitive-ref write) (cdr f94368) f94369)))))))))
#   env=((f94339 . -28) (f94340 . -24) (f94341 . -20) (f94342 . -16) (f94343 . -12) (f94344 . -8) (f94345 . -4) (f94346 . 0))
# emit-expr (vector-set! f94342 0 (closure (f94376 f94377) () (let ((f94376 f94376) (f94377 f94377)) (begin ((primitive-ref write-char) #\" f94377) ((primitive-ref for-each) (closure (f94379) (f94377) (let ((f94379 f94379)) ((primitive-ref write-char) f94379 f94377))) ((primitive-ref string->list) f94376)) ((primitive-ref write-char) #\" f94377)))))
# emit-expr f94342
# emit-variable-ref
# env=((f94339 . -28) (f94340 . -24) (f94341 . -20) (f94342 . -16) (f94343 . -12) (f94344 . -8) (f94345 . -4) (f94346 . 0))
# var=f94342
    movl -16(%esp), %eax  # stack load f94342
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_571732
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_571732:
    movl %eax, -32(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_571733"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_571733:
# check bounds on vector index
    movl -32(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_571735
    cmp  $0,%eax
    jge _L_571734
_L_571735:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_571734:
    movl %eax, -36(%esp)
# emit-expr (closure (f94376 f94377) () (let ((f94376 f94376) (f94377 f94377)) (begin ((primitive-ref write-char) #\" f94377) ((primitive-ref for-each) (closure (f94379) (f94377) (let ((f94379 f94379)) ((primitive-ref write-char) f94379 f94377))) ((primitive-ref string->list) f94376)) ((primitive-ref write-char) #\" f94377))))
# emit-closure
# si = -40
# env = ((f94339 . -28) (f94340 . -24) (f94341 . -20) (f94342 . -16) (f94343 . -12) (f94344 . -8) (f94345 . -4) (f94346 . 0))
# expr = (closure (f94376 f94377) () (let ((f94376 f94376) (f94377 f94377)) (begin ((primitive-ref write-char) #\" f94377) ((primitive-ref for-each) (closure (f94379) (f94377) (let ((f94379 f94379)) ((primitive-ref write-char) f94379 f94377))) ((primitive-ref string->list) f94376)) ((primitive-ref write-char) #\" f94377))))
    movl $_L_571736, 0(%ebp)  # closure label
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $8, %ebp     # bump ebp
    jmp _L_571737            # jump around closure body
_L_571736:
# check argument count
    cmp $8,%eax
    je _L_571738
# invoke error handler eh_argcount
    .extern mrc_eh$uargcount
    movl mrc_eh$uargcount, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_571738:
# emit-tail-expr
# si=-16
# env=((f94377 . -12) (f94376 . -8) (f94339 . -28) (f94340 . -24) (f94341 . -20) (f94342 . -16) (f94343 . -12) (f94344 . -8) (f94345 . -4) (f94346 . 0))
# expr=(let ((f94376 f94376) (f94377 f94377)) (begin ((primitive-ref write-char) #\" f94377) ((primitive-ref for-each) (closure (f94379) (f94377) (let ((f94379 f94379)) ((primitive-ref write-char) f94379 f94377))) ((primitive-ref string->list) f94376)) ((primitive-ref write-char) #\" f94377)))
# emit-tail-let
#  si   = -16
#  env  = ((f94377 . -12) (f94376 . -8) (f94339 . -28) (f94340 . -24) (f94341 . -20) (f94342 . -16) (f94343 . -12) (f94344 . -8) (f94345 . -4) (f94346 . 0))
#  bindings = ((f94376 f94376) (f94377 f94377))
#  body = (begin ((primitive-ref write-char) #\" f94377) ((primitive-ref for-each) (closure (f94379) (f94377) (let ((f94379 f94379)) ((primitive-ref write-char) f94379 f94377))) ((primitive-ref string->list) f94376)) ((primitive-ref write-char) #\" f94377))
# emit-expr f94376
# emit-variable-ref
# env=((f94377 . -12) (f94376 . -8) (f94339 . -28) (f94340 . -24) (f94341 . -20) (f94342 . -16) (f94343 . -12) (f94344 . -8) (f94345 . -4) (f94346 . 0))
# var=f94376
    movl -8(%esp), %eax  # stack load f94376
# end emit-variable-ref
    movl %eax, -16(%esp)  # stack save
# emit-expr f94377
# emit-variable-ref
# env=((f94377 . -12) (f94376 . -8) (f94339 . -28) (f94340 . -24) (f94341 . -20) (f94342 . -16) (f94343 . -12) (f94344 . -8) (f94345 . -4) (f94346 . 0))
# var=f94377
    movl -12(%esp), %eax  # stack load f94377
# end emit-variable-ref
    movl %eax, -20(%esp)  # stack save
# emit-tail-expr
# si=-24
# env=((f94377 . -20) (f94376 . -16) (f94377 . -12) (f94376 . -8) (f94339 . -28) (f94340 . -24) (f94341 . -20) (f94342 . -16) (f94343 . -12) (f94344 . -8) (f94345 . -4) (f94346 . 0))
# expr=(begin ((primitive-ref write-char) #\" f94377) ((primitive-ref for-each) (closure (f94379) (f94377) (let ((f94379 f94379)) ((primitive-ref write-char) f94379 f94377))) ((primitive-ref string->list) f94376)) ((primitive-ref write-char) #\" f94377))
# tail-begin (begin ((primitive-ref write-char) #\" f94377) ((primitive-ref for-each) (closure (f94379) (f94377) (let ((f94379 f94379)) ((primitive-ref write-char) f94379 f94377))) ((primitive-ref string->list) f94376)) ((primitive-ref write-char) #\" f94377))
#   env=((f94377 . -20) (f94376 . -16) (f94377 . -12) (f94376 . -8) (f94339 . -28) (f94340 . -24) (f94341 . -20) (f94342 . -16) (f94343 . -12) (f94344 . -8) (f94345 . -4) (f94346 . 0))
# emit-expr ((primitive-ref write-char) #\" f94377)
# funcall
#    si   =-24
#    env  = ((f94377 . -20) (f94376 . -16) (f94377 . -12) (f94376 . -8) (f94339 . -28) (f94340 . -24) (f94341 . -20) (f94342 . -16) (f94343 . -12) (f94344 . -8) (f94345 . -4) (f94346 . 0))
#    expr = (funcall (primitive-ref write-char) #\" f94377)
# emit-expr (primitive-ref write-char)
    .extern mrc_write$mchar
    movl mrc_write$mchar,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_571739"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_571739":
   movl %eax,  -32(%esp)  # stash funcall-oper in closure slot
# emit-expr #\"
    movl $8719, %eax     # immed #\"
    mov %eax, -36(%esp)  # arg "
# emit-expr f94377
# emit-variable-ref
# env=((f94377 . -20) (f94376 . -16) (f94377 . -12) (f94376 . -8) (f94339 . -28) (f94340 . -24) (f94341 . -20) (f94342 . -16) (f94343 . -12) (f94344 . -8) (f94345 . -4) (f94346 . 0))
# var=f94377
    movl -20(%esp), %eax  # stack load f94377
# end emit-variable-ref
    mov %eax, -40(%esp)  # arg f94377
    movl -32(%esp), %edi   # load new closure to %edi
    add $-24, %esp   # adjust base
    movl $8,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $24, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
# emit-tail-expr
# si=-24
# env=((f94377 . -20) (f94376 . -16) (f94377 . -12) (f94376 . -8) (f94339 . -28) (f94340 . -24) (f94341 . -20) (f94342 . -16) (f94343 . -12) (f94344 . -8) (f94345 . -4) (f94346 . 0))
# expr=(begin ((primitive-ref for-each) (closure (f94379) (f94377) (let ((f94379 f94379)) ((primitive-ref write-char) f94379 f94377))) ((primitive-ref string->list) f94376)) ((primitive-ref write-char) #\" f94377))
# tail-begin (begin ((primitive-ref for-each) (closure (f94379) (f94377) (let ((f94379 f94379)) ((primitive-ref write-char) f94379 f94377))) ((primitive-ref string->list) f94376)) ((primitive-ref write-char) #\" f94377))
#   env=((f94377 . -20) (f94376 . -16) (f94377 . -12) (f94376 . -8) (f94339 . -28) (f94340 . -24) (f94341 . -20) (f94342 . -16) (f94343 . -12) (f94344 . -8) (f94345 . -4) (f94346 . 0))
# emit-expr ((primitive-ref for-each) (closure (f94379) (f94377) (let ((f94379 f94379)) ((primitive-ref write-char) f94379 f94377))) ((primitive-ref string->list) f94376))
# funcall
#    si   =-24
#    env  = ((f94377 . -20) (f94376 . -16) (f94377 . -12) (f94376 . -8) (f94339 . -28) (f94340 . -24) (f94341 . -20) (f94342 . -16) (f94343 . -12) (f94344 . -8) (f94345 . -4) (f94346 . 0))
#    expr = (funcall (primitive-ref for-each) (closure (f94379) (f94377) (let ((f94379 f94379)) ((primitive-ref write-char) f94379 f94377))) ((primitive-ref string->list) f94376))
# emit-expr (primitive-ref for-each)
    .extern mrc_for$meach
    movl mrc_for$meach,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_571740"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_571740":
   movl %eax,  -32(%esp)  # stash funcall-oper in closure slot
# emit-expr (closure (f94379) (f94377) (let ((f94379 f94379)) ((primitive-ref write-char) f94379 f94377)))
# emit-closure
# si = -36
# env = ((f94377 . -20) (f94376 . -16) (f94377 . -12) (f94376 . -8) (f94339 . -28) (f94340 . -24) (f94341 . -20) (f94342 . -16) (f94343 . -12) (f94344 . -8) (f94345 . -4) (f94346 . 0))
# expr = (closure (f94379) (f94377) (let ((f94379 f94379)) ((primitive-ref write-char) f94379 f94377)))
    movl $_L_571741, 0(%ebp)  # closure label
# emit-variable-ref
# env=((f94377 . -20) (f94376 . -16) (f94377 . -12) (f94376 . -8) (f94339 . -28) (f94340 . -24) (f94341 . -20) (f94342 . -16) (f94343 . -12) (f94344 . -8) (f94345 . -4) (f94346 . 0))
# var=f94377
    movl -20(%esp), %eax  # stack load f94377
# end emit-variable-ref
   movl  %eax, 4(%ebp)  # f94377
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $8, %ebp     # bump ebp
    jmp _L_571742            # jump around closure body
_L_571741:
# check argument count
    cmp $4,%eax
    je _L_571743
# invoke error handler eh_argcount
    .extern mrc_eh$uargcount
    movl mrc_eh$uargcount, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_571743:
# emit-tail-expr
# si=-12
# env=((f94379 . -8) (f94377 . 4) (f94377 . -20) (f94376 . -16) (f94377 . -12) (f94376 . -8) (f94339 . -28) (f94340 . -24) (f94341 . -20) (f94342 . -16) (f94343 . -12) (f94344 . -8) (f94345 . -4) (f94346 . 0))
# expr=(let ((f94379 f94379)) ((primitive-ref write-char) f94379 f94377))
# emit-tail-let
#  si   = -12
#  env  = ((f94379 . -8) (f94377 . 4) (f94377 . -20) (f94376 . -16) (f94377 . -12) (f94376 . -8) (f94339 . -28) (f94340 . -24) (f94341 . -20) (f94342 . -16) (f94343 . -12) (f94344 . -8) (f94345 . -4) (f94346 . 0))
#  bindings = ((f94379 f94379))
#  body = ((primitive-ref write-char) f94379 f94377)
# emit-expr f94379
# emit-variable-ref
# env=((f94379 . -8) (f94377 . 4) (f94377 . -20) (f94376 . -16) (f94377 . -12) (f94376 . -8) (f94339 . -28) (f94340 . -24) (f94341 . -20) (f94342 . -16) (f94343 . -12) (f94344 . -8) (f94345 . -4) (f94346 . 0))
# var=f94379
    movl -8(%esp), %eax  # stack load f94379
# end emit-variable-ref
    movl %eax, -12(%esp)  # stack save
# emit-tail-expr
# si=-16
# env=((f94379 . -12) (f94379 . -8) (f94377 . 4) (f94377 . -20) (f94376 . -16) (f94377 . -12) (f94376 . -8) (f94339 . -28) (f94340 . -24) (f94341 . -20) (f94342 . -16) (f94343 . -12) (f94344 . -8) (f94345 . -4) (f94346 . 0))
# expr=((primitive-ref write-char) f94379 f94377)
# emit-tail-funcall
#    si   =-16
#    env  = ((f94379 . -12) (f94379 . -8) (f94377 . 4) (f94377 . -20) (f94376 . -16) (f94377 . -12) (f94376 . -8) (f94339 . -28) (f94340 . -24) (f94341 . -20) (f94342 . -16) (f94343 . -12) (f94344 . -8) (f94345 . -4) (f94346 . 0))
#    expr = (funcall (primitive-ref write-char) f94379 f94377)
# emit-expr (primitive-ref write-char)
    .extern mrc_write$mchar
    movl mrc_write$mchar,%eax
   movl %eax,  -16(%esp)  # stash funcall-oper in next closure slot
# emit-expr f94379
# emit-variable-ref
# env=((f94379 . -12) (f94379 . -8) (f94377 . 4) (f94377 . -20) (f94376 . -16) (f94377 . -12) (f94376 . -8) (f94339 . -28) (f94340 . -24) (f94341 . -20) (f94342 . -16) (f94343 . -12) (f94344 . -8) (f94345 . -4) (f94346 . 0))
# var=f94379
    movl -12(%esp), %eax  # stack load f94379
# end emit-variable-ref
    mov %eax, -20(%esp)    # arg f94379
# emit-expr f94377
# emit-variable-ref
# env=((f94379 . -12) (f94379 . -8) (f94377 . 4) (f94377 . -20) (f94376 . -16) (f94377 . -12) (f94376 . -8) (f94339 . -28) (f94340 . -24) (f94341 . -20) (f94342 . -16) (f94343 . -12) (f94344 . -8) (f94345 . -4) (f94346 . 0))
# var=f94377
    movl 2(%edi), %eax  # frame load f94377
# end emit-variable-ref
    mov %eax, -24(%esp)    # arg f94377
    movl -16(%esp), %edi   # load new closure to %edi
# emit-shift-args:  size=3   si=-16  delta=12
    mov -16(%esp), %ebx  # shift frame cell
    mov %ebx, -4(%esp)  # down to base
# emit-shift-args:  size=2   si=-20  delta=12
    mov -20(%esp), %ebx  # shift frame cell
    mov %ebx, -8(%esp)  # down to base
# emit-shift-args:  size=1   si=-24  delta=12
    mov -24(%esp), %ebx  # shift frame cell
    mov %ebx, -12(%esp)  # down to base
# emit-shift-args:  size=0   si=-28  delta=12
    movl $8,%eax   # save arg count
    jmp *-2(%edi)  # tail-funcall
    .align 4,0x90
_L_571742:
    mov %eax, -36(%esp)  # arg (closure (f94379) (f94377) (let ((f94379 f94379)) ((primitive-ref write-char) f94379 f94377)))
# emit-expr ((primitive-ref string->list) f94376)
# funcall
#    si   =-40
#    env  = ((f94377 . -20) (f94376 . -16) (f94377 . -12) (f94376 . -8) (f94339 . -28) (f94340 . -24) (f94341 . -20) (f94342 . -16) (f94343 . -12) (f94344 . -8) (f94345 . -4) (f94346 . 0))
#    expr = (funcall (primitive-ref string->list) f94376)
# emit-expr (primitive-ref string->list)
    .extern mrc_string$m$glist
    movl mrc_string$m$glist,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_571744"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_571744":
   movl %eax,  -48(%esp)  # stash funcall-oper in closure slot
# emit-expr f94376
# emit-variable-ref
# env=((f94377 . -20) (f94376 . -16) (f94377 . -12) (f94376 . -8) (f94339 . -28) (f94340 . -24) (f94341 . -20) (f94342 . -16) (f94343 . -12) (f94344 . -8) (f94345 . -4) (f94346 . 0))
# var=f94376
    movl -16(%esp), %eax  # stack load f94376
# end emit-variable-ref
    mov %eax, -52(%esp)  # arg f94376
    movl -48(%esp), %edi   # load new closure to %edi
    add $-40, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $40, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    mov %eax, -40(%esp)  # arg ((primitive-ref string->list) f94376)
    movl -32(%esp), %edi   # load new closure to %edi
    add $-24, %esp   # adjust base
    movl $8,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $24, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
# emit-tail-expr
# si=-24
# env=((f94377 . -20) (f94376 . -16) (f94377 . -12) (f94376 . -8) (f94339 . -28) (f94340 . -24) (f94341 . -20) (f94342 . -16) (f94343 . -12) (f94344 . -8) (f94345 . -4) (f94346 . 0))
# expr=(begin ((primitive-ref write-char) #\" f94377))
# tail-begin (begin ((primitive-ref write-char) #\" f94377))
#   env=((f94377 . -20) (f94376 . -16) (f94377 . -12) (f94376 . -8) (f94339 . -28) (f94340 . -24) (f94341 . -20) (f94342 . -16) (f94343 . -12) (f94344 . -8) (f94345 . -4) (f94346 . 0))
# emit-tail-expr
# si=-24
# env=((f94377 . -20) (f94376 . -16) (f94377 . -12) (f94376 . -8) (f94339 . -28) (f94340 . -24) (f94341 . -20) (f94342 . -16) (f94343 . -12) (f94344 . -8) (f94345 . -4) (f94346 . 0))
# expr=((primitive-ref write-char) #\" f94377)
# emit-tail-funcall
#    si   =-24
#    env  = ((f94377 . -20) (f94376 . -16) (f94377 . -12) (f94376 . -8) (f94339 . -28) (f94340 . -24) (f94341 . -20) (f94342 . -16) (f94343 . -12) (f94344 . -8) (f94345 . -4) (f94346 . 0))
#    expr = (funcall (primitive-ref write-char) #\" f94377)
# emit-expr (primitive-ref write-char)
    .extern mrc_write$mchar
    movl mrc_write$mchar,%eax
   movl %eax,  -24(%esp)  # stash funcall-oper in next closure slot
# emit-expr #\"
    movl $8719, %eax     # immed #\"
    mov %eax, -28(%esp)    # arg "
# emit-expr f94377
# emit-variable-ref
# env=((f94377 . -20) (f94376 . -16) (f94377 . -12) (f94376 . -8) (f94339 . -28) (f94340 . -24) (f94341 . -20) (f94342 . -16) (f94343 . -12) (f94344 . -8) (f94345 . -4) (f94346 . 0))
# var=f94377
    movl -20(%esp), %eax  # stack load f94377
# end emit-variable-ref
    mov %eax, -32(%esp)    # arg f94377
    movl -24(%esp), %edi   # load new closure to %edi
# emit-shift-args:  size=3   si=-24  delta=20
    mov -24(%esp), %ebx  # shift frame cell
    mov %ebx, -4(%esp)  # down to base
# emit-shift-args:  size=2   si=-28  delta=20
    mov -28(%esp), %ebx  # shift frame cell
    mov %ebx, -8(%esp)  # down to base
# emit-shift-args:  size=1   si=-32  delta=20
    mov -32(%esp), %ebx  # shift frame cell
    mov %ebx, -12(%esp)  # down to base
# emit-shift-args:  size=0   si=-36  delta=20
    movl $8,%eax   # save arg count
    jmp *-2(%edi)  # tail-funcall
     ret   # return thru stack
    .align 4,0x90
_L_571737:
    movl -32(%esp), %ebx
    movl -36(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin (vector-set! f94341 0 (closure (f94372 f94373) () (let ((f94372 f94372) (f94373 f94373)) ((primitive-ref for-each) (closure (f94375) (f94373) (let ((f94375 f94375)) ((primitive-ref write-char) f94375 f94373))) ((primitive-ref string->list) f94372))))) (vector-set! f94340 0 (closure (f94370 f94371) (f94339) (let ((f94370 f94370) (f94371 f94371)) (begin ((primitive-ref write-char) #\( f94371) ((vector-ref f94339 0) f94370 f94371) ((primitive-ref write-char) #\) f94371))))) (vector-set! f94339 0 (closure (f94368 f94369) (f94339) (let ((f94368 f94368) (f94369 f94369)) (begin ((primitive-ref write) (car f94368) f94369) (if (null? (cdr f94368)) #t (if (pair? (cdr f94368)) (begin ((primitive-ref write-char) #\space f94369) ((vector-ref f94339 0) (cdr f94368) f94369)) (begin ((primitive-ref write-char) #\space f94369) ((primitive-ref write-char) #\. f94369) ((primitive-ref write-char) #\space f94369) ((primitive-ref write) (cdr f94368) f94369)))))))))
# emit-begin
#   expr=(begin (vector-set! f94341 0 (closure (f94372 f94373) () (let ((f94372 f94372) (f94373 f94373)) ((primitive-ref for-each) (closure (f94375) (f94373) (let ((f94375 f94375)) ((primitive-ref write-char) f94375 f94373))) ((primitive-ref string->list) f94372))))) (vector-set! f94340 0 (closure (f94370 f94371) (f94339) (let ((f94370 f94370) (f94371 f94371)) (begin ((primitive-ref write-char) #\( f94371) ((vector-ref f94339 0) f94370 f94371) ((primitive-ref write-char) #\) f94371))))) (vector-set! f94339 0 (closure (f94368 f94369) (f94339) (let ((f94368 f94368) (f94369 f94369)) (begin ((primitive-ref write) (car f94368) f94369) (if (null? (cdr f94368)) #t (if (pair? (cdr f94368)) (begin ((primitive-ref write-char) #\space f94369) ((vector-ref f94339 0) (cdr f94368) f94369)) (begin ((primitive-ref write-char) #\space f94369) ((primitive-ref write-char) #\. f94369) ((primitive-ref write-char) #\space f94369) ((primitive-ref write) (cdr f94368) f94369)))))))))
#   env=((f94339 . -28) (f94340 . -24) (f94341 . -20) (f94342 . -16) (f94343 . -12) (f94344 . -8) (f94345 . -4) (f94346 . 0))
# emit-expr (vector-set! f94341 0 (closure (f94372 f94373) () (let ((f94372 f94372) (f94373 f94373)) ((primitive-ref for-each) (closure (f94375) (f94373) (let ((f94375 f94375)) ((primitive-ref write-char) f94375 f94373))) ((primitive-ref string->list) f94372)))))
# emit-expr f94341
# emit-variable-ref
# env=((f94339 . -28) (f94340 . -24) (f94341 . -20) (f94342 . -16) (f94343 . -12) (f94344 . -8) (f94345 . -4) (f94346 . 0))
# var=f94341
    movl -20(%esp), %eax  # stack load f94341
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_571745
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_571745:
    movl %eax, -32(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_571746"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_571746:
# check bounds on vector index
    movl -32(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_571748
    cmp  $0,%eax
    jge _L_571747
_L_571748:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_571747:
    movl %eax, -36(%esp)
# emit-expr (closure (f94372 f94373) () (let ((f94372 f94372) (f94373 f94373)) ((primitive-ref for-each) (closure (f94375) (f94373) (let ((f94375 f94375)) ((primitive-ref write-char) f94375 f94373))) ((primitive-ref string->list) f94372))))
# emit-closure
# si = -40
# env = ((f94339 . -28) (f94340 . -24) (f94341 . -20) (f94342 . -16) (f94343 . -12) (f94344 . -8) (f94345 . -4) (f94346 . 0))
# expr = (closure (f94372 f94373) () (let ((f94372 f94372) (f94373 f94373)) ((primitive-ref for-each) (closure (f94375) (f94373) (let ((f94375 f94375)) ((primitive-ref write-char) f94375 f94373))) ((primitive-ref string->list) f94372))))
    movl $_L_571749, 0(%ebp)  # closure label
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $8, %ebp     # bump ebp
    jmp _L_571750            # jump around closure body
_L_571749:
# check argument count
    cmp $8,%eax
    je _L_571751
# invoke error handler eh_argcount
    .extern mrc_eh$uargcount
    movl mrc_eh$uargcount, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_571751:
# emit-tail-expr
# si=-16
# env=((f94373 . -12) (f94372 . -8) (f94339 . -28) (f94340 . -24) (f94341 . -20) (f94342 . -16) (f94343 . -12) (f94344 . -8) (f94345 . -4) (f94346 . 0))
# expr=(let ((f94372 f94372) (f94373 f94373)) ((primitive-ref for-each) (closure (f94375) (f94373) (let ((f94375 f94375)) ((primitive-ref write-char) f94375 f94373))) ((primitive-ref string->list) f94372)))
# emit-tail-let
#  si   = -16
#  env  = ((f94373 . -12) (f94372 . -8) (f94339 . -28) (f94340 . -24) (f94341 . -20) (f94342 . -16) (f94343 . -12) (f94344 . -8) (f94345 . -4) (f94346 . 0))
#  bindings = ((f94372 f94372) (f94373 f94373))
#  body = ((primitive-ref for-each) (closure (f94375) (f94373) (let ((f94375 f94375)) ((primitive-ref write-char) f94375 f94373))) ((primitive-ref string->list) f94372))
# emit-expr f94372
# emit-variable-ref
# env=((f94373 . -12) (f94372 . -8) (f94339 . -28) (f94340 . -24) (f94341 . -20) (f94342 . -16) (f94343 . -12) (f94344 . -8) (f94345 . -4) (f94346 . 0))
# var=f94372
    movl -8(%esp), %eax  # stack load f94372
# end emit-variable-ref
    movl %eax, -16(%esp)  # stack save
# emit-expr f94373
# emit-variable-ref
# env=((f94373 . -12) (f94372 . -8) (f94339 . -28) (f94340 . -24) (f94341 . -20) (f94342 . -16) (f94343 . -12) (f94344 . -8) (f94345 . -4) (f94346 . 0))
# var=f94373
    movl -12(%esp), %eax  # stack load f94373
# end emit-variable-ref
    movl %eax, -20(%esp)  # stack save
# emit-tail-expr
# si=-24
# env=((f94373 . -20) (f94372 . -16) (f94373 . -12) (f94372 . -8) (f94339 . -28) (f94340 . -24) (f94341 . -20) (f94342 . -16) (f94343 . -12) (f94344 . -8) (f94345 . -4) (f94346 . 0))
# expr=((primitive-ref for-each) (closure (f94375) (f94373) (let ((f94375 f94375)) ((primitive-ref write-char) f94375 f94373))) ((primitive-ref string->list) f94372))
# emit-tail-funcall
#    si   =-24
#    env  = ((f94373 . -20) (f94372 . -16) (f94373 . -12) (f94372 . -8) (f94339 . -28) (f94340 . -24) (f94341 . -20) (f94342 . -16) (f94343 . -12) (f94344 . -8) (f94345 . -4) (f94346 . 0))
#    expr = (funcall (primitive-ref for-each) (closure (f94375) (f94373) (let ((f94375 f94375)) ((primitive-ref write-char) f94375 f94373))) ((primitive-ref string->list) f94372))
# emit-expr (primitive-ref for-each)
    .extern mrc_for$meach
    movl mrc_for$meach,%eax
   movl %eax,  -24(%esp)  # stash funcall-oper in next closure slot
# emit-expr (closure (f94375) (f94373) (let ((f94375 f94375)) ((primitive-ref write-char) f94375 f94373)))
# emit-closure
# si = -28
# env = ((f94373 . -20) (f94372 . -16) (f94373 . -12) (f94372 . -8) (f94339 . -28) (f94340 . -24) (f94341 . -20) (f94342 . -16) (f94343 . -12) (f94344 . -8) (f94345 . -4) (f94346 . 0))
# expr = (closure (f94375) (f94373) (let ((f94375 f94375)) ((primitive-ref write-char) f94375 f94373)))
    movl $_L_571752, 0(%ebp)  # closure label
# emit-variable-ref
# env=((f94373 . -20) (f94372 . -16) (f94373 . -12) (f94372 . -8) (f94339 . -28) (f94340 . -24) (f94341 . -20) (f94342 . -16) (f94343 . -12) (f94344 . -8) (f94345 . -4) (f94346 . 0))
# var=f94373
    movl -20(%esp), %eax  # stack load f94373
# end emit-variable-ref
   movl  %eax, 4(%ebp)  # f94373
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $8, %ebp     # bump ebp
    jmp _L_571753            # jump around closure body
_L_571752:
# check argument count
    cmp $4,%eax
    je _L_571754
# invoke error handler eh_argcount
    .extern mrc_eh$uargcount
    movl mrc_eh$uargcount, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_571754:
# emit-tail-expr
# si=-12
# env=((f94375 . -8) (f94373 . 4) (f94373 . -20) (f94372 . -16) (f94373 . -12) (f94372 . -8) (f94339 . -28) (f94340 . -24) (f94341 . -20) (f94342 . -16) (f94343 . -12) (f94344 . -8) (f94345 . -4) (f94346 . 0))
# expr=(let ((f94375 f94375)) ((primitive-ref write-char) f94375 f94373))
# emit-tail-let
#  si   = -12
#  env  = ((f94375 . -8) (f94373 . 4) (f94373 . -20) (f94372 . -16) (f94373 . -12) (f94372 . -8) (f94339 . -28) (f94340 . -24) (f94341 . -20) (f94342 . -16) (f94343 . -12) (f94344 . -8) (f94345 . -4) (f94346 . 0))
#  bindings = ((f94375 f94375))
#  body = ((primitive-ref write-char) f94375 f94373)
# emit-expr f94375
# emit-variable-ref
# env=((f94375 . -8) (f94373 . 4) (f94373 . -20) (f94372 . -16) (f94373 . -12) (f94372 . -8) (f94339 . -28) (f94340 . -24) (f94341 . -20) (f94342 . -16) (f94343 . -12) (f94344 . -8) (f94345 . -4) (f94346 . 0))
# var=f94375
    movl -8(%esp), %eax  # stack load f94375
# end emit-variable-ref
    movl %eax, -12(%esp)  # stack save
# emit-tail-expr
# si=-16
# env=((f94375 . -12) (f94375 . -8) (f94373 . 4) (f94373 . -20) (f94372 . -16) (f94373 . -12) (f94372 . -8) (f94339 . -28) (f94340 . -24) (f94341 . -20) (f94342 . -16) (f94343 . -12) (f94344 . -8) (f94345 . -4) (f94346 . 0))
# expr=((primitive-ref write-char) f94375 f94373)
# emit-tail-funcall
#    si   =-16
#    env  = ((f94375 . -12) (f94375 . -8) (f94373 . 4) (f94373 . -20) (f94372 . -16) (f94373 . -12) (f94372 . -8) (f94339 . -28) (f94340 . -24) (f94341 . -20) (f94342 . -16) (f94343 . -12) (f94344 . -8) (f94345 . -4) (f94346 . 0))
#    expr = (funcall (primitive-ref write-char) f94375 f94373)
# emit-expr (primitive-ref write-char)
    .extern mrc_write$mchar
    movl mrc_write$mchar,%eax
   movl %eax,  -16(%esp)  # stash funcall-oper in next closure slot
# emit-expr f94375
# emit-variable-ref
# env=((f94375 . -12) (f94375 . -8) (f94373 . 4) (f94373 . -20) (f94372 . -16) (f94373 . -12) (f94372 . -8) (f94339 . -28) (f94340 . -24) (f94341 . -20) (f94342 . -16) (f94343 . -12) (f94344 . -8) (f94345 . -4) (f94346 . 0))
# var=f94375
    movl -12(%esp), %eax  # stack load f94375
# end emit-variable-ref
    mov %eax, -20(%esp)    # arg f94375
# emit-expr f94373
# emit-variable-ref
# env=((f94375 . -12) (f94375 . -8) (f94373 . 4) (f94373 . -20) (f94372 . -16) (f94373 . -12) (f94372 . -8) (f94339 . -28) (f94340 . -24) (f94341 . -20) (f94342 . -16) (f94343 . -12) (f94344 . -8) (f94345 . -4) (f94346 . 0))
# var=f94373
    movl 2(%edi), %eax  # frame load f94373
# end emit-variable-ref
    mov %eax, -24(%esp)    # arg f94373
    movl -16(%esp), %edi   # load new closure to %edi
# emit-shift-args:  size=3   si=-16  delta=12
    mov -16(%esp), %ebx  # shift frame cell
    mov %ebx, -4(%esp)  # down to base
# emit-shift-args:  size=2   si=-20  delta=12
    mov -20(%esp), %ebx  # shift frame cell
    mov %ebx, -8(%esp)  # down to base
# emit-shift-args:  size=1   si=-24  delta=12
    mov -24(%esp), %ebx  # shift frame cell
    mov %ebx, -12(%esp)  # down to base
# emit-shift-args:  size=0   si=-28  delta=12
    movl $8,%eax   # save arg count
    jmp *-2(%edi)  # tail-funcall
    .align 4,0x90
_L_571753:
    mov %eax, -28(%esp)    # arg (closure (f94375) (f94373) (let ((f94375 f94375)) ((primitive-ref write-char) f94375 f94373)))
# emit-expr ((primitive-ref string->list) f94372)
# funcall
#    si   =-32
#    env  = ((f94373 . -20) (f94372 . -16) (f94373 . -12) (f94372 . -8) (f94339 . -28) (f94340 . -24) (f94341 . -20) (f94342 . -16) (f94343 . -12) (f94344 . -8) (f94345 . -4) (f94346 . 0))
#    expr = (funcall (primitive-ref string->list) f94372)
# emit-expr (primitive-ref string->list)
    .extern mrc_string$m$glist
    movl mrc_string$m$glist,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_571755"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_571755":
   movl %eax,  -40(%esp)  # stash funcall-oper in closure slot
# emit-expr f94372
# emit-variable-ref
# env=((f94373 . -20) (f94372 . -16) (f94373 . -12) (f94372 . -8) (f94339 . -28) (f94340 . -24) (f94341 . -20) (f94342 . -16) (f94343 . -12) (f94344 . -8) (f94345 . -4) (f94346 . 0))
# var=f94372
    movl -16(%esp), %eax  # stack load f94372
# end emit-variable-ref
    mov %eax, -44(%esp)  # arg f94372
    movl -40(%esp), %edi   # load new closure to %edi
    add $-32, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $32, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    mov %eax, -32(%esp)    # arg ((primitive-ref string->list) f94372)
    movl -24(%esp), %edi   # load new closure to %edi
# emit-shift-args:  size=3   si=-24  delta=20
    mov -24(%esp), %ebx  # shift frame cell
    mov %ebx, -4(%esp)  # down to base
# emit-shift-args:  size=2   si=-28  delta=20
    mov -28(%esp), %ebx  # shift frame cell
    mov %ebx, -8(%esp)  # down to base
# emit-shift-args:  size=1   si=-32  delta=20
    mov -32(%esp), %ebx  # shift frame cell
    mov %ebx, -12(%esp)  # down to base
# emit-shift-args:  size=0   si=-36  delta=20
    movl $8,%eax   # save arg count
    jmp *-2(%edi)  # tail-funcall
    .align 4,0x90
_L_571750:
    movl -32(%esp), %ebx
    movl -36(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin (vector-set! f94340 0 (closure (f94370 f94371) (f94339) (let ((f94370 f94370) (f94371 f94371)) (begin ((primitive-ref write-char) #\( f94371) ((vector-ref f94339 0) f94370 f94371) ((primitive-ref write-char) #\) f94371))))) (vector-set! f94339 0 (closure (f94368 f94369) (f94339) (let ((f94368 f94368) (f94369 f94369)) (begin ((primitive-ref write) (car f94368) f94369) (if (null? (cdr f94368)) #t (if (pair? (cdr f94368)) (begin ((primitive-ref write-char) #\space f94369) ((vector-ref f94339 0) (cdr f94368) f94369)) (begin ((primitive-ref write-char) #\space f94369) ((primitive-ref write-char) #\. f94369) ((primitive-ref write-char) #\space f94369) ((primitive-ref write) (cdr f94368) f94369)))))))))
# emit-begin
#   expr=(begin (vector-set! f94340 0 (closure (f94370 f94371) (f94339) (let ((f94370 f94370) (f94371 f94371)) (begin ((primitive-ref write-char) #\( f94371) ((vector-ref f94339 0) f94370 f94371) ((primitive-ref write-char) #\) f94371))))) (vector-set! f94339 0 (closure (f94368 f94369) (f94339) (let ((f94368 f94368) (f94369 f94369)) (begin ((primitive-ref write) (car f94368) f94369) (if (null? (cdr f94368)) #t (if (pair? (cdr f94368)) (begin ((primitive-ref write-char) #\space f94369) ((vector-ref f94339 0) (cdr f94368) f94369)) (begin ((primitive-ref write-char) #\space f94369) ((primitive-ref write-char) #\. f94369) ((primitive-ref write-char) #\space f94369) ((primitive-ref write) (cdr f94368) f94369)))))))))
#   env=((f94339 . -28) (f94340 . -24) (f94341 . -20) (f94342 . -16) (f94343 . -12) (f94344 . -8) (f94345 . -4) (f94346 . 0))
# emit-expr (vector-set! f94340 0 (closure (f94370 f94371) (f94339) (let ((f94370 f94370) (f94371 f94371)) (begin ((primitive-ref write-char) #\( f94371) ((vector-ref f94339 0) f94370 f94371) ((primitive-ref write-char) #\) f94371)))))
# emit-expr f94340
# emit-variable-ref
# env=((f94339 . -28) (f94340 . -24) (f94341 . -20) (f94342 . -16) (f94343 . -12) (f94344 . -8) (f94345 . -4) (f94346 . 0))
# var=f94340
    movl -24(%esp), %eax  # stack load f94340
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_571756
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_571756:
    movl %eax, -32(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_571757"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_571757:
# check bounds on vector index
    movl -32(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_571759
    cmp  $0,%eax
    jge _L_571758
_L_571759:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_571758:
    movl %eax, -36(%esp)
# emit-expr (closure (f94370 f94371) (f94339) (let ((f94370 f94370) (f94371 f94371)) (begin ((primitive-ref write-char) #\( f94371) ((vector-ref f94339 0) f94370 f94371) ((primitive-ref write-char) #\) f94371))))
# emit-closure
# si = -40
# env = ((f94339 . -28) (f94340 . -24) (f94341 . -20) (f94342 . -16) (f94343 . -12) (f94344 . -8) (f94345 . -4) (f94346 . 0))
# expr = (closure (f94370 f94371) (f94339) (let ((f94370 f94370) (f94371 f94371)) (begin ((primitive-ref write-char) #\( f94371) ((vector-ref f94339 0) f94370 f94371) ((primitive-ref write-char) #\) f94371))))
    movl $_L_571760, 0(%ebp)  # closure label
# emit-variable-ref
# env=((f94339 . -28) (f94340 . -24) (f94341 . -20) (f94342 . -16) (f94343 . -12) (f94344 . -8) (f94345 . -4) (f94346 . 0))
# var=f94339
    movl -28(%esp), %eax  # stack load f94339
# end emit-variable-ref
   movl  %eax, 4(%ebp)  # f94339
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $8, %ebp     # bump ebp
    jmp _L_571761            # jump around closure body
_L_571760:
# check argument count
    cmp $8,%eax
    je _L_571762
# invoke error handler eh_argcount
    .extern mrc_eh$uargcount
    movl mrc_eh$uargcount, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_571762:
# emit-tail-expr
# si=-16
# env=((f94371 . -12) (f94370 . -8) (f94339 . 4) (f94339 . -28) (f94340 . -24) (f94341 . -20) (f94342 . -16) (f94343 . -12) (f94344 . -8) (f94345 . -4) (f94346 . 0))
# expr=(let ((f94370 f94370) (f94371 f94371)) (begin ((primitive-ref write-char) #\( f94371) ((vector-ref f94339 0) f94370 f94371) ((primitive-ref write-char) #\) f94371)))
# emit-tail-let
#  si   = -16
#  env  = ((f94371 . -12) (f94370 . -8) (f94339 . 4) (f94339 . -28) (f94340 . -24) (f94341 . -20) (f94342 . -16) (f94343 . -12) (f94344 . -8) (f94345 . -4) (f94346 . 0))
#  bindings = ((f94370 f94370) (f94371 f94371))
#  body = (begin ((primitive-ref write-char) #\( f94371) ((vector-ref f94339 0) f94370 f94371) ((primitive-ref write-char) #\) f94371))
# emit-expr f94370
# emit-variable-ref
# env=((f94371 . -12) (f94370 . -8) (f94339 . 4) (f94339 . -28) (f94340 . -24) (f94341 . -20) (f94342 . -16) (f94343 . -12) (f94344 . -8) (f94345 . -4) (f94346 . 0))
# var=f94370
    movl -8(%esp), %eax  # stack load f94370
# end emit-variable-ref
    movl %eax, -16(%esp)  # stack save
# emit-expr f94371
# emit-variable-ref
# env=((f94371 . -12) (f94370 . -8) (f94339 . 4) (f94339 . -28) (f94340 . -24) (f94341 . -20) (f94342 . -16) (f94343 . -12) (f94344 . -8) (f94345 . -4) (f94346 . 0))
# var=f94371
    movl -12(%esp), %eax  # stack load f94371
# end emit-variable-ref
    movl %eax, -20(%esp)  # stack save
# emit-tail-expr
# si=-24
# env=((f94371 . -20) (f94370 . -16) (f94371 . -12) (f94370 . -8) (f94339 . 4) (f94339 . -28) (f94340 . -24) (f94341 . -20) (f94342 . -16) (f94343 . -12) (f94344 . -8) (f94345 . -4) (f94346 . 0))
# expr=(begin ((primitive-ref write-char) #\( f94371) ((vector-ref f94339 0) f94370 f94371) ((primitive-ref write-char) #\) f94371))
# tail-begin (begin ((primitive-ref write-char) #\( f94371) ((vector-ref f94339 0) f94370 f94371) ((primitive-ref write-char) #\) f94371))
#   env=((f94371 . -20) (f94370 . -16) (f94371 . -12) (f94370 . -8) (f94339 . 4) (f94339 . -28) (f94340 . -24) (f94341 . -20) (f94342 . -16) (f94343 . -12) (f94344 . -8) (f94345 . -4) (f94346 . 0))
# emit-expr ((primitive-ref write-char) #\( f94371)
# funcall
#    si   =-24
#    env  = ((f94371 . -20) (f94370 . -16) (f94371 . -12) (f94370 . -8) (f94339 . 4) (f94339 . -28) (f94340 . -24) (f94341 . -20) (f94342 . -16) (f94343 . -12) (f94344 . -8) (f94345 . -4) (f94346 . 0))
#    expr = (funcall (primitive-ref write-char) #\( f94371)
# emit-expr (primitive-ref write-char)
    .extern mrc_write$mchar
    movl mrc_write$mchar,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_571763"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_571763":
   movl %eax,  -32(%esp)  # stash funcall-oper in closure slot
# emit-expr #\(
    movl $10255, %eax     # immed #\(
    mov %eax, -36(%esp)  # arg (
# emit-expr f94371
# emit-variable-ref
# env=((f94371 . -20) (f94370 . -16) (f94371 . -12) (f94370 . -8) (f94339 . 4) (f94339 . -28) (f94340 . -24) (f94341 . -20) (f94342 . -16) (f94343 . -12) (f94344 . -8) (f94345 . -4) (f94346 . 0))
# var=f94371
    movl -20(%esp), %eax  # stack load f94371
# end emit-variable-ref
    mov %eax, -40(%esp)  # arg f94371
    movl -32(%esp), %edi   # load new closure to %edi
    add $-24, %esp   # adjust base
    movl $8,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $24, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
# emit-tail-expr
# si=-24
# env=((f94371 . -20) (f94370 . -16) (f94371 . -12) (f94370 . -8) (f94339 . 4) (f94339 . -28) (f94340 . -24) (f94341 . -20) (f94342 . -16) (f94343 . -12) (f94344 . -8) (f94345 . -4) (f94346 . 0))
# expr=(begin ((vector-ref f94339 0) f94370 f94371) ((primitive-ref write-char) #\) f94371))
# tail-begin (begin ((vector-ref f94339 0) f94370 f94371) ((primitive-ref write-char) #\) f94371))
#   env=((f94371 . -20) (f94370 . -16) (f94371 . -12) (f94370 . -8) (f94339 . 4) (f94339 . -28) (f94340 . -24) (f94341 . -20) (f94342 . -16) (f94343 . -12) (f94344 . -8) (f94345 . -4) (f94346 . 0))
# emit-expr ((vector-ref f94339 0) f94370 f94371)
# funcall
#    si   =-24
#    env  = ((f94371 . -20) (f94370 . -16) (f94371 . -12) (f94370 . -8) (f94339 . 4) (f94339 . -28) (f94340 . -24) (f94341 . -20) (f94342 . -16) (f94343 . -12) (f94344 . -8) (f94345 . -4) (f94346 . 0))
#    expr = (funcall (vector-ref f94339 0) f94370 f94371)
# emit-expr (vector-ref f94339 0)
# emit-expr f94339
# emit-variable-ref
# env=((f94371 . -20) (f94370 . -16) (f94371 . -12) (f94370 . -8) (f94339 . 4) (f94339 . -28) (f94340 . -24) (f94341 . -20) (f94342 . -16) (f94343 . -12) (f94344 . -8) (f94345 . -4) (f94346 . 0))
# var=f94339
    movl 2(%edi), %eax  # frame load f94339
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_571764
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_571764:
    movl %eax, -32(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_571765"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_571765:
# check bounds on vector index
    movl -32(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_571767
    cmp  $0,%eax
    jge _L_571766
_L_571767:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_571766:
    movl -32(%esp), %esi
    movl -1(%eax,%esi), %eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_571768"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_571768":
   movl %eax,  -32(%esp)  # stash funcall-oper in closure slot
# emit-expr f94370
# emit-variable-ref
# env=((f94371 . -20) (f94370 . -16) (f94371 . -12) (f94370 . -8) (f94339 . 4) (f94339 . -28) (f94340 . -24) (f94341 . -20) (f94342 . -16) (f94343 . -12) (f94344 . -8) (f94345 . -4) (f94346 . 0))
# var=f94370
    movl -16(%esp), %eax  # stack load f94370
# end emit-variable-ref
    mov %eax, -36(%esp)  # arg f94370
# emit-expr f94371
# emit-variable-ref
# env=((f94371 . -20) (f94370 . -16) (f94371 . -12) (f94370 . -8) (f94339 . 4) (f94339 . -28) (f94340 . -24) (f94341 . -20) (f94342 . -16) (f94343 . -12) (f94344 . -8) (f94345 . -4) (f94346 . 0))
# var=f94371
    movl -20(%esp), %eax  # stack load f94371
# end emit-variable-ref
    mov %eax, -40(%esp)  # arg f94371
    movl -32(%esp), %edi   # load new closure to %edi
    add $-24, %esp   # adjust base
    movl $8,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $24, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
# emit-tail-expr
# si=-24
# env=((f94371 . -20) (f94370 . -16) (f94371 . -12) (f94370 . -8) (f94339 . 4) (f94339 . -28) (f94340 . -24) (f94341 . -20) (f94342 . -16) (f94343 . -12) (f94344 . -8) (f94345 . -4) (f94346 . 0))
# expr=(begin ((primitive-ref write-char) #\) f94371))
# tail-begin (begin ((primitive-ref write-char) #\) f94371))
#   env=((f94371 . -20) (f94370 . -16) (f94371 . -12) (f94370 . -8) (f94339 . 4) (f94339 . -28) (f94340 . -24) (f94341 . -20) (f94342 . -16) (f94343 . -12) (f94344 . -8) (f94345 . -4) (f94346 . 0))
# emit-tail-expr
# si=-24
# env=((f94371 . -20) (f94370 . -16) (f94371 . -12) (f94370 . -8) (f94339 . 4) (f94339 . -28) (f94340 . -24) (f94341 . -20) (f94342 . -16) (f94343 . -12) (f94344 . -8) (f94345 . -4) (f94346 . 0))
# expr=((primitive-ref write-char) #\) f94371)
# emit-tail-funcall
#    si   =-24
#    env  = ((f94371 . -20) (f94370 . -16) (f94371 . -12) (f94370 . -8) (f94339 . 4) (f94339 . -28) (f94340 . -24) (f94341 . -20) (f94342 . -16) (f94343 . -12) (f94344 . -8) (f94345 . -4) (f94346 . 0))
#    expr = (funcall (primitive-ref write-char) #\) f94371)
# emit-expr (primitive-ref write-char)
    .extern mrc_write$mchar
    movl mrc_write$mchar,%eax
   movl %eax,  -24(%esp)  # stash funcall-oper in next closure slot
# emit-expr #\)
    movl $10511, %eax     # immed #\)
    mov %eax, -28(%esp)    # arg )
# emit-expr f94371
# emit-variable-ref
# env=((f94371 . -20) (f94370 . -16) (f94371 . -12) (f94370 . -8) (f94339 . 4) (f94339 . -28) (f94340 . -24) (f94341 . -20) (f94342 . -16) (f94343 . -12) (f94344 . -8) (f94345 . -4) (f94346 . 0))
# var=f94371
    movl -20(%esp), %eax  # stack load f94371
# end emit-variable-ref
    mov %eax, -32(%esp)    # arg f94371
    movl -24(%esp), %edi   # load new closure to %edi
# emit-shift-args:  size=3   si=-24  delta=20
    mov -24(%esp), %ebx  # shift frame cell
    mov %ebx, -4(%esp)  # down to base
# emit-shift-args:  size=2   si=-28  delta=20
    mov -28(%esp), %ebx  # shift frame cell
    mov %ebx, -8(%esp)  # down to base
# emit-shift-args:  size=1   si=-32  delta=20
    mov -32(%esp), %ebx  # shift frame cell
    mov %ebx, -12(%esp)  # down to base
# emit-shift-args:  size=0   si=-36  delta=20
    movl $8,%eax   # save arg count
    jmp *-2(%edi)  # tail-funcall
     ret   # return thru stack
    .align 4,0x90
_L_571761:
    movl -32(%esp), %ebx
    movl -36(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin (vector-set! f94339 0 (closure (f94368 f94369) (f94339) (let ((f94368 f94368) (f94369 f94369)) (begin ((primitive-ref write) (car f94368) f94369) (if (null? (cdr f94368)) #t (if (pair? (cdr f94368)) (begin ((primitive-ref write-char) #\space f94369) ((vector-ref f94339 0) (cdr f94368) f94369)) (begin ((primitive-ref write-char) #\space f94369) ((primitive-ref write-char) #\. f94369) ((primitive-ref write-char) #\space f94369) ((primitive-ref write) (cdr f94368) f94369)))))))))
# emit-begin
#   expr=(begin (vector-set! f94339 0 (closure (f94368 f94369) (f94339) (let ((f94368 f94368) (f94369 f94369)) (begin ((primitive-ref write) (car f94368) f94369) (if (null? (cdr f94368)) #t (if (pair? (cdr f94368)) (begin ((primitive-ref write-char) #\space f94369) ((vector-ref f94339 0) (cdr f94368) f94369)) (begin ((primitive-ref write-char) #\space f94369) ((primitive-ref write-char) #\. f94369) ((primitive-ref write-char) #\space f94369) ((primitive-ref write) (cdr f94368) f94369)))))))))
#   env=((f94339 . -28) (f94340 . -24) (f94341 . -20) (f94342 . -16) (f94343 . -12) (f94344 . -8) (f94345 . -4) (f94346 . 0))
# emit-expr (vector-set! f94339 0 (closure (f94368 f94369) (f94339) (let ((f94368 f94368) (f94369 f94369)) (begin ((primitive-ref write) (car f94368) f94369) (if (null? (cdr f94368)) #t (if (pair? (cdr f94368)) (begin ((primitive-ref write-char) #\space f94369) ((vector-ref f94339 0) (cdr f94368) f94369)) (begin ((primitive-ref write-char) #\space f94369) ((primitive-ref write-char) #\. f94369) ((primitive-ref write-char) #\space f94369) ((primitive-ref write) (cdr f94368) f94369))))))))
# emit-expr f94339
# emit-variable-ref
# env=((f94339 . -28) (f94340 . -24) (f94341 . -20) (f94342 . -16) (f94343 . -12) (f94344 . -8) (f94345 . -4) (f94346 . 0))
# var=f94339
    movl -28(%esp), %eax  # stack load f94339
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_571769
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_571769:
    movl %eax, -32(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_571770"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_571770:
# check bounds on vector index
    movl -32(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_571772
    cmp  $0,%eax
    jge _L_571771
_L_571772:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_571771:
    movl %eax, -36(%esp)
# emit-expr (closure (f94368 f94369) (f94339) (let ((f94368 f94368) (f94369 f94369)) (begin ((primitive-ref write) (car f94368) f94369) (if (null? (cdr f94368)) #t (if (pair? (cdr f94368)) (begin ((primitive-ref write-char) #\space f94369) ((vector-ref f94339 0) (cdr f94368) f94369)) (begin ((primitive-ref write-char) #\space f94369) ((primitive-ref write-char) #\. f94369) ((primitive-ref write-char) #\space f94369) ((primitive-ref write) (cdr f94368) f94369)))))))
# emit-closure
# si = -40
# env = ((f94339 . -28) (f94340 . -24) (f94341 . -20) (f94342 . -16) (f94343 . -12) (f94344 . -8) (f94345 . -4) (f94346 . 0))
# expr = (closure (f94368 f94369) (f94339) (let ((f94368 f94368) (f94369 f94369)) (begin ((primitive-ref write) (car f94368) f94369) (if (null? (cdr f94368)) #t (if (pair? (cdr f94368)) (begin ((primitive-ref write-char) #\space f94369) ((vector-ref f94339 0) (cdr f94368) f94369)) (begin ((primitive-ref write-char) #\space f94369) ((primitive-ref write-char) #\. f94369) ((primitive-ref write-char) #\space f94369) ((primitive-ref write) (cdr f94368) f94369)))))))
    movl $_L_571773, 0(%ebp)  # closure label
# emit-variable-ref
# env=((f94339 . -28) (f94340 . -24) (f94341 . -20) (f94342 . -16) (f94343 . -12) (f94344 . -8) (f94345 . -4) (f94346 . 0))
# var=f94339
    movl -28(%esp), %eax  # stack load f94339
# end emit-variable-ref
   movl  %eax, 4(%ebp)  # f94339
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $8, %ebp     # bump ebp
    jmp _L_571774            # jump around closure body
_L_571773:
# check argument count
    cmp $8,%eax
    je _L_571775
# invoke error handler eh_argcount
    .extern mrc_eh$uargcount
    movl mrc_eh$uargcount, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_571775:
# emit-tail-expr
# si=-16
# env=((f94369 . -12) (f94368 . -8) (f94339 . 4) (f94339 . -28) (f94340 . -24) (f94341 . -20) (f94342 . -16) (f94343 . -12) (f94344 . -8) (f94345 . -4) (f94346 . 0))
# expr=(let ((f94368 f94368) (f94369 f94369)) (begin ((primitive-ref write) (car f94368) f94369) (if (null? (cdr f94368)) #t (if (pair? (cdr f94368)) (begin ((primitive-ref write-char) #\space f94369) ((vector-ref f94339 0) (cdr f94368) f94369)) (begin ((primitive-ref write-char) #\space f94369) ((primitive-ref write-char) #\. f94369) ((primitive-ref write-char) #\space f94369) ((primitive-ref write) (cdr f94368) f94369))))))
# emit-tail-let
#  si   = -16
#  env  = ((f94369 . -12) (f94368 . -8) (f94339 . 4) (f94339 . -28) (f94340 . -24) (f94341 . -20) (f94342 . -16) (f94343 . -12) (f94344 . -8) (f94345 . -4) (f94346 . 0))
#  bindings = ((f94368 f94368) (f94369 f94369))
#  body = (begin ((primitive-ref write) (car f94368) f94369) (if (null? (cdr f94368)) #t (if (pair? (cdr f94368)) (begin ((primitive-ref write-char) #\space f94369) ((vector-ref f94339 0) (cdr f94368) f94369)) (begin ((primitive-ref write-char) #\space f94369) ((primitive-ref write-char) #\. f94369) ((primitive-ref write-char) #\space f94369) ((primitive-ref write) (cdr f94368) f94369)))))
# emit-expr f94368
# emit-variable-ref
# env=((f94369 . -12) (f94368 . -8) (f94339 . 4) (f94339 . -28) (f94340 . -24) (f94341 . -20) (f94342 . -16) (f94343 . -12) (f94344 . -8) (f94345 . -4) (f94346 . 0))
# var=f94368
    movl -8(%esp), %eax  # stack load f94368
# end emit-variable-ref
    movl %eax, -16(%esp)  # stack save
# emit-expr f94369
# emit-variable-ref
# env=((f94369 . -12) (f94368 . -8) (f94339 . 4) (f94339 . -28) (f94340 . -24) (f94341 . -20) (f94342 . -16) (f94343 . -12) (f94344 . -8) (f94345 . -4) (f94346 . 0))
# var=f94369
    movl -12(%esp), %eax  # stack load f94369
# end emit-variable-ref
    movl %eax, -20(%esp)  # stack save
# emit-tail-expr
# si=-24
# env=((f94369 . -20) (f94368 . -16) (f94369 . -12) (f94368 . -8) (f94339 . 4) (f94339 . -28) (f94340 . -24) (f94341 . -20) (f94342 . -16) (f94343 . -12) (f94344 . -8) (f94345 . -4) (f94346 . 0))
# expr=(begin ((primitive-ref write) (car f94368) f94369) (if (null? (cdr f94368)) #t (if (pair? (cdr f94368)) (begin ((primitive-ref write-char) #\space f94369) ((vector-ref f94339 0) (cdr f94368) f94369)) (begin ((primitive-ref write-char) #\space f94369) ((primitive-ref write-char) #\. f94369) ((primitive-ref write-char) #\space f94369) ((primitive-ref write) (cdr f94368) f94369)))))
# tail-begin (begin ((primitive-ref write) (car f94368) f94369) (if (null? (cdr f94368)) #t (if (pair? (cdr f94368)) (begin ((primitive-ref write-char) #\space f94369) ((vector-ref f94339 0) (cdr f94368) f94369)) (begin ((primitive-ref write-char) #\space f94369) ((primitive-ref write-char) #\. f94369) ((primitive-ref write-char) #\space f94369) ((primitive-ref write) (cdr f94368) f94369)))))
#   env=((f94369 . -20) (f94368 . -16) (f94369 . -12) (f94368 . -8) (f94339 . 4) (f94339 . -28) (f94340 . -24) (f94341 . -20) (f94342 . -16) (f94343 . -12) (f94344 . -8) (f94345 . -4) (f94346 . 0))
# emit-expr ((primitive-ref write) (car f94368) f94369)
# funcall
#    si   =-24
#    env  = ((f94369 . -20) (f94368 . -16) (f94369 . -12) (f94368 . -8) (f94339 . 4) (f94339 . -28) (f94340 . -24) (f94341 . -20) (f94342 . -16) (f94343 . -12) (f94344 . -8) (f94345 . -4) (f94346 . 0))
#    expr = (funcall (primitive-ref write) (car f94368) f94369)
# emit-expr (primitive-ref write)
    .extern mrc_write
    movl mrc_write,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_571776"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_571776":
   movl %eax,  -32(%esp)  # stash funcall-oper in closure slot
# emit-expr (car f94368)
# emit-expr f94368
# emit-variable-ref
# env=((f94369 . -20) (f94368 . -16) (f94369 . -12) (f94368 . -8) (f94339 . 4) (f94339 . -28) (f94340 . -24) (f94341 . -20) (f94342 . -16) (f94343 . -12) (f94344 . -8) (f94345 . -4) (f94346 . 0))
# var=f94368
    movl -16(%esp), %eax  # stack load f94368
# end emit-variable-ref
# check the argument is a pair
    movl %eax,%ebx
    and $7, %bl
    cmp $1, %bl
    je _L_571777
# invoke error handler eh_pair
    .extern mrc_eh$upair
    movl mrc_eh$upair, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $116,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_571777:
    movl -1(%eax), %eax
    mov %eax, -36(%esp)  # arg (car f94368)
# emit-expr f94369
# emit-variable-ref
# env=((f94369 . -20) (f94368 . -16) (f94369 . -12) (f94368 . -8) (f94339 . 4) (f94339 . -28) (f94340 . -24) (f94341 . -20) (f94342 . -16) (f94343 . -12) (f94344 . -8) (f94345 . -4) (f94346 . 0))
# var=f94369
    movl -20(%esp), %eax  # stack load f94369
# end emit-variable-ref
    mov %eax, -40(%esp)  # arg f94369
    movl -32(%esp), %edi   # load new closure to %edi
    add $-24, %esp   # adjust base
    movl $8,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $24, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
# emit-tail-expr
# si=-24
# env=((f94369 . -20) (f94368 . -16) (f94369 . -12) (f94368 . -8) (f94339 . 4) (f94339 . -28) (f94340 . -24) (f94341 . -20) (f94342 . -16) (f94343 . -12) (f94344 . -8) (f94345 . -4) (f94346 . 0))
# expr=(begin (if (null? (cdr f94368)) #t (if (pair? (cdr f94368)) (begin ((primitive-ref write-char) #\space f94369) ((vector-ref f94339 0) (cdr f94368) f94369)) (begin ((primitive-ref write-char) #\space f94369) ((primitive-ref write-char) #\. f94369) ((primitive-ref write-char) #\space f94369) ((primitive-ref write) (cdr f94368) f94369)))))
# tail-begin (begin (if (null? (cdr f94368)) #t (if (pair? (cdr f94368)) (begin ((primitive-ref write-char) #\space f94369) ((vector-ref f94339 0) (cdr f94368) f94369)) (begin ((primitive-ref write-char) #\space f94369) ((primitive-ref write-char) #\. f94369) ((primitive-ref write-char) #\space f94369) ((primitive-ref write) (cdr f94368) f94369)))))
#   env=((f94369 . -20) (f94368 . -16) (f94369 . -12) (f94368 . -8) (f94339 . 4) (f94339 . -28) (f94340 . -24) (f94341 . -20) (f94342 . -16) (f94343 . -12) (f94344 . -8) (f94345 . -4) (f94346 . 0))
# emit-tail-expr
# si=-24
# env=((f94369 . -20) (f94368 . -16) (f94369 . -12) (f94368 . -8) (f94339 . 4) (f94339 . -28) (f94340 . -24) (f94341 . -20) (f94342 . -16) (f94343 . -12) (f94344 . -8) (f94345 . -4) (f94346 . 0))
# expr=(if (null? (cdr f94368)) #t (if (pair? (cdr f94368)) (begin ((primitive-ref write-char) #\space f94369) ((vector-ref f94339 0) (cdr f94368) f94369)) (begin ((primitive-ref write-char) #\space f94369) ((primitive-ref write-char) #\. f94369) ((primitive-ref write-char) #\space f94369) ((primitive-ref write) (cdr f94368) f94369))))
# emit-expr (null? (cdr f94368))
# emit-expr (cdr f94368)
# emit-expr f94368
# emit-variable-ref
# env=((f94369 . -20) (f94368 . -16) (f94369 . -12) (f94368 . -8) (f94339 . 4) (f94339 . -28) (f94340 . -24) (f94341 . -20) (f94342 . -16) (f94343 . -12) (f94344 . -8) (f94345 . -4) (f94346 . 0))
# var=f94368
    movl -16(%esp), %eax  # stack load f94368
# end emit-variable-ref
# check the argument is a pair
    movl %eax,%ebx
    and $7, %bl
    cmp $1, %bl
    je _L_571780
# invoke error handler eh_pair
    .extern mrc_eh$upair
    movl mrc_eh$upair, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $120,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_571780:
    movl 3(%eax), %eax
    cmp $63, %eax
    mov $0, %eax
    sete %al
    movzbl %al, %eax
    sal $6, %al
    or $47, %al
    cmp $47, %al
    je _L_571778
# emit-tail-expr
# si=-24
# env=((f94369 . -20) (f94368 . -16) (f94369 . -12) (f94368 . -8) (f94339 . 4) (f94339 . -28) (f94340 . -24) (f94341 . -20) (f94342 . -16) (f94343 . -12) (f94344 . -8) (f94345 . -4) (f94346 . 0))
# expr=#t
    movl $111, %eax     # immed #t
    ret                  # immediate tail return
    jmp _L_571779
_L_571778:
# emit-tail-expr
# si=-24
# env=((f94369 . -20) (f94368 . -16) (f94369 . -12) (f94368 . -8) (f94339 . 4) (f94339 . -28) (f94340 . -24) (f94341 . -20) (f94342 . -16) (f94343 . -12) (f94344 . -8) (f94345 . -4) (f94346 . 0))
# expr=(if (pair? (cdr f94368)) (begin ((primitive-ref write-char) #\space f94369) ((vector-ref f94339 0) (cdr f94368) f94369)) (begin ((primitive-ref write-char) #\space f94369) ((primitive-ref write-char) #\. f94369) ((primitive-ref write-char) #\space f94369) ((primitive-ref write) (cdr f94368) f94369)))
# emit-expr (pair? (cdr f94368))
# emit-expr (cdr f94368)
# emit-expr f94368
# emit-variable-ref
# env=((f94369 . -20) (f94368 . -16) (f94369 . -12) (f94368 . -8) (f94339 . 4) (f94339 . -28) (f94340 . -24) (f94341 . -20) (f94342 . -16) (f94343 . -12) (f94344 . -8) (f94345 . -4) (f94346 . 0))
# var=f94368
    movl -16(%esp), %eax  # stack load f94368
# end emit-variable-ref
# check the argument is a pair
    movl %eax,%ebx
    and $7, %bl
    cmp $1, %bl
    je _L_571783
# invoke error handler eh_pair
    .extern mrc_eh$upair
    movl mrc_eh$upair, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $120,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_571783:
    movl 3(%eax), %eax
    and $7, %al
    cmp $1, %al
    sete %al
    movzbl %al, %eax
    sal $6, %al
    or $47, %al
    cmp $47, %al
    je _L_571781
# emit-tail-expr
# si=-24
# env=((f94369 . -20) (f94368 . -16) (f94369 . -12) (f94368 . -8) (f94339 . 4) (f94339 . -28) (f94340 . -24) (f94341 . -20) (f94342 . -16) (f94343 . -12) (f94344 . -8) (f94345 . -4) (f94346 . 0))
# expr=(begin ((primitive-ref write-char) #\space f94369) ((vector-ref f94339 0) (cdr f94368) f94369))
# tail-begin (begin ((primitive-ref write-char) #\space f94369) ((vector-ref f94339 0) (cdr f94368) f94369))
#   env=((f94369 . -20) (f94368 . -16) (f94369 . -12) (f94368 . -8) (f94339 . 4) (f94339 . -28) (f94340 . -24) (f94341 . -20) (f94342 . -16) (f94343 . -12) (f94344 . -8) (f94345 . -4) (f94346 . 0))
# emit-expr ((primitive-ref write-char) #\space f94369)
# funcall
#    si   =-24
#    env  = ((f94369 . -20) (f94368 . -16) (f94369 . -12) (f94368 . -8) (f94339 . 4) (f94339 . -28) (f94340 . -24) (f94341 . -20) (f94342 . -16) (f94343 . -12) (f94344 . -8) (f94345 . -4) (f94346 . 0))
#    expr = (funcall (primitive-ref write-char) #\space f94369)
# emit-expr (primitive-ref write-char)
    .extern mrc_write$mchar
    movl mrc_write$mchar,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_571784"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_571784":
   movl %eax,  -32(%esp)  # stash funcall-oper in closure slot
# emit-expr #\space
    movl $8207, %eax     # immed #\space
    mov %eax, -36(%esp)  # arg  
# emit-expr f94369
# emit-variable-ref
# env=((f94369 . -20) (f94368 . -16) (f94369 . -12) (f94368 . -8) (f94339 . 4) (f94339 . -28) (f94340 . -24) (f94341 . -20) (f94342 . -16) (f94343 . -12) (f94344 . -8) (f94345 . -4) (f94346 . 0))
# var=f94369
    movl -20(%esp), %eax  # stack load f94369
# end emit-variable-ref
    mov %eax, -40(%esp)  # arg f94369
    movl -32(%esp), %edi   # load new closure to %edi
    add $-24, %esp   # adjust base
    movl $8,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $24, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
# emit-tail-expr
# si=-24
# env=((f94369 . -20) (f94368 . -16) (f94369 . -12) (f94368 . -8) (f94339 . 4) (f94339 . -28) (f94340 . -24) (f94341 . -20) (f94342 . -16) (f94343 . -12) (f94344 . -8) (f94345 . -4) (f94346 . 0))
# expr=(begin ((vector-ref f94339 0) (cdr f94368) f94369))
# tail-begin (begin ((vector-ref f94339 0) (cdr f94368) f94369))
#   env=((f94369 . -20) (f94368 . -16) (f94369 . -12) (f94368 . -8) (f94339 . 4) (f94339 . -28) (f94340 . -24) (f94341 . -20) (f94342 . -16) (f94343 . -12) (f94344 . -8) (f94345 . -4) (f94346 . 0))
# emit-tail-expr
# si=-24
# env=((f94369 . -20) (f94368 . -16) (f94369 . -12) (f94368 . -8) (f94339 . 4) (f94339 . -28) (f94340 . -24) (f94341 . -20) (f94342 . -16) (f94343 . -12) (f94344 . -8) (f94345 . -4) (f94346 . 0))
# expr=((vector-ref f94339 0) (cdr f94368) f94369)
# emit-tail-funcall
#    si   =-24
#    env  = ((f94369 . -20) (f94368 . -16) (f94369 . -12) (f94368 . -8) (f94339 . 4) (f94339 . -28) (f94340 . -24) (f94341 . -20) (f94342 . -16) (f94343 . -12) (f94344 . -8) (f94345 . -4) (f94346 . 0))
#    expr = (funcall (vector-ref f94339 0) (cdr f94368) f94369)
# emit-expr (vector-ref f94339 0)
# emit-expr f94339
# emit-variable-ref
# env=((f94369 . -20) (f94368 . -16) (f94369 . -12) (f94368 . -8) (f94339 . 4) (f94339 . -28) (f94340 . -24) (f94341 . -20) (f94342 . -16) (f94343 . -12) (f94344 . -8) (f94345 . -4) (f94346 . 0))
# var=f94339
    movl 2(%edi), %eax  # frame load f94339
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_571785
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_571785:
    movl %eax, -24(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_571786"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_571786:
# check bounds on vector index
    movl -24(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_571788
    cmp  $0,%eax
    jge _L_571787
_L_571788:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_571787:
    movl -24(%esp), %esi
    movl -1(%eax,%esi), %eax
   movl %eax,  -24(%esp)  # stash funcall-oper in next closure slot
# emit-expr (cdr f94368)
# emit-expr f94368
# emit-variable-ref
# env=((f94369 . -20) (f94368 . -16) (f94369 . -12) (f94368 . -8) (f94339 . 4) (f94339 . -28) (f94340 . -24) (f94341 . -20) (f94342 . -16) (f94343 . -12) (f94344 . -8) (f94345 . -4) (f94346 . 0))
# var=f94368
    movl -16(%esp), %eax  # stack load f94368
# end emit-variable-ref
# check the argument is a pair
    movl %eax,%ebx
    and $7, %bl
    cmp $1, %bl
    je _L_571789
# invoke error handler eh_pair
    .extern mrc_eh$upair
    movl mrc_eh$upair, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $120,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_571789:
    movl 3(%eax), %eax
    mov %eax, -28(%esp)    # arg (cdr f94368)
# emit-expr f94369
# emit-variable-ref
# env=((f94369 . -20) (f94368 . -16) (f94369 . -12) (f94368 . -8) (f94339 . 4) (f94339 . -28) (f94340 . -24) (f94341 . -20) (f94342 . -16) (f94343 . -12) (f94344 . -8) (f94345 . -4) (f94346 . 0))
# var=f94369
    movl -20(%esp), %eax  # stack load f94369
# end emit-variable-ref
    mov %eax, -32(%esp)    # arg f94369
    movl -24(%esp), %edi   # load new closure to %edi
# emit-shift-args:  size=3   si=-24  delta=20
    mov -24(%esp), %ebx  # shift frame cell
    mov %ebx, -4(%esp)  # down to base
# emit-shift-args:  size=2   si=-28  delta=20
    mov -28(%esp), %ebx  # shift frame cell
    mov %ebx, -8(%esp)  # down to base
# emit-shift-args:  size=1   si=-32  delta=20
    mov -32(%esp), %ebx  # shift frame cell
    mov %ebx, -12(%esp)  # down to base
# emit-shift-args:  size=0   si=-36  delta=20
    movl $8,%eax   # save arg count
    jmp *-2(%edi)  # tail-funcall
     ret   # return thru stack
    jmp _L_571782
_L_571781:
# emit-tail-expr
# si=-24
# env=((f94369 . -20) (f94368 . -16) (f94369 . -12) (f94368 . -8) (f94339 . 4) (f94339 . -28) (f94340 . -24) (f94341 . -20) (f94342 . -16) (f94343 . -12) (f94344 . -8) (f94345 . -4) (f94346 . 0))
# expr=(begin ((primitive-ref write-char) #\space f94369) ((primitive-ref write-char) #\. f94369) ((primitive-ref write-char) #\space f94369) ((primitive-ref write) (cdr f94368) f94369))
# tail-begin (begin ((primitive-ref write-char) #\space f94369) ((primitive-ref write-char) #\. f94369) ((primitive-ref write-char) #\space f94369) ((primitive-ref write) (cdr f94368) f94369))
#   env=((f94369 . -20) (f94368 . -16) (f94369 . -12) (f94368 . -8) (f94339 . 4) (f94339 . -28) (f94340 . -24) (f94341 . -20) (f94342 . -16) (f94343 . -12) (f94344 . -8) (f94345 . -4) (f94346 . 0))
# emit-expr ((primitive-ref write-char) #\space f94369)
# funcall
#    si   =-24
#    env  = ((f94369 . -20) (f94368 . -16) (f94369 . -12) (f94368 . -8) (f94339 . 4) (f94339 . -28) (f94340 . -24) (f94341 . -20) (f94342 . -16) (f94343 . -12) (f94344 . -8) (f94345 . -4) (f94346 . 0))
#    expr = (funcall (primitive-ref write-char) #\space f94369)
# emit-expr (primitive-ref write-char)
    .extern mrc_write$mchar
    movl mrc_write$mchar,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_571790"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_571790":
   movl %eax,  -32(%esp)  # stash funcall-oper in closure slot
# emit-expr #\space
    movl $8207, %eax     # immed #\space
    mov %eax, -36(%esp)  # arg  
# emit-expr f94369
# emit-variable-ref
# env=((f94369 . -20) (f94368 . -16) (f94369 . -12) (f94368 . -8) (f94339 . 4) (f94339 . -28) (f94340 . -24) (f94341 . -20) (f94342 . -16) (f94343 . -12) (f94344 . -8) (f94345 . -4) (f94346 . 0))
# var=f94369
    movl -20(%esp), %eax  # stack load f94369
# end emit-variable-ref
    mov %eax, -40(%esp)  # arg f94369
    movl -32(%esp), %edi   # load new closure to %edi
    add $-24, %esp   # adjust base
    movl $8,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $24, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
# emit-tail-expr
# si=-24
# env=((f94369 . -20) (f94368 . -16) (f94369 . -12) (f94368 . -8) (f94339 . 4) (f94339 . -28) (f94340 . -24) (f94341 . -20) (f94342 . -16) (f94343 . -12) (f94344 . -8) (f94345 . -4) (f94346 . 0))
# expr=(begin ((primitive-ref write-char) #\. f94369) ((primitive-ref write-char) #\space f94369) ((primitive-ref write) (cdr f94368) f94369))
# tail-begin (begin ((primitive-ref write-char) #\. f94369) ((primitive-ref write-char) #\space f94369) ((primitive-ref write) (cdr f94368) f94369))
#   env=((f94369 . -20) (f94368 . -16) (f94369 . -12) (f94368 . -8) (f94339 . 4) (f94339 . -28) (f94340 . -24) (f94341 . -20) (f94342 . -16) (f94343 . -12) (f94344 . -8) (f94345 . -4) (f94346 . 0))
# emit-expr ((primitive-ref write-char) #\. f94369)
# funcall
#    si   =-24
#    env  = ((f94369 . -20) (f94368 . -16) (f94369 . -12) (f94368 . -8) (f94339 . 4) (f94339 . -28) (f94340 . -24) (f94341 . -20) (f94342 . -16) (f94343 . -12) (f94344 . -8) (f94345 . -4) (f94346 . 0))
#    expr = (funcall (primitive-ref write-char) #\. f94369)
# emit-expr (primitive-ref write-char)
    .extern mrc_write$mchar
    movl mrc_write$mchar,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_571791"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_571791":
   movl %eax,  -32(%esp)  # stash funcall-oper in closure slot
# emit-expr #\.
    movl $11791, %eax     # immed #\.
    mov %eax, -36(%esp)  # arg .
# emit-expr f94369
# emit-variable-ref
# env=((f94369 . -20) (f94368 . -16) (f94369 . -12) (f94368 . -8) (f94339 . 4) (f94339 . -28) (f94340 . -24) (f94341 . -20) (f94342 . -16) (f94343 . -12) (f94344 . -8) (f94345 . -4) (f94346 . 0))
# var=f94369
    movl -20(%esp), %eax  # stack load f94369
# end emit-variable-ref
    mov %eax, -40(%esp)  # arg f94369
    movl -32(%esp), %edi   # load new closure to %edi
    add $-24, %esp   # adjust base
    movl $8,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $24, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
# emit-tail-expr
# si=-24
# env=((f94369 . -20) (f94368 . -16) (f94369 . -12) (f94368 . -8) (f94339 . 4) (f94339 . -28) (f94340 . -24) (f94341 . -20) (f94342 . -16) (f94343 . -12) (f94344 . -8) (f94345 . -4) (f94346 . 0))
# expr=(begin ((primitive-ref write-char) #\space f94369) ((primitive-ref write) (cdr f94368) f94369))
# tail-begin (begin ((primitive-ref write-char) #\space f94369) ((primitive-ref write) (cdr f94368) f94369))
#   env=((f94369 . -20) (f94368 . -16) (f94369 . -12) (f94368 . -8) (f94339 . 4) (f94339 . -28) (f94340 . -24) (f94341 . -20) (f94342 . -16) (f94343 . -12) (f94344 . -8) (f94345 . -4) (f94346 . 0))
# emit-expr ((primitive-ref write-char) #\space f94369)
# funcall
#    si   =-24
#    env  = ((f94369 . -20) (f94368 . -16) (f94369 . -12) (f94368 . -8) (f94339 . 4) (f94339 . -28) (f94340 . -24) (f94341 . -20) (f94342 . -16) (f94343 . -12) (f94344 . -8) (f94345 . -4) (f94346 . 0))
#    expr = (funcall (primitive-ref write-char) #\space f94369)
# emit-expr (primitive-ref write-char)
    .extern mrc_write$mchar
    movl mrc_write$mchar,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_571792"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_571792":
   movl %eax,  -32(%esp)  # stash funcall-oper in closure slot
# emit-expr #\space
    movl $8207, %eax     # immed #\space
    mov %eax, -36(%esp)  # arg  
# emit-expr f94369
# emit-variable-ref
# env=((f94369 . -20) (f94368 . -16) (f94369 . -12) (f94368 . -8) (f94339 . 4) (f94339 . -28) (f94340 . -24) (f94341 . -20) (f94342 . -16) (f94343 . -12) (f94344 . -8) (f94345 . -4) (f94346 . 0))
# var=f94369
    movl -20(%esp), %eax  # stack load f94369
# end emit-variable-ref
    mov %eax, -40(%esp)  # arg f94369
    movl -32(%esp), %edi   # load new closure to %edi
    add $-24, %esp   # adjust base
    movl $8,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $24, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
# emit-tail-expr
# si=-24
# env=((f94369 . -20) (f94368 . -16) (f94369 . -12) (f94368 . -8) (f94339 . 4) (f94339 . -28) (f94340 . -24) (f94341 . -20) (f94342 . -16) (f94343 . -12) (f94344 . -8) (f94345 . -4) (f94346 . 0))
# expr=(begin ((primitive-ref write) (cdr f94368) f94369))
# tail-begin (begin ((primitive-ref write) (cdr f94368) f94369))
#   env=((f94369 . -20) (f94368 . -16) (f94369 . -12) (f94368 . -8) (f94339 . 4) (f94339 . -28) (f94340 . -24) (f94341 . -20) (f94342 . -16) (f94343 . -12) (f94344 . -8) (f94345 . -4) (f94346 . 0))
# emit-tail-expr
# si=-24
# env=((f94369 . -20) (f94368 . -16) (f94369 . -12) (f94368 . -8) (f94339 . 4) (f94339 . -28) (f94340 . -24) (f94341 . -20) (f94342 . -16) (f94343 . -12) (f94344 . -8) (f94345 . -4) (f94346 . 0))
# expr=((primitive-ref write) (cdr f94368) f94369)
# emit-tail-funcall
#    si   =-24
#    env  = ((f94369 . -20) (f94368 . -16) (f94369 . -12) (f94368 . -8) (f94339 . 4) (f94339 . -28) (f94340 . -24) (f94341 . -20) (f94342 . -16) (f94343 . -12) (f94344 . -8) (f94345 . -4) (f94346 . 0))
#    expr = (funcall (primitive-ref write) (cdr f94368) f94369)
# emit-expr (primitive-ref write)
    .extern mrc_write
    movl mrc_write,%eax
   movl %eax,  -24(%esp)  # stash funcall-oper in next closure slot
# emit-expr (cdr f94368)
# emit-expr f94368
# emit-variable-ref
# env=((f94369 . -20) (f94368 . -16) (f94369 . -12) (f94368 . -8) (f94339 . 4) (f94339 . -28) (f94340 . -24) (f94341 . -20) (f94342 . -16) (f94343 . -12) (f94344 . -8) (f94345 . -4) (f94346 . 0))
# var=f94368
    movl -16(%esp), %eax  # stack load f94368
# end emit-variable-ref
# check the argument is a pair
    movl %eax,%ebx
    and $7, %bl
    cmp $1, %bl
    je _L_571793
# invoke error handler eh_pair
    .extern mrc_eh$upair
    movl mrc_eh$upair, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $120,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_571793:
    movl 3(%eax), %eax
    mov %eax, -28(%esp)    # arg (cdr f94368)
# emit-expr f94369
# emit-variable-ref
# env=((f94369 . -20) (f94368 . -16) (f94369 . -12) (f94368 . -8) (f94339 . 4) (f94339 . -28) (f94340 . -24) (f94341 . -20) (f94342 . -16) (f94343 . -12) (f94344 . -8) (f94345 . -4) (f94346 . 0))
# var=f94369
    movl -20(%esp), %eax  # stack load f94369
# end emit-variable-ref
    mov %eax, -32(%esp)    # arg f94369
    movl -24(%esp), %edi   # load new closure to %edi
# emit-shift-args:  size=3   si=-24  delta=20
    mov -24(%esp), %ebx  # shift frame cell
    mov %ebx, -4(%esp)  # down to base
# emit-shift-args:  size=2   si=-28  delta=20
    mov -28(%esp), %ebx  # shift frame cell
    mov %ebx, -8(%esp)  # down to base
# emit-shift-args:  size=1   si=-32  delta=20
    mov -32(%esp), %ebx  # shift frame cell
    mov %ebx, -12(%esp)  # down to base
# emit-shift-args:  size=0   si=-36  delta=20
    movl $8,%eax   # save arg count
    jmp *-2(%edi)  # tail-funcall
     ret   # return thru stack
_L_571782:
_L_571779:
     ret   # return thru stack
    .align 4,0x90
_L_571774:
    movl -32(%esp), %ebx
    movl -36(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin)
# emit-begin
#   expr=(begin)
#   env=((f94339 . -28) (f94340 . -24) (f94341 . -20) (f94342 . -16) (f94343 . -12) (f94344 . -8) (f94345 . -4) (f94346 . 0))
# emit-expr (begin (closure (f94392 f94393 f94394) (f94346 f94345 f94344 f94343 f94341 f94342 f94340) (let ((f94392 f94392) (f94393 f94393) (f94394 f94394)) (if (boolean? f94392) ((vector-ref f94346 0) f94392 f94393) (if (null? f94392) ((vector-ref f94345 0) f94393) (if (char? f94392) (if f94394 ((primitive-ref write-char) f94392 f94393) ((vector-ref f94344 0) f94392 f94393)) (if (fixnum? f94392) ((vector-ref f94343 0) f94392 f94393) (if (string? f94392) (if f94394 ((vector-ref f94341 0) f94392 f94393) ((vector-ref f94342 0) f94392 f94393)) (if (pair? f94392) ((vector-ref f94340 0) f94392 f94393) ((primitive-ref error) ((primitive-ref string->symbol) "write") "unrecognized expression"))))))))))
# emit-begin
#   expr=(begin (closure (f94392 f94393 f94394) (f94346 f94345 f94344 f94343 f94341 f94342 f94340) (let ((f94392 f94392) (f94393 f94393) (f94394 f94394)) (if (boolean? f94392) ((vector-ref f94346 0) f94392 f94393) (if (null? f94392) ((vector-ref f94345 0) f94393) (if (char? f94392) (if f94394 ((primitive-ref write-char) f94392 f94393) ((vector-ref f94344 0) f94392 f94393)) (if (fixnum? f94392) ((vector-ref f94343 0) f94392 f94393) (if (string? f94392) (if f94394 ((vector-ref f94341 0) f94392 f94393) ((vector-ref f94342 0) f94392 f94393)) (if (pair? f94392) ((vector-ref f94340 0) f94392 f94393) ((primitive-ref error) ((primitive-ref string->symbol) "write") "unrecognized expression"))))))))))
#   env=((f94339 . -28) (f94340 . -24) (f94341 . -20) (f94342 . -16) (f94343 . -12) (f94344 . -8) (f94345 . -4) (f94346 . 0))
# emit-expr (closure (f94392 f94393 f94394) (f94346 f94345 f94344 f94343 f94341 f94342 f94340) (let ((f94392 f94392) (f94393 f94393) (f94394 f94394)) (if (boolean? f94392) ((vector-ref f94346 0) f94392 f94393) (if (null? f94392) ((vector-ref f94345 0) f94393) (if (char? f94392) (if f94394 ((primitive-ref write-char) f94392 f94393) ((vector-ref f94344 0) f94392 f94393)) (if (fixnum? f94392) ((vector-ref f94343 0) f94392 f94393) (if (string? f94392) (if f94394 ((vector-ref f94341 0) f94392 f94393) ((vector-ref f94342 0) f94392 f94393)) (if (pair? f94392) ((vector-ref f94340 0) f94392 f94393) ((primitive-ref error) ((primitive-ref string->symbol) "write") "unrecognized expression")))))))))
# emit-closure
# si = -32
# env = ((f94339 . -28) (f94340 . -24) (f94341 . -20) (f94342 . -16) (f94343 . -12) (f94344 . -8) (f94345 . -4) (f94346 . 0))
# expr = (closure (f94392 f94393 f94394) (f94346 f94345 f94344 f94343 f94341 f94342 f94340) (let ((f94392 f94392) (f94393 f94393) (f94394 f94394)) (if (boolean? f94392) ((vector-ref f94346 0) f94392 f94393) (if (null? f94392) ((vector-ref f94345 0) f94393) (if (char? f94392) (if f94394 ((primitive-ref write-char) f94392 f94393) ((vector-ref f94344 0) f94392 f94393)) (if (fixnum? f94392) ((vector-ref f94343 0) f94392 f94393) (if (string? f94392) (if f94394 ((vector-ref f94341 0) f94392 f94393) ((vector-ref f94342 0) f94392 f94393)) (if (pair? f94392) ((vector-ref f94340 0) f94392 f94393) ((primitive-ref error) ((primitive-ref string->symbol) "write") "unrecognized expression")))))))))
    movl $_L_571794, 0(%ebp)  # closure label
# emit-variable-ref
# env=((f94339 . -28) (f94340 . -24) (f94341 . -20) (f94342 . -16) (f94343 . -12) (f94344 . -8) (f94345 . -4) (f94346 . 0))
# var=f94346
    movl 0(%esp), %eax  # stack load f94346
# end emit-variable-ref
   movl  %eax, 4(%ebp)  # f94346
# emit-variable-ref
# env=((f94339 . -28) (f94340 . -24) (f94341 . -20) (f94342 . -16) (f94343 . -12) (f94344 . -8) (f94345 . -4) (f94346 . 0))
# var=f94345
    movl -4(%esp), %eax  # stack load f94345
# end emit-variable-ref
   movl  %eax, 8(%ebp)  # f94345
# emit-variable-ref
# env=((f94339 . -28) (f94340 . -24) (f94341 . -20) (f94342 . -16) (f94343 . -12) (f94344 . -8) (f94345 . -4) (f94346 . 0))
# var=f94344
    movl -8(%esp), %eax  # stack load f94344
# end emit-variable-ref
   movl  %eax, 12(%ebp)  # f94344
# emit-variable-ref
# env=((f94339 . -28) (f94340 . -24) (f94341 . -20) (f94342 . -16) (f94343 . -12) (f94344 . -8) (f94345 . -4) (f94346 . 0))
# var=f94343
    movl -12(%esp), %eax  # stack load f94343
# end emit-variable-ref
   movl  %eax, 16(%ebp)  # f94343
# emit-variable-ref
# env=((f94339 . -28) (f94340 . -24) (f94341 . -20) (f94342 . -16) (f94343 . -12) (f94344 . -8) (f94345 . -4) (f94346 . 0))
# var=f94341
    movl -20(%esp), %eax  # stack load f94341
# end emit-variable-ref
   movl  %eax, 20(%ebp)  # f94341
# emit-variable-ref
# env=((f94339 . -28) (f94340 . -24) (f94341 . -20) (f94342 . -16) (f94343 . -12) (f94344 . -8) (f94345 . -4) (f94346 . 0))
# var=f94342
    movl -16(%esp), %eax  # stack load f94342
# end emit-variable-ref
   movl  %eax, 24(%ebp)  # f94342
# emit-variable-ref
# env=((f94339 . -28) (f94340 . -24) (f94341 . -20) (f94342 . -16) (f94343 . -12) (f94344 . -8) (f94345 . -4) (f94346 . 0))
# var=f94340
    movl -24(%esp), %eax  # stack load f94340
# end emit-variable-ref
   movl  %eax, 28(%ebp)  # f94340
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $32, %ebp     # bump ebp
    jmp _L_571795            # jump around closure body
_L_571794:
# check argument count
    cmp $12,%eax
    je _L_571796
# invoke error handler eh_argcount
    .extern mrc_eh$uargcount
    movl mrc_eh$uargcount, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_571796:
# emit-tail-expr
# si=-20
# env=((f94394 . -16) (f94393 . -12) (f94392 . -8) (f94340 . 28) (f94342 . 24) (f94341 . 20) (f94343 . 16) (f94344 . 12) (f94345 . 8) (f94346 . 4) (f94339 . -28) (f94340 . -24) (f94341 . -20) (f94342 . -16) (f94343 . -12) (f94344 . -8) (f94345 . -4) (f94346 . 0))
# expr=(let ((f94392 f94392) (f94393 f94393) (f94394 f94394)) (if (boolean? f94392) ((vector-ref f94346 0) f94392 f94393) (if (null? f94392) ((vector-ref f94345 0) f94393) (if (char? f94392) (if f94394 ((primitive-ref write-char) f94392 f94393) ((vector-ref f94344 0) f94392 f94393)) (if (fixnum? f94392) ((vector-ref f94343 0) f94392 f94393) (if (string? f94392) (if f94394 ((vector-ref f94341 0) f94392 f94393) ((vector-ref f94342 0) f94392 f94393)) (if (pair? f94392) ((vector-ref f94340 0) f94392 f94393) ((primitive-ref error) ((primitive-ref string->symbol) "write") "unrecognized expression"))))))))
# emit-tail-let
#  si   = -20
#  env  = ((f94394 . -16) (f94393 . -12) (f94392 . -8) (f94340 . 28) (f94342 . 24) (f94341 . 20) (f94343 . 16) (f94344 . 12) (f94345 . 8) (f94346 . 4) (f94339 . -28) (f94340 . -24) (f94341 . -20) (f94342 . -16) (f94343 . -12) (f94344 . -8) (f94345 . -4) (f94346 . 0))
#  bindings = ((f94392 f94392) (f94393 f94393) (f94394 f94394))
#  body = (if (boolean? f94392) ((vector-ref f94346 0) f94392 f94393) (if (null? f94392) ((vector-ref f94345 0) f94393) (if (char? f94392) (if f94394 ((primitive-ref write-char) f94392 f94393) ((vector-ref f94344 0) f94392 f94393)) (if (fixnum? f94392) ((vector-ref f94343 0) f94392 f94393) (if (string? f94392) (if f94394 ((vector-ref f94341 0) f94392 f94393) ((vector-ref f94342 0) f94392 f94393)) (if (pair? f94392) ((vector-ref f94340 0) f94392 f94393) ((primitive-ref error) ((primitive-ref string->symbol) "write") "unrecognized expression")))))))
# emit-expr f94392
# emit-variable-ref
# env=((f94394 . -16) (f94393 . -12) (f94392 . -8) (f94340 . 28) (f94342 . 24) (f94341 . 20) (f94343 . 16) (f94344 . 12) (f94345 . 8) (f94346 . 4) (f94339 . -28) (f94340 . -24) (f94341 . -20) (f94342 . -16) (f94343 . -12) (f94344 . -8) (f94345 . -4) (f94346 . 0))
# var=f94392
    movl -8(%esp), %eax  # stack load f94392
# end emit-variable-ref
    movl %eax, -20(%esp)  # stack save
# emit-expr f94393
# emit-variable-ref
# env=((f94394 . -16) (f94393 . -12) (f94392 . -8) (f94340 . 28) (f94342 . 24) (f94341 . 20) (f94343 . 16) (f94344 . 12) (f94345 . 8) (f94346 . 4) (f94339 . -28) (f94340 . -24) (f94341 . -20) (f94342 . -16) (f94343 . -12) (f94344 . -8) (f94345 . -4) (f94346 . 0))
# var=f94393
    movl -12(%esp), %eax  # stack load f94393
# end emit-variable-ref
    movl %eax, -24(%esp)  # stack save
# emit-expr f94394
# emit-variable-ref
# env=((f94394 . -16) (f94393 . -12) (f94392 . -8) (f94340 . 28) (f94342 . 24) (f94341 . 20) (f94343 . 16) (f94344 . 12) (f94345 . 8) (f94346 . 4) (f94339 . -28) (f94340 . -24) (f94341 . -20) (f94342 . -16) (f94343 . -12) (f94344 . -8) (f94345 . -4) (f94346 . 0))
# var=f94394
    movl -16(%esp), %eax  # stack load f94394
# end emit-variable-ref
    movl %eax, -28(%esp)  # stack save
# emit-tail-expr
# si=-32
# env=((f94394 . -28) (f94393 . -24) (f94392 . -20) (f94394 . -16) (f94393 . -12) (f94392 . -8) (f94340 . 28) (f94342 . 24) (f94341 . 20) (f94343 . 16) (f94344 . 12) (f94345 . 8) (f94346 . 4) (f94339 . -28) (f94340 . -24) (f94341 . -20) (f94342 . -16) (f94343 . -12) (f94344 . -8) (f94345 . -4) (f94346 . 0))
# expr=(if (boolean? f94392) ((vector-ref f94346 0) f94392 f94393) (if (null? f94392) ((vector-ref f94345 0) f94393) (if (char? f94392) (if f94394 ((primitive-ref write-char) f94392 f94393) ((vector-ref f94344 0) f94392 f94393)) (if (fixnum? f94392) ((vector-ref f94343 0) f94392 f94393) (if (string? f94392) (if f94394 ((vector-ref f94341 0) f94392 f94393) ((vector-ref f94342 0) f94392 f94393)) (if (pair? f94392) ((vector-ref f94340 0) f94392 f94393) ((primitive-ref error) ((primitive-ref string->symbol) "write") "unrecognized expression")))))))
# emit-expr (boolean? f94392)
# emit-expr f94392
# emit-variable-ref
# env=((f94394 . -28) (f94393 . -24) (f94392 . -20) (f94394 . -16) (f94393 . -12) (f94392 . -8) (f94340 . 28) (f94342 . 24) (f94341 . 20) (f94343 . 16) (f94344 . 12) (f94345 . 8) (f94346 . 4) (f94339 . -28) (f94340 . -24) (f94341 . -20) (f94342 . -16) (f94343 . -12) (f94344 . -8) (f94345 . -4) (f94346 . 0))
# var=f94392
    movl -20(%esp), %eax  # stack load f94392
# end emit-variable-ref
    and $191, %eax
    cmp $47, %eax
    sete %al
    movzbl %al, %eax
    sal $6, %al
    or $47, %al
    cmp $47, %al
    je _L_571797
# emit-tail-expr
# si=-32
# env=((f94394 . -28) (f94393 . -24) (f94392 . -20) (f94394 . -16) (f94393 . -12) (f94392 . -8) (f94340 . 28) (f94342 . 24) (f94341 . 20) (f94343 . 16) (f94344 . 12) (f94345 . 8) (f94346 . 4) (f94339 . -28) (f94340 . -24) (f94341 . -20) (f94342 . -16) (f94343 . -12) (f94344 . -8) (f94345 . -4) (f94346 . 0))
# expr=((vector-ref f94346 0) f94392 f94393)
# emit-tail-funcall
#    si   =-32
#    env  = ((f94394 . -28) (f94393 . -24) (f94392 . -20) (f94394 . -16) (f94393 . -12) (f94392 . -8) (f94340 . 28) (f94342 . 24) (f94341 . 20) (f94343 . 16) (f94344 . 12) (f94345 . 8) (f94346 . 4) (f94339 . -28) (f94340 . -24) (f94341 . -20) (f94342 . -16) (f94343 . -12) (f94344 . -8) (f94345 . -4) (f94346 . 0))
#    expr = (funcall (vector-ref f94346 0) f94392 f94393)
# emit-expr (vector-ref f94346 0)
# emit-expr f94346
# emit-variable-ref
# env=((f94394 . -28) (f94393 . -24) (f94392 . -20) (f94394 . -16) (f94393 . -12) (f94392 . -8) (f94340 . 28) (f94342 . 24) (f94341 . 20) (f94343 . 16) (f94344 . 12) (f94345 . 8) (f94346 . 4) (f94339 . -28) (f94340 . -24) (f94341 . -20) (f94342 . -16) (f94343 . -12) (f94344 . -8) (f94345 . -4) (f94346 . 0))
# var=f94346
    movl 2(%edi), %eax  # frame load f94346
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_571799
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_571799:
    movl %eax, -32(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_571800"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_571800:
# check bounds on vector index
    movl -32(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_571802
    cmp  $0,%eax
    jge _L_571801
_L_571802:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_571801:
    movl -32(%esp), %esi
    movl -1(%eax,%esi), %eax
   movl %eax,  -32(%esp)  # stash funcall-oper in next closure slot
# emit-expr f94392
# emit-variable-ref
# env=((f94394 . -28) (f94393 . -24) (f94392 . -20) (f94394 . -16) (f94393 . -12) (f94392 . -8) (f94340 . 28) (f94342 . 24) (f94341 . 20) (f94343 . 16) (f94344 . 12) (f94345 . 8) (f94346 . 4) (f94339 . -28) (f94340 . -24) (f94341 . -20) (f94342 . -16) (f94343 . -12) (f94344 . -8) (f94345 . -4) (f94346 . 0))
# var=f94392
    movl -20(%esp), %eax  # stack load f94392
# end emit-variable-ref
    mov %eax, -36(%esp)    # arg f94392
# emit-expr f94393
# emit-variable-ref
# env=((f94394 . -28) (f94393 . -24) (f94392 . -20) (f94394 . -16) (f94393 . -12) (f94392 . -8) (f94340 . 28) (f94342 . 24) (f94341 . 20) (f94343 . 16) (f94344 . 12) (f94345 . 8) (f94346 . 4) (f94339 . -28) (f94340 . -24) (f94341 . -20) (f94342 . -16) (f94343 . -12) (f94344 . -8) (f94345 . -4) (f94346 . 0))
# var=f94393
    movl -24(%esp), %eax  # stack load f94393
# end emit-variable-ref
    mov %eax, -40(%esp)    # arg f94393
    movl -32(%esp), %edi   # load new closure to %edi
# emit-shift-args:  size=3   si=-32  delta=28
    mov -32(%esp), %ebx  # shift frame cell
    mov %ebx, -4(%esp)  # down to base
# emit-shift-args:  size=2   si=-36  delta=28
    mov -36(%esp), %ebx  # shift frame cell
    mov %ebx, -8(%esp)  # down to base
# emit-shift-args:  size=1   si=-40  delta=28
    mov -40(%esp), %ebx  # shift frame cell
    mov %ebx, -12(%esp)  # down to base
# emit-shift-args:  size=0   si=-44  delta=28
    movl $8,%eax   # save arg count
    jmp *-2(%edi)  # tail-funcall
    jmp _L_571798
_L_571797:
# emit-tail-expr
# si=-32
# env=((f94394 . -28) (f94393 . -24) (f94392 . -20) (f94394 . -16) (f94393 . -12) (f94392 . -8) (f94340 . 28) (f94342 . 24) (f94341 . 20) (f94343 . 16) (f94344 . 12) (f94345 . 8) (f94346 . 4) (f94339 . -28) (f94340 . -24) (f94341 . -20) (f94342 . -16) (f94343 . -12) (f94344 . -8) (f94345 . -4) (f94346 . 0))
# expr=(if (null? f94392) ((vector-ref f94345 0) f94393) (if (char? f94392) (if f94394 ((primitive-ref write-char) f94392 f94393) ((vector-ref f94344 0) f94392 f94393)) (if (fixnum? f94392) ((vector-ref f94343 0) f94392 f94393) (if (string? f94392) (if f94394 ((vector-ref f94341 0) f94392 f94393) ((vector-ref f94342 0) f94392 f94393)) (if (pair? f94392) ((vector-ref f94340 0) f94392 f94393) ((primitive-ref error) ((primitive-ref string->symbol) "write") "unrecognized expression"))))))
# emit-expr (null? f94392)
# emit-expr f94392
# emit-variable-ref
# env=((f94394 . -28) (f94393 . -24) (f94392 . -20) (f94394 . -16) (f94393 . -12) (f94392 . -8) (f94340 . 28) (f94342 . 24) (f94341 . 20) (f94343 . 16) (f94344 . 12) (f94345 . 8) (f94346 . 4) (f94339 . -28) (f94340 . -24) (f94341 . -20) (f94342 . -16) (f94343 . -12) (f94344 . -8) (f94345 . -4) (f94346 . 0))
# var=f94392
    movl -20(%esp), %eax  # stack load f94392
# end emit-variable-ref
    cmp $63, %eax
    mov $0, %eax
    sete %al
    movzbl %al, %eax
    sal $6, %al
    or $47, %al
    cmp $47, %al
    je _L_571803
# emit-tail-expr
# si=-32
# env=((f94394 . -28) (f94393 . -24) (f94392 . -20) (f94394 . -16) (f94393 . -12) (f94392 . -8) (f94340 . 28) (f94342 . 24) (f94341 . 20) (f94343 . 16) (f94344 . 12) (f94345 . 8) (f94346 . 4) (f94339 . -28) (f94340 . -24) (f94341 . -20) (f94342 . -16) (f94343 . -12) (f94344 . -8) (f94345 . -4) (f94346 . 0))
# expr=((vector-ref f94345 0) f94393)
# emit-tail-funcall
#    si   =-32
#    env  = ((f94394 . -28) (f94393 . -24) (f94392 . -20) (f94394 . -16) (f94393 . -12) (f94392 . -8) (f94340 . 28) (f94342 . 24) (f94341 . 20) (f94343 . 16) (f94344 . 12) (f94345 . 8) (f94346 . 4) (f94339 . -28) (f94340 . -24) (f94341 . -20) (f94342 . -16) (f94343 . -12) (f94344 . -8) (f94345 . -4) (f94346 . 0))
#    expr = (funcall (vector-ref f94345 0) f94393)
# emit-expr (vector-ref f94345 0)
# emit-expr f94345
# emit-variable-ref
# env=((f94394 . -28) (f94393 . -24) (f94392 . -20) (f94394 . -16) (f94393 . -12) (f94392 . -8) (f94340 . 28) (f94342 . 24) (f94341 . 20) (f94343 . 16) (f94344 . 12) (f94345 . 8) (f94346 . 4) (f94339 . -28) (f94340 . -24) (f94341 . -20) (f94342 . -16) (f94343 . -12) (f94344 . -8) (f94345 . -4) (f94346 . 0))
# var=f94345
    movl 6(%edi), %eax  # frame load f94345
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_571805
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_571805:
    movl %eax, -32(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_571806"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_571806:
# check bounds on vector index
    movl -32(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_571808
    cmp  $0,%eax
    jge _L_571807
_L_571808:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_571807:
    movl -32(%esp), %esi
    movl -1(%eax,%esi), %eax
   movl %eax,  -32(%esp)  # stash funcall-oper in next closure slot
# emit-expr f94393
# emit-variable-ref
# env=((f94394 . -28) (f94393 . -24) (f94392 . -20) (f94394 . -16) (f94393 . -12) (f94392 . -8) (f94340 . 28) (f94342 . 24) (f94341 . 20) (f94343 . 16) (f94344 . 12) (f94345 . 8) (f94346 . 4) (f94339 . -28) (f94340 . -24) (f94341 . -20) (f94342 . -16) (f94343 . -12) (f94344 . -8) (f94345 . -4) (f94346 . 0))
# var=f94393
    movl -24(%esp), %eax  # stack load f94393
# end emit-variable-ref
    mov %eax, -36(%esp)    # arg f94393
    movl -32(%esp), %edi   # load new closure to %edi
# emit-shift-args:  size=2   si=-32  delta=28
    mov -32(%esp), %ebx  # shift frame cell
    mov %ebx, -4(%esp)  # down to base
# emit-shift-args:  size=1   si=-36  delta=28
    mov -36(%esp), %ebx  # shift frame cell
    mov %ebx, -8(%esp)  # down to base
# emit-shift-args:  size=0   si=-40  delta=28
    movl $4,%eax   # save arg count
    jmp *-2(%edi)  # tail-funcall
    jmp _L_571804
_L_571803:
# emit-tail-expr
# si=-32
# env=((f94394 . -28) (f94393 . -24) (f94392 . -20) (f94394 . -16) (f94393 . -12) (f94392 . -8) (f94340 . 28) (f94342 . 24) (f94341 . 20) (f94343 . 16) (f94344 . 12) (f94345 . 8) (f94346 . 4) (f94339 . -28) (f94340 . -24) (f94341 . -20) (f94342 . -16) (f94343 . -12) (f94344 . -8) (f94345 . -4) (f94346 . 0))
# expr=(if (char? f94392) (if f94394 ((primitive-ref write-char) f94392 f94393) ((vector-ref f94344 0) f94392 f94393)) (if (fixnum? f94392) ((vector-ref f94343 0) f94392 f94393) (if (string? f94392) (if f94394 ((vector-ref f94341 0) f94392 f94393) ((vector-ref f94342 0) f94392 f94393)) (if (pair? f94392) ((vector-ref f94340 0) f94392 f94393) ((primitive-ref error) ((primitive-ref string->symbol) "write") "unrecognized expression")))))
# emit-expr (char? f94392)
# emit-expr f94392
# emit-variable-ref
# env=((f94394 . -28) (f94393 . -24) (f94392 . -20) (f94394 . -16) (f94393 . -12) (f94392 . -8) (f94340 . 28) (f94342 . 24) (f94341 . 20) (f94343 . 16) (f94344 . 12) (f94345 . 8) (f94346 . 4) (f94339 . -28) (f94340 . -24) (f94341 . -20) (f94342 . -16) (f94343 . -12) (f94344 . -8) (f94345 . -4) (f94346 . 0))
# var=f94392
    movl -20(%esp), %eax  # stack load f94392
# end emit-variable-ref
    and $255, %eax
    cmp $15, %eax
    sete %al
    movzbl %al, %eax
    sal $6, %al
    or $47, %al
    cmp $47, %al
    je _L_571809
# emit-tail-expr
# si=-32
# env=((f94394 . -28) (f94393 . -24) (f94392 . -20) (f94394 . -16) (f94393 . -12) (f94392 . -8) (f94340 . 28) (f94342 . 24) (f94341 . 20) (f94343 . 16) (f94344 . 12) (f94345 . 8) (f94346 . 4) (f94339 . -28) (f94340 . -24) (f94341 . -20) (f94342 . -16) (f94343 . -12) (f94344 . -8) (f94345 . -4) (f94346 . 0))
# expr=(if f94394 ((primitive-ref write-char) f94392 f94393) ((vector-ref f94344 0) f94392 f94393))
# emit-expr f94394
# emit-variable-ref
# env=((f94394 . -28) (f94393 . -24) (f94392 . -20) (f94394 . -16) (f94393 . -12) (f94392 . -8) (f94340 . 28) (f94342 . 24) (f94341 . 20) (f94343 . 16) (f94344 . 12) (f94345 . 8) (f94346 . 4) (f94339 . -28) (f94340 . -24) (f94341 . -20) (f94342 . -16) (f94343 . -12) (f94344 . -8) (f94345 . -4) (f94346 . 0))
# var=f94394
    movl -28(%esp), %eax  # stack load f94394
# end emit-variable-ref
    cmp $47, %al
    je _L_571811
# emit-tail-expr
# si=-32
# env=((f94394 . -28) (f94393 . -24) (f94392 . -20) (f94394 . -16) (f94393 . -12) (f94392 . -8) (f94340 . 28) (f94342 . 24) (f94341 . 20) (f94343 . 16) (f94344 . 12) (f94345 . 8) (f94346 . 4) (f94339 . -28) (f94340 . -24) (f94341 . -20) (f94342 . -16) (f94343 . -12) (f94344 . -8) (f94345 . -4) (f94346 . 0))
# expr=((primitive-ref write-char) f94392 f94393)
# emit-tail-funcall
#    si   =-32
#    env  = ((f94394 . -28) (f94393 . -24) (f94392 . -20) (f94394 . -16) (f94393 . -12) (f94392 . -8) (f94340 . 28) (f94342 . 24) (f94341 . 20) (f94343 . 16) (f94344 . 12) (f94345 . 8) (f94346 . 4) (f94339 . -28) (f94340 . -24) (f94341 . -20) (f94342 . -16) (f94343 . -12) (f94344 . -8) (f94345 . -4) (f94346 . 0))
#    expr = (funcall (primitive-ref write-char) f94392 f94393)
# emit-expr (primitive-ref write-char)
    .extern mrc_write$mchar
    movl mrc_write$mchar,%eax
   movl %eax,  -32(%esp)  # stash funcall-oper in next closure slot
# emit-expr f94392
# emit-variable-ref
# env=((f94394 . -28) (f94393 . -24) (f94392 . -20) (f94394 . -16) (f94393 . -12) (f94392 . -8) (f94340 . 28) (f94342 . 24) (f94341 . 20) (f94343 . 16) (f94344 . 12) (f94345 . 8) (f94346 . 4) (f94339 . -28) (f94340 . -24) (f94341 . -20) (f94342 . -16) (f94343 . -12) (f94344 . -8) (f94345 . -4) (f94346 . 0))
# var=f94392
    movl -20(%esp), %eax  # stack load f94392
# end emit-variable-ref
    mov %eax, -36(%esp)    # arg f94392
# emit-expr f94393
# emit-variable-ref
# env=((f94394 . -28) (f94393 . -24) (f94392 . -20) (f94394 . -16) (f94393 . -12) (f94392 . -8) (f94340 . 28) (f94342 . 24) (f94341 . 20) (f94343 . 16) (f94344 . 12) (f94345 . 8) (f94346 . 4) (f94339 . -28) (f94340 . -24) (f94341 . -20) (f94342 . -16) (f94343 . -12) (f94344 . -8) (f94345 . -4) (f94346 . 0))
# var=f94393
    movl -24(%esp), %eax  # stack load f94393
# end emit-variable-ref
    mov %eax, -40(%esp)    # arg f94393
    movl -32(%esp), %edi   # load new closure to %edi
# emit-shift-args:  size=3   si=-32  delta=28
    mov -32(%esp), %ebx  # shift frame cell
    mov %ebx, -4(%esp)  # down to base
# emit-shift-args:  size=2   si=-36  delta=28
    mov -36(%esp), %ebx  # shift frame cell
    mov %ebx, -8(%esp)  # down to base
# emit-shift-args:  size=1   si=-40  delta=28
    mov -40(%esp), %ebx  # shift frame cell
    mov %ebx, -12(%esp)  # down to base
# emit-shift-args:  size=0   si=-44  delta=28
    movl $8,%eax   # save arg count
    jmp *-2(%edi)  # tail-funcall
    jmp _L_571812
_L_571811:
# emit-tail-expr
# si=-32
# env=((f94394 . -28) (f94393 . -24) (f94392 . -20) (f94394 . -16) (f94393 . -12) (f94392 . -8) (f94340 . 28) (f94342 . 24) (f94341 . 20) (f94343 . 16) (f94344 . 12) (f94345 . 8) (f94346 . 4) (f94339 . -28) (f94340 . -24) (f94341 . -20) (f94342 . -16) (f94343 . -12) (f94344 . -8) (f94345 . -4) (f94346 . 0))
# expr=((vector-ref f94344 0) f94392 f94393)
# emit-tail-funcall
#    si   =-32
#    env  = ((f94394 . -28) (f94393 . -24) (f94392 . -20) (f94394 . -16) (f94393 . -12) (f94392 . -8) (f94340 . 28) (f94342 . 24) (f94341 . 20) (f94343 . 16) (f94344 . 12) (f94345 . 8) (f94346 . 4) (f94339 . -28) (f94340 . -24) (f94341 . -20) (f94342 . -16) (f94343 . -12) (f94344 . -8) (f94345 . -4) (f94346 . 0))
#    expr = (funcall (vector-ref f94344 0) f94392 f94393)
# emit-expr (vector-ref f94344 0)
# emit-expr f94344
# emit-variable-ref
# env=((f94394 . -28) (f94393 . -24) (f94392 . -20) (f94394 . -16) (f94393 . -12) (f94392 . -8) (f94340 . 28) (f94342 . 24) (f94341 . 20) (f94343 . 16) (f94344 . 12) (f94345 . 8) (f94346 . 4) (f94339 . -28) (f94340 . -24) (f94341 . -20) (f94342 . -16) (f94343 . -12) (f94344 . -8) (f94345 . -4) (f94346 . 0))
# var=f94344
    movl 10(%edi), %eax  # frame load f94344
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_571813
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_571813:
    movl %eax, -32(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_571814"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_571814:
# check bounds on vector index
    movl -32(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_571816
    cmp  $0,%eax
    jge _L_571815
_L_571816:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_571815:
    movl -32(%esp), %esi
    movl -1(%eax,%esi), %eax
   movl %eax,  -32(%esp)  # stash funcall-oper in next closure slot
# emit-expr f94392
# emit-variable-ref
# env=((f94394 . -28) (f94393 . -24) (f94392 . -20) (f94394 . -16) (f94393 . -12) (f94392 . -8) (f94340 . 28) (f94342 . 24) (f94341 . 20) (f94343 . 16) (f94344 . 12) (f94345 . 8) (f94346 . 4) (f94339 . -28) (f94340 . -24) (f94341 . -20) (f94342 . -16) (f94343 . -12) (f94344 . -8) (f94345 . -4) (f94346 . 0))
# var=f94392
    movl -20(%esp), %eax  # stack load f94392
# end emit-variable-ref
    mov %eax, -36(%esp)    # arg f94392
# emit-expr f94393
# emit-variable-ref
# env=((f94394 . -28) (f94393 . -24) (f94392 . -20) (f94394 . -16) (f94393 . -12) (f94392 . -8) (f94340 . 28) (f94342 . 24) (f94341 . 20) (f94343 . 16) (f94344 . 12) (f94345 . 8) (f94346 . 4) (f94339 . -28) (f94340 . -24) (f94341 . -20) (f94342 . -16) (f94343 . -12) (f94344 . -8) (f94345 . -4) (f94346 . 0))
# var=f94393
    movl -24(%esp), %eax  # stack load f94393
# end emit-variable-ref
    mov %eax, -40(%esp)    # arg f94393
    movl -32(%esp), %edi   # load new closure to %edi
# emit-shift-args:  size=3   si=-32  delta=28
    mov -32(%esp), %ebx  # shift frame cell
    mov %ebx, -4(%esp)  # down to base
# emit-shift-args:  size=2   si=-36  delta=28
    mov -36(%esp), %ebx  # shift frame cell
    mov %ebx, -8(%esp)  # down to base
# emit-shift-args:  size=1   si=-40  delta=28
    mov -40(%esp), %ebx  # shift frame cell
    mov %ebx, -12(%esp)  # down to base
# emit-shift-args:  size=0   si=-44  delta=28
    movl $8,%eax   # save arg count
    jmp *-2(%edi)  # tail-funcall
_L_571812:
    jmp _L_571810
_L_571809:
# emit-tail-expr
# si=-32
# env=((f94394 . -28) (f94393 . -24) (f94392 . -20) (f94394 . -16) (f94393 . -12) (f94392 . -8) (f94340 . 28) (f94342 . 24) (f94341 . 20) (f94343 . 16) (f94344 . 12) (f94345 . 8) (f94346 . 4) (f94339 . -28) (f94340 . -24) (f94341 . -20) (f94342 . -16) (f94343 . -12) (f94344 . -8) (f94345 . -4) (f94346 . 0))
# expr=(if (fixnum? f94392) ((vector-ref f94343 0) f94392 f94393) (if (string? f94392) (if f94394 ((vector-ref f94341 0) f94392 f94393) ((vector-ref f94342 0) f94392 f94393)) (if (pair? f94392) ((vector-ref f94340 0) f94392 f94393) ((primitive-ref error) ((primitive-ref string->symbol) "write") "unrecognized expression"))))
# emit-expr (fixnum? f94392)
# emit-expr f94392
# emit-variable-ref
# env=((f94394 . -28) (f94393 . -24) (f94392 . -20) (f94394 . -16) (f94393 . -12) (f94392 . -8) (f94340 . 28) (f94342 . 24) (f94341 . 20) (f94343 . 16) (f94344 . 12) (f94345 . 8) (f94346 . 4) (f94339 . -28) (f94340 . -24) (f94341 . -20) (f94342 . -16) (f94343 . -12) (f94344 . -8) (f94345 . -4) (f94346 . 0))
# var=f94392
    movl -20(%esp), %eax  # stack load f94392
# end emit-variable-ref
    and $3, %al
    cmp $0, %al
    sete %al
    movzbl %al, %eax
    sal $6, %al
    or $47, %al
    cmp $47, %al
    je _L_571817
# emit-tail-expr
# si=-32
# env=((f94394 . -28) (f94393 . -24) (f94392 . -20) (f94394 . -16) (f94393 . -12) (f94392 . -8) (f94340 . 28) (f94342 . 24) (f94341 . 20) (f94343 . 16) (f94344 . 12) (f94345 . 8) (f94346 . 4) (f94339 . -28) (f94340 . -24) (f94341 . -20) (f94342 . -16) (f94343 . -12) (f94344 . -8) (f94345 . -4) (f94346 . 0))
# expr=((vector-ref f94343 0) f94392 f94393)
# emit-tail-funcall
#    si   =-32
#    env  = ((f94394 . -28) (f94393 . -24) (f94392 . -20) (f94394 . -16) (f94393 . -12) (f94392 . -8) (f94340 . 28) (f94342 . 24) (f94341 . 20) (f94343 . 16) (f94344 . 12) (f94345 . 8) (f94346 . 4) (f94339 . -28) (f94340 . -24) (f94341 . -20) (f94342 . -16) (f94343 . -12) (f94344 . -8) (f94345 . -4) (f94346 . 0))
#    expr = (funcall (vector-ref f94343 0) f94392 f94393)
# emit-expr (vector-ref f94343 0)
# emit-expr f94343
# emit-variable-ref
# env=((f94394 . -28) (f94393 . -24) (f94392 . -20) (f94394 . -16) (f94393 . -12) (f94392 . -8) (f94340 . 28) (f94342 . 24) (f94341 . 20) (f94343 . 16) (f94344 . 12) (f94345 . 8) (f94346 . 4) (f94339 . -28) (f94340 . -24) (f94341 . -20) (f94342 . -16) (f94343 . -12) (f94344 . -8) (f94345 . -4) (f94346 . 0))
# var=f94343
    movl 14(%edi), %eax  # frame load f94343
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_571819
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_571819:
    movl %eax, -32(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_571820"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_571820:
# check bounds on vector index
    movl -32(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_571822
    cmp  $0,%eax
    jge _L_571821
_L_571822:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_571821:
    movl -32(%esp), %esi
    movl -1(%eax,%esi), %eax
   movl %eax,  -32(%esp)  # stash funcall-oper in next closure slot
# emit-expr f94392
# emit-variable-ref
# env=((f94394 . -28) (f94393 . -24) (f94392 . -20) (f94394 . -16) (f94393 . -12) (f94392 . -8) (f94340 . 28) (f94342 . 24) (f94341 . 20) (f94343 . 16) (f94344 . 12) (f94345 . 8) (f94346 . 4) (f94339 . -28) (f94340 . -24) (f94341 . -20) (f94342 . -16) (f94343 . -12) (f94344 . -8) (f94345 . -4) (f94346 . 0))
# var=f94392
    movl -20(%esp), %eax  # stack load f94392
# end emit-variable-ref
    mov %eax, -36(%esp)    # arg f94392
# emit-expr f94393
# emit-variable-ref
# env=((f94394 . -28) (f94393 . -24) (f94392 . -20) (f94394 . -16) (f94393 . -12) (f94392 . -8) (f94340 . 28) (f94342 . 24) (f94341 . 20) (f94343 . 16) (f94344 . 12) (f94345 . 8) (f94346 . 4) (f94339 . -28) (f94340 . -24) (f94341 . -20) (f94342 . -16) (f94343 . -12) (f94344 . -8) (f94345 . -4) (f94346 . 0))
# var=f94393
    movl -24(%esp), %eax  # stack load f94393
# end emit-variable-ref
    mov %eax, -40(%esp)    # arg f94393
    movl -32(%esp), %edi   # load new closure to %edi
# emit-shift-args:  size=3   si=-32  delta=28
    mov -32(%esp), %ebx  # shift frame cell
    mov %ebx, -4(%esp)  # down to base
# emit-shift-args:  size=2   si=-36  delta=28
    mov -36(%esp), %ebx  # shift frame cell
    mov %ebx, -8(%esp)  # down to base
# emit-shift-args:  size=1   si=-40  delta=28
    mov -40(%esp), %ebx  # shift frame cell
    mov %ebx, -12(%esp)  # down to base
# emit-shift-args:  size=0   si=-44  delta=28
    movl $8,%eax   # save arg count
    jmp *-2(%edi)  # tail-funcall
    jmp _L_571818
_L_571817:
# emit-tail-expr
# si=-32
# env=((f94394 . -28) (f94393 . -24) (f94392 . -20) (f94394 . -16) (f94393 . -12) (f94392 . -8) (f94340 . 28) (f94342 . 24) (f94341 . 20) (f94343 . 16) (f94344 . 12) (f94345 . 8) (f94346 . 4) (f94339 . -28) (f94340 . -24) (f94341 . -20) (f94342 . -16) (f94343 . -12) (f94344 . -8) (f94345 . -4) (f94346 . 0))
# expr=(if (string? f94392) (if f94394 ((vector-ref f94341 0) f94392 f94393) ((vector-ref f94342 0) f94392 f94393)) (if (pair? f94392) ((vector-ref f94340 0) f94392 f94393) ((primitive-ref error) ((primitive-ref string->symbol) "write") "unrecognized expression")))
# emit-expr (string? f94392)
# emit-expr f94392
# emit-variable-ref
# env=((f94394 . -28) (f94393 . -24) (f94392 . -20) (f94394 . -16) (f94393 . -12) (f94392 . -8) (f94340 . 28) (f94342 . 24) (f94341 . 20) (f94343 . 16) (f94344 . 12) (f94345 . 8) (f94346 . 4) (f94339 . -28) (f94340 . -24) (f94341 . -20) (f94342 . -16) (f94343 . -12) (f94344 . -8) (f94345 . -4) (f94346 . 0))
# var=f94392
    movl -20(%esp), %eax  # stack load f94392
# end emit-variable-ref
    and $7, %al
    cmp $6, %al
    sete %al
    movzbl %al, %eax
    sal $6, %al
    or $47, %al
    cmp $47, %al
    je _L_571823
# emit-tail-expr
# si=-32
# env=((f94394 . -28) (f94393 . -24) (f94392 . -20) (f94394 . -16) (f94393 . -12) (f94392 . -8) (f94340 . 28) (f94342 . 24) (f94341 . 20) (f94343 . 16) (f94344 . 12) (f94345 . 8) (f94346 . 4) (f94339 . -28) (f94340 . -24) (f94341 . -20) (f94342 . -16) (f94343 . -12) (f94344 . -8) (f94345 . -4) (f94346 . 0))
# expr=(if f94394 ((vector-ref f94341 0) f94392 f94393) ((vector-ref f94342 0) f94392 f94393))
# emit-expr f94394
# emit-variable-ref
# env=((f94394 . -28) (f94393 . -24) (f94392 . -20) (f94394 . -16) (f94393 . -12) (f94392 . -8) (f94340 . 28) (f94342 . 24) (f94341 . 20) (f94343 . 16) (f94344 . 12) (f94345 . 8) (f94346 . 4) (f94339 . -28) (f94340 . -24) (f94341 . -20) (f94342 . -16) (f94343 . -12) (f94344 . -8) (f94345 . -4) (f94346 . 0))
# var=f94394
    movl -28(%esp), %eax  # stack load f94394
# end emit-variable-ref
    cmp $47, %al
    je _L_571825
# emit-tail-expr
# si=-32
# env=((f94394 . -28) (f94393 . -24) (f94392 . -20) (f94394 . -16) (f94393 . -12) (f94392 . -8) (f94340 . 28) (f94342 . 24) (f94341 . 20) (f94343 . 16) (f94344 . 12) (f94345 . 8) (f94346 . 4) (f94339 . -28) (f94340 . -24) (f94341 . -20) (f94342 . -16) (f94343 . -12) (f94344 . -8) (f94345 . -4) (f94346 . 0))
# expr=((vector-ref f94341 0) f94392 f94393)
# emit-tail-funcall
#    si   =-32
#    env  = ((f94394 . -28) (f94393 . -24) (f94392 . -20) (f94394 . -16) (f94393 . -12) (f94392 . -8) (f94340 . 28) (f94342 . 24) (f94341 . 20) (f94343 . 16) (f94344 . 12) (f94345 . 8) (f94346 . 4) (f94339 . -28) (f94340 . -24) (f94341 . -20) (f94342 . -16) (f94343 . -12) (f94344 . -8) (f94345 . -4) (f94346 . 0))
#    expr = (funcall (vector-ref f94341 0) f94392 f94393)
# emit-expr (vector-ref f94341 0)
# emit-expr f94341
# emit-variable-ref
# env=((f94394 . -28) (f94393 . -24) (f94392 . -20) (f94394 . -16) (f94393 . -12) (f94392 . -8) (f94340 . 28) (f94342 . 24) (f94341 . 20) (f94343 . 16) (f94344 . 12) (f94345 . 8) (f94346 . 4) (f94339 . -28) (f94340 . -24) (f94341 . -20) (f94342 . -16) (f94343 . -12) (f94344 . -8) (f94345 . -4) (f94346 . 0))
# var=f94341
    movl 18(%edi), %eax  # frame load f94341
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_571827
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_571827:
    movl %eax, -32(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_571828"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_571828:
# check bounds on vector index
    movl -32(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_571830
    cmp  $0,%eax
    jge _L_571829
_L_571830:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_571829:
    movl -32(%esp), %esi
    movl -1(%eax,%esi), %eax
   movl %eax,  -32(%esp)  # stash funcall-oper in next closure slot
# emit-expr f94392
# emit-variable-ref
# env=((f94394 . -28) (f94393 . -24) (f94392 . -20) (f94394 . -16) (f94393 . -12) (f94392 . -8) (f94340 . 28) (f94342 . 24) (f94341 . 20) (f94343 . 16) (f94344 . 12) (f94345 . 8) (f94346 . 4) (f94339 . -28) (f94340 . -24) (f94341 . -20) (f94342 . -16) (f94343 . -12) (f94344 . -8) (f94345 . -4) (f94346 . 0))
# var=f94392
    movl -20(%esp), %eax  # stack load f94392
# end emit-variable-ref
    mov %eax, -36(%esp)    # arg f94392
# emit-expr f94393
# emit-variable-ref
# env=((f94394 . -28) (f94393 . -24) (f94392 . -20) (f94394 . -16) (f94393 . -12) (f94392 . -8) (f94340 . 28) (f94342 . 24) (f94341 . 20) (f94343 . 16) (f94344 . 12) (f94345 . 8) (f94346 . 4) (f94339 . -28) (f94340 . -24) (f94341 . -20) (f94342 . -16) (f94343 . -12) (f94344 . -8) (f94345 . -4) (f94346 . 0))
# var=f94393
    movl -24(%esp), %eax  # stack load f94393
# end emit-variable-ref
    mov %eax, -40(%esp)    # arg f94393
    movl -32(%esp), %edi   # load new closure to %edi
# emit-shift-args:  size=3   si=-32  delta=28
    mov -32(%esp), %ebx  # shift frame cell
    mov %ebx, -4(%esp)  # down to base
# emit-shift-args:  size=2   si=-36  delta=28
    mov -36(%esp), %ebx  # shift frame cell
    mov %ebx, -8(%esp)  # down to base
# emit-shift-args:  size=1   si=-40  delta=28
    mov -40(%esp), %ebx  # shift frame cell
    mov %ebx, -12(%esp)  # down to base
# emit-shift-args:  size=0   si=-44  delta=28
    movl $8,%eax   # save arg count
    jmp *-2(%edi)  # tail-funcall
    jmp _L_571826
_L_571825:
# emit-tail-expr
# si=-32
# env=((f94394 . -28) (f94393 . -24) (f94392 . -20) (f94394 . -16) (f94393 . -12) (f94392 . -8) (f94340 . 28) (f94342 . 24) (f94341 . 20) (f94343 . 16) (f94344 . 12) (f94345 . 8) (f94346 . 4) (f94339 . -28) (f94340 . -24) (f94341 . -20) (f94342 . -16) (f94343 . -12) (f94344 . -8) (f94345 . -4) (f94346 . 0))
# expr=((vector-ref f94342 0) f94392 f94393)
# emit-tail-funcall
#    si   =-32
#    env  = ((f94394 . -28) (f94393 . -24) (f94392 . -20) (f94394 . -16) (f94393 . -12) (f94392 . -8) (f94340 . 28) (f94342 . 24) (f94341 . 20) (f94343 . 16) (f94344 . 12) (f94345 . 8) (f94346 . 4) (f94339 . -28) (f94340 . -24) (f94341 . -20) (f94342 . -16) (f94343 . -12) (f94344 . -8) (f94345 . -4) (f94346 . 0))
#    expr = (funcall (vector-ref f94342 0) f94392 f94393)
# emit-expr (vector-ref f94342 0)
# emit-expr f94342
# emit-variable-ref
# env=((f94394 . -28) (f94393 . -24) (f94392 . -20) (f94394 . -16) (f94393 . -12) (f94392 . -8) (f94340 . 28) (f94342 . 24) (f94341 . 20) (f94343 . 16) (f94344 . 12) (f94345 . 8) (f94346 . 4) (f94339 . -28) (f94340 . -24) (f94341 . -20) (f94342 . -16) (f94343 . -12) (f94344 . -8) (f94345 . -4) (f94346 . 0))
# var=f94342
    movl 22(%edi), %eax  # frame load f94342
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_571831
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_571831:
    movl %eax, -32(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_571832"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_571832:
# check bounds on vector index
    movl -32(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_571834
    cmp  $0,%eax
    jge _L_571833
_L_571834:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_571833:
    movl -32(%esp), %esi
    movl -1(%eax,%esi), %eax
   movl %eax,  -32(%esp)  # stash funcall-oper in next closure slot
# emit-expr f94392
# emit-variable-ref
# env=((f94394 . -28) (f94393 . -24) (f94392 . -20) (f94394 . -16) (f94393 . -12) (f94392 . -8) (f94340 . 28) (f94342 . 24) (f94341 . 20) (f94343 . 16) (f94344 . 12) (f94345 . 8) (f94346 . 4) (f94339 . -28) (f94340 . -24) (f94341 . -20) (f94342 . -16) (f94343 . -12) (f94344 . -8) (f94345 . -4) (f94346 . 0))
# var=f94392
    movl -20(%esp), %eax  # stack load f94392
# end emit-variable-ref
    mov %eax, -36(%esp)    # arg f94392
# emit-expr f94393
# emit-variable-ref
# env=((f94394 . -28) (f94393 . -24) (f94392 . -20) (f94394 . -16) (f94393 . -12) (f94392 . -8) (f94340 . 28) (f94342 . 24) (f94341 . 20) (f94343 . 16) (f94344 . 12) (f94345 . 8) (f94346 . 4) (f94339 . -28) (f94340 . -24) (f94341 . -20) (f94342 . -16) (f94343 . -12) (f94344 . -8) (f94345 . -4) (f94346 . 0))
# var=f94393
    movl -24(%esp), %eax  # stack load f94393
# end emit-variable-ref
    mov %eax, -40(%esp)    # arg f94393
    movl -32(%esp), %edi   # load new closure to %edi
# emit-shift-args:  size=3   si=-32  delta=28
    mov -32(%esp), %ebx  # shift frame cell
    mov %ebx, -4(%esp)  # down to base
# emit-shift-args:  size=2   si=-36  delta=28
    mov -36(%esp), %ebx  # shift frame cell
    mov %ebx, -8(%esp)  # down to base
# emit-shift-args:  size=1   si=-40  delta=28
    mov -40(%esp), %ebx  # shift frame cell
    mov %ebx, -12(%esp)  # down to base
# emit-shift-args:  size=0   si=-44  delta=28
    movl $8,%eax   # save arg count
    jmp *-2(%edi)  # tail-funcall
_L_571826:
    jmp _L_571824
_L_571823:
# emit-tail-expr
# si=-32
# env=((f94394 . -28) (f94393 . -24) (f94392 . -20) (f94394 . -16) (f94393 . -12) (f94392 . -8) (f94340 . 28) (f94342 . 24) (f94341 . 20) (f94343 . 16) (f94344 . 12) (f94345 . 8) (f94346 . 4) (f94339 . -28) (f94340 . -24) (f94341 . -20) (f94342 . -16) (f94343 . -12) (f94344 . -8) (f94345 . -4) (f94346 . 0))
# expr=(if (pair? f94392) ((vector-ref f94340 0) f94392 f94393) ((primitive-ref error) ((primitive-ref string->symbol) "write") "unrecognized expression"))
# emit-expr (pair? f94392)
# emit-expr f94392
# emit-variable-ref
# env=((f94394 . -28) (f94393 . -24) (f94392 . -20) (f94394 . -16) (f94393 . -12) (f94392 . -8) (f94340 . 28) (f94342 . 24) (f94341 . 20) (f94343 . 16) (f94344 . 12) (f94345 . 8) (f94346 . 4) (f94339 . -28) (f94340 . -24) (f94341 . -20) (f94342 . -16) (f94343 . -12) (f94344 . -8) (f94345 . -4) (f94346 . 0))
# var=f94392
    movl -20(%esp), %eax  # stack load f94392
# end emit-variable-ref
    and $7, %al
    cmp $1, %al
    sete %al
    movzbl %al, %eax
    sal $6, %al
    or $47, %al
    cmp $47, %al
    je _L_571835
# emit-tail-expr
# si=-32
# env=((f94394 . -28) (f94393 . -24) (f94392 . -20) (f94394 . -16) (f94393 . -12) (f94392 . -8) (f94340 . 28) (f94342 . 24) (f94341 . 20) (f94343 . 16) (f94344 . 12) (f94345 . 8) (f94346 . 4) (f94339 . -28) (f94340 . -24) (f94341 . -20) (f94342 . -16) (f94343 . -12) (f94344 . -8) (f94345 . -4) (f94346 . 0))
# expr=((vector-ref f94340 0) f94392 f94393)
# emit-tail-funcall
#    si   =-32
#    env  = ((f94394 . -28) (f94393 . -24) (f94392 . -20) (f94394 . -16) (f94393 . -12) (f94392 . -8) (f94340 . 28) (f94342 . 24) (f94341 . 20) (f94343 . 16) (f94344 . 12) (f94345 . 8) (f94346 . 4) (f94339 . -28) (f94340 . -24) (f94341 . -20) (f94342 . -16) (f94343 . -12) (f94344 . -8) (f94345 . -4) (f94346 . 0))
#    expr = (funcall (vector-ref f94340 0) f94392 f94393)
# emit-expr (vector-ref f94340 0)
# emit-expr f94340
# emit-variable-ref
# env=((f94394 . -28) (f94393 . -24) (f94392 . -20) (f94394 . -16) (f94393 . -12) (f94392 . -8) (f94340 . 28) (f94342 . 24) (f94341 . 20) (f94343 . 16) (f94344 . 12) (f94345 . 8) (f94346 . 4) (f94339 . -28) (f94340 . -24) (f94341 . -20) (f94342 . -16) (f94343 . -12) (f94344 . -8) (f94345 . -4) (f94346 . 0))
# var=f94340
    movl 26(%edi), %eax  # frame load f94340
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_571837
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_571837:
    movl %eax, -32(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_571838"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_571838:
# check bounds on vector index
    movl -32(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_571840
    cmp  $0,%eax
    jge _L_571839
_L_571840:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_571839:
    movl -32(%esp), %esi
    movl -1(%eax,%esi), %eax
   movl %eax,  -32(%esp)  # stash funcall-oper in next closure slot
# emit-expr f94392
# emit-variable-ref
# env=((f94394 . -28) (f94393 . -24) (f94392 . -20) (f94394 . -16) (f94393 . -12) (f94392 . -8) (f94340 . 28) (f94342 . 24) (f94341 . 20) (f94343 . 16) (f94344 . 12) (f94345 . 8) (f94346 . 4) (f94339 . -28) (f94340 . -24) (f94341 . -20) (f94342 . -16) (f94343 . -12) (f94344 . -8) (f94345 . -4) (f94346 . 0))
# var=f94392
    movl -20(%esp), %eax  # stack load f94392
# end emit-variable-ref
    mov %eax, -36(%esp)    # arg f94392
# emit-expr f94393
# emit-variable-ref
# env=((f94394 . -28) (f94393 . -24) (f94392 . -20) (f94394 . -16) (f94393 . -12) (f94392 . -8) (f94340 . 28) (f94342 . 24) (f94341 . 20) (f94343 . 16) (f94344 . 12) (f94345 . 8) (f94346 . 4) (f94339 . -28) (f94340 . -24) (f94341 . -20) (f94342 . -16) (f94343 . -12) (f94344 . -8) (f94345 . -4) (f94346 . 0))
# var=f94393
    movl -24(%esp), %eax  # stack load f94393
# end emit-variable-ref
    mov %eax, -40(%esp)    # arg f94393
    movl -32(%esp), %edi   # load new closure to %edi
# emit-shift-args:  size=3   si=-32  delta=28
    mov -32(%esp), %ebx  # shift frame cell
    mov %ebx, -4(%esp)  # down to base
# emit-shift-args:  size=2   si=-36  delta=28
    mov -36(%esp), %ebx  # shift frame cell
    mov %ebx, -8(%esp)  # down to base
# emit-shift-args:  size=1   si=-40  delta=28
    mov -40(%esp), %ebx  # shift frame cell
    mov %ebx, -12(%esp)  # down to base
# emit-shift-args:  size=0   si=-44  delta=28
    movl $8,%eax   # save arg count
    jmp *-2(%edi)  # tail-funcall
    jmp _L_571836
_L_571835:
# emit-tail-expr
# si=-32
# env=((f94394 . -28) (f94393 . -24) (f94392 . -20) (f94394 . -16) (f94393 . -12) (f94392 . -8) (f94340 . 28) (f94342 . 24) (f94341 . 20) (f94343 . 16) (f94344 . 12) (f94345 . 8) (f94346 . 4) (f94339 . -28) (f94340 . -24) (f94341 . -20) (f94342 . -16) (f94343 . -12) (f94344 . -8) (f94345 . -4) (f94346 . 0))
# expr=((primitive-ref error) ((primitive-ref string->symbol) "write") "unrecognized expression")
# emit-tail-funcall
#    si   =-32
#    env  = ((f94394 . -28) (f94393 . -24) (f94392 . -20) (f94394 . -16) (f94393 . -12) (f94392 . -8) (f94340 . 28) (f94342 . 24) (f94341 . 20) (f94343 . 16) (f94344 . 12) (f94345 . 8) (f94346 . 4) (f94339 . -28) (f94340 . -24) (f94341 . -20) (f94342 . -16) (f94343 . -12) (f94344 . -8) (f94345 . -4) (f94346 . 0))
#    expr = (funcall (primitive-ref error) ((primitive-ref string->symbol) "write") "unrecognized expression")
# emit-expr (primitive-ref error)
    .extern mrc_error
    movl mrc_error,%eax
   movl %eax,  -32(%esp)  # stash funcall-oper in next closure slot
# emit-expr ((primitive-ref string->symbol) "write")
# funcall
#    si   =-36
#    env  = ((f94394 . -28) (f94393 . -24) (f94392 . -20) (f94394 . -16) (f94393 . -12) (f94392 . -8) (f94340 . 28) (f94342 . 24) (f94341 . 20) (f94343 . 16) (f94344 . 12) (f94345 . 8) (f94346 . 4) (f94339 . -28) (f94340 . -24) (f94341 . -20) (f94342 . -16) (f94343 . -12) (f94344 . -8) (f94345 . -4) (f94346 . 0))
#    expr = (funcall (primitive-ref string->symbol) "write")
# emit-expr (primitive-ref string->symbol)
    .extern mrc_string$m$gsymbol
    movl mrc_string$m$gsymbol,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_571841"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_571841":
   movl %eax,  -44(%esp)  # stash funcall-oper in closure slot
# emit-expr "write"
# string literal
    jmp _L_571843
    .align 8,0x90
_L_571842 :
    .int 20
    .ascii "write"
_L_571843:
    movl $_L_571842, %eax
    orl $6, %eax
    mov %eax, -48(%esp)  # arg write
    movl -44(%esp), %edi   # load new closure to %edi
    add $-36, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $36, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    mov %eax, -36(%esp)    # arg ((primitive-ref string->symbol) write)
# emit-expr "unrecognized expression"
# string literal
    jmp _L_571845
    .align 8,0x90
_L_571844 :
    .int 92
    .ascii "unrecognized expression"
_L_571845:
    movl $_L_571844, %eax
    orl $6, %eax
    mov %eax, -40(%esp)    # arg unrecognized expression
    movl -32(%esp), %edi   # load new closure to %edi
# emit-shift-args:  size=3   si=-32  delta=28
    mov -32(%esp), %ebx  # shift frame cell
    mov %ebx, -4(%esp)  # down to base
# emit-shift-args:  size=2   si=-36  delta=28
    mov -36(%esp), %ebx  # shift frame cell
    mov %ebx, -8(%esp)  # down to base
# emit-shift-args:  size=1   si=-40  delta=28
    mov -40(%esp), %ebx  # shift frame cell
    mov %ebx, -12(%esp)  # down to base
# emit-shift-args:  size=0   si=-44  delta=28
    movl $8,%eax   # save arg count
    jmp *-2(%edi)  # tail-funcall
_L_571836:
_L_571824:
_L_571818:
_L_571810:
_L_571804:
_L_571798:
    .align 4,0x90
_L_571795:
# emit-expr (begin)
# emit-begin
#   expr=(begin)
#   env=((f94339 . -28) (f94340 . -24) (f94341 . -20) (f94342 . -16) (f94343 . -12) (f94344 . -8) (f94345 . -4) (f94346 . 0))
     movl %eax, mrc_base$mwrite
# == explicit-begins  ==>
# (lambda (expr . args) (let ((p (if (null? args) (current-output-port) (car args)))) (base-write expr p #f)))
# == eliminate-let*  ==>
# (lambda (expr . args) (let ((p (if (null? args) (current-output-port) (car args)))) (base-write expr p #f)))
# == uniquify-variables  ==>
# (lambda (f94395 . f94396) (let ((f94398 (if (null? f94396) (current-output-port) (car f94396)))) (base-write f94395 f94398 #f)))
# == vectorize-letrec  ==>
# (lambda (f94395 . f94396) (let ((f94398 (if (null? f94396) (current-output-port) (car f94396)))) (base-write f94395 f94398 #f)))
# == eliminate-set!  ==>
# (lambda (f94395 . f94396) (let ((f94395 f94395)) (let ((f94398 (if (null? f94396) (current-output-port) (car f94396)))) (base-write f94395 f94398 #f))))
# == close-free-variables  ==>
# (closure (f94395 . f94396) () (let ((f94395 f94395)) (let ((f94398 (if (null? f94396) (current-output-port) (car f94396)))) (base-write f94395 f94398 #f))))
# == eliminate-quote  ==>
# (closure (f94395 . f94396) () (let ((f94395 f94395)) (let ((f94398 (if (null? f94396) (current-output-port) (car f94396)))) (base-write f94395 f94398 #f))))
# == eliminate-when/unless  ==>
# (closure (f94395 . f94396) () (let ((f94395 f94395)) (let ((f94398 (if (null? f94396) (current-output-port) (car f94396)))) (base-write f94395 f94398 #f))))
# == eliminate-cond  ==>
# (closure (f94395 . f94396) () (let ((f94395 f94395)) (let ((f94398 (if (null? f94396) (current-output-port) (car f94396)))) (base-write f94395 f94398 #f))))
# == external-symbols  ==>
# (closure (f94395 . f94396) () (let ((f94395 f94395)) (let ((f94398 (if (null? f94396) ((primitive-ref current-output-port)) (car f94396)))) ((primitive-ref base-write) f94395 f94398 #f))))
# emit-expr (closure (f94395 . f94396) () (let ((f94395 f94395)) (let ((f94398 (if (null? f94396) ((primitive-ref current-output-port)) (car f94396)))) ((primitive-ref base-write) f94395 f94398 #f))))
# emit-closure
# si = 0
# env = ()
# expr = (closure (f94395 . f94396) () (let ((f94395 f94395)) (let ((f94398 (if (null? f94396) ((primitive-ref current-output-port)) (car f94396)))) ((primitive-ref base-write) f94395 f94398 #f))))
    movl $_L_571846, 0(%ebp)  # closure label
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $8, %ebp     # bump ebp
    jmp _L_571847            # jump around closure body
_L_571846:
# check argument count
    cmp $4,%eax
    jge _L_571848
# invoke error handler eh_argcount_min
    .extern mrc_eh$uargcount$umin
    movl mrc_eh$uargcount$umin, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_571848:
# emit-build-varargs-list
    movl $63, %esi       # args <- () 
    lea -4(%esp),%edi    # edi <- esp-4
    subl %eax, %edi      # edi <- esp-4-eax    addr of arg[K+N] on stack
_L_571850:
    lea -8(%esp),%ebx    # addr of arg[K] on stack
    cmp %edi, %ebx       # while edi <> esp+(si+4)
    je _L_571849
    movl (%edi),%ebx     # arg i -> car
    movl %ebx, 0(%ebp)
    movl %esi, 4(%ebp)  # esi -> cdr
    movl %ebp, %esi
    addl $1, %esi       # tag as pair
    addl $8,%ebp         # bump heap ptr
    addl $4,%edi         # move to next previous arg from the end
    jmp _L_571850
_L_571849:
    movl %esi, -12(%esp)  # set args
# emit-tail-expr
# si=-16
# env=((f94396 . -12) (f94395 . -8))
# expr=(let ((f94395 f94395)) (let ((f94398 (if (null? f94396) ((primitive-ref current-output-port)) (car f94396)))) ((primitive-ref base-write) f94395 f94398 #f)))
# emit-tail-let
#  si   = -16
#  env  = ((f94396 . -12) (f94395 . -8))
#  bindings = ((f94395 f94395))
#  body = (let ((f94398 (if (null? f94396) ((primitive-ref current-output-port)) (car f94396)))) ((primitive-ref base-write) f94395 f94398 #f))
# emit-expr f94395
# emit-variable-ref
# env=((f94396 . -12) (f94395 . -8))
# var=f94395
    movl -8(%esp), %eax  # stack load f94395
# end emit-variable-ref
    movl %eax, -16(%esp)  # stack save
# emit-tail-expr
# si=-20
# env=((f94395 . -16) (f94396 . -12) (f94395 . -8))
# expr=(let ((f94398 (if (null? f94396) ((primitive-ref current-output-port)) (car f94396)))) ((primitive-ref base-write) f94395 f94398 #f))
# emit-tail-let
#  si   = -20
#  env  = ((f94395 . -16) (f94396 . -12) (f94395 . -8))
#  bindings = ((f94398 (if (null? f94396) ((primitive-ref current-output-port)) (car f94396))))
#  body = ((primitive-ref base-write) f94395 f94398 #f)
# emit-expr (if (null? f94396) ((primitive-ref current-output-port)) (car f94396))
# emit-expr (null? f94396)
# emit-expr f94396
# emit-variable-ref
# env=((f94395 . -16) (f94396 . -12) (f94395 . -8))
# var=f94396
    movl -12(%esp), %eax  # stack load f94396
# end emit-variable-ref
    cmp $63, %eax
    mov $0, %eax
    sete %al
    movzbl %al, %eax
    sal $6, %al
    or $47, %al
    cmp $47, %al
    je _L_571851
# emit-expr ((primitive-ref current-output-port))
# funcall
#    si   =-20
#    env  = ((f94395 . -16) (f94396 . -12) (f94395 . -8))
#    expr = (funcall (primitive-ref current-output-port))
# emit-expr (primitive-ref current-output-port)
    .extern mrc_current$moutput$mport
    movl mrc_current$moutput$mport,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_571853"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_571853":
   movl %eax,  -28(%esp)  # stash funcall-oper in closure slot
    movl -28(%esp), %edi   # load new closure to %edi
    add $-20, %esp   # adjust base
    movl $0,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $20, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    jmp _L_571852
_L_571851:
# emit-expr (car f94396)
# emit-expr f94396
# emit-variable-ref
# env=((f94395 . -16) (f94396 . -12) (f94395 . -8))
# var=f94396
    movl -12(%esp), %eax  # stack load f94396
# end emit-variable-ref
# check the argument is a pair
    movl %eax,%ebx
    and $7, %bl
    cmp $1, %bl
    je _L_571854
# invoke error handler eh_pair
    .extern mrc_eh$upair
    movl mrc_eh$upair, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $116,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_571854:
    movl -1(%eax), %eax
_L_571852:
    movl %eax, -20(%esp)  # stack save
# emit-tail-expr
# si=-24
# env=((f94398 . -20) (f94395 . -16) (f94396 . -12) (f94395 . -8))
# expr=((primitive-ref base-write) f94395 f94398 #f)
# emit-tail-funcall
#    si   =-24
#    env  = ((f94398 . -20) (f94395 . -16) (f94396 . -12) (f94395 . -8))
#    expr = (funcall (primitive-ref base-write) f94395 f94398 #f)
# emit-expr (primitive-ref base-write)
    .extern mrc_base$mwrite
    movl mrc_base$mwrite,%eax
   movl %eax,  -24(%esp)  # stash funcall-oper in next closure slot
# emit-expr f94395
# emit-variable-ref
# env=((f94398 . -20) (f94395 . -16) (f94396 . -12) (f94395 . -8))
# var=f94395
    movl -16(%esp), %eax  # stack load f94395
# end emit-variable-ref
    mov %eax, -28(%esp)    # arg f94395
# emit-expr f94398
# emit-variable-ref
# env=((f94398 . -20) (f94395 . -16) (f94396 . -12) (f94395 . -8))
# var=f94398
    movl -20(%esp), %eax  # stack load f94398
# end emit-variable-ref
    mov %eax, -32(%esp)    # arg f94398
# emit-expr #f
    movl $47, %eax     # immed #f
    mov %eax, -36(%esp)    # arg #f
    movl -24(%esp), %edi   # load new closure to %edi
# emit-shift-args:  size=4   si=-24  delta=20
    mov -24(%esp), %ebx  # shift frame cell
    mov %ebx, -4(%esp)  # down to base
# emit-shift-args:  size=3   si=-28  delta=20
    mov -28(%esp), %ebx  # shift frame cell
    mov %ebx, -8(%esp)  # down to base
# emit-shift-args:  size=2   si=-32  delta=20
    mov -32(%esp), %ebx  # shift frame cell
    mov %ebx, -12(%esp)  # down to base
# emit-shift-args:  size=1   si=-36  delta=20
    mov -36(%esp), %ebx  # shift frame cell
    mov %ebx, -16(%esp)  # down to base
# emit-shift-args:  size=0   si=-40  delta=20
    movl $12,%eax   # save arg count
    jmp *-2(%edi)  # tail-funcall
    .align 4,0x90
_L_571847:
     movl %eax, mrc_write
# == explicit-begins  ==>
# (lambda (expr . args) (let ((p (if (null? args) (current-output-port) (car args)))) (base-write expr p #t)))
# == eliminate-let*  ==>
# (lambda (expr . args) (let ((p (if (null? args) (current-output-port) (car args)))) (base-write expr p #t)))
# == uniquify-variables  ==>
# (lambda (f94399 . f94400) (let ((f94402 (if (null? f94400) (current-output-port) (car f94400)))) (base-write f94399 f94402 #t)))
# == vectorize-letrec  ==>
# (lambda (f94399 . f94400) (let ((f94402 (if (null? f94400) (current-output-port) (car f94400)))) (base-write f94399 f94402 #t)))
# == eliminate-set!  ==>
# (lambda (f94399 . f94400) (let ((f94399 f94399)) (let ((f94402 (if (null? f94400) (current-output-port) (car f94400)))) (base-write f94399 f94402 #t))))
# == close-free-variables  ==>
# (closure (f94399 . f94400) () (let ((f94399 f94399)) (let ((f94402 (if (null? f94400) (current-output-port) (car f94400)))) (base-write f94399 f94402 #t))))
# == eliminate-quote  ==>
# (closure (f94399 . f94400) () (let ((f94399 f94399)) (let ((f94402 (if (null? f94400) (current-output-port) (car f94400)))) (base-write f94399 f94402 #t))))
# == eliminate-when/unless  ==>
# (closure (f94399 . f94400) () (let ((f94399 f94399)) (let ((f94402 (if (null? f94400) (current-output-port) (car f94400)))) (base-write f94399 f94402 #t))))
# == eliminate-cond  ==>
# (closure (f94399 . f94400) () (let ((f94399 f94399)) (let ((f94402 (if (null? f94400) (current-output-port) (car f94400)))) (base-write f94399 f94402 #t))))
# == external-symbols  ==>
# (closure (f94399 . f94400) () (let ((f94399 f94399)) (let ((f94402 (if (null? f94400) ((primitive-ref current-output-port)) (car f94400)))) ((primitive-ref base-write) f94399 f94402 #t))))
# emit-expr (closure (f94399 . f94400) () (let ((f94399 f94399)) (let ((f94402 (if (null? f94400) ((primitive-ref current-output-port)) (car f94400)))) ((primitive-ref base-write) f94399 f94402 #t))))
# emit-closure
# si = 0
# env = ()
# expr = (closure (f94399 . f94400) () (let ((f94399 f94399)) (let ((f94402 (if (null? f94400) ((primitive-ref current-output-port)) (car f94400)))) ((primitive-ref base-write) f94399 f94402 #t))))
    movl $_L_571855, 0(%ebp)  # closure label
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $8, %ebp     # bump ebp
    jmp _L_571856            # jump around closure body
_L_571855:
# check argument count
    cmp $4,%eax
    jge _L_571857
# invoke error handler eh_argcount_min
    .extern mrc_eh$uargcount$umin
    movl mrc_eh$uargcount$umin, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_571857:
# emit-build-varargs-list
    movl $63, %esi       # args <- () 
    lea -4(%esp),%edi    # edi <- esp-4
    subl %eax, %edi      # edi <- esp-4-eax    addr of arg[K+N] on stack
_L_571859:
    lea -8(%esp),%ebx    # addr of arg[K] on stack
    cmp %edi, %ebx       # while edi <> esp+(si+4)
    je _L_571858
    movl (%edi),%ebx     # arg i -> car
    movl %ebx, 0(%ebp)
    movl %esi, 4(%ebp)  # esi -> cdr
    movl %ebp, %esi
    addl $1, %esi       # tag as pair
    addl $8,%ebp         # bump heap ptr
    addl $4,%edi         # move to next previous arg from the end
    jmp _L_571859
_L_571858:
    movl %esi, -12(%esp)  # set args
# emit-tail-expr
# si=-16
# env=((f94400 . -12) (f94399 . -8))
# expr=(let ((f94399 f94399)) (let ((f94402 (if (null? f94400) ((primitive-ref current-output-port)) (car f94400)))) ((primitive-ref base-write) f94399 f94402 #t)))
# emit-tail-let
#  si   = -16
#  env  = ((f94400 . -12) (f94399 . -8))
#  bindings = ((f94399 f94399))
#  body = (let ((f94402 (if (null? f94400) ((primitive-ref current-output-port)) (car f94400)))) ((primitive-ref base-write) f94399 f94402 #t))
# emit-expr f94399
# emit-variable-ref
# env=((f94400 . -12) (f94399 . -8))
# var=f94399
    movl -8(%esp), %eax  # stack load f94399
# end emit-variable-ref
    movl %eax, -16(%esp)  # stack save
# emit-tail-expr
# si=-20
# env=((f94399 . -16) (f94400 . -12) (f94399 . -8))
# expr=(let ((f94402 (if (null? f94400) ((primitive-ref current-output-port)) (car f94400)))) ((primitive-ref base-write) f94399 f94402 #t))
# emit-tail-let
#  si   = -20
#  env  = ((f94399 . -16) (f94400 . -12) (f94399 . -8))
#  bindings = ((f94402 (if (null? f94400) ((primitive-ref current-output-port)) (car f94400))))
#  body = ((primitive-ref base-write) f94399 f94402 #t)
# emit-expr (if (null? f94400) ((primitive-ref current-output-port)) (car f94400))
# emit-expr (null? f94400)
# emit-expr f94400
# emit-variable-ref
# env=((f94399 . -16) (f94400 . -12) (f94399 . -8))
# var=f94400
    movl -12(%esp), %eax  # stack load f94400
# end emit-variable-ref
    cmp $63, %eax
    mov $0, %eax
    sete %al
    movzbl %al, %eax
    sal $6, %al
    or $47, %al
    cmp $47, %al
    je _L_571860
# emit-expr ((primitive-ref current-output-port))
# funcall
#    si   =-20
#    env  = ((f94399 . -16) (f94400 . -12) (f94399 . -8))
#    expr = (funcall (primitive-ref current-output-port))
# emit-expr (primitive-ref current-output-port)
    .extern mrc_current$moutput$mport
    movl mrc_current$moutput$mport,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_571862"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_571862":
   movl %eax,  -28(%esp)  # stash funcall-oper in closure slot
    movl -28(%esp), %edi   # load new closure to %edi
    add $-20, %esp   # adjust base
    movl $0,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $20, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    jmp _L_571861
_L_571860:
# emit-expr (car f94400)
# emit-expr f94400
# emit-variable-ref
# env=((f94399 . -16) (f94400 . -12) (f94399 . -8))
# var=f94400
    movl -12(%esp), %eax  # stack load f94400
# end emit-variable-ref
# check the argument is a pair
    movl %eax,%ebx
    and $7, %bl
    cmp $1, %bl
    je _L_571863
# invoke error handler eh_pair
    .extern mrc_eh$upair
    movl mrc_eh$upair, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $116,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_571863:
    movl -1(%eax), %eax
_L_571861:
    movl %eax, -20(%esp)  # stack save
# emit-tail-expr
# si=-24
# env=((f94402 . -20) (f94399 . -16) (f94400 . -12) (f94399 . -8))
# expr=((primitive-ref base-write) f94399 f94402 #t)
# emit-tail-funcall
#    si   =-24
#    env  = ((f94402 . -20) (f94399 . -16) (f94400 . -12) (f94399 . -8))
#    expr = (funcall (primitive-ref base-write) f94399 f94402 #t)
# emit-expr (primitive-ref base-write)
    .extern mrc_base$mwrite
    movl mrc_base$mwrite,%eax
   movl %eax,  -24(%esp)  # stash funcall-oper in next closure slot
# emit-expr f94399
# emit-variable-ref
# env=((f94402 . -20) (f94399 . -16) (f94400 . -12) (f94399 . -8))
# var=f94399
    movl -16(%esp), %eax  # stack load f94399
# end emit-variable-ref
    mov %eax, -28(%esp)    # arg f94399
# emit-expr f94402
# emit-variable-ref
# env=((f94402 . -20) (f94399 . -16) (f94400 . -12) (f94399 . -8))
# var=f94402
    movl -20(%esp), %eax  # stack load f94402
# end emit-variable-ref
    mov %eax, -32(%esp)    # arg f94402
# emit-expr #t
    movl $111, %eax     # immed #t
    mov %eax, -36(%esp)    # arg #t
    movl -24(%esp), %edi   # load new closure to %edi
# emit-shift-args:  size=4   si=-24  delta=20
    mov -24(%esp), %ebx  # shift frame cell
    mov %ebx, -4(%esp)  # down to base
# emit-shift-args:  size=3   si=-28  delta=20
    mov -28(%esp), %ebx  # shift frame cell
    mov %ebx, -8(%esp)  # down to base
# emit-shift-args:  size=2   si=-32  delta=20
    mov -32(%esp), %ebx  # shift frame cell
    mov %ebx, -12(%esp)  # down to base
# emit-shift-args:  size=1   si=-36  delta=20
    mov -36(%esp), %ebx  # shift frame cell
    mov %ebx, -16(%esp)  # down to base
# emit-shift-args:  size=0   si=-40  delta=20
    movl $12,%eax   # save arg count
    jmp *-2(%edi)  # tail-funcall
    .align 4,0x90
_L_571856:
     movl %eax, mrc_display
# == explicit-begins  ==>
# (lambda (i) (fixnum->char i))
# == eliminate-let*  ==>
# (lambda (i) (fixnum->char i))
# == uniquify-variables  ==>
# (lambda (f94403) (fixnum->char f94403))
# == vectorize-letrec  ==>
# (lambda (f94403) (fixnum->char f94403))
# == eliminate-set!  ==>
# (lambda (f94403) (let ((f94403 f94403)) (fixnum->char f94403)))
# == close-free-variables  ==>
# (closure (f94403) () (let ((f94403 f94403)) (fixnum->char f94403)))
# == eliminate-quote  ==>
# (closure (f94403) () (let ((f94403 f94403)) (fixnum->char f94403)))
# == eliminate-when/unless  ==>
# (closure (f94403) () (let ((f94403 f94403)) (fixnum->char f94403)))
# == eliminate-cond  ==>
# (closure (f94403) () (let ((f94403 f94403)) (fixnum->char f94403)))
# == external-symbols  ==>
# (closure (f94403) () (let ((f94403 f94403)) (fixnum->char f94403)))
# emit-expr (closure (f94403) () (let ((f94403 f94403)) (fixnum->char f94403)))
# emit-closure
# si = 0
# env = ()
# expr = (closure (f94403) () (let ((f94403 f94403)) (fixnum->char f94403)))
    movl $_L_571864, 0(%ebp)  # closure label
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $8, %ebp     # bump ebp
    jmp _L_571865            # jump around closure body
_L_571864:
# check argument count
    cmp $4,%eax
    je _L_571866
# invoke error handler eh_argcount
    .extern mrc_eh$uargcount
    movl mrc_eh$uargcount, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_571866:
# emit-tail-expr
# si=-12
# env=((f94403 . -8))
# expr=(let ((f94403 f94403)) (fixnum->char f94403))
# emit-tail-let
#  si   = -12
#  env  = ((f94403 . -8))
#  bindings = ((f94403 f94403))
#  body = (fixnum->char f94403)
# emit-expr f94403
# emit-variable-ref
# env=((f94403 . -8))
# var=f94403
    movl -8(%esp), %eax  # stack load f94403
# end emit-variable-ref
    movl %eax, -12(%esp)  # stack save
# emit-tail-expr
# si=-16
# env=((f94403 . -12) (f94403 . -8))
# expr=(fixnum->char f94403)
# tail primcall
# emit-expr f94403
# emit-variable-ref
# env=((f94403 . -12) (f94403 . -8))
# var=f94403
    movl -12(%esp), %eax  # stack load f94403
# end emit-variable-ref
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_571867"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $0,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_571867:
    shll $6, %eax
    orl $15, %eax
#return from tail (fixnum->char f94403)
    ret
    .align 4,0x90
_L_571865:
     movl %eax, mrc_integer$m$gchar
# == explicit-begins  ==>
# (let* ((p (make-vector 8)) (sz 1024)) (begin (vector-set! p 0 (quote input-port)) (vector-set! p 1 "/dev/stdin") (vector-set! p 2 0) (vector-set! p 3 (make-string sz)) (vector-set! p 4 0) (vector-set! p 5 sz) (vector-set! p 6 #f) (vector-set! p 7 -1) p))
# == eliminate-let*  ==>
# (let ((p (make-vector 8))) (let ((sz 1024)) (begin (vector-set! p 0 (quote input-port)) (vector-set! p 1 "/dev/stdin") (vector-set! p 2 0) (vector-set! p 3 (make-string sz)) (vector-set! p 4 0) (vector-set! p 5 sz) (vector-set! p 6 #f) (vector-set! p 7 -1) p)))
# == uniquify-variables  ==>
# (let ((f94404 (make-vector 8))) (let ((f94406 1024)) (begin (vector-set! f94404 0 (quote input-port)) (vector-set! f94404 1 "/dev/stdin") (vector-set! f94404 2 0) (vector-set! f94404 3 (make-string f94406)) (vector-set! f94404 4 0) (vector-set! f94404 5 f94406) (vector-set! f94404 6 #f) (vector-set! f94404 7 -1) f94404)))
# == vectorize-letrec  ==>
# (let ((f94404 (make-vector 8))) (let ((f94406 1024)) (begin (vector-set! f94404 0 (quote input-port)) (vector-set! f94404 1 "/dev/stdin") (vector-set! f94404 2 0) (vector-set! f94404 3 (make-string f94406)) (vector-set! f94404 4 0) (vector-set! f94404 5 f94406) (vector-set! f94404 6 #f) (vector-set! f94404 7 -1) f94404)))
# == eliminate-set!  ==>
# (let ((f94404 (make-vector 8))) (let ((f94406 1024)) (begin (vector-set! f94404 0 (quote input-port)) (vector-set! f94404 1 "/dev/stdin") (vector-set! f94404 2 0) (vector-set! f94404 3 (make-string f94406)) (vector-set! f94404 4 0) (vector-set! f94404 5 f94406) (vector-set! f94404 6 #f) (vector-set! f94404 7 -1) f94404)))
# == close-free-variables  ==>
# (let ((f94404 (make-vector 8))) (let ((f94406 1024)) (begin (vector-set! f94404 0 (quote input-port)) (vector-set! f94404 1 "/dev/stdin") (vector-set! f94404 2 0) (vector-set! f94404 3 (make-string f94406)) (vector-set! f94404 4 0) (vector-set! f94404 5 f94406) (vector-set! f94404 6 #f) (vector-set! f94404 7 -1) f94404)))
# == eliminate-quote  ==>
# (let ((f94404 (make-vector 8))) (let ((f94406 1024)) (begin (vector-set! f94404 0 (string->symbol "input-port")) (vector-set! f94404 1 "/dev/stdin") (vector-set! f94404 2 0) (vector-set! f94404 3 (make-string f94406)) (vector-set! f94404 4 0) (vector-set! f94404 5 f94406) (vector-set! f94404 6 #f) (vector-set! f94404 7 -1) f94404)))
# == eliminate-when/unless  ==>
# (let ((f94404 (make-vector 8))) (let ((f94406 1024)) (begin (vector-set! f94404 0 (string->symbol "input-port")) (vector-set! f94404 1 "/dev/stdin") (vector-set! f94404 2 0) (vector-set! f94404 3 (make-string f94406)) (vector-set! f94404 4 0) (vector-set! f94404 5 f94406) (vector-set! f94404 6 #f) (vector-set! f94404 7 -1) f94404)))
# == eliminate-cond  ==>
# (let ((f94404 (make-vector 8))) (let ((f94406 1024)) (begin (vector-set! f94404 0 (string->symbol "input-port")) (vector-set! f94404 1 "/dev/stdin") (vector-set! f94404 2 0) (vector-set! f94404 3 (make-string f94406)) (vector-set! f94404 4 0) (vector-set! f94404 5 f94406) (vector-set! f94404 6 #f) (vector-set! f94404 7 -1) f94404)))
# == external-symbols  ==>
# (let ((f94404 (make-vector 8))) (let ((f94406 1024)) (begin (vector-set! f94404 0 ((primitive-ref string->symbol) "input-port")) (vector-set! f94404 1 "/dev/stdin") (vector-set! f94404 2 0) (vector-set! f94404 3 (make-string f94406)) (vector-set! f94404 4 0) (vector-set! f94404 5 f94406) (vector-set! f94404 6 #f) (vector-set! f94404 7 -1) f94404)))
# emit-expr (let ((f94404 (make-vector 8))) (let ((f94406 1024)) (begin (vector-set! f94404 0 ((primitive-ref string->symbol) "input-port")) (vector-set! f94404 1 "/dev/stdin") (vector-set! f94404 2 0) (vector-set! f94404 3 (make-string f94406)) (vector-set! f94404 4 0) (vector-set! f94404 5 f94406) (vector-set! f94404 6 #f) (vector-set! f94404 7 -1) f94404)))
# emit-let
#  si   = 0
#  env  = ()
#  bindings = ((f94404 (make-vector 8)))
#  body = (let ((f94406 1024)) (begin (vector-set! f94404 0 ((primitive-ref string->symbol) "input-port")) (vector-set! f94404 1 "/dev/stdin") (vector-set! f94404 2 0) (vector-set! f94404 3 (make-string f94406)) (vector-set! f94404 4 0) (vector-set! f94404 5 f94406) (vector-set! f94404 6 #f) (vector-set! f94404 7 -1) f94404))
# emit-expr (make-vector 8)
# make-vector 8
# emit-expr 8
    movl $32, %eax     # immed 8
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_571868"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_571868:
# check the argument is a fixnum >= 0
    cmp $0,%eax
    jge _L_571869
# invoke error handler eh_length
    .extern mrc_eh$ulength
    movl mrc_eh$ulength, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_571869:
    movl %eax, %esi
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    orl  $5, %eax
    addl $4, %esi
    addl $4, %esi
    andl $-8, %esi
    addl %esi, %ebp
    movl %eax, 0(%esp)  # stack save
# emit-expr (let ((f94406 1024)) (begin (vector-set! f94404 0 ((primitive-ref string->symbol) "input-port")) (vector-set! f94404 1 "/dev/stdin") (vector-set! f94404 2 0) (vector-set! f94404 3 (make-string f94406)) (vector-set! f94404 4 0) (vector-set! f94404 5 f94406) (vector-set! f94404 6 #f) (vector-set! f94404 7 -1) f94404))
# emit-let
#  si   = -4
#  env  = ((f94404 . 0))
#  bindings = ((f94406 1024))
#  body = (begin (vector-set! f94404 0 ((primitive-ref string->symbol) "input-port")) (vector-set! f94404 1 "/dev/stdin") (vector-set! f94404 2 0) (vector-set! f94404 3 (make-string f94406)) (vector-set! f94404 4 0) (vector-set! f94404 5 f94406) (vector-set! f94404 6 #f) (vector-set! f94404 7 -1) f94404)
# emit-expr 1024
    movl $4096, %eax     # immed 1024
    movl %eax, -4(%esp)  # stack save
# emit-expr (begin (vector-set! f94404 0 ((primitive-ref string->symbol) "input-port")) (vector-set! f94404 1 "/dev/stdin") (vector-set! f94404 2 0) (vector-set! f94404 3 (make-string f94406)) (vector-set! f94404 4 0) (vector-set! f94404 5 f94406) (vector-set! f94404 6 #f) (vector-set! f94404 7 -1) f94404)
# emit-begin
#   expr=(begin (vector-set! f94404 0 ((primitive-ref string->symbol) "input-port")) (vector-set! f94404 1 "/dev/stdin") (vector-set! f94404 2 0) (vector-set! f94404 3 (make-string f94406)) (vector-set! f94404 4 0) (vector-set! f94404 5 f94406) (vector-set! f94404 6 #f) (vector-set! f94404 7 -1) f94404)
#   env=((f94406 . -4) (f94404 . 0))
# emit-expr (vector-set! f94404 0 ((primitive-ref string->symbol) "input-port"))
# emit-expr f94404
# emit-variable-ref
# env=((f94406 . -4) (f94404 . 0))
# var=f94404
    movl 0(%esp), %eax  # stack load f94404
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_571870
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_571870:
    movl %eax, -8(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_571871"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_571871:
# check bounds on vector index
    movl -8(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_571873
    cmp  $0,%eax
    jge _L_571872
_L_571873:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_571872:
    movl %eax, -12(%esp)
# emit-expr ((primitive-ref string->symbol) "input-port")
# funcall
#    si   =-16
#    env  = ((f94406 . -4) (f94404 . 0))
#    expr = (funcall (primitive-ref string->symbol) "input-port")
# emit-expr (primitive-ref string->symbol)
    .extern mrc_string$m$gsymbol
    movl mrc_string$m$gsymbol,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_571874"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_571874":
   movl %eax,  -24(%esp)  # stash funcall-oper in closure slot
# emit-expr "input-port"
# string literal
    jmp _L_571876
    .align 8,0x90
_L_571875 :
    .int 40
    .ascii "input-port"
_L_571876:
    movl $_L_571875, %eax
    orl $6, %eax
    mov %eax, -28(%esp)  # arg input-port
    movl -24(%esp), %edi   # load new closure to %edi
    add $-16, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $16, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    movl -8(%esp), %ebx
    movl -12(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin (vector-set! f94404 1 "/dev/stdin") (vector-set! f94404 2 0) (vector-set! f94404 3 (make-string f94406)) (vector-set! f94404 4 0) (vector-set! f94404 5 f94406) (vector-set! f94404 6 #f) (vector-set! f94404 7 -1) f94404)
# emit-begin
#   expr=(begin (vector-set! f94404 1 "/dev/stdin") (vector-set! f94404 2 0) (vector-set! f94404 3 (make-string f94406)) (vector-set! f94404 4 0) (vector-set! f94404 5 f94406) (vector-set! f94404 6 #f) (vector-set! f94404 7 -1) f94404)
#   env=((f94406 . -4) (f94404 . 0))
# emit-expr (vector-set! f94404 1 "/dev/stdin")
# emit-expr f94404
# emit-variable-ref
# env=((f94406 . -4) (f94404 . 0))
# var=f94404
    movl 0(%esp), %eax  # stack load f94404
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_571877
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_571877:
    movl %eax, -8(%esp)
# emit-expr 1
    movl $4, %eax     # immed 1
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_571878"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_571878:
# check bounds on vector index
    movl -8(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_571880
    cmp  $0,%eax
    jge _L_571879
_L_571880:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_571879:
    movl %eax, -12(%esp)
# emit-expr "/dev/stdin"
# string literal
    jmp _L_571882
    .align 8,0x90
_L_571881 :
    .int 40
    .ascii "/dev/stdin"
_L_571882:
    movl $_L_571881, %eax
    orl $6, %eax
    movl -8(%esp), %ebx
    movl -12(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin (vector-set! f94404 2 0) (vector-set! f94404 3 (make-string f94406)) (vector-set! f94404 4 0) (vector-set! f94404 5 f94406) (vector-set! f94404 6 #f) (vector-set! f94404 7 -1) f94404)
# emit-begin
#   expr=(begin (vector-set! f94404 2 0) (vector-set! f94404 3 (make-string f94406)) (vector-set! f94404 4 0) (vector-set! f94404 5 f94406) (vector-set! f94404 6 #f) (vector-set! f94404 7 -1) f94404)
#   env=((f94406 . -4) (f94404 . 0))
# emit-expr (vector-set! f94404 2 0)
# emit-expr f94404
# emit-variable-ref
# env=((f94406 . -4) (f94404 . 0))
# var=f94404
    movl 0(%esp), %eax  # stack load f94404
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_571883
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_571883:
    movl %eax, -8(%esp)
# emit-expr 2
    movl $8, %eax     # immed 2
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_571884"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_571884:
# check bounds on vector index
    movl -8(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_571886
    cmp  $0,%eax
    jge _L_571885
_L_571886:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_571885:
    movl %eax, -12(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
    movl -8(%esp), %ebx
    movl -12(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin (vector-set! f94404 3 (make-string f94406)) (vector-set! f94404 4 0) (vector-set! f94404 5 f94406) (vector-set! f94404 6 #f) (vector-set! f94404 7 -1) f94404)
# emit-begin
#   expr=(begin (vector-set! f94404 3 (make-string f94406)) (vector-set! f94404 4 0) (vector-set! f94404 5 f94406) (vector-set! f94404 6 #f) (vector-set! f94404 7 -1) f94404)
#   env=((f94406 . -4) (f94404 . 0))
# emit-expr (vector-set! f94404 3 (make-string f94406))
# emit-expr f94404
# emit-variable-ref
# env=((f94406 . -4) (f94404 . 0))
# var=f94404
    movl 0(%esp), %eax  # stack load f94404
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_571887
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_571887:
    movl %eax, -8(%esp)
# emit-expr 3
    movl $12, %eax     # immed 3
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_571888"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_571888:
# check bounds on vector index
    movl -8(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_571890
    cmp  $0,%eax
    jge _L_571889
_L_571890:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_571889:
    movl %eax, -12(%esp)
# emit-expr (make-string f94406)
# make-string len=f94406
# emit-expr f94406
# emit-variable-ref
# env=((f94406 . -4) (f94404 . 0))
# var=f94406
    movl -4(%esp), %eax  # stack load f94406
# end emit-variable-ref
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_571891"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $152,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_571891:
# check the argument is a fixnum >= 0
    cmp $0,%eax
    jge _L_571892
# invoke error handler eh_length
    .extern mrc_eh$ulength
    movl mrc_eh$ulength, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $152,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_571892:
    movl %eax, %esi
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    orl $6, %eax
    sar $2, %esi
    add $4, %esi
    add $7, %esi
    andl $-8, %esi
    add  %esi, %ebp
# make-string end
    movl -8(%esp), %ebx
    movl -12(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin (vector-set! f94404 4 0) (vector-set! f94404 5 f94406) (vector-set! f94404 6 #f) (vector-set! f94404 7 -1) f94404)
# emit-begin
#   expr=(begin (vector-set! f94404 4 0) (vector-set! f94404 5 f94406) (vector-set! f94404 6 #f) (vector-set! f94404 7 -1) f94404)
#   env=((f94406 . -4) (f94404 . 0))
# emit-expr (vector-set! f94404 4 0)
# emit-expr f94404
# emit-variable-ref
# env=((f94406 . -4) (f94404 . 0))
# var=f94404
    movl 0(%esp), %eax  # stack load f94404
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_571893
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_571893:
    movl %eax, -8(%esp)
# emit-expr 4
    movl $16, %eax     # immed 4
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_571894"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_571894:
# check bounds on vector index
    movl -8(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_571896
    cmp  $0,%eax
    jge _L_571895
_L_571896:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_571895:
    movl %eax, -12(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
    movl -8(%esp), %ebx
    movl -12(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin (vector-set! f94404 5 f94406) (vector-set! f94404 6 #f) (vector-set! f94404 7 -1) f94404)
# emit-begin
#   expr=(begin (vector-set! f94404 5 f94406) (vector-set! f94404 6 #f) (vector-set! f94404 7 -1) f94404)
#   env=((f94406 . -4) (f94404 . 0))
# emit-expr (vector-set! f94404 5 f94406)
# emit-expr f94404
# emit-variable-ref
# env=((f94406 . -4) (f94404 . 0))
# var=f94404
    movl 0(%esp), %eax  # stack load f94404
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_571897
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_571897:
    movl %eax, -8(%esp)
# emit-expr 5
    movl $20, %eax     # immed 5
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_571898"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_571898:
# check bounds on vector index
    movl -8(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_571900
    cmp  $0,%eax
    jge _L_571899
_L_571900:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_571899:
    movl %eax, -12(%esp)
# emit-expr f94406
# emit-variable-ref
# env=((f94406 . -4) (f94404 . 0))
# var=f94406
    movl -4(%esp), %eax  # stack load f94406
# end emit-variable-ref
    movl -8(%esp), %ebx
    movl -12(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin (vector-set! f94404 6 #f) (vector-set! f94404 7 -1) f94404)
# emit-begin
#   expr=(begin (vector-set! f94404 6 #f) (vector-set! f94404 7 -1) f94404)
#   env=((f94406 . -4) (f94404 . 0))
# emit-expr (vector-set! f94404 6 #f)
# emit-expr f94404
# emit-variable-ref
# env=((f94406 . -4) (f94404 . 0))
# var=f94404
    movl 0(%esp), %eax  # stack load f94404
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_571901
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_571901:
    movl %eax, -8(%esp)
# emit-expr 6
    movl $24, %eax     # immed 6
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_571902"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_571902:
# check bounds on vector index
    movl -8(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_571904
    cmp  $0,%eax
    jge _L_571903
_L_571904:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_571903:
    movl %eax, -12(%esp)
# emit-expr #f
    movl $47, %eax     # immed #f
    movl -8(%esp), %ebx
    movl -12(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin (vector-set! f94404 7 -1) f94404)
# emit-begin
#   expr=(begin (vector-set! f94404 7 -1) f94404)
#   env=((f94406 . -4) (f94404 . 0))
# emit-expr (vector-set! f94404 7 -1)
# emit-expr f94404
# emit-variable-ref
# env=((f94406 . -4) (f94404 . 0))
# var=f94404
    movl 0(%esp), %eax  # stack load f94404
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_571905
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_571905:
    movl %eax, -8(%esp)
# emit-expr 7
    movl $28, %eax     # immed 7
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_571906"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_571906:
# check bounds on vector index
    movl -8(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_571908
    cmp  $0,%eax
    jge _L_571907
_L_571908:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_571907:
    movl %eax, -12(%esp)
# emit-expr -1
    movl $-4, %eax     # immed -1
    movl -8(%esp), %ebx
    movl -12(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin f94404)
# emit-begin
#   expr=(begin f94404)
#   env=((f94406 . -4) (f94404 . 0))
# emit-expr f94404
# emit-variable-ref
# env=((f94406 . -4) (f94404 . 0))
# var=f94404
    movl 0(%esp), %eax  # stack load f94404
# end emit-variable-ref
# emit-expr (begin)
# emit-begin
#   expr=(begin)
#   env=((f94406 . -4) (f94404 . 0))
     movl %eax, mrc_standard$min
# == explicit-begins  ==>
# (lambda (p) (vector-ref p 6))
# == eliminate-let*  ==>
# (lambda (p) (vector-ref p 6))
# == uniquify-variables  ==>
# (lambda (f94407) (vector-ref f94407 6))
# == vectorize-letrec  ==>
# (lambda (f94407) (vector-ref f94407 6))
# == eliminate-set!  ==>
# (lambda (f94407) (let ((f94407 f94407)) (vector-ref f94407 6)))
# == close-free-variables  ==>
# (closure (f94407) () (let ((f94407 f94407)) (vector-ref f94407 6)))
# == eliminate-quote  ==>
# (closure (f94407) () (let ((f94407 f94407)) (vector-ref f94407 6)))
# == eliminate-when/unless  ==>
# (closure (f94407) () (let ((f94407 f94407)) (vector-ref f94407 6)))
# == eliminate-cond  ==>
# (closure (f94407) () (let ((f94407 f94407)) (vector-ref f94407 6)))
# == external-symbols  ==>
# (closure (f94407) () (let ((f94407 f94407)) (vector-ref f94407 6)))
# emit-expr (closure (f94407) () (let ((f94407 f94407)) (vector-ref f94407 6)))
# emit-closure
# si = 0
# env = ()
# expr = (closure (f94407) () (let ((f94407 f94407)) (vector-ref f94407 6)))
    movl $_L_571909, 0(%ebp)  # closure label
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $8, %ebp     # bump ebp
    jmp _L_571910            # jump around closure body
_L_571909:
# check argument count
    cmp $4,%eax
    je _L_571911
# invoke error handler eh_argcount
    .extern mrc_eh$uargcount
    movl mrc_eh$uargcount, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_571911:
# emit-tail-expr
# si=-12
# env=((f94407 . -8))
# expr=(let ((f94407 f94407)) (vector-ref f94407 6))
# emit-tail-let
#  si   = -12
#  env  = ((f94407 . -8))
#  bindings = ((f94407 f94407))
#  body = (vector-ref f94407 6)
# emit-expr f94407
# emit-variable-ref
# env=((f94407 . -8))
# var=f94407
    movl -8(%esp), %eax  # stack load f94407
# end emit-variable-ref
    movl %eax, -12(%esp)  # stack save
# emit-tail-expr
# si=-16
# env=((f94407 . -12) (f94407 . -8))
# expr=(vector-ref f94407 6)
# tail primcall
# emit-expr f94407
# emit-variable-ref
# env=((f94407 . -12) (f94407 . -8))
# var=f94407
    movl -12(%esp), %eax  # stack load f94407
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_571912
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_571912:
    movl %eax, -16(%esp)
# emit-expr 6
    movl $24, %eax     # immed 6
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_571913"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_571913:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_571915
    cmp  $0,%eax
    jge _L_571914
_L_571915:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_571914:
    movl -16(%esp), %esi
    movl -1(%eax,%esi), %eax
#return from tail (vector-ref f94407 6)
    ret
    .align 4,0x90
_L_571910:
     movl %eax, mrc_port$munread
# == explicit-begins  ==>
# (lambda (p) (vector-set! p 6 #f))
# == eliminate-let*  ==>
# (lambda (p) (vector-set! p 6 #f))
# == uniquify-variables  ==>
# (lambda (f94408) (vector-set! f94408 6 #f))
# == vectorize-letrec  ==>
# (lambda (f94408) (vector-set! f94408 6 #f))
# == eliminate-set!  ==>
# (lambda (f94408) (let ((f94408 f94408)) (vector-set! f94408 6 #f)))
# == close-free-variables  ==>
# (closure (f94408) () (let ((f94408 f94408)) (vector-set! f94408 6 #f)))
# == eliminate-quote  ==>
# (closure (f94408) () (let ((f94408 f94408)) (vector-set! f94408 6 #f)))
# == eliminate-when/unless  ==>
# (closure (f94408) () (let ((f94408 f94408)) (vector-set! f94408 6 #f)))
# == eliminate-cond  ==>
# (closure (f94408) () (let ((f94408 f94408)) (vector-set! f94408 6 #f)))
# == external-symbols  ==>
# (closure (f94408) () (let ((f94408 f94408)) (vector-set! f94408 6 #f)))
# emit-expr (closure (f94408) () (let ((f94408 f94408)) (vector-set! f94408 6 #f)))
# emit-closure
# si = 0
# env = ()
# expr = (closure (f94408) () (let ((f94408 f94408)) (vector-set! f94408 6 #f)))
    movl $_L_571916, 0(%ebp)  # closure label
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $8, %ebp     # bump ebp
    jmp _L_571917            # jump around closure body
_L_571916:
# check argument count
    cmp $4,%eax
    je _L_571918
# invoke error handler eh_argcount
    .extern mrc_eh$uargcount
    movl mrc_eh$uargcount, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_571918:
# emit-tail-expr
# si=-12
# env=((f94408 . -8))
# expr=(let ((f94408 f94408)) (vector-set! f94408 6 #f))
# emit-tail-let
#  si   = -12
#  env  = ((f94408 . -8))
#  bindings = ((f94408 f94408))
#  body = (vector-set! f94408 6 #f)
# emit-expr f94408
# emit-variable-ref
# env=((f94408 . -8))
# var=f94408
    movl -8(%esp), %eax  # stack load f94408
# end emit-variable-ref
    movl %eax, -12(%esp)  # stack save
# emit-tail-expr
# si=-16
# env=((f94408 . -12) (f94408 . -8))
# expr=(vector-set! f94408 6 #f)
# tail primcall
# emit-expr f94408
# emit-variable-ref
# env=((f94408 . -12) (f94408 . -8))
# var=f94408
    movl -12(%esp), %eax  # stack load f94408
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_571919
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_571919:
    movl %eax, -16(%esp)
# emit-expr 6
    movl $24, %eax     # immed 6
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_571920"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_571920:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_571922
    cmp  $0,%eax
    jge _L_571921
_L_571922:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_571921:
    movl %eax, -20(%esp)
# emit-expr #f
    movl $47, %eax     # immed #f
    movl -16(%esp), %ebx
    movl -20(%esp), %esi
    movl %eax, -1(%ebx,%esi)
#return from tail (vector-set! f94408 6 #f)
    ret
    .align 4,0x90
_L_571917:
     movl %eax, mrc_port$munread$mclear
# == explicit-begins  ==>
# (lambda (p x) (vector-set! p 6 x))
# == eliminate-let*  ==>
# (lambda (p x) (vector-set! p 6 x))
# == uniquify-variables  ==>
# (lambda (f94409 f94410) (vector-set! f94409 6 f94410))
# == vectorize-letrec  ==>
# (lambda (f94409 f94410) (vector-set! f94409 6 f94410))
# == eliminate-set!  ==>
# (lambda (f94409 f94410) (let ((f94409 f94409) (f94410 f94410)) (vector-set! f94409 6 f94410)))
# == close-free-variables  ==>
# (closure (f94409 f94410) () (let ((f94409 f94409) (f94410 f94410)) (vector-set! f94409 6 f94410)))
# == eliminate-quote  ==>
# (closure (f94409 f94410) () (let ((f94409 f94409) (f94410 f94410)) (vector-set! f94409 6 f94410)))
# == eliminate-when/unless  ==>
# (closure (f94409 f94410) () (let ((f94409 f94409) (f94410 f94410)) (vector-set! f94409 6 f94410)))
# == eliminate-cond  ==>
# (closure (f94409 f94410) () (let ((f94409 f94409) (f94410 f94410)) (vector-set! f94409 6 f94410)))
# == external-symbols  ==>
# (closure (f94409 f94410) () (let ((f94409 f94409) (f94410 f94410)) (vector-set! f94409 6 f94410)))
# emit-expr (closure (f94409 f94410) () (let ((f94409 f94409) (f94410 f94410)) (vector-set! f94409 6 f94410)))
# emit-closure
# si = 0
# env = ()
# expr = (closure (f94409 f94410) () (let ((f94409 f94409) (f94410 f94410)) (vector-set! f94409 6 f94410)))
    movl $_L_571923, 0(%ebp)  # closure label
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $8, %ebp     # bump ebp
    jmp _L_571924            # jump around closure body
_L_571923:
# check argument count
    cmp $8,%eax
    je _L_571925
# invoke error handler eh_argcount
    .extern mrc_eh$uargcount
    movl mrc_eh$uargcount, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_571925:
# emit-tail-expr
# si=-16
# env=((f94410 . -12) (f94409 . -8))
# expr=(let ((f94409 f94409) (f94410 f94410)) (vector-set! f94409 6 f94410))
# emit-tail-let
#  si   = -16
#  env  = ((f94410 . -12) (f94409 . -8))
#  bindings = ((f94409 f94409) (f94410 f94410))
#  body = (vector-set! f94409 6 f94410)
# emit-expr f94409
# emit-variable-ref
# env=((f94410 . -12) (f94409 . -8))
# var=f94409
    movl -8(%esp), %eax  # stack load f94409
# end emit-variable-ref
    movl %eax, -16(%esp)  # stack save
# emit-expr f94410
# emit-variable-ref
# env=((f94410 . -12) (f94409 . -8))
# var=f94410
    movl -12(%esp), %eax  # stack load f94410
# end emit-variable-ref
    movl %eax, -20(%esp)  # stack save
# emit-tail-expr
# si=-24
# env=((f94410 . -20) (f94409 . -16) (f94410 . -12) (f94409 . -8))
# expr=(vector-set! f94409 6 f94410)
# tail primcall
# emit-expr f94409
# emit-variable-ref
# env=((f94410 . -20) (f94409 . -16) (f94410 . -12) (f94409 . -8))
# var=f94409
    movl -16(%esp), %eax  # stack load f94409
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_571926
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_571926:
    movl %eax, -24(%esp)
# emit-expr 6
    movl $24, %eax     # immed 6
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_571927"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_571927:
# check bounds on vector index
    movl -24(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_571929
    cmp  $0,%eax
    jge _L_571928
_L_571929:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_571928:
    movl %eax, -28(%esp)
# emit-expr f94410
# emit-variable-ref
# env=((f94410 . -20) (f94409 . -16) (f94410 . -12) (f94409 . -8))
# var=f94410
    movl -20(%esp), %eax  # stack load f94410
# end emit-variable-ref
    movl -24(%esp), %ebx
    movl -28(%esp), %esi
    movl %eax, -1(%ebx,%esi)
#return from tail (vector-set! f94409 6 f94410)
    ret
    .align 4,0x90
_L_571924:
     movl %eax, mrc_port$munread$mset$b
# == explicit-begins  ==>
# (lambda (p) (vector-ref p 7))
# == eliminate-let*  ==>
# (lambda (p) (vector-ref p 7))
# == uniquify-variables  ==>
# (lambda (f94411) (vector-ref f94411 7))
# == vectorize-letrec  ==>
# (lambda (f94411) (vector-ref f94411 7))
# == eliminate-set!  ==>
# (lambda (f94411) (let ((f94411 f94411)) (vector-ref f94411 7)))
# == close-free-variables  ==>
# (closure (f94411) () (let ((f94411 f94411)) (vector-ref f94411 7)))
# == eliminate-quote  ==>
# (closure (f94411) () (let ((f94411 f94411)) (vector-ref f94411 7)))
# == eliminate-when/unless  ==>
# (closure (f94411) () (let ((f94411 f94411)) (vector-ref f94411 7)))
# == eliminate-cond  ==>
# (closure (f94411) () (let ((f94411 f94411)) (vector-ref f94411 7)))
# == external-symbols  ==>
# (closure (f94411) () (let ((f94411 f94411)) (vector-ref f94411 7)))
# emit-expr (closure (f94411) () (let ((f94411 f94411)) (vector-ref f94411 7)))
# emit-closure
# si = 0
# env = ()
# expr = (closure (f94411) () (let ((f94411 f94411)) (vector-ref f94411 7)))
    movl $_L_571930, 0(%ebp)  # closure label
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $8, %ebp     # bump ebp
    jmp _L_571931            # jump around closure body
_L_571930:
# check argument count
    cmp $4,%eax
    je _L_571932
# invoke error handler eh_argcount
    .extern mrc_eh$uargcount
    movl mrc_eh$uargcount, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_571932:
# emit-tail-expr
# si=-12
# env=((f94411 . -8))
# expr=(let ((f94411 f94411)) (vector-ref f94411 7))
# emit-tail-let
#  si   = -12
#  env  = ((f94411 . -8))
#  bindings = ((f94411 f94411))
#  body = (vector-ref f94411 7)
# emit-expr f94411
# emit-variable-ref
# env=((f94411 . -8))
# var=f94411
    movl -8(%esp), %eax  # stack load f94411
# end emit-variable-ref
    movl %eax, -12(%esp)  # stack save
# emit-tail-expr
# si=-16
# env=((f94411 . -12) (f94411 . -8))
# expr=(vector-ref f94411 7)
# tail primcall
# emit-expr f94411
# emit-variable-ref
# env=((f94411 . -12) (f94411 . -8))
# var=f94411
    movl -12(%esp), %eax  # stack load f94411
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_571933
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_571933:
    movl %eax, -16(%esp)
# emit-expr 7
    movl $28, %eax     # immed 7
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_571934"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_571934:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_571936
    cmp  $0,%eax
    jge _L_571935
_L_571936:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_571935:
    movl -16(%esp), %esi
    movl -1(%eax,%esi), %eax
#return from tail (vector-ref f94411 7)
    ret
    .align 4,0x90
_L_571931:
     movl %eax, mrc_port$mlast
# == explicit-begins  ==>
# (lambda (p i) (vector-set! p 7 i))
# == eliminate-let*  ==>
# (lambda (p i) (vector-set! p 7 i))
# == uniquify-variables  ==>
# (lambda (f94412 f94413) (vector-set! f94412 7 f94413))
# == vectorize-letrec  ==>
# (lambda (f94412 f94413) (vector-set! f94412 7 f94413))
# == eliminate-set!  ==>
# (lambda (f94412 f94413) (let ((f94412 f94412) (f94413 f94413)) (vector-set! f94412 7 f94413)))
# == close-free-variables  ==>
# (closure (f94412 f94413) () (let ((f94412 f94412) (f94413 f94413)) (vector-set! f94412 7 f94413)))
# == eliminate-quote  ==>
# (closure (f94412 f94413) () (let ((f94412 f94412) (f94413 f94413)) (vector-set! f94412 7 f94413)))
# == eliminate-when/unless  ==>
# (closure (f94412 f94413) () (let ((f94412 f94412) (f94413 f94413)) (vector-set! f94412 7 f94413)))
# == eliminate-cond  ==>
# (closure (f94412 f94413) () (let ((f94412 f94412) (f94413 f94413)) (vector-set! f94412 7 f94413)))
# == external-symbols  ==>
# (closure (f94412 f94413) () (let ((f94412 f94412) (f94413 f94413)) (vector-set! f94412 7 f94413)))
# emit-expr (closure (f94412 f94413) () (let ((f94412 f94412) (f94413 f94413)) (vector-set! f94412 7 f94413)))
# emit-closure
# si = 0
# env = ()
# expr = (closure (f94412 f94413) () (let ((f94412 f94412) (f94413 f94413)) (vector-set! f94412 7 f94413)))
    movl $_L_571937, 0(%ebp)  # closure label
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $8, %ebp     # bump ebp
    jmp _L_571938            # jump around closure body
_L_571937:
# check argument count
    cmp $8,%eax
    je _L_571939
# invoke error handler eh_argcount
    .extern mrc_eh$uargcount
    movl mrc_eh$uargcount, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_571939:
# emit-tail-expr
# si=-16
# env=((f94413 . -12) (f94412 . -8))
# expr=(let ((f94412 f94412) (f94413 f94413)) (vector-set! f94412 7 f94413))
# emit-tail-let
#  si   = -16
#  env  = ((f94413 . -12) (f94412 . -8))
#  bindings = ((f94412 f94412) (f94413 f94413))
#  body = (vector-set! f94412 7 f94413)
# emit-expr f94412
# emit-variable-ref
# env=((f94413 . -12) (f94412 . -8))
# var=f94412
    movl -8(%esp), %eax  # stack load f94412
# end emit-variable-ref
    movl %eax, -16(%esp)  # stack save
# emit-expr f94413
# emit-variable-ref
# env=((f94413 . -12) (f94412 . -8))
# var=f94413
    movl -12(%esp), %eax  # stack load f94413
# end emit-variable-ref
    movl %eax, -20(%esp)  # stack save
# emit-tail-expr
# si=-24
# env=((f94413 . -20) (f94412 . -16) (f94413 . -12) (f94412 . -8))
# expr=(vector-set! f94412 7 f94413)
# tail primcall
# emit-expr f94412
# emit-variable-ref
# env=((f94413 . -20) (f94412 . -16) (f94413 . -12) (f94412 . -8))
# var=f94412
    movl -16(%esp), %eax  # stack load f94412
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_571940
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_571940:
    movl %eax, -24(%esp)
# emit-expr 7
    movl $28, %eax     # immed 7
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_571941"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_571941:
# check bounds on vector index
    movl -24(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_571943
    cmp  $0,%eax
    jge _L_571942
_L_571943:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_571942:
    movl %eax, -28(%esp)
# emit-expr f94413
# emit-variable-ref
# env=((f94413 . -20) (f94412 . -16) (f94413 . -12) (f94412 . -8))
# var=f94413
    movl -20(%esp), %eax  # stack load f94413
# end emit-variable-ref
    movl -24(%esp), %ebx
    movl -28(%esp), %esi
    movl %eax, -1(%ebx,%esi)
#return from tail (vector-set! f94412 7 f94413)
    ret
    .align 4,0x90
_L_571938:
     movl %eax, mrc_port$mlast$mset$b
# == explicit-begins  ==>
# (lambda (p) (and (vector? p) (and (fx= (vector-length p) 8) (eq? (port-kind p) (quote input-port)))))
# == eliminate-let*  ==>
# (lambda (p) (and (vector? p) (and (fx= (vector-length p) 8) (eq? (port-kind p) (quote input-port)))))
# == uniquify-variables  ==>
# (lambda (f94414) (and (vector? f94414) (and (fx= (vector-length f94414) 8) (eq? (port-kind f94414) (quote input-port)))))
# == vectorize-letrec  ==>
# (lambda (f94414) (and (vector? f94414) (and (fx= (vector-length f94414) 8) (eq? (port-kind f94414) (quote input-port)))))
# == eliminate-set!  ==>
# (lambda (f94414) (let ((f94414 f94414)) (and (vector? f94414) (and (fx= (vector-length f94414) 8) (eq? (port-kind f94414) (quote input-port))))))
# == close-free-variables  ==>
# (closure (f94414) (and and input-port) (let ((f94414 f94414)) (and (vector? f94414) (and (fx= (vector-length f94414) 8) (eq? (port-kind f94414) (quote input-port))))))
# == eliminate-quote  ==>
# (closure (f94414) (and and input-port) (let ((f94414 f94414)) (and (vector? f94414) (and (fx= (vector-length f94414) 8) (eq? (port-kind f94414) (string->symbol "input-port"))))))
# == eliminate-when/unless  ==>
# (closure (f94414) (and and input-port) (let ((f94414 f94414)) (and (vector? f94414) (and (fx= (vector-length f94414) 8) (eq? (port-kind f94414) (string->symbol "input-port"))))))
# == eliminate-cond  ==>
# (closure (f94414) (and and input-port) (let ((f94414 f94414)) (and (vector? f94414) (and (fx= (vector-length f94414) 8) (eq? (port-kind f94414) (string->symbol "input-port"))))))
# == external-symbols  ==>
# (closure (f94414) (and and input-port) (let ((f94414 f94414)) (and (vector? f94414) (and (fx= (vector-length f94414) 8) (eq? ((primitive-ref port-kind) f94414) ((primitive-ref string->symbol) "input-port"))))))
# emit-expr (closure (f94414) (and and input-port) (let ((f94414 f94414)) (and (vector? f94414) (and (fx= (vector-length f94414) 8) (eq? ((primitive-ref port-kind) f94414) ((primitive-ref string->symbol) "input-port"))))))
# emit-closure
# si = 0
# env = ()
# expr = (closure (f94414) (and and input-port) (let ((f94414 f94414)) (and (vector? f94414) (and (fx= (vector-length f94414) 8) (eq? ((primitive-ref port-kind) f94414) ((primitive-ref string->symbol) "input-port"))))))
    movl $_L_571944, 0(%ebp)  # closure label
# WARNING: free var and not defined in the environmnet
# WARNING: free var and not defined in the environmnet
# WARNING: free var input-port not defined in the environmnet
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $16, %ebp     # bump ebp
    jmp _L_571945            # jump around closure body
_L_571944:
# check argument count
    cmp $4,%eax
    je _L_571946
# invoke error handler eh_argcount
    .extern mrc_eh$uargcount
    movl mrc_eh$uargcount, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_571946:
# emit-tail-expr
# si=-12
# env=((f94414 . -8) (input-port . 12) (and . 8) (and . 4))
# expr=(let ((f94414 f94414)) (and (vector? f94414) (and (fx= (vector-length f94414) 8) (eq? ((primitive-ref port-kind) f94414) ((primitive-ref string->symbol) "input-port")))))
# emit-tail-let
#  si   = -12
#  env  = ((f94414 . -8) (input-port . 12) (and . 8) (and . 4))
#  bindings = ((f94414 f94414))
#  body = (and (vector? f94414) (and (fx= (vector-length f94414) 8) (eq? ((primitive-ref port-kind) f94414) ((primitive-ref string->symbol) "input-port"))))
# emit-expr f94414
# emit-variable-ref
# env=((f94414 . -8) (input-port . 12) (and . 8) (and . 4))
# var=f94414
    movl -8(%esp), %eax  # stack load f94414
# end emit-variable-ref
    movl %eax, -12(%esp)  # stack save
# emit-tail-expr
# si=-16
# env=((f94414 . -12) (f94414 . -8) (input-port . 12) (and . 8) (and . 4))
# expr=(and (vector? f94414) (and (fx= (vector-length f94414) 8) (eq? ((primitive-ref port-kind) f94414) ((primitive-ref string->symbol) "input-port"))))
# emit-tail-expr
# si=-16
# env=((f94414 . -12) (f94414 . -8) (input-port . 12) (and . 8) (and . 4))
# expr=(if (vector? f94414) (and (and (fx= (vector-length f94414) 8) (eq? ((primitive-ref port-kind) f94414) ((primitive-ref string->symbol) "input-port")))) #f)
# emit-expr (vector? f94414)
# emit-expr f94414
# emit-variable-ref
# env=((f94414 . -12) (f94414 . -8) (input-port . 12) (and . 8) (and . 4))
# var=f94414
    movl -12(%esp), %eax  # stack load f94414
# end emit-variable-ref
    and $7, %al
    cmp $5, %al
    sete %al
    movzbl %al, %eax
    sal $6, %al
    or $47, %al
    cmp $47, %al
    je _L_571947
# emit-tail-expr
# si=-16
# env=((f94414 . -12) (f94414 . -8) (input-port . 12) (and . 8) (and . 4))
# expr=(and (and (fx= (vector-length f94414) 8) (eq? ((primitive-ref port-kind) f94414) ((primitive-ref string->symbol) "input-port"))))
# emit-tail-expr
# si=-16
# env=((f94414 . -12) (f94414 . -8) (input-port . 12) (and . 8) (and . 4))
# expr=(and (fx= (vector-length f94414) 8) (eq? ((primitive-ref port-kind) f94414) ((primitive-ref string->symbol) "input-port")))
# emit-tail-expr
# si=-16
# env=((f94414 . -12) (f94414 . -8) (input-port . 12) (and . 8) (and . 4))
# expr=(if (fx= (vector-length f94414) 8) (and (eq? ((primitive-ref port-kind) f94414) ((primitive-ref string->symbol) "input-port"))) #f)
# emit-expr (fx= (vector-length f94414) 8)
# emit-expr 8
    movl $32, %eax     # immed 8
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_571951"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $68,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_571951:
    movl %eax, -16(%esp)
# emit-expr (vector-length f94414)
# emit-expr f94414
# emit-variable-ref
# env=((f94414 . -12) (f94414 . -8) (input-port . 12) (and . 8) (and . 4))
# var=f94414
    movl -12(%esp), %eax  # stack load f94414
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_571952
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_571952:
andl $-8, %eax
movl 0(%eax), %eax
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_571953"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $68,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_571953:
    cmp -16(%esp), %eax
    sete %al
    movzbl %al, %eax
    sal $6, %al
    or $47, %al
    cmp $47, %al
    je _L_571949
# emit-tail-expr
# si=-16
# env=((f94414 . -12) (f94414 . -8) (input-port . 12) (and . 8) (and . 4))
# expr=(and (eq? ((primitive-ref port-kind) f94414) ((primitive-ref string->symbol) "input-port")))
# emit-tail-expr
# si=-16
# env=((f94414 . -12) (f94414 . -8) (input-port . 12) (and . 8) (and . 4))
# expr=(eq? ((primitive-ref port-kind) f94414) ((primitive-ref string->symbol) "input-port"))
# tail primcall
# eq? arg1=((primitive-ref port-kind) f94414) arg2=((primitive-ref string->symbol) "input-port")
# emit-expr ((primitive-ref port-kind) f94414)
# funcall
#    si   =-16
#    env  = ((f94414 . -12) (f94414 . -8) (input-port . 12) (and . 8) (and . 4))
#    expr = (funcall (primitive-ref port-kind) f94414)
# emit-expr (primitive-ref port-kind)
    .extern mrc_port$mkind
    movl mrc_port$mkind,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_571954"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_571954":
   movl %eax,  -24(%esp)  # stash funcall-oper in closure slot
# emit-expr f94414
# emit-variable-ref
# env=((f94414 . -12) (f94414 . -8) (input-port . 12) (and . 8) (and . 4))
# var=f94414
    movl -12(%esp), %eax  # stack load f94414
# end emit-variable-ref
    mov %eax, -28(%esp)  # arg f94414
    movl -24(%esp), %edi   # load new closure to %edi
    add $-16, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $16, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    movl %eax, -16(%esp)
# emit-expr ((primitive-ref string->symbol) "input-port")
# funcall
#    si   =-20
#    env  = ((f94414 . -12) (f94414 . -8) (input-port . 12) (and . 8) (and . 4))
#    expr = (funcall (primitive-ref string->symbol) "input-port")
# emit-expr (primitive-ref string->symbol)
    .extern mrc_string$m$gsymbol
    movl mrc_string$m$gsymbol,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_571955"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_571955":
   movl %eax,  -28(%esp)  # stash funcall-oper in closure slot
# emit-expr "input-port"
# string literal
    jmp _L_571957
    .align 8,0x90
_L_571956 :
    .int 40
    .ascii "input-port"
_L_571957:
    movl $_L_571956, %eax
    orl $6, %eax
    mov %eax, -32(%esp)  # arg input-port
    movl -28(%esp), %edi   # load new closure to %edi
    add $-20, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $20, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    cmp %eax, -16(%esp)
    sete %al
    movzbl %al, %eax
    sal $6, %al
    or $47, %al
#return from tail (eq? ((primitive-ref port-kind) f94414) ((primitive-ref string->symbol) input-port))
    ret
    jmp _L_571950
_L_571949:
# emit-tail-expr
# si=-16
# env=((f94414 . -12) (f94414 . -8) (input-port . 12) (and . 8) (and . 4))
# expr=#f
    movl $47, %eax     # immed #f
    ret                  # immediate tail return
_L_571950:
    jmp _L_571948
_L_571947:
# emit-tail-expr
# si=-16
# env=((f94414 . -12) (f94414 . -8) (input-port . 12) (and . 8) (and . 4))
# expr=#f
    movl $47, %eax     # immed #f
    ret                  # immediate tail return
_L_571948:
    .align 4,0x90
_L_571945:
     movl %eax, mrc_input$mport$q
# == explicit-begins  ==>
# (lambda (p) (and (vector? p) (and (fx= (vector-length p) 6) (eq? (port-kind p) (quote output-port)))))
# == eliminate-let*  ==>
# (lambda (p) (and (vector? p) (and (fx= (vector-length p) 6) (eq? (port-kind p) (quote output-port)))))
# == uniquify-variables  ==>
# (lambda (f94415) (and (vector? f94415) (and (fx= (vector-length f94415) 6) (eq? (port-kind f94415) (quote output-port)))))
# == vectorize-letrec  ==>
# (lambda (f94415) (and (vector? f94415) (and (fx= (vector-length f94415) 6) (eq? (port-kind f94415) (quote output-port)))))
# == eliminate-set!  ==>
# (lambda (f94415) (let ((f94415 f94415)) (and (vector? f94415) (and (fx= (vector-length f94415) 6) (eq? (port-kind f94415) (quote output-port))))))
# == close-free-variables  ==>
# (closure (f94415) (and and output-port) (let ((f94415 f94415)) (and (vector? f94415) (and (fx= (vector-length f94415) 6) (eq? (port-kind f94415) (quote output-port))))))
# == eliminate-quote  ==>
# (closure (f94415) (and and output-port) (let ((f94415 f94415)) (and (vector? f94415) (and (fx= (vector-length f94415) 6) (eq? (port-kind f94415) (string->symbol "output-port"))))))
# == eliminate-when/unless  ==>
# (closure (f94415) (and and output-port) (let ((f94415 f94415)) (and (vector? f94415) (and (fx= (vector-length f94415) 6) (eq? (port-kind f94415) (string->symbol "output-port"))))))
# == eliminate-cond  ==>
# (closure (f94415) (and and output-port) (let ((f94415 f94415)) (and (vector? f94415) (and (fx= (vector-length f94415) 6) (eq? (port-kind f94415) (string->symbol "output-port"))))))
# == external-symbols  ==>
# (closure (f94415) (and and output-port) (let ((f94415 f94415)) (and (vector? f94415) (and (fx= (vector-length f94415) 6) (eq? ((primitive-ref port-kind) f94415) ((primitive-ref string->symbol) "output-port"))))))
# emit-expr (closure (f94415) (and and output-port) (let ((f94415 f94415)) (and (vector? f94415) (and (fx= (vector-length f94415) 6) (eq? ((primitive-ref port-kind) f94415) ((primitive-ref string->symbol) "output-port"))))))
# emit-closure
# si = 0
# env = ()
# expr = (closure (f94415) (and and output-port) (let ((f94415 f94415)) (and (vector? f94415) (and (fx= (vector-length f94415) 6) (eq? ((primitive-ref port-kind) f94415) ((primitive-ref string->symbol) "output-port"))))))
    movl $_L_571958, 0(%ebp)  # closure label
# WARNING: free var and not defined in the environmnet
# WARNING: free var and not defined in the environmnet
# WARNING: free var output-port not defined in the environmnet
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $16, %ebp     # bump ebp
    jmp _L_571959            # jump around closure body
_L_571958:
# check argument count
    cmp $4,%eax
    je _L_571960
# invoke error handler eh_argcount
    .extern mrc_eh$uargcount
    movl mrc_eh$uargcount, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_571960:
# emit-tail-expr
# si=-12
# env=((f94415 . -8) (output-port . 12) (and . 8) (and . 4))
# expr=(let ((f94415 f94415)) (and (vector? f94415) (and (fx= (vector-length f94415) 6) (eq? ((primitive-ref port-kind) f94415) ((primitive-ref string->symbol) "output-port")))))
# emit-tail-let
#  si   = -12
#  env  = ((f94415 . -8) (output-port . 12) (and . 8) (and . 4))
#  bindings = ((f94415 f94415))
#  body = (and (vector? f94415) (and (fx= (vector-length f94415) 6) (eq? ((primitive-ref port-kind) f94415) ((primitive-ref string->symbol) "output-port"))))
# emit-expr f94415
# emit-variable-ref
# env=((f94415 . -8) (output-port . 12) (and . 8) (and . 4))
# var=f94415
    movl -8(%esp), %eax  # stack load f94415
# end emit-variable-ref
    movl %eax, -12(%esp)  # stack save
# emit-tail-expr
# si=-16
# env=((f94415 . -12) (f94415 . -8) (output-port . 12) (and . 8) (and . 4))
# expr=(and (vector? f94415) (and (fx= (vector-length f94415) 6) (eq? ((primitive-ref port-kind) f94415) ((primitive-ref string->symbol) "output-port"))))
# emit-tail-expr
# si=-16
# env=((f94415 . -12) (f94415 . -8) (output-port . 12) (and . 8) (and . 4))
# expr=(if (vector? f94415) (and (and (fx= (vector-length f94415) 6) (eq? ((primitive-ref port-kind) f94415) ((primitive-ref string->symbol) "output-port")))) #f)
# emit-expr (vector? f94415)
# emit-expr f94415
# emit-variable-ref
# env=((f94415 . -12) (f94415 . -8) (output-port . 12) (and . 8) (and . 4))
# var=f94415
    movl -12(%esp), %eax  # stack load f94415
# end emit-variable-ref
    and $7, %al
    cmp $5, %al
    sete %al
    movzbl %al, %eax
    sal $6, %al
    or $47, %al
    cmp $47, %al
    je _L_571961
# emit-tail-expr
# si=-16
# env=((f94415 . -12) (f94415 . -8) (output-port . 12) (and . 8) (and . 4))
# expr=(and (and (fx= (vector-length f94415) 6) (eq? ((primitive-ref port-kind) f94415) ((primitive-ref string->symbol) "output-port"))))
# emit-tail-expr
# si=-16
# env=((f94415 . -12) (f94415 . -8) (output-port . 12) (and . 8) (and . 4))
# expr=(and (fx= (vector-length f94415) 6) (eq? ((primitive-ref port-kind) f94415) ((primitive-ref string->symbol) "output-port")))
# emit-tail-expr
# si=-16
# env=((f94415 . -12) (f94415 . -8) (output-port . 12) (and . 8) (and . 4))
# expr=(if (fx= (vector-length f94415) 6) (and (eq? ((primitive-ref port-kind) f94415) ((primitive-ref string->symbol) "output-port"))) #f)
# emit-expr (fx= (vector-length f94415) 6)
# emit-expr 6
    movl $24, %eax     # immed 6
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_571965"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $68,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_571965:
    movl %eax, -16(%esp)
# emit-expr (vector-length f94415)
# emit-expr f94415
# emit-variable-ref
# env=((f94415 . -12) (f94415 . -8) (output-port . 12) (and . 8) (and . 4))
# var=f94415
    movl -12(%esp), %eax  # stack load f94415
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_571966
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_571966:
andl $-8, %eax
movl 0(%eax), %eax
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_571967"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $68,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_571967:
    cmp -16(%esp), %eax
    sete %al
    movzbl %al, %eax
    sal $6, %al
    or $47, %al
    cmp $47, %al
    je _L_571963
# emit-tail-expr
# si=-16
# env=((f94415 . -12) (f94415 . -8) (output-port . 12) (and . 8) (and . 4))
# expr=(and (eq? ((primitive-ref port-kind) f94415) ((primitive-ref string->symbol) "output-port")))
# emit-tail-expr
# si=-16
# env=((f94415 . -12) (f94415 . -8) (output-port . 12) (and . 8) (and . 4))
# expr=(eq? ((primitive-ref port-kind) f94415) ((primitive-ref string->symbol) "output-port"))
# tail primcall
# eq? arg1=((primitive-ref port-kind) f94415) arg2=((primitive-ref string->symbol) "output-port")
# emit-expr ((primitive-ref port-kind) f94415)
# funcall
#    si   =-16
#    env  = ((f94415 . -12) (f94415 . -8) (output-port . 12) (and . 8) (and . 4))
#    expr = (funcall (primitive-ref port-kind) f94415)
# emit-expr (primitive-ref port-kind)
    .extern mrc_port$mkind
    movl mrc_port$mkind,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_571968"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_571968":
   movl %eax,  -24(%esp)  # stash funcall-oper in closure slot
# emit-expr f94415
# emit-variable-ref
# env=((f94415 . -12) (f94415 . -8) (output-port . 12) (and . 8) (and . 4))
# var=f94415
    movl -12(%esp), %eax  # stack load f94415
# end emit-variable-ref
    mov %eax, -28(%esp)  # arg f94415
    movl -24(%esp), %edi   # load new closure to %edi
    add $-16, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $16, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    movl %eax, -16(%esp)
# emit-expr ((primitive-ref string->symbol) "output-port")
# funcall
#    si   =-20
#    env  = ((f94415 . -12) (f94415 . -8) (output-port . 12) (and . 8) (and . 4))
#    expr = (funcall (primitive-ref string->symbol) "output-port")
# emit-expr (primitive-ref string->symbol)
    .extern mrc_string$m$gsymbol
    movl mrc_string$m$gsymbol,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_571969"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_571969":
   movl %eax,  -28(%esp)  # stash funcall-oper in closure slot
# emit-expr "output-port"
# string literal
    jmp _L_571971
    .align 8,0x90
_L_571970 :
    .int 44
    .ascii "output-port"
_L_571971:
    movl $_L_571970, %eax
    orl $6, %eax
    mov %eax, -32(%esp)  # arg output-port
    movl -28(%esp), %edi   # load new closure to %edi
    add $-20, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $20, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    cmp %eax, -16(%esp)
    sete %al
    movzbl %al, %eax
    sal $6, %al
    or $47, %al
#return from tail (eq? ((primitive-ref port-kind) f94415) ((primitive-ref string->symbol) output-port))
    ret
    jmp _L_571964
_L_571963:
# emit-tail-expr
# si=-16
# env=((f94415 . -12) (f94415 . -8) (output-port . 12) (and . 8) (and . 4))
# expr=#f
    movl $47, %eax     # immed #f
    ret                  # immediate tail return
_L_571964:
    jmp _L_571962
_L_571961:
# emit-tail-expr
# si=-16
# env=((f94415 . -12) (f94415 . -8) (output-port . 12) (and . 8) (and . 4))
# expr=#f
    movl $47, %eax     # immed #f
    ret                  # immediate tail return
_L_571962:
    .align 4,0x90
_L_571959:
     movl %eax, mrc_output$mport$q
# == explicit-begins  ==>
# (lambda (filename) (begin (unless (string? filename) (error (quote open-input-file) "filename must be a string")) (let ((fd (foreign-call "s_open" filename))) (begin (when (negative? fd) (error (quote open-input-file) "open failed")) (let ((p (make-vector 8)) (sz 1024)) (begin (vector-set! p 0 (quote input-port)) (vector-set! p 1 filename) (vector-set! p 2 fd) (vector-set! p 3 (make-string sz)) (vector-set! p 4 0) (vector-set! p 5 sz) (vector-set! p 6 #f) (vector-set! p 7 0) p))))))
# == eliminate-let*  ==>
# (lambda (filename) (begin (unless (string? filename) (error (quote open-input-file) "filename must be a string")) (let ((fd (foreign-call "s_open" filename))) (begin (when (negative? fd) (error (quote open-input-file) "open failed")) (let ((p (make-vector 8)) (sz 1024)) (begin (vector-set! p 0 (quote input-port)) (vector-set! p 1 filename) (vector-set! p 2 fd) (vector-set! p 3 (make-string sz)) (vector-set! p 4 0) (vector-set! p 5 sz) (vector-set! p 6 #f) (vector-set! p 7 0) p))))))
# == uniquify-variables  ==>
# (lambda (f94416) (begin (unless (string? f94416) (error (quote open-input-file) "filename must be a string")) (let ((f94422 (foreign-call "s_open" f94416))) (begin (when (negative? f94422) (error (quote open-input-file) "open failed")) (let ((f94426 (make-vector 8)) (f94425 1024)) (begin (vector-set! f94426 0 (quote input-port)) (vector-set! f94426 1 f94416) (vector-set! f94426 2 f94422) (vector-set! f94426 3 (make-string f94425)) (vector-set! f94426 4 0) (vector-set! f94426 5 f94425) (vector-set! f94426 6 #f) (vector-set! f94426 7 0) f94426))))))
# == vectorize-letrec  ==>
# (lambda (f94416) (begin (unless (string? f94416) (error (quote open-input-file) "filename must be a string")) (let ((f94422 (foreign-call "s_open" f94416))) (begin (when (negative? f94422) (error (quote open-input-file) "open failed")) (let ((f94426 (make-vector 8)) (f94425 1024)) (begin (vector-set! f94426 0 (quote input-port)) (vector-set! f94426 1 f94416) (vector-set! f94426 2 f94422) (vector-set! f94426 3 (make-string f94425)) (vector-set! f94426 4 0) (vector-set! f94426 5 f94425) (vector-set! f94426 6 #f) (vector-set! f94426 7 0) f94426))))))
# == eliminate-set!  ==>
# (lambda (f94416) (let ((f94416 f94416)) (begin (unless (string? f94416) (error (quote open-input-file) "filename must be a string")) (let ((f94422 (foreign-call "s_open" f94416))) (begin (when (negative? f94422) (error (quote open-input-file) "open failed")) (let ((f94426 (make-vector 8)) (f94425 1024)) (begin (vector-set! f94426 0 (quote input-port)) (vector-set! f94426 1 f94416) (vector-set! f94426 2 f94422) (vector-set! f94426 3 (make-string f94425)) (vector-set! f94426 4 0) (vector-set! f94426 5 f94425) (vector-set! f94426 6 #f) (vector-set! f94426 7 0) f94426)))))))
# == close-free-variables  ==>
# (closure (f94416) (input-port) (let ((f94416 f94416)) (begin (unless (string? f94416) (error (quote open-input-file) "filename must be a string")) (let ((f94422 (foreign-call "s_open" f94416))) (begin (when (negative? f94422) (error (quote open-input-file) "open failed")) (let ((f94426 (make-vector 8)) (f94425 1024)) (begin (vector-set! f94426 0 (quote input-port)) (vector-set! f94426 1 f94416) (vector-set! f94426 2 f94422) (vector-set! f94426 3 (make-string f94425)) (vector-set! f94426 4 0) (vector-set! f94426 5 f94425) (vector-set! f94426 6 #f) (vector-set! f94426 7 0) f94426)))))))
# == eliminate-quote  ==>
# (closure (f94416) (input-port) (let ((f94416 f94416)) (begin (unless (string? f94416) (error (string->symbol "open-input-file") "filename must be a string")) (let ((f94422 (foreign-call "s_open" f94416))) (begin (when (negative? f94422) (error (string->symbol "open-input-file") "open failed")) (let ((f94426 (make-vector 8)) (f94425 1024)) (begin (vector-set! f94426 0 (string->symbol "input-port")) (vector-set! f94426 1 f94416) (vector-set! f94426 2 f94422) (vector-set! f94426 3 (make-string f94425)) (vector-set! f94426 4 0) (vector-set! f94426 5 f94425) (vector-set! f94426 6 #f) (vector-set! f94426 7 0) f94426)))))))
# == eliminate-when/unless  ==>
# (closure (f94416) (input-port) (let ((f94416 f94416)) (begin (if (not (string? f94416)) (begin (error (string->symbol "open-input-file") "filename must be a string")) #f) (let ((f94422 (foreign-call "s_open" f94416))) (begin (if (negative? f94422) (begin (error (string->symbol "open-input-file") "open failed")) #f) (let ((f94426 (make-vector 8)) (f94425 1024)) (begin (vector-set! f94426 0 (string->symbol "input-port")) (vector-set! f94426 1 f94416) (vector-set! f94426 2 f94422) (vector-set! f94426 3 (make-string f94425)) (vector-set! f94426 4 0) (vector-set! f94426 5 f94425) (vector-set! f94426 6 #f) (vector-set! f94426 7 0) f94426)))))))
# == eliminate-cond  ==>
# (closure (f94416) (input-port) (let ((f94416 f94416)) (begin (if (not (string? f94416)) (begin (error (string->symbol "open-input-file") "filename must be a string")) #f) (let ((f94422 (foreign-call "s_open" f94416))) (begin (if (negative? f94422) (begin (error (string->symbol "open-input-file") "open failed")) #f) (let ((f94426 (make-vector 8)) (f94425 1024)) (begin (vector-set! f94426 0 (string->symbol "input-port")) (vector-set! f94426 1 f94416) (vector-set! f94426 2 f94422) (vector-set! f94426 3 (make-string f94425)) (vector-set! f94426 4 0) (vector-set! f94426 5 f94425) (vector-set! f94426 6 #f) (vector-set! f94426 7 0) f94426)))))))
# == external-symbols  ==>
# (closure (f94416) (input-port) (let ((f94416 f94416)) (begin (if (not (string? f94416)) (begin ((primitive-ref error) ((primitive-ref string->symbol) "open-input-file") "filename must be a string")) #f) (let ((f94422 (foreign-call "s_open" f94416))) (begin (if ((primitive-ref negative?) f94422) (begin ((primitive-ref error) ((primitive-ref string->symbol) "open-input-file") "open failed")) #f) (let ((f94426 (make-vector 8)) (f94425 1024)) (begin (vector-set! f94426 0 ((primitive-ref string->symbol) "input-port")) (vector-set! f94426 1 f94416) (vector-set! f94426 2 f94422) (vector-set! f94426 3 (make-string f94425)) (vector-set! f94426 4 0) (vector-set! f94426 5 f94425) (vector-set! f94426 6 #f) (vector-set! f94426 7 0) f94426)))))))
# emit-expr (closure (f94416) (input-port) (let ((f94416 f94416)) (begin (if (not (string? f94416)) (begin ((primitive-ref error) ((primitive-ref string->symbol) "open-input-file") "filename must be a string")) #f) (let ((f94422 (foreign-call "s_open" f94416))) (begin (if ((primitive-ref negative?) f94422) (begin ((primitive-ref error) ((primitive-ref string->symbol) "open-input-file") "open failed")) #f) (let ((f94426 (make-vector 8)) (f94425 1024)) (begin (vector-set! f94426 0 ((primitive-ref string->symbol) "input-port")) (vector-set! f94426 1 f94416) (vector-set! f94426 2 f94422) (vector-set! f94426 3 (make-string f94425)) (vector-set! f94426 4 0) (vector-set! f94426 5 f94425) (vector-set! f94426 6 #f) (vector-set! f94426 7 0) f94426)))))))
# emit-closure
# si = 0
# env = ()
# expr = (closure (f94416) (input-port) (let ((f94416 f94416)) (begin (if (not (string? f94416)) (begin ((primitive-ref error) ((primitive-ref string->symbol) "open-input-file") "filename must be a string")) #f) (let ((f94422 (foreign-call "s_open" f94416))) (begin (if ((primitive-ref negative?) f94422) (begin ((primitive-ref error) ((primitive-ref string->symbol) "open-input-file") "open failed")) #f) (let ((f94426 (make-vector 8)) (f94425 1024)) (begin (vector-set! f94426 0 ((primitive-ref string->symbol) "input-port")) (vector-set! f94426 1 f94416) (vector-set! f94426 2 f94422) (vector-set! f94426 3 (make-string f94425)) (vector-set! f94426 4 0) (vector-set! f94426 5 f94425) (vector-set! f94426 6 #f) (vector-set! f94426 7 0) f94426)))))))
    movl $_L_571972, 0(%ebp)  # closure label
# WARNING: free var input-port not defined in the environmnet
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $8, %ebp     # bump ebp
    jmp _L_571973            # jump around closure body
_L_571972:
# check argument count
    cmp $4,%eax
    je _L_571974
# invoke error handler eh_argcount
    .extern mrc_eh$uargcount
    movl mrc_eh$uargcount, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_571974:
# emit-tail-expr
# si=-12
# env=((f94416 . -8) (input-port . 4))
# expr=(let ((f94416 f94416)) (begin (if (not (string? f94416)) (begin ((primitive-ref error) ((primitive-ref string->symbol) "open-input-file") "filename must be a string")) #f) (let ((f94422 (foreign-call "s_open" f94416))) (begin (if ((primitive-ref negative?) f94422) (begin ((primitive-ref error) ((primitive-ref string->symbol) "open-input-file") "open failed")) #f) (let ((f94426 (make-vector 8)) (f94425 1024)) (begin (vector-set! f94426 0 ((primitive-ref string->symbol) "input-port")) (vector-set! f94426 1 f94416) (vector-set! f94426 2 f94422) (vector-set! f94426 3 (make-string f94425)) (vector-set! f94426 4 0) (vector-set! f94426 5 f94425) (vector-set! f94426 6 #f) (vector-set! f94426 7 0) f94426))))))
# emit-tail-let
#  si   = -12
#  env  = ((f94416 . -8) (input-port . 4))
#  bindings = ((f94416 f94416))
#  body = (begin (if (not (string? f94416)) (begin ((primitive-ref error) ((primitive-ref string->symbol) "open-input-file") "filename must be a string")) #f) (let ((f94422 (foreign-call "s_open" f94416))) (begin (if ((primitive-ref negative?) f94422) (begin ((primitive-ref error) ((primitive-ref string->symbol) "open-input-file") "open failed")) #f) (let ((f94426 (make-vector 8)) (f94425 1024)) (begin (vector-set! f94426 0 ((primitive-ref string->symbol) "input-port")) (vector-set! f94426 1 f94416) (vector-set! f94426 2 f94422) (vector-set! f94426 3 (make-string f94425)) (vector-set! f94426 4 0) (vector-set! f94426 5 f94425) (vector-set! f94426 6 #f) (vector-set! f94426 7 0) f94426)))))
# emit-expr f94416
# emit-variable-ref
# env=((f94416 . -8) (input-port . 4))
# var=f94416
    movl -8(%esp), %eax  # stack load f94416
# end emit-variable-ref
    movl %eax, -12(%esp)  # stack save
# emit-tail-expr
# si=-16
# env=((f94416 . -12) (f94416 . -8) (input-port . 4))
# expr=(begin (if (not (string? f94416)) (begin ((primitive-ref error) ((primitive-ref string->symbol) "open-input-file") "filename must be a string")) #f) (let ((f94422 (foreign-call "s_open" f94416))) (begin (if ((primitive-ref negative?) f94422) (begin ((primitive-ref error) ((primitive-ref string->symbol) "open-input-file") "open failed")) #f) (let ((f94426 (make-vector 8)) (f94425 1024)) (begin (vector-set! f94426 0 ((primitive-ref string->symbol) "input-port")) (vector-set! f94426 1 f94416) (vector-set! f94426 2 f94422) (vector-set! f94426 3 (make-string f94425)) (vector-set! f94426 4 0) (vector-set! f94426 5 f94425) (vector-set! f94426 6 #f) (vector-set! f94426 7 0) f94426)))))
# tail-begin (begin (if (not (string? f94416)) (begin ((primitive-ref error) ((primitive-ref string->symbol) "open-input-file") "filename must be a string")) #f) (let ((f94422 (foreign-call "s_open" f94416))) (begin (if ((primitive-ref negative?) f94422) (begin ((primitive-ref error) ((primitive-ref string->symbol) "open-input-file") "open failed")) #f) (let ((f94426 (make-vector 8)) (f94425 1024)) (begin (vector-set! f94426 0 ((primitive-ref string->symbol) "input-port")) (vector-set! f94426 1 f94416) (vector-set! f94426 2 f94422) (vector-set! f94426 3 (make-string f94425)) (vector-set! f94426 4 0) (vector-set! f94426 5 f94425) (vector-set! f94426 6 #f) (vector-set! f94426 7 0) f94426)))))
#   env=((f94416 . -12) (f94416 . -8) (input-port . 4))
# emit-expr (if (not (string? f94416)) (begin ((primitive-ref error) ((primitive-ref string->symbol) "open-input-file") "filename must be a string")) #f)
# emit-expr (not (string? f94416))
# emit-expr (string? f94416)
# emit-expr f94416
# emit-variable-ref
# env=((f94416 . -12) (f94416 . -8) (input-port . 4))
# var=f94416
    movl -12(%esp), %eax  # stack load f94416
# end emit-variable-ref
    and $7, %al
    cmp $6, %al
    sete %al
    movzbl %al, %eax
    sal $6, %al
    or $47, %al
    cmp $47, %eax
    sete %al
    movzbl %al, %eax
    sal $6, %al
    or $47, %al
    cmp $47, %al
    je _L_571975
# emit-expr (begin ((primitive-ref error) ((primitive-ref string->symbol) "open-input-file") "filename must be a string"))
# emit-begin
#   expr=(begin ((primitive-ref error) ((primitive-ref string->symbol) "open-input-file") "filename must be a string"))
#   env=((f94416 . -12) (f94416 . -8) (input-port . 4))
# emit-expr ((primitive-ref error) ((primitive-ref string->symbol) "open-input-file") "filename must be a string")
# funcall
#    si   =-16
#    env  = ((f94416 . -12) (f94416 . -8) (input-port . 4))
#    expr = (funcall (primitive-ref error) ((primitive-ref string->symbol) "open-input-file") "filename must be a string")
# emit-expr (primitive-ref error)
    .extern mrc_error
    movl mrc_error,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_571977"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_571977":
   movl %eax,  -24(%esp)  # stash funcall-oper in closure slot
# emit-expr ((primitive-ref string->symbol) "open-input-file")
# funcall
#    si   =-28
#    env  = ((f94416 . -12) (f94416 . -8) (input-port . 4))
#    expr = (funcall (primitive-ref string->symbol) "open-input-file")
# emit-expr (primitive-ref string->symbol)
    .extern mrc_string$m$gsymbol
    movl mrc_string$m$gsymbol,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_571978"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_571978":
   movl %eax,  -36(%esp)  # stash funcall-oper in closure slot
# emit-expr "open-input-file"
# string literal
    jmp _L_571980
    .align 8,0x90
_L_571979 :
    .int 60
    .ascii "open-input-file"
_L_571980:
    movl $_L_571979, %eax
    orl $6, %eax
    mov %eax, -40(%esp)  # arg open-input-file
    movl -36(%esp), %edi   # load new closure to %edi
    add $-28, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $28, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    mov %eax, -28(%esp)  # arg ((primitive-ref string->symbol) open-input-file)
# emit-expr "filename must be a string"
# string literal
    jmp _L_571982
    .align 8,0x90
_L_571981 :
    .int 100
    .ascii "filename must be a string"
_L_571982:
    movl $_L_571981, %eax
    orl $6, %eax
    mov %eax, -32(%esp)  # arg filename must be a string
    movl -24(%esp), %edi   # load new closure to %edi
    add $-16, %esp   # adjust base
    movl $8,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $16, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
# emit-expr (begin)
# emit-begin
#   expr=(begin)
#   env=((f94416 . -12) (f94416 . -8) (input-port . 4))
    jmp _L_571976
_L_571975:
# emit-expr #f
    movl $47, %eax     # immed #f
_L_571976:
# emit-tail-expr
# si=-16
# env=((f94416 . -12) (f94416 . -8) (input-port . 4))
# expr=(begin (let ((f94422 (foreign-call "s_open" f94416))) (begin (if ((primitive-ref negative?) f94422) (begin ((primitive-ref error) ((primitive-ref string->symbol) "open-input-file") "open failed")) #f) (let ((f94426 (make-vector 8)) (f94425 1024)) (begin (vector-set! f94426 0 ((primitive-ref string->symbol) "input-port")) (vector-set! f94426 1 f94416) (vector-set! f94426 2 f94422) (vector-set! f94426 3 (make-string f94425)) (vector-set! f94426 4 0) (vector-set! f94426 5 f94425) (vector-set! f94426 6 #f) (vector-set! f94426 7 0) f94426)))))
# tail-begin (begin (let ((f94422 (foreign-call "s_open" f94416))) (begin (if ((primitive-ref negative?) f94422) (begin ((primitive-ref error) ((primitive-ref string->symbol) "open-input-file") "open failed")) #f) (let ((f94426 (make-vector 8)) (f94425 1024)) (begin (vector-set! f94426 0 ((primitive-ref string->symbol) "input-port")) (vector-set! f94426 1 f94416) (vector-set! f94426 2 f94422) (vector-set! f94426 3 (make-string f94425)) (vector-set! f94426 4 0) (vector-set! f94426 5 f94425) (vector-set! f94426 6 #f) (vector-set! f94426 7 0) f94426)))))
#   env=((f94416 . -12) (f94416 . -8) (input-port . 4))
# emit-tail-expr
# si=-16
# env=((f94416 . -12) (f94416 . -8) (input-port . 4))
# expr=(let ((f94422 (foreign-call "s_open" f94416))) (begin (if ((primitive-ref negative?) f94422) (begin ((primitive-ref error) ((primitive-ref string->symbol) "open-input-file") "open failed")) #f) (let ((f94426 (make-vector 8)) (f94425 1024)) (begin (vector-set! f94426 0 ((primitive-ref string->symbol) "input-port")) (vector-set! f94426 1 f94416) (vector-set! f94426 2 f94422) (vector-set! f94426 3 (make-string f94425)) (vector-set! f94426 4 0) (vector-set! f94426 5 f94425) (vector-set! f94426 6 #f) (vector-set! f94426 7 0) f94426))))
# emit-tail-let
#  si   = -16
#  env  = ((f94416 . -12) (f94416 . -8) (input-port . 4))
#  bindings = ((f94422 (foreign-call "s_open" f94416)))
#  body = (begin (if ((primitive-ref negative?) f94422) (begin ((primitive-ref error) ((primitive-ref string->symbol) "open-input-file") "open failed")) #f) (let ((f94426 (make-vector 8)) (f94425 1024)) (begin (vector-set! f94426 0 ((primitive-ref string->symbol) "input-port")) (vector-set! f94426 1 f94416) (vector-set! f94426 2 f94422) (vector-set! f94426 3 (make-string f94425)) (vector-set! f94426 4 0) (vector-set! f94426 5 f94425) (vector-set! f94426 6 #f) (vector-set! f94426 7 0) f94426)))
# emit-expr (foreign-call "s_open" f94416)
    movl %ecx,-16(%esp)
    movl %esp,-20(%esp)
# emit-expr f94416
# emit-variable-ref
# env=((f94416 . -12) (f94416 . -8) (input-port . 4))
# var=f94416
    movl -12(%esp), %eax  # stack load f94416
# end emit-variable-ref
    movl %eax, -24(%esp)
    leal -24(%esp),%edi
    movl %edi,%esi
    andl $-16,%esi
    movl 0(%edi),%eax
    movl %eax,0(%esi)
    movl 4(%edi),%eax
    movl %eax,4(%esi)
    movl %esi,%esp
    .extern _s_open
    call _s_open
    movl 4(%esi),%esp
    movl -16(%esp),%ecx
    movl %eax, -16(%esp)  # stack save
# emit-tail-expr
# si=-20
# env=((f94422 . -16) (f94416 . -12) (f94416 . -8) (input-port . 4))
# expr=(begin (if ((primitive-ref negative?) f94422) (begin ((primitive-ref error) ((primitive-ref string->symbol) "open-input-file") "open failed")) #f) (let ((f94426 (make-vector 8)) (f94425 1024)) (begin (vector-set! f94426 0 ((primitive-ref string->symbol) "input-port")) (vector-set! f94426 1 f94416) (vector-set! f94426 2 f94422) (vector-set! f94426 3 (make-string f94425)) (vector-set! f94426 4 0) (vector-set! f94426 5 f94425) (vector-set! f94426 6 #f) (vector-set! f94426 7 0) f94426)))
# tail-begin (begin (if ((primitive-ref negative?) f94422) (begin ((primitive-ref error) ((primitive-ref string->symbol) "open-input-file") "open failed")) #f) (let ((f94426 (make-vector 8)) (f94425 1024)) (begin (vector-set! f94426 0 ((primitive-ref string->symbol) "input-port")) (vector-set! f94426 1 f94416) (vector-set! f94426 2 f94422) (vector-set! f94426 3 (make-string f94425)) (vector-set! f94426 4 0) (vector-set! f94426 5 f94425) (vector-set! f94426 6 #f) (vector-set! f94426 7 0) f94426)))
#   env=((f94422 . -16) (f94416 . -12) (f94416 . -8) (input-port . 4))
# emit-expr (if ((primitive-ref negative?) f94422) (begin ((primitive-ref error) ((primitive-ref string->symbol) "open-input-file") "open failed")) #f)
# emit-expr ((primitive-ref negative?) f94422)
# funcall
#    si   =-20
#    env  = ((f94422 . -16) (f94416 . -12) (f94416 . -8) (input-port . 4))
#    expr = (funcall (primitive-ref negative?) f94422)
# emit-expr (primitive-ref negative?)
    .extern mrc_negative$q
    movl mrc_negative$q,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_571985"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_571985":
   movl %eax,  -28(%esp)  # stash funcall-oper in closure slot
# emit-expr f94422
# emit-variable-ref
# env=((f94422 . -16) (f94416 . -12) (f94416 . -8) (input-port . 4))
# var=f94422
    movl -16(%esp), %eax  # stack load f94422
# end emit-variable-ref
    mov %eax, -32(%esp)  # arg f94422
    movl -28(%esp), %edi   # load new closure to %edi
    add $-20, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $20, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    cmp $47, %al
    je _L_571983
# emit-expr (begin ((primitive-ref error) ((primitive-ref string->symbol) "open-input-file") "open failed"))
# emit-begin
#   expr=(begin ((primitive-ref error) ((primitive-ref string->symbol) "open-input-file") "open failed"))
#   env=((f94422 . -16) (f94416 . -12) (f94416 . -8) (input-port . 4))
# emit-expr ((primitive-ref error) ((primitive-ref string->symbol) "open-input-file") "open failed")
# funcall
#    si   =-20
#    env  = ((f94422 . -16) (f94416 . -12) (f94416 . -8) (input-port . 4))
#    expr = (funcall (primitive-ref error) ((primitive-ref string->symbol) "open-input-file") "open failed")
# emit-expr (primitive-ref error)
    .extern mrc_error
    movl mrc_error,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_571986"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_571986":
   movl %eax,  -28(%esp)  # stash funcall-oper in closure slot
# emit-expr ((primitive-ref string->symbol) "open-input-file")
# funcall
#    si   =-32
#    env  = ((f94422 . -16) (f94416 . -12) (f94416 . -8) (input-port . 4))
#    expr = (funcall (primitive-ref string->symbol) "open-input-file")
# emit-expr (primitive-ref string->symbol)
    .extern mrc_string$m$gsymbol
    movl mrc_string$m$gsymbol,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_571987"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_571987":
   movl %eax,  -40(%esp)  # stash funcall-oper in closure slot
# emit-expr "open-input-file"
# string literal
    jmp _L_571989
    .align 8,0x90
_L_571988 :
    .int 60
    .ascii "open-input-file"
_L_571989:
    movl $_L_571988, %eax
    orl $6, %eax
    mov %eax, -44(%esp)  # arg open-input-file
    movl -40(%esp), %edi   # load new closure to %edi
    add $-32, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $32, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    mov %eax, -32(%esp)  # arg ((primitive-ref string->symbol) open-input-file)
# emit-expr "open failed"
# string literal
    jmp _L_571991
    .align 8,0x90
_L_571990 :
    .int 44
    .ascii "open failed"
_L_571991:
    movl $_L_571990, %eax
    orl $6, %eax
    mov %eax, -36(%esp)  # arg open failed
    movl -28(%esp), %edi   # load new closure to %edi
    add $-20, %esp   # adjust base
    movl $8,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $20, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
# emit-expr (begin)
# emit-begin
#   expr=(begin)
#   env=((f94422 . -16) (f94416 . -12) (f94416 . -8) (input-port . 4))
    jmp _L_571984
_L_571983:
# emit-expr #f
    movl $47, %eax     # immed #f
_L_571984:
# emit-tail-expr
# si=-20
# env=((f94422 . -16) (f94416 . -12) (f94416 . -8) (input-port . 4))
# expr=(begin (let ((f94426 (make-vector 8)) (f94425 1024)) (begin (vector-set! f94426 0 ((primitive-ref string->symbol) "input-port")) (vector-set! f94426 1 f94416) (vector-set! f94426 2 f94422) (vector-set! f94426 3 (make-string f94425)) (vector-set! f94426 4 0) (vector-set! f94426 5 f94425) (vector-set! f94426 6 #f) (vector-set! f94426 7 0) f94426)))
# tail-begin (begin (let ((f94426 (make-vector 8)) (f94425 1024)) (begin (vector-set! f94426 0 ((primitive-ref string->symbol) "input-port")) (vector-set! f94426 1 f94416) (vector-set! f94426 2 f94422) (vector-set! f94426 3 (make-string f94425)) (vector-set! f94426 4 0) (vector-set! f94426 5 f94425) (vector-set! f94426 6 #f) (vector-set! f94426 7 0) f94426)))
#   env=((f94422 . -16) (f94416 . -12) (f94416 . -8) (input-port . 4))
# emit-tail-expr
# si=-20
# env=((f94422 . -16) (f94416 . -12) (f94416 . -8) (input-port . 4))
# expr=(let ((f94426 (make-vector 8)) (f94425 1024)) (begin (vector-set! f94426 0 ((primitive-ref string->symbol) "input-port")) (vector-set! f94426 1 f94416) (vector-set! f94426 2 f94422) (vector-set! f94426 3 (make-string f94425)) (vector-set! f94426 4 0) (vector-set! f94426 5 f94425) (vector-set! f94426 6 #f) (vector-set! f94426 7 0) f94426))
# emit-tail-let
#  si   = -20
#  env  = ((f94422 . -16) (f94416 . -12) (f94416 . -8) (input-port . 4))
#  bindings = ((f94426 (make-vector 8)) (f94425 1024))
#  body = (begin (vector-set! f94426 0 ((primitive-ref string->symbol) "input-port")) (vector-set! f94426 1 f94416) (vector-set! f94426 2 f94422) (vector-set! f94426 3 (make-string f94425)) (vector-set! f94426 4 0) (vector-set! f94426 5 f94425) (vector-set! f94426 6 #f) (vector-set! f94426 7 0) f94426)
# emit-expr (make-vector 8)
# make-vector 8
# emit-expr 8
    movl $32, %eax     # immed 8
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_571992"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_571992:
# check the argument is a fixnum >= 0
    cmp $0,%eax
    jge _L_571993
# invoke error handler eh_length
    .extern mrc_eh$ulength
    movl mrc_eh$ulength, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_571993:
    movl %eax, %esi
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    orl  $5, %eax
    addl $4, %esi
    addl $4, %esi
    andl $-8, %esi
    addl %esi, %ebp
    movl %eax, -20(%esp)  # stack save
# emit-expr 1024
    movl $4096, %eax     # immed 1024
    movl %eax, -24(%esp)  # stack save
# emit-tail-expr
# si=-28
# env=((f94425 . -24) (f94426 . -20) (f94422 . -16) (f94416 . -12) (f94416 . -8) (input-port . 4))
# expr=(begin (vector-set! f94426 0 ((primitive-ref string->symbol) "input-port")) (vector-set! f94426 1 f94416) (vector-set! f94426 2 f94422) (vector-set! f94426 3 (make-string f94425)) (vector-set! f94426 4 0) (vector-set! f94426 5 f94425) (vector-set! f94426 6 #f) (vector-set! f94426 7 0) f94426)
# tail-begin (begin (vector-set! f94426 0 ((primitive-ref string->symbol) "input-port")) (vector-set! f94426 1 f94416) (vector-set! f94426 2 f94422) (vector-set! f94426 3 (make-string f94425)) (vector-set! f94426 4 0) (vector-set! f94426 5 f94425) (vector-set! f94426 6 #f) (vector-set! f94426 7 0) f94426)
#   env=((f94425 . -24) (f94426 . -20) (f94422 . -16) (f94416 . -12) (f94416 . -8) (input-port . 4))
# emit-expr (vector-set! f94426 0 ((primitive-ref string->symbol) "input-port"))
# emit-expr f94426
# emit-variable-ref
# env=((f94425 . -24) (f94426 . -20) (f94422 . -16) (f94416 . -12) (f94416 . -8) (input-port . 4))
# var=f94426
    movl -20(%esp), %eax  # stack load f94426
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_571994
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_571994:
    movl %eax, -28(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_571995"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_571995:
# check bounds on vector index
    movl -28(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_571997
    cmp  $0,%eax
    jge _L_571996
_L_571997:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_571996:
    movl %eax, -32(%esp)
# emit-expr ((primitive-ref string->symbol) "input-port")
# funcall
#    si   =-36
#    env  = ((f94425 . -24) (f94426 . -20) (f94422 . -16) (f94416 . -12) (f94416 . -8) (input-port . 4))
#    expr = (funcall (primitive-ref string->symbol) "input-port")
# emit-expr (primitive-ref string->symbol)
    .extern mrc_string$m$gsymbol
    movl mrc_string$m$gsymbol,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_571998"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_571998":
   movl %eax,  -44(%esp)  # stash funcall-oper in closure slot
# emit-expr "input-port"
# string literal
    jmp _L_572000
    .align 8,0x90
_L_571999 :
    .int 40
    .ascii "input-port"
_L_572000:
    movl $_L_571999, %eax
    orl $6, %eax
    mov %eax, -48(%esp)  # arg input-port
    movl -44(%esp), %edi   # load new closure to %edi
    add $-36, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $36, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    movl -28(%esp), %ebx
    movl -32(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-tail-expr
# si=-28
# env=((f94425 . -24) (f94426 . -20) (f94422 . -16) (f94416 . -12) (f94416 . -8) (input-port . 4))
# expr=(begin (vector-set! f94426 1 f94416) (vector-set! f94426 2 f94422) (vector-set! f94426 3 (make-string f94425)) (vector-set! f94426 4 0) (vector-set! f94426 5 f94425) (vector-set! f94426 6 #f) (vector-set! f94426 7 0) f94426)
# tail-begin (begin (vector-set! f94426 1 f94416) (vector-set! f94426 2 f94422) (vector-set! f94426 3 (make-string f94425)) (vector-set! f94426 4 0) (vector-set! f94426 5 f94425) (vector-set! f94426 6 #f) (vector-set! f94426 7 0) f94426)
#   env=((f94425 . -24) (f94426 . -20) (f94422 . -16) (f94416 . -12) (f94416 . -8) (input-port . 4))
# emit-expr (vector-set! f94426 1 f94416)
# emit-expr f94426
# emit-variable-ref
# env=((f94425 . -24) (f94426 . -20) (f94422 . -16) (f94416 . -12) (f94416 . -8) (input-port . 4))
# var=f94426
    movl -20(%esp), %eax  # stack load f94426
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_572001
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_572001:
    movl %eax, -28(%esp)
# emit-expr 1
    movl $4, %eax     # immed 1
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_572002"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_572002:
# check bounds on vector index
    movl -28(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_572004
    cmp  $0,%eax
    jge _L_572003
_L_572004:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_572003:
    movl %eax, -32(%esp)
# emit-expr f94416
# emit-variable-ref
# env=((f94425 . -24) (f94426 . -20) (f94422 . -16) (f94416 . -12) (f94416 . -8) (input-port . 4))
# var=f94416
    movl -12(%esp), %eax  # stack load f94416
# end emit-variable-ref
    movl -28(%esp), %ebx
    movl -32(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-tail-expr
# si=-28
# env=((f94425 . -24) (f94426 . -20) (f94422 . -16) (f94416 . -12) (f94416 . -8) (input-port . 4))
# expr=(begin (vector-set! f94426 2 f94422) (vector-set! f94426 3 (make-string f94425)) (vector-set! f94426 4 0) (vector-set! f94426 5 f94425) (vector-set! f94426 6 #f) (vector-set! f94426 7 0) f94426)
# tail-begin (begin (vector-set! f94426 2 f94422) (vector-set! f94426 3 (make-string f94425)) (vector-set! f94426 4 0) (vector-set! f94426 5 f94425) (vector-set! f94426 6 #f) (vector-set! f94426 7 0) f94426)
#   env=((f94425 . -24) (f94426 . -20) (f94422 . -16) (f94416 . -12) (f94416 . -8) (input-port . 4))
# emit-expr (vector-set! f94426 2 f94422)
# emit-expr f94426
# emit-variable-ref
# env=((f94425 . -24) (f94426 . -20) (f94422 . -16) (f94416 . -12) (f94416 . -8) (input-port . 4))
# var=f94426
    movl -20(%esp), %eax  # stack load f94426
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_572005
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_572005:
    movl %eax, -28(%esp)
# emit-expr 2
    movl $8, %eax     # immed 2
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_572006"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_572006:
# check bounds on vector index
    movl -28(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_572008
    cmp  $0,%eax
    jge _L_572007
_L_572008:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_572007:
    movl %eax, -32(%esp)
# emit-expr f94422
# emit-variable-ref
# env=((f94425 . -24) (f94426 . -20) (f94422 . -16) (f94416 . -12) (f94416 . -8) (input-port . 4))
# var=f94422
    movl -16(%esp), %eax  # stack load f94422
# end emit-variable-ref
    movl -28(%esp), %ebx
    movl -32(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-tail-expr
# si=-28
# env=((f94425 . -24) (f94426 . -20) (f94422 . -16) (f94416 . -12) (f94416 . -8) (input-port . 4))
# expr=(begin (vector-set! f94426 3 (make-string f94425)) (vector-set! f94426 4 0) (vector-set! f94426 5 f94425) (vector-set! f94426 6 #f) (vector-set! f94426 7 0) f94426)
# tail-begin (begin (vector-set! f94426 3 (make-string f94425)) (vector-set! f94426 4 0) (vector-set! f94426 5 f94425) (vector-set! f94426 6 #f) (vector-set! f94426 7 0) f94426)
#   env=((f94425 . -24) (f94426 . -20) (f94422 . -16) (f94416 . -12) (f94416 . -8) (input-port . 4))
# emit-expr (vector-set! f94426 3 (make-string f94425))
# emit-expr f94426
# emit-variable-ref
# env=((f94425 . -24) (f94426 . -20) (f94422 . -16) (f94416 . -12) (f94416 . -8) (input-port . 4))
# var=f94426
    movl -20(%esp), %eax  # stack load f94426
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_572009
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_572009:
    movl %eax, -28(%esp)
# emit-expr 3
    movl $12, %eax     # immed 3
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_572010"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_572010:
# check bounds on vector index
    movl -28(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_572012
    cmp  $0,%eax
    jge _L_572011
_L_572012:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_572011:
    movl %eax, -32(%esp)
# emit-expr (make-string f94425)
# make-string len=f94425
# emit-expr f94425
# emit-variable-ref
# env=((f94425 . -24) (f94426 . -20) (f94422 . -16) (f94416 . -12) (f94416 . -8) (input-port . 4))
# var=f94425
    movl -24(%esp), %eax  # stack load f94425
# end emit-variable-ref
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_572013"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $152,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_572013:
# check the argument is a fixnum >= 0
    cmp $0,%eax
    jge _L_572014
# invoke error handler eh_length
    .extern mrc_eh$ulength
    movl mrc_eh$ulength, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $152,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_572014:
    movl %eax, %esi
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    orl $6, %eax
    sar $2, %esi
    add $4, %esi
    add $7, %esi
    andl $-8, %esi
    add  %esi, %ebp
# make-string end
    movl -28(%esp), %ebx
    movl -32(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-tail-expr
# si=-28
# env=((f94425 . -24) (f94426 . -20) (f94422 . -16) (f94416 . -12) (f94416 . -8) (input-port . 4))
# expr=(begin (vector-set! f94426 4 0) (vector-set! f94426 5 f94425) (vector-set! f94426 6 #f) (vector-set! f94426 7 0) f94426)
# tail-begin (begin (vector-set! f94426 4 0) (vector-set! f94426 5 f94425) (vector-set! f94426 6 #f) (vector-set! f94426 7 0) f94426)
#   env=((f94425 . -24) (f94426 . -20) (f94422 . -16) (f94416 . -12) (f94416 . -8) (input-port . 4))
# emit-expr (vector-set! f94426 4 0)
# emit-expr f94426
# emit-variable-ref
# env=((f94425 . -24) (f94426 . -20) (f94422 . -16) (f94416 . -12) (f94416 . -8) (input-port . 4))
# var=f94426
    movl -20(%esp), %eax  # stack load f94426
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_572015
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_572015:
    movl %eax, -28(%esp)
# emit-expr 4
    movl $16, %eax     # immed 4
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_572016"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_572016:
# check bounds on vector index
    movl -28(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_572018
    cmp  $0,%eax
    jge _L_572017
_L_572018:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_572017:
    movl %eax, -32(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
    movl -28(%esp), %ebx
    movl -32(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-tail-expr
# si=-28
# env=((f94425 . -24) (f94426 . -20) (f94422 . -16) (f94416 . -12) (f94416 . -8) (input-port . 4))
# expr=(begin (vector-set! f94426 5 f94425) (vector-set! f94426 6 #f) (vector-set! f94426 7 0) f94426)
# tail-begin (begin (vector-set! f94426 5 f94425) (vector-set! f94426 6 #f) (vector-set! f94426 7 0) f94426)
#   env=((f94425 . -24) (f94426 . -20) (f94422 . -16) (f94416 . -12) (f94416 . -8) (input-port . 4))
# emit-expr (vector-set! f94426 5 f94425)
# emit-expr f94426
# emit-variable-ref
# env=((f94425 . -24) (f94426 . -20) (f94422 . -16) (f94416 . -12) (f94416 . -8) (input-port . 4))
# var=f94426
    movl -20(%esp), %eax  # stack load f94426
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_572019
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_572019:
    movl %eax, -28(%esp)
# emit-expr 5
    movl $20, %eax     # immed 5
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_572020"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_572020:
# check bounds on vector index
    movl -28(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_572022
    cmp  $0,%eax
    jge _L_572021
_L_572022:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_572021:
    movl %eax, -32(%esp)
# emit-expr f94425
# emit-variable-ref
# env=((f94425 . -24) (f94426 . -20) (f94422 . -16) (f94416 . -12) (f94416 . -8) (input-port . 4))
# var=f94425
    movl -24(%esp), %eax  # stack load f94425
# end emit-variable-ref
    movl -28(%esp), %ebx
    movl -32(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-tail-expr
# si=-28
# env=((f94425 . -24) (f94426 . -20) (f94422 . -16) (f94416 . -12) (f94416 . -8) (input-port . 4))
# expr=(begin (vector-set! f94426 6 #f) (vector-set! f94426 7 0) f94426)
# tail-begin (begin (vector-set! f94426 6 #f) (vector-set! f94426 7 0) f94426)
#   env=((f94425 . -24) (f94426 . -20) (f94422 . -16) (f94416 . -12) (f94416 . -8) (input-port . 4))
# emit-expr (vector-set! f94426 6 #f)
# emit-expr f94426
# emit-variable-ref
# env=((f94425 . -24) (f94426 . -20) (f94422 . -16) (f94416 . -12) (f94416 . -8) (input-port . 4))
# var=f94426
    movl -20(%esp), %eax  # stack load f94426
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_572023
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_572023:
    movl %eax, -28(%esp)
# emit-expr 6
    movl $24, %eax     # immed 6
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_572024"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_572024:
# check bounds on vector index
    movl -28(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_572026
    cmp  $0,%eax
    jge _L_572025
_L_572026:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_572025:
    movl %eax, -32(%esp)
# emit-expr #f
    movl $47, %eax     # immed #f
    movl -28(%esp), %ebx
    movl -32(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-tail-expr
# si=-28
# env=((f94425 . -24) (f94426 . -20) (f94422 . -16) (f94416 . -12) (f94416 . -8) (input-port . 4))
# expr=(begin (vector-set! f94426 7 0) f94426)
# tail-begin (begin (vector-set! f94426 7 0) f94426)
#   env=((f94425 . -24) (f94426 . -20) (f94422 . -16) (f94416 . -12) (f94416 . -8) (input-port . 4))
# emit-expr (vector-set! f94426 7 0)
# emit-expr f94426
# emit-variable-ref
# env=((f94425 . -24) (f94426 . -20) (f94422 . -16) (f94416 . -12) (f94416 . -8) (input-port . 4))
# var=f94426
    movl -20(%esp), %eax  # stack load f94426
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_572027
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_572027:
    movl %eax, -28(%esp)
# emit-expr 7
    movl $28, %eax     # immed 7
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_572028"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_572028:
# check bounds on vector index
    movl -28(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_572030
    cmp  $0,%eax
    jge _L_572029
_L_572030:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_572029:
    movl %eax, -32(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
    movl -28(%esp), %ebx
    movl -32(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-tail-expr
# si=-28
# env=((f94425 . -24) (f94426 . -20) (f94422 . -16) (f94416 . -12) (f94416 . -8) (input-port . 4))
# expr=(begin f94426)
# tail-begin (begin f94426)
#   env=((f94425 . -24) (f94426 . -20) (f94422 . -16) (f94416 . -12) (f94416 . -8) (input-port . 4))
# emit-tail-expr
# si=-28
# env=((f94425 . -24) (f94426 . -20) (f94422 . -16) (f94416 . -12) (f94416 . -8) (input-port . 4))
# expr=f94426
# emit-tail-variable-ref
# emit-variable-ref
# env=((f94425 . -24) (f94426 . -20) (f94422 . -16) (f94416 . -12) (f94416 . -8) (input-port . 4))
# var=f94426
    movl -20(%esp), %eax  # stack load f94426
# end emit-variable-ref
    ret
# end emit-tail-variable ref
     ret   # return thru stack
     ret   # return thru stack
     ret   # return thru stack
    .align 4,0x90
_L_571973:
     movl %eax, mrc_open$minput$mfile
# == explicit-begins  ==>
# (lambda args (let ((p (if (null? args) (current-input-port) (car args)))) (cond ((port-unread p) (let ((ch (port-unread p))) (begin (unless (eof-object? (port-unread p)) (port-unread-clear p)) ch))) (else (begin (when (fx= (port-last p) (port-ndx p)) (fill-input-buffer p)) (if (port-unread p) (port-unread p) (let ((ch (string-ref (port-buf p) (port-ndx p)))) (begin (port-ndx-add1 p) ch))))))))
# == eliminate-let*  ==>
# (lambda args (let ((p (if (null? args) (current-input-port) (car args)))) (cond ((port-unread p) (let ((ch (port-unread p))) (begin (unless (eof-object? (port-unread p)) (port-unread-clear p)) ch))) (else (begin (when (fx= (port-last p) (port-ndx p)) (fill-input-buffer p)) (if (port-unread p) (port-unread p) (let ((ch (string-ref (port-buf p) (port-ndx p)))) (begin (port-ndx-add1 p) ch))))))))
# == uniquify-variables  ==>
# (lambda f94427 (let ((f94433 (if (null? f94427) (current-input-port) (car f94427)))) (cond ((port-unread f94433) (let ((f94436 (port-unread f94433))) (begin (unless (eof-object? (port-unread f94433)) (port-unread-clear f94433)) f94436))) (else (begin (when (fx= (port-last f94433) (port-ndx f94433)) (fill-input-buffer f94433)) (if (port-unread f94433) (port-unread f94433) (let ((f94437 (string-ref (port-buf f94433) (port-ndx f94433)))) (begin (port-ndx-add1 f94433) f94437))))))))
# == vectorize-letrec  ==>
# (lambda f94427 (let ((f94433 (if (null? f94427) (current-input-port) (car f94427)))) (cond ((port-unread f94433) (let ((f94436 (port-unread f94433))) (begin (unless (eof-object? (port-unread f94433)) (port-unread-clear f94433)) f94436))) (else (begin (when (fx= (port-last f94433) (port-ndx f94433)) (fill-input-buffer f94433)) (if (port-unread f94433) (port-unread f94433) (let ((f94437 (string-ref (port-buf f94433) (port-ndx f94433)))) (begin (port-ndx-add1 f94433) f94437))))))))
# == eliminate-set!  ==>
# (lambda f94427 (let () (let ((f94433 (if (null? f94427) (current-input-port) (car f94427)))) (cond ((port-unread f94433) (let ((f94436 (port-unread f94433))) (begin (unless (eof-object? (port-unread f94433)) (port-unread-clear f94433)) f94436))) (else (begin (when (fx= (port-last f94433) (port-ndx f94433)) (fill-input-buffer f94433)) (if (port-unread f94433) (port-unread f94433) (let ((f94437 (string-ref (port-buf f94433) (port-ndx f94433)))) (begin (port-ndx-add1 f94433) f94437)))))))))
# == close-free-variables  ==>
# (closure f94427 () (let () (let ((f94433 (if (null? f94427) (current-input-port) (car f94427)))) (cond ((port-unread f94433) (let ((f94436 (port-unread f94433))) (begin (unless (eof-object? (port-unread f94433)) (port-unread-clear f94433)) f94436))) (else (begin (when (fx= (port-last f94433) (port-ndx f94433)) (fill-input-buffer f94433)) (if (port-unread f94433) (port-unread f94433) (let ((f94437 (string-ref (port-buf f94433) (port-ndx f94433)))) (begin (port-ndx-add1 f94433) f94437)))))))))
# == eliminate-quote  ==>
# (closure f94427 () (let () (let ((f94433 (if (null? f94427) (current-input-port) (car f94427)))) (cond ((port-unread f94433) (let ((f94436 (port-unread f94433))) (begin (unless (eof-object? (port-unread f94433)) (port-unread-clear f94433)) f94436))) (else (begin (when (fx= (port-last f94433) (port-ndx f94433)) (fill-input-buffer f94433)) (if (port-unread f94433) (port-unread f94433) (let ((f94437 (string-ref (port-buf f94433) (port-ndx f94433)))) (begin (port-ndx-add1 f94433) f94437)))))))))
# == eliminate-when/unless  ==>
# (closure f94427 () (let () (let ((f94433 (if (null? f94427) (current-input-port) (car f94427)))) (cond ((port-unread f94433) (let ((f94436 (port-unread f94433))) (begin (if (not (eof-object? (port-unread f94433))) (begin (port-unread-clear f94433)) #f) f94436))) (else (begin (if (fx= (port-last f94433) (port-ndx f94433)) (begin (fill-input-buffer f94433)) #f) (if (port-unread f94433) (port-unread f94433) (let ((f94437 (string-ref (port-buf f94433) (port-ndx f94433)))) (begin (port-ndx-add1 f94433) f94437)))))))))
# == eliminate-cond  ==>
# (closure f94427 () (let () (let ((f94433 (if (null? f94427) (current-input-port) (car f94427)))) (if (port-unread f94433) (let ((f94436 (port-unread f94433))) (begin (if (not (eof-object? (port-unread f94433))) (begin (port-unread-clear f94433)) #f) f94436)) (begin (if (fx= (port-last f94433) (port-ndx f94433)) (begin (fill-input-buffer f94433)) #f) (if (port-unread f94433) (port-unread f94433) (let ((f94437 (string-ref (port-buf f94433) (port-ndx f94433)))) (begin (port-ndx-add1 f94433) f94437))))))))
# == external-symbols  ==>
# (closure f94427 () (let () (let ((f94433 (if (null? f94427) ((primitive-ref current-input-port)) (car f94427)))) (if ((primitive-ref port-unread) f94433) (let ((f94436 ((primitive-ref port-unread) f94433))) (begin (if (not (eof-object? ((primitive-ref port-unread) f94433))) (begin ((primitive-ref port-unread-clear) f94433)) #f) f94436)) (begin (if (fx= ((primitive-ref port-last) f94433) ((primitive-ref port-ndx) f94433)) (begin ((primitive-ref fill-input-buffer) f94433)) #f) (if ((primitive-ref port-unread) f94433) ((primitive-ref port-unread) f94433) (let ((f94437 (string-ref ((primitive-ref port-buf) f94433) ((primitive-ref port-ndx) f94433)))) (begin ((primitive-ref port-ndx-add1) f94433) f94437))))))))
# emit-expr (closure f94427 () (let () (let ((f94433 (if (null? f94427) ((primitive-ref current-input-port)) (car f94427)))) (if ((primitive-ref port-unread) f94433) (let ((f94436 ((primitive-ref port-unread) f94433))) (begin (if (not (eof-object? ((primitive-ref port-unread) f94433))) (begin ((primitive-ref port-unread-clear) f94433)) #f) f94436)) (begin (if (fx= ((primitive-ref port-last) f94433) ((primitive-ref port-ndx) f94433)) (begin ((primitive-ref fill-input-buffer) f94433)) #f) (if ((primitive-ref port-unread) f94433) ((primitive-ref port-unread) f94433) (let ((f94437 (string-ref ((primitive-ref port-buf) f94433) ((primitive-ref port-ndx) f94433)))) (begin ((primitive-ref port-ndx-add1) f94433) f94437))))))))
# emit-closure
# si = 0
# env = ()
# expr = (closure f94427 () (let () (let ((f94433 (if (null? f94427) ((primitive-ref current-input-port)) (car f94427)))) (if ((primitive-ref port-unread) f94433) (let ((f94436 ((primitive-ref port-unread) f94433))) (begin (if (not (eof-object? ((primitive-ref port-unread) f94433))) (begin ((primitive-ref port-unread-clear) f94433)) #f) f94436)) (begin (if (fx= ((primitive-ref port-last) f94433) ((primitive-ref port-ndx) f94433)) (begin ((primitive-ref fill-input-buffer) f94433)) #f) (if ((primitive-ref port-unread) f94433) ((primitive-ref port-unread) f94433) (let ((f94437 (string-ref ((primitive-ref port-buf) f94433) ((primitive-ref port-ndx) f94433)))) (begin ((primitive-ref port-ndx-add1) f94433) f94437))))))))
    movl $_L_572031, 0(%ebp)  # closure label
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $8, %ebp     # bump ebp
    jmp _L_572032            # jump around closure body
_L_572031:
# check argument count
    cmp $0,%eax
    jge _L_572033
# invoke error handler eh_argcount_min
    .extern mrc_eh$uargcount$umin
    movl mrc_eh$uargcount$umin, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_572033:
# emit-build-varargs-list
    movl $63, %esi       # args <- () 
    lea -4(%esp),%edi    # edi <- esp-4
    subl %eax, %edi      # edi <- esp-4-eax    addr of arg[K+N] on stack
_L_572035:
    lea -4(%esp),%ebx    # addr of arg[K] on stack
    cmp %edi, %ebx       # while edi <> esp+(si+4)
    je _L_572034
    movl (%edi),%ebx     # arg i -> car
    movl %ebx, 0(%ebp)
    movl %esi, 4(%ebp)  # esi -> cdr
    movl %ebp, %esi
    addl $1, %esi       # tag as pair
    addl $8,%ebp         # bump heap ptr
    addl $4,%edi         # move to next previous arg from the end
    jmp _L_572035
_L_572034:
    movl %esi, -8(%esp)  # set args
# emit-tail-expr
# si=-12
# env=((f94427 . -8))
# expr=(let () (let ((f94433 (if (null? f94427) ((primitive-ref current-input-port)) (car f94427)))) (if ((primitive-ref port-unread) f94433) (let ((f94436 ((primitive-ref port-unread) f94433))) (begin (if (not (eof-object? ((primitive-ref port-unread) f94433))) (begin ((primitive-ref port-unread-clear) f94433)) #f) f94436)) (begin (if (fx= ((primitive-ref port-last) f94433) ((primitive-ref port-ndx) f94433)) (begin ((primitive-ref fill-input-buffer) f94433)) #f) (if ((primitive-ref port-unread) f94433) ((primitive-ref port-unread) f94433) (let ((f94437 (string-ref ((primitive-ref port-buf) f94433) ((primitive-ref port-ndx) f94433)))) (begin ((primitive-ref port-ndx-add1) f94433) f94437)))))))
# emit-tail-let
#  si   = -12
#  env  = ((f94427 . -8))
#  bindings = ()
#  body = (let ((f94433 (if (null? f94427) ((primitive-ref current-input-port)) (car f94427)))) (if ((primitive-ref port-unread) f94433) (let ((f94436 ((primitive-ref port-unread) f94433))) (begin (if (not (eof-object? ((primitive-ref port-unread) f94433))) (begin ((primitive-ref port-unread-clear) f94433)) #f) f94436)) (begin (if (fx= ((primitive-ref port-last) f94433) ((primitive-ref port-ndx) f94433)) (begin ((primitive-ref fill-input-buffer) f94433)) #f) (if ((primitive-ref port-unread) f94433) ((primitive-ref port-unread) f94433) (let ((f94437 (string-ref ((primitive-ref port-buf) f94433) ((primitive-ref port-ndx) f94433)))) (begin ((primitive-ref port-ndx-add1) f94433) f94437))))))
# emit-tail-expr
# si=-12
# env=((f94427 . -8))
# expr=(let ((f94433 (if (null? f94427) ((primitive-ref current-input-port)) (car f94427)))) (if ((primitive-ref port-unread) f94433) (let ((f94436 ((primitive-ref port-unread) f94433))) (begin (if (not (eof-object? ((primitive-ref port-unread) f94433))) (begin ((primitive-ref port-unread-clear) f94433)) #f) f94436)) (begin (if (fx= ((primitive-ref port-last) f94433) ((primitive-ref port-ndx) f94433)) (begin ((primitive-ref fill-input-buffer) f94433)) #f) (if ((primitive-ref port-unread) f94433) ((primitive-ref port-unread) f94433) (let ((f94437 (string-ref ((primitive-ref port-buf) f94433) ((primitive-ref port-ndx) f94433)))) (begin ((primitive-ref port-ndx-add1) f94433) f94437))))))
# emit-tail-let
#  si   = -12
#  env  = ((f94427 . -8))
#  bindings = ((f94433 (if (null? f94427) ((primitive-ref current-input-port)) (car f94427))))
#  body = (if ((primitive-ref port-unread) f94433) (let ((f94436 ((primitive-ref port-unread) f94433))) (begin (if (not (eof-object? ((primitive-ref port-unread) f94433))) (begin ((primitive-ref port-unread-clear) f94433)) #f) f94436)) (begin (if (fx= ((primitive-ref port-last) f94433) ((primitive-ref port-ndx) f94433)) (begin ((primitive-ref fill-input-buffer) f94433)) #f) (if ((primitive-ref port-unread) f94433) ((primitive-ref port-unread) f94433) (let ((f94437 (string-ref ((primitive-ref port-buf) f94433) ((primitive-ref port-ndx) f94433)))) (begin ((primitive-ref port-ndx-add1) f94433) f94437)))))
# emit-expr (if (null? f94427) ((primitive-ref current-input-port)) (car f94427))
# emit-expr (null? f94427)
# emit-expr f94427
# emit-variable-ref
# env=((f94427 . -8))
# var=f94427
    movl -8(%esp), %eax  # stack load f94427
# end emit-variable-ref
    cmp $63, %eax
    mov $0, %eax
    sete %al
    movzbl %al, %eax
    sal $6, %al
    or $47, %al
    cmp $47, %al
    je _L_572036
# emit-expr ((primitive-ref current-input-port))
# funcall
#    si   =-12
#    env  = ((f94427 . -8))
#    expr = (funcall (primitive-ref current-input-port))
# emit-expr (primitive-ref current-input-port)
    .extern mrc_current$minput$mport
    movl mrc_current$minput$mport,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_572038"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_572038":
   movl %eax,  -20(%esp)  # stash funcall-oper in closure slot
    movl -20(%esp), %edi   # load new closure to %edi
    add $-12, %esp   # adjust base
    movl $0,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $12, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    jmp _L_572037
_L_572036:
# emit-expr (car f94427)
# emit-expr f94427
# emit-variable-ref
# env=((f94427 . -8))
# var=f94427
    movl -8(%esp), %eax  # stack load f94427
# end emit-variable-ref
# check the argument is a pair
    movl %eax,%ebx
    and $7, %bl
    cmp $1, %bl
    je _L_572039
# invoke error handler eh_pair
    .extern mrc_eh$upair
    movl mrc_eh$upair, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $116,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_572039:
    movl -1(%eax), %eax
_L_572037:
    movl %eax, -12(%esp)  # stack save
# emit-tail-expr
# si=-16
# env=((f94433 . -12) (f94427 . -8))
# expr=(if ((primitive-ref port-unread) f94433) (let ((f94436 ((primitive-ref port-unread) f94433))) (begin (if (not (eof-object? ((primitive-ref port-unread) f94433))) (begin ((primitive-ref port-unread-clear) f94433)) #f) f94436)) (begin (if (fx= ((primitive-ref port-last) f94433) ((primitive-ref port-ndx) f94433)) (begin ((primitive-ref fill-input-buffer) f94433)) #f) (if ((primitive-ref port-unread) f94433) ((primitive-ref port-unread) f94433) (let ((f94437 (string-ref ((primitive-ref port-buf) f94433) ((primitive-ref port-ndx) f94433)))) (begin ((primitive-ref port-ndx-add1) f94433) f94437)))))
# emit-expr ((primitive-ref port-unread) f94433)
# funcall
#    si   =-16
#    env  = ((f94433 . -12) (f94427 . -8))
#    expr = (funcall (primitive-ref port-unread) f94433)
# emit-expr (primitive-ref port-unread)
    .extern mrc_port$munread
    movl mrc_port$munread,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_572042"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_572042":
   movl %eax,  -24(%esp)  # stash funcall-oper in closure slot
# emit-expr f94433
# emit-variable-ref
# env=((f94433 . -12) (f94427 . -8))
# var=f94433
    movl -12(%esp), %eax  # stack load f94433
# end emit-variable-ref
    mov %eax, -28(%esp)  # arg f94433
    movl -24(%esp), %edi   # load new closure to %edi
    add $-16, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $16, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    cmp $47, %al
    je _L_572040
# emit-tail-expr
# si=-16
# env=((f94433 . -12) (f94427 . -8))
# expr=(let ((f94436 ((primitive-ref port-unread) f94433))) (begin (if (not (eof-object? ((primitive-ref port-unread) f94433))) (begin ((primitive-ref port-unread-clear) f94433)) #f) f94436))
# emit-tail-let
#  si   = -16
#  env  = ((f94433 . -12) (f94427 . -8))
#  bindings = ((f94436 ((primitive-ref port-unread) f94433)))
#  body = (begin (if (not (eof-object? ((primitive-ref port-unread) f94433))) (begin ((primitive-ref port-unread-clear) f94433)) #f) f94436)
# emit-expr ((primitive-ref port-unread) f94433)
# funcall
#    si   =-16
#    env  = ((f94433 . -12) (f94427 . -8))
#    expr = (funcall (primitive-ref port-unread) f94433)
# emit-expr (primitive-ref port-unread)
    .extern mrc_port$munread
    movl mrc_port$munread,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_572043"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_572043":
   movl %eax,  -24(%esp)  # stash funcall-oper in closure slot
# emit-expr f94433
# emit-variable-ref
# env=((f94433 . -12) (f94427 . -8))
# var=f94433
    movl -12(%esp), %eax  # stack load f94433
# end emit-variable-ref
    mov %eax, -28(%esp)  # arg f94433
    movl -24(%esp), %edi   # load new closure to %edi
    add $-16, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $16, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    movl %eax, -16(%esp)  # stack save
# emit-tail-expr
# si=-20
# env=((f94436 . -16) (f94433 . -12) (f94427 . -8))
# expr=(begin (if (not (eof-object? ((primitive-ref port-unread) f94433))) (begin ((primitive-ref port-unread-clear) f94433)) #f) f94436)
# tail-begin (begin (if (not (eof-object? ((primitive-ref port-unread) f94433))) (begin ((primitive-ref port-unread-clear) f94433)) #f) f94436)
#   env=((f94436 . -16) (f94433 . -12) (f94427 . -8))
# emit-expr (if (not (eof-object? ((primitive-ref port-unread) f94433))) (begin ((primitive-ref port-unread-clear) f94433)) #f)
# emit-expr (not (eof-object? ((primitive-ref port-unread) f94433)))
# emit-expr (eof-object? ((primitive-ref port-unread) f94433))
# emit-expr ((primitive-ref port-unread) f94433)
# funcall
#    si   =-20
#    env  = ((f94436 . -16) (f94433 . -12) (f94427 . -8))
#    expr = (funcall (primitive-ref port-unread) f94433)
# emit-expr (primitive-ref port-unread)
    .extern mrc_port$munread
    movl mrc_port$munread,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_572046"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_572046":
   movl %eax,  -28(%esp)  # stash funcall-oper in closure slot
# emit-expr f94433
# emit-variable-ref
# env=((f94436 . -16) (f94433 . -12) (f94427 . -8))
# var=f94433
    movl -12(%esp), %eax  # stack load f94433
# end emit-variable-ref
    mov %eax, -32(%esp)  # arg f94433
    movl -28(%esp), %edi   # load new closure to %edi
    add $-20, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $20, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    cmp $95, %eax
    mov $0, %eax
    sete %al
    movzbl %al, %eax
    sal $6, %al
    or $47, %al
    cmp $47, %eax
    sete %al
    movzbl %al, %eax
    sal $6, %al
    or $47, %al
    cmp $47, %al
    je _L_572044
# emit-expr (begin ((primitive-ref port-unread-clear) f94433))
# emit-begin
#   expr=(begin ((primitive-ref port-unread-clear) f94433))
#   env=((f94436 . -16) (f94433 . -12) (f94427 . -8))
# emit-expr ((primitive-ref port-unread-clear) f94433)
# funcall
#    si   =-20
#    env  = ((f94436 . -16) (f94433 . -12) (f94427 . -8))
#    expr = (funcall (primitive-ref port-unread-clear) f94433)
# emit-expr (primitive-ref port-unread-clear)
    .extern mrc_port$munread$mclear
    movl mrc_port$munread$mclear,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_572047"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_572047":
   movl %eax,  -28(%esp)  # stash funcall-oper in closure slot
# emit-expr f94433
# emit-variable-ref
# env=((f94436 . -16) (f94433 . -12) (f94427 . -8))
# var=f94433
    movl -12(%esp), %eax  # stack load f94433
# end emit-variable-ref
    mov %eax, -32(%esp)  # arg f94433
    movl -28(%esp), %edi   # load new closure to %edi
    add $-20, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $20, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
# emit-expr (begin)
# emit-begin
#   expr=(begin)
#   env=((f94436 . -16) (f94433 . -12) (f94427 . -8))
    jmp _L_572045
_L_572044:
# emit-expr #f
    movl $47, %eax     # immed #f
_L_572045:
# emit-tail-expr
# si=-20
# env=((f94436 . -16) (f94433 . -12) (f94427 . -8))
# expr=(begin f94436)
# tail-begin (begin f94436)
#   env=((f94436 . -16) (f94433 . -12) (f94427 . -8))
# emit-tail-expr
# si=-20
# env=((f94436 . -16) (f94433 . -12) (f94427 . -8))
# expr=f94436
# emit-tail-variable-ref
# emit-variable-ref
# env=((f94436 . -16) (f94433 . -12) (f94427 . -8))
# var=f94436
    movl -16(%esp), %eax  # stack load f94436
# end emit-variable-ref
    ret
# end emit-tail-variable ref
     ret   # return thru stack
    jmp _L_572041
_L_572040:
# emit-tail-expr
# si=-16
# env=((f94433 . -12) (f94427 . -8))
# expr=(begin (if (fx= ((primitive-ref port-last) f94433) ((primitive-ref port-ndx) f94433)) (begin ((primitive-ref fill-input-buffer) f94433)) #f) (if ((primitive-ref port-unread) f94433) ((primitive-ref port-unread) f94433) (let ((f94437 (string-ref ((primitive-ref port-buf) f94433) ((primitive-ref port-ndx) f94433)))) (begin ((primitive-ref port-ndx-add1) f94433) f94437))))
# tail-begin (begin (if (fx= ((primitive-ref port-last) f94433) ((primitive-ref port-ndx) f94433)) (begin ((primitive-ref fill-input-buffer) f94433)) #f) (if ((primitive-ref port-unread) f94433) ((primitive-ref port-unread) f94433) (let ((f94437 (string-ref ((primitive-ref port-buf) f94433) ((primitive-ref port-ndx) f94433)))) (begin ((primitive-ref port-ndx-add1) f94433) f94437))))
#   env=((f94433 . -12) (f94427 . -8))
# emit-expr (if (fx= ((primitive-ref port-last) f94433) ((primitive-ref port-ndx) f94433)) (begin ((primitive-ref fill-input-buffer) f94433)) #f)
# emit-expr (fx= ((primitive-ref port-last) f94433) ((primitive-ref port-ndx) f94433))
# emit-expr ((primitive-ref port-ndx) f94433)
# funcall
#    si   =-16
#    env  = ((f94433 . -12) (f94427 . -8))
#    expr = (funcall (primitive-ref port-ndx) f94433)
# emit-expr (primitive-ref port-ndx)
    .extern mrc_port$mndx
    movl mrc_port$mndx,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_572050"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_572050":
   movl %eax,  -24(%esp)  # stash funcall-oper in closure slot
# emit-expr f94433
# emit-variable-ref
# env=((f94433 . -12) (f94427 . -8))
# var=f94433
    movl -12(%esp), %eax  # stack load f94433
# end emit-variable-ref
    mov %eax, -28(%esp)  # arg f94433
    movl -24(%esp), %edi   # load new closure to %edi
    add $-16, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $16, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_572051"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $68,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_572051:
    movl %eax, -16(%esp)
# emit-expr ((primitive-ref port-last) f94433)
# funcall
#    si   =-20
#    env  = ((f94433 . -12) (f94427 . -8))
#    expr = (funcall (primitive-ref port-last) f94433)
# emit-expr (primitive-ref port-last)
    .extern mrc_port$mlast
    movl mrc_port$mlast,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_572052"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_572052":
   movl %eax,  -28(%esp)  # stash funcall-oper in closure slot
# emit-expr f94433
# emit-variable-ref
# env=((f94433 . -12) (f94427 . -8))
# var=f94433
    movl -12(%esp), %eax  # stack load f94433
# end emit-variable-ref
    mov %eax, -32(%esp)  # arg f94433
    movl -28(%esp), %edi   # load new closure to %edi
    add $-20, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $20, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_572053"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $68,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_572053:
    cmp -16(%esp), %eax
    sete %al
    movzbl %al, %eax
    sal $6, %al
    or $47, %al
    cmp $47, %al
    je _L_572048
# emit-expr (begin ((primitive-ref fill-input-buffer) f94433))
# emit-begin
#   expr=(begin ((primitive-ref fill-input-buffer) f94433))
#   env=((f94433 . -12) (f94427 . -8))
# emit-expr ((primitive-ref fill-input-buffer) f94433)
# funcall
#    si   =-16
#    env  = ((f94433 . -12) (f94427 . -8))
#    expr = (funcall (primitive-ref fill-input-buffer) f94433)
# emit-expr (primitive-ref fill-input-buffer)
    .extern mrc_fill$minput$mbuffer
    movl mrc_fill$minput$mbuffer,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_572054"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_572054":
   movl %eax,  -24(%esp)  # stash funcall-oper in closure slot
# emit-expr f94433
# emit-variable-ref
# env=((f94433 . -12) (f94427 . -8))
# var=f94433
    movl -12(%esp), %eax  # stack load f94433
# end emit-variable-ref
    mov %eax, -28(%esp)  # arg f94433
    movl -24(%esp), %edi   # load new closure to %edi
    add $-16, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $16, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
# emit-expr (begin)
# emit-begin
#   expr=(begin)
#   env=((f94433 . -12) (f94427 . -8))
    jmp _L_572049
_L_572048:
# emit-expr #f
    movl $47, %eax     # immed #f
_L_572049:
# emit-tail-expr
# si=-16
# env=((f94433 . -12) (f94427 . -8))
# expr=(begin (if ((primitive-ref port-unread) f94433) ((primitive-ref port-unread) f94433) (let ((f94437 (string-ref ((primitive-ref port-buf) f94433) ((primitive-ref port-ndx) f94433)))) (begin ((primitive-ref port-ndx-add1) f94433) f94437))))
# tail-begin (begin (if ((primitive-ref port-unread) f94433) ((primitive-ref port-unread) f94433) (let ((f94437 (string-ref ((primitive-ref port-buf) f94433) ((primitive-ref port-ndx) f94433)))) (begin ((primitive-ref port-ndx-add1) f94433) f94437))))
#   env=((f94433 . -12) (f94427 . -8))
# emit-tail-expr
# si=-16
# env=((f94433 . -12) (f94427 . -8))
# expr=(if ((primitive-ref port-unread) f94433) ((primitive-ref port-unread) f94433) (let ((f94437 (string-ref ((primitive-ref port-buf) f94433) ((primitive-ref port-ndx) f94433)))) (begin ((primitive-ref port-ndx-add1) f94433) f94437)))
# emit-expr ((primitive-ref port-unread) f94433)
# funcall
#    si   =-16
#    env  = ((f94433 . -12) (f94427 . -8))
#    expr = (funcall (primitive-ref port-unread) f94433)
# emit-expr (primitive-ref port-unread)
    .extern mrc_port$munread
    movl mrc_port$munread,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_572057"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_572057":
   movl %eax,  -24(%esp)  # stash funcall-oper in closure slot
# emit-expr f94433
# emit-variable-ref
# env=((f94433 . -12) (f94427 . -8))
# var=f94433
    movl -12(%esp), %eax  # stack load f94433
# end emit-variable-ref
    mov %eax, -28(%esp)  # arg f94433
    movl -24(%esp), %edi   # load new closure to %edi
    add $-16, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $16, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    cmp $47, %al
    je _L_572055
# emit-tail-expr
# si=-16
# env=((f94433 . -12) (f94427 . -8))
# expr=((primitive-ref port-unread) f94433)
# emit-tail-funcall
#    si   =-16
#    env  = ((f94433 . -12) (f94427 . -8))
#    expr = (funcall (primitive-ref port-unread) f94433)
# emit-expr (primitive-ref port-unread)
    .extern mrc_port$munread
    movl mrc_port$munread,%eax
   movl %eax,  -16(%esp)  # stash funcall-oper in next closure slot
# emit-expr f94433
# emit-variable-ref
# env=((f94433 . -12) (f94427 . -8))
# var=f94433
    movl -12(%esp), %eax  # stack load f94433
# end emit-variable-ref
    mov %eax, -20(%esp)    # arg f94433
    movl -16(%esp), %edi   # load new closure to %edi
# emit-shift-args:  size=2   si=-16  delta=12
    mov -16(%esp), %ebx  # shift frame cell
    mov %ebx, -4(%esp)  # down to base
# emit-shift-args:  size=1   si=-20  delta=12
    mov -20(%esp), %ebx  # shift frame cell
    mov %ebx, -8(%esp)  # down to base
# emit-shift-args:  size=0   si=-24  delta=12
    movl $4,%eax   # save arg count
    jmp *-2(%edi)  # tail-funcall
    jmp _L_572056
_L_572055:
# emit-tail-expr
# si=-16
# env=((f94433 . -12) (f94427 . -8))
# expr=(let ((f94437 (string-ref ((primitive-ref port-buf) f94433) ((primitive-ref port-ndx) f94433)))) (begin ((primitive-ref port-ndx-add1) f94433) f94437))
# emit-tail-let
#  si   = -16
#  env  = ((f94433 . -12) (f94427 . -8))
#  bindings = ((f94437 (string-ref ((primitive-ref port-buf) f94433) ((primitive-ref port-ndx) f94433))))
#  body = (begin ((primitive-ref port-ndx-add1) f94433) f94437)
# emit-expr (string-ref ((primitive-ref port-buf) f94433) ((primitive-ref port-ndx) f94433))
# emit-expr ((primitive-ref port-buf) f94433)
# funcall
#    si   =-16
#    env  = ((f94433 . -12) (f94427 . -8))
#    expr = (funcall (primitive-ref port-buf) f94433)
# emit-expr (primitive-ref port-buf)
    .extern mrc_port$mbuf
    movl mrc_port$mbuf,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_572058"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_572058":
   movl %eax,  -24(%esp)  # stash funcall-oper in closure slot
# emit-expr f94433
# emit-variable-ref
# env=((f94433 . -12) (f94427 . -8))
# var=f94433
    movl -12(%esp), %eax  # stack load f94433
# end emit-variable-ref
    mov %eax, -28(%esp)  # arg f94433
    movl -24(%esp), %edi   # load new closure to %edi
    add $-16, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $16, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
# check the argument is a string
    movl %eax,%ebx
    and $7, %bl
    cmp $6, %bl
    je _L_572059
# invoke error handler eh_string
    .extern mrc_eh$ustring
    movl mrc_eh$ustring, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $164,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_572059:
    movl %eax, -16(%esp)
# emit-expr ((primitive-ref port-ndx) f94433)
# funcall
#    si   =-16
#    env  = ((f94433 . -12) (f94427 . -8))
#    expr = (funcall (primitive-ref port-ndx) f94433)
# emit-expr (primitive-ref port-ndx)
    .extern mrc_port$mndx
    movl mrc_port$mndx,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_572060"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_572060":
   movl %eax,  -24(%esp)  # stash funcall-oper in closure slot
# emit-expr f94433
# emit-variable-ref
# env=((f94433 . -12) (f94427 . -8))
# var=f94433
    movl -12(%esp), %eax  # stack load f94433
# end emit-variable-ref
    mov %eax, -28(%esp)  # arg f94433
    movl -24(%esp), %edi   # load new closure to %edi
    add $-16, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $16, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_572061"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $164,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_572061:
# check bounds on string index
    movl -16(%esp), %ebx
    cmp  %eax,-6(%ebx) 
    jle _L_572063
    cmp  $0,%eax
    jge _L_572062
_L_572063:
# invoke error handler eh_string_index
    .extern mrc_eh$ustring$uindex
    movl mrc_eh$ustring$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $164,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_572062:
    sar $2, %eax
    movl -16(%esp), %esi
    movl -2(%eax,%esi), %eax
    sal $8, %eax
    or  $15, %eax
    movl %eax, -16(%esp)  # stack save
# emit-tail-expr
# si=-20
# env=((f94437 . -16) (f94433 . -12) (f94427 . -8))
# expr=(begin ((primitive-ref port-ndx-add1) f94433) f94437)
# tail-begin (begin ((primitive-ref port-ndx-add1) f94433) f94437)
#   env=((f94437 . -16) (f94433 . -12) (f94427 . -8))
# emit-expr ((primitive-ref port-ndx-add1) f94433)
# funcall
#    si   =-20
#    env  = ((f94437 . -16) (f94433 . -12) (f94427 . -8))
#    expr = (funcall (primitive-ref port-ndx-add1) f94433)
# emit-expr (primitive-ref port-ndx-add1)
    .extern mrc_port$mndx$madd1
    movl mrc_port$mndx$madd1,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_572064"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_572064":
   movl %eax,  -28(%esp)  # stash funcall-oper in closure slot
# emit-expr f94433
# emit-variable-ref
# env=((f94437 . -16) (f94433 . -12) (f94427 . -8))
# var=f94433
    movl -12(%esp), %eax  # stack load f94433
# end emit-variable-ref
    mov %eax, -32(%esp)  # arg f94433
    movl -28(%esp), %edi   # load new closure to %edi
    add $-20, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $20, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
# emit-tail-expr
# si=-20
# env=((f94437 . -16) (f94433 . -12) (f94427 . -8))
# expr=(begin f94437)
# tail-begin (begin f94437)
#   env=((f94437 . -16) (f94433 . -12) (f94427 . -8))
# emit-tail-expr
# si=-20
# env=((f94437 . -16) (f94433 . -12) (f94427 . -8))
# expr=f94437
# emit-tail-variable-ref
# emit-variable-ref
# env=((f94437 . -16) (f94433 . -12) (f94427 . -8))
# var=f94437
    movl -16(%esp), %eax  # stack load f94437
# end emit-variable-ref
    ret
# end emit-tail-variable ref
     ret   # return thru stack
_L_572056:
     ret   # return thru stack
_L_572041:
    .align 4,0x90
_L_572032:
     movl %eax, mrc_read$mchar
# == explicit-begins  ==>
# (lambda (p) (let ((nbytes (foreign-call "s_read" (port-fd p) (port-buf p) (port-size p)))) (begin (port-ndx-reset p) (port-last-set! p nbytes) (when (fxzero? nbytes) (port-unread-set! p (eof-object))))))
# == eliminate-let*  ==>
# (lambda (p) (let ((nbytes (foreign-call "s_read" (port-fd p) (port-buf p) (port-size p)))) (begin (port-ndx-reset p) (port-last-set! p nbytes) (when (fxzero? nbytes) (port-unread-set! p (eof-object))))))
# == uniquify-variables  ==>
# (lambda (f94438) (let ((f94440 (foreign-call "s_read" (port-fd f94438) (port-buf f94438) (port-size f94438)))) (begin (port-ndx-reset f94438) (port-last-set! f94438 f94440) (when (fxzero? f94440) (port-unread-set! f94438 (eof-object))))))
# == vectorize-letrec  ==>
# (lambda (f94438) (let ((f94440 (foreign-call "s_read" (port-fd f94438) (port-buf f94438) (port-size f94438)))) (begin (port-ndx-reset f94438) (port-last-set! f94438 f94440) (when (fxzero? f94440) (port-unread-set! f94438 (eof-object))))))
# == eliminate-set!  ==>
# (lambda (f94438) (let ((f94438 f94438)) (let ((f94440 (foreign-call "s_read" (port-fd f94438) (port-buf f94438) (port-size f94438)))) (begin (port-ndx-reset f94438) (port-last-set! f94438 f94440) (when (fxzero? f94440) (port-unread-set! f94438 (eof-object)))))))
# == close-free-variables  ==>
# (closure (f94438) () (let ((f94438 f94438)) (let ((f94440 (foreign-call "s_read" (port-fd f94438) (port-buf f94438) (port-size f94438)))) (begin (port-ndx-reset f94438) (port-last-set! f94438 f94440) (when (fxzero? f94440) (port-unread-set! f94438 (eof-object)))))))
# == eliminate-quote  ==>
# (closure (f94438) () (let ((f94438 f94438)) (let ((f94440 (foreign-call "s_read" (port-fd f94438) (port-buf f94438) (port-size f94438)))) (begin (port-ndx-reset f94438) (port-last-set! f94438 f94440) (when (fxzero? f94440) (port-unread-set! f94438 (eof-object)))))))
# == eliminate-when/unless  ==>
# (closure (f94438) () (let ((f94438 f94438)) (let ((f94440 (foreign-call "s_read" (port-fd f94438) (port-buf f94438) (port-size f94438)))) (begin (port-ndx-reset f94438) (port-last-set! f94438 f94440) (if (fxzero? f94440) (begin (port-unread-set! f94438 (eof-object))) #f)))))
# == eliminate-cond  ==>
# (closure (f94438) () (let ((f94438 f94438)) (let ((f94440 (foreign-call "s_read" (port-fd f94438) (port-buf f94438) (port-size f94438)))) (begin (port-ndx-reset f94438) (port-last-set! f94438 f94440) (if (fxzero? f94440) (begin (port-unread-set! f94438 (eof-object))) #f)))))
# == external-symbols  ==>
# (closure (f94438) () (let ((f94438 f94438)) (let ((f94440 (foreign-call "s_read" ((primitive-ref port-fd) f94438) ((primitive-ref port-buf) f94438) ((primitive-ref port-size) f94438)))) (begin ((primitive-ref port-ndx-reset) f94438) ((primitive-ref port-last-set!) f94438 f94440) (if (fxzero? f94440) (begin ((primitive-ref port-unread-set!) f94438 (eof-object))) #f)))))
# emit-expr (closure (f94438) () (let ((f94438 f94438)) (let ((f94440 (foreign-call "s_read" ((primitive-ref port-fd) f94438) ((primitive-ref port-buf) f94438) ((primitive-ref port-size) f94438)))) (begin ((primitive-ref port-ndx-reset) f94438) ((primitive-ref port-last-set!) f94438 f94440) (if (fxzero? f94440) (begin ((primitive-ref port-unread-set!) f94438 (eof-object))) #f)))))
# emit-closure
# si = 0
# env = ()
# expr = (closure (f94438) () (let ((f94438 f94438)) (let ((f94440 (foreign-call "s_read" ((primitive-ref port-fd) f94438) ((primitive-ref port-buf) f94438) ((primitive-ref port-size) f94438)))) (begin ((primitive-ref port-ndx-reset) f94438) ((primitive-ref port-last-set!) f94438 f94440) (if (fxzero? f94440) (begin ((primitive-ref port-unread-set!) f94438 (eof-object))) #f)))))
    movl $_L_572065, 0(%ebp)  # closure label
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $8, %ebp     # bump ebp
    jmp _L_572066            # jump around closure body
_L_572065:
# check argument count
    cmp $4,%eax
    je _L_572067
# invoke error handler eh_argcount
    .extern mrc_eh$uargcount
    movl mrc_eh$uargcount, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_572067:
# emit-tail-expr
# si=-12
# env=((f94438 . -8))
# expr=(let ((f94438 f94438)) (let ((f94440 (foreign-call "s_read" ((primitive-ref port-fd) f94438) ((primitive-ref port-buf) f94438) ((primitive-ref port-size) f94438)))) (begin ((primitive-ref port-ndx-reset) f94438) ((primitive-ref port-last-set!) f94438 f94440) (if (fxzero? f94440) (begin ((primitive-ref port-unread-set!) f94438 (eof-object))) #f))))
# emit-tail-let
#  si   = -12
#  env  = ((f94438 . -8))
#  bindings = ((f94438 f94438))
#  body = (let ((f94440 (foreign-call "s_read" ((primitive-ref port-fd) f94438) ((primitive-ref port-buf) f94438) ((primitive-ref port-size) f94438)))) (begin ((primitive-ref port-ndx-reset) f94438) ((primitive-ref port-last-set!) f94438 f94440) (if (fxzero? f94440) (begin ((primitive-ref port-unread-set!) f94438 (eof-object))) #f)))
# emit-expr f94438
# emit-variable-ref
# env=((f94438 . -8))
# var=f94438
    movl -8(%esp), %eax  # stack load f94438
# end emit-variable-ref
    movl %eax, -12(%esp)  # stack save
# emit-tail-expr
# si=-16
# env=((f94438 . -12) (f94438 . -8))
# expr=(let ((f94440 (foreign-call "s_read" ((primitive-ref port-fd) f94438) ((primitive-ref port-buf) f94438) ((primitive-ref port-size) f94438)))) (begin ((primitive-ref port-ndx-reset) f94438) ((primitive-ref port-last-set!) f94438 f94440) (if (fxzero? f94440) (begin ((primitive-ref port-unread-set!) f94438 (eof-object))) #f)))
# emit-tail-let
#  si   = -16
#  env  = ((f94438 . -12) (f94438 . -8))
#  bindings = ((f94440 (foreign-call "s_read" ((primitive-ref port-fd) f94438) ((primitive-ref port-buf) f94438) ((primitive-ref port-size) f94438))))
#  body = (begin ((primitive-ref port-ndx-reset) f94438) ((primitive-ref port-last-set!) f94438 f94440) (if (fxzero? f94440) (begin ((primitive-ref port-unread-set!) f94438 (eof-object))) #f))
# emit-expr (foreign-call "s_read" ((primitive-ref port-fd) f94438) ((primitive-ref port-buf) f94438) ((primitive-ref port-size) f94438))
    movl %ecx,-16(%esp)
    movl %esp,-20(%esp)
# emit-expr ((primitive-ref port-size) f94438)
# funcall
#    si   =-24
#    env  = ((f94438 . -12) (f94438 . -8))
#    expr = (funcall (primitive-ref port-size) f94438)
# emit-expr (primitive-ref port-size)
    .extern mrc_port$msize
    movl mrc_port$msize,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_572068"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_572068":
   movl %eax,  -32(%esp)  # stash funcall-oper in closure slot
# emit-expr f94438
# emit-variable-ref
# env=((f94438 . -12) (f94438 . -8))
# var=f94438
    movl -12(%esp), %eax  # stack load f94438
# end emit-variable-ref
    mov %eax, -36(%esp)  # arg f94438
    movl -32(%esp), %edi   # load new closure to %edi
    add $-24, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $24, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    movl %eax, -24(%esp)
# emit-expr ((primitive-ref port-buf) f94438)
# funcall
#    si   =-28
#    env  = ((f94438 . -12) (f94438 . -8))
#    expr = (funcall (primitive-ref port-buf) f94438)
# emit-expr (primitive-ref port-buf)
    .extern mrc_port$mbuf
    movl mrc_port$mbuf,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_572069"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_572069":
   movl %eax,  -36(%esp)  # stash funcall-oper in closure slot
# emit-expr f94438
# emit-variable-ref
# env=((f94438 . -12) (f94438 . -8))
# var=f94438
    movl -12(%esp), %eax  # stack load f94438
# end emit-variable-ref
    mov %eax, -40(%esp)  # arg f94438
    movl -36(%esp), %edi   # load new closure to %edi
    add $-28, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $28, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    movl %eax, -28(%esp)
# emit-expr ((primitive-ref port-fd) f94438)
# funcall
#    si   =-32
#    env  = ((f94438 . -12) (f94438 . -8))
#    expr = (funcall (primitive-ref port-fd) f94438)
# emit-expr (primitive-ref port-fd)
    .extern mrc_port$mfd
    movl mrc_port$mfd,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_572070"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_572070":
   movl %eax,  -40(%esp)  # stash funcall-oper in closure slot
# emit-expr f94438
# emit-variable-ref
# env=((f94438 . -12) (f94438 . -8))
# var=f94438
    movl -12(%esp), %eax  # stack load f94438
# end emit-variable-ref
    mov %eax, -44(%esp)  # arg f94438
    movl -40(%esp), %edi   # load new closure to %edi
    add $-32, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $32, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    movl %eax, -32(%esp)
    leal -32(%esp),%edi
    movl %edi,%esi
    andl $-16,%esi
    movl 0(%edi),%eax
    movl %eax,0(%esi)
    movl 4(%edi),%eax
    movl %eax,4(%esi)
    movl 8(%edi),%eax
    movl %eax,8(%esi)
    movl 12(%edi),%eax
    movl %eax,12(%esi)
    movl %esi,%esp
    .extern _s_read
    call _s_read
    movl 12(%esi),%esp
    movl -16(%esp),%ecx
    movl %eax, -16(%esp)  # stack save
# emit-tail-expr
# si=-20
# env=((f94440 . -16) (f94438 . -12) (f94438 . -8))
# expr=(begin ((primitive-ref port-ndx-reset) f94438) ((primitive-ref port-last-set!) f94438 f94440) (if (fxzero? f94440) (begin ((primitive-ref port-unread-set!) f94438 (eof-object))) #f))
# tail-begin (begin ((primitive-ref port-ndx-reset) f94438) ((primitive-ref port-last-set!) f94438 f94440) (if (fxzero? f94440) (begin ((primitive-ref port-unread-set!) f94438 (eof-object))) #f))
#   env=((f94440 . -16) (f94438 . -12) (f94438 . -8))
# emit-expr ((primitive-ref port-ndx-reset) f94438)
# funcall
#    si   =-20
#    env  = ((f94440 . -16) (f94438 . -12) (f94438 . -8))
#    expr = (funcall (primitive-ref port-ndx-reset) f94438)
# emit-expr (primitive-ref port-ndx-reset)
    .extern mrc_port$mndx$mreset
    movl mrc_port$mndx$mreset,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_572071"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_572071":
   movl %eax,  -28(%esp)  # stash funcall-oper in closure slot
# emit-expr f94438
# emit-variable-ref
# env=((f94440 . -16) (f94438 . -12) (f94438 . -8))
# var=f94438
    movl -12(%esp), %eax  # stack load f94438
# end emit-variable-ref
    mov %eax, -32(%esp)  # arg f94438
    movl -28(%esp), %edi   # load new closure to %edi
    add $-20, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $20, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
# emit-tail-expr
# si=-20
# env=((f94440 . -16) (f94438 . -12) (f94438 . -8))
# expr=(begin ((primitive-ref port-last-set!) f94438 f94440) (if (fxzero? f94440) (begin ((primitive-ref port-unread-set!) f94438 (eof-object))) #f))
# tail-begin (begin ((primitive-ref port-last-set!) f94438 f94440) (if (fxzero? f94440) (begin ((primitive-ref port-unread-set!) f94438 (eof-object))) #f))
#   env=((f94440 . -16) (f94438 . -12) (f94438 . -8))
# emit-expr ((primitive-ref port-last-set!) f94438 f94440)
# funcall
#    si   =-20
#    env  = ((f94440 . -16) (f94438 . -12) (f94438 . -8))
#    expr = (funcall (primitive-ref port-last-set!) f94438 f94440)
# emit-expr (primitive-ref port-last-set!)
    .extern mrc_port$mlast$mset$b
    movl mrc_port$mlast$mset$b,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_572072"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_572072":
   movl %eax,  -28(%esp)  # stash funcall-oper in closure slot
# emit-expr f94438
# emit-variable-ref
# env=((f94440 . -16) (f94438 . -12) (f94438 . -8))
# var=f94438
    movl -12(%esp), %eax  # stack load f94438
# end emit-variable-ref
    mov %eax, -32(%esp)  # arg f94438
# emit-expr f94440
# emit-variable-ref
# env=((f94440 . -16) (f94438 . -12) (f94438 . -8))
# var=f94440
    movl -16(%esp), %eax  # stack load f94440
# end emit-variable-ref
    mov %eax, -36(%esp)  # arg f94440
    movl -28(%esp), %edi   # load new closure to %edi
    add $-20, %esp   # adjust base
    movl $8,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $20, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
# emit-tail-expr
# si=-20
# env=((f94440 . -16) (f94438 . -12) (f94438 . -8))
# expr=(begin (if (fxzero? f94440) (begin ((primitive-ref port-unread-set!) f94438 (eof-object))) #f))
# tail-begin (begin (if (fxzero? f94440) (begin ((primitive-ref port-unread-set!) f94438 (eof-object))) #f))
#   env=((f94440 . -16) (f94438 . -12) (f94438 . -8))
# emit-tail-expr
# si=-20
# env=((f94440 . -16) (f94438 . -12) (f94438 . -8))
# expr=(if (fxzero? f94440) (begin ((primitive-ref port-unread-set!) f94438 (eof-object))) #f)
# emit-expr (fxzero? f94440)
# emit-expr f94440
# emit-variable-ref
# env=((f94440 . -16) (f94438 . -12) (f94438 . -8))
# var=f94440
    movl -16(%esp), %eax  # stack load f94440
# end emit-variable-ref
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_572075"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $64,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_572075:
    cmp $0, %eax
    sete %al
    movzbl %al, %eax
    sal $6, %al
    or $47, %al
    cmp $47, %al
    je _L_572073
# emit-tail-expr
# si=-20
# env=((f94440 . -16) (f94438 . -12) (f94438 . -8))
# expr=(begin ((primitive-ref port-unread-set!) f94438 (eof-object)))
# tail-begin (begin ((primitive-ref port-unread-set!) f94438 (eof-object)))
#   env=((f94440 . -16) (f94438 . -12) (f94438 . -8))
# emit-tail-expr
# si=-20
# env=((f94440 . -16) (f94438 . -12) (f94438 . -8))
# expr=((primitive-ref port-unread-set!) f94438 (eof-object))
# emit-tail-funcall
#    si   =-20
#    env  = ((f94440 . -16) (f94438 . -12) (f94438 . -8))
#    expr = (funcall (primitive-ref port-unread-set!) f94438 (eof-object))
# emit-expr (primitive-ref port-unread-set!)
    .extern mrc_port$munread$mset$b
    movl mrc_port$munread$mset$b,%eax
   movl %eax,  -20(%esp)  # stash funcall-oper in next closure slot
# emit-expr f94438
# emit-variable-ref
# env=((f94440 . -16) (f94438 . -12) (f94438 . -8))
# var=f94438
    movl -12(%esp), %eax  # stack load f94438
# end emit-variable-ref
    mov %eax, -24(%esp)    # arg f94438
# emit-expr (eof-object)
    movl $95,%eax
    mov %eax, -28(%esp)    # arg (eof-object)
    movl -20(%esp), %edi   # load new closure to %edi
# emit-shift-args:  size=3   si=-20  delta=16
    mov -20(%esp), %ebx  # shift frame cell
    mov %ebx, -4(%esp)  # down to base
# emit-shift-args:  size=2   si=-24  delta=16
    mov -24(%esp), %ebx  # shift frame cell
    mov %ebx, -8(%esp)  # down to base
# emit-shift-args:  size=1   si=-28  delta=16
    mov -28(%esp), %ebx  # shift frame cell
    mov %ebx, -12(%esp)  # down to base
# emit-shift-args:  size=0   si=-32  delta=16
    movl $8,%eax   # save arg count
    jmp *-2(%edi)  # tail-funcall
     ret   # return thru stack
    jmp _L_572074
_L_572073:
# emit-tail-expr
# si=-20
# env=((f94440 . -16) (f94438 . -12) (f94438 . -8))
# expr=#f
    movl $47, %eax     # immed #f
    ret                  # immediate tail return
_L_572074:
     ret   # return thru stack
    .align 4,0x90
_L_572066:
     movl %eax, mrc_fill$minput$mbuffer
# == explicit-begins  ==>
# (quote TBD)
# == eliminate-let*  ==>
# (quote TBD)
# == uniquify-variables  ==>
# (quote TBD)
# == vectorize-letrec  ==>
# (quote TBD)
# == eliminate-set!  ==>
# (quote TBD)
# == close-free-variables  ==>
# (quote TBD)
# == eliminate-quote  ==>
# (string->symbol "TBD")
# == eliminate-when/unless  ==>
# (string->symbol "TBD")
# == eliminate-cond  ==>
# (string->symbol "TBD")
# == external-symbols  ==>
# ((primitive-ref string->symbol) "TBD")
# emit-expr ((primitive-ref string->symbol) "TBD")
# funcall
#    si   =0
#    env  = ()
#    expr = (funcall (primitive-ref string->symbol) "TBD")
# emit-expr (primitive-ref string->symbol)
    .extern mrc_string$m$gsymbol
    movl mrc_string$m$gsymbol,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_572076"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_572076":
   movl %eax,  -8(%esp)  # stash funcall-oper in closure slot
# emit-expr "TBD"
# string literal
    jmp _L_572078
    .align 8,0x90
_L_572077 :
    .int 12
    .ascii "TBD"
_L_572078:
    movl $_L_572077, %eax
    orl $6, %eax
    mov %eax, -12(%esp)  # arg TBD
    movl -8(%esp), %edi   # load new closure to %edi
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    movl -4(%esp), %edi   # restore closure frame ptr
     movl %eax, mrc_unread$mchar
# emit-expr (begin #t)
# emit-begin
#   expr=(begin #t)
#   env=()
# emit-expr #t
    movl $111, %eax     # immed #t
# emit-expr (begin)
# emit-begin
#   expr=(begin)
#   env=()
    .extern base_init_callback
    jmp base_init_callback
