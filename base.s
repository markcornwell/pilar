     .data
     .global "mrc_symbols"
     .align 8
mrc_symbols:
     .int 0xFF
     .global "mrc_string$e$q"
     .align 8
mrc_string$e$q:
     .int 0xFF
     .global "mrc_string$m$gsymbol"
     .align 8
mrc_string$m$gsymbol:
     .int 0xFF
     .global "mrc_append1"
     .align 8
mrc_append1:
     .int 0xFF
     .global "mrc_list$mref"
     .align 8
mrc_list$mref:
     .int 0xFF
     .global "mrc_list$mlength"
     .align 8
mrc_list$mlength:
     .int 0xFF
     .global "mrc_reverse"
     .align 8
mrc_reverse:
     .int 0xFF
     .global "mrc_vector"
     .align 8
mrc_vector:
     .int 0xFF
     .global "mrc_string"
     .align 8
mrc_string:
     .int 0xFF
     .global "mrc_string$m$glist"
     .align 8
mrc_string$m$glist:
     .int 0xFF
     .global "mrc_integer$m$glist"
     .align 8
mrc_integer$m$glist:
     .int 0xFF
     .global "mrc_error"
     .align 8
mrc_error:
     .int 0xFF
     .global "mrc_primitives"
     .align 8
mrc_primitives:
     .int 0xFF
     .global "mrc_eh$uprocedure"
     .align 8
mrc_eh$uprocedure:
     .int 0xFF
     .global "mrc_eh$uargcount"
     .align 8
mrc_eh$uargcount:
     .int 0xFF
     .global "mrc_eh$uargcount$umin"
     .align 8
mrc_eh$uargcount$umin:
     .int 0xFF
     .global "mrc_eh$ufixnum"
     .align 8
mrc_eh$ufixnum:
     .int 0xFF
     .global "mrc_eh$ustring"
     .align 8
mrc_eh$ustring:
     .int 0xFF
     .global "mrc_eh$ucharacter"
     .align 8
mrc_eh$ucharacter:
     .int 0xFF
     .global "mrc_eh$upair"
     .align 8
mrc_eh$upair:
     .int 0xFF
     .global "mrc_eh$uvector"
     .align 8
mrc_eh$uvector:
     .int 0xFF
     .global "mrc_eh$ulength"
     .align 8
mrc_eh$ulength:
     .int 0xFF
     .global "mrc_eh$uvector$uindex"
     .align 8
mrc_eh$uvector$uindex:
     .int 0xFF
     .global "mrc_eh$ustring$uindex"
     .align 8
mrc_eh$ustring$uindex:
     .int 0xFF
     .global "mrc_zero$q"
     .align 8
mrc_zero$q:
     .int 0xFF
     .global "mrc_positive$q"
     .align 8
mrc_positive$q:
     .int 0xFF
     .global "mrc_negative$q"
     .align 8
mrc_negative$q:
     .int 0xFF
     .global "mrc_map"
     .align 8
mrc_map:
     .int 0xFF
     .global "mrc_for$meach"
     .align 8
mrc_for$meach:
     .int 0xFF
     .global "mrc_standard$mout"
     .align 8
mrc_standard$mout:
     .int 0xFF
     .global "mrc_current$moutput$mport"
     .align 8
mrc_current$moutput$mport:
     .int 0xFF
     .global "mrc_port$mfd"
     .align 8
mrc_port$mfd:
     .int 0xFF
     .global "mrc_port$mbuf"
     .align 8
mrc_port$mbuf:
     .int 0xFF
     .global "mrc_port$mndx"
     .align 8
mrc_port$mndx:
     .int 0xFF
     .global "mrc_port$mndx$madd1"
     .align 8
mrc_port$mndx$madd1:
     .int 0xFF
     .global "mrc_port$mndx$mreset"
     .align 8
mrc_port$mndx$mreset:
     .int 0xFF
     .global "mrc_port$msize"
     .align 8
mrc_port$msize:
     .int 0xFF
     .global "mrc_write$mchar"
     .align 8
mrc_write$mchar:
     .int 0xFF
     .global "mrc_flush$moutput$mport"
     .align 8
mrc_flush$moutput$mport:
     .int 0xFF
     .global "mrc_exit"
     .align 8
mrc_exit:
     .int 0xFF
     .global "mrc_output$mport$q"
     .align 8
mrc_output$mport$q:
     .int 0xFF
     .global "mrc_open$moutput$mfile"
     .align 8
mrc_open$moutput$mfile:
     .int 0xFF
     .global "mrc_close$moutput$mport"
     .align 8
mrc_close$moutput$mport:
     .int 0xFF
     .global "mrc_write"
     .align 8
mrc_write:
     .int 0xFF
     .global "mrc_integer$m$gchar"
     .align 8
mrc_integer$m$gchar:
     .int 0xFF
     .text
     .global base_init
     .align 4
base_init:
# == explicit-begins  ==>
# (let ((interned-symbols (cons (make-symbol "nil" ()) ()))) (lambda () interned-symbols))
# == eliminate-let*  ==>
# (let ((interned-symbols (cons (make-symbol "nil" ()) ()))) (lambda () interned-symbols))
# == uniquify-variables  ==>
# (let ((f195865 (cons (make-symbol "nil" ()) ()))) (lambda () f195865))
# == vectorize-letrec  ==>
# (let ((f195865 (cons (make-symbol "nil" ()) ()))) (lambda () f195865))
# == eliminate-set!  ==>
# (let ((f195865 (cons (make-symbol "nil" ()) ()))) (lambda () (let () f195865)))
# == close-free-variables  ==>
# (let ((f195865 (cons (make-symbol "nil" ()) ()))) (closure () (f195865) (let () f195865)))
# == eliminate-quote  ==>
# (let ((f195865 (cons (make-symbol "nil" ()) ()))) (closure () (f195865) (let () f195865)))
# == eliminate-when/unless  ==>
# (let ((f195865 (cons (make-symbol "nil" ()) ()))) (closure () (f195865) (let () f195865)))
# == eliminate-cond  ==>
# (let ((f195865 (cons (make-symbol "nil" ()) ()))) (closure () (f195865) (let () f195865)))
# == external-symbols  ==>
# (let ((f195865 (cons (make-symbol "nil" ()) ()))) (closure () (f195865) (let () f195865)))
# emit-expr (let ((f195865 (cons (make-symbol "nil" ()) ()))) (closure () (f195865) (let () f195865)))
# emit-let
#  si   = 0
#  env  = ()
#  bindings = ((f195865 (cons (make-symbol "nil" ()) ())))
#  body = (closure () (f195865) (let () f195865))
# emit-expr (cons (make-symbol "nil" ()) ())
# cons arg1=(make-symbol "nil" ()) arg2=()
# emit-expr (make-symbol "nil" ())
# make-symbol arg1="nil" arg2=()
# emit-expr "nil"
# string literal
    jmp _L_1423634
    .align 8,0x90
_L_1423633 :
    .int 12
    .ascii "nil"
_L_1423634:
    movl $_L_1423633, %eax
    orl $6, %eax
    movl %eax, 0(%esp)
# emit-expr ()
    movl $63, %eax     # immed ()
    movl %eax, 4(%ebp)
    movl 0(%esp), %eax
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    orl  $3, %eax
    add  $8, %ebp
# make-symbol end
    movl %eax, 0(%esp)
# emit-expr ()
    movl $63, %eax     # immed ()
    movl %eax, 4(%ebp)
    movl 0(%esp), %eax
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    or   $1, %al
    add  $8, %ebp
# cons end
    movl %eax, 0(%esp)  # stack save
# emit-expr (closure () (f195865) (let () f195865))
# emit-closure
# si = -4
# env = ((f195865 . 0))
# expr = (closure () (f195865) (let () f195865))
    movl $_L_1423635, 0(%ebp)  # closure label
# emit-variable-ref
# env=((f195865 . 0))
# var=f195865
    movl 0(%esp), %eax  # stack load f195865
# end emit-variable-ref
   movl  %eax, 4(%ebp)  # f195865
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $8, %ebp     # bump ebp
    jmp _L_1423636            # jump around closure body
_L_1423635:
# check argument count
    cmp $0,%eax
    je _L_1423637
# invoke error handler eh_argcount
    .extern mrc_eh$uargcount
    movl mrc_eh$uargcount, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_1423637:
# emit-tail-expr
# si=-8
# env=((f195865 . 4) (f195865 . 0))
# expr=(let () f195865)
# emit-tail-let
#  si   = -8
#  env  = ((f195865 . 4) (f195865 . 0))
#  bindings = ()
#  body = f195865
# emit-tail-expr
# si=-8
# env=((f195865 . 4) (f195865 . 0))
# expr=f195865
# emit-tail-variable-ref
# emit-variable-ref
# env=((f195865 . 4) (f195865 . 0))
# var=f195865
    movl 2(%edi), %eax  # frame load f195865
# end emit-variable-ref
    ret
# end emit-tail-variable ref
    .align 4,0x90
_L_1423636:
     movl %eax, mrc_symbols
# == explicit-begins  ==>
# (letrec ((slen= (lambda (s1 s2) (fx= (string-length s1) (string-length s2)))) (si= (lambda (s1 s2 i) (char=? (string-ref s1 i) (string-ref s2 i)))) (si<n= (lambda (s1 s2 i n) (if (fx= i n) #t (if (si= s1 s2 i) (si<n= s1 s2 (fx+ i 1) n) #f)))) (ss= (lambda (s1 s2) (if (slen= s1 s2) (si<n= s1 s2 0 (string-length s1)) #f)))) ss=)
# == eliminate-let*  ==>
# (letrec ((slen= (lambda (s1 s2) (fx= (string-length s1) (string-length s2)))) (si= (lambda (s1 s2 i) (char=? (string-ref s1 i) (string-ref s2 i)))) (si<n= (lambda (s1 s2 i n) (if (fx= i n) #t (if (si= s1 s2 i) (si<n= s1 s2 (fx+ i 1) n) #f)))) (ss= (lambda (s1 s2) (if (slen= s1 s2) (si<n= s1 s2 0 (string-length s1)) #f)))) ss=)
# == uniquify-variables  ==>
# (letrec ((f195869 (lambda (f195890 f195891) (fx= (string-length f195890) (string-length f195891)))) (f195868 (lambda (f195887 f195888 f195889) (char=? (string-ref f195887 f195889) (string-ref f195888 f195889)))) (f195867 (lambda (f195883 f195884 f195885 f195886) (if (fx= f195885 f195886) #t (if (f195868 f195883 f195884 f195885) (f195867 f195883 f195884 (fx+ f195885 1) f195886) #f)))) (f195866 (lambda (f195881 f195882) (if (f195869 f195881 f195882) (f195867 f195881 f195882 0 (string-length f195881)) #f)))) f195866)
# == vectorize-letrec  ==>
# (let ((f195869 (make-vector 1)) (f195868 (make-vector 1)) (f195867 (make-vector 1)) (f195866 (make-vector 1))) (begin (begin (vector-set! f195869 0 (lambda (f195890 f195891) (fx= (string-length f195890) (string-length f195891)))) (vector-set! f195868 0 (lambda (f195887 f195888 f195889) (char=? (string-ref f195887 f195889) (string-ref f195888 f195889)))) (vector-set! f195867 0 (lambda (f195883 f195884 f195885 f195886) (if (fx= f195885 f195886) #t (if ((vector-ref f195868 0) f195883 f195884 f195885) ((vector-ref f195867 0) f195883 f195884 (fx+ f195885 1) f195886) #f)))) (vector-set! f195866 0 (lambda (f195881 f195882) (if ((vector-ref f195869 0) f195881 f195882) ((vector-ref f195867 0) f195881 f195882 0 (string-length f195881)) #f)))) (vector-ref f195866 0)))
# == eliminate-set!  ==>
# (let ((f195869 (make-vector 1)) (f195868 (make-vector 1)) (f195867 (make-vector 1)) (f195866 (make-vector 1))) (begin (begin (vector-set! f195869 0 (lambda (f195890 f195891) (let ((f195890 f195890) (f195891 f195891)) (fx= (string-length f195890) (string-length f195891))))) (vector-set! f195868 0 (lambda (f195887 f195888 f195889) (let ((f195887 f195887) (f195888 f195888) (f195889 f195889)) (char=? (string-ref f195887 f195889) (string-ref f195888 f195889))))) (vector-set! f195867 0 (lambda (f195883 f195884 f195885 f195886) (let ((f195883 f195883) (f195884 f195884) (f195885 f195885) (f195886 f195886)) (if (fx= f195885 f195886) #t (if ((vector-ref f195868 0) f195883 f195884 f195885) ((vector-ref f195867 0) f195883 f195884 (fx+ f195885 1) f195886) #f))))) (vector-set! f195866 0 (lambda (f195881 f195882) (let ((f195881 f195881) (f195882 f195882)) (if ((vector-ref f195869 0) f195881 f195882) ((vector-ref f195867 0) f195881 f195882 0 (string-length f195881)) #f))))) (vector-ref f195866 0)))
# == close-free-variables  ==>
# (let ((f195869 (make-vector 1)) (f195868 (make-vector 1)) (f195867 (make-vector 1)) (f195866 (make-vector 1))) (begin (begin (vector-set! f195869 0 (closure (f195890 f195891) () (let ((f195890 f195890) (f195891 f195891)) (fx= (string-length f195890) (string-length f195891))))) (vector-set! f195868 0 (closure (f195887 f195888 f195889) () (let ((f195887 f195887) (f195888 f195888) (f195889 f195889)) (char=? (string-ref f195887 f195889) (string-ref f195888 f195889))))) (vector-set! f195867 0 (closure (f195883 f195884 f195885 f195886) (f195868 f195867) (let ((f195883 f195883) (f195884 f195884) (f195885 f195885) (f195886 f195886)) (if (fx= f195885 f195886) #t (if ((vector-ref f195868 0) f195883 f195884 f195885) ((vector-ref f195867 0) f195883 f195884 (fx+ f195885 1) f195886) #f))))) (vector-set! f195866 0 (closure (f195881 f195882) (f195869 f195867) (let ((f195881 f195881) (f195882 f195882)) (if ((vector-ref f195869 0) f195881 f195882) ((vector-ref f195867 0) f195881 f195882 0 (string-length f195881)) #f))))) (vector-ref f195866 0)))
# == eliminate-quote  ==>
# (let ((f195869 (make-vector 1)) (f195868 (make-vector 1)) (f195867 (make-vector 1)) (f195866 (make-vector 1))) (begin (begin (vector-set! f195869 0 (closure (f195890 f195891) () (let ((f195890 f195890) (f195891 f195891)) (fx= (string-length f195890) (string-length f195891))))) (vector-set! f195868 0 (closure (f195887 f195888 f195889) () (let ((f195887 f195887) (f195888 f195888) (f195889 f195889)) (char=? (string-ref f195887 f195889) (string-ref f195888 f195889))))) (vector-set! f195867 0 (closure (f195883 f195884 f195885 f195886) (f195868 f195867) (let ((f195883 f195883) (f195884 f195884) (f195885 f195885) (f195886 f195886)) (if (fx= f195885 f195886) #t (if ((vector-ref f195868 0) f195883 f195884 f195885) ((vector-ref f195867 0) f195883 f195884 (fx+ f195885 1) f195886) #f))))) (vector-set! f195866 0 (closure (f195881 f195882) (f195869 f195867) (let ((f195881 f195881) (f195882 f195882)) (if ((vector-ref f195869 0) f195881 f195882) ((vector-ref f195867 0) f195881 f195882 0 (string-length f195881)) #f))))) (vector-ref f195866 0)))
# == eliminate-when/unless  ==>
# (let ((f195869 (make-vector 1)) (f195868 (make-vector 1)) (f195867 (make-vector 1)) (f195866 (make-vector 1))) (begin (begin (vector-set! f195869 0 (closure (f195890 f195891) () (let ((f195890 f195890) (f195891 f195891)) (fx= (string-length f195890) (string-length f195891))))) (vector-set! f195868 0 (closure (f195887 f195888 f195889) () (let ((f195887 f195887) (f195888 f195888) (f195889 f195889)) (char=? (string-ref f195887 f195889) (string-ref f195888 f195889))))) (vector-set! f195867 0 (closure (f195883 f195884 f195885 f195886) (f195868 f195867) (let ((f195883 f195883) (f195884 f195884) (f195885 f195885) (f195886 f195886)) (if (fx= f195885 f195886) #t (if ((vector-ref f195868 0) f195883 f195884 f195885) ((vector-ref f195867 0) f195883 f195884 (fx+ f195885 1) f195886) #f))))) (vector-set! f195866 0 (closure (f195881 f195882) (f195869 f195867) (let ((f195881 f195881) (f195882 f195882)) (if ((vector-ref f195869 0) f195881 f195882) ((vector-ref f195867 0) f195881 f195882 0 (string-length f195881)) #f))))) (vector-ref f195866 0)))
# == eliminate-cond  ==>
# (let ((f195869 (make-vector 1)) (f195868 (make-vector 1)) (f195867 (make-vector 1)) (f195866 (make-vector 1))) (begin (begin (vector-set! f195869 0 (closure (f195890 f195891) () (let ((f195890 f195890) (f195891 f195891)) (fx= (string-length f195890) (string-length f195891))))) (vector-set! f195868 0 (closure (f195887 f195888 f195889) () (let ((f195887 f195887) (f195888 f195888) (f195889 f195889)) (char=? (string-ref f195887 f195889) (string-ref f195888 f195889))))) (vector-set! f195867 0 (closure (f195883 f195884 f195885 f195886) (f195868 f195867) (let ((f195883 f195883) (f195884 f195884) (f195885 f195885) (f195886 f195886)) (if (fx= f195885 f195886) #t (if ((vector-ref f195868 0) f195883 f195884 f195885) ((vector-ref f195867 0) f195883 f195884 (fx+ f195885 1) f195886) #f))))) (vector-set! f195866 0 (closure (f195881 f195882) (f195869 f195867) (let ((f195881 f195881) (f195882 f195882)) (if ((vector-ref f195869 0) f195881 f195882) ((vector-ref f195867 0) f195881 f195882 0 (string-length f195881)) #f))))) (vector-ref f195866 0)))
# == external-symbols  ==>
# (let ((f195869 (make-vector 1)) (f195868 (make-vector 1)) (f195867 (make-vector 1)) (f195866 (make-vector 1))) (begin (begin (vector-set! f195869 0 (closure (f195890 f195891) () (let ((f195890 f195890) (f195891 f195891)) (fx= (string-length f195890) (string-length f195891))))) (vector-set! f195868 0 (closure (f195887 f195888 f195889) () (let ((f195887 f195887) (f195888 f195888) (f195889 f195889)) (char=? (string-ref f195887 f195889) (string-ref f195888 f195889))))) (vector-set! f195867 0 (closure (f195883 f195884 f195885 f195886) (f195868 f195867) (let ((f195883 f195883) (f195884 f195884) (f195885 f195885) (f195886 f195886)) (if (fx= f195885 f195886) #t (if ((vector-ref f195868 0) f195883 f195884 f195885) ((vector-ref f195867 0) f195883 f195884 (fx+ f195885 1) f195886) #f))))) (vector-set! f195866 0 (closure (f195881 f195882) (f195869 f195867) (let ((f195881 f195881) (f195882 f195882)) (if ((vector-ref f195869 0) f195881 f195882) ((vector-ref f195867 0) f195881 f195882 0 (string-length f195881)) #f))))) (vector-ref f195866 0)))
# emit-expr (let ((f195869 (make-vector 1)) (f195868 (make-vector 1)) (f195867 (make-vector 1)) (f195866 (make-vector 1))) (begin (begin (vector-set! f195869 0 (closure (f195890 f195891) () (let ((f195890 f195890) (f195891 f195891)) (fx= (string-length f195890) (string-length f195891))))) (vector-set! f195868 0 (closure (f195887 f195888 f195889) () (let ((f195887 f195887) (f195888 f195888) (f195889 f195889)) (char=? (string-ref f195887 f195889) (string-ref f195888 f195889))))) (vector-set! f195867 0 (closure (f195883 f195884 f195885 f195886) (f195868 f195867) (let ((f195883 f195883) (f195884 f195884) (f195885 f195885) (f195886 f195886)) (if (fx= f195885 f195886) #t (if ((vector-ref f195868 0) f195883 f195884 f195885) ((vector-ref f195867 0) f195883 f195884 (fx+ f195885 1) f195886) #f))))) (vector-set! f195866 0 (closure (f195881 f195882) (f195869 f195867) (let ((f195881 f195881) (f195882 f195882)) (if ((vector-ref f195869 0) f195881 f195882) ((vector-ref f195867 0) f195881 f195882 0 (string-length f195881)) #f))))) (vector-ref f195866 0)))
# emit-let
#  si   = 0
#  env  = ()
#  bindings = ((f195869 (make-vector 1)) (f195868 (make-vector 1)) (f195867 (make-vector 1)) (f195866 (make-vector 1)))
#  body = (begin (begin (vector-set! f195869 0 (closure (f195890 f195891) () (let ((f195890 f195890) (f195891 f195891)) (fx= (string-length f195890) (string-length f195891))))) (vector-set! f195868 0 (closure (f195887 f195888 f195889) () (let ((f195887 f195887) (f195888 f195888) (f195889 f195889)) (char=? (string-ref f195887 f195889) (string-ref f195888 f195889))))) (vector-set! f195867 0 (closure (f195883 f195884 f195885 f195886) (f195868 f195867) (let ((f195883 f195883) (f195884 f195884) (f195885 f195885) (f195886 f195886)) (if (fx= f195885 f195886) #t (if ((vector-ref f195868 0) f195883 f195884 f195885) ((vector-ref f195867 0) f195883 f195884 (fx+ f195885 1) f195886) #f))))) (vector-set! f195866 0 (closure (f195881 f195882) (f195869 f195867) (let ((f195881 f195881) (f195882 f195882)) (if ((vector-ref f195869 0) f195881 f195882) ((vector-ref f195867 0) f195881 f195882 0 (string-length f195881)) #f))))) (vector-ref f195866 0))
# emit-expr (make-vector 1)
# make-vector 1
# emit-expr 1
    movl $4, %eax     # immed 1
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1423638"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $128,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1423638:
# check the argument is a fixnum >= 0
    cmp $0,%eax
    jge _L_1423639
# invoke error handler eh_length
    .extern mrc_eh$ulength
    movl mrc_eh$ulength, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $128,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1423639:
    movl %eax, %esi
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    orl  $5, %eax
    addl $4, %esi
    addl $4, %esi
    andl $-8, %esi
    addl %esi, %ebp
    movl %eax, 0(%esp)  # stack save
# emit-expr (make-vector 1)
# make-vector 1
# emit-expr 1
    movl $4, %eax     # immed 1
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1423640"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $128,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1423640:
# check the argument is a fixnum >= 0
    cmp $0,%eax
    jge _L_1423641
# invoke error handler eh_length
    .extern mrc_eh$ulength
    movl mrc_eh$ulength, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $128,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1423641:
    movl %eax, %esi
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    orl  $5, %eax
    addl $4, %esi
    addl $4, %esi
    andl $-8, %esi
    addl %esi, %ebp
    movl %eax, -4(%esp)  # stack save
# emit-expr (make-vector 1)
# make-vector 1
# emit-expr 1
    movl $4, %eax     # immed 1
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1423642"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $128,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1423642:
# check the argument is a fixnum >= 0
    cmp $0,%eax
    jge _L_1423643
# invoke error handler eh_length
    .extern mrc_eh$ulength
    movl mrc_eh$ulength, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $128,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1423643:
    movl %eax, %esi
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    orl  $5, %eax
    addl $4, %esi
    addl $4, %esi
    andl $-8, %esi
    addl %esi, %ebp
    movl %eax, -8(%esp)  # stack save
# emit-expr (make-vector 1)
# make-vector 1
# emit-expr 1
    movl $4, %eax     # immed 1
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1423644"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $128,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1423644:
# check the argument is a fixnum >= 0
    cmp $0,%eax
    jge _L_1423645
# invoke error handler eh_length
    .extern mrc_eh$ulength
    movl mrc_eh$ulength, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $128,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1423645:
    movl %eax, %esi
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    orl  $5, %eax
    addl $4, %esi
    addl $4, %esi
    andl $-8, %esi
    addl %esi, %ebp
    movl %eax, -12(%esp)  # stack save
# emit-expr (begin (begin (vector-set! f195869 0 (closure (f195890 f195891) () (let ((f195890 f195890) (f195891 f195891)) (fx= (string-length f195890) (string-length f195891))))) (vector-set! f195868 0 (closure (f195887 f195888 f195889) () (let ((f195887 f195887) (f195888 f195888) (f195889 f195889)) (char=? (string-ref f195887 f195889) (string-ref f195888 f195889))))) (vector-set! f195867 0 (closure (f195883 f195884 f195885 f195886) (f195868 f195867) (let ((f195883 f195883) (f195884 f195884) (f195885 f195885) (f195886 f195886)) (if (fx= f195885 f195886) #t (if ((vector-ref f195868 0) f195883 f195884 f195885) ((vector-ref f195867 0) f195883 f195884 (fx+ f195885 1) f195886) #f))))) (vector-set! f195866 0 (closure (f195881 f195882) (f195869 f195867) (let ((f195881 f195881) (f195882 f195882)) (if ((vector-ref f195869 0) f195881 f195882) ((vector-ref f195867 0) f195881 f195882 0 (string-length f195881)) #f))))) (vector-ref f195866 0))
# emit-begin
#   expr=(begin (begin (vector-set! f195869 0 (closure (f195890 f195891) () (let ((f195890 f195890) (f195891 f195891)) (fx= (string-length f195890) (string-length f195891))))) (vector-set! f195868 0 (closure (f195887 f195888 f195889) () (let ((f195887 f195887) (f195888 f195888) (f195889 f195889)) (char=? (string-ref f195887 f195889) (string-ref f195888 f195889))))) (vector-set! f195867 0 (closure (f195883 f195884 f195885 f195886) (f195868 f195867) (let ((f195883 f195883) (f195884 f195884) (f195885 f195885) (f195886 f195886)) (if (fx= f195885 f195886) #t (if ((vector-ref f195868 0) f195883 f195884 f195885) ((vector-ref f195867 0) f195883 f195884 (fx+ f195885 1) f195886) #f))))) (vector-set! f195866 0 (closure (f195881 f195882) (f195869 f195867) (let ((f195881 f195881) (f195882 f195882)) (if ((vector-ref f195869 0) f195881 f195882) ((vector-ref f195867 0) f195881 f195882 0 (string-length f195881)) #f))))) (vector-ref f195866 0))
#   env=((f195866 . -12) (f195867 . -8) (f195868 . -4) (f195869 . 0))
# emit-expr (begin (vector-set! f195869 0 (closure (f195890 f195891) () (let ((f195890 f195890) (f195891 f195891)) (fx= (string-length f195890) (string-length f195891))))) (vector-set! f195868 0 (closure (f195887 f195888 f195889) () (let ((f195887 f195887) (f195888 f195888) (f195889 f195889)) (char=? (string-ref f195887 f195889) (string-ref f195888 f195889))))) (vector-set! f195867 0 (closure (f195883 f195884 f195885 f195886) (f195868 f195867) (let ((f195883 f195883) (f195884 f195884) (f195885 f195885) (f195886 f195886)) (if (fx= f195885 f195886) #t (if ((vector-ref f195868 0) f195883 f195884 f195885) ((vector-ref f195867 0) f195883 f195884 (fx+ f195885 1) f195886) #f))))) (vector-set! f195866 0 (closure (f195881 f195882) (f195869 f195867) (let ((f195881 f195881) (f195882 f195882)) (if ((vector-ref f195869 0) f195881 f195882) ((vector-ref f195867 0) f195881 f195882 0 (string-length f195881)) #f)))))
# emit-begin
#   expr=(begin (vector-set! f195869 0 (closure (f195890 f195891) () (let ((f195890 f195890) (f195891 f195891)) (fx= (string-length f195890) (string-length f195891))))) (vector-set! f195868 0 (closure (f195887 f195888 f195889) () (let ((f195887 f195887) (f195888 f195888) (f195889 f195889)) (char=? (string-ref f195887 f195889) (string-ref f195888 f195889))))) (vector-set! f195867 0 (closure (f195883 f195884 f195885 f195886) (f195868 f195867) (let ((f195883 f195883) (f195884 f195884) (f195885 f195885) (f195886 f195886)) (if (fx= f195885 f195886) #t (if ((vector-ref f195868 0) f195883 f195884 f195885) ((vector-ref f195867 0) f195883 f195884 (fx+ f195885 1) f195886) #f))))) (vector-set! f195866 0 (closure (f195881 f195882) (f195869 f195867) (let ((f195881 f195881) (f195882 f195882)) (if ((vector-ref f195869 0) f195881 f195882) ((vector-ref f195867 0) f195881 f195882 0 (string-length f195881)) #f)))))
#   env=((f195866 . -12) (f195867 . -8) (f195868 . -4) (f195869 . 0))
# emit-expr (vector-set! f195869 0 (closure (f195890 f195891) () (let ((f195890 f195890) (f195891 f195891)) (fx= (string-length f195890) (string-length f195891)))))
# emit-expr f195869
# emit-variable-ref
# env=((f195866 . -12) (f195867 . -8) (f195868 . -4) (f195869 . 0))
# var=f195869
    movl 0(%esp), %eax  # stack load f195869
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1423646
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1423646:
    movl %eax, -16(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1423647"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1423647:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1423649
    cmp  $0,%eax
    jge _L_1423648
_L_1423649:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1423648:
    movl %eax, -20(%esp)
# emit-expr (closure (f195890 f195891) () (let ((f195890 f195890) (f195891 f195891)) (fx= (string-length f195890) (string-length f195891))))
# emit-closure
# si = -24
# env = ((f195866 . -12) (f195867 . -8) (f195868 . -4) (f195869 . 0))
# expr = (closure (f195890 f195891) () (let ((f195890 f195890) (f195891 f195891)) (fx= (string-length f195890) (string-length f195891))))
    movl $_L_1423650, 0(%ebp)  # closure label
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $8, %ebp     # bump ebp
    jmp _L_1423651            # jump around closure body
_L_1423650:
# check argument count
    cmp $8,%eax
    je _L_1423652
# invoke error handler eh_argcount
    .extern mrc_eh$uargcount
    movl mrc_eh$uargcount, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_1423652:
# emit-tail-expr
# si=-16
# env=((f195891 . -12) (f195890 . -8) (f195866 . -12) (f195867 . -8) (f195868 . -4) (f195869 . 0))
# expr=(let ((f195890 f195890) (f195891 f195891)) (fx= (string-length f195890) (string-length f195891)))
# emit-tail-let
#  si   = -16
#  env  = ((f195891 . -12) (f195890 . -8) (f195866 . -12) (f195867 . -8) (f195868 . -4) (f195869 . 0))
#  bindings = ((f195890 f195890) (f195891 f195891))
#  body = (fx= (string-length f195890) (string-length f195891))
# emit-expr f195890
# emit-variable-ref
# env=((f195891 . -12) (f195890 . -8) (f195866 . -12) (f195867 . -8) (f195868 . -4) (f195869 . 0))
# var=f195890
    movl -8(%esp), %eax  # stack load f195890
# end emit-variable-ref
    movl %eax, -16(%esp)  # stack save
# emit-expr f195891
# emit-variable-ref
# env=((f195891 . -12) (f195890 . -8) (f195866 . -12) (f195867 . -8) (f195868 . -4) (f195869 . 0))
# var=f195891
    movl -12(%esp), %eax  # stack load f195891
# end emit-variable-ref
    movl %eax, -20(%esp)  # stack save
# emit-tail-expr
# si=-24
# env=((f195891 . -20) (f195890 . -16) (f195891 . -12) (f195890 . -8) (f195866 . -12) (f195867 . -8) (f195868 . -4) (f195869 . 0))
# expr=(fx= (string-length f195890) (string-length f195891))
# tail primcall
# emit-expr (string-length f195891)
# emit-expr f195891
# emit-variable-ref
# env=((f195891 . -20) (f195890 . -16) (f195891 . -12) (f195890 . -8) (f195866 . -12) (f195867 . -8) (f195868 . -4) (f195869 . 0))
# var=f195891
    movl -20(%esp), %eax  # stack load f195891
# end emit-variable-ref
# check the argument is a string
    movl %eax,%ebx
    and $7, %bl
    cmp $6, %bl
    je _L_1423653
# invoke error handler eh_string
    .extern mrc_eh$ustring
    movl mrc_eh$ustring, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $152,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1423653:
    movl -6(%eax), %eax
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1423654"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $60,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1423654:
    movl %eax, -24(%esp)
# emit-expr (string-length f195890)
# emit-expr f195890
# emit-variable-ref
# env=((f195891 . -20) (f195890 . -16) (f195891 . -12) (f195890 . -8) (f195866 . -12) (f195867 . -8) (f195868 . -4) (f195869 . 0))
# var=f195890
    movl -16(%esp), %eax  # stack load f195890
# end emit-variable-ref
# check the argument is a string
    movl %eax,%ebx
    and $7, %bl
    cmp $6, %bl
    je _L_1423655
# invoke error handler eh_string
    .extern mrc_eh$ustring
    movl mrc_eh$ustring, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $152,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1423655:
    movl -6(%eax), %eax
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1423656"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $60,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1423656:
    cmp -24(%esp), %eax
    sete %al
    movzbl %al, %eax
    sal $6, %al
    or $47, %al
#return from tail (fx= (string-length f195890) (string-length f195891))
    ret
    .align 4,0x90
_L_1423651:
    movl -16(%esp), %ebx
    movl -20(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin (vector-set! f195868 0 (closure (f195887 f195888 f195889) () (let ((f195887 f195887) (f195888 f195888) (f195889 f195889)) (char=? (string-ref f195887 f195889) (string-ref f195888 f195889))))) (vector-set! f195867 0 (closure (f195883 f195884 f195885 f195886) (f195868 f195867) (let ((f195883 f195883) (f195884 f195884) (f195885 f195885) (f195886 f195886)) (if (fx= f195885 f195886) #t (if ((vector-ref f195868 0) f195883 f195884 f195885) ((vector-ref f195867 0) f195883 f195884 (fx+ f195885 1) f195886) #f))))) (vector-set! f195866 0 (closure (f195881 f195882) (f195869 f195867) (let ((f195881 f195881) (f195882 f195882)) (if ((vector-ref f195869 0) f195881 f195882) ((vector-ref f195867 0) f195881 f195882 0 (string-length f195881)) #f)))))
# emit-begin
#   expr=(begin (vector-set! f195868 0 (closure (f195887 f195888 f195889) () (let ((f195887 f195887) (f195888 f195888) (f195889 f195889)) (char=? (string-ref f195887 f195889) (string-ref f195888 f195889))))) (vector-set! f195867 0 (closure (f195883 f195884 f195885 f195886) (f195868 f195867) (let ((f195883 f195883) (f195884 f195884) (f195885 f195885) (f195886 f195886)) (if (fx= f195885 f195886) #t (if ((vector-ref f195868 0) f195883 f195884 f195885) ((vector-ref f195867 0) f195883 f195884 (fx+ f195885 1) f195886) #f))))) (vector-set! f195866 0 (closure (f195881 f195882) (f195869 f195867) (let ((f195881 f195881) (f195882 f195882)) (if ((vector-ref f195869 0) f195881 f195882) ((vector-ref f195867 0) f195881 f195882 0 (string-length f195881)) #f)))))
#   env=((f195866 . -12) (f195867 . -8) (f195868 . -4) (f195869 . 0))
# emit-expr (vector-set! f195868 0 (closure (f195887 f195888 f195889) () (let ((f195887 f195887) (f195888 f195888) (f195889 f195889)) (char=? (string-ref f195887 f195889) (string-ref f195888 f195889)))))
# emit-expr f195868
# emit-variable-ref
# env=((f195866 . -12) (f195867 . -8) (f195868 . -4) (f195869 . 0))
# var=f195868
    movl -4(%esp), %eax  # stack load f195868
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1423657
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1423657:
    movl %eax, -16(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1423658"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1423658:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1423660
    cmp  $0,%eax
    jge _L_1423659
_L_1423660:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1423659:
    movl %eax, -20(%esp)
# emit-expr (closure (f195887 f195888 f195889) () (let ((f195887 f195887) (f195888 f195888) (f195889 f195889)) (char=? (string-ref f195887 f195889) (string-ref f195888 f195889))))
# emit-closure
# si = -24
# env = ((f195866 . -12) (f195867 . -8) (f195868 . -4) (f195869 . 0))
# expr = (closure (f195887 f195888 f195889) () (let ((f195887 f195887) (f195888 f195888) (f195889 f195889)) (char=? (string-ref f195887 f195889) (string-ref f195888 f195889))))
    movl $_L_1423661, 0(%ebp)  # closure label
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $8, %ebp     # bump ebp
    jmp _L_1423662            # jump around closure body
_L_1423661:
# check argument count
    cmp $12,%eax
    je _L_1423663
# invoke error handler eh_argcount
    .extern mrc_eh$uargcount
    movl mrc_eh$uargcount, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_1423663:
# emit-tail-expr
# si=-20
# env=((f195889 . -16) (f195888 . -12) (f195887 . -8) (f195866 . -12) (f195867 . -8) (f195868 . -4) (f195869 . 0))
# expr=(let ((f195887 f195887) (f195888 f195888) (f195889 f195889)) (char=? (string-ref f195887 f195889) (string-ref f195888 f195889)))
# emit-tail-let
#  si   = -20
#  env  = ((f195889 . -16) (f195888 . -12) (f195887 . -8) (f195866 . -12) (f195867 . -8) (f195868 . -4) (f195869 . 0))
#  bindings = ((f195887 f195887) (f195888 f195888) (f195889 f195889))
#  body = (char=? (string-ref f195887 f195889) (string-ref f195888 f195889))
# emit-expr f195887
# emit-variable-ref
# env=((f195889 . -16) (f195888 . -12) (f195887 . -8) (f195866 . -12) (f195867 . -8) (f195868 . -4) (f195869 . 0))
# var=f195887
    movl -8(%esp), %eax  # stack load f195887
# end emit-variable-ref
    movl %eax, -20(%esp)  # stack save
# emit-expr f195888
# emit-variable-ref
# env=((f195889 . -16) (f195888 . -12) (f195887 . -8) (f195866 . -12) (f195867 . -8) (f195868 . -4) (f195869 . 0))
# var=f195888
    movl -12(%esp), %eax  # stack load f195888
# end emit-variable-ref
    movl %eax, -24(%esp)  # stack save
# emit-expr f195889
# emit-variable-ref
# env=((f195889 . -16) (f195888 . -12) (f195887 . -8) (f195866 . -12) (f195867 . -8) (f195868 . -4) (f195869 . 0))
# var=f195889
    movl -16(%esp), %eax  # stack load f195889
# end emit-variable-ref
    movl %eax, -28(%esp)  # stack save
# emit-tail-expr
# si=-32
# env=((f195889 . -28) (f195888 . -24) (f195887 . -20) (f195889 . -16) (f195888 . -12) (f195887 . -8) (f195866 . -12) (f195867 . -8) (f195868 . -4) (f195869 . 0))
# expr=(char=? (string-ref f195887 f195889) (string-ref f195888 f195889))
# tail primcall
# char= c1=(string-ref f195887 f195889) c2=(string-ref f195888 f195889)
# emit-expr (string-ref f195887 f195889)
# emit-expr f195887
# emit-variable-ref
# env=((f195889 . -28) (f195888 . -24) (f195887 . -20) (f195889 . -16) (f195888 . -12) (f195887 . -8) (f195866 . -12) (f195867 . -8) (f195868 . -4) (f195869 . 0))
# var=f195887
    movl -20(%esp), %eax  # stack load f195887
# end emit-variable-ref
# check the argument is a string
    movl %eax,%ebx
    and $7, %bl
    cmp $6, %bl
    je _L_1423664
# invoke error handler eh_string
    .extern mrc_eh$ustring
    movl mrc_eh$ustring, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $156,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1423664:
    movl %eax, -32(%esp)
# emit-expr f195889
# emit-variable-ref
# env=((f195889 . -28) (f195888 . -24) (f195887 . -20) (f195889 . -16) (f195888 . -12) (f195887 . -8) (f195866 . -12) (f195867 . -8) (f195868 . -4) (f195869 . 0))
# var=f195889
    movl -28(%esp), %eax  # stack load f195889
# end emit-variable-ref
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1423665"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $156,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1423665:
# check bounds on string index
    movl -32(%esp), %ebx
    cmp  %eax,-6(%ebx) 
    jle _L_1423667
    cmp  $0,%eax
    jge _L_1423666
_L_1423667:
# invoke error handler eh_string_index
    .extern mrc_eh$ustring$uindex
    movl mrc_eh$ustring$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $156,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1423666:
    sar $2, %eax
    movl -32(%esp), %esi
    movl -2(%eax,%esi), %eax
    sal $8, %eax
    or  $15, %eax
# check the argument is a char
    movl %eax,%ebx
    and $255, %bl
    cmp $15, %bl
    je "_L_1423668"
# invoke error handler eh_character
    .extern mrc_eh$ucharacter
    movl mrc_eh$ucharacter, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $32,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1423668:
    movb %ah, -32(%esp)
# emit-expr (string-ref f195888 f195889)
# emit-expr f195888
# emit-variable-ref
# env=((f195889 . -28) (f195888 . -24) (f195887 . -20) (f195889 . -16) (f195888 . -12) (f195887 . -8) (f195866 . -12) (f195867 . -8) (f195868 . -4) (f195869 . 0))
# var=f195888
    movl -24(%esp), %eax  # stack load f195888
# end emit-variable-ref
# check the argument is a string
    movl %eax,%ebx
    and $7, %bl
    cmp $6, %bl
    je _L_1423669
# invoke error handler eh_string
    .extern mrc_eh$ustring
    movl mrc_eh$ustring, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $156,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1423669:
    movl %eax, -36(%esp)
# emit-expr f195889
# emit-variable-ref
# env=((f195889 . -28) (f195888 . -24) (f195887 . -20) (f195889 . -16) (f195888 . -12) (f195887 . -8) (f195866 . -12) (f195867 . -8) (f195868 . -4) (f195869 . 0))
# var=f195889
    movl -28(%esp), %eax  # stack load f195889
# end emit-variable-ref
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1423670"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $156,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1423670:
# check bounds on string index
    movl -36(%esp), %ebx
    cmp  %eax,-6(%ebx) 
    jle _L_1423672
    cmp  $0,%eax
    jge _L_1423671
_L_1423672:
# invoke error handler eh_string_index
    .extern mrc_eh$ustring$uindex
    movl mrc_eh$ustring$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $156,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1423671:
    sar $2, %eax
    movl -36(%esp), %esi
    movl -2(%eax,%esi), %eax
    sal $8, %eax
    or  $15, %eax
# check the argument is a char
    movl %eax,%ebx
    and $255, %bl
    cmp $15, %bl
    je "_L_1423673"
# invoke error handler eh_character
    .extern mrc_eh$ucharacter
    movl mrc_eh$ucharacter, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $32,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1423673:
    cmp %ah, -32(%esp)
    sete %al
    movzbl %al, %eax
    sal $6, %al
    or $47, %al
#return from tail (char=? (string-ref f195887 f195889) (string-ref f195888 f195889))
    ret
    .align 4,0x90
_L_1423662:
    movl -16(%esp), %ebx
    movl -20(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin (vector-set! f195867 0 (closure (f195883 f195884 f195885 f195886) (f195868 f195867) (let ((f195883 f195883) (f195884 f195884) (f195885 f195885) (f195886 f195886)) (if (fx= f195885 f195886) #t (if ((vector-ref f195868 0) f195883 f195884 f195885) ((vector-ref f195867 0) f195883 f195884 (fx+ f195885 1) f195886) #f))))) (vector-set! f195866 0 (closure (f195881 f195882) (f195869 f195867) (let ((f195881 f195881) (f195882 f195882)) (if ((vector-ref f195869 0) f195881 f195882) ((vector-ref f195867 0) f195881 f195882 0 (string-length f195881)) #f)))))
# emit-begin
#   expr=(begin (vector-set! f195867 0 (closure (f195883 f195884 f195885 f195886) (f195868 f195867) (let ((f195883 f195883) (f195884 f195884) (f195885 f195885) (f195886 f195886)) (if (fx= f195885 f195886) #t (if ((vector-ref f195868 0) f195883 f195884 f195885) ((vector-ref f195867 0) f195883 f195884 (fx+ f195885 1) f195886) #f))))) (vector-set! f195866 0 (closure (f195881 f195882) (f195869 f195867) (let ((f195881 f195881) (f195882 f195882)) (if ((vector-ref f195869 0) f195881 f195882) ((vector-ref f195867 0) f195881 f195882 0 (string-length f195881)) #f)))))
#   env=((f195866 . -12) (f195867 . -8) (f195868 . -4) (f195869 . 0))
# emit-expr (vector-set! f195867 0 (closure (f195883 f195884 f195885 f195886) (f195868 f195867) (let ((f195883 f195883) (f195884 f195884) (f195885 f195885) (f195886 f195886)) (if (fx= f195885 f195886) #t (if ((vector-ref f195868 0) f195883 f195884 f195885) ((vector-ref f195867 0) f195883 f195884 (fx+ f195885 1) f195886) #f)))))
# emit-expr f195867
# emit-variable-ref
# env=((f195866 . -12) (f195867 . -8) (f195868 . -4) (f195869 . 0))
# var=f195867
    movl -8(%esp), %eax  # stack load f195867
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1423674
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1423674:
    movl %eax, -16(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1423675"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1423675:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1423677
    cmp  $0,%eax
    jge _L_1423676
_L_1423677:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1423676:
    movl %eax, -20(%esp)
# emit-expr (closure (f195883 f195884 f195885 f195886) (f195868 f195867) (let ((f195883 f195883) (f195884 f195884) (f195885 f195885) (f195886 f195886)) (if (fx= f195885 f195886) #t (if ((vector-ref f195868 0) f195883 f195884 f195885) ((vector-ref f195867 0) f195883 f195884 (fx+ f195885 1) f195886) #f))))
# emit-closure
# si = -24
# env = ((f195866 . -12) (f195867 . -8) (f195868 . -4) (f195869 . 0))
# expr = (closure (f195883 f195884 f195885 f195886) (f195868 f195867) (let ((f195883 f195883) (f195884 f195884) (f195885 f195885) (f195886 f195886)) (if (fx= f195885 f195886) #t (if ((vector-ref f195868 0) f195883 f195884 f195885) ((vector-ref f195867 0) f195883 f195884 (fx+ f195885 1) f195886) #f))))
    movl $_L_1423678, 0(%ebp)  # closure label
# emit-variable-ref
# env=((f195866 . -12) (f195867 . -8) (f195868 . -4) (f195869 . 0))
# var=f195868
    movl -4(%esp), %eax  # stack load f195868
# end emit-variable-ref
   movl  %eax, 4(%ebp)  # f195868
# emit-variable-ref
# env=((f195866 . -12) (f195867 . -8) (f195868 . -4) (f195869 . 0))
# var=f195867
    movl -8(%esp), %eax  # stack load f195867
# end emit-variable-ref
   movl  %eax, 8(%ebp)  # f195867
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $16, %ebp     # bump ebp
    jmp _L_1423679            # jump around closure body
_L_1423678:
# check argument count
    cmp $16,%eax
    je _L_1423680
# invoke error handler eh_argcount
    .extern mrc_eh$uargcount
    movl mrc_eh$uargcount, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_1423680:
# emit-tail-expr
# si=-24
# env=((f195886 . -20) (f195885 . -16) (f195884 . -12) (f195883 . -8) (f195867 . 8) (f195868 . 4) (f195866 . -12) (f195867 . -8) (f195868 . -4) (f195869 . 0))
# expr=(let ((f195883 f195883) (f195884 f195884) (f195885 f195885) (f195886 f195886)) (if (fx= f195885 f195886) #t (if ((vector-ref f195868 0) f195883 f195884 f195885) ((vector-ref f195867 0) f195883 f195884 (fx+ f195885 1) f195886) #f)))
# emit-tail-let
#  si   = -24
#  env  = ((f195886 . -20) (f195885 . -16) (f195884 . -12) (f195883 . -8) (f195867 . 8) (f195868 . 4) (f195866 . -12) (f195867 . -8) (f195868 . -4) (f195869 . 0))
#  bindings = ((f195883 f195883) (f195884 f195884) (f195885 f195885) (f195886 f195886))
#  body = (if (fx= f195885 f195886) #t (if ((vector-ref f195868 0) f195883 f195884 f195885) ((vector-ref f195867 0) f195883 f195884 (fx+ f195885 1) f195886) #f))
# emit-expr f195883
# emit-variable-ref
# env=((f195886 . -20) (f195885 . -16) (f195884 . -12) (f195883 . -8) (f195867 . 8) (f195868 . 4) (f195866 . -12) (f195867 . -8) (f195868 . -4) (f195869 . 0))
# var=f195883
    movl -8(%esp), %eax  # stack load f195883
# end emit-variable-ref
    movl %eax, -24(%esp)  # stack save
# emit-expr f195884
# emit-variable-ref
# env=((f195886 . -20) (f195885 . -16) (f195884 . -12) (f195883 . -8) (f195867 . 8) (f195868 . 4) (f195866 . -12) (f195867 . -8) (f195868 . -4) (f195869 . 0))
# var=f195884
    movl -12(%esp), %eax  # stack load f195884
# end emit-variable-ref
    movl %eax, -28(%esp)  # stack save
# emit-expr f195885
# emit-variable-ref
# env=((f195886 . -20) (f195885 . -16) (f195884 . -12) (f195883 . -8) (f195867 . 8) (f195868 . 4) (f195866 . -12) (f195867 . -8) (f195868 . -4) (f195869 . 0))
# var=f195885
    movl -16(%esp), %eax  # stack load f195885
# end emit-variable-ref
    movl %eax, -32(%esp)  # stack save
# emit-expr f195886
# emit-variable-ref
# env=((f195886 . -20) (f195885 . -16) (f195884 . -12) (f195883 . -8) (f195867 . 8) (f195868 . 4) (f195866 . -12) (f195867 . -8) (f195868 . -4) (f195869 . 0))
# var=f195886
    movl -20(%esp), %eax  # stack load f195886
# end emit-variable-ref
    movl %eax, -36(%esp)  # stack save
# emit-tail-expr
# si=-40
# env=((f195886 . -36) (f195885 . -32) (f195884 . -28) (f195883 . -24) (f195886 . -20) (f195885 . -16) (f195884 . -12) (f195883 . -8) (f195867 . 8) (f195868 . 4) (f195866 . -12) (f195867 . -8) (f195868 . -4) (f195869 . 0))
# expr=(if (fx= f195885 f195886) #t (if ((vector-ref f195868 0) f195883 f195884 f195885) ((vector-ref f195867 0) f195883 f195884 (fx+ f195885 1) f195886) #f))
# emit-expr (fx= f195885 f195886)
# emit-expr f195886
# emit-variable-ref
# env=((f195886 . -36) (f195885 . -32) (f195884 . -28) (f195883 . -24) (f195886 . -20) (f195885 . -16) (f195884 . -12) (f195883 . -8) (f195867 . 8) (f195868 . 4) (f195866 . -12) (f195867 . -8) (f195868 . -4) (f195869 . 0))
# var=f195886
    movl -36(%esp), %eax  # stack load f195886
# end emit-variable-ref
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1423683"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $60,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1423683:
    movl %eax, -40(%esp)
# emit-expr f195885
# emit-variable-ref
# env=((f195886 . -36) (f195885 . -32) (f195884 . -28) (f195883 . -24) (f195886 . -20) (f195885 . -16) (f195884 . -12) (f195883 . -8) (f195867 . 8) (f195868 . 4) (f195866 . -12) (f195867 . -8) (f195868 . -4) (f195869 . 0))
# var=f195885
    movl -32(%esp), %eax  # stack load f195885
# end emit-variable-ref
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1423684"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $60,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1423684:
    cmp -40(%esp), %eax
    sete %al
    movzbl %al, %eax
    sal $6, %al
    or $47, %al
    cmp $47, %al
    je _L_1423681
# emit-tail-expr
# si=-40
# env=((f195886 . -36) (f195885 . -32) (f195884 . -28) (f195883 . -24) (f195886 . -20) (f195885 . -16) (f195884 . -12) (f195883 . -8) (f195867 . 8) (f195868 . 4) (f195866 . -12) (f195867 . -8) (f195868 . -4) (f195869 . 0))
# expr=#t
    movl $111, %eax     # immed #t
    ret                  # immediate tail return
    jmp _L_1423682
_L_1423681:
# emit-tail-expr
# si=-40
# env=((f195886 . -36) (f195885 . -32) (f195884 . -28) (f195883 . -24) (f195886 . -20) (f195885 . -16) (f195884 . -12) (f195883 . -8) (f195867 . 8) (f195868 . 4) (f195866 . -12) (f195867 . -8) (f195868 . -4) (f195869 . 0))
# expr=(if ((vector-ref f195868 0) f195883 f195884 f195885) ((vector-ref f195867 0) f195883 f195884 (fx+ f195885 1) f195886) #f)
# emit-expr ((vector-ref f195868 0) f195883 f195884 f195885)
# funcall
#    si   =-40
#    env  = ((f195886 . -36) (f195885 . -32) (f195884 . -28) (f195883 . -24) (f195886 . -20) (f195885 . -16) (f195884 . -12) (f195883 . -8) (f195867 . 8) (f195868 . 4) (f195866 . -12) (f195867 . -8) (f195868 . -4) (f195869 . 0))
#    expr = (funcall (vector-ref f195868 0) f195883 f195884 f195885)
# emit-expr (vector-ref f195868 0)
# emit-expr f195868
# emit-variable-ref
# env=((f195886 . -36) (f195885 . -32) (f195884 . -28) (f195883 . -24) (f195886 . -20) (f195885 . -16) (f195884 . -12) (f195883 . -8) (f195867 . 8) (f195868 . 4) (f195866 . -12) (f195867 . -8) (f195868 . -4) (f195869 . 0))
# var=f195868
    movl 2(%edi), %eax  # frame load f195868
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1423687
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1423687:
    movl %eax, -48(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1423688"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1423688:
# check bounds on vector index
    movl -48(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1423690
    cmp  $0,%eax
    jge _L_1423689
_L_1423690:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1423689:
    movl -48(%esp), %esi
    movl -1(%eax,%esi), %eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1423691"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1423691":
   movl %eax,  -48(%esp)  # stash funcall-oper in closure slot
# emit-expr f195883
# emit-variable-ref
# env=((f195886 . -36) (f195885 . -32) (f195884 . -28) (f195883 . -24) (f195886 . -20) (f195885 . -16) (f195884 . -12) (f195883 . -8) (f195867 . 8) (f195868 . 4) (f195866 . -12) (f195867 . -8) (f195868 . -4) (f195869 . 0))
# var=f195883
    movl -24(%esp), %eax  # stack load f195883
# end emit-variable-ref
    mov %eax, -52(%esp)  # arg f195883
# emit-expr f195884
# emit-variable-ref
# env=((f195886 . -36) (f195885 . -32) (f195884 . -28) (f195883 . -24) (f195886 . -20) (f195885 . -16) (f195884 . -12) (f195883 . -8) (f195867 . 8) (f195868 . 4) (f195866 . -12) (f195867 . -8) (f195868 . -4) (f195869 . 0))
# var=f195884
    movl -28(%esp), %eax  # stack load f195884
# end emit-variable-ref
    mov %eax, -56(%esp)  # arg f195884
# emit-expr f195885
# emit-variable-ref
# env=((f195886 . -36) (f195885 . -32) (f195884 . -28) (f195883 . -24) (f195886 . -20) (f195885 . -16) (f195884 . -12) (f195883 . -8) (f195867 . 8) (f195868 . 4) (f195866 . -12) (f195867 . -8) (f195868 . -4) (f195869 . 0))
# var=f195885
    movl -32(%esp), %eax  # stack load f195885
# end emit-variable-ref
    mov %eax, -60(%esp)  # arg f195885
    movl -48(%esp), %edi   # load new closure to %edi
    add $-40, %esp   # adjust base
    movl $12,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $40, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    cmp $47, %al
    je _L_1423685
# emit-tail-expr
# si=-40
# env=((f195886 . -36) (f195885 . -32) (f195884 . -28) (f195883 . -24) (f195886 . -20) (f195885 . -16) (f195884 . -12) (f195883 . -8) (f195867 . 8) (f195868 . 4) (f195866 . -12) (f195867 . -8) (f195868 . -4) (f195869 . 0))
# expr=((vector-ref f195867 0) f195883 f195884 (fx+ f195885 1) f195886)
# emit-tail-funcall
#    si   =-40
#    env  = ((f195886 . -36) (f195885 . -32) (f195884 . -28) (f195883 . -24) (f195886 . -20) (f195885 . -16) (f195884 . -12) (f195883 . -8) (f195867 . 8) (f195868 . 4) (f195866 . -12) (f195867 . -8) (f195868 . -4) (f195869 . 0))
#    expr = (funcall (vector-ref f195867 0) f195883 f195884 (fx+ f195885 1) f195886)
# emit-expr (vector-ref f195867 0)
# emit-expr f195867
# emit-variable-ref
# env=((f195886 . -36) (f195885 . -32) (f195884 . -28) (f195883 . -24) (f195886 . -20) (f195885 . -16) (f195884 . -12) (f195883 . -8) (f195867 . 8) (f195868 . 4) (f195866 . -12) (f195867 . -8) (f195868 . -4) (f195869 . 0))
# var=f195867
    movl 6(%edi), %eax  # frame load f195867
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1423692
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1423692:
    movl %eax, -40(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1423693"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1423693:
# check bounds on vector index
    movl -40(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1423695
    cmp  $0,%eax
    jge _L_1423694
_L_1423695:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1423694:
    movl -40(%esp), %esi
    movl -1(%eax,%esi), %eax
   movl %eax,  -40(%esp)  # stash funcall-oper in next closure slot
# emit-expr f195883
# emit-variable-ref
# env=((f195886 . -36) (f195885 . -32) (f195884 . -28) (f195883 . -24) (f195886 . -20) (f195885 . -16) (f195884 . -12) (f195883 . -8) (f195867 . 8) (f195868 . 4) (f195866 . -12) (f195867 . -8) (f195868 . -4) (f195869 . 0))
# var=f195883
    movl -24(%esp), %eax  # stack load f195883
# end emit-variable-ref
    mov %eax, -44(%esp)    # arg f195883
# emit-expr f195884
# emit-variable-ref
# env=((f195886 . -36) (f195885 . -32) (f195884 . -28) (f195883 . -24) (f195886 . -20) (f195885 . -16) (f195884 . -12) (f195883 . -8) (f195867 . 8) (f195868 . 4) (f195866 . -12) (f195867 . -8) (f195868 . -4) (f195869 . 0))
# var=f195884
    movl -28(%esp), %eax  # stack load f195884
# end emit-variable-ref
    mov %eax, -48(%esp)    # arg f195884
# emit-expr (fx+ f195885 1)
# emit-expr 1
    movl $4, %eax     # immed 1
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1423696"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $80,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1423696:
    movl %eax, -52(%esp)  # fx+ push arg1
# emit-expr f195885
# emit-variable-ref
# env=((f195886 . -36) (f195885 . -32) (f195884 . -28) (f195883 . -24) (f195886 . -20) (f195885 . -16) (f195884 . -12) (f195883 . -8) (f195867 . 8) (f195868 . 4) (f195866 . -12) (f195867 . -8) (f195868 . -4) (f195869 . 0))
# var=f195885
    movl -32(%esp), %eax  # stack load f195885
# end emit-variable-ref
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1423697"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $80,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1423697:
    addl -52(%esp), %eax  # fx+ arg1 arg2
    mov %eax, -52(%esp)    # arg (fx+ f195885 1)
# emit-expr f195886
# emit-variable-ref
# env=((f195886 . -36) (f195885 . -32) (f195884 . -28) (f195883 . -24) (f195886 . -20) (f195885 . -16) (f195884 . -12) (f195883 . -8) (f195867 . 8) (f195868 . 4) (f195866 . -12) (f195867 . -8) (f195868 . -4) (f195869 . 0))
# var=f195886
    movl -36(%esp), %eax  # stack load f195886
# end emit-variable-ref
    mov %eax, -56(%esp)    # arg f195886
    movl -40(%esp), %edi   # load new closure to %edi
# emit-shift-args:  size=5   si=-40  delta=36
    mov -40(%esp), %ebx  # shift frame cell
    mov %ebx, -4(%esp)  # down to base
# emit-shift-args:  size=4   si=-44  delta=36
    mov -44(%esp), %ebx  # shift frame cell
    mov %ebx, -8(%esp)  # down to base
# emit-shift-args:  size=3   si=-48  delta=36
    mov -48(%esp), %ebx  # shift frame cell
    mov %ebx, -12(%esp)  # down to base
# emit-shift-args:  size=2   si=-52  delta=36
    mov -52(%esp), %ebx  # shift frame cell
    mov %ebx, -16(%esp)  # down to base
# emit-shift-args:  size=1   si=-56  delta=36
    mov -56(%esp), %ebx  # shift frame cell
    mov %ebx, -20(%esp)  # down to base
# emit-shift-args:  size=0   si=-60  delta=36
    movl $16,%eax   # save arg count
    jmp *-2(%edi)  # tail-funcall
    jmp _L_1423686
_L_1423685:
# emit-tail-expr
# si=-40
# env=((f195886 . -36) (f195885 . -32) (f195884 . -28) (f195883 . -24) (f195886 . -20) (f195885 . -16) (f195884 . -12) (f195883 . -8) (f195867 . 8) (f195868 . 4) (f195866 . -12) (f195867 . -8) (f195868 . -4) (f195869 . 0))
# expr=#f
    movl $47, %eax     # immed #f
    ret                  # immediate tail return
_L_1423686:
_L_1423682:
    .align 4,0x90
_L_1423679:
    movl -16(%esp), %ebx
    movl -20(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin (vector-set! f195866 0 (closure (f195881 f195882) (f195869 f195867) (let ((f195881 f195881) (f195882 f195882)) (if ((vector-ref f195869 0) f195881 f195882) ((vector-ref f195867 0) f195881 f195882 0 (string-length f195881)) #f)))))
# emit-begin
#   expr=(begin (vector-set! f195866 0 (closure (f195881 f195882) (f195869 f195867) (let ((f195881 f195881) (f195882 f195882)) (if ((vector-ref f195869 0) f195881 f195882) ((vector-ref f195867 0) f195881 f195882 0 (string-length f195881)) #f)))))
#   env=((f195866 . -12) (f195867 . -8) (f195868 . -4) (f195869 . 0))
# emit-expr (vector-set! f195866 0 (closure (f195881 f195882) (f195869 f195867) (let ((f195881 f195881) (f195882 f195882)) (if ((vector-ref f195869 0) f195881 f195882) ((vector-ref f195867 0) f195881 f195882 0 (string-length f195881)) #f))))
# emit-expr f195866
# emit-variable-ref
# env=((f195866 . -12) (f195867 . -8) (f195868 . -4) (f195869 . 0))
# var=f195866
    movl -12(%esp), %eax  # stack load f195866
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1423698
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1423698:
    movl %eax, -16(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1423699"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1423699:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1423701
    cmp  $0,%eax
    jge _L_1423700
_L_1423701:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1423700:
    movl %eax, -20(%esp)
# emit-expr (closure (f195881 f195882) (f195869 f195867) (let ((f195881 f195881) (f195882 f195882)) (if ((vector-ref f195869 0) f195881 f195882) ((vector-ref f195867 0) f195881 f195882 0 (string-length f195881)) #f)))
# emit-closure
# si = -24
# env = ((f195866 . -12) (f195867 . -8) (f195868 . -4) (f195869 . 0))
# expr = (closure (f195881 f195882) (f195869 f195867) (let ((f195881 f195881) (f195882 f195882)) (if ((vector-ref f195869 0) f195881 f195882) ((vector-ref f195867 0) f195881 f195882 0 (string-length f195881)) #f)))
    movl $_L_1423702, 0(%ebp)  # closure label
# emit-variable-ref
# env=((f195866 . -12) (f195867 . -8) (f195868 . -4) (f195869 . 0))
# var=f195869
    movl 0(%esp), %eax  # stack load f195869
# end emit-variable-ref
   movl  %eax, 4(%ebp)  # f195869
# emit-variable-ref
# env=((f195866 . -12) (f195867 . -8) (f195868 . -4) (f195869 . 0))
# var=f195867
    movl -8(%esp), %eax  # stack load f195867
# end emit-variable-ref
   movl  %eax, 8(%ebp)  # f195867
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $16, %ebp     # bump ebp
    jmp _L_1423703            # jump around closure body
_L_1423702:
# check argument count
    cmp $8,%eax
    je _L_1423704
# invoke error handler eh_argcount
    .extern mrc_eh$uargcount
    movl mrc_eh$uargcount, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_1423704:
# emit-tail-expr
# si=-16
# env=((f195882 . -12) (f195881 . -8) (f195867 . 8) (f195869 . 4) (f195866 . -12) (f195867 . -8) (f195868 . -4) (f195869 . 0))
# expr=(let ((f195881 f195881) (f195882 f195882)) (if ((vector-ref f195869 0) f195881 f195882) ((vector-ref f195867 0) f195881 f195882 0 (string-length f195881)) #f))
# emit-tail-let
#  si   = -16
#  env  = ((f195882 . -12) (f195881 . -8) (f195867 . 8) (f195869 . 4) (f195866 . -12) (f195867 . -8) (f195868 . -4) (f195869 . 0))
#  bindings = ((f195881 f195881) (f195882 f195882))
#  body = (if ((vector-ref f195869 0) f195881 f195882) ((vector-ref f195867 0) f195881 f195882 0 (string-length f195881)) #f)
# emit-expr f195881
# emit-variable-ref
# env=((f195882 . -12) (f195881 . -8) (f195867 . 8) (f195869 . 4) (f195866 . -12) (f195867 . -8) (f195868 . -4) (f195869 . 0))
# var=f195881
    movl -8(%esp), %eax  # stack load f195881
# end emit-variable-ref
    movl %eax, -16(%esp)  # stack save
# emit-expr f195882
# emit-variable-ref
# env=((f195882 . -12) (f195881 . -8) (f195867 . 8) (f195869 . 4) (f195866 . -12) (f195867 . -8) (f195868 . -4) (f195869 . 0))
# var=f195882
    movl -12(%esp), %eax  # stack load f195882
# end emit-variable-ref
    movl %eax, -20(%esp)  # stack save
# emit-tail-expr
# si=-24
# env=((f195882 . -20) (f195881 . -16) (f195882 . -12) (f195881 . -8) (f195867 . 8) (f195869 . 4) (f195866 . -12) (f195867 . -8) (f195868 . -4) (f195869 . 0))
# expr=(if ((vector-ref f195869 0) f195881 f195882) ((vector-ref f195867 0) f195881 f195882 0 (string-length f195881)) #f)
# emit-expr ((vector-ref f195869 0) f195881 f195882)
# funcall
#    si   =-24
#    env  = ((f195882 . -20) (f195881 . -16) (f195882 . -12) (f195881 . -8) (f195867 . 8) (f195869 . 4) (f195866 . -12) (f195867 . -8) (f195868 . -4) (f195869 . 0))
#    expr = (funcall (vector-ref f195869 0) f195881 f195882)
# emit-expr (vector-ref f195869 0)
# emit-expr f195869
# emit-variable-ref
# env=((f195882 . -20) (f195881 . -16) (f195882 . -12) (f195881 . -8) (f195867 . 8) (f195869 . 4) (f195866 . -12) (f195867 . -8) (f195868 . -4) (f195869 . 0))
# var=f195869
    movl 2(%edi), %eax  # frame load f195869
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1423707
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1423707:
    movl %eax, -32(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1423708"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1423708:
# check bounds on vector index
    movl -32(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1423710
    cmp  $0,%eax
    jge _L_1423709
_L_1423710:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1423709:
    movl -32(%esp), %esi
    movl -1(%eax,%esi), %eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1423711"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1423711":
   movl %eax,  -32(%esp)  # stash funcall-oper in closure slot
# emit-expr f195881
# emit-variable-ref
# env=((f195882 . -20) (f195881 . -16) (f195882 . -12) (f195881 . -8) (f195867 . 8) (f195869 . 4) (f195866 . -12) (f195867 . -8) (f195868 . -4) (f195869 . 0))
# var=f195881
    movl -16(%esp), %eax  # stack load f195881
# end emit-variable-ref
    mov %eax, -36(%esp)  # arg f195881
# emit-expr f195882
# emit-variable-ref
# env=((f195882 . -20) (f195881 . -16) (f195882 . -12) (f195881 . -8) (f195867 . 8) (f195869 . 4) (f195866 . -12) (f195867 . -8) (f195868 . -4) (f195869 . 0))
# var=f195882
    movl -20(%esp), %eax  # stack load f195882
# end emit-variable-ref
    mov %eax, -40(%esp)  # arg f195882
    movl -32(%esp), %edi   # load new closure to %edi
    add $-24, %esp   # adjust base
    movl $8,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $24, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    cmp $47, %al
    je _L_1423705
# emit-tail-expr
# si=-24
# env=((f195882 . -20) (f195881 . -16) (f195882 . -12) (f195881 . -8) (f195867 . 8) (f195869 . 4) (f195866 . -12) (f195867 . -8) (f195868 . -4) (f195869 . 0))
# expr=((vector-ref f195867 0) f195881 f195882 0 (string-length f195881))
# emit-tail-funcall
#    si   =-24
#    env  = ((f195882 . -20) (f195881 . -16) (f195882 . -12) (f195881 . -8) (f195867 . 8) (f195869 . 4) (f195866 . -12) (f195867 . -8) (f195868 . -4) (f195869 . 0))
#    expr = (funcall (vector-ref f195867 0) f195881 f195882 0 (string-length f195881))
# emit-expr (vector-ref f195867 0)
# emit-expr f195867
# emit-variable-ref
# env=((f195882 . -20) (f195881 . -16) (f195882 . -12) (f195881 . -8) (f195867 . 8) (f195869 . 4) (f195866 . -12) (f195867 . -8) (f195868 . -4) (f195869 . 0))
# var=f195867
    movl 6(%edi), %eax  # frame load f195867
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1423712
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1423712:
    movl %eax, -24(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1423713"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1423713:
# check bounds on vector index
    movl -24(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1423715
    cmp  $0,%eax
    jge _L_1423714
_L_1423715:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1423714:
    movl -24(%esp), %esi
    movl -1(%eax,%esi), %eax
   movl %eax,  -24(%esp)  # stash funcall-oper in next closure slot
# emit-expr f195881
# emit-variable-ref
# env=((f195882 . -20) (f195881 . -16) (f195882 . -12) (f195881 . -8) (f195867 . 8) (f195869 . 4) (f195866 . -12) (f195867 . -8) (f195868 . -4) (f195869 . 0))
# var=f195881
    movl -16(%esp), %eax  # stack load f195881
# end emit-variable-ref
    mov %eax, -28(%esp)    # arg f195881
# emit-expr f195882
# emit-variable-ref
# env=((f195882 . -20) (f195881 . -16) (f195882 . -12) (f195881 . -8) (f195867 . 8) (f195869 . 4) (f195866 . -12) (f195867 . -8) (f195868 . -4) (f195869 . 0))
# var=f195882
    movl -20(%esp), %eax  # stack load f195882
# end emit-variable-ref
    mov %eax, -32(%esp)    # arg f195882
# emit-expr 0
    movl $0, %eax     # immed 0
    mov %eax, -36(%esp)    # arg 0
# emit-expr (string-length f195881)
# emit-expr f195881
# emit-variable-ref
# env=((f195882 . -20) (f195881 . -16) (f195882 . -12) (f195881 . -8) (f195867 . 8) (f195869 . 4) (f195866 . -12) (f195867 . -8) (f195868 . -4) (f195869 . 0))
# var=f195881
    movl -16(%esp), %eax  # stack load f195881
# end emit-variable-ref
# check the argument is a string
    movl %eax,%ebx
    and $7, %bl
    cmp $6, %bl
    je _L_1423716
# invoke error handler eh_string
    .extern mrc_eh$ustring
    movl mrc_eh$ustring, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $152,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1423716:
    movl -6(%eax), %eax
    mov %eax, -40(%esp)    # arg (string-length f195881)
    movl -24(%esp), %edi   # load new closure to %edi
# emit-shift-args:  size=5   si=-24  delta=20
    mov -24(%esp), %ebx  # shift frame cell
    mov %ebx, -4(%esp)  # down to base
# emit-shift-args:  size=4   si=-28  delta=20
    mov -28(%esp), %ebx  # shift frame cell
    mov %ebx, -8(%esp)  # down to base
# emit-shift-args:  size=3   si=-32  delta=20
    mov -32(%esp), %ebx  # shift frame cell
    mov %ebx, -12(%esp)  # down to base
# emit-shift-args:  size=2   si=-36  delta=20
    mov -36(%esp), %ebx  # shift frame cell
    mov %ebx, -16(%esp)  # down to base
# emit-shift-args:  size=1   si=-40  delta=20
    mov -40(%esp), %ebx  # shift frame cell
    mov %ebx, -20(%esp)  # down to base
# emit-shift-args:  size=0   si=-44  delta=20
    movl $16,%eax   # save arg count
    jmp *-2(%edi)  # tail-funcall
    jmp _L_1423706
_L_1423705:
# emit-tail-expr
# si=-24
# env=((f195882 . -20) (f195881 . -16) (f195882 . -12) (f195881 . -8) (f195867 . 8) (f195869 . 4) (f195866 . -12) (f195867 . -8) (f195868 . -4) (f195869 . 0))
# expr=#f
    movl $47, %eax     # immed #f
    ret                  # immediate tail return
_L_1423706:
    .align 4,0x90
_L_1423703:
    movl -16(%esp), %ebx
    movl -20(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin)
# emit-begin
#   expr=(begin)
#   env=((f195866 . -12) (f195867 . -8) (f195868 . -4) (f195869 . 0))
# emit-expr (begin (vector-ref f195866 0))
# emit-begin
#   expr=(begin (vector-ref f195866 0))
#   env=((f195866 . -12) (f195867 . -8) (f195868 . -4) (f195869 . 0))
# emit-expr (vector-ref f195866 0)
# emit-expr f195866
# emit-variable-ref
# env=((f195866 . -12) (f195867 . -8) (f195868 . -4) (f195869 . 0))
# var=f195866
    movl -12(%esp), %eax  # stack load f195866
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1423717
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1423717:
    movl %eax, -16(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1423718"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1423718:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1423720
    cmp  $0,%eax
    jge _L_1423719
_L_1423720:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1423719:
    movl -16(%esp), %esi
    movl -1(%eax,%esi), %eax
# emit-expr (begin)
# emit-begin
#   expr=(begin)
#   env=((f195866 . -12) (f195867 . -8) (f195868 . -4) (f195869 . 0))
     movl %eax, mrc_string$e$q
# == explicit-begins  ==>
# (letrec ((str->sym (lambda (str symlist) (if (string=? str (symbol->string (car symlist))) (car symlist) (if (null? (cdr symlist)) (let* ((new-sym (make-symbol str #f)) (new-cdr (cons new-sym ()))) (begin (set-cdr! symlist new-cdr) new-sym)) (str->sym str (cdr symlist))))))) (lambda (str) (str->sym str (symbols))))
# == eliminate-let*  ==>
# (letrec ((str->sym (lambda (str symlist) (if (string=? str (symbol->string (car symlist))) (car symlist) (if (null? (cdr symlist)) (let ((new-sym (make-symbol str #f))) (let ((new-cdr (cons new-sym ()))) (begin (set-cdr! symlist new-cdr) new-sym))) (str->sym str (cdr symlist))))))) (lambda (str) (str->sym str (symbols))))
# == uniquify-variables  ==>
# (letrec ((f195892 (lambda (f195901 f195902) (if (string=? f195901 (symbol->string (car f195902))) (car f195902) (if (null? (cdr f195902)) (let ((f195906 (make-symbol f195901 #f))) (let ((f195908 (cons f195906 ()))) (begin (set-cdr! f195902 f195908) f195906))) (f195892 f195901 (cdr f195902))))))) (lambda (f195910) (f195892 f195910 (symbols))))
# == vectorize-letrec  ==>
# (let ((f195892 (make-vector 1))) (begin (begin (vector-set! f195892 0 (lambda (f195901 f195902) (if (string=? f195901 (symbol->string (car f195902))) (car f195902) (if (null? (cdr f195902)) (let ((f195906 (make-symbol f195901 #f))) (let ((f195908 (cons f195906 ()))) (begin (set-cdr! f195902 f195908) f195906))) ((vector-ref f195892 0) f195901 (cdr f195902))))))) (lambda (f195910) ((vector-ref f195892 0) f195910 (symbols)))))
# == eliminate-set!  ==>
# (let ((f195892 (make-vector 1))) (begin (begin (vector-set! f195892 0 (lambda (f195901 f195902) (let ((f195901 f195901) (f195902 f195902)) (if (string=? f195901 (symbol->string (car f195902))) (car f195902) (if (null? (cdr f195902)) (let ((f195906 (make-symbol f195901 #f))) (let ((f195908 (cons f195906 ()))) (begin (set-cdr! f195902 f195908) f195906))) ((vector-ref f195892 0) f195901 (cdr f195902)))))))) (lambda (f195910) (let ((f195910 f195910)) ((vector-ref f195892 0) f195910 (symbols))))))
# == close-free-variables  ==>
# (let ((f195892 (make-vector 1))) (begin (begin (vector-set! f195892 0 (closure (f195901 f195902) (string=? f195892) (let ((f195901 f195901) (f195902 f195902)) (if (string=? f195901 (symbol->string (car f195902))) (car f195902) (if (null? (cdr f195902)) (let ((f195906 (make-symbol f195901 #f))) (let ((f195908 (cons f195906 ()))) (begin (set-cdr! f195902 f195908) f195906))) ((vector-ref f195892 0) f195901 (cdr f195902)))))))) (closure (f195910) (f195892 symbols) (let ((f195910 f195910)) ((vector-ref f195892 0) f195910 (symbols))))))
# == eliminate-quote  ==>
# (let ((f195892 (make-vector 1))) (begin (begin (vector-set! f195892 0 (closure (f195901 f195902) (string=? f195892) (let ((f195901 f195901) (f195902 f195902)) (if (string=? f195901 (symbol->string (car f195902))) (car f195902) (if (null? (cdr f195902)) (let ((f195906 (make-symbol f195901 #f))) (let ((f195908 (cons f195906 ()))) (begin (set-cdr! f195902 f195908) f195906))) ((vector-ref f195892 0) f195901 (cdr f195902)))))))) (closure (f195910) (f195892 symbols) (let ((f195910 f195910)) ((vector-ref f195892 0) f195910 (symbols))))))
# == eliminate-when/unless  ==>
# (let ((f195892 (make-vector 1))) (begin (begin (vector-set! f195892 0 (closure (f195901 f195902) (string=? f195892) (let ((f195901 f195901) (f195902 f195902)) (if (string=? f195901 (symbol->string (car f195902))) (car f195902) (if (null? (cdr f195902)) (let ((f195906 (make-symbol f195901 #f))) (let ((f195908 (cons f195906 ()))) (begin (set-cdr! f195902 f195908) f195906))) ((vector-ref f195892 0) f195901 (cdr f195902)))))))) (closure (f195910) (f195892 symbols) (let ((f195910 f195910)) ((vector-ref f195892 0) f195910 (symbols))))))
# == eliminate-cond  ==>
# (let ((f195892 (make-vector 1))) (begin (begin (vector-set! f195892 0 (closure (f195901 f195902) (string=? f195892) (let ((f195901 f195901) (f195902 f195902)) (if (string=? f195901 (symbol->string (car f195902))) (car f195902) (if (null? (cdr f195902)) (let ((f195906 (make-symbol f195901 #f))) (let ((f195908 (cons f195906 ()))) (begin (set-cdr! f195902 f195908) f195906))) ((vector-ref f195892 0) f195901 (cdr f195902)))))))) (closure (f195910) (f195892 symbols) (let ((f195910 f195910)) ((vector-ref f195892 0) f195910 (symbols))))))
# == external-symbols  ==>
# (let ((f195892 (make-vector 1))) (begin (begin (vector-set! f195892 0 (closure (f195901 f195902) ((primitive-ref string=?) f195892) (let ((f195901 f195901) (f195902 f195902)) (if ((primitive-ref string=?) f195901 (symbol->string (car f195902))) (car f195902) (if (null? (cdr f195902)) (let ((f195906 (make-symbol f195901 #f))) (let ((f195908 (cons f195906 ()))) (begin (set-cdr! f195902 f195908) f195906))) ((vector-ref f195892 0) f195901 (cdr f195902)))))))) (closure (f195910) (f195892 (primitive-ref symbols)) (let ((f195910 f195910)) ((vector-ref f195892 0) f195910 ((primitive-ref symbols)))))))
# emit-expr (let ((f195892 (make-vector 1))) (begin (begin (vector-set! f195892 0 (closure (f195901 f195902) ((primitive-ref string=?) f195892) (let ((f195901 f195901) (f195902 f195902)) (if ((primitive-ref string=?) f195901 (symbol->string (car f195902))) (car f195902) (if (null? (cdr f195902)) (let ((f195906 (make-symbol f195901 #f))) (let ((f195908 (cons f195906 ()))) (begin (set-cdr! f195902 f195908) f195906))) ((vector-ref f195892 0) f195901 (cdr f195902)))))))) (closure (f195910) (f195892 (primitive-ref symbols)) (let ((f195910 f195910)) ((vector-ref f195892 0) f195910 ((primitive-ref symbols)))))))
# emit-let
#  si   = 0
#  env  = ()
#  bindings = ((f195892 (make-vector 1)))
#  body = (begin (begin (vector-set! f195892 0 (closure (f195901 f195902) ((primitive-ref string=?) f195892) (let ((f195901 f195901) (f195902 f195902)) (if ((primitive-ref string=?) f195901 (symbol->string (car f195902))) (car f195902) (if (null? (cdr f195902)) (let ((f195906 (make-symbol f195901 #f))) (let ((f195908 (cons f195906 ()))) (begin (set-cdr! f195902 f195908) f195906))) ((vector-ref f195892 0) f195901 (cdr f195902)))))))) (closure (f195910) (f195892 (primitive-ref symbols)) (let ((f195910 f195910)) ((vector-ref f195892 0) f195910 ((primitive-ref symbols))))))
# emit-expr (make-vector 1)
# make-vector 1
# emit-expr 1
    movl $4, %eax     # immed 1
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1423721"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $128,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1423721:
# check the argument is a fixnum >= 0
    cmp $0,%eax
    jge _L_1423722
# invoke error handler eh_length
    .extern mrc_eh$ulength
    movl mrc_eh$ulength, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $128,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1423722:
    movl %eax, %esi
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    orl  $5, %eax
    addl $4, %esi
    addl $4, %esi
    andl $-8, %esi
    addl %esi, %ebp
    movl %eax, 0(%esp)  # stack save
# emit-expr (begin (begin (vector-set! f195892 0 (closure (f195901 f195902) ((primitive-ref string=?) f195892) (let ((f195901 f195901) (f195902 f195902)) (if ((primitive-ref string=?) f195901 (symbol->string (car f195902))) (car f195902) (if (null? (cdr f195902)) (let ((f195906 (make-symbol f195901 #f))) (let ((f195908 (cons f195906 ()))) (begin (set-cdr! f195902 f195908) f195906))) ((vector-ref f195892 0) f195901 (cdr f195902)))))))) (closure (f195910) (f195892 (primitive-ref symbols)) (let ((f195910 f195910)) ((vector-ref f195892 0) f195910 ((primitive-ref symbols))))))
# emit-begin
#   expr=(begin (begin (vector-set! f195892 0 (closure (f195901 f195902) ((primitive-ref string=?) f195892) (let ((f195901 f195901) (f195902 f195902)) (if ((primitive-ref string=?) f195901 (symbol->string (car f195902))) (car f195902) (if (null? (cdr f195902)) (let ((f195906 (make-symbol f195901 #f))) (let ((f195908 (cons f195906 ()))) (begin (set-cdr! f195902 f195908) f195906))) ((vector-ref f195892 0) f195901 (cdr f195902)))))))) (closure (f195910) (f195892 (primitive-ref symbols)) (let ((f195910 f195910)) ((vector-ref f195892 0) f195910 ((primitive-ref symbols))))))
#   env=((f195892 . 0))
# emit-expr (begin (vector-set! f195892 0 (closure (f195901 f195902) ((primitive-ref string=?) f195892) (let ((f195901 f195901) (f195902 f195902)) (if ((primitive-ref string=?) f195901 (symbol->string (car f195902))) (car f195902) (if (null? (cdr f195902)) (let ((f195906 (make-symbol f195901 #f))) (let ((f195908 (cons f195906 ()))) (begin (set-cdr! f195902 f195908) f195906))) ((vector-ref f195892 0) f195901 (cdr f195902))))))))
# emit-begin
#   expr=(begin (vector-set! f195892 0 (closure (f195901 f195902) ((primitive-ref string=?) f195892) (let ((f195901 f195901) (f195902 f195902)) (if ((primitive-ref string=?) f195901 (symbol->string (car f195902))) (car f195902) (if (null? (cdr f195902)) (let ((f195906 (make-symbol f195901 #f))) (let ((f195908 (cons f195906 ()))) (begin (set-cdr! f195902 f195908) f195906))) ((vector-ref f195892 0) f195901 (cdr f195902))))))))
#   env=((f195892 . 0))
# emit-expr (vector-set! f195892 0 (closure (f195901 f195902) ((primitive-ref string=?) f195892) (let ((f195901 f195901) (f195902 f195902)) (if ((primitive-ref string=?) f195901 (symbol->string (car f195902))) (car f195902) (if (null? (cdr f195902)) (let ((f195906 (make-symbol f195901 #f))) (let ((f195908 (cons f195906 ()))) (begin (set-cdr! f195902 f195908) f195906))) ((vector-ref f195892 0) f195901 (cdr f195902)))))))
# emit-expr f195892
# emit-variable-ref
# env=((f195892 . 0))
# var=f195892
    movl 0(%esp), %eax  # stack load f195892
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1423723
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1423723:
    movl %eax, -4(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1423724"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1423724:
# check bounds on vector index
    movl -4(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1423726
    cmp  $0,%eax
    jge _L_1423725
_L_1423726:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1423725:
    movl %eax, -8(%esp)
# emit-expr (closure (f195901 f195902) ((primitive-ref string=?) f195892) (let ((f195901 f195901) (f195902 f195902)) (if ((primitive-ref string=?) f195901 (symbol->string (car f195902))) (car f195902) (if (null? (cdr f195902)) (let ((f195906 (make-symbol f195901 #f))) (let ((f195908 (cons f195906 ()))) (begin (set-cdr! f195902 f195908) f195906))) ((vector-ref f195892 0) f195901 (cdr f195902))))))
# emit-closure
# si = -12
# env = ((f195892 . 0))
# expr = (closure (f195901 f195902) ((primitive-ref string=?) f195892) (let ((f195901 f195901) (f195902 f195902)) (if ((primitive-ref string=?) f195901 (symbol->string (car f195902))) (car f195902) (if (null? (cdr f195902)) (let ((f195906 (make-symbol f195901 #f))) (let ((f195908 (cons f195906 ()))) (begin (set-cdr! f195902 f195908) f195906))) ((vector-ref f195892 0) f195901 (cdr f195902))))))
    movl $_L_1423727, 0(%ebp)  # closure label
# WARNING: free var (primitive-ref string=?) not defined in the environmnet
# emit-variable-ref
# env=((f195892 . 0))
# var=f195892
    movl 0(%esp), %eax  # stack load f195892
# end emit-variable-ref
   movl  %eax, 8(%ebp)  # f195892
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $16, %ebp     # bump ebp
    jmp _L_1423728            # jump around closure body
_L_1423727:
# check argument count
    cmp $8,%eax
    je _L_1423729
# invoke error handler eh_argcount
    .extern mrc_eh$uargcount
    movl mrc_eh$uargcount, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_1423729:
# emit-tail-expr
# si=-16
# env=((f195902 . -12) (f195901 . -8) (f195892 . 8) ((primitive-ref string=?) . 4) (f195892 . 0))
# expr=(let ((f195901 f195901) (f195902 f195902)) (if ((primitive-ref string=?) f195901 (symbol->string (car f195902))) (car f195902) (if (null? (cdr f195902)) (let ((f195906 (make-symbol f195901 #f))) (let ((f195908 (cons f195906 ()))) (begin (set-cdr! f195902 f195908) f195906))) ((vector-ref f195892 0) f195901 (cdr f195902)))))
# emit-tail-let
#  si   = -16
#  env  = ((f195902 . -12) (f195901 . -8) (f195892 . 8) ((primitive-ref string=?) . 4) (f195892 . 0))
#  bindings = ((f195901 f195901) (f195902 f195902))
#  body = (if ((primitive-ref string=?) f195901 (symbol->string (car f195902))) (car f195902) (if (null? (cdr f195902)) (let ((f195906 (make-symbol f195901 #f))) (let ((f195908 (cons f195906 ()))) (begin (set-cdr! f195902 f195908) f195906))) ((vector-ref f195892 0) f195901 (cdr f195902))))
# emit-expr f195901
# emit-variable-ref
# env=((f195902 . -12) (f195901 . -8) (f195892 . 8) ((primitive-ref string=?) . 4) (f195892 . 0))
# var=f195901
    movl -8(%esp), %eax  # stack load f195901
# end emit-variable-ref
    movl %eax, -16(%esp)  # stack save
# emit-expr f195902
# emit-variable-ref
# env=((f195902 . -12) (f195901 . -8) (f195892 . 8) ((primitive-ref string=?) . 4) (f195892 . 0))
# var=f195902
    movl -12(%esp), %eax  # stack load f195902
# end emit-variable-ref
    movl %eax, -20(%esp)  # stack save
# emit-tail-expr
# si=-24
# env=((f195902 . -20) (f195901 . -16) (f195902 . -12) (f195901 . -8) (f195892 . 8) ((primitive-ref string=?) . 4) (f195892 . 0))
# expr=(if ((primitive-ref string=?) f195901 (symbol->string (car f195902))) (car f195902) (if (null? (cdr f195902)) (let ((f195906 (make-symbol f195901 #f))) (let ((f195908 (cons f195906 ()))) (begin (set-cdr! f195902 f195908) f195906))) ((vector-ref f195892 0) f195901 (cdr f195902))))
# emit-expr ((primitive-ref string=?) f195901 (symbol->string (car f195902)))
# funcall
#    si   =-24
#    env  = ((f195902 . -20) (f195901 . -16) (f195902 . -12) (f195901 . -8) (f195892 . 8) ((primitive-ref string=?) . 4) (f195892 . 0))
#    expr = (funcall (primitive-ref string=?) f195901 (symbol->string (car f195902)))
# emit-expr (primitive-ref string=?)
    .extern mrc_string$e$q
    movl mrc_string$e$q,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1423732"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1423732":
   movl %eax,  -32(%esp)  # stash funcall-oper in closure slot
# emit-expr f195901
# emit-variable-ref
# env=((f195902 . -20) (f195901 . -16) (f195902 . -12) (f195901 . -8) (f195892 . 8) ((primitive-ref string=?) . 4) (f195892 . 0))
# var=f195901
    movl -16(%esp), %eax  # stack load f195901
# end emit-variable-ref
    mov %eax, -36(%esp)  # arg f195901
# emit-expr (symbol->string (car f195902))
# symbol->string (car f195902)
# emit-expr (car f195902)
# emit-expr f195902
# emit-variable-ref
# env=((f195902 . -20) (f195901 . -16) (f195902 . -12) (f195901 . -8) (f195892 . 8) ((primitive-ref string=?) . 4) (f195892 . 0))
# var=f195902
    movl -20(%esp), %eax  # stack load f195902
# end emit-variable-ref
# check the argument is a pair
    movl %eax,%ebx
    and $7, %bl
    cmp $1, %bl
    je _L_1423733
# invoke error handler eh_pair
    .extern mrc_eh$upair
    movl mrc_eh$upair, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $108,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1423733:
    movl -1(%eax), %eax
    movl -3(%eax), %eax
    mov %eax, -40(%esp)  # arg (symbol->string (car f195902))
    movl -32(%esp), %edi   # load new closure to %edi
    add $-24, %esp   # adjust base
    movl $8,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $24, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    cmp $47, %al
    je _L_1423730
# emit-tail-expr
# si=-24
# env=((f195902 . -20) (f195901 . -16) (f195902 . -12) (f195901 . -8) (f195892 . 8) ((primitive-ref string=?) . 4) (f195892 . 0))
# expr=(car f195902)
# tail primcall
# emit-expr f195902
# emit-variable-ref
# env=((f195902 . -20) (f195901 . -16) (f195902 . -12) (f195901 . -8) (f195892 . 8) ((primitive-ref string=?) . 4) (f195892 . 0))
# var=f195902
    movl -20(%esp), %eax  # stack load f195902
# end emit-variable-ref
# check the argument is a pair
    movl %eax,%ebx
    and $7, %bl
    cmp $1, %bl
    je _L_1423734
# invoke error handler eh_pair
    .extern mrc_eh$upair
    movl mrc_eh$upair, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $108,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1423734:
    movl -1(%eax), %eax
#return from tail (car f195902)
    ret
    jmp _L_1423731
_L_1423730:
# emit-tail-expr
# si=-24
# env=((f195902 . -20) (f195901 . -16) (f195902 . -12) (f195901 . -8) (f195892 . 8) ((primitive-ref string=?) . 4) (f195892 . 0))
# expr=(if (null? (cdr f195902)) (let ((f195906 (make-symbol f195901 #f))) (let ((f195908 (cons f195906 ()))) (begin (set-cdr! f195902 f195908) f195906))) ((vector-ref f195892 0) f195901 (cdr f195902)))
# emit-expr (null? (cdr f195902))
# emit-expr (cdr f195902)
# emit-expr f195902
# emit-variable-ref
# env=((f195902 . -20) (f195901 . -16) (f195902 . -12) (f195901 . -8) (f195892 . 8) ((primitive-ref string=?) . 4) (f195892 . 0))
# var=f195902
    movl -20(%esp), %eax  # stack load f195902
# end emit-variable-ref
# check the argument is a pair
    movl %eax,%ebx
    and $7, %bl
    cmp $1, %bl
    je _L_1423737
# invoke error handler eh_pair
    .extern mrc_eh$upair
    movl mrc_eh$upair, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $112,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1423737:
    movl 3(%eax), %eax
    cmp $63, %eax
    mov $0, %eax
    sete %al
    movzbl %al, %eax
    sal $6, %al
    or $47, %al
    cmp $47, %al
    je _L_1423735
# emit-tail-expr
# si=-24
# env=((f195902 . -20) (f195901 . -16) (f195902 . -12) (f195901 . -8) (f195892 . 8) ((primitive-ref string=?) . 4) (f195892 . 0))
# expr=(let ((f195906 (make-symbol f195901 #f))) (let ((f195908 (cons f195906 ()))) (begin (set-cdr! f195902 f195908) f195906)))
# emit-tail-let
#  si   = -24
#  env  = ((f195902 . -20) (f195901 . -16) (f195902 . -12) (f195901 . -8) (f195892 . 8) ((primitive-ref string=?) . 4) (f195892 . 0))
#  bindings = ((f195906 (make-symbol f195901 #f)))
#  body = (let ((f195908 (cons f195906 ()))) (begin (set-cdr! f195902 f195908) f195906))
# emit-expr (make-symbol f195901 #f)
# make-symbol arg1=f195901 arg2=#f
# emit-expr f195901
# emit-variable-ref
# env=((f195902 . -20) (f195901 . -16) (f195902 . -12) (f195901 . -8) (f195892 . 8) ((primitive-ref string=?) . 4) (f195892 . 0))
# var=f195901
    movl -16(%esp), %eax  # stack load f195901
# end emit-variable-ref
    movl %eax, -24(%esp)
# emit-expr #f
    movl $47, %eax     # immed #f
    movl %eax, 4(%ebp)
    movl -24(%esp), %eax
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    orl  $3, %eax
    add  $8, %ebp
# make-symbol end
    movl %eax, -24(%esp)  # stack save
# emit-tail-expr
# si=-28
# env=((f195906 . -24) (f195902 . -20) (f195901 . -16) (f195902 . -12) (f195901 . -8) (f195892 . 8) ((primitive-ref string=?) . 4) (f195892 . 0))
# expr=(let ((f195908 (cons f195906 ()))) (begin (set-cdr! f195902 f195908) f195906))
# emit-tail-let
#  si   = -28
#  env  = ((f195906 . -24) (f195902 . -20) (f195901 . -16) (f195902 . -12) (f195901 . -8) (f195892 . 8) ((primitive-ref string=?) . 4) (f195892 . 0))
#  bindings = ((f195908 (cons f195906 ())))
#  body = (begin (set-cdr! f195902 f195908) f195906)
# emit-expr (cons f195906 ())
# cons arg1=f195906 arg2=()
# emit-expr f195906
# emit-variable-ref
# env=((f195906 . -24) (f195902 . -20) (f195901 . -16) (f195902 . -12) (f195901 . -8) (f195892 . 8) ((primitive-ref string=?) . 4) (f195892 . 0))
# var=f195906
    movl -24(%esp), %eax  # stack load f195906
# end emit-variable-ref
    movl %eax, -28(%esp)
# emit-expr ()
    movl $63, %eax     # immed ()
    movl %eax, 4(%ebp)
    movl -28(%esp), %eax
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    or   $1, %al
    add  $8, %ebp
# cons end
    movl %eax, -28(%esp)  # stack save
# emit-tail-expr
# si=-32
# env=((f195908 . -28) (f195906 . -24) (f195902 . -20) (f195901 . -16) (f195902 . -12) (f195901 . -8) (f195892 . 8) ((primitive-ref string=?) . 4) (f195892 . 0))
# expr=(begin (set-cdr! f195902 f195908) f195906)
# tail-begin (begin (set-cdr! f195902 f195908) f195906)
#   env=((f195908 . -28) (f195906 . -24) (f195902 . -20) (f195901 . -16) (f195902 . -12) (f195901 . -8) (f195892 . 8) ((primitive-ref string=?) . 4) (f195892 . 0))
# emit-expr (set-cdr! f195902 f195908)
# emit-expr f195902
# emit-variable-ref
# env=((f195908 . -28) (f195906 . -24) (f195902 . -20) (f195901 . -16) (f195902 . -12) (f195901 . -8) (f195892 . 8) ((primitive-ref string=?) . 4) (f195892 . 0))
# var=f195902
    movl -20(%esp), %eax  # stack load f195902
# end emit-variable-ref
# check the argument is a pair
    movl %eax,%ebx
    and $7, %bl
    cmp $1, %bl
    je _L_1423738
# invoke error handler eh_pair
    .extern mrc_eh$upair
    movl mrc_eh$upair, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $120,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1423738:
    movl %eax, -32(%esp)
# emit-expr f195908
# emit-variable-ref
# env=((f195908 . -28) (f195906 . -24) (f195902 . -20) (f195901 . -16) (f195902 . -12) (f195901 . -8) (f195892 . 8) ((primitive-ref string=?) . 4) (f195892 . 0))
# var=f195908
    movl -28(%esp), %eax  # stack load f195908
# end emit-variable-ref
    movl -32(%esp), %ebx
    movl %eax, 3(%ebx)
# emit-tail-expr
# si=-32
# env=((f195908 . -28) (f195906 . -24) (f195902 . -20) (f195901 . -16) (f195902 . -12) (f195901 . -8) (f195892 . 8) ((primitive-ref string=?) . 4) (f195892 . 0))
# expr=(begin f195906)
# tail-begin (begin f195906)
#   env=((f195908 . -28) (f195906 . -24) (f195902 . -20) (f195901 . -16) (f195902 . -12) (f195901 . -8) (f195892 . 8) ((primitive-ref string=?) . 4) (f195892 . 0))
# emit-tail-expr
# si=-32
# env=((f195908 . -28) (f195906 . -24) (f195902 . -20) (f195901 . -16) (f195902 . -12) (f195901 . -8) (f195892 . 8) ((primitive-ref string=?) . 4) (f195892 . 0))
# expr=f195906
# emit-tail-variable-ref
# emit-variable-ref
# env=((f195908 . -28) (f195906 . -24) (f195902 . -20) (f195901 . -16) (f195902 . -12) (f195901 . -8) (f195892 . 8) ((primitive-ref string=?) . 4) (f195892 . 0))
# var=f195906
    movl -24(%esp), %eax  # stack load f195906
# end emit-variable-ref
    ret
# end emit-tail-variable ref
     ret   # return thru stack
    jmp _L_1423736
_L_1423735:
# emit-tail-expr
# si=-24
# env=((f195902 . -20) (f195901 . -16) (f195902 . -12) (f195901 . -8) (f195892 . 8) ((primitive-ref string=?) . 4) (f195892 . 0))
# expr=((vector-ref f195892 0) f195901 (cdr f195902))
# emit-tail-funcall
#    si   =-24
#    env  = ((f195902 . -20) (f195901 . -16) (f195902 . -12) (f195901 . -8) (f195892 . 8) ((primitive-ref string=?) . 4) (f195892 . 0))
#    expr = (funcall (vector-ref f195892 0) f195901 (cdr f195902))
# emit-expr (vector-ref f195892 0)
# emit-expr f195892
# emit-variable-ref
# env=((f195902 . -20) (f195901 . -16) (f195902 . -12) (f195901 . -8) (f195892 . 8) ((primitive-ref string=?) . 4) (f195892 . 0))
# var=f195892
    movl 6(%edi), %eax  # frame load f195892
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1423739
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1423739:
    movl %eax, -24(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1423740"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1423740:
# check bounds on vector index
    movl -24(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1423742
    cmp  $0,%eax
    jge _L_1423741
_L_1423742:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1423741:
    movl -24(%esp), %esi
    movl -1(%eax,%esi), %eax
   movl %eax,  -24(%esp)  # stash funcall-oper in next closure slot
# emit-expr f195901
# emit-variable-ref
# env=((f195902 . -20) (f195901 . -16) (f195902 . -12) (f195901 . -8) (f195892 . 8) ((primitive-ref string=?) . 4) (f195892 . 0))
# var=f195901
    movl -16(%esp), %eax  # stack load f195901
# end emit-variable-ref
    mov %eax, -28(%esp)    # arg f195901
# emit-expr (cdr f195902)
# emit-expr f195902
# emit-variable-ref
# env=((f195902 . -20) (f195901 . -16) (f195902 . -12) (f195901 . -8) (f195892 . 8) ((primitive-ref string=?) . 4) (f195892 . 0))
# var=f195902
    movl -20(%esp), %eax  # stack load f195902
# end emit-variable-ref
# check the argument is a pair
    movl %eax,%ebx
    and $7, %bl
    cmp $1, %bl
    je _L_1423743
# invoke error handler eh_pair
    .extern mrc_eh$upair
    movl mrc_eh$upair, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $112,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1423743:
    movl 3(%eax), %eax
    mov %eax, -32(%esp)    # arg (cdr f195902)
    movl -24(%esp), %edi   # load new closure to %edi
# emit-shift-args:  size=3   si=-24  delta=20
    mov -24(%esp), %ebx  # shift frame cell
    mov %ebx, -4(%esp)  # down to base
# emit-shift-args:  size=2   si=-28  delta=20
    mov -28(%esp), %ebx  # shift frame cell
    mov %ebx, -8(%esp)  # down to base
# emit-shift-args:  size=1   si=-32  delta=20
    mov -32(%esp), %ebx  # shift frame cell
    mov %ebx, -12(%esp)  # down to base
# emit-shift-args:  size=0   si=-36  delta=20
    movl $8,%eax   # save arg count
    jmp *-2(%edi)  # tail-funcall
_L_1423736:
_L_1423731:
    .align 4,0x90
_L_1423728:
    movl -4(%esp), %ebx
    movl -8(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin)
# emit-begin
#   expr=(begin)
#   env=((f195892 . 0))
# emit-expr (begin (closure (f195910) (f195892 (primitive-ref symbols)) (let ((f195910 f195910)) ((vector-ref f195892 0) f195910 ((primitive-ref symbols))))))
# emit-begin
#   expr=(begin (closure (f195910) (f195892 (primitive-ref symbols)) (let ((f195910 f195910)) ((vector-ref f195892 0) f195910 ((primitive-ref symbols))))))
#   env=((f195892 . 0))
# emit-expr (closure (f195910) (f195892 (primitive-ref symbols)) (let ((f195910 f195910)) ((vector-ref f195892 0) f195910 ((primitive-ref symbols)))))
# emit-closure
# si = -4
# env = ((f195892 . 0))
# expr = (closure (f195910) (f195892 (primitive-ref symbols)) (let ((f195910 f195910)) ((vector-ref f195892 0) f195910 ((primitive-ref symbols)))))
    movl $_L_1423744, 0(%ebp)  # closure label
# emit-variable-ref
# env=((f195892 . 0))
# var=f195892
    movl 0(%esp), %eax  # stack load f195892
# end emit-variable-ref
   movl  %eax, 4(%ebp)  # f195892
# WARNING: free var (primitive-ref symbols) not defined in the environmnet
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $16, %ebp     # bump ebp
    jmp _L_1423745            # jump around closure body
_L_1423744:
# check argument count
    cmp $4,%eax
    je _L_1423746
# invoke error handler eh_argcount
    .extern mrc_eh$uargcount
    movl mrc_eh$uargcount, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_1423746:
# emit-tail-expr
# si=-12
# env=((f195910 . -8) ((primitive-ref symbols) . 8) (f195892 . 4) (f195892 . 0))
# expr=(let ((f195910 f195910)) ((vector-ref f195892 0) f195910 ((primitive-ref symbols))))
# emit-tail-let
#  si   = -12
#  env  = ((f195910 . -8) ((primitive-ref symbols) . 8) (f195892 . 4) (f195892 . 0))
#  bindings = ((f195910 f195910))
#  body = ((vector-ref f195892 0) f195910 ((primitive-ref symbols)))
# emit-expr f195910
# emit-variable-ref
# env=((f195910 . -8) ((primitive-ref symbols) . 8) (f195892 . 4) (f195892 . 0))
# var=f195910
    movl -8(%esp), %eax  # stack load f195910
# end emit-variable-ref
    movl %eax, -12(%esp)  # stack save
# emit-tail-expr
# si=-16
# env=((f195910 . -12) (f195910 . -8) ((primitive-ref symbols) . 8) (f195892 . 4) (f195892 . 0))
# expr=((vector-ref f195892 0) f195910 ((primitive-ref symbols)))
# emit-tail-funcall
#    si   =-16
#    env  = ((f195910 . -12) (f195910 . -8) ((primitive-ref symbols) . 8) (f195892 . 4) (f195892 . 0))
#    expr = (funcall (vector-ref f195892 0) f195910 ((primitive-ref symbols)))
# emit-expr (vector-ref f195892 0)
# emit-expr f195892
# emit-variable-ref
# env=((f195910 . -12) (f195910 . -8) ((primitive-ref symbols) . 8) (f195892 . 4) (f195892 . 0))
# var=f195892
    movl 2(%edi), %eax  # frame load f195892
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1423747
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1423747:
    movl %eax, -16(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1423748"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1423748:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1423750
    cmp  $0,%eax
    jge _L_1423749
_L_1423750:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1423749:
    movl -16(%esp), %esi
    movl -1(%eax,%esi), %eax
   movl %eax,  -16(%esp)  # stash funcall-oper in next closure slot
# emit-expr f195910
# emit-variable-ref
# env=((f195910 . -12) (f195910 . -8) ((primitive-ref symbols) . 8) (f195892 . 4) (f195892 . 0))
# var=f195910
    movl -12(%esp), %eax  # stack load f195910
# end emit-variable-ref
    mov %eax, -20(%esp)    # arg f195910
# emit-expr ((primitive-ref symbols))
# funcall
#    si   =-24
#    env  = ((f195910 . -12) (f195910 . -8) ((primitive-ref symbols) . 8) (f195892 . 4) (f195892 . 0))
#    expr = (funcall (primitive-ref symbols))
# emit-expr (primitive-ref symbols)
    .extern mrc_symbols
    movl mrc_symbols,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1423751"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1423751":
   movl %eax,  -32(%esp)  # stash funcall-oper in closure slot
    movl -32(%esp), %edi   # load new closure to %edi
    add $-24, %esp   # adjust base
    movl $0,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $24, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    mov %eax, -24(%esp)    # arg ((primitive-ref symbols))
    movl -16(%esp), %edi   # load new closure to %edi
# emit-shift-args:  size=3   si=-16  delta=12
    mov -16(%esp), %ebx  # shift frame cell
    mov %ebx, -4(%esp)  # down to base
# emit-shift-args:  size=2   si=-20  delta=12
    mov -20(%esp), %ebx  # shift frame cell
    mov %ebx, -8(%esp)  # down to base
# emit-shift-args:  size=1   si=-24  delta=12
    mov -24(%esp), %ebx  # shift frame cell
    mov %ebx, -12(%esp)  # down to base
# emit-shift-args:  size=0   si=-28  delta=12
    movl $8,%eax   # save arg count
    jmp *-2(%edi)  # tail-funcall
    .align 4,0x90
_L_1423745:
# emit-expr (begin)
# emit-begin
#   expr=(begin)
#   env=((f195892 . 0))
     movl %eax, mrc_string$m$gsymbol
# == explicit-begins  ==>
# (lambda (lst elt) (if (null? lst) (cons elt nil) (cons (car lst) (append1 (cdr lst) elt))))
# == eliminate-let*  ==>
# (lambda (lst elt) (if (null? lst) (cons elt nil) (cons (car lst) (append1 (cdr lst) elt))))
# == uniquify-variables  ==>
# (lambda (f195911 f195912) (if (null? f195911) (cons f195912 nil) (cons (car f195911) (append1 (cdr f195911) f195912))))
# == vectorize-letrec  ==>
# (lambda (f195911 f195912) (if (null? f195911) (cons f195912 nil) (cons (car f195911) (append1 (cdr f195911) f195912))))
# == eliminate-set!  ==>
# (lambda (f195911 f195912) (let ((f195911 f195911) (f195912 f195912)) (if (null? f195911) (cons f195912 nil) (cons (car f195911) (append1 (cdr f195911) f195912)))))
# == close-free-variables  ==>
# (closure (f195911 f195912) (nil append1) (let ((f195911 f195911) (f195912 f195912)) (if (null? f195911) (cons f195912 nil) (cons (car f195911) (append1 (cdr f195911) f195912)))))
# == eliminate-quote  ==>
# (closure (f195911 f195912) (nil append1) (let ((f195911 f195911) (f195912 f195912)) (if (null? f195911) (cons f195912 nil) (cons (car f195911) (append1 (cdr f195911) f195912)))))
# == eliminate-when/unless  ==>
# (closure (f195911 f195912) (nil append1) (let ((f195911 f195911) (f195912 f195912)) (if (null? f195911) (cons f195912 nil) (cons (car f195911) (append1 (cdr f195911) f195912)))))
# == eliminate-cond  ==>
# (closure (f195911 f195912) (nil append1) (let ((f195911 f195911) (f195912 f195912)) (if (null? f195911) (cons f195912 nil) (cons (car f195911) (append1 (cdr f195911) f195912)))))
# == external-symbols  ==>
# (closure (f195911 f195912) (nil (primitive-ref append1)) (let ((f195911 f195911) (f195912 f195912)) (if (null? f195911) (cons f195912 nil) (cons (car f195911) ((primitive-ref append1) (cdr f195911) f195912)))))
# emit-expr (closure (f195911 f195912) (nil (primitive-ref append1)) (let ((f195911 f195911) (f195912 f195912)) (if (null? f195911) (cons f195912 nil) (cons (car f195911) ((primitive-ref append1) (cdr f195911) f195912)))))
# emit-closure
# si = 0
# env = ()
# expr = (closure (f195911 f195912) (nil (primitive-ref append1)) (let ((f195911 f195911) (f195912 f195912)) (if (null? f195911) (cons f195912 nil) (cons (car f195911) ((primitive-ref append1) (cdr f195911) f195912)))))
    movl $_L_1423752, 0(%ebp)  # closure label
# WARNING: free var nil not defined in the environmnet
# WARNING: free var (primitive-ref append1) not defined in the environmnet
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $16, %ebp     # bump ebp
    jmp _L_1423753            # jump around closure body
_L_1423752:
# check argument count
    cmp $8,%eax
    je _L_1423754
# invoke error handler eh_argcount
    .extern mrc_eh$uargcount
    movl mrc_eh$uargcount, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_1423754:
# emit-tail-expr
# si=-16
# env=((f195912 . -12) (f195911 . -8) ((primitive-ref append1) . 8) (nil . 4))
# expr=(let ((f195911 f195911) (f195912 f195912)) (if (null? f195911) (cons f195912 nil) (cons (car f195911) ((primitive-ref append1) (cdr f195911) f195912))))
# emit-tail-let
#  si   = -16
#  env  = ((f195912 . -12) (f195911 . -8) ((primitive-ref append1) . 8) (nil . 4))
#  bindings = ((f195911 f195911) (f195912 f195912))
#  body = (if (null? f195911) (cons f195912 nil) (cons (car f195911) ((primitive-ref append1) (cdr f195911) f195912)))
# emit-expr f195911
# emit-variable-ref
# env=((f195912 . -12) (f195911 . -8) ((primitive-ref append1) . 8) (nil . 4))
# var=f195911
    movl -8(%esp), %eax  # stack load f195911
# end emit-variable-ref
    movl %eax, -16(%esp)  # stack save
# emit-expr f195912
# emit-variable-ref
# env=((f195912 . -12) (f195911 . -8) ((primitive-ref append1) . 8) (nil . 4))
# var=f195912
    movl -12(%esp), %eax  # stack load f195912
# end emit-variable-ref
    movl %eax, -20(%esp)  # stack save
# emit-tail-expr
# si=-24
# env=((f195912 . -20) (f195911 . -16) (f195912 . -12) (f195911 . -8) ((primitive-ref append1) . 8) (nil . 4))
# expr=(if (null? f195911) (cons f195912 nil) (cons (car f195911) ((primitive-ref append1) (cdr f195911) f195912)))
# emit-expr (null? f195911)
# emit-expr f195911
# emit-variable-ref
# env=((f195912 . -20) (f195911 . -16) (f195912 . -12) (f195911 . -8) ((primitive-ref append1) . 8) (nil . 4))
# var=f195911
    movl -16(%esp), %eax  # stack load f195911
# end emit-variable-ref
    cmp $63, %eax
    mov $0, %eax
    sete %al
    movzbl %al, %eax
    sal $6, %al
    or $47, %al
    cmp $47, %al
    je _L_1423755
# emit-tail-expr
# si=-24
# env=((f195912 . -20) (f195911 . -16) (f195912 . -12) (f195911 . -8) ((primitive-ref append1) . 8) (nil . 4))
# expr=(cons f195912 nil)
# tail primcall
# cons arg1=f195912 arg2=nil
# emit-expr f195912
# emit-variable-ref
# env=((f195912 . -20) (f195911 . -16) (f195912 . -12) (f195911 . -8) ((primitive-ref append1) . 8) (nil . 4))
# var=f195912
    movl -20(%esp), %eax  # stack load f195912
# end emit-variable-ref
    movl %eax, -24(%esp)
# emit-expr nil
# emit-variable-ref
# env=((f195912 . -20) (f195911 . -16) (f195912 . -12) (f195911 . -8) ((primitive-ref append1) . 8) (nil . 4))
# var=nil
    movl 2(%edi), %eax  # frame load nil
# end emit-variable-ref
    movl %eax, 4(%ebp)
    movl -24(%esp), %eax
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    or   $1, %al
    add  $8, %ebp
# cons end
#return from tail (cons f195912 nil)
    ret
    jmp _L_1423756
_L_1423755:
# emit-tail-expr
# si=-24
# env=((f195912 . -20) (f195911 . -16) (f195912 . -12) (f195911 . -8) ((primitive-ref append1) . 8) (nil . 4))
# expr=(cons (car f195911) ((primitive-ref append1) (cdr f195911) f195912))
# tail primcall
# cons arg1=(car f195911) arg2=((primitive-ref append1) (cdr f195911) f195912)
# emit-expr (car f195911)
# emit-expr f195911
# emit-variable-ref
# env=((f195912 . -20) (f195911 . -16) (f195912 . -12) (f195911 . -8) ((primitive-ref append1) . 8) (nil . 4))
# var=f195911
    movl -16(%esp), %eax  # stack load f195911
# end emit-variable-ref
# check the argument is a pair
    movl %eax,%ebx
    and $7, %bl
    cmp $1, %bl
    je _L_1423757
# invoke error handler eh_pair
    .extern mrc_eh$upair
    movl mrc_eh$upair, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $108,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1423757:
    movl -1(%eax), %eax
    movl %eax, -24(%esp)
# emit-expr ((primitive-ref append1) (cdr f195911) f195912)
# funcall
#    si   =-28
#    env  = ((f195912 . -20) (f195911 . -16) (f195912 . -12) (f195911 . -8) ((primitive-ref append1) . 8) (nil . 4))
#    expr = (funcall (primitive-ref append1) (cdr f195911) f195912)
# emit-expr (primitive-ref append1)
    .extern mrc_append1
    movl mrc_append1,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1423758"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1423758":
   movl %eax,  -36(%esp)  # stash funcall-oper in closure slot
# emit-expr (cdr f195911)
# emit-expr f195911
# emit-variable-ref
# env=((f195912 . -20) (f195911 . -16) (f195912 . -12) (f195911 . -8) ((primitive-ref append1) . 8) (nil . 4))
# var=f195911
    movl -16(%esp), %eax  # stack load f195911
# end emit-variable-ref
# check the argument is a pair
    movl %eax,%ebx
    and $7, %bl
    cmp $1, %bl
    je _L_1423759
# invoke error handler eh_pair
    .extern mrc_eh$upair
    movl mrc_eh$upair, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $112,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1423759:
    movl 3(%eax), %eax
    mov %eax, -40(%esp)  # arg (cdr f195911)
# emit-expr f195912
# emit-variable-ref
# env=((f195912 . -20) (f195911 . -16) (f195912 . -12) (f195911 . -8) ((primitive-ref append1) . 8) (nil . 4))
# var=f195912
    movl -20(%esp), %eax  # stack load f195912
# end emit-variable-ref
    mov %eax, -44(%esp)  # arg f195912
    movl -36(%esp), %edi   # load new closure to %edi
    add $-28, %esp   # adjust base
    movl $8,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $28, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    movl %eax, 4(%ebp)
    movl -24(%esp), %eax
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    or   $1, %al
    add  $8, %ebp
# cons end
#return from tail (cons (car f195911) ((primitive-ref append1) (cdr f195911) f195912))
    ret
_L_1423756:
    .align 4,0x90
_L_1423753:
     movl %eax, mrc_append1
# == explicit-begins  ==>
# (lambda (l k) (if (fx= k 0) (car l) (list-ref (cdr l) (fx- k 1))))
# == eliminate-let*  ==>
# (lambda (l k) (if (fx= k 0) (car l) (list-ref (cdr l) (fx- k 1))))
# == uniquify-variables  ==>
# (lambda (f195913 f195914) (if (fx= f195914 0) (car f195913) (list-ref (cdr f195913) (fx- f195914 1))))
# == vectorize-letrec  ==>
# (lambda (f195913 f195914) (if (fx= f195914 0) (car f195913) (list-ref (cdr f195913) (fx- f195914 1))))
# == eliminate-set!  ==>
# (lambda (f195913 f195914) (let ((f195913 f195913) (f195914 f195914)) (if (fx= f195914 0) (car f195913) (list-ref (cdr f195913) (fx- f195914 1)))))
# == close-free-variables  ==>
# (closure (f195913 f195914) (list-ref) (let ((f195913 f195913) (f195914 f195914)) (if (fx= f195914 0) (car f195913) (list-ref (cdr f195913) (fx- f195914 1)))))
# == eliminate-quote  ==>
# (closure (f195913 f195914) (list-ref) (let ((f195913 f195913) (f195914 f195914)) (if (fx= f195914 0) (car f195913) (list-ref (cdr f195913) (fx- f195914 1)))))
# == eliminate-when/unless  ==>
# (closure (f195913 f195914) (list-ref) (let ((f195913 f195913) (f195914 f195914)) (if (fx= f195914 0) (car f195913) (list-ref (cdr f195913) (fx- f195914 1)))))
# == eliminate-cond  ==>
# (closure (f195913 f195914) (list-ref) (let ((f195913 f195913) (f195914 f195914)) (if (fx= f195914 0) (car f195913) (list-ref (cdr f195913) (fx- f195914 1)))))
# == external-symbols  ==>
# (closure (f195913 f195914) ((primitive-ref list-ref)) (let ((f195913 f195913) (f195914 f195914)) (if (fx= f195914 0) (car f195913) ((primitive-ref list-ref) (cdr f195913) (fx- f195914 1)))))
# emit-expr (closure (f195913 f195914) ((primitive-ref list-ref)) (let ((f195913 f195913) (f195914 f195914)) (if (fx= f195914 0) (car f195913) ((primitive-ref list-ref) (cdr f195913) (fx- f195914 1)))))
# emit-closure
# si = 0
# env = ()
# expr = (closure (f195913 f195914) ((primitive-ref list-ref)) (let ((f195913 f195913) (f195914 f195914)) (if (fx= f195914 0) (car f195913) ((primitive-ref list-ref) (cdr f195913) (fx- f195914 1)))))
    movl $_L_1423760, 0(%ebp)  # closure label
# WARNING: free var (primitive-ref list-ref) not defined in the environmnet
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $8, %ebp     # bump ebp
    jmp _L_1423761            # jump around closure body
_L_1423760:
# check argument count
    cmp $8,%eax
    je _L_1423762
# invoke error handler eh_argcount
    .extern mrc_eh$uargcount
    movl mrc_eh$uargcount, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_1423762:
# emit-tail-expr
# si=-16
# env=((f195914 . -12) (f195913 . -8) ((primitive-ref list-ref) . 4))
# expr=(let ((f195913 f195913) (f195914 f195914)) (if (fx= f195914 0) (car f195913) ((primitive-ref list-ref) (cdr f195913) (fx- f195914 1))))
# emit-tail-let
#  si   = -16
#  env  = ((f195914 . -12) (f195913 . -8) ((primitive-ref list-ref) . 4))
#  bindings = ((f195913 f195913) (f195914 f195914))
#  body = (if (fx= f195914 0) (car f195913) ((primitive-ref list-ref) (cdr f195913) (fx- f195914 1)))
# emit-expr f195913
# emit-variable-ref
# env=((f195914 . -12) (f195913 . -8) ((primitive-ref list-ref) . 4))
# var=f195913
    movl -8(%esp), %eax  # stack load f195913
# end emit-variable-ref
    movl %eax, -16(%esp)  # stack save
# emit-expr f195914
# emit-variable-ref
# env=((f195914 . -12) (f195913 . -8) ((primitive-ref list-ref) . 4))
# var=f195914
    movl -12(%esp), %eax  # stack load f195914
# end emit-variable-ref
    movl %eax, -20(%esp)  # stack save
# emit-tail-expr
# si=-24
# env=((f195914 . -20) (f195913 . -16) (f195914 . -12) (f195913 . -8) ((primitive-ref list-ref) . 4))
# expr=(if (fx= f195914 0) (car f195913) ((primitive-ref list-ref) (cdr f195913) (fx- f195914 1)))
# emit-expr (fx= f195914 0)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1423765"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $60,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1423765:
    movl %eax, -24(%esp)
# emit-expr f195914
# emit-variable-ref
# env=((f195914 . -20) (f195913 . -16) (f195914 . -12) (f195913 . -8) ((primitive-ref list-ref) . 4))
# var=f195914
    movl -20(%esp), %eax  # stack load f195914
# end emit-variable-ref
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1423766"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $60,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1423766:
    cmp -24(%esp), %eax
    sete %al
    movzbl %al, %eax
    sal $6, %al
    or $47, %al
    cmp $47, %al
    je _L_1423763
# emit-tail-expr
# si=-24
# env=((f195914 . -20) (f195913 . -16) (f195914 . -12) (f195913 . -8) ((primitive-ref list-ref) . 4))
# expr=(car f195913)
# tail primcall
# emit-expr f195913
# emit-variable-ref
# env=((f195914 . -20) (f195913 . -16) (f195914 . -12) (f195913 . -8) ((primitive-ref list-ref) . 4))
# var=f195913
    movl -16(%esp), %eax  # stack load f195913
# end emit-variable-ref
# check the argument is a pair
    movl %eax,%ebx
    and $7, %bl
    cmp $1, %bl
    je _L_1423767
# invoke error handler eh_pair
    .extern mrc_eh$upair
    movl mrc_eh$upair, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $108,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1423767:
    movl -1(%eax), %eax
#return from tail (car f195913)
    ret
    jmp _L_1423764
_L_1423763:
# emit-tail-expr
# si=-24
# env=((f195914 . -20) (f195913 . -16) (f195914 . -12) (f195913 . -8) ((primitive-ref list-ref) . 4))
# expr=((primitive-ref list-ref) (cdr f195913) (fx- f195914 1))
# emit-tail-funcall
#    si   =-24
#    env  = ((f195914 . -20) (f195913 . -16) (f195914 . -12) (f195913 . -8) ((primitive-ref list-ref) . 4))
#    expr = (funcall (primitive-ref list-ref) (cdr f195913) (fx- f195914 1))
# emit-expr (primitive-ref list-ref)
    .extern mrc_list$mref
    movl mrc_list$mref,%eax
   movl %eax,  -24(%esp)  # stash funcall-oper in next closure slot
# emit-expr (cdr f195913)
# emit-expr f195913
# emit-variable-ref
# env=((f195914 . -20) (f195913 . -16) (f195914 . -12) (f195913 . -8) ((primitive-ref list-ref) . 4))
# var=f195913
    movl -16(%esp), %eax  # stack load f195913
# end emit-variable-ref
# check the argument is a pair
    movl %eax,%ebx
    and $7, %bl
    cmp $1, %bl
    je _L_1423768
# invoke error handler eh_pair
    .extern mrc_eh$upair
    movl mrc_eh$upair, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $112,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1423768:
    movl 3(%eax), %eax
    mov %eax, -28(%esp)    # arg (cdr f195913)
# emit-expr (fx- f195914 1)
# emit-expr 1
    movl $4, %eax     # immed 1
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1423769"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $84,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1423769:
    movl %eax, -32(%esp)
# emit-expr f195914
# emit-variable-ref
# env=((f195914 . -20) (f195913 . -16) (f195914 . -12) (f195913 . -8) ((primitive-ref list-ref) . 4))
# var=f195914
    movl -20(%esp), %eax  # stack load f195914
# end emit-variable-ref
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1423770"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $84,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1423770:
    subl -32(%esp), %eax
    mov %eax, -32(%esp)    # arg (fx- f195914 1)
    movl -24(%esp), %edi   # load new closure to %edi
# emit-shift-args:  size=3   si=-24  delta=20
    mov -24(%esp), %ebx  # shift frame cell
    mov %ebx, -4(%esp)  # down to base
# emit-shift-args:  size=2   si=-28  delta=20
    mov -28(%esp), %ebx  # shift frame cell
    mov %ebx, -8(%esp)  # down to base
# emit-shift-args:  size=1   si=-32  delta=20
    mov -32(%esp), %ebx  # shift frame cell
    mov %ebx, -12(%esp)  # down to base
# emit-shift-args:  size=0   si=-36  delta=20
    movl $8,%eax   # save arg count
    jmp *-2(%edi)  # tail-funcall
_L_1423764:
    .align 4,0x90
_L_1423761:
     movl %eax, mrc_list$mref
# == explicit-begins  ==>
# (lambda (l) (if (null? l) 0 (fxadd1 (list-length (cdr l)))))
# == eliminate-let*  ==>
# (lambda (l) (if (null? l) 0 (fxadd1 (list-length (cdr l)))))
# == uniquify-variables  ==>
# (lambda (f195915) (if (null? f195915) 0 (fxadd1 (list-length (cdr f195915)))))
# == vectorize-letrec  ==>
# (lambda (f195915) (if (null? f195915) 0 (fxadd1 (list-length (cdr f195915)))))
# == eliminate-set!  ==>
# (lambda (f195915) (let ((f195915 f195915)) (if (null? f195915) 0 (fxadd1 (list-length (cdr f195915))))))
# == close-free-variables  ==>
# (closure (f195915) (list-length) (let ((f195915 f195915)) (if (null? f195915) 0 (fxadd1 (list-length (cdr f195915))))))
# == eliminate-quote  ==>
# (closure (f195915) (list-length) (let ((f195915 f195915)) (if (null? f195915) 0 (fxadd1 (list-length (cdr f195915))))))
# == eliminate-when/unless  ==>
# (closure (f195915) (list-length) (let ((f195915 f195915)) (if (null? f195915) 0 (fxadd1 (list-length (cdr f195915))))))
# == eliminate-cond  ==>
# (closure (f195915) (list-length) (let ((f195915 f195915)) (if (null? f195915) 0 (fxadd1 (list-length (cdr f195915))))))
# == external-symbols  ==>
# (closure (f195915) ((primitive-ref list-length)) (let ((f195915 f195915)) (if (null? f195915) 0 (fxadd1 ((primitive-ref list-length) (cdr f195915))))))
# emit-expr (closure (f195915) ((primitive-ref list-length)) (let ((f195915 f195915)) (if (null? f195915) 0 (fxadd1 ((primitive-ref list-length) (cdr f195915))))))
# emit-closure
# si = 0
# env = ()
# expr = (closure (f195915) ((primitive-ref list-length)) (let ((f195915 f195915)) (if (null? f195915) 0 (fxadd1 ((primitive-ref list-length) (cdr f195915))))))
    movl $_L_1423771, 0(%ebp)  # closure label
# WARNING: free var (primitive-ref list-length) not defined in the environmnet
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $8, %ebp     # bump ebp
    jmp _L_1423772            # jump around closure body
_L_1423771:
# check argument count
    cmp $4,%eax
    je _L_1423773
# invoke error handler eh_argcount
    .extern mrc_eh$uargcount
    movl mrc_eh$uargcount, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_1423773:
# emit-tail-expr
# si=-12
# env=((f195915 . -8) ((primitive-ref list-length) . 4))
# expr=(let ((f195915 f195915)) (if (null? f195915) 0 (fxadd1 ((primitive-ref list-length) (cdr f195915)))))
# emit-tail-let
#  si   = -12
#  env  = ((f195915 . -8) ((primitive-ref list-length) . 4))
#  bindings = ((f195915 f195915))
#  body = (if (null? f195915) 0 (fxadd1 ((primitive-ref list-length) (cdr f195915))))
# emit-expr f195915
# emit-variable-ref
# env=((f195915 . -8) ((primitive-ref list-length) . 4))
# var=f195915
    movl -8(%esp), %eax  # stack load f195915
# end emit-variable-ref
    movl %eax, -12(%esp)  # stack save
# emit-tail-expr
# si=-16
# env=((f195915 . -12) (f195915 . -8) ((primitive-ref list-length) . 4))
# expr=(if (null? f195915) 0 (fxadd1 ((primitive-ref list-length) (cdr f195915))))
# emit-expr (null? f195915)
# emit-expr f195915
# emit-variable-ref
# env=((f195915 . -12) (f195915 . -8) ((primitive-ref list-length) . 4))
# var=f195915
    movl -12(%esp), %eax  # stack load f195915
# end emit-variable-ref
    cmp $63, %eax
    mov $0, %eax
    sete %al
    movzbl %al, %eax
    sal $6, %al
    or $47, %al
    cmp $47, %al
    je _L_1423774
# emit-tail-expr
# si=-16
# env=((f195915 . -12) (f195915 . -8) ((primitive-ref list-length) . 4))
# expr=0
    movl $0, %eax     # immed 0
    ret                  # immediate tail return
    jmp _L_1423775
_L_1423774:
# emit-tail-expr
# si=-16
# env=((f195915 . -12) (f195915 . -8) ((primitive-ref list-length) . 4))
# expr=(fxadd1 ((primitive-ref list-length) (cdr f195915)))
# tail primcall
# emit-expr ((primitive-ref list-length) (cdr f195915))
# funcall
#    si   =-16
#    env  = ((f195915 . -12) (f195915 . -8) ((primitive-ref list-length) . 4))
#    expr = (funcall (primitive-ref list-length) (cdr f195915))
# emit-expr (primitive-ref list-length)
    .extern mrc_list$mlength
    movl mrc_list$mlength,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1423776"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1423776":
   movl %eax,  -24(%esp)  # stash funcall-oper in closure slot
# emit-expr (cdr f195915)
# emit-expr f195915
# emit-variable-ref
# env=((f195915 . -12) (f195915 . -8) ((primitive-ref list-length) . 4))
# var=f195915
    movl -12(%esp), %eax  # stack load f195915
# end emit-variable-ref
# check the argument is a pair
    movl %eax,%ebx
    and $7, %bl
    cmp $1, %bl
    je _L_1423777
# invoke error handler eh_pair
    .extern mrc_eh$upair
    movl mrc_eh$upair, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $112,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1423777:
    movl 3(%eax), %eax
    mov %eax, -28(%esp)  # arg (cdr f195915)
    movl -24(%esp), %edi   # load new closure to %edi
    add $-16, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $16, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1423778"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $48,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1423778:
     addl $4, %eax
#return from tail (fxadd1 ((primitive-ref list-length) (cdr f195915)))
    ret
_L_1423775:
    .align 4,0x90
_L_1423772:
     movl %eax, mrc_list$mlength
# == explicit-begins  ==>
# (letrec ((f (lambda (l lrev) (if (null? l) lrev (f (cdr l) (cons (car l) lrev)))))) (lambda (l) (f l (quote ()))))
# == eliminate-let*  ==>
# (letrec ((f (lambda (l lrev) (if (null? l) lrev (f (cdr l) (cons (car l) lrev)))))) (lambda (l) (f l (quote ()))))
# == uniquify-variables  ==>
# (letrec ((f195916 (lambda (f195919 f195920) (if (null? f195919) f195920 (f195916 (cdr f195919) (cons (car f195919) f195920)))))) (lambda (f195922) (f195916 f195922 (quote ()))))
# == vectorize-letrec  ==>
# (let ((f195916 (make-vector 1))) (begin (begin (vector-set! f195916 0 (lambda (f195919 f195920) (if (null? f195919) f195920 ((vector-ref f195916 0) (cdr f195919) (cons (car f195919) f195920)))))) (lambda (f195922) ((vector-ref f195916 0) f195922 (quote ())))))
# == eliminate-set!  ==>
# (let ((f195916 (make-vector 1))) (begin (begin (vector-set! f195916 0 (lambda (f195919 f195920) (let ((f195919 f195919) (f195920 f195920)) (if (null? f195919) f195920 ((vector-ref f195916 0) (cdr f195919) (cons (car f195919) f195920))))))) (lambda (f195922) (let ((f195922 f195922)) ((vector-ref f195916 0) f195922 (quote ()))))))
# == close-free-variables  ==>
# (let ((f195916 (make-vector 1))) (begin (begin (vector-set! f195916 0 (closure (f195919 f195920) (f195916) (let ((f195919 f195919) (f195920 f195920)) (if (null? f195919) f195920 ((vector-ref f195916 0) (cdr f195919) (cons (car f195919) f195920))))))) (closure (f195922) (f195916) (let ((f195922 f195922)) ((vector-ref f195916 0) f195922 (quote ()))))))
# == eliminate-quote  ==>
# (let ((f195916 (make-vector 1))) (begin (begin (vector-set! f195916 0 (closure (f195919 f195920) (f195916) (let ((f195919 f195919) (f195920 f195920)) (if (null? f195919) f195920 ((vector-ref f195916 0) (cdr f195919) (cons (car f195919) f195920))))))) (closure (f195922) (f195916) (let ((f195922 f195922)) ((vector-ref f195916 0) f195922 ())))))
# == eliminate-when/unless  ==>
# (let ((f195916 (make-vector 1))) (begin (begin (vector-set! f195916 0 (closure (f195919 f195920) (f195916) (let ((f195919 f195919) (f195920 f195920)) (if (null? f195919) f195920 ((vector-ref f195916 0) (cdr f195919) (cons (car f195919) f195920))))))) (closure (f195922) (f195916) (let ((f195922 f195922)) ((vector-ref f195916 0) f195922 ())))))
# == eliminate-cond  ==>
# (let ((f195916 (make-vector 1))) (begin (begin (vector-set! f195916 0 (closure (f195919 f195920) (f195916) (let ((f195919 f195919) (f195920 f195920)) (if (null? f195919) f195920 ((vector-ref f195916 0) (cdr f195919) (cons (car f195919) f195920))))))) (closure (f195922) (f195916) (let ((f195922 f195922)) ((vector-ref f195916 0) f195922 ())))))
# == external-symbols  ==>
# (let ((f195916 (make-vector 1))) (begin (begin (vector-set! f195916 0 (closure (f195919 f195920) (f195916) (let ((f195919 f195919) (f195920 f195920)) (if (null? f195919) f195920 ((vector-ref f195916 0) (cdr f195919) (cons (car f195919) f195920))))))) (closure (f195922) (f195916) (let ((f195922 f195922)) ((vector-ref f195916 0) f195922 ())))))
# emit-expr (let ((f195916 (make-vector 1))) (begin (begin (vector-set! f195916 0 (closure (f195919 f195920) (f195916) (let ((f195919 f195919) (f195920 f195920)) (if (null? f195919) f195920 ((vector-ref f195916 0) (cdr f195919) (cons (car f195919) f195920))))))) (closure (f195922) (f195916) (let ((f195922 f195922)) ((vector-ref f195916 0) f195922 ())))))
# emit-let
#  si   = 0
#  env  = ()
#  bindings = ((f195916 (make-vector 1)))
#  body = (begin (begin (vector-set! f195916 0 (closure (f195919 f195920) (f195916) (let ((f195919 f195919) (f195920 f195920)) (if (null? f195919) f195920 ((vector-ref f195916 0) (cdr f195919) (cons (car f195919) f195920))))))) (closure (f195922) (f195916) (let ((f195922 f195922)) ((vector-ref f195916 0) f195922 ()))))
# emit-expr (make-vector 1)
# make-vector 1
# emit-expr 1
    movl $4, %eax     # immed 1
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1423779"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $128,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1423779:
# check the argument is a fixnum >= 0
    cmp $0,%eax
    jge _L_1423780
# invoke error handler eh_length
    .extern mrc_eh$ulength
    movl mrc_eh$ulength, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $128,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1423780:
    movl %eax, %esi
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    orl  $5, %eax
    addl $4, %esi
    addl $4, %esi
    andl $-8, %esi
    addl %esi, %ebp
    movl %eax, 0(%esp)  # stack save
# emit-expr (begin (begin (vector-set! f195916 0 (closure (f195919 f195920) (f195916) (let ((f195919 f195919) (f195920 f195920)) (if (null? f195919) f195920 ((vector-ref f195916 0) (cdr f195919) (cons (car f195919) f195920))))))) (closure (f195922) (f195916) (let ((f195922 f195922)) ((vector-ref f195916 0) f195922 ()))))
# emit-begin
#   expr=(begin (begin (vector-set! f195916 0 (closure (f195919 f195920) (f195916) (let ((f195919 f195919) (f195920 f195920)) (if (null? f195919) f195920 ((vector-ref f195916 0) (cdr f195919) (cons (car f195919) f195920))))))) (closure (f195922) (f195916) (let ((f195922 f195922)) ((vector-ref f195916 0) f195922 ()))))
#   env=((f195916 . 0))
# emit-expr (begin (vector-set! f195916 0 (closure (f195919 f195920) (f195916) (let ((f195919 f195919) (f195920 f195920)) (if (null? f195919) f195920 ((vector-ref f195916 0) (cdr f195919) (cons (car f195919) f195920)))))))
# emit-begin
#   expr=(begin (vector-set! f195916 0 (closure (f195919 f195920) (f195916) (let ((f195919 f195919) (f195920 f195920)) (if (null? f195919) f195920 ((vector-ref f195916 0) (cdr f195919) (cons (car f195919) f195920)))))))
#   env=((f195916 . 0))
# emit-expr (vector-set! f195916 0 (closure (f195919 f195920) (f195916) (let ((f195919 f195919) (f195920 f195920)) (if (null? f195919) f195920 ((vector-ref f195916 0) (cdr f195919) (cons (car f195919) f195920))))))
# emit-expr f195916
# emit-variable-ref
# env=((f195916 . 0))
# var=f195916
    movl 0(%esp), %eax  # stack load f195916
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1423781
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1423781:
    movl %eax, -4(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1423782"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1423782:
# check bounds on vector index
    movl -4(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1423784
    cmp  $0,%eax
    jge _L_1423783
_L_1423784:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1423783:
    movl %eax, -8(%esp)
# emit-expr (closure (f195919 f195920) (f195916) (let ((f195919 f195919) (f195920 f195920)) (if (null? f195919) f195920 ((vector-ref f195916 0) (cdr f195919) (cons (car f195919) f195920)))))
# emit-closure
# si = -12
# env = ((f195916 . 0))
# expr = (closure (f195919 f195920) (f195916) (let ((f195919 f195919) (f195920 f195920)) (if (null? f195919) f195920 ((vector-ref f195916 0) (cdr f195919) (cons (car f195919) f195920)))))
    movl $_L_1423785, 0(%ebp)  # closure label
# emit-variable-ref
# env=((f195916 . 0))
# var=f195916
    movl 0(%esp), %eax  # stack load f195916
# end emit-variable-ref
   movl  %eax, 4(%ebp)  # f195916
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $8, %ebp     # bump ebp
    jmp _L_1423786            # jump around closure body
_L_1423785:
# check argument count
    cmp $8,%eax
    je _L_1423787
# invoke error handler eh_argcount
    .extern mrc_eh$uargcount
    movl mrc_eh$uargcount, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_1423787:
# emit-tail-expr
# si=-16
# env=((f195920 . -12) (f195919 . -8) (f195916 . 4) (f195916 . 0))
# expr=(let ((f195919 f195919) (f195920 f195920)) (if (null? f195919) f195920 ((vector-ref f195916 0) (cdr f195919) (cons (car f195919) f195920))))
# emit-tail-let
#  si   = -16
#  env  = ((f195920 . -12) (f195919 . -8) (f195916 . 4) (f195916 . 0))
#  bindings = ((f195919 f195919) (f195920 f195920))
#  body = (if (null? f195919) f195920 ((vector-ref f195916 0) (cdr f195919) (cons (car f195919) f195920)))
# emit-expr f195919
# emit-variable-ref
# env=((f195920 . -12) (f195919 . -8) (f195916 . 4) (f195916 . 0))
# var=f195919
    movl -8(%esp), %eax  # stack load f195919
# end emit-variable-ref
    movl %eax, -16(%esp)  # stack save
# emit-expr f195920
# emit-variable-ref
# env=((f195920 . -12) (f195919 . -8) (f195916 . 4) (f195916 . 0))
# var=f195920
    movl -12(%esp), %eax  # stack load f195920
# end emit-variable-ref
    movl %eax, -20(%esp)  # stack save
# emit-tail-expr
# si=-24
# env=((f195920 . -20) (f195919 . -16) (f195920 . -12) (f195919 . -8) (f195916 . 4) (f195916 . 0))
# expr=(if (null? f195919) f195920 ((vector-ref f195916 0) (cdr f195919) (cons (car f195919) f195920)))
# emit-expr (null? f195919)
# emit-expr f195919
# emit-variable-ref
# env=((f195920 . -20) (f195919 . -16) (f195920 . -12) (f195919 . -8) (f195916 . 4) (f195916 . 0))
# var=f195919
    movl -16(%esp), %eax  # stack load f195919
# end emit-variable-ref
    cmp $63, %eax
    mov $0, %eax
    sete %al
    movzbl %al, %eax
    sal $6, %al
    or $47, %al
    cmp $47, %al
    je _L_1423788
# emit-tail-expr
# si=-24
# env=((f195920 . -20) (f195919 . -16) (f195920 . -12) (f195919 . -8) (f195916 . 4) (f195916 . 0))
# expr=f195920
# emit-tail-variable-ref
# emit-variable-ref
# env=((f195920 . -20) (f195919 . -16) (f195920 . -12) (f195919 . -8) (f195916 . 4) (f195916 . 0))
# var=f195920
    movl -20(%esp), %eax  # stack load f195920
# end emit-variable-ref
    ret
# end emit-tail-variable ref
    jmp _L_1423789
_L_1423788:
# emit-tail-expr
# si=-24
# env=((f195920 . -20) (f195919 . -16) (f195920 . -12) (f195919 . -8) (f195916 . 4) (f195916 . 0))
# expr=((vector-ref f195916 0) (cdr f195919) (cons (car f195919) f195920))
# emit-tail-funcall
#    si   =-24
#    env  = ((f195920 . -20) (f195919 . -16) (f195920 . -12) (f195919 . -8) (f195916 . 4) (f195916 . 0))
#    expr = (funcall (vector-ref f195916 0) (cdr f195919) (cons (car f195919) f195920))
# emit-expr (vector-ref f195916 0)
# emit-expr f195916
# emit-variable-ref
# env=((f195920 . -20) (f195919 . -16) (f195920 . -12) (f195919 . -8) (f195916 . 4) (f195916 . 0))
# var=f195916
    movl 2(%edi), %eax  # frame load f195916
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1423790
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1423790:
    movl %eax, -24(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1423791"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1423791:
# check bounds on vector index
    movl -24(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1423793
    cmp  $0,%eax
    jge _L_1423792
_L_1423793:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1423792:
    movl -24(%esp), %esi
    movl -1(%eax,%esi), %eax
   movl %eax,  -24(%esp)  # stash funcall-oper in next closure slot
# emit-expr (cdr f195919)
# emit-expr f195919
# emit-variable-ref
# env=((f195920 . -20) (f195919 . -16) (f195920 . -12) (f195919 . -8) (f195916 . 4) (f195916 . 0))
# var=f195919
    movl -16(%esp), %eax  # stack load f195919
# end emit-variable-ref
# check the argument is a pair
    movl %eax,%ebx
    and $7, %bl
    cmp $1, %bl
    je _L_1423794
# invoke error handler eh_pair
    .extern mrc_eh$upair
    movl mrc_eh$upair, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $112,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1423794:
    movl 3(%eax), %eax
    mov %eax, -28(%esp)    # arg (cdr f195919)
# emit-expr (cons (car f195919) f195920)
# cons arg1=(car f195919) arg2=f195920
# emit-expr (car f195919)
# emit-expr f195919
# emit-variable-ref
# env=((f195920 . -20) (f195919 . -16) (f195920 . -12) (f195919 . -8) (f195916 . 4) (f195916 . 0))
# var=f195919
    movl -16(%esp), %eax  # stack load f195919
# end emit-variable-ref
# check the argument is a pair
    movl %eax,%ebx
    and $7, %bl
    cmp $1, %bl
    je _L_1423795
# invoke error handler eh_pair
    .extern mrc_eh$upair
    movl mrc_eh$upair, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $108,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1423795:
    movl -1(%eax), %eax
    movl %eax, -32(%esp)
# emit-expr f195920
# emit-variable-ref
# env=((f195920 . -20) (f195919 . -16) (f195920 . -12) (f195919 . -8) (f195916 . 4) (f195916 . 0))
# var=f195920
    movl -20(%esp), %eax  # stack load f195920
# end emit-variable-ref
    movl %eax, 4(%ebp)
    movl -32(%esp), %eax
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    or   $1, %al
    add  $8, %ebp
# cons end
    mov %eax, -32(%esp)    # arg (cons (car f195919) f195920)
    movl -24(%esp), %edi   # load new closure to %edi
# emit-shift-args:  size=3   si=-24  delta=20
    mov -24(%esp), %ebx  # shift frame cell
    mov %ebx, -4(%esp)  # down to base
# emit-shift-args:  size=2   si=-28  delta=20
    mov -28(%esp), %ebx  # shift frame cell
    mov %ebx, -8(%esp)  # down to base
# emit-shift-args:  size=1   si=-32  delta=20
    mov -32(%esp), %ebx  # shift frame cell
    mov %ebx, -12(%esp)  # down to base
# emit-shift-args:  size=0   si=-36  delta=20
    movl $8,%eax   # save arg count
    jmp *-2(%edi)  # tail-funcall
_L_1423789:
    .align 4,0x90
_L_1423786:
    movl -4(%esp), %ebx
    movl -8(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin)
# emit-begin
#   expr=(begin)
#   env=((f195916 . 0))
# emit-expr (begin (closure (f195922) (f195916) (let ((f195922 f195922)) ((vector-ref f195916 0) f195922 ()))))
# emit-begin
#   expr=(begin (closure (f195922) (f195916) (let ((f195922 f195922)) ((vector-ref f195916 0) f195922 ()))))
#   env=((f195916 . 0))
# emit-expr (closure (f195922) (f195916) (let ((f195922 f195922)) ((vector-ref f195916 0) f195922 ())))
# emit-closure
# si = -4
# env = ((f195916 . 0))
# expr = (closure (f195922) (f195916) (let ((f195922 f195922)) ((vector-ref f195916 0) f195922 ())))
    movl $_L_1423796, 0(%ebp)  # closure label
# emit-variable-ref
# env=((f195916 . 0))
# var=f195916
    movl 0(%esp), %eax  # stack load f195916
# end emit-variable-ref
   movl  %eax, 4(%ebp)  # f195916
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $8, %ebp     # bump ebp
    jmp _L_1423797            # jump around closure body
_L_1423796:
# check argument count
    cmp $4,%eax
    je _L_1423798
# invoke error handler eh_argcount
    .extern mrc_eh$uargcount
    movl mrc_eh$uargcount, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_1423798:
# emit-tail-expr
# si=-12
# env=((f195922 . -8) (f195916 . 4) (f195916 . 0))
# expr=(let ((f195922 f195922)) ((vector-ref f195916 0) f195922 ()))
# emit-tail-let
#  si   = -12
#  env  = ((f195922 . -8) (f195916 . 4) (f195916 . 0))
#  bindings = ((f195922 f195922))
#  body = ((vector-ref f195916 0) f195922 ())
# emit-expr f195922
# emit-variable-ref
# env=((f195922 . -8) (f195916 . 4) (f195916 . 0))
# var=f195922
    movl -8(%esp), %eax  # stack load f195922
# end emit-variable-ref
    movl %eax, -12(%esp)  # stack save
# emit-tail-expr
# si=-16
# env=((f195922 . -12) (f195922 . -8) (f195916 . 4) (f195916 . 0))
# expr=((vector-ref f195916 0) f195922 ())
# emit-tail-funcall
#    si   =-16
#    env  = ((f195922 . -12) (f195922 . -8) (f195916 . 4) (f195916 . 0))
#    expr = (funcall (vector-ref f195916 0) f195922 ())
# emit-expr (vector-ref f195916 0)
# emit-expr f195916
# emit-variable-ref
# env=((f195922 . -12) (f195922 . -8) (f195916 . 4) (f195916 . 0))
# var=f195916
    movl 2(%edi), %eax  # frame load f195916
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1423799
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1423799:
    movl %eax, -16(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1423800"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1423800:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1423802
    cmp  $0,%eax
    jge _L_1423801
_L_1423802:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1423801:
    movl -16(%esp), %esi
    movl -1(%eax,%esi), %eax
   movl %eax,  -16(%esp)  # stash funcall-oper in next closure slot
# emit-expr f195922
# emit-variable-ref
# env=((f195922 . -12) (f195922 . -8) (f195916 . 4) (f195916 . 0))
# var=f195922
    movl -12(%esp), %eax  # stack load f195922
# end emit-variable-ref
    mov %eax, -20(%esp)    # arg f195922
# emit-expr ()
    movl $63, %eax     # immed ()
    mov %eax, -24(%esp)    # arg ()
    movl -16(%esp), %edi   # load new closure to %edi
# emit-shift-args:  size=3   si=-16  delta=12
    mov -16(%esp), %ebx  # shift frame cell
    mov %ebx, -4(%esp)  # down to base
# emit-shift-args:  size=2   si=-20  delta=12
    mov -20(%esp), %ebx  # shift frame cell
    mov %ebx, -8(%esp)  # down to base
# emit-shift-args:  size=1   si=-24  delta=12
    mov -24(%esp), %ebx  # shift frame cell
    mov %ebx, -12(%esp)  # down to base
# emit-shift-args:  size=0   si=-28  delta=12
    movl $8,%eax   # save arg count
    jmp *-2(%edi)  # tail-funcall
    .align 4,0x90
_L_1423797:
# emit-expr (begin)
# emit-begin
#   expr=(begin)
#   env=((f195916 . 0))
     movl %eax, mrc_reverse
# == explicit-begins  ==>
# (letrec ((fill-vector (lambda (v k args) (if (null? args) v (begin (vector-set! v k (car args)) (fill-vector v (fxadd1 k) (cdr args))))))) (lambda args (let ((v (make-vector (list-length args)))) (fill-vector v 0 args))))
# == eliminate-let*  ==>
# (letrec ((fill-vector (lambda (v k args) (if (null? args) v (begin (vector-set! v k (car args)) (fill-vector v (fxadd1 k) (cdr args))))))) (lambda args (let ((v (make-vector (list-length args)))) (fill-vector v 0 args))))
# == uniquify-variables  ==>
# (letrec ((f195923 (lambda (f195927 f195928 f195929) (if (null? f195929) f195927 (begin (vector-set! f195927 f195928 (car f195929)) (f195923 f195927 (fxadd1 f195928) (cdr f195929))))))) (lambda f195933 (let ((f195935 (make-vector (list-length f195933)))) (f195923 f195935 0 f195933))))
# == vectorize-letrec  ==>
# (let ((f195923 (make-vector 1))) (begin (begin (vector-set! f195923 0 (lambda (f195927 f195928 f195929) (if (null? f195929) f195927 (begin (vector-set! f195927 f195928 (car f195929)) ((vector-ref f195923 0) f195927 (fxadd1 f195928) (cdr f195929))))))) (lambda f195933 (let ((f195935 (make-vector (list-length f195933)))) ((vector-ref f195923 0) f195935 0 f195933)))))
# == eliminate-set!  ==>
# (let ((f195923 (make-vector 1))) (begin (begin (vector-set! f195923 0 (lambda (f195927 f195928 f195929) (let ((f195927 f195927) (f195928 f195928) (f195929 f195929)) (if (null? f195929) f195927 (begin (vector-set! f195927 f195928 (car f195929)) ((vector-ref f195923 0) f195927 (fxadd1 f195928) (cdr f195929)))))))) (lambda f195933 (let () (let ((f195935 (make-vector (list-length f195933)))) ((vector-ref f195923 0) f195935 0 f195933))))))
# == close-free-variables  ==>
# (let ((f195923 (make-vector 1))) (begin (begin (vector-set! f195923 0 (closure (f195927 f195928 f195929) (f195923) (let ((f195927 f195927) (f195928 f195928) (f195929 f195929)) (if (null? f195929) f195927 (begin (vector-set! f195927 f195928 (car f195929)) ((vector-ref f195923 0) f195927 (fxadd1 f195928) (cdr f195929)))))))) (closure f195933 (f195923) (let () (let ((f195935 (make-vector (list-length f195933)))) ((vector-ref f195923 0) f195935 0 f195933))))))
# == eliminate-quote  ==>
# (let ((f195923 (make-vector 1))) (begin (begin (vector-set! f195923 0 (closure (f195927 f195928 f195929) (f195923) (let ((f195927 f195927) (f195928 f195928) (f195929 f195929)) (if (null? f195929) f195927 (begin (vector-set! f195927 f195928 (car f195929)) ((vector-ref f195923 0) f195927 (fxadd1 f195928) (cdr f195929)))))))) (closure f195933 (f195923) (let () (let ((f195935 (make-vector (list-length f195933)))) ((vector-ref f195923 0) f195935 0 f195933))))))
# == eliminate-when/unless  ==>
# (let ((f195923 (make-vector 1))) (begin (begin (vector-set! f195923 0 (closure (f195927 f195928 f195929) (f195923) (let ((f195927 f195927) (f195928 f195928) (f195929 f195929)) (if (null? f195929) f195927 (begin (vector-set! f195927 f195928 (car f195929)) ((vector-ref f195923 0) f195927 (fxadd1 f195928) (cdr f195929)))))))) (closure f195933 (f195923) (let () (let ((f195935 (make-vector (list-length f195933)))) ((vector-ref f195923 0) f195935 0 f195933))))))
# == eliminate-cond  ==>
# (let ((f195923 (make-vector 1))) (begin (begin (vector-set! f195923 0 (closure (f195927 f195928 f195929) (f195923) (let ((f195927 f195927) (f195928 f195928) (f195929 f195929)) (if (null? f195929) f195927 (begin (vector-set! f195927 f195928 (car f195929)) ((vector-ref f195923 0) f195927 (fxadd1 f195928) (cdr f195929)))))))) (closure f195933 (f195923) (let () (let ((f195935 (make-vector (list-length f195933)))) ((vector-ref f195923 0) f195935 0 f195933))))))
# == external-symbols  ==>
# (let ((f195923 (make-vector 1))) (begin (begin (vector-set! f195923 0 (closure (f195927 f195928 f195929) (f195923) (let ((f195927 f195927) (f195928 f195928) (f195929 f195929)) (if (null? f195929) f195927 (begin (vector-set! f195927 f195928 (car f195929)) ((vector-ref f195923 0) f195927 (fxadd1 f195928) (cdr f195929)))))))) (closure f195933 (f195923) (let () (let ((f195935 (make-vector ((primitive-ref list-length) f195933)))) ((vector-ref f195923 0) f195935 0 f195933))))))
# emit-expr (let ((f195923 (make-vector 1))) (begin (begin (vector-set! f195923 0 (closure (f195927 f195928 f195929) (f195923) (let ((f195927 f195927) (f195928 f195928) (f195929 f195929)) (if (null? f195929) f195927 (begin (vector-set! f195927 f195928 (car f195929)) ((vector-ref f195923 0) f195927 (fxadd1 f195928) (cdr f195929)))))))) (closure f195933 (f195923) (let () (let ((f195935 (make-vector ((primitive-ref list-length) f195933)))) ((vector-ref f195923 0) f195935 0 f195933))))))
# emit-let
#  si   = 0
#  env  = ()
#  bindings = ((f195923 (make-vector 1)))
#  body = (begin (begin (vector-set! f195923 0 (closure (f195927 f195928 f195929) (f195923) (let ((f195927 f195927) (f195928 f195928) (f195929 f195929)) (if (null? f195929) f195927 (begin (vector-set! f195927 f195928 (car f195929)) ((vector-ref f195923 0) f195927 (fxadd1 f195928) (cdr f195929)))))))) (closure f195933 (f195923) (let () (let ((f195935 (make-vector ((primitive-ref list-length) f195933)))) ((vector-ref f195923 0) f195935 0 f195933)))))
# emit-expr (make-vector 1)
# make-vector 1
# emit-expr 1
    movl $4, %eax     # immed 1
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1423803"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $128,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1423803:
# check the argument is a fixnum >= 0
    cmp $0,%eax
    jge _L_1423804
# invoke error handler eh_length
    .extern mrc_eh$ulength
    movl mrc_eh$ulength, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $128,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1423804:
    movl %eax, %esi
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    orl  $5, %eax
    addl $4, %esi
    addl $4, %esi
    andl $-8, %esi
    addl %esi, %ebp
    movl %eax, 0(%esp)  # stack save
# emit-expr (begin (begin (vector-set! f195923 0 (closure (f195927 f195928 f195929) (f195923) (let ((f195927 f195927) (f195928 f195928) (f195929 f195929)) (if (null? f195929) f195927 (begin (vector-set! f195927 f195928 (car f195929)) ((vector-ref f195923 0) f195927 (fxadd1 f195928) (cdr f195929)))))))) (closure f195933 (f195923) (let () (let ((f195935 (make-vector ((primitive-ref list-length) f195933)))) ((vector-ref f195923 0) f195935 0 f195933)))))
# emit-begin
#   expr=(begin (begin (vector-set! f195923 0 (closure (f195927 f195928 f195929) (f195923) (let ((f195927 f195927) (f195928 f195928) (f195929 f195929)) (if (null? f195929) f195927 (begin (vector-set! f195927 f195928 (car f195929)) ((vector-ref f195923 0) f195927 (fxadd1 f195928) (cdr f195929)))))))) (closure f195933 (f195923) (let () (let ((f195935 (make-vector ((primitive-ref list-length) f195933)))) ((vector-ref f195923 0) f195935 0 f195933)))))
#   env=((f195923 . 0))
# emit-expr (begin (vector-set! f195923 0 (closure (f195927 f195928 f195929) (f195923) (let ((f195927 f195927) (f195928 f195928) (f195929 f195929)) (if (null? f195929) f195927 (begin (vector-set! f195927 f195928 (car f195929)) ((vector-ref f195923 0) f195927 (fxadd1 f195928) (cdr f195929))))))))
# emit-begin
#   expr=(begin (vector-set! f195923 0 (closure (f195927 f195928 f195929) (f195923) (let ((f195927 f195927) (f195928 f195928) (f195929 f195929)) (if (null? f195929) f195927 (begin (vector-set! f195927 f195928 (car f195929)) ((vector-ref f195923 0) f195927 (fxadd1 f195928) (cdr f195929))))))))
#   env=((f195923 . 0))
# emit-expr (vector-set! f195923 0 (closure (f195927 f195928 f195929) (f195923) (let ((f195927 f195927) (f195928 f195928) (f195929 f195929)) (if (null? f195929) f195927 (begin (vector-set! f195927 f195928 (car f195929)) ((vector-ref f195923 0) f195927 (fxadd1 f195928) (cdr f195929)))))))
# emit-expr f195923
# emit-variable-ref
# env=((f195923 . 0))
# var=f195923
    movl 0(%esp), %eax  # stack load f195923
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1423805
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1423805:
    movl %eax, -4(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1423806"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1423806:
# check bounds on vector index
    movl -4(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1423808
    cmp  $0,%eax
    jge _L_1423807
_L_1423808:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1423807:
    movl %eax, -8(%esp)
# emit-expr (closure (f195927 f195928 f195929) (f195923) (let ((f195927 f195927) (f195928 f195928) (f195929 f195929)) (if (null? f195929) f195927 (begin (vector-set! f195927 f195928 (car f195929)) ((vector-ref f195923 0) f195927 (fxadd1 f195928) (cdr f195929))))))
# emit-closure
# si = -12
# env = ((f195923 . 0))
# expr = (closure (f195927 f195928 f195929) (f195923) (let ((f195927 f195927) (f195928 f195928) (f195929 f195929)) (if (null? f195929) f195927 (begin (vector-set! f195927 f195928 (car f195929)) ((vector-ref f195923 0) f195927 (fxadd1 f195928) (cdr f195929))))))
    movl $_L_1423809, 0(%ebp)  # closure label
# emit-variable-ref
# env=((f195923 . 0))
# var=f195923
    movl 0(%esp), %eax  # stack load f195923
# end emit-variable-ref
   movl  %eax, 4(%ebp)  # f195923
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $8, %ebp     # bump ebp
    jmp _L_1423810            # jump around closure body
_L_1423809:
# check argument count
    cmp $12,%eax
    je _L_1423811
# invoke error handler eh_argcount
    .extern mrc_eh$uargcount
    movl mrc_eh$uargcount, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_1423811:
# emit-tail-expr
# si=-20
# env=((f195929 . -16) (f195928 . -12) (f195927 . -8) (f195923 . 4) (f195923 . 0))
# expr=(let ((f195927 f195927) (f195928 f195928) (f195929 f195929)) (if (null? f195929) f195927 (begin (vector-set! f195927 f195928 (car f195929)) ((vector-ref f195923 0) f195927 (fxadd1 f195928) (cdr f195929)))))
# emit-tail-let
#  si   = -20
#  env  = ((f195929 . -16) (f195928 . -12) (f195927 . -8) (f195923 . 4) (f195923 . 0))
#  bindings = ((f195927 f195927) (f195928 f195928) (f195929 f195929))
#  body = (if (null? f195929) f195927 (begin (vector-set! f195927 f195928 (car f195929)) ((vector-ref f195923 0) f195927 (fxadd1 f195928) (cdr f195929))))
# emit-expr f195927
# emit-variable-ref
# env=((f195929 . -16) (f195928 . -12) (f195927 . -8) (f195923 . 4) (f195923 . 0))
# var=f195927
    movl -8(%esp), %eax  # stack load f195927
# end emit-variable-ref
    movl %eax, -20(%esp)  # stack save
# emit-expr f195928
# emit-variable-ref
# env=((f195929 . -16) (f195928 . -12) (f195927 . -8) (f195923 . 4) (f195923 . 0))
# var=f195928
    movl -12(%esp), %eax  # stack load f195928
# end emit-variable-ref
    movl %eax, -24(%esp)  # stack save
# emit-expr f195929
# emit-variable-ref
# env=((f195929 . -16) (f195928 . -12) (f195927 . -8) (f195923 . 4) (f195923 . 0))
# var=f195929
    movl -16(%esp), %eax  # stack load f195929
# end emit-variable-ref
    movl %eax, -28(%esp)  # stack save
# emit-tail-expr
# si=-32
# env=((f195929 . -28) (f195928 . -24) (f195927 . -20) (f195929 . -16) (f195928 . -12) (f195927 . -8) (f195923 . 4) (f195923 . 0))
# expr=(if (null? f195929) f195927 (begin (vector-set! f195927 f195928 (car f195929)) ((vector-ref f195923 0) f195927 (fxadd1 f195928) (cdr f195929))))
# emit-expr (null? f195929)
# emit-expr f195929
# emit-variable-ref
# env=((f195929 . -28) (f195928 . -24) (f195927 . -20) (f195929 . -16) (f195928 . -12) (f195927 . -8) (f195923 . 4) (f195923 . 0))
# var=f195929
    movl -28(%esp), %eax  # stack load f195929
# end emit-variable-ref
    cmp $63, %eax
    mov $0, %eax
    sete %al
    movzbl %al, %eax
    sal $6, %al
    or $47, %al
    cmp $47, %al
    je _L_1423812
# emit-tail-expr
# si=-32
# env=((f195929 . -28) (f195928 . -24) (f195927 . -20) (f195929 . -16) (f195928 . -12) (f195927 . -8) (f195923 . 4) (f195923 . 0))
# expr=f195927
# emit-tail-variable-ref
# emit-variable-ref
# env=((f195929 . -28) (f195928 . -24) (f195927 . -20) (f195929 . -16) (f195928 . -12) (f195927 . -8) (f195923 . 4) (f195923 . 0))
# var=f195927
    movl -20(%esp), %eax  # stack load f195927
# end emit-variable-ref
    ret
# end emit-tail-variable ref
    jmp _L_1423813
_L_1423812:
# emit-tail-expr
# si=-32
# env=((f195929 . -28) (f195928 . -24) (f195927 . -20) (f195929 . -16) (f195928 . -12) (f195927 . -8) (f195923 . 4) (f195923 . 0))
# expr=(begin (vector-set! f195927 f195928 (car f195929)) ((vector-ref f195923 0) f195927 (fxadd1 f195928) (cdr f195929)))
# tail-begin (begin (vector-set! f195927 f195928 (car f195929)) ((vector-ref f195923 0) f195927 (fxadd1 f195928) (cdr f195929)))
#   env=((f195929 . -28) (f195928 . -24) (f195927 . -20) (f195929 . -16) (f195928 . -12) (f195927 . -8) (f195923 . 4) (f195923 . 0))
# emit-expr (vector-set! f195927 f195928 (car f195929))
# emit-expr f195927
# emit-variable-ref
# env=((f195929 . -28) (f195928 . -24) (f195927 . -20) (f195929 . -16) (f195928 . -12) (f195927 . -8) (f195923 . 4) (f195923 . 0))
# var=f195927
    movl -20(%esp), %eax  # stack load f195927
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1423814
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1423814:
    movl %eax, -32(%esp)
# emit-expr f195928
# emit-variable-ref
# env=((f195929 . -28) (f195928 . -24) (f195927 . -20) (f195929 . -16) (f195928 . -12) (f195927 . -8) (f195923 . 4) (f195923 . 0))
# var=f195928
    movl -24(%esp), %eax  # stack load f195928
# end emit-variable-ref
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1423815"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1423815:
# check bounds on vector index
    movl -32(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1423817
    cmp  $0,%eax
    jge _L_1423816
_L_1423817:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1423816:
    movl %eax, -36(%esp)
# emit-expr (car f195929)
# emit-expr f195929
# emit-variable-ref
# env=((f195929 . -28) (f195928 . -24) (f195927 . -20) (f195929 . -16) (f195928 . -12) (f195927 . -8) (f195923 . 4) (f195923 . 0))
# var=f195929
    movl -28(%esp), %eax  # stack load f195929
# end emit-variable-ref
# check the argument is a pair
    movl %eax,%ebx
    and $7, %bl
    cmp $1, %bl
    je _L_1423818
# invoke error handler eh_pair
    .extern mrc_eh$upair
    movl mrc_eh$upair, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $108,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1423818:
    movl -1(%eax), %eax
    movl -32(%esp), %ebx
    movl -36(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-tail-expr
# si=-32
# env=((f195929 . -28) (f195928 . -24) (f195927 . -20) (f195929 . -16) (f195928 . -12) (f195927 . -8) (f195923 . 4) (f195923 . 0))
# expr=(begin ((vector-ref f195923 0) f195927 (fxadd1 f195928) (cdr f195929)))
# tail-begin (begin ((vector-ref f195923 0) f195927 (fxadd1 f195928) (cdr f195929)))
#   env=((f195929 . -28) (f195928 . -24) (f195927 . -20) (f195929 . -16) (f195928 . -12) (f195927 . -8) (f195923 . 4) (f195923 . 0))
# emit-tail-expr
# si=-32
# env=((f195929 . -28) (f195928 . -24) (f195927 . -20) (f195929 . -16) (f195928 . -12) (f195927 . -8) (f195923 . 4) (f195923 . 0))
# expr=((vector-ref f195923 0) f195927 (fxadd1 f195928) (cdr f195929))
# emit-tail-funcall
#    si   =-32
#    env  = ((f195929 . -28) (f195928 . -24) (f195927 . -20) (f195929 . -16) (f195928 . -12) (f195927 . -8) (f195923 . 4) (f195923 . 0))
#    expr = (funcall (vector-ref f195923 0) f195927 (fxadd1 f195928) (cdr f195929))
# emit-expr (vector-ref f195923 0)
# emit-expr f195923
# emit-variable-ref
# env=((f195929 . -28) (f195928 . -24) (f195927 . -20) (f195929 . -16) (f195928 . -12) (f195927 . -8) (f195923 . 4) (f195923 . 0))
# var=f195923
    movl 2(%edi), %eax  # frame load f195923
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1423819
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1423819:
    movl %eax, -32(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1423820"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1423820:
# check bounds on vector index
    movl -32(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1423822
    cmp  $0,%eax
    jge _L_1423821
_L_1423822:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1423821:
    movl -32(%esp), %esi
    movl -1(%eax,%esi), %eax
   movl %eax,  -32(%esp)  # stash funcall-oper in next closure slot
# emit-expr f195927
# emit-variable-ref
# env=((f195929 . -28) (f195928 . -24) (f195927 . -20) (f195929 . -16) (f195928 . -12) (f195927 . -8) (f195923 . 4) (f195923 . 0))
# var=f195927
    movl -20(%esp), %eax  # stack load f195927
# end emit-variable-ref
    mov %eax, -36(%esp)    # arg f195927
# emit-expr (fxadd1 f195928)
# emit-expr f195928
# emit-variable-ref
# env=((f195929 . -28) (f195928 . -24) (f195927 . -20) (f195929 . -16) (f195928 . -12) (f195927 . -8) (f195923 . 4) (f195923 . 0))
# var=f195928
    movl -24(%esp), %eax  # stack load f195928
# end emit-variable-ref
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1423823"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $48,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1423823:
     addl $4, %eax
    mov %eax, -40(%esp)    # arg (fxadd1 f195928)
# emit-expr (cdr f195929)
# emit-expr f195929
# emit-variable-ref
# env=((f195929 . -28) (f195928 . -24) (f195927 . -20) (f195929 . -16) (f195928 . -12) (f195927 . -8) (f195923 . 4) (f195923 . 0))
# var=f195929
    movl -28(%esp), %eax  # stack load f195929
# end emit-variable-ref
# check the argument is a pair
    movl %eax,%ebx
    and $7, %bl
    cmp $1, %bl
    je _L_1423824
# invoke error handler eh_pair
    .extern mrc_eh$upair
    movl mrc_eh$upair, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $112,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1423824:
    movl 3(%eax), %eax
    mov %eax, -44(%esp)    # arg (cdr f195929)
    movl -32(%esp), %edi   # load new closure to %edi
# emit-shift-args:  size=4   si=-32  delta=28
    mov -32(%esp), %ebx  # shift frame cell
    mov %ebx, -4(%esp)  # down to base
# emit-shift-args:  size=3   si=-36  delta=28
    mov -36(%esp), %ebx  # shift frame cell
    mov %ebx, -8(%esp)  # down to base
# emit-shift-args:  size=2   si=-40  delta=28
    mov -40(%esp), %ebx  # shift frame cell
    mov %ebx, -12(%esp)  # down to base
# emit-shift-args:  size=1   si=-44  delta=28
    mov -44(%esp), %ebx  # shift frame cell
    mov %ebx, -16(%esp)  # down to base
# emit-shift-args:  size=0   si=-48  delta=28
    movl $12,%eax   # save arg count
    jmp *-2(%edi)  # tail-funcall
     ret   # return thru stack
_L_1423813:
    .align 4,0x90
_L_1423810:
    movl -4(%esp), %ebx
    movl -8(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin)
# emit-begin
#   expr=(begin)
#   env=((f195923 . 0))
# emit-expr (begin (closure f195933 (f195923) (let () (let ((f195935 (make-vector ((primitive-ref list-length) f195933)))) ((vector-ref f195923 0) f195935 0 f195933)))))
# emit-begin
#   expr=(begin (closure f195933 (f195923) (let () (let ((f195935 (make-vector ((primitive-ref list-length) f195933)))) ((vector-ref f195923 0) f195935 0 f195933)))))
#   env=((f195923 . 0))
# emit-expr (closure f195933 (f195923) (let () (let ((f195935 (make-vector ((primitive-ref list-length) f195933)))) ((vector-ref f195923 0) f195935 0 f195933))))
# emit-closure
# si = -4
# env = ((f195923 . 0))
# expr = (closure f195933 (f195923) (let () (let ((f195935 (make-vector ((primitive-ref list-length) f195933)))) ((vector-ref f195923 0) f195935 0 f195933))))
    movl $_L_1423825, 0(%ebp)  # closure label
# emit-variable-ref
# env=((f195923 . 0))
# var=f195923
    movl 0(%esp), %eax  # stack load f195923
# end emit-variable-ref
   movl  %eax, 4(%ebp)  # f195923
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $8, %ebp     # bump ebp
    jmp _L_1423826            # jump around closure body
_L_1423825:
# check argument count
    cmp $0,%eax
    jge _L_1423827
# invoke error handler eh_argcount_min
    .extern mrc_eh$uargcount$umin
    movl mrc_eh$uargcount$umin, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_1423827:
# emit-build-varargs-list
    movl $63, %esi       # args <- () 
    lea -4(%esp),%edi    # edi <- esp-4
    subl %eax, %edi      # edi <- esp-4-eax    addr of arg[K+N] on stack
_L_1423829:
    lea -4(%esp),%ebx    # addr of arg[K] on stack
    cmp %edi, %ebx       # while edi <> esp+(si+4)
    je _L_1423828
    movl (%edi),%ebx     # arg i -> car
    movl %ebx, 0(%ebp)
    movl %esi, 4(%ebp)  # esi -> cdr
    movl %ebp, %esi
    addl $1, %esi       # tag as pair
    addl $8,%ebp         # bump heap ptr
    addl $4,%edi         # move to next previous arg from the end
    jmp _L_1423829
_L_1423828:
    movl %esi, -8(%esp)  # set args
# emit-tail-expr
# si=-12
# env=((f195933 . -8) (f195923 . 4) (f195923 . 0))
# expr=(let () (let ((f195935 (make-vector ((primitive-ref list-length) f195933)))) ((vector-ref f195923 0) f195935 0 f195933)))
# emit-tail-let
#  si   = -12
#  env  = ((f195933 . -8) (f195923 . 4) (f195923 . 0))
#  bindings = ()
#  body = (let ((f195935 (make-vector ((primitive-ref list-length) f195933)))) ((vector-ref f195923 0) f195935 0 f195933))
# emit-tail-expr
# si=-12
# env=((f195933 . -8) (f195923 . 4) (f195923 . 0))
# expr=(let ((f195935 (make-vector ((primitive-ref list-length) f195933)))) ((vector-ref f195923 0) f195935 0 f195933))
# emit-tail-let
#  si   = -12
#  env  = ((f195933 . -8) (f195923 . 4) (f195923 . 0))
#  bindings = ((f195935 (make-vector ((primitive-ref list-length) f195933))))
#  body = ((vector-ref f195923 0) f195935 0 f195933)
# emit-expr (make-vector ((primitive-ref list-length) f195933))
# make-vector ((primitive-ref list-length) f195933)
# emit-expr ((primitive-ref list-length) f195933)
# funcall
#    si   =-12
#    env  = ((f195933 . -8) (f195923 . 4) (f195923 . 0))
#    expr = (funcall (primitive-ref list-length) f195933)
# emit-expr (primitive-ref list-length)
    .extern mrc_list$mlength
    movl mrc_list$mlength,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1423830"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1423830":
   movl %eax,  -20(%esp)  # stash funcall-oper in closure slot
# emit-expr f195933
# emit-variable-ref
# env=((f195933 . -8) (f195923 . 4) (f195923 . 0))
# var=f195933
    movl -8(%esp), %eax  # stack load f195933
# end emit-variable-ref
    mov %eax, -24(%esp)  # arg f195933
    movl -20(%esp), %edi   # load new closure to %edi
    add $-12, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $12, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1423831"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $128,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1423831:
# check the argument is a fixnum >= 0
    cmp $0,%eax
    jge _L_1423832
# invoke error handler eh_length
    .extern mrc_eh$ulength
    movl mrc_eh$ulength, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $128,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1423832:
    movl %eax, %esi
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    orl  $5, %eax
    addl $4, %esi
    addl $4, %esi
    andl $-8, %esi
    addl %esi, %ebp
    movl %eax, -12(%esp)  # stack save
# emit-tail-expr
# si=-16
# env=((f195935 . -12) (f195933 . -8) (f195923 . 4) (f195923 . 0))
# expr=((vector-ref f195923 0) f195935 0 f195933)
# emit-tail-funcall
#    si   =-16
#    env  = ((f195935 . -12) (f195933 . -8) (f195923 . 4) (f195923 . 0))
#    expr = (funcall (vector-ref f195923 0) f195935 0 f195933)
# emit-expr (vector-ref f195923 0)
# emit-expr f195923
# emit-variable-ref
# env=((f195935 . -12) (f195933 . -8) (f195923 . 4) (f195923 . 0))
# var=f195923
    movl 2(%edi), %eax  # frame load f195923
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1423833
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1423833:
    movl %eax, -16(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1423834"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1423834:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1423836
    cmp  $0,%eax
    jge _L_1423835
_L_1423836:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1423835:
    movl -16(%esp), %esi
    movl -1(%eax,%esi), %eax
   movl %eax,  -16(%esp)  # stash funcall-oper in next closure slot
# emit-expr f195935
# emit-variable-ref
# env=((f195935 . -12) (f195933 . -8) (f195923 . 4) (f195923 . 0))
# var=f195935
    movl -12(%esp), %eax  # stack load f195935
# end emit-variable-ref
    mov %eax, -20(%esp)    # arg f195935
# emit-expr 0
    movl $0, %eax     # immed 0
    mov %eax, -24(%esp)    # arg 0
# emit-expr f195933
# emit-variable-ref
# env=((f195935 . -12) (f195933 . -8) (f195923 . 4) (f195923 . 0))
# var=f195933
    movl -8(%esp), %eax  # stack load f195933
# end emit-variable-ref
    mov %eax, -28(%esp)    # arg f195933
    movl -16(%esp), %edi   # load new closure to %edi
# emit-shift-args:  size=4   si=-16  delta=12
    mov -16(%esp), %ebx  # shift frame cell
    mov %ebx, -4(%esp)  # down to base
# emit-shift-args:  size=3   si=-20  delta=12
    mov -20(%esp), %ebx  # shift frame cell
    mov %ebx, -8(%esp)  # down to base
# emit-shift-args:  size=2   si=-24  delta=12
    mov -24(%esp), %ebx  # shift frame cell
    mov %ebx, -12(%esp)  # down to base
# emit-shift-args:  size=1   si=-28  delta=12
    mov -28(%esp), %ebx  # shift frame cell
    mov %ebx, -16(%esp)  # down to base
# emit-shift-args:  size=0   si=-32  delta=12
    movl $12,%eax   # save arg count
    jmp *-2(%edi)  # tail-funcall
    .align 4,0x90
_L_1423826:
# emit-expr (begin)
# emit-begin
#   expr=(begin)
#   env=((f195923 . 0))
     movl %eax, mrc_vector
# == explicit-begins  ==>
# (letrec ((fill-string (lambda (s k args) (if (null? args) s (begin (string-set! s k (car args)) (fill-string s (fxadd1 k) (cdr args))))))) (lambda args (let ((s (make-string (list-length args)))) (fill-string s 0 args))))
# == eliminate-let*  ==>
# (letrec ((fill-string (lambda (s k args) (if (null? args) s (begin (string-set! s k (car args)) (fill-string s (fxadd1 k) (cdr args))))))) (lambda args (let ((s (make-string (list-length args)))) (fill-string s 0 args))))
# == uniquify-variables  ==>
# (letrec ((f195936 (lambda (f195940 f195941 f195942) (if (null? f195942) f195940 (begin (string-set! f195940 f195941 (car f195942)) (f195936 f195940 (fxadd1 f195941) (cdr f195942))))))) (lambda f195946 (let ((f195948 (make-string (list-length f195946)))) (f195936 f195948 0 f195946))))
# == vectorize-letrec  ==>
# (let ((f195936 (make-vector 1))) (begin (begin (vector-set! f195936 0 (lambda (f195940 f195941 f195942) (if (null? f195942) f195940 (begin (string-set! f195940 f195941 (car f195942)) ((vector-ref f195936 0) f195940 (fxadd1 f195941) (cdr f195942))))))) (lambda f195946 (let ((f195948 (make-string (list-length f195946)))) ((vector-ref f195936 0) f195948 0 f195946)))))
# == eliminate-set!  ==>
# (let ((f195936 (make-vector 1))) (begin (begin (vector-set! f195936 0 (lambda (f195940 f195941 f195942) (let ((f195940 f195940) (f195941 f195941) (f195942 f195942)) (if (null? f195942) f195940 (begin (string-set! f195940 f195941 (car f195942)) ((vector-ref f195936 0) f195940 (fxadd1 f195941) (cdr f195942)))))))) (lambda f195946 (let () (let ((f195948 (make-string (list-length f195946)))) ((vector-ref f195936 0) f195948 0 f195946))))))
# == close-free-variables  ==>
# (let ((f195936 (make-vector 1))) (begin (begin (vector-set! f195936 0 (closure (f195940 f195941 f195942) (f195936) (let ((f195940 f195940) (f195941 f195941) (f195942 f195942)) (if (null? f195942) f195940 (begin (string-set! f195940 f195941 (car f195942)) ((vector-ref f195936 0) f195940 (fxadd1 f195941) (cdr f195942)))))))) (closure f195946 (f195936) (let () (let ((f195948 (make-string (list-length f195946)))) ((vector-ref f195936 0) f195948 0 f195946))))))
# == eliminate-quote  ==>
# (let ((f195936 (make-vector 1))) (begin (begin (vector-set! f195936 0 (closure (f195940 f195941 f195942) (f195936) (let ((f195940 f195940) (f195941 f195941) (f195942 f195942)) (if (null? f195942) f195940 (begin (string-set! f195940 f195941 (car f195942)) ((vector-ref f195936 0) f195940 (fxadd1 f195941) (cdr f195942)))))))) (closure f195946 (f195936) (let () (let ((f195948 (make-string (list-length f195946)))) ((vector-ref f195936 0) f195948 0 f195946))))))
# == eliminate-when/unless  ==>
# (let ((f195936 (make-vector 1))) (begin (begin (vector-set! f195936 0 (closure (f195940 f195941 f195942) (f195936) (let ((f195940 f195940) (f195941 f195941) (f195942 f195942)) (if (null? f195942) f195940 (begin (string-set! f195940 f195941 (car f195942)) ((vector-ref f195936 0) f195940 (fxadd1 f195941) (cdr f195942)))))))) (closure f195946 (f195936) (let () (let ((f195948 (make-string (list-length f195946)))) ((vector-ref f195936 0) f195948 0 f195946))))))
# == eliminate-cond  ==>
# (let ((f195936 (make-vector 1))) (begin (begin (vector-set! f195936 0 (closure (f195940 f195941 f195942) (f195936) (let ((f195940 f195940) (f195941 f195941) (f195942 f195942)) (if (null? f195942) f195940 (begin (string-set! f195940 f195941 (car f195942)) ((vector-ref f195936 0) f195940 (fxadd1 f195941) (cdr f195942)))))))) (closure f195946 (f195936) (let () (let ((f195948 (make-string (list-length f195946)))) ((vector-ref f195936 0) f195948 0 f195946))))))
# == external-symbols  ==>
# (let ((f195936 (make-vector 1))) (begin (begin (vector-set! f195936 0 (closure (f195940 f195941 f195942) (f195936) (let ((f195940 f195940) (f195941 f195941) (f195942 f195942)) (if (null? f195942) f195940 (begin (string-set! f195940 f195941 (car f195942)) ((vector-ref f195936 0) f195940 (fxadd1 f195941) (cdr f195942)))))))) (closure f195946 (f195936) (let () (let ((f195948 (make-string ((primitive-ref list-length) f195946)))) ((vector-ref f195936 0) f195948 0 f195946))))))
# emit-expr (let ((f195936 (make-vector 1))) (begin (begin (vector-set! f195936 0 (closure (f195940 f195941 f195942) (f195936) (let ((f195940 f195940) (f195941 f195941) (f195942 f195942)) (if (null? f195942) f195940 (begin (string-set! f195940 f195941 (car f195942)) ((vector-ref f195936 0) f195940 (fxadd1 f195941) (cdr f195942)))))))) (closure f195946 (f195936) (let () (let ((f195948 (make-string ((primitive-ref list-length) f195946)))) ((vector-ref f195936 0) f195948 0 f195946))))))
# emit-let
#  si   = 0
#  env  = ()
#  bindings = ((f195936 (make-vector 1)))
#  body = (begin (begin (vector-set! f195936 0 (closure (f195940 f195941 f195942) (f195936) (let ((f195940 f195940) (f195941 f195941) (f195942 f195942)) (if (null? f195942) f195940 (begin (string-set! f195940 f195941 (car f195942)) ((vector-ref f195936 0) f195940 (fxadd1 f195941) (cdr f195942)))))))) (closure f195946 (f195936) (let () (let ((f195948 (make-string ((primitive-ref list-length) f195946)))) ((vector-ref f195936 0) f195948 0 f195946)))))
# emit-expr (make-vector 1)
# make-vector 1
# emit-expr 1
    movl $4, %eax     # immed 1
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1423837"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $128,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1423837:
# check the argument is a fixnum >= 0
    cmp $0,%eax
    jge _L_1423838
# invoke error handler eh_length
    .extern mrc_eh$ulength
    movl mrc_eh$ulength, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $128,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1423838:
    movl %eax, %esi
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    orl  $5, %eax
    addl $4, %esi
    addl $4, %esi
    andl $-8, %esi
    addl %esi, %ebp
    movl %eax, 0(%esp)  # stack save
# emit-expr (begin (begin (vector-set! f195936 0 (closure (f195940 f195941 f195942) (f195936) (let ((f195940 f195940) (f195941 f195941) (f195942 f195942)) (if (null? f195942) f195940 (begin (string-set! f195940 f195941 (car f195942)) ((vector-ref f195936 0) f195940 (fxadd1 f195941) (cdr f195942)))))))) (closure f195946 (f195936) (let () (let ((f195948 (make-string ((primitive-ref list-length) f195946)))) ((vector-ref f195936 0) f195948 0 f195946)))))
# emit-begin
#   expr=(begin (begin (vector-set! f195936 0 (closure (f195940 f195941 f195942) (f195936) (let ((f195940 f195940) (f195941 f195941) (f195942 f195942)) (if (null? f195942) f195940 (begin (string-set! f195940 f195941 (car f195942)) ((vector-ref f195936 0) f195940 (fxadd1 f195941) (cdr f195942)))))))) (closure f195946 (f195936) (let () (let ((f195948 (make-string ((primitive-ref list-length) f195946)))) ((vector-ref f195936 0) f195948 0 f195946)))))
#   env=((f195936 . 0))
# emit-expr (begin (vector-set! f195936 0 (closure (f195940 f195941 f195942) (f195936) (let ((f195940 f195940) (f195941 f195941) (f195942 f195942)) (if (null? f195942) f195940 (begin (string-set! f195940 f195941 (car f195942)) ((vector-ref f195936 0) f195940 (fxadd1 f195941) (cdr f195942))))))))
# emit-begin
#   expr=(begin (vector-set! f195936 0 (closure (f195940 f195941 f195942) (f195936) (let ((f195940 f195940) (f195941 f195941) (f195942 f195942)) (if (null? f195942) f195940 (begin (string-set! f195940 f195941 (car f195942)) ((vector-ref f195936 0) f195940 (fxadd1 f195941) (cdr f195942))))))))
#   env=((f195936 . 0))
# emit-expr (vector-set! f195936 0 (closure (f195940 f195941 f195942) (f195936) (let ((f195940 f195940) (f195941 f195941) (f195942 f195942)) (if (null? f195942) f195940 (begin (string-set! f195940 f195941 (car f195942)) ((vector-ref f195936 0) f195940 (fxadd1 f195941) (cdr f195942)))))))
# emit-expr f195936
# emit-variable-ref
# env=((f195936 . 0))
# var=f195936
    movl 0(%esp), %eax  # stack load f195936
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1423839
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1423839:
    movl %eax, -4(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1423840"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1423840:
# check bounds on vector index
    movl -4(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1423842
    cmp  $0,%eax
    jge _L_1423841
_L_1423842:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1423841:
    movl %eax, -8(%esp)
# emit-expr (closure (f195940 f195941 f195942) (f195936) (let ((f195940 f195940) (f195941 f195941) (f195942 f195942)) (if (null? f195942) f195940 (begin (string-set! f195940 f195941 (car f195942)) ((vector-ref f195936 0) f195940 (fxadd1 f195941) (cdr f195942))))))
# emit-closure
# si = -12
# env = ((f195936 . 0))
# expr = (closure (f195940 f195941 f195942) (f195936) (let ((f195940 f195940) (f195941 f195941) (f195942 f195942)) (if (null? f195942) f195940 (begin (string-set! f195940 f195941 (car f195942)) ((vector-ref f195936 0) f195940 (fxadd1 f195941) (cdr f195942))))))
    movl $_L_1423843, 0(%ebp)  # closure label
# emit-variable-ref
# env=((f195936 . 0))
# var=f195936
    movl 0(%esp), %eax  # stack load f195936
# end emit-variable-ref
   movl  %eax, 4(%ebp)  # f195936
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $8, %ebp     # bump ebp
    jmp _L_1423844            # jump around closure body
_L_1423843:
# check argument count
    cmp $12,%eax
    je _L_1423845
# invoke error handler eh_argcount
    .extern mrc_eh$uargcount
    movl mrc_eh$uargcount, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_1423845:
# emit-tail-expr
# si=-20
# env=((f195942 . -16) (f195941 . -12) (f195940 . -8) (f195936 . 4) (f195936 . 0))
# expr=(let ((f195940 f195940) (f195941 f195941) (f195942 f195942)) (if (null? f195942) f195940 (begin (string-set! f195940 f195941 (car f195942)) ((vector-ref f195936 0) f195940 (fxadd1 f195941) (cdr f195942)))))
# emit-tail-let
#  si   = -20
#  env  = ((f195942 . -16) (f195941 . -12) (f195940 . -8) (f195936 . 4) (f195936 . 0))
#  bindings = ((f195940 f195940) (f195941 f195941) (f195942 f195942))
#  body = (if (null? f195942) f195940 (begin (string-set! f195940 f195941 (car f195942)) ((vector-ref f195936 0) f195940 (fxadd1 f195941) (cdr f195942))))
# emit-expr f195940
# emit-variable-ref
# env=((f195942 . -16) (f195941 . -12) (f195940 . -8) (f195936 . 4) (f195936 . 0))
# var=f195940
    movl -8(%esp), %eax  # stack load f195940
# end emit-variable-ref
    movl %eax, -20(%esp)  # stack save
# emit-expr f195941
# emit-variable-ref
# env=((f195942 . -16) (f195941 . -12) (f195940 . -8) (f195936 . 4) (f195936 . 0))
# var=f195941
    movl -12(%esp), %eax  # stack load f195941
# end emit-variable-ref
    movl %eax, -24(%esp)  # stack save
# emit-expr f195942
# emit-variable-ref
# env=((f195942 . -16) (f195941 . -12) (f195940 . -8) (f195936 . 4) (f195936 . 0))
# var=f195942
    movl -16(%esp), %eax  # stack load f195942
# end emit-variable-ref
    movl %eax, -28(%esp)  # stack save
# emit-tail-expr
# si=-32
# env=((f195942 . -28) (f195941 . -24) (f195940 . -20) (f195942 . -16) (f195941 . -12) (f195940 . -8) (f195936 . 4) (f195936 . 0))
# expr=(if (null? f195942) f195940 (begin (string-set! f195940 f195941 (car f195942)) ((vector-ref f195936 0) f195940 (fxadd1 f195941) (cdr f195942))))
# emit-expr (null? f195942)
# emit-expr f195942
# emit-variable-ref
# env=((f195942 . -28) (f195941 . -24) (f195940 . -20) (f195942 . -16) (f195941 . -12) (f195940 . -8) (f195936 . 4) (f195936 . 0))
# var=f195942
    movl -28(%esp), %eax  # stack load f195942
# end emit-variable-ref
    cmp $63, %eax
    mov $0, %eax
    sete %al
    movzbl %al, %eax
    sal $6, %al
    or $47, %al
    cmp $47, %al
    je _L_1423846
# emit-tail-expr
# si=-32
# env=((f195942 . -28) (f195941 . -24) (f195940 . -20) (f195942 . -16) (f195941 . -12) (f195940 . -8) (f195936 . 4) (f195936 . 0))
# expr=f195940
# emit-tail-variable-ref
# emit-variable-ref
# env=((f195942 . -28) (f195941 . -24) (f195940 . -20) (f195942 . -16) (f195941 . -12) (f195940 . -8) (f195936 . 4) (f195936 . 0))
# var=f195940
    movl -20(%esp), %eax  # stack load f195940
# end emit-variable-ref
    ret
# end emit-tail-variable ref
    jmp _L_1423847
_L_1423846:
# emit-tail-expr
# si=-32
# env=((f195942 . -28) (f195941 . -24) (f195940 . -20) (f195942 . -16) (f195941 . -12) (f195940 . -8) (f195936 . 4) (f195936 . 0))
# expr=(begin (string-set! f195940 f195941 (car f195942)) ((vector-ref f195936 0) f195940 (fxadd1 f195941) (cdr f195942)))
# tail-begin (begin (string-set! f195940 f195941 (car f195942)) ((vector-ref f195936 0) f195940 (fxadd1 f195941) (cdr f195942)))
#   env=((f195942 . -28) (f195941 . -24) (f195940 . -20) (f195942 . -16) (f195941 . -12) (f195940 . -8) (f195936 . 4) (f195936 . 0))
# emit-expr (string-set! f195940 f195941 (car f195942))
# emit-expr f195940
# emit-variable-ref
# env=((f195942 . -28) (f195941 . -24) (f195940 . -20) (f195942 . -16) (f195941 . -12) (f195940 . -8) (f195936 . 4) (f195936 . 0))
# var=f195940
    movl -20(%esp), %eax  # stack load f195940
# end emit-variable-ref
# check the argument is a string
    movl %eax,%ebx
    and $7, %bl
    cmp $6, %bl
    je _L_1423848
# invoke error handler eh_string
    .extern mrc_eh$ustring
    movl mrc_eh$ustring, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $160,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1423848:
    movl %eax, -32(%esp)
# emit-expr f195941
# emit-variable-ref
# env=((f195942 . -28) (f195941 . -24) (f195940 . -20) (f195942 . -16) (f195941 . -12) (f195940 . -8) (f195936 . 4) (f195936 . 0))
# var=f195941
    movl -24(%esp), %eax  # stack load f195941
# end emit-variable-ref
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1423849"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $160,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1423849:
# check bounds on string index
    movl -32(%esp), %ebx
    cmp  %eax,-6(%ebx) 
    jle _L_1423851
    cmp  $0,%eax
    jge _L_1423850
_L_1423851:
# invoke error handler eh_string_index
    .extern mrc_eh$ustring$uindex
    movl mrc_eh$ustring$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $160,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1423850:
    movl %eax, -36(%esp)
# emit-expr (car f195942)
# emit-expr f195942
# emit-variable-ref
# env=((f195942 . -28) (f195941 . -24) (f195940 . -20) (f195942 . -16) (f195941 . -12) (f195940 . -8) (f195936 . 4) (f195936 . 0))
# var=f195942
    movl -28(%esp), %eax  # stack load f195942
# end emit-variable-ref
# check the argument is a pair
    movl %eax,%ebx
    and $7, %bl
    cmp $1, %bl
    je _L_1423852
# invoke error handler eh_pair
    .extern mrc_eh$upair
    movl mrc_eh$upair, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $108,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1423852:
    movl -1(%eax), %eax
# check the argument is a char
    movl %eax,%ebx
    and $255, %bl
    cmp $15, %bl
    je "_L_1423853"
# invoke error handler eh_character
    .extern mrc_eh$ucharacter
    movl mrc_eh$ucharacter, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $160,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1423853:
    movl -32(%esp), %ebx
    movl -36(%esp), %esi
    sar $2, %esi
    movb  %ah, -2(%ebx,%esi)
# emit-tail-expr
# si=-32
# env=((f195942 . -28) (f195941 . -24) (f195940 . -20) (f195942 . -16) (f195941 . -12) (f195940 . -8) (f195936 . 4) (f195936 . 0))
# expr=(begin ((vector-ref f195936 0) f195940 (fxadd1 f195941) (cdr f195942)))
# tail-begin (begin ((vector-ref f195936 0) f195940 (fxadd1 f195941) (cdr f195942)))
#   env=((f195942 . -28) (f195941 . -24) (f195940 . -20) (f195942 . -16) (f195941 . -12) (f195940 . -8) (f195936 . 4) (f195936 . 0))
# emit-tail-expr
# si=-32
# env=((f195942 . -28) (f195941 . -24) (f195940 . -20) (f195942 . -16) (f195941 . -12) (f195940 . -8) (f195936 . 4) (f195936 . 0))
# expr=((vector-ref f195936 0) f195940 (fxadd1 f195941) (cdr f195942))
# emit-tail-funcall
#    si   =-32
#    env  = ((f195942 . -28) (f195941 . -24) (f195940 . -20) (f195942 . -16) (f195941 . -12) (f195940 . -8) (f195936 . 4) (f195936 . 0))
#    expr = (funcall (vector-ref f195936 0) f195940 (fxadd1 f195941) (cdr f195942))
# emit-expr (vector-ref f195936 0)
# emit-expr f195936
# emit-variable-ref
# env=((f195942 . -28) (f195941 . -24) (f195940 . -20) (f195942 . -16) (f195941 . -12) (f195940 . -8) (f195936 . 4) (f195936 . 0))
# var=f195936
    movl 2(%edi), %eax  # frame load f195936
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1423854
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1423854:
    movl %eax, -32(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1423855"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1423855:
# check bounds on vector index
    movl -32(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1423857
    cmp  $0,%eax
    jge _L_1423856
_L_1423857:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1423856:
    movl -32(%esp), %esi
    movl -1(%eax,%esi), %eax
   movl %eax,  -32(%esp)  # stash funcall-oper in next closure slot
# emit-expr f195940
# emit-variable-ref
# env=((f195942 . -28) (f195941 . -24) (f195940 . -20) (f195942 . -16) (f195941 . -12) (f195940 . -8) (f195936 . 4) (f195936 . 0))
# var=f195940
    movl -20(%esp), %eax  # stack load f195940
# end emit-variable-ref
    mov %eax, -36(%esp)    # arg f195940
# emit-expr (fxadd1 f195941)
# emit-expr f195941
# emit-variable-ref
# env=((f195942 . -28) (f195941 . -24) (f195940 . -20) (f195942 . -16) (f195941 . -12) (f195940 . -8) (f195936 . 4) (f195936 . 0))
# var=f195941
    movl -24(%esp), %eax  # stack load f195941
# end emit-variable-ref
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1423858"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $48,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1423858:
     addl $4, %eax
    mov %eax, -40(%esp)    # arg (fxadd1 f195941)
# emit-expr (cdr f195942)
# emit-expr f195942
# emit-variable-ref
# env=((f195942 . -28) (f195941 . -24) (f195940 . -20) (f195942 . -16) (f195941 . -12) (f195940 . -8) (f195936 . 4) (f195936 . 0))
# var=f195942
    movl -28(%esp), %eax  # stack load f195942
# end emit-variable-ref
# check the argument is a pair
    movl %eax,%ebx
    and $7, %bl
    cmp $1, %bl
    je _L_1423859
# invoke error handler eh_pair
    .extern mrc_eh$upair
    movl mrc_eh$upair, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $112,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1423859:
    movl 3(%eax), %eax
    mov %eax, -44(%esp)    # arg (cdr f195942)
    movl -32(%esp), %edi   # load new closure to %edi
# emit-shift-args:  size=4   si=-32  delta=28
    mov -32(%esp), %ebx  # shift frame cell
    mov %ebx, -4(%esp)  # down to base
# emit-shift-args:  size=3   si=-36  delta=28
    mov -36(%esp), %ebx  # shift frame cell
    mov %ebx, -8(%esp)  # down to base
# emit-shift-args:  size=2   si=-40  delta=28
    mov -40(%esp), %ebx  # shift frame cell
    mov %ebx, -12(%esp)  # down to base
# emit-shift-args:  size=1   si=-44  delta=28
    mov -44(%esp), %ebx  # shift frame cell
    mov %ebx, -16(%esp)  # down to base
# emit-shift-args:  size=0   si=-48  delta=28
    movl $12,%eax   # save arg count
    jmp *-2(%edi)  # tail-funcall
     ret   # return thru stack
_L_1423847:
    .align 4,0x90
_L_1423844:
    movl -4(%esp), %ebx
    movl -8(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin)
# emit-begin
#   expr=(begin)
#   env=((f195936 . 0))
# emit-expr (begin (closure f195946 (f195936) (let () (let ((f195948 (make-string ((primitive-ref list-length) f195946)))) ((vector-ref f195936 0) f195948 0 f195946)))))
# emit-begin
#   expr=(begin (closure f195946 (f195936) (let () (let ((f195948 (make-string ((primitive-ref list-length) f195946)))) ((vector-ref f195936 0) f195948 0 f195946)))))
#   env=((f195936 . 0))
# emit-expr (closure f195946 (f195936) (let () (let ((f195948 (make-string ((primitive-ref list-length) f195946)))) ((vector-ref f195936 0) f195948 0 f195946))))
# emit-closure
# si = -4
# env = ((f195936 . 0))
# expr = (closure f195946 (f195936) (let () (let ((f195948 (make-string ((primitive-ref list-length) f195946)))) ((vector-ref f195936 0) f195948 0 f195946))))
    movl $_L_1423860, 0(%ebp)  # closure label
# emit-variable-ref
# env=((f195936 . 0))
# var=f195936
    movl 0(%esp), %eax  # stack load f195936
# end emit-variable-ref
   movl  %eax, 4(%ebp)  # f195936
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $8, %ebp     # bump ebp
    jmp _L_1423861            # jump around closure body
_L_1423860:
# check argument count
    cmp $0,%eax
    jge _L_1423862
# invoke error handler eh_argcount_min
    .extern mrc_eh$uargcount$umin
    movl mrc_eh$uargcount$umin, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_1423862:
# emit-build-varargs-list
    movl $63, %esi       # args <- () 
    lea -4(%esp),%edi    # edi <- esp-4
    subl %eax, %edi      # edi <- esp-4-eax    addr of arg[K+N] on stack
_L_1423864:
    lea -4(%esp),%ebx    # addr of arg[K] on stack
    cmp %edi, %ebx       # while edi <> esp+(si+4)
    je _L_1423863
    movl (%edi),%ebx     # arg i -> car
    movl %ebx, 0(%ebp)
    movl %esi, 4(%ebp)  # esi -> cdr
    movl %ebp, %esi
    addl $1, %esi       # tag as pair
    addl $8,%ebp         # bump heap ptr
    addl $4,%edi         # move to next previous arg from the end
    jmp _L_1423864
_L_1423863:
    movl %esi, -8(%esp)  # set args
# emit-tail-expr
# si=-12
# env=((f195946 . -8) (f195936 . 4) (f195936 . 0))
# expr=(let () (let ((f195948 (make-string ((primitive-ref list-length) f195946)))) ((vector-ref f195936 0) f195948 0 f195946)))
# emit-tail-let
#  si   = -12
#  env  = ((f195946 . -8) (f195936 . 4) (f195936 . 0))
#  bindings = ()
#  body = (let ((f195948 (make-string ((primitive-ref list-length) f195946)))) ((vector-ref f195936 0) f195948 0 f195946))
# emit-tail-expr
# si=-12
# env=((f195946 . -8) (f195936 . 4) (f195936 . 0))
# expr=(let ((f195948 (make-string ((primitive-ref list-length) f195946)))) ((vector-ref f195936 0) f195948 0 f195946))
# emit-tail-let
#  si   = -12
#  env  = ((f195946 . -8) (f195936 . 4) (f195936 . 0))
#  bindings = ((f195948 (make-string ((primitive-ref list-length) f195946))))
#  body = ((vector-ref f195936 0) f195948 0 f195946)
# emit-expr (make-string ((primitive-ref list-length) f195946))
# make-string len=((primitive-ref list-length) f195946)
# emit-expr ((primitive-ref list-length) f195946)
# funcall
#    si   =-12
#    env  = ((f195946 . -8) (f195936 . 4) (f195936 . 0))
#    expr = (funcall (primitive-ref list-length) f195946)
# emit-expr (primitive-ref list-length)
    .extern mrc_list$mlength
    movl mrc_list$mlength,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1423865"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1423865":
   movl %eax,  -20(%esp)  # stash funcall-oper in closure slot
# emit-expr f195946
# emit-variable-ref
# env=((f195946 . -8) (f195936 . 4) (f195936 . 0))
# var=f195946
    movl -8(%esp), %eax  # stack load f195946
# end emit-variable-ref
    mov %eax, -24(%esp)  # arg f195946
    movl -20(%esp), %edi   # load new closure to %edi
    add $-12, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $12, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1423866"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1423866:
# check the argument is a fixnum >= 0
    cmp $0,%eax
    jge _L_1423867
# invoke error handler eh_length
    .extern mrc_eh$ulength
    movl mrc_eh$ulength, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1423867:
    movl %eax, %esi
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    orl $6, %eax
    sar $2, %esi
    add $4, %esi
    add $7, %esi
    andl $-8, %esi
    add  %esi, %ebp
# make-string end
    movl %eax, -12(%esp)  # stack save
# emit-tail-expr
# si=-16
# env=((f195948 . -12) (f195946 . -8) (f195936 . 4) (f195936 . 0))
# expr=((vector-ref f195936 0) f195948 0 f195946)
# emit-tail-funcall
#    si   =-16
#    env  = ((f195948 . -12) (f195946 . -8) (f195936 . 4) (f195936 . 0))
#    expr = (funcall (vector-ref f195936 0) f195948 0 f195946)
# emit-expr (vector-ref f195936 0)
# emit-expr f195936
# emit-variable-ref
# env=((f195948 . -12) (f195946 . -8) (f195936 . 4) (f195936 . 0))
# var=f195936
    movl 2(%edi), %eax  # frame load f195936
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1423868
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1423868:
    movl %eax, -16(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1423869"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1423869:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1423871
    cmp  $0,%eax
    jge _L_1423870
_L_1423871:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1423870:
    movl -16(%esp), %esi
    movl -1(%eax,%esi), %eax
   movl %eax,  -16(%esp)  # stash funcall-oper in next closure slot
# emit-expr f195948
# emit-variable-ref
# env=((f195948 . -12) (f195946 . -8) (f195936 . 4) (f195936 . 0))
# var=f195948
    movl -12(%esp), %eax  # stack load f195948
# end emit-variable-ref
    mov %eax, -20(%esp)    # arg f195948
# emit-expr 0
    movl $0, %eax     # immed 0
    mov %eax, -24(%esp)    # arg 0
# emit-expr f195946
# emit-variable-ref
# env=((f195948 . -12) (f195946 . -8) (f195936 . 4) (f195936 . 0))
# var=f195946
    movl -8(%esp), %eax  # stack load f195946
# end emit-variable-ref
    mov %eax, -28(%esp)    # arg f195946
    movl -16(%esp), %edi   # load new closure to %edi
# emit-shift-args:  size=4   si=-16  delta=12
    mov -16(%esp), %ebx  # shift frame cell
    mov %ebx, -4(%esp)  # down to base
# emit-shift-args:  size=3   si=-20  delta=12
    mov -20(%esp), %ebx  # shift frame cell
    mov %ebx, -8(%esp)  # down to base
# emit-shift-args:  size=2   si=-24  delta=12
    mov -24(%esp), %ebx  # shift frame cell
    mov %ebx, -12(%esp)  # down to base
# emit-shift-args:  size=1   si=-28  delta=12
    mov -28(%esp), %ebx  # shift frame cell
    mov %ebx, -16(%esp)  # down to base
# emit-shift-args:  size=0   si=-32  delta=12
    movl $12,%eax   # save arg count
    jmp *-2(%edi)  # tail-funcall
    .align 4,0x90
_L_1423861:
# emit-expr (begin)
# emit-begin
#   expr=(begin)
#   env=((f195936 . 0))
     movl %eax, mrc_string
# == explicit-begins  ==>
# (letrec ((f (lambda (s i) (if (fx= i (string-length s)) (quote ()) (cons (string-ref s i) (f s (fxadd1 i))))))) (lambda (s) (f s 0)))
# == eliminate-let*  ==>
# (letrec ((f (lambda (s i) (if (fx= i (string-length s)) (quote ()) (cons (string-ref s i) (f s (fxadd1 i))))))) (lambda (s) (f s 0)))
# == uniquify-variables  ==>
# (letrec ((f195949 (lambda (f195952 f195953) (if (fx= f195953 (string-length f195952)) (quote ()) (cons (string-ref f195952 f195953) (f195949 f195952 (fxadd1 f195953))))))) (lambda (f195955) (f195949 f195955 0)))
# == vectorize-letrec  ==>
# (let ((f195949 (make-vector 1))) (begin (begin (vector-set! f195949 0 (lambda (f195952 f195953) (if (fx= f195953 (string-length f195952)) (quote ()) (cons (string-ref f195952 f195953) ((vector-ref f195949 0) f195952 (fxadd1 f195953))))))) (lambda (f195955) ((vector-ref f195949 0) f195955 0))))
# == eliminate-set!  ==>
# (let ((f195949 (make-vector 1))) (begin (begin (vector-set! f195949 0 (lambda (f195952 f195953) (let ((f195952 f195952) (f195953 f195953)) (if (fx= f195953 (string-length f195952)) (quote ()) (cons (string-ref f195952 f195953) ((vector-ref f195949 0) f195952 (fxadd1 f195953)))))))) (lambda (f195955) (let ((f195955 f195955)) ((vector-ref f195949 0) f195955 0)))))
# == close-free-variables  ==>
# (let ((f195949 (make-vector 1))) (begin (begin (vector-set! f195949 0 (closure (f195952 f195953) (f195949) (let ((f195952 f195952) (f195953 f195953)) (if (fx= f195953 (string-length f195952)) (quote ()) (cons (string-ref f195952 f195953) ((vector-ref f195949 0) f195952 (fxadd1 f195953)))))))) (closure (f195955) (f195949) (let ((f195955 f195955)) ((vector-ref f195949 0) f195955 0)))))
# == eliminate-quote  ==>
# (let ((f195949 (make-vector 1))) (begin (begin (vector-set! f195949 0 (closure (f195952 f195953) (f195949) (let ((f195952 f195952) (f195953 f195953)) (if (fx= f195953 (string-length f195952)) () (cons (string-ref f195952 f195953) ((vector-ref f195949 0) f195952 (fxadd1 f195953)))))))) (closure (f195955) (f195949) (let ((f195955 f195955)) ((vector-ref f195949 0) f195955 0)))))
# == eliminate-when/unless  ==>
# (let ((f195949 (make-vector 1))) (begin (begin (vector-set! f195949 0 (closure (f195952 f195953) (f195949) (let ((f195952 f195952) (f195953 f195953)) (if (fx= f195953 (string-length f195952)) () (cons (string-ref f195952 f195953) ((vector-ref f195949 0) f195952 (fxadd1 f195953)))))))) (closure (f195955) (f195949) (let ((f195955 f195955)) ((vector-ref f195949 0) f195955 0)))))
# == eliminate-cond  ==>
# (let ((f195949 (make-vector 1))) (begin (begin (vector-set! f195949 0 (closure (f195952 f195953) (f195949) (let ((f195952 f195952) (f195953 f195953)) (if (fx= f195953 (string-length f195952)) () (cons (string-ref f195952 f195953) ((vector-ref f195949 0) f195952 (fxadd1 f195953)))))))) (closure (f195955) (f195949) (let ((f195955 f195955)) ((vector-ref f195949 0) f195955 0)))))
# == external-symbols  ==>
# (let ((f195949 (make-vector 1))) (begin (begin (vector-set! f195949 0 (closure (f195952 f195953) (f195949) (let ((f195952 f195952) (f195953 f195953)) (if (fx= f195953 (string-length f195952)) () (cons (string-ref f195952 f195953) ((vector-ref f195949 0) f195952 (fxadd1 f195953)))))))) (closure (f195955) (f195949) (let ((f195955 f195955)) ((vector-ref f195949 0) f195955 0)))))
# emit-expr (let ((f195949 (make-vector 1))) (begin (begin (vector-set! f195949 0 (closure (f195952 f195953) (f195949) (let ((f195952 f195952) (f195953 f195953)) (if (fx= f195953 (string-length f195952)) () (cons (string-ref f195952 f195953) ((vector-ref f195949 0) f195952 (fxadd1 f195953)))))))) (closure (f195955) (f195949) (let ((f195955 f195955)) ((vector-ref f195949 0) f195955 0)))))
# emit-let
#  si   = 0
#  env  = ()
#  bindings = ((f195949 (make-vector 1)))
#  body = (begin (begin (vector-set! f195949 0 (closure (f195952 f195953) (f195949) (let ((f195952 f195952) (f195953 f195953)) (if (fx= f195953 (string-length f195952)) () (cons (string-ref f195952 f195953) ((vector-ref f195949 0) f195952 (fxadd1 f195953)))))))) (closure (f195955) (f195949) (let ((f195955 f195955)) ((vector-ref f195949 0) f195955 0))))
# emit-expr (make-vector 1)
# make-vector 1
# emit-expr 1
    movl $4, %eax     # immed 1
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1423872"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $128,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1423872:
# check the argument is a fixnum >= 0
    cmp $0,%eax
    jge _L_1423873
# invoke error handler eh_length
    .extern mrc_eh$ulength
    movl mrc_eh$ulength, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $128,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1423873:
    movl %eax, %esi
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    orl  $5, %eax
    addl $4, %esi
    addl $4, %esi
    andl $-8, %esi
    addl %esi, %ebp
    movl %eax, 0(%esp)  # stack save
# emit-expr (begin (begin (vector-set! f195949 0 (closure (f195952 f195953) (f195949) (let ((f195952 f195952) (f195953 f195953)) (if (fx= f195953 (string-length f195952)) () (cons (string-ref f195952 f195953) ((vector-ref f195949 0) f195952 (fxadd1 f195953)))))))) (closure (f195955) (f195949) (let ((f195955 f195955)) ((vector-ref f195949 0) f195955 0))))
# emit-begin
#   expr=(begin (begin (vector-set! f195949 0 (closure (f195952 f195953) (f195949) (let ((f195952 f195952) (f195953 f195953)) (if (fx= f195953 (string-length f195952)) () (cons (string-ref f195952 f195953) ((vector-ref f195949 0) f195952 (fxadd1 f195953)))))))) (closure (f195955) (f195949) (let ((f195955 f195955)) ((vector-ref f195949 0) f195955 0))))
#   env=((f195949 . 0))
# emit-expr (begin (vector-set! f195949 0 (closure (f195952 f195953) (f195949) (let ((f195952 f195952) (f195953 f195953)) (if (fx= f195953 (string-length f195952)) () (cons (string-ref f195952 f195953) ((vector-ref f195949 0) f195952 (fxadd1 f195953))))))))
# emit-begin
#   expr=(begin (vector-set! f195949 0 (closure (f195952 f195953) (f195949) (let ((f195952 f195952) (f195953 f195953)) (if (fx= f195953 (string-length f195952)) () (cons (string-ref f195952 f195953) ((vector-ref f195949 0) f195952 (fxadd1 f195953))))))))
#   env=((f195949 . 0))
# emit-expr (vector-set! f195949 0 (closure (f195952 f195953) (f195949) (let ((f195952 f195952) (f195953 f195953)) (if (fx= f195953 (string-length f195952)) () (cons (string-ref f195952 f195953) ((vector-ref f195949 0) f195952 (fxadd1 f195953)))))))
# emit-expr f195949
# emit-variable-ref
# env=((f195949 . 0))
# var=f195949
    movl 0(%esp), %eax  # stack load f195949
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1423874
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1423874:
    movl %eax, -4(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1423875"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1423875:
# check bounds on vector index
    movl -4(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1423877
    cmp  $0,%eax
    jge _L_1423876
_L_1423877:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1423876:
    movl %eax, -8(%esp)
# emit-expr (closure (f195952 f195953) (f195949) (let ((f195952 f195952) (f195953 f195953)) (if (fx= f195953 (string-length f195952)) () (cons (string-ref f195952 f195953) ((vector-ref f195949 0) f195952 (fxadd1 f195953))))))
# emit-closure
# si = -12
# env = ((f195949 . 0))
# expr = (closure (f195952 f195953) (f195949) (let ((f195952 f195952) (f195953 f195953)) (if (fx= f195953 (string-length f195952)) () (cons (string-ref f195952 f195953) ((vector-ref f195949 0) f195952 (fxadd1 f195953))))))
    movl $_L_1423878, 0(%ebp)  # closure label
# emit-variable-ref
# env=((f195949 . 0))
# var=f195949
    movl 0(%esp), %eax  # stack load f195949
# end emit-variable-ref
   movl  %eax, 4(%ebp)  # f195949
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $8, %ebp     # bump ebp
    jmp _L_1423879            # jump around closure body
_L_1423878:
# check argument count
    cmp $8,%eax
    je _L_1423880
# invoke error handler eh_argcount
    .extern mrc_eh$uargcount
    movl mrc_eh$uargcount, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_1423880:
# emit-tail-expr
# si=-16
# env=((f195953 . -12) (f195952 . -8) (f195949 . 4) (f195949 . 0))
# expr=(let ((f195952 f195952) (f195953 f195953)) (if (fx= f195953 (string-length f195952)) () (cons (string-ref f195952 f195953) ((vector-ref f195949 0) f195952 (fxadd1 f195953)))))
# emit-tail-let
#  si   = -16
#  env  = ((f195953 . -12) (f195952 . -8) (f195949 . 4) (f195949 . 0))
#  bindings = ((f195952 f195952) (f195953 f195953))
#  body = (if (fx= f195953 (string-length f195952)) () (cons (string-ref f195952 f195953) ((vector-ref f195949 0) f195952 (fxadd1 f195953))))
# emit-expr f195952
# emit-variable-ref
# env=((f195953 . -12) (f195952 . -8) (f195949 . 4) (f195949 . 0))
# var=f195952
    movl -8(%esp), %eax  # stack load f195952
# end emit-variable-ref
    movl %eax, -16(%esp)  # stack save
# emit-expr f195953
# emit-variable-ref
# env=((f195953 . -12) (f195952 . -8) (f195949 . 4) (f195949 . 0))
# var=f195953
    movl -12(%esp), %eax  # stack load f195953
# end emit-variable-ref
    movl %eax, -20(%esp)  # stack save
# emit-tail-expr
# si=-24
# env=((f195953 . -20) (f195952 . -16) (f195953 . -12) (f195952 . -8) (f195949 . 4) (f195949 . 0))
# expr=(if (fx= f195953 (string-length f195952)) () (cons (string-ref f195952 f195953) ((vector-ref f195949 0) f195952 (fxadd1 f195953))))
# emit-expr (fx= f195953 (string-length f195952))
# emit-expr (string-length f195952)
# emit-expr f195952
# emit-variable-ref
# env=((f195953 . -20) (f195952 . -16) (f195953 . -12) (f195952 . -8) (f195949 . 4) (f195949 . 0))
# var=f195952
    movl -16(%esp), %eax  # stack load f195952
# end emit-variable-ref
# check the argument is a string
    movl %eax,%ebx
    and $7, %bl
    cmp $6, %bl
    je _L_1423883
# invoke error handler eh_string
    .extern mrc_eh$ustring
    movl mrc_eh$ustring, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $152,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1423883:
    movl -6(%eax), %eax
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1423884"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $60,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1423884:
    movl %eax, -24(%esp)
# emit-expr f195953
# emit-variable-ref
# env=((f195953 . -20) (f195952 . -16) (f195953 . -12) (f195952 . -8) (f195949 . 4) (f195949 . 0))
# var=f195953
    movl -20(%esp), %eax  # stack load f195953
# end emit-variable-ref
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1423885"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $60,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1423885:
    cmp -24(%esp), %eax
    sete %al
    movzbl %al, %eax
    sal $6, %al
    or $47, %al
    cmp $47, %al
    je _L_1423881
# emit-tail-expr
# si=-24
# env=((f195953 . -20) (f195952 . -16) (f195953 . -12) (f195952 . -8) (f195949 . 4) (f195949 . 0))
# expr=()
    movl $63, %eax     # immed ()
    ret                  # immediate tail return
    jmp _L_1423882
_L_1423881:
# emit-tail-expr
# si=-24
# env=((f195953 . -20) (f195952 . -16) (f195953 . -12) (f195952 . -8) (f195949 . 4) (f195949 . 0))
# expr=(cons (string-ref f195952 f195953) ((vector-ref f195949 0) f195952 (fxadd1 f195953)))
# tail primcall
# cons arg1=(string-ref f195952 f195953) arg2=((vector-ref f195949 0) f195952 (fxadd1 f195953))
# emit-expr (string-ref f195952 f195953)
# emit-expr f195952
# emit-variable-ref
# env=((f195953 . -20) (f195952 . -16) (f195953 . -12) (f195952 . -8) (f195949 . 4) (f195949 . 0))
# var=f195952
    movl -16(%esp), %eax  # stack load f195952
# end emit-variable-ref
# check the argument is a string
    movl %eax,%ebx
    and $7, %bl
    cmp $6, %bl
    je _L_1423886
# invoke error handler eh_string
    .extern mrc_eh$ustring
    movl mrc_eh$ustring, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $156,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1423886:
    movl %eax, -24(%esp)
# emit-expr f195953
# emit-variable-ref
# env=((f195953 . -20) (f195952 . -16) (f195953 . -12) (f195952 . -8) (f195949 . 4) (f195949 . 0))
# var=f195953
    movl -20(%esp), %eax  # stack load f195953
# end emit-variable-ref
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1423887"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $156,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1423887:
# check bounds on string index
    movl -24(%esp), %ebx
    cmp  %eax,-6(%ebx) 
    jle _L_1423889
    cmp  $0,%eax
    jge _L_1423888
_L_1423889:
# invoke error handler eh_string_index
    .extern mrc_eh$ustring$uindex
    movl mrc_eh$ustring$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $156,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1423888:
    sar $2, %eax
    movl -24(%esp), %esi
    movl -2(%eax,%esi), %eax
    sal $8, %eax
    or  $15, %eax
    movl %eax, -24(%esp)
# emit-expr ((vector-ref f195949 0) f195952 (fxadd1 f195953))
# funcall
#    si   =-28
#    env  = ((f195953 . -20) (f195952 . -16) (f195953 . -12) (f195952 . -8) (f195949 . 4) (f195949 . 0))
#    expr = (funcall (vector-ref f195949 0) f195952 (fxadd1 f195953))
# emit-expr (vector-ref f195949 0)
# emit-expr f195949
# emit-variable-ref
# env=((f195953 . -20) (f195952 . -16) (f195953 . -12) (f195952 . -8) (f195949 . 4) (f195949 . 0))
# var=f195949
    movl 2(%edi), %eax  # frame load f195949
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1423890
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1423890:
    movl %eax, -36(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1423891"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1423891:
# check bounds on vector index
    movl -36(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1423893
    cmp  $0,%eax
    jge _L_1423892
_L_1423893:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1423892:
    movl -36(%esp), %esi
    movl -1(%eax,%esi), %eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1423894"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1423894":
   movl %eax,  -36(%esp)  # stash funcall-oper in closure slot
# emit-expr f195952
# emit-variable-ref
# env=((f195953 . -20) (f195952 . -16) (f195953 . -12) (f195952 . -8) (f195949 . 4) (f195949 . 0))
# var=f195952
    movl -16(%esp), %eax  # stack load f195952
# end emit-variable-ref
    mov %eax, -40(%esp)  # arg f195952
# emit-expr (fxadd1 f195953)
# emit-expr f195953
# emit-variable-ref
# env=((f195953 . -20) (f195952 . -16) (f195953 . -12) (f195952 . -8) (f195949 . 4) (f195949 . 0))
# var=f195953
    movl -20(%esp), %eax  # stack load f195953
# end emit-variable-ref
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1423895"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $48,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1423895:
     addl $4, %eax
    mov %eax, -44(%esp)  # arg (fxadd1 f195953)
    movl -36(%esp), %edi   # load new closure to %edi
    add $-28, %esp   # adjust base
    movl $8,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $28, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    movl %eax, 4(%ebp)
    movl -24(%esp), %eax
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    or   $1, %al
    add  $8, %ebp
# cons end
#return from tail (cons (string-ref f195952 f195953) ((vector-ref f195949 0) f195952 (fxadd1 f195953)))
    ret
_L_1423882:
    .align 4,0x90
_L_1423879:
    movl -4(%esp), %ebx
    movl -8(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin)
# emit-begin
#   expr=(begin)
#   env=((f195949 . 0))
# emit-expr (begin (closure (f195955) (f195949) (let ((f195955 f195955)) ((vector-ref f195949 0) f195955 0))))
# emit-begin
#   expr=(begin (closure (f195955) (f195949) (let ((f195955 f195955)) ((vector-ref f195949 0) f195955 0))))
#   env=((f195949 . 0))
# emit-expr (closure (f195955) (f195949) (let ((f195955 f195955)) ((vector-ref f195949 0) f195955 0)))
# emit-closure
# si = -4
# env = ((f195949 . 0))
# expr = (closure (f195955) (f195949) (let ((f195955 f195955)) ((vector-ref f195949 0) f195955 0)))
    movl $_L_1423896, 0(%ebp)  # closure label
# emit-variable-ref
# env=((f195949 . 0))
# var=f195949
    movl 0(%esp), %eax  # stack load f195949
# end emit-variable-ref
   movl  %eax, 4(%ebp)  # f195949
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $8, %ebp     # bump ebp
    jmp _L_1423897            # jump around closure body
_L_1423896:
# check argument count
    cmp $4,%eax
    je _L_1423898
# invoke error handler eh_argcount
    .extern mrc_eh$uargcount
    movl mrc_eh$uargcount, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_1423898:
# emit-tail-expr
# si=-12
# env=((f195955 . -8) (f195949 . 4) (f195949 . 0))
# expr=(let ((f195955 f195955)) ((vector-ref f195949 0) f195955 0))
# emit-tail-let
#  si   = -12
#  env  = ((f195955 . -8) (f195949 . 4) (f195949 . 0))
#  bindings = ((f195955 f195955))
#  body = ((vector-ref f195949 0) f195955 0)
# emit-expr f195955
# emit-variable-ref
# env=((f195955 . -8) (f195949 . 4) (f195949 . 0))
# var=f195955
    movl -8(%esp), %eax  # stack load f195955
# end emit-variable-ref
    movl %eax, -12(%esp)  # stack save
# emit-tail-expr
# si=-16
# env=((f195955 . -12) (f195955 . -8) (f195949 . 4) (f195949 . 0))
# expr=((vector-ref f195949 0) f195955 0)
# emit-tail-funcall
#    si   =-16
#    env  = ((f195955 . -12) (f195955 . -8) (f195949 . 4) (f195949 . 0))
#    expr = (funcall (vector-ref f195949 0) f195955 0)
# emit-expr (vector-ref f195949 0)
# emit-expr f195949
# emit-variable-ref
# env=((f195955 . -12) (f195955 . -8) (f195949 . 4) (f195949 . 0))
# var=f195949
    movl 2(%edi), %eax  # frame load f195949
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1423899
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1423899:
    movl %eax, -16(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1423900"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1423900:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1423902
    cmp  $0,%eax
    jge _L_1423901
_L_1423902:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1423901:
    movl -16(%esp), %esi
    movl -1(%eax,%esi), %eax
   movl %eax,  -16(%esp)  # stash funcall-oper in next closure slot
# emit-expr f195955
# emit-variable-ref
# env=((f195955 . -12) (f195955 . -8) (f195949 . 4) (f195949 . 0))
# var=f195955
    movl -12(%esp), %eax  # stack load f195955
# end emit-variable-ref
    mov %eax, -20(%esp)    # arg f195955
# emit-expr 0
    movl $0, %eax     # immed 0
    mov %eax, -24(%esp)    # arg 0
    movl -16(%esp), %edi   # load new closure to %edi
# emit-shift-args:  size=3   si=-16  delta=12
    mov -16(%esp), %ebx  # shift frame cell
    mov %ebx, -4(%esp)  # down to base
# emit-shift-args:  size=2   si=-20  delta=12
    mov -20(%esp), %ebx  # shift frame cell
    mov %ebx, -8(%esp)  # down to base
# emit-shift-args:  size=1   si=-24  delta=12
    mov -24(%esp), %ebx  # shift frame cell
    mov %ebx, -12(%esp)  # down to base
# emit-shift-args:  size=0   si=-28  delta=12
    movl $8,%eax   # save arg count
    jmp *-2(%edi)  # tail-funcall
    .align 4,0x90
_L_1423897:
# emit-expr (begin)
# emit-begin
#   expr=(begin)
#   env=((f195949 . 0))
     movl %eax, mrc_string$m$glist
# == explicit-begins  ==>
# (letrec ((f (lambda (i l) (cond ((fx< i 10) (cons i l)) (else (f (fxquotient i 10) (cons (fxremainder i 10) l))))))) (lambda (i) (f i (quote ()))))
# == eliminate-let*  ==>
# (letrec ((f (lambda (i l) (cond ((fx< i 10) (cons i l)) (else (f (fxquotient i 10) (cons (fxremainder i 10) l))))))) (lambda (i) (f i (quote ()))))
# == uniquify-variables  ==>
# (letrec ((f195956 (lambda (f195959 f195960) (cond ((fx< f195959 10) (cons f195959 f195960)) (else (f195956 (fxquotient f195959 10) (cons (fxremainder f195959 10) f195960))))))) (lambda (f195962) (f195956 f195962 (quote ()))))
# == vectorize-letrec  ==>
# (let ((f195956 (make-vector 1))) (begin (begin (vector-set! f195956 0 (lambda (f195959 f195960) (cond ((fx< f195959 10) (cons f195959 f195960)) (else ((vector-ref f195956 0) (fxquotient f195959 10) (cons (fxremainder f195959 10) f195960))))))) (lambda (f195962) ((vector-ref f195956 0) f195962 (quote ())))))
# == eliminate-set!  ==>
# (let ((f195956 (make-vector 1))) (begin (begin (vector-set! f195956 0 (lambda (f195959 f195960) (let ((f195959 f195959) (f195960 f195960)) (cond ((fx< f195959 10) (cons f195959 f195960)) (else ((vector-ref f195956 0) (fxquotient f195959 10) (cons (fxremainder f195959 10) f195960)))))))) (lambda (f195962) (let ((f195962 f195962)) ((vector-ref f195956 0) f195962 (quote ()))))))
# == close-free-variables  ==>
# (let ((f195956 (make-vector 1))) (begin (begin (vector-set! f195956 0 (closure (f195959 f195960) (else f195956) (let ((f195959 f195959) (f195960 f195960)) (cond ((fx< f195959 10) (cons f195959 f195960)) (else ((vector-ref f195956 0) (fxquotient f195959 10) (cons (fxremainder f195959 10) f195960)))))))) (closure (f195962) (f195956) (let ((f195962 f195962)) ((vector-ref f195956 0) f195962 (quote ()))))))
# == eliminate-quote  ==>
# (let ((f195956 (make-vector 1))) (begin (begin (vector-set! f195956 0 (closure (f195959 f195960) (else f195956) (let ((f195959 f195959) (f195960 f195960)) (cond ((fx< f195959 10) (cons f195959 f195960)) (else ((vector-ref f195956 0) (fxquotient f195959 10) (cons (fxremainder f195959 10) f195960)))))))) (closure (f195962) (f195956) (let ((f195962 f195962)) ((vector-ref f195956 0) f195962 ())))))
# == eliminate-when/unless  ==>
# (let ((f195956 (make-vector 1))) (begin (begin (vector-set! f195956 0 (closure (f195959 f195960) (else f195956) (let ((f195959 f195959) (f195960 f195960)) (cond ((fx< f195959 10) (cons f195959 f195960)) (else ((vector-ref f195956 0) (fxquotient f195959 10) (cons (fxremainder f195959 10) f195960)))))))) (closure (f195962) (f195956) (let ((f195962 f195962)) ((vector-ref f195956 0) f195962 ())))))
# == eliminate-cond  ==>
# (let ((f195956 (make-vector 1))) (begin (begin (vector-set! f195956 0 (closure (f195959 f195960) (else f195956) (let ((f195959 f195959) (f195960 f195960)) (if (fx< f195959 10) (cons f195959 f195960) ((vector-ref f195956 0) (fxquotient f195959 10) (cons (fxremainder f195959 10) f195960))))))) (closure (f195962) (f195956) (let ((f195962 f195962)) ((vector-ref f195956 0) f195962 ())))))
# == external-symbols  ==>
# (let ((f195956 (make-vector 1))) (begin (begin (vector-set! f195956 0 (closure (f195959 f195960) (else f195956) (let ((f195959 f195959) (f195960 f195960)) (if (fx< f195959 10) (cons f195959 f195960) ((vector-ref f195956 0) (fxquotient f195959 10) (cons (fxremainder f195959 10) f195960))))))) (closure (f195962) (f195956) (let ((f195962 f195962)) ((vector-ref f195956 0) f195962 ())))))
# emit-expr (let ((f195956 (make-vector 1))) (begin (begin (vector-set! f195956 0 (closure (f195959 f195960) (else f195956) (let ((f195959 f195959) (f195960 f195960)) (if (fx< f195959 10) (cons f195959 f195960) ((vector-ref f195956 0) (fxquotient f195959 10) (cons (fxremainder f195959 10) f195960))))))) (closure (f195962) (f195956) (let ((f195962 f195962)) ((vector-ref f195956 0) f195962 ())))))
# emit-let
#  si   = 0
#  env  = ()
#  bindings = ((f195956 (make-vector 1)))
#  body = (begin (begin (vector-set! f195956 0 (closure (f195959 f195960) (else f195956) (let ((f195959 f195959) (f195960 f195960)) (if (fx< f195959 10) (cons f195959 f195960) ((vector-ref f195956 0) (fxquotient f195959 10) (cons (fxremainder f195959 10) f195960))))))) (closure (f195962) (f195956) (let ((f195962 f195962)) ((vector-ref f195956 0) f195962 ()))))
# emit-expr (make-vector 1)
# make-vector 1
# emit-expr 1
    movl $4, %eax     # immed 1
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1423903"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $128,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1423903:
# check the argument is a fixnum >= 0
    cmp $0,%eax
    jge _L_1423904
# invoke error handler eh_length
    .extern mrc_eh$ulength
    movl mrc_eh$ulength, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $128,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1423904:
    movl %eax, %esi
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    orl  $5, %eax
    addl $4, %esi
    addl $4, %esi
    andl $-8, %esi
    addl %esi, %ebp
    movl %eax, 0(%esp)  # stack save
# emit-expr (begin (begin (vector-set! f195956 0 (closure (f195959 f195960) (else f195956) (let ((f195959 f195959) (f195960 f195960)) (if (fx< f195959 10) (cons f195959 f195960) ((vector-ref f195956 0) (fxquotient f195959 10) (cons (fxremainder f195959 10) f195960))))))) (closure (f195962) (f195956) (let ((f195962 f195962)) ((vector-ref f195956 0) f195962 ()))))
# emit-begin
#   expr=(begin (begin (vector-set! f195956 0 (closure (f195959 f195960) (else f195956) (let ((f195959 f195959) (f195960 f195960)) (if (fx< f195959 10) (cons f195959 f195960) ((vector-ref f195956 0) (fxquotient f195959 10) (cons (fxremainder f195959 10) f195960))))))) (closure (f195962) (f195956) (let ((f195962 f195962)) ((vector-ref f195956 0) f195962 ()))))
#   env=((f195956 . 0))
# emit-expr (begin (vector-set! f195956 0 (closure (f195959 f195960) (else f195956) (let ((f195959 f195959) (f195960 f195960)) (if (fx< f195959 10) (cons f195959 f195960) ((vector-ref f195956 0) (fxquotient f195959 10) (cons (fxremainder f195959 10) f195960)))))))
# emit-begin
#   expr=(begin (vector-set! f195956 0 (closure (f195959 f195960) (else f195956) (let ((f195959 f195959) (f195960 f195960)) (if (fx< f195959 10) (cons f195959 f195960) ((vector-ref f195956 0) (fxquotient f195959 10) (cons (fxremainder f195959 10) f195960)))))))
#   env=((f195956 . 0))
# emit-expr (vector-set! f195956 0 (closure (f195959 f195960) (else f195956) (let ((f195959 f195959) (f195960 f195960)) (if (fx< f195959 10) (cons f195959 f195960) ((vector-ref f195956 0) (fxquotient f195959 10) (cons (fxremainder f195959 10) f195960))))))
# emit-expr f195956
# emit-variable-ref
# env=((f195956 . 0))
# var=f195956
    movl 0(%esp), %eax  # stack load f195956
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1423905
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1423905:
    movl %eax, -4(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1423906"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1423906:
# check bounds on vector index
    movl -4(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1423908
    cmp  $0,%eax
    jge _L_1423907
_L_1423908:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1423907:
    movl %eax, -8(%esp)
# emit-expr (closure (f195959 f195960) (else f195956) (let ((f195959 f195959) (f195960 f195960)) (if (fx< f195959 10) (cons f195959 f195960) ((vector-ref f195956 0) (fxquotient f195959 10) (cons (fxremainder f195959 10) f195960)))))
# emit-closure
# si = -12
# env = ((f195956 . 0))
# expr = (closure (f195959 f195960) (else f195956) (let ((f195959 f195959) (f195960 f195960)) (if (fx< f195959 10) (cons f195959 f195960) ((vector-ref f195956 0) (fxquotient f195959 10) (cons (fxremainder f195959 10) f195960)))))
    movl $_L_1423909, 0(%ebp)  # closure label
# WARNING: free var else not defined in the environmnet
# emit-variable-ref
# env=((f195956 . 0))
# var=f195956
    movl 0(%esp), %eax  # stack load f195956
# end emit-variable-ref
   movl  %eax, 8(%ebp)  # f195956
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $16, %ebp     # bump ebp
    jmp _L_1423910            # jump around closure body
_L_1423909:
# check argument count
    cmp $8,%eax
    je _L_1423911
# invoke error handler eh_argcount
    .extern mrc_eh$uargcount
    movl mrc_eh$uargcount, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_1423911:
# emit-tail-expr
# si=-16
# env=((f195960 . -12) (f195959 . -8) (f195956 . 8) (else . 4) (f195956 . 0))
# expr=(let ((f195959 f195959) (f195960 f195960)) (if (fx< f195959 10) (cons f195959 f195960) ((vector-ref f195956 0) (fxquotient f195959 10) (cons (fxremainder f195959 10) f195960))))
# emit-tail-let
#  si   = -16
#  env  = ((f195960 . -12) (f195959 . -8) (f195956 . 8) (else . 4) (f195956 . 0))
#  bindings = ((f195959 f195959) (f195960 f195960))
#  body = (if (fx< f195959 10) (cons f195959 f195960) ((vector-ref f195956 0) (fxquotient f195959 10) (cons (fxremainder f195959 10) f195960)))
# emit-expr f195959
# emit-variable-ref
# env=((f195960 . -12) (f195959 . -8) (f195956 . 8) (else . 4) (f195956 . 0))
# var=f195959
    movl -8(%esp), %eax  # stack load f195959
# end emit-variable-ref
    movl %eax, -16(%esp)  # stack save
# emit-expr f195960
# emit-variable-ref
# env=((f195960 . -12) (f195959 . -8) (f195956 . 8) (else . 4) (f195956 . 0))
# var=f195960
    movl -12(%esp), %eax  # stack load f195960
# end emit-variable-ref
    movl %eax, -20(%esp)  # stack save
# emit-tail-expr
# si=-24
# env=((f195960 . -20) (f195959 . -16) (f195960 . -12) (f195959 . -8) (f195956 . 8) (else . 4) (f195956 . 0))
# expr=(if (fx< f195959 10) (cons f195959 f195960) ((vector-ref f195956 0) (fxquotient f195959 10) (cons (fxremainder f195959 10) f195960)))
# emit-expr (fx< f195959 10)
# emit-expr 10
    movl $40, %eax     # immed 10
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1423914"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $64,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1423914:
    movl %eax, -24(%esp)
# emit-expr f195959
# emit-variable-ref
# env=((f195960 . -20) (f195959 . -16) (f195960 . -12) (f195959 . -8) (f195956 . 8) (else . 4) (f195956 . 0))
# var=f195959
    movl -16(%esp), %eax  # stack load f195959
# end emit-variable-ref
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1423915"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $64,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1423915:
    cmp -24(%esp), %eax
    setl %al
    movzbl %al, %eax
    sal $6, %al
    or $47, %al
    cmp $47, %al
    je _L_1423912
# emit-tail-expr
# si=-24
# env=((f195960 . -20) (f195959 . -16) (f195960 . -12) (f195959 . -8) (f195956 . 8) (else . 4) (f195956 . 0))
# expr=(cons f195959 f195960)
# tail primcall
# cons arg1=f195959 arg2=f195960
# emit-expr f195959
# emit-variable-ref
# env=((f195960 . -20) (f195959 . -16) (f195960 . -12) (f195959 . -8) (f195956 . 8) (else . 4) (f195956 . 0))
# var=f195959
    movl -16(%esp), %eax  # stack load f195959
# end emit-variable-ref
    movl %eax, -24(%esp)
# emit-expr f195960
# emit-variable-ref
# env=((f195960 . -20) (f195959 . -16) (f195960 . -12) (f195959 . -8) (f195956 . 8) (else . 4) (f195956 . 0))
# var=f195960
    movl -20(%esp), %eax  # stack load f195960
# end emit-variable-ref
    movl %eax, 4(%ebp)
    movl -24(%esp), %eax
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    or   $1, %al
    add  $8, %ebp
# cons end
#return from tail (cons f195959 f195960)
    ret
    jmp _L_1423913
_L_1423912:
# emit-tail-expr
# si=-24
# env=((f195960 . -20) (f195959 . -16) (f195960 . -12) (f195959 . -8) (f195956 . 8) (else . 4) (f195956 . 0))
# expr=((vector-ref f195956 0) (fxquotient f195959 10) (cons (fxremainder f195959 10) f195960))
# emit-tail-funcall
#    si   =-24
#    env  = ((f195960 . -20) (f195959 . -16) (f195960 . -12) (f195959 . -8) (f195956 . 8) (else . 4) (f195956 . 0))
#    expr = (funcall (vector-ref f195956 0) (fxquotient f195959 10) (cons (fxremainder f195959 10) f195960))
# emit-expr (vector-ref f195956 0)
# emit-expr f195956
# emit-variable-ref
# env=((f195960 . -20) (f195959 . -16) (f195960 . -12) (f195959 . -8) (f195956 . 8) (else . 4) (f195956 . 0))
# var=f195956
    movl 6(%edi), %eax  # frame load f195956
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1423916
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1423916:
    movl %eax, -24(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1423917"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1423917:
# check bounds on vector index
    movl -24(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1423919
    cmp  $0,%eax
    jge _L_1423918
_L_1423919:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1423918:
    movl -24(%esp), %esi
    movl -1(%eax,%esi), %eax
   movl %eax,  -24(%esp)  # stash funcall-oper in next closure slot
# emit-expr (fxquotient f195959 10)
# emit-expr 10
    movl $40, %eax     # immed 10
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1423921"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $92,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1423921:
    movl %eax, -28(%esp)  # denominator
# emit-expr f195959
# emit-variable-ref
# env=((f195960 . -20) (f195959 . -16) (f195960 . -12) (f195959 . -8) (f195956 . 8) (else . 4) (f195956 . 0))
# var=f195959
    movl -16(%esp), %eax  # stack load f195959
# end emit-variable-ref
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1423922"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $92,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1423922:
    movl -28(%esp),%ebx   # ebx <- denominator
    xor %edx,%edx        # edx <- 0
    cmp $0,%eax
    jge _L_1423920
    not %edx
_L_1423920:
    idiv %ebx            # eax <- edx:eax/ebx
    sal $2,%eax          # eax <- eax*4 (since it was divided away)
    mov %eax, -28(%esp)    # arg (fxquotient f195959 10)
# emit-expr (cons (fxremainder f195959 10) f195960)
# cons arg1=(fxremainder f195959 10) arg2=f195960
# emit-expr (fxremainder f195959 10)
# emit-expr 10
    movl $40, %eax     # immed 10
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1423924"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $92,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1423924:
    movl %eax, -32(%esp)  # denominator
# emit-expr f195959
# emit-variable-ref
# env=((f195960 . -20) (f195959 . -16) (f195960 . -12) (f195959 . -8) (f195956 . 8) (else . 4) (f195956 . 0))
# var=f195959
    movl -16(%esp), %eax  # stack load f195959
# end emit-variable-ref
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1423925"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $92,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1423925:
    movl -32(%esp),%ebx   # ebx <- denominator
    xor %edx,%edx        # edx <- 0
    cmp $0,%eax
    jge _L_1423923
    not %edx
_L_1423923:
    idiv %ebx            # edx <- edx:eax/ebx  remainder
    movl %edx,%eax
    movl %eax, -32(%esp)
# emit-expr f195960
# emit-variable-ref
# env=((f195960 . -20) (f195959 . -16) (f195960 . -12) (f195959 . -8) (f195956 . 8) (else . 4) (f195956 . 0))
# var=f195960
    movl -20(%esp), %eax  # stack load f195960
# end emit-variable-ref
    movl %eax, 4(%ebp)
    movl -32(%esp), %eax
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    or   $1, %al
    add  $8, %ebp
# cons end
    mov %eax, -32(%esp)    # arg (cons (fxremainder f195959 10) f195960)
    movl -24(%esp), %edi   # load new closure to %edi
# emit-shift-args:  size=3   si=-24  delta=20
    mov -24(%esp), %ebx  # shift frame cell
    mov %ebx, -4(%esp)  # down to base
# emit-shift-args:  size=2   si=-28  delta=20
    mov -28(%esp), %ebx  # shift frame cell
    mov %ebx, -8(%esp)  # down to base
# emit-shift-args:  size=1   si=-32  delta=20
    mov -32(%esp), %ebx  # shift frame cell
    mov %ebx, -12(%esp)  # down to base
# emit-shift-args:  size=0   si=-36  delta=20
    movl $8,%eax   # save arg count
    jmp *-2(%edi)  # tail-funcall
_L_1423913:
    .align 4,0x90
_L_1423910:
    movl -4(%esp), %ebx
    movl -8(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin)
# emit-begin
#   expr=(begin)
#   env=((f195956 . 0))
# emit-expr (begin (closure (f195962) (f195956) (let ((f195962 f195962)) ((vector-ref f195956 0) f195962 ()))))
# emit-begin
#   expr=(begin (closure (f195962) (f195956) (let ((f195962 f195962)) ((vector-ref f195956 0) f195962 ()))))
#   env=((f195956 . 0))
# emit-expr (closure (f195962) (f195956) (let ((f195962 f195962)) ((vector-ref f195956 0) f195962 ())))
# emit-closure
# si = -4
# env = ((f195956 . 0))
# expr = (closure (f195962) (f195956) (let ((f195962 f195962)) ((vector-ref f195956 0) f195962 ())))
    movl $_L_1423926, 0(%ebp)  # closure label
# emit-variable-ref
# env=((f195956 . 0))
# var=f195956
    movl 0(%esp), %eax  # stack load f195956
# end emit-variable-ref
   movl  %eax, 4(%ebp)  # f195956
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $8, %ebp     # bump ebp
    jmp _L_1423927            # jump around closure body
_L_1423926:
# check argument count
    cmp $4,%eax
    je _L_1423928
# invoke error handler eh_argcount
    .extern mrc_eh$uargcount
    movl mrc_eh$uargcount, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_1423928:
# emit-tail-expr
# si=-12
# env=((f195962 . -8) (f195956 . 4) (f195956 . 0))
# expr=(let ((f195962 f195962)) ((vector-ref f195956 0) f195962 ()))
# emit-tail-let
#  si   = -12
#  env  = ((f195962 . -8) (f195956 . 4) (f195956 . 0))
#  bindings = ((f195962 f195962))
#  body = ((vector-ref f195956 0) f195962 ())
# emit-expr f195962
# emit-variable-ref
# env=((f195962 . -8) (f195956 . 4) (f195956 . 0))
# var=f195962
    movl -8(%esp), %eax  # stack load f195962
# end emit-variable-ref
    movl %eax, -12(%esp)  # stack save
# emit-tail-expr
# si=-16
# env=((f195962 . -12) (f195962 . -8) (f195956 . 4) (f195956 . 0))
# expr=((vector-ref f195956 0) f195962 ())
# emit-tail-funcall
#    si   =-16
#    env  = ((f195962 . -12) (f195962 . -8) (f195956 . 4) (f195956 . 0))
#    expr = (funcall (vector-ref f195956 0) f195962 ())
# emit-expr (vector-ref f195956 0)
# emit-expr f195956
# emit-variable-ref
# env=((f195962 . -12) (f195962 . -8) (f195956 . 4) (f195956 . 0))
# var=f195956
    movl 2(%edi), %eax  # frame load f195956
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1423929
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1423929:
    movl %eax, -16(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1423930"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1423930:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1423932
    cmp  $0,%eax
    jge _L_1423931
_L_1423932:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1423931:
    movl -16(%esp), %esi
    movl -1(%eax,%esi), %eax
   movl %eax,  -16(%esp)  # stash funcall-oper in next closure slot
# emit-expr f195962
# emit-variable-ref
# env=((f195962 . -12) (f195962 . -8) (f195956 . 4) (f195956 . 0))
# var=f195962
    movl -12(%esp), %eax  # stack load f195962
# end emit-variable-ref
    mov %eax, -20(%esp)    # arg f195962
# emit-expr ()
    movl $63, %eax     # immed ()
    mov %eax, -24(%esp)    # arg ()
    movl -16(%esp), %edi   # load new closure to %edi
# emit-shift-args:  size=3   si=-16  delta=12
    mov -16(%esp), %ebx  # shift frame cell
    mov %ebx, -4(%esp)  # down to base
# emit-shift-args:  size=2   si=-20  delta=12
    mov -20(%esp), %ebx  # shift frame cell
    mov %ebx, -8(%esp)  # down to base
# emit-shift-args:  size=1   si=-24  delta=12
    mov -24(%esp), %ebx  # shift frame cell
    mov %ebx, -12(%esp)  # down to base
# emit-shift-args:  size=0   si=-28  delta=12
    movl $8,%eax   # save arg count
    jmp *-2(%edi)  # tail-funcall
    .align 4,0x90
_L_1423927:
# emit-expr (begin)
# emit-begin
#   expr=(begin)
#   env=((f195956 . 0))
     movl %eax, mrc_integer$m$glist
# == explicit-begins  ==>
# (let* ((write-stderr (lambda (s) (foreign-call "s_write" 2 s (string-length s)))) (write-errmsg (lambda (sym emsg) (begin (write-stderr "error:") (write-stderr (symbol->string sym)) (write-stderr ": ") (write-stderr emsg) (write-stderr "\n"))))) (lambda (sym emsg) (begin (write-errmsg sym emsg) (foreign-call "s_exit" 1))))
# == eliminate-let*  ==>
# (let ((write-stderr (lambda (s) (foreign-call "s_write" 2 s (string-length s))))) (let ((write-errmsg (lambda (sym emsg) (begin (write-stderr "error:") (write-stderr (symbol->string sym)) (write-stderr ": ") (write-stderr emsg) (write-stderr "\n"))))) (lambda (sym emsg) (begin (write-errmsg sym emsg) (foreign-call "s_exit" 1)))))
# == uniquify-variables  ==>
# (let ((f195963 (lambda (f195964) (foreign-call "s_write" 2 f195964 (string-length f195964))))) (let ((f195972 (lambda (f195973 f195974) (begin (f195963 "error:") (f195963 (symbol->string f195973)) (f195963 ": ") (f195963 f195974) (f195963 "\n"))))) (lambda (f195977 f195978) (begin (f195972 f195977 f195978) (foreign-call "s_exit" 1)))))
# == vectorize-letrec  ==>
# (let ((f195963 (lambda (f195964) (foreign-call "s_write" 2 f195964 (string-length f195964))))) (let ((f195972 (lambda (f195973 f195974) (begin (f195963 "error:") (f195963 (symbol->string f195973)) (f195963 ": ") (f195963 f195974) (f195963 "\n"))))) (lambda (f195977 f195978) (begin (f195972 f195977 f195978) (foreign-call "s_exit" 1)))))
# == eliminate-set!  ==>
# (let ((f195963 (lambda (f195964) (let ((f195964 f195964)) (foreign-call "s_write" 2 f195964 (string-length f195964)))))) (let ((f195972 (lambda (f195973 f195974) (let ((f195973 f195973) (f195974 f195974)) (begin (f195963 "error:") (f195963 (symbol->string f195973)) (f195963 ": ") (f195963 f195974) (f195963 "\n")))))) (lambda (f195977 f195978) (let ((f195977 f195977) (f195978 f195978)) (begin (f195972 f195977 f195978) (foreign-call "s_exit" 1))))))
# == close-free-variables  ==>
# (let ((f195963 (closure (f195964) () (let ((f195964 f195964)) (foreign-call "s_write" 2 f195964 (string-length f195964)))))) (let ((f195972 (closure (f195973 f195974) (f195963 f195963 f195963 f195963 f195963) (let ((f195973 f195973) (f195974 f195974)) (begin (f195963 "error:") (f195963 (symbol->string f195973)) (f195963 ": ") (f195963 f195974) (f195963 "\n")))))) (closure (f195977 f195978) (f195972) (let ((f195977 f195977) (f195978 f195978)) (begin (f195972 f195977 f195978) (foreign-call "s_exit" 1))))))
# == eliminate-quote  ==>
# (let ((f195963 (closure (f195964) () (let ((f195964 f195964)) (foreign-call "s_write" 2 f195964 (string-length f195964)))))) (let ((f195972 (closure (f195973 f195974) (f195963 f195963 f195963 f195963 f195963) (let ((f195973 f195973) (f195974 f195974)) (begin (f195963 "error:") (f195963 (symbol->string f195973)) (f195963 ": ") (f195963 f195974) (f195963 "\n")))))) (closure (f195977 f195978) (f195972) (let ((f195977 f195977) (f195978 f195978)) (begin (f195972 f195977 f195978) (foreign-call "s_exit" 1))))))
# == eliminate-when/unless  ==>
# (let ((f195963 (closure (f195964) () (let ((f195964 f195964)) (foreign-call "s_write" 2 f195964 (string-length f195964)))))) (let ((f195972 (closure (f195973 f195974) (f195963 f195963 f195963 f195963 f195963) (let ((f195973 f195973) (f195974 f195974)) (begin (f195963 "error:") (f195963 (symbol->string f195973)) (f195963 ": ") (f195963 f195974) (f195963 "\n")))))) (closure (f195977 f195978) (f195972) (let ((f195977 f195977) (f195978 f195978)) (begin (f195972 f195977 f195978) (foreign-call "s_exit" 1))))))
# == eliminate-cond  ==>
# (let ((f195963 (closure (f195964) () (let ((f195964 f195964)) (foreign-call "s_write" 2 f195964 (string-length f195964)))))) (let ((f195972 (closure (f195973 f195974) (f195963 f195963 f195963 f195963 f195963) (let ((f195973 f195973) (f195974 f195974)) (begin (f195963 "error:") (f195963 (symbol->string f195973)) (f195963 ": ") (f195963 f195974) (f195963 "\n")))))) (closure (f195977 f195978) (f195972) (let ((f195977 f195977) (f195978 f195978)) (begin (f195972 f195977 f195978) (foreign-call "s_exit" 1))))))
# == external-symbols  ==>
# (let ((f195963 (closure (f195964) () (let ((f195964 f195964)) (foreign-call "s_write" 2 f195964 (string-length f195964)))))) (let ((f195972 (closure (f195973 f195974) (f195963 f195963 f195963 f195963 f195963) (let ((f195973 f195973) (f195974 f195974)) (begin (f195963 "error:") (f195963 (symbol->string f195973)) (f195963 ": ") (f195963 f195974) (f195963 "\n")))))) (closure (f195977 f195978) (f195972) (let ((f195977 f195977) (f195978 f195978)) (begin (f195972 f195977 f195978) (foreign-call "s_exit" 1))))))
# emit-expr (let ((f195963 (closure (f195964) () (let ((f195964 f195964)) (foreign-call "s_write" 2 f195964 (string-length f195964)))))) (let ((f195972 (closure (f195973 f195974) (f195963 f195963 f195963 f195963 f195963) (let ((f195973 f195973) (f195974 f195974)) (begin (f195963 "error:") (f195963 (symbol->string f195973)) (f195963 ": ") (f195963 f195974) (f195963 "\n")))))) (closure (f195977 f195978) (f195972) (let ((f195977 f195977) (f195978 f195978)) (begin (f195972 f195977 f195978) (foreign-call "s_exit" 1))))))
# emit-let
#  si   = 0
#  env  = ()
#  bindings = ((f195963 (closure (f195964) () (let ((f195964 f195964)) (foreign-call "s_write" 2 f195964 (string-length f195964))))))
#  body = (let ((f195972 (closure (f195973 f195974) (f195963 f195963 f195963 f195963 f195963) (let ((f195973 f195973) (f195974 f195974)) (begin (f195963 "error:") (f195963 (symbol->string f195973)) (f195963 ": ") (f195963 f195974) (f195963 "\n")))))) (closure (f195977 f195978) (f195972) (let ((f195977 f195977) (f195978 f195978)) (begin (f195972 f195977 f195978) (foreign-call "s_exit" 1)))))
# emit-expr (closure (f195964) () (let ((f195964 f195964)) (foreign-call "s_write" 2 f195964 (string-length f195964))))
# emit-closure
# si = 0
# env = ()
# expr = (closure (f195964) () (let ((f195964 f195964)) (foreign-call "s_write" 2 f195964 (string-length f195964))))
    movl $_L_1423933, 0(%ebp)  # closure label
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $8, %ebp     # bump ebp
    jmp _L_1423934            # jump around closure body
_L_1423933:
# check argument count
    cmp $4,%eax
    je _L_1423935
# invoke error handler eh_argcount
    .extern mrc_eh$uargcount
    movl mrc_eh$uargcount, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_1423935:
# emit-tail-expr
# si=-12
# env=((f195964 . -8))
# expr=(let ((f195964 f195964)) (foreign-call "s_write" 2 f195964 (string-length f195964)))
# emit-tail-let
#  si   = -12
#  env  = ((f195964 . -8))
#  bindings = ((f195964 f195964))
#  body = (foreign-call "s_write" 2 f195964 (string-length f195964))
# emit-expr f195964
# emit-variable-ref
# env=((f195964 . -8))
# var=f195964
    movl -8(%esp), %eax  # stack load f195964
# end emit-variable-ref
    movl %eax, -12(%esp)  # stack save
# emit-tail-expr
# si=-16
# env=((f195964 . -12) (f195964 . -8))
# expr=(foreign-call "s_write" 2 f195964 (string-length f195964))
    movl %ecx,-16(%esp)
    movl %esp,-20(%esp)
# emit-expr (string-length f195964)
# emit-expr f195964
# emit-variable-ref
# env=((f195964 . -12) (f195964 . -8))
# var=f195964
    movl -12(%esp), %eax  # stack load f195964
# end emit-variable-ref
# check the argument is a string
    movl %eax,%ebx
    and $7, %bl
    cmp $6, %bl
    je _L_1423936
# invoke error handler eh_string
    .extern mrc_eh$ustring
    movl mrc_eh$ustring, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $152,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1423936:
    movl -6(%eax), %eax
    movl %eax, -24(%esp)
# emit-expr f195964
# emit-variable-ref
# env=((f195964 . -12) (f195964 . -8))
# var=f195964
    movl -12(%esp), %eax  # stack load f195964
# end emit-variable-ref
    movl %eax, -28(%esp)
# emit-expr 2
    movl $8, %eax     # immed 2
    movl %eax, -32(%esp)
    leal -32(%esp),%edi
    movl %edi,%esi
    andl $-16,%esi
    movl 0(%edi),%eax
    movl %eax,0(%esi)
    movl 4(%edi),%eax
    movl %eax,4(%esi)
    movl 8(%edi),%eax
    movl %eax,8(%esi)
    movl 12(%edi),%eax
    movl %eax,12(%esi)
    movl %esi,%esp
    .extern _s_write
    call _s_write
    movl 12(%esi),%esp
    movl -16(%esp),%ecx
     ret
    .align 4,0x90
_L_1423934:
    movl %eax, 0(%esp)  # stack save
# emit-expr (let ((f195972 (closure (f195973 f195974) (f195963 f195963 f195963 f195963 f195963) (let ((f195973 f195973) (f195974 f195974)) (begin (f195963 "error:") (f195963 (symbol->string f195973)) (f195963 ": ") (f195963 f195974) (f195963 "\n")))))) (closure (f195977 f195978) (f195972) (let ((f195977 f195977) (f195978 f195978)) (begin (f195972 f195977 f195978) (foreign-call "s_exit" 1)))))
# emit-let
#  si   = -4
#  env  = ((f195963 . 0))
#  bindings = ((f195972 (closure (f195973 f195974) (f195963 f195963 f195963 f195963 f195963) (let ((f195973 f195973) (f195974 f195974)) (begin (f195963 "error:") (f195963 (symbol->string f195973)) (f195963 ": ") (f195963 f195974) (f195963 "\n"))))))
#  body = (closure (f195977 f195978) (f195972) (let ((f195977 f195977) (f195978 f195978)) (begin (f195972 f195977 f195978) (foreign-call "s_exit" 1))))
# emit-expr (closure (f195973 f195974) (f195963 f195963 f195963 f195963 f195963) (let ((f195973 f195973) (f195974 f195974)) (begin (f195963 "error:") (f195963 (symbol->string f195973)) (f195963 ": ") (f195963 f195974) (f195963 "\n"))))
# emit-closure
# si = -4
# env = ((f195963 . 0))
# expr = (closure (f195973 f195974) (f195963 f195963 f195963 f195963 f195963) (let ((f195973 f195973) (f195974 f195974)) (begin (f195963 "error:") (f195963 (symbol->string f195973)) (f195963 ": ") (f195963 f195974) (f195963 "\n"))))
    movl $_L_1423937, 0(%ebp)  # closure label
# emit-variable-ref
# env=((f195963 . 0))
# var=f195963
    movl 0(%esp), %eax  # stack load f195963
# end emit-variable-ref
   movl  %eax, 4(%ebp)  # f195963
# emit-variable-ref
# env=((f195963 . 0))
# var=f195963
    movl 0(%esp), %eax  # stack load f195963
# end emit-variable-ref
   movl  %eax, 8(%ebp)  # f195963
# emit-variable-ref
# env=((f195963 . 0))
# var=f195963
    movl 0(%esp), %eax  # stack load f195963
# end emit-variable-ref
   movl  %eax, 12(%ebp)  # f195963
# emit-variable-ref
# env=((f195963 . 0))
# var=f195963
    movl 0(%esp), %eax  # stack load f195963
# end emit-variable-ref
   movl  %eax, 16(%ebp)  # f195963
# emit-variable-ref
# env=((f195963 . 0))
# var=f195963
    movl 0(%esp), %eax  # stack load f195963
# end emit-variable-ref
   movl  %eax, 20(%ebp)  # f195963
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $24, %ebp     # bump ebp
    jmp _L_1423938            # jump around closure body
_L_1423937:
# check argument count
    cmp $8,%eax
    je _L_1423939
# invoke error handler eh_argcount
    .extern mrc_eh$uargcount
    movl mrc_eh$uargcount, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_1423939:
# emit-tail-expr
# si=-16
# env=((f195974 . -12) (f195973 . -8) (f195963 . 20) (f195963 . 16) (f195963 . 12) (f195963 . 8) (f195963 . 4) (f195963 . 0))
# expr=(let ((f195973 f195973) (f195974 f195974)) (begin (f195963 "error:") (f195963 (symbol->string f195973)) (f195963 ": ") (f195963 f195974) (f195963 "\n")))
# emit-tail-let
#  si   = -16
#  env  = ((f195974 . -12) (f195973 . -8) (f195963 . 20) (f195963 . 16) (f195963 . 12) (f195963 . 8) (f195963 . 4) (f195963 . 0))
#  bindings = ((f195973 f195973) (f195974 f195974))
#  body = (begin (f195963 "error:") (f195963 (symbol->string f195973)) (f195963 ": ") (f195963 f195974) (f195963 "\n"))
# emit-expr f195973
# emit-variable-ref
# env=((f195974 . -12) (f195973 . -8) (f195963 . 20) (f195963 . 16) (f195963 . 12) (f195963 . 8) (f195963 . 4) (f195963 . 0))
# var=f195973
    movl -8(%esp), %eax  # stack load f195973
# end emit-variable-ref
    movl %eax, -16(%esp)  # stack save
# emit-expr f195974
# emit-variable-ref
# env=((f195974 . -12) (f195973 . -8) (f195963 . 20) (f195963 . 16) (f195963 . 12) (f195963 . 8) (f195963 . 4) (f195963 . 0))
# var=f195974
    movl -12(%esp), %eax  # stack load f195974
# end emit-variable-ref
    movl %eax, -20(%esp)  # stack save
# emit-tail-expr
# si=-24
# env=((f195974 . -20) (f195973 . -16) (f195974 . -12) (f195973 . -8) (f195963 . 20) (f195963 . 16) (f195963 . 12) (f195963 . 8) (f195963 . 4) (f195963 . 0))
# expr=(begin (f195963 "error:") (f195963 (symbol->string f195973)) (f195963 ": ") (f195963 f195974) (f195963 "\n"))
# tail-begin (begin (f195963 "error:") (f195963 (symbol->string f195973)) (f195963 ": ") (f195963 f195974) (f195963 "\n"))
#   env=((f195974 . -20) (f195973 . -16) (f195974 . -12) (f195973 . -8) (f195963 . 20) (f195963 . 16) (f195963 . 12) (f195963 . 8) (f195963 . 4) (f195963 . 0))
# emit-expr (f195963 "error:")
# funcall
#    si   =-24
#    env  = ((f195974 . -20) (f195973 . -16) (f195974 . -12) (f195973 . -8) (f195963 . 20) (f195963 . 16) (f195963 . 12) (f195963 . 8) (f195963 . 4) (f195963 . 0))
#    expr = (funcall f195963 "error:")
# emit-expr f195963
# emit-variable-ref
# env=((f195974 . -20) (f195973 . -16) (f195974 . -12) (f195973 . -8) (f195963 . 20) (f195963 . 16) (f195963 . 12) (f195963 . 8) (f195963 . 4) (f195963 . 0))
# var=f195963
    movl 18(%edi), %eax  # frame load f195963
# end emit-variable-ref
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1423940"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1423940":
   movl %eax,  -32(%esp)  # stash funcall-oper in closure slot
# emit-expr "error:"
# string literal
    jmp _L_1423942
    .align 8,0x90
_L_1423941 :
    .int 24
    .ascii "error:"
_L_1423942:
    movl $_L_1423941, %eax
    orl $6, %eax
    mov %eax, -36(%esp)  # arg error:
    movl -32(%esp), %edi   # load new closure to %edi
    add $-24, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $24, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
# emit-tail-expr
# si=-24
# env=((f195974 . -20) (f195973 . -16) (f195974 . -12) (f195973 . -8) (f195963 . 20) (f195963 . 16) (f195963 . 12) (f195963 . 8) (f195963 . 4) (f195963 . 0))
# expr=(begin (f195963 (symbol->string f195973)) (f195963 ": ") (f195963 f195974) (f195963 "\n"))
# tail-begin (begin (f195963 (symbol->string f195973)) (f195963 ": ") (f195963 f195974) (f195963 "\n"))
#   env=((f195974 . -20) (f195973 . -16) (f195974 . -12) (f195973 . -8) (f195963 . 20) (f195963 . 16) (f195963 . 12) (f195963 . 8) (f195963 . 4) (f195963 . 0))
# emit-expr (f195963 (symbol->string f195973))
# funcall
#    si   =-24
#    env  = ((f195974 . -20) (f195973 . -16) (f195974 . -12) (f195973 . -8) (f195963 . 20) (f195963 . 16) (f195963 . 12) (f195963 . 8) (f195963 . 4) (f195963 . 0))
#    expr = (funcall f195963 (symbol->string f195973))
# emit-expr f195963
# emit-variable-ref
# env=((f195974 . -20) (f195973 . -16) (f195974 . -12) (f195973 . -8) (f195963 . 20) (f195963 . 16) (f195963 . 12) (f195963 . 8) (f195963 . 4) (f195963 . 0))
# var=f195963
    movl 18(%edi), %eax  # frame load f195963
# end emit-variable-ref
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1423943"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1423943":
   movl %eax,  -32(%esp)  # stash funcall-oper in closure slot
# emit-expr (symbol->string f195973)
# symbol->string f195973
# emit-expr f195973
# emit-variable-ref
# env=((f195974 . -20) (f195973 . -16) (f195974 . -12) (f195973 . -8) (f195963 . 20) (f195963 . 16) (f195963 . 12) (f195963 . 8) (f195963 . 4) (f195963 . 0))
# var=f195973
    movl -16(%esp), %eax  # stack load f195973
# end emit-variable-ref
    movl -3(%eax), %eax
    mov %eax, -36(%esp)  # arg (symbol->string f195973)
    movl -32(%esp), %edi   # load new closure to %edi
    add $-24, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $24, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
# emit-tail-expr
# si=-24
# env=((f195974 . -20) (f195973 . -16) (f195974 . -12) (f195973 . -8) (f195963 . 20) (f195963 . 16) (f195963 . 12) (f195963 . 8) (f195963 . 4) (f195963 . 0))
# expr=(begin (f195963 ": ") (f195963 f195974) (f195963 "\n"))
# tail-begin (begin (f195963 ": ") (f195963 f195974) (f195963 "\n"))
#   env=((f195974 . -20) (f195973 . -16) (f195974 . -12) (f195973 . -8) (f195963 . 20) (f195963 . 16) (f195963 . 12) (f195963 . 8) (f195963 . 4) (f195963 . 0))
# emit-expr (f195963 ": ")
# funcall
#    si   =-24
#    env  = ((f195974 . -20) (f195973 . -16) (f195974 . -12) (f195973 . -8) (f195963 . 20) (f195963 . 16) (f195963 . 12) (f195963 . 8) (f195963 . 4) (f195963 . 0))
#    expr = (funcall f195963 ": ")
# emit-expr f195963
# emit-variable-ref
# env=((f195974 . -20) (f195973 . -16) (f195974 . -12) (f195973 . -8) (f195963 . 20) (f195963 . 16) (f195963 . 12) (f195963 . 8) (f195963 . 4) (f195963 . 0))
# var=f195963
    movl 18(%edi), %eax  # frame load f195963
# end emit-variable-ref
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1423944"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1423944":
   movl %eax,  -32(%esp)  # stash funcall-oper in closure slot
# emit-expr ": "
# string literal
    jmp _L_1423946
    .align 8,0x90
_L_1423945 :
    .int 8
    .ascii ": "
_L_1423946:
    movl $_L_1423945, %eax
    orl $6, %eax
    mov %eax, -36(%esp)  # arg : 
    movl -32(%esp), %edi   # load new closure to %edi
    add $-24, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $24, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
# emit-tail-expr
# si=-24
# env=((f195974 . -20) (f195973 . -16) (f195974 . -12) (f195973 . -8) (f195963 . 20) (f195963 . 16) (f195963 . 12) (f195963 . 8) (f195963 . 4) (f195963 . 0))
# expr=(begin (f195963 f195974) (f195963 "\n"))
# tail-begin (begin (f195963 f195974) (f195963 "\n"))
#   env=((f195974 . -20) (f195973 . -16) (f195974 . -12) (f195973 . -8) (f195963 . 20) (f195963 . 16) (f195963 . 12) (f195963 . 8) (f195963 . 4) (f195963 . 0))
# emit-expr (f195963 f195974)
# funcall
#    si   =-24
#    env  = ((f195974 . -20) (f195973 . -16) (f195974 . -12) (f195973 . -8) (f195963 . 20) (f195963 . 16) (f195963 . 12) (f195963 . 8) (f195963 . 4) (f195963 . 0))
#    expr = (funcall f195963 f195974)
# emit-expr f195963
# emit-variable-ref
# env=((f195974 . -20) (f195973 . -16) (f195974 . -12) (f195973 . -8) (f195963 . 20) (f195963 . 16) (f195963 . 12) (f195963 . 8) (f195963 . 4) (f195963 . 0))
# var=f195963
    movl 18(%edi), %eax  # frame load f195963
# end emit-variable-ref
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1423947"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1423947":
   movl %eax,  -32(%esp)  # stash funcall-oper in closure slot
# emit-expr f195974
# emit-variable-ref
# env=((f195974 . -20) (f195973 . -16) (f195974 . -12) (f195973 . -8) (f195963 . 20) (f195963 . 16) (f195963 . 12) (f195963 . 8) (f195963 . 4) (f195963 . 0))
# var=f195974
    movl -20(%esp), %eax  # stack load f195974
# end emit-variable-ref
    mov %eax, -36(%esp)  # arg f195974
    movl -32(%esp), %edi   # load new closure to %edi
    add $-24, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $24, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
# emit-tail-expr
# si=-24
# env=((f195974 . -20) (f195973 . -16) (f195974 . -12) (f195973 . -8) (f195963 . 20) (f195963 . 16) (f195963 . 12) (f195963 . 8) (f195963 . 4) (f195963 . 0))
# expr=(begin (f195963 "\n"))
# tail-begin (begin (f195963 "\n"))
#   env=((f195974 . -20) (f195973 . -16) (f195974 . -12) (f195973 . -8) (f195963 . 20) (f195963 . 16) (f195963 . 12) (f195963 . 8) (f195963 . 4) (f195963 . 0))
# emit-tail-expr
# si=-24
# env=((f195974 . -20) (f195973 . -16) (f195974 . -12) (f195973 . -8) (f195963 . 20) (f195963 . 16) (f195963 . 12) (f195963 . 8) (f195963 . 4) (f195963 . 0))
# expr=(f195963 "\n")
# emit-tail-funcall
#    si   =-24
#    env  = ((f195974 . -20) (f195973 . -16) (f195974 . -12) (f195973 . -8) (f195963 . 20) (f195963 . 16) (f195963 . 12) (f195963 . 8) (f195963 . 4) (f195963 . 0))
#    expr = (funcall f195963 "\n")
# emit-expr f195963
# emit-variable-ref
# env=((f195974 . -20) (f195973 . -16) (f195974 . -12) (f195973 . -8) (f195963 . 20) (f195963 . 16) (f195963 . 12) (f195963 . 8) (f195963 . 4) (f195963 . 0))
# var=f195963
    movl 18(%edi), %eax  # frame load f195963
# end emit-variable-ref
   movl %eax,  -24(%esp)  # stash funcall-oper in next closure slot
# emit-expr "\n"
# string literal
    jmp _L_1423949
    .align 8,0x90
_L_1423948 :
    .int 4
    .ascii "\n"
_L_1423949:
    movl $_L_1423948, %eax
    orl $6, %eax
    mov %eax, -28(%esp)    # arg 

    movl -24(%esp), %edi   # load new closure to %edi
# emit-shift-args:  size=2   si=-24  delta=20
    mov -24(%esp), %ebx  # shift frame cell
    mov %ebx, -4(%esp)  # down to base
# emit-shift-args:  size=1   si=-28  delta=20
    mov -28(%esp), %ebx  # shift frame cell
    mov %ebx, -8(%esp)  # down to base
# emit-shift-args:  size=0   si=-32  delta=20
    movl $4,%eax   # save arg count
    jmp *-2(%edi)  # tail-funcall
     ret   # return thru stack
    .align 4,0x90
_L_1423938:
    movl %eax, -4(%esp)  # stack save
# emit-expr (closure (f195977 f195978) (f195972) (let ((f195977 f195977) (f195978 f195978)) (begin (f195972 f195977 f195978) (foreign-call "s_exit" 1))))
# emit-closure
# si = -8
# env = ((f195972 . -4) (f195963 . 0))
# expr = (closure (f195977 f195978) (f195972) (let ((f195977 f195977) (f195978 f195978)) (begin (f195972 f195977 f195978) (foreign-call "s_exit" 1))))
    movl $_L_1423950, 0(%ebp)  # closure label
# emit-variable-ref
# env=((f195972 . -4) (f195963 . 0))
# var=f195972
    movl -4(%esp), %eax  # stack load f195972
# end emit-variable-ref
   movl  %eax, 4(%ebp)  # f195972
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $8, %ebp     # bump ebp
    jmp _L_1423951            # jump around closure body
_L_1423950:
# check argument count
    cmp $8,%eax
    je _L_1423952
# invoke error handler eh_argcount
    .extern mrc_eh$uargcount
    movl mrc_eh$uargcount, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_1423952:
# emit-tail-expr
# si=-16
# env=((f195978 . -12) (f195977 . -8) (f195972 . 4) (f195972 . -4) (f195963 . 0))
# expr=(let ((f195977 f195977) (f195978 f195978)) (begin (f195972 f195977 f195978) (foreign-call "s_exit" 1)))
# emit-tail-let
#  si   = -16
#  env  = ((f195978 . -12) (f195977 . -8) (f195972 . 4) (f195972 . -4) (f195963 . 0))
#  bindings = ((f195977 f195977) (f195978 f195978))
#  body = (begin (f195972 f195977 f195978) (foreign-call "s_exit" 1))
# emit-expr f195977
# emit-variable-ref
# env=((f195978 . -12) (f195977 . -8) (f195972 . 4) (f195972 . -4) (f195963 . 0))
# var=f195977
    movl -8(%esp), %eax  # stack load f195977
# end emit-variable-ref
    movl %eax, -16(%esp)  # stack save
# emit-expr f195978
# emit-variable-ref
# env=((f195978 . -12) (f195977 . -8) (f195972 . 4) (f195972 . -4) (f195963 . 0))
# var=f195978
    movl -12(%esp), %eax  # stack load f195978
# end emit-variable-ref
    movl %eax, -20(%esp)  # stack save
# emit-tail-expr
# si=-24
# env=((f195978 . -20) (f195977 . -16) (f195978 . -12) (f195977 . -8) (f195972 . 4) (f195972 . -4) (f195963 . 0))
# expr=(begin (f195972 f195977 f195978) (foreign-call "s_exit" 1))
# tail-begin (begin (f195972 f195977 f195978) (foreign-call "s_exit" 1))
#   env=((f195978 . -20) (f195977 . -16) (f195978 . -12) (f195977 . -8) (f195972 . 4) (f195972 . -4) (f195963 . 0))
# emit-expr (f195972 f195977 f195978)
# funcall
#    si   =-24
#    env  = ((f195978 . -20) (f195977 . -16) (f195978 . -12) (f195977 . -8) (f195972 . 4) (f195972 . -4) (f195963 . 0))
#    expr = (funcall f195972 f195977 f195978)
# emit-expr f195972
# emit-variable-ref
# env=((f195978 . -20) (f195977 . -16) (f195978 . -12) (f195977 . -8) (f195972 . 4) (f195972 . -4) (f195963 . 0))
# var=f195972
    movl 2(%edi), %eax  # frame load f195972
# end emit-variable-ref
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1423953"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1423953":
   movl %eax,  -32(%esp)  # stash funcall-oper in closure slot
# emit-expr f195977
# emit-variable-ref
# env=((f195978 . -20) (f195977 . -16) (f195978 . -12) (f195977 . -8) (f195972 . 4) (f195972 . -4) (f195963 . 0))
# var=f195977
    movl -16(%esp), %eax  # stack load f195977
# end emit-variable-ref
    mov %eax, -36(%esp)  # arg f195977
# emit-expr f195978
# emit-variable-ref
# env=((f195978 . -20) (f195977 . -16) (f195978 . -12) (f195977 . -8) (f195972 . 4) (f195972 . -4) (f195963 . 0))
# var=f195978
    movl -20(%esp), %eax  # stack load f195978
# end emit-variable-ref
    mov %eax, -40(%esp)  # arg f195978
    movl -32(%esp), %edi   # load new closure to %edi
    add $-24, %esp   # adjust base
    movl $8,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $24, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
# emit-tail-expr
# si=-24
# env=((f195978 . -20) (f195977 . -16) (f195978 . -12) (f195977 . -8) (f195972 . 4) (f195972 . -4) (f195963 . 0))
# expr=(begin (foreign-call "s_exit" 1))
# tail-begin (begin (foreign-call "s_exit" 1))
#   env=((f195978 . -20) (f195977 . -16) (f195978 . -12) (f195977 . -8) (f195972 . 4) (f195972 . -4) (f195963 . 0))
# emit-tail-expr
# si=-24
# env=((f195978 . -20) (f195977 . -16) (f195978 . -12) (f195977 . -8) (f195972 . 4) (f195972 . -4) (f195963 . 0))
# expr=(foreign-call "s_exit" 1)
    movl %ecx,-24(%esp)
    movl %esp,-28(%esp)
# emit-expr 1
    movl $4, %eax     # immed 1
    movl %eax, -32(%esp)
    leal -32(%esp),%edi
    movl %edi,%esi
    andl $-16,%esi
    movl 0(%edi),%eax
    movl %eax,0(%esi)
    movl 4(%edi),%eax
    movl %eax,4(%esi)
    movl %esi,%esp
    .extern _s_exit
    call _s_exit
    movl 4(%esi),%esp
    movl -24(%esp),%ecx
     ret
     ret   # return thru stack
    .align 4,0x90
_L_1423951:
     movl %eax, mrc_error
# == explicit-begins  ==>
# (let ((p (quote ()))) (begin (set! p (cons (quote procedure?) p)) (set! p (cons (quote cdr) p)) (set! p (cons (quote car) p)) (set! p (cons (quote symbol-value) p)) (set! p (cons (quote symbol->string) p)) (set! p (cons (quote make-symbol) p)) (set! p (cons (quote symbol?) p)) (set! p (cons (quote string-set!) p)) (set! p (cons (quote string-ref) p)) (set! p (cons (quote string-length) p)) (set! p (cons (quote string?) p)) (set! p (cons (quote make-string) p)) (set! p (cons (quote vector-ref) p)) (set! p (cons (quote vector-set!) p)) (set! p (cons (quote vector-length) p)) (set! p (cons (quote make-vector) p)) (set! p (cons (quote vector?) p)) (set! p (cons (quote set-cdr!) p)) (set! p (cons (quote set-car!) p)) (set! p (cons (quote cdr) p)) (set! p (cons (quote car) p)) (set! p (cons (quote cons) p)) (set! p (cons (quote pair?) p)) (set! p (cons (quote fxremainder) p)) (set! p (cons (quote fxquotient) p)) (set! p (cons (quote fx*) p)) (set! p (cons (quote fx-) p)) (set! p (cons (quote fx+) p)) (set! p (cons (quote fx>=) p)) (set! p (cons (quote fx>) p)) (set! p (cons (quote fx<=) p)) (set! p (cons (quote fx<) p)) (set! p (cons (quote fx=) p)) (set! p (cons (quote fxzero?) p)) (set! p (cons (quote fxsub1) p)) (set! p (cons (quote fxadd1) p)) (set! p (cons (quote fxlogor) p)) (set! p (cons (quote fxlogand) p)) (set! p (cons (quote fxlognot) p)) (set! p (cons (quote char=?) p)) (set! p (cons (quote eq?) p)) (set! p (cons (quote not) p)) (set! p (cons (quote boolean?) p)) (set! p (cons (quote fixnum?) p)) (set! p (cons (quote char?) p)) (set! p (cons (quote null?) p)) (set! p (cons (quote char->fixnum) p)) (set! p (cons (quote fixnum->char) p)) (lambda () p)))
# == eliminate-let*  ==>
# (let ((p (quote ()))) (begin (set! p (cons (quote procedure?) p)) (set! p (cons (quote cdr) p)) (set! p (cons (quote car) p)) (set! p (cons (quote symbol-value) p)) (set! p (cons (quote symbol->string) p)) (set! p (cons (quote make-symbol) p)) (set! p (cons (quote symbol?) p)) (set! p (cons (quote string-set!) p)) (set! p (cons (quote string-ref) p)) (set! p (cons (quote string-length) p)) (set! p (cons (quote string?) p)) (set! p (cons (quote make-string) p)) (set! p (cons (quote vector-ref) p)) (set! p (cons (quote vector-set!) p)) (set! p (cons (quote vector-length) p)) (set! p (cons (quote make-vector) p)) (set! p (cons (quote vector?) p)) (set! p (cons (quote set-cdr!) p)) (set! p (cons (quote set-car!) p)) (set! p (cons (quote cdr) p)) (set! p (cons (quote car) p)) (set! p (cons (quote cons) p)) (set! p (cons (quote pair?) p)) (set! p (cons (quote fxremainder) p)) (set! p (cons (quote fxquotient) p)) (set! p (cons (quote fx*) p)) (set! p (cons (quote fx-) p)) (set! p (cons (quote fx+) p)) (set! p (cons (quote fx>=) p)) (set! p (cons (quote fx>) p)) (set! p (cons (quote fx<=) p)) (set! p (cons (quote fx<) p)) (set! p (cons (quote fx=) p)) (set! p (cons (quote fxzero?) p)) (set! p (cons (quote fxsub1) p)) (set! p (cons (quote fxadd1) p)) (set! p (cons (quote fxlogor) p)) (set! p (cons (quote fxlogand) p)) (set! p (cons (quote fxlognot) p)) (set! p (cons (quote char=?) p)) (set! p (cons (quote eq?) p)) (set! p (cons (quote not) p)) (set! p (cons (quote boolean?) p)) (set! p (cons (quote fixnum?) p)) (set! p (cons (quote char?) p)) (set! p (cons (quote null?) p)) (set! p (cons (quote char->fixnum) p)) (set! p (cons (quote fixnum->char) p)) (lambda () p)))
# == uniquify-variables  ==>
# (let ((f195979 (quote ()))) (begin (set! f195979 (cons (quote procedure?) f195979)) (set! f195979 (cons (quote cdr) f195979)) (set! f195979 (cons (quote car) f195979)) (set! f195979 (cons (quote symbol-value) f195979)) (set! f195979 (cons (quote symbol->string) f195979)) (set! f195979 (cons (quote make-symbol) f195979)) (set! f195979 (cons (quote symbol?) f195979)) (set! f195979 (cons (quote string-set!) f195979)) (set! f195979 (cons (quote string-ref) f195979)) (set! f195979 (cons (quote string-length) f195979)) (set! f195979 (cons (quote string?) f195979)) (set! f195979 (cons (quote make-string) f195979)) (set! f195979 (cons (quote vector-ref) f195979)) (set! f195979 (cons (quote vector-set!) f195979)) (set! f195979 (cons (quote vector-length) f195979)) (set! f195979 (cons (quote make-vector) f195979)) (set! f195979 (cons (quote vector?) f195979)) (set! f195979 (cons (quote set-cdr!) f195979)) (set! f195979 (cons (quote set-car!) f195979)) (set! f195979 (cons (quote cdr) f195979)) (set! f195979 (cons (quote car) f195979)) (set! f195979 (cons (quote cons) f195979)) (set! f195979 (cons (quote pair?) f195979)) (set! f195979 (cons (quote fxremainder) f195979)) (set! f195979 (cons (quote fxquotient) f195979)) (set! f195979 (cons (quote fx*) f195979)) (set! f195979 (cons (quote fx-) f195979)) (set! f195979 (cons (quote fx+) f195979)) (set! f195979 (cons (quote fx>=) f195979)) (set! f195979 (cons (quote fx>) f195979)) (set! f195979 (cons (quote fx<=) f195979)) (set! f195979 (cons (quote fx<) f195979)) (set! f195979 (cons (quote fx=) f195979)) (set! f195979 (cons (quote fxzero?) f195979)) (set! f195979 (cons (quote fxsub1) f195979)) (set! f195979 (cons (quote fxadd1) f195979)) (set! f195979 (cons (quote fxlogor) f195979)) (set! f195979 (cons (quote fxlogand) f195979)) (set! f195979 (cons (quote fxlognot) f195979)) (set! f195979 (cons (quote char=?) f195979)) (set! f195979 (cons (quote eq?) f195979)) (set! f195979 (cons (quote not) f195979)) (set! f195979 (cons (quote boolean?) f195979)) (set! f195979 (cons (quote fixnum?) f195979)) (set! f195979 (cons (quote char?) f195979)) (set! f195979 (cons (quote null?) f195979)) (set! f195979 (cons (quote char->fixnum) f195979)) (set! f195979 (cons (quote fixnum->char) f195979)) (lambda () f195979)))
# == vectorize-letrec  ==>
# (let ((f195979 (quote ()))) (begin (set! f195979 (cons (quote procedure?) f195979)) (set! f195979 (cons (quote cdr) f195979)) (set! f195979 (cons (quote car) f195979)) (set! f195979 (cons (quote symbol-value) f195979)) (set! f195979 (cons (quote symbol->string) f195979)) (set! f195979 (cons (quote make-symbol) f195979)) (set! f195979 (cons (quote symbol?) f195979)) (set! f195979 (cons (quote string-set!) f195979)) (set! f195979 (cons (quote string-ref) f195979)) (set! f195979 (cons (quote string-length) f195979)) (set! f195979 (cons (quote string?) f195979)) (set! f195979 (cons (quote make-string) f195979)) (set! f195979 (cons (quote vector-ref) f195979)) (set! f195979 (cons (quote vector-set!) f195979)) (set! f195979 (cons (quote vector-length) f195979)) (set! f195979 (cons (quote make-vector) f195979)) (set! f195979 (cons (quote vector?) f195979)) (set! f195979 (cons (quote set-cdr!) f195979)) (set! f195979 (cons (quote set-car!) f195979)) (set! f195979 (cons (quote cdr) f195979)) (set! f195979 (cons (quote car) f195979)) (set! f195979 (cons (quote cons) f195979)) (set! f195979 (cons (quote pair?) f195979)) (set! f195979 (cons (quote fxremainder) f195979)) (set! f195979 (cons (quote fxquotient) f195979)) (set! f195979 (cons (quote fx*) f195979)) (set! f195979 (cons (quote fx-) f195979)) (set! f195979 (cons (quote fx+) f195979)) (set! f195979 (cons (quote fx>=) f195979)) (set! f195979 (cons (quote fx>) f195979)) (set! f195979 (cons (quote fx<=) f195979)) (set! f195979 (cons (quote fx<) f195979)) (set! f195979 (cons (quote fx=) f195979)) (set! f195979 (cons (quote fxzero?) f195979)) (set! f195979 (cons (quote fxsub1) f195979)) (set! f195979 (cons (quote fxadd1) f195979)) (set! f195979 (cons (quote fxlogor) f195979)) (set! f195979 (cons (quote fxlogand) f195979)) (set! f195979 (cons (quote fxlognot) f195979)) (set! f195979 (cons (quote char=?) f195979)) (set! f195979 (cons (quote eq?) f195979)) (set! f195979 (cons (quote not) f195979)) (set! f195979 (cons (quote boolean?) f195979)) (set! f195979 (cons (quote fixnum?) f195979)) (set! f195979 (cons (quote char?) f195979)) (set! f195979 (cons (quote null?) f195979)) (set! f195979 (cons (quote char->fixnum) f195979)) (set! f195979 (cons (quote fixnum->char) f195979)) (lambda () f195979)))
# == eliminate-set!  ==>
# (let ((f195979 (vector (quote ())))) (begin (vector-set! f195979 0 (cons (quote procedure?) (vector-ref f195979 0))) (vector-set! f195979 0 (cons (quote cdr) (vector-ref f195979 0))) (vector-set! f195979 0 (cons (quote car) (vector-ref f195979 0))) (vector-set! f195979 0 (cons (quote symbol-value) (vector-ref f195979 0))) (vector-set! f195979 0 (cons (quote symbol->string) (vector-ref f195979 0))) (vector-set! f195979 0 (cons (quote make-symbol) (vector-ref f195979 0))) (vector-set! f195979 0 (cons (quote symbol?) (vector-ref f195979 0))) (vector-set! f195979 0 (cons (quote string-set!) (vector-ref f195979 0))) (vector-set! f195979 0 (cons (quote string-ref) (vector-ref f195979 0))) (vector-set! f195979 0 (cons (quote string-length) (vector-ref f195979 0))) (vector-set! f195979 0 (cons (quote string?) (vector-ref f195979 0))) (vector-set! f195979 0 (cons (quote make-string) (vector-ref f195979 0))) (vector-set! f195979 0 (cons (quote vector-ref) (vector-ref f195979 0))) (vector-set! f195979 0 (cons (quote vector-set!) (vector-ref f195979 0))) (vector-set! f195979 0 (cons (quote vector-length) (vector-ref f195979 0))) (vector-set! f195979 0 (cons (quote make-vector) (vector-ref f195979 0))) (vector-set! f195979 0 (cons (quote vector?) (vector-ref f195979 0))) (vector-set! f195979 0 (cons (quote set-cdr!) (vector-ref f195979 0))) (vector-set! f195979 0 (cons (quote set-car!) (vector-ref f195979 0))) (vector-set! f195979 0 (cons (quote cdr) (vector-ref f195979 0))) (vector-set! f195979 0 (cons (quote car) (vector-ref f195979 0))) (vector-set! f195979 0 (cons (quote cons) (vector-ref f195979 0))) (vector-set! f195979 0 (cons (quote pair?) (vector-ref f195979 0))) (vector-set! f195979 0 (cons (quote fxremainder) (vector-ref f195979 0))) (vector-set! f195979 0 (cons (quote fxquotient) (vector-ref f195979 0))) (vector-set! f195979 0 (cons (quote fx*) (vector-ref f195979 0))) (vector-set! f195979 0 (cons (quote fx-) (vector-ref f195979 0))) (vector-set! f195979 0 (cons (quote fx+) (vector-ref f195979 0))) (vector-set! f195979 0 (cons (quote fx>=) (vector-ref f195979 0))) (vector-set! f195979 0 (cons (quote fx>) (vector-ref f195979 0))) (vector-set! f195979 0 (cons (quote fx<=) (vector-ref f195979 0))) (vector-set! f195979 0 (cons (quote fx<) (vector-ref f195979 0))) (vector-set! f195979 0 (cons (quote fx=) (vector-ref f195979 0))) (vector-set! f195979 0 (cons (quote fxzero?) (vector-ref f195979 0))) (vector-set! f195979 0 (cons (quote fxsub1) (vector-ref f195979 0))) (vector-set! f195979 0 (cons (quote fxadd1) (vector-ref f195979 0))) (vector-set! f195979 0 (cons (quote fxlogor) (vector-ref f195979 0))) (vector-set! f195979 0 (cons (quote fxlogand) (vector-ref f195979 0))) (vector-set! f195979 0 (cons (quote fxlognot) (vector-ref f195979 0))) (vector-set! f195979 0 (cons (quote char=?) (vector-ref f195979 0))) (vector-set! f195979 0 (cons (quote eq?) (vector-ref f195979 0))) (vector-set! f195979 0 (cons (quote not) (vector-ref f195979 0))) (vector-set! f195979 0 (cons (quote boolean?) (vector-ref f195979 0))) (vector-set! f195979 0 (cons (quote fixnum?) (vector-ref f195979 0))) (vector-set! f195979 0 (cons (quote char?) (vector-ref f195979 0))) (vector-set! f195979 0 (cons (quote null?) (vector-ref f195979 0))) (vector-set! f195979 0 (cons (quote char->fixnum) (vector-ref f195979 0))) (vector-set! f195979 0 (cons (quote fixnum->char) (vector-ref f195979 0))) (lambda () (let () (vector-ref f195979 0)))))
# == close-free-variables  ==>
# (let ((f195979 (vector (quote ())))) (begin (vector-set! f195979 0 (cons (quote procedure?) (vector-ref f195979 0))) (vector-set! f195979 0 (cons (quote cdr) (vector-ref f195979 0))) (vector-set! f195979 0 (cons (quote car) (vector-ref f195979 0))) (vector-set! f195979 0 (cons (quote symbol-value) (vector-ref f195979 0))) (vector-set! f195979 0 (cons (quote symbol->string) (vector-ref f195979 0))) (vector-set! f195979 0 (cons (quote make-symbol) (vector-ref f195979 0))) (vector-set! f195979 0 (cons (quote symbol?) (vector-ref f195979 0))) (vector-set! f195979 0 (cons (quote string-set!) (vector-ref f195979 0))) (vector-set! f195979 0 (cons (quote string-ref) (vector-ref f195979 0))) (vector-set! f195979 0 (cons (quote string-length) (vector-ref f195979 0))) (vector-set! f195979 0 (cons (quote string?) (vector-ref f195979 0))) (vector-set! f195979 0 (cons (quote make-string) (vector-ref f195979 0))) (vector-set! f195979 0 (cons (quote vector-ref) (vector-ref f195979 0))) (vector-set! f195979 0 (cons (quote vector-set!) (vector-ref f195979 0))) (vector-set! f195979 0 (cons (quote vector-length) (vector-ref f195979 0))) (vector-set! f195979 0 (cons (quote make-vector) (vector-ref f195979 0))) (vector-set! f195979 0 (cons (quote vector?) (vector-ref f195979 0))) (vector-set! f195979 0 (cons (quote set-cdr!) (vector-ref f195979 0))) (vector-set! f195979 0 (cons (quote set-car!) (vector-ref f195979 0))) (vector-set! f195979 0 (cons (quote cdr) (vector-ref f195979 0))) (vector-set! f195979 0 (cons (quote car) (vector-ref f195979 0))) (vector-set! f195979 0 (cons (quote cons) (vector-ref f195979 0))) (vector-set! f195979 0 (cons (quote pair?) (vector-ref f195979 0))) (vector-set! f195979 0 (cons (quote fxremainder) (vector-ref f195979 0))) (vector-set! f195979 0 (cons (quote fxquotient) (vector-ref f195979 0))) (vector-set! f195979 0 (cons (quote fx*) (vector-ref f195979 0))) (vector-set! f195979 0 (cons (quote fx-) (vector-ref f195979 0))) (vector-set! f195979 0 (cons (quote fx+) (vector-ref f195979 0))) (vector-set! f195979 0 (cons (quote fx>=) (vector-ref f195979 0))) (vector-set! f195979 0 (cons (quote fx>) (vector-ref f195979 0))) (vector-set! f195979 0 (cons (quote fx<=) (vector-ref f195979 0))) (vector-set! f195979 0 (cons (quote fx<) (vector-ref f195979 0))) (vector-set! f195979 0 (cons (quote fx=) (vector-ref f195979 0))) (vector-set! f195979 0 (cons (quote fxzero?) (vector-ref f195979 0))) (vector-set! f195979 0 (cons (quote fxsub1) (vector-ref f195979 0))) (vector-set! f195979 0 (cons (quote fxadd1) (vector-ref f195979 0))) (vector-set! f195979 0 (cons (quote fxlogor) (vector-ref f195979 0))) (vector-set! f195979 0 (cons (quote fxlogand) (vector-ref f195979 0))) (vector-set! f195979 0 (cons (quote fxlognot) (vector-ref f195979 0))) (vector-set! f195979 0 (cons (quote char=?) (vector-ref f195979 0))) (vector-set! f195979 0 (cons (quote eq?) (vector-ref f195979 0))) (vector-set! f195979 0 (cons (quote not) (vector-ref f195979 0))) (vector-set! f195979 0 (cons (quote boolean?) (vector-ref f195979 0))) (vector-set! f195979 0 (cons (quote fixnum?) (vector-ref f195979 0))) (vector-set! f195979 0 (cons (quote char?) (vector-ref f195979 0))) (vector-set! f195979 0 (cons (quote null?) (vector-ref f195979 0))) (vector-set! f195979 0 (cons (quote char->fixnum) (vector-ref f195979 0))) (vector-set! f195979 0 (cons (quote fixnum->char) (vector-ref f195979 0))) (closure () (f195979) (let () (vector-ref f195979 0)))))
# == eliminate-quote  ==>
# (let ((f195979 (vector ()))) (begin (vector-set! f195979 0 (cons (string->symbol "procedure?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons (string->symbol "cdr") (vector-ref f195979 0))) (vector-set! f195979 0 (cons (string->symbol "car") (vector-ref f195979 0))) (vector-set! f195979 0 (cons (string->symbol "symbol-value") (vector-ref f195979 0))) (vector-set! f195979 0 (cons (string->symbol "symbol->string") (vector-ref f195979 0))) (vector-set! f195979 0 (cons (string->symbol "make-symbol") (vector-ref f195979 0))) (vector-set! f195979 0 (cons (string->symbol "symbol?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons (string->symbol "string-set!") (vector-ref f195979 0))) (vector-set! f195979 0 (cons (string->symbol "string-ref") (vector-ref f195979 0))) (vector-set! f195979 0 (cons (string->symbol "string-length") (vector-ref f195979 0))) (vector-set! f195979 0 (cons (string->symbol "string?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons (string->symbol "make-string") (vector-ref f195979 0))) (vector-set! f195979 0 (cons (string->symbol "vector-ref") (vector-ref f195979 0))) (vector-set! f195979 0 (cons (string->symbol "vector-set!") (vector-ref f195979 0))) (vector-set! f195979 0 (cons (string->symbol "vector-length") (vector-ref f195979 0))) (vector-set! f195979 0 (cons (string->symbol "make-vector") (vector-ref f195979 0))) (vector-set! f195979 0 (cons (string->symbol "vector?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons (string->symbol "set-cdr!") (vector-ref f195979 0))) (vector-set! f195979 0 (cons (string->symbol "set-car!") (vector-ref f195979 0))) (vector-set! f195979 0 (cons (string->symbol "cdr") (vector-ref f195979 0))) (vector-set! f195979 0 (cons (string->symbol "car") (vector-ref f195979 0))) (vector-set! f195979 0 (cons (string->symbol "cons") (vector-ref f195979 0))) (vector-set! f195979 0 (cons (string->symbol "pair?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons (string->symbol "fxremainder") (vector-ref f195979 0))) (vector-set! f195979 0 (cons (string->symbol "fxquotient") (vector-ref f195979 0))) (vector-set! f195979 0 (cons (string->symbol "fx*") (vector-ref f195979 0))) (vector-set! f195979 0 (cons (string->symbol "fx-") (vector-ref f195979 0))) (vector-set! f195979 0 (cons (string->symbol "fx+") (vector-ref f195979 0))) (vector-set! f195979 0 (cons (string->symbol "fx>=") (vector-ref f195979 0))) (vector-set! f195979 0 (cons (string->symbol "fx>") (vector-ref f195979 0))) (vector-set! f195979 0 (cons (string->symbol "fx<=") (vector-ref f195979 0))) (vector-set! f195979 0 (cons (string->symbol "fx<") (vector-ref f195979 0))) (vector-set! f195979 0 (cons (string->symbol "fx=") (vector-ref f195979 0))) (vector-set! f195979 0 (cons (string->symbol "fxzero?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons (string->symbol "fxsub1") (vector-ref f195979 0))) (vector-set! f195979 0 (cons (string->symbol "fxadd1") (vector-ref f195979 0))) (vector-set! f195979 0 (cons (string->symbol "fxlogor") (vector-ref f195979 0))) (vector-set! f195979 0 (cons (string->symbol "fxlogand") (vector-ref f195979 0))) (vector-set! f195979 0 (cons (string->symbol "fxlognot") (vector-ref f195979 0))) (vector-set! f195979 0 (cons (string->symbol "char=?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons (string->symbol "eq?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons (string->symbol "not") (vector-ref f195979 0))) (vector-set! f195979 0 (cons (string->symbol "boolean?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons (string->symbol "fixnum?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons (string->symbol "char?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons (string->symbol "null?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons (string->symbol "char->fixnum") (vector-ref f195979 0))) (vector-set! f195979 0 (cons (string->symbol "fixnum->char") (vector-ref f195979 0))) (closure () (f195979) (let () (vector-ref f195979 0)))))
# == eliminate-when/unless  ==>
# (let ((f195979 (vector ()))) (begin (vector-set! f195979 0 (cons (string->symbol "procedure?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons (string->symbol "cdr") (vector-ref f195979 0))) (vector-set! f195979 0 (cons (string->symbol "car") (vector-ref f195979 0))) (vector-set! f195979 0 (cons (string->symbol "symbol-value") (vector-ref f195979 0))) (vector-set! f195979 0 (cons (string->symbol "symbol->string") (vector-ref f195979 0))) (vector-set! f195979 0 (cons (string->symbol "make-symbol") (vector-ref f195979 0))) (vector-set! f195979 0 (cons (string->symbol "symbol?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons (string->symbol "string-set!") (vector-ref f195979 0))) (vector-set! f195979 0 (cons (string->symbol "string-ref") (vector-ref f195979 0))) (vector-set! f195979 0 (cons (string->symbol "string-length") (vector-ref f195979 0))) (vector-set! f195979 0 (cons (string->symbol "string?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons (string->symbol "make-string") (vector-ref f195979 0))) (vector-set! f195979 0 (cons (string->symbol "vector-ref") (vector-ref f195979 0))) (vector-set! f195979 0 (cons (string->symbol "vector-set!") (vector-ref f195979 0))) (vector-set! f195979 0 (cons (string->symbol "vector-length") (vector-ref f195979 0))) (vector-set! f195979 0 (cons (string->symbol "make-vector") (vector-ref f195979 0))) (vector-set! f195979 0 (cons (string->symbol "vector?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons (string->symbol "set-cdr!") (vector-ref f195979 0))) (vector-set! f195979 0 (cons (string->symbol "set-car!") (vector-ref f195979 0))) (vector-set! f195979 0 (cons (string->symbol "cdr") (vector-ref f195979 0))) (vector-set! f195979 0 (cons (string->symbol "car") (vector-ref f195979 0))) (vector-set! f195979 0 (cons (string->symbol "cons") (vector-ref f195979 0))) (vector-set! f195979 0 (cons (string->symbol "pair?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons (string->symbol "fxremainder") (vector-ref f195979 0))) (vector-set! f195979 0 (cons (string->symbol "fxquotient") (vector-ref f195979 0))) (vector-set! f195979 0 (cons (string->symbol "fx*") (vector-ref f195979 0))) (vector-set! f195979 0 (cons (string->symbol "fx-") (vector-ref f195979 0))) (vector-set! f195979 0 (cons (string->symbol "fx+") (vector-ref f195979 0))) (vector-set! f195979 0 (cons (string->symbol "fx>=") (vector-ref f195979 0))) (vector-set! f195979 0 (cons (string->symbol "fx>") (vector-ref f195979 0))) (vector-set! f195979 0 (cons (string->symbol "fx<=") (vector-ref f195979 0))) (vector-set! f195979 0 (cons (string->symbol "fx<") (vector-ref f195979 0))) (vector-set! f195979 0 (cons (string->symbol "fx=") (vector-ref f195979 0))) (vector-set! f195979 0 (cons (string->symbol "fxzero?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons (string->symbol "fxsub1") (vector-ref f195979 0))) (vector-set! f195979 0 (cons (string->symbol "fxadd1") (vector-ref f195979 0))) (vector-set! f195979 0 (cons (string->symbol "fxlogor") (vector-ref f195979 0))) (vector-set! f195979 0 (cons (string->symbol "fxlogand") (vector-ref f195979 0))) (vector-set! f195979 0 (cons (string->symbol "fxlognot") (vector-ref f195979 0))) (vector-set! f195979 0 (cons (string->symbol "char=?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons (string->symbol "eq?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons (string->symbol "not") (vector-ref f195979 0))) (vector-set! f195979 0 (cons (string->symbol "boolean?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons (string->symbol "fixnum?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons (string->symbol "char?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons (string->symbol "null?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons (string->symbol "char->fixnum") (vector-ref f195979 0))) (vector-set! f195979 0 (cons (string->symbol "fixnum->char") (vector-ref f195979 0))) (closure () (f195979) (let () (vector-ref f195979 0)))))
# == eliminate-cond  ==>
# (let ((f195979 (vector ()))) (begin (vector-set! f195979 0 (cons (string->symbol "procedure?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons (string->symbol "cdr") (vector-ref f195979 0))) (vector-set! f195979 0 (cons (string->symbol "car") (vector-ref f195979 0))) (vector-set! f195979 0 (cons (string->symbol "symbol-value") (vector-ref f195979 0))) (vector-set! f195979 0 (cons (string->symbol "symbol->string") (vector-ref f195979 0))) (vector-set! f195979 0 (cons (string->symbol "make-symbol") (vector-ref f195979 0))) (vector-set! f195979 0 (cons (string->symbol "symbol?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons (string->symbol "string-set!") (vector-ref f195979 0))) (vector-set! f195979 0 (cons (string->symbol "string-ref") (vector-ref f195979 0))) (vector-set! f195979 0 (cons (string->symbol "string-length") (vector-ref f195979 0))) (vector-set! f195979 0 (cons (string->symbol "string?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons (string->symbol "make-string") (vector-ref f195979 0))) (vector-set! f195979 0 (cons (string->symbol "vector-ref") (vector-ref f195979 0))) (vector-set! f195979 0 (cons (string->symbol "vector-set!") (vector-ref f195979 0))) (vector-set! f195979 0 (cons (string->symbol "vector-length") (vector-ref f195979 0))) (vector-set! f195979 0 (cons (string->symbol "make-vector") (vector-ref f195979 0))) (vector-set! f195979 0 (cons (string->symbol "vector?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons (string->symbol "set-cdr!") (vector-ref f195979 0))) (vector-set! f195979 0 (cons (string->symbol "set-car!") (vector-ref f195979 0))) (vector-set! f195979 0 (cons (string->symbol "cdr") (vector-ref f195979 0))) (vector-set! f195979 0 (cons (string->symbol "car") (vector-ref f195979 0))) (vector-set! f195979 0 (cons (string->symbol "cons") (vector-ref f195979 0))) (vector-set! f195979 0 (cons (string->symbol "pair?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons (string->symbol "fxremainder") (vector-ref f195979 0))) (vector-set! f195979 0 (cons (string->symbol "fxquotient") (vector-ref f195979 0))) (vector-set! f195979 0 (cons (string->symbol "fx*") (vector-ref f195979 0))) (vector-set! f195979 0 (cons (string->symbol "fx-") (vector-ref f195979 0))) (vector-set! f195979 0 (cons (string->symbol "fx+") (vector-ref f195979 0))) (vector-set! f195979 0 (cons (string->symbol "fx>=") (vector-ref f195979 0))) (vector-set! f195979 0 (cons (string->symbol "fx>") (vector-ref f195979 0))) (vector-set! f195979 0 (cons (string->symbol "fx<=") (vector-ref f195979 0))) (vector-set! f195979 0 (cons (string->symbol "fx<") (vector-ref f195979 0))) (vector-set! f195979 0 (cons (string->symbol "fx=") (vector-ref f195979 0))) (vector-set! f195979 0 (cons (string->symbol "fxzero?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons (string->symbol "fxsub1") (vector-ref f195979 0))) (vector-set! f195979 0 (cons (string->symbol "fxadd1") (vector-ref f195979 0))) (vector-set! f195979 0 (cons (string->symbol "fxlogor") (vector-ref f195979 0))) (vector-set! f195979 0 (cons (string->symbol "fxlogand") (vector-ref f195979 0))) (vector-set! f195979 0 (cons (string->symbol "fxlognot") (vector-ref f195979 0))) (vector-set! f195979 0 (cons (string->symbol "char=?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons (string->symbol "eq?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons (string->symbol "not") (vector-ref f195979 0))) (vector-set! f195979 0 (cons (string->symbol "boolean?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons (string->symbol "fixnum?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons (string->symbol "char?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons (string->symbol "null?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons (string->symbol "char->fixnum") (vector-ref f195979 0))) (vector-set! f195979 0 (cons (string->symbol "fixnum->char") (vector-ref f195979 0))) (closure () (f195979) (let () (vector-ref f195979 0)))))
# == external-symbols  ==>
# (let ((f195979 ((primitive-ref vector) ()))) (begin (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "procedure?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "cdr") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "car") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "symbol-value") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "symbol->string") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "make-symbol") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "symbol?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "string-set!") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "string-ref") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "string-length") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "string?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "make-string") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "vector-ref") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "vector-set!") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "vector-length") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "make-vector") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "vector?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "set-cdr!") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "set-car!") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "cdr") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "car") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "cons") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "pair?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxremainder") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxquotient") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx*") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx-") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx+") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx>=") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx>") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx<=") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx<") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx=") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f195979 0))) (closure () (f195979) (let () (vector-ref f195979 0)))))
# emit-expr (let ((f195979 ((primitive-ref vector) ()))) (begin (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "procedure?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "cdr") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "car") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "symbol-value") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "symbol->string") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "make-symbol") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "symbol?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "string-set!") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "string-ref") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "string-length") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "string?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "make-string") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "vector-ref") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "vector-set!") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "vector-length") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "make-vector") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "vector?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "set-cdr!") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "set-car!") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "cdr") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "car") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "cons") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "pair?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxremainder") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxquotient") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx*") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx-") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx+") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx>=") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx>") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx<=") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx<") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx=") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f195979 0))) (closure () (f195979) (let () (vector-ref f195979 0)))))
# emit-let
#  si   = 0
#  env  = ()
#  bindings = ((f195979 ((primitive-ref vector) ())))
#  body = (begin (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "procedure?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "cdr") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "car") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "symbol-value") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "symbol->string") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "make-symbol") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "symbol?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "string-set!") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "string-ref") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "string-length") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "string?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "make-string") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "vector-ref") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "vector-set!") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "vector-length") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "make-vector") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "vector?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "set-cdr!") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "set-car!") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "cdr") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "car") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "cons") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "pair?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxremainder") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxquotient") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx*") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx-") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx+") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx>=") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx>") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx<=") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx<") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx=") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f195979 0))) (closure () (f195979) (let () (vector-ref f195979 0))))
# emit-expr ((primitive-ref vector) ())
# funcall
#    si   =0
#    env  = ()
#    expr = (funcall (primitive-ref vector) ())
# emit-expr (primitive-ref vector)
    .extern mrc_vector
    movl mrc_vector,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1423954"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1423954":
   movl %eax,  -8(%esp)  # stash funcall-oper in closure slot
# emit-expr ()
    movl $63, %eax     # immed ()
    mov %eax, -12(%esp)  # arg ()
    movl -8(%esp), %edi   # load new closure to %edi
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    movl -4(%esp), %edi   # restore closure frame ptr
    movl %eax, 0(%esp)  # stack save
# emit-expr (begin (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "procedure?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "cdr") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "car") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "symbol-value") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "symbol->string") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "make-symbol") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "symbol?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "string-set!") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "string-ref") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "string-length") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "string?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "make-string") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "vector-ref") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "vector-set!") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "vector-length") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "make-vector") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "vector?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "set-cdr!") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "set-car!") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "cdr") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "car") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "cons") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "pair?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxremainder") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxquotient") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx*") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx-") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx+") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx>=") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx>") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx<=") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx<") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx=") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f195979 0))) (closure () (f195979) (let () (vector-ref f195979 0))))
# emit-begin
#   expr=(begin (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "procedure?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "cdr") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "car") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "symbol-value") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "symbol->string") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "make-symbol") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "symbol?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "string-set!") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "string-ref") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "string-length") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "string?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "make-string") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "vector-ref") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "vector-set!") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "vector-length") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "make-vector") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "vector?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "set-cdr!") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "set-car!") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "cdr") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "car") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "cons") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "pair?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxremainder") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxquotient") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx*") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx-") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx+") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx>=") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx>") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx<=") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx<") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx=") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f195979 0))) (closure () (f195979) (let () (vector-ref f195979 0))))
#   env=((f195979 . 0))
# emit-expr (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "procedure?") (vector-ref f195979 0)))
# emit-expr f195979
# emit-variable-ref
# env=((f195979 . 0))
# var=f195979
    movl 0(%esp), %eax  # stack load f195979
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1423955
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1423955:
    movl %eax, -4(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1423956"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1423956:
# check bounds on vector index
    movl -4(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1423958
    cmp  $0,%eax
    jge _L_1423957
_L_1423958:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1423957:
    movl %eax, -8(%esp)
# emit-expr (cons ((primitive-ref string->symbol) "procedure?") (vector-ref f195979 0))
# cons arg1=((primitive-ref string->symbol) "procedure?") arg2=(vector-ref f195979 0)
# emit-expr ((primitive-ref string->symbol) "procedure?")
# funcall
#    si   =-12
#    env  = ((f195979 . 0))
#    expr = (funcall (primitive-ref string->symbol) "procedure?")
# emit-expr (primitive-ref string->symbol)
    .extern mrc_string$m$gsymbol
    movl mrc_string$m$gsymbol,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1423959"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1423959":
   movl %eax,  -20(%esp)  # stash funcall-oper in closure slot
# emit-expr "procedure?"
# string literal
    jmp _L_1423961
    .align 8,0x90
_L_1423960 :
    .int 40
    .ascii "procedure?"
_L_1423961:
    movl $_L_1423960, %eax
    orl $6, %eax
    mov %eax, -24(%esp)  # arg procedure?
    movl -20(%esp), %edi   # load new closure to %edi
    add $-12, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $12, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    movl %eax, -12(%esp)
# emit-expr (vector-ref f195979 0)
# emit-expr f195979
# emit-variable-ref
# env=((f195979 . 0))
# var=f195979
    movl 0(%esp), %eax  # stack load f195979
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1423962
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1423962:
    movl %eax, -16(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1423963"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1423963:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1423965
    cmp  $0,%eax
    jge _L_1423964
_L_1423965:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1423964:
    movl -16(%esp), %esi
    movl -1(%eax,%esi), %eax
    movl %eax, 4(%ebp)
    movl -12(%esp), %eax
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    or   $1, %al
    add  $8, %ebp
# cons end
    movl -4(%esp), %ebx
    movl -8(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "cdr") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "car") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "symbol-value") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "symbol->string") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "make-symbol") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "symbol?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "string-set!") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "string-ref") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "string-length") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "string?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "make-string") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "vector-ref") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "vector-set!") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "vector-length") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "make-vector") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "vector?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "set-cdr!") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "set-car!") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "cdr") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "car") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "cons") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "pair?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxremainder") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxquotient") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx*") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx-") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx+") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx>=") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx>") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx<=") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx<") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx=") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f195979 0))) (closure () (f195979) (let () (vector-ref f195979 0))))
# emit-begin
#   expr=(begin (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "cdr") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "car") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "symbol-value") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "symbol->string") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "make-symbol") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "symbol?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "string-set!") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "string-ref") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "string-length") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "string?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "make-string") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "vector-ref") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "vector-set!") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "vector-length") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "make-vector") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "vector?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "set-cdr!") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "set-car!") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "cdr") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "car") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "cons") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "pair?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxremainder") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxquotient") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx*") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx-") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx+") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx>=") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx>") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx<=") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx<") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx=") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f195979 0))) (closure () (f195979) (let () (vector-ref f195979 0))))
#   env=((f195979 . 0))
# emit-expr (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "cdr") (vector-ref f195979 0)))
# emit-expr f195979
# emit-variable-ref
# env=((f195979 . 0))
# var=f195979
    movl 0(%esp), %eax  # stack load f195979
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1423966
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1423966:
    movl %eax, -4(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1423967"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1423967:
# check bounds on vector index
    movl -4(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1423969
    cmp  $0,%eax
    jge _L_1423968
_L_1423969:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1423968:
    movl %eax, -8(%esp)
# emit-expr (cons ((primitive-ref string->symbol) "cdr") (vector-ref f195979 0))
# cons arg1=((primitive-ref string->symbol) "cdr") arg2=(vector-ref f195979 0)
# emit-expr ((primitive-ref string->symbol) "cdr")
# funcall
#    si   =-12
#    env  = ((f195979 . 0))
#    expr = (funcall (primitive-ref string->symbol) "cdr")
# emit-expr (primitive-ref string->symbol)
    .extern mrc_string$m$gsymbol
    movl mrc_string$m$gsymbol,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1423970"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1423970":
   movl %eax,  -20(%esp)  # stash funcall-oper in closure slot
# emit-expr "cdr"
# string literal
    jmp _L_1423972
    .align 8,0x90
_L_1423971 :
    .int 12
    .ascii "cdr"
_L_1423972:
    movl $_L_1423971, %eax
    orl $6, %eax
    mov %eax, -24(%esp)  # arg cdr
    movl -20(%esp), %edi   # load new closure to %edi
    add $-12, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $12, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    movl %eax, -12(%esp)
# emit-expr (vector-ref f195979 0)
# emit-expr f195979
# emit-variable-ref
# env=((f195979 . 0))
# var=f195979
    movl 0(%esp), %eax  # stack load f195979
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1423973
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1423973:
    movl %eax, -16(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1423974"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1423974:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1423976
    cmp  $0,%eax
    jge _L_1423975
_L_1423976:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1423975:
    movl -16(%esp), %esi
    movl -1(%eax,%esi), %eax
    movl %eax, 4(%ebp)
    movl -12(%esp), %eax
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    or   $1, %al
    add  $8, %ebp
# cons end
    movl -4(%esp), %ebx
    movl -8(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "car") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "symbol-value") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "symbol->string") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "make-symbol") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "symbol?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "string-set!") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "string-ref") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "string-length") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "string?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "make-string") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "vector-ref") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "vector-set!") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "vector-length") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "make-vector") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "vector?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "set-cdr!") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "set-car!") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "cdr") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "car") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "cons") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "pair?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxremainder") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxquotient") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx*") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx-") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx+") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx>=") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx>") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx<=") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx<") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx=") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f195979 0))) (closure () (f195979) (let () (vector-ref f195979 0))))
# emit-begin
#   expr=(begin (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "car") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "symbol-value") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "symbol->string") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "make-symbol") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "symbol?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "string-set!") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "string-ref") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "string-length") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "string?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "make-string") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "vector-ref") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "vector-set!") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "vector-length") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "make-vector") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "vector?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "set-cdr!") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "set-car!") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "cdr") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "car") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "cons") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "pair?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxremainder") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxquotient") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx*") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx-") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx+") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx>=") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx>") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx<=") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx<") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx=") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f195979 0))) (closure () (f195979) (let () (vector-ref f195979 0))))
#   env=((f195979 . 0))
# emit-expr (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "car") (vector-ref f195979 0)))
# emit-expr f195979
# emit-variable-ref
# env=((f195979 . 0))
# var=f195979
    movl 0(%esp), %eax  # stack load f195979
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1423977
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1423977:
    movl %eax, -4(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1423978"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1423978:
# check bounds on vector index
    movl -4(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1423980
    cmp  $0,%eax
    jge _L_1423979
_L_1423980:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1423979:
    movl %eax, -8(%esp)
# emit-expr (cons ((primitive-ref string->symbol) "car") (vector-ref f195979 0))
# cons arg1=((primitive-ref string->symbol) "car") arg2=(vector-ref f195979 0)
# emit-expr ((primitive-ref string->symbol) "car")
# funcall
#    si   =-12
#    env  = ((f195979 . 0))
#    expr = (funcall (primitive-ref string->symbol) "car")
# emit-expr (primitive-ref string->symbol)
    .extern mrc_string$m$gsymbol
    movl mrc_string$m$gsymbol,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1423981"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1423981":
   movl %eax,  -20(%esp)  # stash funcall-oper in closure slot
# emit-expr "car"
# string literal
    jmp _L_1423983
    .align 8,0x90
_L_1423982 :
    .int 12
    .ascii "car"
_L_1423983:
    movl $_L_1423982, %eax
    orl $6, %eax
    mov %eax, -24(%esp)  # arg car
    movl -20(%esp), %edi   # load new closure to %edi
    add $-12, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $12, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    movl %eax, -12(%esp)
# emit-expr (vector-ref f195979 0)
# emit-expr f195979
# emit-variable-ref
# env=((f195979 . 0))
# var=f195979
    movl 0(%esp), %eax  # stack load f195979
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1423984
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1423984:
    movl %eax, -16(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1423985"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1423985:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1423987
    cmp  $0,%eax
    jge _L_1423986
_L_1423987:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1423986:
    movl -16(%esp), %esi
    movl -1(%eax,%esi), %eax
    movl %eax, 4(%ebp)
    movl -12(%esp), %eax
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    or   $1, %al
    add  $8, %ebp
# cons end
    movl -4(%esp), %ebx
    movl -8(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "symbol-value") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "symbol->string") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "make-symbol") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "symbol?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "string-set!") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "string-ref") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "string-length") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "string?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "make-string") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "vector-ref") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "vector-set!") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "vector-length") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "make-vector") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "vector?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "set-cdr!") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "set-car!") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "cdr") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "car") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "cons") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "pair?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxremainder") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxquotient") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx*") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx-") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx+") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx>=") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx>") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx<=") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx<") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx=") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f195979 0))) (closure () (f195979) (let () (vector-ref f195979 0))))
# emit-begin
#   expr=(begin (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "symbol-value") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "symbol->string") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "make-symbol") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "symbol?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "string-set!") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "string-ref") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "string-length") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "string?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "make-string") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "vector-ref") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "vector-set!") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "vector-length") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "make-vector") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "vector?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "set-cdr!") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "set-car!") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "cdr") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "car") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "cons") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "pair?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxremainder") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxquotient") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx*") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx-") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx+") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx>=") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx>") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx<=") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx<") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx=") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f195979 0))) (closure () (f195979) (let () (vector-ref f195979 0))))
#   env=((f195979 . 0))
# emit-expr (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "symbol-value") (vector-ref f195979 0)))
# emit-expr f195979
# emit-variable-ref
# env=((f195979 . 0))
# var=f195979
    movl 0(%esp), %eax  # stack load f195979
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1423988
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1423988:
    movl %eax, -4(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1423989"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1423989:
# check bounds on vector index
    movl -4(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1423991
    cmp  $0,%eax
    jge _L_1423990
_L_1423991:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1423990:
    movl %eax, -8(%esp)
# emit-expr (cons ((primitive-ref string->symbol) "symbol-value") (vector-ref f195979 0))
# cons arg1=((primitive-ref string->symbol) "symbol-value") arg2=(vector-ref f195979 0)
# emit-expr ((primitive-ref string->symbol) "symbol-value")
# funcall
#    si   =-12
#    env  = ((f195979 . 0))
#    expr = (funcall (primitive-ref string->symbol) "symbol-value")
# emit-expr (primitive-ref string->symbol)
    .extern mrc_string$m$gsymbol
    movl mrc_string$m$gsymbol,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1423992"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1423992":
   movl %eax,  -20(%esp)  # stash funcall-oper in closure slot
# emit-expr "symbol-value"
# string literal
    jmp _L_1423994
    .align 8,0x90
_L_1423993 :
    .int 48
    .ascii "symbol-value"
_L_1423994:
    movl $_L_1423993, %eax
    orl $6, %eax
    mov %eax, -24(%esp)  # arg symbol-value
    movl -20(%esp), %edi   # load new closure to %edi
    add $-12, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $12, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    movl %eax, -12(%esp)
# emit-expr (vector-ref f195979 0)
# emit-expr f195979
# emit-variable-ref
# env=((f195979 . 0))
# var=f195979
    movl 0(%esp), %eax  # stack load f195979
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1423995
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1423995:
    movl %eax, -16(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1423996"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1423996:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1423998
    cmp  $0,%eax
    jge _L_1423997
_L_1423998:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1423997:
    movl -16(%esp), %esi
    movl -1(%eax,%esi), %eax
    movl %eax, 4(%ebp)
    movl -12(%esp), %eax
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    or   $1, %al
    add  $8, %ebp
# cons end
    movl -4(%esp), %ebx
    movl -8(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "symbol->string") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "make-symbol") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "symbol?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "string-set!") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "string-ref") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "string-length") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "string?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "make-string") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "vector-ref") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "vector-set!") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "vector-length") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "make-vector") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "vector?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "set-cdr!") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "set-car!") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "cdr") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "car") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "cons") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "pair?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxremainder") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxquotient") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx*") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx-") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx+") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx>=") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx>") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx<=") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx<") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx=") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f195979 0))) (closure () (f195979) (let () (vector-ref f195979 0))))
# emit-begin
#   expr=(begin (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "symbol->string") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "make-symbol") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "symbol?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "string-set!") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "string-ref") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "string-length") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "string?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "make-string") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "vector-ref") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "vector-set!") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "vector-length") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "make-vector") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "vector?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "set-cdr!") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "set-car!") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "cdr") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "car") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "cons") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "pair?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxremainder") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxquotient") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx*") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx-") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx+") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx>=") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx>") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx<=") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx<") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx=") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f195979 0))) (closure () (f195979) (let () (vector-ref f195979 0))))
#   env=((f195979 . 0))
# emit-expr (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "symbol->string") (vector-ref f195979 0)))
# emit-expr f195979
# emit-variable-ref
# env=((f195979 . 0))
# var=f195979
    movl 0(%esp), %eax  # stack load f195979
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1423999
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1423999:
    movl %eax, -4(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1424000"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1424000:
# check bounds on vector index
    movl -4(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1424002
    cmp  $0,%eax
    jge _L_1424001
_L_1424002:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1424001:
    movl %eax, -8(%esp)
# emit-expr (cons ((primitive-ref string->symbol) "symbol->string") (vector-ref f195979 0))
# cons arg1=((primitive-ref string->symbol) "symbol->string") arg2=(vector-ref f195979 0)
# emit-expr ((primitive-ref string->symbol) "symbol->string")
# funcall
#    si   =-12
#    env  = ((f195979 . 0))
#    expr = (funcall (primitive-ref string->symbol) "symbol->string")
# emit-expr (primitive-ref string->symbol)
    .extern mrc_string$m$gsymbol
    movl mrc_string$m$gsymbol,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1424003"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1424003":
   movl %eax,  -20(%esp)  # stash funcall-oper in closure slot
# emit-expr "symbol->string"
# string literal
    jmp _L_1424005
    .align 8,0x90
_L_1424004 :
    .int 56
    .ascii "symbol->string"
_L_1424005:
    movl $_L_1424004, %eax
    orl $6, %eax
    mov %eax, -24(%esp)  # arg symbol->string
    movl -20(%esp), %edi   # load new closure to %edi
    add $-12, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $12, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    movl %eax, -12(%esp)
# emit-expr (vector-ref f195979 0)
# emit-expr f195979
# emit-variable-ref
# env=((f195979 . 0))
# var=f195979
    movl 0(%esp), %eax  # stack load f195979
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1424006
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1424006:
    movl %eax, -16(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1424007"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1424007:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1424009
    cmp  $0,%eax
    jge _L_1424008
_L_1424009:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1424008:
    movl -16(%esp), %esi
    movl -1(%eax,%esi), %eax
    movl %eax, 4(%ebp)
    movl -12(%esp), %eax
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    or   $1, %al
    add  $8, %ebp
# cons end
    movl -4(%esp), %ebx
    movl -8(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "make-symbol") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "symbol?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "string-set!") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "string-ref") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "string-length") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "string?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "make-string") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "vector-ref") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "vector-set!") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "vector-length") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "make-vector") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "vector?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "set-cdr!") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "set-car!") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "cdr") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "car") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "cons") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "pair?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxremainder") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxquotient") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx*") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx-") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx+") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx>=") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx>") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx<=") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx<") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx=") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f195979 0))) (closure () (f195979) (let () (vector-ref f195979 0))))
# emit-begin
#   expr=(begin (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "make-symbol") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "symbol?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "string-set!") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "string-ref") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "string-length") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "string?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "make-string") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "vector-ref") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "vector-set!") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "vector-length") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "make-vector") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "vector?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "set-cdr!") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "set-car!") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "cdr") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "car") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "cons") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "pair?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxremainder") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxquotient") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx*") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx-") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx+") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx>=") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx>") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx<=") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx<") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx=") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f195979 0))) (closure () (f195979) (let () (vector-ref f195979 0))))
#   env=((f195979 . 0))
# emit-expr (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "make-symbol") (vector-ref f195979 0)))
# emit-expr f195979
# emit-variable-ref
# env=((f195979 . 0))
# var=f195979
    movl 0(%esp), %eax  # stack load f195979
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1424010
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1424010:
    movl %eax, -4(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1424011"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1424011:
# check bounds on vector index
    movl -4(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1424013
    cmp  $0,%eax
    jge _L_1424012
_L_1424013:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1424012:
    movl %eax, -8(%esp)
# emit-expr (cons ((primitive-ref string->symbol) "make-symbol") (vector-ref f195979 0))
# cons arg1=((primitive-ref string->symbol) "make-symbol") arg2=(vector-ref f195979 0)
# emit-expr ((primitive-ref string->symbol) "make-symbol")
# funcall
#    si   =-12
#    env  = ((f195979 . 0))
#    expr = (funcall (primitive-ref string->symbol) "make-symbol")
# emit-expr (primitive-ref string->symbol)
    .extern mrc_string$m$gsymbol
    movl mrc_string$m$gsymbol,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1424014"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1424014":
   movl %eax,  -20(%esp)  # stash funcall-oper in closure slot
# emit-expr "make-symbol"
# string literal
    jmp _L_1424016
    .align 8,0x90
_L_1424015 :
    .int 44
    .ascii "make-symbol"
_L_1424016:
    movl $_L_1424015, %eax
    orl $6, %eax
    mov %eax, -24(%esp)  # arg make-symbol
    movl -20(%esp), %edi   # load new closure to %edi
    add $-12, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $12, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    movl %eax, -12(%esp)
# emit-expr (vector-ref f195979 0)
# emit-expr f195979
# emit-variable-ref
# env=((f195979 . 0))
# var=f195979
    movl 0(%esp), %eax  # stack load f195979
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1424017
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1424017:
    movl %eax, -16(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1424018"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1424018:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1424020
    cmp  $0,%eax
    jge _L_1424019
_L_1424020:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1424019:
    movl -16(%esp), %esi
    movl -1(%eax,%esi), %eax
    movl %eax, 4(%ebp)
    movl -12(%esp), %eax
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    or   $1, %al
    add  $8, %ebp
# cons end
    movl -4(%esp), %ebx
    movl -8(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "symbol?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "string-set!") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "string-ref") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "string-length") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "string?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "make-string") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "vector-ref") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "vector-set!") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "vector-length") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "make-vector") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "vector?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "set-cdr!") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "set-car!") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "cdr") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "car") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "cons") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "pair?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxremainder") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxquotient") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx*") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx-") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx+") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx>=") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx>") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx<=") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx<") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx=") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f195979 0))) (closure () (f195979) (let () (vector-ref f195979 0))))
# emit-begin
#   expr=(begin (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "symbol?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "string-set!") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "string-ref") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "string-length") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "string?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "make-string") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "vector-ref") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "vector-set!") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "vector-length") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "make-vector") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "vector?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "set-cdr!") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "set-car!") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "cdr") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "car") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "cons") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "pair?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxremainder") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxquotient") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx*") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx-") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx+") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx>=") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx>") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx<=") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx<") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx=") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f195979 0))) (closure () (f195979) (let () (vector-ref f195979 0))))
#   env=((f195979 . 0))
# emit-expr (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "symbol?") (vector-ref f195979 0)))
# emit-expr f195979
# emit-variable-ref
# env=((f195979 . 0))
# var=f195979
    movl 0(%esp), %eax  # stack load f195979
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1424021
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1424021:
    movl %eax, -4(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1424022"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1424022:
# check bounds on vector index
    movl -4(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1424024
    cmp  $0,%eax
    jge _L_1424023
_L_1424024:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1424023:
    movl %eax, -8(%esp)
# emit-expr (cons ((primitive-ref string->symbol) "symbol?") (vector-ref f195979 0))
# cons arg1=((primitive-ref string->symbol) "symbol?") arg2=(vector-ref f195979 0)
# emit-expr ((primitive-ref string->symbol) "symbol?")
# funcall
#    si   =-12
#    env  = ((f195979 . 0))
#    expr = (funcall (primitive-ref string->symbol) "symbol?")
# emit-expr (primitive-ref string->symbol)
    .extern mrc_string$m$gsymbol
    movl mrc_string$m$gsymbol,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1424025"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1424025":
   movl %eax,  -20(%esp)  # stash funcall-oper in closure slot
# emit-expr "symbol?"
# string literal
    jmp _L_1424027
    .align 8,0x90
_L_1424026 :
    .int 28
    .ascii "symbol?"
_L_1424027:
    movl $_L_1424026, %eax
    orl $6, %eax
    mov %eax, -24(%esp)  # arg symbol?
    movl -20(%esp), %edi   # load new closure to %edi
    add $-12, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $12, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    movl %eax, -12(%esp)
# emit-expr (vector-ref f195979 0)
# emit-expr f195979
# emit-variable-ref
# env=((f195979 . 0))
# var=f195979
    movl 0(%esp), %eax  # stack load f195979
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1424028
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1424028:
    movl %eax, -16(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1424029"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1424029:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1424031
    cmp  $0,%eax
    jge _L_1424030
_L_1424031:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1424030:
    movl -16(%esp), %esi
    movl -1(%eax,%esi), %eax
    movl %eax, 4(%ebp)
    movl -12(%esp), %eax
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    or   $1, %al
    add  $8, %ebp
# cons end
    movl -4(%esp), %ebx
    movl -8(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "string-set!") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "string-ref") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "string-length") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "string?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "make-string") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "vector-ref") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "vector-set!") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "vector-length") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "make-vector") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "vector?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "set-cdr!") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "set-car!") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "cdr") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "car") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "cons") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "pair?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxremainder") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxquotient") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx*") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx-") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx+") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx>=") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx>") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx<=") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx<") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx=") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f195979 0))) (closure () (f195979) (let () (vector-ref f195979 0))))
# emit-begin
#   expr=(begin (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "string-set!") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "string-ref") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "string-length") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "string?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "make-string") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "vector-ref") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "vector-set!") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "vector-length") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "make-vector") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "vector?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "set-cdr!") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "set-car!") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "cdr") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "car") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "cons") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "pair?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxremainder") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxquotient") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx*") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx-") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx+") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx>=") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx>") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx<=") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx<") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx=") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f195979 0))) (closure () (f195979) (let () (vector-ref f195979 0))))
#   env=((f195979 . 0))
# emit-expr (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "string-set!") (vector-ref f195979 0)))
# emit-expr f195979
# emit-variable-ref
# env=((f195979 . 0))
# var=f195979
    movl 0(%esp), %eax  # stack load f195979
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1424032
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1424032:
    movl %eax, -4(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1424033"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1424033:
# check bounds on vector index
    movl -4(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1424035
    cmp  $0,%eax
    jge _L_1424034
_L_1424035:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1424034:
    movl %eax, -8(%esp)
# emit-expr (cons ((primitive-ref string->symbol) "string-set!") (vector-ref f195979 0))
# cons arg1=((primitive-ref string->symbol) "string-set!") arg2=(vector-ref f195979 0)
# emit-expr ((primitive-ref string->symbol) "string-set!")
# funcall
#    si   =-12
#    env  = ((f195979 . 0))
#    expr = (funcall (primitive-ref string->symbol) "string-set!")
# emit-expr (primitive-ref string->symbol)
    .extern mrc_string$m$gsymbol
    movl mrc_string$m$gsymbol,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1424036"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1424036":
   movl %eax,  -20(%esp)  # stash funcall-oper in closure slot
# emit-expr "string-set!"
# string literal
    jmp _L_1424038
    .align 8,0x90
_L_1424037 :
    .int 44
    .ascii "string-set!"
_L_1424038:
    movl $_L_1424037, %eax
    orl $6, %eax
    mov %eax, -24(%esp)  # arg string-set!
    movl -20(%esp), %edi   # load new closure to %edi
    add $-12, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $12, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    movl %eax, -12(%esp)
# emit-expr (vector-ref f195979 0)
# emit-expr f195979
# emit-variable-ref
# env=((f195979 . 0))
# var=f195979
    movl 0(%esp), %eax  # stack load f195979
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1424039
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1424039:
    movl %eax, -16(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1424040"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1424040:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1424042
    cmp  $0,%eax
    jge _L_1424041
_L_1424042:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1424041:
    movl -16(%esp), %esi
    movl -1(%eax,%esi), %eax
    movl %eax, 4(%ebp)
    movl -12(%esp), %eax
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    or   $1, %al
    add  $8, %ebp
# cons end
    movl -4(%esp), %ebx
    movl -8(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "string-ref") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "string-length") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "string?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "make-string") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "vector-ref") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "vector-set!") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "vector-length") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "make-vector") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "vector?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "set-cdr!") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "set-car!") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "cdr") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "car") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "cons") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "pair?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxremainder") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxquotient") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx*") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx-") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx+") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx>=") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx>") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx<=") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx<") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx=") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f195979 0))) (closure () (f195979) (let () (vector-ref f195979 0))))
# emit-begin
#   expr=(begin (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "string-ref") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "string-length") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "string?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "make-string") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "vector-ref") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "vector-set!") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "vector-length") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "make-vector") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "vector?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "set-cdr!") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "set-car!") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "cdr") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "car") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "cons") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "pair?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxremainder") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxquotient") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx*") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx-") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx+") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx>=") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx>") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx<=") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx<") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx=") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f195979 0))) (closure () (f195979) (let () (vector-ref f195979 0))))
#   env=((f195979 . 0))
# emit-expr (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "string-ref") (vector-ref f195979 0)))
# emit-expr f195979
# emit-variable-ref
# env=((f195979 . 0))
# var=f195979
    movl 0(%esp), %eax  # stack load f195979
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1424043
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1424043:
    movl %eax, -4(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1424044"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1424044:
# check bounds on vector index
    movl -4(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1424046
    cmp  $0,%eax
    jge _L_1424045
_L_1424046:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1424045:
    movl %eax, -8(%esp)
# emit-expr (cons ((primitive-ref string->symbol) "string-ref") (vector-ref f195979 0))
# cons arg1=((primitive-ref string->symbol) "string-ref") arg2=(vector-ref f195979 0)
# emit-expr ((primitive-ref string->symbol) "string-ref")
# funcall
#    si   =-12
#    env  = ((f195979 . 0))
#    expr = (funcall (primitive-ref string->symbol) "string-ref")
# emit-expr (primitive-ref string->symbol)
    .extern mrc_string$m$gsymbol
    movl mrc_string$m$gsymbol,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1424047"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1424047":
   movl %eax,  -20(%esp)  # stash funcall-oper in closure slot
# emit-expr "string-ref"
# string literal
    jmp _L_1424049
    .align 8,0x90
_L_1424048 :
    .int 40
    .ascii "string-ref"
_L_1424049:
    movl $_L_1424048, %eax
    orl $6, %eax
    mov %eax, -24(%esp)  # arg string-ref
    movl -20(%esp), %edi   # load new closure to %edi
    add $-12, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $12, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    movl %eax, -12(%esp)
# emit-expr (vector-ref f195979 0)
# emit-expr f195979
# emit-variable-ref
# env=((f195979 . 0))
# var=f195979
    movl 0(%esp), %eax  # stack load f195979
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1424050
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1424050:
    movl %eax, -16(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1424051"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1424051:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1424053
    cmp  $0,%eax
    jge _L_1424052
_L_1424053:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1424052:
    movl -16(%esp), %esi
    movl -1(%eax,%esi), %eax
    movl %eax, 4(%ebp)
    movl -12(%esp), %eax
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    or   $1, %al
    add  $8, %ebp
# cons end
    movl -4(%esp), %ebx
    movl -8(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "string-length") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "string?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "make-string") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "vector-ref") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "vector-set!") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "vector-length") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "make-vector") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "vector?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "set-cdr!") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "set-car!") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "cdr") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "car") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "cons") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "pair?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxremainder") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxquotient") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx*") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx-") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx+") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx>=") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx>") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx<=") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx<") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx=") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f195979 0))) (closure () (f195979) (let () (vector-ref f195979 0))))
# emit-begin
#   expr=(begin (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "string-length") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "string?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "make-string") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "vector-ref") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "vector-set!") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "vector-length") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "make-vector") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "vector?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "set-cdr!") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "set-car!") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "cdr") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "car") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "cons") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "pair?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxremainder") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxquotient") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx*") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx-") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx+") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx>=") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx>") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx<=") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx<") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx=") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f195979 0))) (closure () (f195979) (let () (vector-ref f195979 0))))
#   env=((f195979 . 0))
# emit-expr (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "string-length") (vector-ref f195979 0)))
# emit-expr f195979
# emit-variable-ref
# env=((f195979 . 0))
# var=f195979
    movl 0(%esp), %eax  # stack load f195979
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1424054
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1424054:
    movl %eax, -4(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1424055"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1424055:
# check bounds on vector index
    movl -4(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1424057
    cmp  $0,%eax
    jge _L_1424056
_L_1424057:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1424056:
    movl %eax, -8(%esp)
# emit-expr (cons ((primitive-ref string->symbol) "string-length") (vector-ref f195979 0))
# cons arg1=((primitive-ref string->symbol) "string-length") arg2=(vector-ref f195979 0)
# emit-expr ((primitive-ref string->symbol) "string-length")
# funcall
#    si   =-12
#    env  = ((f195979 . 0))
#    expr = (funcall (primitive-ref string->symbol) "string-length")
# emit-expr (primitive-ref string->symbol)
    .extern mrc_string$m$gsymbol
    movl mrc_string$m$gsymbol,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1424058"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1424058":
   movl %eax,  -20(%esp)  # stash funcall-oper in closure slot
# emit-expr "string-length"
# string literal
    jmp _L_1424060
    .align 8,0x90
_L_1424059 :
    .int 52
    .ascii "string-length"
_L_1424060:
    movl $_L_1424059, %eax
    orl $6, %eax
    mov %eax, -24(%esp)  # arg string-length
    movl -20(%esp), %edi   # load new closure to %edi
    add $-12, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $12, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    movl %eax, -12(%esp)
# emit-expr (vector-ref f195979 0)
# emit-expr f195979
# emit-variable-ref
# env=((f195979 . 0))
# var=f195979
    movl 0(%esp), %eax  # stack load f195979
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1424061
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1424061:
    movl %eax, -16(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1424062"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1424062:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1424064
    cmp  $0,%eax
    jge _L_1424063
_L_1424064:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1424063:
    movl -16(%esp), %esi
    movl -1(%eax,%esi), %eax
    movl %eax, 4(%ebp)
    movl -12(%esp), %eax
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    or   $1, %al
    add  $8, %ebp
# cons end
    movl -4(%esp), %ebx
    movl -8(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "string?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "make-string") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "vector-ref") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "vector-set!") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "vector-length") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "make-vector") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "vector?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "set-cdr!") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "set-car!") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "cdr") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "car") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "cons") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "pair?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxremainder") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxquotient") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx*") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx-") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx+") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx>=") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx>") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx<=") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx<") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx=") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f195979 0))) (closure () (f195979) (let () (vector-ref f195979 0))))
# emit-begin
#   expr=(begin (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "string?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "make-string") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "vector-ref") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "vector-set!") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "vector-length") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "make-vector") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "vector?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "set-cdr!") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "set-car!") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "cdr") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "car") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "cons") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "pair?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxremainder") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxquotient") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx*") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx-") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx+") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx>=") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx>") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx<=") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx<") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx=") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f195979 0))) (closure () (f195979) (let () (vector-ref f195979 0))))
#   env=((f195979 . 0))
# emit-expr (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "string?") (vector-ref f195979 0)))
# emit-expr f195979
# emit-variable-ref
# env=((f195979 . 0))
# var=f195979
    movl 0(%esp), %eax  # stack load f195979
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1424065
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1424065:
    movl %eax, -4(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1424066"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1424066:
# check bounds on vector index
    movl -4(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1424068
    cmp  $0,%eax
    jge _L_1424067
_L_1424068:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1424067:
    movl %eax, -8(%esp)
# emit-expr (cons ((primitive-ref string->symbol) "string?") (vector-ref f195979 0))
# cons arg1=((primitive-ref string->symbol) "string?") arg2=(vector-ref f195979 0)
# emit-expr ((primitive-ref string->symbol) "string?")
# funcall
#    si   =-12
#    env  = ((f195979 . 0))
#    expr = (funcall (primitive-ref string->symbol) "string?")
# emit-expr (primitive-ref string->symbol)
    .extern mrc_string$m$gsymbol
    movl mrc_string$m$gsymbol,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1424069"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1424069":
   movl %eax,  -20(%esp)  # stash funcall-oper in closure slot
# emit-expr "string?"
# string literal
    jmp _L_1424071
    .align 8,0x90
_L_1424070 :
    .int 28
    .ascii "string?"
_L_1424071:
    movl $_L_1424070, %eax
    orl $6, %eax
    mov %eax, -24(%esp)  # arg string?
    movl -20(%esp), %edi   # load new closure to %edi
    add $-12, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $12, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    movl %eax, -12(%esp)
# emit-expr (vector-ref f195979 0)
# emit-expr f195979
# emit-variable-ref
# env=((f195979 . 0))
# var=f195979
    movl 0(%esp), %eax  # stack load f195979
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1424072
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1424072:
    movl %eax, -16(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1424073"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1424073:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1424075
    cmp  $0,%eax
    jge _L_1424074
_L_1424075:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1424074:
    movl -16(%esp), %esi
    movl -1(%eax,%esi), %eax
    movl %eax, 4(%ebp)
    movl -12(%esp), %eax
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    or   $1, %al
    add  $8, %ebp
# cons end
    movl -4(%esp), %ebx
    movl -8(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "make-string") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "vector-ref") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "vector-set!") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "vector-length") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "make-vector") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "vector?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "set-cdr!") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "set-car!") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "cdr") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "car") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "cons") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "pair?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxremainder") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxquotient") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx*") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx-") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx+") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx>=") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx>") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx<=") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx<") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx=") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f195979 0))) (closure () (f195979) (let () (vector-ref f195979 0))))
# emit-begin
#   expr=(begin (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "make-string") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "vector-ref") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "vector-set!") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "vector-length") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "make-vector") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "vector?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "set-cdr!") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "set-car!") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "cdr") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "car") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "cons") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "pair?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxremainder") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxquotient") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx*") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx-") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx+") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx>=") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx>") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx<=") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx<") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx=") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f195979 0))) (closure () (f195979) (let () (vector-ref f195979 0))))
#   env=((f195979 . 0))
# emit-expr (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "make-string") (vector-ref f195979 0)))
# emit-expr f195979
# emit-variable-ref
# env=((f195979 . 0))
# var=f195979
    movl 0(%esp), %eax  # stack load f195979
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1424076
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1424076:
    movl %eax, -4(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1424077"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1424077:
# check bounds on vector index
    movl -4(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1424079
    cmp  $0,%eax
    jge _L_1424078
_L_1424079:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1424078:
    movl %eax, -8(%esp)
# emit-expr (cons ((primitive-ref string->symbol) "make-string") (vector-ref f195979 0))
# cons arg1=((primitive-ref string->symbol) "make-string") arg2=(vector-ref f195979 0)
# emit-expr ((primitive-ref string->symbol) "make-string")
# funcall
#    si   =-12
#    env  = ((f195979 . 0))
#    expr = (funcall (primitive-ref string->symbol) "make-string")
# emit-expr (primitive-ref string->symbol)
    .extern mrc_string$m$gsymbol
    movl mrc_string$m$gsymbol,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1424080"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1424080":
   movl %eax,  -20(%esp)  # stash funcall-oper in closure slot
# emit-expr "make-string"
# string literal
    jmp _L_1424082
    .align 8,0x90
_L_1424081 :
    .int 44
    .ascii "make-string"
_L_1424082:
    movl $_L_1424081, %eax
    orl $6, %eax
    mov %eax, -24(%esp)  # arg make-string
    movl -20(%esp), %edi   # load new closure to %edi
    add $-12, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $12, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    movl %eax, -12(%esp)
# emit-expr (vector-ref f195979 0)
# emit-expr f195979
# emit-variable-ref
# env=((f195979 . 0))
# var=f195979
    movl 0(%esp), %eax  # stack load f195979
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1424083
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1424083:
    movl %eax, -16(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1424084"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1424084:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1424086
    cmp  $0,%eax
    jge _L_1424085
_L_1424086:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1424085:
    movl -16(%esp), %esi
    movl -1(%eax,%esi), %eax
    movl %eax, 4(%ebp)
    movl -12(%esp), %eax
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    or   $1, %al
    add  $8, %ebp
# cons end
    movl -4(%esp), %ebx
    movl -8(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "vector-ref") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "vector-set!") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "vector-length") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "make-vector") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "vector?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "set-cdr!") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "set-car!") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "cdr") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "car") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "cons") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "pair?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxremainder") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxquotient") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx*") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx-") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx+") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx>=") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx>") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx<=") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx<") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx=") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f195979 0))) (closure () (f195979) (let () (vector-ref f195979 0))))
# emit-begin
#   expr=(begin (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "vector-ref") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "vector-set!") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "vector-length") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "make-vector") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "vector?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "set-cdr!") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "set-car!") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "cdr") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "car") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "cons") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "pair?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxremainder") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxquotient") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx*") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx-") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx+") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx>=") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx>") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx<=") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx<") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx=") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f195979 0))) (closure () (f195979) (let () (vector-ref f195979 0))))
#   env=((f195979 . 0))
# emit-expr (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "vector-ref") (vector-ref f195979 0)))
# emit-expr f195979
# emit-variable-ref
# env=((f195979 . 0))
# var=f195979
    movl 0(%esp), %eax  # stack load f195979
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1424087
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1424087:
    movl %eax, -4(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1424088"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1424088:
# check bounds on vector index
    movl -4(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1424090
    cmp  $0,%eax
    jge _L_1424089
_L_1424090:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1424089:
    movl %eax, -8(%esp)
# emit-expr (cons ((primitive-ref string->symbol) "vector-ref") (vector-ref f195979 0))
# cons arg1=((primitive-ref string->symbol) "vector-ref") arg2=(vector-ref f195979 0)
# emit-expr ((primitive-ref string->symbol) "vector-ref")
# funcall
#    si   =-12
#    env  = ((f195979 . 0))
#    expr = (funcall (primitive-ref string->symbol) "vector-ref")
# emit-expr (primitive-ref string->symbol)
    .extern mrc_string$m$gsymbol
    movl mrc_string$m$gsymbol,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1424091"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1424091":
   movl %eax,  -20(%esp)  # stash funcall-oper in closure slot
# emit-expr "vector-ref"
# string literal
    jmp _L_1424093
    .align 8,0x90
_L_1424092 :
    .int 40
    .ascii "vector-ref"
_L_1424093:
    movl $_L_1424092, %eax
    orl $6, %eax
    mov %eax, -24(%esp)  # arg vector-ref
    movl -20(%esp), %edi   # load new closure to %edi
    add $-12, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $12, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    movl %eax, -12(%esp)
# emit-expr (vector-ref f195979 0)
# emit-expr f195979
# emit-variable-ref
# env=((f195979 . 0))
# var=f195979
    movl 0(%esp), %eax  # stack load f195979
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1424094
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1424094:
    movl %eax, -16(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1424095"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1424095:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1424097
    cmp  $0,%eax
    jge _L_1424096
_L_1424097:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1424096:
    movl -16(%esp), %esi
    movl -1(%eax,%esi), %eax
    movl %eax, 4(%ebp)
    movl -12(%esp), %eax
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    or   $1, %al
    add  $8, %ebp
# cons end
    movl -4(%esp), %ebx
    movl -8(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "vector-set!") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "vector-length") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "make-vector") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "vector?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "set-cdr!") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "set-car!") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "cdr") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "car") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "cons") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "pair?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxremainder") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxquotient") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx*") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx-") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx+") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx>=") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx>") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx<=") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx<") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx=") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f195979 0))) (closure () (f195979) (let () (vector-ref f195979 0))))
# emit-begin
#   expr=(begin (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "vector-set!") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "vector-length") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "make-vector") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "vector?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "set-cdr!") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "set-car!") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "cdr") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "car") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "cons") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "pair?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxremainder") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxquotient") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx*") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx-") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx+") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx>=") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx>") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx<=") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx<") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx=") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f195979 0))) (closure () (f195979) (let () (vector-ref f195979 0))))
#   env=((f195979 . 0))
# emit-expr (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "vector-set!") (vector-ref f195979 0)))
# emit-expr f195979
# emit-variable-ref
# env=((f195979 . 0))
# var=f195979
    movl 0(%esp), %eax  # stack load f195979
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1424098
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1424098:
    movl %eax, -4(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1424099"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1424099:
# check bounds on vector index
    movl -4(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1424101
    cmp  $0,%eax
    jge _L_1424100
_L_1424101:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1424100:
    movl %eax, -8(%esp)
# emit-expr (cons ((primitive-ref string->symbol) "vector-set!") (vector-ref f195979 0))
# cons arg1=((primitive-ref string->symbol) "vector-set!") arg2=(vector-ref f195979 0)
# emit-expr ((primitive-ref string->symbol) "vector-set!")
# funcall
#    si   =-12
#    env  = ((f195979 . 0))
#    expr = (funcall (primitive-ref string->symbol) "vector-set!")
# emit-expr (primitive-ref string->symbol)
    .extern mrc_string$m$gsymbol
    movl mrc_string$m$gsymbol,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1424102"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1424102":
   movl %eax,  -20(%esp)  # stash funcall-oper in closure slot
# emit-expr "vector-set!"
# string literal
    jmp _L_1424104
    .align 8,0x90
_L_1424103 :
    .int 44
    .ascii "vector-set!"
_L_1424104:
    movl $_L_1424103, %eax
    orl $6, %eax
    mov %eax, -24(%esp)  # arg vector-set!
    movl -20(%esp), %edi   # load new closure to %edi
    add $-12, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $12, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    movl %eax, -12(%esp)
# emit-expr (vector-ref f195979 0)
# emit-expr f195979
# emit-variable-ref
# env=((f195979 . 0))
# var=f195979
    movl 0(%esp), %eax  # stack load f195979
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1424105
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1424105:
    movl %eax, -16(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1424106"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1424106:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1424108
    cmp  $0,%eax
    jge _L_1424107
_L_1424108:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1424107:
    movl -16(%esp), %esi
    movl -1(%eax,%esi), %eax
    movl %eax, 4(%ebp)
    movl -12(%esp), %eax
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    or   $1, %al
    add  $8, %ebp
# cons end
    movl -4(%esp), %ebx
    movl -8(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "vector-length") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "make-vector") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "vector?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "set-cdr!") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "set-car!") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "cdr") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "car") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "cons") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "pair?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxremainder") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxquotient") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx*") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx-") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx+") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx>=") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx>") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx<=") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx<") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx=") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f195979 0))) (closure () (f195979) (let () (vector-ref f195979 0))))
# emit-begin
#   expr=(begin (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "vector-length") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "make-vector") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "vector?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "set-cdr!") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "set-car!") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "cdr") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "car") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "cons") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "pair?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxremainder") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxquotient") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx*") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx-") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx+") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx>=") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx>") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx<=") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx<") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx=") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f195979 0))) (closure () (f195979) (let () (vector-ref f195979 0))))
#   env=((f195979 . 0))
# emit-expr (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "vector-length") (vector-ref f195979 0)))
# emit-expr f195979
# emit-variable-ref
# env=((f195979 . 0))
# var=f195979
    movl 0(%esp), %eax  # stack load f195979
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1424109
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1424109:
    movl %eax, -4(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1424110"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1424110:
# check bounds on vector index
    movl -4(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1424112
    cmp  $0,%eax
    jge _L_1424111
_L_1424112:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1424111:
    movl %eax, -8(%esp)
# emit-expr (cons ((primitive-ref string->symbol) "vector-length") (vector-ref f195979 0))
# cons arg1=((primitive-ref string->symbol) "vector-length") arg2=(vector-ref f195979 0)
# emit-expr ((primitive-ref string->symbol) "vector-length")
# funcall
#    si   =-12
#    env  = ((f195979 . 0))
#    expr = (funcall (primitive-ref string->symbol) "vector-length")
# emit-expr (primitive-ref string->symbol)
    .extern mrc_string$m$gsymbol
    movl mrc_string$m$gsymbol,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1424113"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1424113":
   movl %eax,  -20(%esp)  # stash funcall-oper in closure slot
# emit-expr "vector-length"
# string literal
    jmp _L_1424115
    .align 8,0x90
_L_1424114 :
    .int 52
    .ascii "vector-length"
_L_1424115:
    movl $_L_1424114, %eax
    orl $6, %eax
    mov %eax, -24(%esp)  # arg vector-length
    movl -20(%esp), %edi   # load new closure to %edi
    add $-12, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $12, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    movl %eax, -12(%esp)
# emit-expr (vector-ref f195979 0)
# emit-expr f195979
# emit-variable-ref
# env=((f195979 . 0))
# var=f195979
    movl 0(%esp), %eax  # stack load f195979
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1424116
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1424116:
    movl %eax, -16(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1424117"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1424117:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1424119
    cmp  $0,%eax
    jge _L_1424118
_L_1424119:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1424118:
    movl -16(%esp), %esi
    movl -1(%eax,%esi), %eax
    movl %eax, 4(%ebp)
    movl -12(%esp), %eax
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    or   $1, %al
    add  $8, %ebp
# cons end
    movl -4(%esp), %ebx
    movl -8(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "make-vector") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "vector?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "set-cdr!") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "set-car!") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "cdr") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "car") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "cons") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "pair?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxremainder") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxquotient") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx*") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx-") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx+") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx>=") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx>") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx<=") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx<") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx=") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f195979 0))) (closure () (f195979) (let () (vector-ref f195979 0))))
# emit-begin
#   expr=(begin (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "make-vector") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "vector?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "set-cdr!") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "set-car!") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "cdr") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "car") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "cons") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "pair?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxremainder") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxquotient") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx*") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx-") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx+") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx>=") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx>") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx<=") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx<") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx=") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f195979 0))) (closure () (f195979) (let () (vector-ref f195979 0))))
#   env=((f195979 . 0))
# emit-expr (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "make-vector") (vector-ref f195979 0)))
# emit-expr f195979
# emit-variable-ref
# env=((f195979 . 0))
# var=f195979
    movl 0(%esp), %eax  # stack load f195979
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1424120
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1424120:
    movl %eax, -4(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1424121"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1424121:
# check bounds on vector index
    movl -4(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1424123
    cmp  $0,%eax
    jge _L_1424122
_L_1424123:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1424122:
    movl %eax, -8(%esp)
# emit-expr (cons ((primitive-ref string->symbol) "make-vector") (vector-ref f195979 0))
# cons arg1=((primitive-ref string->symbol) "make-vector") arg2=(vector-ref f195979 0)
# emit-expr ((primitive-ref string->symbol) "make-vector")
# funcall
#    si   =-12
#    env  = ((f195979 . 0))
#    expr = (funcall (primitive-ref string->symbol) "make-vector")
# emit-expr (primitive-ref string->symbol)
    .extern mrc_string$m$gsymbol
    movl mrc_string$m$gsymbol,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1424124"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1424124":
   movl %eax,  -20(%esp)  # stash funcall-oper in closure slot
# emit-expr "make-vector"
# string literal
    jmp _L_1424126
    .align 8,0x90
_L_1424125 :
    .int 44
    .ascii "make-vector"
_L_1424126:
    movl $_L_1424125, %eax
    orl $6, %eax
    mov %eax, -24(%esp)  # arg make-vector
    movl -20(%esp), %edi   # load new closure to %edi
    add $-12, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $12, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    movl %eax, -12(%esp)
# emit-expr (vector-ref f195979 0)
# emit-expr f195979
# emit-variable-ref
# env=((f195979 . 0))
# var=f195979
    movl 0(%esp), %eax  # stack load f195979
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1424127
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1424127:
    movl %eax, -16(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1424128"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1424128:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1424130
    cmp  $0,%eax
    jge _L_1424129
_L_1424130:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1424129:
    movl -16(%esp), %esi
    movl -1(%eax,%esi), %eax
    movl %eax, 4(%ebp)
    movl -12(%esp), %eax
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    or   $1, %al
    add  $8, %ebp
# cons end
    movl -4(%esp), %ebx
    movl -8(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "vector?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "set-cdr!") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "set-car!") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "cdr") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "car") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "cons") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "pair?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxremainder") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxquotient") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx*") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx-") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx+") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx>=") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx>") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx<=") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx<") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx=") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f195979 0))) (closure () (f195979) (let () (vector-ref f195979 0))))
# emit-begin
#   expr=(begin (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "vector?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "set-cdr!") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "set-car!") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "cdr") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "car") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "cons") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "pair?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxremainder") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxquotient") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx*") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx-") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx+") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx>=") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx>") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx<=") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx<") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx=") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f195979 0))) (closure () (f195979) (let () (vector-ref f195979 0))))
#   env=((f195979 . 0))
# emit-expr (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "vector?") (vector-ref f195979 0)))
# emit-expr f195979
# emit-variable-ref
# env=((f195979 . 0))
# var=f195979
    movl 0(%esp), %eax  # stack load f195979
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1424131
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1424131:
    movl %eax, -4(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1424132"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1424132:
# check bounds on vector index
    movl -4(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1424134
    cmp  $0,%eax
    jge _L_1424133
_L_1424134:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1424133:
    movl %eax, -8(%esp)
# emit-expr (cons ((primitive-ref string->symbol) "vector?") (vector-ref f195979 0))
# cons arg1=((primitive-ref string->symbol) "vector?") arg2=(vector-ref f195979 0)
# emit-expr ((primitive-ref string->symbol) "vector?")
# funcall
#    si   =-12
#    env  = ((f195979 . 0))
#    expr = (funcall (primitive-ref string->symbol) "vector?")
# emit-expr (primitive-ref string->symbol)
    .extern mrc_string$m$gsymbol
    movl mrc_string$m$gsymbol,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1424135"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1424135":
   movl %eax,  -20(%esp)  # stash funcall-oper in closure slot
# emit-expr "vector?"
# string literal
    jmp _L_1424137
    .align 8,0x90
_L_1424136 :
    .int 28
    .ascii "vector?"
_L_1424137:
    movl $_L_1424136, %eax
    orl $6, %eax
    mov %eax, -24(%esp)  # arg vector?
    movl -20(%esp), %edi   # load new closure to %edi
    add $-12, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $12, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    movl %eax, -12(%esp)
# emit-expr (vector-ref f195979 0)
# emit-expr f195979
# emit-variable-ref
# env=((f195979 . 0))
# var=f195979
    movl 0(%esp), %eax  # stack load f195979
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1424138
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1424138:
    movl %eax, -16(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1424139"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1424139:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1424141
    cmp  $0,%eax
    jge _L_1424140
_L_1424141:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1424140:
    movl -16(%esp), %esi
    movl -1(%eax,%esi), %eax
    movl %eax, 4(%ebp)
    movl -12(%esp), %eax
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    or   $1, %al
    add  $8, %ebp
# cons end
    movl -4(%esp), %ebx
    movl -8(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "set-cdr!") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "set-car!") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "cdr") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "car") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "cons") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "pair?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxremainder") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxquotient") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx*") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx-") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx+") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx>=") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx>") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx<=") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx<") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx=") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f195979 0))) (closure () (f195979) (let () (vector-ref f195979 0))))
# emit-begin
#   expr=(begin (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "set-cdr!") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "set-car!") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "cdr") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "car") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "cons") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "pair?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxremainder") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxquotient") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx*") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx-") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx+") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx>=") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx>") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx<=") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx<") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx=") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f195979 0))) (closure () (f195979) (let () (vector-ref f195979 0))))
#   env=((f195979 . 0))
# emit-expr (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "set-cdr!") (vector-ref f195979 0)))
# emit-expr f195979
# emit-variable-ref
# env=((f195979 . 0))
# var=f195979
    movl 0(%esp), %eax  # stack load f195979
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1424142
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1424142:
    movl %eax, -4(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1424143"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1424143:
# check bounds on vector index
    movl -4(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1424145
    cmp  $0,%eax
    jge _L_1424144
_L_1424145:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1424144:
    movl %eax, -8(%esp)
# emit-expr (cons ((primitive-ref string->symbol) "set-cdr!") (vector-ref f195979 0))
# cons arg1=((primitive-ref string->symbol) "set-cdr!") arg2=(vector-ref f195979 0)
# emit-expr ((primitive-ref string->symbol) "set-cdr!")
# funcall
#    si   =-12
#    env  = ((f195979 . 0))
#    expr = (funcall (primitive-ref string->symbol) "set-cdr!")
# emit-expr (primitive-ref string->symbol)
    .extern mrc_string$m$gsymbol
    movl mrc_string$m$gsymbol,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1424146"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1424146":
   movl %eax,  -20(%esp)  # stash funcall-oper in closure slot
# emit-expr "set-cdr!"
# string literal
    jmp _L_1424148
    .align 8,0x90
_L_1424147 :
    .int 32
    .ascii "set-cdr!"
_L_1424148:
    movl $_L_1424147, %eax
    orl $6, %eax
    mov %eax, -24(%esp)  # arg set-cdr!
    movl -20(%esp), %edi   # load new closure to %edi
    add $-12, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $12, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    movl %eax, -12(%esp)
# emit-expr (vector-ref f195979 0)
# emit-expr f195979
# emit-variable-ref
# env=((f195979 . 0))
# var=f195979
    movl 0(%esp), %eax  # stack load f195979
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1424149
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1424149:
    movl %eax, -16(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1424150"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1424150:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1424152
    cmp  $0,%eax
    jge _L_1424151
_L_1424152:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1424151:
    movl -16(%esp), %esi
    movl -1(%eax,%esi), %eax
    movl %eax, 4(%ebp)
    movl -12(%esp), %eax
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    or   $1, %al
    add  $8, %ebp
# cons end
    movl -4(%esp), %ebx
    movl -8(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "set-car!") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "cdr") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "car") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "cons") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "pair?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxremainder") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxquotient") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx*") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx-") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx+") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx>=") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx>") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx<=") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx<") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx=") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f195979 0))) (closure () (f195979) (let () (vector-ref f195979 0))))
# emit-begin
#   expr=(begin (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "set-car!") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "cdr") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "car") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "cons") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "pair?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxremainder") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxquotient") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx*") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx-") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx+") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx>=") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx>") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx<=") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx<") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx=") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f195979 0))) (closure () (f195979) (let () (vector-ref f195979 0))))
#   env=((f195979 . 0))
# emit-expr (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "set-car!") (vector-ref f195979 0)))
# emit-expr f195979
# emit-variable-ref
# env=((f195979 . 0))
# var=f195979
    movl 0(%esp), %eax  # stack load f195979
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1424153
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1424153:
    movl %eax, -4(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1424154"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1424154:
# check bounds on vector index
    movl -4(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1424156
    cmp  $0,%eax
    jge _L_1424155
_L_1424156:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1424155:
    movl %eax, -8(%esp)
# emit-expr (cons ((primitive-ref string->symbol) "set-car!") (vector-ref f195979 0))
# cons arg1=((primitive-ref string->symbol) "set-car!") arg2=(vector-ref f195979 0)
# emit-expr ((primitive-ref string->symbol) "set-car!")
# funcall
#    si   =-12
#    env  = ((f195979 . 0))
#    expr = (funcall (primitive-ref string->symbol) "set-car!")
# emit-expr (primitive-ref string->symbol)
    .extern mrc_string$m$gsymbol
    movl mrc_string$m$gsymbol,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1424157"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1424157":
   movl %eax,  -20(%esp)  # stash funcall-oper in closure slot
# emit-expr "set-car!"
# string literal
    jmp _L_1424159
    .align 8,0x90
_L_1424158 :
    .int 32
    .ascii "set-car!"
_L_1424159:
    movl $_L_1424158, %eax
    orl $6, %eax
    mov %eax, -24(%esp)  # arg set-car!
    movl -20(%esp), %edi   # load new closure to %edi
    add $-12, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $12, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    movl %eax, -12(%esp)
# emit-expr (vector-ref f195979 0)
# emit-expr f195979
# emit-variable-ref
# env=((f195979 . 0))
# var=f195979
    movl 0(%esp), %eax  # stack load f195979
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1424160
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1424160:
    movl %eax, -16(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1424161"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1424161:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1424163
    cmp  $0,%eax
    jge _L_1424162
_L_1424163:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1424162:
    movl -16(%esp), %esi
    movl -1(%eax,%esi), %eax
    movl %eax, 4(%ebp)
    movl -12(%esp), %eax
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    or   $1, %al
    add  $8, %ebp
# cons end
    movl -4(%esp), %ebx
    movl -8(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "cdr") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "car") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "cons") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "pair?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxremainder") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxquotient") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx*") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx-") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx+") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx>=") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx>") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx<=") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx<") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx=") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f195979 0))) (closure () (f195979) (let () (vector-ref f195979 0))))
# emit-begin
#   expr=(begin (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "cdr") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "car") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "cons") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "pair?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxremainder") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxquotient") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx*") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx-") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx+") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx>=") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx>") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx<=") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx<") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx=") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f195979 0))) (closure () (f195979) (let () (vector-ref f195979 0))))
#   env=((f195979 . 0))
# emit-expr (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "cdr") (vector-ref f195979 0)))
# emit-expr f195979
# emit-variable-ref
# env=((f195979 . 0))
# var=f195979
    movl 0(%esp), %eax  # stack load f195979
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1424164
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1424164:
    movl %eax, -4(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1424165"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1424165:
# check bounds on vector index
    movl -4(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1424167
    cmp  $0,%eax
    jge _L_1424166
_L_1424167:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1424166:
    movl %eax, -8(%esp)
# emit-expr (cons ((primitive-ref string->symbol) "cdr") (vector-ref f195979 0))
# cons arg1=((primitive-ref string->symbol) "cdr") arg2=(vector-ref f195979 0)
# emit-expr ((primitive-ref string->symbol) "cdr")
# funcall
#    si   =-12
#    env  = ((f195979 . 0))
#    expr = (funcall (primitive-ref string->symbol) "cdr")
# emit-expr (primitive-ref string->symbol)
    .extern mrc_string$m$gsymbol
    movl mrc_string$m$gsymbol,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1424168"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1424168":
   movl %eax,  -20(%esp)  # stash funcall-oper in closure slot
# emit-expr "cdr"
# string literal
    jmp _L_1424170
    .align 8,0x90
_L_1424169 :
    .int 12
    .ascii "cdr"
_L_1424170:
    movl $_L_1424169, %eax
    orl $6, %eax
    mov %eax, -24(%esp)  # arg cdr
    movl -20(%esp), %edi   # load new closure to %edi
    add $-12, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $12, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    movl %eax, -12(%esp)
# emit-expr (vector-ref f195979 0)
# emit-expr f195979
# emit-variable-ref
# env=((f195979 . 0))
# var=f195979
    movl 0(%esp), %eax  # stack load f195979
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1424171
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1424171:
    movl %eax, -16(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1424172"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1424172:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1424174
    cmp  $0,%eax
    jge _L_1424173
_L_1424174:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1424173:
    movl -16(%esp), %esi
    movl -1(%eax,%esi), %eax
    movl %eax, 4(%ebp)
    movl -12(%esp), %eax
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    or   $1, %al
    add  $8, %ebp
# cons end
    movl -4(%esp), %ebx
    movl -8(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "car") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "cons") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "pair?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxremainder") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxquotient") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx*") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx-") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx+") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx>=") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx>") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx<=") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx<") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx=") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f195979 0))) (closure () (f195979) (let () (vector-ref f195979 0))))
# emit-begin
#   expr=(begin (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "car") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "cons") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "pair?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxremainder") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxquotient") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx*") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx-") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx+") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx>=") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx>") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx<=") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx<") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx=") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f195979 0))) (closure () (f195979) (let () (vector-ref f195979 0))))
#   env=((f195979 . 0))
# emit-expr (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "car") (vector-ref f195979 0)))
# emit-expr f195979
# emit-variable-ref
# env=((f195979 . 0))
# var=f195979
    movl 0(%esp), %eax  # stack load f195979
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1424175
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1424175:
    movl %eax, -4(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1424176"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1424176:
# check bounds on vector index
    movl -4(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1424178
    cmp  $0,%eax
    jge _L_1424177
_L_1424178:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1424177:
    movl %eax, -8(%esp)
# emit-expr (cons ((primitive-ref string->symbol) "car") (vector-ref f195979 0))
# cons arg1=((primitive-ref string->symbol) "car") arg2=(vector-ref f195979 0)
# emit-expr ((primitive-ref string->symbol) "car")
# funcall
#    si   =-12
#    env  = ((f195979 . 0))
#    expr = (funcall (primitive-ref string->symbol) "car")
# emit-expr (primitive-ref string->symbol)
    .extern mrc_string$m$gsymbol
    movl mrc_string$m$gsymbol,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1424179"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1424179":
   movl %eax,  -20(%esp)  # stash funcall-oper in closure slot
# emit-expr "car"
# string literal
    jmp _L_1424181
    .align 8,0x90
_L_1424180 :
    .int 12
    .ascii "car"
_L_1424181:
    movl $_L_1424180, %eax
    orl $6, %eax
    mov %eax, -24(%esp)  # arg car
    movl -20(%esp), %edi   # load new closure to %edi
    add $-12, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $12, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    movl %eax, -12(%esp)
# emit-expr (vector-ref f195979 0)
# emit-expr f195979
# emit-variable-ref
# env=((f195979 . 0))
# var=f195979
    movl 0(%esp), %eax  # stack load f195979
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1424182
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1424182:
    movl %eax, -16(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1424183"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1424183:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1424185
    cmp  $0,%eax
    jge _L_1424184
_L_1424185:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1424184:
    movl -16(%esp), %esi
    movl -1(%eax,%esi), %eax
    movl %eax, 4(%ebp)
    movl -12(%esp), %eax
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    or   $1, %al
    add  $8, %ebp
# cons end
    movl -4(%esp), %ebx
    movl -8(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "cons") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "pair?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxremainder") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxquotient") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx*") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx-") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx+") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx>=") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx>") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx<=") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx<") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx=") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f195979 0))) (closure () (f195979) (let () (vector-ref f195979 0))))
# emit-begin
#   expr=(begin (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "cons") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "pair?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxremainder") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxquotient") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx*") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx-") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx+") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx>=") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx>") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx<=") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx<") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx=") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f195979 0))) (closure () (f195979) (let () (vector-ref f195979 0))))
#   env=((f195979 . 0))
# emit-expr (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "cons") (vector-ref f195979 0)))
# emit-expr f195979
# emit-variable-ref
# env=((f195979 . 0))
# var=f195979
    movl 0(%esp), %eax  # stack load f195979
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1424186
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1424186:
    movl %eax, -4(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1424187"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1424187:
# check bounds on vector index
    movl -4(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1424189
    cmp  $0,%eax
    jge _L_1424188
_L_1424189:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1424188:
    movl %eax, -8(%esp)
# emit-expr (cons ((primitive-ref string->symbol) "cons") (vector-ref f195979 0))
# cons arg1=((primitive-ref string->symbol) "cons") arg2=(vector-ref f195979 0)
# emit-expr ((primitive-ref string->symbol) "cons")
# funcall
#    si   =-12
#    env  = ((f195979 . 0))
#    expr = (funcall (primitive-ref string->symbol) "cons")
# emit-expr (primitive-ref string->symbol)
    .extern mrc_string$m$gsymbol
    movl mrc_string$m$gsymbol,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1424190"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1424190":
   movl %eax,  -20(%esp)  # stash funcall-oper in closure slot
# emit-expr "cons"
# string literal
    jmp _L_1424192
    .align 8,0x90
_L_1424191 :
    .int 16
    .ascii "cons"
_L_1424192:
    movl $_L_1424191, %eax
    orl $6, %eax
    mov %eax, -24(%esp)  # arg cons
    movl -20(%esp), %edi   # load new closure to %edi
    add $-12, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $12, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    movl %eax, -12(%esp)
# emit-expr (vector-ref f195979 0)
# emit-expr f195979
# emit-variable-ref
# env=((f195979 . 0))
# var=f195979
    movl 0(%esp), %eax  # stack load f195979
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1424193
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1424193:
    movl %eax, -16(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1424194"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1424194:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1424196
    cmp  $0,%eax
    jge _L_1424195
_L_1424196:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1424195:
    movl -16(%esp), %esi
    movl -1(%eax,%esi), %eax
    movl %eax, 4(%ebp)
    movl -12(%esp), %eax
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    or   $1, %al
    add  $8, %ebp
# cons end
    movl -4(%esp), %ebx
    movl -8(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "pair?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxremainder") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxquotient") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx*") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx-") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx+") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx>=") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx>") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx<=") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx<") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx=") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f195979 0))) (closure () (f195979) (let () (vector-ref f195979 0))))
# emit-begin
#   expr=(begin (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "pair?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxremainder") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxquotient") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx*") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx-") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx+") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx>=") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx>") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx<=") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx<") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx=") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f195979 0))) (closure () (f195979) (let () (vector-ref f195979 0))))
#   env=((f195979 . 0))
# emit-expr (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "pair?") (vector-ref f195979 0)))
# emit-expr f195979
# emit-variable-ref
# env=((f195979 . 0))
# var=f195979
    movl 0(%esp), %eax  # stack load f195979
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1424197
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1424197:
    movl %eax, -4(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1424198"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1424198:
# check bounds on vector index
    movl -4(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1424200
    cmp  $0,%eax
    jge _L_1424199
_L_1424200:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1424199:
    movl %eax, -8(%esp)
# emit-expr (cons ((primitive-ref string->symbol) "pair?") (vector-ref f195979 0))
# cons arg1=((primitive-ref string->symbol) "pair?") arg2=(vector-ref f195979 0)
# emit-expr ((primitive-ref string->symbol) "pair?")
# funcall
#    si   =-12
#    env  = ((f195979 . 0))
#    expr = (funcall (primitive-ref string->symbol) "pair?")
# emit-expr (primitive-ref string->symbol)
    .extern mrc_string$m$gsymbol
    movl mrc_string$m$gsymbol,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1424201"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1424201":
   movl %eax,  -20(%esp)  # stash funcall-oper in closure slot
# emit-expr "pair?"
# string literal
    jmp _L_1424203
    .align 8,0x90
_L_1424202 :
    .int 20
    .ascii "pair?"
_L_1424203:
    movl $_L_1424202, %eax
    orl $6, %eax
    mov %eax, -24(%esp)  # arg pair?
    movl -20(%esp), %edi   # load new closure to %edi
    add $-12, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $12, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    movl %eax, -12(%esp)
# emit-expr (vector-ref f195979 0)
# emit-expr f195979
# emit-variable-ref
# env=((f195979 . 0))
# var=f195979
    movl 0(%esp), %eax  # stack load f195979
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1424204
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1424204:
    movl %eax, -16(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1424205"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1424205:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1424207
    cmp  $0,%eax
    jge _L_1424206
_L_1424207:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1424206:
    movl -16(%esp), %esi
    movl -1(%eax,%esi), %eax
    movl %eax, 4(%ebp)
    movl -12(%esp), %eax
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    or   $1, %al
    add  $8, %ebp
# cons end
    movl -4(%esp), %ebx
    movl -8(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxremainder") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxquotient") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx*") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx-") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx+") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx>=") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx>") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx<=") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx<") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx=") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f195979 0))) (closure () (f195979) (let () (vector-ref f195979 0))))
# emit-begin
#   expr=(begin (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxremainder") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxquotient") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx*") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx-") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx+") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx>=") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx>") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx<=") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx<") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx=") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f195979 0))) (closure () (f195979) (let () (vector-ref f195979 0))))
#   env=((f195979 . 0))
# emit-expr (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxremainder") (vector-ref f195979 0)))
# emit-expr f195979
# emit-variable-ref
# env=((f195979 . 0))
# var=f195979
    movl 0(%esp), %eax  # stack load f195979
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1424208
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1424208:
    movl %eax, -4(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1424209"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1424209:
# check bounds on vector index
    movl -4(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1424211
    cmp  $0,%eax
    jge _L_1424210
_L_1424211:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1424210:
    movl %eax, -8(%esp)
# emit-expr (cons ((primitive-ref string->symbol) "fxremainder") (vector-ref f195979 0))
# cons arg1=((primitive-ref string->symbol) "fxremainder") arg2=(vector-ref f195979 0)
# emit-expr ((primitive-ref string->symbol) "fxremainder")
# funcall
#    si   =-12
#    env  = ((f195979 . 0))
#    expr = (funcall (primitive-ref string->symbol) "fxremainder")
# emit-expr (primitive-ref string->symbol)
    .extern mrc_string$m$gsymbol
    movl mrc_string$m$gsymbol,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1424212"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1424212":
   movl %eax,  -20(%esp)  # stash funcall-oper in closure slot
# emit-expr "fxremainder"
# string literal
    jmp _L_1424214
    .align 8,0x90
_L_1424213 :
    .int 44
    .ascii "fxremainder"
_L_1424214:
    movl $_L_1424213, %eax
    orl $6, %eax
    mov %eax, -24(%esp)  # arg fxremainder
    movl -20(%esp), %edi   # load new closure to %edi
    add $-12, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $12, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    movl %eax, -12(%esp)
# emit-expr (vector-ref f195979 0)
# emit-expr f195979
# emit-variable-ref
# env=((f195979 . 0))
# var=f195979
    movl 0(%esp), %eax  # stack load f195979
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1424215
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1424215:
    movl %eax, -16(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1424216"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1424216:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1424218
    cmp  $0,%eax
    jge _L_1424217
_L_1424218:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1424217:
    movl -16(%esp), %esi
    movl -1(%eax,%esi), %eax
    movl %eax, 4(%ebp)
    movl -12(%esp), %eax
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    or   $1, %al
    add  $8, %ebp
# cons end
    movl -4(%esp), %ebx
    movl -8(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxquotient") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx*") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx-") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx+") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx>=") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx>") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx<=") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx<") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx=") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f195979 0))) (closure () (f195979) (let () (vector-ref f195979 0))))
# emit-begin
#   expr=(begin (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxquotient") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx*") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx-") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx+") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx>=") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx>") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx<=") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx<") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx=") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f195979 0))) (closure () (f195979) (let () (vector-ref f195979 0))))
#   env=((f195979 . 0))
# emit-expr (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxquotient") (vector-ref f195979 0)))
# emit-expr f195979
# emit-variable-ref
# env=((f195979 . 0))
# var=f195979
    movl 0(%esp), %eax  # stack load f195979
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1424219
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1424219:
    movl %eax, -4(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1424220"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1424220:
# check bounds on vector index
    movl -4(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1424222
    cmp  $0,%eax
    jge _L_1424221
_L_1424222:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1424221:
    movl %eax, -8(%esp)
# emit-expr (cons ((primitive-ref string->symbol) "fxquotient") (vector-ref f195979 0))
# cons arg1=((primitive-ref string->symbol) "fxquotient") arg2=(vector-ref f195979 0)
# emit-expr ((primitive-ref string->symbol) "fxquotient")
# funcall
#    si   =-12
#    env  = ((f195979 . 0))
#    expr = (funcall (primitive-ref string->symbol) "fxquotient")
# emit-expr (primitive-ref string->symbol)
    .extern mrc_string$m$gsymbol
    movl mrc_string$m$gsymbol,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1424223"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1424223":
   movl %eax,  -20(%esp)  # stash funcall-oper in closure slot
# emit-expr "fxquotient"
# string literal
    jmp _L_1424225
    .align 8,0x90
_L_1424224 :
    .int 40
    .ascii "fxquotient"
_L_1424225:
    movl $_L_1424224, %eax
    orl $6, %eax
    mov %eax, -24(%esp)  # arg fxquotient
    movl -20(%esp), %edi   # load new closure to %edi
    add $-12, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $12, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    movl %eax, -12(%esp)
# emit-expr (vector-ref f195979 0)
# emit-expr f195979
# emit-variable-ref
# env=((f195979 . 0))
# var=f195979
    movl 0(%esp), %eax  # stack load f195979
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1424226
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1424226:
    movl %eax, -16(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1424227"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1424227:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1424229
    cmp  $0,%eax
    jge _L_1424228
_L_1424229:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1424228:
    movl -16(%esp), %esi
    movl -1(%eax,%esi), %eax
    movl %eax, 4(%ebp)
    movl -12(%esp), %eax
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    or   $1, %al
    add  $8, %ebp
# cons end
    movl -4(%esp), %ebx
    movl -8(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx*") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx-") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx+") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx>=") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx>") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx<=") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx<") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx=") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f195979 0))) (closure () (f195979) (let () (vector-ref f195979 0))))
# emit-begin
#   expr=(begin (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx*") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx-") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx+") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx>=") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx>") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx<=") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx<") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx=") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f195979 0))) (closure () (f195979) (let () (vector-ref f195979 0))))
#   env=((f195979 . 0))
# emit-expr (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx*") (vector-ref f195979 0)))
# emit-expr f195979
# emit-variable-ref
# env=((f195979 . 0))
# var=f195979
    movl 0(%esp), %eax  # stack load f195979
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1424230
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1424230:
    movl %eax, -4(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1424231"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1424231:
# check bounds on vector index
    movl -4(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1424233
    cmp  $0,%eax
    jge _L_1424232
_L_1424233:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1424232:
    movl %eax, -8(%esp)
# emit-expr (cons ((primitive-ref string->symbol) "fx*") (vector-ref f195979 0))
# cons arg1=((primitive-ref string->symbol) "fx*") arg2=(vector-ref f195979 0)
# emit-expr ((primitive-ref string->symbol) "fx*")
# funcall
#    si   =-12
#    env  = ((f195979 . 0))
#    expr = (funcall (primitive-ref string->symbol) "fx*")
# emit-expr (primitive-ref string->symbol)
    .extern mrc_string$m$gsymbol
    movl mrc_string$m$gsymbol,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1424234"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1424234":
   movl %eax,  -20(%esp)  # stash funcall-oper in closure slot
# emit-expr "fx*"
# string literal
    jmp _L_1424236
    .align 8,0x90
_L_1424235 :
    .int 12
    .ascii "fx*"
_L_1424236:
    movl $_L_1424235, %eax
    orl $6, %eax
    mov %eax, -24(%esp)  # arg fx*
    movl -20(%esp), %edi   # load new closure to %edi
    add $-12, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $12, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    movl %eax, -12(%esp)
# emit-expr (vector-ref f195979 0)
# emit-expr f195979
# emit-variable-ref
# env=((f195979 . 0))
# var=f195979
    movl 0(%esp), %eax  # stack load f195979
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1424237
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1424237:
    movl %eax, -16(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1424238"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1424238:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1424240
    cmp  $0,%eax
    jge _L_1424239
_L_1424240:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1424239:
    movl -16(%esp), %esi
    movl -1(%eax,%esi), %eax
    movl %eax, 4(%ebp)
    movl -12(%esp), %eax
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    or   $1, %al
    add  $8, %ebp
# cons end
    movl -4(%esp), %ebx
    movl -8(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx-") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx+") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx>=") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx>") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx<=") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx<") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx=") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f195979 0))) (closure () (f195979) (let () (vector-ref f195979 0))))
# emit-begin
#   expr=(begin (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx-") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx+") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx>=") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx>") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx<=") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx<") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx=") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f195979 0))) (closure () (f195979) (let () (vector-ref f195979 0))))
#   env=((f195979 . 0))
# emit-expr (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx-") (vector-ref f195979 0)))
# emit-expr f195979
# emit-variable-ref
# env=((f195979 . 0))
# var=f195979
    movl 0(%esp), %eax  # stack load f195979
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1424241
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1424241:
    movl %eax, -4(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1424242"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1424242:
# check bounds on vector index
    movl -4(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1424244
    cmp  $0,%eax
    jge _L_1424243
_L_1424244:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1424243:
    movl %eax, -8(%esp)
# emit-expr (cons ((primitive-ref string->symbol) "fx-") (vector-ref f195979 0))
# cons arg1=((primitive-ref string->symbol) "fx-") arg2=(vector-ref f195979 0)
# emit-expr ((primitive-ref string->symbol) "fx-")
# funcall
#    si   =-12
#    env  = ((f195979 . 0))
#    expr = (funcall (primitive-ref string->symbol) "fx-")
# emit-expr (primitive-ref string->symbol)
    .extern mrc_string$m$gsymbol
    movl mrc_string$m$gsymbol,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1424245"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1424245":
   movl %eax,  -20(%esp)  # stash funcall-oper in closure slot
# emit-expr "fx-"
# string literal
    jmp _L_1424247
    .align 8,0x90
_L_1424246 :
    .int 12
    .ascii "fx-"
_L_1424247:
    movl $_L_1424246, %eax
    orl $6, %eax
    mov %eax, -24(%esp)  # arg fx-
    movl -20(%esp), %edi   # load new closure to %edi
    add $-12, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $12, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    movl %eax, -12(%esp)
# emit-expr (vector-ref f195979 0)
# emit-expr f195979
# emit-variable-ref
# env=((f195979 . 0))
# var=f195979
    movl 0(%esp), %eax  # stack load f195979
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1424248
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1424248:
    movl %eax, -16(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1424249"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1424249:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1424251
    cmp  $0,%eax
    jge _L_1424250
_L_1424251:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1424250:
    movl -16(%esp), %esi
    movl -1(%eax,%esi), %eax
    movl %eax, 4(%ebp)
    movl -12(%esp), %eax
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    or   $1, %al
    add  $8, %ebp
# cons end
    movl -4(%esp), %ebx
    movl -8(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx+") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx>=") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx>") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx<=") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx<") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx=") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f195979 0))) (closure () (f195979) (let () (vector-ref f195979 0))))
# emit-begin
#   expr=(begin (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx+") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx>=") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx>") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx<=") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx<") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx=") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f195979 0))) (closure () (f195979) (let () (vector-ref f195979 0))))
#   env=((f195979 . 0))
# emit-expr (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx+") (vector-ref f195979 0)))
# emit-expr f195979
# emit-variable-ref
# env=((f195979 . 0))
# var=f195979
    movl 0(%esp), %eax  # stack load f195979
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1424252
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1424252:
    movl %eax, -4(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1424253"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1424253:
# check bounds on vector index
    movl -4(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1424255
    cmp  $0,%eax
    jge _L_1424254
_L_1424255:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1424254:
    movl %eax, -8(%esp)
# emit-expr (cons ((primitive-ref string->symbol) "fx+") (vector-ref f195979 0))
# cons arg1=((primitive-ref string->symbol) "fx+") arg2=(vector-ref f195979 0)
# emit-expr ((primitive-ref string->symbol) "fx+")
# funcall
#    si   =-12
#    env  = ((f195979 . 0))
#    expr = (funcall (primitive-ref string->symbol) "fx+")
# emit-expr (primitive-ref string->symbol)
    .extern mrc_string$m$gsymbol
    movl mrc_string$m$gsymbol,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1424256"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1424256":
   movl %eax,  -20(%esp)  # stash funcall-oper in closure slot
# emit-expr "fx+"
# string literal
    jmp _L_1424258
    .align 8,0x90
_L_1424257 :
    .int 12
    .ascii "fx+"
_L_1424258:
    movl $_L_1424257, %eax
    orl $6, %eax
    mov %eax, -24(%esp)  # arg fx+
    movl -20(%esp), %edi   # load new closure to %edi
    add $-12, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $12, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    movl %eax, -12(%esp)
# emit-expr (vector-ref f195979 0)
# emit-expr f195979
# emit-variable-ref
# env=((f195979 . 0))
# var=f195979
    movl 0(%esp), %eax  # stack load f195979
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1424259
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1424259:
    movl %eax, -16(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1424260"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1424260:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1424262
    cmp  $0,%eax
    jge _L_1424261
_L_1424262:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1424261:
    movl -16(%esp), %esi
    movl -1(%eax,%esi), %eax
    movl %eax, 4(%ebp)
    movl -12(%esp), %eax
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    or   $1, %al
    add  $8, %ebp
# cons end
    movl -4(%esp), %ebx
    movl -8(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx>=") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx>") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx<=") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx<") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx=") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f195979 0))) (closure () (f195979) (let () (vector-ref f195979 0))))
# emit-begin
#   expr=(begin (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx>=") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx>") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx<=") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx<") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx=") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f195979 0))) (closure () (f195979) (let () (vector-ref f195979 0))))
#   env=((f195979 . 0))
# emit-expr (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx>=") (vector-ref f195979 0)))
# emit-expr f195979
# emit-variable-ref
# env=((f195979 . 0))
# var=f195979
    movl 0(%esp), %eax  # stack load f195979
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1424263
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1424263:
    movl %eax, -4(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1424264"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1424264:
# check bounds on vector index
    movl -4(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1424266
    cmp  $0,%eax
    jge _L_1424265
_L_1424266:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1424265:
    movl %eax, -8(%esp)
# emit-expr (cons ((primitive-ref string->symbol) "fx>=") (vector-ref f195979 0))
# cons arg1=((primitive-ref string->symbol) "fx>=") arg2=(vector-ref f195979 0)
# emit-expr ((primitive-ref string->symbol) "fx>=")
# funcall
#    si   =-12
#    env  = ((f195979 . 0))
#    expr = (funcall (primitive-ref string->symbol) "fx>=")
# emit-expr (primitive-ref string->symbol)
    .extern mrc_string$m$gsymbol
    movl mrc_string$m$gsymbol,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1424267"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1424267":
   movl %eax,  -20(%esp)  # stash funcall-oper in closure slot
# emit-expr "fx>="
# string literal
    jmp _L_1424269
    .align 8,0x90
_L_1424268 :
    .int 16
    .ascii "fx>="
_L_1424269:
    movl $_L_1424268, %eax
    orl $6, %eax
    mov %eax, -24(%esp)  # arg fx>=
    movl -20(%esp), %edi   # load new closure to %edi
    add $-12, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $12, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    movl %eax, -12(%esp)
# emit-expr (vector-ref f195979 0)
# emit-expr f195979
# emit-variable-ref
# env=((f195979 . 0))
# var=f195979
    movl 0(%esp), %eax  # stack load f195979
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1424270
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1424270:
    movl %eax, -16(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1424271"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1424271:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1424273
    cmp  $0,%eax
    jge _L_1424272
_L_1424273:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1424272:
    movl -16(%esp), %esi
    movl -1(%eax,%esi), %eax
    movl %eax, 4(%ebp)
    movl -12(%esp), %eax
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    or   $1, %al
    add  $8, %ebp
# cons end
    movl -4(%esp), %ebx
    movl -8(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx>") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx<=") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx<") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx=") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f195979 0))) (closure () (f195979) (let () (vector-ref f195979 0))))
# emit-begin
#   expr=(begin (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx>") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx<=") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx<") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx=") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f195979 0))) (closure () (f195979) (let () (vector-ref f195979 0))))
#   env=((f195979 . 0))
# emit-expr (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx>") (vector-ref f195979 0)))
# emit-expr f195979
# emit-variable-ref
# env=((f195979 . 0))
# var=f195979
    movl 0(%esp), %eax  # stack load f195979
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1424274
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1424274:
    movl %eax, -4(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1424275"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1424275:
# check bounds on vector index
    movl -4(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1424277
    cmp  $0,%eax
    jge _L_1424276
_L_1424277:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1424276:
    movl %eax, -8(%esp)
# emit-expr (cons ((primitive-ref string->symbol) "fx>") (vector-ref f195979 0))
# cons arg1=((primitive-ref string->symbol) "fx>") arg2=(vector-ref f195979 0)
# emit-expr ((primitive-ref string->symbol) "fx>")
# funcall
#    si   =-12
#    env  = ((f195979 . 0))
#    expr = (funcall (primitive-ref string->symbol) "fx>")
# emit-expr (primitive-ref string->symbol)
    .extern mrc_string$m$gsymbol
    movl mrc_string$m$gsymbol,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1424278"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1424278":
   movl %eax,  -20(%esp)  # stash funcall-oper in closure slot
# emit-expr "fx>"
# string literal
    jmp _L_1424280
    .align 8,0x90
_L_1424279 :
    .int 12
    .ascii "fx>"
_L_1424280:
    movl $_L_1424279, %eax
    orl $6, %eax
    mov %eax, -24(%esp)  # arg fx>
    movl -20(%esp), %edi   # load new closure to %edi
    add $-12, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $12, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    movl %eax, -12(%esp)
# emit-expr (vector-ref f195979 0)
# emit-expr f195979
# emit-variable-ref
# env=((f195979 . 0))
# var=f195979
    movl 0(%esp), %eax  # stack load f195979
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1424281
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1424281:
    movl %eax, -16(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1424282"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1424282:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1424284
    cmp  $0,%eax
    jge _L_1424283
_L_1424284:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1424283:
    movl -16(%esp), %esi
    movl -1(%eax,%esi), %eax
    movl %eax, 4(%ebp)
    movl -12(%esp), %eax
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    or   $1, %al
    add  $8, %ebp
# cons end
    movl -4(%esp), %ebx
    movl -8(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx<=") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx<") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx=") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f195979 0))) (closure () (f195979) (let () (vector-ref f195979 0))))
# emit-begin
#   expr=(begin (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx<=") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx<") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx=") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f195979 0))) (closure () (f195979) (let () (vector-ref f195979 0))))
#   env=((f195979 . 0))
# emit-expr (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx<=") (vector-ref f195979 0)))
# emit-expr f195979
# emit-variable-ref
# env=((f195979 . 0))
# var=f195979
    movl 0(%esp), %eax  # stack load f195979
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1424285
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1424285:
    movl %eax, -4(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1424286"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1424286:
# check bounds on vector index
    movl -4(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1424288
    cmp  $0,%eax
    jge _L_1424287
_L_1424288:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1424287:
    movl %eax, -8(%esp)
# emit-expr (cons ((primitive-ref string->symbol) "fx<=") (vector-ref f195979 0))
# cons arg1=((primitive-ref string->symbol) "fx<=") arg2=(vector-ref f195979 0)
# emit-expr ((primitive-ref string->symbol) "fx<=")
# funcall
#    si   =-12
#    env  = ((f195979 . 0))
#    expr = (funcall (primitive-ref string->symbol) "fx<=")
# emit-expr (primitive-ref string->symbol)
    .extern mrc_string$m$gsymbol
    movl mrc_string$m$gsymbol,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1424289"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1424289":
   movl %eax,  -20(%esp)  # stash funcall-oper in closure slot
# emit-expr "fx<="
# string literal
    jmp _L_1424291
    .align 8,0x90
_L_1424290 :
    .int 16
    .ascii "fx<="
_L_1424291:
    movl $_L_1424290, %eax
    orl $6, %eax
    mov %eax, -24(%esp)  # arg fx<=
    movl -20(%esp), %edi   # load new closure to %edi
    add $-12, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $12, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    movl %eax, -12(%esp)
# emit-expr (vector-ref f195979 0)
# emit-expr f195979
# emit-variable-ref
# env=((f195979 . 0))
# var=f195979
    movl 0(%esp), %eax  # stack load f195979
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1424292
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1424292:
    movl %eax, -16(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1424293"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1424293:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1424295
    cmp  $0,%eax
    jge _L_1424294
_L_1424295:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1424294:
    movl -16(%esp), %esi
    movl -1(%eax,%esi), %eax
    movl %eax, 4(%ebp)
    movl -12(%esp), %eax
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    or   $1, %al
    add  $8, %ebp
# cons end
    movl -4(%esp), %ebx
    movl -8(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx<") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx=") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f195979 0))) (closure () (f195979) (let () (vector-ref f195979 0))))
# emit-begin
#   expr=(begin (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx<") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx=") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f195979 0))) (closure () (f195979) (let () (vector-ref f195979 0))))
#   env=((f195979 . 0))
# emit-expr (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx<") (vector-ref f195979 0)))
# emit-expr f195979
# emit-variable-ref
# env=((f195979 . 0))
# var=f195979
    movl 0(%esp), %eax  # stack load f195979
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1424296
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1424296:
    movl %eax, -4(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1424297"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1424297:
# check bounds on vector index
    movl -4(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1424299
    cmp  $0,%eax
    jge _L_1424298
_L_1424299:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1424298:
    movl %eax, -8(%esp)
# emit-expr (cons ((primitive-ref string->symbol) "fx<") (vector-ref f195979 0))
# cons arg1=((primitive-ref string->symbol) "fx<") arg2=(vector-ref f195979 0)
# emit-expr ((primitive-ref string->symbol) "fx<")
# funcall
#    si   =-12
#    env  = ((f195979 . 0))
#    expr = (funcall (primitive-ref string->symbol) "fx<")
# emit-expr (primitive-ref string->symbol)
    .extern mrc_string$m$gsymbol
    movl mrc_string$m$gsymbol,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1424300"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1424300":
   movl %eax,  -20(%esp)  # stash funcall-oper in closure slot
# emit-expr "fx<"
# string literal
    jmp _L_1424302
    .align 8,0x90
_L_1424301 :
    .int 12
    .ascii "fx<"
_L_1424302:
    movl $_L_1424301, %eax
    orl $6, %eax
    mov %eax, -24(%esp)  # arg fx<
    movl -20(%esp), %edi   # load new closure to %edi
    add $-12, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $12, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    movl %eax, -12(%esp)
# emit-expr (vector-ref f195979 0)
# emit-expr f195979
# emit-variable-ref
# env=((f195979 . 0))
# var=f195979
    movl 0(%esp), %eax  # stack load f195979
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1424303
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1424303:
    movl %eax, -16(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1424304"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1424304:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1424306
    cmp  $0,%eax
    jge _L_1424305
_L_1424306:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1424305:
    movl -16(%esp), %esi
    movl -1(%eax,%esi), %eax
    movl %eax, 4(%ebp)
    movl -12(%esp), %eax
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    or   $1, %al
    add  $8, %ebp
# cons end
    movl -4(%esp), %ebx
    movl -8(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx=") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f195979 0))) (closure () (f195979) (let () (vector-ref f195979 0))))
# emit-begin
#   expr=(begin (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx=") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f195979 0))) (closure () (f195979) (let () (vector-ref f195979 0))))
#   env=((f195979 . 0))
# emit-expr (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx=") (vector-ref f195979 0)))
# emit-expr f195979
# emit-variable-ref
# env=((f195979 . 0))
# var=f195979
    movl 0(%esp), %eax  # stack load f195979
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1424307
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1424307:
    movl %eax, -4(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1424308"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1424308:
# check bounds on vector index
    movl -4(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1424310
    cmp  $0,%eax
    jge _L_1424309
_L_1424310:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1424309:
    movl %eax, -8(%esp)
# emit-expr (cons ((primitive-ref string->symbol) "fx=") (vector-ref f195979 0))
# cons arg1=((primitive-ref string->symbol) "fx=") arg2=(vector-ref f195979 0)
# emit-expr ((primitive-ref string->symbol) "fx=")
# funcall
#    si   =-12
#    env  = ((f195979 . 0))
#    expr = (funcall (primitive-ref string->symbol) "fx=")
# emit-expr (primitive-ref string->symbol)
    .extern mrc_string$m$gsymbol
    movl mrc_string$m$gsymbol,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1424311"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1424311":
   movl %eax,  -20(%esp)  # stash funcall-oper in closure slot
# emit-expr "fx="
# string literal
    jmp _L_1424313
    .align 8,0x90
_L_1424312 :
    .int 12
    .ascii "fx="
_L_1424313:
    movl $_L_1424312, %eax
    orl $6, %eax
    mov %eax, -24(%esp)  # arg fx=
    movl -20(%esp), %edi   # load new closure to %edi
    add $-12, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $12, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    movl %eax, -12(%esp)
# emit-expr (vector-ref f195979 0)
# emit-expr f195979
# emit-variable-ref
# env=((f195979 . 0))
# var=f195979
    movl 0(%esp), %eax  # stack load f195979
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1424314
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1424314:
    movl %eax, -16(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1424315"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1424315:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1424317
    cmp  $0,%eax
    jge _L_1424316
_L_1424317:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1424316:
    movl -16(%esp), %esi
    movl -1(%eax,%esi), %eax
    movl %eax, 4(%ebp)
    movl -12(%esp), %eax
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    or   $1, %al
    add  $8, %ebp
# cons end
    movl -4(%esp), %ebx
    movl -8(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f195979 0))) (closure () (f195979) (let () (vector-ref f195979 0))))
# emit-begin
#   expr=(begin (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f195979 0))) (closure () (f195979) (let () (vector-ref f195979 0))))
#   env=((f195979 . 0))
# emit-expr (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f195979 0)))
# emit-expr f195979
# emit-variable-ref
# env=((f195979 . 0))
# var=f195979
    movl 0(%esp), %eax  # stack load f195979
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1424318
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1424318:
    movl %eax, -4(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1424319"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1424319:
# check bounds on vector index
    movl -4(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1424321
    cmp  $0,%eax
    jge _L_1424320
_L_1424321:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1424320:
    movl %eax, -8(%esp)
# emit-expr (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f195979 0))
# cons arg1=((primitive-ref string->symbol) "fxzero?") arg2=(vector-ref f195979 0)
# emit-expr ((primitive-ref string->symbol) "fxzero?")
# funcall
#    si   =-12
#    env  = ((f195979 . 0))
#    expr = (funcall (primitive-ref string->symbol) "fxzero?")
# emit-expr (primitive-ref string->symbol)
    .extern mrc_string$m$gsymbol
    movl mrc_string$m$gsymbol,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1424322"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1424322":
   movl %eax,  -20(%esp)  # stash funcall-oper in closure slot
# emit-expr "fxzero?"
# string literal
    jmp _L_1424324
    .align 8,0x90
_L_1424323 :
    .int 28
    .ascii "fxzero?"
_L_1424324:
    movl $_L_1424323, %eax
    orl $6, %eax
    mov %eax, -24(%esp)  # arg fxzero?
    movl -20(%esp), %edi   # load new closure to %edi
    add $-12, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $12, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    movl %eax, -12(%esp)
# emit-expr (vector-ref f195979 0)
# emit-expr f195979
# emit-variable-ref
# env=((f195979 . 0))
# var=f195979
    movl 0(%esp), %eax  # stack load f195979
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1424325
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1424325:
    movl %eax, -16(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1424326"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1424326:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1424328
    cmp  $0,%eax
    jge _L_1424327
_L_1424328:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1424327:
    movl -16(%esp), %esi
    movl -1(%eax,%esi), %eax
    movl %eax, 4(%ebp)
    movl -12(%esp), %eax
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    or   $1, %al
    add  $8, %ebp
# cons end
    movl -4(%esp), %ebx
    movl -8(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f195979 0))) (closure () (f195979) (let () (vector-ref f195979 0))))
# emit-begin
#   expr=(begin (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f195979 0))) (closure () (f195979) (let () (vector-ref f195979 0))))
#   env=((f195979 . 0))
# emit-expr (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f195979 0)))
# emit-expr f195979
# emit-variable-ref
# env=((f195979 . 0))
# var=f195979
    movl 0(%esp), %eax  # stack load f195979
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1424329
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1424329:
    movl %eax, -4(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1424330"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1424330:
# check bounds on vector index
    movl -4(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1424332
    cmp  $0,%eax
    jge _L_1424331
_L_1424332:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1424331:
    movl %eax, -8(%esp)
# emit-expr (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f195979 0))
# cons arg1=((primitive-ref string->symbol) "fxsub1") arg2=(vector-ref f195979 0)
# emit-expr ((primitive-ref string->symbol) "fxsub1")
# funcall
#    si   =-12
#    env  = ((f195979 . 0))
#    expr = (funcall (primitive-ref string->symbol) "fxsub1")
# emit-expr (primitive-ref string->symbol)
    .extern mrc_string$m$gsymbol
    movl mrc_string$m$gsymbol,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1424333"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1424333":
   movl %eax,  -20(%esp)  # stash funcall-oper in closure slot
# emit-expr "fxsub1"
# string literal
    jmp _L_1424335
    .align 8,0x90
_L_1424334 :
    .int 24
    .ascii "fxsub1"
_L_1424335:
    movl $_L_1424334, %eax
    orl $6, %eax
    mov %eax, -24(%esp)  # arg fxsub1
    movl -20(%esp), %edi   # load new closure to %edi
    add $-12, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $12, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    movl %eax, -12(%esp)
# emit-expr (vector-ref f195979 0)
# emit-expr f195979
# emit-variable-ref
# env=((f195979 . 0))
# var=f195979
    movl 0(%esp), %eax  # stack load f195979
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1424336
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1424336:
    movl %eax, -16(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1424337"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1424337:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1424339
    cmp  $0,%eax
    jge _L_1424338
_L_1424339:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1424338:
    movl -16(%esp), %esi
    movl -1(%eax,%esi), %eax
    movl %eax, 4(%ebp)
    movl -12(%esp), %eax
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    or   $1, %al
    add  $8, %ebp
# cons end
    movl -4(%esp), %ebx
    movl -8(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f195979 0))) (closure () (f195979) (let () (vector-ref f195979 0))))
# emit-begin
#   expr=(begin (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f195979 0))) (closure () (f195979) (let () (vector-ref f195979 0))))
#   env=((f195979 . 0))
# emit-expr (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f195979 0)))
# emit-expr f195979
# emit-variable-ref
# env=((f195979 . 0))
# var=f195979
    movl 0(%esp), %eax  # stack load f195979
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1424340
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1424340:
    movl %eax, -4(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1424341"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1424341:
# check bounds on vector index
    movl -4(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1424343
    cmp  $0,%eax
    jge _L_1424342
_L_1424343:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1424342:
    movl %eax, -8(%esp)
# emit-expr (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f195979 0))
# cons arg1=((primitive-ref string->symbol) "fxadd1") arg2=(vector-ref f195979 0)
# emit-expr ((primitive-ref string->symbol) "fxadd1")
# funcall
#    si   =-12
#    env  = ((f195979 . 0))
#    expr = (funcall (primitive-ref string->symbol) "fxadd1")
# emit-expr (primitive-ref string->symbol)
    .extern mrc_string$m$gsymbol
    movl mrc_string$m$gsymbol,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1424344"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1424344":
   movl %eax,  -20(%esp)  # stash funcall-oper in closure slot
# emit-expr "fxadd1"
# string literal
    jmp _L_1424346
    .align 8,0x90
_L_1424345 :
    .int 24
    .ascii "fxadd1"
_L_1424346:
    movl $_L_1424345, %eax
    orl $6, %eax
    mov %eax, -24(%esp)  # arg fxadd1
    movl -20(%esp), %edi   # load new closure to %edi
    add $-12, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $12, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    movl %eax, -12(%esp)
# emit-expr (vector-ref f195979 0)
# emit-expr f195979
# emit-variable-ref
# env=((f195979 . 0))
# var=f195979
    movl 0(%esp), %eax  # stack load f195979
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1424347
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1424347:
    movl %eax, -16(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1424348"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1424348:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1424350
    cmp  $0,%eax
    jge _L_1424349
_L_1424350:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1424349:
    movl -16(%esp), %esi
    movl -1(%eax,%esi), %eax
    movl %eax, 4(%ebp)
    movl -12(%esp), %eax
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    or   $1, %al
    add  $8, %ebp
# cons end
    movl -4(%esp), %ebx
    movl -8(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f195979 0))) (closure () (f195979) (let () (vector-ref f195979 0))))
# emit-begin
#   expr=(begin (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f195979 0))) (closure () (f195979) (let () (vector-ref f195979 0))))
#   env=((f195979 . 0))
# emit-expr (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f195979 0)))
# emit-expr f195979
# emit-variable-ref
# env=((f195979 . 0))
# var=f195979
    movl 0(%esp), %eax  # stack load f195979
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1424351
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1424351:
    movl %eax, -4(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1424352"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1424352:
# check bounds on vector index
    movl -4(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1424354
    cmp  $0,%eax
    jge _L_1424353
_L_1424354:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1424353:
    movl %eax, -8(%esp)
# emit-expr (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f195979 0))
# cons arg1=((primitive-ref string->symbol) "fxlogor") arg2=(vector-ref f195979 0)
# emit-expr ((primitive-ref string->symbol) "fxlogor")
# funcall
#    si   =-12
#    env  = ((f195979 . 0))
#    expr = (funcall (primitive-ref string->symbol) "fxlogor")
# emit-expr (primitive-ref string->symbol)
    .extern mrc_string$m$gsymbol
    movl mrc_string$m$gsymbol,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1424355"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1424355":
   movl %eax,  -20(%esp)  # stash funcall-oper in closure slot
# emit-expr "fxlogor"
# string literal
    jmp _L_1424357
    .align 8,0x90
_L_1424356 :
    .int 28
    .ascii "fxlogor"
_L_1424357:
    movl $_L_1424356, %eax
    orl $6, %eax
    mov %eax, -24(%esp)  # arg fxlogor
    movl -20(%esp), %edi   # load new closure to %edi
    add $-12, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $12, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    movl %eax, -12(%esp)
# emit-expr (vector-ref f195979 0)
# emit-expr f195979
# emit-variable-ref
# env=((f195979 . 0))
# var=f195979
    movl 0(%esp), %eax  # stack load f195979
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1424358
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1424358:
    movl %eax, -16(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1424359"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1424359:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1424361
    cmp  $0,%eax
    jge _L_1424360
_L_1424361:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1424360:
    movl -16(%esp), %esi
    movl -1(%eax,%esi), %eax
    movl %eax, 4(%ebp)
    movl -12(%esp), %eax
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    or   $1, %al
    add  $8, %ebp
# cons end
    movl -4(%esp), %ebx
    movl -8(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f195979 0))) (closure () (f195979) (let () (vector-ref f195979 0))))
# emit-begin
#   expr=(begin (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f195979 0))) (closure () (f195979) (let () (vector-ref f195979 0))))
#   env=((f195979 . 0))
# emit-expr (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f195979 0)))
# emit-expr f195979
# emit-variable-ref
# env=((f195979 . 0))
# var=f195979
    movl 0(%esp), %eax  # stack load f195979
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1424362
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1424362:
    movl %eax, -4(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1424363"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1424363:
# check bounds on vector index
    movl -4(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1424365
    cmp  $0,%eax
    jge _L_1424364
_L_1424365:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1424364:
    movl %eax, -8(%esp)
# emit-expr (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f195979 0))
# cons arg1=((primitive-ref string->symbol) "fxlogand") arg2=(vector-ref f195979 0)
# emit-expr ((primitive-ref string->symbol) "fxlogand")
# funcall
#    si   =-12
#    env  = ((f195979 . 0))
#    expr = (funcall (primitive-ref string->symbol) "fxlogand")
# emit-expr (primitive-ref string->symbol)
    .extern mrc_string$m$gsymbol
    movl mrc_string$m$gsymbol,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1424366"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1424366":
   movl %eax,  -20(%esp)  # stash funcall-oper in closure slot
# emit-expr "fxlogand"
# string literal
    jmp _L_1424368
    .align 8,0x90
_L_1424367 :
    .int 32
    .ascii "fxlogand"
_L_1424368:
    movl $_L_1424367, %eax
    orl $6, %eax
    mov %eax, -24(%esp)  # arg fxlogand
    movl -20(%esp), %edi   # load new closure to %edi
    add $-12, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $12, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    movl %eax, -12(%esp)
# emit-expr (vector-ref f195979 0)
# emit-expr f195979
# emit-variable-ref
# env=((f195979 . 0))
# var=f195979
    movl 0(%esp), %eax  # stack load f195979
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1424369
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1424369:
    movl %eax, -16(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1424370"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1424370:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1424372
    cmp  $0,%eax
    jge _L_1424371
_L_1424372:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1424371:
    movl -16(%esp), %esi
    movl -1(%eax,%esi), %eax
    movl %eax, 4(%ebp)
    movl -12(%esp), %eax
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    or   $1, %al
    add  $8, %ebp
# cons end
    movl -4(%esp), %ebx
    movl -8(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f195979 0))) (closure () (f195979) (let () (vector-ref f195979 0))))
# emit-begin
#   expr=(begin (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f195979 0))) (closure () (f195979) (let () (vector-ref f195979 0))))
#   env=((f195979 . 0))
# emit-expr (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f195979 0)))
# emit-expr f195979
# emit-variable-ref
# env=((f195979 . 0))
# var=f195979
    movl 0(%esp), %eax  # stack load f195979
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1424373
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1424373:
    movl %eax, -4(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1424374"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1424374:
# check bounds on vector index
    movl -4(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1424376
    cmp  $0,%eax
    jge _L_1424375
_L_1424376:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1424375:
    movl %eax, -8(%esp)
# emit-expr (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f195979 0))
# cons arg1=((primitive-ref string->symbol) "fxlognot") arg2=(vector-ref f195979 0)
# emit-expr ((primitive-ref string->symbol) "fxlognot")
# funcall
#    si   =-12
#    env  = ((f195979 . 0))
#    expr = (funcall (primitive-ref string->symbol) "fxlognot")
# emit-expr (primitive-ref string->symbol)
    .extern mrc_string$m$gsymbol
    movl mrc_string$m$gsymbol,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1424377"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1424377":
   movl %eax,  -20(%esp)  # stash funcall-oper in closure slot
# emit-expr "fxlognot"
# string literal
    jmp _L_1424379
    .align 8,0x90
_L_1424378 :
    .int 32
    .ascii "fxlognot"
_L_1424379:
    movl $_L_1424378, %eax
    orl $6, %eax
    mov %eax, -24(%esp)  # arg fxlognot
    movl -20(%esp), %edi   # load new closure to %edi
    add $-12, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $12, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    movl %eax, -12(%esp)
# emit-expr (vector-ref f195979 0)
# emit-expr f195979
# emit-variable-ref
# env=((f195979 . 0))
# var=f195979
    movl 0(%esp), %eax  # stack load f195979
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1424380
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1424380:
    movl %eax, -16(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1424381"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1424381:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1424383
    cmp  $0,%eax
    jge _L_1424382
_L_1424383:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1424382:
    movl -16(%esp), %esi
    movl -1(%eax,%esi), %eax
    movl %eax, 4(%ebp)
    movl -12(%esp), %eax
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    or   $1, %al
    add  $8, %ebp
# cons end
    movl -4(%esp), %ebx
    movl -8(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f195979 0))) (closure () (f195979) (let () (vector-ref f195979 0))))
# emit-begin
#   expr=(begin (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f195979 0))) (closure () (f195979) (let () (vector-ref f195979 0))))
#   env=((f195979 . 0))
# emit-expr (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f195979 0)))
# emit-expr f195979
# emit-variable-ref
# env=((f195979 . 0))
# var=f195979
    movl 0(%esp), %eax  # stack load f195979
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1424384
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1424384:
    movl %eax, -4(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1424385"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1424385:
# check bounds on vector index
    movl -4(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1424387
    cmp  $0,%eax
    jge _L_1424386
_L_1424387:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1424386:
    movl %eax, -8(%esp)
# emit-expr (cons ((primitive-ref string->symbol) "char=?") (vector-ref f195979 0))
# cons arg1=((primitive-ref string->symbol) "char=?") arg2=(vector-ref f195979 0)
# emit-expr ((primitive-ref string->symbol) "char=?")
# funcall
#    si   =-12
#    env  = ((f195979 . 0))
#    expr = (funcall (primitive-ref string->symbol) "char=?")
# emit-expr (primitive-ref string->symbol)
    .extern mrc_string$m$gsymbol
    movl mrc_string$m$gsymbol,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1424388"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1424388":
   movl %eax,  -20(%esp)  # stash funcall-oper in closure slot
# emit-expr "char=?"
# string literal
    jmp _L_1424390
    .align 8,0x90
_L_1424389 :
    .int 24
    .ascii "char=?"
_L_1424390:
    movl $_L_1424389, %eax
    orl $6, %eax
    mov %eax, -24(%esp)  # arg char=?
    movl -20(%esp), %edi   # load new closure to %edi
    add $-12, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $12, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    movl %eax, -12(%esp)
# emit-expr (vector-ref f195979 0)
# emit-expr f195979
# emit-variable-ref
# env=((f195979 . 0))
# var=f195979
    movl 0(%esp), %eax  # stack load f195979
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1424391
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1424391:
    movl %eax, -16(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1424392"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1424392:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1424394
    cmp  $0,%eax
    jge _L_1424393
_L_1424394:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1424393:
    movl -16(%esp), %esi
    movl -1(%eax,%esi), %eax
    movl %eax, 4(%ebp)
    movl -12(%esp), %eax
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    or   $1, %al
    add  $8, %ebp
# cons end
    movl -4(%esp), %ebx
    movl -8(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f195979 0))) (closure () (f195979) (let () (vector-ref f195979 0))))
# emit-begin
#   expr=(begin (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f195979 0))) (closure () (f195979) (let () (vector-ref f195979 0))))
#   env=((f195979 . 0))
# emit-expr (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f195979 0)))
# emit-expr f195979
# emit-variable-ref
# env=((f195979 . 0))
# var=f195979
    movl 0(%esp), %eax  # stack load f195979
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1424395
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1424395:
    movl %eax, -4(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1424396"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1424396:
# check bounds on vector index
    movl -4(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1424398
    cmp  $0,%eax
    jge _L_1424397
_L_1424398:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1424397:
    movl %eax, -8(%esp)
# emit-expr (cons ((primitive-ref string->symbol) "eq?") (vector-ref f195979 0))
# cons arg1=((primitive-ref string->symbol) "eq?") arg2=(vector-ref f195979 0)
# emit-expr ((primitive-ref string->symbol) "eq?")
# funcall
#    si   =-12
#    env  = ((f195979 . 0))
#    expr = (funcall (primitive-ref string->symbol) "eq?")
# emit-expr (primitive-ref string->symbol)
    .extern mrc_string$m$gsymbol
    movl mrc_string$m$gsymbol,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1424399"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1424399":
   movl %eax,  -20(%esp)  # stash funcall-oper in closure slot
# emit-expr "eq?"
# string literal
    jmp _L_1424401
    .align 8,0x90
_L_1424400 :
    .int 12
    .ascii "eq?"
_L_1424401:
    movl $_L_1424400, %eax
    orl $6, %eax
    mov %eax, -24(%esp)  # arg eq?
    movl -20(%esp), %edi   # load new closure to %edi
    add $-12, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $12, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    movl %eax, -12(%esp)
# emit-expr (vector-ref f195979 0)
# emit-expr f195979
# emit-variable-ref
# env=((f195979 . 0))
# var=f195979
    movl 0(%esp), %eax  # stack load f195979
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1424402
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1424402:
    movl %eax, -16(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1424403"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1424403:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1424405
    cmp  $0,%eax
    jge _L_1424404
_L_1424405:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1424404:
    movl -16(%esp), %esi
    movl -1(%eax,%esi), %eax
    movl %eax, 4(%ebp)
    movl -12(%esp), %eax
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    or   $1, %al
    add  $8, %ebp
# cons end
    movl -4(%esp), %ebx
    movl -8(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f195979 0))) (closure () (f195979) (let () (vector-ref f195979 0))))
# emit-begin
#   expr=(begin (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f195979 0))) (closure () (f195979) (let () (vector-ref f195979 0))))
#   env=((f195979 . 0))
# emit-expr (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f195979 0)))
# emit-expr f195979
# emit-variable-ref
# env=((f195979 . 0))
# var=f195979
    movl 0(%esp), %eax  # stack load f195979
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1424406
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1424406:
    movl %eax, -4(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1424407"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1424407:
# check bounds on vector index
    movl -4(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1424409
    cmp  $0,%eax
    jge _L_1424408
_L_1424409:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1424408:
    movl %eax, -8(%esp)
# emit-expr (cons ((primitive-ref string->symbol) "not") (vector-ref f195979 0))
# cons arg1=((primitive-ref string->symbol) "not") arg2=(vector-ref f195979 0)
# emit-expr ((primitive-ref string->symbol) "not")
# funcall
#    si   =-12
#    env  = ((f195979 . 0))
#    expr = (funcall (primitive-ref string->symbol) "not")
# emit-expr (primitive-ref string->symbol)
    .extern mrc_string$m$gsymbol
    movl mrc_string$m$gsymbol,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1424410"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1424410":
   movl %eax,  -20(%esp)  # stash funcall-oper in closure slot
# emit-expr "not"
# string literal
    jmp _L_1424412
    .align 8,0x90
_L_1424411 :
    .int 12
    .ascii "not"
_L_1424412:
    movl $_L_1424411, %eax
    orl $6, %eax
    mov %eax, -24(%esp)  # arg not
    movl -20(%esp), %edi   # load new closure to %edi
    add $-12, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $12, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    movl %eax, -12(%esp)
# emit-expr (vector-ref f195979 0)
# emit-expr f195979
# emit-variable-ref
# env=((f195979 . 0))
# var=f195979
    movl 0(%esp), %eax  # stack load f195979
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1424413
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1424413:
    movl %eax, -16(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1424414"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1424414:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1424416
    cmp  $0,%eax
    jge _L_1424415
_L_1424416:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1424415:
    movl -16(%esp), %esi
    movl -1(%eax,%esi), %eax
    movl %eax, 4(%ebp)
    movl -12(%esp), %eax
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    or   $1, %al
    add  $8, %ebp
# cons end
    movl -4(%esp), %ebx
    movl -8(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f195979 0))) (closure () (f195979) (let () (vector-ref f195979 0))))
# emit-begin
#   expr=(begin (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f195979 0))) (closure () (f195979) (let () (vector-ref f195979 0))))
#   env=((f195979 . 0))
# emit-expr (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f195979 0)))
# emit-expr f195979
# emit-variable-ref
# env=((f195979 . 0))
# var=f195979
    movl 0(%esp), %eax  # stack load f195979
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1424417
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1424417:
    movl %eax, -4(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1424418"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1424418:
# check bounds on vector index
    movl -4(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1424420
    cmp  $0,%eax
    jge _L_1424419
_L_1424420:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1424419:
    movl %eax, -8(%esp)
# emit-expr (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f195979 0))
# cons arg1=((primitive-ref string->symbol) "boolean?") arg2=(vector-ref f195979 0)
# emit-expr ((primitive-ref string->symbol) "boolean?")
# funcall
#    si   =-12
#    env  = ((f195979 . 0))
#    expr = (funcall (primitive-ref string->symbol) "boolean?")
# emit-expr (primitive-ref string->symbol)
    .extern mrc_string$m$gsymbol
    movl mrc_string$m$gsymbol,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1424421"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1424421":
   movl %eax,  -20(%esp)  # stash funcall-oper in closure slot
# emit-expr "boolean?"
# string literal
    jmp _L_1424423
    .align 8,0x90
_L_1424422 :
    .int 32
    .ascii "boolean?"
_L_1424423:
    movl $_L_1424422, %eax
    orl $6, %eax
    mov %eax, -24(%esp)  # arg boolean?
    movl -20(%esp), %edi   # load new closure to %edi
    add $-12, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $12, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    movl %eax, -12(%esp)
# emit-expr (vector-ref f195979 0)
# emit-expr f195979
# emit-variable-ref
# env=((f195979 . 0))
# var=f195979
    movl 0(%esp), %eax  # stack load f195979
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1424424
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1424424:
    movl %eax, -16(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1424425"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1424425:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1424427
    cmp  $0,%eax
    jge _L_1424426
_L_1424427:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1424426:
    movl -16(%esp), %esi
    movl -1(%eax,%esi), %eax
    movl %eax, 4(%ebp)
    movl -12(%esp), %eax
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    or   $1, %al
    add  $8, %ebp
# cons end
    movl -4(%esp), %ebx
    movl -8(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f195979 0))) (closure () (f195979) (let () (vector-ref f195979 0))))
# emit-begin
#   expr=(begin (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f195979 0))) (closure () (f195979) (let () (vector-ref f195979 0))))
#   env=((f195979 . 0))
# emit-expr (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f195979 0)))
# emit-expr f195979
# emit-variable-ref
# env=((f195979 . 0))
# var=f195979
    movl 0(%esp), %eax  # stack load f195979
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1424428
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1424428:
    movl %eax, -4(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1424429"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1424429:
# check bounds on vector index
    movl -4(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1424431
    cmp  $0,%eax
    jge _L_1424430
_L_1424431:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1424430:
    movl %eax, -8(%esp)
# emit-expr (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f195979 0))
# cons arg1=((primitive-ref string->symbol) "fixnum?") arg2=(vector-ref f195979 0)
# emit-expr ((primitive-ref string->symbol) "fixnum?")
# funcall
#    si   =-12
#    env  = ((f195979 . 0))
#    expr = (funcall (primitive-ref string->symbol) "fixnum?")
# emit-expr (primitive-ref string->symbol)
    .extern mrc_string$m$gsymbol
    movl mrc_string$m$gsymbol,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1424432"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1424432":
   movl %eax,  -20(%esp)  # stash funcall-oper in closure slot
# emit-expr "fixnum?"
# string literal
    jmp _L_1424434
    .align 8,0x90
_L_1424433 :
    .int 28
    .ascii "fixnum?"
_L_1424434:
    movl $_L_1424433, %eax
    orl $6, %eax
    mov %eax, -24(%esp)  # arg fixnum?
    movl -20(%esp), %edi   # load new closure to %edi
    add $-12, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $12, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    movl %eax, -12(%esp)
# emit-expr (vector-ref f195979 0)
# emit-expr f195979
# emit-variable-ref
# env=((f195979 . 0))
# var=f195979
    movl 0(%esp), %eax  # stack load f195979
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1424435
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1424435:
    movl %eax, -16(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1424436"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1424436:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1424438
    cmp  $0,%eax
    jge _L_1424437
_L_1424438:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1424437:
    movl -16(%esp), %esi
    movl -1(%eax,%esi), %eax
    movl %eax, 4(%ebp)
    movl -12(%esp), %eax
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    or   $1, %al
    add  $8, %ebp
# cons end
    movl -4(%esp), %ebx
    movl -8(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f195979 0))) (closure () (f195979) (let () (vector-ref f195979 0))))
# emit-begin
#   expr=(begin (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f195979 0))) (closure () (f195979) (let () (vector-ref f195979 0))))
#   env=((f195979 . 0))
# emit-expr (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f195979 0)))
# emit-expr f195979
# emit-variable-ref
# env=((f195979 . 0))
# var=f195979
    movl 0(%esp), %eax  # stack load f195979
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1424439
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1424439:
    movl %eax, -4(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1424440"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1424440:
# check bounds on vector index
    movl -4(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1424442
    cmp  $0,%eax
    jge _L_1424441
_L_1424442:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1424441:
    movl %eax, -8(%esp)
# emit-expr (cons ((primitive-ref string->symbol) "char?") (vector-ref f195979 0))
# cons arg1=((primitive-ref string->symbol) "char?") arg2=(vector-ref f195979 0)
# emit-expr ((primitive-ref string->symbol) "char?")
# funcall
#    si   =-12
#    env  = ((f195979 . 0))
#    expr = (funcall (primitive-ref string->symbol) "char?")
# emit-expr (primitive-ref string->symbol)
    .extern mrc_string$m$gsymbol
    movl mrc_string$m$gsymbol,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1424443"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1424443":
   movl %eax,  -20(%esp)  # stash funcall-oper in closure slot
# emit-expr "char?"
# string literal
    jmp _L_1424445
    .align 8,0x90
_L_1424444 :
    .int 20
    .ascii "char?"
_L_1424445:
    movl $_L_1424444, %eax
    orl $6, %eax
    mov %eax, -24(%esp)  # arg char?
    movl -20(%esp), %edi   # load new closure to %edi
    add $-12, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $12, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    movl %eax, -12(%esp)
# emit-expr (vector-ref f195979 0)
# emit-expr f195979
# emit-variable-ref
# env=((f195979 . 0))
# var=f195979
    movl 0(%esp), %eax  # stack load f195979
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1424446
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1424446:
    movl %eax, -16(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1424447"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1424447:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1424449
    cmp  $0,%eax
    jge _L_1424448
_L_1424449:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1424448:
    movl -16(%esp), %esi
    movl -1(%eax,%esi), %eax
    movl %eax, 4(%ebp)
    movl -12(%esp), %eax
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    or   $1, %al
    add  $8, %ebp
# cons end
    movl -4(%esp), %ebx
    movl -8(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f195979 0))) (closure () (f195979) (let () (vector-ref f195979 0))))
# emit-begin
#   expr=(begin (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f195979 0))) (closure () (f195979) (let () (vector-ref f195979 0))))
#   env=((f195979 . 0))
# emit-expr (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f195979 0)))
# emit-expr f195979
# emit-variable-ref
# env=((f195979 . 0))
# var=f195979
    movl 0(%esp), %eax  # stack load f195979
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1424450
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1424450:
    movl %eax, -4(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1424451"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1424451:
# check bounds on vector index
    movl -4(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1424453
    cmp  $0,%eax
    jge _L_1424452
_L_1424453:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1424452:
    movl %eax, -8(%esp)
# emit-expr (cons ((primitive-ref string->symbol) "null?") (vector-ref f195979 0))
# cons arg1=((primitive-ref string->symbol) "null?") arg2=(vector-ref f195979 0)
# emit-expr ((primitive-ref string->symbol) "null?")
# funcall
#    si   =-12
#    env  = ((f195979 . 0))
#    expr = (funcall (primitive-ref string->symbol) "null?")
# emit-expr (primitive-ref string->symbol)
    .extern mrc_string$m$gsymbol
    movl mrc_string$m$gsymbol,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1424454"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1424454":
   movl %eax,  -20(%esp)  # stash funcall-oper in closure slot
# emit-expr "null?"
# string literal
    jmp _L_1424456
    .align 8,0x90
_L_1424455 :
    .int 20
    .ascii "null?"
_L_1424456:
    movl $_L_1424455, %eax
    orl $6, %eax
    mov %eax, -24(%esp)  # arg null?
    movl -20(%esp), %edi   # load new closure to %edi
    add $-12, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $12, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    movl %eax, -12(%esp)
# emit-expr (vector-ref f195979 0)
# emit-expr f195979
# emit-variable-ref
# env=((f195979 . 0))
# var=f195979
    movl 0(%esp), %eax  # stack load f195979
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1424457
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1424457:
    movl %eax, -16(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1424458"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1424458:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1424460
    cmp  $0,%eax
    jge _L_1424459
_L_1424460:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1424459:
    movl -16(%esp), %esi
    movl -1(%eax,%esi), %eax
    movl %eax, 4(%ebp)
    movl -12(%esp), %eax
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    or   $1, %al
    add  $8, %ebp
# cons end
    movl -4(%esp), %ebx
    movl -8(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f195979 0))) (closure () (f195979) (let () (vector-ref f195979 0))))
# emit-begin
#   expr=(begin (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f195979 0))) (closure () (f195979) (let () (vector-ref f195979 0))))
#   env=((f195979 . 0))
# emit-expr (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f195979 0)))
# emit-expr f195979
# emit-variable-ref
# env=((f195979 . 0))
# var=f195979
    movl 0(%esp), %eax  # stack load f195979
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1424461
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1424461:
    movl %eax, -4(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1424462"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1424462:
# check bounds on vector index
    movl -4(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1424464
    cmp  $0,%eax
    jge _L_1424463
_L_1424464:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1424463:
    movl %eax, -8(%esp)
# emit-expr (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f195979 0))
# cons arg1=((primitive-ref string->symbol) "char->fixnum") arg2=(vector-ref f195979 0)
# emit-expr ((primitive-ref string->symbol) "char->fixnum")
# funcall
#    si   =-12
#    env  = ((f195979 . 0))
#    expr = (funcall (primitive-ref string->symbol) "char->fixnum")
# emit-expr (primitive-ref string->symbol)
    .extern mrc_string$m$gsymbol
    movl mrc_string$m$gsymbol,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1424465"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1424465":
   movl %eax,  -20(%esp)  # stash funcall-oper in closure slot
# emit-expr "char->fixnum"
# string literal
    jmp _L_1424467
    .align 8,0x90
_L_1424466 :
    .int 48
    .ascii "char->fixnum"
_L_1424467:
    movl $_L_1424466, %eax
    orl $6, %eax
    mov %eax, -24(%esp)  # arg char->fixnum
    movl -20(%esp), %edi   # load new closure to %edi
    add $-12, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $12, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    movl %eax, -12(%esp)
# emit-expr (vector-ref f195979 0)
# emit-expr f195979
# emit-variable-ref
# env=((f195979 . 0))
# var=f195979
    movl 0(%esp), %eax  # stack load f195979
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1424468
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1424468:
    movl %eax, -16(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1424469"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1424469:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1424471
    cmp  $0,%eax
    jge _L_1424470
_L_1424471:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1424470:
    movl -16(%esp), %esi
    movl -1(%eax,%esi), %eax
    movl %eax, 4(%ebp)
    movl -12(%esp), %eax
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    or   $1, %al
    add  $8, %ebp
# cons end
    movl -4(%esp), %ebx
    movl -8(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f195979 0))) (closure () (f195979) (let () (vector-ref f195979 0))))
# emit-begin
#   expr=(begin (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f195979 0))) (closure () (f195979) (let () (vector-ref f195979 0))))
#   env=((f195979 . 0))
# emit-expr (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f195979 0)))
# emit-expr f195979
# emit-variable-ref
# env=((f195979 . 0))
# var=f195979
    movl 0(%esp), %eax  # stack load f195979
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1424472
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1424472:
    movl %eax, -4(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1424473"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1424473:
# check bounds on vector index
    movl -4(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1424475
    cmp  $0,%eax
    jge _L_1424474
_L_1424475:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1424474:
    movl %eax, -8(%esp)
# emit-expr (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f195979 0))
# cons arg1=((primitive-ref string->symbol) "fixnum->char") arg2=(vector-ref f195979 0)
# emit-expr ((primitive-ref string->symbol) "fixnum->char")
# funcall
#    si   =-12
#    env  = ((f195979 . 0))
#    expr = (funcall (primitive-ref string->symbol) "fixnum->char")
# emit-expr (primitive-ref string->symbol)
    .extern mrc_string$m$gsymbol
    movl mrc_string$m$gsymbol,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1424476"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1424476":
   movl %eax,  -20(%esp)  # stash funcall-oper in closure slot
# emit-expr "fixnum->char"
# string literal
    jmp _L_1424478
    .align 8,0x90
_L_1424477 :
    .int 48
    .ascii "fixnum->char"
_L_1424478:
    movl $_L_1424477, %eax
    orl $6, %eax
    mov %eax, -24(%esp)  # arg fixnum->char
    movl -20(%esp), %edi   # load new closure to %edi
    add $-12, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $12, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    movl %eax, -12(%esp)
# emit-expr (vector-ref f195979 0)
# emit-expr f195979
# emit-variable-ref
# env=((f195979 . 0))
# var=f195979
    movl 0(%esp), %eax  # stack load f195979
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1424479
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1424479:
    movl %eax, -16(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1424480"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1424480:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1424482
    cmp  $0,%eax
    jge _L_1424481
_L_1424482:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1424481:
    movl -16(%esp), %esi
    movl -1(%eax,%esi), %eax
    movl %eax, 4(%ebp)
    movl -12(%esp), %eax
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    or   $1, %al
    add  $8, %ebp
# cons end
    movl -4(%esp), %ebx
    movl -8(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin (closure () (f195979) (let () (vector-ref f195979 0))))
# emit-begin
#   expr=(begin (closure () (f195979) (let () (vector-ref f195979 0))))
#   env=((f195979 . 0))
# emit-expr (closure () (f195979) (let () (vector-ref f195979 0)))
# emit-closure
# si = -4
# env = ((f195979 . 0))
# expr = (closure () (f195979) (let () (vector-ref f195979 0)))
    movl $_L_1424483, 0(%ebp)  # closure label
# emit-variable-ref
# env=((f195979 . 0))
# var=f195979
    movl 0(%esp), %eax  # stack load f195979
# end emit-variable-ref
   movl  %eax, 4(%ebp)  # f195979
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $8, %ebp     # bump ebp
    jmp _L_1424484            # jump around closure body
_L_1424483:
# check argument count
    cmp $0,%eax
    je _L_1424485
# invoke error handler eh_argcount
    .extern mrc_eh$uargcount
    movl mrc_eh$uargcount, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_1424485:
# emit-tail-expr
# si=-8
# env=((f195979 . 4) (f195979 . 0))
# expr=(let () (vector-ref f195979 0))
# emit-tail-let
#  si   = -8
#  env  = ((f195979 . 4) (f195979 . 0))
#  bindings = ()
#  body = (vector-ref f195979 0)
# emit-tail-expr
# si=-8
# env=((f195979 . 4) (f195979 . 0))
# expr=(vector-ref f195979 0)
# tail primcall
# emit-expr f195979
# emit-variable-ref
# env=((f195979 . 4) (f195979 . 0))
# var=f195979
    movl 2(%edi), %eax  # frame load f195979
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1424486
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1424486:
    movl %eax, -8(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1424487"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1424487:
# check bounds on vector index
    movl -8(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1424489
    cmp  $0,%eax
    jge _L_1424488
_L_1424489:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1424488:
    movl -8(%esp), %esi
    movl -1(%eax,%esi), %eax
#return from tail (vector-ref f195979 0)
    ret
    .align 4,0x90
_L_1424484:
# emit-expr (begin)
# emit-begin
#   expr=(begin)
#   env=((f195979 . 0))
     movl %eax, mrc_primitives
# == explicit-begins  ==>
# (lambda () (error (quote funcall) "arg 1 must be a procedure"))
# == eliminate-let*  ==>
# (lambda () (error (quote funcall) "arg 1 must be a procedure"))
# == uniquify-variables  ==>
# (lambda () (error (quote funcall) "arg 1 must be a procedure"))
# == vectorize-letrec  ==>
# (lambda () (error (quote funcall) "arg 1 must be a procedure"))
# == eliminate-set!  ==>
# (lambda () (let () (error (quote funcall) "arg 1 must be a procedure")))
# == close-free-variables  ==>
# (closure () (error funcall) (let () (error (quote funcall) "arg 1 must be a procedure")))
# == eliminate-quote  ==>
# (closure () (error funcall) (let () (error (string->symbol "funcall") "arg 1 must be a procedure")))
# == eliminate-when/unless  ==>
# (closure () (error funcall) (let () (error (string->symbol "funcall") "arg 1 must be a procedure")))
# == eliminate-cond  ==>
# (closure () (error funcall) (let () (error (string->symbol "funcall") "arg 1 must be a procedure")))
# == external-symbols  ==>
# (closure () ((primitive-ref error) funcall) (let () ((primitive-ref error) ((primitive-ref string->symbol) "funcall") "arg 1 must be a procedure")))
# emit-expr (closure () ((primitive-ref error) funcall) (let () ((primitive-ref error) ((primitive-ref string->symbol) "funcall") "arg 1 must be a procedure")))
# emit-closure
# si = 0
# env = ()
# expr = (closure () ((primitive-ref error) funcall) (let () ((primitive-ref error) ((primitive-ref string->symbol) "funcall") "arg 1 must be a procedure")))
    movl $_L_1424490, 0(%ebp)  # closure label
# WARNING: free var (primitive-ref error) not defined in the environmnet
# WARNING: free var funcall not defined in the environmnet
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $16, %ebp     # bump ebp
    jmp _L_1424491            # jump around closure body
_L_1424490:
# check argument count
    cmp $0,%eax
    je _L_1424492
# invoke error handler eh_argcount
    .extern mrc_eh$uargcount
    movl mrc_eh$uargcount, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_1424492:
# emit-tail-expr
# si=-8
# env=((funcall . 8) ((primitive-ref error) . 4))
# expr=(let () ((primitive-ref error) ((primitive-ref string->symbol) "funcall") "arg 1 must be a procedure"))
# emit-tail-let
#  si   = -8
#  env  = ((funcall . 8) ((primitive-ref error) . 4))
#  bindings = ()
#  body = ((primitive-ref error) ((primitive-ref string->symbol) "funcall") "arg 1 must be a procedure")
# emit-tail-expr
# si=-8
# env=((funcall . 8) ((primitive-ref error) . 4))
# expr=((primitive-ref error) ((primitive-ref string->symbol) "funcall") "arg 1 must be a procedure")
# emit-tail-funcall
#    si   =-8
#    env  = ((funcall . 8) ((primitive-ref error) . 4))
#    expr = (funcall (primitive-ref error) ((primitive-ref string->symbol) "funcall") "arg 1 must be a procedure")
# emit-expr (primitive-ref error)
    .extern mrc_error
    movl mrc_error,%eax
   movl %eax,  -8(%esp)  # stash funcall-oper in next closure slot
# emit-expr ((primitive-ref string->symbol) "funcall")
# funcall
#    si   =-12
#    env  = ((funcall . 8) ((primitive-ref error) . 4))
#    expr = (funcall (primitive-ref string->symbol) "funcall")
# emit-expr (primitive-ref string->symbol)
    .extern mrc_string$m$gsymbol
    movl mrc_string$m$gsymbol,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1424493"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1424493":
   movl %eax,  -20(%esp)  # stash funcall-oper in closure slot
# emit-expr "funcall"
# string literal
    jmp _L_1424495
    .align 8,0x90
_L_1424494 :
    .int 28
    .ascii "funcall"
_L_1424495:
    movl $_L_1424494, %eax
    orl $6, %eax
    mov %eax, -24(%esp)  # arg funcall
    movl -20(%esp), %edi   # load new closure to %edi
    add $-12, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $12, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    mov %eax, -12(%esp)    # arg ((primitive-ref string->symbol) funcall)
# emit-expr "arg 1 must be a procedure"
# string literal
    jmp _L_1424497
    .align 8,0x90
_L_1424496 :
    .int 100
    .ascii "arg 1 must be a procedure"
_L_1424497:
    movl $_L_1424496, %eax
    orl $6, %eax
    mov %eax, -16(%esp)    # arg arg 1 must be a procedure
    movl -8(%esp), %edi   # load new closure to %edi
# emit-shift-args:  size=3   si=-8  delta=4
    mov -8(%esp), %ebx  # shift frame cell
    mov %ebx, -4(%esp)  # down to base
# emit-shift-args:  size=2   si=-12  delta=4
    mov -12(%esp), %ebx  # shift frame cell
    mov %ebx, -8(%esp)  # down to base
# emit-shift-args:  size=1   si=-16  delta=4
    mov -16(%esp), %ebx  # shift frame cell
    mov %ebx, -12(%esp)  # down to base
# emit-shift-args:  size=0   si=-20  delta=4
    movl $8,%eax   # save arg count
    jmp *-2(%edi)  # tail-funcall
    .align 4,0x90
_L_1424491:
     movl %eax, mrc_eh$uprocedure
# == explicit-begins  ==>
# (lambda () (error (quote funcall) "wrong number of args"))
# == eliminate-let*  ==>
# (lambda () (error (quote funcall) "wrong number of args"))
# == uniquify-variables  ==>
# (lambda () (error (quote funcall) "wrong number of args"))
# == vectorize-letrec  ==>
# (lambda () (error (quote funcall) "wrong number of args"))
# == eliminate-set!  ==>
# (lambda () (let () (error (quote funcall) "wrong number of args")))
# == close-free-variables  ==>
# (closure () (error funcall) (let () (error (quote funcall) "wrong number of args")))
# == eliminate-quote  ==>
# (closure () (error funcall) (let () (error (string->symbol "funcall") "wrong number of args")))
# == eliminate-when/unless  ==>
# (closure () (error funcall) (let () (error (string->symbol "funcall") "wrong number of args")))
# == eliminate-cond  ==>
# (closure () (error funcall) (let () (error (string->symbol "funcall") "wrong number of args")))
# == external-symbols  ==>
# (closure () ((primitive-ref error) funcall) (let () ((primitive-ref error) ((primitive-ref string->symbol) "funcall") "wrong number of args")))
# emit-expr (closure () ((primitive-ref error) funcall) (let () ((primitive-ref error) ((primitive-ref string->symbol) "funcall") "wrong number of args")))
# emit-closure
# si = 0
# env = ()
# expr = (closure () ((primitive-ref error) funcall) (let () ((primitive-ref error) ((primitive-ref string->symbol) "funcall") "wrong number of args")))
    movl $_L_1424498, 0(%ebp)  # closure label
# WARNING: free var (primitive-ref error) not defined in the environmnet
# WARNING: free var funcall not defined in the environmnet
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $16, %ebp     # bump ebp
    jmp _L_1424499            # jump around closure body
_L_1424498:
# check argument count
    cmp $0,%eax
    je _L_1424500
# invoke error handler eh_argcount
    .extern mrc_eh$uargcount
    movl mrc_eh$uargcount, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_1424500:
# emit-tail-expr
# si=-8
# env=((funcall . 8) ((primitive-ref error) . 4))
# expr=(let () ((primitive-ref error) ((primitive-ref string->symbol) "funcall") "wrong number of args"))
# emit-tail-let
#  si   = -8
#  env  = ((funcall . 8) ((primitive-ref error) . 4))
#  bindings = ()
#  body = ((primitive-ref error) ((primitive-ref string->symbol) "funcall") "wrong number of args")
# emit-tail-expr
# si=-8
# env=((funcall . 8) ((primitive-ref error) . 4))
# expr=((primitive-ref error) ((primitive-ref string->symbol) "funcall") "wrong number of args")
# emit-tail-funcall
#    si   =-8
#    env  = ((funcall . 8) ((primitive-ref error) . 4))
#    expr = (funcall (primitive-ref error) ((primitive-ref string->symbol) "funcall") "wrong number of args")
# emit-expr (primitive-ref error)
    .extern mrc_error
    movl mrc_error,%eax
   movl %eax,  -8(%esp)  # stash funcall-oper in next closure slot
# emit-expr ((primitive-ref string->symbol) "funcall")
# funcall
#    si   =-12
#    env  = ((funcall . 8) ((primitive-ref error) . 4))
#    expr = (funcall (primitive-ref string->symbol) "funcall")
# emit-expr (primitive-ref string->symbol)
    .extern mrc_string$m$gsymbol
    movl mrc_string$m$gsymbol,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1424501"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1424501":
   movl %eax,  -20(%esp)  # stash funcall-oper in closure slot
# emit-expr "funcall"
# string literal
    jmp _L_1424503
    .align 8,0x90
_L_1424502 :
    .int 28
    .ascii "funcall"
_L_1424503:
    movl $_L_1424502, %eax
    orl $6, %eax
    mov %eax, -24(%esp)  # arg funcall
    movl -20(%esp), %edi   # load new closure to %edi
    add $-12, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $12, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    mov %eax, -12(%esp)    # arg ((primitive-ref string->symbol) funcall)
# emit-expr "wrong number of args"
# string literal
    jmp _L_1424505
    .align 8,0x90
_L_1424504 :
    .int 80
    .ascii "wrong number of args"
_L_1424505:
    movl $_L_1424504, %eax
    orl $6, %eax
    mov %eax, -16(%esp)    # arg wrong number of args
    movl -8(%esp), %edi   # load new closure to %edi
# emit-shift-args:  size=3   si=-8  delta=4
    mov -8(%esp), %ebx  # shift frame cell
    mov %ebx, -4(%esp)  # down to base
# emit-shift-args:  size=2   si=-12  delta=4
    mov -12(%esp), %ebx  # shift frame cell
    mov %ebx, -8(%esp)  # down to base
# emit-shift-args:  size=1   si=-16  delta=4
    mov -16(%esp), %ebx  # shift frame cell
    mov %ebx, -12(%esp)  # down to base
# emit-shift-args:  size=0   si=-20  delta=4
    movl $8,%eax   # save arg count
    jmp *-2(%edi)  # tail-funcall
    .align 4,0x90
_L_1424499:
     movl %eax, mrc_eh$uargcount
# == explicit-begins  ==>
# (lambda () (error (quote funcall) "too few args"))
# == eliminate-let*  ==>
# (lambda () (error (quote funcall) "too few args"))
# == uniquify-variables  ==>
# (lambda () (error (quote funcall) "too few args"))
# == vectorize-letrec  ==>
# (lambda () (error (quote funcall) "too few args"))
# == eliminate-set!  ==>
# (lambda () (let () (error (quote funcall) "too few args")))
# == close-free-variables  ==>
# (closure () (error funcall) (let () (error (quote funcall) "too few args")))
# == eliminate-quote  ==>
# (closure () (error funcall) (let () (error (string->symbol "funcall") "too few args")))
# == eliminate-when/unless  ==>
# (closure () (error funcall) (let () (error (string->symbol "funcall") "too few args")))
# == eliminate-cond  ==>
# (closure () (error funcall) (let () (error (string->symbol "funcall") "too few args")))
# == external-symbols  ==>
# (closure () ((primitive-ref error) funcall) (let () ((primitive-ref error) ((primitive-ref string->symbol) "funcall") "too few args")))
# emit-expr (closure () ((primitive-ref error) funcall) (let () ((primitive-ref error) ((primitive-ref string->symbol) "funcall") "too few args")))
# emit-closure
# si = 0
# env = ()
# expr = (closure () ((primitive-ref error) funcall) (let () ((primitive-ref error) ((primitive-ref string->symbol) "funcall") "too few args")))
    movl $_L_1424506, 0(%ebp)  # closure label
# WARNING: free var (primitive-ref error) not defined in the environmnet
# WARNING: free var funcall not defined in the environmnet
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $16, %ebp     # bump ebp
    jmp _L_1424507            # jump around closure body
_L_1424506:
# check argument count
    cmp $0,%eax
    je _L_1424508
# invoke error handler eh_argcount
    .extern mrc_eh$uargcount
    movl mrc_eh$uargcount, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_1424508:
# emit-tail-expr
# si=-8
# env=((funcall . 8) ((primitive-ref error) . 4))
# expr=(let () ((primitive-ref error) ((primitive-ref string->symbol) "funcall") "too few args"))
# emit-tail-let
#  si   = -8
#  env  = ((funcall . 8) ((primitive-ref error) . 4))
#  bindings = ()
#  body = ((primitive-ref error) ((primitive-ref string->symbol) "funcall") "too few args")
# emit-tail-expr
# si=-8
# env=((funcall . 8) ((primitive-ref error) . 4))
# expr=((primitive-ref error) ((primitive-ref string->symbol) "funcall") "too few args")
# emit-tail-funcall
#    si   =-8
#    env  = ((funcall . 8) ((primitive-ref error) . 4))
#    expr = (funcall (primitive-ref error) ((primitive-ref string->symbol) "funcall") "too few args")
# emit-expr (primitive-ref error)
    .extern mrc_error
    movl mrc_error,%eax
   movl %eax,  -8(%esp)  # stash funcall-oper in next closure slot
# emit-expr ((primitive-ref string->symbol) "funcall")
# funcall
#    si   =-12
#    env  = ((funcall . 8) ((primitive-ref error) . 4))
#    expr = (funcall (primitive-ref string->symbol) "funcall")
# emit-expr (primitive-ref string->symbol)
    .extern mrc_string$m$gsymbol
    movl mrc_string$m$gsymbol,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1424509"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1424509":
   movl %eax,  -20(%esp)  # stash funcall-oper in closure slot
# emit-expr "funcall"
# string literal
    jmp _L_1424511
    .align 8,0x90
_L_1424510 :
    .int 28
    .ascii "funcall"
_L_1424511:
    movl $_L_1424510, %eax
    orl $6, %eax
    mov %eax, -24(%esp)  # arg funcall
    movl -20(%esp), %edi   # load new closure to %edi
    add $-12, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $12, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    mov %eax, -12(%esp)    # arg ((primitive-ref string->symbol) funcall)
# emit-expr "too few args"
# string literal
    jmp _L_1424513
    .align 8,0x90
_L_1424512 :
    .int 48
    .ascii "too few args"
_L_1424513:
    movl $_L_1424512, %eax
    orl $6, %eax
    mov %eax, -16(%esp)    # arg too few args
    movl -8(%esp), %edi   # load new closure to %edi
# emit-shift-args:  size=3   si=-8  delta=4
    mov -8(%esp), %ebx  # shift frame cell
    mov %ebx, -4(%esp)  # down to base
# emit-shift-args:  size=2   si=-12  delta=4
    mov -12(%esp), %ebx  # shift frame cell
    mov %ebx, -8(%esp)  # down to base
# emit-shift-args:  size=1   si=-16  delta=4
    mov -16(%esp), %ebx  # shift frame cell
    mov %ebx, -12(%esp)  # down to base
# emit-shift-args:  size=0   si=-20  delta=4
    movl $8,%eax   # save arg count
    jmp *-2(%edi)  # tail-funcall
    .align 4,0x90
_L_1424507:
     movl %eax, mrc_eh$uargcount$umin
# == explicit-begins  ==>
# (lambda (i) (error (list-ref (primitives) i) "arg must be a fixnum"))
# == eliminate-let*  ==>
# (lambda (i) (error (list-ref (primitives) i) "arg must be a fixnum"))
# == uniquify-variables  ==>
# (lambda (f195980) (error (list-ref (primitives) f195980) "arg must be a fixnum"))
# == vectorize-letrec  ==>
# (lambda (f195980) (error (list-ref (primitives) f195980) "arg must be a fixnum"))
# == eliminate-set!  ==>
# (lambda (f195980) (let ((f195980 f195980)) (error (list-ref (primitives) f195980) "arg must be a fixnum")))
# == close-free-variables  ==>
# (closure (f195980) (error list-ref primitives) (let ((f195980 f195980)) (error (list-ref (primitives) f195980) "arg must be a fixnum")))
# == eliminate-quote  ==>
# (closure (f195980) (error list-ref primitives) (let ((f195980 f195980)) (error (list-ref (primitives) f195980) "arg must be a fixnum")))
# == eliminate-when/unless  ==>
# (closure (f195980) (error list-ref primitives) (let ((f195980 f195980)) (error (list-ref (primitives) f195980) "arg must be a fixnum")))
# == eliminate-cond  ==>
# (closure (f195980) (error list-ref primitives) (let ((f195980 f195980)) (error (list-ref (primitives) f195980) "arg must be a fixnum")))
# == external-symbols  ==>
# (closure (f195980) ((primitive-ref error) (primitive-ref list-ref) (primitive-ref primitives)) (let ((f195980 f195980)) ((primitive-ref error) ((primitive-ref list-ref) ((primitive-ref primitives)) f195980) "arg must be a fixnum")))
# emit-expr (closure (f195980) ((primitive-ref error) (primitive-ref list-ref) (primitive-ref primitives)) (let ((f195980 f195980)) ((primitive-ref error) ((primitive-ref list-ref) ((primitive-ref primitives)) f195980) "arg must be a fixnum")))
# emit-closure
# si = 0
# env = ()
# expr = (closure (f195980) ((primitive-ref error) (primitive-ref list-ref) (primitive-ref primitives)) (let ((f195980 f195980)) ((primitive-ref error) ((primitive-ref list-ref) ((primitive-ref primitives)) f195980) "arg must be a fixnum")))
    movl $_L_1424514, 0(%ebp)  # closure label
# WARNING: free var (primitive-ref error) not defined in the environmnet
# WARNING: free var (primitive-ref list-ref) not defined in the environmnet
# WARNING: free var (primitive-ref primitives) not defined in the environmnet
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $16, %ebp     # bump ebp
    jmp _L_1424515            # jump around closure body
_L_1424514:
# check argument count
    cmp $4,%eax
    je _L_1424516
# invoke error handler eh_argcount
    .extern mrc_eh$uargcount
    movl mrc_eh$uargcount, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_1424516:
# emit-tail-expr
# si=-12
# env=((f195980 . -8) ((primitive-ref primitives) . 12) ((primitive-ref list-ref) . 8) ((primitive-ref error) . 4))
# expr=(let ((f195980 f195980)) ((primitive-ref error) ((primitive-ref list-ref) ((primitive-ref primitives)) f195980) "arg must be a fixnum"))
# emit-tail-let
#  si   = -12
#  env  = ((f195980 . -8) ((primitive-ref primitives) . 12) ((primitive-ref list-ref) . 8) ((primitive-ref error) . 4))
#  bindings = ((f195980 f195980))
#  body = ((primitive-ref error) ((primitive-ref list-ref) ((primitive-ref primitives)) f195980) "arg must be a fixnum")
# emit-expr f195980
# emit-variable-ref
# env=((f195980 . -8) ((primitive-ref primitives) . 12) ((primitive-ref list-ref) . 8) ((primitive-ref error) . 4))
# var=f195980
    movl -8(%esp), %eax  # stack load f195980
# end emit-variable-ref
    movl %eax, -12(%esp)  # stack save
# emit-tail-expr
# si=-16
# env=((f195980 . -12) (f195980 . -8) ((primitive-ref primitives) . 12) ((primitive-ref list-ref) . 8) ((primitive-ref error) . 4))
# expr=((primitive-ref error) ((primitive-ref list-ref) ((primitive-ref primitives)) f195980) "arg must be a fixnum")
# emit-tail-funcall
#    si   =-16
#    env  = ((f195980 . -12) (f195980 . -8) ((primitive-ref primitives) . 12) ((primitive-ref list-ref) . 8) ((primitive-ref error) . 4))
#    expr = (funcall (primitive-ref error) ((primitive-ref list-ref) ((primitive-ref primitives)) f195980) "arg must be a fixnum")
# emit-expr (primitive-ref error)
    .extern mrc_error
    movl mrc_error,%eax
   movl %eax,  -16(%esp)  # stash funcall-oper in next closure slot
# emit-expr ((primitive-ref list-ref) ((primitive-ref primitives)) f195980)
# funcall
#    si   =-20
#    env  = ((f195980 . -12) (f195980 . -8) ((primitive-ref primitives) . 12) ((primitive-ref list-ref) . 8) ((primitive-ref error) . 4))
#    expr = (funcall (primitive-ref list-ref) ((primitive-ref primitives)) f195980)
# emit-expr (primitive-ref list-ref)
    .extern mrc_list$mref
    movl mrc_list$mref,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1424517"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1424517":
   movl %eax,  -28(%esp)  # stash funcall-oper in closure slot
# emit-expr ((primitive-ref primitives))
# funcall
#    si   =-32
#    env  = ((f195980 . -12) (f195980 . -8) ((primitive-ref primitives) . 12) ((primitive-ref list-ref) . 8) ((primitive-ref error) . 4))
#    expr = (funcall (primitive-ref primitives))
# emit-expr (primitive-ref primitives)
    .extern mrc_primitives
    movl mrc_primitives,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1424518"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1424518":
   movl %eax,  -40(%esp)  # stash funcall-oper in closure slot
    movl -40(%esp), %edi   # load new closure to %edi
    add $-32, %esp   # adjust base
    movl $0,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $32, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    mov %eax, -32(%esp)  # arg ((primitive-ref primitives))
# emit-expr f195980
# emit-variable-ref
# env=((f195980 . -12) (f195980 . -8) ((primitive-ref primitives) . 12) ((primitive-ref list-ref) . 8) ((primitive-ref error) . 4))
# var=f195980
    movl -12(%esp), %eax  # stack load f195980
# end emit-variable-ref
    mov %eax, -36(%esp)  # arg f195980
    movl -28(%esp), %edi   # load new closure to %edi
    add $-20, %esp   # adjust base
    movl $8,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $20, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    mov %eax, -20(%esp)    # arg ((primitive-ref list-ref) ((primitive-ref primitives)) f195980)
# emit-expr "arg must be a fixnum"
# string literal
    jmp _L_1424520
    .align 8,0x90
_L_1424519 :
    .int 80
    .ascii "arg must be a fixnum"
_L_1424520:
    movl $_L_1424519, %eax
    orl $6, %eax
    mov %eax, -24(%esp)    # arg arg must be a fixnum
    movl -16(%esp), %edi   # load new closure to %edi
# emit-shift-args:  size=3   si=-16  delta=12
    mov -16(%esp), %ebx  # shift frame cell
    mov %ebx, -4(%esp)  # down to base
# emit-shift-args:  size=2   si=-20  delta=12
    mov -20(%esp), %ebx  # shift frame cell
    mov %ebx, -8(%esp)  # down to base
# emit-shift-args:  size=1   si=-24  delta=12
    mov -24(%esp), %ebx  # shift frame cell
    mov %ebx, -12(%esp)  # down to base
# emit-shift-args:  size=0   si=-28  delta=12
    movl $8,%eax   # save arg count
    jmp *-2(%edi)  # tail-funcall
    .align 4,0x90
_L_1424515:
     movl %eax, mrc_eh$ufixnum
# == explicit-begins  ==>
# (lambda (i) (error (list-ref (primitives) i) "arg must be a string"))
# == eliminate-let*  ==>
# (lambda (i) (error (list-ref (primitives) i) "arg must be a string"))
# == uniquify-variables  ==>
# (lambda (f195981) (error (list-ref (primitives) f195981) "arg must be a string"))
# == vectorize-letrec  ==>
# (lambda (f195981) (error (list-ref (primitives) f195981) "arg must be a string"))
# == eliminate-set!  ==>
# (lambda (f195981) (let ((f195981 f195981)) (error (list-ref (primitives) f195981) "arg must be a string")))
# == close-free-variables  ==>
# (closure (f195981) (error list-ref primitives) (let ((f195981 f195981)) (error (list-ref (primitives) f195981) "arg must be a string")))
# == eliminate-quote  ==>
# (closure (f195981) (error list-ref primitives) (let ((f195981 f195981)) (error (list-ref (primitives) f195981) "arg must be a string")))
# == eliminate-when/unless  ==>
# (closure (f195981) (error list-ref primitives) (let ((f195981 f195981)) (error (list-ref (primitives) f195981) "arg must be a string")))
# == eliminate-cond  ==>
# (closure (f195981) (error list-ref primitives) (let ((f195981 f195981)) (error (list-ref (primitives) f195981) "arg must be a string")))
# == external-symbols  ==>
# (closure (f195981) ((primitive-ref error) (primitive-ref list-ref) (primitive-ref primitives)) (let ((f195981 f195981)) ((primitive-ref error) ((primitive-ref list-ref) ((primitive-ref primitives)) f195981) "arg must be a string")))
# emit-expr (closure (f195981) ((primitive-ref error) (primitive-ref list-ref) (primitive-ref primitives)) (let ((f195981 f195981)) ((primitive-ref error) ((primitive-ref list-ref) ((primitive-ref primitives)) f195981) "arg must be a string")))
# emit-closure
# si = 0
# env = ()
# expr = (closure (f195981) ((primitive-ref error) (primitive-ref list-ref) (primitive-ref primitives)) (let ((f195981 f195981)) ((primitive-ref error) ((primitive-ref list-ref) ((primitive-ref primitives)) f195981) "arg must be a string")))
    movl $_L_1424521, 0(%ebp)  # closure label
# WARNING: free var (primitive-ref error) not defined in the environmnet
# WARNING: free var (primitive-ref list-ref) not defined in the environmnet
# WARNING: free var (primitive-ref primitives) not defined in the environmnet
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $16, %ebp     # bump ebp
    jmp _L_1424522            # jump around closure body
_L_1424521:
# check argument count
    cmp $4,%eax
    je _L_1424523
# invoke error handler eh_argcount
    .extern mrc_eh$uargcount
    movl mrc_eh$uargcount, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_1424523:
# emit-tail-expr
# si=-12
# env=((f195981 . -8) ((primitive-ref primitives) . 12) ((primitive-ref list-ref) . 8) ((primitive-ref error) . 4))
# expr=(let ((f195981 f195981)) ((primitive-ref error) ((primitive-ref list-ref) ((primitive-ref primitives)) f195981) "arg must be a string"))
# emit-tail-let
#  si   = -12
#  env  = ((f195981 . -8) ((primitive-ref primitives) . 12) ((primitive-ref list-ref) . 8) ((primitive-ref error) . 4))
#  bindings = ((f195981 f195981))
#  body = ((primitive-ref error) ((primitive-ref list-ref) ((primitive-ref primitives)) f195981) "arg must be a string")
# emit-expr f195981
# emit-variable-ref
# env=((f195981 . -8) ((primitive-ref primitives) . 12) ((primitive-ref list-ref) . 8) ((primitive-ref error) . 4))
# var=f195981
    movl -8(%esp), %eax  # stack load f195981
# end emit-variable-ref
    movl %eax, -12(%esp)  # stack save
# emit-tail-expr
# si=-16
# env=((f195981 . -12) (f195981 . -8) ((primitive-ref primitives) . 12) ((primitive-ref list-ref) . 8) ((primitive-ref error) . 4))
# expr=((primitive-ref error) ((primitive-ref list-ref) ((primitive-ref primitives)) f195981) "arg must be a string")
# emit-tail-funcall
#    si   =-16
#    env  = ((f195981 . -12) (f195981 . -8) ((primitive-ref primitives) . 12) ((primitive-ref list-ref) . 8) ((primitive-ref error) . 4))
#    expr = (funcall (primitive-ref error) ((primitive-ref list-ref) ((primitive-ref primitives)) f195981) "arg must be a string")
# emit-expr (primitive-ref error)
    .extern mrc_error
    movl mrc_error,%eax
   movl %eax,  -16(%esp)  # stash funcall-oper in next closure slot
# emit-expr ((primitive-ref list-ref) ((primitive-ref primitives)) f195981)
# funcall
#    si   =-20
#    env  = ((f195981 . -12) (f195981 . -8) ((primitive-ref primitives) . 12) ((primitive-ref list-ref) . 8) ((primitive-ref error) . 4))
#    expr = (funcall (primitive-ref list-ref) ((primitive-ref primitives)) f195981)
# emit-expr (primitive-ref list-ref)
    .extern mrc_list$mref
    movl mrc_list$mref,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1424524"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1424524":
   movl %eax,  -28(%esp)  # stash funcall-oper in closure slot
# emit-expr ((primitive-ref primitives))
# funcall
#    si   =-32
#    env  = ((f195981 . -12) (f195981 . -8) ((primitive-ref primitives) . 12) ((primitive-ref list-ref) . 8) ((primitive-ref error) . 4))
#    expr = (funcall (primitive-ref primitives))
# emit-expr (primitive-ref primitives)
    .extern mrc_primitives
    movl mrc_primitives,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1424525"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1424525":
   movl %eax,  -40(%esp)  # stash funcall-oper in closure slot
    movl -40(%esp), %edi   # load new closure to %edi
    add $-32, %esp   # adjust base
    movl $0,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $32, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    mov %eax, -32(%esp)  # arg ((primitive-ref primitives))
# emit-expr f195981
# emit-variable-ref
# env=((f195981 . -12) (f195981 . -8) ((primitive-ref primitives) . 12) ((primitive-ref list-ref) . 8) ((primitive-ref error) . 4))
# var=f195981
    movl -12(%esp), %eax  # stack load f195981
# end emit-variable-ref
    mov %eax, -36(%esp)  # arg f195981
    movl -28(%esp), %edi   # load new closure to %edi
    add $-20, %esp   # adjust base
    movl $8,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $20, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    mov %eax, -20(%esp)    # arg ((primitive-ref list-ref) ((primitive-ref primitives)) f195981)
# emit-expr "arg must be a string"
# string literal
    jmp _L_1424527
    .align 8,0x90
_L_1424526 :
    .int 80
    .ascii "arg must be a string"
_L_1424527:
    movl $_L_1424526, %eax
    orl $6, %eax
    mov %eax, -24(%esp)    # arg arg must be a string
    movl -16(%esp), %edi   # load new closure to %edi
# emit-shift-args:  size=3   si=-16  delta=12
    mov -16(%esp), %ebx  # shift frame cell
    mov %ebx, -4(%esp)  # down to base
# emit-shift-args:  size=2   si=-20  delta=12
    mov -20(%esp), %ebx  # shift frame cell
    mov %ebx, -8(%esp)  # down to base
# emit-shift-args:  size=1   si=-24  delta=12
    mov -24(%esp), %ebx  # shift frame cell
    mov %ebx, -12(%esp)  # down to base
# emit-shift-args:  size=0   si=-28  delta=12
    movl $8,%eax   # save arg count
    jmp *-2(%edi)  # tail-funcall
    .align 4,0x90
_L_1424522:
     movl %eax, mrc_eh$ustring
# == explicit-begins  ==>
# (lambda (i) (error (list-ref (primitives) i) "arg must be a character"))
# == eliminate-let*  ==>
# (lambda (i) (error (list-ref (primitives) i) "arg must be a character"))
# == uniquify-variables  ==>
# (lambda (f195982) (error (list-ref (primitives) f195982) "arg must be a character"))
# == vectorize-letrec  ==>
# (lambda (f195982) (error (list-ref (primitives) f195982) "arg must be a character"))
# == eliminate-set!  ==>
# (lambda (f195982) (let ((f195982 f195982)) (error (list-ref (primitives) f195982) "arg must be a character")))
# == close-free-variables  ==>
# (closure (f195982) (error list-ref primitives) (let ((f195982 f195982)) (error (list-ref (primitives) f195982) "arg must be a character")))
# == eliminate-quote  ==>
# (closure (f195982) (error list-ref primitives) (let ((f195982 f195982)) (error (list-ref (primitives) f195982) "arg must be a character")))
# == eliminate-when/unless  ==>
# (closure (f195982) (error list-ref primitives) (let ((f195982 f195982)) (error (list-ref (primitives) f195982) "arg must be a character")))
# == eliminate-cond  ==>
# (closure (f195982) (error list-ref primitives) (let ((f195982 f195982)) (error (list-ref (primitives) f195982) "arg must be a character")))
# == external-symbols  ==>
# (closure (f195982) ((primitive-ref error) (primitive-ref list-ref) (primitive-ref primitives)) (let ((f195982 f195982)) ((primitive-ref error) ((primitive-ref list-ref) ((primitive-ref primitives)) f195982) "arg must be a character")))
# emit-expr (closure (f195982) ((primitive-ref error) (primitive-ref list-ref) (primitive-ref primitives)) (let ((f195982 f195982)) ((primitive-ref error) ((primitive-ref list-ref) ((primitive-ref primitives)) f195982) "arg must be a character")))
# emit-closure
# si = 0
# env = ()
# expr = (closure (f195982) ((primitive-ref error) (primitive-ref list-ref) (primitive-ref primitives)) (let ((f195982 f195982)) ((primitive-ref error) ((primitive-ref list-ref) ((primitive-ref primitives)) f195982) "arg must be a character")))
    movl $_L_1424528, 0(%ebp)  # closure label
# WARNING: free var (primitive-ref error) not defined in the environmnet
# WARNING: free var (primitive-ref list-ref) not defined in the environmnet
# WARNING: free var (primitive-ref primitives) not defined in the environmnet
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $16, %ebp     # bump ebp
    jmp _L_1424529            # jump around closure body
_L_1424528:
# check argument count
    cmp $4,%eax
    je _L_1424530
# invoke error handler eh_argcount
    .extern mrc_eh$uargcount
    movl mrc_eh$uargcount, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_1424530:
# emit-tail-expr
# si=-12
# env=((f195982 . -8) ((primitive-ref primitives) . 12) ((primitive-ref list-ref) . 8) ((primitive-ref error) . 4))
# expr=(let ((f195982 f195982)) ((primitive-ref error) ((primitive-ref list-ref) ((primitive-ref primitives)) f195982) "arg must be a character"))
# emit-tail-let
#  si   = -12
#  env  = ((f195982 . -8) ((primitive-ref primitives) . 12) ((primitive-ref list-ref) . 8) ((primitive-ref error) . 4))
#  bindings = ((f195982 f195982))
#  body = ((primitive-ref error) ((primitive-ref list-ref) ((primitive-ref primitives)) f195982) "arg must be a character")
# emit-expr f195982
# emit-variable-ref
# env=((f195982 . -8) ((primitive-ref primitives) . 12) ((primitive-ref list-ref) . 8) ((primitive-ref error) . 4))
# var=f195982
    movl -8(%esp), %eax  # stack load f195982
# end emit-variable-ref
    movl %eax, -12(%esp)  # stack save
# emit-tail-expr
# si=-16
# env=((f195982 . -12) (f195982 . -8) ((primitive-ref primitives) . 12) ((primitive-ref list-ref) . 8) ((primitive-ref error) . 4))
# expr=((primitive-ref error) ((primitive-ref list-ref) ((primitive-ref primitives)) f195982) "arg must be a character")
# emit-tail-funcall
#    si   =-16
#    env  = ((f195982 . -12) (f195982 . -8) ((primitive-ref primitives) . 12) ((primitive-ref list-ref) . 8) ((primitive-ref error) . 4))
#    expr = (funcall (primitive-ref error) ((primitive-ref list-ref) ((primitive-ref primitives)) f195982) "arg must be a character")
# emit-expr (primitive-ref error)
    .extern mrc_error
    movl mrc_error,%eax
   movl %eax,  -16(%esp)  # stash funcall-oper in next closure slot
# emit-expr ((primitive-ref list-ref) ((primitive-ref primitives)) f195982)
# funcall
#    si   =-20
#    env  = ((f195982 . -12) (f195982 . -8) ((primitive-ref primitives) . 12) ((primitive-ref list-ref) . 8) ((primitive-ref error) . 4))
#    expr = (funcall (primitive-ref list-ref) ((primitive-ref primitives)) f195982)
# emit-expr (primitive-ref list-ref)
    .extern mrc_list$mref
    movl mrc_list$mref,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1424531"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1424531":
   movl %eax,  -28(%esp)  # stash funcall-oper in closure slot
# emit-expr ((primitive-ref primitives))
# funcall
#    si   =-32
#    env  = ((f195982 . -12) (f195982 . -8) ((primitive-ref primitives) . 12) ((primitive-ref list-ref) . 8) ((primitive-ref error) . 4))
#    expr = (funcall (primitive-ref primitives))
# emit-expr (primitive-ref primitives)
    .extern mrc_primitives
    movl mrc_primitives,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1424532"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1424532":
   movl %eax,  -40(%esp)  # stash funcall-oper in closure slot
    movl -40(%esp), %edi   # load new closure to %edi
    add $-32, %esp   # adjust base
    movl $0,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $32, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    mov %eax, -32(%esp)  # arg ((primitive-ref primitives))
# emit-expr f195982
# emit-variable-ref
# env=((f195982 . -12) (f195982 . -8) ((primitive-ref primitives) . 12) ((primitive-ref list-ref) . 8) ((primitive-ref error) . 4))
# var=f195982
    movl -12(%esp), %eax  # stack load f195982
# end emit-variable-ref
    mov %eax, -36(%esp)  # arg f195982
    movl -28(%esp), %edi   # load new closure to %edi
    add $-20, %esp   # adjust base
    movl $8,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $20, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    mov %eax, -20(%esp)    # arg ((primitive-ref list-ref) ((primitive-ref primitives)) f195982)
# emit-expr "arg must be a character"
# string literal
    jmp _L_1424534
    .align 8,0x90
_L_1424533 :
    .int 92
    .ascii "arg must be a character"
_L_1424534:
    movl $_L_1424533, %eax
    orl $6, %eax
    mov %eax, -24(%esp)    # arg arg must be a character
    movl -16(%esp), %edi   # load new closure to %edi
# emit-shift-args:  size=3   si=-16  delta=12
    mov -16(%esp), %ebx  # shift frame cell
    mov %ebx, -4(%esp)  # down to base
# emit-shift-args:  size=2   si=-20  delta=12
    mov -20(%esp), %ebx  # shift frame cell
    mov %ebx, -8(%esp)  # down to base
# emit-shift-args:  size=1   si=-24  delta=12
    mov -24(%esp), %ebx  # shift frame cell
    mov %ebx, -12(%esp)  # down to base
# emit-shift-args:  size=0   si=-28  delta=12
    movl $8,%eax   # save arg count
    jmp *-2(%edi)  # tail-funcall
    .align 4,0x90
_L_1424529:
     movl %eax, mrc_eh$ucharacter
# == explicit-begins  ==>
# (lambda (i) (error (list-ref (primitives) i) "arg must be a pair"))
# == eliminate-let*  ==>
# (lambda (i) (error (list-ref (primitives) i) "arg must be a pair"))
# == uniquify-variables  ==>
# (lambda (f195983) (error (list-ref (primitives) f195983) "arg must be a pair"))
# == vectorize-letrec  ==>
# (lambda (f195983) (error (list-ref (primitives) f195983) "arg must be a pair"))
# == eliminate-set!  ==>
# (lambda (f195983) (let ((f195983 f195983)) (error (list-ref (primitives) f195983) "arg must be a pair")))
# == close-free-variables  ==>
# (closure (f195983) (error list-ref primitives) (let ((f195983 f195983)) (error (list-ref (primitives) f195983) "arg must be a pair")))
# == eliminate-quote  ==>
# (closure (f195983) (error list-ref primitives) (let ((f195983 f195983)) (error (list-ref (primitives) f195983) "arg must be a pair")))
# == eliminate-when/unless  ==>
# (closure (f195983) (error list-ref primitives) (let ((f195983 f195983)) (error (list-ref (primitives) f195983) "arg must be a pair")))
# == eliminate-cond  ==>
# (closure (f195983) (error list-ref primitives) (let ((f195983 f195983)) (error (list-ref (primitives) f195983) "arg must be a pair")))
# == external-symbols  ==>
# (closure (f195983) ((primitive-ref error) (primitive-ref list-ref) (primitive-ref primitives)) (let ((f195983 f195983)) ((primitive-ref error) ((primitive-ref list-ref) ((primitive-ref primitives)) f195983) "arg must be a pair")))
# emit-expr (closure (f195983) ((primitive-ref error) (primitive-ref list-ref) (primitive-ref primitives)) (let ((f195983 f195983)) ((primitive-ref error) ((primitive-ref list-ref) ((primitive-ref primitives)) f195983) "arg must be a pair")))
# emit-closure
# si = 0
# env = ()
# expr = (closure (f195983) ((primitive-ref error) (primitive-ref list-ref) (primitive-ref primitives)) (let ((f195983 f195983)) ((primitive-ref error) ((primitive-ref list-ref) ((primitive-ref primitives)) f195983) "arg must be a pair")))
    movl $_L_1424535, 0(%ebp)  # closure label
# WARNING: free var (primitive-ref error) not defined in the environmnet
# WARNING: free var (primitive-ref list-ref) not defined in the environmnet
# WARNING: free var (primitive-ref primitives) not defined in the environmnet
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $16, %ebp     # bump ebp
    jmp _L_1424536            # jump around closure body
_L_1424535:
# check argument count
    cmp $4,%eax
    je _L_1424537
# invoke error handler eh_argcount
    .extern mrc_eh$uargcount
    movl mrc_eh$uargcount, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_1424537:
# emit-tail-expr
# si=-12
# env=((f195983 . -8) ((primitive-ref primitives) . 12) ((primitive-ref list-ref) . 8) ((primitive-ref error) . 4))
# expr=(let ((f195983 f195983)) ((primitive-ref error) ((primitive-ref list-ref) ((primitive-ref primitives)) f195983) "arg must be a pair"))
# emit-tail-let
#  si   = -12
#  env  = ((f195983 . -8) ((primitive-ref primitives) . 12) ((primitive-ref list-ref) . 8) ((primitive-ref error) . 4))
#  bindings = ((f195983 f195983))
#  body = ((primitive-ref error) ((primitive-ref list-ref) ((primitive-ref primitives)) f195983) "arg must be a pair")
# emit-expr f195983
# emit-variable-ref
# env=((f195983 . -8) ((primitive-ref primitives) . 12) ((primitive-ref list-ref) . 8) ((primitive-ref error) . 4))
# var=f195983
    movl -8(%esp), %eax  # stack load f195983
# end emit-variable-ref
    movl %eax, -12(%esp)  # stack save
# emit-tail-expr
# si=-16
# env=((f195983 . -12) (f195983 . -8) ((primitive-ref primitives) . 12) ((primitive-ref list-ref) . 8) ((primitive-ref error) . 4))
# expr=((primitive-ref error) ((primitive-ref list-ref) ((primitive-ref primitives)) f195983) "arg must be a pair")
# emit-tail-funcall
#    si   =-16
#    env  = ((f195983 . -12) (f195983 . -8) ((primitive-ref primitives) . 12) ((primitive-ref list-ref) . 8) ((primitive-ref error) . 4))
#    expr = (funcall (primitive-ref error) ((primitive-ref list-ref) ((primitive-ref primitives)) f195983) "arg must be a pair")
# emit-expr (primitive-ref error)
    .extern mrc_error
    movl mrc_error,%eax
   movl %eax,  -16(%esp)  # stash funcall-oper in next closure slot
# emit-expr ((primitive-ref list-ref) ((primitive-ref primitives)) f195983)
# funcall
#    si   =-20
#    env  = ((f195983 . -12) (f195983 . -8) ((primitive-ref primitives) . 12) ((primitive-ref list-ref) . 8) ((primitive-ref error) . 4))
#    expr = (funcall (primitive-ref list-ref) ((primitive-ref primitives)) f195983)
# emit-expr (primitive-ref list-ref)
    .extern mrc_list$mref
    movl mrc_list$mref,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1424538"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1424538":
   movl %eax,  -28(%esp)  # stash funcall-oper in closure slot
# emit-expr ((primitive-ref primitives))
# funcall
#    si   =-32
#    env  = ((f195983 . -12) (f195983 . -8) ((primitive-ref primitives) . 12) ((primitive-ref list-ref) . 8) ((primitive-ref error) . 4))
#    expr = (funcall (primitive-ref primitives))
# emit-expr (primitive-ref primitives)
    .extern mrc_primitives
    movl mrc_primitives,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1424539"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1424539":
   movl %eax,  -40(%esp)  # stash funcall-oper in closure slot
    movl -40(%esp), %edi   # load new closure to %edi
    add $-32, %esp   # adjust base
    movl $0,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $32, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    mov %eax, -32(%esp)  # arg ((primitive-ref primitives))
# emit-expr f195983
# emit-variable-ref
# env=((f195983 . -12) (f195983 . -8) ((primitive-ref primitives) . 12) ((primitive-ref list-ref) . 8) ((primitive-ref error) . 4))
# var=f195983
    movl -12(%esp), %eax  # stack load f195983
# end emit-variable-ref
    mov %eax, -36(%esp)  # arg f195983
    movl -28(%esp), %edi   # load new closure to %edi
    add $-20, %esp   # adjust base
    movl $8,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $20, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    mov %eax, -20(%esp)    # arg ((primitive-ref list-ref) ((primitive-ref primitives)) f195983)
# emit-expr "arg must be a pair"
# string literal
    jmp _L_1424541
    .align 8,0x90
_L_1424540 :
    .int 72
    .ascii "arg must be a pair"
_L_1424541:
    movl $_L_1424540, %eax
    orl $6, %eax
    mov %eax, -24(%esp)    # arg arg must be a pair
    movl -16(%esp), %edi   # load new closure to %edi
# emit-shift-args:  size=3   si=-16  delta=12
    mov -16(%esp), %ebx  # shift frame cell
    mov %ebx, -4(%esp)  # down to base
# emit-shift-args:  size=2   si=-20  delta=12
    mov -20(%esp), %ebx  # shift frame cell
    mov %ebx, -8(%esp)  # down to base
# emit-shift-args:  size=1   si=-24  delta=12
    mov -24(%esp), %ebx  # shift frame cell
    mov %ebx, -12(%esp)  # down to base
# emit-shift-args:  size=0   si=-28  delta=12
    movl $8,%eax   # save arg count
    jmp *-2(%edi)  # tail-funcall
    .align 4,0x90
_L_1424536:
     movl %eax, mrc_eh$upair
# == explicit-begins  ==>
# (lambda (i) (error (list-ref (primitives) i) "arg must be a vector"))
# == eliminate-let*  ==>
# (lambda (i) (error (list-ref (primitives) i) "arg must be a vector"))
# == uniquify-variables  ==>
# (lambda (f195984) (error (list-ref (primitives) f195984) "arg must be a vector"))
# == vectorize-letrec  ==>
# (lambda (f195984) (error (list-ref (primitives) f195984) "arg must be a vector"))
# == eliminate-set!  ==>
# (lambda (f195984) (let ((f195984 f195984)) (error (list-ref (primitives) f195984) "arg must be a vector")))
# == close-free-variables  ==>
# (closure (f195984) (error list-ref primitives) (let ((f195984 f195984)) (error (list-ref (primitives) f195984) "arg must be a vector")))
# == eliminate-quote  ==>
# (closure (f195984) (error list-ref primitives) (let ((f195984 f195984)) (error (list-ref (primitives) f195984) "arg must be a vector")))
# == eliminate-when/unless  ==>
# (closure (f195984) (error list-ref primitives) (let ((f195984 f195984)) (error (list-ref (primitives) f195984) "arg must be a vector")))
# == eliminate-cond  ==>
# (closure (f195984) (error list-ref primitives) (let ((f195984 f195984)) (error (list-ref (primitives) f195984) "arg must be a vector")))
# == external-symbols  ==>
# (closure (f195984) ((primitive-ref error) (primitive-ref list-ref) (primitive-ref primitives)) (let ((f195984 f195984)) ((primitive-ref error) ((primitive-ref list-ref) ((primitive-ref primitives)) f195984) "arg must be a vector")))
# emit-expr (closure (f195984) ((primitive-ref error) (primitive-ref list-ref) (primitive-ref primitives)) (let ((f195984 f195984)) ((primitive-ref error) ((primitive-ref list-ref) ((primitive-ref primitives)) f195984) "arg must be a vector")))
# emit-closure
# si = 0
# env = ()
# expr = (closure (f195984) ((primitive-ref error) (primitive-ref list-ref) (primitive-ref primitives)) (let ((f195984 f195984)) ((primitive-ref error) ((primitive-ref list-ref) ((primitive-ref primitives)) f195984) "arg must be a vector")))
    movl $_L_1424542, 0(%ebp)  # closure label
# WARNING: free var (primitive-ref error) not defined in the environmnet
# WARNING: free var (primitive-ref list-ref) not defined in the environmnet
# WARNING: free var (primitive-ref primitives) not defined in the environmnet
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $16, %ebp     # bump ebp
    jmp _L_1424543            # jump around closure body
_L_1424542:
# check argument count
    cmp $4,%eax
    je _L_1424544
# invoke error handler eh_argcount
    .extern mrc_eh$uargcount
    movl mrc_eh$uargcount, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_1424544:
# emit-tail-expr
# si=-12
# env=((f195984 . -8) ((primitive-ref primitives) . 12) ((primitive-ref list-ref) . 8) ((primitive-ref error) . 4))
# expr=(let ((f195984 f195984)) ((primitive-ref error) ((primitive-ref list-ref) ((primitive-ref primitives)) f195984) "arg must be a vector"))
# emit-tail-let
#  si   = -12
#  env  = ((f195984 . -8) ((primitive-ref primitives) . 12) ((primitive-ref list-ref) . 8) ((primitive-ref error) . 4))
#  bindings = ((f195984 f195984))
#  body = ((primitive-ref error) ((primitive-ref list-ref) ((primitive-ref primitives)) f195984) "arg must be a vector")
# emit-expr f195984
# emit-variable-ref
# env=((f195984 . -8) ((primitive-ref primitives) . 12) ((primitive-ref list-ref) . 8) ((primitive-ref error) . 4))
# var=f195984
    movl -8(%esp), %eax  # stack load f195984
# end emit-variable-ref
    movl %eax, -12(%esp)  # stack save
# emit-tail-expr
# si=-16
# env=((f195984 . -12) (f195984 . -8) ((primitive-ref primitives) . 12) ((primitive-ref list-ref) . 8) ((primitive-ref error) . 4))
# expr=((primitive-ref error) ((primitive-ref list-ref) ((primitive-ref primitives)) f195984) "arg must be a vector")
# emit-tail-funcall
#    si   =-16
#    env  = ((f195984 . -12) (f195984 . -8) ((primitive-ref primitives) . 12) ((primitive-ref list-ref) . 8) ((primitive-ref error) . 4))
#    expr = (funcall (primitive-ref error) ((primitive-ref list-ref) ((primitive-ref primitives)) f195984) "arg must be a vector")
# emit-expr (primitive-ref error)
    .extern mrc_error
    movl mrc_error,%eax
   movl %eax,  -16(%esp)  # stash funcall-oper in next closure slot
# emit-expr ((primitive-ref list-ref) ((primitive-ref primitives)) f195984)
# funcall
#    si   =-20
#    env  = ((f195984 . -12) (f195984 . -8) ((primitive-ref primitives) . 12) ((primitive-ref list-ref) . 8) ((primitive-ref error) . 4))
#    expr = (funcall (primitive-ref list-ref) ((primitive-ref primitives)) f195984)
# emit-expr (primitive-ref list-ref)
    .extern mrc_list$mref
    movl mrc_list$mref,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1424545"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1424545":
   movl %eax,  -28(%esp)  # stash funcall-oper in closure slot
# emit-expr ((primitive-ref primitives))
# funcall
#    si   =-32
#    env  = ((f195984 . -12) (f195984 . -8) ((primitive-ref primitives) . 12) ((primitive-ref list-ref) . 8) ((primitive-ref error) . 4))
#    expr = (funcall (primitive-ref primitives))
# emit-expr (primitive-ref primitives)
    .extern mrc_primitives
    movl mrc_primitives,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1424546"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1424546":
   movl %eax,  -40(%esp)  # stash funcall-oper in closure slot
    movl -40(%esp), %edi   # load new closure to %edi
    add $-32, %esp   # adjust base
    movl $0,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $32, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    mov %eax, -32(%esp)  # arg ((primitive-ref primitives))
# emit-expr f195984
# emit-variable-ref
# env=((f195984 . -12) (f195984 . -8) ((primitive-ref primitives) . 12) ((primitive-ref list-ref) . 8) ((primitive-ref error) . 4))
# var=f195984
    movl -12(%esp), %eax  # stack load f195984
# end emit-variable-ref
    mov %eax, -36(%esp)  # arg f195984
    movl -28(%esp), %edi   # load new closure to %edi
    add $-20, %esp   # adjust base
    movl $8,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $20, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    mov %eax, -20(%esp)    # arg ((primitive-ref list-ref) ((primitive-ref primitives)) f195984)
# emit-expr "arg must be a vector"
# string literal
    jmp _L_1424548
    .align 8,0x90
_L_1424547 :
    .int 80
    .ascii "arg must be a vector"
_L_1424548:
    movl $_L_1424547, %eax
    orl $6, %eax
    mov %eax, -24(%esp)    # arg arg must be a vector
    movl -16(%esp), %edi   # load new closure to %edi
# emit-shift-args:  size=3   si=-16  delta=12
    mov -16(%esp), %ebx  # shift frame cell
    mov %ebx, -4(%esp)  # down to base
# emit-shift-args:  size=2   si=-20  delta=12
    mov -20(%esp), %ebx  # shift frame cell
    mov %ebx, -8(%esp)  # down to base
# emit-shift-args:  size=1   si=-24  delta=12
    mov -24(%esp), %ebx  # shift frame cell
    mov %ebx, -12(%esp)  # down to base
# emit-shift-args:  size=0   si=-28  delta=12
    movl $8,%eax   # save arg count
    jmp *-2(%edi)  # tail-funcall
    .align 4,0x90
_L_1424543:
     movl %eax, mrc_eh$uvector
# == explicit-begins  ==>
# (lambda (i) (error (list-ref (primitives) i) "length must be a fixnum >= 0"))
# == eliminate-let*  ==>
# (lambda (i) (error (list-ref (primitives) i) "length must be a fixnum >= 0"))
# == uniquify-variables  ==>
# (lambda (f195985) (error (list-ref (primitives) f195985) "length must be a fixnum >= 0"))
# == vectorize-letrec  ==>
# (lambda (f195985) (error (list-ref (primitives) f195985) "length must be a fixnum >= 0"))
# == eliminate-set!  ==>
# (lambda (f195985) (let ((f195985 f195985)) (error (list-ref (primitives) f195985) "length must be a fixnum >= 0")))
# == close-free-variables  ==>
# (closure (f195985) (error list-ref primitives) (let ((f195985 f195985)) (error (list-ref (primitives) f195985) "length must be a fixnum >= 0")))
# == eliminate-quote  ==>
# (closure (f195985) (error list-ref primitives) (let ((f195985 f195985)) (error (list-ref (primitives) f195985) "length must be a fixnum >= 0")))
# == eliminate-when/unless  ==>
# (closure (f195985) (error list-ref primitives) (let ((f195985 f195985)) (error (list-ref (primitives) f195985) "length must be a fixnum >= 0")))
# == eliminate-cond  ==>
# (closure (f195985) (error list-ref primitives) (let ((f195985 f195985)) (error (list-ref (primitives) f195985) "length must be a fixnum >= 0")))
# == external-symbols  ==>
# (closure (f195985) ((primitive-ref error) (primitive-ref list-ref) (primitive-ref primitives)) (let ((f195985 f195985)) ((primitive-ref error) ((primitive-ref list-ref) ((primitive-ref primitives)) f195985) "length must be a fixnum >= 0")))
# emit-expr (closure (f195985) ((primitive-ref error) (primitive-ref list-ref) (primitive-ref primitives)) (let ((f195985 f195985)) ((primitive-ref error) ((primitive-ref list-ref) ((primitive-ref primitives)) f195985) "length must be a fixnum >= 0")))
# emit-closure
# si = 0
# env = ()
# expr = (closure (f195985) ((primitive-ref error) (primitive-ref list-ref) (primitive-ref primitives)) (let ((f195985 f195985)) ((primitive-ref error) ((primitive-ref list-ref) ((primitive-ref primitives)) f195985) "length must be a fixnum >= 0")))
    movl $_L_1424549, 0(%ebp)  # closure label
# WARNING: free var (primitive-ref error) not defined in the environmnet
# WARNING: free var (primitive-ref list-ref) not defined in the environmnet
# WARNING: free var (primitive-ref primitives) not defined in the environmnet
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $16, %ebp     # bump ebp
    jmp _L_1424550            # jump around closure body
_L_1424549:
# check argument count
    cmp $4,%eax
    je _L_1424551
# invoke error handler eh_argcount
    .extern mrc_eh$uargcount
    movl mrc_eh$uargcount, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_1424551:
# emit-tail-expr
# si=-12
# env=((f195985 . -8) ((primitive-ref primitives) . 12) ((primitive-ref list-ref) . 8) ((primitive-ref error) . 4))
# expr=(let ((f195985 f195985)) ((primitive-ref error) ((primitive-ref list-ref) ((primitive-ref primitives)) f195985) "length must be a fixnum >= 0"))
# emit-tail-let
#  si   = -12
#  env  = ((f195985 . -8) ((primitive-ref primitives) . 12) ((primitive-ref list-ref) . 8) ((primitive-ref error) . 4))
#  bindings = ((f195985 f195985))
#  body = ((primitive-ref error) ((primitive-ref list-ref) ((primitive-ref primitives)) f195985) "length must be a fixnum >= 0")
# emit-expr f195985
# emit-variable-ref
# env=((f195985 . -8) ((primitive-ref primitives) . 12) ((primitive-ref list-ref) . 8) ((primitive-ref error) . 4))
# var=f195985
    movl -8(%esp), %eax  # stack load f195985
# end emit-variable-ref
    movl %eax, -12(%esp)  # stack save
# emit-tail-expr
# si=-16
# env=((f195985 . -12) (f195985 . -8) ((primitive-ref primitives) . 12) ((primitive-ref list-ref) . 8) ((primitive-ref error) . 4))
# expr=((primitive-ref error) ((primitive-ref list-ref) ((primitive-ref primitives)) f195985) "length must be a fixnum >= 0")
# emit-tail-funcall
#    si   =-16
#    env  = ((f195985 . -12) (f195985 . -8) ((primitive-ref primitives) . 12) ((primitive-ref list-ref) . 8) ((primitive-ref error) . 4))
#    expr = (funcall (primitive-ref error) ((primitive-ref list-ref) ((primitive-ref primitives)) f195985) "length must be a fixnum >= 0")
# emit-expr (primitive-ref error)
    .extern mrc_error
    movl mrc_error,%eax
   movl %eax,  -16(%esp)  # stash funcall-oper in next closure slot
# emit-expr ((primitive-ref list-ref) ((primitive-ref primitives)) f195985)
# funcall
#    si   =-20
#    env  = ((f195985 . -12) (f195985 . -8) ((primitive-ref primitives) . 12) ((primitive-ref list-ref) . 8) ((primitive-ref error) . 4))
#    expr = (funcall (primitive-ref list-ref) ((primitive-ref primitives)) f195985)
# emit-expr (primitive-ref list-ref)
    .extern mrc_list$mref
    movl mrc_list$mref,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1424552"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1424552":
   movl %eax,  -28(%esp)  # stash funcall-oper in closure slot
# emit-expr ((primitive-ref primitives))
# funcall
#    si   =-32
#    env  = ((f195985 . -12) (f195985 . -8) ((primitive-ref primitives) . 12) ((primitive-ref list-ref) . 8) ((primitive-ref error) . 4))
#    expr = (funcall (primitive-ref primitives))
# emit-expr (primitive-ref primitives)
    .extern mrc_primitives
    movl mrc_primitives,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1424553"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1424553":
   movl %eax,  -40(%esp)  # stash funcall-oper in closure slot
    movl -40(%esp), %edi   # load new closure to %edi
    add $-32, %esp   # adjust base
    movl $0,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $32, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    mov %eax, -32(%esp)  # arg ((primitive-ref primitives))
# emit-expr f195985
# emit-variable-ref
# env=((f195985 . -12) (f195985 . -8) ((primitive-ref primitives) . 12) ((primitive-ref list-ref) . 8) ((primitive-ref error) . 4))
# var=f195985
    movl -12(%esp), %eax  # stack load f195985
# end emit-variable-ref
    mov %eax, -36(%esp)  # arg f195985
    movl -28(%esp), %edi   # load new closure to %edi
    add $-20, %esp   # adjust base
    movl $8,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $20, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    mov %eax, -20(%esp)    # arg ((primitive-ref list-ref) ((primitive-ref primitives)) f195985)
# emit-expr "length must be a fixnum >= 0"
# string literal
    jmp _L_1424555
    .align 8,0x90
_L_1424554 :
    .int 112
    .ascii "length must be a fixnum >= 0"
_L_1424555:
    movl $_L_1424554, %eax
    orl $6, %eax
    mov %eax, -24(%esp)    # arg length must be a fixnum >= 0
    movl -16(%esp), %edi   # load new closure to %edi
# emit-shift-args:  size=3   si=-16  delta=12
    mov -16(%esp), %ebx  # shift frame cell
    mov %ebx, -4(%esp)  # down to base
# emit-shift-args:  size=2   si=-20  delta=12
    mov -20(%esp), %ebx  # shift frame cell
    mov %ebx, -8(%esp)  # down to base
# emit-shift-args:  size=1   si=-24  delta=12
    mov -24(%esp), %ebx  # shift frame cell
    mov %ebx, -12(%esp)  # down to base
# emit-shift-args:  size=0   si=-28  delta=12
    movl $8,%eax   # save arg count
    jmp *-2(%edi)  # tail-funcall
    .align 4,0x90
_L_1424550:
     movl %eax, mrc_eh$ulength
# == explicit-begins  ==>
# (lambda (i) (error (list-ref (primitives) i) "index out of bounds"))
# == eliminate-let*  ==>
# (lambda (i) (error (list-ref (primitives) i) "index out of bounds"))
# == uniquify-variables  ==>
# (lambda (f195986) (error (list-ref (primitives) f195986) "index out of bounds"))
# == vectorize-letrec  ==>
# (lambda (f195986) (error (list-ref (primitives) f195986) "index out of bounds"))
# == eliminate-set!  ==>
# (lambda (f195986) (let ((f195986 f195986)) (error (list-ref (primitives) f195986) "index out of bounds")))
# == close-free-variables  ==>
# (closure (f195986) (error list-ref primitives) (let ((f195986 f195986)) (error (list-ref (primitives) f195986) "index out of bounds")))
# == eliminate-quote  ==>
# (closure (f195986) (error list-ref primitives) (let ((f195986 f195986)) (error (list-ref (primitives) f195986) "index out of bounds")))
# == eliminate-when/unless  ==>
# (closure (f195986) (error list-ref primitives) (let ((f195986 f195986)) (error (list-ref (primitives) f195986) "index out of bounds")))
# == eliminate-cond  ==>
# (closure (f195986) (error list-ref primitives) (let ((f195986 f195986)) (error (list-ref (primitives) f195986) "index out of bounds")))
# == external-symbols  ==>
# (closure (f195986) ((primitive-ref error) (primitive-ref list-ref) (primitive-ref primitives)) (let ((f195986 f195986)) ((primitive-ref error) ((primitive-ref list-ref) ((primitive-ref primitives)) f195986) "index out of bounds")))
# emit-expr (closure (f195986) ((primitive-ref error) (primitive-ref list-ref) (primitive-ref primitives)) (let ((f195986 f195986)) ((primitive-ref error) ((primitive-ref list-ref) ((primitive-ref primitives)) f195986) "index out of bounds")))
# emit-closure
# si = 0
# env = ()
# expr = (closure (f195986) ((primitive-ref error) (primitive-ref list-ref) (primitive-ref primitives)) (let ((f195986 f195986)) ((primitive-ref error) ((primitive-ref list-ref) ((primitive-ref primitives)) f195986) "index out of bounds")))
    movl $_L_1424556, 0(%ebp)  # closure label
# WARNING: free var (primitive-ref error) not defined in the environmnet
# WARNING: free var (primitive-ref list-ref) not defined in the environmnet
# WARNING: free var (primitive-ref primitives) not defined in the environmnet
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $16, %ebp     # bump ebp
    jmp _L_1424557            # jump around closure body
_L_1424556:
# check argument count
    cmp $4,%eax
    je _L_1424558
# invoke error handler eh_argcount
    .extern mrc_eh$uargcount
    movl mrc_eh$uargcount, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_1424558:
# emit-tail-expr
# si=-12
# env=((f195986 . -8) ((primitive-ref primitives) . 12) ((primitive-ref list-ref) . 8) ((primitive-ref error) . 4))
# expr=(let ((f195986 f195986)) ((primitive-ref error) ((primitive-ref list-ref) ((primitive-ref primitives)) f195986) "index out of bounds"))
# emit-tail-let
#  si   = -12
#  env  = ((f195986 . -8) ((primitive-ref primitives) . 12) ((primitive-ref list-ref) . 8) ((primitive-ref error) . 4))
#  bindings = ((f195986 f195986))
#  body = ((primitive-ref error) ((primitive-ref list-ref) ((primitive-ref primitives)) f195986) "index out of bounds")
# emit-expr f195986
# emit-variable-ref
# env=((f195986 . -8) ((primitive-ref primitives) . 12) ((primitive-ref list-ref) . 8) ((primitive-ref error) . 4))
# var=f195986
    movl -8(%esp), %eax  # stack load f195986
# end emit-variable-ref
    movl %eax, -12(%esp)  # stack save
# emit-tail-expr
# si=-16
# env=((f195986 . -12) (f195986 . -8) ((primitive-ref primitives) . 12) ((primitive-ref list-ref) . 8) ((primitive-ref error) . 4))
# expr=((primitive-ref error) ((primitive-ref list-ref) ((primitive-ref primitives)) f195986) "index out of bounds")
# emit-tail-funcall
#    si   =-16
#    env  = ((f195986 . -12) (f195986 . -8) ((primitive-ref primitives) . 12) ((primitive-ref list-ref) . 8) ((primitive-ref error) . 4))
#    expr = (funcall (primitive-ref error) ((primitive-ref list-ref) ((primitive-ref primitives)) f195986) "index out of bounds")
# emit-expr (primitive-ref error)
    .extern mrc_error
    movl mrc_error,%eax
   movl %eax,  -16(%esp)  # stash funcall-oper in next closure slot
# emit-expr ((primitive-ref list-ref) ((primitive-ref primitives)) f195986)
# funcall
#    si   =-20
#    env  = ((f195986 . -12) (f195986 . -8) ((primitive-ref primitives) . 12) ((primitive-ref list-ref) . 8) ((primitive-ref error) . 4))
#    expr = (funcall (primitive-ref list-ref) ((primitive-ref primitives)) f195986)
# emit-expr (primitive-ref list-ref)
    .extern mrc_list$mref
    movl mrc_list$mref,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1424559"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1424559":
   movl %eax,  -28(%esp)  # stash funcall-oper in closure slot
# emit-expr ((primitive-ref primitives))
# funcall
#    si   =-32
#    env  = ((f195986 . -12) (f195986 . -8) ((primitive-ref primitives) . 12) ((primitive-ref list-ref) . 8) ((primitive-ref error) . 4))
#    expr = (funcall (primitive-ref primitives))
# emit-expr (primitive-ref primitives)
    .extern mrc_primitives
    movl mrc_primitives,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1424560"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1424560":
   movl %eax,  -40(%esp)  # stash funcall-oper in closure slot
    movl -40(%esp), %edi   # load new closure to %edi
    add $-32, %esp   # adjust base
    movl $0,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $32, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    mov %eax, -32(%esp)  # arg ((primitive-ref primitives))
# emit-expr f195986
# emit-variable-ref
# env=((f195986 . -12) (f195986 . -8) ((primitive-ref primitives) . 12) ((primitive-ref list-ref) . 8) ((primitive-ref error) . 4))
# var=f195986
    movl -12(%esp), %eax  # stack load f195986
# end emit-variable-ref
    mov %eax, -36(%esp)  # arg f195986
    movl -28(%esp), %edi   # load new closure to %edi
    add $-20, %esp   # adjust base
    movl $8,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $20, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    mov %eax, -20(%esp)    # arg ((primitive-ref list-ref) ((primitive-ref primitives)) f195986)
# emit-expr "index out of bounds"
# string literal
    jmp _L_1424562
    .align 8,0x90
_L_1424561 :
    .int 76
    .ascii "index out of bounds"
_L_1424562:
    movl $_L_1424561, %eax
    orl $6, %eax
    mov %eax, -24(%esp)    # arg index out of bounds
    movl -16(%esp), %edi   # load new closure to %edi
# emit-shift-args:  size=3   si=-16  delta=12
    mov -16(%esp), %ebx  # shift frame cell
    mov %ebx, -4(%esp)  # down to base
# emit-shift-args:  size=2   si=-20  delta=12
    mov -20(%esp), %ebx  # shift frame cell
    mov %ebx, -8(%esp)  # down to base
# emit-shift-args:  size=1   si=-24  delta=12
    mov -24(%esp), %ebx  # shift frame cell
    mov %ebx, -12(%esp)  # down to base
# emit-shift-args:  size=0   si=-28  delta=12
    movl $8,%eax   # save arg count
    jmp *-2(%edi)  # tail-funcall
    .align 4,0x90
_L_1424557:
     movl %eax, mrc_eh$uvector$uindex
# == explicit-begins  ==>
# (lambda (i) (error (list-ref (primitives) i) "index out of bounds"))
# == eliminate-let*  ==>
# (lambda (i) (error (list-ref (primitives) i) "index out of bounds"))
# == uniquify-variables  ==>
# (lambda (f195987) (error (list-ref (primitives) f195987) "index out of bounds"))
# == vectorize-letrec  ==>
# (lambda (f195987) (error (list-ref (primitives) f195987) "index out of bounds"))
# == eliminate-set!  ==>
# (lambda (f195987) (let ((f195987 f195987)) (error (list-ref (primitives) f195987) "index out of bounds")))
# == close-free-variables  ==>
# (closure (f195987) (error list-ref primitives) (let ((f195987 f195987)) (error (list-ref (primitives) f195987) "index out of bounds")))
# == eliminate-quote  ==>
# (closure (f195987) (error list-ref primitives) (let ((f195987 f195987)) (error (list-ref (primitives) f195987) "index out of bounds")))
# == eliminate-when/unless  ==>
# (closure (f195987) (error list-ref primitives) (let ((f195987 f195987)) (error (list-ref (primitives) f195987) "index out of bounds")))
# == eliminate-cond  ==>
# (closure (f195987) (error list-ref primitives) (let ((f195987 f195987)) (error (list-ref (primitives) f195987) "index out of bounds")))
# == external-symbols  ==>
# (closure (f195987) ((primitive-ref error) (primitive-ref list-ref) (primitive-ref primitives)) (let ((f195987 f195987)) ((primitive-ref error) ((primitive-ref list-ref) ((primitive-ref primitives)) f195987) "index out of bounds")))
# emit-expr (closure (f195987) ((primitive-ref error) (primitive-ref list-ref) (primitive-ref primitives)) (let ((f195987 f195987)) ((primitive-ref error) ((primitive-ref list-ref) ((primitive-ref primitives)) f195987) "index out of bounds")))
# emit-closure
# si = 0
# env = ()
# expr = (closure (f195987) ((primitive-ref error) (primitive-ref list-ref) (primitive-ref primitives)) (let ((f195987 f195987)) ((primitive-ref error) ((primitive-ref list-ref) ((primitive-ref primitives)) f195987) "index out of bounds")))
    movl $_L_1424563, 0(%ebp)  # closure label
# WARNING: free var (primitive-ref error) not defined in the environmnet
# WARNING: free var (primitive-ref list-ref) not defined in the environmnet
# WARNING: free var (primitive-ref primitives) not defined in the environmnet
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $16, %ebp     # bump ebp
    jmp _L_1424564            # jump around closure body
_L_1424563:
# check argument count
    cmp $4,%eax
    je _L_1424565
# invoke error handler eh_argcount
    .extern mrc_eh$uargcount
    movl mrc_eh$uargcount, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_1424565:
# emit-tail-expr
# si=-12
# env=((f195987 . -8) ((primitive-ref primitives) . 12) ((primitive-ref list-ref) . 8) ((primitive-ref error) . 4))
# expr=(let ((f195987 f195987)) ((primitive-ref error) ((primitive-ref list-ref) ((primitive-ref primitives)) f195987) "index out of bounds"))
# emit-tail-let
#  si   = -12
#  env  = ((f195987 . -8) ((primitive-ref primitives) . 12) ((primitive-ref list-ref) . 8) ((primitive-ref error) . 4))
#  bindings = ((f195987 f195987))
#  body = ((primitive-ref error) ((primitive-ref list-ref) ((primitive-ref primitives)) f195987) "index out of bounds")
# emit-expr f195987
# emit-variable-ref
# env=((f195987 . -8) ((primitive-ref primitives) . 12) ((primitive-ref list-ref) . 8) ((primitive-ref error) . 4))
# var=f195987
    movl -8(%esp), %eax  # stack load f195987
# end emit-variable-ref
    movl %eax, -12(%esp)  # stack save
# emit-tail-expr
# si=-16
# env=((f195987 . -12) (f195987 . -8) ((primitive-ref primitives) . 12) ((primitive-ref list-ref) . 8) ((primitive-ref error) . 4))
# expr=((primitive-ref error) ((primitive-ref list-ref) ((primitive-ref primitives)) f195987) "index out of bounds")
# emit-tail-funcall
#    si   =-16
#    env  = ((f195987 . -12) (f195987 . -8) ((primitive-ref primitives) . 12) ((primitive-ref list-ref) . 8) ((primitive-ref error) . 4))
#    expr = (funcall (primitive-ref error) ((primitive-ref list-ref) ((primitive-ref primitives)) f195987) "index out of bounds")
# emit-expr (primitive-ref error)
    .extern mrc_error
    movl mrc_error,%eax
   movl %eax,  -16(%esp)  # stash funcall-oper in next closure slot
# emit-expr ((primitive-ref list-ref) ((primitive-ref primitives)) f195987)
# funcall
#    si   =-20
#    env  = ((f195987 . -12) (f195987 . -8) ((primitive-ref primitives) . 12) ((primitive-ref list-ref) . 8) ((primitive-ref error) . 4))
#    expr = (funcall (primitive-ref list-ref) ((primitive-ref primitives)) f195987)
# emit-expr (primitive-ref list-ref)
    .extern mrc_list$mref
    movl mrc_list$mref,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1424566"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1424566":
   movl %eax,  -28(%esp)  # stash funcall-oper in closure slot
# emit-expr ((primitive-ref primitives))
# funcall
#    si   =-32
#    env  = ((f195987 . -12) (f195987 . -8) ((primitive-ref primitives) . 12) ((primitive-ref list-ref) . 8) ((primitive-ref error) . 4))
#    expr = (funcall (primitive-ref primitives))
# emit-expr (primitive-ref primitives)
    .extern mrc_primitives
    movl mrc_primitives,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1424567"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1424567":
   movl %eax,  -40(%esp)  # stash funcall-oper in closure slot
    movl -40(%esp), %edi   # load new closure to %edi
    add $-32, %esp   # adjust base
    movl $0,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $32, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    mov %eax, -32(%esp)  # arg ((primitive-ref primitives))
# emit-expr f195987
# emit-variable-ref
# env=((f195987 . -12) (f195987 . -8) ((primitive-ref primitives) . 12) ((primitive-ref list-ref) . 8) ((primitive-ref error) . 4))
# var=f195987
    movl -12(%esp), %eax  # stack load f195987
# end emit-variable-ref
    mov %eax, -36(%esp)  # arg f195987
    movl -28(%esp), %edi   # load new closure to %edi
    add $-20, %esp   # adjust base
    movl $8,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $20, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    mov %eax, -20(%esp)    # arg ((primitive-ref list-ref) ((primitive-ref primitives)) f195987)
# emit-expr "index out of bounds"
# string literal
    jmp _L_1424569
    .align 8,0x90
_L_1424568 :
    .int 76
    .ascii "index out of bounds"
_L_1424569:
    movl $_L_1424568, %eax
    orl $6, %eax
    mov %eax, -24(%esp)    # arg index out of bounds
    movl -16(%esp), %edi   # load new closure to %edi
# emit-shift-args:  size=3   si=-16  delta=12
    mov -16(%esp), %ebx  # shift frame cell
    mov %ebx, -4(%esp)  # down to base
# emit-shift-args:  size=2   si=-20  delta=12
    mov -20(%esp), %ebx  # shift frame cell
    mov %ebx, -8(%esp)  # down to base
# emit-shift-args:  size=1   si=-24  delta=12
    mov -24(%esp), %ebx  # shift frame cell
    mov %ebx, -12(%esp)  # down to base
# emit-shift-args:  size=0   si=-28  delta=12
    movl $8,%eax   # save arg count
    jmp *-2(%edi)  # tail-funcall
    .align 4,0x90
_L_1424564:
     movl %eax, mrc_eh$ustring$uindex
# == explicit-begins  ==>
# (lambda (z) (fxzero? z))
# == eliminate-let*  ==>
# (lambda (z) (fxzero? z))
# == uniquify-variables  ==>
# (lambda (f195988) (fxzero? f195988))
# == vectorize-letrec  ==>
# (lambda (f195988) (fxzero? f195988))
# == eliminate-set!  ==>
# (lambda (f195988) (let ((f195988 f195988)) (fxzero? f195988)))
# == close-free-variables  ==>
# (closure (f195988) () (let ((f195988 f195988)) (fxzero? f195988)))
# == eliminate-quote  ==>
# (closure (f195988) () (let ((f195988 f195988)) (fxzero? f195988)))
# == eliminate-when/unless  ==>
# (closure (f195988) () (let ((f195988 f195988)) (fxzero? f195988)))
# == eliminate-cond  ==>
# (closure (f195988) () (let ((f195988 f195988)) (fxzero? f195988)))
# == external-symbols  ==>
# (closure (f195988) () (let ((f195988 f195988)) (fxzero? f195988)))
# emit-expr (closure (f195988) () (let ((f195988 f195988)) (fxzero? f195988)))
# emit-closure
# si = 0
# env = ()
# expr = (closure (f195988) () (let ((f195988 f195988)) (fxzero? f195988)))
    movl $_L_1424570, 0(%ebp)  # closure label
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $8, %ebp     # bump ebp
    jmp _L_1424571            # jump around closure body
_L_1424570:
# check argument count
    cmp $4,%eax
    je _L_1424572
# invoke error handler eh_argcount
    .extern mrc_eh$uargcount
    movl mrc_eh$uargcount, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_1424572:
# emit-tail-expr
# si=-12
# env=((f195988 . -8))
# expr=(let ((f195988 f195988)) (fxzero? f195988))
# emit-tail-let
#  si   = -12
#  env  = ((f195988 . -8))
#  bindings = ((f195988 f195988))
#  body = (fxzero? f195988)
# emit-expr f195988
# emit-variable-ref
# env=((f195988 . -8))
# var=f195988
    movl -8(%esp), %eax  # stack load f195988
# end emit-variable-ref
    movl %eax, -12(%esp)  # stack save
# emit-tail-expr
# si=-16
# env=((f195988 . -12) (f195988 . -8))
# expr=(fxzero? f195988)
# tail primcall
# emit-expr f195988
# emit-variable-ref
# env=((f195988 . -12) (f195988 . -8))
# var=f195988
    movl -12(%esp), %eax  # stack load f195988
# end emit-variable-ref
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1424573"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $56,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1424573:
    cmp $0, %eax
    sete %al
    movzbl %al, %eax
    sal $6, %al
    or $47, %al
#return from tail (fxzero? f195988)
    ret
    .align 4,0x90
_L_1424571:
     movl %eax, mrc_zero$q
# == explicit-begins  ==>
# (lambda (x) (fx> x 0))
# == eliminate-let*  ==>
# (lambda (x) (fx> x 0))
# == uniquify-variables  ==>
# (lambda (f195989) (fx> f195989 0))
# == vectorize-letrec  ==>
# (lambda (f195989) (fx> f195989 0))
# == eliminate-set!  ==>
# (lambda (f195989) (let ((f195989 f195989)) (fx> f195989 0)))
# == close-free-variables  ==>
# (closure (f195989) () (let ((f195989 f195989)) (fx> f195989 0)))
# == eliminate-quote  ==>
# (closure (f195989) () (let ((f195989 f195989)) (fx> f195989 0)))
# == eliminate-when/unless  ==>
# (closure (f195989) () (let ((f195989 f195989)) (fx> f195989 0)))
# == eliminate-cond  ==>
# (closure (f195989) () (let ((f195989 f195989)) (fx> f195989 0)))
# == external-symbols  ==>
# (closure (f195989) () (let ((f195989 f195989)) (fx> f195989 0)))
# emit-expr (closure (f195989) () (let ((f195989 f195989)) (fx> f195989 0)))
# emit-closure
# si = 0
# env = ()
# expr = (closure (f195989) () (let ((f195989 f195989)) (fx> f195989 0)))
    movl $_L_1424574, 0(%ebp)  # closure label
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $8, %ebp     # bump ebp
    jmp _L_1424575            # jump around closure body
_L_1424574:
# check argument count
    cmp $4,%eax
    je _L_1424576
# invoke error handler eh_argcount
    .extern mrc_eh$uargcount
    movl mrc_eh$uargcount, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_1424576:
# emit-tail-expr
# si=-12
# env=((f195989 . -8))
# expr=(let ((f195989 f195989)) (fx> f195989 0))
# emit-tail-let
#  si   = -12
#  env  = ((f195989 . -8))
#  bindings = ((f195989 f195989))
#  body = (fx> f195989 0)
# emit-expr f195989
# emit-variable-ref
# env=((f195989 . -8))
# var=f195989
    movl -8(%esp), %eax  # stack load f195989
# end emit-variable-ref
    movl %eax, -12(%esp)  # stack save
# emit-tail-expr
# si=-16
# env=((f195989 . -12) (f195989 . -8))
# expr=(fx> f195989 0)
# tail primcall
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1424577"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $72,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1424577:
    movl %eax, -16(%esp)
# emit-expr f195989
# emit-variable-ref
# env=((f195989 . -12) (f195989 . -8))
# var=f195989
    movl -12(%esp), %eax  # stack load f195989
# end emit-variable-ref
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1424578"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $72,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1424578:
    cmp -16(%esp), %eax
    setg %al
    movzbl %al, %eax
    sal $6, %al
    or $47, %al
#return from tail (fx> f195989 0)
    ret
    .align 4,0x90
_L_1424575:
     movl %eax, mrc_positive$q
# == explicit-begins  ==>
# (lambda (x) (fx< x 0))
# == eliminate-let*  ==>
# (lambda (x) (fx< x 0))
# == uniquify-variables  ==>
# (lambda (f195990) (fx< f195990 0))
# == vectorize-letrec  ==>
# (lambda (f195990) (fx< f195990 0))
# == eliminate-set!  ==>
# (lambda (f195990) (let ((f195990 f195990)) (fx< f195990 0)))
# == close-free-variables  ==>
# (closure (f195990) () (let ((f195990 f195990)) (fx< f195990 0)))
# == eliminate-quote  ==>
# (closure (f195990) () (let ((f195990 f195990)) (fx< f195990 0)))
# == eliminate-when/unless  ==>
# (closure (f195990) () (let ((f195990 f195990)) (fx< f195990 0)))
# == eliminate-cond  ==>
# (closure (f195990) () (let ((f195990 f195990)) (fx< f195990 0)))
# == external-symbols  ==>
# (closure (f195990) () (let ((f195990 f195990)) (fx< f195990 0)))
# emit-expr (closure (f195990) () (let ((f195990 f195990)) (fx< f195990 0)))
# emit-closure
# si = 0
# env = ()
# expr = (closure (f195990) () (let ((f195990 f195990)) (fx< f195990 0)))
    movl $_L_1424579, 0(%ebp)  # closure label
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $8, %ebp     # bump ebp
    jmp _L_1424580            # jump around closure body
_L_1424579:
# check argument count
    cmp $4,%eax
    je _L_1424581
# invoke error handler eh_argcount
    .extern mrc_eh$uargcount
    movl mrc_eh$uargcount, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_1424581:
# emit-tail-expr
# si=-12
# env=((f195990 . -8))
# expr=(let ((f195990 f195990)) (fx< f195990 0))
# emit-tail-let
#  si   = -12
#  env  = ((f195990 . -8))
#  bindings = ((f195990 f195990))
#  body = (fx< f195990 0)
# emit-expr f195990
# emit-variable-ref
# env=((f195990 . -8))
# var=f195990
    movl -8(%esp), %eax  # stack load f195990
# end emit-variable-ref
    movl %eax, -12(%esp)  # stack save
# emit-tail-expr
# si=-16
# env=((f195990 . -12) (f195990 . -8))
# expr=(fx< f195990 0)
# tail primcall
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1424582"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $64,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1424582:
    movl %eax, -16(%esp)
# emit-expr f195990
# emit-variable-ref
# env=((f195990 . -12) (f195990 . -8))
# var=f195990
    movl -12(%esp), %eax  # stack load f195990
# end emit-variable-ref
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1424583"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $64,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1424583:
    cmp -16(%esp), %eax
    setl %al
    movzbl %al, %eax
    sal $6, %al
    or $47, %al
#return from tail (fx< f195990 0)
    ret
    .align 4,0x90
_L_1424580:
     movl %eax, mrc_negative$q
# == explicit-begins  ==>
# (lambda (f l) (if (null? l) (quote ()) (cons (f (car l)) (map f (cdr l)))))
# == eliminate-let*  ==>
# (lambda (f l) (if (null? l) (quote ()) (cons (f (car l)) (map f (cdr l)))))
# == uniquify-variables  ==>
# (lambda (f195991 f195992) (if (null? f195992) (quote ()) (cons (f195991 (car f195992)) (map f195991 (cdr f195992)))))
# == vectorize-letrec  ==>
# (lambda (f195991 f195992) (if (null? f195992) (quote ()) (cons (f195991 (car f195992)) (map f195991 (cdr f195992)))))
# == eliminate-set!  ==>
# (lambda (f195991 f195992) (let ((f195991 f195991) (f195992 f195992)) (if (null? f195992) (quote ()) (cons (f195991 (car f195992)) (map f195991 (cdr f195992))))))
# == close-free-variables  ==>
# (closure (f195991 f195992) (map) (let ((f195991 f195991) (f195992 f195992)) (if (null? f195992) (quote ()) (cons (f195991 (car f195992)) (map f195991 (cdr f195992))))))
# == eliminate-quote  ==>
# (closure (f195991 f195992) (map) (let ((f195991 f195991) (f195992 f195992)) (if (null? f195992) () (cons (f195991 (car f195992)) (map f195991 (cdr f195992))))))
# == eliminate-when/unless  ==>
# (closure (f195991 f195992) (map) (let ((f195991 f195991) (f195992 f195992)) (if (null? f195992) () (cons (f195991 (car f195992)) (map f195991 (cdr f195992))))))
# == eliminate-cond  ==>
# (closure (f195991 f195992) (map) (let ((f195991 f195991) (f195992 f195992)) (if (null? f195992) () (cons (f195991 (car f195992)) (map f195991 (cdr f195992))))))
# == external-symbols  ==>
# (closure (f195991 f195992) ((primitive-ref map)) (let ((f195991 f195991) (f195992 f195992)) (if (null? f195992) () (cons (f195991 (car f195992)) ((primitive-ref map) f195991 (cdr f195992))))))
# emit-expr (closure (f195991 f195992) ((primitive-ref map)) (let ((f195991 f195991) (f195992 f195992)) (if (null? f195992) () (cons (f195991 (car f195992)) ((primitive-ref map) f195991 (cdr f195992))))))
# emit-closure
# si = 0
# env = ()
# expr = (closure (f195991 f195992) ((primitive-ref map)) (let ((f195991 f195991) (f195992 f195992)) (if (null? f195992) () (cons (f195991 (car f195992)) ((primitive-ref map) f195991 (cdr f195992))))))
    movl $_L_1424584, 0(%ebp)  # closure label
# WARNING: free var (primitive-ref map) not defined in the environmnet
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $8, %ebp     # bump ebp
    jmp _L_1424585            # jump around closure body
_L_1424584:
# check argument count
    cmp $8,%eax
    je _L_1424586
# invoke error handler eh_argcount
    .extern mrc_eh$uargcount
    movl mrc_eh$uargcount, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_1424586:
# emit-tail-expr
# si=-16
# env=((f195992 . -12) (f195991 . -8) ((primitive-ref map) . 4))
# expr=(let ((f195991 f195991) (f195992 f195992)) (if (null? f195992) () (cons (f195991 (car f195992)) ((primitive-ref map) f195991 (cdr f195992)))))
# emit-tail-let
#  si   = -16
#  env  = ((f195992 . -12) (f195991 . -8) ((primitive-ref map) . 4))
#  bindings = ((f195991 f195991) (f195992 f195992))
#  body = (if (null? f195992) () (cons (f195991 (car f195992)) ((primitive-ref map) f195991 (cdr f195992))))
# emit-expr f195991
# emit-variable-ref
# env=((f195992 . -12) (f195991 . -8) ((primitive-ref map) . 4))
# var=f195991
    movl -8(%esp), %eax  # stack load f195991
# end emit-variable-ref
    movl %eax, -16(%esp)  # stack save
# emit-expr f195992
# emit-variable-ref
# env=((f195992 . -12) (f195991 . -8) ((primitive-ref map) . 4))
# var=f195992
    movl -12(%esp), %eax  # stack load f195992
# end emit-variable-ref
    movl %eax, -20(%esp)  # stack save
# emit-tail-expr
# si=-24
# env=((f195992 . -20) (f195991 . -16) (f195992 . -12) (f195991 . -8) ((primitive-ref map) . 4))
# expr=(if (null? f195992) () (cons (f195991 (car f195992)) ((primitive-ref map) f195991 (cdr f195992))))
# emit-expr (null? f195992)
# emit-expr f195992
# emit-variable-ref
# env=((f195992 . -20) (f195991 . -16) (f195992 . -12) (f195991 . -8) ((primitive-ref map) . 4))
# var=f195992
    movl -20(%esp), %eax  # stack load f195992
# end emit-variable-ref
    cmp $63, %eax
    mov $0, %eax
    sete %al
    movzbl %al, %eax
    sal $6, %al
    or $47, %al
    cmp $47, %al
    je _L_1424587
# emit-tail-expr
# si=-24
# env=((f195992 . -20) (f195991 . -16) (f195992 . -12) (f195991 . -8) ((primitive-ref map) . 4))
# expr=()
    movl $63, %eax     # immed ()
    ret                  # immediate tail return
    jmp _L_1424588
_L_1424587:
# emit-tail-expr
# si=-24
# env=((f195992 . -20) (f195991 . -16) (f195992 . -12) (f195991 . -8) ((primitive-ref map) . 4))
# expr=(cons (f195991 (car f195992)) ((primitive-ref map) f195991 (cdr f195992)))
# tail primcall
# cons arg1=(f195991 (car f195992)) arg2=((primitive-ref map) f195991 (cdr f195992))
# emit-expr (f195991 (car f195992))
# funcall
#    si   =-24
#    env  = ((f195992 . -20) (f195991 . -16) (f195992 . -12) (f195991 . -8) ((primitive-ref map) . 4))
#    expr = (funcall f195991 (car f195992))
# emit-expr f195991
# emit-variable-ref
# env=((f195992 . -20) (f195991 . -16) (f195992 . -12) (f195991 . -8) ((primitive-ref map) . 4))
# var=f195991
    movl -16(%esp), %eax  # stack load f195991
# end emit-variable-ref
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1424589"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1424589":
   movl %eax,  -32(%esp)  # stash funcall-oper in closure slot
# emit-expr (car f195992)
# emit-expr f195992
# emit-variable-ref
# env=((f195992 . -20) (f195991 . -16) (f195992 . -12) (f195991 . -8) ((primitive-ref map) . 4))
# var=f195992
    movl -20(%esp), %eax  # stack load f195992
# end emit-variable-ref
# check the argument is a pair
    movl %eax,%ebx
    and $7, %bl
    cmp $1, %bl
    je _L_1424590
# invoke error handler eh_pair
    .extern mrc_eh$upair
    movl mrc_eh$upair, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $108,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1424590:
    movl -1(%eax), %eax
    mov %eax, -36(%esp)  # arg (car f195992)
    movl -32(%esp), %edi   # load new closure to %edi
    add $-24, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $24, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    movl %eax, -24(%esp)
# emit-expr ((primitive-ref map) f195991 (cdr f195992))
# funcall
#    si   =-28
#    env  = ((f195992 . -20) (f195991 . -16) (f195992 . -12) (f195991 . -8) ((primitive-ref map) . 4))
#    expr = (funcall (primitive-ref map) f195991 (cdr f195992))
# emit-expr (primitive-ref map)
    .extern mrc_map
    movl mrc_map,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1424591"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1424591":
   movl %eax,  -36(%esp)  # stash funcall-oper in closure slot
# emit-expr f195991
# emit-variable-ref
# env=((f195992 . -20) (f195991 . -16) (f195992 . -12) (f195991 . -8) ((primitive-ref map) . 4))
# var=f195991
    movl -16(%esp), %eax  # stack load f195991
# end emit-variable-ref
    mov %eax, -40(%esp)  # arg f195991
# emit-expr (cdr f195992)
# emit-expr f195992
# emit-variable-ref
# env=((f195992 . -20) (f195991 . -16) (f195992 . -12) (f195991 . -8) ((primitive-ref map) . 4))
# var=f195992
    movl -20(%esp), %eax  # stack load f195992
# end emit-variable-ref
# check the argument is a pair
    movl %eax,%ebx
    and $7, %bl
    cmp $1, %bl
    je _L_1424592
# invoke error handler eh_pair
    .extern mrc_eh$upair
    movl mrc_eh$upair, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $112,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1424592:
    movl 3(%eax), %eax
    mov %eax, -44(%esp)  # arg (cdr f195992)
    movl -36(%esp), %edi   # load new closure to %edi
    add $-28, %esp   # adjust base
    movl $8,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $28, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    movl %eax, 4(%ebp)
    movl -24(%esp), %eax
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    or   $1, %al
    add  $8, %ebp
# cons end
#return from tail (cons (f195991 (car f195992)) ((primitive-ref map) f195991 (cdr f195992)))
    ret
_L_1424588:
    .align 4,0x90
_L_1424585:
     movl %eax, mrc_map
# == explicit-begins  ==>
# (lambda (f l) (unless (null? l) (begin (f (car l)) (for-each f (cdr l)))))
# == eliminate-let*  ==>
# (lambda (f l) (unless (null? l) (begin (f (car l)) (for-each f (cdr l)))))
# == uniquify-variables  ==>
# (lambda (f195993 f195994) (unless (null? f195994) (begin (f195993 (car f195994)) (for-each f195993 (cdr f195994)))))
# == vectorize-letrec  ==>
# (lambda (f195993 f195994) (unless (null? f195994) (begin (f195993 (car f195994)) (for-each f195993 (cdr f195994)))))
# == eliminate-set!  ==>
# (lambda (f195993 f195994) (let ((f195993 f195993) (f195994 f195994)) (unless (null? f195994) (begin (f195993 (car f195994)) (for-each f195993 (cdr f195994))))))
# == close-free-variables  ==>
# (closure (f195993 f195994) (unless for-each) (let ((f195993 f195993) (f195994 f195994)) (unless (null? f195994) (begin (f195993 (car f195994)) (for-each f195993 (cdr f195994))))))
# == eliminate-quote  ==>
# (closure (f195993 f195994) (unless for-each) (let ((f195993 f195993) (f195994 f195994)) (unless (null? f195994) (begin (f195993 (car f195994)) (for-each f195993 (cdr f195994))))))
# == eliminate-when/unless  ==>
# (closure (f195993 f195994) (if (not for-each) (begin) #f) (let ((f195993 f195993) (f195994 f195994)) (if (not (null? f195994)) (begin (begin (f195993 (car f195994)) (for-each f195993 (cdr f195994)))) #f)))
# == eliminate-cond  ==>
# (closure (f195993 f195994) (if (not for-each) (begin) #f) (let ((f195993 f195993) (f195994 f195994)) (if (not (null? f195994)) (begin (begin (f195993 (car f195994)) (for-each f195993 (cdr f195994)))) #f)))
# == external-symbols  ==>
# (closure (f195993 f195994) (if (not (primitive-ref for-each)) (begin) #f) (let ((f195993 f195993) (f195994 f195994)) (if (not (null? f195994)) (begin (begin (f195993 (car f195994)) ((primitive-ref for-each) f195993 (cdr f195994)))) #f)))
# emit-expr (closure (f195993 f195994) (if (not (primitive-ref for-each)) (begin) #f) (let ((f195993 f195993) (f195994 f195994)) (if (not (null? f195994)) (begin (begin (f195993 (car f195994)) ((primitive-ref for-each) f195993 (cdr f195994)))) #f)))
# emit-closure
# si = 0
# env = ()
# expr = (closure (f195993 f195994) (if (not (primitive-ref for-each)) (begin) #f) (let ((f195993 f195993) (f195994 f195994)) (if (not (null? f195994)) (begin (begin (f195993 (car f195994)) ((primitive-ref for-each) f195993 (cdr f195994)))) #f)))
    movl $_L_1424593, 0(%ebp)  # closure label
# WARNING: free var if not defined in the environmnet
# WARNING: free var (not (primitive-ref for-each)) not defined in the environmnet
# WARNING: free var (begin) not defined in the environmnet
# WARNING: free var #f not defined in the environmnet
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $24, %ebp     # bump ebp
    jmp _L_1424594            # jump around closure body
_L_1424593:
# check argument count
    cmp $8,%eax
    je _L_1424595
# invoke error handler eh_argcount
    .extern mrc_eh$uargcount
    movl mrc_eh$uargcount, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_1424595:
# emit-tail-expr
# si=-16
# env=((f195994 . -12) (f195993 . -8) (#f . 16) ((begin) . 12) ((not (primitive-ref for-each)) . 8) (if . 4))
# expr=(let ((f195993 f195993) (f195994 f195994)) (if (not (null? f195994)) (begin (begin (f195993 (car f195994)) ((primitive-ref for-each) f195993 (cdr f195994)))) #f))
# emit-tail-let
#  si   = -16
#  env  = ((f195994 . -12) (f195993 . -8) (#f . 16) ((begin) . 12) ((not (primitive-ref for-each)) . 8) (if . 4))
#  bindings = ((f195993 f195993) (f195994 f195994))
#  body = (if (not (null? f195994)) (begin (begin (f195993 (car f195994)) ((primitive-ref for-each) f195993 (cdr f195994)))) #f)
# emit-expr f195993
# emit-variable-ref
# env=((f195994 . -12) (f195993 . -8) (#f . 16) ((begin) . 12) ((not (primitive-ref for-each)) . 8) (if . 4))
# var=f195993
    movl -8(%esp), %eax  # stack load f195993
# end emit-variable-ref
    movl %eax, -16(%esp)  # stack save
# emit-expr f195994
# emit-variable-ref
# env=((f195994 . -12) (f195993 . -8) (#f . 16) ((begin) . 12) ((not (primitive-ref for-each)) . 8) (if . 4))
# var=f195994
    movl -12(%esp), %eax  # stack load f195994
# end emit-variable-ref
    movl %eax, -20(%esp)  # stack save
# emit-tail-expr
# si=-24
# env=((f195994 . -20) (f195993 . -16) (f195994 . -12) (f195993 . -8) (#f . 16) ((begin) . 12) ((not (primitive-ref for-each)) . 8) (if . 4))
# expr=(if (not (null? f195994)) (begin (begin (f195993 (car f195994)) ((primitive-ref for-each) f195993 (cdr f195994)))) #f)
# emit-expr (not (null? f195994))
# emit-expr (null? f195994)
# emit-expr f195994
# emit-variable-ref
# env=((f195994 . -20) (f195993 . -16) (f195994 . -12) (f195993 . -8) (#f . 16) ((begin) . 12) ((not (primitive-ref for-each)) . 8) (if . 4))
# var=f195994
    movl -20(%esp), %eax  # stack load f195994
# end emit-variable-ref
    cmp $63, %eax
    mov $0, %eax
    sete %al
    movzbl %al, %eax
    sal $6, %al
    or $47, %al
    cmp $47, %eax
    sete %al
    movzbl %al, %eax
    sal $6, %al
    or $47, %al
    cmp $47, %al
    je _L_1424596
# emit-tail-expr
# si=-24
# env=((f195994 . -20) (f195993 . -16) (f195994 . -12) (f195993 . -8) (#f . 16) ((begin) . 12) ((not (primitive-ref for-each)) . 8) (if . 4))
# expr=(begin (begin (f195993 (car f195994)) ((primitive-ref for-each) f195993 (cdr f195994))))
# tail-begin (begin (begin (f195993 (car f195994)) ((primitive-ref for-each) f195993 (cdr f195994))))
#   env=((f195994 . -20) (f195993 . -16) (f195994 . -12) (f195993 . -8) (#f . 16) ((begin) . 12) ((not (primitive-ref for-each)) . 8) (if . 4))
# emit-tail-expr
# si=-24
# env=((f195994 . -20) (f195993 . -16) (f195994 . -12) (f195993 . -8) (#f . 16) ((begin) . 12) ((not (primitive-ref for-each)) . 8) (if . 4))
# expr=(begin (f195993 (car f195994)) ((primitive-ref for-each) f195993 (cdr f195994)))
# tail-begin (begin (f195993 (car f195994)) ((primitive-ref for-each) f195993 (cdr f195994)))
#   env=((f195994 . -20) (f195993 . -16) (f195994 . -12) (f195993 . -8) (#f . 16) ((begin) . 12) ((not (primitive-ref for-each)) . 8) (if . 4))
# emit-expr (f195993 (car f195994))
# funcall
#    si   =-24
#    env  = ((f195994 . -20) (f195993 . -16) (f195994 . -12) (f195993 . -8) (#f . 16) ((begin) . 12) ((not (primitive-ref for-each)) . 8) (if . 4))
#    expr = (funcall f195993 (car f195994))
# emit-expr f195993
# emit-variable-ref
# env=((f195994 . -20) (f195993 . -16) (f195994 . -12) (f195993 . -8) (#f . 16) ((begin) . 12) ((not (primitive-ref for-each)) . 8) (if . 4))
# var=f195993
    movl -16(%esp), %eax  # stack load f195993
# end emit-variable-ref
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1424598"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1424598":
   movl %eax,  -32(%esp)  # stash funcall-oper in closure slot
# emit-expr (car f195994)
# emit-expr f195994
# emit-variable-ref
# env=((f195994 . -20) (f195993 . -16) (f195994 . -12) (f195993 . -8) (#f . 16) ((begin) . 12) ((not (primitive-ref for-each)) . 8) (if . 4))
# var=f195994
    movl -20(%esp), %eax  # stack load f195994
# end emit-variable-ref
# check the argument is a pair
    movl %eax,%ebx
    and $7, %bl
    cmp $1, %bl
    je _L_1424599
# invoke error handler eh_pair
    .extern mrc_eh$upair
    movl mrc_eh$upair, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $108,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1424599:
    movl -1(%eax), %eax
    mov %eax, -36(%esp)  # arg (car f195994)
    movl -32(%esp), %edi   # load new closure to %edi
    add $-24, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $24, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
# emit-tail-expr
# si=-24
# env=((f195994 . -20) (f195993 . -16) (f195994 . -12) (f195993 . -8) (#f . 16) ((begin) . 12) ((not (primitive-ref for-each)) . 8) (if . 4))
# expr=(begin ((primitive-ref for-each) f195993 (cdr f195994)))
# tail-begin (begin ((primitive-ref for-each) f195993 (cdr f195994)))
#   env=((f195994 . -20) (f195993 . -16) (f195994 . -12) (f195993 . -8) (#f . 16) ((begin) . 12) ((not (primitive-ref for-each)) . 8) (if . 4))
# emit-tail-expr
# si=-24
# env=((f195994 . -20) (f195993 . -16) (f195994 . -12) (f195993 . -8) (#f . 16) ((begin) . 12) ((not (primitive-ref for-each)) . 8) (if . 4))
# expr=((primitive-ref for-each) f195993 (cdr f195994))
# emit-tail-funcall
#    si   =-24
#    env  = ((f195994 . -20) (f195993 . -16) (f195994 . -12) (f195993 . -8) (#f . 16) ((begin) . 12) ((not (primitive-ref for-each)) . 8) (if . 4))
#    expr = (funcall (primitive-ref for-each) f195993 (cdr f195994))
# emit-expr (primitive-ref for-each)
    .extern mrc_for$meach
    movl mrc_for$meach,%eax
   movl %eax,  -24(%esp)  # stash funcall-oper in next closure slot
# emit-expr f195993
# emit-variable-ref
# env=((f195994 . -20) (f195993 . -16) (f195994 . -12) (f195993 . -8) (#f . 16) ((begin) . 12) ((not (primitive-ref for-each)) . 8) (if . 4))
# var=f195993
    movl -16(%esp), %eax  # stack load f195993
# end emit-variable-ref
    mov %eax, -28(%esp)    # arg f195993
# emit-expr (cdr f195994)
# emit-expr f195994
# emit-variable-ref
# env=((f195994 . -20) (f195993 . -16) (f195994 . -12) (f195993 . -8) (#f . 16) ((begin) . 12) ((not (primitive-ref for-each)) . 8) (if . 4))
# var=f195994
    movl -20(%esp), %eax  # stack load f195994
# end emit-variable-ref
# check the argument is a pair
    movl %eax,%ebx
    and $7, %bl
    cmp $1, %bl
    je _L_1424600
# invoke error handler eh_pair
    .extern mrc_eh$upair
    movl mrc_eh$upair, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $112,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1424600:
    movl 3(%eax), %eax
    mov %eax, -32(%esp)    # arg (cdr f195994)
    movl -24(%esp), %edi   # load new closure to %edi
# emit-shift-args:  size=3   si=-24  delta=20
    mov -24(%esp), %ebx  # shift frame cell
    mov %ebx, -4(%esp)  # down to base
# emit-shift-args:  size=2   si=-28  delta=20
    mov -28(%esp), %ebx  # shift frame cell
    mov %ebx, -8(%esp)  # down to base
# emit-shift-args:  size=1   si=-32  delta=20
    mov -32(%esp), %ebx  # shift frame cell
    mov %ebx, -12(%esp)  # down to base
# emit-shift-args:  size=0   si=-36  delta=20
    movl $8,%eax   # save arg count
    jmp *-2(%edi)  # tail-funcall
     ret   # return thru stack
     ret   # return thru stack
    jmp _L_1424597
_L_1424596:
# emit-tail-expr
# si=-24
# env=((f195994 . -20) (f195993 . -16) (f195994 . -12) (f195993 . -8) (#f . 16) ((begin) . 12) ((not (primitive-ref for-each)) . 8) (if . 4))
# expr=#f
    movl $47, %eax     # immed #f
    ret                  # immediate tail return
_L_1424597:
    .align 4,0x90
_L_1424594:
     movl %eax, mrc_for$meach
# == explicit-begins  ==>
# (let ((p (make-vector 6)) (sz 1024)) (begin (vector-set! p 0 (quote output-port)) (vector-set! p 1 "/dev/stdout") (vector-set! p 2 1) (vector-set! p 3 (make-string sz)) (vector-set! p 4 0) (vector-set! p 5 sz) p))
# == eliminate-let*  ==>
# (let ((p (make-vector 6)) (sz 1024)) (begin (vector-set! p 0 (quote output-port)) (vector-set! p 1 "/dev/stdout") (vector-set! p 2 1) (vector-set! p 3 (make-string sz)) (vector-set! p 4 0) (vector-set! p 5 sz) p))
# == uniquify-variables  ==>
# (let ((f195996 (make-vector 6)) (f195995 1024)) (begin (vector-set! f195996 0 (quote output-port)) (vector-set! f195996 1 "/dev/stdout") (vector-set! f195996 2 1) (vector-set! f195996 3 (make-string f195995)) (vector-set! f195996 4 0) (vector-set! f195996 5 f195995) f195996))
# == vectorize-letrec  ==>
# (let ((f195996 (make-vector 6)) (f195995 1024)) (begin (vector-set! f195996 0 (quote output-port)) (vector-set! f195996 1 "/dev/stdout") (vector-set! f195996 2 1) (vector-set! f195996 3 (make-string f195995)) (vector-set! f195996 4 0) (vector-set! f195996 5 f195995) f195996))
# == eliminate-set!  ==>
# (let ((f195996 (make-vector 6)) (f195995 1024)) (begin (vector-set! f195996 0 (quote output-port)) (vector-set! f195996 1 "/dev/stdout") (vector-set! f195996 2 1) (vector-set! f195996 3 (make-string f195995)) (vector-set! f195996 4 0) (vector-set! f195996 5 f195995) f195996))
# == close-free-variables  ==>
# (let ((f195996 (make-vector 6)) (f195995 1024)) (begin (vector-set! f195996 0 (quote output-port)) (vector-set! f195996 1 "/dev/stdout") (vector-set! f195996 2 1) (vector-set! f195996 3 (make-string f195995)) (vector-set! f195996 4 0) (vector-set! f195996 5 f195995) f195996))
# == eliminate-quote  ==>
# (let ((f195996 (make-vector 6)) (f195995 1024)) (begin (vector-set! f195996 0 (string->symbol "output-port")) (vector-set! f195996 1 "/dev/stdout") (vector-set! f195996 2 1) (vector-set! f195996 3 (make-string f195995)) (vector-set! f195996 4 0) (vector-set! f195996 5 f195995) f195996))
# == eliminate-when/unless  ==>
# (let ((f195996 (make-vector 6)) (f195995 1024)) (begin (vector-set! f195996 0 (string->symbol "output-port")) (vector-set! f195996 1 "/dev/stdout") (vector-set! f195996 2 1) (vector-set! f195996 3 (make-string f195995)) (vector-set! f195996 4 0) (vector-set! f195996 5 f195995) f195996))
# == eliminate-cond  ==>
# (let ((f195996 (make-vector 6)) (f195995 1024)) (begin (vector-set! f195996 0 (string->symbol "output-port")) (vector-set! f195996 1 "/dev/stdout") (vector-set! f195996 2 1) (vector-set! f195996 3 (make-string f195995)) (vector-set! f195996 4 0) (vector-set! f195996 5 f195995) f195996))
# == external-symbols  ==>
# (let ((f195996 (make-vector 6)) (f195995 1024)) (begin (vector-set! f195996 0 ((primitive-ref string->symbol) "output-port")) (vector-set! f195996 1 "/dev/stdout") (vector-set! f195996 2 1) (vector-set! f195996 3 (make-string f195995)) (vector-set! f195996 4 0) (vector-set! f195996 5 f195995) f195996))
# emit-expr (let ((f195996 (make-vector 6)) (f195995 1024)) (begin (vector-set! f195996 0 ((primitive-ref string->symbol) "output-port")) (vector-set! f195996 1 "/dev/stdout") (vector-set! f195996 2 1) (vector-set! f195996 3 (make-string f195995)) (vector-set! f195996 4 0) (vector-set! f195996 5 f195995) f195996))
# emit-let
#  si   = 0
#  env  = ()
#  bindings = ((f195996 (make-vector 6)) (f195995 1024))
#  body = (begin (vector-set! f195996 0 ((primitive-ref string->symbol) "output-port")) (vector-set! f195996 1 "/dev/stdout") (vector-set! f195996 2 1) (vector-set! f195996 3 (make-string f195995)) (vector-set! f195996 4 0) (vector-set! f195996 5 f195995) f195996)
# emit-expr (make-vector 6)
# make-vector 6
# emit-expr 6
    movl $24, %eax     # immed 6
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1424601"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $128,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1424601:
# check the argument is a fixnum >= 0
    cmp $0,%eax
    jge _L_1424602
# invoke error handler eh_length
    .extern mrc_eh$ulength
    movl mrc_eh$ulength, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $128,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1424602:
    movl %eax, %esi
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    orl  $5, %eax
    addl $4, %esi
    addl $4, %esi
    andl $-8, %esi
    addl %esi, %ebp
    movl %eax, 0(%esp)  # stack save
# emit-expr 1024
    movl $4096, %eax     # immed 1024
    movl %eax, -4(%esp)  # stack save
# emit-expr (begin (vector-set! f195996 0 ((primitive-ref string->symbol) "output-port")) (vector-set! f195996 1 "/dev/stdout") (vector-set! f195996 2 1) (vector-set! f195996 3 (make-string f195995)) (vector-set! f195996 4 0) (vector-set! f195996 5 f195995) f195996)
# emit-begin
#   expr=(begin (vector-set! f195996 0 ((primitive-ref string->symbol) "output-port")) (vector-set! f195996 1 "/dev/stdout") (vector-set! f195996 2 1) (vector-set! f195996 3 (make-string f195995)) (vector-set! f195996 4 0) (vector-set! f195996 5 f195995) f195996)
#   env=((f195995 . -4) (f195996 . 0))
# emit-expr (vector-set! f195996 0 ((primitive-ref string->symbol) "output-port"))
# emit-expr f195996
# emit-variable-ref
# env=((f195995 . -4) (f195996 . 0))
# var=f195996
    movl 0(%esp), %eax  # stack load f195996
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1424603
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1424603:
    movl %eax, -8(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1424604"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1424604:
# check bounds on vector index
    movl -8(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1424606
    cmp  $0,%eax
    jge _L_1424605
_L_1424606:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1424605:
    movl %eax, -12(%esp)
# emit-expr ((primitive-ref string->symbol) "output-port")
# funcall
#    si   =-16
#    env  = ((f195995 . -4) (f195996 . 0))
#    expr = (funcall (primitive-ref string->symbol) "output-port")
# emit-expr (primitive-ref string->symbol)
    .extern mrc_string$m$gsymbol
    movl mrc_string$m$gsymbol,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1424607"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1424607":
   movl %eax,  -24(%esp)  # stash funcall-oper in closure slot
# emit-expr "output-port"
# string literal
    jmp _L_1424609
    .align 8,0x90
_L_1424608 :
    .int 44
    .ascii "output-port"
_L_1424609:
    movl $_L_1424608, %eax
    orl $6, %eax
    mov %eax, -28(%esp)  # arg output-port
    movl -24(%esp), %edi   # load new closure to %edi
    add $-16, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $16, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    movl -8(%esp), %ebx
    movl -12(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin (vector-set! f195996 1 "/dev/stdout") (vector-set! f195996 2 1) (vector-set! f195996 3 (make-string f195995)) (vector-set! f195996 4 0) (vector-set! f195996 5 f195995) f195996)
# emit-begin
#   expr=(begin (vector-set! f195996 1 "/dev/stdout") (vector-set! f195996 2 1) (vector-set! f195996 3 (make-string f195995)) (vector-set! f195996 4 0) (vector-set! f195996 5 f195995) f195996)
#   env=((f195995 . -4) (f195996 . 0))
# emit-expr (vector-set! f195996 1 "/dev/stdout")
# emit-expr f195996
# emit-variable-ref
# env=((f195995 . -4) (f195996 . 0))
# var=f195996
    movl 0(%esp), %eax  # stack load f195996
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1424610
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1424610:
    movl %eax, -8(%esp)
# emit-expr 1
    movl $4, %eax     # immed 1
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1424611"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1424611:
# check bounds on vector index
    movl -8(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1424613
    cmp  $0,%eax
    jge _L_1424612
_L_1424613:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1424612:
    movl %eax, -12(%esp)
# emit-expr "/dev/stdout"
# string literal
    jmp _L_1424615
    .align 8,0x90
_L_1424614 :
    .int 44
    .ascii "/dev/stdout"
_L_1424615:
    movl $_L_1424614, %eax
    orl $6, %eax
    movl -8(%esp), %ebx
    movl -12(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin (vector-set! f195996 2 1) (vector-set! f195996 3 (make-string f195995)) (vector-set! f195996 4 0) (vector-set! f195996 5 f195995) f195996)
# emit-begin
#   expr=(begin (vector-set! f195996 2 1) (vector-set! f195996 3 (make-string f195995)) (vector-set! f195996 4 0) (vector-set! f195996 5 f195995) f195996)
#   env=((f195995 . -4) (f195996 . 0))
# emit-expr (vector-set! f195996 2 1)
# emit-expr f195996
# emit-variable-ref
# env=((f195995 . -4) (f195996 . 0))
# var=f195996
    movl 0(%esp), %eax  # stack load f195996
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1424616
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1424616:
    movl %eax, -8(%esp)
# emit-expr 2
    movl $8, %eax     # immed 2
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1424617"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1424617:
# check bounds on vector index
    movl -8(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1424619
    cmp  $0,%eax
    jge _L_1424618
_L_1424619:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1424618:
    movl %eax, -12(%esp)
# emit-expr 1
    movl $4, %eax     # immed 1
    movl -8(%esp), %ebx
    movl -12(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin (vector-set! f195996 3 (make-string f195995)) (vector-set! f195996 4 0) (vector-set! f195996 5 f195995) f195996)
# emit-begin
#   expr=(begin (vector-set! f195996 3 (make-string f195995)) (vector-set! f195996 4 0) (vector-set! f195996 5 f195995) f195996)
#   env=((f195995 . -4) (f195996 . 0))
# emit-expr (vector-set! f195996 3 (make-string f195995))
# emit-expr f195996
# emit-variable-ref
# env=((f195995 . -4) (f195996 . 0))
# var=f195996
    movl 0(%esp), %eax  # stack load f195996
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1424620
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1424620:
    movl %eax, -8(%esp)
# emit-expr 3
    movl $12, %eax     # immed 3
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1424621"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1424621:
# check bounds on vector index
    movl -8(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1424623
    cmp  $0,%eax
    jge _L_1424622
_L_1424623:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1424622:
    movl %eax, -12(%esp)
# emit-expr (make-string f195995)
# make-string len=f195995
# emit-expr f195995
# emit-variable-ref
# env=((f195995 . -4) (f195996 . 0))
# var=f195995
    movl -4(%esp), %eax  # stack load f195995
# end emit-variable-ref
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1424624"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1424624:
# check the argument is a fixnum >= 0
    cmp $0,%eax
    jge _L_1424625
# invoke error handler eh_length
    .extern mrc_eh$ulength
    movl mrc_eh$ulength, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1424625:
    movl %eax, %esi
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    orl $6, %eax
    sar $2, %esi
    add $4, %esi
    add $7, %esi
    andl $-8, %esi
    add  %esi, %ebp
# make-string end
    movl -8(%esp), %ebx
    movl -12(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin (vector-set! f195996 4 0) (vector-set! f195996 5 f195995) f195996)
# emit-begin
#   expr=(begin (vector-set! f195996 4 0) (vector-set! f195996 5 f195995) f195996)
#   env=((f195995 . -4) (f195996 . 0))
# emit-expr (vector-set! f195996 4 0)
# emit-expr f195996
# emit-variable-ref
# env=((f195995 . -4) (f195996 . 0))
# var=f195996
    movl 0(%esp), %eax  # stack load f195996
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1424626
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1424626:
    movl %eax, -8(%esp)
# emit-expr 4
    movl $16, %eax     # immed 4
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1424627"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1424627:
# check bounds on vector index
    movl -8(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1424629
    cmp  $0,%eax
    jge _L_1424628
_L_1424629:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1424628:
    movl %eax, -12(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
    movl -8(%esp), %ebx
    movl -12(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin (vector-set! f195996 5 f195995) f195996)
# emit-begin
#   expr=(begin (vector-set! f195996 5 f195995) f195996)
#   env=((f195995 . -4) (f195996 . 0))
# emit-expr (vector-set! f195996 5 f195995)
# emit-expr f195996
# emit-variable-ref
# env=((f195995 . -4) (f195996 . 0))
# var=f195996
    movl 0(%esp), %eax  # stack load f195996
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1424630
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1424630:
    movl %eax, -8(%esp)
# emit-expr 5
    movl $20, %eax     # immed 5
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1424631"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1424631:
# check bounds on vector index
    movl -8(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1424633
    cmp  $0,%eax
    jge _L_1424632
_L_1424633:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1424632:
    movl %eax, -12(%esp)
# emit-expr f195995
# emit-variable-ref
# env=((f195995 . -4) (f195996 . 0))
# var=f195995
    movl -4(%esp), %eax  # stack load f195995
# end emit-variable-ref
    movl -8(%esp), %ebx
    movl -12(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin f195996)
# emit-begin
#   expr=(begin f195996)
#   env=((f195995 . -4) (f195996 . 0))
# emit-expr f195996
# emit-variable-ref
# env=((f195995 . -4) (f195996 . 0))
# var=f195996
    movl 0(%esp), %eax  # stack load f195996
# end emit-variable-ref
# emit-expr (begin)
# emit-begin
#   expr=(begin)
#   env=((f195995 . -4) (f195996 . 0))
     movl %eax, mrc_standard$mout
# == explicit-begins  ==>
# (let ((current-out standard-out)) (lambda () current-out))
# == eliminate-let*  ==>
# (let ((current-out standard-out)) (lambda () current-out))
# == uniquify-variables  ==>
# (let ((f195997 standard-out)) (lambda () f195997))
# == vectorize-letrec  ==>
# (let ((f195997 standard-out)) (lambda () f195997))
# == eliminate-set!  ==>
# (let ((f195997 standard-out)) (lambda () (let () f195997)))
# == close-free-variables  ==>
# (let ((f195997 standard-out)) (closure () (f195997) (let () f195997)))
# == eliminate-quote  ==>
# (let ((f195997 standard-out)) (closure () (f195997) (let () f195997)))
# == eliminate-when/unless  ==>
# (let ((f195997 standard-out)) (closure () (f195997) (let () f195997)))
# == eliminate-cond  ==>
# (let ((f195997 standard-out)) (closure () (f195997) (let () f195997)))
# == external-symbols  ==>
# (let ((f195997 (primitive-ref standard-out))) (closure () (f195997) (let () f195997)))
# emit-expr (let ((f195997 (primitive-ref standard-out))) (closure () (f195997) (let () f195997)))
# emit-let
#  si   = 0
#  env  = ()
#  bindings = ((f195997 (primitive-ref standard-out)))
#  body = (closure () (f195997) (let () f195997))
# emit-expr (primitive-ref standard-out)
    .extern mrc_standard$mout
    movl mrc_standard$mout,%eax
    movl %eax, 0(%esp)  # stack save
# emit-expr (closure () (f195997) (let () f195997))
# emit-closure
# si = -4
# env = ((f195997 . 0))
# expr = (closure () (f195997) (let () f195997))
    movl $_L_1424634, 0(%ebp)  # closure label
# emit-variable-ref
# env=((f195997 . 0))
# var=f195997
    movl 0(%esp), %eax  # stack load f195997
# end emit-variable-ref
   movl  %eax, 4(%ebp)  # f195997
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $8, %ebp     # bump ebp
    jmp _L_1424635            # jump around closure body
_L_1424634:
# check argument count
    cmp $0,%eax
    je _L_1424636
# invoke error handler eh_argcount
    .extern mrc_eh$uargcount
    movl mrc_eh$uargcount, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_1424636:
# emit-tail-expr
# si=-8
# env=((f195997 . 4) (f195997 . 0))
# expr=(let () f195997)
# emit-tail-let
#  si   = -8
#  env  = ((f195997 . 4) (f195997 . 0))
#  bindings = ()
#  body = f195997
# emit-tail-expr
# si=-8
# env=((f195997 . 4) (f195997 . 0))
# expr=f195997
# emit-tail-variable-ref
# emit-variable-ref
# env=((f195997 . 4) (f195997 . 0))
# var=f195997
    movl 2(%edi), %eax  # frame load f195997
# end emit-variable-ref
    ret
# end emit-tail-variable ref
    .align 4,0x90
_L_1424635:
     movl %eax, mrc_current$moutput$mport
# == explicit-begins  ==>
# (lambda (p) (vector-ref p 2))
# == eliminate-let*  ==>
# (lambda (p) (vector-ref p 2))
# == uniquify-variables  ==>
# (lambda (f195998) (vector-ref f195998 2))
# == vectorize-letrec  ==>
# (lambda (f195998) (vector-ref f195998 2))
# == eliminate-set!  ==>
# (lambda (f195998) (let ((f195998 f195998)) (vector-ref f195998 2)))
# == close-free-variables  ==>
# (closure (f195998) () (let ((f195998 f195998)) (vector-ref f195998 2)))
# == eliminate-quote  ==>
# (closure (f195998) () (let ((f195998 f195998)) (vector-ref f195998 2)))
# == eliminate-when/unless  ==>
# (closure (f195998) () (let ((f195998 f195998)) (vector-ref f195998 2)))
# == eliminate-cond  ==>
# (closure (f195998) () (let ((f195998 f195998)) (vector-ref f195998 2)))
# == external-symbols  ==>
# (closure (f195998) () (let ((f195998 f195998)) (vector-ref f195998 2)))
# emit-expr (closure (f195998) () (let ((f195998 f195998)) (vector-ref f195998 2)))
# emit-closure
# si = 0
# env = ()
# expr = (closure (f195998) () (let ((f195998 f195998)) (vector-ref f195998 2)))
    movl $_L_1424637, 0(%ebp)  # closure label
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $8, %ebp     # bump ebp
    jmp _L_1424638            # jump around closure body
_L_1424637:
# check argument count
    cmp $4,%eax
    je _L_1424639
# invoke error handler eh_argcount
    .extern mrc_eh$uargcount
    movl mrc_eh$uargcount, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_1424639:
# emit-tail-expr
# si=-12
# env=((f195998 . -8))
# expr=(let ((f195998 f195998)) (vector-ref f195998 2))
# emit-tail-let
#  si   = -12
#  env  = ((f195998 . -8))
#  bindings = ((f195998 f195998))
#  body = (vector-ref f195998 2)
# emit-expr f195998
# emit-variable-ref
# env=((f195998 . -8))
# var=f195998
    movl -8(%esp), %eax  # stack load f195998
# end emit-variable-ref
    movl %eax, -12(%esp)  # stack save
# emit-tail-expr
# si=-16
# env=((f195998 . -12) (f195998 . -8))
# expr=(vector-ref f195998 2)
# tail primcall
# emit-expr f195998
# emit-variable-ref
# env=((f195998 . -12) (f195998 . -8))
# var=f195998
    movl -12(%esp), %eax  # stack load f195998
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1424640
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1424640:
    movl %eax, -16(%esp)
# emit-expr 2
    movl $8, %eax     # immed 2
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1424641"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1424641:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1424643
    cmp  $0,%eax
    jge _L_1424642
_L_1424643:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1424642:
    movl -16(%esp), %esi
    movl -1(%eax,%esi), %eax
#return from tail (vector-ref f195998 2)
    ret
    .align 4,0x90
_L_1424638:
     movl %eax, mrc_port$mfd
# == explicit-begins  ==>
# (lambda (p) (vector-ref p 3))
# == eliminate-let*  ==>
# (lambda (p) (vector-ref p 3))
# == uniquify-variables  ==>
# (lambda (f195999) (vector-ref f195999 3))
# == vectorize-letrec  ==>
# (lambda (f195999) (vector-ref f195999 3))
# == eliminate-set!  ==>
# (lambda (f195999) (let ((f195999 f195999)) (vector-ref f195999 3)))
# == close-free-variables  ==>
# (closure (f195999) () (let ((f195999 f195999)) (vector-ref f195999 3)))
# == eliminate-quote  ==>
# (closure (f195999) () (let ((f195999 f195999)) (vector-ref f195999 3)))
# == eliminate-when/unless  ==>
# (closure (f195999) () (let ((f195999 f195999)) (vector-ref f195999 3)))
# == eliminate-cond  ==>
# (closure (f195999) () (let ((f195999 f195999)) (vector-ref f195999 3)))
# == external-symbols  ==>
# (closure (f195999) () (let ((f195999 f195999)) (vector-ref f195999 3)))
# emit-expr (closure (f195999) () (let ((f195999 f195999)) (vector-ref f195999 3)))
# emit-closure
# si = 0
# env = ()
# expr = (closure (f195999) () (let ((f195999 f195999)) (vector-ref f195999 3)))
    movl $_L_1424644, 0(%ebp)  # closure label
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $8, %ebp     # bump ebp
    jmp _L_1424645            # jump around closure body
_L_1424644:
# check argument count
    cmp $4,%eax
    je _L_1424646
# invoke error handler eh_argcount
    .extern mrc_eh$uargcount
    movl mrc_eh$uargcount, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_1424646:
# emit-tail-expr
# si=-12
# env=((f195999 . -8))
# expr=(let ((f195999 f195999)) (vector-ref f195999 3))
# emit-tail-let
#  si   = -12
#  env  = ((f195999 . -8))
#  bindings = ((f195999 f195999))
#  body = (vector-ref f195999 3)
# emit-expr f195999
# emit-variable-ref
# env=((f195999 . -8))
# var=f195999
    movl -8(%esp), %eax  # stack load f195999
# end emit-variable-ref
    movl %eax, -12(%esp)  # stack save
# emit-tail-expr
# si=-16
# env=((f195999 . -12) (f195999 . -8))
# expr=(vector-ref f195999 3)
# tail primcall
# emit-expr f195999
# emit-variable-ref
# env=((f195999 . -12) (f195999 . -8))
# var=f195999
    movl -12(%esp), %eax  # stack load f195999
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1424647
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1424647:
    movl %eax, -16(%esp)
# emit-expr 3
    movl $12, %eax     # immed 3
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1424648"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1424648:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1424650
    cmp  $0,%eax
    jge _L_1424649
_L_1424650:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1424649:
    movl -16(%esp), %esi
    movl -1(%eax,%esi), %eax
#return from tail (vector-ref f195999 3)
    ret
    .align 4,0x90
_L_1424645:
     movl %eax, mrc_port$mbuf
# == explicit-begins  ==>
# (lambda (p) (vector-ref p 4))
# == eliminate-let*  ==>
# (lambda (p) (vector-ref p 4))
# == uniquify-variables  ==>
# (lambda (f196000) (vector-ref f196000 4))
# == vectorize-letrec  ==>
# (lambda (f196000) (vector-ref f196000 4))
# == eliminate-set!  ==>
# (lambda (f196000) (let ((f196000 f196000)) (vector-ref f196000 4)))
# == close-free-variables  ==>
# (closure (f196000) () (let ((f196000 f196000)) (vector-ref f196000 4)))
# == eliminate-quote  ==>
# (closure (f196000) () (let ((f196000 f196000)) (vector-ref f196000 4)))
# == eliminate-when/unless  ==>
# (closure (f196000) () (let ((f196000 f196000)) (vector-ref f196000 4)))
# == eliminate-cond  ==>
# (closure (f196000) () (let ((f196000 f196000)) (vector-ref f196000 4)))
# == external-symbols  ==>
# (closure (f196000) () (let ((f196000 f196000)) (vector-ref f196000 4)))
# emit-expr (closure (f196000) () (let ((f196000 f196000)) (vector-ref f196000 4)))
# emit-closure
# si = 0
# env = ()
# expr = (closure (f196000) () (let ((f196000 f196000)) (vector-ref f196000 4)))
    movl $_L_1424651, 0(%ebp)  # closure label
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $8, %ebp     # bump ebp
    jmp _L_1424652            # jump around closure body
_L_1424651:
# check argument count
    cmp $4,%eax
    je _L_1424653
# invoke error handler eh_argcount
    .extern mrc_eh$uargcount
    movl mrc_eh$uargcount, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_1424653:
# emit-tail-expr
# si=-12
# env=((f196000 . -8))
# expr=(let ((f196000 f196000)) (vector-ref f196000 4))
# emit-tail-let
#  si   = -12
#  env  = ((f196000 . -8))
#  bindings = ((f196000 f196000))
#  body = (vector-ref f196000 4)
# emit-expr f196000
# emit-variable-ref
# env=((f196000 . -8))
# var=f196000
    movl -8(%esp), %eax  # stack load f196000
# end emit-variable-ref
    movl %eax, -12(%esp)  # stack save
# emit-tail-expr
# si=-16
# env=((f196000 . -12) (f196000 . -8))
# expr=(vector-ref f196000 4)
# tail primcall
# emit-expr f196000
# emit-variable-ref
# env=((f196000 . -12) (f196000 . -8))
# var=f196000
    movl -12(%esp), %eax  # stack load f196000
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1424654
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1424654:
    movl %eax, -16(%esp)
# emit-expr 4
    movl $16, %eax     # immed 4
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1424655"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1424655:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1424657
    cmp  $0,%eax
    jge _L_1424656
_L_1424657:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1424656:
    movl -16(%esp), %esi
    movl -1(%eax,%esi), %eax
#return from tail (vector-ref f196000 4)
    ret
    .align 4,0x90
_L_1424652:
     movl %eax, mrc_port$mndx
# == explicit-begins  ==>
# (lambda (p) (vector-set! p 4 (fxadd1 (vector-ref p 4))))
# == eliminate-let*  ==>
# (lambda (p) (vector-set! p 4 (fxadd1 (vector-ref p 4))))
# == uniquify-variables  ==>
# (lambda (f196001) (vector-set! f196001 4 (fxadd1 (vector-ref f196001 4))))
# == vectorize-letrec  ==>
# (lambda (f196001) (vector-set! f196001 4 (fxadd1 (vector-ref f196001 4))))
# == eliminate-set!  ==>
# (lambda (f196001) (let ((f196001 f196001)) (vector-set! f196001 4 (fxadd1 (vector-ref f196001 4)))))
# == close-free-variables  ==>
# (closure (f196001) () (let ((f196001 f196001)) (vector-set! f196001 4 (fxadd1 (vector-ref f196001 4)))))
# == eliminate-quote  ==>
# (closure (f196001) () (let ((f196001 f196001)) (vector-set! f196001 4 (fxadd1 (vector-ref f196001 4)))))
# == eliminate-when/unless  ==>
# (closure (f196001) () (let ((f196001 f196001)) (vector-set! f196001 4 (fxadd1 (vector-ref f196001 4)))))
# == eliminate-cond  ==>
# (closure (f196001) () (let ((f196001 f196001)) (vector-set! f196001 4 (fxadd1 (vector-ref f196001 4)))))
# == external-symbols  ==>
# (closure (f196001) () (let ((f196001 f196001)) (vector-set! f196001 4 (fxadd1 (vector-ref f196001 4)))))
# emit-expr (closure (f196001) () (let ((f196001 f196001)) (vector-set! f196001 4 (fxadd1 (vector-ref f196001 4)))))
# emit-closure
# si = 0
# env = ()
# expr = (closure (f196001) () (let ((f196001 f196001)) (vector-set! f196001 4 (fxadd1 (vector-ref f196001 4)))))
    movl $_L_1424658, 0(%ebp)  # closure label
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $8, %ebp     # bump ebp
    jmp _L_1424659            # jump around closure body
_L_1424658:
# check argument count
    cmp $4,%eax
    je _L_1424660
# invoke error handler eh_argcount
    .extern mrc_eh$uargcount
    movl mrc_eh$uargcount, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_1424660:
# emit-tail-expr
# si=-12
# env=((f196001 . -8))
# expr=(let ((f196001 f196001)) (vector-set! f196001 4 (fxadd1 (vector-ref f196001 4))))
# emit-tail-let
#  si   = -12
#  env  = ((f196001 . -8))
#  bindings = ((f196001 f196001))
#  body = (vector-set! f196001 4 (fxadd1 (vector-ref f196001 4)))
# emit-expr f196001
# emit-variable-ref
# env=((f196001 . -8))
# var=f196001
    movl -8(%esp), %eax  # stack load f196001
# end emit-variable-ref
    movl %eax, -12(%esp)  # stack save
# emit-tail-expr
# si=-16
# env=((f196001 . -12) (f196001 . -8))
# expr=(vector-set! f196001 4 (fxadd1 (vector-ref f196001 4)))
# tail primcall
# emit-expr f196001
# emit-variable-ref
# env=((f196001 . -12) (f196001 . -8))
# var=f196001
    movl -12(%esp), %eax  # stack load f196001
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1424661
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1424661:
    movl %eax, -16(%esp)
# emit-expr 4
    movl $16, %eax     # immed 4
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1424662"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1424662:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1424664
    cmp  $0,%eax
    jge _L_1424663
_L_1424664:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1424663:
    movl %eax, -20(%esp)
# emit-expr (fxadd1 (vector-ref f196001 4))
# emit-expr (vector-ref f196001 4)
# emit-expr f196001
# emit-variable-ref
# env=((f196001 . -12) (f196001 . -8))
# var=f196001
    movl -12(%esp), %eax  # stack load f196001
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1424665
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1424665:
    movl %eax, -24(%esp)
# emit-expr 4
    movl $16, %eax     # immed 4
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1424666"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1424666:
# check bounds on vector index
    movl -24(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1424668
    cmp  $0,%eax
    jge _L_1424667
_L_1424668:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1424667:
    movl -24(%esp), %esi
    movl -1(%eax,%esi), %eax
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1424669"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $48,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1424669:
     addl $4, %eax
    movl -16(%esp), %ebx
    movl -20(%esp), %esi
    movl %eax, -1(%ebx,%esi)
#return from tail (vector-set! f196001 4 (fxadd1 (vector-ref f196001 4)))
    ret
    .align 4,0x90
_L_1424659:
     movl %eax, mrc_port$mndx$madd1
# == explicit-begins  ==>
# (lambda (p) (vector-set! p 4 0))
# == eliminate-let*  ==>
# (lambda (p) (vector-set! p 4 0))
# == uniquify-variables  ==>
# (lambda (f196002) (vector-set! f196002 4 0))
# == vectorize-letrec  ==>
# (lambda (f196002) (vector-set! f196002 4 0))
# == eliminate-set!  ==>
# (lambda (f196002) (let ((f196002 f196002)) (vector-set! f196002 4 0)))
# == close-free-variables  ==>
# (closure (f196002) () (let ((f196002 f196002)) (vector-set! f196002 4 0)))
# == eliminate-quote  ==>
# (closure (f196002) () (let ((f196002 f196002)) (vector-set! f196002 4 0)))
# == eliminate-when/unless  ==>
# (closure (f196002) () (let ((f196002 f196002)) (vector-set! f196002 4 0)))
# == eliminate-cond  ==>
# (closure (f196002) () (let ((f196002 f196002)) (vector-set! f196002 4 0)))
# == external-symbols  ==>
# (closure (f196002) () (let ((f196002 f196002)) (vector-set! f196002 4 0)))
# emit-expr (closure (f196002) () (let ((f196002 f196002)) (vector-set! f196002 4 0)))
# emit-closure
# si = 0
# env = ()
# expr = (closure (f196002) () (let ((f196002 f196002)) (vector-set! f196002 4 0)))
    movl $_L_1424670, 0(%ebp)  # closure label
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $8, %ebp     # bump ebp
    jmp _L_1424671            # jump around closure body
_L_1424670:
# check argument count
    cmp $4,%eax
    je _L_1424672
# invoke error handler eh_argcount
    .extern mrc_eh$uargcount
    movl mrc_eh$uargcount, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_1424672:
# emit-tail-expr
# si=-12
# env=((f196002 . -8))
# expr=(let ((f196002 f196002)) (vector-set! f196002 4 0))
# emit-tail-let
#  si   = -12
#  env  = ((f196002 . -8))
#  bindings = ((f196002 f196002))
#  body = (vector-set! f196002 4 0)
# emit-expr f196002
# emit-variable-ref
# env=((f196002 . -8))
# var=f196002
    movl -8(%esp), %eax  # stack load f196002
# end emit-variable-ref
    movl %eax, -12(%esp)  # stack save
# emit-tail-expr
# si=-16
# env=((f196002 . -12) (f196002 . -8))
# expr=(vector-set! f196002 4 0)
# tail primcall
# emit-expr f196002
# emit-variable-ref
# env=((f196002 . -12) (f196002 . -8))
# var=f196002
    movl -12(%esp), %eax  # stack load f196002
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1424673
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1424673:
    movl %eax, -16(%esp)
# emit-expr 4
    movl $16, %eax     # immed 4
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1424674"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1424674:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1424676
    cmp  $0,%eax
    jge _L_1424675
_L_1424676:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1424675:
    movl %eax, -20(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
    movl -16(%esp), %ebx
    movl -20(%esp), %esi
    movl %eax, -1(%ebx,%esi)
#return from tail (vector-set! f196002 4 0)
    ret
    .align 4,0x90
_L_1424671:
     movl %eax, mrc_port$mndx$mreset
# == explicit-begins  ==>
# (lambda (p) (vector-ref p 5))
# == eliminate-let*  ==>
# (lambda (p) (vector-ref p 5))
# == uniquify-variables  ==>
# (lambda (f196003) (vector-ref f196003 5))
# == vectorize-letrec  ==>
# (lambda (f196003) (vector-ref f196003 5))
# == eliminate-set!  ==>
# (lambda (f196003) (let ((f196003 f196003)) (vector-ref f196003 5)))
# == close-free-variables  ==>
# (closure (f196003) () (let ((f196003 f196003)) (vector-ref f196003 5)))
# == eliminate-quote  ==>
# (closure (f196003) () (let ((f196003 f196003)) (vector-ref f196003 5)))
# == eliminate-when/unless  ==>
# (closure (f196003) () (let ((f196003 f196003)) (vector-ref f196003 5)))
# == eliminate-cond  ==>
# (closure (f196003) () (let ((f196003 f196003)) (vector-ref f196003 5)))
# == external-symbols  ==>
# (closure (f196003) () (let ((f196003 f196003)) (vector-ref f196003 5)))
# emit-expr (closure (f196003) () (let ((f196003 f196003)) (vector-ref f196003 5)))
# emit-closure
# si = 0
# env = ()
# expr = (closure (f196003) () (let ((f196003 f196003)) (vector-ref f196003 5)))
    movl $_L_1424677, 0(%ebp)  # closure label
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $8, %ebp     # bump ebp
    jmp _L_1424678            # jump around closure body
_L_1424677:
# check argument count
    cmp $4,%eax
    je _L_1424679
# invoke error handler eh_argcount
    .extern mrc_eh$uargcount
    movl mrc_eh$uargcount, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_1424679:
# emit-tail-expr
# si=-12
# env=((f196003 . -8))
# expr=(let ((f196003 f196003)) (vector-ref f196003 5))
# emit-tail-let
#  si   = -12
#  env  = ((f196003 . -8))
#  bindings = ((f196003 f196003))
#  body = (vector-ref f196003 5)
# emit-expr f196003
# emit-variable-ref
# env=((f196003 . -8))
# var=f196003
    movl -8(%esp), %eax  # stack load f196003
# end emit-variable-ref
    movl %eax, -12(%esp)  # stack save
# emit-tail-expr
# si=-16
# env=((f196003 . -12) (f196003 . -8))
# expr=(vector-ref f196003 5)
# tail primcall
# emit-expr f196003
# emit-variable-ref
# env=((f196003 . -12) (f196003 . -8))
# var=f196003
    movl -12(%esp), %eax  # stack load f196003
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1424680
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1424680:
    movl %eax, -16(%esp)
# emit-expr 5
    movl $20, %eax     # immed 5
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1424681"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1424681:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1424683
    cmp  $0,%eax
    jge _L_1424682
_L_1424683:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1424682:
    movl -16(%esp), %esi
    movl -1(%eax,%esi), %eax
#return from tail (vector-ref f196003 5)
    ret
    .align 4,0x90
_L_1424678:
     movl %eax, mrc_port$msize
# == explicit-begins  ==>
# (lambda (ch) (let ((p (current-output-port))) (begin (string-set! (port-buf p) (port-ndx p) ch) (port-ndx-add1 p))))
# == eliminate-let*  ==>
# (lambda (ch) (let ((p (current-output-port))) (begin (string-set! (port-buf p) (port-ndx p) ch) (port-ndx-add1 p))))
# == uniquify-variables  ==>
# (lambda (f196004) (let ((f196006 (current-output-port))) (begin (string-set! (port-buf f196006) (port-ndx f196006) f196004) (port-ndx-add1 f196006))))
# == vectorize-letrec  ==>
# (lambda (f196004) (let ((f196006 (current-output-port))) (begin (string-set! (port-buf f196006) (port-ndx f196006) f196004) (port-ndx-add1 f196006))))
# == eliminate-set!  ==>
# (lambda (f196004) (let ((f196004 f196004)) (let ((f196006 (current-output-port))) (begin (string-set! (port-buf f196006) (port-ndx f196006) f196004) (port-ndx-add1 f196006)))))
# == close-free-variables  ==>
# (closure (f196004) (port-buf port-ndx port-ndx-add1) (let ((f196004 f196004)) (let ((f196006 (current-output-port))) (begin (string-set! (port-buf f196006) (port-ndx f196006) f196004) (port-ndx-add1 f196006)))))
# == eliminate-quote  ==>
# (closure (f196004) (port-buf port-ndx port-ndx-add1) (let ((f196004 f196004)) (let ((f196006 (current-output-port))) (begin (string-set! (port-buf f196006) (port-ndx f196006) f196004) (port-ndx-add1 f196006)))))
# == eliminate-when/unless  ==>
# (closure (f196004) (port-buf port-ndx port-ndx-add1) (let ((f196004 f196004)) (let ((f196006 (current-output-port))) (begin (string-set! (port-buf f196006) (port-ndx f196006) f196004) (port-ndx-add1 f196006)))))
# == eliminate-cond  ==>
# (closure (f196004) (port-buf port-ndx port-ndx-add1) (let ((f196004 f196004)) (let ((f196006 (current-output-port))) (begin (string-set! (port-buf f196006) (port-ndx f196006) f196004) (port-ndx-add1 f196006)))))
# == external-symbols  ==>
# (closure (f196004) ((primitive-ref port-buf) (primitive-ref port-ndx) (primitive-ref port-ndx-add1)) (let ((f196004 f196004)) (let ((f196006 ((primitive-ref current-output-port)))) (begin (string-set! ((primitive-ref port-buf) f196006) ((primitive-ref port-ndx) f196006) f196004) ((primitive-ref port-ndx-add1) f196006)))))
# emit-expr (closure (f196004) ((primitive-ref port-buf) (primitive-ref port-ndx) (primitive-ref port-ndx-add1)) (let ((f196004 f196004)) (let ((f196006 ((primitive-ref current-output-port)))) (begin (string-set! ((primitive-ref port-buf) f196006) ((primitive-ref port-ndx) f196006) f196004) ((primitive-ref port-ndx-add1) f196006)))))
# emit-closure
# si = 0
# env = ()
# expr = (closure (f196004) ((primitive-ref port-buf) (primitive-ref port-ndx) (primitive-ref port-ndx-add1)) (let ((f196004 f196004)) (let ((f196006 ((primitive-ref current-output-port)))) (begin (string-set! ((primitive-ref port-buf) f196006) ((primitive-ref port-ndx) f196006) f196004) ((primitive-ref port-ndx-add1) f196006)))))
    movl $_L_1424684, 0(%ebp)  # closure label
# WARNING: free var (primitive-ref port-buf) not defined in the environmnet
# WARNING: free var (primitive-ref port-ndx) not defined in the environmnet
# WARNING: free var (primitive-ref port-ndx-add1) not defined in the environmnet
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $16, %ebp     # bump ebp
    jmp _L_1424685            # jump around closure body
_L_1424684:
# check argument count
    cmp $4,%eax
    je _L_1424686
# invoke error handler eh_argcount
    .extern mrc_eh$uargcount
    movl mrc_eh$uargcount, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_1424686:
# emit-tail-expr
# si=-12
# env=((f196004 . -8) ((primitive-ref port-ndx-add1) . 12) ((primitive-ref port-ndx) . 8) ((primitive-ref port-buf) . 4))
# expr=(let ((f196004 f196004)) (let ((f196006 ((primitive-ref current-output-port)))) (begin (string-set! ((primitive-ref port-buf) f196006) ((primitive-ref port-ndx) f196006) f196004) ((primitive-ref port-ndx-add1) f196006))))
# emit-tail-let
#  si   = -12
#  env  = ((f196004 . -8) ((primitive-ref port-ndx-add1) . 12) ((primitive-ref port-ndx) . 8) ((primitive-ref port-buf) . 4))
#  bindings = ((f196004 f196004))
#  body = (let ((f196006 ((primitive-ref current-output-port)))) (begin (string-set! ((primitive-ref port-buf) f196006) ((primitive-ref port-ndx) f196006) f196004) ((primitive-ref port-ndx-add1) f196006)))
# emit-expr f196004
# emit-variable-ref
# env=((f196004 . -8) ((primitive-ref port-ndx-add1) . 12) ((primitive-ref port-ndx) . 8) ((primitive-ref port-buf) . 4))
# var=f196004
    movl -8(%esp), %eax  # stack load f196004
# end emit-variable-ref
    movl %eax, -12(%esp)  # stack save
# emit-tail-expr
# si=-16
# env=((f196004 . -12) (f196004 . -8) ((primitive-ref port-ndx-add1) . 12) ((primitive-ref port-ndx) . 8) ((primitive-ref port-buf) . 4))
# expr=(let ((f196006 ((primitive-ref current-output-port)))) (begin (string-set! ((primitive-ref port-buf) f196006) ((primitive-ref port-ndx) f196006) f196004) ((primitive-ref port-ndx-add1) f196006)))
# emit-tail-let
#  si   = -16
#  env  = ((f196004 . -12) (f196004 . -8) ((primitive-ref port-ndx-add1) . 12) ((primitive-ref port-ndx) . 8) ((primitive-ref port-buf) . 4))
#  bindings = ((f196006 ((primitive-ref current-output-port))))
#  body = (begin (string-set! ((primitive-ref port-buf) f196006) ((primitive-ref port-ndx) f196006) f196004) ((primitive-ref port-ndx-add1) f196006))
# emit-expr ((primitive-ref current-output-port))
# funcall
#    si   =-16
#    env  = ((f196004 . -12) (f196004 . -8) ((primitive-ref port-ndx-add1) . 12) ((primitive-ref port-ndx) . 8) ((primitive-ref port-buf) . 4))
#    expr = (funcall (primitive-ref current-output-port))
# emit-expr (primitive-ref current-output-port)
    .extern mrc_current$moutput$mport
    movl mrc_current$moutput$mport,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1424687"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1424687":
   movl %eax,  -24(%esp)  # stash funcall-oper in closure slot
    movl -24(%esp), %edi   # load new closure to %edi
    add $-16, %esp   # adjust base
    movl $0,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $16, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    movl %eax, -16(%esp)  # stack save
# emit-tail-expr
# si=-20
# env=((f196006 . -16) (f196004 . -12) (f196004 . -8) ((primitive-ref port-ndx-add1) . 12) ((primitive-ref port-ndx) . 8) ((primitive-ref port-buf) . 4))
# expr=(begin (string-set! ((primitive-ref port-buf) f196006) ((primitive-ref port-ndx) f196006) f196004) ((primitive-ref port-ndx-add1) f196006))
# tail-begin (begin (string-set! ((primitive-ref port-buf) f196006) ((primitive-ref port-ndx) f196006) f196004) ((primitive-ref port-ndx-add1) f196006))
#   env=((f196006 . -16) (f196004 . -12) (f196004 . -8) ((primitive-ref port-ndx-add1) . 12) ((primitive-ref port-ndx) . 8) ((primitive-ref port-buf) . 4))
# emit-expr (string-set! ((primitive-ref port-buf) f196006) ((primitive-ref port-ndx) f196006) f196004)
# emit-expr ((primitive-ref port-buf) f196006)
# funcall
#    si   =-20
#    env  = ((f196006 . -16) (f196004 . -12) (f196004 . -8) ((primitive-ref port-ndx-add1) . 12) ((primitive-ref port-ndx) . 8) ((primitive-ref port-buf) . 4))
#    expr = (funcall (primitive-ref port-buf) f196006)
# emit-expr (primitive-ref port-buf)
    .extern mrc_port$mbuf
    movl mrc_port$mbuf,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1424688"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1424688":
   movl %eax,  -28(%esp)  # stash funcall-oper in closure slot
# emit-expr f196006
# emit-variable-ref
# env=((f196006 . -16) (f196004 . -12) (f196004 . -8) ((primitive-ref port-ndx-add1) . 12) ((primitive-ref port-ndx) . 8) ((primitive-ref port-buf) . 4))
# var=f196006
    movl -16(%esp), %eax  # stack load f196006
# end emit-variable-ref
    mov %eax, -32(%esp)  # arg f196006
    movl -28(%esp), %edi   # load new closure to %edi
    add $-20, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $20, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
# check the argument is a string
    movl %eax,%ebx
    and $7, %bl
    cmp $6, %bl
    je _L_1424689
# invoke error handler eh_string
    .extern mrc_eh$ustring
    movl mrc_eh$ustring, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $160,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1424689:
    movl %eax, -20(%esp)
# emit-expr ((primitive-ref port-ndx) f196006)
# funcall
#    si   =-20
#    env  = ((f196006 . -16) (f196004 . -12) (f196004 . -8) ((primitive-ref port-ndx-add1) . 12) ((primitive-ref port-ndx) . 8) ((primitive-ref port-buf) . 4))
#    expr = (funcall (primitive-ref port-ndx) f196006)
# emit-expr (primitive-ref port-ndx)
    .extern mrc_port$mndx
    movl mrc_port$mndx,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1424690"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1424690":
   movl %eax,  -28(%esp)  # stash funcall-oper in closure slot
# emit-expr f196006
# emit-variable-ref
# env=((f196006 . -16) (f196004 . -12) (f196004 . -8) ((primitive-ref port-ndx-add1) . 12) ((primitive-ref port-ndx) . 8) ((primitive-ref port-buf) . 4))
# var=f196006
    movl -16(%esp), %eax  # stack load f196006
# end emit-variable-ref
    mov %eax, -32(%esp)  # arg f196006
    movl -28(%esp), %edi   # load new closure to %edi
    add $-20, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $20, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1424691"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $160,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1424691:
# check bounds on string index
    movl -20(%esp), %ebx
    cmp  %eax,-6(%ebx) 
    jle _L_1424693
    cmp  $0,%eax
    jge _L_1424692
_L_1424693:
# invoke error handler eh_string_index
    .extern mrc_eh$ustring$uindex
    movl mrc_eh$ustring$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $160,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1424692:
    movl %eax, -24(%esp)
# emit-expr f196004
# emit-variable-ref
# env=((f196006 . -16) (f196004 . -12) (f196004 . -8) ((primitive-ref port-ndx-add1) . 12) ((primitive-ref port-ndx) . 8) ((primitive-ref port-buf) . 4))
# var=f196004
    movl -12(%esp), %eax  # stack load f196004
# end emit-variable-ref
# check the argument is a char
    movl %eax,%ebx
    and $255, %bl
    cmp $15, %bl
    je "_L_1424694"
# invoke error handler eh_character
    .extern mrc_eh$ucharacter
    movl mrc_eh$ucharacter, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $160,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1424694:
    movl -20(%esp), %ebx
    movl -24(%esp), %esi
    sar $2, %esi
    movb  %ah, -2(%ebx,%esi)
# emit-tail-expr
# si=-20
# env=((f196006 . -16) (f196004 . -12) (f196004 . -8) ((primitive-ref port-ndx-add1) . 12) ((primitive-ref port-ndx) . 8) ((primitive-ref port-buf) . 4))
# expr=(begin ((primitive-ref port-ndx-add1) f196006))
# tail-begin (begin ((primitive-ref port-ndx-add1) f196006))
#   env=((f196006 . -16) (f196004 . -12) (f196004 . -8) ((primitive-ref port-ndx-add1) . 12) ((primitive-ref port-ndx) . 8) ((primitive-ref port-buf) . 4))
# emit-tail-expr
# si=-20
# env=((f196006 . -16) (f196004 . -12) (f196004 . -8) ((primitive-ref port-ndx-add1) . 12) ((primitive-ref port-ndx) . 8) ((primitive-ref port-buf) . 4))
# expr=((primitive-ref port-ndx-add1) f196006)
# emit-tail-funcall
#    si   =-20
#    env  = ((f196006 . -16) (f196004 . -12) (f196004 . -8) ((primitive-ref port-ndx-add1) . 12) ((primitive-ref port-ndx) . 8) ((primitive-ref port-buf) . 4))
#    expr = (funcall (primitive-ref port-ndx-add1) f196006)
# emit-expr (primitive-ref port-ndx-add1)
    .extern mrc_port$mndx$madd1
    movl mrc_port$mndx$madd1,%eax
   movl %eax,  -20(%esp)  # stash funcall-oper in next closure slot
# emit-expr f196006
# emit-variable-ref
# env=((f196006 . -16) (f196004 . -12) (f196004 . -8) ((primitive-ref port-ndx-add1) . 12) ((primitive-ref port-ndx) . 8) ((primitive-ref port-buf) . 4))
# var=f196006
    movl -16(%esp), %eax  # stack load f196006
# end emit-variable-ref
    mov %eax, -24(%esp)    # arg f196006
    movl -20(%esp), %edi   # load new closure to %edi
# emit-shift-args:  size=2   si=-20  delta=16
    mov -20(%esp), %ebx  # shift frame cell
    mov %ebx, -4(%esp)  # down to base
# emit-shift-args:  size=1   si=-24  delta=16
    mov -24(%esp), %ebx  # shift frame cell
    mov %ebx, -8(%esp)  # down to base
# emit-shift-args:  size=0   si=-28  delta=16
    movl $4,%eax   # save arg count
    jmp *-2(%edi)  # tail-funcall
     ret   # return thru stack
    .align 4,0x90
_L_1424685:
     movl %eax, mrc_write$mchar
# == explicit-begins  ==>
# (lambda args (let ((p (if (null? args) (current-output-port) (car args)))) (begin (foreign-call "s_write" (port-fd p) (port-buf p) (port-ndx p)) (port-ndx-reset p))))
# == eliminate-let*  ==>
# (lambda args (let ((p (if (null? args) (current-output-port) (car args)))) (begin (foreign-call "s_write" (port-fd p) (port-buf p) (port-ndx p)) (port-ndx-reset p))))
# == uniquify-variables  ==>
# (lambda f196007 (let ((f196009 (if (null? f196007) (current-output-port) (car f196007)))) (begin (foreign-call "s_write" (port-fd f196009) (port-buf f196009) (port-ndx f196009)) (port-ndx-reset f196009))))
# == vectorize-letrec  ==>
# (lambda f196007 (let ((f196009 (if (null? f196007) (current-output-port) (car f196007)))) (begin (foreign-call "s_write" (port-fd f196009) (port-buf f196009) (port-ndx f196009)) (port-ndx-reset f196009))))
# == eliminate-set!  ==>
# (lambda f196007 (let () (let ((f196009 (if (null? f196007) (current-output-port) (car f196007)))) (begin (foreign-call "s_write" (port-fd f196009) (port-buf f196009) (port-ndx f196009)) (port-ndx-reset f196009)))))
# == close-free-variables  ==>
# (closure f196007 (port-fd port-buf port-ndx port-ndx-reset) (let () (let ((f196009 (if (null? f196007) (current-output-port) (car f196007)))) (begin (foreign-call "s_write" (port-fd f196009) (port-buf f196009) (port-ndx f196009)) (port-ndx-reset f196009)))))
# == eliminate-quote  ==>
# (closure f196007 (port-fd port-buf port-ndx port-ndx-reset) (let () (let ((f196009 (if (null? f196007) (current-output-port) (car f196007)))) (begin (foreign-call "s_write" (port-fd f196009) (port-buf f196009) (port-ndx f196009)) (port-ndx-reset f196009)))))
# == eliminate-when/unless  ==>
# (closure f196007 (port-fd port-buf port-ndx port-ndx-reset) (let () (let ((f196009 (if (null? f196007) (current-output-port) (car f196007)))) (begin (foreign-call "s_write" (port-fd f196009) (port-buf f196009) (port-ndx f196009)) (port-ndx-reset f196009)))))
# == eliminate-cond  ==>
# (closure f196007 (port-fd port-buf port-ndx port-ndx-reset) (let () (let ((f196009 (if (null? f196007) (current-output-port) (car f196007)))) (begin (foreign-call "s_write" (port-fd f196009) (port-buf f196009) (port-ndx f196009)) (port-ndx-reset f196009)))))
# == external-symbols  ==>
# (closure f196007 ((primitive-ref port-fd) (primitive-ref port-buf) (primitive-ref port-ndx) (primitive-ref port-ndx-reset)) (let () (let ((f196009 (if (null? f196007) ((primitive-ref current-output-port)) (car f196007)))) (begin (foreign-call "s_write" ((primitive-ref port-fd) f196009) ((primitive-ref port-buf) f196009) ((primitive-ref port-ndx) f196009)) ((primitive-ref port-ndx-reset) f196009)))))
# emit-expr (closure f196007 ((primitive-ref port-fd) (primitive-ref port-buf) (primitive-ref port-ndx) (primitive-ref port-ndx-reset)) (let () (let ((f196009 (if (null? f196007) ((primitive-ref current-output-port)) (car f196007)))) (begin (foreign-call "s_write" ((primitive-ref port-fd) f196009) ((primitive-ref port-buf) f196009) ((primitive-ref port-ndx) f196009)) ((primitive-ref port-ndx-reset) f196009)))))
# emit-closure
# si = 0
# env = ()
# expr = (closure f196007 ((primitive-ref port-fd) (primitive-ref port-buf) (primitive-ref port-ndx) (primitive-ref port-ndx-reset)) (let () (let ((f196009 (if (null? f196007) ((primitive-ref current-output-port)) (car f196007)))) (begin (foreign-call "s_write" ((primitive-ref port-fd) f196009) ((primitive-ref port-buf) f196009) ((primitive-ref port-ndx) f196009)) ((primitive-ref port-ndx-reset) f196009)))))
    movl $_L_1424695, 0(%ebp)  # closure label
# WARNING: free var (primitive-ref port-fd) not defined in the environmnet
# WARNING: free var (primitive-ref port-buf) not defined in the environmnet
# WARNING: free var (primitive-ref port-ndx) not defined in the environmnet
# WARNING: free var (primitive-ref port-ndx-reset) not defined in the environmnet
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $24, %ebp     # bump ebp
    jmp _L_1424696            # jump around closure body
_L_1424695:
# check argument count
    cmp $0,%eax
    jge _L_1424697
# invoke error handler eh_argcount_min
    .extern mrc_eh$uargcount$umin
    movl mrc_eh$uargcount$umin, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_1424697:
# emit-build-varargs-list
    movl $63, %esi       # args <- () 
    lea -4(%esp),%edi    # edi <- esp-4
    subl %eax, %edi      # edi <- esp-4-eax    addr of arg[K+N] on stack
_L_1424699:
    lea -4(%esp),%ebx    # addr of arg[K] on stack
    cmp %edi, %ebx       # while edi <> esp+(si+4)
    je _L_1424698
    movl (%edi),%ebx     # arg i -> car
    movl %ebx, 0(%ebp)
    movl %esi, 4(%ebp)  # esi -> cdr
    movl %ebp, %esi
    addl $1, %esi       # tag as pair
    addl $8,%ebp         # bump heap ptr
    addl $4,%edi         # move to next previous arg from the end
    jmp _L_1424699
_L_1424698:
    movl %esi, -8(%esp)  # set args
# emit-tail-expr
# si=-12
# env=((f196007 . -8) ((primitive-ref port-ndx-reset) . 16) ((primitive-ref port-ndx) . 12) ((primitive-ref port-buf) . 8) ((primitive-ref port-fd) . 4))
# expr=(let () (let ((f196009 (if (null? f196007) ((primitive-ref current-output-port)) (car f196007)))) (begin (foreign-call "s_write" ((primitive-ref port-fd) f196009) ((primitive-ref port-buf) f196009) ((primitive-ref port-ndx) f196009)) ((primitive-ref port-ndx-reset) f196009))))
# emit-tail-let
#  si   = -12
#  env  = ((f196007 . -8) ((primitive-ref port-ndx-reset) . 16) ((primitive-ref port-ndx) . 12) ((primitive-ref port-buf) . 8) ((primitive-ref port-fd) . 4))
#  bindings = ()
#  body = (let ((f196009 (if (null? f196007) ((primitive-ref current-output-port)) (car f196007)))) (begin (foreign-call "s_write" ((primitive-ref port-fd) f196009) ((primitive-ref port-buf) f196009) ((primitive-ref port-ndx) f196009)) ((primitive-ref port-ndx-reset) f196009)))
# emit-tail-expr
# si=-12
# env=((f196007 . -8) ((primitive-ref port-ndx-reset) . 16) ((primitive-ref port-ndx) . 12) ((primitive-ref port-buf) . 8) ((primitive-ref port-fd) . 4))
# expr=(let ((f196009 (if (null? f196007) ((primitive-ref current-output-port)) (car f196007)))) (begin (foreign-call "s_write" ((primitive-ref port-fd) f196009) ((primitive-ref port-buf) f196009) ((primitive-ref port-ndx) f196009)) ((primitive-ref port-ndx-reset) f196009)))
# emit-tail-let
#  si   = -12
#  env  = ((f196007 . -8) ((primitive-ref port-ndx-reset) . 16) ((primitive-ref port-ndx) . 12) ((primitive-ref port-buf) . 8) ((primitive-ref port-fd) . 4))
#  bindings = ((f196009 (if (null? f196007) ((primitive-ref current-output-port)) (car f196007))))
#  body = (begin (foreign-call "s_write" ((primitive-ref port-fd) f196009) ((primitive-ref port-buf) f196009) ((primitive-ref port-ndx) f196009)) ((primitive-ref port-ndx-reset) f196009))
# emit-expr (if (null? f196007) ((primitive-ref current-output-port)) (car f196007))
# emit-expr (null? f196007)
# emit-expr f196007
# emit-variable-ref
# env=((f196007 . -8) ((primitive-ref port-ndx-reset) . 16) ((primitive-ref port-ndx) . 12) ((primitive-ref port-buf) . 8) ((primitive-ref port-fd) . 4))
# var=f196007
    movl -8(%esp), %eax  # stack load f196007
# end emit-variable-ref
    cmp $63, %eax
    mov $0, %eax
    sete %al
    movzbl %al, %eax
    sal $6, %al
    or $47, %al
    cmp $47, %al
    je _L_1424700
# emit-expr ((primitive-ref current-output-port))
# funcall
#    si   =-12
#    env  = ((f196007 . -8) ((primitive-ref port-ndx-reset) . 16) ((primitive-ref port-ndx) . 12) ((primitive-ref port-buf) . 8) ((primitive-ref port-fd) . 4))
#    expr = (funcall (primitive-ref current-output-port))
# emit-expr (primitive-ref current-output-port)
    .extern mrc_current$moutput$mport
    movl mrc_current$moutput$mport,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1424702"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1424702":
   movl %eax,  -20(%esp)  # stash funcall-oper in closure slot
    movl -20(%esp), %edi   # load new closure to %edi
    add $-12, %esp   # adjust base
    movl $0,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $12, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    jmp _L_1424701
_L_1424700:
# emit-expr (car f196007)
# emit-expr f196007
# emit-variable-ref
# env=((f196007 . -8) ((primitive-ref port-ndx-reset) . 16) ((primitive-ref port-ndx) . 12) ((primitive-ref port-buf) . 8) ((primitive-ref port-fd) . 4))
# var=f196007
    movl -8(%esp), %eax  # stack load f196007
# end emit-variable-ref
# check the argument is a pair
    movl %eax,%ebx
    and $7, %bl
    cmp $1, %bl
    je _L_1424703
# invoke error handler eh_pair
    .extern mrc_eh$upair
    movl mrc_eh$upair, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $108,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1424703:
    movl -1(%eax), %eax
_L_1424701:
    movl %eax, -12(%esp)  # stack save
# emit-tail-expr
# si=-16
# env=((f196009 . -12) (f196007 . -8) ((primitive-ref port-ndx-reset) . 16) ((primitive-ref port-ndx) . 12) ((primitive-ref port-buf) . 8) ((primitive-ref port-fd) . 4))
# expr=(begin (foreign-call "s_write" ((primitive-ref port-fd) f196009) ((primitive-ref port-buf) f196009) ((primitive-ref port-ndx) f196009)) ((primitive-ref port-ndx-reset) f196009))
# tail-begin (begin (foreign-call "s_write" ((primitive-ref port-fd) f196009) ((primitive-ref port-buf) f196009) ((primitive-ref port-ndx) f196009)) ((primitive-ref port-ndx-reset) f196009))
#   env=((f196009 . -12) (f196007 . -8) ((primitive-ref port-ndx-reset) . 16) ((primitive-ref port-ndx) . 12) ((primitive-ref port-buf) . 8) ((primitive-ref port-fd) . 4))
# emit-expr (foreign-call "s_write" ((primitive-ref port-fd) f196009) ((primitive-ref port-buf) f196009) ((primitive-ref port-ndx) f196009))
    movl %ecx,-16(%esp)
    movl %esp,-20(%esp)
# emit-expr ((primitive-ref port-ndx) f196009)
# funcall
#    si   =-24
#    env  = ((f196009 . -12) (f196007 . -8) ((primitive-ref port-ndx-reset) . 16) ((primitive-ref port-ndx) . 12) ((primitive-ref port-buf) . 8) ((primitive-ref port-fd) . 4))
#    expr = (funcall (primitive-ref port-ndx) f196009)
# emit-expr (primitive-ref port-ndx)
    .extern mrc_port$mndx
    movl mrc_port$mndx,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1424704"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1424704":
   movl %eax,  -32(%esp)  # stash funcall-oper in closure slot
# emit-expr f196009
# emit-variable-ref
# env=((f196009 . -12) (f196007 . -8) ((primitive-ref port-ndx-reset) . 16) ((primitive-ref port-ndx) . 12) ((primitive-ref port-buf) . 8) ((primitive-ref port-fd) . 4))
# var=f196009
    movl -12(%esp), %eax  # stack load f196009
# end emit-variable-ref
    mov %eax, -36(%esp)  # arg f196009
    movl -32(%esp), %edi   # load new closure to %edi
    add $-24, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $24, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    movl %eax, -24(%esp)
# emit-expr ((primitive-ref port-buf) f196009)
# funcall
#    si   =-28
#    env  = ((f196009 . -12) (f196007 . -8) ((primitive-ref port-ndx-reset) . 16) ((primitive-ref port-ndx) . 12) ((primitive-ref port-buf) . 8) ((primitive-ref port-fd) . 4))
#    expr = (funcall (primitive-ref port-buf) f196009)
# emit-expr (primitive-ref port-buf)
    .extern mrc_port$mbuf
    movl mrc_port$mbuf,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1424705"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1424705":
   movl %eax,  -36(%esp)  # stash funcall-oper in closure slot
# emit-expr f196009
# emit-variable-ref
# env=((f196009 . -12) (f196007 . -8) ((primitive-ref port-ndx-reset) . 16) ((primitive-ref port-ndx) . 12) ((primitive-ref port-buf) . 8) ((primitive-ref port-fd) . 4))
# var=f196009
    movl -12(%esp), %eax  # stack load f196009
# end emit-variable-ref
    mov %eax, -40(%esp)  # arg f196009
    movl -36(%esp), %edi   # load new closure to %edi
    add $-28, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $28, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    movl %eax, -28(%esp)
# emit-expr ((primitive-ref port-fd) f196009)
# funcall
#    si   =-32
#    env  = ((f196009 . -12) (f196007 . -8) ((primitive-ref port-ndx-reset) . 16) ((primitive-ref port-ndx) . 12) ((primitive-ref port-buf) . 8) ((primitive-ref port-fd) . 4))
#    expr = (funcall (primitive-ref port-fd) f196009)
# emit-expr (primitive-ref port-fd)
    .extern mrc_port$mfd
    movl mrc_port$mfd,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1424706"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1424706":
   movl %eax,  -40(%esp)  # stash funcall-oper in closure slot
# emit-expr f196009
# emit-variable-ref
# env=((f196009 . -12) (f196007 . -8) ((primitive-ref port-ndx-reset) . 16) ((primitive-ref port-ndx) . 12) ((primitive-ref port-buf) . 8) ((primitive-ref port-fd) . 4))
# var=f196009
    movl -12(%esp), %eax  # stack load f196009
# end emit-variable-ref
    mov %eax, -44(%esp)  # arg f196009
    movl -40(%esp), %edi   # load new closure to %edi
    add $-32, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $32, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    movl %eax, -32(%esp)
    leal -32(%esp),%edi
    movl %edi,%esi
    andl $-16,%esi
    movl 0(%edi),%eax
    movl %eax,0(%esi)
    movl 4(%edi),%eax
    movl %eax,4(%esi)
    movl 8(%edi),%eax
    movl %eax,8(%esi)
    movl 12(%edi),%eax
    movl %eax,12(%esi)
    movl %esi,%esp
    .extern _s_write
    call _s_write
    movl 12(%esi),%esp
    movl -16(%esp),%ecx
# emit-tail-expr
# si=-16
# env=((f196009 . -12) (f196007 . -8) ((primitive-ref port-ndx-reset) . 16) ((primitive-ref port-ndx) . 12) ((primitive-ref port-buf) . 8) ((primitive-ref port-fd) . 4))
# expr=(begin ((primitive-ref port-ndx-reset) f196009))
# tail-begin (begin ((primitive-ref port-ndx-reset) f196009))
#   env=((f196009 . -12) (f196007 . -8) ((primitive-ref port-ndx-reset) . 16) ((primitive-ref port-ndx) . 12) ((primitive-ref port-buf) . 8) ((primitive-ref port-fd) . 4))
# emit-tail-expr
# si=-16
# env=((f196009 . -12) (f196007 . -8) ((primitive-ref port-ndx-reset) . 16) ((primitive-ref port-ndx) . 12) ((primitive-ref port-buf) . 8) ((primitive-ref port-fd) . 4))
# expr=((primitive-ref port-ndx-reset) f196009)
# emit-tail-funcall
#    si   =-16
#    env  = ((f196009 . -12) (f196007 . -8) ((primitive-ref port-ndx-reset) . 16) ((primitive-ref port-ndx) . 12) ((primitive-ref port-buf) . 8) ((primitive-ref port-fd) . 4))
#    expr = (funcall (primitive-ref port-ndx-reset) f196009)
# emit-expr (primitive-ref port-ndx-reset)
    .extern mrc_port$mndx$mreset
    movl mrc_port$mndx$mreset,%eax
   movl %eax,  -16(%esp)  # stash funcall-oper in next closure slot
# emit-expr f196009
# emit-variable-ref
# env=((f196009 . -12) (f196007 . -8) ((primitive-ref port-ndx-reset) . 16) ((primitive-ref port-ndx) . 12) ((primitive-ref port-buf) . 8) ((primitive-ref port-fd) . 4))
# var=f196009
    movl -12(%esp), %eax  # stack load f196009
# end emit-variable-ref
    mov %eax, -20(%esp)    # arg f196009
    movl -16(%esp), %edi   # load new closure to %edi
# emit-shift-args:  size=2   si=-16  delta=12
    mov -16(%esp), %ebx  # shift frame cell
    mov %ebx, -4(%esp)  # down to base
# emit-shift-args:  size=1   si=-20  delta=12
    mov -20(%esp), %ebx  # shift frame cell
    mov %ebx, -8(%esp)  # down to base
# emit-shift-args:  size=0   si=-24  delta=12
    movl $4,%eax   # save arg count
    jmp *-2(%edi)  # tail-funcall
     ret   # return thru stack
    .align 4,0x90
_L_1424696:
     movl %eax, mrc_flush$moutput$mport
# == explicit-begins  ==>
# (lambda () (begin (flush-output-port) (foreign-call "s_exit")))
# == eliminate-let*  ==>
# (lambda () (begin (flush-output-port) (foreign-call "s_exit")))
# == uniquify-variables  ==>
# (lambda () (begin (flush-output-port) (foreign-call "s_exit")))
# == vectorize-letrec  ==>
# (lambda () (begin (flush-output-port) (foreign-call "s_exit")))
# == eliminate-set!  ==>
# (lambda () (let () (begin (flush-output-port) (foreign-call "s_exit"))))
# == close-free-variables  ==>
# (closure () (flush-output-port) (let () (begin (flush-output-port) (foreign-call "s_exit"))))
# == eliminate-quote  ==>
# (closure () (flush-output-port) (let () (begin (flush-output-port) (foreign-call "s_exit"))))
# == eliminate-when/unless  ==>
# (closure () (flush-output-port) (let () (begin (flush-output-port) (foreign-call "s_exit"))))
# == eliminate-cond  ==>
# (closure () (flush-output-port) (let () (begin (flush-output-port) (foreign-call "s_exit"))))
# == external-symbols  ==>
# (closure () ((primitive-ref flush-output-port)) (let () (begin ((primitive-ref flush-output-port)) (foreign-call "s_exit"))))
# emit-expr (closure () ((primitive-ref flush-output-port)) (let () (begin ((primitive-ref flush-output-port)) (foreign-call "s_exit"))))
# emit-closure
# si = 0
# env = ()
# expr = (closure () ((primitive-ref flush-output-port)) (let () (begin ((primitive-ref flush-output-port)) (foreign-call "s_exit"))))
    movl $_L_1424707, 0(%ebp)  # closure label
# WARNING: free var (primitive-ref flush-output-port) not defined in the environmnet
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $8, %ebp     # bump ebp
    jmp _L_1424708            # jump around closure body
_L_1424707:
# check argument count
    cmp $0,%eax
    je _L_1424709
# invoke error handler eh_argcount
    .extern mrc_eh$uargcount
    movl mrc_eh$uargcount, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_1424709:
# emit-tail-expr
# si=-8
# env=(((primitive-ref flush-output-port) . 4))
# expr=(let () (begin ((primitive-ref flush-output-port)) (foreign-call "s_exit")))
# emit-tail-let
#  si   = -8
#  env  = (((primitive-ref flush-output-port) . 4))
#  bindings = ()
#  body = (begin ((primitive-ref flush-output-port)) (foreign-call "s_exit"))
# emit-tail-expr
# si=-8
# env=(((primitive-ref flush-output-port) . 4))
# expr=(begin ((primitive-ref flush-output-port)) (foreign-call "s_exit"))
# tail-begin (begin ((primitive-ref flush-output-port)) (foreign-call "s_exit"))
#   env=(((primitive-ref flush-output-port) . 4))
# emit-expr ((primitive-ref flush-output-port))
# funcall
#    si   =-8
#    env  = (((primitive-ref flush-output-port) . 4))
#    expr = (funcall (primitive-ref flush-output-port))
# emit-expr (primitive-ref flush-output-port)
    .extern mrc_flush$moutput$mport
    movl mrc_flush$moutput$mport,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1424710"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1424710":
   movl %eax,  -16(%esp)  # stash funcall-oper in closure slot
    movl -16(%esp), %edi   # load new closure to %edi
    add $-8, %esp   # adjust base
    movl $0,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $8, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
# emit-tail-expr
# si=-8
# env=(((primitive-ref flush-output-port) . 4))
# expr=(begin (foreign-call "s_exit"))
# tail-begin (begin (foreign-call "s_exit"))
#   env=(((primitive-ref flush-output-port) . 4))
# emit-tail-expr
# si=-8
# env=(((primitive-ref flush-output-port) . 4))
# expr=(foreign-call "s_exit")
    movl %ecx,-8(%esp)
    movl %esp,-12(%esp)
    leal -12(%esp),%edi
    movl %edi,%esi
    andl $-16,%esi
    movl 0(%edi),%eax
    movl %eax,0(%esi)
    movl %esi,%esp
    .extern _s_exit
    call _s_exit
    movl 0(%esi),%esp
    movl -8(%esp),%ecx
     ret
     ret   # return thru stack
    .align 4,0x90
_L_1424708:
     movl %eax, mrc_exit
# == explicit-begins  ==>
# (lambda (x) (if (vector? x) (if (fx= 6 (vector-length? x)) (symbol=? (vector-ref x 0) (quote output-port)) #f) #f))
# == eliminate-let*  ==>
# (lambda (x) (if (vector? x) (if (fx= 6 (vector-length? x)) (symbol=? (vector-ref x 0) (quote output-port)) #f) #f))
# == uniquify-variables  ==>
# (lambda (f196010) (if (vector? f196010) (if (fx= 6 (vector-length? f196010)) (symbol=? (vector-ref f196010 0) (quote output-port)) #f) #f))
# == vectorize-letrec  ==>
# (lambda (f196010) (if (vector? f196010) (if (fx= 6 (vector-length? f196010)) (symbol=? (vector-ref f196010 0) (quote output-port)) #f) #f))
# == eliminate-set!  ==>
# (lambda (f196010) (let ((f196010 f196010)) (if (vector? f196010) (if (fx= 6 (vector-length? f196010)) (symbol=? (vector-ref f196010 0) (quote output-port)) #f) #f)))
# == close-free-variables  ==>
# (closure (f196010) (vector-length? symbol=? output-port) (let ((f196010 f196010)) (if (vector? f196010) (if (fx= 6 (vector-length? f196010)) (symbol=? (vector-ref f196010 0) (quote output-port)) #f) #f)))
# == eliminate-quote  ==>
# (closure (f196010) (vector-length? symbol=? output-port) (let ((f196010 f196010)) (if (vector? f196010) (if (fx= 6 (vector-length? f196010)) (symbol=? (vector-ref f196010 0) (string->symbol "output-port")) #f) #f)))
# == eliminate-when/unless  ==>
# (closure (f196010) (vector-length? symbol=? output-port) (let ((f196010 f196010)) (if (vector? f196010) (if (fx= 6 (vector-length? f196010)) (symbol=? (vector-ref f196010 0) (string->symbol "output-port")) #f) #f)))
# == eliminate-cond  ==>
# (closure (f196010) (vector-length? symbol=? output-port) (let ((f196010 f196010)) (if (vector? f196010) (if (fx= 6 (vector-length? f196010)) (symbol=? (vector-ref f196010 0) (string->symbol "output-port")) #f) #f)))
# == external-symbols  ==>
# (closure (f196010) (vector-length? symbol=? output-port) (let ((f196010 f196010)) (if (vector? f196010) (if (fx= 6 (vector-length? f196010)) (symbol=? (vector-ref f196010 0) ((primitive-ref string->symbol) "output-port")) #f) #f)))
# emit-expr (closure (f196010) (vector-length? symbol=? output-port) (let ((f196010 f196010)) (if (vector? f196010) (if (fx= 6 (vector-length? f196010)) (symbol=? (vector-ref f196010 0) ((primitive-ref string->symbol) "output-port")) #f) #f)))
# emit-closure
# si = 0
# env = ()
# expr = (closure (f196010) (vector-length? symbol=? output-port) (let ((f196010 f196010)) (if (vector? f196010) (if (fx= 6 (vector-length? f196010)) (symbol=? (vector-ref f196010 0) ((primitive-ref string->symbol) "output-port")) #f) #f)))
    movl $_L_1424711, 0(%ebp)  # closure label
# WARNING: free var vector-length? not defined in the environmnet
# WARNING: free var symbol=? not defined in the environmnet
# WARNING: free var output-port not defined in the environmnet
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $16, %ebp     # bump ebp
    jmp _L_1424712            # jump around closure body
_L_1424711:
# check argument count
    cmp $4,%eax
    je _L_1424713
# invoke error handler eh_argcount
    .extern mrc_eh$uargcount
    movl mrc_eh$uargcount, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_1424713:
# emit-tail-expr
# si=-12
# env=((f196010 . -8) (output-port . 12) (symbol=? . 8) (vector-length? . 4))
# expr=(let ((f196010 f196010)) (if (vector? f196010) (if (fx= 6 (vector-length? f196010)) (symbol=? (vector-ref f196010 0) ((primitive-ref string->symbol) "output-port")) #f) #f))
# emit-tail-let
#  si   = -12
#  env  = ((f196010 . -8) (output-port . 12) (symbol=? . 8) (vector-length? . 4))
#  bindings = ((f196010 f196010))
#  body = (if (vector? f196010) (if (fx= 6 (vector-length? f196010)) (symbol=? (vector-ref f196010 0) ((primitive-ref string->symbol) "output-port")) #f) #f)
# emit-expr f196010
# emit-variable-ref
# env=((f196010 . -8) (output-port . 12) (symbol=? . 8) (vector-length? . 4))
# var=f196010
    movl -8(%esp), %eax  # stack load f196010
# end emit-variable-ref
    movl %eax, -12(%esp)  # stack save
# emit-tail-expr
# si=-16
# env=((f196010 . -12) (f196010 . -8) (output-port . 12) (symbol=? . 8) (vector-length? . 4))
# expr=(if (vector? f196010) (if (fx= 6 (vector-length? f196010)) (symbol=? (vector-ref f196010 0) ((primitive-ref string->symbol) "output-port")) #f) #f)
# emit-expr (vector? f196010)
# emit-expr f196010
# emit-variable-ref
# env=((f196010 . -12) (f196010 . -8) (output-port . 12) (symbol=? . 8) (vector-length? . 4))
# var=f196010
    movl -12(%esp), %eax  # stack load f196010
# end emit-variable-ref
    and $7, %al
    cmp $5, %al
    sete %al
    movzbl %al, %eax
    sal $6, %al
    or $47, %al
    cmp $47, %al
    je _L_1424714
# emit-tail-expr
# si=-16
# env=((f196010 . -12) (f196010 . -8) (output-port . 12) (symbol=? . 8) (vector-length? . 4))
# expr=(if (fx= 6 (vector-length? f196010)) (symbol=? (vector-ref f196010 0) ((primitive-ref string->symbol) "output-port")) #f)
# emit-expr (fx= 6 (vector-length? f196010))
# emit-expr (vector-length? f196010)
# funcall
#    si   =-16
#    env  = ((f196010 . -12) (f196010 . -8) (output-port . 12) (symbol=? . 8) (vector-length? . 4))
#    expr = (funcall vector-length? f196010)
# emit-expr vector-length?
# emit-variable-ref
# env=((f196010 . -12) (f196010 . -8) (output-port . 12) (symbol=? . 8) (vector-length? . 4))
# var=vector-length?
    movl 2(%edi), %eax  # frame load vector-length?
# end emit-variable-ref
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1424718"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1424718":
   movl %eax,  -24(%esp)  # stash funcall-oper in closure slot
# emit-expr f196010
# emit-variable-ref
# env=((f196010 . -12) (f196010 . -8) (output-port . 12) (symbol=? . 8) (vector-length? . 4))
# var=f196010
    movl -12(%esp), %eax  # stack load f196010
# end emit-variable-ref
    mov %eax, -28(%esp)  # arg f196010
    movl -24(%esp), %edi   # load new closure to %edi
    add $-16, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $16, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1424719"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $60,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1424719:
    movl %eax, -16(%esp)
# emit-expr 6
    movl $24, %eax     # immed 6
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1424720"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $60,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1424720:
    cmp -16(%esp), %eax
    sete %al
    movzbl %al, %eax
    sal $6, %al
    or $47, %al
    cmp $47, %al
    je _L_1424716
# emit-tail-expr
# si=-16
# env=((f196010 . -12) (f196010 . -8) (output-port . 12) (symbol=? . 8) (vector-length? . 4))
# expr=(symbol=? (vector-ref f196010 0) ((primitive-ref string->symbol) "output-port"))
# emit-tail-funcall
#    si   =-16
#    env  = ((f196010 . -12) (f196010 . -8) (output-port . 12) (symbol=? . 8) (vector-length? . 4))
#    expr = (funcall symbol=? (vector-ref f196010 0) ((primitive-ref string->symbol) "output-port"))
# emit-expr symbol=?
# emit-variable-ref
# env=((f196010 . -12) (f196010 . -8) (output-port . 12) (symbol=? . 8) (vector-length? . 4))
# var=symbol=?
    movl 6(%edi), %eax  # frame load symbol=?
# end emit-variable-ref
   movl %eax,  -16(%esp)  # stash funcall-oper in next closure slot
# emit-expr (vector-ref f196010 0)
# emit-expr f196010
# emit-variable-ref
# env=((f196010 . -12) (f196010 . -8) (output-port . 12) (symbol=? . 8) (vector-length? . 4))
# var=f196010
    movl -12(%esp), %eax  # stack load f196010
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1424721
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1424721:
    movl %eax, -20(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1424722"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1424722:
# check bounds on vector index
    movl -20(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1424724
    cmp  $0,%eax
    jge _L_1424723
_L_1424724:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1424723:
    movl -20(%esp), %esi
    movl -1(%eax,%esi), %eax
    mov %eax, -20(%esp)    # arg (vector-ref f196010 0)
# emit-expr ((primitive-ref string->symbol) "output-port")
# funcall
#    si   =-24
#    env  = ((f196010 . -12) (f196010 . -8) (output-port . 12) (symbol=? . 8) (vector-length? . 4))
#    expr = (funcall (primitive-ref string->symbol) "output-port")
# emit-expr (primitive-ref string->symbol)
    .extern mrc_string$m$gsymbol
    movl mrc_string$m$gsymbol,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1424725"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1424725":
   movl %eax,  -32(%esp)  # stash funcall-oper in closure slot
# emit-expr "output-port"
# string literal
    jmp _L_1424727
    .align 8,0x90
_L_1424726 :
    .int 44
    .ascii "output-port"
_L_1424727:
    movl $_L_1424726, %eax
    orl $6, %eax
    mov %eax, -36(%esp)  # arg output-port
    movl -32(%esp), %edi   # load new closure to %edi
    add $-24, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $24, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    mov %eax, -24(%esp)    # arg ((primitive-ref string->symbol) output-port)
    movl -16(%esp), %edi   # load new closure to %edi
# emit-shift-args:  size=3   si=-16  delta=12
    mov -16(%esp), %ebx  # shift frame cell
    mov %ebx, -4(%esp)  # down to base
# emit-shift-args:  size=2   si=-20  delta=12
    mov -20(%esp), %ebx  # shift frame cell
    mov %ebx, -8(%esp)  # down to base
# emit-shift-args:  size=1   si=-24  delta=12
    mov -24(%esp), %ebx  # shift frame cell
    mov %ebx, -12(%esp)  # down to base
# emit-shift-args:  size=0   si=-28  delta=12
    movl $8,%eax   # save arg count
    jmp *-2(%edi)  # tail-funcall
    jmp _L_1424717
_L_1424716:
# emit-tail-expr
# si=-16
# env=((f196010 . -12) (f196010 . -8) (output-port . 12) (symbol=? . 8) (vector-length? . 4))
# expr=#f
    movl $47, %eax     # immed #f
    ret                  # immediate tail return
_L_1424717:
    jmp _L_1424715
_L_1424714:
# emit-tail-expr
# si=-16
# env=((f196010 . -12) (f196010 . -8) (output-port . 12) (symbol=? . 8) (vector-length? . 4))
# expr=#f
    movl $47, %eax     # immed #f
    ret                  # immediate tail return
_L_1424715:
    .align 4,0x90
_L_1424712:
     movl %eax, mrc_output$mport$q
# == explicit-begins  ==>
# (lambda (x) (error (quote open-output) "not yet implemented"))
# == eliminate-let*  ==>
# (lambda (x) (error (quote open-output) "not yet implemented"))
# == uniquify-variables  ==>
# (lambda (f196011) (error (quote open-output) "not yet implemented"))
# == vectorize-letrec  ==>
# (lambda (f196011) (error (quote open-output) "not yet implemented"))
# == eliminate-set!  ==>
# (lambda (f196011) (let ((f196011 f196011)) (error (quote open-output) "not yet implemented")))
# == close-free-variables  ==>
# (closure (f196011) (error open-output) (let ((f196011 f196011)) (error (quote open-output) "not yet implemented")))
# == eliminate-quote  ==>
# (closure (f196011) (error open-output) (let ((f196011 f196011)) (error (string->symbol "open-output") "not yet implemented")))
# == eliminate-when/unless  ==>
# (closure (f196011) (error open-output) (let ((f196011 f196011)) (error (string->symbol "open-output") "not yet implemented")))
# == eliminate-cond  ==>
# (closure (f196011) (error open-output) (let ((f196011 f196011)) (error (string->symbol "open-output") "not yet implemented")))
# == external-symbols  ==>
# (closure (f196011) ((primitive-ref error) open-output) (let ((f196011 f196011)) ((primitive-ref error) ((primitive-ref string->symbol) "open-output") "not yet implemented")))
# emit-expr (closure (f196011) ((primitive-ref error) open-output) (let ((f196011 f196011)) ((primitive-ref error) ((primitive-ref string->symbol) "open-output") "not yet implemented")))
# emit-closure
# si = 0
# env = ()
# expr = (closure (f196011) ((primitive-ref error) open-output) (let ((f196011 f196011)) ((primitive-ref error) ((primitive-ref string->symbol) "open-output") "not yet implemented")))
    movl $_L_1424728, 0(%ebp)  # closure label
# WARNING: free var (primitive-ref error) not defined in the environmnet
# WARNING: free var open-output not defined in the environmnet
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $16, %ebp     # bump ebp
    jmp _L_1424729            # jump around closure body
_L_1424728:
# check argument count
    cmp $4,%eax
    je _L_1424730
# invoke error handler eh_argcount
    .extern mrc_eh$uargcount
    movl mrc_eh$uargcount, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_1424730:
# emit-tail-expr
# si=-12
# env=((f196011 . -8) (open-output . 8) ((primitive-ref error) . 4))
# expr=(let ((f196011 f196011)) ((primitive-ref error) ((primitive-ref string->symbol) "open-output") "not yet implemented"))
# emit-tail-let
#  si   = -12
#  env  = ((f196011 . -8) (open-output . 8) ((primitive-ref error) . 4))
#  bindings = ((f196011 f196011))
#  body = ((primitive-ref error) ((primitive-ref string->symbol) "open-output") "not yet implemented")
# emit-expr f196011
# emit-variable-ref
# env=((f196011 . -8) (open-output . 8) ((primitive-ref error) . 4))
# var=f196011
    movl -8(%esp), %eax  # stack load f196011
# end emit-variable-ref
    movl %eax, -12(%esp)  # stack save
# emit-tail-expr
# si=-16
# env=((f196011 . -12) (f196011 . -8) (open-output . 8) ((primitive-ref error) . 4))
# expr=((primitive-ref error) ((primitive-ref string->symbol) "open-output") "not yet implemented")
# emit-tail-funcall
#    si   =-16
#    env  = ((f196011 . -12) (f196011 . -8) (open-output . 8) ((primitive-ref error) . 4))
#    expr = (funcall (primitive-ref error) ((primitive-ref string->symbol) "open-output") "not yet implemented")
# emit-expr (primitive-ref error)
    .extern mrc_error
    movl mrc_error,%eax
   movl %eax,  -16(%esp)  # stash funcall-oper in next closure slot
# emit-expr ((primitive-ref string->symbol) "open-output")
# funcall
#    si   =-20
#    env  = ((f196011 . -12) (f196011 . -8) (open-output . 8) ((primitive-ref error) . 4))
#    expr = (funcall (primitive-ref string->symbol) "open-output")
# emit-expr (primitive-ref string->symbol)
    .extern mrc_string$m$gsymbol
    movl mrc_string$m$gsymbol,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1424731"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1424731":
   movl %eax,  -28(%esp)  # stash funcall-oper in closure slot
# emit-expr "open-output"
# string literal
    jmp _L_1424733
    .align 8,0x90
_L_1424732 :
    .int 44
    .ascii "open-output"
_L_1424733:
    movl $_L_1424732, %eax
    orl $6, %eax
    mov %eax, -32(%esp)  # arg open-output
    movl -28(%esp), %edi   # load new closure to %edi
    add $-20, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $20, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    mov %eax, -20(%esp)    # arg ((primitive-ref string->symbol) open-output)
# emit-expr "not yet implemented"
# string literal
    jmp _L_1424735
    .align 8,0x90
_L_1424734 :
    .int 76
    .ascii "not yet implemented"
_L_1424735:
    movl $_L_1424734, %eax
    orl $6, %eax
    mov %eax, -24(%esp)    # arg not yet implemented
    movl -16(%esp), %edi   # load new closure to %edi
# emit-shift-args:  size=3   si=-16  delta=12
    mov -16(%esp), %ebx  # shift frame cell
    mov %ebx, -4(%esp)  # down to base
# emit-shift-args:  size=2   si=-20  delta=12
    mov -20(%esp), %ebx  # shift frame cell
    mov %ebx, -8(%esp)  # down to base
# emit-shift-args:  size=1   si=-24  delta=12
    mov -24(%esp), %ebx  # shift frame cell
    mov %ebx, -12(%esp)  # down to base
# emit-shift-args:  size=0   si=-28  delta=12
    movl $8,%eax   # save arg count
    jmp *-2(%edi)  # tail-funcall
    .align 4,0x90
_L_1424729:
     movl %eax, mrc_open$moutput$mfile
# == explicit-begins  ==>
# (lambda (p) (flush-output-port p))
# == eliminate-let*  ==>
# (lambda (p) (flush-output-port p))
# == uniquify-variables  ==>
# (lambda (f196012) (flush-output-port f196012))
# == vectorize-letrec  ==>
# (lambda (f196012) (flush-output-port f196012))
# == eliminate-set!  ==>
# (lambda (f196012) (let ((f196012 f196012)) (flush-output-port f196012)))
# == close-free-variables  ==>
# (closure (f196012) (flush-output-port) (let ((f196012 f196012)) (flush-output-port f196012)))
# == eliminate-quote  ==>
# (closure (f196012) (flush-output-port) (let ((f196012 f196012)) (flush-output-port f196012)))
# == eliminate-when/unless  ==>
# (closure (f196012) (flush-output-port) (let ((f196012 f196012)) (flush-output-port f196012)))
# == eliminate-cond  ==>
# (closure (f196012) (flush-output-port) (let ((f196012 f196012)) (flush-output-port f196012)))
# == external-symbols  ==>
# (closure (f196012) ((primitive-ref flush-output-port)) (let ((f196012 f196012)) ((primitive-ref flush-output-port) f196012)))
# emit-expr (closure (f196012) ((primitive-ref flush-output-port)) (let ((f196012 f196012)) ((primitive-ref flush-output-port) f196012)))
# emit-closure
# si = 0
# env = ()
# expr = (closure (f196012) ((primitive-ref flush-output-port)) (let ((f196012 f196012)) ((primitive-ref flush-output-port) f196012)))
    movl $_L_1424736, 0(%ebp)  # closure label
# WARNING: free var (primitive-ref flush-output-port) not defined in the environmnet
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $8, %ebp     # bump ebp
    jmp _L_1424737            # jump around closure body
_L_1424736:
# check argument count
    cmp $4,%eax
    je _L_1424738
# invoke error handler eh_argcount
    .extern mrc_eh$uargcount
    movl mrc_eh$uargcount, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_1424738:
# emit-tail-expr
# si=-12
# env=((f196012 . -8) ((primitive-ref flush-output-port) . 4))
# expr=(let ((f196012 f196012)) ((primitive-ref flush-output-port) f196012))
# emit-tail-let
#  si   = -12
#  env  = ((f196012 . -8) ((primitive-ref flush-output-port) . 4))
#  bindings = ((f196012 f196012))
#  body = ((primitive-ref flush-output-port) f196012)
# emit-expr f196012
# emit-variable-ref
# env=((f196012 . -8) ((primitive-ref flush-output-port) . 4))
# var=f196012
    movl -8(%esp), %eax  # stack load f196012
# end emit-variable-ref
    movl %eax, -12(%esp)  # stack save
# emit-tail-expr
# si=-16
# env=((f196012 . -12) (f196012 . -8) ((primitive-ref flush-output-port) . 4))
# expr=((primitive-ref flush-output-port) f196012)
# emit-tail-funcall
#    si   =-16
#    env  = ((f196012 . -12) (f196012 . -8) ((primitive-ref flush-output-port) . 4))
#    expr = (funcall (primitive-ref flush-output-port) f196012)
# emit-expr (primitive-ref flush-output-port)
    .extern mrc_flush$moutput$mport
    movl mrc_flush$moutput$mport,%eax
   movl %eax,  -16(%esp)  # stash funcall-oper in next closure slot
# emit-expr f196012
# emit-variable-ref
# env=((f196012 . -12) (f196012 . -8) ((primitive-ref flush-output-port) . 4))
# var=f196012
    movl -12(%esp), %eax  # stack load f196012
# end emit-variable-ref
    mov %eax, -20(%esp)    # arg f196012
    movl -16(%esp), %edi   # load new closure to %edi
# emit-shift-args:  size=2   si=-16  delta=12
    mov -16(%esp), %ebx  # shift frame cell
    mov %ebx, -4(%esp)  # down to base
# emit-shift-args:  size=1   si=-20  delta=12
    mov -20(%esp), %ebx  # shift frame cell
    mov %ebx, -8(%esp)  # down to base
# emit-shift-args:  size=0   si=-24  delta=12
    movl $4,%eax   # save arg count
    jmp *-2(%edi)  # tail-funcall
    .align 4,0x90
_L_1424737:
     movl %eax, mrc_close$moutput$mport
# == explicit-begins  ==>
# (letrec ((print-boolean (lambda (expr) (begin (write-char #\#) (if expr (write-char #\t) (write-char #\f))))) (print-null (lambda () (begin (write-char #\() (write-char #\))))) (print-char (lambda (expr) (begin (write-char #\#) (write-char #\\) (write-char expr)))) (print-fixnum (lambda (i) (if (negative? i) (begin (write-char #\-) (print-fixnum (fx* -1 i))) (map (lambda (x) (write-char (fixnum->char (fx+ (char->fixnum #\0) x)))) (integer->list i))))) (print-string (lambda (s) (begin (write-char #\") (for-each write-char (string->list s)) (write-char #\")))) (print-pair (lambda (pr) (begin (write-char #\() (print-pairs pr) (write-char #\))))) (print-pairs (lambda (pr) (begin (write (car pr)) (cond ((null? (cdr pr)) #t) ((pair? (cdr pr)) (begin (write-char #\space) (print-pairs (cdr pr)))) (else (begin (write-char #\space) (write-char #\.) (write-char #\space) (write (cdr pr))))))))) (lambda (expr) (cond ((boolean? expr) (print-boolean expr)) ((null? expr) (print-null)) ((char? expr) (print-char expr)) ((fixnum? expr) (print-fixnum expr)) ((string? expr) (print-string expr)) ((pair? expr) (print-pair expr)) (else (error (quote write) "unrecognized expression")))))
# == eliminate-let*  ==>
# (letrec ((print-boolean (lambda (expr) (begin (write-char #\#) (if expr (write-char #\t) (write-char #\f))))) (print-null (lambda () (begin (write-char #\() (write-char #\))))) (print-char (lambda (expr) (begin (write-char #\#) (write-char #\\) (write-char expr)))) (print-fixnum (lambda (i) (if (negative? i) (begin (write-char #\-) (print-fixnum (fx* -1 i))) (map (lambda (x) (write-char (fixnum->char (fx+ (char->fixnum #\0) x)))) (integer->list i))))) (print-string (lambda (s) (begin (write-char #\") (for-each write-char (string->list s)) (write-char #\")))) (print-pair (lambda (pr) (begin (write-char #\() (print-pairs pr) (write-char #\))))) (print-pairs (lambda (pr) (begin (write (car pr)) (cond ((null? (cdr pr)) #t) ((pair? (cdr pr)) (begin (write-char #\space) (print-pairs (cdr pr)))) (else (begin (write-char #\space) (write-char #\.) (write-char #\space) (write (cdr pr))))))))) (lambda (expr) (cond ((boolean? expr) (print-boolean expr)) ((null? expr) (print-null)) ((char? expr) (print-char expr)) ((fixnum? expr) (print-fixnum expr)) ((string? expr) (print-string expr)) ((pair? expr) (print-pair expr)) (else (error (quote write) "unrecognized expression")))))
# == uniquify-variables  ==>
# (letrec ((f196019 (lambda (f196035) (begin (write-char #\#) (if f196035 (write-char #\t) (write-char #\f))))) (f196018 (lambda () (begin (write-char #\() (write-char #\))))) (f196017 (lambda (f196034) (begin (write-char #\#) (write-char #\\) (write-char f196034)))) (f196016 (lambda (f196031) (if (negative? f196031) (begin (write-char #\-) (f196016 (fx* -1 f196031))) (map (lambda (f196033) (write-char (fixnum->char (fx+ (char->fixnum #\0) f196033)))) (integer->list f196031))))) (f196015 (lambda (f196030) (begin (write-char #\") (for-each write-char (string->list f196030)) (write-char #\")))) (f196014 (lambda (f196029) (begin (write-char #\() (f196013 f196029) (write-char #\))))) (f196013 (lambda (f196028) (begin (write (car f196028)) (cond ((null? (cdr f196028)) #t) ((pair? (cdr f196028)) (begin (write-char #\space) (f196013 (cdr f196028)))) (else (begin (write-char #\space) (write-char #\.) (write-char #\space) (write (cdr f196028))))))))) (lambda (f196037) (cond ((boolean? f196037) (f196019 f196037)) ((null? f196037) (f196018)) ((char? f196037) (f196017 f196037)) ((fixnum? f196037) (f196016 f196037)) ((string? f196037) (f196015 f196037)) ((pair? f196037) (f196014 f196037)) (else (error (quote write) "unrecognized expression")))))
# == vectorize-letrec  ==>
# (let ((f196019 (make-vector 1)) (f196018 (make-vector 1)) (f196017 (make-vector 1)) (f196016 (make-vector 1)) (f196015 (make-vector 1)) (f196014 (make-vector 1)) (f196013 (make-vector 1))) (begin (begin (vector-set! f196019 0 (lambda (f196035) (begin (write-char #\#) (if f196035 (write-char #\t) (write-char #\f))))) (vector-set! f196018 0 (lambda () (begin (write-char #\() (write-char #\))))) (vector-set! f196017 0 (lambda (f196034) (begin (write-char #\#) (write-char #\\) (write-char f196034)))) (vector-set! f196016 0 (lambda (f196031) (if (negative? f196031) (begin (write-char #\-) ((vector-ref f196016 0) (fx* -1 f196031))) (map (lambda (f196033) (write-char (fixnum->char (fx+ (char->fixnum #\0) f196033)))) (integer->list f196031))))) (vector-set! f196015 0 (lambda (f196030) (begin (write-char #\") (for-each write-char (string->list f196030)) (write-char #\")))) (vector-set! f196014 0 (lambda (f196029) (begin (write-char #\() ((vector-ref f196013 0) f196029) (write-char #\))))) (vector-set! f196013 0 (lambda (f196028) (begin (write (car f196028)) (cond ((null? (cdr f196028)) #t) ((pair? (cdr f196028)) (begin (write-char #\space) ((vector-ref f196013 0) (cdr f196028)))) (else (begin (write-char #\space) (write-char #\.) (write-char #\space) (write (cdr f196028))))))))) (lambda (f196037) (cond ((boolean? f196037) ((vector-ref f196019 0) f196037)) ((null? f196037) ((vector-ref f196018 0))) ((char? f196037) ((vector-ref f196017 0) f196037)) ((fixnum? f196037) ((vector-ref f196016 0) f196037)) ((string? f196037) ((vector-ref f196015 0) f196037)) ((pair? f196037) ((vector-ref f196014 0) f196037)) (else (error (quote write) "unrecognized expression"))))))
# == eliminate-set!  ==>
# (let ((f196019 (make-vector 1)) (f196018 (make-vector 1)) (f196017 (make-vector 1)) (f196016 (make-vector 1)) (f196015 (make-vector 1)) (f196014 (make-vector 1)) (f196013 (make-vector 1))) (begin (begin (vector-set! f196019 0 (lambda (f196035) (let ((f196035 f196035)) (begin (write-char #\#) (if f196035 (write-char #\t) (write-char #\f)))))) (vector-set! f196018 0 (lambda () (let () (begin (write-char #\() (write-char #\)))))) (vector-set! f196017 0 (lambda (f196034) (let ((f196034 f196034)) (begin (write-char #\#) (write-char #\\) (write-char f196034))))) (vector-set! f196016 0 (lambda (f196031) (let ((f196031 f196031)) (if (negative? f196031) (begin (write-char #\-) ((vector-ref f196016 0) (fx* -1 f196031))) (map (lambda (f196033) (let ((f196033 f196033)) (write-char (fixnum->char (fx+ (char->fixnum #\0) f196033))))) (integer->list f196031)))))) (vector-set! f196015 0 (lambda (f196030) (let ((f196030 f196030)) (begin (write-char #\") (for-each write-char (string->list f196030)) (write-char #\"))))) (vector-set! f196014 0 (lambda (f196029) (let ((f196029 f196029)) (begin (write-char #\() ((vector-ref f196013 0) f196029) (write-char #\)))))) (vector-set! f196013 0 (lambda (f196028) (let ((f196028 f196028)) (begin (write (car f196028)) (cond ((null? (cdr f196028)) #t) ((pair? (cdr f196028)) (begin (write-char #\space) ((vector-ref f196013 0) (cdr f196028)))) (else (begin (write-char #\space) (write-char #\.) (write-char #\space) (write (cdr f196028)))))))))) (lambda (f196037) (let ((f196037 f196037)) (cond ((boolean? f196037) ((vector-ref f196019 0) f196037)) ((null? f196037) ((vector-ref f196018 0))) ((char? f196037) ((vector-ref f196017 0) f196037)) ((fixnum? f196037) ((vector-ref f196016 0) f196037)) ((string? f196037) ((vector-ref f196015 0) f196037)) ((pair? f196037) ((vector-ref f196014 0) f196037)) (else (error (quote write) "unrecognized expression")))))))
# == close-free-variables  ==>
# (let ((f196019 (make-vector 1)) (f196018 (make-vector 1)) (f196017 (make-vector 1)) (f196016 (make-vector 1)) (f196015 (make-vector 1)) (f196014 (make-vector 1)) (f196013 (make-vector 1))) (begin (begin (vector-set! f196019 0 (closure (f196035) (write-char write-char write-char) (let ((f196035 f196035)) (begin (write-char #\#) (if f196035 (write-char #\t) (write-char #\f)))))) (vector-set! f196018 0 (closure () (write-char write-char) (let () (begin (write-char #\() (write-char #\)))))) (vector-set! f196017 0 (closure (f196034) (write-char write-char write-char) (let ((f196034 f196034)) (begin (write-char #\#) (write-char #\\) (write-char f196034))))) (vector-set! f196016 0 (closure (f196031) (negative? write-char f196016 map write-char integer->list) (let ((f196031 f196031)) (if (negative? f196031) (begin (write-char #\-) ((vector-ref f196016 0) (fx* -1 f196031))) (map (closure (f196033) (write-char) (let ((f196033 f196033)) (write-char (fixnum->char (fx+ (char->fixnum #\0) f196033))))) (integer->list f196031)))))) (vector-set! f196015 0 (closure (f196030) (write-char for-each write-char string->list write-char) (let ((f196030 f196030)) (begin (write-char #\") (for-each write-char (string->list f196030)) (write-char #\"))))) (vector-set! f196014 0 (closure (f196029) (write-char f196013 write-char) (let ((f196029 f196029)) (begin (write-char #\() ((vector-ref f196013 0) f196029) (write-char #\)))))) (vector-set! f196013 0 (closure (f196028) (write write-char f196013 else write-char write-char write-char write) (let ((f196028 f196028)) (begin (write (car f196028)) (cond ((null? (cdr f196028)) #t) ((pair? (cdr f196028)) (begin (write-char #\space) ((vector-ref f196013 0) (cdr f196028)))) (else (begin (write-char #\space) (write-char #\.) (write-char #\space) (write (cdr f196028)))))))))) (closure (f196037) (f196019 f196018 f196017 f196016 f196015 f196014 else error write) (let ((f196037 f196037)) (cond ((boolean? f196037) ((vector-ref f196019 0) f196037)) ((null? f196037) ((vector-ref f196018 0))) ((char? f196037) ((vector-ref f196017 0) f196037)) ((fixnum? f196037) ((vector-ref f196016 0) f196037)) ((string? f196037) ((vector-ref f196015 0) f196037)) ((pair? f196037) ((vector-ref f196014 0) f196037)) (else (error (quote write) "unrecognized expression")))))))
# == eliminate-quote  ==>
# (let ((f196019 (make-vector 1)) (f196018 (make-vector 1)) (f196017 (make-vector 1)) (f196016 (make-vector 1)) (f196015 (make-vector 1)) (f196014 (make-vector 1)) (f196013 (make-vector 1))) (begin (begin (vector-set! f196019 0 (closure (f196035) (write-char write-char write-char) (let ((f196035 f196035)) (begin (write-char #\#) (if f196035 (write-char #\t) (write-char #\f)))))) (vector-set! f196018 0 (closure () (write-char write-char) (let () (begin (write-char #\() (write-char #\)))))) (vector-set! f196017 0 (closure (f196034) (write-char write-char write-char) (let ((f196034 f196034)) (begin (write-char #\#) (write-char #\\) (write-char f196034))))) (vector-set! f196016 0 (closure (f196031) (negative? write-char f196016 map write-char integer->list) (let ((f196031 f196031)) (if (negative? f196031) (begin (write-char #\-) ((vector-ref f196016 0) (fx* -1 f196031))) (map (closure (f196033) (write-char) (let ((f196033 f196033)) (write-char (fixnum->char (fx+ (char->fixnum #\0) f196033))))) (integer->list f196031)))))) (vector-set! f196015 0 (closure (f196030) (write-char for-each write-char string->list write-char) (let ((f196030 f196030)) (begin (write-char #\") (for-each write-char (string->list f196030)) (write-char #\"))))) (vector-set! f196014 0 (closure (f196029) (write-char f196013 write-char) (let ((f196029 f196029)) (begin (write-char #\() ((vector-ref f196013 0) f196029) (write-char #\)))))) (vector-set! f196013 0 (closure (f196028) (write write-char f196013 else write-char write-char write-char write) (let ((f196028 f196028)) (begin (write (car f196028)) (cond ((null? (cdr f196028)) #t) ((pair? (cdr f196028)) (begin (write-char #\space) ((vector-ref f196013 0) (cdr f196028)))) (else (begin (write-char #\space) (write-char #\.) (write-char #\space) (write (cdr f196028)))))))))) (closure (f196037) (f196019 f196018 f196017 f196016 f196015 f196014 else error write) (let ((f196037 f196037)) (cond ((boolean? f196037) ((vector-ref f196019 0) f196037)) ((null? f196037) ((vector-ref f196018 0))) ((char? f196037) ((vector-ref f196017 0) f196037)) ((fixnum? f196037) ((vector-ref f196016 0) f196037)) ((string? f196037) ((vector-ref f196015 0) f196037)) ((pair? f196037) ((vector-ref f196014 0) f196037)) (else (error (string->symbol "write") "unrecognized expression")))))))
# == eliminate-when/unless  ==>
# (let ((f196019 (make-vector 1)) (f196018 (make-vector 1)) (f196017 (make-vector 1)) (f196016 (make-vector 1)) (f196015 (make-vector 1)) (f196014 (make-vector 1)) (f196013 (make-vector 1))) (begin (begin (vector-set! f196019 0 (closure (f196035) (write-char write-char write-char) (let ((f196035 f196035)) (begin (write-char #\#) (if f196035 (write-char #\t) (write-char #\f)))))) (vector-set! f196018 0 (closure () (write-char write-char) (let () (begin (write-char #\() (write-char #\)))))) (vector-set! f196017 0 (closure (f196034) (write-char write-char write-char) (let ((f196034 f196034)) (begin (write-char #\#) (write-char #\\) (write-char f196034))))) (vector-set! f196016 0 (closure (f196031) (negative? write-char f196016 map write-char integer->list) (let ((f196031 f196031)) (if (negative? f196031) (begin (write-char #\-) ((vector-ref f196016 0) (fx* -1 f196031))) (map (closure (f196033) (write-char) (let ((f196033 f196033)) (write-char (fixnum->char (fx+ (char->fixnum #\0) f196033))))) (integer->list f196031)))))) (vector-set! f196015 0 (closure (f196030) (write-char for-each write-char string->list write-char) (let ((f196030 f196030)) (begin (write-char #\") (for-each write-char (string->list f196030)) (write-char #\"))))) (vector-set! f196014 0 (closure (f196029) (write-char f196013 write-char) (let ((f196029 f196029)) (begin (write-char #\() ((vector-ref f196013 0) f196029) (write-char #\)))))) (vector-set! f196013 0 (closure (f196028) (write write-char f196013 else write-char write-char write-char write) (let ((f196028 f196028)) (begin (write (car f196028)) (cond ((null? (cdr f196028)) #t) ((pair? (cdr f196028)) (begin (write-char #\space) ((vector-ref f196013 0) (cdr f196028)))) (else (begin (write-char #\space) (write-char #\.) (write-char #\space) (write (cdr f196028)))))))))) (closure (f196037) (f196019 f196018 f196017 f196016 f196015 f196014 else error write) (let ((f196037 f196037)) (cond ((boolean? f196037) ((vector-ref f196019 0) f196037)) ((null? f196037) ((vector-ref f196018 0))) ((char? f196037) ((vector-ref f196017 0) f196037)) ((fixnum? f196037) ((vector-ref f196016 0) f196037)) ((string? f196037) ((vector-ref f196015 0) f196037)) ((pair? f196037) ((vector-ref f196014 0) f196037)) (else (error (string->symbol "write") "unrecognized expression")))))))
# == eliminate-cond  ==>
# (let ((f196019 (make-vector 1)) (f196018 (make-vector 1)) (f196017 (make-vector 1)) (f196016 (make-vector 1)) (f196015 (make-vector 1)) (f196014 (make-vector 1)) (f196013 (make-vector 1))) (begin (begin (vector-set! f196019 0 (closure (f196035) (write-char write-char write-char) (let ((f196035 f196035)) (begin (write-char #\#) (if f196035 (write-char #\t) (write-char #\f)))))) (vector-set! f196018 0 (closure () (write-char write-char) (let () (begin (write-char #\() (write-char #\)))))) (vector-set! f196017 0 (closure (f196034) (write-char write-char write-char) (let ((f196034 f196034)) (begin (write-char #\#) (write-char #\\) (write-char f196034))))) (vector-set! f196016 0 (closure (f196031) (negative? write-char f196016 map write-char integer->list) (let ((f196031 f196031)) (if (negative? f196031) (begin (write-char #\-) ((vector-ref f196016 0) (fx* -1 f196031))) (map (closure (f196033) (write-char) (let ((f196033 f196033)) (write-char (fixnum->char (fx+ (char->fixnum #\0) f196033))))) (integer->list f196031)))))) (vector-set! f196015 0 (closure (f196030) (write-char for-each write-char string->list write-char) (let ((f196030 f196030)) (begin (write-char #\") (for-each write-char (string->list f196030)) (write-char #\"))))) (vector-set! f196014 0 (closure (f196029) (write-char f196013 write-char) (let ((f196029 f196029)) (begin (write-char #\() ((vector-ref f196013 0) f196029) (write-char #\)))))) (vector-set! f196013 0 (closure (f196028) (write write-char f196013 else write-char write-char write-char write) (let ((f196028 f196028)) (begin (write (car f196028)) (if (null? (cdr f196028)) #t (if (pair? (cdr f196028)) (begin (write-char #\space) ((vector-ref f196013 0) (cdr f196028))) (begin (write-char #\space) (write-char #\.) (write-char #\space) (write (cdr f196028)))))))))) (closure (f196037) (f196019 f196018 f196017 f196016 f196015 f196014 else error write) (let ((f196037 f196037)) (if (boolean? f196037) ((vector-ref f196019 0) f196037) (if (null? f196037) ((vector-ref f196018 0)) (if (char? f196037) ((vector-ref f196017 0) f196037) (if (fixnum? f196037) ((vector-ref f196016 0) f196037) (if (string? f196037) ((vector-ref f196015 0) f196037) (if (pair? f196037) ((vector-ref f196014 0) f196037) (error (string->symbol "write") "unrecognized expression")))))))))))
# == external-symbols  ==>
# (let ((f196019 (make-vector 1)) (f196018 (make-vector 1)) (f196017 (make-vector 1)) (f196016 (make-vector 1)) (f196015 (make-vector 1)) (f196014 (make-vector 1)) (f196013 (make-vector 1))) (begin (begin (vector-set! f196019 0 (closure (f196035) ((primitive-ref write-char) (primitive-ref write-char) (primitive-ref write-char)) (let ((f196035 f196035)) (begin ((primitive-ref write-char) #\#) (if f196035 ((primitive-ref write-char) #\t) ((primitive-ref write-char) #\f)))))) (vector-set! f196018 0 (closure () ((primitive-ref write-char) (primitive-ref write-char)) (let () (begin ((primitive-ref write-char) #\() ((primitive-ref write-char) #\)))))) (vector-set! f196017 0 (closure (f196034) ((primitive-ref write-char) (primitive-ref write-char) (primitive-ref write-char)) (let ((f196034 f196034)) (begin ((primitive-ref write-char) #\#) ((primitive-ref write-char) #\\) ((primitive-ref write-char) f196034))))) (vector-set! f196016 0 (closure (f196031) ((primitive-ref negative?) (primitive-ref write-char) f196016 (primitive-ref map) (primitive-ref write-char) (primitive-ref integer->list)) (let ((f196031 f196031)) (if ((primitive-ref negative?) f196031) (begin ((primitive-ref write-char) #\-) ((vector-ref f196016 0) (fx* -1 f196031))) ((primitive-ref map) (closure (f196033) ((primitive-ref write-char)) (let ((f196033 f196033)) ((primitive-ref write-char) (fixnum->char (fx+ (char->fixnum #\0) f196033))))) ((primitive-ref integer->list) f196031)))))) (vector-set! f196015 0 (closure (f196030) ((primitive-ref write-char) (primitive-ref for-each) (primitive-ref write-char) (primitive-ref string->list) (primitive-ref write-char)) (let ((f196030 f196030)) (begin ((primitive-ref write-char) #\") ((primitive-ref for-each) (primitive-ref write-char) ((primitive-ref string->list) f196030)) ((primitive-ref write-char) #\"))))) (vector-set! f196014 0 (closure (f196029) ((primitive-ref write-char) f196013 (primitive-ref write-char)) (let ((f196029 f196029)) (begin ((primitive-ref write-char) #\() ((vector-ref f196013 0) f196029) ((primitive-ref write-char) #\)))))) (vector-set! f196013 0 (closure (f196028) ((primitive-ref write) (primitive-ref write-char) f196013 else (primitive-ref write-char) (primitive-ref write-char) (primitive-ref write-char) (primitive-ref write)) (let ((f196028 f196028)) (begin ((primitive-ref write) (car f196028)) (if (null? (cdr f196028)) #t (if (pair? (cdr f196028)) (begin ((primitive-ref write-char) #\space) ((vector-ref f196013 0) (cdr f196028))) (begin ((primitive-ref write-char) #\space) ((primitive-ref write-char) #\.) ((primitive-ref write-char) #\space) ((primitive-ref write) (cdr f196028)))))))))) (closure (f196037) (f196019 f196018 f196017 f196016 f196015 f196014 else (primitive-ref error) (primitive-ref write)) (let ((f196037 f196037)) (if (boolean? f196037) ((vector-ref f196019 0) f196037) (if (null? f196037) ((vector-ref f196018 0)) (if (char? f196037) ((vector-ref f196017 0) f196037) (if (fixnum? f196037) ((vector-ref f196016 0) f196037) (if (string? f196037) ((vector-ref f196015 0) f196037) (if (pair? f196037) ((vector-ref f196014 0) f196037) ((primitive-ref error) ((primitive-ref string->symbol) "write") "unrecognized expression")))))))))))
# emit-expr (let ((f196019 (make-vector 1)) (f196018 (make-vector 1)) (f196017 (make-vector 1)) (f196016 (make-vector 1)) (f196015 (make-vector 1)) (f196014 (make-vector 1)) (f196013 (make-vector 1))) (begin (begin (vector-set! f196019 0 (closure (f196035) ((primitive-ref write-char) (primitive-ref write-char) (primitive-ref write-char)) (let ((f196035 f196035)) (begin ((primitive-ref write-char) #\#) (if f196035 ((primitive-ref write-char) #\t) ((primitive-ref write-char) #\f)))))) (vector-set! f196018 0 (closure () ((primitive-ref write-char) (primitive-ref write-char)) (let () (begin ((primitive-ref write-char) #\() ((primitive-ref write-char) #\)))))) (vector-set! f196017 0 (closure (f196034) ((primitive-ref write-char) (primitive-ref write-char) (primitive-ref write-char)) (let ((f196034 f196034)) (begin ((primitive-ref write-char) #\#) ((primitive-ref write-char) #\\) ((primitive-ref write-char) f196034))))) (vector-set! f196016 0 (closure (f196031) ((primitive-ref negative?) (primitive-ref write-char) f196016 (primitive-ref map) (primitive-ref write-char) (primitive-ref integer->list)) (let ((f196031 f196031)) (if ((primitive-ref negative?) f196031) (begin ((primitive-ref write-char) #\-) ((vector-ref f196016 0) (fx* -1 f196031))) ((primitive-ref map) (closure (f196033) ((primitive-ref write-char)) (let ((f196033 f196033)) ((primitive-ref write-char) (fixnum->char (fx+ (char->fixnum #\0) f196033))))) ((primitive-ref integer->list) f196031)))))) (vector-set! f196015 0 (closure (f196030) ((primitive-ref write-char) (primitive-ref for-each) (primitive-ref write-char) (primitive-ref string->list) (primitive-ref write-char)) (let ((f196030 f196030)) (begin ((primitive-ref write-char) #\") ((primitive-ref for-each) (primitive-ref write-char) ((primitive-ref string->list) f196030)) ((primitive-ref write-char) #\"))))) (vector-set! f196014 0 (closure (f196029) ((primitive-ref write-char) f196013 (primitive-ref write-char)) (let ((f196029 f196029)) (begin ((primitive-ref write-char) #\() ((vector-ref f196013 0) f196029) ((primitive-ref write-char) #\)))))) (vector-set! f196013 0 (closure (f196028) ((primitive-ref write) (primitive-ref write-char) f196013 else (primitive-ref write-char) (primitive-ref write-char) (primitive-ref write-char) (primitive-ref write)) (let ((f196028 f196028)) (begin ((primitive-ref write) (car f196028)) (if (null? (cdr f196028)) #t (if (pair? (cdr f196028)) (begin ((primitive-ref write-char) #\space) ((vector-ref f196013 0) (cdr f196028))) (begin ((primitive-ref write-char) #\space) ((primitive-ref write-char) #\.) ((primitive-ref write-char) #\space) ((primitive-ref write) (cdr f196028)))))))))) (closure (f196037) (f196019 f196018 f196017 f196016 f196015 f196014 else (primitive-ref error) (primitive-ref write)) (let ((f196037 f196037)) (if (boolean? f196037) ((vector-ref f196019 0) f196037) (if (null? f196037) ((vector-ref f196018 0)) (if (char? f196037) ((vector-ref f196017 0) f196037) (if (fixnum? f196037) ((vector-ref f196016 0) f196037) (if (string? f196037) ((vector-ref f196015 0) f196037) (if (pair? f196037) ((vector-ref f196014 0) f196037) ((primitive-ref error) ((primitive-ref string->symbol) "write") "unrecognized expression")))))))))))
# emit-let
#  si   = 0
#  env  = ()
#  bindings = ((f196019 (make-vector 1)) (f196018 (make-vector 1)) (f196017 (make-vector 1)) (f196016 (make-vector 1)) (f196015 (make-vector 1)) (f196014 (make-vector 1)) (f196013 (make-vector 1)))
#  body = (begin (begin (vector-set! f196019 0 (closure (f196035) ((primitive-ref write-char) (primitive-ref write-char) (primitive-ref write-char)) (let ((f196035 f196035)) (begin ((primitive-ref write-char) #\#) (if f196035 ((primitive-ref write-char) #\t) ((primitive-ref write-char) #\f)))))) (vector-set! f196018 0 (closure () ((primitive-ref write-char) (primitive-ref write-char)) (let () (begin ((primitive-ref write-char) #\() ((primitive-ref write-char) #\)))))) (vector-set! f196017 0 (closure (f196034) ((primitive-ref write-char) (primitive-ref write-char) (primitive-ref write-char)) (let ((f196034 f196034)) (begin ((primitive-ref write-char) #\#) ((primitive-ref write-char) #\\) ((primitive-ref write-char) f196034))))) (vector-set! f196016 0 (closure (f196031) ((primitive-ref negative?) (primitive-ref write-char) f196016 (primitive-ref map) (primitive-ref write-char) (primitive-ref integer->list)) (let ((f196031 f196031)) (if ((primitive-ref negative?) f196031) (begin ((primitive-ref write-char) #\-) ((vector-ref f196016 0) (fx* -1 f196031))) ((primitive-ref map) (closure (f196033) ((primitive-ref write-char)) (let ((f196033 f196033)) ((primitive-ref write-char) (fixnum->char (fx+ (char->fixnum #\0) f196033))))) ((primitive-ref integer->list) f196031)))))) (vector-set! f196015 0 (closure (f196030) ((primitive-ref write-char) (primitive-ref for-each) (primitive-ref write-char) (primitive-ref string->list) (primitive-ref write-char)) (let ((f196030 f196030)) (begin ((primitive-ref write-char) #\") ((primitive-ref for-each) (primitive-ref write-char) ((primitive-ref string->list) f196030)) ((primitive-ref write-char) #\"))))) (vector-set! f196014 0 (closure (f196029) ((primitive-ref write-char) f196013 (primitive-ref write-char)) (let ((f196029 f196029)) (begin ((primitive-ref write-char) #\() ((vector-ref f196013 0) f196029) ((primitive-ref write-char) #\)))))) (vector-set! f196013 0 (closure (f196028) ((primitive-ref write) (primitive-ref write-char) f196013 else (primitive-ref write-char) (primitive-ref write-char) (primitive-ref write-char) (primitive-ref write)) (let ((f196028 f196028)) (begin ((primitive-ref write) (car f196028)) (if (null? (cdr f196028)) #t (if (pair? (cdr f196028)) (begin ((primitive-ref write-char) #\space) ((vector-ref f196013 0) (cdr f196028))) (begin ((primitive-ref write-char) #\space) ((primitive-ref write-char) #\.) ((primitive-ref write-char) #\space) ((primitive-ref write) (cdr f196028)))))))))) (closure (f196037) (f196019 f196018 f196017 f196016 f196015 f196014 else (primitive-ref error) (primitive-ref write)) (let ((f196037 f196037)) (if (boolean? f196037) ((vector-ref f196019 0) f196037) (if (null? f196037) ((vector-ref f196018 0)) (if (char? f196037) ((vector-ref f196017 0) f196037) (if (fixnum? f196037) ((vector-ref f196016 0) f196037) (if (string? f196037) ((vector-ref f196015 0) f196037) (if (pair? f196037) ((vector-ref f196014 0) f196037) ((primitive-ref error) ((primitive-ref string->symbol) "write") "unrecognized expression"))))))))))
# emit-expr (make-vector 1)
# make-vector 1
# emit-expr 1
    movl $4, %eax     # immed 1
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1424739"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $128,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1424739:
# check the argument is a fixnum >= 0
    cmp $0,%eax
    jge _L_1424740
# invoke error handler eh_length
    .extern mrc_eh$ulength
    movl mrc_eh$ulength, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $128,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1424740:
    movl %eax, %esi
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    orl  $5, %eax
    addl $4, %esi
    addl $4, %esi
    andl $-8, %esi
    addl %esi, %ebp
    movl %eax, 0(%esp)  # stack save
# emit-expr (make-vector 1)
# make-vector 1
# emit-expr 1
    movl $4, %eax     # immed 1
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1424741"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $128,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1424741:
# check the argument is a fixnum >= 0
    cmp $0,%eax
    jge _L_1424742
# invoke error handler eh_length
    .extern mrc_eh$ulength
    movl mrc_eh$ulength, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $128,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1424742:
    movl %eax, %esi
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    orl  $5, %eax
    addl $4, %esi
    addl $4, %esi
    andl $-8, %esi
    addl %esi, %ebp
    movl %eax, -4(%esp)  # stack save
# emit-expr (make-vector 1)
# make-vector 1
# emit-expr 1
    movl $4, %eax     # immed 1
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1424743"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $128,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1424743:
# check the argument is a fixnum >= 0
    cmp $0,%eax
    jge _L_1424744
# invoke error handler eh_length
    .extern mrc_eh$ulength
    movl mrc_eh$ulength, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $128,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1424744:
    movl %eax, %esi
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    orl  $5, %eax
    addl $4, %esi
    addl $4, %esi
    andl $-8, %esi
    addl %esi, %ebp
    movl %eax, -8(%esp)  # stack save
# emit-expr (make-vector 1)
# make-vector 1
# emit-expr 1
    movl $4, %eax     # immed 1
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1424745"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $128,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1424745:
# check the argument is a fixnum >= 0
    cmp $0,%eax
    jge _L_1424746
# invoke error handler eh_length
    .extern mrc_eh$ulength
    movl mrc_eh$ulength, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $128,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1424746:
    movl %eax, %esi
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    orl  $5, %eax
    addl $4, %esi
    addl $4, %esi
    andl $-8, %esi
    addl %esi, %ebp
    movl %eax, -12(%esp)  # stack save
# emit-expr (make-vector 1)
# make-vector 1
# emit-expr 1
    movl $4, %eax     # immed 1
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1424747"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $128,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1424747:
# check the argument is a fixnum >= 0
    cmp $0,%eax
    jge _L_1424748
# invoke error handler eh_length
    .extern mrc_eh$ulength
    movl mrc_eh$ulength, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $128,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1424748:
    movl %eax, %esi
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    orl  $5, %eax
    addl $4, %esi
    addl $4, %esi
    andl $-8, %esi
    addl %esi, %ebp
    movl %eax, -16(%esp)  # stack save
# emit-expr (make-vector 1)
# make-vector 1
# emit-expr 1
    movl $4, %eax     # immed 1
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1424749"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $128,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1424749:
# check the argument is a fixnum >= 0
    cmp $0,%eax
    jge _L_1424750
# invoke error handler eh_length
    .extern mrc_eh$ulength
    movl mrc_eh$ulength, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $128,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1424750:
    movl %eax, %esi
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    orl  $5, %eax
    addl $4, %esi
    addl $4, %esi
    andl $-8, %esi
    addl %esi, %ebp
    movl %eax, -20(%esp)  # stack save
# emit-expr (make-vector 1)
# make-vector 1
# emit-expr 1
    movl $4, %eax     # immed 1
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1424751"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $128,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1424751:
# check the argument is a fixnum >= 0
    cmp $0,%eax
    jge _L_1424752
# invoke error handler eh_length
    .extern mrc_eh$ulength
    movl mrc_eh$ulength, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $128,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1424752:
    movl %eax, %esi
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    orl  $5, %eax
    addl $4, %esi
    addl $4, %esi
    andl $-8, %esi
    addl %esi, %ebp
    movl %eax, -24(%esp)  # stack save
# emit-expr (begin (begin (vector-set! f196019 0 (closure (f196035) ((primitive-ref write-char) (primitive-ref write-char) (primitive-ref write-char)) (let ((f196035 f196035)) (begin ((primitive-ref write-char) #\#) (if f196035 ((primitive-ref write-char) #\t) ((primitive-ref write-char) #\f)))))) (vector-set! f196018 0 (closure () ((primitive-ref write-char) (primitive-ref write-char)) (let () (begin ((primitive-ref write-char) #\() ((primitive-ref write-char) #\)))))) (vector-set! f196017 0 (closure (f196034) ((primitive-ref write-char) (primitive-ref write-char) (primitive-ref write-char)) (let ((f196034 f196034)) (begin ((primitive-ref write-char) #\#) ((primitive-ref write-char) #\\) ((primitive-ref write-char) f196034))))) (vector-set! f196016 0 (closure (f196031) ((primitive-ref negative?) (primitive-ref write-char) f196016 (primitive-ref map) (primitive-ref write-char) (primitive-ref integer->list)) (let ((f196031 f196031)) (if ((primitive-ref negative?) f196031) (begin ((primitive-ref write-char) #\-) ((vector-ref f196016 0) (fx* -1 f196031))) ((primitive-ref map) (closure (f196033) ((primitive-ref write-char)) (let ((f196033 f196033)) ((primitive-ref write-char) (fixnum->char (fx+ (char->fixnum #\0) f196033))))) ((primitive-ref integer->list) f196031)))))) (vector-set! f196015 0 (closure (f196030) ((primitive-ref write-char) (primitive-ref for-each) (primitive-ref write-char) (primitive-ref string->list) (primitive-ref write-char)) (let ((f196030 f196030)) (begin ((primitive-ref write-char) #\") ((primitive-ref for-each) (primitive-ref write-char) ((primitive-ref string->list) f196030)) ((primitive-ref write-char) #\"))))) (vector-set! f196014 0 (closure (f196029) ((primitive-ref write-char) f196013 (primitive-ref write-char)) (let ((f196029 f196029)) (begin ((primitive-ref write-char) #\() ((vector-ref f196013 0) f196029) ((primitive-ref write-char) #\)))))) (vector-set! f196013 0 (closure (f196028) ((primitive-ref write) (primitive-ref write-char) f196013 else (primitive-ref write-char) (primitive-ref write-char) (primitive-ref write-char) (primitive-ref write)) (let ((f196028 f196028)) (begin ((primitive-ref write) (car f196028)) (if (null? (cdr f196028)) #t (if (pair? (cdr f196028)) (begin ((primitive-ref write-char) #\space) ((vector-ref f196013 0) (cdr f196028))) (begin ((primitive-ref write-char) #\space) ((primitive-ref write-char) #\.) ((primitive-ref write-char) #\space) ((primitive-ref write) (cdr f196028)))))))))) (closure (f196037) (f196019 f196018 f196017 f196016 f196015 f196014 else (primitive-ref error) (primitive-ref write)) (let ((f196037 f196037)) (if (boolean? f196037) ((vector-ref f196019 0) f196037) (if (null? f196037) ((vector-ref f196018 0)) (if (char? f196037) ((vector-ref f196017 0) f196037) (if (fixnum? f196037) ((vector-ref f196016 0) f196037) (if (string? f196037) ((vector-ref f196015 0) f196037) (if (pair? f196037) ((vector-ref f196014 0) f196037) ((primitive-ref error) ((primitive-ref string->symbol) "write") "unrecognized expression"))))))))))
# emit-begin
#   expr=(begin (begin (vector-set! f196019 0 (closure (f196035) ((primitive-ref write-char) (primitive-ref write-char) (primitive-ref write-char)) (let ((f196035 f196035)) (begin ((primitive-ref write-char) #\#) (if f196035 ((primitive-ref write-char) #\t) ((primitive-ref write-char) #\f)))))) (vector-set! f196018 0 (closure () ((primitive-ref write-char) (primitive-ref write-char)) (let () (begin ((primitive-ref write-char) #\() ((primitive-ref write-char) #\)))))) (vector-set! f196017 0 (closure (f196034) ((primitive-ref write-char) (primitive-ref write-char) (primitive-ref write-char)) (let ((f196034 f196034)) (begin ((primitive-ref write-char) #\#) ((primitive-ref write-char) #\\) ((primitive-ref write-char) f196034))))) (vector-set! f196016 0 (closure (f196031) ((primitive-ref negative?) (primitive-ref write-char) f196016 (primitive-ref map) (primitive-ref write-char) (primitive-ref integer->list)) (let ((f196031 f196031)) (if ((primitive-ref negative?) f196031) (begin ((primitive-ref write-char) #\-) ((vector-ref f196016 0) (fx* -1 f196031))) ((primitive-ref map) (closure (f196033) ((primitive-ref write-char)) (let ((f196033 f196033)) ((primitive-ref write-char) (fixnum->char (fx+ (char->fixnum #\0) f196033))))) ((primitive-ref integer->list) f196031)))))) (vector-set! f196015 0 (closure (f196030) ((primitive-ref write-char) (primitive-ref for-each) (primitive-ref write-char) (primitive-ref string->list) (primitive-ref write-char)) (let ((f196030 f196030)) (begin ((primitive-ref write-char) #\") ((primitive-ref for-each) (primitive-ref write-char) ((primitive-ref string->list) f196030)) ((primitive-ref write-char) #\"))))) (vector-set! f196014 0 (closure (f196029) ((primitive-ref write-char) f196013 (primitive-ref write-char)) (let ((f196029 f196029)) (begin ((primitive-ref write-char) #\() ((vector-ref f196013 0) f196029) ((primitive-ref write-char) #\)))))) (vector-set! f196013 0 (closure (f196028) ((primitive-ref write) (primitive-ref write-char) f196013 else (primitive-ref write-char) (primitive-ref write-char) (primitive-ref write-char) (primitive-ref write)) (let ((f196028 f196028)) (begin ((primitive-ref write) (car f196028)) (if (null? (cdr f196028)) #t (if (pair? (cdr f196028)) (begin ((primitive-ref write-char) #\space) ((vector-ref f196013 0) (cdr f196028))) (begin ((primitive-ref write-char) #\space) ((primitive-ref write-char) #\.) ((primitive-ref write-char) #\space) ((primitive-ref write) (cdr f196028)))))))))) (closure (f196037) (f196019 f196018 f196017 f196016 f196015 f196014 else (primitive-ref error) (primitive-ref write)) (let ((f196037 f196037)) (if (boolean? f196037) ((vector-ref f196019 0) f196037) (if (null? f196037) ((vector-ref f196018 0)) (if (char? f196037) ((vector-ref f196017 0) f196037) (if (fixnum? f196037) ((vector-ref f196016 0) f196037) (if (string? f196037) ((vector-ref f196015 0) f196037) (if (pair? f196037) ((vector-ref f196014 0) f196037) ((primitive-ref error) ((primitive-ref string->symbol) "write") "unrecognized expression"))))))))))
#   env=((f196013 . -24) (f196014 . -20) (f196015 . -16) (f196016 . -12) (f196017 . -8) (f196018 . -4) (f196019 . 0))
# emit-expr (begin (vector-set! f196019 0 (closure (f196035) ((primitive-ref write-char) (primitive-ref write-char) (primitive-ref write-char)) (let ((f196035 f196035)) (begin ((primitive-ref write-char) #\#) (if f196035 ((primitive-ref write-char) #\t) ((primitive-ref write-char) #\f)))))) (vector-set! f196018 0 (closure () ((primitive-ref write-char) (primitive-ref write-char)) (let () (begin ((primitive-ref write-char) #\() ((primitive-ref write-char) #\)))))) (vector-set! f196017 0 (closure (f196034) ((primitive-ref write-char) (primitive-ref write-char) (primitive-ref write-char)) (let ((f196034 f196034)) (begin ((primitive-ref write-char) #\#) ((primitive-ref write-char) #\\) ((primitive-ref write-char) f196034))))) (vector-set! f196016 0 (closure (f196031) ((primitive-ref negative?) (primitive-ref write-char) f196016 (primitive-ref map) (primitive-ref write-char) (primitive-ref integer->list)) (let ((f196031 f196031)) (if ((primitive-ref negative?) f196031) (begin ((primitive-ref write-char) #\-) ((vector-ref f196016 0) (fx* -1 f196031))) ((primitive-ref map) (closure (f196033) ((primitive-ref write-char)) (let ((f196033 f196033)) ((primitive-ref write-char) (fixnum->char (fx+ (char->fixnum #\0) f196033))))) ((primitive-ref integer->list) f196031)))))) (vector-set! f196015 0 (closure (f196030) ((primitive-ref write-char) (primitive-ref for-each) (primitive-ref write-char) (primitive-ref string->list) (primitive-ref write-char)) (let ((f196030 f196030)) (begin ((primitive-ref write-char) #\") ((primitive-ref for-each) (primitive-ref write-char) ((primitive-ref string->list) f196030)) ((primitive-ref write-char) #\"))))) (vector-set! f196014 0 (closure (f196029) ((primitive-ref write-char) f196013 (primitive-ref write-char)) (let ((f196029 f196029)) (begin ((primitive-ref write-char) #\() ((vector-ref f196013 0) f196029) ((primitive-ref write-char) #\)))))) (vector-set! f196013 0 (closure (f196028) ((primitive-ref write) (primitive-ref write-char) f196013 else (primitive-ref write-char) (primitive-ref write-char) (primitive-ref write-char) (primitive-ref write)) (let ((f196028 f196028)) (begin ((primitive-ref write) (car f196028)) (if (null? (cdr f196028)) #t (if (pair? (cdr f196028)) (begin ((primitive-ref write-char) #\space) ((vector-ref f196013 0) (cdr f196028))) (begin ((primitive-ref write-char) #\space) ((primitive-ref write-char) #\.) ((primitive-ref write-char) #\space) ((primitive-ref write) (cdr f196028))))))))))
# emit-begin
#   expr=(begin (vector-set! f196019 0 (closure (f196035) ((primitive-ref write-char) (primitive-ref write-char) (primitive-ref write-char)) (let ((f196035 f196035)) (begin ((primitive-ref write-char) #\#) (if f196035 ((primitive-ref write-char) #\t) ((primitive-ref write-char) #\f)))))) (vector-set! f196018 0 (closure () ((primitive-ref write-char) (primitive-ref write-char)) (let () (begin ((primitive-ref write-char) #\() ((primitive-ref write-char) #\)))))) (vector-set! f196017 0 (closure (f196034) ((primitive-ref write-char) (primitive-ref write-char) (primitive-ref write-char)) (let ((f196034 f196034)) (begin ((primitive-ref write-char) #\#) ((primitive-ref write-char) #\\) ((primitive-ref write-char) f196034))))) (vector-set! f196016 0 (closure (f196031) ((primitive-ref negative?) (primitive-ref write-char) f196016 (primitive-ref map) (primitive-ref write-char) (primitive-ref integer->list)) (let ((f196031 f196031)) (if ((primitive-ref negative?) f196031) (begin ((primitive-ref write-char) #\-) ((vector-ref f196016 0) (fx* -1 f196031))) ((primitive-ref map) (closure (f196033) ((primitive-ref write-char)) (let ((f196033 f196033)) ((primitive-ref write-char) (fixnum->char (fx+ (char->fixnum #\0) f196033))))) ((primitive-ref integer->list) f196031)))))) (vector-set! f196015 0 (closure (f196030) ((primitive-ref write-char) (primitive-ref for-each) (primitive-ref write-char) (primitive-ref string->list) (primitive-ref write-char)) (let ((f196030 f196030)) (begin ((primitive-ref write-char) #\") ((primitive-ref for-each) (primitive-ref write-char) ((primitive-ref string->list) f196030)) ((primitive-ref write-char) #\"))))) (vector-set! f196014 0 (closure (f196029) ((primitive-ref write-char) f196013 (primitive-ref write-char)) (let ((f196029 f196029)) (begin ((primitive-ref write-char) #\() ((vector-ref f196013 0) f196029) ((primitive-ref write-char) #\)))))) (vector-set! f196013 0 (closure (f196028) ((primitive-ref write) (primitive-ref write-char) f196013 else (primitive-ref write-char) (primitive-ref write-char) (primitive-ref write-char) (primitive-ref write)) (let ((f196028 f196028)) (begin ((primitive-ref write) (car f196028)) (if (null? (cdr f196028)) #t (if (pair? (cdr f196028)) (begin ((primitive-ref write-char) #\space) ((vector-ref f196013 0) (cdr f196028))) (begin ((primitive-ref write-char) #\space) ((primitive-ref write-char) #\.) ((primitive-ref write-char) #\space) ((primitive-ref write) (cdr f196028))))))))))
#   env=((f196013 . -24) (f196014 . -20) (f196015 . -16) (f196016 . -12) (f196017 . -8) (f196018 . -4) (f196019 . 0))
# emit-expr (vector-set! f196019 0 (closure (f196035) ((primitive-ref write-char) (primitive-ref write-char) (primitive-ref write-char)) (let ((f196035 f196035)) (begin ((primitive-ref write-char) #\#) (if f196035 ((primitive-ref write-char) #\t) ((primitive-ref write-char) #\f))))))
# emit-expr f196019
# emit-variable-ref
# env=((f196013 . -24) (f196014 . -20) (f196015 . -16) (f196016 . -12) (f196017 . -8) (f196018 . -4) (f196019 . 0))
# var=f196019
    movl 0(%esp), %eax  # stack load f196019
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1424753
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1424753:
    movl %eax, -28(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1424754"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1424754:
# check bounds on vector index
    movl -28(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1424756
    cmp  $0,%eax
    jge _L_1424755
_L_1424756:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1424755:
    movl %eax, -32(%esp)
# emit-expr (closure (f196035) ((primitive-ref write-char) (primitive-ref write-char) (primitive-ref write-char)) (let ((f196035 f196035)) (begin ((primitive-ref write-char) #\#) (if f196035 ((primitive-ref write-char) #\t) ((primitive-ref write-char) #\f)))))
# emit-closure
# si = -36
# env = ((f196013 . -24) (f196014 . -20) (f196015 . -16) (f196016 . -12) (f196017 . -8) (f196018 . -4) (f196019 . 0))
# expr = (closure (f196035) ((primitive-ref write-char) (primitive-ref write-char) (primitive-ref write-char)) (let ((f196035 f196035)) (begin ((primitive-ref write-char) #\#) (if f196035 ((primitive-ref write-char) #\t) ((primitive-ref write-char) #\f)))))
    movl $_L_1424757, 0(%ebp)  # closure label
# WARNING: free var (primitive-ref write-char) not defined in the environmnet
# WARNING: free var (primitive-ref write-char) not defined in the environmnet
# WARNING: free var (primitive-ref write-char) not defined in the environmnet
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $16, %ebp     # bump ebp
    jmp _L_1424758            # jump around closure body
_L_1424757:
# check argument count
    cmp $4,%eax
    je _L_1424759
# invoke error handler eh_argcount
    .extern mrc_eh$uargcount
    movl mrc_eh$uargcount, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_1424759:
# emit-tail-expr
# si=-12
# env=((f196035 . -8) ((primitive-ref write-char) . 12) ((primitive-ref write-char) . 8) ((primitive-ref write-char) . 4) (f196013 . -24) (f196014 . -20) (f196015 . -16) (f196016 . -12) (f196017 . -8) (f196018 . -4) (f196019 . 0))
# expr=(let ((f196035 f196035)) (begin ((primitive-ref write-char) #\#) (if f196035 ((primitive-ref write-char) #\t) ((primitive-ref write-char) #\f))))
# emit-tail-let
#  si   = -12
#  env  = ((f196035 . -8) ((primitive-ref write-char) . 12) ((primitive-ref write-char) . 8) ((primitive-ref write-char) . 4) (f196013 . -24) (f196014 . -20) (f196015 . -16) (f196016 . -12) (f196017 . -8) (f196018 . -4) (f196019 . 0))
#  bindings = ((f196035 f196035))
#  body = (begin ((primitive-ref write-char) #\#) (if f196035 ((primitive-ref write-char) #\t) ((primitive-ref write-char) #\f)))
# emit-expr f196035
# emit-variable-ref
# env=((f196035 . -8) ((primitive-ref write-char) . 12) ((primitive-ref write-char) . 8) ((primitive-ref write-char) . 4) (f196013 . -24) (f196014 . -20) (f196015 . -16) (f196016 . -12) (f196017 . -8) (f196018 . -4) (f196019 . 0))
# var=f196035
    movl -8(%esp), %eax  # stack load f196035
# end emit-variable-ref
    movl %eax, -12(%esp)  # stack save
# emit-tail-expr
# si=-16
# env=((f196035 . -12) (f196035 . -8) ((primitive-ref write-char) . 12) ((primitive-ref write-char) . 8) ((primitive-ref write-char) . 4) (f196013 . -24) (f196014 . -20) (f196015 . -16) (f196016 . -12) (f196017 . -8) (f196018 . -4) (f196019 . 0))
# expr=(begin ((primitive-ref write-char) #\#) (if f196035 ((primitive-ref write-char) #\t) ((primitive-ref write-char) #\f)))
# tail-begin (begin ((primitive-ref write-char) #\#) (if f196035 ((primitive-ref write-char) #\t) ((primitive-ref write-char) #\f)))
#   env=((f196035 . -12) (f196035 . -8) ((primitive-ref write-char) . 12) ((primitive-ref write-char) . 8) ((primitive-ref write-char) . 4) (f196013 . -24) (f196014 . -20) (f196015 . -16) (f196016 . -12) (f196017 . -8) (f196018 . -4) (f196019 . 0))
# emit-expr ((primitive-ref write-char) #\#)
# funcall
#    si   =-16
#    env  = ((f196035 . -12) (f196035 . -8) ((primitive-ref write-char) . 12) ((primitive-ref write-char) . 8) ((primitive-ref write-char) . 4) (f196013 . -24) (f196014 . -20) (f196015 . -16) (f196016 . -12) (f196017 . -8) (f196018 . -4) (f196019 . 0))
#    expr = (funcall (primitive-ref write-char) #\#)
# emit-expr (primitive-ref write-char)
    .extern mrc_write$mchar
    movl mrc_write$mchar,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1424760"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1424760":
   movl %eax,  -24(%esp)  # stash funcall-oper in closure slot
# emit-expr #\#
    movl $8975, %eax     # immed #\#
    mov %eax, -28(%esp)  # arg #
    movl -24(%esp), %edi   # load new closure to %edi
    add $-16, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $16, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
# emit-tail-expr
# si=-16
# env=((f196035 . -12) (f196035 . -8) ((primitive-ref write-char) . 12) ((primitive-ref write-char) . 8) ((primitive-ref write-char) . 4) (f196013 . -24) (f196014 . -20) (f196015 . -16) (f196016 . -12) (f196017 . -8) (f196018 . -4) (f196019 . 0))
# expr=(begin (if f196035 ((primitive-ref write-char) #\t) ((primitive-ref write-char) #\f)))
# tail-begin (begin (if f196035 ((primitive-ref write-char) #\t) ((primitive-ref write-char) #\f)))
#   env=((f196035 . -12) (f196035 . -8) ((primitive-ref write-char) . 12) ((primitive-ref write-char) . 8) ((primitive-ref write-char) . 4) (f196013 . -24) (f196014 . -20) (f196015 . -16) (f196016 . -12) (f196017 . -8) (f196018 . -4) (f196019 . 0))
# emit-tail-expr
# si=-16
# env=((f196035 . -12) (f196035 . -8) ((primitive-ref write-char) . 12) ((primitive-ref write-char) . 8) ((primitive-ref write-char) . 4) (f196013 . -24) (f196014 . -20) (f196015 . -16) (f196016 . -12) (f196017 . -8) (f196018 . -4) (f196019 . 0))
# expr=(if f196035 ((primitive-ref write-char) #\t) ((primitive-ref write-char) #\f))
# emit-expr f196035
# emit-variable-ref
# env=((f196035 . -12) (f196035 . -8) ((primitive-ref write-char) . 12) ((primitive-ref write-char) . 8) ((primitive-ref write-char) . 4) (f196013 . -24) (f196014 . -20) (f196015 . -16) (f196016 . -12) (f196017 . -8) (f196018 . -4) (f196019 . 0))
# var=f196035
    movl -12(%esp), %eax  # stack load f196035
# end emit-variable-ref
    cmp $47, %al
    je _L_1424761
# emit-tail-expr
# si=-16
# env=((f196035 . -12) (f196035 . -8) ((primitive-ref write-char) . 12) ((primitive-ref write-char) . 8) ((primitive-ref write-char) . 4) (f196013 . -24) (f196014 . -20) (f196015 . -16) (f196016 . -12) (f196017 . -8) (f196018 . -4) (f196019 . 0))
# expr=((primitive-ref write-char) #\t)
# emit-tail-funcall
#    si   =-16
#    env  = ((f196035 . -12) (f196035 . -8) ((primitive-ref write-char) . 12) ((primitive-ref write-char) . 8) ((primitive-ref write-char) . 4) (f196013 . -24) (f196014 . -20) (f196015 . -16) (f196016 . -12) (f196017 . -8) (f196018 . -4) (f196019 . 0))
#    expr = (funcall (primitive-ref write-char) #\t)
# emit-expr (primitive-ref write-char)
    .extern mrc_write$mchar
    movl mrc_write$mchar,%eax
   movl %eax,  -16(%esp)  # stash funcall-oper in next closure slot
# emit-expr #\t
    movl $29711, %eax     # immed #\t
    mov %eax, -20(%esp)    # arg t
    movl -16(%esp), %edi   # load new closure to %edi
# emit-shift-args:  size=2   si=-16  delta=12
    mov -16(%esp), %ebx  # shift frame cell
    mov %ebx, -4(%esp)  # down to base
# emit-shift-args:  size=1   si=-20  delta=12
    mov -20(%esp), %ebx  # shift frame cell
    mov %ebx, -8(%esp)  # down to base
# emit-shift-args:  size=0   si=-24  delta=12
    movl $4,%eax   # save arg count
    jmp *-2(%edi)  # tail-funcall
    jmp _L_1424762
_L_1424761:
# emit-tail-expr
# si=-16
# env=((f196035 . -12) (f196035 . -8) ((primitive-ref write-char) . 12) ((primitive-ref write-char) . 8) ((primitive-ref write-char) . 4) (f196013 . -24) (f196014 . -20) (f196015 . -16) (f196016 . -12) (f196017 . -8) (f196018 . -4) (f196019 . 0))
# expr=((primitive-ref write-char) #\f)
# emit-tail-funcall
#    si   =-16
#    env  = ((f196035 . -12) (f196035 . -8) ((primitive-ref write-char) . 12) ((primitive-ref write-char) . 8) ((primitive-ref write-char) . 4) (f196013 . -24) (f196014 . -20) (f196015 . -16) (f196016 . -12) (f196017 . -8) (f196018 . -4) (f196019 . 0))
#    expr = (funcall (primitive-ref write-char) #\f)
# emit-expr (primitive-ref write-char)
    .extern mrc_write$mchar
    movl mrc_write$mchar,%eax
   movl %eax,  -16(%esp)  # stash funcall-oper in next closure slot
# emit-expr #\f
    movl $26127, %eax     # immed #\f
    mov %eax, -20(%esp)    # arg f
    movl -16(%esp), %edi   # load new closure to %edi
# emit-shift-args:  size=2   si=-16  delta=12
    mov -16(%esp), %ebx  # shift frame cell
    mov %ebx, -4(%esp)  # down to base
# emit-shift-args:  size=1   si=-20  delta=12
    mov -20(%esp), %ebx  # shift frame cell
    mov %ebx, -8(%esp)  # down to base
# emit-shift-args:  size=0   si=-24  delta=12
    movl $4,%eax   # save arg count
    jmp *-2(%edi)  # tail-funcall
_L_1424762:
     ret   # return thru stack
    .align 4,0x90
_L_1424758:
    movl -28(%esp), %ebx
    movl -32(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin (vector-set! f196018 0 (closure () ((primitive-ref write-char) (primitive-ref write-char)) (let () (begin ((primitive-ref write-char) #\() ((primitive-ref write-char) #\)))))) (vector-set! f196017 0 (closure (f196034) ((primitive-ref write-char) (primitive-ref write-char) (primitive-ref write-char)) (let ((f196034 f196034)) (begin ((primitive-ref write-char) #\#) ((primitive-ref write-char) #\\) ((primitive-ref write-char) f196034))))) (vector-set! f196016 0 (closure (f196031) ((primitive-ref negative?) (primitive-ref write-char) f196016 (primitive-ref map) (primitive-ref write-char) (primitive-ref integer->list)) (let ((f196031 f196031)) (if ((primitive-ref negative?) f196031) (begin ((primitive-ref write-char) #\-) ((vector-ref f196016 0) (fx* -1 f196031))) ((primitive-ref map) (closure (f196033) ((primitive-ref write-char)) (let ((f196033 f196033)) ((primitive-ref write-char) (fixnum->char (fx+ (char->fixnum #\0) f196033))))) ((primitive-ref integer->list) f196031)))))) (vector-set! f196015 0 (closure (f196030) ((primitive-ref write-char) (primitive-ref for-each) (primitive-ref write-char) (primitive-ref string->list) (primitive-ref write-char)) (let ((f196030 f196030)) (begin ((primitive-ref write-char) #\") ((primitive-ref for-each) (primitive-ref write-char) ((primitive-ref string->list) f196030)) ((primitive-ref write-char) #\"))))) (vector-set! f196014 0 (closure (f196029) ((primitive-ref write-char) f196013 (primitive-ref write-char)) (let ((f196029 f196029)) (begin ((primitive-ref write-char) #\() ((vector-ref f196013 0) f196029) ((primitive-ref write-char) #\)))))) (vector-set! f196013 0 (closure (f196028) ((primitive-ref write) (primitive-ref write-char) f196013 else (primitive-ref write-char) (primitive-ref write-char) (primitive-ref write-char) (primitive-ref write)) (let ((f196028 f196028)) (begin ((primitive-ref write) (car f196028)) (if (null? (cdr f196028)) #t (if (pair? (cdr f196028)) (begin ((primitive-ref write-char) #\space) ((vector-ref f196013 0) (cdr f196028))) (begin ((primitive-ref write-char) #\space) ((primitive-ref write-char) #\.) ((primitive-ref write-char) #\space) ((primitive-ref write) (cdr f196028))))))))))
# emit-begin
#   expr=(begin (vector-set! f196018 0 (closure () ((primitive-ref write-char) (primitive-ref write-char)) (let () (begin ((primitive-ref write-char) #\() ((primitive-ref write-char) #\)))))) (vector-set! f196017 0 (closure (f196034) ((primitive-ref write-char) (primitive-ref write-char) (primitive-ref write-char)) (let ((f196034 f196034)) (begin ((primitive-ref write-char) #\#) ((primitive-ref write-char) #\\) ((primitive-ref write-char) f196034))))) (vector-set! f196016 0 (closure (f196031) ((primitive-ref negative?) (primitive-ref write-char) f196016 (primitive-ref map) (primitive-ref write-char) (primitive-ref integer->list)) (let ((f196031 f196031)) (if ((primitive-ref negative?) f196031) (begin ((primitive-ref write-char) #\-) ((vector-ref f196016 0) (fx* -1 f196031))) ((primitive-ref map) (closure (f196033) ((primitive-ref write-char)) (let ((f196033 f196033)) ((primitive-ref write-char) (fixnum->char (fx+ (char->fixnum #\0) f196033))))) ((primitive-ref integer->list) f196031)))))) (vector-set! f196015 0 (closure (f196030) ((primitive-ref write-char) (primitive-ref for-each) (primitive-ref write-char) (primitive-ref string->list) (primitive-ref write-char)) (let ((f196030 f196030)) (begin ((primitive-ref write-char) #\") ((primitive-ref for-each) (primitive-ref write-char) ((primitive-ref string->list) f196030)) ((primitive-ref write-char) #\"))))) (vector-set! f196014 0 (closure (f196029) ((primitive-ref write-char) f196013 (primitive-ref write-char)) (let ((f196029 f196029)) (begin ((primitive-ref write-char) #\() ((vector-ref f196013 0) f196029) ((primitive-ref write-char) #\)))))) (vector-set! f196013 0 (closure (f196028) ((primitive-ref write) (primitive-ref write-char) f196013 else (primitive-ref write-char) (primitive-ref write-char) (primitive-ref write-char) (primitive-ref write)) (let ((f196028 f196028)) (begin ((primitive-ref write) (car f196028)) (if (null? (cdr f196028)) #t (if (pair? (cdr f196028)) (begin ((primitive-ref write-char) #\space) ((vector-ref f196013 0) (cdr f196028))) (begin ((primitive-ref write-char) #\space) ((primitive-ref write-char) #\.) ((primitive-ref write-char) #\space) ((primitive-ref write) (cdr f196028))))))))))
#   env=((f196013 . -24) (f196014 . -20) (f196015 . -16) (f196016 . -12) (f196017 . -8) (f196018 . -4) (f196019 . 0))
# emit-expr (vector-set! f196018 0 (closure () ((primitive-ref write-char) (primitive-ref write-char)) (let () (begin ((primitive-ref write-char) #\() ((primitive-ref write-char) #\))))))
# emit-expr f196018
# emit-variable-ref
# env=((f196013 . -24) (f196014 . -20) (f196015 . -16) (f196016 . -12) (f196017 . -8) (f196018 . -4) (f196019 . 0))
# var=f196018
    movl -4(%esp), %eax  # stack load f196018
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1424763
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1424763:
    movl %eax, -28(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1424764"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1424764:
# check bounds on vector index
    movl -28(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1424766
    cmp  $0,%eax
    jge _L_1424765
_L_1424766:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1424765:
    movl %eax, -32(%esp)
# emit-expr (closure () ((primitive-ref write-char) (primitive-ref write-char)) (let () (begin ((primitive-ref write-char) #\() ((primitive-ref write-char) #\)))))
# emit-closure
# si = -36
# env = ((f196013 . -24) (f196014 . -20) (f196015 . -16) (f196016 . -12) (f196017 . -8) (f196018 . -4) (f196019 . 0))
# expr = (closure () ((primitive-ref write-char) (primitive-ref write-char)) (let () (begin ((primitive-ref write-char) #\() ((primitive-ref write-char) #\)))))
    movl $_L_1424767, 0(%ebp)  # closure label
# WARNING: free var (primitive-ref write-char) not defined in the environmnet
# WARNING: free var (primitive-ref write-char) not defined in the environmnet
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $16, %ebp     # bump ebp
    jmp _L_1424768            # jump around closure body
_L_1424767:
# check argument count
    cmp $0,%eax
    je _L_1424769
# invoke error handler eh_argcount
    .extern mrc_eh$uargcount
    movl mrc_eh$uargcount, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_1424769:
# emit-tail-expr
# si=-8
# env=(((primitive-ref write-char) . 8) ((primitive-ref write-char) . 4) (f196013 . -24) (f196014 . -20) (f196015 . -16) (f196016 . -12) (f196017 . -8) (f196018 . -4) (f196019 . 0))
# expr=(let () (begin ((primitive-ref write-char) #\() ((primitive-ref write-char) #\))))
# emit-tail-let
#  si   = -8
#  env  = (((primitive-ref write-char) . 8) ((primitive-ref write-char) . 4) (f196013 . -24) (f196014 . -20) (f196015 . -16) (f196016 . -12) (f196017 . -8) (f196018 . -4) (f196019 . 0))
#  bindings = ()
#  body = (begin ((primitive-ref write-char) #\() ((primitive-ref write-char) #\)))
# emit-tail-expr
# si=-8
# env=(((primitive-ref write-char) . 8) ((primitive-ref write-char) . 4) (f196013 . -24) (f196014 . -20) (f196015 . -16) (f196016 . -12) (f196017 . -8) (f196018 . -4) (f196019 . 0))
# expr=(begin ((primitive-ref write-char) #\() ((primitive-ref write-char) #\)))
# tail-begin (begin ((primitive-ref write-char) #\() ((primitive-ref write-char) #\)))
#   env=(((primitive-ref write-char) . 8) ((primitive-ref write-char) . 4) (f196013 . -24) (f196014 . -20) (f196015 . -16) (f196016 . -12) (f196017 . -8) (f196018 . -4) (f196019 . 0))
# emit-expr ((primitive-ref write-char) #\()
# funcall
#    si   =-8
#    env  = (((primitive-ref write-char) . 8) ((primitive-ref write-char) . 4) (f196013 . -24) (f196014 . -20) (f196015 . -16) (f196016 . -12) (f196017 . -8) (f196018 . -4) (f196019 . 0))
#    expr = (funcall (primitive-ref write-char) #\()
# emit-expr (primitive-ref write-char)
    .extern mrc_write$mchar
    movl mrc_write$mchar,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1424770"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1424770":
   movl %eax,  -16(%esp)  # stash funcall-oper in closure slot
# emit-expr #\(
    movl $10255, %eax     # immed #\(
    mov %eax, -20(%esp)  # arg (
    movl -16(%esp), %edi   # load new closure to %edi
    add $-8, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $8, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
# emit-tail-expr
# si=-8
# env=(((primitive-ref write-char) . 8) ((primitive-ref write-char) . 4) (f196013 . -24) (f196014 . -20) (f196015 . -16) (f196016 . -12) (f196017 . -8) (f196018 . -4) (f196019 . 0))
# expr=(begin ((primitive-ref write-char) #\)))
# tail-begin (begin ((primitive-ref write-char) #\)))
#   env=(((primitive-ref write-char) . 8) ((primitive-ref write-char) . 4) (f196013 . -24) (f196014 . -20) (f196015 . -16) (f196016 . -12) (f196017 . -8) (f196018 . -4) (f196019 . 0))
# emit-tail-expr
# si=-8
# env=(((primitive-ref write-char) . 8) ((primitive-ref write-char) . 4) (f196013 . -24) (f196014 . -20) (f196015 . -16) (f196016 . -12) (f196017 . -8) (f196018 . -4) (f196019 . 0))
# expr=((primitive-ref write-char) #\))
# emit-tail-funcall
#    si   =-8
#    env  = (((primitive-ref write-char) . 8) ((primitive-ref write-char) . 4) (f196013 . -24) (f196014 . -20) (f196015 . -16) (f196016 . -12) (f196017 . -8) (f196018 . -4) (f196019 . 0))
#    expr = (funcall (primitive-ref write-char) #\))
# emit-expr (primitive-ref write-char)
    .extern mrc_write$mchar
    movl mrc_write$mchar,%eax
   movl %eax,  -8(%esp)  # stash funcall-oper in next closure slot
# emit-expr #\)
    movl $10511, %eax     # immed #\)
    mov %eax, -12(%esp)    # arg )
    movl -8(%esp), %edi   # load new closure to %edi
# emit-shift-args:  size=2   si=-8  delta=4
    mov -8(%esp), %ebx  # shift frame cell
    mov %ebx, -4(%esp)  # down to base
# emit-shift-args:  size=1   si=-12  delta=4
    mov -12(%esp), %ebx  # shift frame cell
    mov %ebx, -8(%esp)  # down to base
# emit-shift-args:  size=0   si=-16  delta=4
    movl $4,%eax   # save arg count
    jmp *-2(%edi)  # tail-funcall
     ret   # return thru stack
    .align 4,0x90
_L_1424768:
    movl -28(%esp), %ebx
    movl -32(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin (vector-set! f196017 0 (closure (f196034) ((primitive-ref write-char) (primitive-ref write-char) (primitive-ref write-char)) (let ((f196034 f196034)) (begin ((primitive-ref write-char) #\#) ((primitive-ref write-char) #\\) ((primitive-ref write-char) f196034))))) (vector-set! f196016 0 (closure (f196031) ((primitive-ref negative?) (primitive-ref write-char) f196016 (primitive-ref map) (primitive-ref write-char) (primitive-ref integer->list)) (let ((f196031 f196031)) (if ((primitive-ref negative?) f196031) (begin ((primitive-ref write-char) #\-) ((vector-ref f196016 0) (fx* -1 f196031))) ((primitive-ref map) (closure (f196033) ((primitive-ref write-char)) (let ((f196033 f196033)) ((primitive-ref write-char) (fixnum->char (fx+ (char->fixnum #\0) f196033))))) ((primitive-ref integer->list) f196031)))))) (vector-set! f196015 0 (closure (f196030) ((primitive-ref write-char) (primitive-ref for-each) (primitive-ref write-char) (primitive-ref string->list) (primitive-ref write-char)) (let ((f196030 f196030)) (begin ((primitive-ref write-char) #\") ((primitive-ref for-each) (primitive-ref write-char) ((primitive-ref string->list) f196030)) ((primitive-ref write-char) #\"))))) (vector-set! f196014 0 (closure (f196029) ((primitive-ref write-char) f196013 (primitive-ref write-char)) (let ((f196029 f196029)) (begin ((primitive-ref write-char) #\() ((vector-ref f196013 0) f196029) ((primitive-ref write-char) #\)))))) (vector-set! f196013 0 (closure (f196028) ((primitive-ref write) (primitive-ref write-char) f196013 else (primitive-ref write-char) (primitive-ref write-char) (primitive-ref write-char) (primitive-ref write)) (let ((f196028 f196028)) (begin ((primitive-ref write) (car f196028)) (if (null? (cdr f196028)) #t (if (pair? (cdr f196028)) (begin ((primitive-ref write-char) #\space) ((vector-ref f196013 0) (cdr f196028))) (begin ((primitive-ref write-char) #\space) ((primitive-ref write-char) #\.) ((primitive-ref write-char) #\space) ((primitive-ref write) (cdr f196028))))))))))
# emit-begin
#   expr=(begin (vector-set! f196017 0 (closure (f196034) ((primitive-ref write-char) (primitive-ref write-char) (primitive-ref write-char)) (let ((f196034 f196034)) (begin ((primitive-ref write-char) #\#) ((primitive-ref write-char) #\\) ((primitive-ref write-char) f196034))))) (vector-set! f196016 0 (closure (f196031) ((primitive-ref negative?) (primitive-ref write-char) f196016 (primitive-ref map) (primitive-ref write-char) (primitive-ref integer->list)) (let ((f196031 f196031)) (if ((primitive-ref negative?) f196031) (begin ((primitive-ref write-char) #\-) ((vector-ref f196016 0) (fx* -1 f196031))) ((primitive-ref map) (closure (f196033) ((primitive-ref write-char)) (let ((f196033 f196033)) ((primitive-ref write-char) (fixnum->char (fx+ (char->fixnum #\0) f196033))))) ((primitive-ref integer->list) f196031)))))) (vector-set! f196015 0 (closure (f196030) ((primitive-ref write-char) (primitive-ref for-each) (primitive-ref write-char) (primitive-ref string->list) (primitive-ref write-char)) (let ((f196030 f196030)) (begin ((primitive-ref write-char) #\") ((primitive-ref for-each) (primitive-ref write-char) ((primitive-ref string->list) f196030)) ((primitive-ref write-char) #\"))))) (vector-set! f196014 0 (closure (f196029) ((primitive-ref write-char) f196013 (primitive-ref write-char)) (let ((f196029 f196029)) (begin ((primitive-ref write-char) #\() ((vector-ref f196013 0) f196029) ((primitive-ref write-char) #\)))))) (vector-set! f196013 0 (closure (f196028) ((primitive-ref write) (primitive-ref write-char) f196013 else (primitive-ref write-char) (primitive-ref write-char) (primitive-ref write-char) (primitive-ref write)) (let ((f196028 f196028)) (begin ((primitive-ref write) (car f196028)) (if (null? (cdr f196028)) #t (if (pair? (cdr f196028)) (begin ((primitive-ref write-char) #\space) ((vector-ref f196013 0) (cdr f196028))) (begin ((primitive-ref write-char) #\space) ((primitive-ref write-char) #\.) ((primitive-ref write-char) #\space) ((primitive-ref write) (cdr f196028))))))))))
#   env=((f196013 . -24) (f196014 . -20) (f196015 . -16) (f196016 . -12) (f196017 . -8) (f196018 . -4) (f196019 . 0))
# emit-expr (vector-set! f196017 0 (closure (f196034) ((primitive-ref write-char) (primitive-ref write-char) (primitive-ref write-char)) (let ((f196034 f196034)) (begin ((primitive-ref write-char) #\#) ((primitive-ref write-char) #\\) ((primitive-ref write-char) f196034)))))
# emit-expr f196017
# emit-variable-ref
# env=((f196013 . -24) (f196014 . -20) (f196015 . -16) (f196016 . -12) (f196017 . -8) (f196018 . -4) (f196019 . 0))
# var=f196017
    movl -8(%esp), %eax  # stack load f196017
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1424771
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1424771:
    movl %eax, -28(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1424772"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1424772:
# check bounds on vector index
    movl -28(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1424774
    cmp  $0,%eax
    jge _L_1424773
_L_1424774:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1424773:
    movl %eax, -32(%esp)
# emit-expr (closure (f196034) ((primitive-ref write-char) (primitive-ref write-char) (primitive-ref write-char)) (let ((f196034 f196034)) (begin ((primitive-ref write-char) #\#) ((primitive-ref write-char) #\\) ((primitive-ref write-char) f196034))))
# emit-closure
# si = -36
# env = ((f196013 . -24) (f196014 . -20) (f196015 . -16) (f196016 . -12) (f196017 . -8) (f196018 . -4) (f196019 . 0))
# expr = (closure (f196034) ((primitive-ref write-char) (primitive-ref write-char) (primitive-ref write-char)) (let ((f196034 f196034)) (begin ((primitive-ref write-char) #\#) ((primitive-ref write-char) #\\) ((primitive-ref write-char) f196034))))
    movl $_L_1424775, 0(%ebp)  # closure label
# WARNING: free var (primitive-ref write-char) not defined in the environmnet
# WARNING: free var (primitive-ref write-char) not defined in the environmnet
# WARNING: free var (primitive-ref write-char) not defined in the environmnet
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $16, %ebp     # bump ebp
    jmp _L_1424776            # jump around closure body
_L_1424775:
# check argument count
    cmp $4,%eax
    je _L_1424777
# invoke error handler eh_argcount
    .extern mrc_eh$uargcount
    movl mrc_eh$uargcount, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_1424777:
# emit-tail-expr
# si=-12
# env=((f196034 . -8) ((primitive-ref write-char) . 12) ((primitive-ref write-char) . 8) ((primitive-ref write-char) . 4) (f196013 . -24) (f196014 . -20) (f196015 . -16) (f196016 . -12) (f196017 . -8) (f196018 . -4) (f196019 . 0))
# expr=(let ((f196034 f196034)) (begin ((primitive-ref write-char) #\#) ((primitive-ref write-char) #\\) ((primitive-ref write-char) f196034)))
# emit-tail-let
#  si   = -12
#  env  = ((f196034 . -8) ((primitive-ref write-char) . 12) ((primitive-ref write-char) . 8) ((primitive-ref write-char) . 4) (f196013 . -24) (f196014 . -20) (f196015 . -16) (f196016 . -12) (f196017 . -8) (f196018 . -4) (f196019 . 0))
#  bindings = ((f196034 f196034))
#  body = (begin ((primitive-ref write-char) #\#) ((primitive-ref write-char) #\\) ((primitive-ref write-char) f196034))
# emit-expr f196034
# emit-variable-ref
# env=((f196034 . -8) ((primitive-ref write-char) . 12) ((primitive-ref write-char) . 8) ((primitive-ref write-char) . 4) (f196013 . -24) (f196014 . -20) (f196015 . -16) (f196016 . -12) (f196017 . -8) (f196018 . -4) (f196019 . 0))
# var=f196034
    movl -8(%esp), %eax  # stack load f196034
# end emit-variable-ref
    movl %eax, -12(%esp)  # stack save
# emit-tail-expr
# si=-16
# env=((f196034 . -12) (f196034 . -8) ((primitive-ref write-char) . 12) ((primitive-ref write-char) . 8) ((primitive-ref write-char) . 4) (f196013 . -24) (f196014 . -20) (f196015 . -16) (f196016 . -12) (f196017 . -8) (f196018 . -4) (f196019 . 0))
# expr=(begin ((primitive-ref write-char) #\#) ((primitive-ref write-char) #\\) ((primitive-ref write-char) f196034))
# tail-begin (begin ((primitive-ref write-char) #\#) ((primitive-ref write-char) #\\) ((primitive-ref write-char) f196034))
#   env=((f196034 . -12) (f196034 . -8) ((primitive-ref write-char) . 12) ((primitive-ref write-char) . 8) ((primitive-ref write-char) . 4) (f196013 . -24) (f196014 . -20) (f196015 . -16) (f196016 . -12) (f196017 . -8) (f196018 . -4) (f196019 . 0))
# emit-expr ((primitive-ref write-char) #\#)
# funcall
#    si   =-16
#    env  = ((f196034 . -12) (f196034 . -8) ((primitive-ref write-char) . 12) ((primitive-ref write-char) . 8) ((primitive-ref write-char) . 4) (f196013 . -24) (f196014 . -20) (f196015 . -16) (f196016 . -12) (f196017 . -8) (f196018 . -4) (f196019 . 0))
#    expr = (funcall (primitive-ref write-char) #\#)
# emit-expr (primitive-ref write-char)
    .extern mrc_write$mchar
    movl mrc_write$mchar,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1424778"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1424778":
   movl %eax,  -24(%esp)  # stash funcall-oper in closure slot
# emit-expr #\#
    movl $8975, %eax     # immed #\#
    mov %eax, -28(%esp)  # arg #
    movl -24(%esp), %edi   # load new closure to %edi
    add $-16, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $16, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
# emit-tail-expr
# si=-16
# env=((f196034 . -12) (f196034 . -8) ((primitive-ref write-char) . 12) ((primitive-ref write-char) . 8) ((primitive-ref write-char) . 4) (f196013 . -24) (f196014 . -20) (f196015 . -16) (f196016 . -12) (f196017 . -8) (f196018 . -4) (f196019 . 0))
# expr=(begin ((primitive-ref write-char) #\\) ((primitive-ref write-char) f196034))
# tail-begin (begin ((primitive-ref write-char) #\\) ((primitive-ref write-char) f196034))
#   env=((f196034 . -12) (f196034 . -8) ((primitive-ref write-char) . 12) ((primitive-ref write-char) . 8) ((primitive-ref write-char) . 4) (f196013 . -24) (f196014 . -20) (f196015 . -16) (f196016 . -12) (f196017 . -8) (f196018 . -4) (f196019 . 0))
# emit-expr ((primitive-ref write-char) #\\)
# funcall
#    si   =-16
#    env  = ((f196034 . -12) (f196034 . -8) ((primitive-ref write-char) . 12) ((primitive-ref write-char) . 8) ((primitive-ref write-char) . 4) (f196013 . -24) (f196014 . -20) (f196015 . -16) (f196016 . -12) (f196017 . -8) (f196018 . -4) (f196019 . 0))
#    expr = (funcall (primitive-ref write-char) #\\)
# emit-expr (primitive-ref write-char)
    .extern mrc_write$mchar
    movl mrc_write$mchar,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1424779"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1424779":
   movl %eax,  -24(%esp)  # stash funcall-oper in closure slot
# emit-expr #\\
    movl $23567, %eax     # immed #\\
    mov %eax, -28(%esp)  # arg \
    movl -24(%esp), %edi   # load new closure to %edi
    add $-16, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $16, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
# emit-tail-expr
# si=-16
# env=((f196034 . -12) (f196034 . -8) ((primitive-ref write-char) . 12) ((primitive-ref write-char) . 8) ((primitive-ref write-char) . 4) (f196013 . -24) (f196014 . -20) (f196015 . -16) (f196016 . -12) (f196017 . -8) (f196018 . -4) (f196019 . 0))
# expr=(begin ((primitive-ref write-char) f196034))
# tail-begin (begin ((primitive-ref write-char) f196034))
#   env=((f196034 . -12) (f196034 . -8) ((primitive-ref write-char) . 12) ((primitive-ref write-char) . 8) ((primitive-ref write-char) . 4) (f196013 . -24) (f196014 . -20) (f196015 . -16) (f196016 . -12) (f196017 . -8) (f196018 . -4) (f196019 . 0))
# emit-tail-expr
# si=-16
# env=((f196034 . -12) (f196034 . -8) ((primitive-ref write-char) . 12) ((primitive-ref write-char) . 8) ((primitive-ref write-char) . 4) (f196013 . -24) (f196014 . -20) (f196015 . -16) (f196016 . -12) (f196017 . -8) (f196018 . -4) (f196019 . 0))
# expr=((primitive-ref write-char) f196034)
# emit-tail-funcall
#    si   =-16
#    env  = ((f196034 . -12) (f196034 . -8) ((primitive-ref write-char) . 12) ((primitive-ref write-char) . 8) ((primitive-ref write-char) . 4) (f196013 . -24) (f196014 . -20) (f196015 . -16) (f196016 . -12) (f196017 . -8) (f196018 . -4) (f196019 . 0))
#    expr = (funcall (primitive-ref write-char) f196034)
# emit-expr (primitive-ref write-char)
    .extern mrc_write$mchar
    movl mrc_write$mchar,%eax
   movl %eax,  -16(%esp)  # stash funcall-oper in next closure slot
# emit-expr f196034
# emit-variable-ref
# env=((f196034 . -12) (f196034 . -8) ((primitive-ref write-char) . 12) ((primitive-ref write-char) . 8) ((primitive-ref write-char) . 4) (f196013 . -24) (f196014 . -20) (f196015 . -16) (f196016 . -12) (f196017 . -8) (f196018 . -4) (f196019 . 0))
# var=f196034
    movl -12(%esp), %eax  # stack load f196034
# end emit-variable-ref
    mov %eax, -20(%esp)    # arg f196034
    movl -16(%esp), %edi   # load new closure to %edi
# emit-shift-args:  size=2   si=-16  delta=12
    mov -16(%esp), %ebx  # shift frame cell
    mov %ebx, -4(%esp)  # down to base
# emit-shift-args:  size=1   si=-20  delta=12
    mov -20(%esp), %ebx  # shift frame cell
    mov %ebx, -8(%esp)  # down to base
# emit-shift-args:  size=0   si=-24  delta=12
    movl $4,%eax   # save arg count
    jmp *-2(%edi)  # tail-funcall
     ret   # return thru stack
    .align 4,0x90
_L_1424776:
    movl -28(%esp), %ebx
    movl -32(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin (vector-set! f196016 0 (closure (f196031) ((primitive-ref negative?) (primitive-ref write-char) f196016 (primitive-ref map) (primitive-ref write-char) (primitive-ref integer->list)) (let ((f196031 f196031)) (if ((primitive-ref negative?) f196031) (begin ((primitive-ref write-char) #\-) ((vector-ref f196016 0) (fx* -1 f196031))) ((primitive-ref map) (closure (f196033) ((primitive-ref write-char)) (let ((f196033 f196033)) ((primitive-ref write-char) (fixnum->char (fx+ (char->fixnum #\0) f196033))))) ((primitive-ref integer->list) f196031)))))) (vector-set! f196015 0 (closure (f196030) ((primitive-ref write-char) (primitive-ref for-each) (primitive-ref write-char) (primitive-ref string->list) (primitive-ref write-char)) (let ((f196030 f196030)) (begin ((primitive-ref write-char) #\") ((primitive-ref for-each) (primitive-ref write-char) ((primitive-ref string->list) f196030)) ((primitive-ref write-char) #\"))))) (vector-set! f196014 0 (closure (f196029) ((primitive-ref write-char) f196013 (primitive-ref write-char)) (let ((f196029 f196029)) (begin ((primitive-ref write-char) #\() ((vector-ref f196013 0) f196029) ((primitive-ref write-char) #\)))))) (vector-set! f196013 0 (closure (f196028) ((primitive-ref write) (primitive-ref write-char) f196013 else (primitive-ref write-char) (primitive-ref write-char) (primitive-ref write-char) (primitive-ref write)) (let ((f196028 f196028)) (begin ((primitive-ref write) (car f196028)) (if (null? (cdr f196028)) #t (if (pair? (cdr f196028)) (begin ((primitive-ref write-char) #\space) ((vector-ref f196013 0) (cdr f196028))) (begin ((primitive-ref write-char) #\space) ((primitive-ref write-char) #\.) ((primitive-ref write-char) #\space) ((primitive-ref write) (cdr f196028))))))))))
# emit-begin
#   expr=(begin (vector-set! f196016 0 (closure (f196031) ((primitive-ref negative?) (primitive-ref write-char) f196016 (primitive-ref map) (primitive-ref write-char) (primitive-ref integer->list)) (let ((f196031 f196031)) (if ((primitive-ref negative?) f196031) (begin ((primitive-ref write-char) #\-) ((vector-ref f196016 0) (fx* -1 f196031))) ((primitive-ref map) (closure (f196033) ((primitive-ref write-char)) (let ((f196033 f196033)) ((primitive-ref write-char) (fixnum->char (fx+ (char->fixnum #\0) f196033))))) ((primitive-ref integer->list) f196031)))))) (vector-set! f196015 0 (closure (f196030) ((primitive-ref write-char) (primitive-ref for-each) (primitive-ref write-char) (primitive-ref string->list) (primitive-ref write-char)) (let ((f196030 f196030)) (begin ((primitive-ref write-char) #\") ((primitive-ref for-each) (primitive-ref write-char) ((primitive-ref string->list) f196030)) ((primitive-ref write-char) #\"))))) (vector-set! f196014 0 (closure (f196029) ((primitive-ref write-char) f196013 (primitive-ref write-char)) (let ((f196029 f196029)) (begin ((primitive-ref write-char) #\() ((vector-ref f196013 0) f196029) ((primitive-ref write-char) #\)))))) (vector-set! f196013 0 (closure (f196028) ((primitive-ref write) (primitive-ref write-char) f196013 else (primitive-ref write-char) (primitive-ref write-char) (primitive-ref write-char) (primitive-ref write)) (let ((f196028 f196028)) (begin ((primitive-ref write) (car f196028)) (if (null? (cdr f196028)) #t (if (pair? (cdr f196028)) (begin ((primitive-ref write-char) #\space) ((vector-ref f196013 0) (cdr f196028))) (begin ((primitive-ref write-char) #\space) ((primitive-ref write-char) #\.) ((primitive-ref write-char) #\space) ((primitive-ref write) (cdr f196028))))))))))
#   env=((f196013 . -24) (f196014 . -20) (f196015 . -16) (f196016 . -12) (f196017 . -8) (f196018 . -4) (f196019 . 0))
# emit-expr (vector-set! f196016 0 (closure (f196031) ((primitive-ref negative?) (primitive-ref write-char) f196016 (primitive-ref map) (primitive-ref write-char) (primitive-ref integer->list)) (let ((f196031 f196031)) (if ((primitive-ref negative?) f196031) (begin ((primitive-ref write-char) #\-) ((vector-ref f196016 0) (fx* -1 f196031))) ((primitive-ref map) (closure (f196033) ((primitive-ref write-char)) (let ((f196033 f196033)) ((primitive-ref write-char) (fixnum->char (fx+ (char->fixnum #\0) f196033))))) ((primitive-ref integer->list) f196031))))))
# emit-expr f196016
# emit-variable-ref
# env=((f196013 . -24) (f196014 . -20) (f196015 . -16) (f196016 . -12) (f196017 . -8) (f196018 . -4) (f196019 . 0))
# var=f196016
    movl -12(%esp), %eax  # stack load f196016
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1424780
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1424780:
    movl %eax, -28(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1424781"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1424781:
# check bounds on vector index
    movl -28(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1424783
    cmp  $0,%eax
    jge _L_1424782
_L_1424783:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1424782:
    movl %eax, -32(%esp)
# emit-expr (closure (f196031) ((primitive-ref negative?) (primitive-ref write-char) f196016 (primitive-ref map) (primitive-ref write-char) (primitive-ref integer->list)) (let ((f196031 f196031)) (if ((primitive-ref negative?) f196031) (begin ((primitive-ref write-char) #\-) ((vector-ref f196016 0) (fx* -1 f196031))) ((primitive-ref map) (closure (f196033) ((primitive-ref write-char)) (let ((f196033 f196033)) ((primitive-ref write-char) (fixnum->char (fx+ (char->fixnum #\0) f196033))))) ((primitive-ref integer->list) f196031)))))
# emit-closure
# si = -36
# env = ((f196013 . -24) (f196014 . -20) (f196015 . -16) (f196016 . -12) (f196017 . -8) (f196018 . -4) (f196019 . 0))
# expr = (closure (f196031) ((primitive-ref negative?) (primitive-ref write-char) f196016 (primitive-ref map) (primitive-ref write-char) (primitive-ref integer->list)) (let ((f196031 f196031)) (if ((primitive-ref negative?) f196031) (begin ((primitive-ref write-char) #\-) ((vector-ref f196016 0) (fx* -1 f196031))) ((primitive-ref map) (closure (f196033) ((primitive-ref write-char)) (let ((f196033 f196033)) ((primitive-ref write-char) (fixnum->char (fx+ (char->fixnum #\0) f196033))))) ((primitive-ref integer->list) f196031)))))
    movl $_L_1424784, 0(%ebp)  # closure label
# WARNING: free var (primitive-ref negative?) not defined in the environmnet
# WARNING: free var (primitive-ref write-char) not defined in the environmnet
# emit-variable-ref
# env=((f196013 . -24) (f196014 . -20) (f196015 . -16) (f196016 . -12) (f196017 . -8) (f196018 . -4) (f196019 . 0))
# var=f196016
    movl -12(%esp), %eax  # stack load f196016
# end emit-variable-ref
   movl  %eax, 12(%ebp)  # f196016
# WARNING: free var (primitive-ref map) not defined in the environmnet
# WARNING: free var (primitive-ref write-char) not defined in the environmnet
# WARNING: free var (primitive-ref integer->list) not defined in the environmnet
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $32, %ebp     # bump ebp
    jmp _L_1424785            # jump around closure body
_L_1424784:
# check argument count
    cmp $4,%eax
    je _L_1424786
# invoke error handler eh_argcount
    .extern mrc_eh$uargcount
    movl mrc_eh$uargcount, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_1424786:
# emit-tail-expr
# si=-12
# env=((f196031 . -8) ((primitive-ref integer->list) . 24) ((primitive-ref write-char) . 20) ((primitive-ref map) . 16) (f196016 . 12) ((primitive-ref write-char) . 8) ((primitive-ref negative?) . 4) (f196013 . -24) (f196014 . -20) (f196015 . -16) (f196016 . -12) (f196017 . -8) (f196018 . -4) (f196019 . 0))
# expr=(let ((f196031 f196031)) (if ((primitive-ref negative?) f196031) (begin ((primitive-ref write-char) #\-) ((vector-ref f196016 0) (fx* -1 f196031))) ((primitive-ref map) (closure (f196033) ((primitive-ref write-char)) (let ((f196033 f196033)) ((primitive-ref write-char) (fixnum->char (fx+ (char->fixnum #\0) f196033))))) ((primitive-ref integer->list) f196031))))
# emit-tail-let
#  si   = -12
#  env  = ((f196031 . -8) ((primitive-ref integer->list) . 24) ((primitive-ref write-char) . 20) ((primitive-ref map) . 16) (f196016 . 12) ((primitive-ref write-char) . 8) ((primitive-ref negative?) . 4) (f196013 . -24) (f196014 . -20) (f196015 . -16) (f196016 . -12) (f196017 . -8) (f196018 . -4) (f196019 . 0))
#  bindings = ((f196031 f196031))
#  body = (if ((primitive-ref negative?) f196031) (begin ((primitive-ref write-char) #\-) ((vector-ref f196016 0) (fx* -1 f196031))) ((primitive-ref map) (closure (f196033) ((primitive-ref write-char)) (let ((f196033 f196033)) ((primitive-ref write-char) (fixnum->char (fx+ (char->fixnum #\0) f196033))))) ((primitive-ref integer->list) f196031)))
# emit-expr f196031
# emit-variable-ref
# env=((f196031 . -8) ((primitive-ref integer->list) . 24) ((primitive-ref write-char) . 20) ((primitive-ref map) . 16) (f196016 . 12) ((primitive-ref write-char) . 8) ((primitive-ref negative?) . 4) (f196013 . -24) (f196014 . -20) (f196015 . -16) (f196016 . -12) (f196017 . -8) (f196018 . -4) (f196019 . 0))
# var=f196031
    movl -8(%esp), %eax  # stack load f196031
# end emit-variable-ref
    movl %eax, -12(%esp)  # stack save
# emit-tail-expr
# si=-16
# env=((f196031 . -12) (f196031 . -8) ((primitive-ref integer->list) . 24) ((primitive-ref write-char) . 20) ((primitive-ref map) . 16) (f196016 . 12) ((primitive-ref write-char) . 8) ((primitive-ref negative?) . 4) (f196013 . -24) (f196014 . -20) (f196015 . -16) (f196016 . -12) (f196017 . -8) (f196018 . -4) (f196019 . 0))
# expr=(if ((primitive-ref negative?) f196031) (begin ((primitive-ref write-char) #\-) ((vector-ref f196016 0) (fx* -1 f196031))) ((primitive-ref map) (closure (f196033) ((primitive-ref write-char)) (let ((f196033 f196033)) ((primitive-ref write-char) (fixnum->char (fx+ (char->fixnum #\0) f196033))))) ((primitive-ref integer->list) f196031)))
# emit-expr ((primitive-ref negative?) f196031)
# funcall
#    si   =-16
#    env  = ((f196031 . -12) (f196031 . -8) ((primitive-ref integer->list) . 24) ((primitive-ref write-char) . 20) ((primitive-ref map) . 16) (f196016 . 12) ((primitive-ref write-char) . 8) ((primitive-ref negative?) . 4) (f196013 . -24) (f196014 . -20) (f196015 . -16) (f196016 . -12) (f196017 . -8) (f196018 . -4) (f196019 . 0))
#    expr = (funcall (primitive-ref negative?) f196031)
# emit-expr (primitive-ref negative?)
    .extern mrc_negative$q
    movl mrc_negative$q,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1424789"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1424789":
   movl %eax,  -24(%esp)  # stash funcall-oper in closure slot
# emit-expr f196031
# emit-variable-ref
# env=((f196031 . -12) (f196031 . -8) ((primitive-ref integer->list) . 24) ((primitive-ref write-char) . 20) ((primitive-ref map) . 16) (f196016 . 12) ((primitive-ref write-char) . 8) ((primitive-ref negative?) . 4) (f196013 . -24) (f196014 . -20) (f196015 . -16) (f196016 . -12) (f196017 . -8) (f196018 . -4) (f196019 . 0))
# var=f196031
    movl -12(%esp), %eax  # stack load f196031
# end emit-variable-ref
    mov %eax, -28(%esp)  # arg f196031
    movl -24(%esp), %edi   # load new closure to %edi
    add $-16, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $16, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    cmp $47, %al
    je _L_1424787
# emit-tail-expr
# si=-16
# env=((f196031 . -12) (f196031 . -8) ((primitive-ref integer->list) . 24) ((primitive-ref write-char) . 20) ((primitive-ref map) . 16) (f196016 . 12) ((primitive-ref write-char) . 8) ((primitive-ref negative?) . 4) (f196013 . -24) (f196014 . -20) (f196015 . -16) (f196016 . -12) (f196017 . -8) (f196018 . -4) (f196019 . 0))
# expr=(begin ((primitive-ref write-char) #\-) ((vector-ref f196016 0) (fx* -1 f196031)))
# tail-begin (begin ((primitive-ref write-char) #\-) ((vector-ref f196016 0) (fx* -1 f196031)))
#   env=((f196031 . -12) (f196031 . -8) ((primitive-ref integer->list) . 24) ((primitive-ref write-char) . 20) ((primitive-ref map) . 16) (f196016 . 12) ((primitive-ref write-char) . 8) ((primitive-ref negative?) . 4) (f196013 . -24) (f196014 . -20) (f196015 . -16) (f196016 . -12) (f196017 . -8) (f196018 . -4) (f196019 . 0))
# emit-expr ((primitive-ref write-char) #\-)
# funcall
#    si   =-16
#    env  = ((f196031 . -12) (f196031 . -8) ((primitive-ref integer->list) . 24) ((primitive-ref write-char) . 20) ((primitive-ref map) . 16) (f196016 . 12) ((primitive-ref write-char) . 8) ((primitive-ref negative?) . 4) (f196013 . -24) (f196014 . -20) (f196015 . -16) (f196016 . -12) (f196017 . -8) (f196018 . -4) (f196019 . 0))
#    expr = (funcall (primitive-ref write-char) #\-)
# emit-expr (primitive-ref write-char)
    .extern mrc_write$mchar
    movl mrc_write$mchar,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1424790"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1424790":
   movl %eax,  -24(%esp)  # stash funcall-oper in closure slot
# emit-expr #\-
    movl $11535, %eax     # immed #\-
    mov %eax, -28(%esp)  # arg -
    movl -24(%esp), %edi   # load new closure to %edi
    add $-16, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $16, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
# emit-tail-expr
# si=-16
# env=((f196031 . -12) (f196031 . -8) ((primitive-ref integer->list) . 24) ((primitive-ref write-char) . 20) ((primitive-ref map) . 16) (f196016 . 12) ((primitive-ref write-char) . 8) ((primitive-ref negative?) . 4) (f196013 . -24) (f196014 . -20) (f196015 . -16) (f196016 . -12) (f196017 . -8) (f196018 . -4) (f196019 . 0))
# expr=(begin ((vector-ref f196016 0) (fx* -1 f196031)))
# tail-begin (begin ((vector-ref f196016 0) (fx* -1 f196031)))
#   env=((f196031 . -12) (f196031 . -8) ((primitive-ref integer->list) . 24) ((primitive-ref write-char) . 20) ((primitive-ref map) . 16) (f196016 . 12) ((primitive-ref write-char) . 8) ((primitive-ref negative?) . 4) (f196013 . -24) (f196014 . -20) (f196015 . -16) (f196016 . -12) (f196017 . -8) (f196018 . -4) (f196019 . 0))
# emit-tail-expr
# si=-16
# env=((f196031 . -12) (f196031 . -8) ((primitive-ref integer->list) . 24) ((primitive-ref write-char) . 20) ((primitive-ref map) . 16) (f196016 . 12) ((primitive-ref write-char) . 8) ((primitive-ref negative?) . 4) (f196013 . -24) (f196014 . -20) (f196015 . -16) (f196016 . -12) (f196017 . -8) (f196018 . -4) (f196019 . 0))
# expr=((vector-ref f196016 0) (fx* -1 f196031))
# emit-tail-funcall
#    si   =-16
#    env  = ((f196031 . -12) (f196031 . -8) ((primitive-ref integer->list) . 24) ((primitive-ref write-char) . 20) ((primitive-ref map) . 16) (f196016 . 12) ((primitive-ref write-char) . 8) ((primitive-ref negative?) . 4) (f196013 . -24) (f196014 . -20) (f196015 . -16) (f196016 . -12) (f196017 . -8) (f196018 . -4) (f196019 . 0))
#    expr = (funcall (vector-ref f196016 0) (fx* -1 f196031))
# emit-expr (vector-ref f196016 0)
# emit-expr f196016
# emit-variable-ref
# env=((f196031 . -12) (f196031 . -8) ((primitive-ref integer->list) . 24) ((primitive-ref write-char) . 20) ((primitive-ref map) . 16) (f196016 . 12) ((primitive-ref write-char) . 8) ((primitive-ref negative?) . 4) (f196013 . -24) (f196014 . -20) (f196015 . -16) (f196016 . -12) (f196017 . -8) (f196018 . -4) (f196019 . 0))
# var=f196016
    movl 10(%edi), %eax  # frame load f196016
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1424791
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1424791:
    movl %eax, -16(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1424792"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1424792:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1424794
    cmp  $0,%eax
    jge _L_1424793
_L_1424794:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1424793:
    movl -16(%esp), %esi
    movl -1(%eax,%esi), %eax
   movl %eax,  -16(%esp)  # stash funcall-oper in next closure slot
# emit-expr (fx* -1 f196031)
# emit-expr f196031
# emit-variable-ref
# env=((f196031 . -12) (f196031 . -8) ((primitive-ref integer->list) . 24) ((primitive-ref write-char) . 20) ((primitive-ref map) . 16) (f196016 . 12) ((primitive-ref write-char) . 8) ((primitive-ref negative?) . 4) (f196013 . -24) (f196014 . -20) (f196015 . -16) (f196016 . -12) (f196017 . -8) (f196018 . -4) (f196019 . 0))
# var=f196031
    movl -12(%esp), %eax  # stack load f196031
# end emit-variable-ref
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1424795"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $88,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1424795:
    sar $2, %eax
    movl %eax, -20(%esp)
# emit-expr -1
    movl $-4, %eax     # immed -1
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1424796"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $88,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1424796:
    imul -20(%esp), %eax
    mov %eax, -20(%esp)    # arg (fx* -1 f196031)
    movl -16(%esp), %edi   # load new closure to %edi
# emit-shift-args:  size=2   si=-16  delta=12
    mov -16(%esp), %ebx  # shift frame cell
    mov %ebx, -4(%esp)  # down to base
# emit-shift-args:  size=1   si=-20  delta=12
    mov -20(%esp), %ebx  # shift frame cell
    mov %ebx, -8(%esp)  # down to base
# emit-shift-args:  size=0   si=-24  delta=12
    movl $4,%eax   # save arg count
    jmp *-2(%edi)  # tail-funcall
     ret   # return thru stack
    jmp _L_1424788
_L_1424787:
# emit-tail-expr
# si=-16
# env=((f196031 . -12) (f196031 . -8) ((primitive-ref integer->list) . 24) ((primitive-ref write-char) . 20) ((primitive-ref map) . 16) (f196016 . 12) ((primitive-ref write-char) . 8) ((primitive-ref negative?) . 4) (f196013 . -24) (f196014 . -20) (f196015 . -16) (f196016 . -12) (f196017 . -8) (f196018 . -4) (f196019 . 0))
# expr=((primitive-ref map) (closure (f196033) ((primitive-ref write-char)) (let ((f196033 f196033)) ((primitive-ref write-char) (fixnum->char (fx+ (char->fixnum #\0) f196033))))) ((primitive-ref integer->list) f196031))
# emit-tail-funcall
#    si   =-16
#    env  = ((f196031 . -12) (f196031 . -8) ((primitive-ref integer->list) . 24) ((primitive-ref write-char) . 20) ((primitive-ref map) . 16) (f196016 . 12) ((primitive-ref write-char) . 8) ((primitive-ref negative?) . 4) (f196013 . -24) (f196014 . -20) (f196015 . -16) (f196016 . -12) (f196017 . -8) (f196018 . -4) (f196019 . 0))
#    expr = (funcall (primitive-ref map) (closure (f196033) ((primitive-ref write-char)) (let ((f196033 f196033)) ((primitive-ref write-char) (fixnum->char (fx+ (char->fixnum #\0) f196033))))) ((primitive-ref integer->list) f196031))
# emit-expr (primitive-ref map)
    .extern mrc_map
    movl mrc_map,%eax
   movl %eax,  -16(%esp)  # stash funcall-oper in next closure slot
# emit-expr (closure (f196033) ((primitive-ref write-char)) (let ((f196033 f196033)) ((primitive-ref write-char) (fixnum->char (fx+ (char->fixnum #\0) f196033)))))
# emit-closure
# si = -20
# env = ((f196031 . -12) (f196031 . -8) ((primitive-ref integer->list) . 24) ((primitive-ref write-char) . 20) ((primitive-ref map) . 16) (f196016 . 12) ((primitive-ref write-char) . 8) ((primitive-ref negative?) . 4) (f196013 . -24) (f196014 . -20) (f196015 . -16) (f196016 . -12) (f196017 . -8) (f196018 . -4) (f196019 . 0))
# expr = (closure (f196033) ((primitive-ref write-char)) (let ((f196033 f196033)) ((primitive-ref write-char) (fixnum->char (fx+ (char->fixnum #\0) f196033)))))
    movl $_L_1424797, 0(%ebp)  # closure label
# emit-variable-ref
# env=((f196031 . -12) (f196031 . -8) ((primitive-ref integer->list) . 24) ((primitive-ref write-char) . 20) ((primitive-ref map) . 16) (f196016 . 12) ((primitive-ref write-char) . 8) ((primitive-ref negative?) . 4) (f196013 . -24) (f196014 . -20) (f196015 . -16) (f196016 . -12) (f196017 . -8) (f196018 . -4) (f196019 . 0))
# var=(primitive-ref write-char)
    movl 18(%edi), %eax  # frame load (primitive-ref write-char)
# end emit-variable-ref
   movl  %eax, 4(%ebp)  # (primitive-ref write-char)
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $8, %ebp     # bump ebp
    jmp _L_1424798            # jump around closure body
_L_1424797:
# check argument count
    cmp $4,%eax
    je _L_1424799
# invoke error handler eh_argcount
    .extern mrc_eh$uargcount
    movl mrc_eh$uargcount, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_1424799:
# emit-tail-expr
# si=-12
# env=((f196033 . -8) ((primitive-ref write-char) . 4) (f196031 . -12) (f196031 . -8) ((primitive-ref integer->list) . 24) ((primitive-ref write-char) . 20) ((primitive-ref map) . 16) (f196016 . 12) ((primitive-ref write-char) . 8) ((primitive-ref negative?) . 4) (f196013 . -24) (f196014 . -20) (f196015 . -16) (f196016 . -12) (f196017 . -8) (f196018 . -4) (f196019 . 0))
# expr=(let ((f196033 f196033)) ((primitive-ref write-char) (fixnum->char (fx+ (char->fixnum #\0) f196033))))
# emit-tail-let
#  si   = -12
#  env  = ((f196033 . -8) ((primitive-ref write-char) . 4) (f196031 . -12) (f196031 . -8) ((primitive-ref integer->list) . 24) ((primitive-ref write-char) . 20) ((primitive-ref map) . 16) (f196016 . 12) ((primitive-ref write-char) . 8) ((primitive-ref negative?) . 4) (f196013 . -24) (f196014 . -20) (f196015 . -16) (f196016 . -12) (f196017 . -8) (f196018 . -4) (f196019 . 0))
#  bindings = ((f196033 f196033))
#  body = ((primitive-ref write-char) (fixnum->char (fx+ (char->fixnum #\0) f196033)))
# emit-expr f196033
# emit-variable-ref
# env=((f196033 . -8) ((primitive-ref write-char) . 4) (f196031 . -12) (f196031 . -8) ((primitive-ref integer->list) . 24) ((primitive-ref write-char) . 20) ((primitive-ref map) . 16) (f196016 . 12) ((primitive-ref write-char) . 8) ((primitive-ref negative?) . 4) (f196013 . -24) (f196014 . -20) (f196015 . -16) (f196016 . -12) (f196017 . -8) (f196018 . -4) (f196019 . 0))
# var=f196033
    movl -8(%esp), %eax  # stack load f196033
# end emit-variable-ref
    movl %eax, -12(%esp)  # stack save
# emit-tail-expr
# si=-16
# env=((f196033 . -12) (f196033 . -8) ((primitive-ref write-char) . 4) (f196031 . -12) (f196031 . -8) ((primitive-ref integer->list) . 24) ((primitive-ref write-char) . 20) ((primitive-ref map) . 16) (f196016 . 12) ((primitive-ref write-char) . 8) ((primitive-ref negative?) . 4) (f196013 . -24) (f196014 . -20) (f196015 . -16) (f196016 . -12) (f196017 . -8) (f196018 . -4) (f196019 . 0))
# expr=((primitive-ref write-char) (fixnum->char (fx+ (char->fixnum #\0) f196033)))
# emit-tail-funcall
#    si   =-16
#    env  = ((f196033 . -12) (f196033 . -8) ((primitive-ref write-char) . 4) (f196031 . -12) (f196031 . -8) ((primitive-ref integer->list) . 24) ((primitive-ref write-char) . 20) ((primitive-ref map) . 16) (f196016 . 12) ((primitive-ref write-char) . 8) ((primitive-ref negative?) . 4) (f196013 . -24) (f196014 . -20) (f196015 . -16) (f196016 . -12) (f196017 . -8) (f196018 . -4) (f196019 . 0))
#    expr = (funcall (primitive-ref write-char) (fixnum->char (fx+ (char->fixnum #\0) f196033)))
# emit-expr (primitive-ref write-char)
    .extern mrc_write$mchar
    movl mrc_write$mchar,%eax
   movl %eax,  -16(%esp)  # stash funcall-oper in next closure slot
# emit-expr (fixnum->char (fx+ (char->fixnum #\0) f196033))
# emit-expr (fx+ (char->fixnum #\0) f196033)
# emit-expr f196033
# emit-variable-ref
# env=((f196033 . -12) (f196033 . -8) ((primitive-ref write-char) . 4) (f196031 . -12) (f196031 . -8) ((primitive-ref integer->list) . 24) ((primitive-ref write-char) . 20) ((primitive-ref map) . 16) (f196016 . 12) ((primitive-ref write-char) . 8) ((primitive-ref negative?) . 4) (f196013 . -24) (f196014 . -20) (f196015 . -16) (f196016 . -12) (f196017 . -8) (f196018 . -4) (f196019 . 0))
# var=f196033
    movl -12(%esp), %eax  # stack load f196033
# end emit-variable-ref
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1424800"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $80,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1424800:
    movl %eax, -20(%esp)  # fx+ push arg1
# emit-expr (char->fixnum #\0)
# emit-expr #\0
    movl $12303, %eax     # immed #\0
# check the argument is a char
    movl %eax,%ebx
    and $255, %bl
    cmp $15, %bl
    je "_L_1424801"
# invoke error handler eh_character
    .extern mrc_eh$ucharacter
    movl mrc_eh$ucharacter, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $4,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1424801:
   shrl $8, %eax
   shll $2, %eax
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1424802"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $80,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1424802:
    addl -20(%esp), %eax  # fx+ arg1 arg2
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1424803"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $0,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1424803:
    shll $6, %eax
    orl $15, %eax
    mov %eax, -20(%esp)    # arg (fixnum->char (fx+ (char->fixnum 0) f196033))
    movl -16(%esp), %edi   # load new closure to %edi
# emit-shift-args:  size=2   si=-16  delta=12
    mov -16(%esp), %ebx  # shift frame cell
    mov %ebx, -4(%esp)  # down to base
# emit-shift-args:  size=1   si=-20  delta=12
    mov -20(%esp), %ebx  # shift frame cell
    mov %ebx, -8(%esp)  # down to base
# emit-shift-args:  size=0   si=-24  delta=12
    movl $4,%eax   # save arg count
    jmp *-2(%edi)  # tail-funcall
    .align 4,0x90
_L_1424798:
    mov %eax, -20(%esp)    # arg (closure (f196033) ((primitive-ref write-char)) (let ((f196033 f196033)) ((primitive-ref write-char) (fixnum->char (fx+ (char->fixnum 0) f196033)))))
# emit-expr ((primitive-ref integer->list) f196031)
# funcall
#    si   =-24
#    env  = ((f196031 . -12) (f196031 . -8) ((primitive-ref integer->list) . 24) ((primitive-ref write-char) . 20) ((primitive-ref map) . 16) (f196016 . 12) ((primitive-ref write-char) . 8) ((primitive-ref negative?) . 4) (f196013 . -24) (f196014 . -20) (f196015 . -16) (f196016 . -12) (f196017 . -8) (f196018 . -4) (f196019 . 0))
#    expr = (funcall (primitive-ref integer->list) f196031)
# emit-expr (primitive-ref integer->list)
    .extern mrc_integer$m$glist
    movl mrc_integer$m$glist,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1424804"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1424804":
   movl %eax,  -32(%esp)  # stash funcall-oper in closure slot
# emit-expr f196031
# emit-variable-ref
# env=((f196031 . -12) (f196031 . -8) ((primitive-ref integer->list) . 24) ((primitive-ref write-char) . 20) ((primitive-ref map) . 16) (f196016 . 12) ((primitive-ref write-char) . 8) ((primitive-ref negative?) . 4) (f196013 . -24) (f196014 . -20) (f196015 . -16) (f196016 . -12) (f196017 . -8) (f196018 . -4) (f196019 . 0))
# var=f196031
    movl -12(%esp), %eax  # stack load f196031
# end emit-variable-ref
    mov %eax, -36(%esp)  # arg f196031
    movl -32(%esp), %edi   # load new closure to %edi
    add $-24, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $24, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    mov %eax, -24(%esp)    # arg ((primitive-ref integer->list) f196031)
    movl -16(%esp), %edi   # load new closure to %edi
# emit-shift-args:  size=3   si=-16  delta=12
    mov -16(%esp), %ebx  # shift frame cell
    mov %ebx, -4(%esp)  # down to base
# emit-shift-args:  size=2   si=-20  delta=12
    mov -20(%esp), %ebx  # shift frame cell
    mov %ebx, -8(%esp)  # down to base
# emit-shift-args:  size=1   si=-24  delta=12
    mov -24(%esp), %ebx  # shift frame cell
    mov %ebx, -12(%esp)  # down to base
# emit-shift-args:  size=0   si=-28  delta=12
    movl $8,%eax   # save arg count
    jmp *-2(%edi)  # tail-funcall
_L_1424788:
    .align 4,0x90
_L_1424785:
    movl -28(%esp), %ebx
    movl -32(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin (vector-set! f196015 0 (closure (f196030) ((primitive-ref write-char) (primitive-ref for-each) (primitive-ref write-char) (primitive-ref string->list) (primitive-ref write-char)) (let ((f196030 f196030)) (begin ((primitive-ref write-char) #\") ((primitive-ref for-each) (primitive-ref write-char) ((primitive-ref string->list) f196030)) ((primitive-ref write-char) #\"))))) (vector-set! f196014 0 (closure (f196029) ((primitive-ref write-char) f196013 (primitive-ref write-char)) (let ((f196029 f196029)) (begin ((primitive-ref write-char) #\() ((vector-ref f196013 0) f196029) ((primitive-ref write-char) #\)))))) (vector-set! f196013 0 (closure (f196028) ((primitive-ref write) (primitive-ref write-char) f196013 else (primitive-ref write-char) (primitive-ref write-char) (primitive-ref write-char) (primitive-ref write)) (let ((f196028 f196028)) (begin ((primitive-ref write) (car f196028)) (if (null? (cdr f196028)) #t (if (pair? (cdr f196028)) (begin ((primitive-ref write-char) #\space) ((vector-ref f196013 0) (cdr f196028))) (begin ((primitive-ref write-char) #\space) ((primitive-ref write-char) #\.) ((primitive-ref write-char) #\space) ((primitive-ref write) (cdr f196028))))))))))
# emit-begin
#   expr=(begin (vector-set! f196015 0 (closure (f196030) ((primitive-ref write-char) (primitive-ref for-each) (primitive-ref write-char) (primitive-ref string->list) (primitive-ref write-char)) (let ((f196030 f196030)) (begin ((primitive-ref write-char) #\") ((primitive-ref for-each) (primitive-ref write-char) ((primitive-ref string->list) f196030)) ((primitive-ref write-char) #\"))))) (vector-set! f196014 0 (closure (f196029) ((primitive-ref write-char) f196013 (primitive-ref write-char)) (let ((f196029 f196029)) (begin ((primitive-ref write-char) #\() ((vector-ref f196013 0) f196029) ((primitive-ref write-char) #\)))))) (vector-set! f196013 0 (closure (f196028) ((primitive-ref write) (primitive-ref write-char) f196013 else (primitive-ref write-char) (primitive-ref write-char) (primitive-ref write-char) (primitive-ref write)) (let ((f196028 f196028)) (begin ((primitive-ref write) (car f196028)) (if (null? (cdr f196028)) #t (if (pair? (cdr f196028)) (begin ((primitive-ref write-char) #\space) ((vector-ref f196013 0) (cdr f196028))) (begin ((primitive-ref write-char) #\space) ((primitive-ref write-char) #\.) ((primitive-ref write-char) #\space) ((primitive-ref write) (cdr f196028))))))))))
#   env=((f196013 . -24) (f196014 . -20) (f196015 . -16) (f196016 . -12) (f196017 . -8) (f196018 . -4) (f196019 . 0))
# emit-expr (vector-set! f196015 0 (closure (f196030) ((primitive-ref write-char) (primitive-ref for-each) (primitive-ref write-char) (primitive-ref string->list) (primitive-ref write-char)) (let ((f196030 f196030)) (begin ((primitive-ref write-char) #\") ((primitive-ref for-each) (primitive-ref write-char) ((primitive-ref string->list) f196030)) ((primitive-ref write-char) #\")))))
# emit-expr f196015
# emit-variable-ref
# env=((f196013 . -24) (f196014 . -20) (f196015 . -16) (f196016 . -12) (f196017 . -8) (f196018 . -4) (f196019 . 0))
# var=f196015
    movl -16(%esp), %eax  # stack load f196015
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1424805
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1424805:
    movl %eax, -28(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1424806"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1424806:
# check bounds on vector index
    movl -28(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1424808
    cmp  $0,%eax
    jge _L_1424807
_L_1424808:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1424807:
    movl %eax, -32(%esp)
# emit-expr (closure (f196030) ((primitive-ref write-char) (primitive-ref for-each) (primitive-ref write-char) (primitive-ref string->list) (primitive-ref write-char)) (let ((f196030 f196030)) (begin ((primitive-ref write-char) #\") ((primitive-ref for-each) (primitive-ref write-char) ((primitive-ref string->list) f196030)) ((primitive-ref write-char) #\"))))
# emit-closure
# si = -36
# env = ((f196013 . -24) (f196014 . -20) (f196015 . -16) (f196016 . -12) (f196017 . -8) (f196018 . -4) (f196019 . 0))
# expr = (closure (f196030) ((primitive-ref write-char) (primitive-ref for-each) (primitive-ref write-char) (primitive-ref string->list) (primitive-ref write-char)) (let ((f196030 f196030)) (begin ((primitive-ref write-char) #\") ((primitive-ref for-each) (primitive-ref write-char) ((primitive-ref string->list) f196030)) ((primitive-ref write-char) #\"))))
    movl $_L_1424809, 0(%ebp)  # closure label
# WARNING: free var (primitive-ref write-char) not defined in the environmnet
# WARNING: free var (primitive-ref for-each) not defined in the environmnet
# WARNING: free var (primitive-ref write-char) not defined in the environmnet
# WARNING: free var (primitive-ref string->list) not defined in the environmnet
# WARNING: free var (primitive-ref write-char) not defined in the environmnet
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $24, %ebp     # bump ebp
    jmp _L_1424810            # jump around closure body
_L_1424809:
# check argument count
    cmp $4,%eax
    je _L_1424811
# invoke error handler eh_argcount
    .extern mrc_eh$uargcount
    movl mrc_eh$uargcount, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_1424811:
# emit-tail-expr
# si=-12
# env=((f196030 . -8) ((primitive-ref write-char) . 20) ((primitive-ref string->list) . 16) ((primitive-ref write-char) . 12) ((primitive-ref for-each) . 8) ((primitive-ref write-char) . 4) (f196013 . -24) (f196014 . -20) (f196015 . -16) (f196016 . -12) (f196017 . -8) (f196018 . -4) (f196019 . 0))
# expr=(let ((f196030 f196030)) (begin ((primitive-ref write-char) #\") ((primitive-ref for-each) (primitive-ref write-char) ((primitive-ref string->list) f196030)) ((primitive-ref write-char) #\")))
# emit-tail-let
#  si   = -12
#  env  = ((f196030 . -8) ((primitive-ref write-char) . 20) ((primitive-ref string->list) . 16) ((primitive-ref write-char) . 12) ((primitive-ref for-each) . 8) ((primitive-ref write-char) . 4) (f196013 . -24) (f196014 . -20) (f196015 . -16) (f196016 . -12) (f196017 . -8) (f196018 . -4) (f196019 . 0))
#  bindings = ((f196030 f196030))
#  body = (begin ((primitive-ref write-char) #\") ((primitive-ref for-each) (primitive-ref write-char) ((primitive-ref string->list) f196030)) ((primitive-ref write-char) #\"))
# emit-expr f196030
# emit-variable-ref
# env=((f196030 . -8) ((primitive-ref write-char) . 20) ((primitive-ref string->list) . 16) ((primitive-ref write-char) . 12) ((primitive-ref for-each) . 8) ((primitive-ref write-char) . 4) (f196013 . -24) (f196014 . -20) (f196015 . -16) (f196016 . -12) (f196017 . -8) (f196018 . -4) (f196019 . 0))
# var=f196030
    movl -8(%esp), %eax  # stack load f196030
# end emit-variable-ref
    movl %eax, -12(%esp)  # stack save
# emit-tail-expr
# si=-16
# env=((f196030 . -12) (f196030 . -8) ((primitive-ref write-char) . 20) ((primitive-ref string->list) . 16) ((primitive-ref write-char) . 12) ((primitive-ref for-each) . 8) ((primitive-ref write-char) . 4) (f196013 . -24) (f196014 . -20) (f196015 . -16) (f196016 . -12) (f196017 . -8) (f196018 . -4) (f196019 . 0))
# expr=(begin ((primitive-ref write-char) #\") ((primitive-ref for-each) (primitive-ref write-char) ((primitive-ref string->list) f196030)) ((primitive-ref write-char) #\"))
# tail-begin (begin ((primitive-ref write-char) #\") ((primitive-ref for-each) (primitive-ref write-char) ((primitive-ref string->list) f196030)) ((primitive-ref write-char) #\"))
#   env=((f196030 . -12) (f196030 . -8) ((primitive-ref write-char) . 20) ((primitive-ref string->list) . 16) ((primitive-ref write-char) . 12) ((primitive-ref for-each) . 8) ((primitive-ref write-char) . 4) (f196013 . -24) (f196014 . -20) (f196015 . -16) (f196016 . -12) (f196017 . -8) (f196018 . -4) (f196019 . 0))
# emit-expr ((primitive-ref write-char) #\")
# funcall
#    si   =-16
#    env  = ((f196030 . -12) (f196030 . -8) ((primitive-ref write-char) . 20) ((primitive-ref string->list) . 16) ((primitive-ref write-char) . 12) ((primitive-ref for-each) . 8) ((primitive-ref write-char) . 4) (f196013 . -24) (f196014 . -20) (f196015 . -16) (f196016 . -12) (f196017 . -8) (f196018 . -4) (f196019 . 0))
#    expr = (funcall (primitive-ref write-char) #\")
# emit-expr (primitive-ref write-char)
    .extern mrc_write$mchar
    movl mrc_write$mchar,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1424812"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1424812":
   movl %eax,  -24(%esp)  # stash funcall-oper in closure slot
# emit-expr #\"
    movl $8719, %eax     # immed #\"
    mov %eax, -28(%esp)  # arg "
    movl -24(%esp), %edi   # load new closure to %edi
    add $-16, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $16, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
# emit-tail-expr
# si=-16
# env=((f196030 . -12) (f196030 . -8) ((primitive-ref write-char) . 20) ((primitive-ref string->list) . 16) ((primitive-ref write-char) . 12) ((primitive-ref for-each) . 8) ((primitive-ref write-char) . 4) (f196013 . -24) (f196014 . -20) (f196015 . -16) (f196016 . -12) (f196017 . -8) (f196018 . -4) (f196019 . 0))
# expr=(begin ((primitive-ref for-each) (primitive-ref write-char) ((primitive-ref string->list) f196030)) ((primitive-ref write-char) #\"))
# tail-begin (begin ((primitive-ref for-each) (primitive-ref write-char) ((primitive-ref string->list) f196030)) ((primitive-ref write-char) #\"))
#   env=((f196030 . -12) (f196030 . -8) ((primitive-ref write-char) . 20) ((primitive-ref string->list) . 16) ((primitive-ref write-char) . 12) ((primitive-ref for-each) . 8) ((primitive-ref write-char) . 4) (f196013 . -24) (f196014 . -20) (f196015 . -16) (f196016 . -12) (f196017 . -8) (f196018 . -4) (f196019 . 0))
# emit-expr ((primitive-ref for-each) (primitive-ref write-char) ((primitive-ref string->list) f196030))
# funcall
#    si   =-16
#    env  = ((f196030 . -12) (f196030 . -8) ((primitive-ref write-char) . 20) ((primitive-ref string->list) . 16) ((primitive-ref write-char) . 12) ((primitive-ref for-each) . 8) ((primitive-ref write-char) . 4) (f196013 . -24) (f196014 . -20) (f196015 . -16) (f196016 . -12) (f196017 . -8) (f196018 . -4) (f196019 . 0))
#    expr = (funcall (primitive-ref for-each) (primitive-ref write-char) ((primitive-ref string->list) f196030))
# emit-expr (primitive-ref for-each)
    .extern mrc_for$meach
    movl mrc_for$meach,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1424813"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1424813":
   movl %eax,  -24(%esp)  # stash funcall-oper in closure slot
# emit-expr (primitive-ref write-char)
    .extern mrc_write$mchar
    movl mrc_write$mchar,%eax
    mov %eax, -28(%esp)  # arg (primitive-ref write-char)
# emit-expr ((primitive-ref string->list) f196030)
# funcall
#    si   =-32
#    env  = ((f196030 . -12) (f196030 . -8) ((primitive-ref write-char) . 20) ((primitive-ref string->list) . 16) ((primitive-ref write-char) . 12) ((primitive-ref for-each) . 8) ((primitive-ref write-char) . 4) (f196013 . -24) (f196014 . -20) (f196015 . -16) (f196016 . -12) (f196017 . -8) (f196018 . -4) (f196019 . 0))
#    expr = (funcall (primitive-ref string->list) f196030)
# emit-expr (primitive-ref string->list)
    .extern mrc_string$m$glist
    movl mrc_string$m$glist,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1424814"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1424814":
   movl %eax,  -40(%esp)  # stash funcall-oper in closure slot
# emit-expr f196030
# emit-variable-ref
# env=((f196030 . -12) (f196030 . -8) ((primitive-ref write-char) . 20) ((primitive-ref string->list) . 16) ((primitive-ref write-char) . 12) ((primitive-ref for-each) . 8) ((primitive-ref write-char) . 4) (f196013 . -24) (f196014 . -20) (f196015 . -16) (f196016 . -12) (f196017 . -8) (f196018 . -4) (f196019 . 0))
# var=f196030
    movl -12(%esp), %eax  # stack load f196030
# end emit-variable-ref
    mov %eax, -44(%esp)  # arg f196030
    movl -40(%esp), %edi   # load new closure to %edi
    add $-32, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $32, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    mov %eax, -32(%esp)  # arg ((primitive-ref string->list) f196030)
    movl -24(%esp), %edi   # load new closure to %edi
    add $-16, %esp   # adjust base
    movl $8,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $16, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
# emit-tail-expr
# si=-16
# env=((f196030 . -12) (f196030 . -8) ((primitive-ref write-char) . 20) ((primitive-ref string->list) . 16) ((primitive-ref write-char) . 12) ((primitive-ref for-each) . 8) ((primitive-ref write-char) . 4) (f196013 . -24) (f196014 . -20) (f196015 . -16) (f196016 . -12) (f196017 . -8) (f196018 . -4) (f196019 . 0))
# expr=(begin ((primitive-ref write-char) #\"))
# tail-begin (begin ((primitive-ref write-char) #\"))
#   env=((f196030 . -12) (f196030 . -8) ((primitive-ref write-char) . 20) ((primitive-ref string->list) . 16) ((primitive-ref write-char) . 12) ((primitive-ref for-each) . 8) ((primitive-ref write-char) . 4) (f196013 . -24) (f196014 . -20) (f196015 . -16) (f196016 . -12) (f196017 . -8) (f196018 . -4) (f196019 . 0))
# emit-tail-expr
# si=-16
# env=((f196030 . -12) (f196030 . -8) ((primitive-ref write-char) . 20) ((primitive-ref string->list) . 16) ((primitive-ref write-char) . 12) ((primitive-ref for-each) . 8) ((primitive-ref write-char) . 4) (f196013 . -24) (f196014 . -20) (f196015 . -16) (f196016 . -12) (f196017 . -8) (f196018 . -4) (f196019 . 0))
# expr=((primitive-ref write-char) #\")
# emit-tail-funcall
#    si   =-16
#    env  = ((f196030 . -12) (f196030 . -8) ((primitive-ref write-char) . 20) ((primitive-ref string->list) . 16) ((primitive-ref write-char) . 12) ((primitive-ref for-each) . 8) ((primitive-ref write-char) . 4) (f196013 . -24) (f196014 . -20) (f196015 . -16) (f196016 . -12) (f196017 . -8) (f196018 . -4) (f196019 . 0))
#    expr = (funcall (primitive-ref write-char) #\")
# emit-expr (primitive-ref write-char)
    .extern mrc_write$mchar
    movl mrc_write$mchar,%eax
   movl %eax,  -16(%esp)  # stash funcall-oper in next closure slot
# emit-expr #\"
    movl $8719, %eax     # immed #\"
    mov %eax, -20(%esp)    # arg "
    movl -16(%esp), %edi   # load new closure to %edi
# emit-shift-args:  size=2   si=-16  delta=12
    mov -16(%esp), %ebx  # shift frame cell
    mov %ebx, -4(%esp)  # down to base
# emit-shift-args:  size=1   si=-20  delta=12
    mov -20(%esp), %ebx  # shift frame cell
    mov %ebx, -8(%esp)  # down to base
# emit-shift-args:  size=0   si=-24  delta=12
    movl $4,%eax   # save arg count
    jmp *-2(%edi)  # tail-funcall
     ret   # return thru stack
    .align 4,0x90
_L_1424810:
    movl -28(%esp), %ebx
    movl -32(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin (vector-set! f196014 0 (closure (f196029) ((primitive-ref write-char) f196013 (primitive-ref write-char)) (let ((f196029 f196029)) (begin ((primitive-ref write-char) #\() ((vector-ref f196013 0) f196029) ((primitive-ref write-char) #\)))))) (vector-set! f196013 0 (closure (f196028) ((primitive-ref write) (primitive-ref write-char) f196013 else (primitive-ref write-char) (primitive-ref write-char) (primitive-ref write-char) (primitive-ref write)) (let ((f196028 f196028)) (begin ((primitive-ref write) (car f196028)) (if (null? (cdr f196028)) #t (if (pair? (cdr f196028)) (begin ((primitive-ref write-char) #\space) ((vector-ref f196013 0) (cdr f196028))) (begin ((primitive-ref write-char) #\space) ((primitive-ref write-char) #\.) ((primitive-ref write-char) #\space) ((primitive-ref write) (cdr f196028))))))))))
# emit-begin
#   expr=(begin (vector-set! f196014 0 (closure (f196029) ((primitive-ref write-char) f196013 (primitive-ref write-char)) (let ((f196029 f196029)) (begin ((primitive-ref write-char) #\() ((vector-ref f196013 0) f196029) ((primitive-ref write-char) #\)))))) (vector-set! f196013 0 (closure (f196028) ((primitive-ref write) (primitive-ref write-char) f196013 else (primitive-ref write-char) (primitive-ref write-char) (primitive-ref write-char) (primitive-ref write)) (let ((f196028 f196028)) (begin ((primitive-ref write) (car f196028)) (if (null? (cdr f196028)) #t (if (pair? (cdr f196028)) (begin ((primitive-ref write-char) #\space) ((vector-ref f196013 0) (cdr f196028))) (begin ((primitive-ref write-char) #\space) ((primitive-ref write-char) #\.) ((primitive-ref write-char) #\space) ((primitive-ref write) (cdr f196028))))))))))
#   env=((f196013 . -24) (f196014 . -20) (f196015 . -16) (f196016 . -12) (f196017 . -8) (f196018 . -4) (f196019 . 0))
# emit-expr (vector-set! f196014 0 (closure (f196029) ((primitive-ref write-char) f196013 (primitive-ref write-char)) (let ((f196029 f196029)) (begin ((primitive-ref write-char) #\() ((vector-ref f196013 0) f196029) ((primitive-ref write-char) #\))))))
# emit-expr f196014
# emit-variable-ref
# env=((f196013 . -24) (f196014 . -20) (f196015 . -16) (f196016 . -12) (f196017 . -8) (f196018 . -4) (f196019 . 0))
# var=f196014
    movl -20(%esp), %eax  # stack load f196014
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1424815
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1424815:
    movl %eax, -28(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1424816"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1424816:
# check bounds on vector index
    movl -28(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1424818
    cmp  $0,%eax
    jge _L_1424817
_L_1424818:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1424817:
    movl %eax, -32(%esp)
# emit-expr (closure (f196029) ((primitive-ref write-char) f196013 (primitive-ref write-char)) (let ((f196029 f196029)) (begin ((primitive-ref write-char) #\() ((vector-ref f196013 0) f196029) ((primitive-ref write-char) #\)))))
# emit-closure
# si = -36
# env = ((f196013 . -24) (f196014 . -20) (f196015 . -16) (f196016 . -12) (f196017 . -8) (f196018 . -4) (f196019 . 0))
# expr = (closure (f196029) ((primitive-ref write-char) f196013 (primitive-ref write-char)) (let ((f196029 f196029)) (begin ((primitive-ref write-char) #\() ((vector-ref f196013 0) f196029) ((primitive-ref write-char) #\)))))
    movl $_L_1424819, 0(%ebp)  # closure label
# WARNING: free var (primitive-ref write-char) not defined in the environmnet
# emit-variable-ref
# env=((f196013 . -24) (f196014 . -20) (f196015 . -16) (f196016 . -12) (f196017 . -8) (f196018 . -4) (f196019 . 0))
# var=f196013
    movl -24(%esp), %eax  # stack load f196013
# end emit-variable-ref
   movl  %eax, 8(%ebp)  # f196013
# WARNING: free var (primitive-ref write-char) not defined in the environmnet
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $16, %ebp     # bump ebp
    jmp _L_1424820            # jump around closure body
_L_1424819:
# check argument count
    cmp $4,%eax
    je _L_1424821
# invoke error handler eh_argcount
    .extern mrc_eh$uargcount
    movl mrc_eh$uargcount, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_1424821:
# emit-tail-expr
# si=-12
# env=((f196029 . -8) ((primitive-ref write-char) . 12) (f196013 . 8) ((primitive-ref write-char) . 4) (f196013 . -24) (f196014 . -20) (f196015 . -16) (f196016 . -12) (f196017 . -8) (f196018 . -4) (f196019 . 0))
# expr=(let ((f196029 f196029)) (begin ((primitive-ref write-char) #\() ((vector-ref f196013 0) f196029) ((primitive-ref write-char) #\))))
# emit-tail-let
#  si   = -12
#  env  = ((f196029 . -8) ((primitive-ref write-char) . 12) (f196013 . 8) ((primitive-ref write-char) . 4) (f196013 . -24) (f196014 . -20) (f196015 . -16) (f196016 . -12) (f196017 . -8) (f196018 . -4) (f196019 . 0))
#  bindings = ((f196029 f196029))
#  body = (begin ((primitive-ref write-char) #\() ((vector-ref f196013 0) f196029) ((primitive-ref write-char) #\)))
# emit-expr f196029
# emit-variable-ref
# env=((f196029 . -8) ((primitive-ref write-char) . 12) (f196013 . 8) ((primitive-ref write-char) . 4) (f196013 . -24) (f196014 . -20) (f196015 . -16) (f196016 . -12) (f196017 . -8) (f196018 . -4) (f196019 . 0))
# var=f196029
    movl -8(%esp), %eax  # stack load f196029
# end emit-variable-ref
    movl %eax, -12(%esp)  # stack save
# emit-tail-expr
# si=-16
# env=((f196029 . -12) (f196029 . -8) ((primitive-ref write-char) . 12) (f196013 . 8) ((primitive-ref write-char) . 4) (f196013 . -24) (f196014 . -20) (f196015 . -16) (f196016 . -12) (f196017 . -8) (f196018 . -4) (f196019 . 0))
# expr=(begin ((primitive-ref write-char) #\() ((vector-ref f196013 0) f196029) ((primitive-ref write-char) #\)))
# tail-begin (begin ((primitive-ref write-char) #\() ((vector-ref f196013 0) f196029) ((primitive-ref write-char) #\)))
#   env=((f196029 . -12) (f196029 . -8) ((primitive-ref write-char) . 12) (f196013 . 8) ((primitive-ref write-char) . 4) (f196013 . -24) (f196014 . -20) (f196015 . -16) (f196016 . -12) (f196017 . -8) (f196018 . -4) (f196019 . 0))
# emit-expr ((primitive-ref write-char) #\()
# funcall
#    si   =-16
#    env  = ((f196029 . -12) (f196029 . -8) ((primitive-ref write-char) . 12) (f196013 . 8) ((primitive-ref write-char) . 4) (f196013 . -24) (f196014 . -20) (f196015 . -16) (f196016 . -12) (f196017 . -8) (f196018 . -4) (f196019 . 0))
#    expr = (funcall (primitive-ref write-char) #\()
# emit-expr (primitive-ref write-char)
    .extern mrc_write$mchar
    movl mrc_write$mchar,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1424822"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1424822":
   movl %eax,  -24(%esp)  # stash funcall-oper in closure slot
# emit-expr #\(
    movl $10255, %eax     # immed #\(
    mov %eax, -28(%esp)  # arg (
    movl -24(%esp), %edi   # load new closure to %edi
    add $-16, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $16, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
# emit-tail-expr
# si=-16
# env=((f196029 . -12) (f196029 . -8) ((primitive-ref write-char) . 12) (f196013 . 8) ((primitive-ref write-char) . 4) (f196013 . -24) (f196014 . -20) (f196015 . -16) (f196016 . -12) (f196017 . -8) (f196018 . -4) (f196019 . 0))
# expr=(begin ((vector-ref f196013 0) f196029) ((primitive-ref write-char) #\)))
# tail-begin (begin ((vector-ref f196013 0) f196029) ((primitive-ref write-char) #\)))
#   env=((f196029 . -12) (f196029 . -8) ((primitive-ref write-char) . 12) (f196013 . 8) ((primitive-ref write-char) . 4) (f196013 . -24) (f196014 . -20) (f196015 . -16) (f196016 . -12) (f196017 . -8) (f196018 . -4) (f196019 . 0))
# emit-expr ((vector-ref f196013 0) f196029)
# funcall
#    si   =-16
#    env  = ((f196029 . -12) (f196029 . -8) ((primitive-ref write-char) . 12) (f196013 . 8) ((primitive-ref write-char) . 4) (f196013 . -24) (f196014 . -20) (f196015 . -16) (f196016 . -12) (f196017 . -8) (f196018 . -4) (f196019 . 0))
#    expr = (funcall (vector-ref f196013 0) f196029)
# emit-expr (vector-ref f196013 0)
# emit-expr f196013
# emit-variable-ref
# env=((f196029 . -12) (f196029 . -8) ((primitive-ref write-char) . 12) (f196013 . 8) ((primitive-ref write-char) . 4) (f196013 . -24) (f196014 . -20) (f196015 . -16) (f196016 . -12) (f196017 . -8) (f196018 . -4) (f196019 . 0))
# var=f196013
    movl 6(%edi), %eax  # frame load f196013
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1424823
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1424823:
    movl %eax, -24(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1424824"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1424824:
# check bounds on vector index
    movl -24(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1424826
    cmp  $0,%eax
    jge _L_1424825
_L_1424826:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1424825:
    movl -24(%esp), %esi
    movl -1(%eax,%esi), %eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1424827"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1424827":
   movl %eax,  -24(%esp)  # stash funcall-oper in closure slot
# emit-expr f196029
# emit-variable-ref
# env=((f196029 . -12) (f196029 . -8) ((primitive-ref write-char) . 12) (f196013 . 8) ((primitive-ref write-char) . 4) (f196013 . -24) (f196014 . -20) (f196015 . -16) (f196016 . -12) (f196017 . -8) (f196018 . -4) (f196019 . 0))
# var=f196029
    movl -12(%esp), %eax  # stack load f196029
# end emit-variable-ref
    mov %eax, -28(%esp)  # arg f196029
    movl -24(%esp), %edi   # load new closure to %edi
    add $-16, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $16, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
# emit-tail-expr
# si=-16
# env=((f196029 . -12) (f196029 . -8) ((primitive-ref write-char) . 12) (f196013 . 8) ((primitive-ref write-char) . 4) (f196013 . -24) (f196014 . -20) (f196015 . -16) (f196016 . -12) (f196017 . -8) (f196018 . -4) (f196019 . 0))
# expr=(begin ((primitive-ref write-char) #\)))
# tail-begin (begin ((primitive-ref write-char) #\)))
#   env=((f196029 . -12) (f196029 . -8) ((primitive-ref write-char) . 12) (f196013 . 8) ((primitive-ref write-char) . 4) (f196013 . -24) (f196014 . -20) (f196015 . -16) (f196016 . -12) (f196017 . -8) (f196018 . -4) (f196019 . 0))
# emit-tail-expr
# si=-16
# env=((f196029 . -12) (f196029 . -8) ((primitive-ref write-char) . 12) (f196013 . 8) ((primitive-ref write-char) . 4) (f196013 . -24) (f196014 . -20) (f196015 . -16) (f196016 . -12) (f196017 . -8) (f196018 . -4) (f196019 . 0))
# expr=((primitive-ref write-char) #\))
# emit-tail-funcall
#    si   =-16
#    env  = ((f196029 . -12) (f196029 . -8) ((primitive-ref write-char) . 12) (f196013 . 8) ((primitive-ref write-char) . 4) (f196013 . -24) (f196014 . -20) (f196015 . -16) (f196016 . -12) (f196017 . -8) (f196018 . -4) (f196019 . 0))
#    expr = (funcall (primitive-ref write-char) #\))
# emit-expr (primitive-ref write-char)
    .extern mrc_write$mchar
    movl mrc_write$mchar,%eax
   movl %eax,  -16(%esp)  # stash funcall-oper in next closure slot
# emit-expr #\)
    movl $10511, %eax     # immed #\)
    mov %eax, -20(%esp)    # arg )
    movl -16(%esp), %edi   # load new closure to %edi
# emit-shift-args:  size=2   si=-16  delta=12
    mov -16(%esp), %ebx  # shift frame cell
    mov %ebx, -4(%esp)  # down to base
# emit-shift-args:  size=1   si=-20  delta=12
    mov -20(%esp), %ebx  # shift frame cell
    mov %ebx, -8(%esp)  # down to base
# emit-shift-args:  size=0   si=-24  delta=12
    movl $4,%eax   # save arg count
    jmp *-2(%edi)  # tail-funcall
     ret   # return thru stack
    .align 4,0x90
_L_1424820:
    movl -28(%esp), %ebx
    movl -32(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin (vector-set! f196013 0 (closure (f196028) ((primitive-ref write) (primitive-ref write-char) f196013 else (primitive-ref write-char) (primitive-ref write-char) (primitive-ref write-char) (primitive-ref write)) (let ((f196028 f196028)) (begin ((primitive-ref write) (car f196028)) (if (null? (cdr f196028)) #t (if (pair? (cdr f196028)) (begin ((primitive-ref write-char) #\space) ((vector-ref f196013 0) (cdr f196028))) (begin ((primitive-ref write-char) #\space) ((primitive-ref write-char) #\.) ((primitive-ref write-char) #\space) ((primitive-ref write) (cdr f196028))))))))))
# emit-begin
#   expr=(begin (vector-set! f196013 0 (closure (f196028) ((primitive-ref write) (primitive-ref write-char) f196013 else (primitive-ref write-char) (primitive-ref write-char) (primitive-ref write-char) (primitive-ref write)) (let ((f196028 f196028)) (begin ((primitive-ref write) (car f196028)) (if (null? (cdr f196028)) #t (if (pair? (cdr f196028)) (begin ((primitive-ref write-char) #\space) ((vector-ref f196013 0) (cdr f196028))) (begin ((primitive-ref write-char) #\space) ((primitive-ref write-char) #\.) ((primitive-ref write-char) #\space) ((primitive-ref write) (cdr f196028))))))))))
#   env=((f196013 . -24) (f196014 . -20) (f196015 . -16) (f196016 . -12) (f196017 . -8) (f196018 . -4) (f196019 . 0))
# emit-expr (vector-set! f196013 0 (closure (f196028) ((primitive-ref write) (primitive-ref write-char) f196013 else (primitive-ref write-char) (primitive-ref write-char) (primitive-ref write-char) (primitive-ref write)) (let ((f196028 f196028)) (begin ((primitive-ref write) (car f196028)) (if (null? (cdr f196028)) #t (if (pair? (cdr f196028)) (begin ((primitive-ref write-char) #\space) ((vector-ref f196013 0) (cdr f196028))) (begin ((primitive-ref write-char) #\space) ((primitive-ref write-char) #\.) ((primitive-ref write-char) #\space) ((primitive-ref write) (cdr f196028)))))))))
# emit-expr f196013
# emit-variable-ref
# env=((f196013 . -24) (f196014 . -20) (f196015 . -16) (f196016 . -12) (f196017 . -8) (f196018 . -4) (f196019 . 0))
# var=f196013
    movl -24(%esp), %eax  # stack load f196013
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1424828
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1424828:
    movl %eax, -28(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1424829"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1424829:
# check bounds on vector index
    movl -28(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1424831
    cmp  $0,%eax
    jge _L_1424830
_L_1424831:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1424830:
    movl %eax, -32(%esp)
# emit-expr (closure (f196028) ((primitive-ref write) (primitive-ref write-char) f196013 else (primitive-ref write-char) (primitive-ref write-char) (primitive-ref write-char) (primitive-ref write)) (let ((f196028 f196028)) (begin ((primitive-ref write) (car f196028)) (if (null? (cdr f196028)) #t (if (pair? (cdr f196028)) (begin ((primitive-ref write-char) #\space) ((vector-ref f196013 0) (cdr f196028))) (begin ((primitive-ref write-char) #\space) ((primitive-ref write-char) #\.) ((primitive-ref write-char) #\space) ((primitive-ref write) (cdr f196028))))))))
# emit-closure
# si = -36
# env = ((f196013 . -24) (f196014 . -20) (f196015 . -16) (f196016 . -12) (f196017 . -8) (f196018 . -4) (f196019 . 0))
# expr = (closure (f196028) ((primitive-ref write) (primitive-ref write-char) f196013 else (primitive-ref write-char) (primitive-ref write-char) (primitive-ref write-char) (primitive-ref write)) (let ((f196028 f196028)) (begin ((primitive-ref write) (car f196028)) (if (null? (cdr f196028)) #t (if (pair? (cdr f196028)) (begin ((primitive-ref write-char) #\space) ((vector-ref f196013 0) (cdr f196028))) (begin ((primitive-ref write-char) #\space) ((primitive-ref write-char) #\.) ((primitive-ref write-char) #\space) ((primitive-ref write) (cdr f196028))))))))
    movl $_L_1424832, 0(%ebp)  # closure label
# WARNING: free var (primitive-ref write) not defined in the environmnet
# WARNING: free var (primitive-ref write-char) not defined in the environmnet
# emit-variable-ref
# env=((f196013 . -24) (f196014 . -20) (f196015 . -16) (f196016 . -12) (f196017 . -8) (f196018 . -4) (f196019 . 0))
# var=f196013
    movl -24(%esp), %eax  # stack load f196013
# end emit-variable-ref
   movl  %eax, 12(%ebp)  # f196013
# WARNING: free var else not defined in the environmnet
# WARNING: free var (primitive-ref write-char) not defined in the environmnet
# WARNING: free var (primitive-ref write-char) not defined in the environmnet
# WARNING: free var (primitive-ref write-char) not defined in the environmnet
# WARNING: free var (primitive-ref write) not defined in the environmnet
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $40, %ebp     # bump ebp
    jmp _L_1424833            # jump around closure body
_L_1424832:
# check argument count
    cmp $4,%eax
    je _L_1424834
# invoke error handler eh_argcount
    .extern mrc_eh$uargcount
    movl mrc_eh$uargcount, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_1424834:
# emit-tail-expr
# si=-12
# env=((f196028 . -8) ((primitive-ref write) . 32) ((primitive-ref write-char) . 28) ((primitive-ref write-char) . 24) ((primitive-ref write-char) . 20) (else . 16) (f196013 . 12) ((primitive-ref write-char) . 8) ((primitive-ref write) . 4) (f196013 . -24) (f196014 . -20) (f196015 . -16) (f196016 . -12) (f196017 . -8) (f196018 . -4) (f196019 . 0))
# expr=(let ((f196028 f196028)) (begin ((primitive-ref write) (car f196028)) (if (null? (cdr f196028)) #t (if (pair? (cdr f196028)) (begin ((primitive-ref write-char) #\space) ((vector-ref f196013 0) (cdr f196028))) (begin ((primitive-ref write-char) #\space) ((primitive-ref write-char) #\.) ((primitive-ref write-char) #\space) ((primitive-ref write) (cdr f196028)))))))
# emit-tail-let
#  si   = -12
#  env  = ((f196028 . -8) ((primitive-ref write) . 32) ((primitive-ref write-char) . 28) ((primitive-ref write-char) . 24) ((primitive-ref write-char) . 20) (else . 16) (f196013 . 12) ((primitive-ref write-char) . 8) ((primitive-ref write) . 4) (f196013 . -24) (f196014 . -20) (f196015 . -16) (f196016 . -12) (f196017 . -8) (f196018 . -4) (f196019 . 0))
#  bindings = ((f196028 f196028))
#  body = (begin ((primitive-ref write) (car f196028)) (if (null? (cdr f196028)) #t (if (pair? (cdr f196028)) (begin ((primitive-ref write-char) #\space) ((vector-ref f196013 0) (cdr f196028))) (begin ((primitive-ref write-char) #\space) ((primitive-ref write-char) #\.) ((primitive-ref write-char) #\space) ((primitive-ref write) (cdr f196028))))))
# emit-expr f196028
# emit-variable-ref
# env=((f196028 . -8) ((primitive-ref write) . 32) ((primitive-ref write-char) . 28) ((primitive-ref write-char) . 24) ((primitive-ref write-char) . 20) (else . 16) (f196013 . 12) ((primitive-ref write-char) . 8) ((primitive-ref write) . 4) (f196013 . -24) (f196014 . -20) (f196015 . -16) (f196016 . -12) (f196017 . -8) (f196018 . -4) (f196019 . 0))
# var=f196028
    movl -8(%esp), %eax  # stack load f196028
# end emit-variable-ref
    movl %eax, -12(%esp)  # stack save
# emit-tail-expr
# si=-16
# env=((f196028 . -12) (f196028 . -8) ((primitive-ref write) . 32) ((primitive-ref write-char) . 28) ((primitive-ref write-char) . 24) ((primitive-ref write-char) . 20) (else . 16) (f196013 . 12) ((primitive-ref write-char) . 8) ((primitive-ref write) . 4) (f196013 . -24) (f196014 . -20) (f196015 . -16) (f196016 . -12) (f196017 . -8) (f196018 . -4) (f196019 . 0))
# expr=(begin ((primitive-ref write) (car f196028)) (if (null? (cdr f196028)) #t (if (pair? (cdr f196028)) (begin ((primitive-ref write-char) #\space) ((vector-ref f196013 0) (cdr f196028))) (begin ((primitive-ref write-char) #\space) ((primitive-ref write-char) #\.) ((primitive-ref write-char) #\space) ((primitive-ref write) (cdr f196028))))))
# tail-begin (begin ((primitive-ref write) (car f196028)) (if (null? (cdr f196028)) #t (if (pair? (cdr f196028)) (begin ((primitive-ref write-char) #\space) ((vector-ref f196013 0) (cdr f196028))) (begin ((primitive-ref write-char) #\space) ((primitive-ref write-char) #\.) ((primitive-ref write-char) #\space) ((primitive-ref write) (cdr f196028))))))
#   env=((f196028 . -12) (f196028 . -8) ((primitive-ref write) . 32) ((primitive-ref write-char) . 28) ((primitive-ref write-char) . 24) ((primitive-ref write-char) . 20) (else . 16) (f196013 . 12) ((primitive-ref write-char) . 8) ((primitive-ref write) . 4) (f196013 . -24) (f196014 . -20) (f196015 . -16) (f196016 . -12) (f196017 . -8) (f196018 . -4) (f196019 . 0))
# emit-expr ((primitive-ref write) (car f196028))
# funcall
#    si   =-16
#    env  = ((f196028 . -12) (f196028 . -8) ((primitive-ref write) . 32) ((primitive-ref write-char) . 28) ((primitive-ref write-char) . 24) ((primitive-ref write-char) . 20) (else . 16) (f196013 . 12) ((primitive-ref write-char) . 8) ((primitive-ref write) . 4) (f196013 . -24) (f196014 . -20) (f196015 . -16) (f196016 . -12) (f196017 . -8) (f196018 . -4) (f196019 . 0))
#    expr = (funcall (primitive-ref write) (car f196028))
# emit-expr (primitive-ref write)
    .extern mrc_write
    movl mrc_write,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1424835"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1424835":
   movl %eax,  -24(%esp)  # stash funcall-oper in closure slot
# emit-expr (car f196028)
# emit-expr f196028
# emit-variable-ref
# env=((f196028 . -12) (f196028 . -8) ((primitive-ref write) . 32) ((primitive-ref write-char) . 28) ((primitive-ref write-char) . 24) ((primitive-ref write-char) . 20) (else . 16) (f196013 . 12) ((primitive-ref write-char) . 8) ((primitive-ref write) . 4) (f196013 . -24) (f196014 . -20) (f196015 . -16) (f196016 . -12) (f196017 . -8) (f196018 . -4) (f196019 . 0))
# var=f196028
    movl -12(%esp), %eax  # stack load f196028
# end emit-variable-ref
# check the argument is a pair
    movl %eax,%ebx
    and $7, %bl
    cmp $1, %bl
    je _L_1424836
# invoke error handler eh_pair
    .extern mrc_eh$upair
    movl mrc_eh$upair, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $108,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1424836:
    movl -1(%eax), %eax
    mov %eax, -28(%esp)  # arg (car f196028)
    movl -24(%esp), %edi   # load new closure to %edi
    add $-16, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $16, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
# emit-tail-expr
# si=-16
# env=((f196028 . -12) (f196028 . -8) ((primitive-ref write) . 32) ((primitive-ref write-char) . 28) ((primitive-ref write-char) . 24) ((primitive-ref write-char) . 20) (else . 16) (f196013 . 12) ((primitive-ref write-char) . 8) ((primitive-ref write) . 4) (f196013 . -24) (f196014 . -20) (f196015 . -16) (f196016 . -12) (f196017 . -8) (f196018 . -4) (f196019 . 0))
# expr=(begin (if (null? (cdr f196028)) #t (if (pair? (cdr f196028)) (begin ((primitive-ref write-char) #\space) ((vector-ref f196013 0) (cdr f196028))) (begin ((primitive-ref write-char) #\space) ((primitive-ref write-char) #\.) ((primitive-ref write-char) #\space) ((primitive-ref write) (cdr f196028))))))
# tail-begin (begin (if (null? (cdr f196028)) #t (if (pair? (cdr f196028)) (begin ((primitive-ref write-char) #\space) ((vector-ref f196013 0) (cdr f196028))) (begin ((primitive-ref write-char) #\space) ((primitive-ref write-char) #\.) ((primitive-ref write-char) #\space) ((primitive-ref write) (cdr f196028))))))
#   env=((f196028 . -12) (f196028 . -8) ((primitive-ref write) . 32) ((primitive-ref write-char) . 28) ((primitive-ref write-char) . 24) ((primitive-ref write-char) . 20) (else . 16) (f196013 . 12) ((primitive-ref write-char) . 8) ((primitive-ref write) . 4) (f196013 . -24) (f196014 . -20) (f196015 . -16) (f196016 . -12) (f196017 . -8) (f196018 . -4) (f196019 . 0))
# emit-tail-expr
# si=-16
# env=((f196028 . -12) (f196028 . -8) ((primitive-ref write) . 32) ((primitive-ref write-char) . 28) ((primitive-ref write-char) . 24) ((primitive-ref write-char) . 20) (else . 16) (f196013 . 12) ((primitive-ref write-char) . 8) ((primitive-ref write) . 4) (f196013 . -24) (f196014 . -20) (f196015 . -16) (f196016 . -12) (f196017 . -8) (f196018 . -4) (f196019 . 0))
# expr=(if (null? (cdr f196028)) #t (if (pair? (cdr f196028)) (begin ((primitive-ref write-char) #\space) ((vector-ref f196013 0) (cdr f196028))) (begin ((primitive-ref write-char) #\space) ((primitive-ref write-char) #\.) ((primitive-ref write-char) #\space) ((primitive-ref write) (cdr f196028)))))
# emit-expr (null? (cdr f196028))
# emit-expr (cdr f196028)
# emit-expr f196028
# emit-variable-ref
# env=((f196028 . -12) (f196028 . -8) ((primitive-ref write) . 32) ((primitive-ref write-char) . 28) ((primitive-ref write-char) . 24) ((primitive-ref write-char) . 20) (else . 16) (f196013 . 12) ((primitive-ref write-char) . 8) ((primitive-ref write) . 4) (f196013 . -24) (f196014 . -20) (f196015 . -16) (f196016 . -12) (f196017 . -8) (f196018 . -4) (f196019 . 0))
# var=f196028
    movl -12(%esp), %eax  # stack load f196028
# end emit-variable-ref
# check the argument is a pair
    movl %eax,%ebx
    and $7, %bl
    cmp $1, %bl
    je _L_1424839
# invoke error handler eh_pair
    .extern mrc_eh$upair
    movl mrc_eh$upair, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $112,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1424839:
    movl 3(%eax), %eax
    cmp $63, %eax
    mov $0, %eax
    sete %al
    movzbl %al, %eax
    sal $6, %al
    or $47, %al
    cmp $47, %al
    je _L_1424837
# emit-tail-expr
# si=-16
# env=((f196028 . -12) (f196028 . -8) ((primitive-ref write) . 32) ((primitive-ref write-char) . 28) ((primitive-ref write-char) . 24) ((primitive-ref write-char) . 20) (else . 16) (f196013 . 12) ((primitive-ref write-char) . 8) ((primitive-ref write) . 4) (f196013 . -24) (f196014 . -20) (f196015 . -16) (f196016 . -12) (f196017 . -8) (f196018 . -4) (f196019 . 0))
# expr=#t
    movl $111, %eax     # immed #t
    ret                  # immediate tail return
    jmp _L_1424838
_L_1424837:
# emit-tail-expr
# si=-16
# env=((f196028 . -12) (f196028 . -8) ((primitive-ref write) . 32) ((primitive-ref write-char) . 28) ((primitive-ref write-char) . 24) ((primitive-ref write-char) . 20) (else . 16) (f196013 . 12) ((primitive-ref write-char) . 8) ((primitive-ref write) . 4) (f196013 . -24) (f196014 . -20) (f196015 . -16) (f196016 . -12) (f196017 . -8) (f196018 . -4) (f196019 . 0))
# expr=(if (pair? (cdr f196028)) (begin ((primitive-ref write-char) #\space) ((vector-ref f196013 0) (cdr f196028))) (begin ((primitive-ref write-char) #\space) ((primitive-ref write-char) #\.) ((primitive-ref write-char) #\space) ((primitive-ref write) (cdr f196028))))
# emit-expr (pair? (cdr f196028))
# emit-expr (cdr f196028)
# emit-expr f196028
# emit-variable-ref
# env=((f196028 . -12) (f196028 . -8) ((primitive-ref write) . 32) ((primitive-ref write-char) . 28) ((primitive-ref write-char) . 24) ((primitive-ref write-char) . 20) (else . 16) (f196013 . 12) ((primitive-ref write-char) . 8) ((primitive-ref write) . 4) (f196013 . -24) (f196014 . -20) (f196015 . -16) (f196016 . -12) (f196017 . -8) (f196018 . -4) (f196019 . 0))
# var=f196028
    movl -12(%esp), %eax  # stack load f196028
# end emit-variable-ref
# check the argument is a pair
    movl %eax,%ebx
    and $7, %bl
    cmp $1, %bl
    je _L_1424842
# invoke error handler eh_pair
    .extern mrc_eh$upair
    movl mrc_eh$upair, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $112,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1424842:
    movl 3(%eax), %eax
    and $7, %al
    cmp $1, %al
    sete %al
    movzbl %al, %eax
    sal $6, %al
    or $47, %al
    cmp $47, %al
    je _L_1424840
# emit-tail-expr
# si=-16
# env=((f196028 . -12) (f196028 . -8) ((primitive-ref write) . 32) ((primitive-ref write-char) . 28) ((primitive-ref write-char) . 24) ((primitive-ref write-char) . 20) (else . 16) (f196013 . 12) ((primitive-ref write-char) . 8) ((primitive-ref write) . 4) (f196013 . -24) (f196014 . -20) (f196015 . -16) (f196016 . -12) (f196017 . -8) (f196018 . -4) (f196019 . 0))
# expr=(begin ((primitive-ref write-char) #\space) ((vector-ref f196013 0) (cdr f196028)))
# tail-begin (begin ((primitive-ref write-char) #\space) ((vector-ref f196013 0) (cdr f196028)))
#   env=((f196028 . -12) (f196028 . -8) ((primitive-ref write) . 32) ((primitive-ref write-char) . 28) ((primitive-ref write-char) . 24) ((primitive-ref write-char) . 20) (else . 16) (f196013 . 12) ((primitive-ref write-char) . 8) ((primitive-ref write) . 4) (f196013 . -24) (f196014 . -20) (f196015 . -16) (f196016 . -12) (f196017 . -8) (f196018 . -4) (f196019 . 0))
# emit-expr ((primitive-ref write-char) #\space)
# funcall
#    si   =-16
#    env  = ((f196028 . -12) (f196028 . -8) ((primitive-ref write) . 32) ((primitive-ref write-char) . 28) ((primitive-ref write-char) . 24) ((primitive-ref write-char) . 20) (else . 16) (f196013 . 12) ((primitive-ref write-char) . 8) ((primitive-ref write) . 4) (f196013 . -24) (f196014 . -20) (f196015 . -16) (f196016 . -12) (f196017 . -8) (f196018 . -4) (f196019 . 0))
#    expr = (funcall (primitive-ref write-char) #\space)
# emit-expr (primitive-ref write-char)
    .extern mrc_write$mchar
    movl mrc_write$mchar,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1424843"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1424843":
   movl %eax,  -24(%esp)  # stash funcall-oper in closure slot
# emit-expr #\space
    movl $8207, %eax     # immed #\space
    mov %eax, -28(%esp)  # arg  
    movl -24(%esp), %edi   # load new closure to %edi
    add $-16, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $16, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
# emit-tail-expr
# si=-16
# env=((f196028 . -12) (f196028 . -8) ((primitive-ref write) . 32) ((primitive-ref write-char) . 28) ((primitive-ref write-char) . 24) ((primitive-ref write-char) . 20) (else . 16) (f196013 . 12) ((primitive-ref write-char) . 8) ((primitive-ref write) . 4) (f196013 . -24) (f196014 . -20) (f196015 . -16) (f196016 . -12) (f196017 . -8) (f196018 . -4) (f196019 . 0))
# expr=(begin ((vector-ref f196013 0) (cdr f196028)))
# tail-begin (begin ((vector-ref f196013 0) (cdr f196028)))
#   env=((f196028 . -12) (f196028 . -8) ((primitive-ref write) . 32) ((primitive-ref write-char) . 28) ((primitive-ref write-char) . 24) ((primitive-ref write-char) . 20) (else . 16) (f196013 . 12) ((primitive-ref write-char) . 8) ((primitive-ref write) . 4) (f196013 . -24) (f196014 . -20) (f196015 . -16) (f196016 . -12) (f196017 . -8) (f196018 . -4) (f196019 . 0))
# emit-tail-expr
# si=-16
# env=((f196028 . -12) (f196028 . -8) ((primitive-ref write) . 32) ((primitive-ref write-char) . 28) ((primitive-ref write-char) . 24) ((primitive-ref write-char) . 20) (else . 16) (f196013 . 12) ((primitive-ref write-char) . 8) ((primitive-ref write) . 4) (f196013 . -24) (f196014 . -20) (f196015 . -16) (f196016 . -12) (f196017 . -8) (f196018 . -4) (f196019 . 0))
# expr=((vector-ref f196013 0) (cdr f196028))
# emit-tail-funcall
#    si   =-16
#    env  = ((f196028 . -12) (f196028 . -8) ((primitive-ref write) . 32) ((primitive-ref write-char) . 28) ((primitive-ref write-char) . 24) ((primitive-ref write-char) . 20) (else . 16) (f196013 . 12) ((primitive-ref write-char) . 8) ((primitive-ref write) . 4) (f196013 . -24) (f196014 . -20) (f196015 . -16) (f196016 . -12) (f196017 . -8) (f196018 . -4) (f196019 . 0))
#    expr = (funcall (vector-ref f196013 0) (cdr f196028))
# emit-expr (vector-ref f196013 0)
# emit-expr f196013
# emit-variable-ref
# env=((f196028 . -12) (f196028 . -8) ((primitive-ref write) . 32) ((primitive-ref write-char) . 28) ((primitive-ref write-char) . 24) ((primitive-ref write-char) . 20) (else . 16) (f196013 . 12) ((primitive-ref write-char) . 8) ((primitive-ref write) . 4) (f196013 . -24) (f196014 . -20) (f196015 . -16) (f196016 . -12) (f196017 . -8) (f196018 . -4) (f196019 . 0))
# var=f196013
    movl 10(%edi), %eax  # frame load f196013
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1424844
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1424844:
    movl %eax, -16(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1424845"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1424845:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1424847
    cmp  $0,%eax
    jge _L_1424846
_L_1424847:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1424846:
    movl -16(%esp), %esi
    movl -1(%eax,%esi), %eax
   movl %eax,  -16(%esp)  # stash funcall-oper in next closure slot
# emit-expr (cdr f196028)
# emit-expr f196028
# emit-variable-ref
# env=((f196028 . -12) (f196028 . -8) ((primitive-ref write) . 32) ((primitive-ref write-char) . 28) ((primitive-ref write-char) . 24) ((primitive-ref write-char) . 20) (else . 16) (f196013 . 12) ((primitive-ref write-char) . 8) ((primitive-ref write) . 4) (f196013 . -24) (f196014 . -20) (f196015 . -16) (f196016 . -12) (f196017 . -8) (f196018 . -4) (f196019 . 0))
# var=f196028
    movl -12(%esp), %eax  # stack load f196028
# end emit-variable-ref
# check the argument is a pair
    movl %eax,%ebx
    and $7, %bl
    cmp $1, %bl
    je _L_1424848
# invoke error handler eh_pair
    .extern mrc_eh$upair
    movl mrc_eh$upair, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $112,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1424848:
    movl 3(%eax), %eax
    mov %eax, -20(%esp)    # arg (cdr f196028)
    movl -16(%esp), %edi   # load new closure to %edi
# emit-shift-args:  size=2   si=-16  delta=12
    mov -16(%esp), %ebx  # shift frame cell
    mov %ebx, -4(%esp)  # down to base
# emit-shift-args:  size=1   si=-20  delta=12
    mov -20(%esp), %ebx  # shift frame cell
    mov %ebx, -8(%esp)  # down to base
# emit-shift-args:  size=0   si=-24  delta=12
    movl $4,%eax   # save arg count
    jmp *-2(%edi)  # tail-funcall
     ret   # return thru stack
    jmp _L_1424841
_L_1424840:
# emit-tail-expr
# si=-16
# env=((f196028 . -12) (f196028 . -8) ((primitive-ref write) . 32) ((primitive-ref write-char) . 28) ((primitive-ref write-char) . 24) ((primitive-ref write-char) . 20) (else . 16) (f196013 . 12) ((primitive-ref write-char) . 8) ((primitive-ref write) . 4) (f196013 . -24) (f196014 . -20) (f196015 . -16) (f196016 . -12) (f196017 . -8) (f196018 . -4) (f196019 . 0))
# expr=(begin ((primitive-ref write-char) #\space) ((primitive-ref write-char) #\.) ((primitive-ref write-char) #\space) ((primitive-ref write) (cdr f196028)))
# tail-begin (begin ((primitive-ref write-char) #\space) ((primitive-ref write-char) #\.) ((primitive-ref write-char) #\space) ((primitive-ref write) (cdr f196028)))
#   env=((f196028 . -12) (f196028 . -8) ((primitive-ref write) . 32) ((primitive-ref write-char) . 28) ((primitive-ref write-char) . 24) ((primitive-ref write-char) . 20) (else . 16) (f196013 . 12) ((primitive-ref write-char) . 8) ((primitive-ref write) . 4) (f196013 . -24) (f196014 . -20) (f196015 . -16) (f196016 . -12) (f196017 . -8) (f196018 . -4) (f196019 . 0))
# emit-expr ((primitive-ref write-char) #\space)
# funcall
#    si   =-16
#    env  = ((f196028 . -12) (f196028 . -8) ((primitive-ref write) . 32) ((primitive-ref write-char) . 28) ((primitive-ref write-char) . 24) ((primitive-ref write-char) . 20) (else . 16) (f196013 . 12) ((primitive-ref write-char) . 8) ((primitive-ref write) . 4) (f196013 . -24) (f196014 . -20) (f196015 . -16) (f196016 . -12) (f196017 . -8) (f196018 . -4) (f196019 . 0))
#    expr = (funcall (primitive-ref write-char) #\space)
# emit-expr (primitive-ref write-char)
    .extern mrc_write$mchar
    movl mrc_write$mchar,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1424849"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1424849":
   movl %eax,  -24(%esp)  # stash funcall-oper in closure slot
# emit-expr #\space
    movl $8207, %eax     # immed #\space
    mov %eax, -28(%esp)  # arg  
    movl -24(%esp), %edi   # load new closure to %edi
    add $-16, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $16, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
# emit-tail-expr
# si=-16
# env=((f196028 . -12) (f196028 . -8) ((primitive-ref write) . 32) ((primitive-ref write-char) . 28) ((primitive-ref write-char) . 24) ((primitive-ref write-char) . 20) (else . 16) (f196013 . 12) ((primitive-ref write-char) . 8) ((primitive-ref write) . 4) (f196013 . -24) (f196014 . -20) (f196015 . -16) (f196016 . -12) (f196017 . -8) (f196018 . -4) (f196019 . 0))
# expr=(begin ((primitive-ref write-char) #\.) ((primitive-ref write-char) #\space) ((primitive-ref write) (cdr f196028)))
# tail-begin (begin ((primitive-ref write-char) #\.) ((primitive-ref write-char) #\space) ((primitive-ref write) (cdr f196028)))
#   env=((f196028 . -12) (f196028 . -8) ((primitive-ref write) . 32) ((primitive-ref write-char) . 28) ((primitive-ref write-char) . 24) ((primitive-ref write-char) . 20) (else . 16) (f196013 . 12) ((primitive-ref write-char) . 8) ((primitive-ref write) . 4) (f196013 . -24) (f196014 . -20) (f196015 . -16) (f196016 . -12) (f196017 . -8) (f196018 . -4) (f196019 . 0))
# emit-expr ((primitive-ref write-char) #\.)
# funcall
#    si   =-16
#    env  = ((f196028 . -12) (f196028 . -8) ((primitive-ref write) . 32) ((primitive-ref write-char) . 28) ((primitive-ref write-char) . 24) ((primitive-ref write-char) . 20) (else . 16) (f196013 . 12) ((primitive-ref write-char) . 8) ((primitive-ref write) . 4) (f196013 . -24) (f196014 . -20) (f196015 . -16) (f196016 . -12) (f196017 . -8) (f196018 . -4) (f196019 . 0))
#    expr = (funcall (primitive-ref write-char) #\.)
# emit-expr (primitive-ref write-char)
    .extern mrc_write$mchar
    movl mrc_write$mchar,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1424850"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1424850":
   movl %eax,  -24(%esp)  # stash funcall-oper in closure slot
# emit-expr #\.
    movl $11791, %eax     # immed #\.
    mov %eax, -28(%esp)  # arg .
    movl -24(%esp), %edi   # load new closure to %edi
    add $-16, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $16, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
# emit-tail-expr
# si=-16
# env=((f196028 . -12) (f196028 . -8) ((primitive-ref write) . 32) ((primitive-ref write-char) . 28) ((primitive-ref write-char) . 24) ((primitive-ref write-char) . 20) (else . 16) (f196013 . 12) ((primitive-ref write-char) . 8) ((primitive-ref write) . 4) (f196013 . -24) (f196014 . -20) (f196015 . -16) (f196016 . -12) (f196017 . -8) (f196018 . -4) (f196019 . 0))
# expr=(begin ((primitive-ref write-char) #\space) ((primitive-ref write) (cdr f196028)))
# tail-begin (begin ((primitive-ref write-char) #\space) ((primitive-ref write) (cdr f196028)))
#   env=((f196028 . -12) (f196028 . -8) ((primitive-ref write) . 32) ((primitive-ref write-char) . 28) ((primitive-ref write-char) . 24) ((primitive-ref write-char) . 20) (else . 16) (f196013 . 12) ((primitive-ref write-char) . 8) ((primitive-ref write) . 4) (f196013 . -24) (f196014 . -20) (f196015 . -16) (f196016 . -12) (f196017 . -8) (f196018 . -4) (f196019 . 0))
# emit-expr ((primitive-ref write-char) #\space)
# funcall
#    si   =-16
#    env  = ((f196028 . -12) (f196028 . -8) ((primitive-ref write) . 32) ((primitive-ref write-char) . 28) ((primitive-ref write-char) . 24) ((primitive-ref write-char) . 20) (else . 16) (f196013 . 12) ((primitive-ref write-char) . 8) ((primitive-ref write) . 4) (f196013 . -24) (f196014 . -20) (f196015 . -16) (f196016 . -12) (f196017 . -8) (f196018 . -4) (f196019 . 0))
#    expr = (funcall (primitive-ref write-char) #\space)
# emit-expr (primitive-ref write-char)
    .extern mrc_write$mchar
    movl mrc_write$mchar,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1424851"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1424851":
   movl %eax,  -24(%esp)  # stash funcall-oper in closure slot
# emit-expr #\space
    movl $8207, %eax     # immed #\space
    mov %eax, -28(%esp)  # arg  
    movl -24(%esp), %edi   # load new closure to %edi
    add $-16, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $16, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
# emit-tail-expr
# si=-16
# env=((f196028 . -12) (f196028 . -8) ((primitive-ref write) . 32) ((primitive-ref write-char) . 28) ((primitive-ref write-char) . 24) ((primitive-ref write-char) . 20) (else . 16) (f196013 . 12) ((primitive-ref write-char) . 8) ((primitive-ref write) . 4) (f196013 . -24) (f196014 . -20) (f196015 . -16) (f196016 . -12) (f196017 . -8) (f196018 . -4) (f196019 . 0))
# expr=(begin ((primitive-ref write) (cdr f196028)))
# tail-begin (begin ((primitive-ref write) (cdr f196028)))
#   env=((f196028 . -12) (f196028 . -8) ((primitive-ref write) . 32) ((primitive-ref write-char) . 28) ((primitive-ref write-char) . 24) ((primitive-ref write-char) . 20) (else . 16) (f196013 . 12) ((primitive-ref write-char) . 8) ((primitive-ref write) . 4) (f196013 . -24) (f196014 . -20) (f196015 . -16) (f196016 . -12) (f196017 . -8) (f196018 . -4) (f196019 . 0))
# emit-tail-expr
# si=-16
# env=((f196028 . -12) (f196028 . -8) ((primitive-ref write) . 32) ((primitive-ref write-char) . 28) ((primitive-ref write-char) . 24) ((primitive-ref write-char) . 20) (else . 16) (f196013 . 12) ((primitive-ref write-char) . 8) ((primitive-ref write) . 4) (f196013 . -24) (f196014 . -20) (f196015 . -16) (f196016 . -12) (f196017 . -8) (f196018 . -4) (f196019 . 0))
# expr=((primitive-ref write) (cdr f196028))
# emit-tail-funcall
#    si   =-16
#    env  = ((f196028 . -12) (f196028 . -8) ((primitive-ref write) . 32) ((primitive-ref write-char) . 28) ((primitive-ref write-char) . 24) ((primitive-ref write-char) . 20) (else . 16) (f196013 . 12) ((primitive-ref write-char) . 8) ((primitive-ref write) . 4) (f196013 . -24) (f196014 . -20) (f196015 . -16) (f196016 . -12) (f196017 . -8) (f196018 . -4) (f196019 . 0))
#    expr = (funcall (primitive-ref write) (cdr f196028))
# emit-expr (primitive-ref write)
    .extern mrc_write
    movl mrc_write,%eax
   movl %eax,  -16(%esp)  # stash funcall-oper in next closure slot
# emit-expr (cdr f196028)
# emit-expr f196028
# emit-variable-ref
# env=((f196028 . -12) (f196028 . -8) ((primitive-ref write) . 32) ((primitive-ref write-char) . 28) ((primitive-ref write-char) . 24) ((primitive-ref write-char) . 20) (else . 16) (f196013 . 12) ((primitive-ref write-char) . 8) ((primitive-ref write) . 4) (f196013 . -24) (f196014 . -20) (f196015 . -16) (f196016 . -12) (f196017 . -8) (f196018 . -4) (f196019 . 0))
# var=f196028
    movl -12(%esp), %eax  # stack load f196028
# end emit-variable-ref
# check the argument is a pair
    movl %eax,%ebx
    and $7, %bl
    cmp $1, %bl
    je _L_1424852
# invoke error handler eh_pair
    .extern mrc_eh$upair
    movl mrc_eh$upair, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $112,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1424852:
    movl 3(%eax), %eax
    mov %eax, -20(%esp)    # arg (cdr f196028)
    movl -16(%esp), %edi   # load new closure to %edi
# emit-shift-args:  size=2   si=-16  delta=12
    mov -16(%esp), %ebx  # shift frame cell
    mov %ebx, -4(%esp)  # down to base
# emit-shift-args:  size=1   si=-20  delta=12
    mov -20(%esp), %ebx  # shift frame cell
    mov %ebx, -8(%esp)  # down to base
# emit-shift-args:  size=0   si=-24  delta=12
    movl $4,%eax   # save arg count
    jmp *-2(%edi)  # tail-funcall
     ret   # return thru stack
_L_1424841:
_L_1424838:
     ret   # return thru stack
    .align 4,0x90
_L_1424833:
    movl -28(%esp), %ebx
    movl -32(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin)
# emit-begin
#   expr=(begin)
#   env=((f196013 . -24) (f196014 . -20) (f196015 . -16) (f196016 . -12) (f196017 . -8) (f196018 . -4) (f196019 . 0))
# emit-expr (begin (closure (f196037) (f196019 f196018 f196017 f196016 f196015 f196014 else (primitive-ref error) (primitive-ref write)) (let ((f196037 f196037)) (if (boolean? f196037) ((vector-ref f196019 0) f196037) (if (null? f196037) ((vector-ref f196018 0)) (if (char? f196037) ((vector-ref f196017 0) f196037) (if (fixnum? f196037) ((vector-ref f196016 0) f196037) (if (string? f196037) ((vector-ref f196015 0) f196037) (if (pair? f196037) ((vector-ref f196014 0) f196037) ((primitive-ref error) ((primitive-ref string->symbol) "write") "unrecognized expression"))))))))))
# emit-begin
#   expr=(begin (closure (f196037) (f196019 f196018 f196017 f196016 f196015 f196014 else (primitive-ref error) (primitive-ref write)) (let ((f196037 f196037)) (if (boolean? f196037) ((vector-ref f196019 0) f196037) (if (null? f196037) ((vector-ref f196018 0)) (if (char? f196037) ((vector-ref f196017 0) f196037) (if (fixnum? f196037) ((vector-ref f196016 0) f196037) (if (string? f196037) ((vector-ref f196015 0) f196037) (if (pair? f196037) ((vector-ref f196014 0) f196037) ((primitive-ref error) ((primitive-ref string->symbol) "write") "unrecognized expression"))))))))))
#   env=((f196013 . -24) (f196014 . -20) (f196015 . -16) (f196016 . -12) (f196017 . -8) (f196018 . -4) (f196019 . 0))
# emit-expr (closure (f196037) (f196019 f196018 f196017 f196016 f196015 f196014 else (primitive-ref error) (primitive-ref write)) (let ((f196037 f196037)) (if (boolean? f196037) ((vector-ref f196019 0) f196037) (if (null? f196037) ((vector-ref f196018 0)) (if (char? f196037) ((vector-ref f196017 0) f196037) (if (fixnum? f196037) ((vector-ref f196016 0) f196037) (if (string? f196037) ((vector-ref f196015 0) f196037) (if (pair? f196037) ((vector-ref f196014 0) f196037) ((primitive-ref error) ((primitive-ref string->symbol) "write") "unrecognized expression")))))))))
# emit-closure
# si = -28
# env = ((f196013 . -24) (f196014 . -20) (f196015 . -16) (f196016 . -12) (f196017 . -8) (f196018 . -4) (f196019 . 0))
# expr = (closure (f196037) (f196019 f196018 f196017 f196016 f196015 f196014 else (primitive-ref error) (primitive-ref write)) (let ((f196037 f196037)) (if (boolean? f196037) ((vector-ref f196019 0) f196037) (if (null? f196037) ((vector-ref f196018 0)) (if (char? f196037) ((vector-ref f196017 0) f196037) (if (fixnum? f196037) ((vector-ref f196016 0) f196037) (if (string? f196037) ((vector-ref f196015 0) f196037) (if (pair? f196037) ((vector-ref f196014 0) f196037) ((primitive-ref error) ((primitive-ref string->symbol) "write") "unrecognized expression")))))))))
    movl $_L_1424853, 0(%ebp)  # closure label
# emit-variable-ref
# env=((f196013 . -24) (f196014 . -20) (f196015 . -16) (f196016 . -12) (f196017 . -8) (f196018 . -4) (f196019 . 0))
# var=f196019
    movl 0(%esp), %eax  # stack load f196019
# end emit-variable-ref
   movl  %eax, 4(%ebp)  # f196019
# emit-variable-ref
# env=((f196013 . -24) (f196014 . -20) (f196015 . -16) (f196016 . -12) (f196017 . -8) (f196018 . -4) (f196019 . 0))
# var=f196018
    movl -4(%esp), %eax  # stack load f196018
# end emit-variable-ref
   movl  %eax, 8(%ebp)  # f196018
# emit-variable-ref
# env=((f196013 . -24) (f196014 . -20) (f196015 . -16) (f196016 . -12) (f196017 . -8) (f196018 . -4) (f196019 . 0))
# var=f196017
    movl -8(%esp), %eax  # stack load f196017
# end emit-variable-ref
   movl  %eax, 12(%ebp)  # f196017
# emit-variable-ref
# env=((f196013 . -24) (f196014 . -20) (f196015 . -16) (f196016 . -12) (f196017 . -8) (f196018 . -4) (f196019 . 0))
# var=f196016
    movl -12(%esp), %eax  # stack load f196016
# end emit-variable-ref
   movl  %eax, 16(%ebp)  # f196016
# emit-variable-ref
# env=((f196013 . -24) (f196014 . -20) (f196015 . -16) (f196016 . -12) (f196017 . -8) (f196018 . -4) (f196019 . 0))
# var=f196015
    movl -16(%esp), %eax  # stack load f196015
# end emit-variable-ref
   movl  %eax, 20(%ebp)  # f196015
# emit-variable-ref
# env=((f196013 . -24) (f196014 . -20) (f196015 . -16) (f196016 . -12) (f196017 . -8) (f196018 . -4) (f196019 . 0))
# var=f196014
    movl -20(%esp), %eax  # stack load f196014
# end emit-variable-ref
   movl  %eax, 24(%ebp)  # f196014
# WARNING: free var else not defined in the environmnet
# WARNING: free var (primitive-ref error) not defined in the environmnet
# WARNING: free var (primitive-ref write) not defined in the environmnet
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $40, %ebp     # bump ebp
    jmp _L_1424854            # jump around closure body
_L_1424853:
# check argument count
    cmp $4,%eax
    je _L_1424855
# invoke error handler eh_argcount
    .extern mrc_eh$uargcount
    movl mrc_eh$uargcount, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_1424855:
# emit-tail-expr
# si=-12
# env=((f196037 . -8) ((primitive-ref write) . 36) ((primitive-ref error) . 32) (else . 28) (f196014 . 24) (f196015 . 20) (f196016 . 16) (f196017 . 12) (f196018 . 8) (f196019 . 4) (f196013 . -24) (f196014 . -20) (f196015 . -16) (f196016 . -12) (f196017 . -8) (f196018 . -4) (f196019 . 0))
# expr=(let ((f196037 f196037)) (if (boolean? f196037) ((vector-ref f196019 0) f196037) (if (null? f196037) ((vector-ref f196018 0)) (if (char? f196037) ((vector-ref f196017 0) f196037) (if (fixnum? f196037) ((vector-ref f196016 0) f196037) (if (string? f196037) ((vector-ref f196015 0) f196037) (if (pair? f196037) ((vector-ref f196014 0) f196037) ((primitive-ref error) ((primitive-ref string->symbol) "write") "unrecognized expression"))))))))
# emit-tail-let
#  si   = -12
#  env  = ((f196037 . -8) ((primitive-ref write) . 36) ((primitive-ref error) . 32) (else . 28) (f196014 . 24) (f196015 . 20) (f196016 . 16) (f196017 . 12) (f196018 . 8) (f196019 . 4) (f196013 . -24) (f196014 . -20) (f196015 . -16) (f196016 . -12) (f196017 . -8) (f196018 . -4) (f196019 . 0))
#  bindings = ((f196037 f196037))
#  body = (if (boolean? f196037) ((vector-ref f196019 0) f196037) (if (null? f196037) ((vector-ref f196018 0)) (if (char? f196037) ((vector-ref f196017 0) f196037) (if (fixnum? f196037) ((vector-ref f196016 0) f196037) (if (string? f196037) ((vector-ref f196015 0) f196037) (if (pair? f196037) ((vector-ref f196014 0) f196037) ((primitive-ref error) ((primitive-ref string->symbol) "write") "unrecognized expression")))))))
# emit-expr f196037
# emit-variable-ref
# env=((f196037 . -8) ((primitive-ref write) . 36) ((primitive-ref error) . 32) (else . 28) (f196014 . 24) (f196015 . 20) (f196016 . 16) (f196017 . 12) (f196018 . 8) (f196019 . 4) (f196013 . -24) (f196014 . -20) (f196015 . -16) (f196016 . -12) (f196017 . -8) (f196018 . -4) (f196019 . 0))
# var=f196037
    movl -8(%esp), %eax  # stack load f196037
# end emit-variable-ref
    movl %eax, -12(%esp)  # stack save
# emit-tail-expr
# si=-16
# env=((f196037 . -12) (f196037 . -8) ((primitive-ref write) . 36) ((primitive-ref error) . 32) (else . 28) (f196014 . 24) (f196015 . 20) (f196016 . 16) (f196017 . 12) (f196018 . 8) (f196019 . 4) (f196013 . -24) (f196014 . -20) (f196015 . -16) (f196016 . -12) (f196017 . -8) (f196018 . -4) (f196019 . 0))
# expr=(if (boolean? f196037) ((vector-ref f196019 0) f196037) (if (null? f196037) ((vector-ref f196018 0)) (if (char? f196037) ((vector-ref f196017 0) f196037) (if (fixnum? f196037) ((vector-ref f196016 0) f196037) (if (string? f196037) ((vector-ref f196015 0) f196037) (if (pair? f196037) ((vector-ref f196014 0) f196037) ((primitive-ref error) ((primitive-ref string->symbol) "write") "unrecognized expression")))))))
# emit-expr (boolean? f196037)
# emit-expr f196037
# emit-variable-ref
# env=((f196037 . -12) (f196037 . -8) ((primitive-ref write) . 36) ((primitive-ref error) . 32) (else . 28) (f196014 . 24) (f196015 . 20) (f196016 . 16) (f196017 . 12) (f196018 . 8) (f196019 . 4) (f196013 . -24) (f196014 . -20) (f196015 . -16) (f196016 . -12) (f196017 . -8) (f196018 . -4) (f196019 . 0))
# var=f196037
    movl -12(%esp), %eax  # stack load f196037
# end emit-variable-ref
    and $191, %eax
    cmp $47, %eax
    sete %al
    movzbl %al, %eax
    sal $6, %al
    or $47, %al
    cmp $47, %al
    je _L_1424856
# emit-tail-expr
# si=-16
# env=((f196037 . -12) (f196037 . -8) ((primitive-ref write) . 36) ((primitive-ref error) . 32) (else . 28) (f196014 . 24) (f196015 . 20) (f196016 . 16) (f196017 . 12) (f196018 . 8) (f196019 . 4) (f196013 . -24) (f196014 . -20) (f196015 . -16) (f196016 . -12) (f196017 . -8) (f196018 . -4) (f196019 . 0))
# expr=((vector-ref f196019 0) f196037)
# emit-tail-funcall
#    si   =-16
#    env  = ((f196037 . -12) (f196037 . -8) ((primitive-ref write) . 36) ((primitive-ref error) . 32) (else . 28) (f196014 . 24) (f196015 . 20) (f196016 . 16) (f196017 . 12) (f196018 . 8) (f196019 . 4) (f196013 . -24) (f196014 . -20) (f196015 . -16) (f196016 . -12) (f196017 . -8) (f196018 . -4) (f196019 . 0))
#    expr = (funcall (vector-ref f196019 0) f196037)
# emit-expr (vector-ref f196019 0)
# emit-expr f196019
# emit-variable-ref
# env=((f196037 . -12) (f196037 . -8) ((primitive-ref write) . 36) ((primitive-ref error) . 32) (else . 28) (f196014 . 24) (f196015 . 20) (f196016 . 16) (f196017 . 12) (f196018 . 8) (f196019 . 4) (f196013 . -24) (f196014 . -20) (f196015 . -16) (f196016 . -12) (f196017 . -8) (f196018 . -4) (f196019 . 0))
# var=f196019
    movl 2(%edi), %eax  # frame load f196019
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1424858
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1424858:
    movl %eax, -16(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1424859"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1424859:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1424861
    cmp  $0,%eax
    jge _L_1424860
_L_1424861:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1424860:
    movl -16(%esp), %esi
    movl -1(%eax,%esi), %eax
   movl %eax,  -16(%esp)  # stash funcall-oper in next closure slot
# emit-expr f196037
# emit-variable-ref
# env=((f196037 . -12) (f196037 . -8) ((primitive-ref write) . 36) ((primitive-ref error) . 32) (else . 28) (f196014 . 24) (f196015 . 20) (f196016 . 16) (f196017 . 12) (f196018 . 8) (f196019 . 4) (f196013 . -24) (f196014 . -20) (f196015 . -16) (f196016 . -12) (f196017 . -8) (f196018 . -4) (f196019 . 0))
# var=f196037
    movl -12(%esp), %eax  # stack load f196037
# end emit-variable-ref
    mov %eax, -20(%esp)    # arg f196037
    movl -16(%esp), %edi   # load new closure to %edi
# emit-shift-args:  size=2   si=-16  delta=12
    mov -16(%esp), %ebx  # shift frame cell
    mov %ebx, -4(%esp)  # down to base
# emit-shift-args:  size=1   si=-20  delta=12
    mov -20(%esp), %ebx  # shift frame cell
    mov %ebx, -8(%esp)  # down to base
# emit-shift-args:  size=0   si=-24  delta=12
    movl $4,%eax   # save arg count
    jmp *-2(%edi)  # tail-funcall
    jmp _L_1424857
_L_1424856:
# emit-tail-expr
# si=-16
# env=((f196037 . -12) (f196037 . -8) ((primitive-ref write) . 36) ((primitive-ref error) . 32) (else . 28) (f196014 . 24) (f196015 . 20) (f196016 . 16) (f196017 . 12) (f196018 . 8) (f196019 . 4) (f196013 . -24) (f196014 . -20) (f196015 . -16) (f196016 . -12) (f196017 . -8) (f196018 . -4) (f196019 . 0))
# expr=(if (null? f196037) ((vector-ref f196018 0)) (if (char? f196037) ((vector-ref f196017 0) f196037) (if (fixnum? f196037) ((vector-ref f196016 0) f196037) (if (string? f196037) ((vector-ref f196015 0) f196037) (if (pair? f196037) ((vector-ref f196014 0) f196037) ((primitive-ref error) ((primitive-ref string->symbol) "write") "unrecognized expression"))))))
# emit-expr (null? f196037)
# emit-expr f196037
# emit-variable-ref
# env=((f196037 . -12) (f196037 . -8) ((primitive-ref write) . 36) ((primitive-ref error) . 32) (else . 28) (f196014 . 24) (f196015 . 20) (f196016 . 16) (f196017 . 12) (f196018 . 8) (f196019 . 4) (f196013 . -24) (f196014 . -20) (f196015 . -16) (f196016 . -12) (f196017 . -8) (f196018 . -4) (f196019 . 0))
# var=f196037
    movl -12(%esp), %eax  # stack load f196037
# end emit-variable-ref
    cmp $63, %eax
    mov $0, %eax
    sete %al
    movzbl %al, %eax
    sal $6, %al
    or $47, %al
    cmp $47, %al
    je _L_1424862
# emit-tail-expr
# si=-16
# env=((f196037 . -12) (f196037 . -8) ((primitive-ref write) . 36) ((primitive-ref error) . 32) (else . 28) (f196014 . 24) (f196015 . 20) (f196016 . 16) (f196017 . 12) (f196018 . 8) (f196019 . 4) (f196013 . -24) (f196014 . -20) (f196015 . -16) (f196016 . -12) (f196017 . -8) (f196018 . -4) (f196019 . 0))
# expr=((vector-ref f196018 0))
# emit-tail-funcall
#    si   =-16
#    env  = ((f196037 . -12) (f196037 . -8) ((primitive-ref write) . 36) ((primitive-ref error) . 32) (else . 28) (f196014 . 24) (f196015 . 20) (f196016 . 16) (f196017 . 12) (f196018 . 8) (f196019 . 4) (f196013 . -24) (f196014 . -20) (f196015 . -16) (f196016 . -12) (f196017 . -8) (f196018 . -4) (f196019 . 0))
#    expr = (funcall (vector-ref f196018 0))
# emit-expr (vector-ref f196018 0)
# emit-expr f196018
# emit-variable-ref
# env=((f196037 . -12) (f196037 . -8) ((primitive-ref write) . 36) ((primitive-ref error) . 32) (else . 28) (f196014 . 24) (f196015 . 20) (f196016 . 16) (f196017 . 12) (f196018 . 8) (f196019 . 4) (f196013 . -24) (f196014 . -20) (f196015 . -16) (f196016 . -12) (f196017 . -8) (f196018 . -4) (f196019 . 0))
# var=f196018
    movl 6(%edi), %eax  # frame load f196018
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1424864
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1424864:
    movl %eax, -16(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1424865"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1424865:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1424867
    cmp  $0,%eax
    jge _L_1424866
_L_1424867:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1424866:
    movl -16(%esp), %esi
    movl -1(%eax,%esi), %eax
   movl %eax,  -16(%esp)  # stash funcall-oper in next closure slot
    movl -16(%esp), %edi   # load new closure to %edi
# emit-shift-args:  size=1   si=-16  delta=12
    mov -16(%esp), %ebx  # shift frame cell
    mov %ebx, -4(%esp)  # down to base
# emit-shift-args:  size=0   si=-20  delta=12
    movl $0,%eax   # save arg count
    jmp *-2(%edi)  # tail-funcall
    jmp _L_1424863
_L_1424862:
# emit-tail-expr
# si=-16
# env=((f196037 . -12) (f196037 . -8) ((primitive-ref write) . 36) ((primitive-ref error) . 32) (else . 28) (f196014 . 24) (f196015 . 20) (f196016 . 16) (f196017 . 12) (f196018 . 8) (f196019 . 4) (f196013 . -24) (f196014 . -20) (f196015 . -16) (f196016 . -12) (f196017 . -8) (f196018 . -4) (f196019 . 0))
# expr=(if (char? f196037) ((vector-ref f196017 0) f196037) (if (fixnum? f196037) ((vector-ref f196016 0) f196037) (if (string? f196037) ((vector-ref f196015 0) f196037) (if (pair? f196037) ((vector-ref f196014 0) f196037) ((primitive-ref error) ((primitive-ref string->symbol) "write") "unrecognized expression")))))
# emit-expr (char? f196037)
# emit-expr f196037
# emit-variable-ref
# env=((f196037 . -12) (f196037 . -8) ((primitive-ref write) . 36) ((primitive-ref error) . 32) (else . 28) (f196014 . 24) (f196015 . 20) (f196016 . 16) (f196017 . 12) (f196018 . 8) (f196019 . 4) (f196013 . -24) (f196014 . -20) (f196015 . -16) (f196016 . -12) (f196017 . -8) (f196018 . -4) (f196019 . 0))
# var=f196037
    movl -12(%esp), %eax  # stack load f196037
# end emit-variable-ref
    and $255, %eax
    cmp $15, %eax
    sete %al
    movzbl %al, %eax
    sal $6, %al
    or $47, %al
    cmp $47, %al
    je _L_1424868
# emit-tail-expr
# si=-16
# env=((f196037 . -12) (f196037 . -8) ((primitive-ref write) . 36) ((primitive-ref error) . 32) (else . 28) (f196014 . 24) (f196015 . 20) (f196016 . 16) (f196017 . 12) (f196018 . 8) (f196019 . 4) (f196013 . -24) (f196014 . -20) (f196015 . -16) (f196016 . -12) (f196017 . -8) (f196018 . -4) (f196019 . 0))
# expr=((vector-ref f196017 0) f196037)
# emit-tail-funcall
#    si   =-16
#    env  = ((f196037 . -12) (f196037 . -8) ((primitive-ref write) . 36) ((primitive-ref error) . 32) (else . 28) (f196014 . 24) (f196015 . 20) (f196016 . 16) (f196017 . 12) (f196018 . 8) (f196019 . 4) (f196013 . -24) (f196014 . -20) (f196015 . -16) (f196016 . -12) (f196017 . -8) (f196018 . -4) (f196019 . 0))
#    expr = (funcall (vector-ref f196017 0) f196037)
# emit-expr (vector-ref f196017 0)
# emit-expr f196017
# emit-variable-ref
# env=((f196037 . -12) (f196037 . -8) ((primitive-ref write) . 36) ((primitive-ref error) . 32) (else . 28) (f196014 . 24) (f196015 . 20) (f196016 . 16) (f196017 . 12) (f196018 . 8) (f196019 . 4) (f196013 . -24) (f196014 . -20) (f196015 . -16) (f196016 . -12) (f196017 . -8) (f196018 . -4) (f196019 . 0))
# var=f196017
    movl 10(%edi), %eax  # frame load f196017
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1424870
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1424870:
    movl %eax, -16(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1424871"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1424871:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1424873
    cmp  $0,%eax
    jge _L_1424872
_L_1424873:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1424872:
    movl -16(%esp), %esi
    movl -1(%eax,%esi), %eax
   movl %eax,  -16(%esp)  # stash funcall-oper in next closure slot
# emit-expr f196037
# emit-variable-ref
# env=((f196037 . -12) (f196037 . -8) ((primitive-ref write) . 36) ((primitive-ref error) . 32) (else . 28) (f196014 . 24) (f196015 . 20) (f196016 . 16) (f196017 . 12) (f196018 . 8) (f196019 . 4) (f196013 . -24) (f196014 . -20) (f196015 . -16) (f196016 . -12) (f196017 . -8) (f196018 . -4) (f196019 . 0))
# var=f196037
    movl -12(%esp), %eax  # stack load f196037
# end emit-variable-ref
    mov %eax, -20(%esp)    # arg f196037
    movl -16(%esp), %edi   # load new closure to %edi
# emit-shift-args:  size=2   si=-16  delta=12
    mov -16(%esp), %ebx  # shift frame cell
    mov %ebx, -4(%esp)  # down to base
# emit-shift-args:  size=1   si=-20  delta=12
    mov -20(%esp), %ebx  # shift frame cell
    mov %ebx, -8(%esp)  # down to base
# emit-shift-args:  size=0   si=-24  delta=12
    movl $4,%eax   # save arg count
    jmp *-2(%edi)  # tail-funcall
    jmp _L_1424869
_L_1424868:
# emit-tail-expr
# si=-16
# env=((f196037 . -12) (f196037 . -8) ((primitive-ref write) . 36) ((primitive-ref error) . 32) (else . 28) (f196014 . 24) (f196015 . 20) (f196016 . 16) (f196017 . 12) (f196018 . 8) (f196019 . 4) (f196013 . -24) (f196014 . -20) (f196015 . -16) (f196016 . -12) (f196017 . -8) (f196018 . -4) (f196019 . 0))
# expr=(if (fixnum? f196037) ((vector-ref f196016 0) f196037) (if (string? f196037) ((vector-ref f196015 0) f196037) (if (pair? f196037) ((vector-ref f196014 0) f196037) ((primitive-ref error) ((primitive-ref string->symbol) "write") "unrecognized expression"))))
# emit-expr (fixnum? f196037)
# emit-expr f196037
# emit-variable-ref
# env=((f196037 . -12) (f196037 . -8) ((primitive-ref write) . 36) ((primitive-ref error) . 32) (else . 28) (f196014 . 24) (f196015 . 20) (f196016 . 16) (f196017 . 12) (f196018 . 8) (f196019 . 4) (f196013 . -24) (f196014 . -20) (f196015 . -16) (f196016 . -12) (f196017 . -8) (f196018 . -4) (f196019 . 0))
# var=f196037
    movl -12(%esp), %eax  # stack load f196037
# end emit-variable-ref
    and $3, %al
    cmp $0, %al
    sete %al
    movzbl %al, %eax
    sal $6, %al
    or $47, %al
    cmp $47, %al
    je _L_1424874
# emit-tail-expr
# si=-16
# env=((f196037 . -12) (f196037 . -8) ((primitive-ref write) . 36) ((primitive-ref error) . 32) (else . 28) (f196014 . 24) (f196015 . 20) (f196016 . 16) (f196017 . 12) (f196018 . 8) (f196019 . 4) (f196013 . -24) (f196014 . -20) (f196015 . -16) (f196016 . -12) (f196017 . -8) (f196018 . -4) (f196019 . 0))
# expr=((vector-ref f196016 0) f196037)
# emit-tail-funcall
#    si   =-16
#    env  = ((f196037 . -12) (f196037 . -8) ((primitive-ref write) . 36) ((primitive-ref error) . 32) (else . 28) (f196014 . 24) (f196015 . 20) (f196016 . 16) (f196017 . 12) (f196018 . 8) (f196019 . 4) (f196013 . -24) (f196014 . -20) (f196015 . -16) (f196016 . -12) (f196017 . -8) (f196018 . -4) (f196019 . 0))
#    expr = (funcall (vector-ref f196016 0) f196037)
# emit-expr (vector-ref f196016 0)
# emit-expr f196016
# emit-variable-ref
# env=((f196037 . -12) (f196037 . -8) ((primitive-ref write) . 36) ((primitive-ref error) . 32) (else . 28) (f196014 . 24) (f196015 . 20) (f196016 . 16) (f196017 . 12) (f196018 . 8) (f196019 . 4) (f196013 . -24) (f196014 . -20) (f196015 . -16) (f196016 . -12) (f196017 . -8) (f196018 . -4) (f196019 . 0))
# var=f196016
    movl 14(%edi), %eax  # frame load f196016
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1424876
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1424876:
    movl %eax, -16(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1424877"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1424877:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1424879
    cmp  $0,%eax
    jge _L_1424878
_L_1424879:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1424878:
    movl -16(%esp), %esi
    movl -1(%eax,%esi), %eax
   movl %eax,  -16(%esp)  # stash funcall-oper in next closure slot
# emit-expr f196037
# emit-variable-ref
# env=((f196037 . -12) (f196037 . -8) ((primitive-ref write) . 36) ((primitive-ref error) . 32) (else . 28) (f196014 . 24) (f196015 . 20) (f196016 . 16) (f196017 . 12) (f196018 . 8) (f196019 . 4) (f196013 . -24) (f196014 . -20) (f196015 . -16) (f196016 . -12) (f196017 . -8) (f196018 . -4) (f196019 . 0))
# var=f196037
    movl -12(%esp), %eax  # stack load f196037
# end emit-variable-ref
    mov %eax, -20(%esp)    # arg f196037
    movl -16(%esp), %edi   # load new closure to %edi
# emit-shift-args:  size=2   si=-16  delta=12
    mov -16(%esp), %ebx  # shift frame cell
    mov %ebx, -4(%esp)  # down to base
# emit-shift-args:  size=1   si=-20  delta=12
    mov -20(%esp), %ebx  # shift frame cell
    mov %ebx, -8(%esp)  # down to base
# emit-shift-args:  size=0   si=-24  delta=12
    movl $4,%eax   # save arg count
    jmp *-2(%edi)  # tail-funcall
    jmp _L_1424875
_L_1424874:
# emit-tail-expr
# si=-16
# env=((f196037 . -12) (f196037 . -8) ((primitive-ref write) . 36) ((primitive-ref error) . 32) (else . 28) (f196014 . 24) (f196015 . 20) (f196016 . 16) (f196017 . 12) (f196018 . 8) (f196019 . 4) (f196013 . -24) (f196014 . -20) (f196015 . -16) (f196016 . -12) (f196017 . -8) (f196018 . -4) (f196019 . 0))
# expr=(if (string? f196037) ((vector-ref f196015 0) f196037) (if (pair? f196037) ((vector-ref f196014 0) f196037) ((primitive-ref error) ((primitive-ref string->symbol) "write") "unrecognized expression")))
# emit-expr (string? f196037)
# emit-expr f196037
# emit-variable-ref
# env=((f196037 . -12) (f196037 . -8) ((primitive-ref write) . 36) ((primitive-ref error) . 32) (else . 28) (f196014 . 24) (f196015 . 20) (f196016 . 16) (f196017 . 12) (f196018 . 8) (f196019 . 4) (f196013 . -24) (f196014 . -20) (f196015 . -16) (f196016 . -12) (f196017 . -8) (f196018 . -4) (f196019 . 0))
# var=f196037
    movl -12(%esp), %eax  # stack load f196037
# end emit-variable-ref
    and $7, %al
    cmp $6, %al
    sete %al
    movzbl %al, %eax
    sal $6, %al
    or $47, %al
    cmp $47, %al
    je _L_1424880
# emit-tail-expr
# si=-16
# env=((f196037 . -12) (f196037 . -8) ((primitive-ref write) . 36) ((primitive-ref error) . 32) (else . 28) (f196014 . 24) (f196015 . 20) (f196016 . 16) (f196017 . 12) (f196018 . 8) (f196019 . 4) (f196013 . -24) (f196014 . -20) (f196015 . -16) (f196016 . -12) (f196017 . -8) (f196018 . -4) (f196019 . 0))
# expr=((vector-ref f196015 0) f196037)
# emit-tail-funcall
#    si   =-16
#    env  = ((f196037 . -12) (f196037 . -8) ((primitive-ref write) . 36) ((primitive-ref error) . 32) (else . 28) (f196014 . 24) (f196015 . 20) (f196016 . 16) (f196017 . 12) (f196018 . 8) (f196019 . 4) (f196013 . -24) (f196014 . -20) (f196015 . -16) (f196016 . -12) (f196017 . -8) (f196018 . -4) (f196019 . 0))
#    expr = (funcall (vector-ref f196015 0) f196037)
# emit-expr (vector-ref f196015 0)
# emit-expr f196015
# emit-variable-ref
# env=((f196037 . -12) (f196037 . -8) ((primitive-ref write) . 36) ((primitive-ref error) . 32) (else . 28) (f196014 . 24) (f196015 . 20) (f196016 . 16) (f196017 . 12) (f196018 . 8) (f196019 . 4) (f196013 . -24) (f196014 . -20) (f196015 . -16) (f196016 . -12) (f196017 . -8) (f196018 . -4) (f196019 . 0))
# var=f196015
    movl 18(%edi), %eax  # frame load f196015
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1424882
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1424882:
    movl %eax, -16(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1424883"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1424883:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1424885
    cmp  $0,%eax
    jge _L_1424884
_L_1424885:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1424884:
    movl -16(%esp), %esi
    movl -1(%eax,%esi), %eax
   movl %eax,  -16(%esp)  # stash funcall-oper in next closure slot
# emit-expr f196037
# emit-variable-ref
# env=((f196037 . -12) (f196037 . -8) ((primitive-ref write) . 36) ((primitive-ref error) . 32) (else . 28) (f196014 . 24) (f196015 . 20) (f196016 . 16) (f196017 . 12) (f196018 . 8) (f196019 . 4) (f196013 . -24) (f196014 . -20) (f196015 . -16) (f196016 . -12) (f196017 . -8) (f196018 . -4) (f196019 . 0))
# var=f196037
    movl -12(%esp), %eax  # stack load f196037
# end emit-variable-ref
    mov %eax, -20(%esp)    # arg f196037
    movl -16(%esp), %edi   # load new closure to %edi
# emit-shift-args:  size=2   si=-16  delta=12
    mov -16(%esp), %ebx  # shift frame cell
    mov %ebx, -4(%esp)  # down to base
# emit-shift-args:  size=1   si=-20  delta=12
    mov -20(%esp), %ebx  # shift frame cell
    mov %ebx, -8(%esp)  # down to base
# emit-shift-args:  size=0   si=-24  delta=12
    movl $4,%eax   # save arg count
    jmp *-2(%edi)  # tail-funcall
    jmp _L_1424881
_L_1424880:
# emit-tail-expr
# si=-16
# env=((f196037 . -12) (f196037 . -8) ((primitive-ref write) . 36) ((primitive-ref error) . 32) (else . 28) (f196014 . 24) (f196015 . 20) (f196016 . 16) (f196017 . 12) (f196018 . 8) (f196019 . 4) (f196013 . -24) (f196014 . -20) (f196015 . -16) (f196016 . -12) (f196017 . -8) (f196018 . -4) (f196019 . 0))
# expr=(if (pair? f196037) ((vector-ref f196014 0) f196037) ((primitive-ref error) ((primitive-ref string->symbol) "write") "unrecognized expression"))
# emit-expr (pair? f196037)
# emit-expr f196037
# emit-variable-ref
# env=((f196037 . -12) (f196037 . -8) ((primitive-ref write) . 36) ((primitive-ref error) . 32) (else . 28) (f196014 . 24) (f196015 . 20) (f196016 . 16) (f196017 . 12) (f196018 . 8) (f196019 . 4) (f196013 . -24) (f196014 . -20) (f196015 . -16) (f196016 . -12) (f196017 . -8) (f196018 . -4) (f196019 . 0))
# var=f196037
    movl -12(%esp), %eax  # stack load f196037
# end emit-variable-ref
    and $7, %al
    cmp $1, %al
    sete %al
    movzbl %al, %eax
    sal $6, %al
    or $47, %al
    cmp $47, %al
    je _L_1424886
# emit-tail-expr
# si=-16
# env=((f196037 . -12) (f196037 . -8) ((primitive-ref write) . 36) ((primitive-ref error) . 32) (else . 28) (f196014 . 24) (f196015 . 20) (f196016 . 16) (f196017 . 12) (f196018 . 8) (f196019 . 4) (f196013 . -24) (f196014 . -20) (f196015 . -16) (f196016 . -12) (f196017 . -8) (f196018 . -4) (f196019 . 0))
# expr=((vector-ref f196014 0) f196037)
# emit-tail-funcall
#    si   =-16
#    env  = ((f196037 . -12) (f196037 . -8) ((primitive-ref write) . 36) ((primitive-ref error) . 32) (else . 28) (f196014 . 24) (f196015 . 20) (f196016 . 16) (f196017 . 12) (f196018 . 8) (f196019 . 4) (f196013 . -24) (f196014 . -20) (f196015 . -16) (f196016 . -12) (f196017 . -8) (f196018 . -4) (f196019 . 0))
#    expr = (funcall (vector-ref f196014 0) f196037)
# emit-expr (vector-ref f196014 0)
# emit-expr f196014
# emit-variable-ref
# env=((f196037 . -12) (f196037 . -8) ((primitive-ref write) . 36) ((primitive-ref error) . 32) (else . 28) (f196014 . 24) (f196015 . 20) (f196016 . 16) (f196017 . 12) (f196018 . 8) (f196019 . 4) (f196013 . -24) (f196014 . -20) (f196015 . -16) (f196016 . -12) (f196017 . -8) (f196018 . -4) (f196019 . 0))
# var=f196014
    movl 22(%edi), %eax  # frame load f196014
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1424888
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1424888:
    movl %eax, -16(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1424889"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1424889:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1424891
    cmp  $0,%eax
    jge _L_1424890
_L_1424891:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1424890:
    movl -16(%esp), %esi
    movl -1(%eax,%esi), %eax
   movl %eax,  -16(%esp)  # stash funcall-oper in next closure slot
# emit-expr f196037
# emit-variable-ref
# env=((f196037 . -12) (f196037 . -8) ((primitive-ref write) . 36) ((primitive-ref error) . 32) (else . 28) (f196014 . 24) (f196015 . 20) (f196016 . 16) (f196017 . 12) (f196018 . 8) (f196019 . 4) (f196013 . -24) (f196014 . -20) (f196015 . -16) (f196016 . -12) (f196017 . -8) (f196018 . -4) (f196019 . 0))
# var=f196037
    movl -12(%esp), %eax  # stack load f196037
# end emit-variable-ref
    mov %eax, -20(%esp)    # arg f196037
    movl -16(%esp), %edi   # load new closure to %edi
# emit-shift-args:  size=2   si=-16  delta=12
    mov -16(%esp), %ebx  # shift frame cell
    mov %ebx, -4(%esp)  # down to base
# emit-shift-args:  size=1   si=-20  delta=12
    mov -20(%esp), %ebx  # shift frame cell
    mov %ebx, -8(%esp)  # down to base
# emit-shift-args:  size=0   si=-24  delta=12
    movl $4,%eax   # save arg count
    jmp *-2(%edi)  # tail-funcall
    jmp _L_1424887
_L_1424886:
# emit-tail-expr
# si=-16
# env=((f196037 . -12) (f196037 . -8) ((primitive-ref write) . 36) ((primitive-ref error) . 32) (else . 28) (f196014 . 24) (f196015 . 20) (f196016 . 16) (f196017 . 12) (f196018 . 8) (f196019 . 4) (f196013 . -24) (f196014 . -20) (f196015 . -16) (f196016 . -12) (f196017 . -8) (f196018 . -4) (f196019 . 0))
# expr=((primitive-ref error) ((primitive-ref string->symbol) "write") "unrecognized expression")
# emit-tail-funcall
#    si   =-16
#    env  = ((f196037 . -12) (f196037 . -8) ((primitive-ref write) . 36) ((primitive-ref error) . 32) (else . 28) (f196014 . 24) (f196015 . 20) (f196016 . 16) (f196017 . 12) (f196018 . 8) (f196019 . 4) (f196013 . -24) (f196014 . -20) (f196015 . -16) (f196016 . -12) (f196017 . -8) (f196018 . -4) (f196019 . 0))
#    expr = (funcall (primitive-ref error) ((primitive-ref string->symbol) "write") "unrecognized expression")
# emit-expr (primitive-ref error)
    .extern mrc_error
    movl mrc_error,%eax
   movl %eax,  -16(%esp)  # stash funcall-oper in next closure slot
# emit-expr ((primitive-ref string->symbol) "write")
# funcall
#    si   =-20
#    env  = ((f196037 . -12) (f196037 . -8) ((primitive-ref write) . 36) ((primitive-ref error) . 32) (else . 28) (f196014 . 24) (f196015 . 20) (f196016 . 16) (f196017 . 12) (f196018 . 8) (f196019 . 4) (f196013 . -24) (f196014 . -20) (f196015 . -16) (f196016 . -12) (f196017 . -8) (f196018 . -4) (f196019 . 0))
#    expr = (funcall (primitive-ref string->symbol) "write")
# emit-expr (primitive-ref string->symbol)
    .extern mrc_string$m$gsymbol
    movl mrc_string$m$gsymbol,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1424892"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1424892":
   movl %eax,  -28(%esp)  # stash funcall-oper in closure slot
# emit-expr "write"
# string literal
    jmp _L_1424894
    .align 8,0x90
_L_1424893 :
    .int 20
    .ascii "write"
_L_1424894:
    movl $_L_1424893, %eax
    orl $6, %eax
    mov %eax, -32(%esp)  # arg write
    movl -28(%esp), %edi   # load new closure to %edi
    add $-20, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $20, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    mov %eax, -20(%esp)    # arg ((primitive-ref string->symbol) write)
# emit-expr "unrecognized expression"
# string literal
    jmp _L_1424896
    .align 8,0x90
_L_1424895 :
    .int 92
    .ascii "unrecognized expression"
_L_1424896:
    movl $_L_1424895, %eax
    orl $6, %eax
    mov %eax, -24(%esp)    # arg unrecognized expression
    movl -16(%esp), %edi   # load new closure to %edi
# emit-shift-args:  size=3   si=-16  delta=12
    mov -16(%esp), %ebx  # shift frame cell
    mov %ebx, -4(%esp)  # down to base
# emit-shift-args:  size=2   si=-20  delta=12
    mov -20(%esp), %ebx  # shift frame cell
    mov %ebx, -8(%esp)  # down to base
# emit-shift-args:  size=1   si=-24  delta=12
    mov -24(%esp), %ebx  # shift frame cell
    mov %ebx, -12(%esp)  # down to base
# emit-shift-args:  size=0   si=-28  delta=12
    movl $8,%eax   # save arg count
    jmp *-2(%edi)  # tail-funcall
_L_1424887:
_L_1424881:
_L_1424875:
_L_1424869:
_L_1424863:
_L_1424857:
    .align 4,0x90
_L_1424854:
# emit-expr (begin)
# emit-begin
#   expr=(begin)
#   env=((f196013 . -24) (f196014 . -20) (f196015 . -16) (f196016 . -12) (f196017 . -8) (f196018 . -4) (f196019 . 0))
     movl %eax, mrc_write
# == explicit-begins  ==>
# (lambda (i) (fixnum->char i))
# == eliminate-let*  ==>
# (lambda (i) (fixnum->char i))
# == uniquify-variables  ==>
# (lambda (f196038) (fixnum->char f196038))
# == vectorize-letrec  ==>
# (lambda (f196038) (fixnum->char f196038))
# == eliminate-set!  ==>
# (lambda (f196038) (let ((f196038 f196038)) (fixnum->char f196038)))
# == close-free-variables  ==>
# (closure (f196038) () (let ((f196038 f196038)) (fixnum->char f196038)))
# == eliminate-quote  ==>
# (closure (f196038) () (let ((f196038 f196038)) (fixnum->char f196038)))
# == eliminate-when/unless  ==>
# (closure (f196038) () (let ((f196038 f196038)) (fixnum->char f196038)))
# == eliminate-cond  ==>
# (closure (f196038) () (let ((f196038 f196038)) (fixnum->char f196038)))
# == external-symbols  ==>
# (closure (f196038) () (let ((f196038 f196038)) (fixnum->char f196038)))
# emit-expr (closure (f196038) () (let ((f196038 f196038)) (fixnum->char f196038)))
# emit-closure
# si = 0
# env = ()
# expr = (closure (f196038) () (let ((f196038 f196038)) (fixnum->char f196038)))
    movl $_L_1424897, 0(%ebp)  # closure label
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $8, %ebp     # bump ebp
    jmp _L_1424898            # jump around closure body
_L_1424897:
# check argument count
    cmp $4,%eax
    je _L_1424899
# invoke error handler eh_argcount
    .extern mrc_eh$uargcount
    movl mrc_eh$uargcount, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_1424899:
# emit-tail-expr
# si=-12
# env=((f196038 . -8))
# expr=(let ((f196038 f196038)) (fixnum->char f196038))
# emit-tail-let
#  si   = -12
#  env  = ((f196038 . -8))
#  bindings = ((f196038 f196038))
#  body = (fixnum->char f196038)
# emit-expr f196038
# emit-variable-ref
# env=((f196038 . -8))
# var=f196038
    movl -8(%esp), %eax  # stack load f196038
# end emit-variable-ref
    movl %eax, -12(%esp)  # stack save
# emit-tail-expr
# si=-16
# env=((f196038 . -12) (f196038 . -8))
# expr=(fixnum->char f196038)
# tail primcall
# emit-expr f196038
# emit-variable-ref
# env=((f196038 . -12) (f196038 . -8))
# var=f196038
    movl -12(%esp), %eax  # stack load f196038
# end emit-variable-ref
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1424900"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $0,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1424900:
    shll $6, %eax
    orl $15, %eax
#return from tail (fixnum->char f196038)
    ret
    .align 4,0x90
_L_1424898:
     movl %eax, mrc_integer$m$gchar
# emit-expr (begin #t)
# emit-begin
#   expr=(begin #t)
#   env=()
# emit-expr #t
    movl $111, %eax     # immed #t
# emit-expr (begin)
# emit-begin
#   expr=(begin)
#   env=()
    .extern base_init_callback
    jmp base_init_callback
