     .data
     .global "mrc_symbols"
     .align 8
mrc_symbols:
     .int 0xFF
     .global "mrc_string$e$q"
     .align 8
mrc_string$e$q:
     .int 0xFF
     .global "mrc_string$m$gsymbol"
     .align 8
mrc_string$m$gsymbol:
     .int 0xFF
     .global "mrc_append1"
     .align 8
mrc_append1:
     .int 0xFF
     .global "mrc_list$mref"
     .align 8
mrc_list$mref:
     .int 0xFF
     .global "mrc_list$mlength"
     .align 8
mrc_list$mlength:
     .int 0xFF
     .global "mrc_reverse"
     .align 8
mrc_reverse:
     .int 0xFF
     .global "mrc_list"
     .align 8
mrc_list:
     .int 0xFF
     .global "mrc_vector"
     .align 8
mrc_vector:
     .int 0xFF
     .global "mrc_string"
     .align 8
mrc_string:
     .int 0xFF
     .global "mrc_string$m$glist"
     .align 8
mrc_string$m$glist:
     .int 0xFF
     .global "mrc_integer$m$glist"
     .align 8
mrc_integer$m$glist:
     .int 0xFF
     .global "mrc_error"
     .align 8
mrc_error:
     .int 0xFF
     .global "mrc_primitives"
     .align 8
mrc_primitives:
     .int 0xFF
     .global "mrc_eh$uprocedure"
     .align 8
mrc_eh$uprocedure:
     .int 0xFF
     .global "mrc_eh$uargcount"
     .align 8
mrc_eh$uargcount:
     .int 0xFF
     .global "mrc_eh$uargcount$umin"
     .align 8
mrc_eh$uargcount$umin:
     .int 0xFF
     .global "mrc_eh$ufixnum"
     .align 8
mrc_eh$ufixnum:
     .int 0xFF
     .global "mrc_eh$ustring"
     .align 8
mrc_eh$ustring:
     .int 0xFF
     .global "mrc_eh$ucharacter"
     .align 8
mrc_eh$ucharacter:
     .int 0xFF
     .global "mrc_eh$upair"
     .align 8
mrc_eh$upair:
     .int 0xFF
     .global "mrc_eh$uvector"
     .align 8
mrc_eh$uvector:
     .int 0xFF
     .global "mrc_eh$ulength"
     .align 8
mrc_eh$ulength:
     .int 0xFF
     .global "mrc_eh$uvector$uindex"
     .align 8
mrc_eh$uvector$uindex:
     .int 0xFF
     .global "mrc_eh$ustring$uindex"
     .align 8
mrc_eh$ustring$uindex:
     .int 0xFF
     .global "mrc_zero$q"
     .align 8
mrc_zero$q:
     .int 0xFF
     .global "mrc_positive$q"
     .align 8
mrc_positive$q:
     .int 0xFF
     .global "mrc_negative$q"
     .align 8
mrc_negative$q:
     .int 0xFF
     .global "mrc_even$q"
     .align 8
mrc_even$q:
     .int 0xFF
     .global "mrc_odd$q"
     .align 8
mrc_odd$q:
     .int 0xFF
     .global "mrc_map"
     .align 8
mrc_map:
     .int 0xFF
     .global "mrc_for$meach"
     .align 8
mrc_for$meach:
     .int 0xFF
     .global "mrc_standard$mout"
     .align 8
mrc_standard$mout:
     .int 0xFF
     .global "mrc_current$moutput$mport"
     .align 8
mrc_current$moutput$mport:
     .int 0xFF
     .global "mrc_current$minput$mport"
     .align 8
mrc_current$minput$mport:
     .int 0xFF
     .global "mrc_port$mkind"
     .align 8
mrc_port$mkind:
     .int 0xFF
     .global "mrc_port$mpath"
     .align 8
mrc_port$mpath:
     .int 0xFF
     .global "mrc_port$mfd"
     .align 8
mrc_port$mfd:
     .int 0xFF
     .global "mrc_port$mbuf"
     .align 8
mrc_port$mbuf:
     .int 0xFF
     .global "mrc_port$mndx"
     .align 8
mrc_port$mndx:
     .int 0xFF
     .global "mrc_port$mndx$madd1"
     .align 8
mrc_port$mndx$madd1:
     .int 0xFF
     .global "mrc_port$mndx$mreset"
     .align 8
mrc_port$mndx$mreset:
     .int 0xFF
     .global "mrc_port$msize"
     .align 8
mrc_port$msize:
     .int 0xFF
     .global "mrc_write$mchar"
     .align 8
mrc_write$mchar:
     .int 0xFF
     .global "mrc_flush$moutput$mport"
     .align 8
mrc_flush$moutput$mport:
     .int 0xFF
     .global "mrc_exit"
     .align 8
mrc_exit:
     .int 0xFF
     .global "mrc_open$moutput$mfile"
     .align 8
mrc_open$moutput$mfile:
     .int 0xFF
     .global "mrc_close$minput$mport"
     .align 8
mrc_close$minput$mport:
     .int 0xFF
     .global "mrc_close$moutput$mport"
     .align 8
mrc_close$moutput$mport:
     .int 0xFF
     .global "mrc_base$mwrite"
     .align 8
mrc_base$mwrite:
     .int 0xFF
     .global "mrc_write"
     .align 8
mrc_write:
     .int 0xFF
     .global "mrc_display"
     .align 8
mrc_display:
     .int 0xFF
     .global "mrc_integer$m$gchar"
     .align 8
mrc_integer$m$gchar:
     .int 0xFF
     .global "mrc_standard$min"
     .align 8
mrc_standard$min:
     .int 0xFF
     .global "mrc_port$munread"
     .align 8
mrc_port$munread:
     .int 0xFF
     .global "mrc_port$munread$mclear"
     .align 8
mrc_port$munread$mclear:
     .int 0xFF
     .global "mrc_port$munread$mset$b"
     .align 8
mrc_port$munread$mset$b:
     .int 0xFF
     .global "mrc_port$mlast"
     .align 8
mrc_port$mlast:
     .int 0xFF
     .global "mrc_port$mlast$mset$b"
     .align 8
mrc_port$mlast$mset$b:
     .int 0xFF
     .global "mrc_input$mport$q"
     .align 8
mrc_input$mport$q:
     .int 0xFF
     .global "mrc_output$mport$q"
     .align 8
mrc_output$mport$q:
     .int 0xFF
     .global "mrc_open$minput$mfile"
     .align 8
mrc_open$minput$mfile:
     .int 0xFF
     .global "mrc_read$mchar"
     .align 8
mrc_read$mchar:
     .int 0xFF
     .global "mrc_fill$minput$mbuffer"
     .align 8
mrc_fill$minput$mbuffer:
     .int 0xFF
     .global "mrc_unread$mchar"
     .align 8
mrc_unread$mchar:
     .int 0xFF
     .text
     .global base_init
     .align 4
base_init:
# == explicit-begins  ==>
# (let ((interned-symbols (cons (make-symbol "nil" ()) ()))) (lambda () interned-symbols))
# == eliminate-let*  ==>
# (let ((interned-symbols (cons (make-symbol "nil" ()) ()))) (lambda () interned-symbols))
# == uniquify-variables  ==>
# (let ((f6152 (cons (make-symbol "nil" ()) ()))) (lambda () f6152))
# == vectorize-letrec  ==>
# (let ((f6152 (cons (make-symbol "nil" ()) ()))) (lambda () f6152))
# == eliminate-set!  ==>
# (let ((f6152 (cons (make-symbol "nil" ()) ()))) (lambda () (let () f6152)))
# == close-free-variables  ==>
# (let ((f6152 (cons (make-symbol "nil" ()) ()))) (closure () (f6152) (let () f6152)))
# == eliminate-quote  ==>
# (let ((f6152 (cons (make-symbol "nil" ()) ()))) (closure () (f6152) (let () f6152)))
# == eliminate-when/unless  ==>
# (let ((f6152 (cons (make-symbol "nil" ()) ()))) (closure () (f6152) (let () f6152)))
# == eliminate-cond  ==>
# (let ((f6152 (cons (make-symbol "nil" ()) ()))) (closure () (f6152) (let () f6152)))
# == external-symbols  ==>
# (let ((f6152 (cons (make-symbol "nil" ()) ()))) (closure () (f6152) (let () f6152)))
# emit-expr (let ((f6152 (cons (make-symbol "nil" ()) ()))) (closure () (f6152) (let () f6152)))
# emit-let
#  si   = 0
#  env  = ()
#  bindings = ((f6152 (cons (make-symbol "nil" ()) ())))
#  body = (closure () (f6152) (let () f6152))
# emit-expr (cons (make-symbol "nil" ()) ())
# cons arg1=(make-symbol "nil" ()) arg2=()
# emit-expr (make-symbol "nil" ())
# make-symbol arg1="nil" arg2=()
# emit-expr "nil"
# string literal
    jmp _L_37308
    .align 8,0x90
_L_37307 :
    .int 12
    .ascii "nil"
_L_37308:
    movl $_L_37307, %eax
    orl $6, %eax
    movl %eax, 0(%esp)
# emit-expr ()
    movl $63, %eax     # immed ()
    movl %eax, 4(%ebp)
    movl 0(%esp), %eax
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    orl  $3, %eax
    add  $8, %ebp
# make-symbol end
    movl %eax, 0(%esp)
# emit-expr ()
    movl $63, %eax     # immed ()
    movl %eax, 4(%ebp)
    movl 0(%esp), %eax
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    or   $1, %al
    add  $8, %ebp
# cons end
    movl %eax, 0(%esp)  # stack save
# emit-expr (closure () (f6152) (let () f6152))
# emit-closure
# si = -4
# env = ((f6152 . 0))
# expr = (closure () (f6152) (let () f6152))
    movl $_L_37309, 0(%ebp)  # closure label
# emit-variable-ref
# env=((f6152 . 0))
# var=f6152
    movl 0(%esp), %eax  # stack load f6152
# end emit-variable-ref
   movl  %eax, 4(%ebp)  # f6152
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $8, %ebp     # bump ebp
    jmp _L_37310            # jump around closure body
_L_37309:
# check argument count
    cmp $0,%eax
    je _L_37311
# invoke error handler eh_argcount
    .extern mrc_eh$uargcount
    movl mrc_eh$uargcount, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_37311:
# emit-tail-expr
# si=-8
# env=((f6152 . 4) (f6152 . 0))
# expr=(let () f6152)
# emit-tail-let
#  si   = -8
#  env  = ((f6152 . 4) (f6152 . 0))
#  bindings = ()
#  body = f6152
# emit-tail-expr
# si=-8
# env=((f6152 . 4) (f6152 . 0))
# expr=f6152
# emit-tail-variable-ref
# emit-variable-ref
# env=((f6152 . 4) (f6152 . 0))
# var=f6152
    movl 2(%edi), %eax  # frame load f6152
# end emit-variable-ref
    ret
# end emit-tail-variable ref
    .align 4,0x90
_L_37310:
     movl %eax, mrc_symbols
# == explicit-begins  ==>
# (letrec ((slen= (lambda (s1 s2) (fx= (string-length s1) (string-length s2)))) (si= (lambda (s1 s2 i) (char=? (string-ref s1 i) (string-ref s2 i)))) (si<n= (lambda (s1 s2 i n) (if (fx= i n) #t (if (si= s1 s2 i) (si<n= s1 s2 (fx+ i 1) n) #f)))) (ss= (lambda (s1 s2) (if (slen= s1 s2) (si<n= s1 s2 0 (string-length s1)) #f)))) ss=)
# == eliminate-let*  ==>
# (letrec ((slen= (lambda (s1 s2) (fx= (string-length s1) (string-length s2)))) (si= (lambda (s1 s2 i) (char=? (string-ref s1 i) (string-ref s2 i)))) (si<n= (lambda (s1 s2 i n) (if (fx= i n) #t (if (si= s1 s2 i) (si<n= s1 s2 (fx+ i 1) n) #f)))) (ss= (lambda (s1 s2) (if (slen= s1 s2) (si<n= s1 s2 0 (string-length s1)) #f)))) ss=)
# == uniquify-variables  ==>
# (letrec ((f6156 (lambda (f6177 f6178) (fx= (string-length f6177) (string-length f6178)))) (f6155 (lambda (f6174 f6175 f6176) (char=? (string-ref f6174 f6176) (string-ref f6175 f6176)))) (f6154 (lambda (f6170 f6171 f6172 f6173) (if (fx= f6172 f6173) #t (if (f6155 f6170 f6171 f6172) (f6154 f6170 f6171 (fx+ f6172 1) f6173) #f)))) (f6153 (lambda (f6168 f6169) (if (f6156 f6168 f6169) (f6154 f6168 f6169 0 (string-length f6168)) #f)))) f6153)
# == vectorize-letrec  ==>
# (let ((f6156 (make-vector 1)) (f6155 (make-vector 1)) (f6154 (make-vector 1)) (f6153 (make-vector 1))) (begin (begin (vector-set! f6156 0 (lambda (f6177 f6178) (fx= (string-length f6177) (string-length f6178)))) (vector-set! f6155 0 (lambda (f6174 f6175 f6176) (char=? (string-ref f6174 f6176) (string-ref f6175 f6176)))) (vector-set! f6154 0 (lambda (f6170 f6171 f6172 f6173) (if (fx= f6172 f6173) #t (if ((vector-ref f6155 0) f6170 f6171 f6172) ((vector-ref f6154 0) f6170 f6171 (fx+ f6172 1) f6173) #f)))) (vector-set! f6153 0 (lambda (f6168 f6169) (if ((vector-ref f6156 0) f6168 f6169) ((vector-ref f6154 0) f6168 f6169 0 (string-length f6168)) #f)))) (vector-ref f6153 0)))
# == eliminate-set!  ==>
# (let ((f6156 (make-vector 1)) (f6155 (make-vector 1)) (f6154 (make-vector 1)) (f6153 (make-vector 1))) (begin (begin (vector-set! f6156 0 (lambda (f6177 f6178) (let ((f6177 f6177) (f6178 f6178)) (fx= (string-length f6177) (string-length f6178))))) (vector-set! f6155 0 (lambda (f6174 f6175 f6176) (let ((f6174 f6174) (f6175 f6175) (f6176 f6176)) (char=? (string-ref f6174 f6176) (string-ref f6175 f6176))))) (vector-set! f6154 0 (lambda (f6170 f6171 f6172 f6173) (let ((f6170 f6170) (f6171 f6171) (f6172 f6172) (f6173 f6173)) (if (fx= f6172 f6173) #t (if ((vector-ref f6155 0) f6170 f6171 f6172) ((vector-ref f6154 0) f6170 f6171 (fx+ f6172 1) f6173) #f))))) (vector-set! f6153 0 (lambda (f6168 f6169) (let ((f6168 f6168) (f6169 f6169)) (if ((vector-ref f6156 0) f6168 f6169) ((vector-ref f6154 0) f6168 f6169 0 (string-length f6168)) #f))))) (vector-ref f6153 0)))
# == close-free-variables  ==>
# (let ((f6156 (make-vector 1)) (f6155 (make-vector 1)) (f6154 (make-vector 1)) (f6153 (make-vector 1))) (begin (begin (vector-set! f6156 0 (closure (f6177 f6178) () (let ((f6177 f6177) (f6178 f6178)) (fx= (string-length f6177) (string-length f6178))))) (vector-set! f6155 0 (closure (f6174 f6175 f6176) () (let ((f6174 f6174) (f6175 f6175) (f6176 f6176)) (char=? (string-ref f6174 f6176) (string-ref f6175 f6176))))) (vector-set! f6154 0 (closure (f6170 f6171 f6172 f6173) (f6155 f6154) (let ((f6170 f6170) (f6171 f6171) (f6172 f6172) (f6173 f6173)) (if (fx= f6172 f6173) #t (if ((vector-ref f6155 0) f6170 f6171 f6172) ((vector-ref f6154 0) f6170 f6171 (fx+ f6172 1) f6173) #f))))) (vector-set! f6153 0 (closure (f6168 f6169) (f6156 f6154) (let ((f6168 f6168) (f6169 f6169)) (if ((vector-ref f6156 0) f6168 f6169) ((vector-ref f6154 0) f6168 f6169 0 (string-length f6168)) #f))))) (vector-ref f6153 0)))
# == eliminate-quote  ==>
# (let ((f6156 (make-vector 1)) (f6155 (make-vector 1)) (f6154 (make-vector 1)) (f6153 (make-vector 1))) (begin (begin (vector-set! f6156 0 (closure (f6177 f6178) () (let ((f6177 f6177) (f6178 f6178)) (fx= (string-length f6177) (string-length f6178))))) (vector-set! f6155 0 (closure (f6174 f6175 f6176) () (let ((f6174 f6174) (f6175 f6175) (f6176 f6176)) (char=? (string-ref f6174 f6176) (string-ref f6175 f6176))))) (vector-set! f6154 0 (closure (f6170 f6171 f6172 f6173) (f6155 f6154) (let ((f6170 f6170) (f6171 f6171) (f6172 f6172) (f6173 f6173)) (if (fx= f6172 f6173) #t (if ((vector-ref f6155 0) f6170 f6171 f6172) ((vector-ref f6154 0) f6170 f6171 (fx+ f6172 1) f6173) #f))))) (vector-set! f6153 0 (closure (f6168 f6169) (f6156 f6154) (let ((f6168 f6168) (f6169 f6169)) (if ((vector-ref f6156 0) f6168 f6169) ((vector-ref f6154 0) f6168 f6169 0 (string-length f6168)) #f))))) (vector-ref f6153 0)))
# == eliminate-when/unless  ==>
# (let ((f6156 (make-vector 1)) (f6155 (make-vector 1)) (f6154 (make-vector 1)) (f6153 (make-vector 1))) (begin (begin (vector-set! f6156 0 (closure (f6177 f6178) () (let ((f6177 f6177) (f6178 f6178)) (fx= (string-length f6177) (string-length f6178))))) (vector-set! f6155 0 (closure (f6174 f6175 f6176) () (let ((f6174 f6174) (f6175 f6175) (f6176 f6176)) (char=? (string-ref f6174 f6176) (string-ref f6175 f6176))))) (vector-set! f6154 0 (closure (f6170 f6171 f6172 f6173) (f6155 f6154) (let ((f6170 f6170) (f6171 f6171) (f6172 f6172) (f6173 f6173)) (if (fx= f6172 f6173) #t (if ((vector-ref f6155 0) f6170 f6171 f6172) ((vector-ref f6154 0) f6170 f6171 (fx+ f6172 1) f6173) #f))))) (vector-set! f6153 0 (closure (f6168 f6169) (f6156 f6154) (let ((f6168 f6168) (f6169 f6169)) (if ((vector-ref f6156 0) f6168 f6169) ((vector-ref f6154 0) f6168 f6169 0 (string-length f6168)) #f))))) (vector-ref f6153 0)))
# == eliminate-cond  ==>
# (let ((f6156 (make-vector 1)) (f6155 (make-vector 1)) (f6154 (make-vector 1)) (f6153 (make-vector 1))) (begin (begin (vector-set! f6156 0 (closure (f6177 f6178) () (let ((f6177 f6177) (f6178 f6178)) (fx= (string-length f6177) (string-length f6178))))) (vector-set! f6155 0 (closure (f6174 f6175 f6176) () (let ((f6174 f6174) (f6175 f6175) (f6176 f6176)) (char=? (string-ref f6174 f6176) (string-ref f6175 f6176))))) (vector-set! f6154 0 (closure (f6170 f6171 f6172 f6173) (f6155 f6154) (let ((f6170 f6170) (f6171 f6171) (f6172 f6172) (f6173 f6173)) (if (fx= f6172 f6173) #t (if ((vector-ref f6155 0) f6170 f6171 f6172) ((vector-ref f6154 0) f6170 f6171 (fx+ f6172 1) f6173) #f))))) (vector-set! f6153 0 (closure (f6168 f6169) (f6156 f6154) (let ((f6168 f6168) (f6169 f6169)) (if ((vector-ref f6156 0) f6168 f6169) ((vector-ref f6154 0) f6168 f6169 0 (string-length f6168)) #f))))) (vector-ref f6153 0)))
# == external-symbols  ==>
# (let ((f6156 (make-vector 1)) (f6155 (make-vector 1)) (f6154 (make-vector 1)) (f6153 (make-vector 1))) (begin (begin (vector-set! f6156 0 (closure (f6177 f6178) () (let ((f6177 f6177) (f6178 f6178)) (fx= (string-length f6177) (string-length f6178))))) (vector-set! f6155 0 (closure (f6174 f6175 f6176) () (let ((f6174 f6174) (f6175 f6175) (f6176 f6176)) (char=? (string-ref f6174 f6176) (string-ref f6175 f6176))))) (vector-set! f6154 0 (closure (f6170 f6171 f6172 f6173) (f6155 f6154) (let ((f6170 f6170) (f6171 f6171) (f6172 f6172) (f6173 f6173)) (if (fx= f6172 f6173) #t (if ((vector-ref f6155 0) f6170 f6171 f6172) ((vector-ref f6154 0) f6170 f6171 (fx+ f6172 1) f6173) #f))))) (vector-set! f6153 0 (closure (f6168 f6169) (f6156 f6154) (let ((f6168 f6168) (f6169 f6169)) (if ((vector-ref f6156 0) f6168 f6169) ((vector-ref f6154 0) f6168 f6169 0 (string-length f6168)) #f))))) (vector-ref f6153 0)))
# emit-expr (let ((f6156 (make-vector 1)) (f6155 (make-vector 1)) (f6154 (make-vector 1)) (f6153 (make-vector 1))) (begin (begin (vector-set! f6156 0 (closure (f6177 f6178) () (let ((f6177 f6177) (f6178 f6178)) (fx= (string-length f6177) (string-length f6178))))) (vector-set! f6155 0 (closure (f6174 f6175 f6176) () (let ((f6174 f6174) (f6175 f6175) (f6176 f6176)) (char=? (string-ref f6174 f6176) (string-ref f6175 f6176))))) (vector-set! f6154 0 (closure (f6170 f6171 f6172 f6173) (f6155 f6154) (let ((f6170 f6170) (f6171 f6171) (f6172 f6172) (f6173 f6173)) (if (fx= f6172 f6173) #t (if ((vector-ref f6155 0) f6170 f6171 f6172) ((vector-ref f6154 0) f6170 f6171 (fx+ f6172 1) f6173) #f))))) (vector-set! f6153 0 (closure (f6168 f6169) (f6156 f6154) (let ((f6168 f6168) (f6169 f6169)) (if ((vector-ref f6156 0) f6168 f6169) ((vector-ref f6154 0) f6168 f6169 0 (string-length f6168)) #f))))) (vector-ref f6153 0)))
# emit-let
#  si   = 0
#  env  = ()
#  bindings = ((f6156 (make-vector 1)) (f6155 (make-vector 1)) (f6154 (make-vector 1)) (f6153 (make-vector 1)))
#  body = (begin (begin (vector-set! f6156 0 (closure (f6177 f6178) () (let ((f6177 f6177) (f6178 f6178)) (fx= (string-length f6177) (string-length f6178))))) (vector-set! f6155 0 (closure (f6174 f6175 f6176) () (let ((f6174 f6174) (f6175 f6175) (f6176 f6176)) (char=? (string-ref f6174 f6176) (string-ref f6175 f6176))))) (vector-set! f6154 0 (closure (f6170 f6171 f6172 f6173) (f6155 f6154) (let ((f6170 f6170) (f6171 f6171) (f6172 f6172) (f6173 f6173)) (if (fx= f6172 f6173) #t (if ((vector-ref f6155 0) f6170 f6171 f6172) ((vector-ref f6154 0) f6170 f6171 (fx+ f6172 1) f6173) #f))))) (vector-set! f6153 0 (closure (f6168 f6169) (f6156 f6154) (let ((f6168 f6168) (f6169 f6169)) (if ((vector-ref f6156 0) f6168 f6169) ((vector-ref f6154 0) f6168 f6169 0 (string-length f6168)) #f))))) (vector-ref f6153 0))
# emit-expr (make-vector 1)
# make-vector 1
# emit-expr 1
    movl $4, %eax     # immed 1
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_37312"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_37312:
# check the argument is a fixnum >= 0
    cmp $0,%eax
    jge _L_37313
# invoke error handler eh_length
    .extern mrc_eh$ulength
    movl mrc_eh$ulength, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_37313:
    movl %eax, %esi
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    orl  $5, %eax
    addl $4, %esi
    addl $4, %esi
    andl $-8, %esi
    addl %esi, %ebp
    movl %eax, 0(%esp)  # stack save
# emit-expr (make-vector 1)
# make-vector 1
# emit-expr 1
    movl $4, %eax     # immed 1
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_37314"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_37314:
# check the argument is a fixnum >= 0
    cmp $0,%eax
    jge _L_37315
# invoke error handler eh_length
    .extern mrc_eh$ulength
    movl mrc_eh$ulength, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_37315:
    movl %eax, %esi
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    orl  $5, %eax
    addl $4, %esi
    addl $4, %esi
    andl $-8, %esi
    addl %esi, %ebp
    movl %eax, -4(%esp)  # stack save
# emit-expr (make-vector 1)
# make-vector 1
# emit-expr 1
    movl $4, %eax     # immed 1
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_37316"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_37316:
# check the argument is a fixnum >= 0
    cmp $0,%eax
    jge _L_37317
# invoke error handler eh_length
    .extern mrc_eh$ulength
    movl mrc_eh$ulength, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_37317:
    movl %eax, %esi
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    orl  $5, %eax
    addl $4, %esi
    addl $4, %esi
    andl $-8, %esi
    addl %esi, %ebp
    movl %eax, -8(%esp)  # stack save
# emit-expr (make-vector 1)
# make-vector 1
# emit-expr 1
    movl $4, %eax     # immed 1
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_37318"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_37318:
# check the argument is a fixnum >= 0
    cmp $0,%eax
    jge _L_37319
# invoke error handler eh_length
    .extern mrc_eh$ulength
    movl mrc_eh$ulength, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_37319:
    movl %eax, %esi
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    orl  $5, %eax
    addl $4, %esi
    addl $4, %esi
    andl $-8, %esi
    addl %esi, %ebp
    movl %eax, -12(%esp)  # stack save
# emit-expr (begin (begin (vector-set! f6156 0 (closure (f6177 f6178) () (let ((f6177 f6177) (f6178 f6178)) (fx= (string-length f6177) (string-length f6178))))) (vector-set! f6155 0 (closure (f6174 f6175 f6176) () (let ((f6174 f6174) (f6175 f6175) (f6176 f6176)) (char=? (string-ref f6174 f6176) (string-ref f6175 f6176))))) (vector-set! f6154 0 (closure (f6170 f6171 f6172 f6173) (f6155 f6154) (let ((f6170 f6170) (f6171 f6171) (f6172 f6172) (f6173 f6173)) (if (fx= f6172 f6173) #t (if ((vector-ref f6155 0) f6170 f6171 f6172) ((vector-ref f6154 0) f6170 f6171 (fx+ f6172 1) f6173) #f))))) (vector-set! f6153 0 (closure (f6168 f6169) (f6156 f6154) (let ((f6168 f6168) (f6169 f6169)) (if ((vector-ref f6156 0) f6168 f6169) ((vector-ref f6154 0) f6168 f6169 0 (string-length f6168)) #f))))) (vector-ref f6153 0))
# emit-begin
#   expr=(begin (begin (vector-set! f6156 0 (closure (f6177 f6178) () (let ((f6177 f6177) (f6178 f6178)) (fx= (string-length f6177) (string-length f6178))))) (vector-set! f6155 0 (closure (f6174 f6175 f6176) () (let ((f6174 f6174) (f6175 f6175) (f6176 f6176)) (char=? (string-ref f6174 f6176) (string-ref f6175 f6176))))) (vector-set! f6154 0 (closure (f6170 f6171 f6172 f6173) (f6155 f6154) (let ((f6170 f6170) (f6171 f6171) (f6172 f6172) (f6173 f6173)) (if (fx= f6172 f6173) #t (if ((vector-ref f6155 0) f6170 f6171 f6172) ((vector-ref f6154 0) f6170 f6171 (fx+ f6172 1) f6173) #f))))) (vector-set! f6153 0 (closure (f6168 f6169) (f6156 f6154) (let ((f6168 f6168) (f6169 f6169)) (if ((vector-ref f6156 0) f6168 f6169) ((vector-ref f6154 0) f6168 f6169 0 (string-length f6168)) #f))))) (vector-ref f6153 0))
#   env=((f6153 . -12) (f6154 . -8) (f6155 . -4) (f6156 . 0))
# emit-expr (begin (vector-set! f6156 0 (closure (f6177 f6178) () (let ((f6177 f6177) (f6178 f6178)) (fx= (string-length f6177) (string-length f6178))))) (vector-set! f6155 0 (closure (f6174 f6175 f6176) () (let ((f6174 f6174) (f6175 f6175) (f6176 f6176)) (char=? (string-ref f6174 f6176) (string-ref f6175 f6176))))) (vector-set! f6154 0 (closure (f6170 f6171 f6172 f6173) (f6155 f6154) (let ((f6170 f6170) (f6171 f6171) (f6172 f6172) (f6173 f6173)) (if (fx= f6172 f6173) #t (if ((vector-ref f6155 0) f6170 f6171 f6172) ((vector-ref f6154 0) f6170 f6171 (fx+ f6172 1) f6173) #f))))) (vector-set! f6153 0 (closure (f6168 f6169) (f6156 f6154) (let ((f6168 f6168) (f6169 f6169)) (if ((vector-ref f6156 0) f6168 f6169) ((vector-ref f6154 0) f6168 f6169 0 (string-length f6168)) #f)))))
# emit-begin
#   expr=(begin (vector-set! f6156 0 (closure (f6177 f6178) () (let ((f6177 f6177) (f6178 f6178)) (fx= (string-length f6177) (string-length f6178))))) (vector-set! f6155 0 (closure (f6174 f6175 f6176) () (let ((f6174 f6174) (f6175 f6175) (f6176 f6176)) (char=? (string-ref f6174 f6176) (string-ref f6175 f6176))))) (vector-set! f6154 0 (closure (f6170 f6171 f6172 f6173) (f6155 f6154) (let ((f6170 f6170) (f6171 f6171) (f6172 f6172) (f6173 f6173)) (if (fx= f6172 f6173) #t (if ((vector-ref f6155 0) f6170 f6171 f6172) ((vector-ref f6154 0) f6170 f6171 (fx+ f6172 1) f6173) #f))))) (vector-set! f6153 0 (closure (f6168 f6169) (f6156 f6154) (let ((f6168 f6168) (f6169 f6169)) (if ((vector-ref f6156 0) f6168 f6169) ((vector-ref f6154 0) f6168 f6169 0 (string-length f6168)) #f)))))
#   env=((f6153 . -12) (f6154 . -8) (f6155 . -4) (f6156 . 0))
# emit-expr (vector-set! f6156 0 (closure (f6177 f6178) () (let ((f6177 f6177) (f6178 f6178)) (fx= (string-length f6177) (string-length f6178)))))
# emit-expr f6156
# emit-variable-ref
# env=((f6153 . -12) (f6154 . -8) (f6155 . -4) (f6156 . 0))
# var=f6156
    movl 0(%esp), %eax  # stack load f6156
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_37320
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_37320:
    movl %eax, -16(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_37321"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_37321:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_37323
    cmp  $0,%eax
    jge _L_37322
_L_37323:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_37322:
    movl %eax, -20(%esp)
# emit-expr (closure (f6177 f6178) () (let ((f6177 f6177) (f6178 f6178)) (fx= (string-length f6177) (string-length f6178))))
# emit-closure
# si = -24
# env = ((f6153 . -12) (f6154 . -8) (f6155 . -4) (f6156 . 0))
# expr = (closure (f6177 f6178) () (let ((f6177 f6177) (f6178 f6178)) (fx= (string-length f6177) (string-length f6178))))
    movl $_L_37324, 0(%ebp)  # closure label
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $8, %ebp     # bump ebp
    jmp _L_37325            # jump around closure body
_L_37324:
# check argument count
    cmp $8,%eax
    je _L_37326
# invoke error handler eh_argcount
    .extern mrc_eh$uargcount
    movl mrc_eh$uargcount, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_37326:
# emit-tail-expr
# si=-16
# env=((f6178 . -12) (f6177 . -8) (f6153 . -12) (f6154 . -8) (f6155 . -4) (f6156 . 0))
# expr=(let ((f6177 f6177) (f6178 f6178)) (fx= (string-length f6177) (string-length f6178)))
# emit-tail-let
#  si   = -16
#  env  = ((f6178 . -12) (f6177 . -8) (f6153 . -12) (f6154 . -8) (f6155 . -4) (f6156 . 0))
#  bindings = ((f6177 f6177) (f6178 f6178))
#  body = (fx= (string-length f6177) (string-length f6178))
# emit-expr f6177
# emit-variable-ref
# env=((f6178 . -12) (f6177 . -8) (f6153 . -12) (f6154 . -8) (f6155 . -4) (f6156 . 0))
# var=f6177
    movl -8(%esp), %eax  # stack load f6177
# end emit-variable-ref
    movl %eax, -16(%esp)  # stack save
# emit-expr f6178
# emit-variable-ref
# env=((f6178 . -12) (f6177 . -8) (f6153 . -12) (f6154 . -8) (f6155 . -4) (f6156 . 0))
# var=f6178
    movl -12(%esp), %eax  # stack load f6178
# end emit-variable-ref
    movl %eax, -20(%esp)  # stack save
# emit-tail-expr
# si=-24
# env=((f6178 . -20) (f6177 . -16) (f6178 . -12) (f6177 . -8) (f6153 . -12) (f6154 . -8) (f6155 . -4) (f6156 . 0))
# expr=(fx= (string-length f6177) (string-length f6178))
# tail primcall
# emit-expr (string-length f6178)
# emit-expr f6178
# emit-variable-ref
# env=((f6178 . -20) (f6177 . -16) (f6178 . -12) (f6177 . -8) (f6153 . -12) (f6154 . -8) (f6155 . -4) (f6156 . 0))
# var=f6178
    movl -20(%esp), %eax  # stack load f6178
# end emit-variable-ref
# check the argument is a string
    movl %eax,%ebx
    and $7, %bl
    cmp $6, %bl
    je _L_37327
# invoke error handler eh_string
    .extern mrc_eh$ustring
    movl mrc_eh$ustring, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $160,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_37327:
    movl -6(%eax), %eax
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_37328"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $68,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_37328:
    movl %eax, -24(%esp)
# emit-expr (string-length f6177)
# emit-expr f6177
# emit-variable-ref
# env=((f6178 . -20) (f6177 . -16) (f6178 . -12) (f6177 . -8) (f6153 . -12) (f6154 . -8) (f6155 . -4) (f6156 . 0))
# var=f6177
    movl -16(%esp), %eax  # stack load f6177
# end emit-variable-ref
# check the argument is a string
    movl %eax,%ebx
    and $7, %bl
    cmp $6, %bl
    je _L_37329
# invoke error handler eh_string
    .extern mrc_eh$ustring
    movl mrc_eh$ustring, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $160,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_37329:
    movl -6(%eax), %eax
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_37330"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $68,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_37330:
    cmp -24(%esp), %eax
    sete %al
    movzbl %al, %eax
    sal $6, %al
    or $47, %al
#return from tail (fx= (string-length f6177) (string-length f6178))
    ret
    .align 4,0x90
_L_37325:
    movl -16(%esp), %ebx
    movl -20(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin (vector-set! f6155 0 (closure (f6174 f6175 f6176) () (let ((f6174 f6174) (f6175 f6175) (f6176 f6176)) (char=? (string-ref f6174 f6176) (string-ref f6175 f6176))))) (vector-set! f6154 0 (closure (f6170 f6171 f6172 f6173) (f6155 f6154) (let ((f6170 f6170) (f6171 f6171) (f6172 f6172) (f6173 f6173)) (if (fx= f6172 f6173) #t (if ((vector-ref f6155 0) f6170 f6171 f6172) ((vector-ref f6154 0) f6170 f6171 (fx+ f6172 1) f6173) #f))))) (vector-set! f6153 0 (closure (f6168 f6169) (f6156 f6154) (let ((f6168 f6168) (f6169 f6169)) (if ((vector-ref f6156 0) f6168 f6169) ((vector-ref f6154 0) f6168 f6169 0 (string-length f6168)) #f)))))
# emit-begin
#   expr=(begin (vector-set! f6155 0 (closure (f6174 f6175 f6176) () (let ((f6174 f6174) (f6175 f6175) (f6176 f6176)) (char=? (string-ref f6174 f6176) (string-ref f6175 f6176))))) (vector-set! f6154 0 (closure (f6170 f6171 f6172 f6173) (f6155 f6154) (let ((f6170 f6170) (f6171 f6171) (f6172 f6172) (f6173 f6173)) (if (fx= f6172 f6173) #t (if ((vector-ref f6155 0) f6170 f6171 f6172) ((vector-ref f6154 0) f6170 f6171 (fx+ f6172 1) f6173) #f))))) (vector-set! f6153 0 (closure (f6168 f6169) (f6156 f6154) (let ((f6168 f6168) (f6169 f6169)) (if ((vector-ref f6156 0) f6168 f6169) ((vector-ref f6154 0) f6168 f6169 0 (string-length f6168)) #f)))))
#   env=((f6153 . -12) (f6154 . -8) (f6155 . -4) (f6156 . 0))
# emit-expr (vector-set! f6155 0 (closure (f6174 f6175 f6176) () (let ((f6174 f6174) (f6175 f6175) (f6176 f6176)) (char=? (string-ref f6174 f6176) (string-ref f6175 f6176)))))
# emit-expr f6155
# emit-variable-ref
# env=((f6153 . -12) (f6154 . -8) (f6155 . -4) (f6156 . 0))
# var=f6155
    movl -4(%esp), %eax  # stack load f6155
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_37331
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_37331:
    movl %eax, -16(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_37332"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_37332:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_37334
    cmp  $0,%eax
    jge _L_37333
_L_37334:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_37333:
    movl %eax, -20(%esp)
# emit-expr (closure (f6174 f6175 f6176) () (let ((f6174 f6174) (f6175 f6175) (f6176 f6176)) (char=? (string-ref f6174 f6176) (string-ref f6175 f6176))))
# emit-closure
# si = -24
# env = ((f6153 . -12) (f6154 . -8) (f6155 . -4) (f6156 . 0))
# expr = (closure (f6174 f6175 f6176) () (let ((f6174 f6174) (f6175 f6175) (f6176 f6176)) (char=? (string-ref f6174 f6176) (string-ref f6175 f6176))))
    movl $_L_37335, 0(%ebp)  # closure label
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $8, %ebp     # bump ebp
    jmp _L_37336            # jump around closure body
_L_37335:
# check argument count
    cmp $12,%eax
    je _L_37337
# invoke error handler eh_argcount
    .extern mrc_eh$uargcount
    movl mrc_eh$uargcount, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_37337:
# emit-tail-expr
# si=-20
# env=((f6176 . -16) (f6175 . -12) (f6174 . -8) (f6153 . -12) (f6154 . -8) (f6155 . -4) (f6156 . 0))
# expr=(let ((f6174 f6174) (f6175 f6175) (f6176 f6176)) (char=? (string-ref f6174 f6176) (string-ref f6175 f6176)))
# emit-tail-let
#  si   = -20
#  env  = ((f6176 . -16) (f6175 . -12) (f6174 . -8) (f6153 . -12) (f6154 . -8) (f6155 . -4) (f6156 . 0))
#  bindings = ((f6174 f6174) (f6175 f6175) (f6176 f6176))
#  body = (char=? (string-ref f6174 f6176) (string-ref f6175 f6176))
# emit-expr f6174
# emit-variable-ref
# env=((f6176 . -16) (f6175 . -12) (f6174 . -8) (f6153 . -12) (f6154 . -8) (f6155 . -4) (f6156 . 0))
# var=f6174
    movl -8(%esp), %eax  # stack load f6174
# end emit-variable-ref
    movl %eax, -20(%esp)  # stack save
# emit-expr f6175
# emit-variable-ref
# env=((f6176 . -16) (f6175 . -12) (f6174 . -8) (f6153 . -12) (f6154 . -8) (f6155 . -4) (f6156 . 0))
# var=f6175
    movl -12(%esp), %eax  # stack load f6175
# end emit-variable-ref
    movl %eax, -24(%esp)  # stack save
# emit-expr f6176
# emit-variable-ref
# env=((f6176 . -16) (f6175 . -12) (f6174 . -8) (f6153 . -12) (f6154 . -8) (f6155 . -4) (f6156 . 0))
# var=f6176
    movl -16(%esp), %eax  # stack load f6176
# end emit-variable-ref
    movl %eax, -28(%esp)  # stack save
# emit-tail-expr
# si=-32
# env=((f6176 . -28) (f6175 . -24) (f6174 . -20) (f6176 . -16) (f6175 . -12) (f6174 . -8) (f6153 . -12) (f6154 . -8) (f6155 . -4) (f6156 . 0))
# expr=(char=? (string-ref f6174 f6176) (string-ref f6175 f6176))
# tail primcall
# char= c1=(string-ref f6174 f6176) c2=(string-ref f6175 f6176)
# emit-expr (string-ref f6174 f6176)
# emit-expr f6174
# emit-variable-ref
# env=((f6176 . -28) (f6175 . -24) (f6174 . -20) (f6176 . -16) (f6175 . -12) (f6174 . -8) (f6153 . -12) (f6154 . -8) (f6155 . -4) (f6156 . 0))
# var=f6174
    movl -20(%esp), %eax  # stack load f6174
# end emit-variable-ref
# check the argument is a string
    movl %eax,%ebx
    and $7, %bl
    cmp $6, %bl
    je _L_37338
# invoke error handler eh_string
    .extern mrc_eh$ustring
    movl mrc_eh$ustring, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $164,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_37338:
    movl %eax, -32(%esp)
# emit-expr f6176
# emit-variable-ref
# env=((f6176 . -28) (f6175 . -24) (f6174 . -20) (f6176 . -16) (f6175 . -12) (f6174 . -8) (f6153 . -12) (f6154 . -8) (f6155 . -4) (f6156 . 0))
# var=f6176
    movl -28(%esp), %eax  # stack load f6176
# end emit-variable-ref
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_37339"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $164,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_37339:
# check bounds on string index
    movl -32(%esp), %ebx
    cmp  %eax,-6(%ebx) 
    jle _L_37341
    cmp  $0,%eax
    jge _L_37340
_L_37341:
# invoke error handler eh_string_index
    .extern mrc_eh$ustring$uindex
    movl mrc_eh$ustring$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $164,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_37340:
    sar $2, %eax
    movl -32(%esp), %esi
    movl -2(%eax,%esi), %eax
    sal $8, %eax
    or  $15, %eax
# check the argument is a char
    movl %eax,%ebx
    and $255, %bl
    cmp $15, %bl
    je "_L_37342"
# invoke error handler eh_character
    .extern mrc_eh$ucharacter
    movl mrc_eh$ucharacter, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $40,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_37342:
    movb %ah, -32(%esp)
# emit-expr (string-ref f6175 f6176)
# emit-expr f6175
# emit-variable-ref
# env=((f6176 . -28) (f6175 . -24) (f6174 . -20) (f6176 . -16) (f6175 . -12) (f6174 . -8) (f6153 . -12) (f6154 . -8) (f6155 . -4) (f6156 . 0))
# var=f6175
    movl -24(%esp), %eax  # stack load f6175
# end emit-variable-ref
# check the argument is a string
    movl %eax,%ebx
    and $7, %bl
    cmp $6, %bl
    je _L_37343
# invoke error handler eh_string
    .extern mrc_eh$ustring
    movl mrc_eh$ustring, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $164,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_37343:
    movl %eax, -36(%esp)
# emit-expr f6176
# emit-variable-ref
# env=((f6176 . -28) (f6175 . -24) (f6174 . -20) (f6176 . -16) (f6175 . -12) (f6174 . -8) (f6153 . -12) (f6154 . -8) (f6155 . -4) (f6156 . 0))
# var=f6176
    movl -28(%esp), %eax  # stack load f6176
# end emit-variable-ref
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_37344"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $164,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_37344:
# check bounds on string index
    movl -36(%esp), %ebx
    cmp  %eax,-6(%ebx) 
    jle _L_37346
    cmp  $0,%eax
    jge _L_37345
_L_37346:
# invoke error handler eh_string_index
    .extern mrc_eh$ustring$uindex
    movl mrc_eh$ustring$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $164,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_37345:
    sar $2, %eax
    movl -36(%esp), %esi
    movl -2(%eax,%esi), %eax
    sal $8, %eax
    or  $15, %eax
# check the argument is a char
    movl %eax,%ebx
    and $255, %bl
    cmp $15, %bl
    je "_L_37347"
# invoke error handler eh_character
    .extern mrc_eh$ucharacter
    movl mrc_eh$ucharacter, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $40,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_37347:
    cmp %ah, -32(%esp)
    sete %al
    movzbl %al, %eax
    sal $6, %al
    or $47, %al
#return from tail (char=? (string-ref f6174 f6176) (string-ref f6175 f6176))
    ret
    .align 4,0x90
_L_37336:
    movl -16(%esp), %ebx
    movl -20(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin (vector-set! f6154 0 (closure (f6170 f6171 f6172 f6173) (f6155 f6154) (let ((f6170 f6170) (f6171 f6171) (f6172 f6172) (f6173 f6173)) (if (fx= f6172 f6173) #t (if ((vector-ref f6155 0) f6170 f6171 f6172) ((vector-ref f6154 0) f6170 f6171 (fx+ f6172 1) f6173) #f))))) (vector-set! f6153 0 (closure (f6168 f6169) (f6156 f6154) (let ((f6168 f6168) (f6169 f6169)) (if ((vector-ref f6156 0) f6168 f6169) ((vector-ref f6154 0) f6168 f6169 0 (string-length f6168)) #f)))))
# emit-begin
#   expr=(begin (vector-set! f6154 0 (closure (f6170 f6171 f6172 f6173) (f6155 f6154) (let ((f6170 f6170) (f6171 f6171) (f6172 f6172) (f6173 f6173)) (if (fx= f6172 f6173) #t (if ((vector-ref f6155 0) f6170 f6171 f6172) ((vector-ref f6154 0) f6170 f6171 (fx+ f6172 1) f6173) #f))))) (vector-set! f6153 0 (closure (f6168 f6169) (f6156 f6154) (let ((f6168 f6168) (f6169 f6169)) (if ((vector-ref f6156 0) f6168 f6169) ((vector-ref f6154 0) f6168 f6169 0 (string-length f6168)) #f)))))
#   env=((f6153 . -12) (f6154 . -8) (f6155 . -4) (f6156 . 0))
# emit-expr (vector-set! f6154 0 (closure (f6170 f6171 f6172 f6173) (f6155 f6154) (let ((f6170 f6170) (f6171 f6171) (f6172 f6172) (f6173 f6173)) (if (fx= f6172 f6173) #t (if ((vector-ref f6155 0) f6170 f6171 f6172) ((vector-ref f6154 0) f6170 f6171 (fx+ f6172 1) f6173) #f)))))
# emit-expr f6154
# emit-variable-ref
# env=((f6153 . -12) (f6154 . -8) (f6155 . -4) (f6156 . 0))
# var=f6154
    movl -8(%esp), %eax  # stack load f6154
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_37348
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_37348:
    movl %eax, -16(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_37349"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_37349:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_37351
    cmp  $0,%eax
    jge _L_37350
_L_37351:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_37350:
    movl %eax, -20(%esp)
# emit-expr (closure (f6170 f6171 f6172 f6173) (f6155 f6154) (let ((f6170 f6170) (f6171 f6171) (f6172 f6172) (f6173 f6173)) (if (fx= f6172 f6173) #t (if ((vector-ref f6155 0) f6170 f6171 f6172) ((vector-ref f6154 0) f6170 f6171 (fx+ f6172 1) f6173) #f))))
# emit-closure
# si = -24
# env = ((f6153 . -12) (f6154 . -8) (f6155 . -4) (f6156 . 0))
# expr = (closure (f6170 f6171 f6172 f6173) (f6155 f6154) (let ((f6170 f6170) (f6171 f6171) (f6172 f6172) (f6173 f6173)) (if (fx= f6172 f6173) #t (if ((vector-ref f6155 0) f6170 f6171 f6172) ((vector-ref f6154 0) f6170 f6171 (fx+ f6172 1) f6173) #f))))
    movl $_L_37352, 0(%ebp)  # closure label
# emit-variable-ref
# env=((f6153 . -12) (f6154 . -8) (f6155 . -4) (f6156 . 0))
# var=f6155
    movl -4(%esp), %eax  # stack load f6155
# end emit-variable-ref
   movl  %eax, 4(%ebp)  # f6155
# emit-variable-ref
# env=((f6153 . -12) (f6154 . -8) (f6155 . -4) (f6156 . 0))
# var=f6154
    movl -8(%esp), %eax  # stack load f6154
# end emit-variable-ref
   movl  %eax, 8(%ebp)  # f6154
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $16, %ebp     # bump ebp
    jmp _L_37353            # jump around closure body
_L_37352:
# check argument count
    cmp $16,%eax
    je _L_37354
# invoke error handler eh_argcount
    .extern mrc_eh$uargcount
    movl mrc_eh$uargcount, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_37354:
# emit-tail-expr
# si=-24
# env=((f6173 . -20) (f6172 . -16) (f6171 . -12) (f6170 . -8) (f6154 . 8) (f6155 . 4) (f6153 . -12) (f6154 . -8) (f6155 . -4) (f6156 . 0))
# expr=(let ((f6170 f6170) (f6171 f6171) (f6172 f6172) (f6173 f6173)) (if (fx= f6172 f6173) #t (if ((vector-ref f6155 0) f6170 f6171 f6172) ((vector-ref f6154 0) f6170 f6171 (fx+ f6172 1) f6173) #f)))
# emit-tail-let
#  si   = -24
#  env  = ((f6173 . -20) (f6172 . -16) (f6171 . -12) (f6170 . -8) (f6154 . 8) (f6155 . 4) (f6153 . -12) (f6154 . -8) (f6155 . -4) (f6156 . 0))
#  bindings = ((f6170 f6170) (f6171 f6171) (f6172 f6172) (f6173 f6173))
#  body = (if (fx= f6172 f6173) #t (if ((vector-ref f6155 0) f6170 f6171 f6172) ((vector-ref f6154 0) f6170 f6171 (fx+ f6172 1) f6173) #f))
# emit-expr f6170
# emit-variable-ref
# env=((f6173 . -20) (f6172 . -16) (f6171 . -12) (f6170 . -8) (f6154 . 8) (f6155 . 4) (f6153 . -12) (f6154 . -8) (f6155 . -4) (f6156 . 0))
# var=f6170
    movl -8(%esp), %eax  # stack load f6170
# end emit-variable-ref
    movl %eax, -24(%esp)  # stack save
# emit-expr f6171
# emit-variable-ref
# env=((f6173 . -20) (f6172 . -16) (f6171 . -12) (f6170 . -8) (f6154 . 8) (f6155 . 4) (f6153 . -12) (f6154 . -8) (f6155 . -4) (f6156 . 0))
# var=f6171
    movl -12(%esp), %eax  # stack load f6171
# end emit-variable-ref
    movl %eax, -28(%esp)  # stack save
# emit-expr f6172
# emit-variable-ref
# env=((f6173 . -20) (f6172 . -16) (f6171 . -12) (f6170 . -8) (f6154 . 8) (f6155 . 4) (f6153 . -12) (f6154 . -8) (f6155 . -4) (f6156 . 0))
# var=f6172
    movl -16(%esp), %eax  # stack load f6172
# end emit-variable-ref
    movl %eax, -32(%esp)  # stack save
# emit-expr f6173
# emit-variable-ref
# env=((f6173 . -20) (f6172 . -16) (f6171 . -12) (f6170 . -8) (f6154 . 8) (f6155 . 4) (f6153 . -12) (f6154 . -8) (f6155 . -4) (f6156 . 0))
# var=f6173
    movl -20(%esp), %eax  # stack load f6173
# end emit-variable-ref
    movl %eax, -36(%esp)  # stack save
# emit-tail-expr
# si=-40
# env=((f6173 . -36) (f6172 . -32) (f6171 . -28) (f6170 . -24) (f6173 . -20) (f6172 . -16) (f6171 . -12) (f6170 . -8) (f6154 . 8) (f6155 . 4) (f6153 . -12) (f6154 . -8) (f6155 . -4) (f6156 . 0))
# expr=(if (fx= f6172 f6173) #t (if ((vector-ref f6155 0) f6170 f6171 f6172) ((vector-ref f6154 0) f6170 f6171 (fx+ f6172 1) f6173) #f))
# emit-expr (fx= f6172 f6173)
# emit-expr f6173
# emit-variable-ref
# env=((f6173 . -36) (f6172 . -32) (f6171 . -28) (f6170 . -24) (f6173 . -20) (f6172 . -16) (f6171 . -12) (f6170 . -8) (f6154 . 8) (f6155 . 4) (f6153 . -12) (f6154 . -8) (f6155 . -4) (f6156 . 0))
# var=f6173
    movl -36(%esp), %eax  # stack load f6173
# end emit-variable-ref
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_37357"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $68,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_37357:
    movl %eax, -40(%esp)
# emit-expr f6172
# emit-variable-ref
# env=((f6173 . -36) (f6172 . -32) (f6171 . -28) (f6170 . -24) (f6173 . -20) (f6172 . -16) (f6171 . -12) (f6170 . -8) (f6154 . 8) (f6155 . 4) (f6153 . -12) (f6154 . -8) (f6155 . -4) (f6156 . 0))
# var=f6172
    movl -32(%esp), %eax  # stack load f6172
# end emit-variable-ref
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_37358"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $68,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_37358:
    cmp -40(%esp), %eax
    sete %al
    movzbl %al, %eax
    sal $6, %al
    or $47, %al
    cmp $47, %al
    je _L_37355
# emit-tail-expr
# si=-40
# env=((f6173 . -36) (f6172 . -32) (f6171 . -28) (f6170 . -24) (f6173 . -20) (f6172 . -16) (f6171 . -12) (f6170 . -8) (f6154 . 8) (f6155 . 4) (f6153 . -12) (f6154 . -8) (f6155 . -4) (f6156 . 0))
# expr=#t
    movl $111, %eax     # immed #t
    ret                  # immediate tail return
    jmp _L_37356
_L_37355:
# emit-tail-expr
# si=-40
# env=((f6173 . -36) (f6172 . -32) (f6171 . -28) (f6170 . -24) (f6173 . -20) (f6172 . -16) (f6171 . -12) (f6170 . -8) (f6154 . 8) (f6155 . 4) (f6153 . -12) (f6154 . -8) (f6155 . -4) (f6156 . 0))
# expr=(if ((vector-ref f6155 0) f6170 f6171 f6172) ((vector-ref f6154 0) f6170 f6171 (fx+ f6172 1) f6173) #f)
# emit-expr ((vector-ref f6155 0) f6170 f6171 f6172)
# funcall
#    si   =-40
#    env  = ((f6173 . -36) (f6172 . -32) (f6171 . -28) (f6170 . -24) (f6173 . -20) (f6172 . -16) (f6171 . -12) (f6170 . -8) (f6154 . 8) (f6155 . 4) (f6153 . -12) (f6154 . -8) (f6155 . -4) (f6156 . 0))
#    expr = (funcall (vector-ref f6155 0) f6170 f6171 f6172)
# emit-expr (vector-ref f6155 0)
# emit-expr f6155
# emit-variable-ref
# env=((f6173 . -36) (f6172 . -32) (f6171 . -28) (f6170 . -24) (f6173 . -20) (f6172 . -16) (f6171 . -12) (f6170 . -8) (f6154 . 8) (f6155 . 4) (f6153 . -12) (f6154 . -8) (f6155 . -4) (f6156 . 0))
# var=f6155
    movl 2(%edi), %eax  # frame load f6155
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_37361
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_37361:
    movl %eax, -48(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_37362"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_37362:
# check bounds on vector index
    movl -48(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_37364
    cmp  $0,%eax
    jge _L_37363
_L_37364:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_37363:
    movl -48(%esp), %esi
    movl -1(%eax,%esi), %eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_37365"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_37365":
   movl %eax,  -48(%esp)  # stash funcall-oper in closure slot
# emit-expr f6170
# emit-variable-ref
# env=((f6173 . -36) (f6172 . -32) (f6171 . -28) (f6170 . -24) (f6173 . -20) (f6172 . -16) (f6171 . -12) (f6170 . -8) (f6154 . 8) (f6155 . 4) (f6153 . -12) (f6154 . -8) (f6155 . -4) (f6156 . 0))
# var=f6170
    movl -24(%esp), %eax  # stack load f6170
# end emit-variable-ref
    mov %eax, -52(%esp)  # arg f6170
# emit-expr f6171
# emit-variable-ref
# env=((f6173 . -36) (f6172 . -32) (f6171 . -28) (f6170 . -24) (f6173 . -20) (f6172 . -16) (f6171 . -12) (f6170 . -8) (f6154 . 8) (f6155 . 4) (f6153 . -12) (f6154 . -8) (f6155 . -4) (f6156 . 0))
# var=f6171
    movl -28(%esp), %eax  # stack load f6171
# end emit-variable-ref
    mov %eax, -56(%esp)  # arg f6171
# emit-expr f6172
# emit-variable-ref
# env=((f6173 . -36) (f6172 . -32) (f6171 . -28) (f6170 . -24) (f6173 . -20) (f6172 . -16) (f6171 . -12) (f6170 . -8) (f6154 . 8) (f6155 . 4) (f6153 . -12) (f6154 . -8) (f6155 . -4) (f6156 . 0))
# var=f6172
    movl -32(%esp), %eax  # stack load f6172
# end emit-variable-ref
    mov %eax, -60(%esp)  # arg f6172
    movl -48(%esp), %edi   # load new closure to %edi
    add $-40, %esp   # adjust base
    movl $12,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $40, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    cmp $47, %al
    je _L_37359
# emit-tail-expr
# si=-40
# env=((f6173 . -36) (f6172 . -32) (f6171 . -28) (f6170 . -24) (f6173 . -20) (f6172 . -16) (f6171 . -12) (f6170 . -8) (f6154 . 8) (f6155 . 4) (f6153 . -12) (f6154 . -8) (f6155 . -4) (f6156 . 0))
# expr=((vector-ref f6154 0) f6170 f6171 (fx+ f6172 1) f6173)
# emit-tail-funcall
#    si   =-40
#    env  = ((f6173 . -36) (f6172 . -32) (f6171 . -28) (f6170 . -24) (f6173 . -20) (f6172 . -16) (f6171 . -12) (f6170 . -8) (f6154 . 8) (f6155 . 4) (f6153 . -12) (f6154 . -8) (f6155 . -4) (f6156 . 0))
#    expr = (funcall (vector-ref f6154 0) f6170 f6171 (fx+ f6172 1) f6173)
# emit-expr (vector-ref f6154 0)
# emit-expr f6154
# emit-variable-ref
# env=((f6173 . -36) (f6172 . -32) (f6171 . -28) (f6170 . -24) (f6173 . -20) (f6172 . -16) (f6171 . -12) (f6170 . -8) (f6154 . 8) (f6155 . 4) (f6153 . -12) (f6154 . -8) (f6155 . -4) (f6156 . 0))
# var=f6154
    movl 6(%edi), %eax  # frame load f6154
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_37366
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_37366:
    movl %eax, -40(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_37367"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_37367:
# check bounds on vector index
    movl -40(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_37369
    cmp  $0,%eax
    jge _L_37368
_L_37369:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_37368:
    movl -40(%esp), %esi
    movl -1(%eax,%esi), %eax
   movl %eax,  -40(%esp)  # stash funcall-oper in next closure slot
# emit-expr f6170
# emit-variable-ref
# env=((f6173 . -36) (f6172 . -32) (f6171 . -28) (f6170 . -24) (f6173 . -20) (f6172 . -16) (f6171 . -12) (f6170 . -8) (f6154 . 8) (f6155 . 4) (f6153 . -12) (f6154 . -8) (f6155 . -4) (f6156 . 0))
# var=f6170
    movl -24(%esp), %eax  # stack load f6170
# end emit-variable-ref
    mov %eax, -44(%esp)    # arg f6170
# emit-expr f6171
# emit-variable-ref
# env=((f6173 . -36) (f6172 . -32) (f6171 . -28) (f6170 . -24) (f6173 . -20) (f6172 . -16) (f6171 . -12) (f6170 . -8) (f6154 . 8) (f6155 . 4) (f6153 . -12) (f6154 . -8) (f6155 . -4) (f6156 . 0))
# var=f6171
    movl -28(%esp), %eax  # stack load f6171
# end emit-variable-ref
    mov %eax, -48(%esp)    # arg f6171
# emit-expr (fx+ f6172 1)
# emit-expr 1
    movl $4, %eax     # immed 1
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_37370"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $88,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_37370:
    movl %eax, -52(%esp)  # fx+ push arg1
# emit-expr f6172
# emit-variable-ref
# env=((f6173 . -36) (f6172 . -32) (f6171 . -28) (f6170 . -24) (f6173 . -20) (f6172 . -16) (f6171 . -12) (f6170 . -8) (f6154 . 8) (f6155 . 4) (f6153 . -12) (f6154 . -8) (f6155 . -4) (f6156 . 0))
# var=f6172
    movl -32(%esp), %eax  # stack load f6172
# end emit-variable-ref
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_37371"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $88,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_37371:
    addl -52(%esp), %eax  # fx+ arg1 arg2
    mov %eax, -52(%esp)    # arg (fx+ f6172 1)
# emit-expr f6173
# emit-variable-ref
# env=((f6173 . -36) (f6172 . -32) (f6171 . -28) (f6170 . -24) (f6173 . -20) (f6172 . -16) (f6171 . -12) (f6170 . -8) (f6154 . 8) (f6155 . 4) (f6153 . -12) (f6154 . -8) (f6155 . -4) (f6156 . 0))
# var=f6173
    movl -36(%esp), %eax  # stack load f6173
# end emit-variable-ref
    mov %eax, -56(%esp)    # arg f6173
    movl -40(%esp), %edi   # load new closure to %edi
# emit-shift-args:  size=5   si=-40  delta=36
    mov -40(%esp), %ebx  # shift frame cell
    mov %ebx, -4(%esp)  # down to base
# emit-shift-args:  size=4   si=-44  delta=36
    mov -44(%esp), %ebx  # shift frame cell
    mov %ebx, -8(%esp)  # down to base
# emit-shift-args:  size=3   si=-48  delta=36
    mov -48(%esp), %ebx  # shift frame cell
    mov %ebx, -12(%esp)  # down to base
# emit-shift-args:  size=2   si=-52  delta=36
    mov -52(%esp), %ebx  # shift frame cell
    mov %ebx, -16(%esp)  # down to base
# emit-shift-args:  size=1   si=-56  delta=36
    mov -56(%esp), %ebx  # shift frame cell
    mov %ebx, -20(%esp)  # down to base
# emit-shift-args:  size=0   si=-60  delta=36
    movl $16,%eax   # save arg count
    jmp *-2(%edi)  # tail-funcall
    jmp _L_37360
_L_37359:
# emit-tail-expr
# si=-40
# env=((f6173 . -36) (f6172 . -32) (f6171 . -28) (f6170 . -24) (f6173 . -20) (f6172 . -16) (f6171 . -12) (f6170 . -8) (f6154 . 8) (f6155 . 4) (f6153 . -12) (f6154 . -8) (f6155 . -4) (f6156 . 0))
# expr=#f
    movl $47, %eax     # immed #f
    ret                  # immediate tail return
_L_37360:
_L_37356:
    .align 4,0x90
_L_37353:
    movl -16(%esp), %ebx
    movl -20(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin (vector-set! f6153 0 (closure (f6168 f6169) (f6156 f6154) (let ((f6168 f6168) (f6169 f6169)) (if ((vector-ref f6156 0) f6168 f6169) ((vector-ref f6154 0) f6168 f6169 0 (string-length f6168)) #f)))))
# emit-begin
#   expr=(begin (vector-set! f6153 0 (closure (f6168 f6169) (f6156 f6154) (let ((f6168 f6168) (f6169 f6169)) (if ((vector-ref f6156 0) f6168 f6169) ((vector-ref f6154 0) f6168 f6169 0 (string-length f6168)) #f)))))
#   env=((f6153 . -12) (f6154 . -8) (f6155 . -4) (f6156 . 0))
# emit-expr (vector-set! f6153 0 (closure (f6168 f6169) (f6156 f6154) (let ((f6168 f6168) (f6169 f6169)) (if ((vector-ref f6156 0) f6168 f6169) ((vector-ref f6154 0) f6168 f6169 0 (string-length f6168)) #f))))
# emit-expr f6153
# emit-variable-ref
# env=((f6153 . -12) (f6154 . -8) (f6155 . -4) (f6156 . 0))
# var=f6153
    movl -12(%esp), %eax  # stack load f6153
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_37372
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_37372:
    movl %eax, -16(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_37373"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_37373:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_37375
    cmp  $0,%eax
    jge _L_37374
_L_37375:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_37374:
    movl %eax, -20(%esp)
# emit-expr (closure (f6168 f6169) (f6156 f6154) (let ((f6168 f6168) (f6169 f6169)) (if ((vector-ref f6156 0) f6168 f6169) ((vector-ref f6154 0) f6168 f6169 0 (string-length f6168)) #f)))
# emit-closure
# si = -24
# env = ((f6153 . -12) (f6154 . -8) (f6155 . -4) (f6156 . 0))
# expr = (closure (f6168 f6169) (f6156 f6154) (let ((f6168 f6168) (f6169 f6169)) (if ((vector-ref f6156 0) f6168 f6169) ((vector-ref f6154 0) f6168 f6169 0 (string-length f6168)) #f)))
    movl $_L_37376, 0(%ebp)  # closure label
# emit-variable-ref
# env=((f6153 . -12) (f6154 . -8) (f6155 . -4) (f6156 . 0))
# var=f6156
    movl 0(%esp), %eax  # stack load f6156
# end emit-variable-ref
   movl  %eax, 4(%ebp)  # f6156
# emit-variable-ref
# env=((f6153 . -12) (f6154 . -8) (f6155 . -4) (f6156 . 0))
# var=f6154
    movl -8(%esp), %eax  # stack load f6154
# end emit-variable-ref
   movl  %eax, 8(%ebp)  # f6154
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $16, %ebp     # bump ebp
    jmp _L_37377            # jump around closure body
_L_37376:
# check argument count
    cmp $8,%eax
    je _L_37378
# invoke error handler eh_argcount
    .extern mrc_eh$uargcount
    movl mrc_eh$uargcount, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_37378:
# emit-tail-expr
# si=-16
# env=((f6169 . -12) (f6168 . -8) (f6154 . 8) (f6156 . 4) (f6153 . -12) (f6154 . -8) (f6155 . -4) (f6156 . 0))
# expr=(let ((f6168 f6168) (f6169 f6169)) (if ((vector-ref f6156 0) f6168 f6169) ((vector-ref f6154 0) f6168 f6169 0 (string-length f6168)) #f))
# emit-tail-let
#  si   = -16
#  env  = ((f6169 . -12) (f6168 . -8) (f6154 . 8) (f6156 . 4) (f6153 . -12) (f6154 . -8) (f6155 . -4) (f6156 . 0))
#  bindings = ((f6168 f6168) (f6169 f6169))
#  body = (if ((vector-ref f6156 0) f6168 f6169) ((vector-ref f6154 0) f6168 f6169 0 (string-length f6168)) #f)
# emit-expr f6168
# emit-variable-ref
# env=((f6169 . -12) (f6168 . -8) (f6154 . 8) (f6156 . 4) (f6153 . -12) (f6154 . -8) (f6155 . -4) (f6156 . 0))
# var=f6168
    movl -8(%esp), %eax  # stack load f6168
# end emit-variable-ref
    movl %eax, -16(%esp)  # stack save
# emit-expr f6169
# emit-variable-ref
# env=((f6169 . -12) (f6168 . -8) (f6154 . 8) (f6156 . 4) (f6153 . -12) (f6154 . -8) (f6155 . -4) (f6156 . 0))
# var=f6169
    movl -12(%esp), %eax  # stack load f6169
# end emit-variable-ref
    movl %eax, -20(%esp)  # stack save
# emit-tail-expr
# si=-24
# env=((f6169 . -20) (f6168 . -16) (f6169 . -12) (f6168 . -8) (f6154 . 8) (f6156 . 4) (f6153 . -12) (f6154 . -8) (f6155 . -4) (f6156 . 0))
# expr=(if ((vector-ref f6156 0) f6168 f6169) ((vector-ref f6154 0) f6168 f6169 0 (string-length f6168)) #f)
# emit-expr ((vector-ref f6156 0) f6168 f6169)
# funcall
#    si   =-24
#    env  = ((f6169 . -20) (f6168 . -16) (f6169 . -12) (f6168 . -8) (f6154 . 8) (f6156 . 4) (f6153 . -12) (f6154 . -8) (f6155 . -4) (f6156 . 0))
#    expr = (funcall (vector-ref f6156 0) f6168 f6169)
# emit-expr (vector-ref f6156 0)
# emit-expr f6156
# emit-variable-ref
# env=((f6169 . -20) (f6168 . -16) (f6169 . -12) (f6168 . -8) (f6154 . 8) (f6156 . 4) (f6153 . -12) (f6154 . -8) (f6155 . -4) (f6156 . 0))
# var=f6156
    movl 2(%edi), %eax  # frame load f6156
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_37381
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_37381:
    movl %eax, -32(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_37382"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_37382:
# check bounds on vector index
    movl -32(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_37384
    cmp  $0,%eax
    jge _L_37383
_L_37384:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_37383:
    movl -32(%esp), %esi
    movl -1(%eax,%esi), %eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_37385"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_37385":
   movl %eax,  -32(%esp)  # stash funcall-oper in closure slot
# emit-expr f6168
# emit-variable-ref
# env=((f6169 . -20) (f6168 . -16) (f6169 . -12) (f6168 . -8) (f6154 . 8) (f6156 . 4) (f6153 . -12) (f6154 . -8) (f6155 . -4) (f6156 . 0))
# var=f6168
    movl -16(%esp), %eax  # stack load f6168
# end emit-variable-ref
    mov %eax, -36(%esp)  # arg f6168
# emit-expr f6169
# emit-variable-ref
# env=((f6169 . -20) (f6168 . -16) (f6169 . -12) (f6168 . -8) (f6154 . 8) (f6156 . 4) (f6153 . -12) (f6154 . -8) (f6155 . -4) (f6156 . 0))
# var=f6169
    movl -20(%esp), %eax  # stack load f6169
# end emit-variable-ref
    mov %eax, -40(%esp)  # arg f6169
    movl -32(%esp), %edi   # load new closure to %edi
    add $-24, %esp   # adjust base
    movl $8,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $24, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    cmp $47, %al
    je _L_37379
# emit-tail-expr
# si=-24
# env=((f6169 . -20) (f6168 . -16) (f6169 . -12) (f6168 . -8) (f6154 . 8) (f6156 . 4) (f6153 . -12) (f6154 . -8) (f6155 . -4) (f6156 . 0))
# expr=((vector-ref f6154 0) f6168 f6169 0 (string-length f6168))
# emit-tail-funcall
#    si   =-24
#    env  = ((f6169 . -20) (f6168 . -16) (f6169 . -12) (f6168 . -8) (f6154 . 8) (f6156 . 4) (f6153 . -12) (f6154 . -8) (f6155 . -4) (f6156 . 0))
#    expr = (funcall (vector-ref f6154 0) f6168 f6169 0 (string-length f6168))
# emit-expr (vector-ref f6154 0)
# emit-expr f6154
# emit-variable-ref
# env=((f6169 . -20) (f6168 . -16) (f6169 . -12) (f6168 . -8) (f6154 . 8) (f6156 . 4) (f6153 . -12) (f6154 . -8) (f6155 . -4) (f6156 . 0))
# var=f6154
    movl 6(%edi), %eax  # frame load f6154
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_37386
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_37386:
    movl %eax, -24(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_37387"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_37387:
# check bounds on vector index
    movl -24(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_37389
    cmp  $0,%eax
    jge _L_37388
_L_37389:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_37388:
    movl -24(%esp), %esi
    movl -1(%eax,%esi), %eax
   movl %eax,  -24(%esp)  # stash funcall-oper in next closure slot
# emit-expr f6168
# emit-variable-ref
# env=((f6169 . -20) (f6168 . -16) (f6169 . -12) (f6168 . -8) (f6154 . 8) (f6156 . 4) (f6153 . -12) (f6154 . -8) (f6155 . -4) (f6156 . 0))
# var=f6168
    movl -16(%esp), %eax  # stack load f6168
# end emit-variable-ref
    mov %eax, -28(%esp)    # arg f6168
# emit-expr f6169
# emit-variable-ref
# env=((f6169 . -20) (f6168 . -16) (f6169 . -12) (f6168 . -8) (f6154 . 8) (f6156 . 4) (f6153 . -12) (f6154 . -8) (f6155 . -4) (f6156 . 0))
# var=f6169
    movl -20(%esp), %eax  # stack load f6169
# end emit-variable-ref
    mov %eax, -32(%esp)    # arg f6169
# emit-expr 0
    movl $0, %eax     # immed 0
    mov %eax, -36(%esp)    # arg 0
# emit-expr (string-length f6168)
# emit-expr f6168
# emit-variable-ref
# env=((f6169 . -20) (f6168 . -16) (f6169 . -12) (f6168 . -8) (f6154 . 8) (f6156 . 4) (f6153 . -12) (f6154 . -8) (f6155 . -4) (f6156 . 0))
# var=f6168
    movl -16(%esp), %eax  # stack load f6168
# end emit-variable-ref
# check the argument is a string
    movl %eax,%ebx
    and $7, %bl
    cmp $6, %bl
    je _L_37390
# invoke error handler eh_string
    .extern mrc_eh$ustring
    movl mrc_eh$ustring, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $160,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_37390:
    movl -6(%eax), %eax
    mov %eax, -40(%esp)    # arg (string-length f6168)
    movl -24(%esp), %edi   # load new closure to %edi
# emit-shift-args:  size=5   si=-24  delta=20
    mov -24(%esp), %ebx  # shift frame cell
    mov %ebx, -4(%esp)  # down to base
# emit-shift-args:  size=4   si=-28  delta=20
    mov -28(%esp), %ebx  # shift frame cell
    mov %ebx, -8(%esp)  # down to base
# emit-shift-args:  size=3   si=-32  delta=20
    mov -32(%esp), %ebx  # shift frame cell
    mov %ebx, -12(%esp)  # down to base
# emit-shift-args:  size=2   si=-36  delta=20
    mov -36(%esp), %ebx  # shift frame cell
    mov %ebx, -16(%esp)  # down to base
# emit-shift-args:  size=1   si=-40  delta=20
    mov -40(%esp), %ebx  # shift frame cell
    mov %ebx, -20(%esp)  # down to base
# emit-shift-args:  size=0   si=-44  delta=20
    movl $16,%eax   # save arg count
    jmp *-2(%edi)  # tail-funcall
    jmp _L_37380
_L_37379:
# emit-tail-expr
# si=-24
# env=((f6169 . -20) (f6168 . -16) (f6169 . -12) (f6168 . -8) (f6154 . 8) (f6156 . 4) (f6153 . -12) (f6154 . -8) (f6155 . -4) (f6156 . 0))
# expr=#f
    movl $47, %eax     # immed #f
    ret                  # immediate tail return
_L_37380:
    .align 4,0x90
_L_37377:
    movl -16(%esp), %ebx
    movl -20(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin)
# emit-begin
#   expr=(begin)
#   env=((f6153 . -12) (f6154 . -8) (f6155 . -4) (f6156 . 0))
# emit-expr (begin (vector-ref f6153 0))
# emit-begin
#   expr=(begin (vector-ref f6153 0))
#   env=((f6153 . -12) (f6154 . -8) (f6155 . -4) (f6156 . 0))
# emit-expr (vector-ref f6153 0)
# emit-expr f6153
# emit-variable-ref
# env=((f6153 . -12) (f6154 . -8) (f6155 . -4) (f6156 . 0))
# var=f6153
    movl -12(%esp), %eax  # stack load f6153
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_37391
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_37391:
    movl %eax, -16(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_37392"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_37392:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_37394
    cmp  $0,%eax
    jge _L_37393
_L_37394:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_37393:
    movl -16(%esp), %esi
    movl -1(%eax,%esi), %eax
# emit-expr (begin)
# emit-begin
#   expr=(begin)
#   env=((f6153 . -12) (f6154 . -8) (f6155 . -4) (f6156 . 0))
     movl %eax, mrc_string$e$q
# == explicit-begins  ==>
# (letrec ((str->sym (lambda (str symlist) (if (string=? str (symbol->string (car symlist))) (car symlist) (if (null? (cdr symlist)) (let* ((new-sym (make-symbol str #f)) (new-cdr (cons new-sym ()))) (begin (set-cdr! symlist new-cdr) new-sym)) (str->sym str (cdr symlist))))))) (lambda (str) (str->sym str (symbols))))
# == eliminate-let*  ==>
# (letrec ((str->sym (lambda (str symlist) (if (string=? str (symbol->string (car symlist))) (car symlist) (if (null? (cdr symlist)) (let ((new-sym (make-symbol str #f))) (let ((new-cdr (cons new-sym ()))) (begin (set-cdr! symlist new-cdr) new-sym))) (str->sym str (cdr symlist))))))) (lambda (str) (str->sym str (symbols))))
# == uniquify-variables  ==>
# (letrec ((f6179 (lambda (f6188 f6189) (if (string=? f6188 (symbol->string (car f6189))) (car f6189) (if (null? (cdr f6189)) (let ((f6193 (make-symbol f6188 #f))) (let ((f6195 (cons f6193 ()))) (begin (set-cdr! f6189 f6195) f6193))) (f6179 f6188 (cdr f6189))))))) (lambda (f6197) (f6179 f6197 (symbols))))
# == vectorize-letrec  ==>
# (let ((f6179 (make-vector 1))) (begin (begin (vector-set! f6179 0 (lambda (f6188 f6189) (if (string=? f6188 (symbol->string (car f6189))) (car f6189) (if (null? (cdr f6189)) (let ((f6193 (make-symbol f6188 #f))) (let ((f6195 (cons f6193 ()))) (begin (set-cdr! f6189 f6195) f6193))) ((vector-ref f6179 0) f6188 (cdr f6189))))))) (lambda (f6197) ((vector-ref f6179 0) f6197 (symbols)))))
# == eliminate-set!  ==>
# (let ((f6179 (make-vector 1))) (begin (begin (vector-set! f6179 0 (lambda (f6188 f6189) (let ((f6188 f6188) (f6189 f6189)) (if (string=? f6188 (symbol->string (car f6189))) (car f6189) (if (null? (cdr f6189)) (let ((f6193 (make-symbol f6188 #f))) (let ((f6195 (cons f6193 ()))) (begin (set-cdr! f6189 f6195) f6193))) ((vector-ref f6179 0) f6188 (cdr f6189)))))))) (lambda (f6197) (let ((f6197 f6197)) ((vector-ref f6179 0) f6197 (symbols))))))
# == close-free-variables  ==>
# (let ((f6179 (make-vector 1))) (begin (begin (vector-set! f6179 0 (closure (f6188 f6189) (f6179) (let ((f6188 f6188) (f6189 f6189)) (if (string=? f6188 (symbol->string (car f6189))) (car f6189) (if (null? (cdr f6189)) (let ((f6193 (make-symbol f6188 #f))) (let ((f6195 (cons f6193 ()))) (begin (set-cdr! f6189 f6195) f6193))) ((vector-ref f6179 0) f6188 (cdr f6189)))))))) (closure (f6197) (f6179) (let ((f6197 f6197)) ((vector-ref f6179 0) f6197 (symbols))))))
# == eliminate-quote  ==>
# (let ((f6179 (make-vector 1))) (begin (begin (vector-set! f6179 0 (closure (f6188 f6189) (f6179) (let ((f6188 f6188) (f6189 f6189)) (if (string=? f6188 (symbol->string (car f6189))) (car f6189) (if (null? (cdr f6189)) (let ((f6193 (make-symbol f6188 #f))) (let ((f6195 (cons f6193 ()))) (begin (set-cdr! f6189 f6195) f6193))) ((vector-ref f6179 0) f6188 (cdr f6189)))))))) (closure (f6197) (f6179) (let ((f6197 f6197)) ((vector-ref f6179 0) f6197 (symbols))))))
# == eliminate-when/unless  ==>
# (let ((f6179 (make-vector 1))) (begin (begin (vector-set! f6179 0 (closure (f6188 f6189) (f6179) (let ((f6188 f6188) (f6189 f6189)) (if (string=? f6188 (symbol->string (car f6189))) (car f6189) (if (null? (cdr f6189)) (let ((f6193 (make-symbol f6188 #f))) (let ((f6195 (cons f6193 ()))) (begin (set-cdr! f6189 f6195) f6193))) ((vector-ref f6179 0) f6188 (cdr f6189)))))))) (closure (f6197) (f6179) (let ((f6197 f6197)) ((vector-ref f6179 0) f6197 (symbols))))))
# == eliminate-cond  ==>
# (let ((f6179 (make-vector 1))) (begin (begin (vector-set! f6179 0 (closure (f6188 f6189) (f6179) (let ((f6188 f6188) (f6189 f6189)) (if (string=? f6188 (symbol->string (car f6189))) (car f6189) (if (null? (cdr f6189)) (let ((f6193 (make-symbol f6188 #f))) (let ((f6195 (cons f6193 ()))) (begin (set-cdr! f6189 f6195) f6193))) ((vector-ref f6179 0) f6188 (cdr f6189)))))))) (closure (f6197) (f6179) (let ((f6197 f6197)) ((vector-ref f6179 0) f6197 (symbols))))))
# == external-symbols  ==>
# (let ((f6179 (make-vector 1))) (begin (begin (vector-set! f6179 0 (closure (f6188 f6189) (f6179) (let ((f6188 f6188) (f6189 f6189)) (if ((primitive-ref string=?) f6188 (symbol->string (car f6189))) (car f6189) (if (null? (cdr f6189)) (let ((f6193 (make-symbol f6188 #f))) (let ((f6195 (cons f6193 ()))) (begin (set-cdr! f6189 f6195) f6193))) ((vector-ref f6179 0) f6188 (cdr f6189)))))))) (closure (f6197) (f6179) (let ((f6197 f6197)) ((vector-ref f6179 0) f6197 ((primitive-ref symbols)))))))
# emit-expr (let ((f6179 (make-vector 1))) (begin (begin (vector-set! f6179 0 (closure (f6188 f6189) (f6179) (let ((f6188 f6188) (f6189 f6189)) (if ((primitive-ref string=?) f6188 (symbol->string (car f6189))) (car f6189) (if (null? (cdr f6189)) (let ((f6193 (make-symbol f6188 #f))) (let ((f6195 (cons f6193 ()))) (begin (set-cdr! f6189 f6195) f6193))) ((vector-ref f6179 0) f6188 (cdr f6189)))))))) (closure (f6197) (f6179) (let ((f6197 f6197)) ((vector-ref f6179 0) f6197 ((primitive-ref symbols)))))))
# emit-let
#  si   = 0
#  env  = ()
#  bindings = ((f6179 (make-vector 1)))
#  body = (begin (begin (vector-set! f6179 0 (closure (f6188 f6189) (f6179) (let ((f6188 f6188) (f6189 f6189)) (if ((primitive-ref string=?) f6188 (symbol->string (car f6189))) (car f6189) (if (null? (cdr f6189)) (let ((f6193 (make-symbol f6188 #f))) (let ((f6195 (cons f6193 ()))) (begin (set-cdr! f6189 f6195) f6193))) ((vector-ref f6179 0) f6188 (cdr f6189)))))))) (closure (f6197) (f6179) (let ((f6197 f6197)) ((vector-ref f6179 0) f6197 ((primitive-ref symbols))))))
# emit-expr (make-vector 1)
# make-vector 1
# emit-expr 1
    movl $4, %eax     # immed 1
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_37395"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_37395:
# check the argument is a fixnum >= 0
    cmp $0,%eax
    jge _L_37396
# invoke error handler eh_length
    .extern mrc_eh$ulength
    movl mrc_eh$ulength, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_37396:
    movl %eax, %esi
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    orl  $5, %eax
    addl $4, %esi
    addl $4, %esi
    andl $-8, %esi
    addl %esi, %ebp
    movl %eax, 0(%esp)  # stack save
# emit-expr (begin (begin (vector-set! f6179 0 (closure (f6188 f6189) (f6179) (let ((f6188 f6188) (f6189 f6189)) (if ((primitive-ref string=?) f6188 (symbol->string (car f6189))) (car f6189) (if (null? (cdr f6189)) (let ((f6193 (make-symbol f6188 #f))) (let ((f6195 (cons f6193 ()))) (begin (set-cdr! f6189 f6195) f6193))) ((vector-ref f6179 0) f6188 (cdr f6189)))))))) (closure (f6197) (f6179) (let ((f6197 f6197)) ((vector-ref f6179 0) f6197 ((primitive-ref symbols))))))
# emit-begin
#   expr=(begin (begin (vector-set! f6179 0 (closure (f6188 f6189) (f6179) (let ((f6188 f6188) (f6189 f6189)) (if ((primitive-ref string=?) f6188 (symbol->string (car f6189))) (car f6189) (if (null? (cdr f6189)) (let ((f6193 (make-symbol f6188 #f))) (let ((f6195 (cons f6193 ()))) (begin (set-cdr! f6189 f6195) f6193))) ((vector-ref f6179 0) f6188 (cdr f6189)))))))) (closure (f6197) (f6179) (let ((f6197 f6197)) ((vector-ref f6179 0) f6197 ((primitive-ref symbols))))))
#   env=((f6179 . 0))
# emit-expr (begin (vector-set! f6179 0 (closure (f6188 f6189) (f6179) (let ((f6188 f6188) (f6189 f6189)) (if ((primitive-ref string=?) f6188 (symbol->string (car f6189))) (car f6189) (if (null? (cdr f6189)) (let ((f6193 (make-symbol f6188 #f))) (let ((f6195 (cons f6193 ()))) (begin (set-cdr! f6189 f6195) f6193))) ((vector-ref f6179 0) f6188 (cdr f6189))))))))
# emit-begin
#   expr=(begin (vector-set! f6179 0 (closure (f6188 f6189) (f6179) (let ((f6188 f6188) (f6189 f6189)) (if ((primitive-ref string=?) f6188 (symbol->string (car f6189))) (car f6189) (if (null? (cdr f6189)) (let ((f6193 (make-symbol f6188 #f))) (let ((f6195 (cons f6193 ()))) (begin (set-cdr! f6189 f6195) f6193))) ((vector-ref f6179 0) f6188 (cdr f6189))))))))
#   env=((f6179 . 0))
# emit-expr (vector-set! f6179 0 (closure (f6188 f6189) (f6179) (let ((f6188 f6188) (f6189 f6189)) (if ((primitive-ref string=?) f6188 (symbol->string (car f6189))) (car f6189) (if (null? (cdr f6189)) (let ((f6193 (make-symbol f6188 #f))) (let ((f6195 (cons f6193 ()))) (begin (set-cdr! f6189 f6195) f6193))) ((vector-ref f6179 0) f6188 (cdr f6189)))))))
# emit-expr f6179
# emit-variable-ref
# env=((f6179 . 0))
# var=f6179
    movl 0(%esp), %eax  # stack load f6179
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_37397
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_37397:
    movl %eax, -4(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_37398"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_37398:
# check bounds on vector index
    movl -4(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_37400
    cmp  $0,%eax
    jge _L_37399
_L_37400:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_37399:
    movl %eax, -8(%esp)
# emit-expr (closure (f6188 f6189) (f6179) (let ((f6188 f6188) (f6189 f6189)) (if ((primitive-ref string=?) f6188 (symbol->string (car f6189))) (car f6189) (if (null? (cdr f6189)) (let ((f6193 (make-symbol f6188 #f))) (let ((f6195 (cons f6193 ()))) (begin (set-cdr! f6189 f6195) f6193))) ((vector-ref f6179 0) f6188 (cdr f6189))))))
# emit-closure
# si = -12
# env = ((f6179 . 0))
# expr = (closure (f6188 f6189) (f6179) (let ((f6188 f6188) (f6189 f6189)) (if ((primitive-ref string=?) f6188 (symbol->string (car f6189))) (car f6189) (if (null? (cdr f6189)) (let ((f6193 (make-symbol f6188 #f))) (let ((f6195 (cons f6193 ()))) (begin (set-cdr! f6189 f6195) f6193))) ((vector-ref f6179 0) f6188 (cdr f6189))))))
    movl $_L_37401, 0(%ebp)  # closure label
# emit-variable-ref
# env=((f6179 . 0))
# var=f6179
    movl 0(%esp), %eax  # stack load f6179
# end emit-variable-ref
   movl  %eax, 4(%ebp)  # f6179
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $8, %ebp     # bump ebp
    jmp _L_37402            # jump around closure body
_L_37401:
# check argument count
    cmp $8,%eax
    je _L_37403
# invoke error handler eh_argcount
    .extern mrc_eh$uargcount
    movl mrc_eh$uargcount, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_37403:
# emit-tail-expr
# si=-16
# env=((f6189 . -12) (f6188 . -8) (f6179 . 4) (f6179 . 0))
# expr=(let ((f6188 f6188) (f6189 f6189)) (if ((primitive-ref string=?) f6188 (symbol->string (car f6189))) (car f6189) (if (null? (cdr f6189)) (let ((f6193 (make-symbol f6188 #f))) (let ((f6195 (cons f6193 ()))) (begin (set-cdr! f6189 f6195) f6193))) ((vector-ref f6179 0) f6188 (cdr f6189)))))
# emit-tail-let
#  si   = -16
#  env  = ((f6189 . -12) (f6188 . -8) (f6179 . 4) (f6179 . 0))
#  bindings = ((f6188 f6188) (f6189 f6189))
#  body = (if ((primitive-ref string=?) f6188 (symbol->string (car f6189))) (car f6189) (if (null? (cdr f6189)) (let ((f6193 (make-symbol f6188 #f))) (let ((f6195 (cons f6193 ()))) (begin (set-cdr! f6189 f6195) f6193))) ((vector-ref f6179 0) f6188 (cdr f6189))))
# emit-expr f6188
# emit-variable-ref
# env=((f6189 . -12) (f6188 . -8) (f6179 . 4) (f6179 . 0))
# var=f6188
    movl -8(%esp), %eax  # stack load f6188
# end emit-variable-ref
    movl %eax, -16(%esp)  # stack save
# emit-expr f6189
# emit-variable-ref
# env=((f6189 . -12) (f6188 . -8) (f6179 . 4) (f6179 . 0))
# var=f6189
    movl -12(%esp), %eax  # stack load f6189
# end emit-variable-ref
    movl %eax, -20(%esp)  # stack save
# emit-tail-expr
# si=-24
# env=((f6189 . -20) (f6188 . -16) (f6189 . -12) (f6188 . -8) (f6179 . 4) (f6179 . 0))
# expr=(if ((primitive-ref string=?) f6188 (symbol->string (car f6189))) (car f6189) (if (null? (cdr f6189)) (let ((f6193 (make-symbol f6188 #f))) (let ((f6195 (cons f6193 ()))) (begin (set-cdr! f6189 f6195) f6193))) ((vector-ref f6179 0) f6188 (cdr f6189))))
# emit-expr ((primitive-ref string=?) f6188 (symbol->string (car f6189)))
# funcall
#    si   =-24
#    env  = ((f6189 . -20) (f6188 . -16) (f6189 . -12) (f6188 . -8) (f6179 . 4) (f6179 . 0))
#    expr = (funcall (primitive-ref string=?) f6188 (symbol->string (car f6189)))
# emit-expr (primitive-ref string=?)
    .extern mrc_string$e$q
    movl mrc_string$e$q,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_37406"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_37406":
   movl %eax,  -32(%esp)  # stash funcall-oper in closure slot
# emit-expr f6188
# emit-variable-ref
# env=((f6189 . -20) (f6188 . -16) (f6189 . -12) (f6188 . -8) (f6179 . 4) (f6179 . 0))
# var=f6188
    movl -16(%esp), %eax  # stack load f6188
# end emit-variable-ref
    mov %eax, -36(%esp)  # arg f6188
# emit-expr (symbol->string (car f6189))
# symbol->string (car f6189)
# emit-expr (car f6189)
# emit-expr f6189
# emit-variable-ref
# env=((f6189 . -20) (f6188 . -16) (f6189 . -12) (f6188 . -8) (f6179 . 4) (f6179 . 0))
# var=f6189
    movl -20(%esp), %eax  # stack load f6189
# end emit-variable-ref
# check the argument is a pair
    movl %eax,%ebx
    and $7, %bl
    cmp $1, %bl
    je _L_37407
# invoke error handler eh_pair
    .extern mrc_eh$upair
    movl mrc_eh$upair, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $116,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_37407:
    movl -1(%eax), %eax
    movl -3(%eax), %eax
    mov %eax, -40(%esp)  # arg (symbol->string (car f6189))
    movl -32(%esp), %edi   # load new closure to %edi
    add $-24, %esp   # adjust base
    movl $8,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $24, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    cmp $47, %al
    je _L_37404
# emit-tail-expr
# si=-24
# env=((f6189 . -20) (f6188 . -16) (f6189 . -12) (f6188 . -8) (f6179 . 4) (f6179 . 0))
# expr=(car f6189)
# tail primcall
# emit-expr f6189
# emit-variable-ref
# env=((f6189 . -20) (f6188 . -16) (f6189 . -12) (f6188 . -8) (f6179 . 4) (f6179 . 0))
# var=f6189
    movl -20(%esp), %eax  # stack load f6189
# end emit-variable-ref
# check the argument is a pair
    movl %eax,%ebx
    and $7, %bl
    cmp $1, %bl
    je _L_37408
# invoke error handler eh_pair
    .extern mrc_eh$upair
    movl mrc_eh$upair, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $116,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_37408:
    movl -1(%eax), %eax
#return from tail (car f6189)
    ret
    jmp _L_37405
_L_37404:
# emit-tail-expr
# si=-24
# env=((f6189 . -20) (f6188 . -16) (f6189 . -12) (f6188 . -8) (f6179 . 4) (f6179 . 0))
# expr=(if (null? (cdr f6189)) (let ((f6193 (make-symbol f6188 #f))) (let ((f6195 (cons f6193 ()))) (begin (set-cdr! f6189 f6195) f6193))) ((vector-ref f6179 0) f6188 (cdr f6189)))
# emit-expr (null? (cdr f6189))
# emit-expr (cdr f6189)
# emit-expr f6189
# emit-variable-ref
# env=((f6189 . -20) (f6188 . -16) (f6189 . -12) (f6188 . -8) (f6179 . 4) (f6179 . 0))
# var=f6189
    movl -20(%esp), %eax  # stack load f6189
# end emit-variable-ref
# check the argument is a pair
    movl %eax,%ebx
    and $7, %bl
    cmp $1, %bl
    je _L_37411
# invoke error handler eh_pair
    .extern mrc_eh$upair
    movl mrc_eh$upair, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $120,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_37411:
    movl 3(%eax), %eax
    cmp $63, %eax
    mov $0, %eax
    sete %al
    movzbl %al, %eax
    sal $6, %al
    or $47, %al
    cmp $47, %al
    je _L_37409
# emit-tail-expr
# si=-24
# env=((f6189 . -20) (f6188 . -16) (f6189 . -12) (f6188 . -8) (f6179 . 4) (f6179 . 0))
# expr=(let ((f6193 (make-symbol f6188 #f))) (let ((f6195 (cons f6193 ()))) (begin (set-cdr! f6189 f6195) f6193)))
# emit-tail-let
#  si   = -24
#  env  = ((f6189 . -20) (f6188 . -16) (f6189 . -12) (f6188 . -8) (f6179 . 4) (f6179 . 0))
#  bindings = ((f6193 (make-symbol f6188 #f)))
#  body = (let ((f6195 (cons f6193 ()))) (begin (set-cdr! f6189 f6195) f6193))
# emit-expr (make-symbol f6188 #f)
# make-symbol arg1=f6188 arg2=#f
# emit-expr f6188
# emit-variable-ref
# env=((f6189 . -20) (f6188 . -16) (f6189 . -12) (f6188 . -8) (f6179 . 4) (f6179 . 0))
# var=f6188
    movl -16(%esp), %eax  # stack load f6188
# end emit-variable-ref
    movl %eax, -24(%esp)
# emit-expr #f
    movl $47, %eax     # immed #f
    movl %eax, 4(%ebp)
    movl -24(%esp), %eax
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    orl  $3, %eax
    add  $8, %ebp
# make-symbol end
    movl %eax, -24(%esp)  # stack save
# emit-tail-expr
# si=-28
# env=((f6193 . -24) (f6189 . -20) (f6188 . -16) (f6189 . -12) (f6188 . -8) (f6179 . 4) (f6179 . 0))
# expr=(let ((f6195 (cons f6193 ()))) (begin (set-cdr! f6189 f6195) f6193))
# emit-tail-let
#  si   = -28
#  env  = ((f6193 . -24) (f6189 . -20) (f6188 . -16) (f6189 . -12) (f6188 . -8) (f6179 . 4) (f6179 . 0))
#  bindings = ((f6195 (cons f6193 ())))
#  body = (begin (set-cdr! f6189 f6195) f6193)
# emit-expr (cons f6193 ())
# cons arg1=f6193 arg2=()
# emit-expr f6193
# emit-variable-ref
# env=((f6193 . -24) (f6189 . -20) (f6188 . -16) (f6189 . -12) (f6188 . -8) (f6179 . 4) (f6179 . 0))
# var=f6193
    movl -24(%esp), %eax  # stack load f6193
# end emit-variable-ref
    movl %eax, -28(%esp)
# emit-expr ()
    movl $63, %eax     # immed ()
    movl %eax, 4(%ebp)
    movl -28(%esp), %eax
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    or   $1, %al
    add  $8, %ebp
# cons end
    movl %eax, -28(%esp)  # stack save
# emit-tail-expr
# si=-32
# env=((f6195 . -28) (f6193 . -24) (f6189 . -20) (f6188 . -16) (f6189 . -12) (f6188 . -8) (f6179 . 4) (f6179 . 0))
# expr=(begin (set-cdr! f6189 f6195) f6193)
# tail-begin (begin (set-cdr! f6189 f6195) f6193)
#   env=((f6195 . -28) (f6193 . -24) (f6189 . -20) (f6188 . -16) (f6189 . -12) (f6188 . -8) (f6179 . 4) (f6179 . 0))
# emit-expr (set-cdr! f6189 f6195)
# emit-expr f6189
# emit-variable-ref
# env=((f6195 . -28) (f6193 . -24) (f6189 . -20) (f6188 . -16) (f6189 . -12) (f6188 . -8) (f6179 . 4) (f6179 . 0))
# var=f6189
    movl -20(%esp), %eax  # stack load f6189
# end emit-variable-ref
# check the argument is a pair
    movl %eax,%ebx
    and $7, %bl
    cmp $1, %bl
    je _L_37412
# invoke error handler eh_pair
    .extern mrc_eh$upair
    movl mrc_eh$upair, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $128,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_37412:
    movl %eax, -32(%esp)
# emit-expr f6195
# emit-variable-ref
# env=((f6195 . -28) (f6193 . -24) (f6189 . -20) (f6188 . -16) (f6189 . -12) (f6188 . -8) (f6179 . 4) (f6179 . 0))
# var=f6195
    movl -28(%esp), %eax  # stack load f6195
# end emit-variable-ref
    movl -32(%esp), %ebx
    movl %eax, 3(%ebx)
# emit-tail-expr
# si=-32
# env=((f6195 . -28) (f6193 . -24) (f6189 . -20) (f6188 . -16) (f6189 . -12) (f6188 . -8) (f6179 . 4) (f6179 . 0))
# expr=(begin f6193)
# tail-begin (begin f6193)
#   env=((f6195 . -28) (f6193 . -24) (f6189 . -20) (f6188 . -16) (f6189 . -12) (f6188 . -8) (f6179 . 4) (f6179 . 0))
# emit-tail-expr
# si=-32
# env=((f6195 . -28) (f6193 . -24) (f6189 . -20) (f6188 . -16) (f6189 . -12) (f6188 . -8) (f6179 . 4) (f6179 . 0))
# expr=f6193
# emit-tail-variable-ref
# emit-variable-ref
# env=((f6195 . -28) (f6193 . -24) (f6189 . -20) (f6188 . -16) (f6189 . -12) (f6188 . -8) (f6179 . 4) (f6179 . 0))
# var=f6193
    movl -24(%esp), %eax  # stack load f6193
# end emit-variable-ref
    ret
# end emit-tail-variable ref
     ret   # return thru stack
    jmp _L_37410
_L_37409:
# emit-tail-expr
# si=-24
# env=((f6189 . -20) (f6188 . -16) (f6189 . -12) (f6188 . -8) (f6179 . 4) (f6179 . 0))
# expr=((vector-ref f6179 0) f6188 (cdr f6189))
# emit-tail-funcall
#    si   =-24
#    env  = ((f6189 . -20) (f6188 . -16) (f6189 . -12) (f6188 . -8) (f6179 . 4) (f6179 . 0))
#    expr = (funcall (vector-ref f6179 0) f6188 (cdr f6189))
# emit-expr (vector-ref f6179 0)
# emit-expr f6179
# emit-variable-ref
# env=((f6189 . -20) (f6188 . -16) (f6189 . -12) (f6188 . -8) (f6179 . 4) (f6179 . 0))
# var=f6179
    movl 2(%edi), %eax  # frame load f6179
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_37413
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_37413:
    movl %eax, -24(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_37414"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_37414:
# check bounds on vector index
    movl -24(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_37416
    cmp  $0,%eax
    jge _L_37415
_L_37416:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_37415:
    movl -24(%esp), %esi
    movl -1(%eax,%esi), %eax
   movl %eax,  -24(%esp)  # stash funcall-oper in next closure slot
# emit-expr f6188
# emit-variable-ref
# env=((f6189 . -20) (f6188 . -16) (f6189 . -12) (f6188 . -8) (f6179 . 4) (f6179 . 0))
# var=f6188
    movl -16(%esp), %eax  # stack load f6188
# end emit-variable-ref
    mov %eax, -28(%esp)    # arg f6188
# emit-expr (cdr f6189)
# emit-expr f6189
# emit-variable-ref
# env=((f6189 . -20) (f6188 . -16) (f6189 . -12) (f6188 . -8) (f6179 . 4) (f6179 . 0))
# var=f6189
    movl -20(%esp), %eax  # stack load f6189
# end emit-variable-ref
# check the argument is a pair
    movl %eax,%ebx
    and $7, %bl
    cmp $1, %bl
    je _L_37417
# invoke error handler eh_pair
    .extern mrc_eh$upair
    movl mrc_eh$upair, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $120,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_37417:
    movl 3(%eax), %eax
    mov %eax, -32(%esp)    # arg (cdr f6189)
    movl -24(%esp), %edi   # load new closure to %edi
# emit-shift-args:  size=3   si=-24  delta=20
    mov -24(%esp), %ebx  # shift frame cell
    mov %ebx, -4(%esp)  # down to base
# emit-shift-args:  size=2   si=-28  delta=20
    mov -28(%esp), %ebx  # shift frame cell
    mov %ebx, -8(%esp)  # down to base
# emit-shift-args:  size=1   si=-32  delta=20
    mov -32(%esp), %ebx  # shift frame cell
    mov %ebx, -12(%esp)  # down to base
# emit-shift-args:  size=0   si=-36  delta=20
    movl $8,%eax   # save arg count
    jmp *-2(%edi)  # tail-funcall
_L_37410:
_L_37405:
    .align 4,0x90
_L_37402:
    movl -4(%esp), %ebx
    movl -8(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin)
# emit-begin
#   expr=(begin)
#   env=((f6179 . 0))
# emit-expr (begin (closure (f6197) (f6179) (let ((f6197 f6197)) ((vector-ref f6179 0) f6197 ((primitive-ref symbols))))))
# emit-begin
#   expr=(begin (closure (f6197) (f6179) (let ((f6197 f6197)) ((vector-ref f6179 0) f6197 ((primitive-ref symbols))))))
#   env=((f6179 . 0))
# emit-expr (closure (f6197) (f6179) (let ((f6197 f6197)) ((vector-ref f6179 0) f6197 ((primitive-ref symbols)))))
# emit-closure
# si = -4
# env = ((f6179 . 0))
# expr = (closure (f6197) (f6179) (let ((f6197 f6197)) ((vector-ref f6179 0) f6197 ((primitive-ref symbols)))))
    movl $_L_37418, 0(%ebp)  # closure label
# emit-variable-ref
# env=((f6179 . 0))
# var=f6179
    movl 0(%esp), %eax  # stack load f6179
# end emit-variable-ref
   movl  %eax, 4(%ebp)  # f6179
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $8, %ebp     # bump ebp
    jmp _L_37419            # jump around closure body
_L_37418:
# check argument count
    cmp $4,%eax
    je _L_37420
# invoke error handler eh_argcount
    .extern mrc_eh$uargcount
    movl mrc_eh$uargcount, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_37420:
# emit-tail-expr
# si=-12
# env=((f6197 . -8) (f6179 . 4) (f6179 . 0))
# expr=(let ((f6197 f6197)) ((vector-ref f6179 0) f6197 ((primitive-ref symbols))))
# emit-tail-let
#  si   = -12
#  env  = ((f6197 . -8) (f6179 . 4) (f6179 . 0))
#  bindings = ((f6197 f6197))
#  body = ((vector-ref f6179 0) f6197 ((primitive-ref symbols)))
# emit-expr f6197
# emit-variable-ref
# env=((f6197 . -8) (f6179 . 4) (f6179 . 0))
# var=f6197
    movl -8(%esp), %eax  # stack load f6197
# end emit-variable-ref
    movl %eax, -12(%esp)  # stack save
# emit-tail-expr
# si=-16
# env=((f6197 . -12) (f6197 . -8) (f6179 . 4) (f6179 . 0))
# expr=((vector-ref f6179 0) f6197 ((primitive-ref symbols)))
# emit-tail-funcall
#    si   =-16
#    env  = ((f6197 . -12) (f6197 . -8) (f6179 . 4) (f6179 . 0))
#    expr = (funcall (vector-ref f6179 0) f6197 ((primitive-ref symbols)))
# emit-expr (vector-ref f6179 0)
# emit-expr f6179
# emit-variable-ref
# env=((f6197 . -12) (f6197 . -8) (f6179 . 4) (f6179 . 0))
# var=f6179
    movl 2(%edi), %eax  # frame load f6179
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_37421
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_37421:
    movl %eax, -16(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_37422"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_37422:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_37424
    cmp  $0,%eax
    jge _L_37423
_L_37424:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_37423:
    movl -16(%esp), %esi
    movl -1(%eax,%esi), %eax
   movl %eax,  -16(%esp)  # stash funcall-oper in next closure slot
# emit-expr f6197
# emit-variable-ref
# env=((f6197 . -12) (f6197 . -8) (f6179 . 4) (f6179 . 0))
# var=f6197
    movl -12(%esp), %eax  # stack load f6197
# end emit-variable-ref
    mov %eax, -20(%esp)    # arg f6197
# emit-expr ((primitive-ref symbols))
# funcall
#    si   =-24
#    env  = ((f6197 . -12) (f6197 . -8) (f6179 . 4) (f6179 . 0))
#    expr = (funcall (primitive-ref symbols))
# emit-expr (primitive-ref symbols)
    .extern mrc_symbols
    movl mrc_symbols,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_37425"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_37425":
   movl %eax,  -32(%esp)  # stash funcall-oper in closure slot
    movl -32(%esp), %edi   # load new closure to %edi
    add $-24, %esp   # adjust base
    movl $0,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $24, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    mov %eax, -24(%esp)    # arg ((primitive-ref symbols))
    movl -16(%esp), %edi   # load new closure to %edi
# emit-shift-args:  size=3   si=-16  delta=12
    mov -16(%esp), %ebx  # shift frame cell
    mov %ebx, -4(%esp)  # down to base
# emit-shift-args:  size=2   si=-20  delta=12
    mov -20(%esp), %ebx  # shift frame cell
    mov %ebx, -8(%esp)  # down to base
# emit-shift-args:  size=1   si=-24  delta=12
    mov -24(%esp), %ebx  # shift frame cell
    mov %ebx, -12(%esp)  # down to base
# emit-shift-args:  size=0   si=-28  delta=12
    movl $8,%eax   # save arg count
    jmp *-2(%edi)  # tail-funcall
    .align 4,0x90
_L_37419:
# emit-expr (begin)
# emit-begin
#   expr=(begin)
#   env=((f6179 . 0))
     movl %eax, mrc_string$m$gsymbol
# == explicit-begins  ==>
# (lambda (lst elt) (if (null? lst) (cons elt nil) (cons (car lst) (append1 (cdr lst) elt))))
# == eliminate-let*  ==>
# (lambda (lst elt) (if (null? lst) (cons elt nil) (cons (car lst) (append1 (cdr lst) elt))))
# == uniquify-variables  ==>
# (lambda (f6198 f6199) (if (null? f6198) (cons f6199 nil) (cons (car f6198) (append1 (cdr f6198) f6199))))
# == vectorize-letrec  ==>
# (lambda (f6198 f6199) (if (null? f6198) (cons f6199 nil) (cons (car f6198) (append1 (cdr f6198) f6199))))
# == eliminate-set!  ==>
# (lambda (f6198 f6199) (let ((f6198 f6198) (f6199 f6199)) (if (null? f6198) (cons f6199 nil) (cons (car f6198) (append1 (cdr f6198) f6199)))))
# == close-free-variables  ==>
# (closure (f6198 f6199) (nil) (let ((f6198 f6198) (f6199 f6199)) (if (null? f6198) (cons f6199 nil) (cons (car f6198) (append1 (cdr f6198) f6199)))))
# == eliminate-quote  ==>
# (closure (f6198 f6199) (nil) (let ((f6198 f6198) (f6199 f6199)) (if (null? f6198) (cons f6199 nil) (cons (car f6198) (append1 (cdr f6198) f6199)))))
# == eliminate-when/unless  ==>
# (closure (f6198 f6199) (nil) (let ((f6198 f6198) (f6199 f6199)) (if (null? f6198) (cons f6199 nil) (cons (car f6198) (append1 (cdr f6198) f6199)))))
# == eliminate-cond  ==>
# (closure (f6198 f6199) (nil) (let ((f6198 f6198) (f6199 f6199)) (if (null? f6198) (cons f6199 nil) (cons (car f6198) (append1 (cdr f6198) f6199)))))
# == external-symbols  ==>
# (closure (f6198 f6199) (nil) (let ((f6198 f6198) (f6199 f6199)) (if (null? f6198) (cons f6199 nil) (cons (car f6198) ((primitive-ref append1) (cdr f6198) f6199)))))
# emit-expr (closure (f6198 f6199) (nil) (let ((f6198 f6198) (f6199 f6199)) (if (null? f6198) (cons f6199 nil) (cons (car f6198) ((primitive-ref append1) (cdr f6198) f6199)))))
# emit-closure
# si = 0
# env = ()
# expr = (closure (f6198 f6199) (nil) (let ((f6198 f6198) (f6199 f6199)) (if (null? f6198) (cons f6199 nil) (cons (car f6198) ((primitive-ref append1) (cdr f6198) f6199)))))
    movl $_L_37426, 0(%ebp)  # closure label
# WARNING: free var nil not defined in the environmnet
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $8, %ebp     # bump ebp
    jmp _L_37427            # jump around closure body
_L_37426:
# check argument count
    cmp $8,%eax
    je _L_37428
# invoke error handler eh_argcount
    .extern mrc_eh$uargcount
    movl mrc_eh$uargcount, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_37428:
# emit-tail-expr
# si=-16
# env=((f6199 . -12) (f6198 . -8) (nil . 4))
# expr=(let ((f6198 f6198) (f6199 f6199)) (if (null? f6198) (cons f6199 nil) (cons (car f6198) ((primitive-ref append1) (cdr f6198) f6199))))
# emit-tail-let
#  si   = -16
#  env  = ((f6199 . -12) (f6198 . -8) (nil . 4))
#  bindings = ((f6198 f6198) (f6199 f6199))
#  body = (if (null? f6198) (cons f6199 nil) (cons (car f6198) ((primitive-ref append1) (cdr f6198) f6199)))
# emit-expr f6198
# emit-variable-ref
# env=((f6199 . -12) (f6198 . -8) (nil . 4))
# var=f6198
    movl -8(%esp), %eax  # stack load f6198
# end emit-variable-ref
    movl %eax, -16(%esp)  # stack save
# emit-expr f6199
# emit-variable-ref
# env=((f6199 . -12) (f6198 . -8) (nil . 4))
# var=f6199
    movl -12(%esp), %eax  # stack load f6199
# end emit-variable-ref
    movl %eax, -20(%esp)  # stack save
# emit-tail-expr
# si=-24
# env=((f6199 . -20) (f6198 . -16) (f6199 . -12) (f6198 . -8) (nil . 4))
# expr=(if (null? f6198) (cons f6199 nil) (cons (car f6198) ((primitive-ref append1) (cdr f6198) f6199)))
# emit-expr (null? f6198)
# emit-expr f6198
# emit-variable-ref
# env=((f6199 . -20) (f6198 . -16) (f6199 . -12) (f6198 . -8) (nil . 4))
# var=f6198
    movl -16(%esp), %eax  # stack load f6198
# end emit-variable-ref
    cmp $63, %eax
    mov $0, %eax
    sete %al
    movzbl %al, %eax
    sal $6, %al
    or $47, %al
    cmp $47, %al
    je _L_37429
# emit-tail-expr
# si=-24
# env=((f6199 . -20) (f6198 . -16) (f6199 . -12) (f6198 . -8) (nil . 4))
# expr=(cons f6199 nil)
# tail primcall
# cons arg1=f6199 arg2=nil
# emit-expr f6199
# emit-variable-ref
# env=((f6199 . -20) (f6198 . -16) (f6199 . -12) (f6198 . -8) (nil . 4))
# var=f6199
    movl -20(%esp), %eax  # stack load f6199
# end emit-variable-ref
    movl %eax, -24(%esp)
# emit-expr nil
# emit-variable-ref
# env=((f6199 . -20) (f6198 . -16) (f6199 . -12) (f6198 . -8) (nil . 4))
# var=nil
    movl 2(%edi), %eax  # frame load nil
# end emit-variable-ref
    movl %eax, 4(%ebp)
    movl -24(%esp), %eax
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    or   $1, %al
    add  $8, %ebp
# cons end
#return from tail (cons f6199 nil)
    ret
    jmp _L_37430
_L_37429:
# emit-tail-expr
# si=-24
# env=((f6199 . -20) (f6198 . -16) (f6199 . -12) (f6198 . -8) (nil . 4))
# expr=(cons (car f6198) ((primitive-ref append1) (cdr f6198) f6199))
# tail primcall
# cons arg1=(car f6198) arg2=((primitive-ref append1) (cdr f6198) f6199)
# emit-expr (car f6198)
# emit-expr f6198
# emit-variable-ref
# env=((f6199 . -20) (f6198 . -16) (f6199 . -12) (f6198 . -8) (nil . 4))
# var=f6198
    movl -16(%esp), %eax  # stack load f6198
# end emit-variable-ref
# check the argument is a pair
    movl %eax,%ebx
    and $7, %bl
    cmp $1, %bl
    je _L_37431
# invoke error handler eh_pair
    .extern mrc_eh$upair
    movl mrc_eh$upair, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $116,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_37431:
    movl -1(%eax), %eax
    movl %eax, -24(%esp)
# emit-expr ((primitive-ref append1) (cdr f6198) f6199)
# funcall
#    si   =-28
#    env  = ((f6199 . -20) (f6198 . -16) (f6199 . -12) (f6198 . -8) (nil . 4))
#    expr = (funcall (primitive-ref append1) (cdr f6198) f6199)
# emit-expr (primitive-ref append1)
    .extern mrc_append1
    movl mrc_append1,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_37432"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_37432":
   movl %eax,  -36(%esp)  # stash funcall-oper in closure slot
# emit-expr (cdr f6198)
# emit-expr f6198
# emit-variable-ref
# env=((f6199 . -20) (f6198 . -16) (f6199 . -12) (f6198 . -8) (nil . 4))
# var=f6198
    movl -16(%esp), %eax  # stack load f6198
# end emit-variable-ref
# check the argument is a pair
    movl %eax,%ebx
    and $7, %bl
    cmp $1, %bl
    je _L_37433
# invoke error handler eh_pair
    .extern mrc_eh$upair
    movl mrc_eh$upair, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $120,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_37433:
    movl 3(%eax), %eax
    mov %eax, -40(%esp)  # arg (cdr f6198)
# emit-expr f6199
# emit-variable-ref
# env=((f6199 . -20) (f6198 . -16) (f6199 . -12) (f6198 . -8) (nil . 4))
# var=f6199
    movl -20(%esp), %eax  # stack load f6199
# end emit-variable-ref
    mov %eax, -44(%esp)  # arg f6199
    movl -36(%esp), %edi   # load new closure to %edi
    add $-28, %esp   # adjust base
    movl $8,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $28, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    movl %eax, 4(%ebp)
    movl -24(%esp), %eax
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    or   $1, %al
    add  $8, %ebp
# cons end
#return from tail (cons (car f6198) ((primitive-ref append1) (cdr f6198) f6199))
    ret
_L_37430:
    .align 4,0x90
_L_37427:
     movl %eax, mrc_append1
# == explicit-begins  ==>
# (lambda (l k) (if (fx= k 0) (car l) (list-ref (cdr l) (fx- k 1))))
# == eliminate-let*  ==>
# (lambda (l k) (if (fx= k 0) (car l) (list-ref (cdr l) (fx- k 1))))
# == uniquify-variables  ==>
# (lambda (f6200 f6201) (if (fx= f6201 0) (car f6200) (list-ref (cdr f6200) (fx- f6201 1))))
# == vectorize-letrec  ==>
# (lambda (f6200 f6201) (if (fx= f6201 0) (car f6200) (list-ref (cdr f6200) (fx- f6201 1))))
# == eliminate-set!  ==>
# (lambda (f6200 f6201) (let ((f6200 f6200) (f6201 f6201)) (if (fx= f6201 0) (car f6200) (list-ref (cdr f6200) (fx- f6201 1)))))
# == close-free-variables  ==>
# (closure (f6200 f6201) () (let ((f6200 f6200) (f6201 f6201)) (if (fx= f6201 0) (car f6200) (list-ref (cdr f6200) (fx- f6201 1)))))
# == eliminate-quote  ==>
# (closure (f6200 f6201) () (let ((f6200 f6200) (f6201 f6201)) (if (fx= f6201 0) (car f6200) (list-ref (cdr f6200) (fx- f6201 1)))))
# == eliminate-when/unless  ==>
# (closure (f6200 f6201) () (let ((f6200 f6200) (f6201 f6201)) (if (fx= f6201 0) (car f6200) (list-ref (cdr f6200) (fx- f6201 1)))))
# == eliminate-cond  ==>
# (closure (f6200 f6201) () (let ((f6200 f6200) (f6201 f6201)) (if (fx= f6201 0) (car f6200) (list-ref (cdr f6200) (fx- f6201 1)))))
# == external-symbols  ==>
# (closure (f6200 f6201) () (let ((f6200 f6200) (f6201 f6201)) (if (fx= f6201 0) (car f6200) ((primitive-ref list-ref) (cdr f6200) (fx- f6201 1)))))
# emit-expr (closure (f6200 f6201) () (let ((f6200 f6200) (f6201 f6201)) (if (fx= f6201 0) (car f6200) ((primitive-ref list-ref) (cdr f6200) (fx- f6201 1)))))
# emit-closure
# si = 0
# env = ()
# expr = (closure (f6200 f6201) () (let ((f6200 f6200) (f6201 f6201)) (if (fx= f6201 0) (car f6200) ((primitive-ref list-ref) (cdr f6200) (fx- f6201 1)))))
    movl $_L_37434, 0(%ebp)  # closure label
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $8, %ebp     # bump ebp
    jmp _L_37435            # jump around closure body
_L_37434:
# check argument count
    cmp $8,%eax
    je _L_37436
# invoke error handler eh_argcount
    .extern mrc_eh$uargcount
    movl mrc_eh$uargcount, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_37436:
# emit-tail-expr
# si=-16
# env=((f6201 . -12) (f6200 . -8))
# expr=(let ((f6200 f6200) (f6201 f6201)) (if (fx= f6201 0) (car f6200) ((primitive-ref list-ref) (cdr f6200) (fx- f6201 1))))
# emit-tail-let
#  si   = -16
#  env  = ((f6201 . -12) (f6200 . -8))
#  bindings = ((f6200 f6200) (f6201 f6201))
#  body = (if (fx= f6201 0) (car f6200) ((primitive-ref list-ref) (cdr f6200) (fx- f6201 1)))
# emit-expr f6200
# emit-variable-ref
# env=((f6201 . -12) (f6200 . -8))
# var=f6200
    movl -8(%esp), %eax  # stack load f6200
# end emit-variable-ref
    movl %eax, -16(%esp)  # stack save
# emit-expr f6201
# emit-variable-ref
# env=((f6201 . -12) (f6200 . -8))
# var=f6201
    movl -12(%esp), %eax  # stack load f6201
# end emit-variable-ref
    movl %eax, -20(%esp)  # stack save
# emit-tail-expr
# si=-24
# env=((f6201 . -20) (f6200 . -16) (f6201 . -12) (f6200 . -8))
# expr=(if (fx= f6201 0) (car f6200) ((primitive-ref list-ref) (cdr f6200) (fx- f6201 1)))
# emit-expr (fx= f6201 0)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_37439"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $68,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_37439:
    movl %eax, -24(%esp)
# emit-expr f6201
# emit-variable-ref
# env=((f6201 . -20) (f6200 . -16) (f6201 . -12) (f6200 . -8))
# var=f6201
    movl -20(%esp), %eax  # stack load f6201
# end emit-variable-ref
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_37440"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $68,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_37440:
    cmp -24(%esp), %eax
    sete %al
    movzbl %al, %eax
    sal $6, %al
    or $47, %al
    cmp $47, %al
    je _L_37437
# emit-tail-expr
# si=-24
# env=((f6201 . -20) (f6200 . -16) (f6201 . -12) (f6200 . -8))
# expr=(car f6200)
# tail primcall
# emit-expr f6200
# emit-variable-ref
# env=((f6201 . -20) (f6200 . -16) (f6201 . -12) (f6200 . -8))
# var=f6200
    movl -16(%esp), %eax  # stack load f6200
# end emit-variable-ref
# check the argument is a pair
    movl %eax,%ebx
    and $7, %bl
    cmp $1, %bl
    je _L_37441
# invoke error handler eh_pair
    .extern mrc_eh$upair
    movl mrc_eh$upair, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $116,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_37441:
    movl -1(%eax), %eax
#return from tail (car f6200)
    ret
    jmp _L_37438
_L_37437:
# emit-tail-expr
# si=-24
# env=((f6201 . -20) (f6200 . -16) (f6201 . -12) (f6200 . -8))
# expr=((primitive-ref list-ref) (cdr f6200) (fx- f6201 1))
# emit-tail-funcall
#    si   =-24
#    env  = ((f6201 . -20) (f6200 . -16) (f6201 . -12) (f6200 . -8))
#    expr = (funcall (primitive-ref list-ref) (cdr f6200) (fx- f6201 1))
# emit-expr (primitive-ref list-ref)
    .extern mrc_list$mref
    movl mrc_list$mref,%eax
   movl %eax,  -24(%esp)  # stash funcall-oper in next closure slot
# emit-expr (cdr f6200)
# emit-expr f6200
# emit-variable-ref
# env=((f6201 . -20) (f6200 . -16) (f6201 . -12) (f6200 . -8))
# var=f6200
    movl -16(%esp), %eax  # stack load f6200
# end emit-variable-ref
# check the argument is a pair
    movl %eax,%ebx
    and $7, %bl
    cmp $1, %bl
    je _L_37442
# invoke error handler eh_pair
    .extern mrc_eh$upair
    movl mrc_eh$upair, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $120,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_37442:
    movl 3(%eax), %eax
    mov %eax, -28(%esp)    # arg (cdr f6200)
# emit-expr (fx- f6201 1)
# emit-expr 1
    movl $4, %eax     # immed 1
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_37443"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $92,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_37443:
    movl %eax, -32(%esp)
# emit-expr f6201
# emit-variable-ref
# env=((f6201 . -20) (f6200 . -16) (f6201 . -12) (f6200 . -8))
# var=f6201
    movl -20(%esp), %eax  # stack load f6201
# end emit-variable-ref
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_37444"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $92,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_37444:
    subl -32(%esp), %eax
    mov %eax, -32(%esp)    # arg (fx- f6201 1)
    movl -24(%esp), %edi   # load new closure to %edi
# emit-shift-args:  size=3   si=-24  delta=20
    mov -24(%esp), %ebx  # shift frame cell
    mov %ebx, -4(%esp)  # down to base
# emit-shift-args:  size=2   si=-28  delta=20
    mov -28(%esp), %ebx  # shift frame cell
    mov %ebx, -8(%esp)  # down to base
# emit-shift-args:  size=1   si=-32  delta=20
    mov -32(%esp), %ebx  # shift frame cell
    mov %ebx, -12(%esp)  # down to base
# emit-shift-args:  size=0   si=-36  delta=20
    movl $8,%eax   # save arg count
    jmp *-2(%edi)  # tail-funcall
_L_37438:
    .align 4,0x90
_L_37435:
     movl %eax, mrc_list$mref
# == explicit-begins  ==>
# (lambda (l) (if (null? l) 0 (fxadd1 (list-length (cdr l)))))
# == eliminate-let*  ==>
# (lambda (l) (if (null? l) 0 (fxadd1 (list-length (cdr l)))))
# == uniquify-variables  ==>
# (lambda (f6202) (if (null? f6202) 0 (fxadd1 (list-length (cdr f6202)))))
# == vectorize-letrec  ==>
# (lambda (f6202) (if (null? f6202) 0 (fxadd1 (list-length (cdr f6202)))))
# == eliminate-set!  ==>
# (lambda (f6202) (let ((f6202 f6202)) (if (null? f6202) 0 (fxadd1 (list-length (cdr f6202))))))
# == close-free-variables  ==>
# (closure (f6202) () (let ((f6202 f6202)) (if (null? f6202) 0 (fxadd1 (list-length (cdr f6202))))))
# == eliminate-quote  ==>
# (closure (f6202) () (let ((f6202 f6202)) (if (null? f6202) 0 (fxadd1 (list-length (cdr f6202))))))
# == eliminate-when/unless  ==>
# (closure (f6202) () (let ((f6202 f6202)) (if (null? f6202) 0 (fxadd1 (list-length (cdr f6202))))))
# == eliminate-cond  ==>
# (closure (f6202) () (let ((f6202 f6202)) (if (null? f6202) 0 (fxadd1 (list-length (cdr f6202))))))
# == external-symbols  ==>
# (closure (f6202) () (let ((f6202 f6202)) (if (null? f6202) 0 (fxadd1 ((primitive-ref list-length) (cdr f6202))))))
# emit-expr (closure (f6202) () (let ((f6202 f6202)) (if (null? f6202) 0 (fxadd1 ((primitive-ref list-length) (cdr f6202))))))
# emit-closure
# si = 0
# env = ()
# expr = (closure (f6202) () (let ((f6202 f6202)) (if (null? f6202) 0 (fxadd1 ((primitive-ref list-length) (cdr f6202))))))
    movl $_L_37445, 0(%ebp)  # closure label
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $8, %ebp     # bump ebp
    jmp _L_37446            # jump around closure body
_L_37445:
# check argument count
    cmp $4,%eax
    je _L_37447
# invoke error handler eh_argcount
    .extern mrc_eh$uargcount
    movl mrc_eh$uargcount, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_37447:
# emit-tail-expr
# si=-12
# env=((f6202 . -8))
# expr=(let ((f6202 f6202)) (if (null? f6202) 0 (fxadd1 ((primitive-ref list-length) (cdr f6202)))))
# emit-tail-let
#  si   = -12
#  env  = ((f6202 . -8))
#  bindings = ((f6202 f6202))
#  body = (if (null? f6202) 0 (fxadd1 ((primitive-ref list-length) (cdr f6202))))
# emit-expr f6202
# emit-variable-ref
# env=((f6202 . -8))
# var=f6202
    movl -8(%esp), %eax  # stack load f6202
# end emit-variable-ref
    movl %eax, -12(%esp)  # stack save
# emit-tail-expr
# si=-16
# env=((f6202 . -12) (f6202 . -8))
# expr=(if (null? f6202) 0 (fxadd1 ((primitive-ref list-length) (cdr f6202))))
# emit-expr (null? f6202)
# emit-expr f6202
# emit-variable-ref
# env=((f6202 . -12) (f6202 . -8))
# var=f6202
    movl -12(%esp), %eax  # stack load f6202
# end emit-variable-ref
    cmp $63, %eax
    mov $0, %eax
    sete %al
    movzbl %al, %eax
    sal $6, %al
    or $47, %al
    cmp $47, %al
    je _L_37448
# emit-tail-expr
# si=-16
# env=((f6202 . -12) (f6202 . -8))
# expr=0
    movl $0, %eax     # immed 0
    ret                  # immediate tail return
    jmp _L_37449
_L_37448:
# emit-tail-expr
# si=-16
# env=((f6202 . -12) (f6202 . -8))
# expr=(fxadd1 ((primitive-ref list-length) (cdr f6202)))
# tail primcall
# emit-expr ((primitive-ref list-length) (cdr f6202))
# funcall
#    si   =-16
#    env  = ((f6202 . -12) (f6202 . -8))
#    expr = (funcall (primitive-ref list-length) (cdr f6202))
# emit-expr (primitive-ref list-length)
    .extern mrc_list$mlength
    movl mrc_list$mlength,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_37450"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_37450":
   movl %eax,  -24(%esp)  # stash funcall-oper in closure slot
# emit-expr (cdr f6202)
# emit-expr f6202
# emit-variable-ref
# env=((f6202 . -12) (f6202 . -8))
# var=f6202
    movl -12(%esp), %eax  # stack load f6202
# end emit-variable-ref
# check the argument is a pair
    movl %eax,%ebx
    and $7, %bl
    cmp $1, %bl
    je _L_37451
# invoke error handler eh_pair
    .extern mrc_eh$upair
    movl mrc_eh$upair, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $120,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_37451:
    movl 3(%eax), %eax
    mov %eax, -28(%esp)  # arg (cdr f6202)
    movl -24(%esp), %edi   # load new closure to %edi
    add $-16, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $16, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_37452"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $56,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_37452:
     addl $4, %eax
#return from tail (fxadd1 ((primitive-ref list-length) (cdr f6202)))
    ret
_L_37449:
    .align 4,0x90
_L_37446:
     movl %eax, mrc_list$mlength
# == explicit-begins  ==>
# (letrec ((f (lambda (l lrev) (if (null? l) lrev (f (cdr l) (cons (car l) lrev)))))) (lambda (l) (f l (quote ()))))
# == eliminate-let*  ==>
# (letrec ((f (lambda (l lrev) (if (null? l) lrev (f (cdr l) (cons (car l) lrev)))))) (lambda (l) (f l (quote ()))))
# == uniquify-variables  ==>
# (letrec ((f6203 (lambda (f6206 f6207) (if (null? f6206) f6207 (f6203 (cdr f6206) (cons (car f6206) f6207)))))) (lambda (f6209) (f6203 f6209 (quote ()))))
# == vectorize-letrec  ==>
# (let ((f6203 (make-vector 1))) (begin (begin (vector-set! f6203 0 (lambda (f6206 f6207) (if (null? f6206) f6207 ((vector-ref f6203 0) (cdr f6206) (cons (car f6206) f6207)))))) (lambda (f6209) ((vector-ref f6203 0) f6209 (quote ())))))
# == eliminate-set!  ==>
# (let ((f6203 (make-vector 1))) (begin (begin (vector-set! f6203 0 (lambda (f6206 f6207) (let ((f6206 f6206) (f6207 f6207)) (if (null? f6206) f6207 ((vector-ref f6203 0) (cdr f6206) (cons (car f6206) f6207))))))) (lambda (f6209) (let ((f6209 f6209)) ((vector-ref f6203 0) f6209 (quote ()))))))
# == close-free-variables  ==>
# (let ((f6203 (make-vector 1))) (begin (begin (vector-set! f6203 0 (closure (f6206 f6207) (f6203) (let ((f6206 f6206) (f6207 f6207)) (if (null? f6206) f6207 ((vector-ref f6203 0) (cdr f6206) (cons (car f6206) f6207))))))) (closure (f6209) (f6203) (let ((f6209 f6209)) ((vector-ref f6203 0) f6209 (quote ()))))))
# == eliminate-quote  ==>
# (let ((f6203 (make-vector 1))) (begin (begin (vector-set! f6203 0 (closure (f6206 f6207) (f6203) (let ((f6206 f6206) (f6207 f6207)) (if (null? f6206) f6207 ((vector-ref f6203 0) (cdr f6206) (cons (car f6206) f6207))))))) (closure (f6209) (f6203) (let ((f6209 f6209)) ((vector-ref f6203 0) f6209 ())))))
# == eliminate-when/unless  ==>
# (let ((f6203 (make-vector 1))) (begin (begin (vector-set! f6203 0 (closure (f6206 f6207) (f6203) (let ((f6206 f6206) (f6207 f6207)) (if (null? f6206) f6207 ((vector-ref f6203 0) (cdr f6206) (cons (car f6206) f6207))))))) (closure (f6209) (f6203) (let ((f6209 f6209)) ((vector-ref f6203 0) f6209 ())))))
# == eliminate-cond  ==>
# (let ((f6203 (make-vector 1))) (begin (begin (vector-set! f6203 0 (closure (f6206 f6207) (f6203) (let ((f6206 f6206) (f6207 f6207)) (if (null? f6206) f6207 ((vector-ref f6203 0) (cdr f6206) (cons (car f6206) f6207))))))) (closure (f6209) (f6203) (let ((f6209 f6209)) ((vector-ref f6203 0) f6209 ())))))
# == external-symbols  ==>
# (let ((f6203 (make-vector 1))) (begin (begin (vector-set! f6203 0 (closure (f6206 f6207) (f6203) (let ((f6206 f6206) (f6207 f6207)) (if (null? f6206) f6207 ((vector-ref f6203 0) (cdr f6206) (cons (car f6206) f6207))))))) (closure (f6209) (f6203) (let ((f6209 f6209)) ((vector-ref f6203 0) f6209 ())))))
# emit-expr (let ((f6203 (make-vector 1))) (begin (begin (vector-set! f6203 0 (closure (f6206 f6207) (f6203) (let ((f6206 f6206) (f6207 f6207)) (if (null? f6206) f6207 ((vector-ref f6203 0) (cdr f6206) (cons (car f6206) f6207))))))) (closure (f6209) (f6203) (let ((f6209 f6209)) ((vector-ref f6203 0) f6209 ())))))
# emit-let
#  si   = 0
#  env  = ()
#  bindings = ((f6203 (make-vector 1)))
#  body = (begin (begin (vector-set! f6203 0 (closure (f6206 f6207) (f6203) (let ((f6206 f6206) (f6207 f6207)) (if (null? f6206) f6207 ((vector-ref f6203 0) (cdr f6206) (cons (car f6206) f6207))))))) (closure (f6209) (f6203) (let ((f6209 f6209)) ((vector-ref f6203 0) f6209 ()))))
# emit-expr (make-vector 1)
# make-vector 1
# emit-expr 1
    movl $4, %eax     # immed 1
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_37453"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_37453:
# check the argument is a fixnum >= 0
    cmp $0,%eax
    jge _L_37454
# invoke error handler eh_length
    .extern mrc_eh$ulength
    movl mrc_eh$ulength, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_37454:
    movl %eax, %esi
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    orl  $5, %eax
    addl $4, %esi
    addl $4, %esi
    andl $-8, %esi
    addl %esi, %ebp
    movl %eax, 0(%esp)  # stack save
# emit-expr (begin (begin (vector-set! f6203 0 (closure (f6206 f6207) (f6203) (let ((f6206 f6206) (f6207 f6207)) (if (null? f6206) f6207 ((vector-ref f6203 0) (cdr f6206) (cons (car f6206) f6207))))))) (closure (f6209) (f6203) (let ((f6209 f6209)) ((vector-ref f6203 0) f6209 ()))))
# emit-begin
#   expr=(begin (begin (vector-set! f6203 0 (closure (f6206 f6207) (f6203) (let ((f6206 f6206) (f6207 f6207)) (if (null? f6206) f6207 ((vector-ref f6203 0) (cdr f6206) (cons (car f6206) f6207))))))) (closure (f6209) (f6203) (let ((f6209 f6209)) ((vector-ref f6203 0) f6209 ()))))
#   env=((f6203 . 0))
# emit-expr (begin (vector-set! f6203 0 (closure (f6206 f6207) (f6203) (let ((f6206 f6206) (f6207 f6207)) (if (null? f6206) f6207 ((vector-ref f6203 0) (cdr f6206) (cons (car f6206) f6207)))))))
# emit-begin
#   expr=(begin (vector-set! f6203 0 (closure (f6206 f6207) (f6203) (let ((f6206 f6206) (f6207 f6207)) (if (null? f6206) f6207 ((vector-ref f6203 0) (cdr f6206) (cons (car f6206) f6207)))))))
#   env=((f6203 . 0))
# emit-expr (vector-set! f6203 0 (closure (f6206 f6207) (f6203) (let ((f6206 f6206) (f6207 f6207)) (if (null? f6206) f6207 ((vector-ref f6203 0) (cdr f6206) (cons (car f6206) f6207))))))
# emit-expr f6203
# emit-variable-ref
# env=((f6203 . 0))
# var=f6203
    movl 0(%esp), %eax  # stack load f6203
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_37455
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_37455:
    movl %eax, -4(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_37456"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_37456:
# check bounds on vector index
    movl -4(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_37458
    cmp  $0,%eax
    jge _L_37457
_L_37458:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_37457:
    movl %eax, -8(%esp)
# emit-expr (closure (f6206 f6207) (f6203) (let ((f6206 f6206) (f6207 f6207)) (if (null? f6206) f6207 ((vector-ref f6203 0) (cdr f6206) (cons (car f6206) f6207)))))
# emit-closure
# si = -12
# env = ((f6203 . 0))
# expr = (closure (f6206 f6207) (f6203) (let ((f6206 f6206) (f6207 f6207)) (if (null? f6206) f6207 ((vector-ref f6203 0) (cdr f6206) (cons (car f6206) f6207)))))
    movl $_L_37459, 0(%ebp)  # closure label
# emit-variable-ref
# env=((f6203 . 0))
# var=f6203
    movl 0(%esp), %eax  # stack load f6203
# end emit-variable-ref
   movl  %eax, 4(%ebp)  # f6203
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $8, %ebp     # bump ebp
    jmp _L_37460            # jump around closure body
_L_37459:
# check argument count
    cmp $8,%eax
    je _L_37461
# invoke error handler eh_argcount
    .extern mrc_eh$uargcount
    movl mrc_eh$uargcount, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_37461:
# emit-tail-expr
# si=-16
# env=((f6207 . -12) (f6206 . -8) (f6203 . 4) (f6203 . 0))
# expr=(let ((f6206 f6206) (f6207 f6207)) (if (null? f6206) f6207 ((vector-ref f6203 0) (cdr f6206) (cons (car f6206) f6207))))
# emit-tail-let
#  si   = -16
#  env  = ((f6207 . -12) (f6206 . -8) (f6203 . 4) (f6203 . 0))
#  bindings = ((f6206 f6206) (f6207 f6207))
#  body = (if (null? f6206) f6207 ((vector-ref f6203 0) (cdr f6206) (cons (car f6206) f6207)))
# emit-expr f6206
# emit-variable-ref
# env=((f6207 . -12) (f6206 . -8) (f6203 . 4) (f6203 . 0))
# var=f6206
    movl -8(%esp), %eax  # stack load f6206
# end emit-variable-ref
    movl %eax, -16(%esp)  # stack save
# emit-expr f6207
# emit-variable-ref
# env=((f6207 . -12) (f6206 . -8) (f6203 . 4) (f6203 . 0))
# var=f6207
    movl -12(%esp), %eax  # stack load f6207
# end emit-variable-ref
    movl %eax, -20(%esp)  # stack save
# emit-tail-expr
# si=-24
# env=((f6207 . -20) (f6206 . -16) (f6207 . -12) (f6206 . -8) (f6203 . 4) (f6203 . 0))
# expr=(if (null? f6206) f6207 ((vector-ref f6203 0) (cdr f6206) (cons (car f6206) f6207)))
# emit-expr (null? f6206)
# emit-expr f6206
# emit-variable-ref
# env=((f6207 . -20) (f6206 . -16) (f6207 . -12) (f6206 . -8) (f6203 . 4) (f6203 . 0))
# var=f6206
    movl -16(%esp), %eax  # stack load f6206
# end emit-variable-ref
    cmp $63, %eax
    mov $0, %eax
    sete %al
    movzbl %al, %eax
    sal $6, %al
    or $47, %al
    cmp $47, %al
    je _L_37462
# emit-tail-expr
# si=-24
# env=((f6207 . -20) (f6206 . -16) (f6207 . -12) (f6206 . -8) (f6203 . 4) (f6203 . 0))
# expr=f6207
# emit-tail-variable-ref
# emit-variable-ref
# env=((f6207 . -20) (f6206 . -16) (f6207 . -12) (f6206 . -8) (f6203 . 4) (f6203 . 0))
# var=f6207
    movl -20(%esp), %eax  # stack load f6207
# end emit-variable-ref
    ret
# end emit-tail-variable ref
    jmp _L_37463
_L_37462:
# emit-tail-expr
# si=-24
# env=((f6207 . -20) (f6206 . -16) (f6207 . -12) (f6206 . -8) (f6203 . 4) (f6203 . 0))
# expr=((vector-ref f6203 0) (cdr f6206) (cons (car f6206) f6207))
# emit-tail-funcall
#    si   =-24
#    env  = ((f6207 . -20) (f6206 . -16) (f6207 . -12) (f6206 . -8) (f6203 . 4) (f6203 . 0))
#    expr = (funcall (vector-ref f6203 0) (cdr f6206) (cons (car f6206) f6207))
# emit-expr (vector-ref f6203 0)
# emit-expr f6203
# emit-variable-ref
# env=((f6207 . -20) (f6206 . -16) (f6207 . -12) (f6206 . -8) (f6203 . 4) (f6203 . 0))
# var=f6203
    movl 2(%edi), %eax  # frame load f6203
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_37464
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_37464:
    movl %eax, -24(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_37465"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_37465:
# check bounds on vector index
    movl -24(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_37467
    cmp  $0,%eax
    jge _L_37466
_L_37467:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_37466:
    movl -24(%esp), %esi
    movl -1(%eax,%esi), %eax
   movl %eax,  -24(%esp)  # stash funcall-oper in next closure slot
# emit-expr (cdr f6206)
# emit-expr f6206
# emit-variable-ref
# env=((f6207 . -20) (f6206 . -16) (f6207 . -12) (f6206 . -8) (f6203 . 4) (f6203 . 0))
# var=f6206
    movl -16(%esp), %eax  # stack load f6206
# end emit-variable-ref
# check the argument is a pair
    movl %eax,%ebx
    and $7, %bl
    cmp $1, %bl
    je _L_37468
# invoke error handler eh_pair
    .extern mrc_eh$upair
    movl mrc_eh$upair, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $120,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_37468:
    movl 3(%eax), %eax
    mov %eax, -28(%esp)    # arg (cdr f6206)
# emit-expr (cons (car f6206) f6207)
# cons arg1=(car f6206) arg2=f6207
# emit-expr (car f6206)
# emit-expr f6206
# emit-variable-ref
# env=((f6207 . -20) (f6206 . -16) (f6207 . -12) (f6206 . -8) (f6203 . 4) (f6203 . 0))
# var=f6206
    movl -16(%esp), %eax  # stack load f6206
# end emit-variable-ref
# check the argument is a pair
    movl %eax,%ebx
    and $7, %bl
    cmp $1, %bl
    je _L_37469
# invoke error handler eh_pair
    .extern mrc_eh$upair
    movl mrc_eh$upair, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $116,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_37469:
    movl -1(%eax), %eax
    movl %eax, -32(%esp)
# emit-expr f6207
# emit-variable-ref
# env=((f6207 . -20) (f6206 . -16) (f6207 . -12) (f6206 . -8) (f6203 . 4) (f6203 . 0))
# var=f6207
    movl -20(%esp), %eax  # stack load f6207
# end emit-variable-ref
    movl %eax, 4(%ebp)
    movl -32(%esp), %eax
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    or   $1, %al
    add  $8, %ebp
# cons end
    mov %eax, -32(%esp)    # arg (cons (car f6206) f6207)
    movl -24(%esp), %edi   # load new closure to %edi
# emit-shift-args:  size=3   si=-24  delta=20
    mov -24(%esp), %ebx  # shift frame cell
    mov %ebx, -4(%esp)  # down to base
# emit-shift-args:  size=2   si=-28  delta=20
    mov -28(%esp), %ebx  # shift frame cell
    mov %ebx, -8(%esp)  # down to base
# emit-shift-args:  size=1   si=-32  delta=20
    mov -32(%esp), %ebx  # shift frame cell
    mov %ebx, -12(%esp)  # down to base
# emit-shift-args:  size=0   si=-36  delta=20
    movl $8,%eax   # save arg count
    jmp *-2(%edi)  # tail-funcall
_L_37463:
    .align 4,0x90
_L_37460:
    movl -4(%esp), %ebx
    movl -8(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin)
# emit-begin
#   expr=(begin)
#   env=((f6203 . 0))
# emit-expr (begin (closure (f6209) (f6203) (let ((f6209 f6209)) ((vector-ref f6203 0) f6209 ()))))
# emit-begin
#   expr=(begin (closure (f6209) (f6203) (let ((f6209 f6209)) ((vector-ref f6203 0) f6209 ()))))
#   env=((f6203 . 0))
# emit-expr (closure (f6209) (f6203) (let ((f6209 f6209)) ((vector-ref f6203 0) f6209 ())))
# emit-closure
# si = -4
# env = ((f6203 . 0))
# expr = (closure (f6209) (f6203) (let ((f6209 f6209)) ((vector-ref f6203 0) f6209 ())))
    movl $_L_37470, 0(%ebp)  # closure label
# emit-variable-ref
# env=((f6203 . 0))
# var=f6203
    movl 0(%esp), %eax  # stack load f6203
# end emit-variable-ref
   movl  %eax, 4(%ebp)  # f6203
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $8, %ebp     # bump ebp
    jmp _L_37471            # jump around closure body
_L_37470:
# check argument count
    cmp $4,%eax
    je _L_37472
# invoke error handler eh_argcount
    .extern mrc_eh$uargcount
    movl mrc_eh$uargcount, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_37472:
# emit-tail-expr
# si=-12
# env=((f6209 . -8) (f6203 . 4) (f6203 . 0))
# expr=(let ((f6209 f6209)) ((vector-ref f6203 0) f6209 ()))
# emit-tail-let
#  si   = -12
#  env  = ((f6209 . -8) (f6203 . 4) (f6203 . 0))
#  bindings = ((f6209 f6209))
#  body = ((vector-ref f6203 0) f6209 ())
# emit-expr f6209
# emit-variable-ref
# env=((f6209 . -8) (f6203 . 4) (f6203 . 0))
# var=f6209
    movl -8(%esp), %eax  # stack load f6209
# end emit-variable-ref
    movl %eax, -12(%esp)  # stack save
# emit-tail-expr
# si=-16
# env=((f6209 . -12) (f6209 . -8) (f6203 . 4) (f6203 . 0))
# expr=((vector-ref f6203 0) f6209 ())
# emit-tail-funcall
#    si   =-16
#    env  = ((f6209 . -12) (f6209 . -8) (f6203 . 4) (f6203 . 0))
#    expr = (funcall (vector-ref f6203 0) f6209 ())
# emit-expr (vector-ref f6203 0)
# emit-expr f6203
# emit-variable-ref
# env=((f6209 . -12) (f6209 . -8) (f6203 . 4) (f6203 . 0))
# var=f6203
    movl 2(%edi), %eax  # frame load f6203
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_37473
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_37473:
    movl %eax, -16(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_37474"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_37474:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_37476
    cmp  $0,%eax
    jge _L_37475
_L_37476:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_37475:
    movl -16(%esp), %esi
    movl -1(%eax,%esi), %eax
   movl %eax,  -16(%esp)  # stash funcall-oper in next closure slot
# emit-expr f6209
# emit-variable-ref
# env=((f6209 . -12) (f6209 . -8) (f6203 . 4) (f6203 . 0))
# var=f6209
    movl -12(%esp), %eax  # stack load f6209
# end emit-variable-ref
    mov %eax, -20(%esp)    # arg f6209
# emit-expr ()
    movl $63, %eax     # immed ()
    mov %eax, -24(%esp)    # arg ()
    movl -16(%esp), %edi   # load new closure to %edi
# emit-shift-args:  size=3   si=-16  delta=12
    mov -16(%esp), %ebx  # shift frame cell
    mov %ebx, -4(%esp)  # down to base
# emit-shift-args:  size=2   si=-20  delta=12
    mov -20(%esp), %ebx  # shift frame cell
    mov %ebx, -8(%esp)  # down to base
# emit-shift-args:  size=1   si=-24  delta=12
    mov -24(%esp), %ebx  # shift frame cell
    mov %ebx, -12(%esp)  # down to base
# emit-shift-args:  size=0   si=-28  delta=12
    movl $8,%eax   # save arg count
    jmp *-2(%edi)  # tail-funcall
    .align 4,0x90
_L_37471:
# emit-expr (begin)
# emit-begin
#   expr=(begin)
#   env=((f6203 . 0))
     movl %eax, mrc_reverse
# == explicit-begins  ==>
# (lambda args args)
# == eliminate-let*  ==>
# (lambda args args)
# == uniquify-variables  ==>
# (lambda f6210 f6210)
# == vectorize-letrec  ==>
# (lambda f6210 f6210)
# == eliminate-set!  ==>
# (lambda f6210 (let () f6210))
# == close-free-variables  ==>
# (closure f6210 () (let () f6210))
# == eliminate-quote  ==>
# (closure f6210 () (let () f6210))
# == eliminate-when/unless  ==>
# (closure f6210 () (let () f6210))
# == eliminate-cond  ==>
# (closure f6210 () (let () f6210))
# == external-symbols  ==>
# (closure f6210 () (let () f6210))
# emit-expr (closure f6210 () (let () f6210))
# emit-closure
# si = 0
# env = ()
# expr = (closure f6210 () (let () f6210))
    movl $_L_37477, 0(%ebp)  # closure label
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $8, %ebp     # bump ebp
    jmp _L_37478            # jump around closure body
_L_37477:
# check argument count
    cmp $0,%eax
    jge _L_37479
# invoke error handler eh_argcount_min
    .extern mrc_eh$uargcount$umin
    movl mrc_eh$uargcount$umin, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_37479:
# emit-build-varargs-list
    movl $63, %esi       # args <- () 
    lea -4(%esp),%edi    # edi <- esp-4
    subl %eax, %edi      # edi <- esp-4-eax    addr of arg[K+N] on stack
_L_37481:
    lea -4(%esp),%ebx    # addr of arg[K] on stack
    cmp %edi, %ebx       # while edi <> esp+(si+4)
    je _L_37480
    movl (%edi),%ebx     # arg i -> car
    movl %ebx, 0(%ebp)
    movl %esi, 4(%ebp)  # esi -> cdr
    movl %ebp, %esi
    addl $1, %esi       # tag as pair
    addl $8,%ebp         # bump heap ptr
    addl $4,%edi         # move to next previous arg from the end
    jmp _L_37481
_L_37480:
    movl %esi, -8(%esp)  # set args
# emit-tail-expr
# si=-12
# env=((f6210 . -8))
# expr=(let () f6210)
# emit-tail-let
#  si   = -12
#  env  = ((f6210 . -8))
#  bindings = ()
#  body = f6210
# emit-tail-expr
# si=-12
# env=((f6210 . -8))
# expr=f6210
# emit-tail-variable-ref
# emit-variable-ref
# env=((f6210 . -8))
# var=f6210
    movl -8(%esp), %eax  # stack load f6210
# end emit-variable-ref
    ret
# end emit-tail-variable ref
    .align 4,0x90
_L_37478:
     movl %eax, mrc_list
# == explicit-begins  ==>
# (letrec ((fill-vector (lambda (v k args) (if (null? args) v (begin (vector-set! v k (car args)) (fill-vector v (fxadd1 k) (cdr args))))))) (lambda args (let ((v (make-vector (list-length args)))) (fill-vector v 0 args))))
# == eliminate-let*  ==>
# (letrec ((fill-vector (lambda (v k args) (if (null? args) v (begin (vector-set! v k (car args)) (fill-vector v (fxadd1 k) (cdr args))))))) (lambda args (let ((v (make-vector (list-length args)))) (fill-vector v 0 args))))
# == uniquify-variables  ==>
# (letrec ((f6211 (lambda (f6215 f6216 f6217) (if (null? f6217) f6215 (begin (vector-set! f6215 f6216 (car f6217)) (f6211 f6215 (fxadd1 f6216) (cdr f6217))))))) (lambda f6221 (let ((f6223 (make-vector (list-length f6221)))) (f6211 f6223 0 f6221))))
# == vectorize-letrec  ==>
# (let ((f6211 (make-vector 1))) (begin (begin (vector-set! f6211 0 (lambda (f6215 f6216 f6217) (if (null? f6217) f6215 (begin (vector-set! f6215 f6216 (car f6217)) ((vector-ref f6211 0) f6215 (fxadd1 f6216) (cdr f6217))))))) (lambda f6221 (let ((f6223 (make-vector (list-length f6221)))) ((vector-ref f6211 0) f6223 0 f6221)))))
# == eliminate-set!  ==>
# (let ((f6211 (make-vector 1))) (begin (begin (vector-set! f6211 0 (lambda (f6215 f6216 f6217) (let ((f6215 f6215) (f6216 f6216) (f6217 f6217)) (if (null? f6217) f6215 (begin (vector-set! f6215 f6216 (car f6217)) ((vector-ref f6211 0) f6215 (fxadd1 f6216) (cdr f6217)))))))) (lambda f6221 (let () (let ((f6223 (make-vector (list-length f6221)))) ((vector-ref f6211 0) f6223 0 f6221))))))
# == close-free-variables  ==>
# (let ((f6211 (make-vector 1))) (begin (begin (vector-set! f6211 0 (closure (f6215 f6216 f6217) (f6211) (let ((f6215 f6215) (f6216 f6216) (f6217 f6217)) (if (null? f6217) f6215 (begin (vector-set! f6215 f6216 (car f6217)) ((vector-ref f6211 0) f6215 (fxadd1 f6216) (cdr f6217)))))))) (closure f6221 (f6211) (let () (let ((f6223 (make-vector (list-length f6221)))) ((vector-ref f6211 0) f6223 0 f6221))))))
# == eliminate-quote  ==>
# (let ((f6211 (make-vector 1))) (begin (begin (vector-set! f6211 0 (closure (f6215 f6216 f6217) (f6211) (let ((f6215 f6215) (f6216 f6216) (f6217 f6217)) (if (null? f6217) f6215 (begin (vector-set! f6215 f6216 (car f6217)) ((vector-ref f6211 0) f6215 (fxadd1 f6216) (cdr f6217)))))))) (closure f6221 (f6211) (let () (let ((f6223 (make-vector (list-length f6221)))) ((vector-ref f6211 0) f6223 0 f6221))))))
# == eliminate-when/unless  ==>
# (let ((f6211 (make-vector 1))) (begin (begin (vector-set! f6211 0 (closure (f6215 f6216 f6217) (f6211) (let ((f6215 f6215) (f6216 f6216) (f6217 f6217)) (if (null? f6217) f6215 (begin (vector-set! f6215 f6216 (car f6217)) ((vector-ref f6211 0) f6215 (fxadd1 f6216) (cdr f6217)))))))) (closure f6221 (f6211) (let () (let ((f6223 (make-vector (list-length f6221)))) ((vector-ref f6211 0) f6223 0 f6221))))))
# == eliminate-cond  ==>
# (let ((f6211 (make-vector 1))) (begin (begin (vector-set! f6211 0 (closure (f6215 f6216 f6217) (f6211) (let ((f6215 f6215) (f6216 f6216) (f6217 f6217)) (if (null? f6217) f6215 (begin (vector-set! f6215 f6216 (car f6217)) ((vector-ref f6211 0) f6215 (fxadd1 f6216) (cdr f6217)))))))) (closure f6221 (f6211) (let () (let ((f6223 (make-vector (list-length f6221)))) ((vector-ref f6211 0) f6223 0 f6221))))))
# == external-symbols  ==>
# (let ((f6211 (make-vector 1))) (begin (begin (vector-set! f6211 0 (closure (f6215 f6216 f6217) (f6211) (let ((f6215 f6215) (f6216 f6216) (f6217 f6217)) (if (null? f6217) f6215 (begin (vector-set! f6215 f6216 (car f6217)) ((vector-ref f6211 0) f6215 (fxadd1 f6216) (cdr f6217)))))))) (closure f6221 (f6211) (let () (let ((f6223 (make-vector ((primitive-ref list-length) f6221)))) ((vector-ref f6211 0) f6223 0 f6221))))))
# emit-expr (let ((f6211 (make-vector 1))) (begin (begin (vector-set! f6211 0 (closure (f6215 f6216 f6217) (f6211) (let ((f6215 f6215) (f6216 f6216) (f6217 f6217)) (if (null? f6217) f6215 (begin (vector-set! f6215 f6216 (car f6217)) ((vector-ref f6211 0) f6215 (fxadd1 f6216) (cdr f6217)))))))) (closure f6221 (f6211) (let () (let ((f6223 (make-vector ((primitive-ref list-length) f6221)))) ((vector-ref f6211 0) f6223 0 f6221))))))
# emit-let
#  si   = 0
#  env  = ()
#  bindings = ((f6211 (make-vector 1)))
#  body = (begin (begin (vector-set! f6211 0 (closure (f6215 f6216 f6217) (f6211) (let ((f6215 f6215) (f6216 f6216) (f6217 f6217)) (if (null? f6217) f6215 (begin (vector-set! f6215 f6216 (car f6217)) ((vector-ref f6211 0) f6215 (fxadd1 f6216) (cdr f6217)))))))) (closure f6221 (f6211) (let () (let ((f6223 (make-vector ((primitive-ref list-length) f6221)))) ((vector-ref f6211 0) f6223 0 f6221)))))
# emit-expr (make-vector 1)
# make-vector 1
# emit-expr 1
    movl $4, %eax     # immed 1
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_37482"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_37482:
# check the argument is a fixnum >= 0
    cmp $0,%eax
    jge _L_37483
# invoke error handler eh_length
    .extern mrc_eh$ulength
    movl mrc_eh$ulength, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_37483:
    movl %eax, %esi
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    orl  $5, %eax
    addl $4, %esi
    addl $4, %esi
    andl $-8, %esi
    addl %esi, %ebp
    movl %eax, 0(%esp)  # stack save
# emit-expr (begin (begin (vector-set! f6211 0 (closure (f6215 f6216 f6217) (f6211) (let ((f6215 f6215) (f6216 f6216) (f6217 f6217)) (if (null? f6217) f6215 (begin (vector-set! f6215 f6216 (car f6217)) ((vector-ref f6211 0) f6215 (fxadd1 f6216) (cdr f6217)))))))) (closure f6221 (f6211) (let () (let ((f6223 (make-vector ((primitive-ref list-length) f6221)))) ((vector-ref f6211 0) f6223 0 f6221)))))
# emit-begin
#   expr=(begin (begin (vector-set! f6211 0 (closure (f6215 f6216 f6217) (f6211) (let ((f6215 f6215) (f6216 f6216) (f6217 f6217)) (if (null? f6217) f6215 (begin (vector-set! f6215 f6216 (car f6217)) ((vector-ref f6211 0) f6215 (fxadd1 f6216) (cdr f6217)))))))) (closure f6221 (f6211) (let () (let ((f6223 (make-vector ((primitive-ref list-length) f6221)))) ((vector-ref f6211 0) f6223 0 f6221)))))
#   env=((f6211 . 0))
# emit-expr (begin (vector-set! f6211 0 (closure (f6215 f6216 f6217) (f6211) (let ((f6215 f6215) (f6216 f6216) (f6217 f6217)) (if (null? f6217) f6215 (begin (vector-set! f6215 f6216 (car f6217)) ((vector-ref f6211 0) f6215 (fxadd1 f6216) (cdr f6217))))))))
# emit-begin
#   expr=(begin (vector-set! f6211 0 (closure (f6215 f6216 f6217) (f6211) (let ((f6215 f6215) (f6216 f6216) (f6217 f6217)) (if (null? f6217) f6215 (begin (vector-set! f6215 f6216 (car f6217)) ((vector-ref f6211 0) f6215 (fxadd1 f6216) (cdr f6217))))))))
#   env=((f6211 . 0))
# emit-expr (vector-set! f6211 0 (closure (f6215 f6216 f6217) (f6211) (let ((f6215 f6215) (f6216 f6216) (f6217 f6217)) (if (null? f6217) f6215 (begin (vector-set! f6215 f6216 (car f6217)) ((vector-ref f6211 0) f6215 (fxadd1 f6216) (cdr f6217)))))))
# emit-expr f6211
# emit-variable-ref
# env=((f6211 . 0))
# var=f6211
    movl 0(%esp), %eax  # stack load f6211
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_37484
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_37484:
    movl %eax, -4(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_37485"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_37485:
# check bounds on vector index
    movl -4(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_37487
    cmp  $0,%eax
    jge _L_37486
_L_37487:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_37486:
    movl %eax, -8(%esp)
# emit-expr (closure (f6215 f6216 f6217) (f6211) (let ((f6215 f6215) (f6216 f6216) (f6217 f6217)) (if (null? f6217) f6215 (begin (vector-set! f6215 f6216 (car f6217)) ((vector-ref f6211 0) f6215 (fxadd1 f6216) (cdr f6217))))))
# emit-closure
# si = -12
# env = ((f6211 . 0))
# expr = (closure (f6215 f6216 f6217) (f6211) (let ((f6215 f6215) (f6216 f6216) (f6217 f6217)) (if (null? f6217) f6215 (begin (vector-set! f6215 f6216 (car f6217)) ((vector-ref f6211 0) f6215 (fxadd1 f6216) (cdr f6217))))))
    movl $_L_37488, 0(%ebp)  # closure label
# emit-variable-ref
# env=((f6211 . 0))
# var=f6211
    movl 0(%esp), %eax  # stack load f6211
# end emit-variable-ref
   movl  %eax, 4(%ebp)  # f6211
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $8, %ebp     # bump ebp
    jmp _L_37489            # jump around closure body
_L_37488:
# check argument count
    cmp $12,%eax
    je _L_37490
# invoke error handler eh_argcount
    .extern mrc_eh$uargcount
    movl mrc_eh$uargcount, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_37490:
# emit-tail-expr
# si=-20
# env=((f6217 . -16) (f6216 . -12) (f6215 . -8) (f6211 . 4) (f6211 . 0))
# expr=(let ((f6215 f6215) (f6216 f6216) (f6217 f6217)) (if (null? f6217) f6215 (begin (vector-set! f6215 f6216 (car f6217)) ((vector-ref f6211 0) f6215 (fxadd1 f6216) (cdr f6217)))))
# emit-tail-let
#  si   = -20
#  env  = ((f6217 . -16) (f6216 . -12) (f6215 . -8) (f6211 . 4) (f6211 . 0))
#  bindings = ((f6215 f6215) (f6216 f6216) (f6217 f6217))
#  body = (if (null? f6217) f6215 (begin (vector-set! f6215 f6216 (car f6217)) ((vector-ref f6211 0) f6215 (fxadd1 f6216) (cdr f6217))))
# emit-expr f6215
# emit-variable-ref
# env=((f6217 . -16) (f6216 . -12) (f6215 . -8) (f6211 . 4) (f6211 . 0))
# var=f6215
    movl -8(%esp), %eax  # stack load f6215
# end emit-variable-ref
    movl %eax, -20(%esp)  # stack save
# emit-expr f6216
# emit-variable-ref
# env=((f6217 . -16) (f6216 . -12) (f6215 . -8) (f6211 . 4) (f6211 . 0))
# var=f6216
    movl -12(%esp), %eax  # stack load f6216
# end emit-variable-ref
    movl %eax, -24(%esp)  # stack save
# emit-expr f6217
# emit-variable-ref
# env=((f6217 . -16) (f6216 . -12) (f6215 . -8) (f6211 . 4) (f6211 . 0))
# var=f6217
    movl -16(%esp), %eax  # stack load f6217
# end emit-variable-ref
    movl %eax, -28(%esp)  # stack save
# emit-tail-expr
# si=-32
# env=((f6217 . -28) (f6216 . -24) (f6215 . -20) (f6217 . -16) (f6216 . -12) (f6215 . -8) (f6211 . 4) (f6211 . 0))
# expr=(if (null? f6217) f6215 (begin (vector-set! f6215 f6216 (car f6217)) ((vector-ref f6211 0) f6215 (fxadd1 f6216) (cdr f6217))))
# emit-expr (null? f6217)
# emit-expr f6217
# emit-variable-ref
# env=((f6217 . -28) (f6216 . -24) (f6215 . -20) (f6217 . -16) (f6216 . -12) (f6215 . -8) (f6211 . 4) (f6211 . 0))
# var=f6217
    movl -28(%esp), %eax  # stack load f6217
# end emit-variable-ref
    cmp $63, %eax
    mov $0, %eax
    sete %al
    movzbl %al, %eax
    sal $6, %al
    or $47, %al
    cmp $47, %al
    je _L_37491
# emit-tail-expr
# si=-32
# env=((f6217 . -28) (f6216 . -24) (f6215 . -20) (f6217 . -16) (f6216 . -12) (f6215 . -8) (f6211 . 4) (f6211 . 0))
# expr=f6215
# emit-tail-variable-ref
# emit-variable-ref
# env=((f6217 . -28) (f6216 . -24) (f6215 . -20) (f6217 . -16) (f6216 . -12) (f6215 . -8) (f6211 . 4) (f6211 . 0))
# var=f6215
    movl -20(%esp), %eax  # stack load f6215
# end emit-variable-ref
    ret
# end emit-tail-variable ref
    jmp _L_37492
_L_37491:
# emit-tail-expr
# si=-32
# env=((f6217 . -28) (f6216 . -24) (f6215 . -20) (f6217 . -16) (f6216 . -12) (f6215 . -8) (f6211 . 4) (f6211 . 0))
# expr=(begin (vector-set! f6215 f6216 (car f6217)) ((vector-ref f6211 0) f6215 (fxadd1 f6216) (cdr f6217)))
# tail-begin (begin (vector-set! f6215 f6216 (car f6217)) ((vector-ref f6211 0) f6215 (fxadd1 f6216) (cdr f6217)))
#   env=((f6217 . -28) (f6216 . -24) (f6215 . -20) (f6217 . -16) (f6216 . -12) (f6215 . -8) (f6211 . 4) (f6211 . 0))
# emit-expr (vector-set! f6215 f6216 (car f6217))
# emit-expr f6215
# emit-variable-ref
# env=((f6217 . -28) (f6216 . -24) (f6215 . -20) (f6217 . -16) (f6216 . -12) (f6215 . -8) (f6211 . 4) (f6211 . 0))
# var=f6215
    movl -20(%esp), %eax  # stack load f6215
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_37493
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_37493:
    movl %eax, -32(%esp)
# emit-expr f6216
# emit-variable-ref
# env=((f6217 . -28) (f6216 . -24) (f6215 . -20) (f6217 . -16) (f6216 . -12) (f6215 . -8) (f6211 . 4) (f6211 . 0))
# var=f6216
    movl -24(%esp), %eax  # stack load f6216
# end emit-variable-ref
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_37494"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_37494:
# check bounds on vector index
    movl -32(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_37496
    cmp  $0,%eax
    jge _L_37495
_L_37496:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_37495:
    movl %eax, -36(%esp)
# emit-expr (car f6217)
# emit-expr f6217
# emit-variable-ref
# env=((f6217 . -28) (f6216 . -24) (f6215 . -20) (f6217 . -16) (f6216 . -12) (f6215 . -8) (f6211 . 4) (f6211 . 0))
# var=f6217
    movl -28(%esp), %eax  # stack load f6217
# end emit-variable-ref
# check the argument is a pair
    movl %eax,%ebx
    and $7, %bl
    cmp $1, %bl
    je _L_37497
# invoke error handler eh_pair
    .extern mrc_eh$upair
    movl mrc_eh$upair, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $116,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_37497:
    movl -1(%eax), %eax
    movl -32(%esp), %ebx
    movl -36(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-tail-expr
# si=-32
# env=((f6217 . -28) (f6216 . -24) (f6215 . -20) (f6217 . -16) (f6216 . -12) (f6215 . -8) (f6211 . 4) (f6211 . 0))
# expr=(begin ((vector-ref f6211 0) f6215 (fxadd1 f6216) (cdr f6217)))
# tail-begin (begin ((vector-ref f6211 0) f6215 (fxadd1 f6216) (cdr f6217)))
#   env=((f6217 . -28) (f6216 . -24) (f6215 . -20) (f6217 . -16) (f6216 . -12) (f6215 . -8) (f6211 . 4) (f6211 . 0))
# emit-tail-expr
# si=-32
# env=((f6217 . -28) (f6216 . -24) (f6215 . -20) (f6217 . -16) (f6216 . -12) (f6215 . -8) (f6211 . 4) (f6211 . 0))
# expr=((vector-ref f6211 0) f6215 (fxadd1 f6216) (cdr f6217))
# emit-tail-funcall
#    si   =-32
#    env  = ((f6217 . -28) (f6216 . -24) (f6215 . -20) (f6217 . -16) (f6216 . -12) (f6215 . -8) (f6211 . 4) (f6211 . 0))
#    expr = (funcall (vector-ref f6211 0) f6215 (fxadd1 f6216) (cdr f6217))
# emit-expr (vector-ref f6211 0)
# emit-expr f6211
# emit-variable-ref
# env=((f6217 . -28) (f6216 . -24) (f6215 . -20) (f6217 . -16) (f6216 . -12) (f6215 . -8) (f6211 . 4) (f6211 . 0))
# var=f6211
    movl 2(%edi), %eax  # frame load f6211
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_37498
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_37498:
    movl %eax, -32(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_37499"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_37499:
# check bounds on vector index
    movl -32(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_37501
    cmp  $0,%eax
    jge _L_37500
_L_37501:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_37500:
    movl -32(%esp), %esi
    movl -1(%eax,%esi), %eax
   movl %eax,  -32(%esp)  # stash funcall-oper in next closure slot
# emit-expr f6215
# emit-variable-ref
# env=((f6217 . -28) (f6216 . -24) (f6215 . -20) (f6217 . -16) (f6216 . -12) (f6215 . -8) (f6211 . 4) (f6211 . 0))
# var=f6215
    movl -20(%esp), %eax  # stack load f6215
# end emit-variable-ref
    mov %eax, -36(%esp)    # arg f6215
# emit-expr (fxadd1 f6216)
# emit-expr f6216
# emit-variable-ref
# env=((f6217 . -28) (f6216 . -24) (f6215 . -20) (f6217 . -16) (f6216 . -12) (f6215 . -8) (f6211 . 4) (f6211 . 0))
# var=f6216
    movl -24(%esp), %eax  # stack load f6216
# end emit-variable-ref
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_37502"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $56,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_37502:
     addl $4, %eax
    mov %eax, -40(%esp)    # arg (fxadd1 f6216)
# emit-expr (cdr f6217)
# emit-expr f6217
# emit-variable-ref
# env=((f6217 . -28) (f6216 . -24) (f6215 . -20) (f6217 . -16) (f6216 . -12) (f6215 . -8) (f6211 . 4) (f6211 . 0))
# var=f6217
    movl -28(%esp), %eax  # stack load f6217
# end emit-variable-ref
# check the argument is a pair
    movl %eax,%ebx
    and $7, %bl
    cmp $1, %bl
    je _L_37503
# invoke error handler eh_pair
    .extern mrc_eh$upair
    movl mrc_eh$upair, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $120,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_37503:
    movl 3(%eax), %eax
    mov %eax, -44(%esp)    # arg (cdr f6217)
    movl -32(%esp), %edi   # load new closure to %edi
# emit-shift-args:  size=4   si=-32  delta=28
    mov -32(%esp), %ebx  # shift frame cell
    mov %ebx, -4(%esp)  # down to base
# emit-shift-args:  size=3   si=-36  delta=28
    mov -36(%esp), %ebx  # shift frame cell
    mov %ebx, -8(%esp)  # down to base
# emit-shift-args:  size=2   si=-40  delta=28
    mov -40(%esp), %ebx  # shift frame cell
    mov %ebx, -12(%esp)  # down to base
# emit-shift-args:  size=1   si=-44  delta=28
    mov -44(%esp), %ebx  # shift frame cell
    mov %ebx, -16(%esp)  # down to base
# emit-shift-args:  size=0   si=-48  delta=28
    movl $12,%eax   # save arg count
    jmp *-2(%edi)  # tail-funcall
     ret   # return thru stack
_L_37492:
    .align 4,0x90
_L_37489:
    movl -4(%esp), %ebx
    movl -8(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin)
# emit-begin
#   expr=(begin)
#   env=((f6211 . 0))
# emit-expr (begin (closure f6221 (f6211) (let () (let ((f6223 (make-vector ((primitive-ref list-length) f6221)))) ((vector-ref f6211 0) f6223 0 f6221)))))
# emit-begin
#   expr=(begin (closure f6221 (f6211) (let () (let ((f6223 (make-vector ((primitive-ref list-length) f6221)))) ((vector-ref f6211 0) f6223 0 f6221)))))
#   env=((f6211 . 0))
# emit-expr (closure f6221 (f6211) (let () (let ((f6223 (make-vector ((primitive-ref list-length) f6221)))) ((vector-ref f6211 0) f6223 0 f6221))))
# emit-closure
# si = -4
# env = ((f6211 . 0))
# expr = (closure f6221 (f6211) (let () (let ((f6223 (make-vector ((primitive-ref list-length) f6221)))) ((vector-ref f6211 0) f6223 0 f6221))))
    movl $_L_37504, 0(%ebp)  # closure label
# emit-variable-ref
# env=((f6211 . 0))
# var=f6211
    movl 0(%esp), %eax  # stack load f6211
# end emit-variable-ref
   movl  %eax, 4(%ebp)  # f6211
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $8, %ebp     # bump ebp
    jmp _L_37505            # jump around closure body
_L_37504:
# check argument count
    cmp $0,%eax
    jge _L_37506
# invoke error handler eh_argcount_min
    .extern mrc_eh$uargcount$umin
    movl mrc_eh$uargcount$umin, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_37506:
# emit-build-varargs-list
    movl $63, %esi       # args <- () 
    lea -4(%esp),%edi    # edi <- esp-4
    subl %eax, %edi      # edi <- esp-4-eax    addr of arg[K+N] on stack
_L_37508:
    lea -4(%esp),%ebx    # addr of arg[K] on stack
    cmp %edi, %ebx       # while edi <> esp+(si+4)
    je _L_37507
    movl (%edi),%ebx     # arg i -> car
    movl %ebx, 0(%ebp)
    movl %esi, 4(%ebp)  # esi -> cdr
    movl %ebp, %esi
    addl $1, %esi       # tag as pair
    addl $8,%ebp         # bump heap ptr
    addl $4,%edi         # move to next previous arg from the end
    jmp _L_37508
_L_37507:
    movl %esi, -8(%esp)  # set args
# emit-tail-expr
# si=-12
# env=((f6221 . -8) (f6211 . 4) (f6211 . 0))
# expr=(let () (let ((f6223 (make-vector ((primitive-ref list-length) f6221)))) ((vector-ref f6211 0) f6223 0 f6221)))
# emit-tail-let
#  si   = -12
#  env  = ((f6221 . -8) (f6211 . 4) (f6211 . 0))
#  bindings = ()
#  body = (let ((f6223 (make-vector ((primitive-ref list-length) f6221)))) ((vector-ref f6211 0) f6223 0 f6221))
# emit-tail-expr
# si=-12
# env=((f6221 . -8) (f6211 . 4) (f6211 . 0))
# expr=(let ((f6223 (make-vector ((primitive-ref list-length) f6221)))) ((vector-ref f6211 0) f6223 0 f6221))
# emit-tail-let
#  si   = -12
#  env  = ((f6221 . -8) (f6211 . 4) (f6211 . 0))
#  bindings = ((f6223 (make-vector ((primitive-ref list-length) f6221))))
#  body = ((vector-ref f6211 0) f6223 0 f6221)
# emit-expr (make-vector ((primitive-ref list-length) f6221))
# make-vector ((primitive-ref list-length) f6221)
# emit-expr ((primitive-ref list-length) f6221)
# funcall
#    si   =-12
#    env  = ((f6221 . -8) (f6211 . 4) (f6211 . 0))
#    expr = (funcall (primitive-ref list-length) f6221)
# emit-expr (primitive-ref list-length)
    .extern mrc_list$mlength
    movl mrc_list$mlength,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_37509"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_37509":
   movl %eax,  -20(%esp)  # stash funcall-oper in closure slot
# emit-expr f6221
# emit-variable-ref
# env=((f6221 . -8) (f6211 . 4) (f6211 . 0))
# var=f6221
    movl -8(%esp), %eax  # stack load f6221
# end emit-variable-ref
    mov %eax, -24(%esp)  # arg f6221
    movl -20(%esp), %edi   # load new closure to %edi
    add $-12, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $12, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_37510"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_37510:
# check the argument is a fixnum >= 0
    cmp $0,%eax
    jge _L_37511
# invoke error handler eh_length
    .extern mrc_eh$ulength
    movl mrc_eh$ulength, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_37511:
    movl %eax, %esi
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    orl  $5, %eax
    addl $4, %esi
    addl $4, %esi
    andl $-8, %esi
    addl %esi, %ebp
    movl %eax, -12(%esp)  # stack save
# emit-tail-expr
# si=-16
# env=((f6223 . -12) (f6221 . -8) (f6211 . 4) (f6211 . 0))
# expr=((vector-ref f6211 0) f6223 0 f6221)
# emit-tail-funcall
#    si   =-16
#    env  = ((f6223 . -12) (f6221 . -8) (f6211 . 4) (f6211 . 0))
#    expr = (funcall (vector-ref f6211 0) f6223 0 f6221)
# emit-expr (vector-ref f6211 0)
# emit-expr f6211
# emit-variable-ref
# env=((f6223 . -12) (f6221 . -8) (f6211 . 4) (f6211 . 0))
# var=f6211
    movl 2(%edi), %eax  # frame load f6211
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_37512
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_37512:
    movl %eax, -16(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_37513"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_37513:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_37515
    cmp  $0,%eax
    jge _L_37514
_L_37515:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_37514:
    movl -16(%esp), %esi
    movl -1(%eax,%esi), %eax
   movl %eax,  -16(%esp)  # stash funcall-oper in next closure slot
# emit-expr f6223
# emit-variable-ref
# env=((f6223 . -12) (f6221 . -8) (f6211 . 4) (f6211 . 0))
# var=f6223
    movl -12(%esp), %eax  # stack load f6223
# end emit-variable-ref
    mov %eax, -20(%esp)    # arg f6223
# emit-expr 0
    movl $0, %eax     # immed 0
    mov %eax, -24(%esp)    # arg 0
# emit-expr f6221
# emit-variable-ref
# env=((f6223 . -12) (f6221 . -8) (f6211 . 4) (f6211 . 0))
# var=f6221
    movl -8(%esp), %eax  # stack load f6221
# end emit-variable-ref
    mov %eax, -28(%esp)    # arg f6221
    movl -16(%esp), %edi   # load new closure to %edi
# emit-shift-args:  size=4   si=-16  delta=12
    mov -16(%esp), %ebx  # shift frame cell
    mov %ebx, -4(%esp)  # down to base
# emit-shift-args:  size=3   si=-20  delta=12
    mov -20(%esp), %ebx  # shift frame cell
    mov %ebx, -8(%esp)  # down to base
# emit-shift-args:  size=2   si=-24  delta=12
    mov -24(%esp), %ebx  # shift frame cell
    mov %ebx, -12(%esp)  # down to base
# emit-shift-args:  size=1   si=-28  delta=12
    mov -28(%esp), %ebx  # shift frame cell
    mov %ebx, -16(%esp)  # down to base
# emit-shift-args:  size=0   si=-32  delta=12
    movl $12,%eax   # save arg count
    jmp *-2(%edi)  # tail-funcall
    .align 4,0x90
_L_37505:
# emit-expr (begin)
# emit-begin
#   expr=(begin)
#   env=((f6211 . 0))
     movl %eax, mrc_vector
# == explicit-begins  ==>
# (letrec ((fill-string (lambda (s k args) (if (null? args) s (begin (string-set! s k (car args)) (fill-string s (fxadd1 k) (cdr args))))))) (lambda args (let ((s (make-string (list-length args)))) (fill-string s 0 args))))
# == eliminate-let*  ==>
# (letrec ((fill-string (lambda (s k args) (if (null? args) s (begin (string-set! s k (car args)) (fill-string s (fxadd1 k) (cdr args))))))) (lambda args (let ((s (make-string (list-length args)))) (fill-string s 0 args))))
# == uniquify-variables  ==>
# (letrec ((f6224 (lambda (f6228 f6229 f6230) (if (null? f6230) f6228 (begin (string-set! f6228 f6229 (car f6230)) (f6224 f6228 (fxadd1 f6229) (cdr f6230))))))) (lambda f6234 (let ((f6236 (make-string (list-length f6234)))) (f6224 f6236 0 f6234))))
# == vectorize-letrec  ==>
# (let ((f6224 (make-vector 1))) (begin (begin (vector-set! f6224 0 (lambda (f6228 f6229 f6230) (if (null? f6230) f6228 (begin (string-set! f6228 f6229 (car f6230)) ((vector-ref f6224 0) f6228 (fxadd1 f6229) (cdr f6230))))))) (lambda f6234 (let ((f6236 (make-string (list-length f6234)))) ((vector-ref f6224 0) f6236 0 f6234)))))
# == eliminate-set!  ==>
# (let ((f6224 (make-vector 1))) (begin (begin (vector-set! f6224 0 (lambda (f6228 f6229 f6230) (let ((f6228 f6228) (f6229 f6229) (f6230 f6230)) (if (null? f6230) f6228 (begin (string-set! f6228 f6229 (car f6230)) ((vector-ref f6224 0) f6228 (fxadd1 f6229) (cdr f6230)))))))) (lambda f6234 (let () (let ((f6236 (make-string (list-length f6234)))) ((vector-ref f6224 0) f6236 0 f6234))))))
# == close-free-variables  ==>
# (let ((f6224 (make-vector 1))) (begin (begin (vector-set! f6224 0 (closure (f6228 f6229 f6230) (f6224) (let ((f6228 f6228) (f6229 f6229) (f6230 f6230)) (if (null? f6230) f6228 (begin (string-set! f6228 f6229 (car f6230)) ((vector-ref f6224 0) f6228 (fxadd1 f6229) (cdr f6230)))))))) (closure f6234 (f6224) (let () (let ((f6236 (make-string (list-length f6234)))) ((vector-ref f6224 0) f6236 0 f6234))))))
# == eliminate-quote  ==>
# (let ((f6224 (make-vector 1))) (begin (begin (vector-set! f6224 0 (closure (f6228 f6229 f6230) (f6224) (let ((f6228 f6228) (f6229 f6229) (f6230 f6230)) (if (null? f6230) f6228 (begin (string-set! f6228 f6229 (car f6230)) ((vector-ref f6224 0) f6228 (fxadd1 f6229) (cdr f6230)))))))) (closure f6234 (f6224) (let () (let ((f6236 (make-string (list-length f6234)))) ((vector-ref f6224 0) f6236 0 f6234))))))
# == eliminate-when/unless  ==>
# (let ((f6224 (make-vector 1))) (begin (begin (vector-set! f6224 0 (closure (f6228 f6229 f6230) (f6224) (let ((f6228 f6228) (f6229 f6229) (f6230 f6230)) (if (null? f6230) f6228 (begin (string-set! f6228 f6229 (car f6230)) ((vector-ref f6224 0) f6228 (fxadd1 f6229) (cdr f6230)))))))) (closure f6234 (f6224) (let () (let ((f6236 (make-string (list-length f6234)))) ((vector-ref f6224 0) f6236 0 f6234))))))
# == eliminate-cond  ==>
# (let ((f6224 (make-vector 1))) (begin (begin (vector-set! f6224 0 (closure (f6228 f6229 f6230) (f6224) (let ((f6228 f6228) (f6229 f6229) (f6230 f6230)) (if (null? f6230) f6228 (begin (string-set! f6228 f6229 (car f6230)) ((vector-ref f6224 0) f6228 (fxadd1 f6229) (cdr f6230)))))))) (closure f6234 (f6224) (let () (let ((f6236 (make-string (list-length f6234)))) ((vector-ref f6224 0) f6236 0 f6234))))))
# == external-symbols  ==>
# (let ((f6224 (make-vector 1))) (begin (begin (vector-set! f6224 0 (closure (f6228 f6229 f6230) (f6224) (let ((f6228 f6228) (f6229 f6229) (f6230 f6230)) (if (null? f6230) f6228 (begin (string-set! f6228 f6229 (car f6230)) ((vector-ref f6224 0) f6228 (fxadd1 f6229) (cdr f6230)))))))) (closure f6234 (f6224) (let () (let ((f6236 (make-string ((primitive-ref list-length) f6234)))) ((vector-ref f6224 0) f6236 0 f6234))))))
# emit-expr (let ((f6224 (make-vector 1))) (begin (begin (vector-set! f6224 0 (closure (f6228 f6229 f6230) (f6224) (let ((f6228 f6228) (f6229 f6229) (f6230 f6230)) (if (null? f6230) f6228 (begin (string-set! f6228 f6229 (car f6230)) ((vector-ref f6224 0) f6228 (fxadd1 f6229) (cdr f6230)))))))) (closure f6234 (f6224) (let () (let ((f6236 (make-string ((primitive-ref list-length) f6234)))) ((vector-ref f6224 0) f6236 0 f6234))))))
# emit-let
#  si   = 0
#  env  = ()
#  bindings = ((f6224 (make-vector 1)))
#  body = (begin (begin (vector-set! f6224 0 (closure (f6228 f6229 f6230) (f6224) (let ((f6228 f6228) (f6229 f6229) (f6230 f6230)) (if (null? f6230) f6228 (begin (string-set! f6228 f6229 (car f6230)) ((vector-ref f6224 0) f6228 (fxadd1 f6229) (cdr f6230)))))))) (closure f6234 (f6224) (let () (let ((f6236 (make-string ((primitive-ref list-length) f6234)))) ((vector-ref f6224 0) f6236 0 f6234)))))
# emit-expr (make-vector 1)
# make-vector 1
# emit-expr 1
    movl $4, %eax     # immed 1
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_37516"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_37516:
# check the argument is a fixnum >= 0
    cmp $0,%eax
    jge _L_37517
# invoke error handler eh_length
    .extern mrc_eh$ulength
    movl mrc_eh$ulength, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_37517:
    movl %eax, %esi
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    orl  $5, %eax
    addl $4, %esi
    addl $4, %esi
    andl $-8, %esi
    addl %esi, %ebp
    movl %eax, 0(%esp)  # stack save
# emit-expr (begin (begin (vector-set! f6224 0 (closure (f6228 f6229 f6230) (f6224) (let ((f6228 f6228) (f6229 f6229) (f6230 f6230)) (if (null? f6230) f6228 (begin (string-set! f6228 f6229 (car f6230)) ((vector-ref f6224 0) f6228 (fxadd1 f6229) (cdr f6230)))))))) (closure f6234 (f6224) (let () (let ((f6236 (make-string ((primitive-ref list-length) f6234)))) ((vector-ref f6224 0) f6236 0 f6234)))))
# emit-begin
#   expr=(begin (begin (vector-set! f6224 0 (closure (f6228 f6229 f6230) (f6224) (let ((f6228 f6228) (f6229 f6229) (f6230 f6230)) (if (null? f6230) f6228 (begin (string-set! f6228 f6229 (car f6230)) ((vector-ref f6224 0) f6228 (fxadd1 f6229) (cdr f6230)))))))) (closure f6234 (f6224) (let () (let ((f6236 (make-string ((primitive-ref list-length) f6234)))) ((vector-ref f6224 0) f6236 0 f6234)))))
#   env=((f6224 . 0))
# emit-expr (begin (vector-set! f6224 0 (closure (f6228 f6229 f6230) (f6224) (let ((f6228 f6228) (f6229 f6229) (f6230 f6230)) (if (null? f6230) f6228 (begin (string-set! f6228 f6229 (car f6230)) ((vector-ref f6224 0) f6228 (fxadd1 f6229) (cdr f6230))))))))
# emit-begin
#   expr=(begin (vector-set! f6224 0 (closure (f6228 f6229 f6230) (f6224) (let ((f6228 f6228) (f6229 f6229) (f6230 f6230)) (if (null? f6230) f6228 (begin (string-set! f6228 f6229 (car f6230)) ((vector-ref f6224 0) f6228 (fxadd1 f6229) (cdr f6230))))))))
#   env=((f6224 . 0))
# emit-expr (vector-set! f6224 0 (closure (f6228 f6229 f6230) (f6224) (let ((f6228 f6228) (f6229 f6229) (f6230 f6230)) (if (null? f6230) f6228 (begin (string-set! f6228 f6229 (car f6230)) ((vector-ref f6224 0) f6228 (fxadd1 f6229) (cdr f6230)))))))
# emit-expr f6224
# emit-variable-ref
# env=((f6224 . 0))
# var=f6224
    movl 0(%esp), %eax  # stack load f6224
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_37518
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_37518:
    movl %eax, -4(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_37519"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_37519:
# check bounds on vector index
    movl -4(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_37521
    cmp  $0,%eax
    jge _L_37520
_L_37521:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_37520:
    movl %eax, -8(%esp)
# emit-expr (closure (f6228 f6229 f6230) (f6224) (let ((f6228 f6228) (f6229 f6229) (f6230 f6230)) (if (null? f6230) f6228 (begin (string-set! f6228 f6229 (car f6230)) ((vector-ref f6224 0) f6228 (fxadd1 f6229) (cdr f6230))))))
# emit-closure
# si = -12
# env = ((f6224 . 0))
# expr = (closure (f6228 f6229 f6230) (f6224) (let ((f6228 f6228) (f6229 f6229) (f6230 f6230)) (if (null? f6230) f6228 (begin (string-set! f6228 f6229 (car f6230)) ((vector-ref f6224 0) f6228 (fxadd1 f6229) (cdr f6230))))))
    movl $_L_37522, 0(%ebp)  # closure label
# emit-variable-ref
# env=((f6224 . 0))
# var=f6224
    movl 0(%esp), %eax  # stack load f6224
# end emit-variable-ref
   movl  %eax, 4(%ebp)  # f6224
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $8, %ebp     # bump ebp
    jmp _L_37523            # jump around closure body
_L_37522:
# check argument count
    cmp $12,%eax
    je _L_37524
# invoke error handler eh_argcount
    .extern mrc_eh$uargcount
    movl mrc_eh$uargcount, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_37524:
# emit-tail-expr
# si=-20
# env=((f6230 . -16) (f6229 . -12) (f6228 . -8) (f6224 . 4) (f6224 . 0))
# expr=(let ((f6228 f6228) (f6229 f6229) (f6230 f6230)) (if (null? f6230) f6228 (begin (string-set! f6228 f6229 (car f6230)) ((vector-ref f6224 0) f6228 (fxadd1 f6229) (cdr f6230)))))
# emit-tail-let
#  si   = -20
#  env  = ((f6230 . -16) (f6229 . -12) (f6228 . -8) (f6224 . 4) (f6224 . 0))
#  bindings = ((f6228 f6228) (f6229 f6229) (f6230 f6230))
#  body = (if (null? f6230) f6228 (begin (string-set! f6228 f6229 (car f6230)) ((vector-ref f6224 0) f6228 (fxadd1 f6229) (cdr f6230))))
# emit-expr f6228
# emit-variable-ref
# env=((f6230 . -16) (f6229 . -12) (f6228 . -8) (f6224 . 4) (f6224 . 0))
# var=f6228
    movl -8(%esp), %eax  # stack load f6228
# end emit-variable-ref
    movl %eax, -20(%esp)  # stack save
# emit-expr f6229
# emit-variable-ref
# env=((f6230 . -16) (f6229 . -12) (f6228 . -8) (f6224 . 4) (f6224 . 0))
# var=f6229
    movl -12(%esp), %eax  # stack load f6229
# end emit-variable-ref
    movl %eax, -24(%esp)  # stack save
# emit-expr f6230
# emit-variable-ref
# env=((f6230 . -16) (f6229 . -12) (f6228 . -8) (f6224 . 4) (f6224 . 0))
# var=f6230
    movl -16(%esp), %eax  # stack load f6230
# end emit-variable-ref
    movl %eax, -28(%esp)  # stack save
# emit-tail-expr
# si=-32
# env=((f6230 . -28) (f6229 . -24) (f6228 . -20) (f6230 . -16) (f6229 . -12) (f6228 . -8) (f6224 . 4) (f6224 . 0))
# expr=(if (null? f6230) f6228 (begin (string-set! f6228 f6229 (car f6230)) ((vector-ref f6224 0) f6228 (fxadd1 f6229) (cdr f6230))))
# emit-expr (null? f6230)
# emit-expr f6230
# emit-variable-ref
# env=((f6230 . -28) (f6229 . -24) (f6228 . -20) (f6230 . -16) (f6229 . -12) (f6228 . -8) (f6224 . 4) (f6224 . 0))
# var=f6230
    movl -28(%esp), %eax  # stack load f6230
# end emit-variable-ref
    cmp $63, %eax
    mov $0, %eax
    sete %al
    movzbl %al, %eax
    sal $6, %al
    or $47, %al
    cmp $47, %al
    je _L_37525
# emit-tail-expr
# si=-32
# env=((f6230 . -28) (f6229 . -24) (f6228 . -20) (f6230 . -16) (f6229 . -12) (f6228 . -8) (f6224 . 4) (f6224 . 0))
# expr=f6228
# emit-tail-variable-ref
# emit-variable-ref
# env=((f6230 . -28) (f6229 . -24) (f6228 . -20) (f6230 . -16) (f6229 . -12) (f6228 . -8) (f6224 . 4) (f6224 . 0))
# var=f6228
    movl -20(%esp), %eax  # stack load f6228
# end emit-variable-ref
    ret
# end emit-tail-variable ref
    jmp _L_37526
_L_37525:
# emit-tail-expr
# si=-32
# env=((f6230 . -28) (f6229 . -24) (f6228 . -20) (f6230 . -16) (f6229 . -12) (f6228 . -8) (f6224 . 4) (f6224 . 0))
# expr=(begin (string-set! f6228 f6229 (car f6230)) ((vector-ref f6224 0) f6228 (fxadd1 f6229) (cdr f6230)))
# tail-begin (begin (string-set! f6228 f6229 (car f6230)) ((vector-ref f6224 0) f6228 (fxadd1 f6229) (cdr f6230)))
#   env=((f6230 . -28) (f6229 . -24) (f6228 . -20) (f6230 . -16) (f6229 . -12) (f6228 . -8) (f6224 . 4) (f6224 . 0))
# emit-expr (string-set! f6228 f6229 (car f6230))
# emit-expr f6228
# emit-variable-ref
# env=((f6230 . -28) (f6229 . -24) (f6228 . -20) (f6230 . -16) (f6229 . -12) (f6228 . -8) (f6224 . 4) (f6224 . 0))
# var=f6228
    movl -20(%esp), %eax  # stack load f6228
# end emit-variable-ref
# check the argument is a string
    movl %eax,%ebx
    and $7, %bl
    cmp $6, %bl
    je _L_37527
# invoke error handler eh_string
    .extern mrc_eh$ustring
    movl mrc_eh$ustring, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $168,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_37527:
    movl %eax, -32(%esp)
# emit-expr f6229
# emit-variable-ref
# env=((f6230 . -28) (f6229 . -24) (f6228 . -20) (f6230 . -16) (f6229 . -12) (f6228 . -8) (f6224 . 4) (f6224 . 0))
# var=f6229
    movl -24(%esp), %eax  # stack load f6229
# end emit-variable-ref
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_37528"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $168,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_37528:
# check bounds on string index
    movl -32(%esp), %ebx
    cmp  %eax,-6(%ebx) 
    jle _L_37530
    cmp  $0,%eax
    jge _L_37529
_L_37530:
# invoke error handler eh_string_index
    .extern mrc_eh$ustring$uindex
    movl mrc_eh$ustring$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $168,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_37529:
    movl %eax, -36(%esp)
# emit-expr (car f6230)
# emit-expr f6230
# emit-variable-ref
# env=((f6230 . -28) (f6229 . -24) (f6228 . -20) (f6230 . -16) (f6229 . -12) (f6228 . -8) (f6224 . 4) (f6224 . 0))
# var=f6230
    movl -28(%esp), %eax  # stack load f6230
# end emit-variable-ref
# check the argument is a pair
    movl %eax,%ebx
    and $7, %bl
    cmp $1, %bl
    je _L_37531
# invoke error handler eh_pair
    .extern mrc_eh$upair
    movl mrc_eh$upair, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $116,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_37531:
    movl -1(%eax), %eax
# check the argument is a char
    movl %eax,%ebx
    and $255, %bl
    cmp $15, %bl
    je "_L_37532"
# invoke error handler eh_character
    .extern mrc_eh$ucharacter
    movl mrc_eh$ucharacter, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $168,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_37532:
    movl -32(%esp), %ebx
    movl -36(%esp), %esi
    sar $2, %esi
    movb  %ah, -2(%ebx,%esi)
# emit-tail-expr
# si=-32
# env=((f6230 . -28) (f6229 . -24) (f6228 . -20) (f6230 . -16) (f6229 . -12) (f6228 . -8) (f6224 . 4) (f6224 . 0))
# expr=(begin ((vector-ref f6224 0) f6228 (fxadd1 f6229) (cdr f6230)))
# tail-begin (begin ((vector-ref f6224 0) f6228 (fxadd1 f6229) (cdr f6230)))
#   env=((f6230 . -28) (f6229 . -24) (f6228 . -20) (f6230 . -16) (f6229 . -12) (f6228 . -8) (f6224 . 4) (f6224 . 0))
# emit-tail-expr
# si=-32
# env=((f6230 . -28) (f6229 . -24) (f6228 . -20) (f6230 . -16) (f6229 . -12) (f6228 . -8) (f6224 . 4) (f6224 . 0))
# expr=((vector-ref f6224 0) f6228 (fxadd1 f6229) (cdr f6230))
# emit-tail-funcall
#    si   =-32
#    env  = ((f6230 . -28) (f6229 . -24) (f6228 . -20) (f6230 . -16) (f6229 . -12) (f6228 . -8) (f6224 . 4) (f6224 . 0))
#    expr = (funcall (vector-ref f6224 0) f6228 (fxadd1 f6229) (cdr f6230))
# emit-expr (vector-ref f6224 0)
# emit-expr f6224
# emit-variable-ref
# env=((f6230 . -28) (f6229 . -24) (f6228 . -20) (f6230 . -16) (f6229 . -12) (f6228 . -8) (f6224 . 4) (f6224 . 0))
# var=f6224
    movl 2(%edi), %eax  # frame load f6224
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_37533
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_37533:
    movl %eax, -32(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_37534"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_37534:
# check bounds on vector index
    movl -32(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_37536
    cmp  $0,%eax
    jge _L_37535
_L_37536:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_37535:
    movl -32(%esp), %esi
    movl -1(%eax,%esi), %eax
   movl %eax,  -32(%esp)  # stash funcall-oper in next closure slot
# emit-expr f6228
# emit-variable-ref
# env=((f6230 . -28) (f6229 . -24) (f6228 . -20) (f6230 . -16) (f6229 . -12) (f6228 . -8) (f6224 . 4) (f6224 . 0))
# var=f6228
    movl -20(%esp), %eax  # stack load f6228
# end emit-variable-ref
    mov %eax, -36(%esp)    # arg f6228
# emit-expr (fxadd1 f6229)
# emit-expr f6229
# emit-variable-ref
# env=((f6230 . -28) (f6229 . -24) (f6228 . -20) (f6230 . -16) (f6229 . -12) (f6228 . -8) (f6224 . 4) (f6224 . 0))
# var=f6229
    movl -24(%esp), %eax  # stack load f6229
# end emit-variable-ref
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_37537"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $56,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_37537:
     addl $4, %eax
    mov %eax, -40(%esp)    # arg (fxadd1 f6229)
# emit-expr (cdr f6230)
# emit-expr f6230
# emit-variable-ref
# env=((f6230 . -28) (f6229 . -24) (f6228 . -20) (f6230 . -16) (f6229 . -12) (f6228 . -8) (f6224 . 4) (f6224 . 0))
# var=f6230
    movl -28(%esp), %eax  # stack load f6230
# end emit-variable-ref
# check the argument is a pair
    movl %eax,%ebx
    and $7, %bl
    cmp $1, %bl
    je _L_37538
# invoke error handler eh_pair
    .extern mrc_eh$upair
    movl mrc_eh$upair, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $120,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_37538:
    movl 3(%eax), %eax
    mov %eax, -44(%esp)    # arg (cdr f6230)
    movl -32(%esp), %edi   # load new closure to %edi
# emit-shift-args:  size=4   si=-32  delta=28
    mov -32(%esp), %ebx  # shift frame cell
    mov %ebx, -4(%esp)  # down to base
# emit-shift-args:  size=3   si=-36  delta=28
    mov -36(%esp), %ebx  # shift frame cell
    mov %ebx, -8(%esp)  # down to base
# emit-shift-args:  size=2   si=-40  delta=28
    mov -40(%esp), %ebx  # shift frame cell
    mov %ebx, -12(%esp)  # down to base
# emit-shift-args:  size=1   si=-44  delta=28
    mov -44(%esp), %ebx  # shift frame cell
    mov %ebx, -16(%esp)  # down to base
# emit-shift-args:  size=0   si=-48  delta=28
    movl $12,%eax   # save arg count
    jmp *-2(%edi)  # tail-funcall
     ret   # return thru stack
_L_37526:
    .align 4,0x90
_L_37523:
    movl -4(%esp), %ebx
    movl -8(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin)
# emit-begin
#   expr=(begin)
#   env=((f6224 . 0))
# emit-expr (begin (closure f6234 (f6224) (let () (let ((f6236 (make-string ((primitive-ref list-length) f6234)))) ((vector-ref f6224 0) f6236 0 f6234)))))
# emit-begin
#   expr=(begin (closure f6234 (f6224) (let () (let ((f6236 (make-string ((primitive-ref list-length) f6234)))) ((vector-ref f6224 0) f6236 0 f6234)))))
#   env=((f6224 . 0))
# emit-expr (closure f6234 (f6224) (let () (let ((f6236 (make-string ((primitive-ref list-length) f6234)))) ((vector-ref f6224 0) f6236 0 f6234))))
# emit-closure
# si = -4
# env = ((f6224 . 0))
# expr = (closure f6234 (f6224) (let () (let ((f6236 (make-string ((primitive-ref list-length) f6234)))) ((vector-ref f6224 0) f6236 0 f6234))))
    movl $_L_37539, 0(%ebp)  # closure label
# emit-variable-ref
# env=((f6224 . 0))
# var=f6224
    movl 0(%esp), %eax  # stack load f6224
# end emit-variable-ref
   movl  %eax, 4(%ebp)  # f6224
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $8, %ebp     # bump ebp
    jmp _L_37540            # jump around closure body
_L_37539:
# check argument count
    cmp $0,%eax
    jge _L_37541
# invoke error handler eh_argcount_min
    .extern mrc_eh$uargcount$umin
    movl mrc_eh$uargcount$umin, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_37541:
# emit-build-varargs-list
    movl $63, %esi       # args <- () 
    lea -4(%esp),%edi    # edi <- esp-4
    subl %eax, %edi      # edi <- esp-4-eax    addr of arg[K+N] on stack
_L_37543:
    lea -4(%esp),%ebx    # addr of arg[K] on stack
    cmp %edi, %ebx       # while edi <> esp+(si+4)
    je _L_37542
    movl (%edi),%ebx     # arg i -> car
    movl %ebx, 0(%ebp)
    movl %esi, 4(%ebp)  # esi -> cdr
    movl %ebp, %esi
    addl $1, %esi       # tag as pair
    addl $8,%ebp         # bump heap ptr
    addl $4,%edi         # move to next previous arg from the end
    jmp _L_37543
_L_37542:
    movl %esi, -8(%esp)  # set args
# emit-tail-expr
# si=-12
# env=((f6234 . -8) (f6224 . 4) (f6224 . 0))
# expr=(let () (let ((f6236 (make-string ((primitive-ref list-length) f6234)))) ((vector-ref f6224 0) f6236 0 f6234)))
# emit-tail-let
#  si   = -12
#  env  = ((f6234 . -8) (f6224 . 4) (f6224 . 0))
#  bindings = ()
#  body = (let ((f6236 (make-string ((primitive-ref list-length) f6234)))) ((vector-ref f6224 0) f6236 0 f6234))
# emit-tail-expr
# si=-12
# env=((f6234 . -8) (f6224 . 4) (f6224 . 0))
# expr=(let ((f6236 (make-string ((primitive-ref list-length) f6234)))) ((vector-ref f6224 0) f6236 0 f6234))
# emit-tail-let
#  si   = -12
#  env  = ((f6234 . -8) (f6224 . 4) (f6224 . 0))
#  bindings = ((f6236 (make-string ((primitive-ref list-length) f6234))))
#  body = ((vector-ref f6224 0) f6236 0 f6234)
# emit-expr (make-string ((primitive-ref list-length) f6234))
# make-string len=((primitive-ref list-length) f6234)
# emit-expr ((primitive-ref list-length) f6234)
# funcall
#    si   =-12
#    env  = ((f6234 . -8) (f6224 . 4) (f6224 . 0))
#    expr = (funcall (primitive-ref list-length) f6234)
# emit-expr (primitive-ref list-length)
    .extern mrc_list$mlength
    movl mrc_list$mlength,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_37544"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_37544":
   movl %eax,  -20(%esp)  # stash funcall-oper in closure slot
# emit-expr f6234
# emit-variable-ref
# env=((f6234 . -8) (f6224 . 4) (f6224 . 0))
# var=f6234
    movl -8(%esp), %eax  # stack load f6234
# end emit-variable-ref
    mov %eax, -24(%esp)  # arg f6234
    movl -20(%esp), %edi   # load new closure to %edi
    add $-12, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $12, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_37545"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $152,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_37545:
# check the argument is a fixnum >= 0
    cmp $0,%eax
    jge _L_37546
# invoke error handler eh_length
    .extern mrc_eh$ulength
    movl mrc_eh$ulength, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $152,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_37546:
    movl %eax, %esi
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    orl $6, %eax
    sar $2, %esi
    add $4, %esi
    add $7, %esi
    andl $-8, %esi
    add  %esi, %ebp
# make-string end
    movl %eax, -12(%esp)  # stack save
# emit-tail-expr
# si=-16
# env=((f6236 . -12) (f6234 . -8) (f6224 . 4) (f6224 . 0))
# expr=((vector-ref f6224 0) f6236 0 f6234)
# emit-tail-funcall
#    si   =-16
#    env  = ((f6236 . -12) (f6234 . -8) (f6224 . 4) (f6224 . 0))
#    expr = (funcall (vector-ref f6224 0) f6236 0 f6234)
# emit-expr (vector-ref f6224 0)
# emit-expr f6224
# emit-variable-ref
# env=((f6236 . -12) (f6234 . -8) (f6224 . 4) (f6224 . 0))
# var=f6224
    movl 2(%edi), %eax  # frame load f6224
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_37547
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_37547:
    movl %eax, -16(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_37548"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_37548:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_37550
    cmp  $0,%eax
    jge _L_37549
_L_37550:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_37549:
    movl -16(%esp), %esi
    movl -1(%eax,%esi), %eax
   movl %eax,  -16(%esp)  # stash funcall-oper in next closure slot
# emit-expr f6236
# emit-variable-ref
# env=((f6236 . -12) (f6234 . -8) (f6224 . 4) (f6224 . 0))
# var=f6236
    movl -12(%esp), %eax  # stack load f6236
# end emit-variable-ref
    mov %eax, -20(%esp)    # arg f6236
# emit-expr 0
    movl $0, %eax     # immed 0
    mov %eax, -24(%esp)    # arg 0
# emit-expr f6234
# emit-variable-ref
# env=((f6236 . -12) (f6234 . -8) (f6224 . 4) (f6224 . 0))
# var=f6234
    movl -8(%esp), %eax  # stack load f6234
# end emit-variable-ref
    mov %eax, -28(%esp)    # arg f6234
    movl -16(%esp), %edi   # load new closure to %edi
# emit-shift-args:  size=4   si=-16  delta=12
    mov -16(%esp), %ebx  # shift frame cell
    mov %ebx, -4(%esp)  # down to base
# emit-shift-args:  size=3   si=-20  delta=12
    mov -20(%esp), %ebx  # shift frame cell
    mov %ebx, -8(%esp)  # down to base
# emit-shift-args:  size=2   si=-24  delta=12
    mov -24(%esp), %ebx  # shift frame cell
    mov %ebx, -12(%esp)  # down to base
# emit-shift-args:  size=1   si=-28  delta=12
    mov -28(%esp), %ebx  # shift frame cell
    mov %ebx, -16(%esp)  # down to base
# emit-shift-args:  size=0   si=-32  delta=12
    movl $12,%eax   # save arg count
    jmp *-2(%edi)  # tail-funcall
    .align 4,0x90
_L_37540:
# emit-expr (begin)
# emit-begin
#   expr=(begin)
#   env=((f6224 . 0))
     movl %eax, mrc_string
# == explicit-begins  ==>
# (letrec ((f (lambda (s i) (if (fx= i (string-length s)) (quote ()) (cons (string-ref s i) (f s (fxadd1 i))))))) (lambda (s) (f s 0)))
# == eliminate-let*  ==>
# (letrec ((f (lambda (s i) (if (fx= i (string-length s)) (quote ()) (cons (string-ref s i) (f s (fxadd1 i))))))) (lambda (s) (f s 0)))
# == uniquify-variables  ==>
# (letrec ((f6237 (lambda (f6240 f6241) (if (fx= f6241 (string-length f6240)) (quote ()) (cons (string-ref f6240 f6241) (f6237 f6240 (fxadd1 f6241))))))) (lambda (f6243) (f6237 f6243 0)))
# == vectorize-letrec  ==>
# (let ((f6237 (make-vector 1))) (begin (begin (vector-set! f6237 0 (lambda (f6240 f6241) (if (fx= f6241 (string-length f6240)) (quote ()) (cons (string-ref f6240 f6241) ((vector-ref f6237 0) f6240 (fxadd1 f6241))))))) (lambda (f6243) ((vector-ref f6237 0) f6243 0))))
# == eliminate-set!  ==>
# (let ((f6237 (make-vector 1))) (begin (begin (vector-set! f6237 0 (lambda (f6240 f6241) (let ((f6240 f6240) (f6241 f6241)) (if (fx= f6241 (string-length f6240)) (quote ()) (cons (string-ref f6240 f6241) ((vector-ref f6237 0) f6240 (fxadd1 f6241)))))))) (lambda (f6243) (let ((f6243 f6243)) ((vector-ref f6237 0) f6243 0)))))
# == close-free-variables  ==>
# (let ((f6237 (make-vector 1))) (begin (begin (vector-set! f6237 0 (closure (f6240 f6241) (f6237) (let ((f6240 f6240) (f6241 f6241)) (if (fx= f6241 (string-length f6240)) (quote ()) (cons (string-ref f6240 f6241) ((vector-ref f6237 0) f6240 (fxadd1 f6241)))))))) (closure (f6243) (f6237) (let ((f6243 f6243)) ((vector-ref f6237 0) f6243 0)))))
# == eliminate-quote  ==>
# (let ((f6237 (make-vector 1))) (begin (begin (vector-set! f6237 0 (closure (f6240 f6241) (f6237) (let ((f6240 f6240) (f6241 f6241)) (if (fx= f6241 (string-length f6240)) () (cons (string-ref f6240 f6241) ((vector-ref f6237 0) f6240 (fxadd1 f6241)))))))) (closure (f6243) (f6237) (let ((f6243 f6243)) ((vector-ref f6237 0) f6243 0)))))
# == eliminate-when/unless  ==>
# (let ((f6237 (make-vector 1))) (begin (begin (vector-set! f6237 0 (closure (f6240 f6241) (f6237) (let ((f6240 f6240) (f6241 f6241)) (if (fx= f6241 (string-length f6240)) () (cons (string-ref f6240 f6241) ((vector-ref f6237 0) f6240 (fxadd1 f6241)))))))) (closure (f6243) (f6237) (let ((f6243 f6243)) ((vector-ref f6237 0) f6243 0)))))
# == eliminate-cond  ==>
# (let ((f6237 (make-vector 1))) (begin (begin (vector-set! f6237 0 (closure (f6240 f6241) (f6237) (let ((f6240 f6240) (f6241 f6241)) (if (fx= f6241 (string-length f6240)) () (cons (string-ref f6240 f6241) ((vector-ref f6237 0) f6240 (fxadd1 f6241)))))))) (closure (f6243) (f6237) (let ((f6243 f6243)) ((vector-ref f6237 0) f6243 0)))))
# == external-symbols  ==>
# (let ((f6237 (make-vector 1))) (begin (begin (vector-set! f6237 0 (closure (f6240 f6241) (f6237) (let ((f6240 f6240) (f6241 f6241)) (if (fx= f6241 (string-length f6240)) () (cons (string-ref f6240 f6241) ((vector-ref f6237 0) f6240 (fxadd1 f6241)))))))) (closure (f6243) (f6237) (let ((f6243 f6243)) ((vector-ref f6237 0) f6243 0)))))
# emit-expr (let ((f6237 (make-vector 1))) (begin (begin (vector-set! f6237 0 (closure (f6240 f6241) (f6237) (let ((f6240 f6240) (f6241 f6241)) (if (fx= f6241 (string-length f6240)) () (cons (string-ref f6240 f6241) ((vector-ref f6237 0) f6240 (fxadd1 f6241)))))))) (closure (f6243) (f6237) (let ((f6243 f6243)) ((vector-ref f6237 0) f6243 0)))))
# emit-let
#  si   = 0
#  env  = ()
#  bindings = ((f6237 (make-vector 1)))
#  body = (begin (begin (vector-set! f6237 0 (closure (f6240 f6241) (f6237) (let ((f6240 f6240) (f6241 f6241)) (if (fx= f6241 (string-length f6240)) () (cons (string-ref f6240 f6241) ((vector-ref f6237 0) f6240 (fxadd1 f6241)))))))) (closure (f6243) (f6237) (let ((f6243 f6243)) ((vector-ref f6237 0) f6243 0))))
# emit-expr (make-vector 1)
# make-vector 1
# emit-expr 1
    movl $4, %eax     # immed 1
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_37551"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_37551:
# check the argument is a fixnum >= 0
    cmp $0,%eax
    jge _L_37552
# invoke error handler eh_length
    .extern mrc_eh$ulength
    movl mrc_eh$ulength, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_37552:
    movl %eax, %esi
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    orl  $5, %eax
    addl $4, %esi
    addl $4, %esi
    andl $-8, %esi
    addl %esi, %ebp
    movl %eax, 0(%esp)  # stack save
# emit-expr (begin (begin (vector-set! f6237 0 (closure (f6240 f6241) (f6237) (let ((f6240 f6240) (f6241 f6241)) (if (fx= f6241 (string-length f6240)) () (cons (string-ref f6240 f6241) ((vector-ref f6237 0) f6240 (fxadd1 f6241)))))))) (closure (f6243) (f6237) (let ((f6243 f6243)) ((vector-ref f6237 0) f6243 0))))
# emit-begin
#   expr=(begin (begin (vector-set! f6237 0 (closure (f6240 f6241) (f6237) (let ((f6240 f6240) (f6241 f6241)) (if (fx= f6241 (string-length f6240)) () (cons (string-ref f6240 f6241) ((vector-ref f6237 0) f6240 (fxadd1 f6241)))))))) (closure (f6243) (f6237) (let ((f6243 f6243)) ((vector-ref f6237 0) f6243 0))))
#   env=((f6237 . 0))
# emit-expr (begin (vector-set! f6237 0 (closure (f6240 f6241) (f6237) (let ((f6240 f6240) (f6241 f6241)) (if (fx= f6241 (string-length f6240)) () (cons (string-ref f6240 f6241) ((vector-ref f6237 0) f6240 (fxadd1 f6241))))))))
# emit-begin
#   expr=(begin (vector-set! f6237 0 (closure (f6240 f6241) (f6237) (let ((f6240 f6240) (f6241 f6241)) (if (fx= f6241 (string-length f6240)) () (cons (string-ref f6240 f6241) ((vector-ref f6237 0) f6240 (fxadd1 f6241))))))))
#   env=((f6237 . 0))
# emit-expr (vector-set! f6237 0 (closure (f6240 f6241) (f6237) (let ((f6240 f6240) (f6241 f6241)) (if (fx= f6241 (string-length f6240)) () (cons (string-ref f6240 f6241) ((vector-ref f6237 0) f6240 (fxadd1 f6241)))))))
# emit-expr f6237
# emit-variable-ref
# env=((f6237 . 0))
# var=f6237
    movl 0(%esp), %eax  # stack load f6237
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_37553
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_37553:
    movl %eax, -4(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_37554"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_37554:
# check bounds on vector index
    movl -4(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_37556
    cmp  $0,%eax
    jge _L_37555
_L_37556:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_37555:
    movl %eax, -8(%esp)
# emit-expr (closure (f6240 f6241) (f6237) (let ((f6240 f6240) (f6241 f6241)) (if (fx= f6241 (string-length f6240)) () (cons (string-ref f6240 f6241) ((vector-ref f6237 0) f6240 (fxadd1 f6241))))))
# emit-closure
# si = -12
# env = ((f6237 . 0))
# expr = (closure (f6240 f6241) (f6237) (let ((f6240 f6240) (f6241 f6241)) (if (fx= f6241 (string-length f6240)) () (cons (string-ref f6240 f6241) ((vector-ref f6237 0) f6240 (fxadd1 f6241))))))
    movl $_L_37557, 0(%ebp)  # closure label
# emit-variable-ref
# env=((f6237 . 0))
# var=f6237
    movl 0(%esp), %eax  # stack load f6237
# end emit-variable-ref
   movl  %eax, 4(%ebp)  # f6237
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $8, %ebp     # bump ebp
    jmp _L_37558            # jump around closure body
_L_37557:
# check argument count
    cmp $8,%eax
    je _L_37559
# invoke error handler eh_argcount
    .extern mrc_eh$uargcount
    movl mrc_eh$uargcount, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_37559:
# emit-tail-expr
# si=-16
# env=((f6241 . -12) (f6240 . -8) (f6237 . 4) (f6237 . 0))
# expr=(let ((f6240 f6240) (f6241 f6241)) (if (fx= f6241 (string-length f6240)) () (cons (string-ref f6240 f6241) ((vector-ref f6237 0) f6240 (fxadd1 f6241)))))
# emit-tail-let
#  si   = -16
#  env  = ((f6241 . -12) (f6240 . -8) (f6237 . 4) (f6237 . 0))
#  bindings = ((f6240 f6240) (f6241 f6241))
#  body = (if (fx= f6241 (string-length f6240)) () (cons (string-ref f6240 f6241) ((vector-ref f6237 0) f6240 (fxadd1 f6241))))
# emit-expr f6240
# emit-variable-ref
# env=((f6241 . -12) (f6240 . -8) (f6237 . 4) (f6237 . 0))
# var=f6240
    movl -8(%esp), %eax  # stack load f6240
# end emit-variable-ref
    movl %eax, -16(%esp)  # stack save
# emit-expr f6241
# emit-variable-ref
# env=((f6241 . -12) (f6240 . -8) (f6237 . 4) (f6237 . 0))
# var=f6241
    movl -12(%esp), %eax  # stack load f6241
# end emit-variable-ref
    movl %eax, -20(%esp)  # stack save
# emit-tail-expr
# si=-24
# env=((f6241 . -20) (f6240 . -16) (f6241 . -12) (f6240 . -8) (f6237 . 4) (f6237 . 0))
# expr=(if (fx= f6241 (string-length f6240)) () (cons (string-ref f6240 f6241) ((vector-ref f6237 0) f6240 (fxadd1 f6241))))
# emit-expr (fx= f6241 (string-length f6240))
# emit-expr (string-length f6240)
# emit-expr f6240
# emit-variable-ref
# env=((f6241 . -20) (f6240 . -16) (f6241 . -12) (f6240 . -8) (f6237 . 4) (f6237 . 0))
# var=f6240
    movl -16(%esp), %eax  # stack load f6240
# end emit-variable-ref
# check the argument is a string
    movl %eax,%ebx
    and $7, %bl
    cmp $6, %bl
    je _L_37562
# invoke error handler eh_string
    .extern mrc_eh$ustring
    movl mrc_eh$ustring, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $160,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_37562:
    movl -6(%eax), %eax
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_37563"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $68,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_37563:
    movl %eax, -24(%esp)
# emit-expr f6241
# emit-variable-ref
# env=((f6241 . -20) (f6240 . -16) (f6241 . -12) (f6240 . -8) (f6237 . 4) (f6237 . 0))
# var=f6241
    movl -20(%esp), %eax  # stack load f6241
# end emit-variable-ref
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_37564"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $68,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_37564:
    cmp -24(%esp), %eax
    sete %al
    movzbl %al, %eax
    sal $6, %al
    or $47, %al
    cmp $47, %al
    je _L_37560
# emit-tail-expr
# si=-24
# env=((f6241 . -20) (f6240 . -16) (f6241 . -12) (f6240 . -8) (f6237 . 4) (f6237 . 0))
# expr=()
    movl $63, %eax     # immed ()
    ret                  # immediate tail return
    jmp _L_37561
_L_37560:
# emit-tail-expr
# si=-24
# env=((f6241 . -20) (f6240 . -16) (f6241 . -12) (f6240 . -8) (f6237 . 4) (f6237 . 0))
# expr=(cons (string-ref f6240 f6241) ((vector-ref f6237 0) f6240 (fxadd1 f6241)))
# tail primcall
# cons arg1=(string-ref f6240 f6241) arg2=((vector-ref f6237 0) f6240 (fxadd1 f6241))
# emit-expr (string-ref f6240 f6241)
# emit-expr f6240
# emit-variable-ref
# env=((f6241 . -20) (f6240 . -16) (f6241 . -12) (f6240 . -8) (f6237 . 4) (f6237 . 0))
# var=f6240
    movl -16(%esp), %eax  # stack load f6240
# end emit-variable-ref
# check the argument is a string
    movl %eax,%ebx
    and $7, %bl
    cmp $6, %bl
    je _L_37565
# invoke error handler eh_string
    .extern mrc_eh$ustring
    movl mrc_eh$ustring, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $164,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_37565:
    movl %eax, -24(%esp)
# emit-expr f6241
# emit-variable-ref
# env=((f6241 . -20) (f6240 . -16) (f6241 . -12) (f6240 . -8) (f6237 . 4) (f6237 . 0))
# var=f6241
    movl -20(%esp), %eax  # stack load f6241
# end emit-variable-ref
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_37566"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $164,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_37566:
# check bounds on string index
    movl -24(%esp), %ebx
    cmp  %eax,-6(%ebx) 
    jle _L_37568
    cmp  $0,%eax
    jge _L_37567
_L_37568:
# invoke error handler eh_string_index
    .extern mrc_eh$ustring$uindex
    movl mrc_eh$ustring$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $164,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_37567:
    sar $2, %eax
    movl -24(%esp), %esi
    movl -2(%eax,%esi), %eax
    sal $8, %eax
    or  $15, %eax
    movl %eax, -24(%esp)
# emit-expr ((vector-ref f6237 0) f6240 (fxadd1 f6241))
# funcall
#    si   =-28
#    env  = ((f6241 . -20) (f6240 . -16) (f6241 . -12) (f6240 . -8) (f6237 . 4) (f6237 . 0))
#    expr = (funcall (vector-ref f6237 0) f6240 (fxadd1 f6241))
# emit-expr (vector-ref f6237 0)
# emit-expr f6237
# emit-variable-ref
# env=((f6241 . -20) (f6240 . -16) (f6241 . -12) (f6240 . -8) (f6237 . 4) (f6237 . 0))
# var=f6237
    movl 2(%edi), %eax  # frame load f6237
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_37569
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_37569:
    movl %eax, -36(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_37570"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_37570:
# check bounds on vector index
    movl -36(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_37572
    cmp  $0,%eax
    jge _L_37571
_L_37572:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_37571:
    movl -36(%esp), %esi
    movl -1(%eax,%esi), %eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_37573"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_37573":
   movl %eax,  -36(%esp)  # stash funcall-oper in closure slot
# emit-expr f6240
# emit-variable-ref
# env=((f6241 . -20) (f6240 . -16) (f6241 . -12) (f6240 . -8) (f6237 . 4) (f6237 . 0))
# var=f6240
    movl -16(%esp), %eax  # stack load f6240
# end emit-variable-ref
    mov %eax, -40(%esp)  # arg f6240
# emit-expr (fxadd1 f6241)
# emit-expr f6241
# emit-variable-ref
# env=((f6241 . -20) (f6240 . -16) (f6241 . -12) (f6240 . -8) (f6237 . 4) (f6237 . 0))
# var=f6241
    movl -20(%esp), %eax  # stack load f6241
# end emit-variable-ref
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_37574"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $56,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_37574:
     addl $4, %eax
    mov %eax, -44(%esp)  # arg (fxadd1 f6241)
    movl -36(%esp), %edi   # load new closure to %edi
    add $-28, %esp   # adjust base
    movl $8,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $28, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    movl %eax, 4(%ebp)
    movl -24(%esp), %eax
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    or   $1, %al
    add  $8, %ebp
# cons end
#return from tail (cons (string-ref f6240 f6241) ((vector-ref f6237 0) f6240 (fxadd1 f6241)))
    ret
_L_37561:
    .align 4,0x90
_L_37558:
    movl -4(%esp), %ebx
    movl -8(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin)
# emit-begin
#   expr=(begin)
#   env=((f6237 . 0))
# emit-expr (begin (closure (f6243) (f6237) (let ((f6243 f6243)) ((vector-ref f6237 0) f6243 0))))
# emit-begin
#   expr=(begin (closure (f6243) (f6237) (let ((f6243 f6243)) ((vector-ref f6237 0) f6243 0))))
#   env=((f6237 . 0))
# emit-expr (closure (f6243) (f6237) (let ((f6243 f6243)) ((vector-ref f6237 0) f6243 0)))
# emit-closure
# si = -4
# env = ((f6237 . 0))
# expr = (closure (f6243) (f6237) (let ((f6243 f6243)) ((vector-ref f6237 0) f6243 0)))
    movl $_L_37575, 0(%ebp)  # closure label
# emit-variable-ref
# env=((f6237 . 0))
# var=f6237
    movl 0(%esp), %eax  # stack load f6237
# end emit-variable-ref
   movl  %eax, 4(%ebp)  # f6237
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $8, %ebp     # bump ebp
    jmp _L_37576            # jump around closure body
_L_37575:
# check argument count
    cmp $4,%eax
    je _L_37577
# invoke error handler eh_argcount
    .extern mrc_eh$uargcount
    movl mrc_eh$uargcount, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_37577:
# emit-tail-expr
# si=-12
# env=((f6243 . -8) (f6237 . 4) (f6237 . 0))
# expr=(let ((f6243 f6243)) ((vector-ref f6237 0) f6243 0))
# emit-tail-let
#  si   = -12
#  env  = ((f6243 . -8) (f6237 . 4) (f6237 . 0))
#  bindings = ((f6243 f6243))
#  body = ((vector-ref f6237 0) f6243 0)
# emit-expr f6243
# emit-variable-ref
# env=((f6243 . -8) (f6237 . 4) (f6237 . 0))
# var=f6243
    movl -8(%esp), %eax  # stack load f6243
# end emit-variable-ref
    movl %eax, -12(%esp)  # stack save
# emit-tail-expr
# si=-16
# env=((f6243 . -12) (f6243 . -8) (f6237 . 4) (f6237 . 0))
# expr=((vector-ref f6237 0) f6243 0)
# emit-tail-funcall
#    si   =-16
#    env  = ((f6243 . -12) (f6243 . -8) (f6237 . 4) (f6237 . 0))
#    expr = (funcall (vector-ref f6237 0) f6243 0)
# emit-expr (vector-ref f6237 0)
# emit-expr f6237
# emit-variable-ref
# env=((f6243 . -12) (f6243 . -8) (f6237 . 4) (f6237 . 0))
# var=f6237
    movl 2(%edi), %eax  # frame load f6237
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_37578
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_37578:
    movl %eax, -16(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_37579"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_37579:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_37581
    cmp  $0,%eax
    jge _L_37580
_L_37581:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_37580:
    movl -16(%esp), %esi
    movl -1(%eax,%esi), %eax
   movl %eax,  -16(%esp)  # stash funcall-oper in next closure slot
# emit-expr f6243
# emit-variable-ref
# env=((f6243 . -12) (f6243 . -8) (f6237 . 4) (f6237 . 0))
# var=f6243
    movl -12(%esp), %eax  # stack load f6243
# end emit-variable-ref
    mov %eax, -20(%esp)    # arg f6243
# emit-expr 0
    movl $0, %eax     # immed 0
    mov %eax, -24(%esp)    # arg 0
    movl -16(%esp), %edi   # load new closure to %edi
# emit-shift-args:  size=3   si=-16  delta=12
    mov -16(%esp), %ebx  # shift frame cell
    mov %ebx, -4(%esp)  # down to base
# emit-shift-args:  size=2   si=-20  delta=12
    mov -20(%esp), %ebx  # shift frame cell
    mov %ebx, -8(%esp)  # down to base
# emit-shift-args:  size=1   si=-24  delta=12
    mov -24(%esp), %ebx  # shift frame cell
    mov %ebx, -12(%esp)  # down to base
# emit-shift-args:  size=0   si=-28  delta=12
    movl $8,%eax   # save arg count
    jmp *-2(%edi)  # tail-funcall
    .align 4,0x90
_L_37576:
# emit-expr (begin)
# emit-begin
#   expr=(begin)
#   env=((f6237 . 0))
     movl %eax, mrc_string$m$glist
# == explicit-begins  ==>
# (letrec ((f (lambda (i l) (cond ((fx< i 10) (cons i l)) (else (f (fxquotient i 10) (cons (fxremainder i 10) l))))))) (lambda (i) (f i (quote ()))))
# == eliminate-let*  ==>
# (letrec ((f (lambda (i l) (cond ((fx< i 10) (cons i l)) (else (f (fxquotient i 10) (cons (fxremainder i 10) l))))))) (lambda (i) (f i (quote ()))))
# == uniquify-variables  ==>
# (letrec ((f6244 (lambda (f6247 f6248) (cond ((fx< f6247 10) (cons f6247 f6248)) (else (f6244 (fxquotient f6247 10) (cons (fxremainder f6247 10) f6248))))))) (lambda (f6250) (f6244 f6250 (quote ()))))
# == vectorize-letrec  ==>
# (let ((f6244 (make-vector 1))) (begin (begin (vector-set! f6244 0 (lambda (f6247 f6248) (cond ((fx< f6247 10) (cons f6247 f6248)) (else ((vector-ref f6244 0) (fxquotient f6247 10) (cons (fxremainder f6247 10) f6248))))))) (lambda (f6250) ((vector-ref f6244 0) f6250 (quote ())))))
# == eliminate-set!  ==>
# (let ((f6244 (make-vector 1))) (begin (begin (vector-set! f6244 0 (lambda (f6247 f6248) (let ((f6247 f6247) (f6248 f6248)) (cond ((fx< f6247 10) (cons f6247 f6248)) (else ((vector-ref f6244 0) (fxquotient f6247 10) (cons (fxremainder f6247 10) f6248)))))))) (lambda (f6250) (let ((f6250 f6250)) ((vector-ref f6244 0) f6250 (quote ()))))))
# == close-free-variables  ==>
# (let ((f6244 (make-vector 1))) (begin (begin (vector-set! f6244 0 (closure (f6247 f6248) (f6244) (let ((f6247 f6247) (f6248 f6248)) (cond ((fx< f6247 10) (cons f6247 f6248)) (else ((vector-ref f6244 0) (fxquotient f6247 10) (cons (fxremainder f6247 10) f6248)))))))) (closure (f6250) (f6244) (let ((f6250 f6250)) ((vector-ref f6244 0) f6250 (quote ()))))))
# == eliminate-quote  ==>
# (let ((f6244 (make-vector 1))) (begin (begin (vector-set! f6244 0 (closure (f6247 f6248) (f6244) (let ((f6247 f6247) (f6248 f6248)) (cond ((fx< f6247 10) (cons f6247 f6248)) (else ((vector-ref f6244 0) (fxquotient f6247 10) (cons (fxremainder f6247 10) f6248)))))))) (closure (f6250) (f6244) (let ((f6250 f6250)) ((vector-ref f6244 0) f6250 ())))))
# == eliminate-when/unless  ==>
# (let ((f6244 (make-vector 1))) (begin (begin (vector-set! f6244 0 (closure (f6247 f6248) (f6244) (let ((f6247 f6247) (f6248 f6248)) (cond ((fx< f6247 10) (cons f6247 f6248)) (else ((vector-ref f6244 0) (fxquotient f6247 10) (cons (fxremainder f6247 10) f6248)))))))) (closure (f6250) (f6244) (let ((f6250 f6250)) ((vector-ref f6244 0) f6250 ())))))
# == eliminate-cond  ==>
# (let ((f6244 (make-vector 1))) (begin (begin (vector-set! f6244 0 (closure (f6247 f6248) (f6244) (let ((f6247 f6247) (f6248 f6248)) (if (fx< f6247 10) (cons f6247 f6248) ((vector-ref f6244 0) (fxquotient f6247 10) (cons (fxremainder f6247 10) f6248))))))) (closure (f6250) (f6244) (let ((f6250 f6250)) ((vector-ref f6244 0) f6250 ())))))
# == external-symbols  ==>
# (let ((f6244 (make-vector 1))) (begin (begin (vector-set! f6244 0 (closure (f6247 f6248) (f6244) (let ((f6247 f6247) (f6248 f6248)) (if (fx< f6247 10) (cons f6247 f6248) ((vector-ref f6244 0) (fxquotient f6247 10) (cons (fxremainder f6247 10) f6248))))))) (closure (f6250) (f6244) (let ((f6250 f6250)) ((vector-ref f6244 0) f6250 ())))))
# emit-expr (let ((f6244 (make-vector 1))) (begin (begin (vector-set! f6244 0 (closure (f6247 f6248) (f6244) (let ((f6247 f6247) (f6248 f6248)) (if (fx< f6247 10) (cons f6247 f6248) ((vector-ref f6244 0) (fxquotient f6247 10) (cons (fxremainder f6247 10) f6248))))))) (closure (f6250) (f6244) (let ((f6250 f6250)) ((vector-ref f6244 0) f6250 ())))))
# emit-let
#  si   = 0
#  env  = ()
#  bindings = ((f6244 (make-vector 1)))
#  body = (begin (begin (vector-set! f6244 0 (closure (f6247 f6248) (f6244) (let ((f6247 f6247) (f6248 f6248)) (if (fx< f6247 10) (cons f6247 f6248) ((vector-ref f6244 0) (fxquotient f6247 10) (cons (fxremainder f6247 10) f6248))))))) (closure (f6250) (f6244) (let ((f6250 f6250)) ((vector-ref f6244 0) f6250 ()))))
# emit-expr (make-vector 1)
# make-vector 1
# emit-expr 1
    movl $4, %eax     # immed 1
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_37582"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_37582:
# check the argument is a fixnum >= 0
    cmp $0,%eax
    jge _L_37583
# invoke error handler eh_length
    .extern mrc_eh$ulength
    movl mrc_eh$ulength, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_37583:
    movl %eax, %esi
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    orl  $5, %eax
    addl $4, %esi
    addl $4, %esi
    andl $-8, %esi
    addl %esi, %ebp
    movl %eax, 0(%esp)  # stack save
# emit-expr (begin (begin (vector-set! f6244 0 (closure (f6247 f6248) (f6244) (let ((f6247 f6247) (f6248 f6248)) (if (fx< f6247 10) (cons f6247 f6248) ((vector-ref f6244 0) (fxquotient f6247 10) (cons (fxremainder f6247 10) f6248))))))) (closure (f6250) (f6244) (let ((f6250 f6250)) ((vector-ref f6244 0) f6250 ()))))
# emit-begin
#   expr=(begin (begin (vector-set! f6244 0 (closure (f6247 f6248) (f6244) (let ((f6247 f6247) (f6248 f6248)) (if (fx< f6247 10) (cons f6247 f6248) ((vector-ref f6244 0) (fxquotient f6247 10) (cons (fxremainder f6247 10) f6248))))))) (closure (f6250) (f6244) (let ((f6250 f6250)) ((vector-ref f6244 0) f6250 ()))))
#   env=((f6244 . 0))
# emit-expr (begin (vector-set! f6244 0 (closure (f6247 f6248) (f6244) (let ((f6247 f6247) (f6248 f6248)) (if (fx< f6247 10) (cons f6247 f6248) ((vector-ref f6244 0) (fxquotient f6247 10) (cons (fxremainder f6247 10) f6248)))))))
# emit-begin
#   expr=(begin (vector-set! f6244 0 (closure (f6247 f6248) (f6244) (let ((f6247 f6247) (f6248 f6248)) (if (fx< f6247 10) (cons f6247 f6248) ((vector-ref f6244 0) (fxquotient f6247 10) (cons (fxremainder f6247 10) f6248)))))))
#   env=((f6244 . 0))
# emit-expr (vector-set! f6244 0 (closure (f6247 f6248) (f6244) (let ((f6247 f6247) (f6248 f6248)) (if (fx< f6247 10) (cons f6247 f6248) ((vector-ref f6244 0) (fxquotient f6247 10) (cons (fxremainder f6247 10) f6248))))))
# emit-expr f6244
# emit-variable-ref
# env=((f6244 . 0))
# var=f6244
    movl 0(%esp), %eax  # stack load f6244
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_37584
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_37584:
    movl %eax, -4(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_37585"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_37585:
# check bounds on vector index
    movl -4(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_37587
    cmp  $0,%eax
    jge _L_37586
_L_37587:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_37586:
    movl %eax, -8(%esp)
# emit-expr (closure (f6247 f6248) (f6244) (let ((f6247 f6247) (f6248 f6248)) (if (fx< f6247 10) (cons f6247 f6248) ((vector-ref f6244 0) (fxquotient f6247 10) (cons (fxremainder f6247 10) f6248)))))
# emit-closure
# si = -12
# env = ((f6244 . 0))
# expr = (closure (f6247 f6248) (f6244) (let ((f6247 f6247) (f6248 f6248)) (if (fx< f6247 10) (cons f6247 f6248) ((vector-ref f6244 0) (fxquotient f6247 10) (cons (fxremainder f6247 10) f6248)))))
    movl $_L_37588, 0(%ebp)  # closure label
# emit-variable-ref
# env=((f6244 . 0))
# var=f6244
    movl 0(%esp), %eax  # stack load f6244
# end emit-variable-ref
   movl  %eax, 4(%ebp)  # f6244
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $8, %ebp     # bump ebp
    jmp _L_37589            # jump around closure body
_L_37588:
# check argument count
    cmp $8,%eax
    je _L_37590
# invoke error handler eh_argcount
    .extern mrc_eh$uargcount
    movl mrc_eh$uargcount, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_37590:
# emit-tail-expr
# si=-16
# env=((f6248 . -12) (f6247 . -8) (f6244 . 4) (f6244 . 0))
# expr=(let ((f6247 f6247) (f6248 f6248)) (if (fx< f6247 10) (cons f6247 f6248) ((vector-ref f6244 0) (fxquotient f6247 10) (cons (fxremainder f6247 10) f6248))))
# emit-tail-let
#  si   = -16
#  env  = ((f6248 . -12) (f6247 . -8) (f6244 . 4) (f6244 . 0))
#  bindings = ((f6247 f6247) (f6248 f6248))
#  body = (if (fx< f6247 10) (cons f6247 f6248) ((vector-ref f6244 0) (fxquotient f6247 10) (cons (fxremainder f6247 10) f6248)))
# emit-expr f6247
# emit-variable-ref
# env=((f6248 . -12) (f6247 . -8) (f6244 . 4) (f6244 . 0))
# var=f6247
    movl -8(%esp), %eax  # stack load f6247
# end emit-variable-ref
    movl %eax, -16(%esp)  # stack save
# emit-expr f6248
# emit-variable-ref
# env=((f6248 . -12) (f6247 . -8) (f6244 . 4) (f6244 . 0))
# var=f6248
    movl -12(%esp), %eax  # stack load f6248
# end emit-variable-ref
    movl %eax, -20(%esp)  # stack save
# emit-tail-expr
# si=-24
# env=((f6248 . -20) (f6247 . -16) (f6248 . -12) (f6247 . -8) (f6244 . 4) (f6244 . 0))
# expr=(if (fx< f6247 10) (cons f6247 f6248) ((vector-ref f6244 0) (fxquotient f6247 10) (cons (fxremainder f6247 10) f6248)))
# emit-expr (fx< f6247 10)
# emit-expr 10
    movl $40, %eax     # immed 10
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_37593"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $72,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_37593:
    movl %eax, -24(%esp)
# emit-expr f6247
# emit-variable-ref
# env=((f6248 . -20) (f6247 . -16) (f6248 . -12) (f6247 . -8) (f6244 . 4) (f6244 . 0))
# var=f6247
    movl -16(%esp), %eax  # stack load f6247
# end emit-variable-ref
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_37594"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $72,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_37594:
    cmp -24(%esp), %eax
    setl %al
    movzbl %al, %eax
    sal $6, %al
    or $47, %al
    cmp $47, %al
    je _L_37591
# emit-tail-expr
# si=-24
# env=((f6248 . -20) (f6247 . -16) (f6248 . -12) (f6247 . -8) (f6244 . 4) (f6244 . 0))
# expr=(cons f6247 f6248)
# tail primcall
# cons arg1=f6247 arg2=f6248
# emit-expr f6247
# emit-variable-ref
# env=((f6248 . -20) (f6247 . -16) (f6248 . -12) (f6247 . -8) (f6244 . 4) (f6244 . 0))
# var=f6247
    movl -16(%esp), %eax  # stack load f6247
# end emit-variable-ref
    movl %eax, -24(%esp)
# emit-expr f6248
# emit-variable-ref
# env=((f6248 . -20) (f6247 . -16) (f6248 . -12) (f6247 . -8) (f6244 . 4) (f6244 . 0))
# var=f6248
    movl -20(%esp), %eax  # stack load f6248
# end emit-variable-ref
    movl %eax, 4(%ebp)
    movl -24(%esp), %eax
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    or   $1, %al
    add  $8, %ebp
# cons end
#return from tail (cons f6247 f6248)
    ret
    jmp _L_37592
_L_37591:
# emit-tail-expr
# si=-24
# env=((f6248 . -20) (f6247 . -16) (f6248 . -12) (f6247 . -8) (f6244 . 4) (f6244 . 0))
# expr=((vector-ref f6244 0) (fxquotient f6247 10) (cons (fxremainder f6247 10) f6248))
# emit-tail-funcall
#    si   =-24
#    env  = ((f6248 . -20) (f6247 . -16) (f6248 . -12) (f6247 . -8) (f6244 . 4) (f6244 . 0))
#    expr = (funcall (vector-ref f6244 0) (fxquotient f6247 10) (cons (fxremainder f6247 10) f6248))
# emit-expr (vector-ref f6244 0)
# emit-expr f6244
# emit-variable-ref
# env=((f6248 . -20) (f6247 . -16) (f6248 . -12) (f6247 . -8) (f6244 . 4) (f6244 . 0))
# var=f6244
    movl 2(%edi), %eax  # frame load f6244
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_37595
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_37595:
    movl %eax, -24(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_37596"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_37596:
# check bounds on vector index
    movl -24(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_37598
    cmp  $0,%eax
    jge _L_37597
_L_37598:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_37597:
    movl -24(%esp), %esi
    movl -1(%eax,%esi), %eax
   movl %eax,  -24(%esp)  # stash funcall-oper in next closure slot
# emit-expr (fxquotient f6247 10)
# emit-expr 10
    movl $40, %eax     # immed 10
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_37600"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $100,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_37600:
    movl %eax, -28(%esp)  # denominator
# emit-expr f6247
# emit-variable-ref
# env=((f6248 . -20) (f6247 . -16) (f6248 . -12) (f6247 . -8) (f6244 . 4) (f6244 . 0))
# var=f6247
    movl -16(%esp), %eax  # stack load f6247
# end emit-variable-ref
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_37601"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $100,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_37601:
    movl -28(%esp),%ebx   # ebx <- denominator
    xor %edx,%edx        # edx <- 0
    cmp $0,%eax
    jge _L_37599
    not %edx
_L_37599:
    idiv %ebx            # eax <- edx:eax/ebx
    sal $2,%eax          # eax <- eax*4 (since it was divided away)
    mov %eax, -28(%esp)    # arg (fxquotient f6247 10)
# emit-expr (cons (fxremainder f6247 10) f6248)
# cons arg1=(fxremainder f6247 10) arg2=f6248
# emit-expr (fxremainder f6247 10)
# emit-expr 10
    movl $40, %eax     # immed 10
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_37603"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $100,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_37603:
    movl %eax, -32(%esp)  # denominator
# emit-expr f6247
# emit-variable-ref
# env=((f6248 . -20) (f6247 . -16) (f6248 . -12) (f6247 . -8) (f6244 . 4) (f6244 . 0))
# var=f6247
    movl -16(%esp), %eax  # stack load f6247
# end emit-variable-ref
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_37604"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $100,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_37604:
    movl -32(%esp),%ebx   # ebx <- denominator
    xor %edx,%edx        # edx <- 0
    cmp $0,%eax
    jge _L_37602
    not %edx
_L_37602:
    idiv %ebx            # edx <- edx:eax/ebx  remainder
    movl %edx,%eax
    movl %eax, -32(%esp)
# emit-expr f6248
# emit-variable-ref
# env=((f6248 . -20) (f6247 . -16) (f6248 . -12) (f6247 . -8) (f6244 . 4) (f6244 . 0))
# var=f6248
    movl -20(%esp), %eax  # stack load f6248
# end emit-variable-ref
    movl %eax, 4(%ebp)
    movl -32(%esp), %eax
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    or   $1, %al
    add  $8, %ebp
# cons end
    mov %eax, -32(%esp)    # arg (cons (fxremainder f6247 10) f6248)
    movl -24(%esp), %edi   # load new closure to %edi
# emit-shift-args:  size=3   si=-24  delta=20
    mov -24(%esp), %ebx  # shift frame cell
    mov %ebx, -4(%esp)  # down to base
# emit-shift-args:  size=2   si=-28  delta=20
    mov -28(%esp), %ebx  # shift frame cell
    mov %ebx, -8(%esp)  # down to base
# emit-shift-args:  size=1   si=-32  delta=20
    mov -32(%esp), %ebx  # shift frame cell
    mov %ebx, -12(%esp)  # down to base
# emit-shift-args:  size=0   si=-36  delta=20
    movl $8,%eax   # save arg count
    jmp *-2(%edi)  # tail-funcall
_L_37592:
    .align 4,0x90
_L_37589:
    movl -4(%esp), %ebx
    movl -8(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin)
# emit-begin
#   expr=(begin)
#   env=((f6244 . 0))
# emit-expr (begin (closure (f6250) (f6244) (let ((f6250 f6250)) ((vector-ref f6244 0) f6250 ()))))
# emit-begin
#   expr=(begin (closure (f6250) (f6244) (let ((f6250 f6250)) ((vector-ref f6244 0) f6250 ()))))
#   env=((f6244 . 0))
# emit-expr (closure (f6250) (f6244) (let ((f6250 f6250)) ((vector-ref f6244 0) f6250 ())))
# emit-closure
# si = -4
# env = ((f6244 . 0))
# expr = (closure (f6250) (f6244) (let ((f6250 f6250)) ((vector-ref f6244 0) f6250 ())))
    movl $_L_37605, 0(%ebp)  # closure label
# emit-variable-ref
# env=((f6244 . 0))
# var=f6244
    movl 0(%esp), %eax  # stack load f6244
# end emit-variable-ref
   movl  %eax, 4(%ebp)  # f6244
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $8, %ebp     # bump ebp
    jmp _L_37606            # jump around closure body
_L_37605:
# check argument count
    cmp $4,%eax
    je _L_37607
# invoke error handler eh_argcount
    .extern mrc_eh$uargcount
    movl mrc_eh$uargcount, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_37607:
# emit-tail-expr
# si=-12
# env=((f6250 . -8) (f6244 . 4) (f6244 . 0))
# expr=(let ((f6250 f6250)) ((vector-ref f6244 0) f6250 ()))
# emit-tail-let
#  si   = -12
#  env  = ((f6250 . -8) (f6244 . 4) (f6244 . 0))
#  bindings = ((f6250 f6250))
#  body = ((vector-ref f6244 0) f6250 ())
# emit-expr f6250
# emit-variable-ref
# env=((f6250 . -8) (f6244 . 4) (f6244 . 0))
# var=f6250
    movl -8(%esp), %eax  # stack load f6250
# end emit-variable-ref
    movl %eax, -12(%esp)  # stack save
# emit-tail-expr
# si=-16
# env=((f6250 . -12) (f6250 . -8) (f6244 . 4) (f6244 . 0))
# expr=((vector-ref f6244 0) f6250 ())
# emit-tail-funcall
#    si   =-16
#    env  = ((f6250 . -12) (f6250 . -8) (f6244 . 4) (f6244 . 0))
#    expr = (funcall (vector-ref f6244 0) f6250 ())
# emit-expr (vector-ref f6244 0)
# emit-expr f6244
# emit-variable-ref
# env=((f6250 . -12) (f6250 . -8) (f6244 . 4) (f6244 . 0))
# var=f6244
    movl 2(%edi), %eax  # frame load f6244
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_37608
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_37608:
    movl %eax, -16(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_37609"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_37609:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_37611
    cmp  $0,%eax
    jge _L_37610
_L_37611:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_37610:
    movl -16(%esp), %esi
    movl -1(%eax,%esi), %eax
   movl %eax,  -16(%esp)  # stash funcall-oper in next closure slot
# emit-expr f6250
# emit-variable-ref
# env=((f6250 . -12) (f6250 . -8) (f6244 . 4) (f6244 . 0))
# var=f6250
    movl -12(%esp), %eax  # stack load f6250
# end emit-variable-ref
    mov %eax, -20(%esp)    # arg f6250
# emit-expr ()
    movl $63, %eax     # immed ()
    mov %eax, -24(%esp)    # arg ()
    movl -16(%esp), %edi   # load new closure to %edi
# emit-shift-args:  size=3   si=-16  delta=12
    mov -16(%esp), %ebx  # shift frame cell
    mov %ebx, -4(%esp)  # down to base
# emit-shift-args:  size=2   si=-20  delta=12
    mov -20(%esp), %ebx  # shift frame cell
    mov %ebx, -8(%esp)  # down to base
# emit-shift-args:  size=1   si=-24  delta=12
    mov -24(%esp), %ebx  # shift frame cell
    mov %ebx, -12(%esp)  # down to base
# emit-shift-args:  size=0   si=-28  delta=12
    movl $8,%eax   # save arg count
    jmp *-2(%edi)  # tail-funcall
    .align 4,0x90
_L_37606:
# emit-expr (begin)
# emit-begin
#   expr=(begin)
#   env=((f6244 . 0))
     movl %eax, mrc_integer$m$glist
# == explicit-begins  ==>
# (let* ((write-stderr (lambda (s) (foreign-call "s_write" 2 s (string-length s)))) (write-errmsg (lambda (sym emsg) (begin (write-stderr "error:") (write-stderr (symbol->string sym)) (write-stderr ": ") (write-stderr emsg) (write-stderr "\n"))))) (lambda (sym emsg) (begin (write-errmsg sym emsg) (foreign-call "s_exit" 1))))
# == eliminate-let*  ==>
# (let ((write-stderr (lambda (s) (foreign-call "s_write" 2 s (string-length s))))) (let ((write-errmsg (lambda (sym emsg) (begin (write-stderr "error:") (write-stderr (symbol->string sym)) (write-stderr ": ") (write-stderr emsg) (write-stderr "\n"))))) (lambda (sym emsg) (begin (write-errmsg sym emsg) (foreign-call "s_exit" 1)))))
# == uniquify-variables  ==>
# (let ((f6251 (lambda (f6252) (foreign-call "s_write" 2 f6252 (string-length f6252))))) (let ((f6260 (lambda (f6261 f6262) (begin (f6251 "error:") (f6251 (symbol->string f6261)) (f6251 ": ") (f6251 f6262) (f6251 "\n"))))) (lambda (f6265 f6266) (begin (f6260 f6265 f6266) (foreign-call "s_exit" 1)))))
# == vectorize-letrec  ==>
# (let ((f6251 (lambda (f6252) (foreign-call "s_write" 2 f6252 (string-length f6252))))) (let ((f6260 (lambda (f6261 f6262) (begin (f6251 "error:") (f6251 (symbol->string f6261)) (f6251 ": ") (f6251 f6262) (f6251 "\n"))))) (lambda (f6265 f6266) (begin (f6260 f6265 f6266) (foreign-call "s_exit" 1)))))
# == eliminate-set!  ==>
# (let ((f6251 (lambda (f6252) (let ((f6252 f6252)) (foreign-call "s_write" 2 f6252 (string-length f6252)))))) (let ((f6260 (lambda (f6261 f6262) (let ((f6261 f6261) (f6262 f6262)) (begin (f6251 "error:") (f6251 (symbol->string f6261)) (f6251 ": ") (f6251 f6262) (f6251 "\n")))))) (lambda (f6265 f6266) (let ((f6265 f6265) (f6266 f6266)) (begin (f6260 f6265 f6266) (foreign-call "s_exit" 1))))))
# == close-free-variables  ==>
# (let ((f6251 (closure (f6252) () (let ((f6252 f6252)) (foreign-call "s_write" 2 f6252 (string-length f6252)))))) (let ((f6260 (closure (f6261 f6262) (f6251 f6251 f6251 f6251 f6251) (let ((f6261 f6261) (f6262 f6262)) (begin (f6251 "error:") (f6251 (symbol->string f6261)) (f6251 ": ") (f6251 f6262) (f6251 "\n")))))) (closure (f6265 f6266) (f6260) (let ((f6265 f6265) (f6266 f6266)) (begin (f6260 f6265 f6266) (foreign-call "s_exit" 1))))))
# == eliminate-quote  ==>
# (let ((f6251 (closure (f6252) () (let ((f6252 f6252)) (foreign-call "s_write" 2 f6252 (string-length f6252)))))) (let ((f6260 (closure (f6261 f6262) (f6251 f6251 f6251 f6251 f6251) (let ((f6261 f6261) (f6262 f6262)) (begin (f6251 "error:") (f6251 (symbol->string f6261)) (f6251 ": ") (f6251 f6262) (f6251 "\n")))))) (closure (f6265 f6266) (f6260) (let ((f6265 f6265) (f6266 f6266)) (begin (f6260 f6265 f6266) (foreign-call "s_exit" 1))))))
# == eliminate-when/unless  ==>
# (let ((f6251 (closure (f6252) () (let ((f6252 f6252)) (foreign-call "s_write" 2 f6252 (string-length f6252)))))) (let ((f6260 (closure (f6261 f6262) (f6251 f6251 f6251 f6251 f6251) (let ((f6261 f6261) (f6262 f6262)) (begin (f6251 "error:") (f6251 (symbol->string f6261)) (f6251 ": ") (f6251 f6262) (f6251 "\n")))))) (closure (f6265 f6266) (f6260) (let ((f6265 f6265) (f6266 f6266)) (begin (f6260 f6265 f6266) (foreign-call "s_exit" 1))))))
# == eliminate-cond  ==>
# (let ((f6251 (closure (f6252) () (let ((f6252 f6252)) (foreign-call "s_write" 2 f6252 (string-length f6252)))))) (let ((f6260 (closure (f6261 f6262) (f6251 f6251 f6251 f6251 f6251) (let ((f6261 f6261) (f6262 f6262)) (begin (f6251 "error:") (f6251 (symbol->string f6261)) (f6251 ": ") (f6251 f6262) (f6251 "\n")))))) (closure (f6265 f6266) (f6260) (let ((f6265 f6265) (f6266 f6266)) (begin (f6260 f6265 f6266) (foreign-call "s_exit" 1))))))
# == external-symbols  ==>
# (let ((f6251 (closure (f6252) () (let ((f6252 f6252)) (foreign-call "s_write" 2 f6252 (string-length f6252)))))) (let ((f6260 (closure (f6261 f6262) (f6251 f6251 f6251 f6251 f6251) (let ((f6261 f6261) (f6262 f6262)) (begin (f6251 "error:") (f6251 (symbol->string f6261)) (f6251 ": ") (f6251 f6262) (f6251 "\n")))))) (closure (f6265 f6266) (f6260) (let ((f6265 f6265) (f6266 f6266)) (begin (f6260 f6265 f6266) (foreign-call "s_exit" 1))))))
# emit-expr (let ((f6251 (closure (f6252) () (let ((f6252 f6252)) (foreign-call "s_write" 2 f6252 (string-length f6252)))))) (let ((f6260 (closure (f6261 f6262) (f6251 f6251 f6251 f6251 f6251) (let ((f6261 f6261) (f6262 f6262)) (begin (f6251 "error:") (f6251 (symbol->string f6261)) (f6251 ": ") (f6251 f6262) (f6251 "\n")))))) (closure (f6265 f6266) (f6260) (let ((f6265 f6265) (f6266 f6266)) (begin (f6260 f6265 f6266) (foreign-call "s_exit" 1))))))
# emit-let
#  si   = 0
#  env  = ()
#  bindings = ((f6251 (closure (f6252) () (let ((f6252 f6252)) (foreign-call "s_write" 2 f6252 (string-length f6252))))))
#  body = (let ((f6260 (closure (f6261 f6262) (f6251 f6251 f6251 f6251 f6251) (let ((f6261 f6261) (f6262 f6262)) (begin (f6251 "error:") (f6251 (symbol->string f6261)) (f6251 ": ") (f6251 f6262) (f6251 "\n")))))) (closure (f6265 f6266) (f6260) (let ((f6265 f6265) (f6266 f6266)) (begin (f6260 f6265 f6266) (foreign-call "s_exit" 1)))))
# emit-expr (closure (f6252) () (let ((f6252 f6252)) (foreign-call "s_write" 2 f6252 (string-length f6252))))
# emit-closure
# si = 0
# env = ()
# expr = (closure (f6252) () (let ((f6252 f6252)) (foreign-call "s_write" 2 f6252 (string-length f6252))))
    movl $_L_37612, 0(%ebp)  # closure label
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $8, %ebp     # bump ebp
    jmp _L_37613            # jump around closure body
_L_37612:
# check argument count
    cmp $4,%eax
    je _L_37614
# invoke error handler eh_argcount
    .extern mrc_eh$uargcount
    movl mrc_eh$uargcount, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_37614:
# emit-tail-expr
# si=-12
# env=((f6252 . -8))
# expr=(let ((f6252 f6252)) (foreign-call "s_write" 2 f6252 (string-length f6252)))
# emit-tail-let
#  si   = -12
#  env  = ((f6252 . -8))
#  bindings = ((f6252 f6252))
#  body = (foreign-call "s_write" 2 f6252 (string-length f6252))
# emit-expr f6252
# emit-variable-ref
# env=((f6252 . -8))
# var=f6252
    movl -8(%esp), %eax  # stack load f6252
# end emit-variable-ref
    movl %eax, -12(%esp)  # stack save
# emit-tail-expr
# si=-16
# env=((f6252 . -12) (f6252 . -8))
# expr=(foreign-call "s_write" 2 f6252 (string-length f6252))
    movl %ecx,-16(%esp)
    movl %esp,-20(%esp)
# emit-expr (string-length f6252)
# emit-expr f6252
# emit-variable-ref
# env=((f6252 . -12) (f6252 . -8))
# var=f6252
    movl -12(%esp), %eax  # stack load f6252
# end emit-variable-ref
# check the argument is a string
    movl %eax,%ebx
    and $7, %bl
    cmp $6, %bl
    je _L_37615
# invoke error handler eh_string
    .extern mrc_eh$ustring
    movl mrc_eh$ustring, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $160,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_37615:
    movl -6(%eax), %eax
    movl %eax, -24(%esp)
# emit-expr f6252
# emit-variable-ref
# env=((f6252 . -12) (f6252 . -8))
# var=f6252
    movl -12(%esp), %eax  # stack load f6252
# end emit-variable-ref
    movl %eax, -28(%esp)
# emit-expr 2
    movl $8, %eax     # immed 2
    movl %eax, -32(%esp)
    leal -32(%esp),%edi
    movl %edi,%esi
    andl $-16,%esi
    movl 0(%edi),%eax
    movl %eax,0(%esi)
    movl 4(%edi),%eax
    movl %eax,4(%esi)
    movl 8(%edi),%eax
    movl %eax,8(%esi)
    movl 12(%edi),%eax
    movl %eax,12(%esi)
    movl %esi,%esp
    .extern _s_write
    call _s_write
    movl 12(%esi),%esp
    movl -16(%esp),%ecx
     ret
    .align 4,0x90
_L_37613:
    movl %eax, 0(%esp)  # stack save
# emit-expr (let ((f6260 (closure (f6261 f6262) (f6251 f6251 f6251 f6251 f6251) (let ((f6261 f6261) (f6262 f6262)) (begin (f6251 "error:") (f6251 (symbol->string f6261)) (f6251 ": ") (f6251 f6262) (f6251 "\n")))))) (closure (f6265 f6266) (f6260) (let ((f6265 f6265) (f6266 f6266)) (begin (f6260 f6265 f6266) (foreign-call "s_exit" 1)))))
# emit-let
#  si   = -4
#  env  = ((f6251 . 0))
#  bindings = ((f6260 (closure (f6261 f6262) (f6251 f6251 f6251 f6251 f6251) (let ((f6261 f6261) (f6262 f6262)) (begin (f6251 "error:") (f6251 (symbol->string f6261)) (f6251 ": ") (f6251 f6262) (f6251 "\n"))))))
#  body = (closure (f6265 f6266) (f6260) (let ((f6265 f6265) (f6266 f6266)) (begin (f6260 f6265 f6266) (foreign-call "s_exit" 1))))
# emit-expr (closure (f6261 f6262) (f6251 f6251 f6251 f6251 f6251) (let ((f6261 f6261) (f6262 f6262)) (begin (f6251 "error:") (f6251 (symbol->string f6261)) (f6251 ": ") (f6251 f6262) (f6251 "\n"))))
# emit-closure
# si = -4
# env = ((f6251 . 0))
# expr = (closure (f6261 f6262) (f6251 f6251 f6251 f6251 f6251) (let ((f6261 f6261) (f6262 f6262)) (begin (f6251 "error:") (f6251 (symbol->string f6261)) (f6251 ": ") (f6251 f6262) (f6251 "\n"))))
    movl $_L_37616, 0(%ebp)  # closure label
# emit-variable-ref
# env=((f6251 . 0))
# var=f6251
    movl 0(%esp), %eax  # stack load f6251
# end emit-variable-ref
   movl  %eax, 4(%ebp)  # f6251
# emit-variable-ref
# env=((f6251 . 0))
# var=f6251
    movl 0(%esp), %eax  # stack load f6251
# end emit-variable-ref
   movl  %eax, 8(%ebp)  # f6251
# emit-variable-ref
# env=((f6251 . 0))
# var=f6251
    movl 0(%esp), %eax  # stack load f6251
# end emit-variable-ref
   movl  %eax, 12(%ebp)  # f6251
# emit-variable-ref
# env=((f6251 . 0))
# var=f6251
    movl 0(%esp), %eax  # stack load f6251
# end emit-variable-ref
   movl  %eax, 16(%ebp)  # f6251
# emit-variable-ref
# env=((f6251 . 0))
# var=f6251
    movl 0(%esp), %eax  # stack load f6251
# end emit-variable-ref
   movl  %eax, 20(%ebp)  # f6251
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $24, %ebp     # bump ebp
    jmp _L_37617            # jump around closure body
_L_37616:
# check argument count
    cmp $8,%eax
    je _L_37618
# invoke error handler eh_argcount
    .extern mrc_eh$uargcount
    movl mrc_eh$uargcount, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_37618:
# emit-tail-expr
# si=-16
# env=((f6262 . -12) (f6261 . -8) (f6251 . 20) (f6251 . 16) (f6251 . 12) (f6251 . 8) (f6251 . 4) (f6251 . 0))
# expr=(let ((f6261 f6261) (f6262 f6262)) (begin (f6251 "error:") (f6251 (symbol->string f6261)) (f6251 ": ") (f6251 f6262) (f6251 "\n")))
# emit-tail-let
#  si   = -16
#  env  = ((f6262 . -12) (f6261 . -8) (f6251 . 20) (f6251 . 16) (f6251 . 12) (f6251 . 8) (f6251 . 4) (f6251 . 0))
#  bindings = ((f6261 f6261) (f6262 f6262))
#  body = (begin (f6251 "error:") (f6251 (symbol->string f6261)) (f6251 ": ") (f6251 f6262) (f6251 "\n"))
# emit-expr f6261
# emit-variable-ref
# env=((f6262 . -12) (f6261 . -8) (f6251 . 20) (f6251 . 16) (f6251 . 12) (f6251 . 8) (f6251 . 4) (f6251 . 0))
# var=f6261
    movl -8(%esp), %eax  # stack load f6261
# end emit-variable-ref
    movl %eax, -16(%esp)  # stack save
# emit-expr f6262
# emit-variable-ref
# env=((f6262 . -12) (f6261 . -8) (f6251 . 20) (f6251 . 16) (f6251 . 12) (f6251 . 8) (f6251 . 4) (f6251 . 0))
# var=f6262
    movl -12(%esp), %eax  # stack load f6262
# end emit-variable-ref
    movl %eax, -20(%esp)  # stack save
# emit-tail-expr
# si=-24
# env=((f6262 . -20) (f6261 . -16) (f6262 . -12) (f6261 . -8) (f6251 . 20) (f6251 . 16) (f6251 . 12) (f6251 . 8) (f6251 . 4) (f6251 . 0))
# expr=(begin (f6251 "error:") (f6251 (symbol->string f6261)) (f6251 ": ") (f6251 f6262) (f6251 "\n"))
# tail-begin (begin (f6251 "error:") (f6251 (symbol->string f6261)) (f6251 ": ") (f6251 f6262) (f6251 "\n"))
#   env=((f6262 . -20) (f6261 . -16) (f6262 . -12) (f6261 . -8) (f6251 . 20) (f6251 . 16) (f6251 . 12) (f6251 . 8) (f6251 . 4) (f6251 . 0))
# emit-expr (f6251 "error:")
# funcall
#    si   =-24
#    env  = ((f6262 . -20) (f6261 . -16) (f6262 . -12) (f6261 . -8) (f6251 . 20) (f6251 . 16) (f6251 . 12) (f6251 . 8) (f6251 . 4) (f6251 . 0))
#    expr = (funcall f6251 "error:")
# emit-expr f6251
# emit-variable-ref
# env=((f6262 . -20) (f6261 . -16) (f6262 . -12) (f6261 . -8) (f6251 . 20) (f6251 . 16) (f6251 . 12) (f6251 . 8) (f6251 . 4) (f6251 . 0))
# var=f6251
    movl 18(%edi), %eax  # frame load f6251
# end emit-variable-ref
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_37619"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_37619":
   movl %eax,  -32(%esp)  # stash funcall-oper in closure slot
# emit-expr "error:"
# string literal
    jmp _L_37621
    .align 8,0x90
_L_37620 :
    .int 24
    .ascii "error:"
_L_37621:
    movl $_L_37620, %eax
    orl $6, %eax
    mov %eax, -36(%esp)  # arg error:
    movl -32(%esp), %edi   # load new closure to %edi
    add $-24, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $24, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
# emit-tail-expr
# si=-24
# env=((f6262 . -20) (f6261 . -16) (f6262 . -12) (f6261 . -8) (f6251 . 20) (f6251 . 16) (f6251 . 12) (f6251 . 8) (f6251 . 4) (f6251 . 0))
# expr=(begin (f6251 (symbol->string f6261)) (f6251 ": ") (f6251 f6262) (f6251 "\n"))
# tail-begin (begin (f6251 (symbol->string f6261)) (f6251 ": ") (f6251 f6262) (f6251 "\n"))
#   env=((f6262 . -20) (f6261 . -16) (f6262 . -12) (f6261 . -8) (f6251 . 20) (f6251 . 16) (f6251 . 12) (f6251 . 8) (f6251 . 4) (f6251 . 0))
# emit-expr (f6251 (symbol->string f6261))
# funcall
#    si   =-24
#    env  = ((f6262 . -20) (f6261 . -16) (f6262 . -12) (f6261 . -8) (f6251 . 20) (f6251 . 16) (f6251 . 12) (f6251 . 8) (f6251 . 4) (f6251 . 0))
#    expr = (funcall f6251 (symbol->string f6261))
# emit-expr f6251
# emit-variable-ref
# env=((f6262 . -20) (f6261 . -16) (f6262 . -12) (f6261 . -8) (f6251 . 20) (f6251 . 16) (f6251 . 12) (f6251 . 8) (f6251 . 4) (f6251 . 0))
# var=f6251
    movl 18(%edi), %eax  # frame load f6251
# end emit-variable-ref
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_37622"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_37622":
   movl %eax,  -32(%esp)  # stash funcall-oper in closure slot
# emit-expr (symbol->string f6261)
# symbol->string f6261
# emit-expr f6261
# emit-variable-ref
# env=((f6262 . -20) (f6261 . -16) (f6262 . -12) (f6261 . -8) (f6251 . 20) (f6251 . 16) (f6251 . 12) (f6251 . 8) (f6251 . 4) (f6251 . 0))
# var=f6261
    movl -16(%esp), %eax  # stack load f6261
# end emit-variable-ref
    movl -3(%eax), %eax
    mov %eax, -36(%esp)  # arg (symbol->string f6261)
    movl -32(%esp), %edi   # load new closure to %edi
    add $-24, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $24, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
# emit-tail-expr
# si=-24
# env=((f6262 . -20) (f6261 . -16) (f6262 . -12) (f6261 . -8) (f6251 . 20) (f6251 . 16) (f6251 . 12) (f6251 . 8) (f6251 . 4) (f6251 . 0))
# expr=(begin (f6251 ": ") (f6251 f6262) (f6251 "\n"))
# tail-begin (begin (f6251 ": ") (f6251 f6262) (f6251 "\n"))
#   env=((f6262 . -20) (f6261 . -16) (f6262 . -12) (f6261 . -8) (f6251 . 20) (f6251 . 16) (f6251 . 12) (f6251 . 8) (f6251 . 4) (f6251 . 0))
# emit-expr (f6251 ": ")
# funcall
#    si   =-24
#    env  = ((f6262 . -20) (f6261 . -16) (f6262 . -12) (f6261 . -8) (f6251 . 20) (f6251 . 16) (f6251 . 12) (f6251 . 8) (f6251 . 4) (f6251 . 0))
#    expr = (funcall f6251 ": ")
# emit-expr f6251
# emit-variable-ref
# env=((f6262 . -20) (f6261 . -16) (f6262 . -12) (f6261 . -8) (f6251 . 20) (f6251 . 16) (f6251 . 12) (f6251 . 8) (f6251 . 4) (f6251 . 0))
# var=f6251
    movl 18(%edi), %eax  # frame load f6251
# end emit-variable-ref
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_37623"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_37623":
   movl %eax,  -32(%esp)  # stash funcall-oper in closure slot
# emit-expr ": "
# string literal
    jmp _L_37625
    .align 8,0x90
_L_37624 :
    .int 8
    .ascii ": "
_L_37625:
    movl $_L_37624, %eax
    orl $6, %eax
    mov %eax, -36(%esp)  # arg : 
    movl -32(%esp), %edi   # load new closure to %edi
    add $-24, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $24, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
# emit-tail-expr
# si=-24
# env=((f6262 . -20) (f6261 . -16) (f6262 . -12) (f6261 . -8) (f6251 . 20) (f6251 . 16) (f6251 . 12) (f6251 . 8) (f6251 . 4) (f6251 . 0))
# expr=(begin (f6251 f6262) (f6251 "\n"))
# tail-begin (begin (f6251 f6262) (f6251 "\n"))
#   env=((f6262 . -20) (f6261 . -16) (f6262 . -12) (f6261 . -8) (f6251 . 20) (f6251 . 16) (f6251 . 12) (f6251 . 8) (f6251 . 4) (f6251 . 0))
# emit-expr (f6251 f6262)
# funcall
#    si   =-24
#    env  = ((f6262 . -20) (f6261 . -16) (f6262 . -12) (f6261 . -8) (f6251 . 20) (f6251 . 16) (f6251 . 12) (f6251 . 8) (f6251 . 4) (f6251 . 0))
#    expr = (funcall f6251 f6262)
# emit-expr f6251
# emit-variable-ref
# env=((f6262 . -20) (f6261 . -16) (f6262 . -12) (f6261 . -8) (f6251 . 20) (f6251 . 16) (f6251 . 12) (f6251 . 8) (f6251 . 4) (f6251 . 0))
# var=f6251
    movl 18(%edi), %eax  # frame load f6251
# end emit-variable-ref
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_37626"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_37626":
   movl %eax,  -32(%esp)  # stash funcall-oper in closure slot
# emit-expr f6262
# emit-variable-ref
# env=((f6262 . -20) (f6261 . -16) (f6262 . -12) (f6261 . -8) (f6251 . 20) (f6251 . 16) (f6251 . 12) (f6251 . 8) (f6251 . 4) (f6251 . 0))
# var=f6262
    movl -20(%esp), %eax  # stack load f6262
# end emit-variable-ref
    mov %eax, -36(%esp)  # arg f6262
    movl -32(%esp), %edi   # load new closure to %edi
    add $-24, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $24, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
# emit-tail-expr
# si=-24
# env=((f6262 . -20) (f6261 . -16) (f6262 . -12) (f6261 . -8) (f6251 . 20) (f6251 . 16) (f6251 . 12) (f6251 . 8) (f6251 . 4) (f6251 . 0))
# expr=(begin (f6251 "\n"))
# tail-begin (begin (f6251 "\n"))
#   env=((f6262 . -20) (f6261 . -16) (f6262 . -12) (f6261 . -8) (f6251 . 20) (f6251 . 16) (f6251 . 12) (f6251 . 8) (f6251 . 4) (f6251 . 0))
# emit-tail-expr
# si=-24
# env=((f6262 . -20) (f6261 . -16) (f6262 . -12) (f6261 . -8) (f6251 . 20) (f6251 . 16) (f6251 . 12) (f6251 . 8) (f6251 . 4) (f6251 . 0))
# expr=(f6251 "\n")
# emit-tail-funcall
#    si   =-24
#    env  = ((f6262 . -20) (f6261 . -16) (f6262 . -12) (f6261 . -8) (f6251 . 20) (f6251 . 16) (f6251 . 12) (f6251 . 8) (f6251 . 4) (f6251 . 0))
#    expr = (funcall f6251 "\n")
# emit-expr f6251
# emit-variable-ref
# env=((f6262 . -20) (f6261 . -16) (f6262 . -12) (f6261 . -8) (f6251 . 20) (f6251 . 16) (f6251 . 12) (f6251 . 8) (f6251 . 4) (f6251 . 0))
# var=f6251
    movl 18(%edi), %eax  # frame load f6251
# end emit-variable-ref
   movl %eax,  -24(%esp)  # stash funcall-oper in next closure slot
# emit-expr "\n"
# string literal
    jmp _L_37628
    .align 8,0x90
_L_37627 :
    .int 4
    .ascii "\n"
_L_37628:
    movl $_L_37627, %eax
    orl $6, %eax
    mov %eax, -28(%esp)    # arg 

    movl -24(%esp), %edi   # load new closure to %edi
# emit-shift-args:  size=2   si=-24  delta=20
    mov -24(%esp), %ebx  # shift frame cell
    mov %ebx, -4(%esp)  # down to base
# emit-shift-args:  size=1   si=-28  delta=20
    mov -28(%esp), %ebx  # shift frame cell
    mov %ebx, -8(%esp)  # down to base
# emit-shift-args:  size=0   si=-32  delta=20
    movl $4,%eax   # save arg count
    jmp *-2(%edi)  # tail-funcall
     ret   # return thru stack
    .align 4,0x90
_L_37617:
    movl %eax, -4(%esp)  # stack save
# emit-expr (closure (f6265 f6266) (f6260) (let ((f6265 f6265) (f6266 f6266)) (begin (f6260 f6265 f6266) (foreign-call "s_exit" 1))))
# emit-closure
# si = -8
# env = ((f6260 . -4) (f6251 . 0))
# expr = (closure (f6265 f6266) (f6260) (let ((f6265 f6265) (f6266 f6266)) (begin (f6260 f6265 f6266) (foreign-call "s_exit" 1))))
    movl $_L_37629, 0(%ebp)  # closure label
# emit-variable-ref
# env=((f6260 . -4) (f6251 . 0))
# var=f6260
    movl -4(%esp), %eax  # stack load f6260
# end emit-variable-ref
   movl  %eax, 4(%ebp)  # f6260
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $8, %ebp     # bump ebp
    jmp _L_37630            # jump around closure body
_L_37629:
# check argument count
    cmp $8,%eax
    je _L_37631
# invoke error handler eh_argcount
    .extern mrc_eh$uargcount
    movl mrc_eh$uargcount, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_37631:
# emit-tail-expr
# si=-16
# env=((f6266 . -12) (f6265 . -8) (f6260 . 4) (f6260 . -4) (f6251 . 0))
# expr=(let ((f6265 f6265) (f6266 f6266)) (begin (f6260 f6265 f6266) (foreign-call "s_exit" 1)))
# emit-tail-let
#  si   = -16
#  env  = ((f6266 . -12) (f6265 . -8) (f6260 . 4) (f6260 . -4) (f6251 . 0))
#  bindings = ((f6265 f6265) (f6266 f6266))
#  body = (begin (f6260 f6265 f6266) (foreign-call "s_exit" 1))
# emit-expr f6265
# emit-variable-ref
# env=((f6266 . -12) (f6265 . -8) (f6260 . 4) (f6260 . -4) (f6251 . 0))
# var=f6265
    movl -8(%esp), %eax  # stack load f6265
# end emit-variable-ref
    movl %eax, -16(%esp)  # stack save
# emit-expr f6266
# emit-variable-ref
# env=((f6266 . -12) (f6265 . -8) (f6260 . 4) (f6260 . -4) (f6251 . 0))
# var=f6266
    movl -12(%esp), %eax  # stack load f6266
# end emit-variable-ref
    movl %eax, -20(%esp)  # stack save
# emit-tail-expr
# si=-24
# env=((f6266 . -20) (f6265 . -16) (f6266 . -12) (f6265 . -8) (f6260 . 4) (f6260 . -4) (f6251 . 0))
# expr=(begin (f6260 f6265 f6266) (foreign-call "s_exit" 1))
# tail-begin (begin (f6260 f6265 f6266) (foreign-call "s_exit" 1))
#   env=((f6266 . -20) (f6265 . -16) (f6266 . -12) (f6265 . -8) (f6260 . 4) (f6260 . -4) (f6251 . 0))
# emit-expr (f6260 f6265 f6266)
# funcall
#    si   =-24
#    env  = ((f6266 . -20) (f6265 . -16) (f6266 . -12) (f6265 . -8) (f6260 . 4) (f6260 . -4) (f6251 . 0))
#    expr = (funcall f6260 f6265 f6266)
# emit-expr f6260
# emit-variable-ref
# env=((f6266 . -20) (f6265 . -16) (f6266 . -12) (f6265 . -8) (f6260 . 4) (f6260 . -4) (f6251 . 0))
# var=f6260
    movl 2(%edi), %eax  # frame load f6260
# end emit-variable-ref
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_37632"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_37632":
   movl %eax,  -32(%esp)  # stash funcall-oper in closure slot
# emit-expr f6265
# emit-variable-ref
# env=((f6266 . -20) (f6265 . -16) (f6266 . -12) (f6265 . -8) (f6260 . 4) (f6260 . -4) (f6251 . 0))
# var=f6265
    movl -16(%esp), %eax  # stack load f6265
# end emit-variable-ref
    mov %eax, -36(%esp)  # arg f6265
# emit-expr f6266
# emit-variable-ref
# env=((f6266 . -20) (f6265 . -16) (f6266 . -12) (f6265 . -8) (f6260 . 4) (f6260 . -4) (f6251 . 0))
# var=f6266
    movl -20(%esp), %eax  # stack load f6266
# end emit-variable-ref
    mov %eax, -40(%esp)  # arg f6266
    movl -32(%esp), %edi   # load new closure to %edi
    add $-24, %esp   # adjust base
    movl $8,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $24, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
# emit-tail-expr
# si=-24
# env=((f6266 . -20) (f6265 . -16) (f6266 . -12) (f6265 . -8) (f6260 . 4) (f6260 . -4) (f6251 . 0))
# expr=(begin (foreign-call "s_exit" 1))
# tail-begin (begin (foreign-call "s_exit" 1))
#   env=((f6266 . -20) (f6265 . -16) (f6266 . -12) (f6265 . -8) (f6260 . 4) (f6260 . -4) (f6251 . 0))
# emit-tail-expr
# si=-24
# env=((f6266 . -20) (f6265 . -16) (f6266 . -12) (f6265 . -8) (f6260 . 4) (f6260 . -4) (f6251 . 0))
# expr=(foreign-call "s_exit" 1)
    movl %ecx,-24(%esp)
    movl %esp,-28(%esp)
# emit-expr 1
    movl $4, %eax     # immed 1
    movl %eax, -32(%esp)
    leal -32(%esp),%edi
    movl %edi,%esi
    andl $-16,%esi
    movl 0(%edi),%eax
    movl %eax,0(%esi)
    movl 4(%edi),%eax
    movl %eax,4(%esi)
    movl %esi,%esp
    .extern _s_exit
    call _s_exit
    movl 4(%esi),%esp
    movl -24(%esp),%ecx
     ret
     ret   # return thru stack
    .align 4,0x90
_L_37630:
     movl %eax, mrc_error
# == explicit-begins  ==>
# (let ((p (quote ()))) (begin (set! p (cons (quote procedure?) p)) (set! p (cons (quote cdr) p)) (set! p (cons (quote car) p)) (set! p (cons (quote symbol-value) p)) (set! p (cons (quote symbol->string) p)) (set! p (cons (quote make-symbol) p)) (set! p (cons (quote symbol?) p)) (set! p (cons (quote string-set!) p)) (set! p (cons (quote string-ref) p)) (set! p (cons (quote string-length) p)) (set! p (cons (quote string?) p)) (set! p (cons (quote make-string) p)) (set! p (cons (quote vector-ref) p)) (set! p (cons (quote vector-set!) p)) (set! p (cons (quote vector-length) p)) (set! p (cons (quote make-vector) p)) (set! p (cons (quote vector?) p)) (set! p (cons (quote set-cdr!) p)) (set! p (cons (quote set-car!) p)) (set! p (cons (quote cdr) p)) (set! p (cons (quote car) p)) (set! p (cons (quote cons) p)) (set! p (cons (quote pair?) p)) (set! p (cons (quote fxremainder) p)) (set! p (cons (quote fxquotient) p)) (set! p (cons (quote fx*) p)) (set! p (cons (quote fx-) p)) (set! p (cons (quote fx+) p)) (set! p (cons (quote fx>=) p)) (set! p (cons (quote fx>) p)) (set! p (cons (quote fx<=) p)) (set! p (cons (quote fx<) p)) (set! p (cons (quote fx=) p)) (set! p (cons (quote fxzero?) p)) (set! p (cons (quote fxsub1) p)) (set! p (cons (quote fxadd1) p)) (set! p (cons (quote fxlogor) p)) (set! p (cons (quote fxlogand) p)) (set! p (cons (quote fxlognot) p)) (set! p (cons (quote char=?) p)) (set! p (cons (quote eq?) p)) (set! p (cons (quote not) p)) (set! p (cons (quote boolean?) p)) (set! p (cons (quote fixnum?) p)) (set! p (cons (quote char?) p)) (set! p (cons (quote eof-object) p)) (set! p (cons (quote eof-object?) p)) (set! p (cons (quote null?) p)) (set! p (cons (quote char->fixnum) p)) (set! p (cons (quote fixnum->char) p)) (lambda () p)))
# == eliminate-let*  ==>
# (let ((p (quote ()))) (begin (set! p (cons (quote procedure?) p)) (set! p (cons (quote cdr) p)) (set! p (cons (quote car) p)) (set! p (cons (quote symbol-value) p)) (set! p (cons (quote symbol->string) p)) (set! p (cons (quote make-symbol) p)) (set! p (cons (quote symbol?) p)) (set! p (cons (quote string-set!) p)) (set! p (cons (quote string-ref) p)) (set! p (cons (quote string-length) p)) (set! p (cons (quote string?) p)) (set! p (cons (quote make-string) p)) (set! p (cons (quote vector-ref) p)) (set! p (cons (quote vector-set!) p)) (set! p (cons (quote vector-length) p)) (set! p (cons (quote make-vector) p)) (set! p (cons (quote vector?) p)) (set! p (cons (quote set-cdr!) p)) (set! p (cons (quote set-car!) p)) (set! p (cons (quote cdr) p)) (set! p (cons (quote car) p)) (set! p (cons (quote cons) p)) (set! p (cons (quote pair?) p)) (set! p (cons (quote fxremainder) p)) (set! p (cons (quote fxquotient) p)) (set! p (cons (quote fx*) p)) (set! p (cons (quote fx-) p)) (set! p (cons (quote fx+) p)) (set! p (cons (quote fx>=) p)) (set! p (cons (quote fx>) p)) (set! p (cons (quote fx<=) p)) (set! p (cons (quote fx<) p)) (set! p (cons (quote fx=) p)) (set! p (cons (quote fxzero?) p)) (set! p (cons (quote fxsub1) p)) (set! p (cons (quote fxadd1) p)) (set! p (cons (quote fxlogor) p)) (set! p (cons (quote fxlogand) p)) (set! p (cons (quote fxlognot) p)) (set! p (cons (quote char=?) p)) (set! p (cons (quote eq?) p)) (set! p (cons (quote not) p)) (set! p (cons (quote boolean?) p)) (set! p (cons (quote fixnum?) p)) (set! p (cons (quote char?) p)) (set! p (cons (quote eof-object) p)) (set! p (cons (quote eof-object?) p)) (set! p (cons (quote null?) p)) (set! p (cons (quote char->fixnum) p)) (set! p (cons (quote fixnum->char) p)) (lambda () p)))
# == uniquify-variables  ==>
# (let ((f6267 (quote ()))) (begin (set! f6267 (cons (quote procedure?) f6267)) (set! f6267 (cons (quote cdr) f6267)) (set! f6267 (cons (quote car) f6267)) (set! f6267 (cons (quote symbol-value) f6267)) (set! f6267 (cons (quote symbol->string) f6267)) (set! f6267 (cons (quote make-symbol) f6267)) (set! f6267 (cons (quote symbol?) f6267)) (set! f6267 (cons (quote string-set!) f6267)) (set! f6267 (cons (quote string-ref) f6267)) (set! f6267 (cons (quote string-length) f6267)) (set! f6267 (cons (quote string?) f6267)) (set! f6267 (cons (quote make-string) f6267)) (set! f6267 (cons (quote vector-ref) f6267)) (set! f6267 (cons (quote vector-set!) f6267)) (set! f6267 (cons (quote vector-length) f6267)) (set! f6267 (cons (quote make-vector) f6267)) (set! f6267 (cons (quote vector?) f6267)) (set! f6267 (cons (quote set-cdr!) f6267)) (set! f6267 (cons (quote set-car!) f6267)) (set! f6267 (cons (quote cdr) f6267)) (set! f6267 (cons (quote car) f6267)) (set! f6267 (cons (quote cons) f6267)) (set! f6267 (cons (quote pair?) f6267)) (set! f6267 (cons (quote fxremainder) f6267)) (set! f6267 (cons (quote fxquotient) f6267)) (set! f6267 (cons (quote fx*) f6267)) (set! f6267 (cons (quote fx-) f6267)) (set! f6267 (cons (quote fx+) f6267)) (set! f6267 (cons (quote fx>=) f6267)) (set! f6267 (cons (quote fx>) f6267)) (set! f6267 (cons (quote fx<=) f6267)) (set! f6267 (cons (quote fx<) f6267)) (set! f6267 (cons (quote fx=) f6267)) (set! f6267 (cons (quote fxzero?) f6267)) (set! f6267 (cons (quote fxsub1) f6267)) (set! f6267 (cons (quote fxadd1) f6267)) (set! f6267 (cons (quote fxlogor) f6267)) (set! f6267 (cons (quote fxlogand) f6267)) (set! f6267 (cons (quote fxlognot) f6267)) (set! f6267 (cons (quote char=?) f6267)) (set! f6267 (cons (quote eq?) f6267)) (set! f6267 (cons (quote not) f6267)) (set! f6267 (cons (quote boolean?) f6267)) (set! f6267 (cons (quote fixnum?) f6267)) (set! f6267 (cons (quote char?) f6267)) (set! f6267 (cons (quote eof-object) f6267)) (set! f6267 (cons (quote eof-object?) f6267)) (set! f6267 (cons (quote null?) f6267)) (set! f6267 (cons (quote char->fixnum) f6267)) (set! f6267 (cons (quote fixnum->char) f6267)) (lambda () f6267)))
# == vectorize-letrec  ==>
# (let ((f6267 (quote ()))) (begin (set! f6267 (cons (quote procedure?) f6267)) (set! f6267 (cons (quote cdr) f6267)) (set! f6267 (cons (quote car) f6267)) (set! f6267 (cons (quote symbol-value) f6267)) (set! f6267 (cons (quote symbol->string) f6267)) (set! f6267 (cons (quote make-symbol) f6267)) (set! f6267 (cons (quote symbol?) f6267)) (set! f6267 (cons (quote string-set!) f6267)) (set! f6267 (cons (quote string-ref) f6267)) (set! f6267 (cons (quote string-length) f6267)) (set! f6267 (cons (quote string?) f6267)) (set! f6267 (cons (quote make-string) f6267)) (set! f6267 (cons (quote vector-ref) f6267)) (set! f6267 (cons (quote vector-set!) f6267)) (set! f6267 (cons (quote vector-length) f6267)) (set! f6267 (cons (quote make-vector) f6267)) (set! f6267 (cons (quote vector?) f6267)) (set! f6267 (cons (quote set-cdr!) f6267)) (set! f6267 (cons (quote set-car!) f6267)) (set! f6267 (cons (quote cdr) f6267)) (set! f6267 (cons (quote car) f6267)) (set! f6267 (cons (quote cons) f6267)) (set! f6267 (cons (quote pair?) f6267)) (set! f6267 (cons (quote fxremainder) f6267)) (set! f6267 (cons (quote fxquotient) f6267)) (set! f6267 (cons (quote fx*) f6267)) (set! f6267 (cons (quote fx-) f6267)) (set! f6267 (cons (quote fx+) f6267)) (set! f6267 (cons (quote fx>=) f6267)) (set! f6267 (cons (quote fx>) f6267)) (set! f6267 (cons (quote fx<=) f6267)) (set! f6267 (cons (quote fx<) f6267)) (set! f6267 (cons (quote fx=) f6267)) (set! f6267 (cons (quote fxzero?) f6267)) (set! f6267 (cons (quote fxsub1) f6267)) (set! f6267 (cons (quote fxadd1) f6267)) (set! f6267 (cons (quote fxlogor) f6267)) (set! f6267 (cons (quote fxlogand) f6267)) (set! f6267 (cons (quote fxlognot) f6267)) (set! f6267 (cons (quote char=?) f6267)) (set! f6267 (cons (quote eq?) f6267)) (set! f6267 (cons (quote not) f6267)) (set! f6267 (cons (quote boolean?) f6267)) (set! f6267 (cons (quote fixnum?) f6267)) (set! f6267 (cons (quote char?) f6267)) (set! f6267 (cons (quote eof-object) f6267)) (set! f6267 (cons (quote eof-object?) f6267)) (set! f6267 (cons (quote null?) f6267)) (set! f6267 (cons (quote char->fixnum) f6267)) (set! f6267 (cons (quote fixnum->char) f6267)) (lambda () f6267)))
# == eliminate-set!  ==>
# (let ((f6267 (vector (quote ())))) (begin (vector-set! f6267 0 (cons (quote procedure?) (vector-ref f6267 0))) (vector-set! f6267 0 (cons (quote cdr) (vector-ref f6267 0))) (vector-set! f6267 0 (cons (quote car) (vector-ref f6267 0))) (vector-set! f6267 0 (cons (quote symbol-value) (vector-ref f6267 0))) (vector-set! f6267 0 (cons (quote symbol->string) (vector-ref f6267 0))) (vector-set! f6267 0 (cons (quote make-symbol) (vector-ref f6267 0))) (vector-set! f6267 0 (cons (quote symbol?) (vector-ref f6267 0))) (vector-set! f6267 0 (cons (quote string-set!) (vector-ref f6267 0))) (vector-set! f6267 0 (cons (quote string-ref) (vector-ref f6267 0))) (vector-set! f6267 0 (cons (quote string-length) (vector-ref f6267 0))) (vector-set! f6267 0 (cons (quote string?) (vector-ref f6267 0))) (vector-set! f6267 0 (cons (quote make-string) (vector-ref f6267 0))) (vector-set! f6267 0 (cons (quote vector-ref) (vector-ref f6267 0))) (vector-set! f6267 0 (cons (quote vector-set!) (vector-ref f6267 0))) (vector-set! f6267 0 (cons (quote vector-length) (vector-ref f6267 0))) (vector-set! f6267 0 (cons (quote make-vector) (vector-ref f6267 0))) (vector-set! f6267 0 (cons (quote vector?) (vector-ref f6267 0))) (vector-set! f6267 0 (cons (quote set-cdr!) (vector-ref f6267 0))) (vector-set! f6267 0 (cons (quote set-car!) (vector-ref f6267 0))) (vector-set! f6267 0 (cons (quote cdr) (vector-ref f6267 0))) (vector-set! f6267 0 (cons (quote car) (vector-ref f6267 0))) (vector-set! f6267 0 (cons (quote cons) (vector-ref f6267 0))) (vector-set! f6267 0 (cons (quote pair?) (vector-ref f6267 0))) (vector-set! f6267 0 (cons (quote fxremainder) (vector-ref f6267 0))) (vector-set! f6267 0 (cons (quote fxquotient) (vector-ref f6267 0))) (vector-set! f6267 0 (cons (quote fx*) (vector-ref f6267 0))) (vector-set! f6267 0 (cons (quote fx-) (vector-ref f6267 0))) (vector-set! f6267 0 (cons (quote fx+) (vector-ref f6267 0))) (vector-set! f6267 0 (cons (quote fx>=) (vector-ref f6267 0))) (vector-set! f6267 0 (cons (quote fx>) (vector-ref f6267 0))) (vector-set! f6267 0 (cons (quote fx<=) (vector-ref f6267 0))) (vector-set! f6267 0 (cons (quote fx<) (vector-ref f6267 0))) (vector-set! f6267 0 (cons (quote fx=) (vector-ref f6267 0))) (vector-set! f6267 0 (cons (quote fxzero?) (vector-ref f6267 0))) (vector-set! f6267 0 (cons (quote fxsub1) (vector-ref f6267 0))) (vector-set! f6267 0 (cons (quote fxadd1) (vector-ref f6267 0))) (vector-set! f6267 0 (cons (quote fxlogor) (vector-ref f6267 0))) (vector-set! f6267 0 (cons (quote fxlogand) (vector-ref f6267 0))) (vector-set! f6267 0 (cons (quote fxlognot) (vector-ref f6267 0))) (vector-set! f6267 0 (cons (quote char=?) (vector-ref f6267 0))) (vector-set! f6267 0 (cons (quote eq?) (vector-ref f6267 0))) (vector-set! f6267 0 (cons (quote not) (vector-ref f6267 0))) (vector-set! f6267 0 (cons (quote boolean?) (vector-ref f6267 0))) (vector-set! f6267 0 (cons (quote fixnum?) (vector-ref f6267 0))) (vector-set! f6267 0 (cons (quote char?) (vector-ref f6267 0))) (vector-set! f6267 0 (cons (quote eof-object) (vector-ref f6267 0))) (vector-set! f6267 0 (cons (quote eof-object?) (vector-ref f6267 0))) (vector-set! f6267 0 (cons (quote null?) (vector-ref f6267 0))) (vector-set! f6267 0 (cons (quote char->fixnum) (vector-ref f6267 0))) (vector-set! f6267 0 (cons (quote fixnum->char) (vector-ref f6267 0))) (lambda () (let () (vector-ref f6267 0)))))
# == close-free-variables  ==>
# (let ((f6267 (vector (quote ())))) (begin (vector-set! f6267 0 (cons (quote procedure?) (vector-ref f6267 0))) (vector-set! f6267 0 (cons (quote cdr) (vector-ref f6267 0))) (vector-set! f6267 0 (cons (quote car) (vector-ref f6267 0))) (vector-set! f6267 0 (cons (quote symbol-value) (vector-ref f6267 0))) (vector-set! f6267 0 (cons (quote symbol->string) (vector-ref f6267 0))) (vector-set! f6267 0 (cons (quote make-symbol) (vector-ref f6267 0))) (vector-set! f6267 0 (cons (quote symbol?) (vector-ref f6267 0))) (vector-set! f6267 0 (cons (quote string-set!) (vector-ref f6267 0))) (vector-set! f6267 0 (cons (quote string-ref) (vector-ref f6267 0))) (vector-set! f6267 0 (cons (quote string-length) (vector-ref f6267 0))) (vector-set! f6267 0 (cons (quote string?) (vector-ref f6267 0))) (vector-set! f6267 0 (cons (quote make-string) (vector-ref f6267 0))) (vector-set! f6267 0 (cons (quote vector-ref) (vector-ref f6267 0))) (vector-set! f6267 0 (cons (quote vector-set!) (vector-ref f6267 0))) (vector-set! f6267 0 (cons (quote vector-length) (vector-ref f6267 0))) (vector-set! f6267 0 (cons (quote make-vector) (vector-ref f6267 0))) (vector-set! f6267 0 (cons (quote vector?) (vector-ref f6267 0))) (vector-set! f6267 0 (cons (quote set-cdr!) (vector-ref f6267 0))) (vector-set! f6267 0 (cons (quote set-car!) (vector-ref f6267 0))) (vector-set! f6267 0 (cons (quote cdr) (vector-ref f6267 0))) (vector-set! f6267 0 (cons (quote car) (vector-ref f6267 0))) (vector-set! f6267 0 (cons (quote cons) (vector-ref f6267 0))) (vector-set! f6267 0 (cons (quote pair?) (vector-ref f6267 0))) (vector-set! f6267 0 (cons (quote fxremainder) (vector-ref f6267 0))) (vector-set! f6267 0 (cons (quote fxquotient) (vector-ref f6267 0))) (vector-set! f6267 0 (cons (quote fx*) (vector-ref f6267 0))) (vector-set! f6267 0 (cons (quote fx-) (vector-ref f6267 0))) (vector-set! f6267 0 (cons (quote fx+) (vector-ref f6267 0))) (vector-set! f6267 0 (cons (quote fx>=) (vector-ref f6267 0))) (vector-set! f6267 0 (cons (quote fx>) (vector-ref f6267 0))) (vector-set! f6267 0 (cons (quote fx<=) (vector-ref f6267 0))) (vector-set! f6267 0 (cons (quote fx<) (vector-ref f6267 0))) (vector-set! f6267 0 (cons (quote fx=) (vector-ref f6267 0))) (vector-set! f6267 0 (cons (quote fxzero?) (vector-ref f6267 0))) (vector-set! f6267 0 (cons (quote fxsub1) (vector-ref f6267 0))) (vector-set! f6267 0 (cons (quote fxadd1) (vector-ref f6267 0))) (vector-set! f6267 0 (cons (quote fxlogor) (vector-ref f6267 0))) (vector-set! f6267 0 (cons (quote fxlogand) (vector-ref f6267 0))) (vector-set! f6267 0 (cons (quote fxlognot) (vector-ref f6267 0))) (vector-set! f6267 0 (cons (quote char=?) (vector-ref f6267 0))) (vector-set! f6267 0 (cons (quote eq?) (vector-ref f6267 0))) (vector-set! f6267 0 (cons (quote not) (vector-ref f6267 0))) (vector-set! f6267 0 (cons (quote boolean?) (vector-ref f6267 0))) (vector-set! f6267 0 (cons (quote fixnum?) (vector-ref f6267 0))) (vector-set! f6267 0 (cons (quote char?) (vector-ref f6267 0))) (vector-set! f6267 0 (cons (quote eof-object) (vector-ref f6267 0))) (vector-set! f6267 0 (cons (quote eof-object?) (vector-ref f6267 0))) (vector-set! f6267 0 (cons (quote null?) (vector-ref f6267 0))) (vector-set! f6267 0 (cons (quote char->fixnum) (vector-ref f6267 0))) (vector-set! f6267 0 (cons (quote fixnum->char) (vector-ref f6267 0))) (closure () (f6267) (let () (vector-ref f6267 0)))))
# == eliminate-quote  ==>
# (let ((f6267 (vector ()))) (begin (vector-set! f6267 0 (cons (string->symbol "procedure?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons (string->symbol "cdr") (vector-ref f6267 0))) (vector-set! f6267 0 (cons (string->symbol "car") (vector-ref f6267 0))) (vector-set! f6267 0 (cons (string->symbol "symbol-value") (vector-ref f6267 0))) (vector-set! f6267 0 (cons (string->symbol "symbol->string") (vector-ref f6267 0))) (vector-set! f6267 0 (cons (string->symbol "make-symbol") (vector-ref f6267 0))) (vector-set! f6267 0 (cons (string->symbol "symbol?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons (string->symbol "string-set!") (vector-ref f6267 0))) (vector-set! f6267 0 (cons (string->symbol "string-ref") (vector-ref f6267 0))) (vector-set! f6267 0 (cons (string->symbol "string-length") (vector-ref f6267 0))) (vector-set! f6267 0 (cons (string->symbol "string?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons (string->symbol "make-string") (vector-ref f6267 0))) (vector-set! f6267 0 (cons (string->symbol "vector-ref") (vector-ref f6267 0))) (vector-set! f6267 0 (cons (string->symbol "vector-set!") (vector-ref f6267 0))) (vector-set! f6267 0 (cons (string->symbol "vector-length") (vector-ref f6267 0))) (vector-set! f6267 0 (cons (string->symbol "make-vector") (vector-ref f6267 0))) (vector-set! f6267 0 (cons (string->symbol "vector?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons (string->symbol "set-cdr!") (vector-ref f6267 0))) (vector-set! f6267 0 (cons (string->symbol "set-car!") (vector-ref f6267 0))) (vector-set! f6267 0 (cons (string->symbol "cdr") (vector-ref f6267 0))) (vector-set! f6267 0 (cons (string->symbol "car") (vector-ref f6267 0))) (vector-set! f6267 0 (cons (string->symbol "cons") (vector-ref f6267 0))) (vector-set! f6267 0 (cons (string->symbol "pair?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons (string->symbol "fxremainder") (vector-ref f6267 0))) (vector-set! f6267 0 (cons (string->symbol "fxquotient") (vector-ref f6267 0))) (vector-set! f6267 0 (cons (string->symbol "fx*") (vector-ref f6267 0))) (vector-set! f6267 0 (cons (string->symbol "fx-") (vector-ref f6267 0))) (vector-set! f6267 0 (cons (string->symbol "fx+") (vector-ref f6267 0))) (vector-set! f6267 0 (cons (string->symbol "fx>=") (vector-ref f6267 0))) (vector-set! f6267 0 (cons (string->symbol "fx>") (vector-ref f6267 0))) (vector-set! f6267 0 (cons (string->symbol "fx<=") (vector-ref f6267 0))) (vector-set! f6267 0 (cons (string->symbol "fx<") (vector-ref f6267 0))) (vector-set! f6267 0 (cons (string->symbol "fx=") (vector-ref f6267 0))) (vector-set! f6267 0 (cons (string->symbol "fxzero?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons (string->symbol "fxsub1") (vector-ref f6267 0))) (vector-set! f6267 0 (cons (string->symbol "fxadd1") (vector-ref f6267 0))) (vector-set! f6267 0 (cons (string->symbol "fxlogor") (vector-ref f6267 0))) (vector-set! f6267 0 (cons (string->symbol "fxlogand") (vector-ref f6267 0))) (vector-set! f6267 0 (cons (string->symbol "fxlognot") (vector-ref f6267 0))) (vector-set! f6267 0 (cons (string->symbol "char=?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons (string->symbol "eq?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons (string->symbol "not") (vector-ref f6267 0))) (vector-set! f6267 0 (cons (string->symbol "boolean?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons (string->symbol "fixnum?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons (string->symbol "char?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons (string->symbol "eof-object") (vector-ref f6267 0))) (vector-set! f6267 0 (cons (string->symbol "eof-object?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons (string->symbol "null?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons (string->symbol "char->fixnum") (vector-ref f6267 0))) (vector-set! f6267 0 (cons (string->symbol "fixnum->char") (vector-ref f6267 0))) (closure () (f6267) (let () (vector-ref f6267 0)))))
# == eliminate-when/unless  ==>
# (let ((f6267 (vector ()))) (begin (vector-set! f6267 0 (cons (string->symbol "procedure?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons (string->symbol "cdr") (vector-ref f6267 0))) (vector-set! f6267 0 (cons (string->symbol "car") (vector-ref f6267 0))) (vector-set! f6267 0 (cons (string->symbol "symbol-value") (vector-ref f6267 0))) (vector-set! f6267 0 (cons (string->symbol "symbol->string") (vector-ref f6267 0))) (vector-set! f6267 0 (cons (string->symbol "make-symbol") (vector-ref f6267 0))) (vector-set! f6267 0 (cons (string->symbol "symbol?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons (string->symbol "string-set!") (vector-ref f6267 0))) (vector-set! f6267 0 (cons (string->symbol "string-ref") (vector-ref f6267 0))) (vector-set! f6267 0 (cons (string->symbol "string-length") (vector-ref f6267 0))) (vector-set! f6267 0 (cons (string->symbol "string?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons (string->symbol "make-string") (vector-ref f6267 0))) (vector-set! f6267 0 (cons (string->symbol "vector-ref") (vector-ref f6267 0))) (vector-set! f6267 0 (cons (string->symbol "vector-set!") (vector-ref f6267 0))) (vector-set! f6267 0 (cons (string->symbol "vector-length") (vector-ref f6267 0))) (vector-set! f6267 0 (cons (string->symbol "make-vector") (vector-ref f6267 0))) (vector-set! f6267 0 (cons (string->symbol "vector?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons (string->symbol "set-cdr!") (vector-ref f6267 0))) (vector-set! f6267 0 (cons (string->symbol "set-car!") (vector-ref f6267 0))) (vector-set! f6267 0 (cons (string->symbol "cdr") (vector-ref f6267 0))) (vector-set! f6267 0 (cons (string->symbol "car") (vector-ref f6267 0))) (vector-set! f6267 0 (cons (string->symbol "cons") (vector-ref f6267 0))) (vector-set! f6267 0 (cons (string->symbol "pair?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons (string->symbol "fxremainder") (vector-ref f6267 0))) (vector-set! f6267 0 (cons (string->symbol "fxquotient") (vector-ref f6267 0))) (vector-set! f6267 0 (cons (string->symbol "fx*") (vector-ref f6267 0))) (vector-set! f6267 0 (cons (string->symbol "fx-") (vector-ref f6267 0))) (vector-set! f6267 0 (cons (string->symbol "fx+") (vector-ref f6267 0))) (vector-set! f6267 0 (cons (string->symbol "fx>=") (vector-ref f6267 0))) (vector-set! f6267 0 (cons (string->symbol "fx>") (vector-ref f6267 0))) (vector-set! f6267 0 (cons (string->symbol "fx<=") (vector-ref f6267 0))) (vector-set! f6267 0 (cons (string->symbol "fx<") (vector-ref f6267 0))) (vector-set! f6267 0 (cons (string->symbol "fx=") (vector-ref f6267 0))) (vector-set! f6267 0 (cons (string->symbol "fxzero?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons (string->symbol "fxsub1") (vector-ref f6267 0))) (vector-set! f6267 0 (cons (string->symbol "fxadd1") (vector-ref f6267 0))) (vector-set! f6267 0 (cons (string->symbol "fxlogor") (vector-ref f6267 0))) (vector-set! f6267 0 (cons (string->symbol "fxlogand") (vector-ref f6267 0))) (vector-set! f6267 0 (cons (string->symbol "fxlognot") (vector-ref f6267 0))) (vector-set! f6267 0 (cons (string->symbol "char=?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons (string->symbol "eq?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons (string->symbol "not") (vector-ref f6267 0))) (vector-set! f6267 0 (cons (string->symbol "boolean?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons (string->symbol "fixnum?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons (string->symbol "char?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons (string->symbol "eof-object") (vector-ref f6267 0))) (vector-set! f6267 0 (cons (string->symbol "eof-object?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons (string->symbol "null?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons (string->symbol "char->fixnum") (vector-ref f6267 0))) (vector-set! f6267 0 (cons (string->symbol "fixnum->char") (vector-ref f6267 0))) (closure () (f6267) (let () (vector-ref f6267 0)))))
# == eliminate-cond  ==>
# (let ((f6267 (vector ()))) (begin (vector-set! f6267 0 (cons (string->symbol "procedure?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons (string->symbol "cdr") (vector-ref f6267 0))) (vector-set! f6267 0 (cons (string->symbol "car") (vector-ref f6267 0))) (vector-set! f6267 0 (cons (string->symbol "symbol-value") (vector-ref f6267 0))) (vector-set! f6267 0 (cons (string->symbol "symbol->string") (vector-ref f6267 0))) (vector-set! f6267 0 (cons (string->symbol "make-symbol") (vector-ref f6267 0))) (vector-set! f6267 0 (cons (string->symbol "symbol?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons (string->symbol "string-set!") (vector-ref f6267 0))) (vector-set! f6267 0 (cons (string->symbol "string-ref") (vector-ref f6267 0))) (vector-set! f6267 0 (cons (string->symbol "string-length") (vector-ref f6267 0))) (vector-set! f6267 0 (cons (string->symbol "string?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons (string->symbol "make-string") (vector-ref f6267 0))) (vector-set! f6267 0 (cons (string->symbol "vector-ref") (vector-ref f6267 0))) (vector-set! f6267 0 (cons (string->symbol "vector-set!") (vector-ref f6267 0))) (vector-set! f6267 0 (cons (string->symbol "vector-length") (vector-ref f6267 0))) (vector-set! f6267 0 (cons (string->symbol "make-vector") (vector-ref f6267 0))) (vector-set! f6267 0 (cons (string->symbol "vector?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons (string->symbol "set-cdr!") (vector-ref f6267 0))) (vector-set! f6267 0 (cons (string->symbol "set-car!") (vector-ref f6267 0))) (vector-set! f6267 0 (cons (string->symbol "cdr") (vector-ref f6267 0))) (vector-set! f6267 0 (cons (string->symbol "car") (vector-ref f6267 0))) (vector-set! f6267 0 (cons (string->symbol "cons") (vector-ref f6267 0))) (vector-set! f6267 0 (cons (string->symbol "pair?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons (string->symbol "fxremainder") (vector-ref f6267 0))) (vector-set! f6267 0 (cons (string->symbol "fxquotient") (vector-ref f6267 0))) (vector-set! f6267 0 (cons (string->symbol "fx*") (vector-ref f6267 0))) (vector-set! f6267 0 (cons (string->symbol "fx-") (vector-ref f6267 0))) (vector-set! f6267 0 (cons (string->symbol "fx+") (vector-ref f6267 0))) (vector-set! f6267 0 (cons (string->symbol "fx>=") (vector-ref f6267 0))) (vector-set! f6267 0 (cons (string->symbol "fx>") (vector-ref f6267 0))) (vector-set! f6267 0 (cons (string->symbol "fx<=") (vector-ref f6267 0))) (vector-set! f6267 0 (cons (string->symbol "fx<") (vector-ref f6267 0))) (vector-set! f6267 0 (cons (string->symbol "fx=") (vector-ref f6267 0))) (vector-set! f6267 0 (cons (string->symbol "fxzero?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons (string->symbol "fxsub1") (vector-ref f6267 0))) (vector-set! f6267 0 (cons (string->symbol "fxadd1") (vector-ref f6267 0))) (vector-set! f6267 0 (cons (string->symbol "fxlogor") (vector-ref f6267 0))) (vector-set! f6267 0 (cons (string->symbol "fxlogand") (vector-ref f6267 0))) (vector-set! f6267 0 (cons (string->symbol "fxlognot") (vector-ref f6267 0))) (vector-set! f6267 0 (cons (string->symbol "char=?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons (string->symbol "eq?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons (string->symbol "not") (vector-ref f6267 0))) (vector-set! f6267 0 (cons (string->symbol "boolean?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons (string->symbol "fixnum?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons (string->symbol "char?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons (string->symbol "eof-object") (vector-ref f6267 0))) (vector-set! f6267 0 (cons (string->symbol "eof-object?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons (string->symbol "null?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons (string->symbol "char->fixnum") (vector-ref f6267 0))) (vector-set! f6267 0 (cons (string->symbol "fixnum->char") (vector-ref f6267 0))) (closure () (f6267) (let () (vector-ref f6267 0)))))
# == external-symbols  ==>
# (let ((f6267 ((primitive-ref vector) ()))) (begin (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "procedure?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "cdr") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "car") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "symbol-value") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "symbol->string") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "make-symbol") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "symbol?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "string-set!") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "string-ref") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "string-length") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "string?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "make-string") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "vector-ref") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "vector-set!") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "vector-length") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "make-vector") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "vector?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "set-cdr!") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "set-car!") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "cdr") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "car") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "cons") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "pair?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fxremainder") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fxquotient") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fx*") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fx-") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fx+") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fx>=") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fx>") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fx<=") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fx<") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fx=") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "eof-object") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "eof-object?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f6267 0))) (closure () (f6267) (let () (vector-ref f6267 0)))))
# emit-expr (let ((f6267 ((primitive-ref vector) ()))) (begin (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "procedure?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "cdr") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "car") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "symbol-value") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "symbol->string") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "make-symbol") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "symbol?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "string-set!") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "string-ref") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "string-length") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "string?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "make-string") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "vector-ref") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "vector-set!") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "vector-length") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "make-vector") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "vector?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "set-cdr!") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "set-car!") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "cdr") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "car") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "cons") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "pair?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fxremainder") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fxquotient") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fx*") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fx-") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fx+") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fx>=") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fx>") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fx<=") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fx<") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fx=") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "eof-object") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "eof-object?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f6267 0))) (closure () (f6267) (let () (vector-ref f6267 0)))))
# emit-let
#  si   = 0
#  env  = ()
#  bindings = ((f6267 ((primitive-ref vector) ())))
#  body = (begin (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "procedure?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "cdr") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "car") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "symbol-value") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "symbol->string") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "make-symbol") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "symbol?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "string-set!") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "string-ref") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "string-length") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "string?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "make-string") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "vector-ref") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "vector-set!") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "vector-length") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "make-vector") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "vector?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "set-cdr!") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "set-car!") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "cdr") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "car") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "cons") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "pair?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fxremainder") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fxquotient") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fx*") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fx-") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fx+") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fx>=") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fx>") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fx<=") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fx<") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fx=") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "eof-object") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "eof-object?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f6267 0))) (closure () (f6267) (let () (vector-ref f6267 0))))
# emit-expr ((primitive-ref vector) ())
# funcall
#    si   =0
#    env  = ()
#    expr = (funcall (primitive-ref vector) ())
# emit-expr (primitive-ref vector)
    .extern mrc_vector
    movl mrc_vector,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_37633"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_37633":
   movl %eax,  -8(%esp)  # stash funcall-oper in closure slot
# emit-expr ()
    movl $63, %eax     # immed ()
    mov %eax, -12(%esp)  # arg ()
    movl -8(%esp), %edi   # load new closure to %edi
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    movl -4(%esp), %edi   # restore closure frame ptr
    movl %eax, 0(%esp)  # stack save
# emit-expr (begin (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "procedure?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "cdr") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "car") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "symbol-value") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "symbol->string") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "make-symbol") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "symbol?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "string-set!") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "string-ref") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "string-length") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "string?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "make-string") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "vector-ref") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "vector-set!") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "vector-length") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "make-vector") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "vector?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "set-cdr!") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "set-car!") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "cdr") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "car") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "cons") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "pair?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fxremainder") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fxquotient") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fx*") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fx-") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fx+") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fx>=") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fx>") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fx<=") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fx<") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fx=") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "eof-object") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "eof-object?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f6267 0))) (closure () (f6267) (let () (vector-ref f6267 0))))
# emit-begin
#   expr=(begin (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "procedure?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "cdr") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "car") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "symbol-value") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "symbol->string") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "make-symbol") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "symbol?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "string-set!") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "string-ref") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "string-length") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "string?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "make-string") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "vector-ref") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "vector-set!") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "vector-length") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "make-vector") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "vector?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "set-cdr!") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "set-car!") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "cdr") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "car") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "cons") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "pair?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fxremainder") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fxquotient") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fx*") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fx-") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fx+") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fx>=") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fx>") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fx<=") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fx<") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fx=") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "eof-object") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "eof-object?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f6267 0))) (closure () (f6267) (let () (vector-ref f6267 0))))
#   env=((f6267 . 0))
# emit-expr (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "procedure?") (vector-ref f6267 0)))
# emit-expr f6267
# emit-variable-ref
# env=((f6267 . 0))
# var=f6267
    movl 0(%esp), %eax  # stack load f6267
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_37634
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_37634:
    movl %eax, -4(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_37635"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_37635:
# check bounds on vector index
    movl -4(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_37637
    cmp  $0,%eax
    jge _L_37636
_L_37637:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_37636:
    movl %eax, -8(%esp)
# emit-expr (cons ((primitive-ref string->symbol) "procedure?") (vector-ref f6267 0))
# cons arg1=((primitive-ref string->symbol) "procedure?") arg2=(vector-ref f6267 0)
# emit-expr ((primitive-ref string->symbol) "procedure?")
# funcall
#    si   =-12
#    env  = ((f6267 . 0))
#    expr = (funcall (primitive-ref string->symbol) "procedure?")
# emit-expr (primitive-ref string->symbol)
    .extern mrc_string$m$gsymbol
    movl mrc_string$m$gsymbol,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_37638"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_37638":
   movl %eax,  -20(%esp)  # stash funcall-oper in closure slot
# emit-expr "procedure?"
# string literal
    jmp _L_37640
    .align 8,0x90
_L_37639 :
    .int 40
    .ascii "procedure?"
_L_37640:
    movl $_L_37639, %eax
    orl $6, %eax
    mov %eax, -24(%esp)  # arg procedure?
    movl -20(%esp), %edi   # load new closure to %edi
    add $-12, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $12, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    movl %eax, -12(%esp)
# emit-expr (vector-ref f6267 0)
# emit-expr f6267
# emit-variable-ref
# env=((f6267 . 0))
# var=f6267
    movl 0(%esp), %eax  # stack load f6267
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_37641
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_37641:
    movl %eax, -16(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_37642"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_37642:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_37644
    cmp  $0,%eax
    jge _L_37643
_L_37644:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_37643:
    movl -16(%esp), %esi
    movl -1(%eax,%esi), %eax
    movl %eax, 4(%ebp)
    movl -12(%esp), %eax
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    or   $1, %al
    add  $8, %ebp
# cons end
    movl -4(%esp), %ebx
    movl -8(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "cdr") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "car") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "symbol-value") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "symbol->string") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "make-symbol") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "symbol?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "string-set!") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "string-ref") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "string-length") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "string?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "make-string") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "vector-ref") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "vector-set!") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "vector-length") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "make-vector") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "vector?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "set-cdr!") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "set-car!") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "cdr") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "car") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "cons") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "pair?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fxremainder") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fxquotient") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fx*") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fx-") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fx+") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fx>=") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fx>") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fx<=") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fx<") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fx=") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "eof-object") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "eof-object?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f6267 0))) (closure () (f6267) (let () (vector-ref f6267 0))))
# emit-begin
#   expr=(begin (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "cdr") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "car") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "symbol-value") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "symbol->string") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "make-symbol") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "symbol?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "string-set!") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "string-ref") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "string-length") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "string?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "make-string") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "vector-ref") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "vector-set!") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "vector-length") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "make-vector") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "vector?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "set-cdr!") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "set-car!") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "cdr") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "car") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "cons") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "pair?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fxremainder") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fxquotient") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fx*") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fx-") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fx+") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fx>=") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fx>") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fx<=") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fx<") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fx=") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "eof-object") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "eof-object?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f6267 0))) (closure () (f6267) (let () (vector-ref f6267 0))))
#   env=((f6267 . 0))
# emit-expr (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "cdr") (vector-ref f6267 0)))
# emit-expr f6267
# emit-variable-ref
# env=((f6267 . 0))
# var=f6267
    movl 0(%esp), %eax  # stack load f6267
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_37645
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_37645:
    movl %eax, -4(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_37646"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_37646:
# check bounds on vector index
    movl -4(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_37648
    cmp  $0,%eax
    jge _L_37647
_L_37648:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_37647:
    movl %eax, -8(%esp)
# emit-expr (cons ((primitive-ref string->symbol) "cdr") (vector-ref f6267 0))
# cons arg1=((primitive-ref string->symbol) "cdr") arg2=(vector-ref f6267 0)
# emit-expr ((primitive-ref string->symbol) "cdr")
# funcall
#    si   =-12
#    env  = ((f6267 . 0))
#    expr = (funcall (primitive-ref string->symbol) "cdr")
# emit-expr (primitive-ref string->symbol)
    .extern mrc_string$m$gsymbol
    movl mrc_string$m$gsymbol,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_37649"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_37649":
   movl %eax,  -20(%esp)  # stash funcall-oper in closure slot
# emit-expr "cdr"
# string literal
    jmp _L_37651
    .align 8,0x90
_L_37650 :
    .int 12
    .ascii "cdr"
_L_37651:
    movl $_L_37650, %eax
    orl $6, %eax
    mov %eax, -24(%esp)  # arg cdr
    movl -20(%esp), %edi   # load new closure to %edi
    add $-12, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $12, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    movl %eax, -12(%esp)
# emit-expr (vector-ref f6267 0)
# emit-expr f6267
# emit-variable-ref
# env=((f6267 . 0))
# var=f6267
    movl 0(%esp), %eax  # stack load f6267
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_37652
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_37652:
    movl %eax, -16(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_37653"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_37653:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_37655
    cmp  $0,%eax
    jge _L_37654
_L_37655:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_37654:
    movl -16(%esp), %esi
    movl -1(%eax,%esi), %eax
    movl %eax, 4(%ebp)
    movl -12(%esp), %eax
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    or   $1, %al
    add  $8, %ebp
# cons end
    movl -4(%esp), %ebx
    movl -8(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "car") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "symbol-value") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "symbol->string") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "make-symbol") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "symbol?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "string-set!") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "string-ref") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "string-length") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "string?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "make-string") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "vector-ref") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "vector-set!") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "vector-length") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "make-vector") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "vector?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "set-cdr!") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "set-car!") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "cdr") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "car") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "cons") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "pair?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fxremainder") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fxquotient") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fx*") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fx-") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fx+") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fx>=") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fx>") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fx<=") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fx<") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fx=") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "eof-object") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "eof-object?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f6267 0))) (closure () (f6267) (let () (vector-ref f6267 0))))
# emit-begin
#   expr=(begin (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "car") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "symbol-value") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "symbol->string") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "make-symbol") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "symbol?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "string-set!") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "string-ref") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "string-length") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "string?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "make-string") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "vector-ref") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "vector-set!") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "vector-length") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "make-vector") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "vector?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "set-cdr!") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "set-car!") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "cdr") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "car") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "cons") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "pair?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fxremainder") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fxquotient") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fx*") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fx-") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fx+") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fx>=") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fx>") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fx<=") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fx<") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fx=") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "eof-object") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "eof-object?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f6267 0))) (closure () (f6267) (let () (vector-ref f6267 0))))
#   env=((f6267 . 0))
# emit-expr (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "car") (vector-ref f6267 0)))
# emit-expr f6267
# emit-variable-ref
# env=((f6267 . 0))
# var=f6267
    movl 0(%esp), %eax  # stack load f6267
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_37656
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_37656:
    movl %eax, -4(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_37657"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_37657:
# check bounds on vector index
    movl -4(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_37659
    cmp  $0,%eax
    jge _L_37658
_L_37659:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_37658:
    movl %eax, -8(%esp)
# emit-expr (cons ((primitive-ref string->symbol) "car") (vector-ref f6267 0))
# cons arg1=((primitive-ref string->symbol) "car") arg2=(vector-ref f6267 0)
# emit-expr ((primitive-ref string->symbol) "car")
# funcall
#    si   =-12
#    env  = ((f6267 . 0))
#    expr = (funcall (primitive-ref string->symbol) "car")
# emit-expr (primitive-ref string->symbol)
    .extern mrc_string$m$gsymbol
    movl mrc_string$m$gsymbol,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_37660"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_37660":
   movl %eax,  -20(%esp)  # stash funcall-oper in closure slot
# emit-expr "car"
# string literal
    jmp _L_37662
    .align 8,0x90
_L_37661 :
    .int 12
    .ascii "car"
_L_37662:
    movl $_L_37661, %eax
    orl $6, %eax
    mov %eax, -24(%esp)  # arg car
    movl -20(%esp), %edi   # load new closure to %edi
    add $-12, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $12, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    movl %eax, -12(%esp)
# emit-expr (vector-ref f6267 0)
# emit-expr f6267
# emit-variable-ref
# env=((f6267 . 0))
# var=f6267
    movl 0(%esp), %eax  # stack load f6267
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_37663
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_37663:
    movl %eax, -16(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_37664"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_37664:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_37666
    cmp  $0,%eax
    jge _L_37665
_L_37666:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_37665:
    movl -16(%esp), %esi
    movl -1(%eax,%esi), %eax
    movl %eax, 4(%ebp)
    movl -12(%esp), %eax
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    or   $1, %al
    add  $8, %ebp
# cons end
    movl -4(%esp), %ebx
    movl -8(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "symbol-value") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "symbol->string") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "make-symbol") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "symbol?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "string-set!") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "string-ref") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "string-length") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "string?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "make-string") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "vector-ref") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "vector-set!") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "vector-length") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "make-vector") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "vector?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "set-cdr!") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "set-car!") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "cdr") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "car") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "cons") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "pair?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fxremainder") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fxquotient") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fx*") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fx-") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fx+") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fx>=") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fx>") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fx<=") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fx<") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fx=") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "eof-object") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "eof-object?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f6267 0))) (closure () (f6267) (let () (vector-ref f6267 0))))
# emit-begin
#   expr=(begin (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "symbol-value") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "symbol->string") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "make-symbol") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "symbol?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "string-set!") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "string-ref") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "string-length") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "string?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "make-string") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "vector-ref") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "vector-set!") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "vector-length") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "make-vector") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "vector?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "set-cdr!") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "set-car!") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "cdr") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "car") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "cons") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "pair?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fxremainder") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fxquotient") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fx*") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fx-") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fx+") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fx>=") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fx>") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fx<=") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fx<") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fx=") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "eof-object") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "eof-object?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f6267 0))) (closure () (f6267) (let () (vector-ref f6267 0))))
#   env=((f6267 . 0))
# emit-expr (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "symbol-value") (vector-ref f6267 0)))
# emit-expr f6267
# emit-variable-ref
# env=((f6267 . 0))
# var=f6267
    movl 0(%esp), %eax  # stack load f6267
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_37667
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_37667:
    movl %eax, -4(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_37668"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_37668:
# check bounds on vector index
    movl -4(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_37670
    cmp  $0,%eax
    jge _L_37669
_L_37670:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_37669:
    movl %eax, -8(%esp)
# emit-expr (cons ((primitive-ref string->symbol) "symbol-value") (vector-ref f6267 0))
# cons arg1=((primitive-ref string->symbol) "symbol-value") arg2=(vector-ref f6267 0)
# emit-expr ((primitive-ref string->symbol) "symbol-value")
# funcall
#    si   =-12
#    env  = ((f6267 . 0))
#    expr = (funcall (primitive-ref string->symbol) "symbol-value")
# emit-expr (primitive-ref string->symbol)
    .extern mrc_string$m$gsymbol
    movl mrc_string$m$gsymbol,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_37671"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_37671":
   movl %eax,  -20(%esp)  # stash funcall-oper in closure slot
# emit-expr "symbol-value"
# string literal
    jmp _L_37673
    .align 8,0x90
_L_37672 :
    .int 48
    .ascii "symbol-value"
_L_37673:
    movl $_L_37672, %eax
    orl $6, %eax
    mov %eax, -24(%esp)  # arg symbol-value
    movl -20(%esp), %edi   # load new closure to %edi
    add $-12, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $12, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    movl %eax, -12(%esp)
# emit-expr (vector-ref f6267 0)
# emit-expr f6267
# emit-variable-ref
# env=((f6267 . 0))
# var=f6267
    movl 0(%esp), %eax  # stack load f6267
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_37674
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_37674:
    movl %eax, -16(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_37675"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_37675:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_37677
    cmp  $0,%eax
    jge _L_37676
_L_37677:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_37676:
    movl -16(%esp), %esi
    movl -1(%eax,%esi), %eax
    movl %eax, 4(%ebp)
    movl -12(%esp), %eax
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    or   $1, %al
    add  $8, %ebp
# cons end
    movl -4(%esp), %ebx
    movl -8(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "symbol->string") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "make-symbol") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "symbol?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "string-set!") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "string-ref") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "string-length") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "string?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "make-string") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "vector-ref") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "vector-set!") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "vector-length") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "make-vector") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "vector?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "set-cdr!") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "set-car!") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "cdr") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "car") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "cons") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "pair?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fxremainder") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fxquotient") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fx*") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fx-") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fx+") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fx>=") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fx>") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fx<=") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fx<") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fx=") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "eof-object") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "eof-object?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f6267 0))) (closure () (f6267) (let () (vector-ref f6267 0))))
# emit-begin
#   expr=(begin (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "symbol->string") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "make-symbol") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "symbol?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "string-set!") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "string-ref") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "string-length") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "string?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "make-string") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "vector-ref") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "vector-set!") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "vector-length") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "make-vector") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "vector?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "set-cdr!") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "set-car!") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "cdr") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "car") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "cons") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "pair?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fxremainder") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fxquotient") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fx*") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fx-") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fx+") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fx>=") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fx>") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fx<=") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fx<") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fx=") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "eof-object") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "eof-object?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f6267 0))) (closure () (f6267) (let () (vector-ref f6267 0))))
#   env=((f6267 . 0))
# emit-expr (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "symbol->string") (vector-ref f6267 0)))
# emit-expr f6267
# emit-variable-ref
# env=((f6267 . 0))
# var=f6267
    movl 0(%esp), %eax  # stack load f6267
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_37678
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_37678:
    movl %eax, -4(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_37679"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_37679:
# check bounds on vector index
    movl -4(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_37681
    cmp  $0,%eax
    jge _L_37680
_L_37681:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_37680:
    movl %eax, -8(%esp)
# emit-expr (cons ((primitive-ref string->symbol) "symbol->string") (vector-ref f6267 0))
# cons arg1=((primitive-ref string->symbol) "symbol->string") arg2=(vector-ref f6267 0)
# emit-expr ((primitive-ref string->symbol) "symbol->string")
# funcall
#    si   =-12
#    env  = ((f6267 . 0))
#    expr = (funcall (primitive-ref string->symbol) "symbol->string")
# emit-expr (primitive-ref string->symbol)
    .extern mrc_string$m$gsymbol
    movl mrc_string$m$gsymbol,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_37682"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_37682":
   movl %eax,  -20(%esp)  # stash funcall-oper in closure slot
# emit-expr "symbol->string"
# string literal
    jmp _L_37684
    .align 8,0x90
_L_37683 :
    .int 56
    .ascii "symbol->string"
_L_37684:
    movl $_L_37683, %eax
    orl $6, %eax
    mov %eax, -24(%esp)  # arg symbol->string
    movl -20(%esp), %edi   # load new closure to %edi
    add $-12, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $12, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    movl %eax, -12(%esp)
# emit-expr (vector-ref f6267 0)
# emit-expr f6267
# emit-variable-ref
# env=((f6267 . 0))
# var=f6267
    movl 0(%esp), %eax  # stack load f6267
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_37685
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_37685:
    movl %eax, -16(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_37686"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_37686:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_37688
    cmp  $0,%eax
    jge _L_37687
_L_37688:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_37687:
    movl -16(%esp), %esi
    movl -1(%eax,%esi), %eax
    movl %eax, 4(%ebp)
    movl -12(%esp), %eax
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    or   $1, %al
    add  $8, %ebp
# cons end
    movl -4(%esp), %ebx
    movl -8(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "make-symbol") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "symbol?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "string-set!") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "string-ref") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "string-length") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "string?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "make-string") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "vector-ref") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "vector-set!") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "vector-length") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "make-vector") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "vector?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "set-cdr!") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "set-car!") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "cdr") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "car") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "cons") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "pair?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fxremainder") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fxquotient") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fx*") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fx-") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fx+") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fx>=") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fx>") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fx<=") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fx<") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fx=") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "eof-object") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "eof-object?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f6267 0))) (closure () (f6267) (let () (vector-ref f6267 0))))
# emit-begin
#   expr=(begin (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "make-symbol") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "symbol?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "string-set!") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "string-ref") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "string-length") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "string?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "make-string") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "vector-ref") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "vector-set!") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "vector-length") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "make-vector") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "vector?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "set-cdr!") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "set-car!") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "cdr") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "car") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "cons") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "pair?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fxremainder") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fxquotient") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fx*") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fx-") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fx+") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fx>=") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fx>") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fx<=") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fx<") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fx=") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "eof-object") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "eof-object?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f6267 0))) (closure () (f6267) (let () (vector-ref f6267 0))))
#   env=((f6267 . 0))
# emit-expr (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "make-symbol") (vector-ref f6267 0)))
# emit-expr f6267
# emit-variable-ref
# env=((f6267 . 0))
# var=f6267
    movl 0(%esp), %eax  # stack load f6267
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_37689
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_37689:
    movl %eax, -4(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_37690"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_37690:
# check bounds on vector index
    movl -4(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_37692
    cmp  $0,%eax
    jge _L_37691
_L_37692:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_37691:
    movl %eax, -8(%esp)
# emit-expr (cons ((primitive-ref string->symbol) "make-symbol") (vector-ref f6267 0))
# cons arg1=((primitive-ref string->symbol) "make-symbol") arg2=(vector-ref f6267 0)
# emit-expr ((primitive-ref string->symbol) "make-symbol")
# funcall
#    si   =-12
#    env  = ((f6267 . 0))
#    expr = (funcall (primitive-ref string->symbol) "make-symbol")
# emit-expr (primitive-ref string->symbol)
    .extern mrc_string$m$gsymbol
    movl mrc_string$m$gsymbol,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_37693"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_37693":
   movl %eax,  -20(%esp)  # stash funcall-oper in closure slot
# emit-expr "make-symbol"
# string literal
    jmp _L_37695
    .align 8,0x90
_L_37694 :
    .int 44
    .ascii "make-symbol"
_L_37695:
    movl $_L_37694, %eax
    orl $6, %eax
    mov %eax, -24(%esp)  # arg make-symbol
    movl -20(%esp), %edi   # load new closure to %edi
    add $-12, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $12, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    movl %eax, -12(%esp)
# emit-expr (vector-ref f6267 0)
# emit-expr f6267
# emit-variable-ref
# env=((f6267 . 0))
# var=f6267
    movl 0(%esp), %eax  # stack load f6267
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_37696
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_37696:
    movl %eax, -16(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_37697"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_37697:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_37699
    cmp  $0,%eax
    jge _L_37698
_L_37699:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_37698:
    movl -16(%esp), %esi
    movl -1(%eax,%esi), %eax
    movl %eax, 4(%ebp)
    movl -12(%esp), %eax
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    or   $1, %al
    add  $8, %ebp
# cons end
    movl -4(%esp), %ebx
    movl -8(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "symbol?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "string-set!") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "string-ref") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "string-length") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "string?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "make-string") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "vector-ref") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "vector-set!") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "vector-length") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "make-vector") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "vector?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "set-cdr!") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "set-car!") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "cdr") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "car") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "cons") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "pair?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fxremainder") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fxquotient") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fx*") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fx-") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fx+") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fx>=") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fx>") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fx<=") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fx<") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fx=") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "eof-object") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "eof-object?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f6267 0))) (closure () (f6267) (let () (vector-ref f6267 0))))
# emit-begin
#   expr=(begin (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "symbol?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "string-set!") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "string-ref") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "string-length") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "string?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "make-string") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "vector-ref") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "vector-set!") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "vector-length") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "make-vector") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "vector?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "set-cdr!") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "set-car!") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "cdr") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "car") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "cons") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "pair?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fxremainder") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fxquotient") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fx*") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fx-") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fx+") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fx>=") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fx>") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fx<=") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fx<") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fx=") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "eof-object") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "eof-object?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f6267 0))) (closure () (f6267) (let () (vector-ref f6267 0))))
#   env=((f6267 . 0))
# emit-expr (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "symbol?") (vector-ref f6267 0)))
# emit-expr f6267
# emit-variable-ref
# env=((f6267 . 0))
# var=f6267
    movl 0(%esp), %eax  # stack load f6267
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_37700
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_37700:
    movl %eax, -4(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_37701"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_37701:
# check bounds on vector index
    movl -4(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_37703
    cmp  $0,%eax
    jge _L_37702
_L_37703:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_37702:
    movl %eax, -8(%esp)
# emit-expr (cons ((primitive-ref string->symbol) "symbol?") (vector-ref f6267 0))
# cons arg1=((primitive-ref string->symbol) "symbol?") arg2=(vector-ref f6267 0)
# emit-expr ((primitive-ref string->symbol) "symbol?")
# funcall
#    si   =-12
#    env  = ((f6267 . 0))
#    expr = (funcall (primitive-ref string->symbol) "symbol?")
# emit-expr (primitive-ref string->symbol)
    .extern mrc_string$m$gsymbol
    movl mrc_string$m$gsymbol,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_37704"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_37704":
   movl %eax,  -20(%esp)  # stash funcall-oper in closure slot
# emit-expr "symbol?"
# string literal
    jmp _L_37706
    .align 8,0x90
_L_37705 :
    .int 28
    .ascii "symbol?"
_L_37706:
    movl $_L_37705, %eax
    orl $6, %eax
    mov %eax, -24(%esp)  # arg symbol?
    movl -20(%esp), %edi   # load new closure to %edi
    add $-12, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $12, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    movl %eax, -12(%esp)
# emit-expr (vector-ref f6267 0)
# emit-expr f6267
# emit-variable-ref
# env=((f6267 . 0))
# var=f6267
    movl 0(%esp), %eax  # stack load f6267
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_37707
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_37707:
    movl %eax, -16(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_37708"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_37708:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_37710
    cmp  $0,%eax
    jge _L_37709
_L_37710:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_37709:
    movl -16(%esp), %esi
    movl -1(%eax,%esi), %eax
    movl %eax, 4(%ebp)
    movl -12(%esp), %eax
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    or   $1, %al
    add  $8, %ebp
# cons end
    movl -4(%esp), %ebx
    movl -8(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "string-set!") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "string-ref") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "string-length") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "string?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "make-string") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "vector-ref") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "vector-set!") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "vector-length") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "make-vector") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "vector?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "set-cdr!") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "set-car!") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "cdr") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "car") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "cons") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "pair?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fxremainder") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fxquotient") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fx*") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fx-") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fx+") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fx>=") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fx>") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fx<=") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fx<") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fx=") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "eof-object") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "eof-object?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f6267 0))) (closure () (f6267) (let () (vector-ref f6267 0))))
# emit-begin
#   expr=(begin (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "string-set!") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "string-ref") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "string-length") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "string?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "make-string") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "vector-ref") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "vector-set!") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "vector-length") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "make-vector") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "vector?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "set-cdr!") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "set-car!") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "cdr") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "car") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "cons") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "pair?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fxremainder") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fxquotient") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fx*") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fx-") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fx+") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fx>=") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fx>") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fx<=") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fx<") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fx=") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "eof-object") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "eof-object?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f6267 0))) (closure () (f6267) (let () (vector-ref f6267 0))))
#   env=((f6267 . 0))
# emit-expr (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "string-set!") (vector-ref f6267 0)))
# emit-expr f6267
# emit-variable-ref
# env=((f6267 . 0))
# var=f6267
    movl 0(%esp), %eax  # stack load f6267
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_37711
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_37711:
    movl %eax, -4(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_37712"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_37712:
# check bounds on vector index
    movl -4(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_37714
    cmp  $0,%eax
    jge _L_37713
_L_37714:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_37713:
    movl %eax, -8(%esp)
# emit-expr (cons ((primitive-ref string->symbol) "string-set!") (vector-ref f6267 0))
# cons arg1=((primitive-ref string->symbol) "string-set!") arg2=(vector-ref f6267 0)
# emit-expr ((primitive-ref string->symbol) "string-set!")
# funcall
#    si   =-12
#    env  = ((f6267 . 0))
#    expr = (funcall (primitive-ref string->symbol) "string-set!")
# emit-expr (primitive-ref string->symbol)
    .extern mrc_string$m$gsymbol
    movl mrc_string$m$gsymbol,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_37715"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_37715":
   movl %eax,  -20(%esp)  # stash funcall-oper in closure slot
# emit-expr "string-set!"
# string literal
    jmp _L_37717
    .align 8,0x90
_L_37716 :
    .int 44
    .ascii "string-set!"
_L_37717:
    movl $_L_37716, %eax
    orl $6, %eax
    mov %eax, -24(%esp)  # arg string-set!
    movl -20(%esp), %edi   # load new closure to %edi
    add $-12, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $12, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    movl %eax, -12(%esp)
# emit-expr (vector-ref f6267 0)
# emit-expr f6267
# emit-variable-ref
# env=((f6267 . 0))
# var=f6267
    movl 0(%esp), %eax  # stack load f6267
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_37718
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_37718:
    movl %eax, -16(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_37719"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_37719:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_37721
    cmp  $0,%eax
    jge _L_37720
_L_37721:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_37720:
    movl -16(%esp), %esi
    movl -1(%eax,%esi), %eax
    movl %eax, 4(%ebp)
    movl -12(%esp), %eax
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    or   $1, %al
    add  $8, %ebp
# cons end
    movl -4(%esp), %ebx
    movl -8(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "string-ref") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "string-length") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "string?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "make-string") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "vector-ref") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "vector-set!") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "vector-length") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "make-vector") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "vector?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "set-cdr!") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "set-car!") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "cdr") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "car") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "cons") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "pair?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fxremainder") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fxquotient") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fx*") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fx-") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fx+") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fx>=") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fx>") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fx<=") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fx<") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fx=") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "eof-object") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "eof-object?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f6267 0))) (closure () (f6267) (let () (vector-ref f6267 0))))
# emit-begin
#   expr=(begin (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "string-ref") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "string-length") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "string?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "make-string") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "vector-ref") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "vector-set!") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "vector-length") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "make-vector") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "vector?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "set-cdr!") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "set-car!") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "cdr") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "car") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "cons") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "pair?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fxremainder") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fxquotient") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fx*") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fx-") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fx+") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fx>=") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fx>") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fx<=") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fx<") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fx=") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "eof-object") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "eof-object?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f6267 0))) (closure () (f6267) (let () (vector-ref f6267 0))))
#   env=((f6267 . 0))
# emit-expr (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "string-ref") (vector-ref f6267 0)))
# emit-expr f6267
# emit-variable-ref
# env=((f6267 . 0))
# var=f6267
    movl 0(%esp), %eax  # stack load f6267
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_37722
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_37722:
    movl %eax, -4(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_37723"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_37723:
# check bounds on vector index
    movl -4(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_37725
    cmp  $0,%eax
    jge _L_37724
_L_37725:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_37724:
    movl %eax, -8(%esp)
# emit-expr (cons ((primitive-ref string->symbol) "string-ref") (vector-ref f6267 0))
# cons arg1=((primitive-ref string->symbol) "string-ref") arg2=(vector-ref f6267 0)
# emit-expr ((primitive-ref string->symbol) "string-ref")
# funcall
#    si   =-12
#    env  = ((f6267 . 0))
#    expr = (funcall (primitive-ref string->symbol) "string-ref")
# emit-expr (primitive-ref string->symbol)
    .extern mrc_string$m$gsymbol
    movl mrc_string$m$gsymbol,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_37726"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_37726":
   movl %eax,  -20(%esp)  # stash funcall-oper in closure slot
# emit-expr "string-ref"
# string literal
    jmp _L_37728
    .align 8,0x90
_L_37727 :
    .int 40
    .ascii "string-ref"
_L_37728:
    movl $_L_37727, %eax
    orl $6, %eax
    mov %eax, -24(%esp)  # arg string-ref
    movl -20(%esp), %edi   # load new closure to %edi
    add $-12, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $12, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    movl %eax, -12(%esp)
# emit-expr (vector-ref f6267 0)
# emit-expr f6267
# emit-variable-ref
# env=((f6267 . 0))
# var=f6267
    movl 0(%esp), %eax  # stack load f6267
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_37729
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_37729:
    movl %eax, -16(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_37730"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_37730:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_37732
    cmp  $0,%eax
    jge _L_37731
_L_37732:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_37731:
    movl -16(%esp), %esi
    movl -1(%eax,%esi), %eax
    movl %eax, 4(%ebp)
    movl -12(%esp), %eax
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    or   $1, %al
    add  $8, %ebp
# cons end
    movl -4(%esp), %ebx
    movl -8(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "string-length") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "string?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "make-string") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "vector-ref") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "vector-set!") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "vector-length") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "make-vector") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "vector?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "set-cdr!") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "set-car!") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "cdr") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "car") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "cons") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "pair?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fxremainder") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fxquotient") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fx*") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fx-") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fx+") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fx>=") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fx>") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fx<=") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fx<") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fx=") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "eof-object") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "eof-object?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f6267 0))) (closure () (f6267) (let () (vector-ref f6267 0))))
# emit-begin
#   expr=(begin (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "string-length") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "string?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "make-string") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "vector-ref") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "vector-set!") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "vector-length") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "make-vector") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "vector?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "set-cdr!") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "set-car!") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "cdr") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "car") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "cons") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "pair?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fxremainder") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fxquotient") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fx*") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fx-") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fx+") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fx>=") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fx>") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fx<=") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fx<") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fx=") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "eof-object") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "eof-object?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f6267 0))) (closure () (f6267) (let () (vector-ref f6267 0))))
#   env=((f6267 . 0))
# emit-expr (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "string-length") (vector-ref f6267 0)))
# emit-expr f6267
# emit-variable-ref
# env=((f6267 . 0))
# var=f6267
    movl 0(%esp), %eax  # stack load f6267
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_37733
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_37733:
    movl %eax, -4(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_37734"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_37734:
# check bounds on vector index
    movl -4(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_37736
    cmp  $0,%eax
    jge _L_37735
_L_37736:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_37735:
    movl %eax, -8(%esp)
# emit-expr (cons ((primitive-ref string->symbol) "string-length") (vector-ref f6267 0))
# cons arg1=((primitive-ref string->symbol) "string-length") arg2=(vector-ref f6267 0)
# emit-expr ((primitive-ref string->symbol) "string-length")
# funcall
#    si   =-12
#    env  = ((f6267 . 0))
#    expr = (funcall (primitive-ref string->symbol) "string-length")
# emit-expr (primitive-ref string->symbol)
    .extern mrc_string$m$gsymbol
    movl mrc_string$m$gsymbol,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_37737"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_37737":
   movl %eax,  -20(%esp)  # stash funcall-oper in closure slot
# emit-expr "string-length"
# string literal
    jmp _L_37739
    .align 8,0x90
_L_37738 :
    .int 52
    .ascii "string-length"
_L_37739:
    movl $_L_37738, %eax
    orl $6, %eax
    mov %eax, -24(%esp)  # arg string-length
    movl -20(%esp), %edi   # load new closure to %edi
    add $-12, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $12, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    movl %eax, -12(%esp)
# emit-expr (vector-ref f6267 0)
# emit-expr f6267
# emit-variable-ref
# env=((f6267 . 0))
# var=f6267
    movl 0(%esp), %eax  # stack load f6267
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_37740
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_37740:
    movl %eax, -16(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_37741"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_37741:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_37743
    cmp  $0,%eax
    jge _L_37742
_L_37743:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_37742:
    movl -16(%esp), %esi
    movl -1(%eax,%esi), %eax
    movl %eax, 4(%ebp)
    movl -12(%esp), %eax
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    or   $1, %al
    add  $8, %ebp
# cons end
    movl -4(%esp), %ebx
    movl -8(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "string?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "make-string") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "vector-ref") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "vector-set!") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "vector-length") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "make-vector") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "vector?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "set-cdr!") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "set-car!") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "cdr") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "car") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "cons") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "pair?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fxremainder") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fxquotient") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fx*") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fx-") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fx+") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fx>=") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fx>") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fx<=") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fx<") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fx=") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "eof-object") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "eof-object?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f6267 0))) (closure () (f6267) (let () (vector-ref f6267 0))))
# emit-begin
#   expr=(begin (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "string?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "make-string") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "vector-ref") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "vector-set!") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "vector-length") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "make-vector") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "vector?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "set-cdr!") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "set-car!") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "cdr") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "car") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "cons") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "pair?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fxremainder") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fxquotient") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fx*") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fx-") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fx+") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fx>=") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fx>") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fx<=") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fx<") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fx=") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "eof-object") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "eof-object?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f6267 0))) (closure () (f6267) (let () (vector-ref f6267 0))))
#   env=((f6267 . 0))
# emit-expr (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "string?") (vector-ref f6267 0)))
# emit-expr f6267
# emit-variable-ref
# env=((f6267 . 0))
# var=f6267
    movl 0(%esp), %eax  # stack load f6267
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_37744
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_37744:
    movl %eax, -4(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_37745"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_37745:
# check bounds on vector index
    movl -4(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_37747
    cmp  $0,%eax
    jge _L_37746
_L_37747:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_37746:
    movl %eax, -8(%esp)
# emit-expr (cons ((primitive-ref string->symbol) "string?") (vector-ref f6267 0))
# cons arg1=((primitive-ref string->symbol) "string?") arg2=(vector-ref f6267 0)
# emit-expr ((primitive-ref string->symbol) "string?")
# funcall
#    si   =-12
#    env  = ((f6267 . 0))
#    expr = (funcall (primitive-ref string->symbol) "string?")
# emit-expr (primitive-ref string->symbol)
    .extern mrc_string$m$gsymbol
    movl mrc_string$m$gsymbol,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_37748"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_37748":
   movl %eax,  -20(%esp)  # stash funcall-oper in closure slot
# emit-expr "string?"
# string literal
    jmp _L_37750
    .align 8,0x90
_L_37749 :
    .int 28
    .ascii "string?"
_L_37750:
    movl $_L_37749, %eax
    orl $6, %eax
    mov %eax, -24(%esp)  # arg string?
    movl -20(%esp), %edi   # load new closure to %edi
    add $-12, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $12, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    movl %eax, -12(%esp)
# emit-expr (vector-ref f6267 0)
# emit-expr f6267
# emit-variable-ref
# env=((f6267 . 0))
# var=f6267
    movl 0(%esp), %eax  # stack load f6267
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_37751
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_37751:
    movl %eax, -16(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_37752"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_37752:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_37754
    cmp  $0,%eax
    jge _L_37753
_L_37754:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_37753:
    movl -16(%esp), %esi
    movl -1(%eax,%esi), %eax
    movl %eax, 4(%ebp)
    movl -12(%esp), %eax
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    or   $1, %al
    add  $8, %ebp
# cons end
    movl -4(%esp), %ebx
    movl -8(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "make-string") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "vector-ref") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "vector-set!") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "vector-length") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "make-vector") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "vector?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "set-cdr!") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "set-car!") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "cdr") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "car") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "cons") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "pair?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fxremainder") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fxquotient") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fx*") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fx-") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fx+") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fx>=") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fx>") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fx<=") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fx<") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fx=") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "eof-object") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "eof-object?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f6267 0))) (closure () (f6267) (let () (vector-ref f6267 0))))
# emit-begin
#   expr=(begin (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "make-string") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "vector-ref") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "vector-set!") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "vector-length") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "make-vector") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "vector?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "set-cdr!") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "set-car!") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "cdr") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "car") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "cons") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "pair?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fxremainder") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fxquotient") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fx*") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fx-") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fx+") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fx>=") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fx>") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fx<=") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fx<") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fx=") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "eof-object") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "eof-object?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f6267 0))) (closure () (f6267) (let () (vector-ref f6267 0))))
#   env=((f6267 . 0))
# emit-expr (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "make-string") (vector-ref f6267 0)))
# emit-expr f6267
# emit-variable-ref
# env=((f6267 . 0))
# var=f6267
    movl 0(%esp), %eax  # stack load f6267
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_37755
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_37755:
    movl %eax, -4(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_37756"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_37756:
# check bounds on vector index
    movl -4(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_37758
    cmp  $0,%eax
    jge _L_37757
_L_37758:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_37757:
    movl %eax, -8(%esp)
# emit-expr (cons ((primitive-ref string->symbol) "make-string") (vector-ref f6267 0))
# cons arg1=((primitive-ref string->symbol) "make-string") arg2=(vector-ref f6267 0)
# emit-expr ((primitive-ref string->symbol) "make-string")
# funcall
#    si   =-12
#    env  = ((f6267 . 0))
#    expr = (funcall (primitive-ref string->symbol) "make-string")
# emit-expr (primitive-ref string->symbol)
    .extern mrc_string$m$gsymbol
    movl mrc_string$m$gsymbol,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_37759"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_37759":
   movl %eax,  -20(%esp)  # stash funcall-oper in closure slot
# emit-expr "make-string"
# string literal
    jmp _L_37761
    .align 8,0x90
_L_37760 :
    .int 44
    .ascii "make-string"
_L_37761:
    movl $_L_37760, %eax
    orl $6, %eax
    mov %eax, -24(%esp)  # arg make-string
    movl -20(%esp), %edi   # load new closure to %edi
    add $-12, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $12, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    movl %eax, -12(%esp)
# emit-expr (vector-ref f6267 0)
# emit-expr f6267
# emit-variable-ref
# env=((f6267 . 0))
# var=f6267
    movl 0(%esp), %eax  # stack load f6267
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_37762
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_37762:
    movl %eax, -16(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_37763"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_37763:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_37765
    cmp  $0,%eax
    jge _L_37764
_L_37765:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_37764:
    movl -16(%esp), %esi
    movl -1(%eax,%esi), %eax
    movl %eax, 4(%ebp)
    movl -12(%esp), %eax
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    or   $1, %al
    add  $8, %ebp
# cons end
    movl -4(%esp), %ebx
    movl -8(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "vector-ref") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "vector-set!") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "vector-length") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "make-vector") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "vector?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "set-cdr!") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "set-car!") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "cdr") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "car") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "cons") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "pair?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fxremainder") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fxquotient") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fx*") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fx-") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fx+") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fx>=") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fx>") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fx<=") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fx<") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fx=") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "eof-object") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "eof-object?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f6267 0))) (closure () (f6267) (let () (vector-ref f6267 0))))
# emit-begin
#   expr=(begin (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "vector-ref") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "vector-set!") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "vector-length") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "make-vector") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "vector?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "set-cdr!") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "set-car!") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "cdr") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "car") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "cons") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "pair?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fxremainder") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fxquotient") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fx*") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fx-") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fx+") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fx>=") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fx>") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fx<=") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fx<") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fx=") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "eof-object") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "eof-object?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f6267 0))) (closure () (f6267) (let () (vector-ref f6267 0))))
#   env=((f6267 . 0))
# emit-expr (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "vector-ref") (vector-ref f6267 0)))
# emit-expr f6267
# emit-variable-ref
# env=((f6267 . 0))
# var=f6267
    movl 0(%esp), %eax  # stack load f6267
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_37766
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_37766:
    movl %eax, -4(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_37767"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_37767:
# check bounds on vector index
    movl -4(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_37769
    cmp  $0,%eax
    jge _L_37768
_L_37769:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_37768:
    movl %eax, -8(%esp)
# emit-expr (cons ((primitive-ref string->symbol) "vector-ref") (vector-ref f6267 0))
# cons arg1=((primitive-ref string->symbol) "vector-ref") arg2=(vector-ref f6267 0)
# emit-expr ((primitive-ref string->symbol) "vector-ref")
# funcall
#    si   =-12
#    env  = ((f6267 . 0))
#    expr = (funcall (primitive-ref string->symbol) "vector-ref")
# emit-expr (primitive-ref string->symbol)
    .extern mrc_string$m$gsymbol
    movl mrc_string$m$gsymbol,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_37770"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_37770":
   movl %eax,  -20(%esp)  # stash funcall-oper in closure slot
# emit-expr "vector-ref"
# string literal
    jmp _L_37772
    .align 8,0x90
_L_37771 :
    .int 40
    .ascii "vector-ref"
_L_37772:
    movl $_L_37771, %eax
    orl $6, %eax
    mov %eax, -24(%esp)  # arg vector-ref
    movl -20(%esp), %edi   # load new closure to %edi
    add $-12, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $12, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    movl %eax, -12(%esp)
# emit-expr (vector-ref f6267 0)
# emit-expr f6267
# emit-variable-ref
# env=((f6267 . 0))
# var=f6267
    movl 0(%esp), %eax  # stack load f6267
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_37773
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_37773:
    movl %eax, -16(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_37774"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_37774:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_37776
    cmp  $0,%eax
    jge _L_37775
_L_37776:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_37775:
    movl -16(%esp), %esi
    movl -1(%eax,%esi), %eax
    movl %eax, 4(%ebp)
    movl -12(%esp), %eax
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    or   $1, %al
    add  $8, %ebp
# cons end
    movl -4(%esp), %ebx
    movl -8(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "vector-set!") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "vector-length") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "make-vector") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "vector?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "set-cdr!") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "set-car!") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "cdr") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "car") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "cons") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "pair?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fxremainder") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fxquotient") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fx*") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fx-") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fx+") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fx>=") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fx>") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fx<=") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fx<") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fx=") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "eof-object") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "eof-object?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f6267 0))) (closure () (f6267) (let () (vector-ref f6267 0))))
# emit-begin
#   expr=(begin (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "vector-set!") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "vector-length") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "make-vector") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "vector?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "set-cdr!") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "set-car!") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "cdr") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "car") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "cons") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "pair?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fxremainder") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fxquotient") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fx*") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fx-") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fx+") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fx>=") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fx>") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fx<=") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fx<") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fx=") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "eof-object") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "eof-object?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f6267 0))) (closure () (f6267) (let () (vector-ref f6267 0))))
#   env=((f6267 . 0))
# emit-expr (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "vector-set!") (vector-ref f6267 0)))
# emit-expr f6267
# emit-variable-ref
# env=((f6267 . 0))
# var=f6267
    movl 0(%esp), %eax  # stack load f6267
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_37777
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_37777:
    movl %eax, -4(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_37778"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_37778:
# check bounds on vector index
    movl -4(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_37780
    cmp  $0,%eax
    jge _L_37779
_L_37780:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_37779:
    movl %eax, -8(%esp)
# emit-expr (cons ((primitive-ref string->symbol) "vector-set!") (vector-ref f6267 0))
# cons arg1=((primitive-ref string->symbol) "vector-set!") arg2=(vector-ref f6267 0)
# emit-expr ((primitive-ref string->symbol) "vector-set!")
# funcall
#    si   =-12
#    env  = ((f6267 . 0))
#    expr = (funcall (primitive-ref string->symbol) "vector-set!")
# emit-expr (primitive-ref string->symbol)
    .extern mrc_string$m$gsymbol
    movl mrc_string$m$gsymbol,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_37781"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_37781":
   movl %eax,  -20(%esp)  # stash funcall-oper in closure slot
# emit-expr "vector-set!"
# string literal
    jmp _L_37783
    .align 8,0x90
_L_37782 :
    .int 44
    .ascii "vector-set!"
_L_37783:
    movl $_L_37782, %eax
    orl $6, %eax
    mov %eax, -24(%esp)  # arg vector-set!
    movl -20(%esp), %edi   # load new closure to %edi
    add $-12, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $12, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    movl %eax, -12(%esp)
# emit-expr (vector-ref f6267 0)
# emit-expr f6267
# emit-variable-ref
# env=((f6267 . 0))
# var=f6267
    movl 0(%esp), %eax  # stack load f6267
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_37784
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_37784:
    movl %eax, -16(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_37785"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_37785:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_37787
    cmp  $0,%eax
    jge _L_37786
_L_37787:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_37786:
    movl -16(%esp), %esi
    movl -1(%eax,%esi), %eax
    movl %eax, 4(%ebp)
    movl -12(%esp), %eax
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    or   $1, %al
    add  $8, %ebp
# cons end
    movl -4(%esp), %ebx
    movl -8(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "vector-length") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "make-vector") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "vector?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "set-cdr!") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "set-car!") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "cdr") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "car") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "cons") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "pair?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fxremainder") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fxquotient") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fx*") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fx-") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fx+") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fx>=") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fx>") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fx<=") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fx<") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fx=") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "eof-object") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "eof-object?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f6267 0))) (closure () (f6267) (let () (vector-ref f6267 0))))
# emit-begin
#   expr=(begin (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "vector-length") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "make-vector") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "vector?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "set-cdr!") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "set-car!") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "cdr") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "car") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "cons") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "pair?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fxremainder") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fxquotient") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fx*") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fx-") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fx+") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fx>=") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fx>") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fx<=") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fx<") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fx=") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "eof-object") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "eof-object?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f6267 0))) (closure () (f6267) (let () (vector-ref f6267 0))))
#   env=((f6267 . 0))
# emit-expr (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "vector-length") (vector-ref f6267 0)))
# emit-expr f6267
# emit-variable-ref
# env=((f6267 . 0))
# var=f6267
    movl 0(%esp), %eax  # stack load f6267
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_37788
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_37788:
    movl %eax, -4(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_37789"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_37789:
# check bounds on vector index
    movl -4(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_37791
    cmp  $0,%eax
    jge _L_37790
_L_37791:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_37790:
    movl %eax, -8(%esp)
# emit-expr (cons ((primitive-ref string->symbol) "vector-length") (vector-ref f6267 0))
# cons arg1=((primitive-ref string->symbol) "vector-length") arg2=(vector-ref f6267 0)
# emit-expr ((primitive-ref string->symbol) "vector-length")
# funcall
#    si   =-12
#    env  = ((f6267 . 0))
#    expr = (funcall (primitive-ref string->symbol) "vector-length")
# emit-expr (primitive-ref string->symbol)
    .extern mrc_string$m$gsymbol
    movl mrc_string$m$gsymbol,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_37792"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_37792":
   movl %eax,  -20(%esp)  # stash funcall-oper in closure slot
# emit-expr "vector-length"
# string literal
    jmp _L_37794
    .align 8,0x90
_L_37793 :
    .int 52
    .ascii "vector-length"
_L_37794:
    movl $_L_37793, %eax
    orl $6, %eax
    mov %eax, -24(%esp)  # arg vector-length
    movl -20(%esp), %edi   # load new closure to %edi
    add $-12, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $12, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    movl %eax, -12(%esp)
# emit-expr (vector-ref f6267 0)
# emit-expr f6267
# emit-variable-ref
# env=((f6267 . 0))
# var=f6267
    movl 0(%esp), %eax  # stack load f6267
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_37795
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_37795:
    movl %eax, -16(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_37796"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_37796:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_37798
    cmp  $0,%eax
    jge _L_37797
_L_37798:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_37797:
    movl -16(%esp), %esi
    movl -1(%eax,%esi), %eax
    movl %eax, 4(%ebp)
    movl -12(%esp), %eax
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    or   $1, %al
    add  $8, %ebp
# cons end
    movl -4(%esp), %ebx
    movl -8(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "make-vector") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "vector?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "set-cdr!") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "set-car!") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "cdr") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "car") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "cons") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "pair?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fxremainder") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fxquotient") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fx*") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fx-") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fx+") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fx>=") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fx>") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fx<=") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fx<") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fx=") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "eof-object") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "eof-object?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f6267 0))) (closure () (f6267) (let () (vector-ref f6267 0))))
# emit-begin
#   expr=(begin (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "make-vector") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "vector?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "set-cdr!") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "set-car!") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "cdr") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "car") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "cons") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "pair?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fxremainder") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fxquotient") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fx*") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fx-") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fx+") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fx>=") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fx>") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fx<=") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fx<") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fx=") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "eof-object") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "eof-object?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f6267 0))) (closure () (f6267) (let () (vector-ref f6267 0))))
#   env=((f6267 . 0))
# emit-expr (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "make-vector") (vector-ref f6267 0)))
# emit-expr f6267
# emit-variable-ref
# env=((f6267 . 0))
# var=f6267
    movl 0(%esp), %eax  # stack load f6267
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_37799
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_37799:
    movl %eax, -4(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_37800"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_37800:
# check bounds on vector index
    movl -4(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_37802
    cmp  $0,%eax
    jge _L_37801
_L_37802:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_37801:
    movl %eax, -8(%esp)
# emit-expr (cons ((primitive-ref string->symbol) "make-vector") (vector-ref f6267 0))
# cons arg1=((primitive-ref string->symbol) "make-vector") arg2=(vector-ref f6267 0)
# emit-expr ((primitive-ref string->symbol) "make-vector")
# funcall
#    si   =-12
#    env  = ((f6267 . 0))
#    expr = (funcall (primitive-ref string->symbol) "make-vector")
# emit-expr (primitive-ref string->symbol)
    .extern mrc_string$m$gsymbol
    movl mrc_string$m$gsymbol,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_37803"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_37803":
   movl %eax,  -20(%esp)  # stash funcall-oper in closure slot
# emit-expr "make-vector"
# string literal
    jmp _L_37805
    .align 8,0x90
_L_37804 :
    .int 44
    .ascii "make-vector"
_L_37805:
    movl $_L_37804, %eax
    orl $6, %eax
    mov %eax, -24(%esp)  # arg make-vector
    movl -20(%esp), %edi   # load new closure to %edi
    add $-12, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $12, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    movl %eax, -12(%esp)
# emit-expr (vector-ref f6267 0)
# emit-expr f6267
# emit-variable-ref
# env=((f6267 . 0))
# var=f6267
    movl 0(%esp), %eax  # stack load f6267
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_37806
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_37806:
    movl %eax, -16(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_37807"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_37807:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_37809
    cmp  $0,%eax
    jge _L_37808
_L_37809:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_37808:
    movl -16(%esp), %esi
    movl -1(%eax,%esi), %eax
    movl %eax, 4(%ebp)
    movl -12(%esp), %eax
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    or   $1, %al
    add  $8, %ebp
# cons end
    movl -4(%esp), %ebx
    movl -8(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "vector?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "set-cdr!") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "set-car!") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "cdr") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "car") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "cons") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "pair?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fxremainder") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fxquotient") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fx*") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fx-") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fx+") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fx>=") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fx>") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fx<=") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fx<") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fx=") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "eof-object") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "eof-object?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f6267 0))) (closure () (f6267) (let () (vector-ref f6267 0))))
# emit-begin
#   expr=(begin (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "vector?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "set-cdr!") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "set-car!") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "cdr") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "car") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "cons") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "pair?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fxremainder") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fxquotient") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fx*") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fx-") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fx+") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fx>=") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fx>") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fx<=") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fx<") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fx=") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "eof-object") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "eof-object?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f6267 0))) (closure () (f6267) (let () (vector-ref f6267 0))))
#   env=((f6267 . 0))
# emit-expr (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "vector?") (vector-ref f6267 0)))
# emit-expr f6267
# emit-variable-ref
# env=((f6267 . 0))
# var=f6267
    movl 0(%esp), %eax  # stack load f6267
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_37810
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_37810:
    movl %eax, -4(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_37811"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_37811:
# check bounds on vector index
    movl -4(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_37813
    cmp  $0,%eax
    jge _L_37812
_L_37813:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_37812:
    movl %eax, -8(%esp)
# emit-expr (cons ((primitive-ref string->symbol) "vector?") (vector-ref f6267 0))
# cons arg1=((primitive-ref string->symbol) "vector?") arg2=(vector-ref f6267 0)
# emit-expr ((primitive-ref string->symbol) "vector?")
# funcall
#    si   =-12
#    env  = ((f6267 . 0))
#    expr = (funcall (primitive-ref string->symbol) "vector?")
# emit-expr (primitive-ref string->symbol)
    .extern mrc_string$m$gsymbol
    movl mrc_string$m$gsymbol,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_37814"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_37814":
   movl %eax,  -20(%esp)  # stash funcall-oper in closure slot
# emit-expr "vector?"
# string literal
    jmp _L_37816
    .align 8,0x90
_L_37815 :
    .int 28
    .ascii "vector?"
_L_37816:
    movl $_L_37815, %eax
    orl $6, %eax
    mov %eax, -24(%esp)  # arg vector?
    movl -20(%esp), %edi   # load new closure to %edi
    add $-12, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $12, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    movl %eax, -12(%esp)
# emit-expr (vector-ref f6267 0)
# emit-expr f6267
# emit-variable-ref
# env=((f6267 . 0))
# var=f6267
    movl 0(%esp), %eax  # stack load f6267
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_37817
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_37817:
    movl %eax, -16(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_37818"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_37818:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_37820
    cmp  $0,%eax
    jge _L_37819
_L_37820:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_37819:
    movl -16(%esp), %esi
    movl -1(%eax,%esi), %eax
    movl %eax, 4(%ebp)
    movl -12(%esp), %eax
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    or   $1, %al
    add  $8, %ebp
# cons end
    movl -4(%esp), %ebx
    movl -8(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "set-cdr!") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "set-car!") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "cdr") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "car") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "cons") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "pair?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fxremainder") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fxquotient") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fx*") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fx-") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fx+") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fx>=") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fx>") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fx<=") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fx<") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fx=") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "eof-object") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "eof-object?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f6267 0))) (closure () (f6267) (let () (vector-ref f6267 0))))
# emit-begin
#   expr=(begin (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "set-cdr!") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "set-car!") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "cdr") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "car") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "cons") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "pair?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fxremainder") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fxquotient") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fx*") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fx-") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fx+") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fx>=") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fx>") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fx<=") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fx<") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fx=") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "eof-object") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "eof-object?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f6267 0))) (closure () (f6267) (let () (vector-ref f6267 0))))
#   env=((f6267 . 0))
# emit-expr (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "set-cdr!") (vector-ref f6267 0)))
# emit-expr f6267
# emit-variable-ref
# env=((f6267 . 0))
# var=f6267
    movl 0(%esp), %eax  # stack load f6267
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_37821
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_37821:
    movl %eax, -4(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_37822"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_37822:
# check bounds on vector index
    movl -4(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_37824
    cmp  $0,%eax
    jge _L_37823
_L_37824:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_37823:
    movl %eax, -8(%esp)
# emit-expr (cons ((primitive-ref string->symbol) "set-cdr!") (vector-ref f6267 0))
# cons arg1=((primitive-ref string->symbol) "set-cdr!") arg2=(vector-ref f6267 0)
# emit-expr ((primitive-ref string->symbol) "set-cdr!")
# funcall
#    si   =-12
#    env  = ((f6267 . 0))
#    expr = (funcall (primitive-ref string->symbol) "set-cdr!")
# emit-expr (primitive-ref string->symbol)
    .extern mrc_string$m$gsymbol
    movl mrc_string$m$gsymbol,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_37825"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_37825":
   movl %eax,  -20(%esp)  # stash funcall-oper in closure slot
# emit-expr "set-cdr!"
# string literal
    jmp _L_37827
    .align 8,0x90
_L_37826 :
    .int 32
    .ascii "set-cdr!"
_L_37827:
    movl $_L_37826, %eax
    orl $6, %eax
    mov %eax, -24(%esp)  # arg set-cdr!
    movl -20(%esp), %edi   # load new closure to %edi
    add $-12, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $12, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    movl %eax, -12(%esp)
# emit-expr (vector-ref f6267 0)
# emit-expr f6267
# emit-variable-ref
# env=((f6267 . 0))
# var=f6267
    movl 0(%esp), %eax  # stack load f6267
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_37828
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_37828:
    movl %eax, -16(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_37829"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_37829:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_37831
    cmp  $0,%eax
    jge _L_37830
_L_37831:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_37830:
    movl -16(%esp), %esi
    movl -1(%eax,%esi), %eax
    movl %eax, 4(%ebp)
    movl -12(%esp), %eax
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    or   $1, %al
    add  $8, %ebp
# cons end
    movl -4(%esp), %ebx
    movl -8(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "set-car!") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "cdr") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "car") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "cons") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "pair?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fxremainder") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fxquotient") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fx*") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fx-") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fx+") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fx>=") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fx>") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fx<=") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fx<") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fx=") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "eof-object") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "eof-object?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f6267 0))) (closure () (f6267) (let () (vector-ref f6267 0))))
# emit-begin
#   expr=(begin (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "set-car!") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "cdr") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "car") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "cons") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "pair?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fxremainder") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fxquotient") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fx*") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fx-") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fx+") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fx>=") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fx>") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fx<=") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fx<") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fx=") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "eof-object") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "eof-object?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f6267 0))) (closure () (f6267) (let () (vector-ref f6267 0))))
#   env=((f6267 . 0))
# emit-expr (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "set-car!") (vector-ref f6267 0)))
# emit-expr f6267
# emit-variable-ref
# env=((f6267 . 0))
# var=f6267
    movl 0(%esp), %eax  # stack load f6267
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_37832
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_37832:
    movl %eax, -4(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_37833"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_37833:
# check bounds on vector index
    movl -4(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_37835
    cmp  $0,%eax
    jge _L_37834
_L_37835:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_37834:
    movl %eax, -8(%esp)
# emit-expr (cons ((primitive-ref string->symbol) "set-car!") (vector-ref f6267 0))
# cons arg1=((primitive-ref string->symbol) "set-car!") arg2=(vector-ref f6267 0)
# emit-expr ((primitive-ref string->symbol) "set-car!")
# funcall
#    si   =-12
#    env  = ((f6267 . 0))
#    expr = (funcall (primitive-ref string->symbol) "set-car!")
# emit-expr (primitive-ref string->symbol)
    .extern mrc_string$m$gsymbol
    movl mrc_string$m$gsymbol,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_37836"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_37836":
   movl %eax,  -20(%esp)  # stash funcall-oper in closure slot
# emit-expr "set-car!"
# string literal
    jmp _L_37838
    .align 8,0x90
_L_37837 :
    .int 32
    .ascii "set-car!"
_L_37838:
    movl $_L_37837, %eax
    orl $6, %eax
    mov %eax, -24(%esp)  # arg set-car!
    movl -20(%esp), %edi   # load new closure to %edi
    add $-12, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $12, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    movl %eax, -12(%esp)
# emit-expr (vector-ref f6267 0)
# emit-expr f6267
# emit-variable-ref
# env=((f6267 . 0))
# var=f6267
    movl 0(%esp), %eax  # stack load f6267
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_37839
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_37839:
    movl %eax, -16(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_37840"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_37840:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_37842
    cmp  $0,%eax
    jge _L_37841
_L_37842:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_37841:
    movl -16(%esp), %esi
    movl -1(%eax,%esi), %eax
    movl %eax, 4(%ebp)
    movl -12(%esp), %eax
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    or   $1, %al
    add  $8, %ebp
# cons end
    movl -4(%esp), %ebx
    movl -8(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "cdr") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "car") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "cons") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "pair?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fxremainder") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fxquotient") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fx*") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fx-") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fx+") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fx>=") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fx>") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fx<=") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fx<") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fx=") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "eof-object") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "eof-object?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f6267 0))) (closure () (f6267) (let () (vector-ref f6267 0))))
# emit-begin
#   expr=(begin (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "cdr") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "car") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "cons") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "pair?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fxremainder") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fxquotient") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fx*") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fx-") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fx+") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fx>=") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fx>") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fx<=") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fx<") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fx=") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "eof-object") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "eof-object?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f6267 0))) (closure () (f6267) (let () (vector-ref f6267 0))))
#   env=((f6267 . 0))
# emit-expr (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "cdr") (vector-ref f6267 0)))
# emit-expr f6267
# emit-variable-ref
# env=((f6267 . 0))
# var=f6267
    movl 0(%esp), %eax  # stack load f6267
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_37843
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_37843:
    movl %eax, -4(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_37844"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_37844:
# check bounds on vector index
    movl -4(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_37846
    cmp  $0,%eax
    jge _L_37845
_L_37846:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_37845:
    movl %eax, -8(%esp)
# emit-expr (cons ((primitive-ref string->symbol) "cdr") (vector-ref f6267 0))
# cons arg1=((primitive-ref string->symbol) "cdr") arg2=(vector-ref f6267 0)
# emit-expr ((primitive-ref string->symbol) "cdr")
# funcall
#    si   =-12
#    env  = ((f6267 . 0))
#    expr = (funcall (primitive-ref string->symbol) "cdr")
# emit-expr (primitive-ref string->symbol)
    .extern mrc_string$m$gsymbol
    movl mrc_string$m$gsymbol,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_37847"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_37847":
   movl %eax,  -20(%esp)  # stash funcall-oper in closure slot
# emit-expr "cdr"
# string literal
    jmp _L_37849
    .align 8,0x90
_L_37848 :
    .int 12
    .ascii "cdr"
_L_37849:
    movl $_L_37848, %eax
    orl $6, %eax
    mov %eax, -24(%esp)  # arg cdr
    movl -20(%esp), %edi   # load new closure to %edi
    add $-12, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $12, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    movl %eax, -12(%esp)
# emit-expr (vector-ref f6267 0)
# emit-expr f6267
# emit-variable-ref
# env=((f6267 . 0))
# var=f6267
    movl 0(%esp), %eax  # stack load f6267
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_37850
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_37850:
    movl %eax, -16(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_37851"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_37851:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_37853
    cmp  $0,%eax
    jge _L_37852
_L_37853:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_37852:
    movl -16(%esp), %esi
    movl -1(%eax,%esi), %eax
    movl %eax, 4(%ebp)
    movl -12(%esp), %eax
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    or   $1, %al
    add  $8, %ebp
# cons end
    movl -4(%esp), %ebx
    movl -8(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "car") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "cons") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "pair?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fxremainder") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fxquotient") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fx*") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fx-") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fx+") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fx>=") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fx>") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fx<=") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fx<") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fx=") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "eof-object") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "eof-object?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f6267 0))) (closure () (f6267) (let () (vector-ref f6267 0))))
# emit-begin
#   expr=(begin (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "car") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "cons") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "pair?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fxremainder") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fxquotient") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fx*") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fx-") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fx+") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fx>=") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fx>") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fx<=") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fx<") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fx=") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "eof-object") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "eof-object?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f6267 0))) (closure () (f6267) (let () (vector-ref f6267 0))))
#   env=((f6267 . 0))
# emit-expr (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "car") (vector-ref f6267 0)))
# emit-expr f6267
# emit-variable-ref
# env=((f6267 . 0))
# var=f6267
    movl 0(%esp), %eax  # stack load f6267
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_37854
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_37854:
    movl %eax, -4(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_37855"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_37855:
# check bounds on vector index
    movl -4(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_37857
    cmp  $0,%eax
    jge _L_37856
_L_37857:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_37856:
    movl %eax, -8(%esp)
# emit-expr (cons ((primitive-ref string->symbol) "car") (vector-ref f6267 0))
# cons arg1=((primitive-ref string->symbol) "car") arg2=(vector-ref f6267 0)
# emit-expr ((primitive-ref string->symbol) "car")
# funcall
#    si   =-12
#    env  = ((f6267 . 0))
#    expr = (funcall (primitive-ref string->symbol) "car")
# emit-expr (primitive-ref string->symbol)
    .extern mrc_string$m$gsymbol
    movl mrc_string$m$gsymbol,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_37858"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_37858":
   movl %eax,  -20(%esp)  # stash funcall-oper in closure slot
# emit-expr "car"
# string literal
    jmp _L_37860
    .align 8,0x90
_L_37859 :
    .int 12
    .ascii "car"
_L_37860:
    movl $_L_37859, %eax
    orl $6, %eax
    mov %eax, -24(%esp)  # arg car
    movl -20(%esp), %edi   # load new closure to %edi
    add $-12, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $12, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    movl %eax, -12(%esp)
# emit-expr (vector-ref f6267 0)
# emit-expr f6267
# emit-variable-ref
# env=((f6267 . 0))
# var=f6267
    movl 0(%esp), %eax  # stack load f6267
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_37861
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_37861:
    movl %eax, -16(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_37862"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_37862:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_37864
    cmp  $0,%eax
    jge _L_37863
_L_37864:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_37863:
    movl -16(%esp), %esi
    movl -1(%eax,%esi), %eax
    movl %eax, 4(%ebp)
    movl -12(%esp), %eax
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    or   $1, %al
    add  $8, %ebp
# cons end
    movl -4(%esp), %ebx
    movl -8(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "cons") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "pair?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fxremainder") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fxquotient") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fx*") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fx-") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fx+") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fx>=") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fx>") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fx<=") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fx<") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fx=") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "eof-object") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "eof-object?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f6267 0))) (closure () (f6267) (let () (vector-ref f6267 0))))
# emit-begin
#   expr=(begin (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "cons") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "pair?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fxremainder") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fxquotient") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fx*") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fx-") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fx+") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fx>=") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fx>") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fx<=") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fx<") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fx=") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "eof-object") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "eof-object?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f6267 0))) (closure () (f6267) (let () (vector-ref f6267 0))))
#   env=((f6267 . 0))
# emit-expr (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "cons") (vector-ref f6267 0)))
# emit-expr f6267
# emit-variable-ref
# env=((f6267 . 0))
# var=f6267
    movl 0(%esp), %eax  # stack load f6267
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_37865
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_37865:
    movl %eax, -4(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_37866"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_37866:
# check bounds on vector index
    movl -4(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_37868
    cmp  $0,%eax
    jge _L_37867
_L_37868:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_37867:
    movl %eax, -8(%esp)
# emit-expr (cons ((primitive-ref string->symbol) "cons") (vector-ref f6267 0))
# cons arg1=((primitive-ref string->symbol) "cons") arg2=(vector-ref f6267 0)
# emit-expr ((primitive-ref string->symbol) "cons")
# funcall
#    si   =-12
#    env  = ((f6267 . 0))
#    expr = (funcall (primitive-ref string->symbol) "cons")
# emit-expr (primitive-ref string->symbol)
    .extern mrc_string$m$gsymbol
    movl mrc_string$m$gsymbol,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_37869"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_37869":
   movl %eax,  -20(%esp)  # stash funcall-oper in closure slot
# emit-expr "cons"
# string literal
    jmp _L_37871
    .align 8,0x90
_L_37870 :
    .int 16
    .ascii "cons"
_L_37871:
    movl $_L_37870, %eax
    orl $6, %eax
    mov %eax, -24(%esp)  # arg cons
    movl -20(%esp), %edi   # load new closure to %edi
    add $-12, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $12, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    movl %eax, -12(%esp)
# emit-expr (vector-ref f6267 0)
# emit-expr f6267
# emit-variable-ref
# env=((f6267 . 0))
# var=f6267
    movl 0(%esp), %eax  # stack load f6267
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_37872
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_37872:
    movl %eax, -16(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_37873"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_37873:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_37875
    cmp  $0,%eax
    jge _L_37874
_L_37875:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_37874:
    movl -16(%esp), %esi
    movl -1(%eax,%esi), %eax
    movl %eax, 4(%ebp)
    movl -12(%esp), %eax
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    or   $1, %al
    add  $8, %ebp
# cons end
    movl -4(%esp), %ebx
    movl -8(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "pair?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fxremainder") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fxquotient") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fx*") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fx-") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fx+") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fx>=") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fx>") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fx<=") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fx<") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fx=") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "eof-object") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "eof-object?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f6267 0))) (closure () (f6267) (let () (vector-ref f6267 0))))
# emit-begin
#   expr=(begin (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "pair?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fxremainder") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fxquotient") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fx*") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fx-") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fx+") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fx>=") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fx>") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fx<=") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fx<") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fx=") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "eof-object") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "eof-object?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f6267 0))) (closure () (f6267) (let () (vector-ref f6267 0))))
#   env=((f6267 . 0))
# emit-expr (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "pair?") (vector-ref f6267 0)))
# emit-expr f6267
# emit-variable-ref
# env=((f6267 . 0))
# var=f6267
    movl 0(%esp), %eax  # stack load f6267
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_37876
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_37876:
    movl %eax, -4(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_37877"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_37877:
# check bounds on vector index
    movl -4(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_37879
    cmp  $0,%eax
    jge _L_37878
_L_37879:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_37878:
    movl %eax, -8(%esp)
# emit-expr (cons ((primitive-ref string->symbol) "pair?") (vector-ref f6267 0))
# cons arg1=((primitive-ref string->symbol) "pair?") arg2=(vector-ref f6267 0)
# emit-expr ((primitive-ref string->symbol) "pair?")
# funcall
#    si   =-12
#    env  = ((f6267 . 0))
#    expr = (funcall (primitive-ref string->symbol) "pair?")
# emit-expr (primitive-ref string->symbol)
    .extern mrc_string$m$gsymbol
    movl mrc_string$m$gsymbol,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_37880"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_37880":
   movl %eax,  -20(%esp)  # stash funcall-oper in closure slot
# emit-expr "pair?"
# string literal
    jmp _L_37882
    .align 8,0x90
_L_37881 :
    .int 20
    .ascii "pair?"
_L_37882:
    movl $_L_37881, %eax
    orl $6, %eax
    mov %eax, -24(%esp)  # arg pair?
    movl -20(%esp), %edi   # load new closure to %edi
    add $-12, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $12, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    movl %eax, -12(%esp)
# emit-expr (vector-ref f6267 0)
# emit-expr f6267
# emit-variable-ref
# env=((f6267 . 0))
# var=f6267
    movl 0(%esp), %eax  # stack load f6267
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_37883
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_37883:
    movl %eax, -16(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_37884"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_37884:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_37886
    cmp  $0,%eax
    jge _L_37885
_L_37886:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_37885:
    movl -16(%esp), %esi
    movl -1(%eax,%esi), %eax
    movl %eax, 4(%ebp)
    movl -12(%esp), %eax
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    or   $1, %al
    add  $8, %ebp
# cons end
    movl -4(%esp), %ebx
    movl -8(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fxremainder") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fxquotient") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fx*") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fx-") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fx+") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fx>=") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fx>") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fx<=") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fx<") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fx=") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "eof-object") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "eof-object?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f6267 0))) (closure () (f6267) (let () (vector-ref f6267 0))))
# emit-begin
#   expr=(begin (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fxremainder") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fxquotient") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fx*") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fx-") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fx+") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fx>=") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fx>") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fx<=") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fx<") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fx=") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "eof-object") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "eof-object?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f6267 0))) (closure () (f6267) (let () (vector-ref f6267 0))))
#   env=((f6267 . 0))
# emit-expr (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fxremainder") (vector-ref f6267 0)))
# emit-expr f6267
# emit-variable-ref
# env=((f6267 . 0))
# var=f6267
    movl 0(%esp), %eax  # stack load f6267
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_37887
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_37887:
    movl %eax, -4(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_37888"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_37888:
# check bounds on vector index
    movl -4(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_37890
    cmp  $0,%eax
    jge _L_37889
_L_37890:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_37889:
    movl %eax, -8(%esp)
# emit-expr (cons ((primitive-ref string->symbol) "fxremainder") (vector-ref f6267 0))
# cons arg1=((primitive-ref string->symbol) "fxremainder") arg2=(vector-ref f6267 0)
# emit-expr ((primitive-ref string->symbol) "fxremainder")
# funcall
#    si   =-12
#    env  = ((f6267 . 0))
#    expr = (funcall (primitive-ref string->symbol) "fxremainder")
# emit-expr (primitive-ref string->symbol)
    .extern mrc_string$m$gsymbol
    movl mrc_string$m$gsymbol,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_37891"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_37891":
   movl %eax,  -20(%esp)  # stash funcall-oper in closure slot
# emit-expr "fxremainder"
# string literal
    jmp _L_37893
    .align 8,0x90
_L_37892 :
    .int 44
    .ascii "fxremainder"
_L_37893:
    movl $_L_37892, %eax
    orl $6, %eax
    mov %eax, -24(%esp)  # arg fxremainder
    movl -20(%esp), %edi   # load new closure to %edi
    add $-12, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $12, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    movl %eax, -12(%esp)
# emit-expr (vector-ref f6267 0)
# emit-expr f6267
# emit-variable-ref
# env=((f6267 . 0))
# var=f6267
    movl 0(%esp), %eax  # stack load f6267
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_37894
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_37894:
    movl %eax, -16(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_37895"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_37895:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_37897
    cmp  $0,%eax
    jge _L_37896
_L_37897:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_37896:
    movl -16(%esp), %esi
    movl -1(%eax,%esi), %eax
    movl %eax, 4(%ebp)
    movl -12(%esp), %eax
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    or   $1, %al
    add  $8, %ebp
# cons end
    movl -4(%esp), %ebx
    movl -8(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fxquotient") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fx*") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fx-") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fx+") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fx>=") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fx>") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fx<=") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fx<") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fx=") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "eof-object") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "eof-object?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f6267 0))) (closure () (f6267) (let () (vector-ref f6267 0))))
# emit-begin
#   expr=(begin (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fxquotient") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fx*") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fx-") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fx+") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fx>=") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fx>") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fx<=") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fx<") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fx=") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "eof-object") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "eof-object?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f6267 0))) (closure () (f6267) (let () (vector-ref f6267 0))))
#   env=((f6267 . 0))
# emit-expr (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fxquotient") (vector-ref f6267 0)))
# emit-expr f6267
# emit-variable-ref
# env=((f6267 . 0))
# var=f6267
    movl 0(%esp), %eax  # stack load f6267
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_37898
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_37898:
    movl %eax, -4(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_37899"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_37899:
# check bounds on vector index
    movl -4(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_37901
    cmp  $0,%eax
    jge _L_37900
_L_37901:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_37900:
    movl %eax, -8(%esp)
# emit-expr (cons ((primitive-ref string->symbol) "fxquotient") (vector-ref f6267 0))
# cons arg1=((primitive-ref string->symbol) "fxquotient") arg2=(vector-ref f6267 0)
# emit-expr ((primitive-ref string->symbol) "fxquotient")
# funcall
#    si   =-12
#    env  = ((f6267 . 0))
#    expr = (funcall (primitive-ref string->symbol) "fxquotient")
# emit-expr (primitive-ref string->symbol)
    .extern mrc_string$m$gsymbol
    movl mrc_string$m$gsymbol,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_37902"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_37902":
   movl %eax,  -20(%esp)  # stash funcall-oper in closure slot
# emit-expr "fxquotient"
# string literal
    jmp _L_37904
    .align 8,0x90
_L_37903 :
    .int 40
    .ascii "fxquotient"
_L_37904:
    movl $_L_37903, %eax
    orl $6, %eax
    mov %eax, -24(%esp)  # arg fxquotient
    movl -20(%esp), %edi   # load new closure to %edi
    add $-12, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $12, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    movl %eax, -12(%esp)
# emit-expr (vector-ref f6267 0)
# emit-expr f6267
# emit-variable-ref
# env=((f6267 . 0))
# var=f6267
    movl 0(%esp), %eax  # stack load f6267
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_37905
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_37905:
    movl %eax, -16(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_37906"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_37906:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_37908
    cmp  $0,%eax
    jge _L_37907
_L_37908:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_37907:
    movl -16(%esp), %esi
    movl -1(%eax,%esi), %eax
    movl %eax, 4(%ebp)
    movl -12(%esp), %eax
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    or   $1, %al
    add  $8, %ebp
# cons end
    movl -4(%esp), %ebx
    movl -8(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fx*") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fx-") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fx+") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fx>=") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fx>") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fx<=") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fx<") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fx=") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "eof-object") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "eof-object?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f6267 0))) (closure () (f6267) (let () (vector-ref f6267 0))))
# emit-begin
#   expr=(begin (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fx*") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fx-") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fx+") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fx>=") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fx>") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fx<=") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fx<") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fx=") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "eof-object") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "eof-object?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f6267 0))) (closure () (f6267) (let () (vector-ref f6267 0))))
#   env=((f6267 . 0))
# emit-expr (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fx*") (vector-ref f6267 0)))
# emit-expr f6267
# emit-variable-ref
# env=((f6267 . 0))
# var=f6267
    movl 0(%esp), %eax  # stack load f6267
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_37909
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_37909:
    movl %eax, -4(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_37910"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_37910:
# check bounds on vector index
    movl -4(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_37912
    cmp  $0,%eax
    jge _L_37911
_L_37912:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_37911:
    movl %eax, -8(%esp)
# emit-expr (cons ((primitive-ref string->symbol) "fx*") (vector-ref f6267 0))
# cons arg1=((primitive-ref string->symbol) "fx*") arg2=(vector-ref f6267 0)
# emit-expr ((primitive-ref string->symbol) "fx*")
# funcall
#    si   =-12
#    env  = ((f6267 . 0))
#    expr = (funcall (primitive-ref string->symbol) "fx*")
# emit-expr (primitive-ref string->symbol)
    .extern mrc_string$m$gsymbol
    movl mrc_string$m$gsymbol,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_37913"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_37913":
   movl %eax,  -20(%esp)  # stash funcall-oper in closure slot
# emit-expr "fx*"
# string literal
    jmp _L_37915
    .align 8,0x90
_L_37914 :
    .int 12
    .ascii "fx*"
_L_37915:
    movl $_L_37914, %eax
    orl $6, %eax
    mov %eax, -24(%esp)  # arg fx*
    movl -20(%esp), %edi   # load new closure to %edi
    add $-12, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $12, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    movl %eax, -12(%esp)
# emit-expr (vector-ref f6267 0)
# emit-expr f6267
# emit-variable-ref
# env=((f6267 . 0))
# var=f6267
    movl 0(%esp), %eax  # stack load f6267
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_37916
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_37916:
    movl %eax, -16(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_37917"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_37917:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_37919
    cmp  $0,%eax
    jge _L_37918
_L_37919:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_37918:
    movl -16(%esp), %esi
    movl -1(%eax,%esi), %eax
    movl %eax, 4(%ebp)
    movl -12(%esp), %eax
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    or   $1, %al
    add  $8, %ebp
# cons end
    movl -4(%esp), %ebx
    movl -8(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fx-") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fx+") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fx>=") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fx>") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fx<=") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fx<") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fx=") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "eof-object") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "eof-object?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f6267 0))) (closure () (f6267) (let () (vector-ref f6267 0))))
# emit-begin
#   expr=(begin (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fx-") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fx+") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fx>=") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fx>") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fx<=") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fx<") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fx=") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "eof-object") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "eof-object?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f6267 0))) (closure () (f6267) (let () (vector-ref f6267 0))))
#   env=((f6267 . 0))
# emit-expr (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fx-") (vector-ref f6267 0)))
# emit-expr f6267
# emit-variable-ref
# env=((f6267 . 0))
# var=f6267
    movl 0(%esp), %eax  # stack load f6267
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_37920
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_37920:
    movl %eax, -4(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_37921"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_37921:
# check bounds on vector index
    movl -4(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_37923
    cmp  $0,%eax
    jge _L_37922
_L_37923:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_37922:
    movl %eax, -8(%esp)
# emit-expr (cons ((primitive-ref string->symbol) "fx-") (vector-ref f6267 0))
# cons arg1=((primitive-ref string->symbol) "fx-") arg2=(vector-ref f6267 0)
# emit-expr ((primitive-ref string->symbol) "fx-")
# funcall
#    si   =-12
#    env  = ((f6267 . 0))
#    expr = (funcall (primitive-ref string->symbol) "fx-")
# emit-expr (primitive-ref string->symbol)
    .extern mrc_string$m$gsymbol
    movl mrc_string$m$gsymbol,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_37924"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_37924":
   movl %eax,  -20(%esp)  # stash funcall-oper in closure slot
# emit-expr "fx-"
# string literal
    jmp _L_37926
    .align 8,0x90
_L_37925 :
    .int 12
    .ascii "fx-"
_L_37926:
    movl $_L_37925, %eax
    orl $6, %eax
    mov %eax, -24(%esp)  # arg fx-
    movl -20(%esp), %edi   # load new closure to %edi
    add $-12, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $12, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    movl %eax, -12(%esp)
# emit-expr (vector-ref f6267 0)
# emit-expr f6267
# emit-variable-ref
# env=((f6267 . 0))
# var=f6267
    movl 0(%esp), %eax  # stack load f6267
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_37927
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_37927:
    movl %eax, -16(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_37928"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_37928:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_37930
    cmp  $0,%eax
    jge _L_37929
_L_37930:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_37929:
    movl -16(%esp), %esi
    movl -1(%eax,%esi), %eax
    movl %eax, 4(%ebp)
    movl -12(%esp), %eax
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    or   $1, %al
    add  $8, %ebp
# cons end
    movl -4(%esp), %ebx
    movl -8(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fx+") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fx>=") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fx>") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fx<=") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fx<") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fx=") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "eof-object") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "eof-object?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f6267 0))) (closure () (f6267) (let () (vector-ref f6267 0))))
# emit-begin
#   expr=(begin (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fx+") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fx>=") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fx>") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fx<=") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fx<") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fx=") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "eof-object") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "eof-object?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f6267 0))) (closure () (f6267) (let () (vector-ref f6267 0))))
#   env=((f6267 . 0))
# emit-expr (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fx+") (vector-ref f6267 0)))
# emit-expr f6267
# emit-variable-ref
# env=((f6267 . 0))
# var=f6267
    movl 0(%esp), %eax  # stack load f6267
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_37931
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_37931:
    movl %eax, -4(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_37932"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_37932:
# check bounds on vector index
    movl -4(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_37934
    cmp  $0,%eax
    jge _L_37933
_L_37934:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_37933:
    movl %eax, -8(%esp)
# emit-expr (cons ((primitive-ref string->symbol) "fx+") (vector-ref f6267 0))
# cons arg1=((primitive-ref string->symbol) "fx+") arg2=(vector-ref f6267 0)
# emit-expr ((primitive-ref string->symbol) "fx+")
# funcall
#    si   =-12
#    env  = ((f6267 . 0))
#    expr = (funcall (primitive-ref string->symbol) "fx+")
# emit-expr (primitive-ref string->symbol)
    .extern mrc_string$m$gsymbol
    movl mrc_string$m$gsymbol,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_37935"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_37935":
   movl %eax,  -20(%esp)  # stash funcall-oper in closure slot
# emit-expr "fx+"
# string literal
    jmp _L_37937
    .align 8,0x90
_L_37936 :
    .int 12
    .ascii "fx+"
_L_37937:
    movl $_L_37936, %eax
    orl $6, %eax
    mov %eax, -24(%esp)  # arg fx+
    movl -20(%esp), %edi   # load new closure to %edi
    add $-12, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $12, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    movl %eax, -12(%esp)
# emit-expr (vector-ref f6267 0)
# emit-expr f6267
# emit-variable-ref
# env=((f6267 . 0))
# var=f6267
    movl 0(%esp), %eax  # stack load f6267
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_37938
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_37938:
    movl %eax, -16(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_37939"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_37939:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_37941
    cmp  $0,%eax
    jge _L_37940
_L_37941:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_37940:
    movl -16(%esp), %esi
    movl -1(%eax,%esi), %eax
    movl %eax, 4(%ebp)
    movl -12(%esp), %eax
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    or   $1, %al
    add  $8, %ebp
# cons end
    movl -4(%esp), %ebx
    movl -8(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fx>=") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fx>") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fx<=") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fx<") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fx=") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "eof-object") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "eof-object?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f6267 0))) (closure () (f6267) (let () (vector-ref f6267 0))))
# emit-begin
#   expr=(begin (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fx>=") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fx>") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fx<=") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fx<") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fx=") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "eof-object") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "eof-object?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f6267 0))) (closure () (f6267) (let () (vector-ref f6267 0))))
#   env=((f6267 . 0))
# emit-expr (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fx>=") (vector-ref f6267 0)))
# emit-expr f6267
# emit-variable-ref
# env=((f6267 . 0))
# var=f6267
    movl 0(%esp), %eax  # stack load f6267
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_37942
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_37942:
    movl %eax, -4(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_37943"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_37943:
# check bounds on vector index
    movl -4(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_37945
    cmp  $0,%eax
    jge _L_37944
_L_37945:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_37944:
    movl %eax, -8(%esp)
# emit-expr (cons ((primitive-ref string->symbol) "fx>=") (vector-ref f6267 0))
# cons arg1=((primitive-ref string->symbol) "fx>=") arg2=(vector-ref f6267 0)
# emit-expr ((primitive-ref string->symbol) "fx>=")
# funcall
#    si   =-12
#    env  = ((f6267 . 0))
#    expr = (funcall (primitive-ref string->symbol) "fx>=")
# emit-expr (primitive-ref string->symbol)
    .extern mrc_string$m$gsymbol
    movl mrc_string$m$gsymbol,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_37946"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_37946":
   movl %eax,  -20(%esp)  # stash funcall-oper in closure slot
# emit-expr "fx>="
# string literal
    jmp _L_37948
    .align 8,0x90
_L_37947 :
    .int 16
    .ascii "fx>="
_L_37948:
    movl $_L_37947, %eax
    orl $6, %eax
    mov %eax, -24(%esp)  # arg fx>=
    movl -20(%esp), %edi   # load new closure to %edi
    add $-12, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $12, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    movl %eax, -12(%esp)
# emit-expr (vector-ref f6267 0)
# emit-expr f6267
# emit-variable-ref
# env=((f6267 . 0))
# var=f6267
    movl 0(%esp), %eax  # stack load f6267
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_37949
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_37949:
    movl %eax, -16(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_37950"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_37950:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_37952
    cmp  $0,%eax
    jge _L_37951
_L_37952:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_37951:
    movl -16(%esp), %esi
    movl -1(%eax,%esi), %eax
    movl %eax, 4(%ebp)
    movl -12(%esp), %eax
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    or   $1, %al
    add  $8, %ebp
# cons end
    movl -4(%esp), %ebx
    movl -8(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fx>") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fx<=") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fx<") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fx=") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "eof-object") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "eof-object?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f6267 0))) (closure () (f6267) (let () (vector-ref f6267 0))))
# emit-begin
#   expr=(begin (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fx>") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fx<=") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fx<") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fx=") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "eof-object") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "eof-object?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f6267 0))) (closure () (f6267) (let () (vector-ref f6267 0))))
#   env=((f6267 . 0))
# emit-expr (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fx>") (vector-ref f6267 0)))
# emit-expr f6267
# emit-variable-ref
# env=((f6267 . 0))
# var=f6267
    movl 0(%esp), %eax  # stack load f6267
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_37953
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_37953:
    movl %eax, -4(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_37954"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_37954:
# check bounds on vector index
    movl -4(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_37956
    cmp  $0,%eax
    jge _L_37955
_L_37956:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_37955:
    movl %eax, -8(%esp)
# emit-expr (cons ((primitive-ref string->symbol) "fx>") (vector-ref f6267 0))
# cons arg1=((primitive-ref string->symbol) "fx>") arg2=(vector-ref f6267 0)
# emit-expr ((primitive-ref string->symbol) "fx>")
# funcall
#    si   =-12
#    env  = ((f6267 . 0))
#    expr = (funcall (primitive-ref string->symbol) "fx>")
# emit-expr (primitive-ref string->symbol)
    .extern mrc_string$m$gsymbol
    movl mrc_string$m$gsymbol,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_37957"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_37957":
   movl %eax,  -20(%esp)  # stash funcall-oper in closure slot
# emit-expr "fx>"
# string literal
    jmp _L_37959
    .align 8,0x90
_L_37958 :
    .int 12
    .ascii "fx>"
_L_37959:
    movl $_L_37958, %eax
    orl $6, %eax
    mov %eax, -24(%esp)  # arg fx>
    movl -20(%esp), %edi   # load new closure to %edi
    add $-12, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $12, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    movl %eax, -12(%esp)
# emit-expr (vector-ref f6267 0)
# emit-expr f6267
# emit-variable-ref
# env=((f6267 . 0))
# var=f6267
    movl 0(%esp), %eax  # stack load f6267
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_37960
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_37960:
    movl %eax, -16(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_37961"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_37961:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_37963
    cmp  $0,%eax
    jge _L_37962
_L_37963:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_37962:
    movl -16(%esp), %esi
    movl -1(%eax,%esi), %eax
    movl %eax, 4(%ebp)
    movl -12(%esp), %eax
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    or   $1, %al
    add  $8, %ebp
# cons end
    movl -4(%esp), %ebx
    movl -8(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fx<=") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fx<") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fx=") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "eof-object") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "eof-object?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f6267 0))) (closure () (f6267) (let () (vector-ref f6267 0))))
# emit-begin
#   expr=(begin (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fx<=") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fx<") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fx=") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "eof-object") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "eof-object?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f6267 0))) (closure () (f6267) (let () (vector-ref f6267 0))))
#   env=((f6267 . 0))
# emit-expr (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fx<=") (vector-ref f6267 0)))
# emit-expr f6267
# emit-variable-ref
# env=((f6267 . 0))
# var=f6267
    movl 0(%esp), %eax  # stack load f6267
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_37964
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_37964:
    movl %eax, -4(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_37965"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_37965:
# check bounds on vector index
    movl -4(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_37967
    cmp  $0,%eax
    jge _L_37966
_L_37967:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_37966:
    movl %eax, -8(%esp)
# emit-expr (cons ((primitive-ref string->symbol) "fx<=") (vector-ref f6267 0))
# cons arg1=((primitive-ref string->symbol) "fx<=") arg2=(vector-ref f6267 0)
# emit-expr ((primitive-ref string->symbol) "fx<=")
# funcall
#    si   =-12
#    env  = ((f6267 . 0))
#    expr = (funcall (primitive-ref string->symbol) "fx<=")
# emit-expr (primitive-ref string->symbol)
    .extern mrc_string$m$gsymbol
    movl mrc_string$m$gsymbol,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_37968"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_37968":
   movl %eax,  -20(%esp)  # stash funcall-oper in closure slot
# emit-expr "fx<="
# string literal
    jmp _L_37970
    .align 8,0x90
_L_37969 :
    .int 16
    .ascii "fx<="
_L_37970:
    movl $_L_37969, %eax
    orl $6, %eax
    mov %eax, -24(%esp)  # arg fx<=
    movl -20(%esp), %edi   # load new closure to %edi
    add $-12, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $12, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    movl %eax, -12(%esp)
# emit-expr (vector-ref f6267 0)
# emit-expr f6267
# emit-variable-ref
# env=((f6267 . 0))
# var=f6267
    movl 0(%esp), %eax  # stack load f6267
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_37971
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_37971:
    movl %eax, -16(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_37972"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_37972:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_37974
    cmp  $0,%eax
    jge _L_37973
_L_37974:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_37973:
    movl -16(%esp), %esi
    movl -1(%eax,%esi), %eax
    movl %eax, 4(%ebp)
    movl -12(%esp), %eax
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    or   $1, %al
    add  $8, %ebp
# cons end
    movl -4(%esp), %ebx
    movl -8(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fx<") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fx=") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "eof-object") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "eof-object?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f6267 0))) (closure () (f6267) (let () (vector-ref f6267 0))))
# emit-begin
#   expr=(begin (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fx<") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fx=") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "eof-object") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "eof-object?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f6267 0))) (closure () (f6267) (let () (vector-ref f6267 0))))
#   env=((f6267 . 0))
# emit-expr (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fx<") (vector-ref f6267 0)))
# emit-expr f6267
# emit-variable-ref
# env=((f6267 . 0))
# var=f6267
    movl 0(%esp), %eax  # stack load f6267
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_37975
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_37975:
    movl %eax, -4(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_37976"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_37976:
# check bounds on vector index
    movl -4(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_37978
    cmp  $0,%eax
    jge _L_37977
_L_37978:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_37977:
    movl %eax, -8(%esp)
# emit-expr (cons ((primitive-ref string->symbol) "fx<") (vector-ref f6267 0))
# cons arg1=((primitive-ref string->symbol) "fx<") arg2=(vector-ref f6267 0)
# emit-expr ((primitive-ref string->symbol) "fx<")
# funcall
#    si   =-12
#    env  = ((f6267 . 0))
#    expr = (funcall (primitive-ref string->symbol) "fx<")
# emit-expr (primitive-ref string->symbol)
    .extern mrc_string$m$gsymbol
    movl mrc_string$m$gsymbol,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_37979"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_37979":
   movl %eax,  -20(%esp)  # stash funcall-oper in closure slot
# emit-expr "fx<"
# string literal
    jmp _L_37981
    .align 8,0x90
_L_37980 :
    .int 12
    .ascii "fx<"
_L_37981:
    movl $_L_37980, %eax
    orl $6, %eax
    mov %eax, -24(%esp)  # arg fx<
    movl -20(%esp), %edi   # load new closure to %edi
    add $-12, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $12, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    movl %eax, -12(%esp)
# emit-expr (vector-ref f6267 0)
# emit-expr f6267
# emit-variable-ref
# env=((f6267 . 0))
# var=f6267
    movl 0(%esp), %eax  # stack load f6267
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_37982
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_37982:
    movl %eax, -16(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_37983"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_37983:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_37985
    cmp  $0,%eax
    jge _L_37984
_L_37985:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_37984:
    movl -16(%esp), %esi
    movl -1(%eax,%esi), %eax
    movl %eax, 4(%ebp)
    movl -12(%esp), %eax
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    or   $1, %al
    add  $8, %ebp
# cons end
    movl -4(%esp), %ebx
    movl -8(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fx=") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "eof-object") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "eof-object?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f6267 0))) (closure () (f6267) (let () (vector-ref f6267 0))))
# emit-begin
#   expr=(begin (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fx=") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "eof-object") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "eof-object?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f6267 0))) (closure () (f6267) (let () (vector-ref f6267 0))))
#   env=((f6267 . 0))
# emit-expr (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fx=") (vector-ref f6267 0)))
# emit-expr f6267
# emit-variable-ref
# env=((f6267 . 0))
# var=f6267
    movl 0(%esp), %eax  # stack load f6267
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_37986
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_37986:
    movl %eax, -4(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_37987"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_37987:
# check bounds on vector index
    movl -4(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_37989
    cmp  $0,%eax
    jge _L_37988
_L_37989:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_37988:
    movl %eax, -8(%esp)
# emit-expr (cons ((primitive-ref string->symbol) "fx=") (vector-ref f6267 0))
# cons arg1=((primitive-ref string->symbol) "fx=") arg2=(vector-ref f6267 0)
# emit-expr ((primitive-ref string->symbol) "fx=")
# funcall
#    si   =-12
#    env  = ((f6267 . 0))
#    expr = (funcall (primitive-ref string->symbol) "fx=")
# emit-expr (primitive-ref string->symbol)
    .extern mrc_string$m$gsymbol
    movl mrc_string$m$gsymbol,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_37990"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_37990":
   movl %eax,  -20(%esp)  # stash funcall-oper in closure slot
# emit-expr "fx="
# string literal
    jmp _L_37992
    .align 8,0x90
_L_37991 :
    .int 12
    .ascii "fx="
_L_37992:
    movl $_L_37991, %eax
    orl $6, %eax
    mov %eax, -24(%esp)  # arg fx=
    movl -20(%esp), %edi   # load new closure to %edi
    add $-12, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $12, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    movl %eax, -12(%esp)
# emit-expr (vector-ref f6267 0)
# emit-expr f6267
# emit-variable-ref
# env=((f6267 . 0))
# var=f6267
    movl 0(%esp), %eax  # stack load f6267
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_37993
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_37993:
    movl %eax, -16(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_37994"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_37994:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_37996
    cmp  $0,%eax
    jge _L_37995
_L_37996:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_37995:
    movl -16(%esp), %esi
    movl -1(%eax,%esi), %eax
    movl %eax, 4(%ebp)
    movl -12(%esp), %eax
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    or   $1, %al
    add  $8, %ebp
# cons end
    movl -4(%esp), %ebx
    movl -8(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "eof-object") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "eof-object?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f6267 0))) (closure () (f6267) (let () (vector-ref f6267 0))))
# emit-begin
#   expr=(begin (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "eof-object") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "eof-object?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f6267 0))) (closure () (f6267) (let () (vector-ref f6267 0))))
#   env=((f6267 . 0))
# emit-expr (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f6267 0)))
# emit-expr f6267
# emit-variable-ref
# env=((f6267 . 0))
# var=f6267
    movl 0(%esp), %eax  # stack load f6267
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_37997
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_37997:
    movl %eax, -4(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_37998"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_37998:
# check bounds on vector index
    movl -4(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_38000
    cmp  $0,%eax
    jge _L_37999
_L_38000:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_37999:
    movl %eax, -8(%esp)
# emit-expr (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f6267 0))
# cons arg1=((primitive-ref string->symbol) "fxzero?") arg2=(vector-ref f6267 0)
# emit-expr ((primitive-ref string->symbol) "fxzero?")
# funcall
#    si   =-12
#    env  = ((f6267 . 0))
#    expr = (funcall (primitive-ref string->symbol) "fxzero?")
# emit-expr (primitive-ref string->symbol)
    .extern mrc_string$m$gsymbol
    movl mrc_string$m$gsymbol,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_38001"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_38001":
   movl %eax,  -20(%esp)  # stash funcall-oper in closure slot
# emit-expr "fxzero?"
# string literal
    jmp _L_38003
    .align 8,0x90
_L_38002 :
    .int 28
    .ascii "fxzero?"
_L_38003:
    movl $_L_38002, %eax
    orl $6, %eax
    mov %eax, -24(%esp)  # arg fxzero?
    movl -20(%esp), %edi   # load new closure to %edi
    add $-12, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $12, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    movl %eax, -12(%esp)
# emit-expr (vector-ref f6267 0)
# emit-expr f6267
# emit-variable-ref
# env=((f6267 . 0))
# var=f6267
    movl 0(%esp), %eax  # stack load f6267
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_38004
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_38004:
    movl %eax, -16(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_38005"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_38005:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_38007
    cmp  $0,%eax
    jge _L_38006
_L_38007:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_38006:
    movl -16(%esp), %esi
    movl -1(%eax,%esi), %eax
    movl %eax, 4(%ebp)
    movl -12(%esp), %eax
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    or   $1, %al
    add  $8, %ebp
# cons end
    movl -4(%esp), %ebx
    movl -8(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "eof-object") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "eof-object?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f6267 0))) (closure () (f6267) (let () (vector-ref f6267 0))))
# emit-begin
#   expr=(begin (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "eof-object") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "eof-object?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f6267 0))) (closure () (f6267) (let () (vector-ref f6267 0))))
#   env=((f6267 . 0))
# emit-expr (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f6267 0)))
# emit-expr f6267
# emit-variable-ref
# env=((f6267 . 0))
# var=f6267
    movl 0(%esp), %eax  # stack load f6267
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_38008
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_38008:
    movl %eax, -4(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_38009"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_38009:
# check bounds on vector index
    movl -4(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_38011
    cmp  $0,%eax
    jge _L_38010
_L_38011:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_38010:
    movl %eax, -8(%esp)
# emit-expr (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f6267 0))
# cons arg1=((primitive-ref string->symbol) "fxsub1") arg2=(vector-ref f6267 0)
# emit-expr ((primitive-ref string->symbol) "fxsub1")
# funcall
#    si   =-12
#    env  = ((f6267 . 0))
#    expr = (funcall (primitive-ref string->symbol) "fxsub1")
# emit-expr (primitive-ref string->symbol)
    .extern mrc_string$m$gsymbol
    movl mrc_string$m$gsymbol,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_38012"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_38012":
   movl %eax,  -20(%esp)  # stash funcall-oper in closure slot
# emit-expr "fxsub1"
# string literal
    jmp _L_38014
    .align 8,0x90
_L_38013 :
    .int 24
    .ascii "fxsub1"
_L_38014:
    movl $_L_38013, %eax
    orl $6, %eax
    mov %eax, -24(%esp)  # arg fxsub1
    movl -20(%esp), %edi   # load new closure to %edi
    add $-12, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $12, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    movl %eax, -12(%esp)
# emit-expr (vector-ref f6267 0)
# emit-expr f6267
# emit-variable-ref
# env=((f6267 . 0))
# var=f6267
    movl 0(%esp), %eax  # stack load f6267
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_38015
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_38015:
    movl %eax, -16(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_38016"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_38016:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_38018
    cmp  $0,%eax
    jge _L_38017
_L_38018:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_38017:
    movl -16(%esp), %esi
    movl -1(%eax,%esi), %eax
    movl %eax, 4(%ebp)
    movl -12(%esp), %eax
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    or   $1, %al
    add  $8, %ebp
# cons end
    movl -4(%esp), %ebx
    movl -8(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "eof-object") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "eof-object?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f6267 0))) (closure () (f6267) (let () (vector-ref f6267 0))))
# emit-begin
#   expr=(begin (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "eof-object") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "eof-object?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f6267 0))) (closure () (f6267) (let () (vector-ref f6267 0))))
#   env=((f6267 . 0))
# emit-expr (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f6267 0)))
# emit-expr f6267
# emit-variable-ref
# env=((f6267 . 0))
# var=f6267
    movl 0(%esp), %eax  # stack load f6267
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_38019
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_38019:
    movl %eax, -4(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_38020"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_38020:
# check bounds on vector index
    movl -4(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_38022
    cmp  $0,%eax
    jge _L_38021
_L_38022:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_38021:
    movl %eax, -8(%esp)
# emit-expr (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f6267 0))
# cons arg1=((primitive-ref string->symbol) "fxadd1") arg2=(vector-ref f6267 0)
# emit-expr ((primitive-ref string->symbol) "fxadd1")
# funcall
#    si   =-12
#    env  = ((f6267 . 0))
#    expr = (funcall (primitive-ref string->symbol) "fxadd1")
# emit-expr (primitive-ref string->symbol)
    .extern mrc_string$m$gsymbol
    movl mrc_string$m$gsymbol,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_38023"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_38023":
   movl %eax,  -20(%esp)  # stash funcall-oper in closure slot
# emit-expr "fxadd1"
# string literal
    jmp _L_38025
    .align 8,0x90
_L_38024 :
    .int 24
    .ascii "fxadd1"
_L_38025:
    movl $_L_38024, %eax
    orl $6, %eax
    mov %eax, -24(%esp)  # arg fxadd1
    movl -20(%esp), %edi   # load new closure to %edi
    add $-12, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $12, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    movl %eax, -12(%esp)
# emit-expr (vector-ref f6267 0)
# emit-expr f6267
# emit-variable-ref
# env=((f6267 . 0))
# var=f6267
    movl 0(%esp), %eax  # stack load f6267
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_38026
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_38026:
    movl %eax, -16(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_38027"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_38027:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_38029
    cmp  $0,%eax
    jge _L_38028
_L_38029:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_38028:
    movl -16(%esp), %esi
    movl -1(%eax,%esi), %eax
    movl %eax, 4(%ebp)
    movl -12(%esp), %eax
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    or   $1, %al
    add  $8, %ebp
# cons end
    movl -4(%esp), %ebx
    movl -8(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "eof-object") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "eof-object?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f6267 0))) (closure () (f6267) (let () (vector-ref f6267 0))))
# emit-begin
#   expr=(begin (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "eof-object") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "eof-object?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f6267 0))) (closure () (f6267) (let () (vector-ref f6267 0))))
#   env=((f6267 . 0))
# emit-expr (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f6267 0)))
# emit-expr f6267
# emit-variable-ref
# env=((f6267 . 0))
# var=f6267
    movl 0(%esp), %eax  # stack load f6267
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_38030
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_38030:
    movl %eax, -4(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_38031"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_38031:
# check bounds on vector index
    movl -4(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_38033
    cmp  $0,%eax
    jge _L_38032
_L_38033:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_38032:
    movl %eax, -8(%esp)
# emit-expr (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f6267 0))
# cons arg1=((primitive-ref string->symbol) "fxlogor") arg2=(vector-ref f6267 0)
# emit-expr ((primitive-ref string->symbol) "fxlogor")
# funcall
#    si   =-12
#    env  = ((f6267 . 0))
#    expr = (funcall (primitive-ref string->symbol) "fxlogor")
# emit-expr (primitive-ref string->symbol)
    .extern mrc_string$m$gsymbol
    movl mrc_string$m$gsymbol,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_38034"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_38034":
   movl %eax,  -20(%esp)  # stash funcall-oper in closure slot
# emit-expr "fxlogor"
# string literal
    jmp _L_38036
    .align 8,0x90
_L_38035 :
    .int 28
    .ascii "fxlogor"
_L_38036:
    movl $_L_38035, %eax
    orl $6, %eax
    mov %eax, -24(%esp)  # arg fxlogor
    movl -20(%esp), %edi   # load new closure to %edi
    add $-12, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $12, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    movl %eax, -12(%esp)
# emit-expr (vector-ref f6267 0)
# emit-expr f6267
# emit-variable-ref
# env=((f6267 . 0))
# var=f6267
    movl 0(%esp), %eax  # stack load f6267
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_38037
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_38037:
    movl %eax, -16(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_38038"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_38038:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_38040
    cmp  $0,%eax
    jge _L_38039
_L_38040:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_38039:
    movl -16(%esp), %esi
    movl -1(%eax,%esi), %eax
    movl %eax, 4(%ebp)
    movl -12(%esp), %eax
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    or   $1, %al
    add  $8, %ebp
# cons end
    movl -4(%esp), %ebx
    movl -8(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "eof-object") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "eof-object?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f6267 0))) (closure () (f6267) (let () (vector-ref f6267 0))))
# emit-begin
#   expr=(begin (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "eof-object") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "eof-object?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f6267 0))) (closure () (f6267) (let () (vector-ref f6267 0))))
#   env=((f6267 . 0))
# emit-expr (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f6267 0)))
# emit-expr f6267
# emit-variable-ref
# env=((f6267 . 0))
# var=f6267
    movl 0(%esp), %eax  # stack load f6267
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_38041
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_38041:
    movl %eax, -4(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_38042"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_38042:
# check bounds on vector index
    movl -4(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_38044
    cmp  $0,%eax
    jge _L_38043
_L_38044:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_38043:
    movl %eax, -8(%esp)
# emit-expr (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f6267 0))
# cons arg1=((primitive-ref string->symbol) "fxlogand") arg2=(vector-ref f6267 0)
# emit-expr ((primitive-ref string->symbol) "fxlogand")
# funcall
#    si   =-12
#    env  = ((f6267 . 0))
#    expr = (funcall (primitive-ref string->symbol) "fxlogand")
# emit-expr (primitive-ref string->symbol)
    .extern mrc_string$m$gsymbol
    movl mrc_string$m$gsymbol,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_38045"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_38045":
   movl %eax,  -20(%esp)  # stash funcall-oper in closure slot
# emit-expr "fxlogand"
# string literal
    jmp _L_38047
    .align 8,0x90
_L_38046 :
    .int 32
    .ascii "fxlogand"
_L_38047:
    movl $_L_38046, %eax
    orl $6, %eax
    mov %eax, -24(%esp)  # arg fxlogand
    movl -20(%esp), %edi   # load new closure to %edi
    add $-12, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $12, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    movl %eax, -12(%esp)
# emit-expr (vector-ref f6267 0)
# emit-expr f6267
# emit-variable-ref
# env=((f6267 . 0))
# var=f6267
    movl 0(%esp), %eax  # stack load f6267
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_38048
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_38048:
    movl %eax, -16(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_38049"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_38049:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_38051
    cmp  $0,%eax
    jge _L_38050
_L_38051:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_38050:
    movl -16(%esp), %esi
    movl -1(%eax,%esi), %eax
    movl %eax, 4(%ebp)
    movl -12(%esp), %eax
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    or   $1, %al
    add  $8, %ebp
# cons end
    movl -4(%esp), %ebx
    movl -8(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "eof-object") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "eof-object?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f6267 0))) (closure () (f6267) (let () (vector-ref f6267 0))))
# emit-begin
#   expr=(begin (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "eof-object") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "eof-object?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f6267 0))) (closure () (f6267) (let () (vector-ref f6267 0))))
#   env=((f6267 . 0))
# emit-expr (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f6267 0)))
# emit-expr f6267
# emit-variable-ref
# env=((f6267 . 0))
# var=f6267
    movl 0(%esp), %eax  # stack load f6267
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_38052
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_38052:
    movl %eax, -4(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_38053"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_38053:
# check bounds on vector index
    movl -4(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_38055
    cmp  $0,%eax
    jge _L_38054
_L_38055:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_38054:
    movl %eax, -8(%esp)
# emit-expr (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f6267 0))
# cons arg1=((primitive-ref string->symbol) "fxlognot") arg2=(vector-ref f6267 0)
# emit-expr ((primitive-ref string->symbol) "fxlognot")
# funcall
#    si   =-12
#    env  = ((f6267 . 0))
#    expr = (funcall (primitive-ref string->symbol) "fxlognot")
# emit-expr (primitive-ref string->symbol)
    .extern mrc_string$m$gsymbol
    movl mrc_string$m$gsymbol,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_38056"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_38056":
   movl %eax,  -20(%esp)  # stash funcall-oper in closure slot
# emit-expr "fxlognot"
# string literal
    jmp _L_38058
    .align 8,0x90
_L_38057 :
    .int 32
    .ascii "fxlognot"
_L_38058:
    movl $_L_38057, %eax
    orl $6, %eax
    mov %eax, -24(%esp)  # arg fxlognot
    movl -20(%esp), %edi   # load new closure to %edi
    add $-12, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $12, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    movl %eax, -12(%esp)
# emit-expr (vector-ref f6267 0)
# emit-expr f6267
# emit-variable-ref
# env=((f6267 . 0))
# var=f6267
    movl 0(%esp), %eax  # stack load f6267
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_38059
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_38059:
    movl %eax, -16(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_38060"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_38060:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_38062
    cmp  $0,%eax
    jge _L_38061
_L_38062:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_38061:
    movl -16(%esp), %esi
    movl -1(%eax,%esi), %eax
    movl %eax, 4(%ebp)
    movl -12(%esp), %eax
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    or   $1, %al
    add  $8, %ebp
# cons end
    movl -4(%esp), %ebx
    movl -8(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "eof-object") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "eof-object?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f6267 0))) (closure () (f6267) (let () (vector-ref f6267 0))))
# emit-begin
#   expr=(begin (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "eof-object") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "eof-object?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f6267 0))) (closure () (f6267) (let () (vector-ref f6267 0))))
#   env=((f6267 . 0))
# emit-expr (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f6267 0)))
# emit-expr f6267
# emit-variable-ref
# env=((f6267 . 0))
# var=f6267
    movl 0(%esp), %eax  # stack load f6267
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_38063
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_38063:
    movl %eax, -4(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_38064"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_38064:
# check bounds on vector index
    movl -4(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_38066
    cmp  $0,%eax
    jge _L_38065
_L_38066:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_38065:
    movl %eax, -8(%esp)
# emit-expr (cons ((primitive-ref string->symbol) "char=?") (vector-ref f6267 0))
# cons arg1=((primitive-ref string->symbol) "char=?") arg2=(vector-ref f6267 0)
# emit-expr ((primitive-ref string->symbol) "char=?")
# funcall
#    si   =-12
#    env  = ((f6267 . 0))
#    expr = (funcall (primitive-ref string->symbol) "char=?")
# emit-expr (primitive-ref string->symbol)
    .extern mrc_string$m$gsymbol
    movl mrc_string$m$gsymbol,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_38067"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_38067":
   movl %eax,  -20(%esp)  # stash funcall-oper in closure slot
# emit-expr "char=?"
# string literal
    jmp _L_38069
    .align 8,0x90
_L_38068 :
    .int 24
    .ascii "char=?"
_L_38069:
    movl $_L_38068, %eax
    orl $6, %eax
    mov %eax, -24(%esp)  # arg char=?
    movl -20(%esp), %edi   # load new closure to %edi
    add $-12, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $12, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    movl %eax, -12(%esp)
# emit-expr (vector-ref f6267 0)
# emit-expr f6267
# emit-variable-ref
# env=((f6267 . 0))
# var=f6267
    movl 0(%esp), %eax  # stack load f6267
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_38070
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_38070:
    movl %eax, -16(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_38071"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_38071:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_38073
    cmp  $0,%eax
    jge _L_38072
_L_38073:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_38072:
    movl -16(%esp), %esi
    movl -1(%eax,%esi), %eax
    movl %eax, 4(%ebp)
    movl -12(%esp), %eax
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    or   $1, %al
    add  $8, %ebp
# cons end
    movl -4(%esp), %ebx
    movl -8(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "eof-object") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "eof-object?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f6267 0))) (closure () (f6267) (let () (vector-ref f6267 0))))
# emit-begin
#   expr=(begin (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "eof-object") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "eof-object?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f6267 0))) (closure () (f6267) (let () (vector-ref f6267 0))))
#   env=((f6267 . 0))
# emit-expr (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f6267 0)))
# emit-expr f6267
# emit-variable-ref
# env=((f6267 . 0))
# var=f6267
    movl 0(%esp), %eax  # stack load f6267
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_38074
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_38074:
    movl %eax, -4(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_38075"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_38075:
# check bounds on vector index
    movl -4(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_38077
    cmp  $0,%eax
    jge _L_38076
_L_38077:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_38076:
    movl %eax, -8(%esp)
# emit-expr (cons ((primitive-ref string->symbol) "eq?") (vector-ref f6267 0))
# cons arg1=((primitive-ref string->symbol) "eq?") arg2=(vector-ref f6267 0)
# emit-expr ((primitive-ref string->symbol) "eq?")
# funcall
#    si   =-12
#    env  = ((f6267 . 0))
#    expr = (funcall (primitive-ref string->symbol) "eq?")
# emit-expr (primitive-ref string->symbol)
    .extern mrc_string$m$gsymbol
    movl mrc_string$m$gsymbol,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_38078"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_38078":
   movl %eax,  -20(%esp)  # stash funcall-oper in closure slot
# emit-expr "eq?"
# string literal
    jmp _L_38080
    .align 8,0x90
_L_38079 :
    .int 12
    .ascii "eq?"
_L_38080:
    movl $_L_38079, %eax
    orl $6, %eax
    mov %eax, -24(%esp)  # arg eq?
    movl -20(%esp), %edi   # load new closure to %edi
    add $-12, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $12, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    movl %eax, -12(%esp)
# emit-expr (vector-ref f6267 0)
# emit-expr f6267
# emit-variable-ref
# env=((f6267 . 0))
# var=f6267
    movl 0(%esp), %eax  # stack load f6267
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_38081
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_38081:
    movl %eax, -16(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_38082"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_38082:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_38084
    cmp  $0,%eax
    jge _L_38083
_L_38084:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_38083:
    movl -16(%esp), %esi
    movl -1(%eax,%esi), %eax
    movl %eax, 4(%ebp)
    movl -12(%esp), %eax
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    or   $1, %al
    add  $8, %ebp
# cons end
    movl -4(%esp), %ebx
    movl -8(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "eof-object") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "eof-object?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f6267 0))) (closure () (f6267) (let () (vector-ref f6267 0))))
# emit-begin
#   expr=(begin (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "eof-object") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "eof-object?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f6267 0))) (closure () (f6267) (let () (vector-ref f6267 0))))
#   env=((f6267 . 0))
# emit-expr (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f6267 0)))
# emit-expr f6267
# emit-variable-ref
# env=((f6267 . 0))
# var=f6267
    movl 0(%esp), %eax  # stack load f6267
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_38085
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_38085:
    movl %eax, -4(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_38086"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_38086:
# check bounds on vector index
    movl -4(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_38088
    cmp  $0,%eax
    jge _L_38087
_L_38088:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_38087:
    movl %eax, -8(%esp)
# emit-expr (cons ((primitive-ref string->symbol) "not") (vector-ref f6267 0))
# cons arg1=((primitive-ref string->symbol) "not") arg2=(vector-ref f6267 0)
# emit-expr ((primitive-ref string->symbol) "not")
# funcall
#    si   =-12
#    env  = ((f6267 . 0))
#    expr = (funcall (primitive-ref string->symbol) "not")
# emit-expr (primitive-ref string->symbol)
    .extern mrc_string$m$gsymbol
    movl mrc_string$m$gsymbol,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_38089"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_38089":
   movl %eax,  -20(%esp)  # stash funcall-oper in closure slot
# emit-expr "not"
# string literal
    jmp _L_38091
    .align 8,0x90
_L_38090 :
    .int 12
    .ascii "not"
_L_38091:
    movl $_L_38090, %eax
    orl $6, %eax
    mov %eax, -24(%esp)  # arg not
    movl -20(%esp), %edi   # load new closure to %edi
    add $-12, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $12, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    movl %eax, -12(%esp)
# emit-expr (vector-ref f6267 0)
# emit-expr f6267
# emit-variable-ref
# env=((f6267 . 0))
# var=f6267
    movl 0(%esp), %eax  # stack load f6267
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_38092
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_38092:
    movl %eax, -16(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_38093"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_38093:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_38095
    cmp  $0,%eax
    jge _L_38094
_L_38095:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_38094:
    movl -16(%esp), %esi
    movl -1(%eax,%esi), %eax
    movl %eax, 4(%ebp)
    movl -12(%esp), %eax
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    or   $1, %al
    add  $8, %ebp
# cons end
    movl -4(%esp), %ebx
    movl -8(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "eof-object") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "eof-object?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f6267 0))) (closure () (f6267) (let () (vector-ref f6267 0))))
# emit-begin
#   expr=(begin (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "eof-object") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "eof-object?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f6267 0))) (closure () (f6267) (let () (vector-ref f6267 0))))
#   env=((f6267 . 0))
# emit-expr (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f6267 0)))
# emit-expr f6267
# emit-variable-ref
# env=((f6267 . 0))
# var=f6267
    movl 0(%esp), %eax  # stack load f6267
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_38096
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_38096:
    movl %eax, -4(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_38097"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_38097:
# check bounds on vector index
    movl -4(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_38099
    cmp  $0,%eax
    jge _L_38098
_L_38099:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_38098:
    movl %eax, -8(%esp)
# emit-expr (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f6267 0))
# cons arg1=((primitive-ref string->symbol) "boolean?") arg2=(vector-ref f6267 0)
# emit-expr ((primitive-ref string->symbol) "boolean?")
# funcall
#    si   =-12
#    env  = ((f6267 . 0))
#    expr = (funcall (primitive-ref string->symbol) "boolean?")
# emit-expr (primitive-ref string->symbol)
    .extern mrc_string$m$gsymbol
    movl mrc_string$m$gsymbol,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_38100"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_38100":
   movl %eax,  -20(%esp)  # stash funcall-oper in closure slot
# emit-expr "boolean?"
# string literal
    jmp _L_38102
    .align 8,0x90
_L_38101 :
    .int 32
    .ascii "boolean?"
_L_38102:
    movl $_L_38101, %eax
    orl $6, %eax
    mov %eax, -24(%esp)  # arg boolean?
    movl -20(%esp), %edi   # load new closure to %edi
    add $-12, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $12, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    movl %eax, -12(%esp)
# emit-expr (vector-ref f6267 0)
# emit-expr f6267
# emit-variable-ref
# env=((f6267 . 0))
# var=f6267
    movl 0(%esp), %eax  # stack load f6267
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_38103
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_38103:
    movl %eax, -16(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_38104"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_38104:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_38106
    cmp  $0,%eax
    jge _L_38105
_L_38106:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_38105:
    movl -16(%esp), %esi
    movl -1(%eax,%esi), %eax
    movl %eax, 4(%ebp)
    movl -12(%esp), %eax
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    or   $1, %al
    add  $8, %ebp
# cons end
    movl -4(%esp), %ebx
    movl -8(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "eof-object") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "eof-object?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f6267 0))) (closure () (f6267) (let () (vector-ref f6267 0))))
# emit-begin
#   expr=(begin (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "eof-object") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "eof-object?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f6267 0))) (closure () (f6267) (let () (vector-ref f6267 0))))
#   env=((f6267 . 0))
# emit-expr (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f6267 0)))
# emit-expr f6267
# emit-variable-ref
# env=((f6267 . 0))
# var=f6267
    movl 0(%esp), %eax  # stack load f6267
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_38107
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_38107:
    movl %eax, -4(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_38108"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_38108:
# check bounds on vector index
    movl -4(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_38110
    cmp  $0,%eax
    jge _L_38109
_L_38110:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_38109:
    movl %eax, -8(%esp)
# emit-expr (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f6267 0))
# cons arg1=((primitive-ref string->symbol) "fixnum?") arg2=(vector-ref f6267 0)
# emit-expr ((primitive-ref string->symbol) "fixnum?")
# funcall
#    si   =-12
#    env  = ((f6267 . 0))
#    expr = (funcall (primitive-ref string->symbol) "fixnum?")
# emit-expr (primitive-ref string->symbol)
    .extern mrc_string$m$gsymbol
    movl mrc_string$m$gsymbol,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_38111"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_38111":
   movl %eax,  -20(%esp)  # stash funcall-oper in closure slot
# emit-expr "fixnum?"
# string literal
    jmp _L_38113
    .align 8,0x90
_L_38112 :
    .int 28
    .ascii "fixnum?"
_L_38113:
    movl $_L_38112, %eax
    orl $6, %eax
    mov %eax, -24(%esp)  # arg fixnum?
    movl -20(%esp), %edi   # load new closure to %edi
    add $-12, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $12, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    movl %eax, -12(%esp)
# emit-expr (vector-ref f6267 0)
# emit-expr f6267
# emit-variable-ref
# env=((f6267 . 0))
# var=f6267
    movl 0(%esp), %eax  # stack load f6267
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_38114
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_38114:
    movl %eax, -16(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_38115"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_38115:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_38117
    cmp  $0,%eax
    jge _L_38116
_L_38117:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_38116:
    movl -16(%esp), %esi
    movl -1(%eax,%esi), %eax
    movl %eax, 4(%ebp)
    movl -12(%esp), %eax
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    or   $1, %al
    add  $8, %ebp
# cons end
    movl -4(%esp), %ebx
    movl -8(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "eof-object") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "eof-object?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f6267 0))) (closure () (f6267) (let () (vector-ref f6267 0))))
# emit-begin
#   expr=(begin (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "eof-object") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "eof-object?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f6267 0))) (closure () (f6267) (let () (vector-ref f6267 0))))
#   env=((f6267 . 0))
# emit-expr (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f6267 0)))
# emit-expr f6267
# emit-variable-ref
# env=((f6267 . 0))
# var=f6267
    movl 0(%esp), %eax  # stack load f6267
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_38118
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_38118:
    movl %eax, -4(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_38119"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_38119:
# check bounds on vector index
    movl -4(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_38121
    cmp  $0,%eax
    jge _L_38120
_L_38121:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_38120:
    movl %eax, -8(%esp)
# emit-expr (cons ((primitive-ref string->symbol) "char?") (vector-ref f6267 0))
# cons arg1=((primitive-ref string->symbol) "char?") arg2=(vector-ref f6267 0)
# emit-expr ((primitive-ref string->symbol) "char?")
# funcall
#    si   =-12
#    env  = ((f6267 . 0))
#    expr = (funcall (primitive-ref string->symbol) "char?")
# emit-expr (primitive-ref string->symbol)
    .extern mrc_string$m$gsymbol
    movl mrc_string$m$gsymbol,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_38122"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_38122":
   movl %eax,  -20(%esp)  # stash funcall-oper in closure slot
# emit-expr "char?"
# string literal
    jmp _L_38124
    .align 8,0x90
_L_38123 :
    .int 20
    .ascii "char?"
_L_38124:
    movl $_L_38123, %eax
    orl $6, %eax
    mov %eax, -24(%esp)  # arg char?
    movl -20(%esp), %edi   # load new closure to %edi
    add $-12, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $12, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    movl %eax, -12(%esp)
# emit-expr (vector-ref f6267 0)
# emit-expr f6267
# emit-variable-ref
# env=((f6267 . 0))
# var=f6267
    movl 0(%esp), %eax  # stack load f6267
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_38125
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_38125:
    movl %eax, -16(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_38126"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_38126:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_38128
    cmp  $0,%eax
    jge _L_38127
_L_38128:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_38127:
    movl -16(%esp), %esi
    movl -1(%eax,%esi), %eax
    movl %eax, 4(%ebp)
    movl -12(%esp), %eax
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    or   $1, %al
    add  $8, %ebp
# cons end
    movl -4(%esp), %ebx
    movl -8(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "eof-object") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "eof-object?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f6267 0))) (closure () (f6267) (let () (vector-ref f6267 0))))
# emit-begin
#   expr=(begin (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "eof-object") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "eof-object?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f6267 0))) (closure () (f6267) (let () (vector-ref f6267 0))))
#   env=((f6267 . 0))
# emit-expr (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "eof-object") (vector-ref f6267 0)))
# emit-expr f6267
# emit-variable-ref
# env=((f6267 . 0))
# var=f6267
    movl 0(%esp), %eax  # stack load f6267
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_38129
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_38129:
    movl %eax, -4(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_38130"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_38130:
# check bounds on vector index
    movl -4(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_38132
    cmp  $0,%eax
    jge _L_38131
_L_38132:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_38131:
    movl %eax, -8(%esp)
# emit-expr (cons ((primitive-ref string->symbol) "eof-object") (vector-ref f6267 0))
# cons arg1=((primitive-ref string->symbol) "eof-object") arg2=(vector-ref f6267 0)
# emit-expr ((primitive-ref string->symbol) "eof-object")
# funcall
#    si   =-12
#    env  = ((f6267 . 0))
#    expr = (funcall (primitive-ref string->symbol) "eof-object")
# emit-expr (primitive-ref string->symbol)
    .extern mrc_string$m$gsymbol
    movl mrc_string$m$gsymbol,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_38133"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_38133":
   movl %eax,  -20(%esp)  # stash funcall-oper in closure slot
# emit-expr "eof-object"
# string literal
    jmp _L_38135
    .align 8,0x90
_L_38134 :
    .int 40
    .ascii "eof-object"
_L_38135:
    movl $_L_38134, %eax
    orl $6, %eax
    mov %eax, -24(%esp)  # arg eof-object
    movl -20(%esp), %edi   # load new closure to %edi
    add $-12, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $12, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    movl %eax, -12(%esp)
# emit-expr (vector-ref f6267 0)
# emit-expr f6267
# emit-variable-ref
# env=((f6267 . 0))
# var=f6267
    movl 0(%esp), %eax  # stack load f6267
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_38136
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_38136:
    movl %eax, -16(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_38137"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_38137:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_38139
    cmp  $0,%eax
    jge _L_38138
_L_38139:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_38138:
    movl -16(%esp), %esi
    movl -1(%eax,%esi), %eax
    movl %eax, 4(%ebp)
    movl -12(%esp), %eax
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    or   $1, %al
    add  $8, %ebp
# cons end
    movl -4(%esp), %ebx
    movl -8(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "eof-object?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f6267 0))) (closure () (f6267) (let () (vector-ref f6267 0))))
# emit-begin
#   expr=(begin (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "eof-object?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f6267 0))) (closure () (f6267) (let () (vector-ref f6267 0))))
#   env=((f6267 . 0))
# emit-expr (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "eof-object?") (vector-ref f6267 0)))
# emit-expr f6267
# emit-variable-ref
# env=((f6267 . 0))
# var=f6267
    movl 0(%esp), %eax  # stack load f6267
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_38140
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_38140:
    movl %eax, -4(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_38141"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_38141:
# check bounds on vector index
    movl -4(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_38143
    cmp  $0,%eax
    jge _L_38142
_L_38143:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_38142:
    movl %eax, -8(%esp)
# emit-expr (cons ((primitive-ref string->symbol) "eof-object?") (vector-ref f6267 0))
# cons arg1=((primitive-ref string->symbol) "eof-object?") arg2=(vector-ref f6267 0)
# emit-expr ((primitive-ref string->symbol) "eof-object?")
# funcall
#    si   =-12
#    env  = ((f6267 . 0))
#    expr = (funcall (primitive-ref string->symbol) "eof-object?")
# emit-expr (primitive-ref string->symbol)
    .extern mrc_string$m$gsymbol
    movl mrc_string$m$gsymbol,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_38144"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_38144":
   movl %eax,  -20(%esp)  # stash funcall-oper in closure slot
# emit-expr "eof-object?"
# string literal
    jmp _L_38146
    .align 8,0x90
_L_38145 :
    .int 44
    .ascii "eof-object?"
_L_38146:
    movl $_L_38145, %eax
    orl $6, %eax
    mov %eax, -24(%esp)  # arg eof-object?
    movl -20(%esp), %edi   # load new closure to %edi
    add $-12, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $12, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    movl %eax, -12(%esp)
# emit-expr (vector-ref f6267 0)
# emit-expr f6267
# emit-variable-ref
# env=((f6267 . 0))
# var=f6267
    movl 0(%esp), %eax  # stack load f6267
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_38147
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_38147:
    movl %eax, -16(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_38148"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_38148:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_38150
    cmp  $0,%eax
    jge _L_38149
_L_38150:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_38149:
    movl -16(%esp), %esi
    movl -1(%eax,%esi), %eax
    movl %eax, 4(%ebp)
    movl -12(%esp), %eax
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    or   $1, %al
    add  $8, %ebp
# cons end
    movl -4(%esp), %ebx
    movl -8(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f6267 0))) (closure () (f6267) (let () (vector-ref f6267 0))))
# emit-begin
#   expr=(begin (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f6267 0))) (closure () (f6267) (let () (vector-ref f6267 0))))
#   env=((f6267 . 0))
# emit-expr (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f6267 0)))
# emit-expr f6267
# emit-variable-ref
# env=((f6267 . 0))
# var=f6267
    movl 0(%esp), %eax  # stack load f6267
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_38151
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_38151:
    movl %eax, -4(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_38152"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_38152:
# check bounds on vector index
    movl -4(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_38154
    cmp  $0,%eax
    jge _L_38153
_L_38154:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_38153:
    movl %eax, -8(%esp)
# emit-expr (cons ((primitive-ref string->symbol) "null?") (vector-ref f6267 0))
# cons arg1=((primitive-ref string->symbol) "null?") arg2=(vector-ref f6267 0)
# emit-expr ((primitive-ref string->symbol) "null?")
# funcall
#    si   =-12
#    env  = ((f6267 . 0))
#    expr = (funcall (primitive-ref string->symbol) "null?")
# emit-expr (primitive-ref string->symbol)
    .extern mrc_string$m$gsymbol
    movl mrc_string$m$gsymbol,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_38155"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_38155":
   movl %eax,  -20(%esp)  # stash funcall-oper in closure slot
# emit-expr "null?"
# string literal
    jmp _L_38157
    .align 8,0x90
_L_38156 :
    .int 20
    .ascii "null?"
_L_38157:
    movl $_L_38156, %eax
    orl $6, %eax
    mov %eax, -24(%esp)  # arg null?
    movl -20(%esp), %edi   # load new closure to %edi
    add $-12, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $12, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    movl %eax, -12(%esp)
# emit-expr (vector-ref f6267 0)
# emit-expr f6267
# emit-variable-ref
# env=((f6267 . 0))
# var=f6267
    movl 0(%esp), %eax  # stack load f6267
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_38158
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_38158:
    movl %eax, -16(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_38159"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_38159:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_38161
    cmp  $0,%eax
    jge _L_38160
_L_38161:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_38160:
    movl -16(%esp), %esi
    movl -1(%eax,%esi), %eax
    movl %eax, 4(%ebp)
    movl -12(%esp), %eax
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    or   $1, %al
    add  $8, %ebp
# cons end
    movl -4(%esp), %ebx
    movl -8(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f6267 0))) (closure () (f6267) (let () (vector-ref f6267 0))))
# emit-begin
#   expr=(begin (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f6267 0))) (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f6267 0))) (closure () (f6267) (let () (vector-ref f6267 0))))
#   env=((f6267 . 0))
# emit-expr (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f6267 0)))
# emit-expr f6267
# emit-variable-ref
# env=((f6267 . 0))
# var=f6267
    movl 0(%esp), %eax  # stack load f6267
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_38162
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_38162:
    movl %eax, -4(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_38163"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_38163:
# check bounds on vector index
    movl -4(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_38165
    cmp  $0,%eax
    jge _L_38164
_L_38165:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_38164:
    movl %eax, -8(%esp)
# emit-expr (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f6267 0))
# cons arg1=((primitive-ref string->symbol) "char->fixnum") arg2=(vector-ref f6267 0)
# emit-expr ((primitive-ref string->symbol) "char->fixnum")
# funcall
#    si   =-12
#    env  = ((f6267 . 0))
#    expr = (funcall (primitive-ref string->symbol) "char->fixnum")
# emit-expr (primitive-ref string->symbol)
    .extern mrc_string$m$gsymbol
    movl mrc_string$m$gsymbol,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_38166"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_38166":
   movl %eax,  -20(%esp)  # stash funcall-oper in closure slot
# emit-expr "char->fixnum"
# string literal
    jmp _L_38168
    .align 8,0x90
_L_38167 :
    .int 48
    .ascii "char->fixnum"
_L_38168:
    movl $_L_38167, %eax
    orl $6, %eax
    mov %eax, -24(%esp)  # arg char->fixnum
    movl -20(%esp), %edi   # load new closure to %edi
    add $-12, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $12, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    movl %eax, -12(%esp)
# emit-expr (vector-ref f6267 0)
# emit-expr f6267
# emit-variable-ref
# env=((f6267 . 0))
# var=f6267
    movl 0(%esp), %eax  # stack load f6267
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_38169
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_38169:
    movl %eax, -16(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_38170"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_38170:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_38172
    cmp  $0,%eax
    jge _L_38171
_L_38172:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_38171:
    movl -16(%esp), %esi
    movl -1(%eax,%esi), %eax
    movl %eax, 4(%ebp)
    movl -12(%esp), %eax
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    or   $1, %al
    add  $8, %ebp
# cons end
    movl -4(%esp), %ebx
    movl -8(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f6267 0))) (closure () (f6267) (let () (vector-ref f6267 0))))
# emit-begin
#   expr=(begin (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f6267 0))) (closure () (f6267) (let () (vector-ref f6267 0))))
#   env=((f6267 . 0))
# emit-expr (vector-set! f6267 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f6267 0)))
# emit-expr f6267
# emit-variable-ref
# env=((f6267 . 0))
# var=f6267
    movl 0(%esp), %eax  # stack load f6267
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_38173
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_38173:
    movl %eax, -4(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_38174"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_38174:
# check bounds on vector index
    movl -4(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_38176
    cmp  $0,%eax
    jge _L_38175
_L_38176:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_38175:
    movl %eax, -8(%esp)
# emit-expr (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f6267 0))
# cons arg1=((primitive-ref string->symbol) "fixnum->char") arg2=(vector-ref f6267 0)
# emit-expr ((primitive-ref string->symbol) "fixnum->char")
# funcall
#    si   =-12
#    env  = ((f6267 . 0))
#    expr = (funcall (primitive-ref string->symbol) "fixnum->char")
# emit-expr (primitive-ref string->symbol)
    .extern mrc_string$m$gsymbol
    movl mrc_string$m$gsymbol,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_38177"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_38177":
   movl %eax,  -20(%esp)  # stash funcall-oper in closure slot
# emit-expr "fixnum->char"
# string literal
    jmp _L_38179
    .align 8,0x90
_L_38178 :
    .int 48
    .ascii "fixnum->char"
_L_38179:
    movl $_L_38178, %eax
    orl $6, %eax
    mov %eax, -24(%esp)  # arg fixnum->char
    movl -20(%esp), %edi   # load new closure to %edi
    add $-12, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $12, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    movl %eax, -12(%esp)
# emit-expr (vector-ref f6267 0)
# emit-expr f6267
# emit-variable-ref
# env=((f6267 . 0))
# var=f6267
    movl 0(%esp), %eax  # stack load f6267
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_38180
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_38180:
    movl %eax, -16(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_38181"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_38181:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_38183
    cmp  $0,%eax
    jge _L_38182
_L_38183:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_38182:
    movl -16(%esp), %esi
    movl -1(%eax,%esi), %eax
    movl %eax, 4(%ebp)
    movl -12(%esp), %eax
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    or   $1, %al
    add  $8, %ebp
# cons end
    movl -4(%esp), %ebx
    movl -8(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin (closure () (f6267) (let () (vector-ref f6267 0))))
# emit-begin
#   expr=(begin (closure () (f6267) (let () (vector-ref f6267 0))))
#   env=((f6267 . 0))
# emit-expr (closure () (f6267) (let () (vector-ref f6267 0)))
# emit-closure
# si = -4
# env = ((f6267 . 0))
# expr = (closure () (f6267) (let () (vector-ref f6267 0)))
    movl $_L_38184, 0(%ebp)  # closure label
# emit-variable-ref
# env=((f6267 . 0))
# var=f6267
    movl 0(%esp), %eax  # stack load f6267
# end emit-variable-ref
   movl  %eax, 4(%ebp)  # f6267
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $8, %ebp     # bump ebp
    jmp _L_38185            # jump around closure body
_L_38184:
# check argument count
    cmp $0,%eax
    je _L_38186
# invoke error handler eh_argcount
    .extern mrc_eh$uargcount
    movl mrc_eh$uargcount, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_38186:
# emit-tail-expr
# si=-8
# env=((f6267 . 4) (f6267 . 0))
# expr=(let () (vector-ref f6267 0))
# emit-tail-let
#  si   = -8
#  env  = ((f6267 . 4) (f6267 . 0))
#  bindings = ()
#  body = (vector-ref f6267 0)
# emit-tail-expr
# si=-8
# env=((f6267 . 4) (f6267 . 0))
# expr=(vector-ref f6267 0)
# tail primcall
# emit-expr f6267
# emit-variable-ref
# env=((f6267 . 4) (f6267 . 0))
# var=f6267
    movl 2(%edi), %eax  # frame load f6267
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_38187
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_38187:
    movl %eax, -8(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_38188"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_38188:
# check bounds on vector index
    movl -8(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_38190
    cmp  $0,%eax
    jge _L_38189
_L_38190:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_38189:
    movl -8(%esp), %esi
    movl -1(%eax,%esi), %eax
#return from tail (vector-ref f6267 0)
    ret
    .align 4,0x90
_L_38185:
# emit-expr (begin)
# emit-begin
#   expr=(begin)
#   env=((f6267 . 0))
     movl %eax, mrc_primitives
# == explicit-begins  ==>
# (lambda () (error (quote funcall) "arg 1 must be a procedure"))
# == eliminate-let*  ==>
# (lambda () (error (quote funcall) "arg 1 must be a procedure"))
# == uniquify-variables  ==>
# (lambda () (error (quote funcall) "arg 1 must be a procedure"))
# == vectorize-letrec  ==>
# (lambda () (error (quote funcall) "arg 1 must be a procedure"))
# == eliminate-set!  ==>
# (lambda () (let () (error (quote funcall) "arg 1 must be a procedure")))
# == close-free-variables  ==>
# (closure () (funcall) (let () (error (quote funcall) "arg 1 must be a procedure")))
# == eliminate-quote  ==>
# (closure () (funcall) (let () (error (string->symbol "funcall") "arg 1 must be a procedure")))
# == eliminate-when/unless  ==>
# (closure () (funcall) (let () (error (string->symbol "funcall") "arg 1 must be a procedure")))
# == eliminate-cond  ==>
# (closure () (funcall) (let () (error (string->symbol "funcall") "arg 1 must be a procedure")))
# == external-symbols  ==>
# (closure () (funcall) (let () ((primitive-ref error) ((primitive-ref string->symbol) "funcall") "arg 1 must be a procedure")))
# emit-expr (closure () (funcall) (let () ((primitive-ref error) ((primitive-ref string->symbol) "funcall") "arg 1 must be a procedure")))
# emit-closure
# si = 0
# env = ()
# expr = (closure () (funcall) (let () ((primitive-ref error) ((primitive-ref string->symbol) "funcall") "arg 1 must be a procedure")))
    movl $_L_38191, 0(%ebp)  # closure label
# WARNING: free var funcall not defined in the environmnet
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $8, %ebp     # bump ebp
    jmp _L_38192            # jump around closure body
_L_38191:
# check argument count
    cmp $0,%eax
    je _L_38193
# invoke error handler eh_argcount
    .extern mrc_eh$uargcount
    movl mrc_eh$uargcount, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_38193:
# emit-tail-expr
# si=-8
# env=((funcall . 4))
# expr=(let () ((primitive-ref error) ((primitive-ref string->symbol) "funcall") "arg 1 must be a procedure"))
# emit-tail-let
#  si   = -8
#  env  = ((funcall . 4))
#  bindings = ()
#  body = ((primitive-ref error) ((primitive-ref string->symbol) "funcall") "arg 1 must be a procedure")
# emit-tail-expr
# si=-8
# env=((funcall . 4))
# expr=((primitive-ref error) ((primitive-ref string->symbol) "funcall") "arg 1 must be a procedure")
# emit-tail-funcall
#    si   =-8
#    env  = ((funcall . 4))
#    expr = (funcall (primitive-ref error) ((primitive-ref string->symbol) "funcall") "arg 1 must be a procedure")
# emit-expr (primitive-ref error)
    .extern mrc_error
    movl mrc_error,%eax
   movl %eax,  -8(%esp)  # stash funcall-oper in next closure slot
# emit-expr ((primitive-ref string->symbol) "funcall")
# funcall
#    si   =-12
#    env  = ((funcall . 4))
#    expr = (funcall (primitive-ref string->symbol) "funcall")
# emit-expr (primitive-ref string->symbol)
    .extern mrc_string$m$gsymbol
    movl mrc_string$m$gsymbol,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_38194"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_38194":
   movl %eax,  -20(%esp)  # stash funcall-oper in closure slot
# emit-expr "funcall"
# string literal
    jmp _L_38196
    .align 8,0x90
_L_38195 :
    .int 28
    .ascii "funcall"
_L_38196:
    movl $_L_38195, %eax
    orl $6, %eax
    mov %eax, -24(%esp)  # arg funcall
    movl -20(%esp), %edi   # load new closure to %edi
    add $-12, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $12, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    mov %eax, -12(%esp)    # arg ((primitive-ref string->symbol) funcall)
# emit-expr "arg 1 must be a procedure"
# string literal
    jmp _L_38198
    .align 8,0x90
_L_38197 :
    .int 100
    .ascii "arg 1 must be a procedure"
_L_38198:
    movl $_L_38197, %eax
    orl $6, %eax
    mov %eax, -16(%esp)    # arg arg 1 must be a procedure
    movl -8(%esp), %edi   # load new closure to %edi
# emit-shift-args:  size=3   si=-8  delta=4
    mov -8(%esp), %ebx  # shift frame cell
    mov %ebx, -4(%esp)  # down to base
# emit-shift-args:  size=2   si=-12  delta=4
    mov -12(%esp), %ebx  # shift frame cell
    mov %ebx, -8(%esp)  # down to base
# emit-shift-args:  size=1   si=-16  delta=4
    mov -16(%esp), %ebx  # shift frame cell
    mov %ebx, -12(%esp)  # down to base
# emit-shift-args:  size=0   si=-20  delta=4
    movl $8,%eax   # save arg count
    jmp *-2(%edi)  # tail-funcall
    .align 4,0x90
_L_38192:
     movl %eax, mrc_eh$uprocedure
# == explicit-begins  ==>
# (lambda () (error (quote funcall) "wrong number of args"))
# == eliminate-let*  ==>
# (lambda () (error (quote funcall) "wrong number of args"))
# == uniquify-variables  ==>
# (lambda () (error (quote funcall) "wrong number of args"))
# == vectorize-letrec  ==>
# (lambda () (error (quote funcall) "wrong number of args"))
# == eliminate-set!  ==>
# (lambda () (let () (error (quote funcall) "wrong number of args")))
# == close-free-variables  ==>
# (closure () (funcall) (let () (error (quote funcall) "wrong number of args")))
# == eliminate-quote  ==>
# (closure () (funcall) (let () (error (string->symbol "funcall") "wrong number of args")))
# == eliminate-when/unless  ==>
# (closure () (funcall) (let () (error (string->symbol "funcall") "wrong number of args")))
# == eliminate-cond  ==>
# (closure () (funcall) (let () (error (string->symbol "funcall") "wrong number of args")))
# == external-symbols  ==>
# (closure () (funcall) (let () ((primitive-ref error) ((primitive-ref string->symbol) "funcall") "wrong number of args")))
# emit-expr (closure () (funcall) (let () ((primitive-ref error) ((primitive-ref string->symbol) "funcall") "wrong number of args")))
# emit-closure
# si = 0
# env = ()
# expr = (closure () (funcall) (let () ((primitive-ref error) ((primitive-ref string->symbol) "funcall") "wrong number of args")))
    movl $_L_38199, 0(%ebp)  # closure label
# WARNING: free var funcall not defined in the environmnet
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $8, %ebp     # bump ebp
    jmp _L_38200            # jump around closure body
_L_38199:
# check argument count
    cmp $0,%eax
    je _L_38201
# invoke error handler eh_argcount
    .extern mrc_eh$uargcount
    movl mrc_eh$uargcount, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_38201:
# emit-tail-expr
# si=-8
# env=((funcall . 4))
# expr=(let () ((primitive-ref error) ((primitive-ref string->symbol) "funcall") "wrong number of args"))
# emit-tail-let
#  si   = -8
#  env  = ((funcall . 4))
#  bindings = ()
#  body = ((primitive-ref error) ((primitive-ref string->symbol) "funcall") "wrong number of args")
# emit-tail-expr
# si=-8
# env=((funcall . 4))
# expr=((primitive-ref error) ((primitive-ref string->symbol) "funcall") "wrong number of args")
# emit-tail-funcall
#    si   =-8
#    env  = ((funcall . 4))
#    expr = (funcall (primitive-ref error) ((primitive-ref string->symbol) "funcall") "wrong number of args")
# emit-expr (primitive-ref error)
    .extern mrc_error
    movl mrc_error,%eax
   movl %eax,  -8(%esp)  # stash funcall-oper in next closure slot
# emit-expr ((primitive-ref string->symbol) "funcall")
# funcall
#    si   =-12
#    env  = ((funcall . 4))
#    expr = (funcall (primitive-ref string->symbol) "funcall")
# emit-expr (primitive-ref string->symbol)
    .extern mrc_string$m$gsymbol
    movl mrc_string$m$gsymbol,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_38202"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_38202":
   movl %eax,  -20(%esp)  # stash funcall-oper in closure slot
# emit-expr "funcall"
# string literal
    jmp _L_38204
    .align 8,0x90
_L_38203 :
    .int 28
    .ascii "funcall"
_L_38204:
    movl $_L_38203, %eax
    orl $6, %eax
    mov %eax, -24(%esp)  # arg funcall
    movl -20(%esp), %edi   # load new closure to %edi
    add $-12, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $12, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    mov %eax, -12(%esp)    # arg ((primitive-ref string->symbol) funcall)
# emit-expr "wrong number of args"
# string literal
    jmp _L_38206
    .align 8,0x90
_L_38205 :
    .int 80
    .ascii "wrong number of args"
_L_38206:
    movl $_L_38205, %eax
    orl $6, %eax
    mov %eax, -16(%esp)    # arg wrong number of args
    movl -8(%esp), %edi   # load new closure to %edi
# emit-shift-args:  size=3   si=-8  delta=4
    mov -8(%esp), %ebx  # shift frame cell
    mov %ebx, -4(%esp)  # down to base
# emit-shift-args:  size=2   si=-12  delta=4
    mov -12(%esp), %ebx  # shift frame cell
    mov %ebx, -8(%esp)  # down to base
# emit-shift-args:  size=1   si=-16  delta=4
    mov -16(%esp), %ebx  # shift frame cell
    mov %ebx, -12(%esp)  # down to base
# emit-shift-args:  size=0   si=-20  delta=4
    movl $8,%eax   # save arg count
    jmp *-2(%edi)  # tail-funcall
    .align 4,0x90
_L_38200:
     movl %eax, mrc_eh$uargcount
# == explicit-begins  ==>
# (lambda () (error (quote funcall) "too few args"))
# == eliminate-let*  ==>
# (lambda () (error (quote funcall) "too few args"))
# == uniquify-variables  ==>
# (lambda () (error (quote funcall) "too few args"))
# == vectorize-letrec  ==>
# (lambda () (error (quote funcall) "too few args"))
# == eliminate-set!  ==>
# (lambda () (let () (error (quote funcall) "too few args")))
# == close-free-variables  ==>
# (closure () (funcall) (let () (error (quote funcall) "too few args")))
# == eliminate-quote  ==>
# (closure () (funcall) (let () (error (string->symbol "funcall") "too few args")))
# == eliminate-when/unless  ==>
# (closure () (funcall) (let () (error (string->symbol "funcall") "too few args")))
# == eliminate-cond  ==>
# (closure () (funcall) (let () (error (string->symbol "funcall") "too few args")))
# == external-symbols  ==>
# (closure () (funcall) (let () ((primitive-ref error) ((primitive-ref string->symbol) "funcall") "too few args")))
# emit-expr (closure () (funcall) (let () ((primitive-ref error) ((primitive-ref string->symbol) "funcall") "too few args")))
# emit-closure
# si = 0
# env = ()
# expr = (closure () (funcall) (let () ((primitive-ref error) ((primitive-ref string->symbol) "funcall") "too few args")))
    movl $_L_38207, 0(%ebp)  # closure label
# WARNING: free var funcall not defined in the environmnet
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $8, %ebp     # bump ebp
    jmp _L_38208            # jump around closure body
_L_38207:
# check argument count
    cmp $0,%eax
    je _L_38209
# invoke error handler eh_argcount
    .extern mrc_eh$uargcount
    movl mrc_eh$uargcount, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_38209:
# emit-tail-expr
# si=-8
# env=((funcall . 4))
# expr=(let () ((primitive-ref error) ((primitive-ref string->symbol) "funcall") "too few args"))
# emit-tail-let
#  si   = -8
#  env  = ((funcall . 4))
#  bindings = ()
#  body = ((primitive-ref error) ((primitive-ref string->symbol) "funcall") "too few args")
# emit-tail-expr
# si=-8
# env=((funcall . 4))
# expr=((primitive-ref error) ((primitive-ref string->symbol) "funcall") "too few args")
# emit-tail-funcall
#    si   =-8
#    env  = ((funcall . 4))
#    expr = (funcall (primitive-ref error) ((primitive-ref string->symbol) "funcall") "too few args")
# emit-expr (primitive-ref error)
    .extern mrc_error
    movl mrc_error,%eax
   movl %eax,  -8(%esp)  # stash funcall-oper in next closure slot
# emit-expr ((primitive-ref string->symbol) "funcall")
# funcall
#    si   =-12
#    env  = ((funcall . 4))
#    expr = (funcall (primitive-ref string->symbol) "funcall")
# emit-expr (primitive-ref string->symbol)
    .extern mrc_string$m$gsymbol
    movl mrc_string$m$gsymbol,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_38210"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_38210":
   movl %eax,  -20(%esp)  # stash funcall-oper in closure slot
# emit-expr "funcall"
# string literal
    jmp _L_38212
    .align 8,0x90
_L_38211 :
    .int 28
    .ascii "funcall"
_L_38212:
    movl $_L_38211, %eax
    orl $6, %eax
    mov %eax, -24(%esp)  # arg funcall
    movl -20(%esp), %edi   # load new closure to %edi
    add $-12, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $12, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    mov %eax, -12(%esp)    # arg ((primitive-ref string->symbol) funcall)
# emit-expr "too few args"
# string literal
    jmp _L_38214
    .align 8,0x90
_L_38213 :
    .int 48
    .ascii "too few args"
_L_38214:
    movl $_L_38213, %eax
    orl $6, %eax
    mov %eax, -16(%esp)    # arg too few args
    movl -8(%esp), %edi   # load new closure to %edi
# emit-shift-args:  size=3   si=-8  delta=4
    mov -8(%esp), %ebx  # shift frame cell
    mov %ebx, -4(%esp)  # down to base
# emit-shift-args:  size=2   si=-12  delta=4
    mov -12(%esp), %ebx  # shift frame cell
    mov %ebx, -8(%esp)  # down to base
# emit-shift-args:  size=1   si=-16  delta=4
    mov -16(%esp), %ebx  # shift frame cell
    mov %ebx, -12(%esp)  # down to base
# emit-shift-args:  size=0   si=-20  delta=4
    movl $8,%eax   # save arg count
    jmp *-2(%edi)  # tail-funcall
    .align 4,0x90
_L_38208:
     movl %eax, mrc_eh$uargcount$umin
# == explicit-begins  ==>
# (lambda (i) (error (list-ref (primitives) i) "arg must be a fixnum"))
# == eliminate-let*  ==>
# (lambda (i) (error (list-ref (primitives) i) "arg must be a fixnum"))
# == uniquify-variables  ==>
# (lambda (f6268) (error (list-ref (primitives) f6268) "arg must be a fixnum"))
# == vectorize-letrec  ==>
# (lambda (f6268) (error (list-ref (primitives) f6268) "arg must be a fixnum"))
# == eliminate-set!  ==>
# (lambda (f6268) (let ((f6268 f6268)) (error (list-ref (primitives) f6268) "arg must be a fixnum")))
# == close-free-variables  ==>
# (closure (f6268) () (let ((f6268 f6268)) (error (list-ref (primitives) f6268) "arg must be a fixnum")))
# == eliminate-quote  ==>
# (closure (f6268) () (let ((f6268 f6268)) (error (list-ref (primitives) f6268) "arg must be a fixnum")))
# == eliminate-when/unless  ==>
# (closure (f6268) () (let ((f6268 f6268)) (error (list-ref (primitives) f6268) "arg must be a fixnum")))
# == eliminate-cond  ==>
# (closure (f6268) () (let ((f6268 f6268)) (error (list-ref (primitives) f6268) "arg must be a fixnum")))
# == external-symbols  ==>
# (closure (f6268) () (let ((f6268 f6268)) ((primitive-ref error) ((primitive-ref list-ref) ((primitive-ref primitives)) f6268) "arg must be a fixnum")))
# emit-expr (closure (f6268) () (let ((f6268 f6268)) ((primitive-ref error) ((primitive-ref list-ref) ((primitive-ref primitives)) f6268) "arg must be a fixnum")))
# emit-closure
# si = 0
# env = ()
# expr = (closure (f6268) () (let ((f6268 f6268)) ((primitive-ref error) ((primitive-ref list-ref) ((primitive-ref primitives)) f6268) "arg must be a fixnum")))
    movl $_L_38215, 0(%ebp)  # closure label
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $8, %ebp     # bump ebp
    jmp _L_38216            # jump around closure body
_L_38215:
# check argument count
    cmp $4,%eax
    je _L_38217
# invoke error handler eh_argcount
    .extern mrc_eh$uargcount
    movl mrc_eh$uargcount, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_38217:
# emit-tail-expr
# si=-12
# env=((f6268 . -8))
# expr=(let ((f6268 f6268)) ((primitive-ref error) ((primitive-ref list-ref) ((primitive-ref primitives)) f6268) "arg must be a fixnum"))
# emit-tail-let
#  si   = -12
#  env  = ((f6268 . -8))
#  bindings = ((f6268 f6268))
#  body = ((primitive-ref error) ((primitive-ref list-ref) ((primitive-ref primitives)) f6268) "arg must be a fixnum")
# emit-expr f6268
# emit-variable-ref
# env=((f6268 . -8))
# var=f6268
    movl -8(%esp), %eax  # stack load f6268
# end emit-variable-ref
    movl %eax, -12(%esp)  # stack save
# emit-tail-expr
# si=-16
# env=((f6268 . -12) (f6268 . -8))
# expr=((primitive-ref error) ((primitive-ref list-ref) ((primitive-ref primitives)) f6268) "arg must be a fixnum")
# emit-tail-funcall
#    si   =-16
#    env  = ((f6268 . -12) (f6268 . -8))
#    expr = (funcall (primitive-ref error) ((primitive-ref list-ref) ((primitive-ref primitives)) f6268) "arg must be a fixnum")
# emit-expr (primitive-ref error)
    .extern mrc_error
    movl mrc_error,%eax
   movl %eax,  -16(%esp)  # stash funcall-oper in next closure slot
# emit-expr ((primitive-ref list-ref) ((primitive-ref primitives)) f6268)
# funcall
#    si   =-20
#    env  = ((f6268 . -12) (f6268 . -8))
#    expr = (funcall (primitive-ref list-ref) ((primitive-ref primitives)) f6268)
# emit-expr (primitive-ref list-ref)
    .extern mrc_list$mref
    movl mrc_list$mref,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_38218"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_38218":
   movl %eax,  -28(%esp)  # stash funcall-oper in closure slot
# emit-expr ((primitive-ref primitives))
# funcall
#    si   =-32
#    env  = ((f6268 . -12) (f6268 . -8))
#    expr = (funcall (primitive-ref primitives))
# emit-expr (primitive-ref primitives)
    .extern mrc_primitives
    movl mrc_primitives,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_38219"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_38219":
   movl %eax,  -40(%esp)  # stash funcall-oper in closure slot
    movl -40(%esp), %edi   # load new closure to %edi
    add $-32, %esp   # adjust base
    movl $0,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $32, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    mov %eax, -32(%esp)  # arg ((primitive-ref primitives))
# emit-expr f6268
# emit-variable-ref
# env=((f6268 . -12) (f6268 . -8))
# var=f6268
    movl -12(%esp), %eax  # stack load f6268
# end emit-variable-ref
    mov %eax, -36(%esp)  # arg f6268
    movl -28(%esp), %edi   # load new closure to %edi
    add $-20, %esp   # adjust base
    movl $8,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $20, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    mov %eax, -20(%esp)    # arg ((primitive-ref list-ref) ((primitive-ref primitives)) f6268)
# emit-expr "arg must be a fixnum"
# string literal
    jmp _L_38221
    .align 8,0x90
_L_38220 :
    .int 80
    .ascii "arg must be a fixnum"
_L_38221:
    movl $_L_38220, %eax
    orl $6, %eax
    mov %eax, -24(%esp)    # arg arg must be a fixnum
    movl -16(%esp), %edi   # load new closure to %edi
# emit-shift-args:  size=3   si=-16  delta=12
    mov -16(%esp), %ebx  # shift frame cell
    mov %ebx, -4(%esp)  # down to base
# emit-shift-args:  size=2   si=-20  delta=12
    mov -20(%esp), %ebx  # shift frame cell
    mov %ebx, -8(%esp)  # down to base
# emit-shift-args:  size=1   si=-24  delta=12
    mov -24(%esp), %ebx  # shift frame cell
    mov %ebx, -12(%esp)  # down to base
# emit-shift-args:  size=0   si=-28  delta=12
    movl $8,%eax   # save arg count
    jmp *-2(%edi)  # tail-funcall
    .align 4,0x90
_L_38216:
     movl %eax, mrc_eh$ufixnum
# == explicit-begins  ==>
# (lambda (i) (error (list-ref (primitives) i) "arg must be a string"))
# == eliminate-let*  ==>
# (lambda (i) (error (list-ref (primitives) i) "arg must be a string"))
# == uniquify-variables  ==>
# (lambda (f6269) (error (list-ref (primitives) f6269) "arg must be a string"))
# == vectorize-letrec  ==>
# (lambda (f6269) (error (list-ref (primitives) f6269) "arg must be a string"))
# == eliminate-set!  ==>
# (lambda (f6269) (let ((f6269 f6269)) (error (list-ref (primitives) f6269) "arg must be a string")))
# == close-free-variables  ==>
# (closure (f6269) () (let ((f6269 f6269)) (error (list-ref (primitives) f6269) "arg must be a string")))
# == eliminate-quote  ==>
# (closure (f6269) () (let ((f6269 f6269)) (error (list-ref (primitives) f6269) "arg must be a string")))
# == eliminate-when/unless  ==>
# (closure (f6269) () (let ((f6269 f6269)) (error (list-ref (primitives) f6269) "arg must be a string")))
# == eliminate-cond  ==>
# (closure (f6269) () (let ((f6269 f6269)) (error (list-ref (primitives) f6269) "arg must be a string")))
# == external-symbols  ==>
# (closure (f6269) () (let ((f6269 f6269)) ((primitive-ref error) ((primitive-ref list-ref) ((primitive-ref primitives)) f6269) "arg must be a string")))
# emit-expr (closure (f6269) () (let ((f6269 f6269)) ((primitive-ref error) ((primitive-ref list-ref) ((primitive-ref primitives)) f6269) "arg must be a string")))
# emit-closure
# si = 0
# env = ()
# expr = (closure (f6269) () (let ((f6269 f6269)) ((primitive-ref error) ((primitive-ref list-ref) ((primitive-ref primitives)) f6269) "arg must be a string")))
    movl $_L_38222, 0(%ebp)  # closure label
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $8, %ebp     # bump ebp
    jmp _L_38223            # jump around closure body
_L_38222:
# check argument count
    cmp $4,%eax
    je _L_38224
# invoke error handler eh_argcount
    .extern mrc_eh$uargcount
    movl mrc_eh$uargcount, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_38224:
# emit-tail-expr
# si=-12
# env=((f6269 . -8))
# expr=(let ((f6269 f6269)) ((primitive-ref error) ((primitive-ref list-ref) ((primitive-ref primitives)) f6269) "arg must be a string"))
# emit-tail-let
#  si   = -12
#  env  = ((f6269 . -8))
#  bindings = ((f6269 f6269))
#  body = ((primitive-ref error) ((primitive-ref list-ref) ((primitive-ref primitives)) f6269) "arg must be a string")
# emit-expr f6269
# emit-variable-ref
# env=((f6269 . -8))
# var=f6269
    movl -8(%esp), %eax  # stack load f6269
# end emit-variable-ref
    movl %eax, -12(%esp)  # stack save
# emit-tail-expr
# si=-16
# env=((f6269 . -12) (f6269 . -8))
# expr=((primitive-ref error) ((primitive-ref list-ref) ((primitive-ref primitives)) f6269) "arg must be a string")
# emit-tail-funcall
#    si   =-16
#    env  = ((f6269 . -12) (f6269 . -8))
#    expr = (funcall (primitive-ref error) ((primitive-ref list-ref) ((primitive-ref primitives)) f6269) "arg must be a string")
# emit-expr (primitive-ref error)
    .extern mrc_error
    movl mrc_error,%eax
   movl %eax,  -16(%esp)  # stash funcall-oper in next closure slot
# emit-expr ((primitive-ref list-ref) ((primitive-ref primitives)) f6269)
# funcall
#    si   =-20
#    env  = ((f6269 . -12) (f6269 . -8))
#    expr = (funcall (primitive-ref list-ref) ((primitive-ref primitives)) f6269)
# emit-expr (primitive-ref list-ref)
    .extern mrc_list$mref
    movl mrc_list$mref,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_38225"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_38225":
   movl %eax,  -28(%esp)  # stash funcall-oper in closure slot
# emit-expr ((primitive-ref primitives))
# funcall
#    si   =-32
#    env  = ((f6269 . -12) (f6269 . -8))
#    expr = (funcall (primitive-ref primitives))
# emit-expr (primitive-ref primitives)
    .extern mrc_primitives
    movl mrc_primitives,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_38226"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_38226":
   movl %eax,  -40(%esp)  # stash funcall-oper in closure slot
    movl -40(%esp), %edi   # load new closure to %edi
    add $-32, %esp   # adjust base
    movl $0,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $32, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    mov %eax, -32(%esp)  # arg ((primitive-ref primitives))
# emit-expr f6269
# emit-variable-ref
# env=((f6269 . -12) (f6269 . -8))
# var=f6269
    movl -12(%esp), %eax  # stack load f6269
# end emit-variable-ref
    mov %eax, -36(%esp)  # arg f6269
    movl -28(%esp), %edi   # load new closure to %edi
    add $-20, %esp   # adjust base
    movl $8,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $20, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    mov %eax, -20(%esp)    # arg ((primitive-ref list-ref) ((primitive-ref primitives)) f6269)
# emit-expr "arg must be a string"
# string literal
    jmp _L_38228
    .align 8,0x90
_L_38227 :
    .int 80
    .ascii "arg must be a string"
_L_38228:
    movl $_L_38227, %eax
    orl $6, %eax
    mov %eax, -24(%esp)    # arg arg must be a string
    movl -16(%esp), %edi   # load new closure to %edi
# emit-shift-args:  size=3   si=-16  delta=12
    mov -16(%esp), %ebx  # shift frame cell
    mov %ebx, -4(%esp)  # down to base
# emit-shift-args:  size=2   si=-20  delta=12
    mov -20(%esp), %ebx  # shift frame cell
    mov %ebx, -8(%esp)  # down to base
# emit-shift-args:  size=1   si=-24  delta=12
    mov -24(%esp), %ebx  # shift frame cell
    mov %ebx, -12(%esp)  # down to base
# emit-shift-args:  size=0   si=-28  delta=12
    movl $8,%eax   # save arg count
    jmp *-2(%edi)  # tail-funcall
    .align 4,0x90
_L_38223:
     movl %eax, mrc_eh$ustring
# == explicit-begins  ==>
# (lambda (i) (error (list-ref (primitives) i) "arg must be a character"))
# == eliminate-let*  ==>
# (lambda (i) (error (list-ref (primitives) i) "arg must be a character"))
# == uniquify-variables  ==>
# (lambda (f6270) (error (list-ref (primitives) f6270) "arg must be a character"))
# == vectorize-letrec  ==>
# (lambda (f6270) (error (list-ref (primitives) f6270) "arg must be a character"))
# == eliminate-set!  ==>
# (lambda (f6270) (let ((f6270 f6270)) (error (list-ref (primitives) f6270) "arg must be a character")))
# == close-free-variables  ==>
# (closure (f6270) () (let ((f6270 f6270)) (error (list-ref (primitives) f6270) "arg must be a character")))
# == eliminate-quote  ==>
# (closure (f6270) () (let ((f6270 f6270)) (error (list-ref (primitives) f6270) "arg must be a character")))
# == eliminate-when/unless  ==>
# (closure (f6270) () (let ((f6270 f6270)) (error (list-ref (primitives) f6270) "arg must be a character")))
# == eliminate-cond  ==>
# (closure (f6270) () (let ((f6270 f6270)) (error (list-ref (primitives) f6270) "arg must be a character")))
# == external-symbols  ==>
# (closure (f6270) () (let ((f6270 f6270)) ((primitive-ref error) ((primitive-ref list-ref) ((primitive-ref primitives)) f6270) "arg must be a character")))
# emit-expr (closure (f6270) () (let ((f6270 f6270)) ((primitive-ref error) ((primitive-ref list-ref) ((primitive-ref primitives)) f6270) "arg must be a character")))
# emit-closure
# si = 0
# env = ()
# expr = (closure (f6270) () (let ((f6270 f6270)) ((primitive-ref error) ((primitive-ref list-ref) ((primitive-ref primitives)) f6270) "arg must be a character")))
    movl $_L_38229, 0(%ebp)  # closure label
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $8, %ebp     # bump ebp
    jmp _L_38230            # jump around closure body
_L_38229:
# check argument count
    cmp $4,%eax
    je _L_38231
# invoke error handler eh_argcount
    .extern mrc_eh$uargcount
    movl mrc_eh$uargcount, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_38231:
# emit-tail-expr
# si=-12
# env=((f6270 . -8))
# expr=(let ((f6270 f6270)) ((primitive-ref error) ((primitive-ref list-ref) ((primitive-ref primitives)) f6270) "arg must be a character"))
# emit-tail-let
#  si   = -12
#  env  = ((f6270 . -8))
#  bindings = ((f6270 f6270))
#  body = ((primitive-ref error) ((primitive-ref list-ref) ((primitive-ref primitives)) f6270) "arg must be a character")
# emit-expr f6270
# emit-variable-ref
# env=((f6270 . -8))
# var=f6270
    movl -8(%esp), %eax  # stack load f6270
# end emit-variable-ref
    movl %eax, -12(%esp)  # stack save
# emit-tail-expr
# si=-16
# env=((f6270 . -12) (f6270 . -8))
# expr=((primitive-ref error) ((primitive-ref list-ref) ((primitive-ref primitives)) f6270) "arg must be a character")
# emit-tail-funcall
#    si   =-16
#    env  = ((f6270 . -12) (f6270 . -8))
#    expr = (funcall (primitive-ref error) ((primitive-ref list-ref) ((primitive-ref primitives)) f6270) "arg must be a character")
# emit-expr (primitive-ref error)
    .extern mrc_error
    movl mrc_error,%eax
   movl %eax,  -16(%esp)  # stash funcall-oper in next closure slot
# emit-expr ((primitive-ref list-ref) ((primitive-ref primitives)) f6270)
# funcall
#    si   =-20
#    env  = ((f6270 . -12) (f6270 . -8))
#    expr = (funcall (primitive-ref list-ref) ((primitive-ref primitives)) f6270)
# emit-expr (primitive-ref list-ref)
    .extern mrc_list$mref
    movl mrc_list$mref,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_38232"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_38232":
   movl %eax,  -28(%esp)  # stash funcall-oper in closure slot
# emit-expr ((primitive-ref primitives))
# funcall
#    si   =-32
#    env  = ((f6270 . -12) (f6270 . -8))
#    expr = (funcall (primitive-ref primitives))
# emit-expr (primitive-ref primitives)
    .extern mrc_primitives
    movl mrc_primitives,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_38233"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_38233":
   movl %eax,  -40(%esp)  # stash funcall-oper in closure slot
    movl -40(%esp), %edi   # load new closure to %edi
    add $-32, %esp   # adjust base
    movl $0,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $32, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    mov %eax, -32(%esp)  # arg ((primitive-ref primitives))
# emit-expr f6270
# emit-variable-ref
# env=((f6270 . -12) (f6270 . -8))
# var=f6270
    movl -12(%esp), %eax  # stack load f6270
# end emit-variable-ref
    mov %eax, -36(%esp)  # arg f6270
    movl -28(%esp), %edi   # load new closure to %edi
    add $-20, %esp   # adjust base
    movl $8,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $20, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    mov %eax, -20(%esp)    # arg ((primitive-ref list-ref) ((primitive-ref primitives)) f6270)
# emit-expr "arg must be a character"
# string literal
    jmp _L_38235
    .align 8,0x90
_L_38234 :
    .int 92
    .ascii "arg must be a character"
_L_38235:
    movl $_L_38234, %eax
    orl $6, %eax
    mov %eax, -24(%esp)    # arg arg must be a character
    movl -16(%esp), %edi   # load new closure to %edi
# emit-shift-args:  size=3   si=-16  delta=12
    mov -16(%esp), %ebx  # shift frame cell
    mov %ebx, -4(%esp)  # down to base
# emit-shift-args:  size=2   si=-20  delta=12
    mov -20(%esp), %ebx  # shift frame cell
    mov %ebx, -8(%esp)  # down to base
# emit-shift-args:  size=1   si=-24  delta=12
    mov -24(%esp), %ebx  # shift frame cell
    mov %ebx, -12(%esp)  # down to base
# emit-shift-args:  size=0   si=-28  delta=12
    movl $8,%eax   # save arg count
    jmp *-2(%edi)  # tail-funcall
    .align 4,0x90
_L_38230:
     movl %eax, mrc_eh$ucharacter
# == explicit-begins  ==>
# (lambda (i) (error (list-ref (primitives) i) "arg must be a pair"))
# == eliminate-let*  ==>
# (lambda (i) (error (list-ref (primitives) i) "arg must be a pair"))
# == uniquify-variables  ==>
# (lambda (f6271) (error (list-ref (primitives) f6271) "arg must be a pair"))
# == vectorize-letrec  ==>
# (lambda (f6271) (error (list-ref (primitives) f6271) "arg must be a pair"))
# == eliminate-set!  ==>
# (lambda (f6271) (let ((f6271 f6271)) (error (list-ref (primitives) f6271) "arg must be a pair")))
# == close-free-variables  ==>
# (closure (f6271) () (let ((f6271 f6271)) (error (list-ref (primitives) f6271) "arg must be a pair")))
# == eliminate-quote  ==>
# (closure (f6271) () (let ((f6271 f6271)) (error (list-ref (primitives) f6271) "arg must be a pair")))
# == eliminate-when/unless  ==>
# (closure (f6271) () (let ((f6271 f6271)) (error (list-ref (primitives) f6271) "arg must be a pair")))
# == eliminate-cond  ==>
# (closure (f6271) () (let ((f6271 f6271)) (error (list-ref (primitives) f6271) "arg must be a pair")))
# == external-symbols  ==>
# (closure (f6271) () (let ((f6271 f6271)) ((primitive-ref error) ((primitive-ref list-ref) ((primitive-ref primitives)) f6271) "arg must be a pair")))
# emit-expr (closure (f6271) () (let ((f6271 f6271)) ((primitive-ref error) ((primitive-ref list-ref) ((primitive-ref primitives)) f6271) "arg must be a pair")))
# emit-closure
# si = 0
# env = ()
# expr = (closure (f6271) () (let ((f6271 f6271)) ((primitive-ref error) ((primitive-ref list-ref) ((primitive-ref primitives)) f6271) "arg must be a pair")))
    movl $_L_38236, 0(%ebp)  # closure label
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $8, %ebp     # bump ebp
    jmp _L_38237            # jump around closure body
_L_38236:
# check argument count
    cmp $4,%eax
    je _L_38238
# invoke error handler eh_argcount
    .extern mrc_eh$uargcount
    movl mrc_eh$uargcount, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_38238:
# emit-tail-expr
# si=-12
# env=((f6271 . -8))
# expr=(let ((f6271 f6271)) ((primitive-ref error) ((primitive-ref list-ref) ((primitive-ref primitives)) f6271) "arg must be a pair"))
# emit-tail-let
#  si   = -12
#  env  = ((f6271 . -8))
#  bindings = ((f6271 f6271))
#  body = ((primitive-ref error) ((primitive-ref list-ref) ((primitive-ref primitives)) f6271) "arg must be a pair")
# emit-expr f6271
# emit-variable-ref
# env=((f6271 . -8))
# var=f6271
    movl -8(%esp), %eax  # stack load f6271
# end emit-variable-ref
    movl %eax, -12(%esp)  # stack save
# emit-tail-expr
# si=-16
# env=((f6271 . -12) (f6271 . -8))
# expr=((primitive-ref error) ((primitive-ref list-ref) ((primitive-ref primitives)) f6271) "arg must be a pair")
# emit-tail-funcall
#    si   =-16
#    env  = ((f6271 . -12) (f6271 . -8))
#    expr = (funcall (primitive-ref error) ((primitive-ref list-ref) ((primitive-ref primitives)) f6271) "arg must be a pair")
# emit-expr (primitive-ref error)
    .extern mrc_error
    movl mrc_error,%eax
   movl %eax,  -16(%esp)  # stash funcall-oper in next closure slot
# emit-expr ((primitive-ref list-ref) ((primitive-ref primitives)) f6271)
# funcall
#    si   =-20
#    env  = ((f6271 . -12) (f6271 . -8))
#    expr = (funcall (primitive-ref list-ref) ((primitive-ref primitives)) f6271)
# emit-expr (primitive-ref list-ref)
    .extern mrc_list$mref
    movl mrc_list$mref,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_38239"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_38239":
   movl %eax,  -28(%esp)  # stash funcall-oper in closure slot
# emit-expr ((primitive-ref primitives))
# funcall
#    si   =-32
#    env  = ((f6271 . -12) (f6271 . -8))
#    expr = (funcall (primitive-ref primitives))
# emit-expr (primitive-ref primitives)
    .extern mrc_primitives
    movl mrc_primitives,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_38240"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_38240":
   movl %eax,  -40(%esp)  # stash funcall-oper in closure slot
    movl -40(%esp), %edi   # load new closure to %edi
    add $-32, %esp   # adjust base
    movl $0,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $32, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    mov %eax, -32(%esp)  # arg ((primitive-ref primitives))
# emit-expr f6271
# emit-variable-ref
# env=((f6271 . -12) (f6271 . -8))
# var=f6271
    movl -12(%esp), %eax  # stack load f6271
# end emit-variable-ref
    mov %eax, -36(%esp)  # arg f6271
    movl -28(%esp), %edi   # load new closure to %edi
    add $-20, %esp   # adjust base
    movl $8,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $20, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    mov %eax, -20(%esp)    # arg ((primitive-ref list-ref) ((primitive-ref primitives)) f6271)
# emit-expr "arg must be a pair"
# string literal
    jmp _L_38242
    .align 8,0x90
_L_38241 :
    .int 72
    .ascii "arg must be a pair"
_L_38242:
    movl $_L_38241, %eax
    orl $6, %eax
    mov %eax, -24(%esp)    # arg arg must be a pair
    movl -16(%esp), %edi   # load new closure to %edi
# emit-shift-args:  size=3   si=-16  delta=12
    mov -16(%esp), %ebx  # shift frame cell
    mov %ebx, -4(%esp)  # down to base
# emit-shift-args:  size=2   si=-20  delta=12
    mov -20(%esp), %ebx  # shift frame cell
    mov %ebx, -8(%esp)  # down to base
# emit-shift-args:  size=1   si=-24  delta=12
    mov -24(%esp), %ebx  # shift frame cell
    mov %ebx, -12(%esp)  # down to base
# emit-shift-args:  size=0   si=-28  delta=12
    movl $8,%eax   # save arg count
    jmp *-2(%edi)  # tail-funcall
    .align 4,0x90
_L_38237:
     movl %eax, mrc_eh$upair
# == explicit-begins  ==>
# (lambda (i) (error (list-ref (primitives) i) "arg must be a vector"))
# == eliminate-let*  ==>
# (lambda (i) (error (list-ref (primitives) i) "arg must be a vector"))
# == uniquify-variables  ==>
# (lambda (f6272) (error (list-ref (primitives) f6272) "arg must be a vector"))
# == vectorize-letrec  ==>
# (lambda (f6272) (error (list-ref (primitives) f6272) "arg must be a vector"))
# == eliminate-set!  ==>
# (lambda (f6272) (let ((f6272 f6272)) (error (list-ref (primitives) f6272) "arg must be a vector")))
# == close-free-variables  ==>
# (closure (f6272) () (let ((f6272 f6272)) (error (list-ref (primitives) f6272) "arg must be a vector")))
# == eliminate-quote  ==>
# (closure (f6272) () (let ((f6272 f6272)) (error (list-ref (primitives) f6272) "arg must be a vector")))
# == eliminate-when/unless  ==>
# (closure (f6272) () (let ((f6272 f6272)) (error (list-ref (primitives) f6272) "arg must be a vector")))
# == eliminate-cond  ==>
# (closure (f6272) () (let ((f6272 f6272)) (error (list-ref (primitives) f6272) "arg must be a vector")))
# == external-symbols  ==>
# (closure (f6272) () (let ((f6272 f6272)) ((primitive-ref error) ((primitive-ref list-ref) ((primitive-ref primitives)) f6272) "arg must be a vector")))
# emit-expr (closure (f6272) () (let ((f6272 f6272)) ((primitive-ref error) ((primitive-ref list-ref) ((primitive-ref primitives)) f6272) "arg must be a vector")))
# emit-closure
# si = 0
# env = ()
# expr = (closure (f6272) () (let ((f6272 f6272)) ((primitive-ref error) ((primitive-ref list-ref) ((primitive-ref primitives)) f6272) "arg must be a vector")))
    movl $_L_38243, 0(%ebp)  # closure label
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $8, %ebp     # bump ebp
    jmp _L_38244            # jump around closure body
_L_38243:
# check argument count
    cmp $4,%eax
    je _L_38245
# invoke error handler eh_argcount
    .extern mrc_eh$uargcount
    movl mrc_eh$uargcount, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_38245:
# emit-tail-expr
# si=-12
# env=((f6272 . -8))
# expr=(let ((f6272 f6272)) ((primitive-ref error) ((primitive-ref list-ref) ((primitive-ref primitives)) f6272) "arg must be a vector"))
# emit-tail-let
#  si   = -12
#  env  = ((f6272 . -8))
#  bindings = ((f6272 f6272))
#  body = ((primitive-ref error) ((primitive-ref list-ref) ((primitive-ref primitives)) f6272) "arg must be a vector")
# emit-expr f6272
# emit-variable-ref
# env=((f6272 . -8))
# var=f6272
    movl -8(%esp), %eax  # stack load f6272
# end emit-variable-ref
    movl %eax, -12(%esp)  # stack save
# emit-tail-expr
# si=-16
# env=((f6272 . -12) (f6272 . -8))
# expr=((primitive-ref error) ((primitive-ref list-ref) ((primitive-ref primitives)) f6272) "arg must be a vector")
# emit-tail-funcall
#    si   =-16
#    env  = ((f6272 . -12) (f6272 . -8))
#    expr = (funcall (primitive-ref error) ((primitive-ref list-ref) ((primitive-ref primitives)) f6272) "arg must be a vector")
# emit-expr (primitive-ref error)
    .extern mrc_error
    movl mrc_error,%eax
   movl %eax,  -16(%esp)  # stash funcall-oper in next closure slot
# emit-expr ((primitive-ref list-ref) ((primitive-ref primitives)) f6272)
# funcall
#    si   =-20
#    env  = ((f6272 . -12) (f6272 . -8))
#    expr = (funcall (primitive-ref list-ref) ((primitive-ref primitives)) f6272)
# emit-expr (primitive-ref list-ref)
    .extern mrc_list$mref
    movl mrc_list$mref,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_38246"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_38246":
   movl %eax,  -28(%esp)  # stash funcall-oper in closure slot
# emit-expr ((primitive-ref primitives))
# funcall
#    si   =-32
#    env  = ((f6272 . -12) (f6272 . -8))
#    expr = (funcall (primitive-ref primitives))
# emit-expr (primitive-ref primitives)
    .extern mrc_primitives
    movl mrc_primitives,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_38247"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_38247":
   movl %eax,  -40(%esp)  # stash funcall-oper in closure slot
    movl -40(%esp), %edi   # load new closure to %edi
    add $-32, %esp   # adjust base
    movl $0,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $32, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    mov %eax, -32(%esp)  # arg ((primitive-ref primitives))
# emit-expr f6272
# emit-variable-ref
# env=((f6272 . -12) (f6272 . -8))
# var=f6272
    movl -12(%esp), %eax  # stack load f6272
# end emit-variable-ref
    mov %eax, -36(%esp)  # arg f6272
    movl -28(%esp), %edi   # load new closure to %edi
    add $-20, %esp   # adjust base
    movl $8,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $20, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    mov %eax, -20(%esp)    # arg ((primitive-ref list-ref) ((primitive-ref primitives)) f6272)
# emit-expr "arg must be a vector"
# string literal
    jmp _L_38249
    .align 8,0x90
_L_38248 :
    .int 80
    .ascii "arg must be a vector"
_L_38249:
    movl $_L_38248, %eax
    orl $6, %eax
    mov %eax, -24(%esp)    # arg arg must be a vector
    movl -16(%esp), %edi   # load new closure to %edi
# emit-shift-args:  size=3   si=-16  delta=12
    mov -16(%esp), %ebx  # shift frame cell
    mov %ebx, -4(%esp)  # down to base
# emit-shift-args:  size=2   si=-20  delta=12
    mov -20(%esp), %ebx  # shift frame cell
    mov %ebx, -8(%esp)  # down to base
# emit-shift-args:  size=1   si=-24  delta=12
    mov -24(%esp), %ebx  # shift frame cell
    mov %ebx, -12(%esp)  # down to base
# emit-shift-args:  size=0   si=-28  delta=12
    movl $8,%eax   # save arg count
    jmp *-2(%edi)  # tail-funcall
    .align 4,0x90
_L_38244:
     movl %eax, mrc_eh$uvector
# == explicit-begins  ==>
# (lambda (i) (error (list-ref (primitives) i) "length must be a fixnum >= 0"))
# == eliminate-let*  ==>
# (lambda (i) (error (list-ref (primitives) i) "length must be a fixnum >= 0"))
# == uniquify-variables  ==>
# (lambda (f6273) (error (list-ref (primitives) f6273) "length must be a fixnum >= 0"))
# == vectorize-letrec  ==>
# (lambda (f6273) (error (list-ref (primitives) f6273) "length must be a fixnum >= 0"))
# == eliminate-set!  ==>
# (lambda (f6273) (let ((f6273 f6273)) (error (list-ref (primitives) f6273) "length must be a fixnum >= 0")))
# == close-free-variables  ==>
# (closure (f6273) () (let ((f6273 f6273)) (error (list-ref (primitives) f6273) "length must be a fixnum >= 0")))
# == eliminate-quote  ==>
# (closure (f6273) () (let ((f6273 f6273)) (error (list-ref (primitives) f6273) "length must be a fixnum >= 0")))
# == eliminate-when/unless  ==>
# (closure (f6273) () (let ((f6273 f6273)) (error (list-ref (primitives) f6273) "length must be a fixnum >= 0")))
# == eliminate-cond  ==>
# (closure (f6273) () (let ((f6273 f6273)) (error (list-ref (primitives) f6273) "length must be a fixnum >= 0")))
# == external-symbols  ==>
# (closure (f6273) () (let ((f6273 f6273)) ((primitive-ref error) ((primitive-ref list-ref) ((primitive-ref primitives)) f6273) "length must be a fixnum >= 0")))
# emit-expr (closure (f6273) () (let ((f6273 f6273)) ((primitive-ref error) ((primitive-ref list-ref) ((primitive-ref primitives)) f6273) "length must be a fixnum >= 0")))
# emit-closure
# si = 0
# env = ()
# expr = (closure (f6273) () (let ((f6273 f6273)) ((primitive-ref error) ((primitive-ref list-ref) ((primitive-ref primitives)) f6273) "length must be a fixnum >= 0")))
    movl $_L_38250, 0(%ebp)  # closure label
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $8, %ebp     # bump ebp
    jmp _L_38251            # jump around closure body
_L_38250:
# check argument count
    cmp $4,%eax
    je _L_38252
# invoke error handler eh_argcount
    .extern mrc_eh$uargcount
    movl mrc_eh$uargcount, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_38252:
# emit-tail-expr
# si=-12
# env=((f6273 . -8))
# expr=(let ((f6273 f6273)) ((primitive-ref error) ((primitive-ref list-ref) ((primitive-ref primitives)) f6273) "length must be a fixnum >= 0"))
# emit-tail-let
#  si   = -12
#  env  = ((f6273 . -8))
#  bindings = ((f6273 f6273))
#  body = ((primitive-ref error) ((primitive-ref list-ref) ((primitive-ref primitives)) f6273) "length must be a fixnum >= 0")
# emit-expr f6273
# emit-variable-ref
# env=((f6273 . -8))
# var=f6273
    movl -8(%esp), %eax  # stack load f6273
# end emit-variable-ref
    movl %eax, -12(%esp)  # stack save
# emit-tail-expr
# si=-16
# env=((f6273 . -12) (f6273 . -8))
# expr=((primitive-ref error) ((primitive-ref list-ref) ((primitive-ref primitives)) f6273) "length must be a fixnum >= 0")
# emit-tail-funcall
#    si   =-16
#    env  = ((f6273 . -12) (f6273 . -8))
#    expr = (funcall (primitive-ref error) ((primitive-ref list-ref) ((primitive-ref primitives)) f6273) "length must be a fixnum >= 0")
# emit-expr (primitive-ref error)
    .extern mrc_error
    movl mrc_error,%eax
   movl %eax,  -16(%esp)  # stash funcall-oper in next closure slot
# emit-expr ((primitive-ref list-ref) ((primitive-ref primitives)) f6273)
# funcall
#    si   =-20
#    env  = ((f6273 . -12) (f6273 . -8))
#    expr = (funcall (primitive-ref list-ref) ((primitive-ref primitives)) f6273)
# emit-expr (primitive-ref list-ref)
    .extern mrc_list$mref
    movl mrc_list$mref,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_38253"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_38253":
   movl %eax,  -28(%esp)  # stash funcall-oper in closure slot
# emit-expr ((primitive-ref primitives))
# funcall
#    si   =-32
#    env  = ((f6273 . -12) (f6273 . -8))
#    expr = (funcall (primitive-ref primitives))
# emit-expr (primitive-ref primitives)
    .extern mrc_primitives
    movl mrc_primitives,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_38254"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_38254":
   movl %eax,  -40(%esp)  # stash funcall-oper in closure slot
    movl -40(%esp), %edi   # load new closure to %edi
    add $-32, %esp   # adjust base
    movl $0,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $32, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    mov %eax, -32(%esp)  # arg ((primitive-ref primitives))
# emit-expr f6273
# emit-variable-ref
# env=((f6273 . -12) (f6273 . -8))
# var=f6273
    movl -12(%esp), %eax  # stack load f6273
# end emit-variable-ref
    mov %eax, -36(%esp)  # arg f6273
    movl -28(%esp), %edi   # load new closure to %edi
    add $-20, %esp   # adjust base
    movl $8,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $20, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    mov %eax, -20(%esp)    # arg ((primitive-ref list-ref) ((primitive-ref primitives)) f6273)
# emit-expr "length must be a fixnum >= 0"
# string literal
    jmp _L_38256
    .align 8,0x90
_L_38255 :
    .int 112
    .ascii "length must be a fixnum >= 0"
_L_38256:
    movl $_L_38255, %eax
    orl $6, %eax
    mov %eax, -24(%esp)    # arg length must be a fixnum >= 0
    movl -16(%esp), %edi   # load new closure to %edi
# emit-shift-args:  size=3   si=-16  delta=12
    mov -16(%esp), %ebx  # shift frame cell
    mov %ebx, -4(%esp)  # down to base
# emit-shift-args:  size=2   si=-20  delta=12
    mov -20(%esp), %ebx  # shift frame cell
    mov %ebx, -8(%esp)  # down to base
# emit-shift-args:  size=1   si=-24  delta=12
    mov -24(%esp), %ebx  # shift frame cell
    mov %ebx, -12(%esp)  # down to base
# emit-shift-args:  size=0   si=-28  delta=12
    movl $8,%eax   # save arg count
    jmp *-2(%edi)  # tail-funcall
    .align 4,0x90
_L_38251:
     movl %eax, mrc_eh$ulength
# == explicit-begins  ==>
# (lambda (i) (error (list-ref (primitives) i) "index out of bounds"))
# == eliminate-let*  ==>
# (lambda (i) (error (list-ref (primitives) i) "index out of bounds"))
# == uniquify-variables  ==>
# (lambda (f6274) (error (list-ref (primitives) f6274) "index out of bounds"))
# == vectorize-letrec  ==>
# (lambda (f6274) (error (list-ref (primitives) f6274) "index out of bounds"))
# == eliminate-set!  ==>
# (lambda (f6274) (let ((f6274 f6274)) (error (list-ref (primitives) f6274) "index out of bounds")))
# == close-free-variables  ==>
# (closure (f6274) () (let ((f6274 f6274)) (error (list-ref (primitives) f6274) "index out of bounds")))
# == eliminate-quote  ==>
# (closure (f6274) () (let ((f6274 f6274)) (error (list-ref (primitives) f6274) "index out of bounds")))
# == eliminate-when/unless  ==>
# (closure (f6274) () (let ((f6274 f6274)) (error (list-ref (primitives) f6274) "index out of bounds")))
# == eliminate-cond  ==>
# (closure (f6274) () (let ((f6274 f6274)) (error (list-ref (primitives) f6274) "index out of bounds")))
# == external-symbols  ==>
# (closure (f6274) () (let ((f6274 f6274)) ((primitive-ref error) ((primitive-ref list-ref) ((primitive-ref primitives)) f6274) "index out of bounds")))
# emit-expr (closure (f6274) () (let ((f6274 f6274)) ((primitive-ref error) ((primitive-ref list-ref) ((primitive-ref primitives)) f6274) "index out of bounds")))
# emit-closure
# si = 0
# env = ()
# expr = (closure (f6274) () (let ((f6274 f6274)) ((primitive-ref error) ((primitive-ref list-ref) ((primitive-ref primitives)) f6274) "index out of bounds")))
    movl $_L_38257, 0(%ebp)  # closure label
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $8, %ebp     # bump ebp
    jmp _L_38258            # jump around closure body
_L_38257:
# check argument count
    cmp $4,%eax
    je _L_38259
# invoke error handler eh_argcount
    .extern mrc_eh$uargcount
    movl mrc_eh$uargcount, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_38259:
# emit-tail-expr
# si=-12
# env=((f6274 . -8))
# expr=(let ((f6274 f6274)) ((primitive-ref error) ((primitive-ref list-ref) ((primitive-ref primitives)) f6274) "index out of bounds"))
# emit-tail-let
#  si   = -12
#  env  = ((f6274 . -8))
#  bindings = ((f6274 f6274))
#  body = ((primitive-ref error) ((primitive-ref list-ref) ((primitive-ref primitives)) f6274) "index out of bounds")
# emit-expr f6274
# emit-variable-ref
# env=((f6274 . -8))
# var=f6274
    movl -8(%esp), %eax  # stack load f6274
# end emit-variable-ref
    movl %eax, -12(%esp)  # stack save
# emit-tail-expr
# si=-16
# env=((f6274 . -12) (f6274 . -8))
# expr=((primitive-ref error) ((primitive-ref list-ref) ((primitive-ref primitives)) f6274) "index out of bounds")
# emit-tail-funcall
#    si   =-16
#    env  = ((f6274 . -12) (f6274 . -8))
#    expr = (funcall (primitive-ref error) ((primitive-ref list-ref) ((primitive-ref primitives)) f6274) "index out of bounds")
# emit-expr (primitive-ref error)
    .extern mrc_error
    movl mrc_error,%eax
   movl %eax,  -16(%esp)  # stash funcall-oper in next closure slot
# emit-expr ((primitive-ref list-ref) ((primitive-ref primitives)) f6274)
# funcall
#    si   =-20
#    env  = ((f6274 . -12) (f6274 . -8))
#    expr = (funcall (primitive-ref list-ref) ((primitive-ref primitives)) f6274)
# emit-expr (primitive-ref list-ref)
    .extern mrc_list$mref
    movl mrc_list$mref,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_38260"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_38260":
   movl %eax,  -28(%esp)  # stash funcall-oper in closure slot
# emit-expr ((primitive-ref primitives))
# funcall
#    si   =-32
#    env  = ((f6274 . -12) (f6274 . -8))
#    expr = (funcall (primitive-ref primitives))
# emit-expr (primitive-ref primitives)
    .extern mrc_primitives
    movl mrc_primitives,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_38261"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_38261":
   movl %eax,  -40(%esp)  # stash funcall-oper in closure slot
    movl -40(%esp), %edi   # load new closure to %edi
    add $-32, %esp   # adjust base
    movl $0,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $32, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    mov %eax, -32(%esp)  # arg ((primitive-ref primitives))
# emit-expr f6274
# emit-variable-ref
# env=((f6274 . -12) (f6274 . -8))
# var=f6274
    movl -12(%esp), %eax  # stack load f6274
# end emit-variable-ref
    mov %eax, -36(%esp)  # arg f6274
    movl -28(%esp), %edi   # load new closure to %edi
    add $-20, %esp   # adjust base
    movl $8,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $20, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    mov %eax, -20(%esp)    # arg ((primitive-ref list-ref) ((primitive-ref primitives)) f6274)
# emit-expr "index out of bounds"
# string literal
    jmp _L_38263
    .align 8,0x90
_L_38262 :
    .int 76
    .ascii "index out of bounds"
_L_38263:
    movl $_L_38262, %eax
    orl $6, %eax
    mov %eax, -24(%esp)    # arg index out of bounds
    movl -16(%esp), %edi   # load new closure to %edi
# emit-shift-args:  size=3   si=-16  delta=12
    mov -16(%esp), %ebx  # shift frame cell
    mov %ebx, -4(%esp)  # down to base
# emit-shift-args:  size=2   si=-20  delta=12
    mov -20(%esp), %ebx  # shift frame cell
    mov %ebx, -8(%esp)  # down to base
# emit-shift-args:  size=1   si=-24  delta=12
    mov -24(%esp), %ebx  # shift frame cell
    mov %ebx, -12(%esp)  # down to base
# emit-shift-args:  size=0   si=-28  delta=12
    movl $8,%eax   # save arg count
    jmp *-2(%edi)  # tail-funcall
    .align 4,0x90
_L_38258:
     movl %eax, mrc_eh$uvector$uindex
# == explicit-begins  ==>
# (lambda (i) (error (list-ref (primitives) i) "index out of bounds"))
# == eliminate-let*  ==>
# (lambda (i) (error (list-ref (primitives) i) "index out of bounds"))
# == uniquify-variables  ==>
# (lambda (f6275) (error (list-ref (primitives) f6275) "index out of bounds"))
# == vectorize-letrec  ==>
# (lambda (f6275) (error (list-ref (primitives) f6275) "index out of bounds"))
# == eliminate-set!  ==>
# (lambda (f6275) (let ((f6275 f6275)) (error (list-ref (primitives) f6275) "index out of bounds")))
# == close-free-variables  ==>
# (closure (f6275) () (let ((f6275 f6275)) (error (list-ref (primitives) f6275) "index out of bounds")))
# == eliminate-quote  ==>
# (closure (f6275) () (let ((f6275 f6275)) (error (list-ref (primitives) f6275) "index out of bounds")))
# == eliminate-when/unless  ==>
# (closure (f6275) () (let ((f6275 f6275)) (error (list-ref (primitives) f6275) "index out of bounds")))
# == eliminate-cond  ==>
# (closure (f6275) () (let ((f6275 f6275)) (error (list-ref (primitives) f6275) "index out of bounds")))
# == external-symbols  ==>
# (closure (f6275) () (let ((f6275 f6275)) ((primitive-ref error) ((primitive-ref list-ref) ((primitive-ref primitives)) f6275) "index out of bounds")))
# emit-expr (closure (f6275) () (let ((f6275 f6275)) ((primitive-ref error) ((primitive-ref list-ref) ((primitive-ref primitives)) f6275) "index out of bounds")))
# emit-closure
# si = 0
# env = ()
# expr = (closure (f6275) () (let ((f6275 f6275)) ((primitive-ref error) ((primitive-ref list-ref) ((primitive-ref primitives)) f6275) "index out of bounds")))
    movl $_L_38264, 0(%ebp)  # closure label
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $8, %ebp     # bump ebp
    jmp _L_38265            # jump around closure body
_L_38264:
# check argument count
    cmp $4,%eax
    je _L_38266
# invoke error handler eh_argcount
    .extern mrc_eh$uargcount
    movl mrc_eh$uargcount, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_38266:
# emit-tail-expr
# si=-12
# env=((f6275 . -8))
# expr=(let ((f6275 f6275)) ((primitive-ref error) ((primitive-ref list-ref) ((primitive-ref primitives)) f6275) "index out of bounds"))
# emit-tail-let
#  si   = -12
#  env  = ((f6275 . -8))
#  bindings = ((f6275 f6275))
#  body = ((primitive-ref error) ((primitive-ref list-ref) ((primitive-ref primitives)) f6275) "index out of bounds")
# emit-expr f6275
# emit-variable-ref
# env=((f6275 . -8))
# var=f6275
    movl -8(%esp), %eax  # stack load f6275
# end emit-variable-ref
    movl %eax, -12(%esp)  # stack save
# emit-tail-expr
# si=-16
# env=((f6275 . -12) (f6275 . -8))
# expr=((primitive-ref error) ((primitive-ref list-ref) ((primitive-ref primitives)) f6275) "index out of bounds")
# emit-tail-funcall
#    si   =-16
#    env  = ((f6275 . -12) (f6275 . -8))
#    expr = (funcall (primitive-ref error) ((primitive-ref list-ref) ((primitive-ref primitives)) f6275) "index out of bounds")
# emit-expr (primitive-ref error)
    .extern mrc_error
    movl mrc_error,%eax
   movl %eax,  -16(%esp)  # stash funcall-oper in next closure slot
# emit-expr ((primitive-ref list-ref) ((primitive-ref primitives)) f6275)
# funcall
#    si   =-20
#    env  = ((f6275 . -12) (f6275 . -8))
#    expr = (funcall (primitive-ref list-ref) ((primitive-ref primitives)) f6275)
# emit-expr (primitive-ref list-ref)
    .extern mrc_list$mref
    movl mrc_list$mref,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_38267"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_38267":
   movl %eax,  -28(%esp)  # stash funcall-oper in closure slot
# emit-expr ((primitive-ref primitives))
# funcall
#    si   =-32
#    env  = ((f6275 . -12) (f6275 . -8))
#    expr = (funcall (primitive-ref primitives))
# emit-expr (primitive-ref primitives)
    .extern mrc_primitives
    movl mrc_primitives,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_38268"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_38268":
   movl %eax,  -40(%esp)  # stash funcall-oper in closure slot
    movl -40(%esp), %edi   # load new closure to %edi
    add $-32, %esp   # adjust base
    movl $0,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $32, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    mov %eax, -32(%esp)  # arg ((primitive-ref primitives))
# emit-expr f6275
# emit-variable-ref
# env=((f6275 . -12) (f6275 . -8))
# var=f6275
    movl -12(%esp), %eax  # stack load f6275
# end emit-variable-ref
    mov %eax, -36(%esp)  # arg f6275
    movl -28(%esp), %edi   # load new closure to %edi
    add $-20, %esp   # adjust base
    movl $8,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $20, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    mov %eax, -20(%esp)    # arg ((primitive-ref list-ref) ((primitive-ref primitives)) f6275)
# emit-expr "index out of bounds"
# string literal
    jmp _L_38270
    .align 8,0x90
_L_38269 :
    .int 76
    .ascii "index out of bounds"
_L_38270:
    movl $_L_38269, %eax
    orl $6, %eax
    mov %eax, -24(%esp)    # arg index out of bounds
    movl -16(%esp), %edi   # load new closure to %edi
# emit-shift-args:  size=3   si=-16  delta=12
    mov -16(%esp), %ebx  # shift frame cell
    mov %ebx, -4(%esp)  # down to base
# emit-shift-args:  size=2   si=-20  delta=12
    mov -20(%esp), %ebx  # shift frame cell
    mov %ebx, -8(%esp)  # down to base
# emit-shift-args:  size=1   si=-24  delta=12
    mov -24(%esp), %ebx  # shift frame cell
    mov %ebx, -12(%esp)  # down to base
# emit-shift-args:  size=0   si=-28  delta=12
    movl $8,%eax   # save arg count
    jmp *-2(%edi)  # tail-funcall
    .align 4,0x90
_L_38265:
     movl %eax, mrc_eh$ustring$uindex
# == explicit-begins  ==>
# (lambda (z) (fxzero? z))
# == eliminate-let*  ==>
# (lambda (z) (fxzero? z))
# == uniquify-variables  ==>
# (lambda (f6276) (fxzero? f6276))
# == vectorize-letrec  ==>
# (lambda (f6276) (fxzero? f6276))
# == eliminate-set!  ==>
# (lambda (f6276) (let ((f6276 f6276)) (fxzero? f6276)))
# == close-free-variables  ==>
# (closure (f6276) () (let ((f6276 f6276)) (fxzero? f6276)))
# == eliminate-quote  ==>
# (closure (f6276) () (let ((f6276 f6276)) (fxzero? f6276)))
# == eliminate-when/unless  ==>
# (closure (f6276) () (let ((f6276 f6276)) (fxzero? f6276)))
# == eliminate-cond  ==>
# (closure (f6276) () (let ((f6276 f6276)) (fxzero? f6276)))
# == external-symbols  ==>
# (closure (f6276) () (let ((f6276 f6276)) (fxzero? f6276)))
# emit-expr (closure (f6276) () (let ((f6276 f6276)) (fxzero? f6276)))
# emit-closure
# si = 0
# env = ()
# expr = (closure (f6276) () (let ((f6276 f6276)) (fxzero? f6276)))
    movl $_L_38271, 0(%ebp)  # closure label
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $8, %ebp     # bump ebp
    jmp _L_38272            # jump around closure body
_L_38271:
# check argument count
    cmp $4,%eax
    je _L_38273
# invoke error handler eh_argcount
    .extern mrc_eh$uargcount
    movl mrc_eh$uargcount, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_38273:
# emit-tail-expr
# si=-12
# env=((f6276 . -8))
# expr=(let ((f6276 f6276)) (fxzero? f6276))
# emit-tail-let
#  si   = -12
#  env  = ((f6276 . -8))
#  bindings = ((f6276 f6276))
#  body = (fxzero? f6276)
# emit-expr f6276
# emit-variable-ref
# env=((f6276 . -8))
# var=f6276
    movl -8(%esp), %eax  # stack load f6276
# end emit-variable-ref
    movl %eax, -12(%esp)  # stack save
# emit-tail-expr
# si=-16
# env=((f6276 . -12) (f6276 . -8))
# expr=(fxzero? f6276)
# tail primcall
# emit-expr f6276
# emit-variable-ref
# env=((f6276 . -12) (f6276 . -8))
# var=f6276
    movl -12(%esp), %eax  # stack load f6276
# end emit-variable-ref
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_38274"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $64,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_38274:
    cmp $0, %eax
    sete %al
    movzbl %al, %eax
    sal $6, %al
    or $47, %al
#return from tail (fxzero? f6276)
    ret
    .align 4,0x90
_L_38272:
     movl %eax, mrc_zero$q
# == explicit-begins  ==>
# (lambda (x) (fx> x 0))
# == eliminate-let*  ==>
# (lambda (x) (fx> x 0))
# == uniquify-variables  ==>
# (lambda (f6277) (fx> f6277 0))
# == vectorize-letrec  ==>
# (lambda (f6277) (fx> f6277 0))
# == eliminate-set!  ==>
# (lambda (f6277) (let ((f6277 f6277)) (fx> f6277 0)))
# == close-free-variables  ==>
# (closure (f6277) () (let ((f6277 f6277)) (fx> f6277 0)))
# == eliminate-quote  ==>
# (closure (f6277) () (let ((f6277 f6277)) (fx> f6277 0)))
# == eliminate-when/unless  ==>
# (closure (f6277) () (let ((f6277 f6277)) (fx> f6277 0)))
# == eliminate-cond  ==>
# (closure (f6277) () (let ((f6277 f6277)) (fx> f6277 0)))
# == external-symbols  ==>
# (closure (f6277) () (let ((f6277 f6277)) (fx> f6277 0)))
# emit-expr (closure (f6277) () (let ((f6277 f6277)) (fx> f6277 0)))
# emit-closure
# si = 0
# env = ()
# expr = (closure (f6277) () (let ((f6277 f6277)) (fx> f6277 0)))
    movl $_L_38275, 0(%ebp)  # closure label
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $8, %ebp     # bump ebp
    jmp _L_38276            # jump around closure body
_L_38275:
# check argument count
    cmp $4,%eax
    je _L_38277
# invoke error handler eh_argcount
    .extern mrc_eh$uargcount
    movl mrc_eh$uargcount, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_38277:
# emit-tail-expr
# si=-12
# env=((f6277 . -8))
# expr=(let ((f6277 f6277)) (fx> f6277 0))
# emit-tail-let
#  si   = -12
#  env  = ((f6277 . -8))
#  bindings = ((f6277 f6277))
#  body = (fx> f6277 0)
# emit-expr f6277
# emit-variable-ref
# env=((f6277 . -8))
# var=f6277
    movl -8(%esp), %eax  # stack load f6277
# end emit-variable-ref
    movl %eax, -12(%esp)  # stack save
# emit-tail-expr
# si=-16
# env=((f6277 . -12) (f6277 . -8))
# expr=(fx> f6277 0)
# tail primcall
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_38278"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $80,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_38278:
    movl %eax, -16(%esp)
# emit-expr f6277
# emit-variable-ref
# env=((f6277 . -12) (f6277 . -8))
# var=f6277
    movl -12(%esp), %eax  # stack load f6277
# end emit-variable-ref
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_38279"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $80,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_38279:
    cmp -16(%esp), %eax
    setg %al
    movzbl %al, %eax
    sal $6, %al
    or $47, %al
#return from tail (fx> f6277 0)
    ret
    .align 4,0x90
_L_38276:
     movl %eax, mrc_positive$q
# == explicit-begins  ==>
# (lambda (x) (fx< x 0))
# == eliminate-let*  ==>
# (lambda (x) (fx< x 0))
# == uniquify-variables  ==>
# (lambda (f6278) (fx< f6278 0))
# == vectorize-letrec  ==>
# (lambda (f6278) (fx< f6278 0))
# == eliminate-set!  ==>
# (lambda (f6278) (let ((f6278 f6278)) (fx< f6278 0)))
# == close-free-variables  ==>
# (closure (f6278) () (let ((f6278 f6278)) (fx< f6278 0)))
# == eliminate-quote  ==>
# (closure (f6278) () (let ((f6278 f6278)) (fx< f6278 0)))
# == eliminate-when/unless  ==>
# (closure (f6278) () (let ((f6278 f6278)) (fx< f6278 0)))
# == eliminate-cond  ==>
# (closure (f6278) () (let ((f6278 f6278)) (fx< f6278 0)))
# == external-symbols  ==>
# (closure (f6278) () (let ((f6278 f6278)) (fx< f6278 0)))
# emit-expr (closure (f6278) () (let ((f6278 f6278)) (fx< f6278 0)))
# emit-closure
# si = 0
# env = ()
# expr = (closure (f6278) () (let ((f6278 f6278)) (fx< f6278 0)))
    movl $_L_38280, 0(%ebp)  # closure label
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $8, %ebp     # bump ebp
    jmp _L_38281            # jump around closure body
_L_38280:
# check argument count
    cmp $4,%eax
    je _L_38282
# invoke error handler eh_argcount
    .extern mrc_eh$uargcount
    movl mrc_eh$uargcount, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_38282:
# emit-tail-expr
# si=-12
# env=((f6278 . -8))
# expr=(let ((f6278 f6278)) (fx< f6278 0))
# emit-tail-let
#  si   = -12
#  env  = ((f6278 . -8))
#  bindings = ((f6278 f6278))
#  body = (fx< f6278 0)
# emit-expr f6278
# emit-variable-ref
# env=((f6278 . -8))
# var=f6278
    movl -8(%esp), %eax  # stack load f6278
# end emit-variable-ref
    movl %eax, -12(%esp)  # stack save
# emit-tail-expr
# si=-16
# env=((f6278 . -12) (f6278 . -8))
# expr=(fx< f6278 0)
# tail primcall
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_38283"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $72,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_38283:
    movl %eax, -16(%esp)
# emit-expr f6278
# emit-variable-ref
# env=((f6278 . -12) (f6278 . -8))
# var=f6278
    movl -12(%esp), %eax  # stack load f6278
# end emit-variable-ref
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_38284"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $72,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_38284:
    cmp -16(%esp), %eax
    setl %al
    movzbl %al, %eax
    sal $6, %al
    or $47, %al
#return from tail (fx< f6278 0)
    ret
    .align 4,0x90
_L_38281:
     movl %eax, mrc_negative$q
# == explicit-begins  ==>
# (lambda (x) (fxzero? (fxremainder x 2)))
# == eliminate-let*  ==>
# (lambda (x) (fxzero? (fxremainder x 2)))
# == uniquify-variables  ==>
# (lambda (f6279) (fxzero? (fxremainder f6279 2)))
# == vectorize-letrec  ==>
# (lambda (f6279) (fxzero? (fxremainder f6279 2)))
# == eliminate-set!  ==>
# (lambda (f6279) (let ((f6279 f6279)) (fxzero? (fxremainder f6279 2))))
# == close-free-variables  ==>
# (closure (f6279) () (let ((f6279 f6279)) (fxzero? (fxremainder f6279 2))))
# == eliminate-quote  ==>
# (closure (f6279) () (let ((f6279 f6279)) (fxzero? (fxremainder f6279 2))))
# == eliminate-when/unless  ==>
# (closure (f6279) () (let ((f6279 f6279)) (fxzero? (fxremainder f6279 2))))
# == eliminate-cond  ==>
# (closure (f6279) () (let ((f6279 f6279)) (fxzero? (fxremainder f6279 2))))
# == external-symbols  ==>
# (closure (f6279) () (let ((f6279 f6279)) (fxzero? (fxremainder f6279 2))))
# emit-expr (closure (f6279) () (let ((f6279 f6279)) (fxzero? (fxremainder f6279 2))))
# emit-closure
# si = 0
# env = ()
# expr = (closure (f6279) () (let ((f6279 f6279)) (fxzero? (fxremainder f6279 2))))
    movl $_L_38285, 0(%ebp)  # closure label
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $8, %ebp     # bump ebp
    jmp _L_38286            # jump around closure body
_L_38285:
# check argument count
    cmp $4,%eax
    je _L_38287
# invoke error handler eh_argcount
    .extern mrc_eh$uargcount
    movl mrc_eh$uargcount, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_38287:
# emit-tail-expr
# si=-12
# env=((f6279 . -8))
# expr=(let ((f6279 f6279)) (fxzero? (fxremainder f6279 2)))
# emit-tail-let
#  si   = -12
#  env  = ((f6279 . -8))
#  bindings = ((f6279 f6279))
#  body = (fxzero? (fxremainder f6279 2))
# emit-expr f6279
# emit-variable-ref
# env=((f6279 . -8))
# var=f6279
    movl -8(%esp), %eax  # stack load f6279
# end emit-variable-ref
    movl %eax, -12(%esp)  # stack save
# emit-tail-expr
# si=-16
# env=((f6279 . -12) (f6279 . -8))
# expr=(fxzero? (fxremainder f6279 2))
# tail primcall
# emit-expr (fxremainder f6279 2)
# emit-expr 2
    movl $8, %eax     # immed 2
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_38289"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $100,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_38289:
    movl %eax, -16(%esp)  # denominator
# emit-expr f6279
# emit-variable-ref
# env=((f6279 . -12) (f6279 . -8))
# var=f6279
    movl -12(%esp), %eax  # stack load f6279
# end emit-variable-ref
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_38290"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $100,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_38290:
    movl -16(%esp),%ebx   # ebx <- denominator
    xor %edx,%edx        # edx <- 0
    cmp $0,%eax
    jge _L_38288
    not %edx
_L_38288:
    idiv %ebx            # edx <- edx:eax/ebx  remainder
    movl %edx,%eax
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_38291"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $64,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_38291:
    cmp $0, %eax
    sete %al
    movzbl %al, %eax
    sal $6, %al
    or $47, %al
#return from tail (fxzero? (fxremainder f6279 2))
    ret
    .align 4,0x90
_L_38286:
     movl %eax, mrc_even$q
# == explicit-begins  ==>
# (lambda (x) (not (even? x)))
# == eliminate-let*  ==>
# (lambda (x) (not (even? x)))
# == uniquify-variables  ==>
# (lambda (f6280) (not (even? f6280)))
# == vectorize-letrec  ==>
# (lambda (f6280) (not (even? f6280)))
# == eliminate-set!  ==>
# (lambda (f6280) (let ((f6280 f6280)) (not (even? f6280))))
# == close-free-variables  ==>
# (closure (f6280) () (let ((f6280 f6280)) (not (even? f6280))))
# == eliminate-quote  ==>
# (closure (f6280) () (let ((f6280 f6280)) (not (even? f6280))))
# == eliminate-when/unless  ==>
# (closure (f6280) () (let ((f6280 f6280)) (not (even? f6280))))
# == eliminate-cond  ==>
# (closure (f6280) () (let ((f6280 f6280)) (not (even? f6280))))
# == external-symbols  ==>
# (closure (f6280) () (let ((f6280 f6280)) (not ((primitive-ref even?) f6280))))
# emit-expr (closure (f6280) () (let ((f6280 f6280)) (not ((primitive-ref even?) f6280))))
# emit-closure
# si = 0
# env = ()
# expr = (closure (f6280) () (let ((f6280 f6280)) (not ((primitive-ref even?) f6280))))
    movl $_L_38292, 0(%ebp)  # closure label
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $8, %ebp     # bump ebp
    jmp _L_38293            # jump around closure body
_L_38292:
# check argument count
    cmp $4,%eax
    je _L_38294
# invoke error handler eh_argcount
    .extern mrc_eh$uargcount
    movl mrc_eh$uargcount, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_38294:
# emit-tail-expr
# si=-12
# env=((f6280 . -8))
# expr=(let ((f6280 f6280)) (not ((primitive-ref even?) f6280)))
# emit-tail-let
#  si   = -12
#  env  = ((f6280 . -8))
#  bindings = ((f6280 f6280))
#  body = (not ((primitive-ref even?) f6280))
# emit-expr f6280
# emit-variable-ref
# env=((f6280 . -8))
# var=f6280
    movl -8(%esp), %eax  # stack load f6280
# end emit-variable-ref
    movl %eax, -12(%esp)  # stack save
# emit-tail-expr
# si=-16
# env=((f6280 . -12) (f6280 . -8))
# expr=(not ((primitive-ref even?) f6280))
# tail primcall
# emit-expr ((primitive-ref even?) f6280)
# funcall
#    si   =-16
#    env  = ((f6280 . -12) (f6280 . -8))
#    expr = (funcall (primitive-ref even?) f6280)
# emit-expr (primitive-ref even?)
    .extern mrc_even$q
    movl mrc_even$q,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_38295"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_38295":
   movl %eax,  -24(%esp)  # stash funcall-oper in closure slot
# emit-expr f6280
# emit-variable-ref
# env=((f6280 . -12) (f6280 . -8))
# var=f6280
    movl -12(%esp), %eax  # stack load f6280
# end emit-variable-ref
    mov %eax, -28(%esp)  # arg f6280
    movl -24(%esp), %edi   # load new closure to %edi
    add $-16, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $16, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    cmp $47, %eax
    sete %al
    movzbl %al, %eax
    sal $6, %al
    or $47, %al
#return from tail (not ((primitive-ref even?) f6280))
    ret
    .align 4,0x90
_L_38293:
     movl %eax, mrc_odd$q
# == explicit-begins  ==>
# (lambda (f l) (if (null? l) (quote ()) (cons (f (car l)) (map f (cdr l)))))
# == eliminate-let*  ==>
# (lambda (f l) (if (null? l) (quote ()) (cons (f (car l)) (map f (cdr l)))))
# == uniquify-variables  ==>
# (lambda (f6281 f6282) (if (null? f6282) (quote ()) (cons (f6281 (car f6282)) (map f6281 (cdr f6282)))))
# == vectorize-letrec  ==>
# (lambda (f6281 f6282) (if (null? f6282) (quote ()) (cons (f6281 (car f6282)) (map f6281 (cdr f6282)))))
# == eliminate-set!  ==>
# (lambda (f6281 f6282) (let ((f6281 f6281) (f6282 f6282)) (if (null? f6282) (quote ()) (cons (f6281 (car f6282)) (map f6281 (cdr f6282))))))
# == close-free-variables  ==>
# (closure (f6281 f6282) () (let ((f6281 f6281) (f6282 f6282)) (if (null? f6282) (quote ()) (cons (f6281 (car f6282)) (map f6281 (cdr f6282))))))
# == eliminate-quote  ==>
# (closure (f6281 f6282) () (let ((f6281 f6281) (f6282 f6282)) (if (null? f6282) () (cons (f6281 (car f6282)) (map f6281 (cdr f6282))))))
# == eliminate-when/unless  ==>
# (closure (f6281 f6282) () (let ((f6281 f6281) (f6282 f6282)) (if (null? f6282) () (cons (f6281 (car f6282)) (map f6281 (cdr f6282))))))
# == eliminate-cond  ==>
# (closure (f6281 f6282) () (let ((f6281 f6281) (f6282 f6282)) (if (null? f6282) () (cons (f6281 (car f6282)) (map f6281 (cdr f6282))))))
# == external-symbols  ==>
# (closure (f6281 f6282) () (let ((f6281 f6281) (f6282 f6282)) (if (null? f6282) () (cons (f6281 (car f6282)) ((primitive-ref map) f6281 (cdr f6282))))))
# emit-expr (closure (f6281 f6282) () (let ((f6281 f6281) (f6282 f6282)) (if (null? f6282) () (cons (f6281 (car f6282)) ((primitive-ref map) f6281 (cdr f6282))))))
# emit-closure
# si = 0
# env = ()
# expr = (closure (f6281 f6282) () (let ((f6281 f6281) (f6282 f6282)) (if (null? f6282) () (cons (f6281 (car f6282)) ((primitive-ref map) f6281 (cdr f6282))))))
    movl $_L_38296, 0(%ebp)  # closure label
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $8, %ebp     # bump ebp
    jmp _L_38297            # jump around closure body
_L_38296:
# check argument count
    cmp $8,%eax
    je _L_38298
# invoke error handler eh_argcount
    .extern mrc_eh$uargcount
    movl mrc_eh$uargcount, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_38298:
# emit-tail-expr
# si=-16
# env=((f6282 . -12) (f6281 . -8))
# expr=(let ((f6281 f6281) (f6282 f6282)) (if (null? f6282) () (cons (f6281 (car f6282)) ((primitive-ref map) f6281 (cdr f6282)))))
# emit-tail-let
#  si   = -16
#  env  = ((f6282 . -12) (f6281 . -8))
#  bindings = ((f6281 f6281) (f6282 f6282))
#  body = (if (null? f6282) () (cons (f6281 (car f6282)) ((primitive-ref map) f6281 (cdr f6282))))
# emit-expr f6281
# emit-variable-ref
# env=((f6282 . -12) (f6281 . -8))
# var=f6281
    movl -8(%esp), %eax  # stack load f6281
# end emit-variable-ref
    movl %eax, -16(%esp)  # stack save
# emit-expr f6282
# emit-variable-ref
# env=((f6282 . -12) (f6281 . -8))
# var=f6282
    movl -12(%esp), %eax  # stack load f6282
# end emit-variable-ref
    movl %eax, -20(%esp)  # stack save
# emit-tail-expr
# si=-24
# env=((f6282 . -20) (f6281 . -16) (f6282 . -12) (f6281 . -8))
# expr=(if (null? f6282) () (cons (f6281 (car f6282)) ((primitive-ref map) f6281 (cdr f6282))))
# emit-expr (null? f6282)
# emit-expr f6282
# emit-variable-ref
# env=((f6282 . -20) (f6281 . -16) (f6282 . -12) (f6281 . -8))
# var=f6282
    movl -20(%esp), %eax  # stack load f6282
# end emit-variable-ref
    cmp $63, %eax
    mov $0, %eax
    sete %al
    movzbl %al, %eax
    sal $6, %al
    or $47, %al
    cmp $47, %al
    je _L_38299
# emit-tail-expr
# si=-24
# env=((f6282 . -20) (f6281 . -16) (f6282 . -12) (f6281 . -8))
# expr=()
    movl $63, %eax     # immed ()
    ret                  # immediate tail return
    jmp _L_38300
_L_38299:
# emit-tail-expr
# si=-24
# env=((f6282 . -20) (f6281 . -16) (f6282 . -12) (f6281 . -8))
# expr=(cons (f6281 (car f6282)) ((primitive-ref map) f6281 (cdr f6282)))
# tail primcall
# cons arg1=(f6281 (car f6282)) arg2=((primitive-ref map) f6281 (cdr f6282))
# emit-expr (f6281 (car f6282))
# funcall
#    si   =-24
#    env  = ((f6282 . -20) (f6281 . -16) (f6282 . -12) (f6281 . -8))
#    expr = (funcall f6281 (car f6282))
# emit-expr f6281
# emit-variable-ref
# env=((f6282 . -20) (f6281 . -16) (f6282 . -12) (f6281 . -8))
# var=f6281
    movl -16(%esp), %eax  # stack load f6281
# end emit-variable-ref
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_38301"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_38301":
   movl %eax,  -32(%esp)  # stash funcall-oper in closure slot
# emit-expr (car f6282)
# emit-expr f6282
# emit-variable-ref
# env=((f6282 . -20) (f6281 . -16) (f6282 . -12) (f6281 . -8))
# var=f6282
    movl -20(%esp), %eax  # stack load f6282
# end emit-variable-ref
# check the argument is a pair
    movl %eax,%ebx
    and $7, %bl
    cmp $1, %bl
    je _L_38302
# invoke error handler eh_pair
    .extern mrc_eh$upair
    movl mrc_eh$upair, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $116,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_38302:
    movl -1(%eax), %eax
    mov %eax, -36(%esp)  # arg (car f6282)
    movl -32(%esp), %edi   # load new closure to %edi
    add $-24, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $24, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    movl %eax, -24(%esp)
# emit-expr ((primitive-ref map) f6281 (cdr f6282))
# funcall
#    si   =-28
#    env  = ((f6282 . -20) (f6281 . -16) (f6282 . -12) (f6281 . -8))
#    expr = (funcall (primitive-ref map) f6281 (cdr f6282))
# emit-expr (primitive-ref map)
    .extern mrc_map
    movl mrc_map,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_38303"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_38303":
   movl %eax,  -36(%esp)  # stash funcall-oper in closure slot
# emit-expr f6281
# emit-variable-ref
# env=((f6282 . -20) (f6281 . -16) (f6282 . -12) (f6281 . -8))
# var=f6281
    movl -16(%esp), %eax  # stack load f6281
# end emit-variable-ref
    mov %eax, -40(%esp)  # arg f6281
# emit-expr (cdr f6282)
# emit-expr f6282
# emit-variable-ref
# env=((f6282 . -20) (f6281 . -16) (f6282 . -12) (f6281 . -8))
# var=f6282
    movl -20(%esp), %eax  # stack load f6282
# end emit-variable-ref
# check the argument is a pair
    movl %eax,%ebx
    and $7, %bl
    cmp $1, %bl
    je _L_38304
# invoke error handler eh_pair
    .extern mrc_eh$upair
    movl mrc_eh$upair, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $120,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_38304:
    movl 3(%eax), %eax
    mov %eax, -44(%esp)  # arg (cdr f6282)
    movl -36(%esp), %edi   # load new closure to %edi
    add $-28, %esp   # adjust base
    movl $8,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $28, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    movl %eax, 4(%ebp)
    movl -24(%esp), %eax
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    or   $1, %al
    add  $8, %ebp
# cons end
#return from tail (cons (f6281 (car f6282)) ((primitive-ref map) f6281 (cdr f6282)))
    ret
_L_38300:
    .align 4,0x90
_L_38297:
     movl %eax, mrc_map
# == explicit-begins  ==>
# (lambda (f l) (unless (null? l) (begin (f (car l)) (for-each f (cdr l)))))
# == eliminate-let*  ==>
# (lambda (f l) (unless (null? l) (begin (f (car l)) (for-each f (cdr l)))))
# == uniquify-variables  ==>
# (lambda (f6283 f6284) (unless (null? f6284) (begin (f6283 (car f6284)) (for-each f6283 (cdr f6284)))))
# == vectorize-letrec  ==>
# (lambda (f6283 f6284) (unless (null? f6284) (begin (f6283 (car f6284)) (for-each f6283 (cdr f6284)))))
# == eliminate-set!  ==>
# (lambda (f6283 f6284) (let ((f6283 f6283) (f6284 f6284)) (unless (null? f6284) (begin (f6283 (car f6284)) (for-each f6283 (cdr f6284))))))
# == close-free-variables  ==>
# (closure (f6283 f6284) () (let ((f6283 f6283) (f6284 f6284)) (unless (null? f6284) (begin (f6283 (car f6284)) (for-each f6283 (cdr f6284))))))
# == eliminate-quote  ==>
# (closure (f6283 f6284) () (let ((f6283 f6283) (f6284 f6284)) (unless (null? f6284) (begin (f6283 (car f6284)) (for-each f6283 (cdr f6284))))))
# == eliminate-when/unless  ==>
# (closure (f6283 f6284) () (let ((f6283 f6283) (f6284 f6284)) (if (not (null? f6284)) (begin (begin (f6283 (car f6284)) (for-each f6283 (cdr f6284)))) #f)))
# == eliminate-cond  ==>
# (closure (f6283 f6284) () (let ((f6283 f6283) (f6284 f6284)) (if (not (null? f6284)) (begin (begin (f6283 (car f6284)) (for-each f6283 (cdr f6284)))) #f)))
# == external-symbols  ==>
# (closure (f6283 f6284) () (let ((f6283 f6283) (f6284 f6284)) (if (not (null? f6284)) (begin (begin (f6283 (car f6284)) ((primitive-ref for-each) f6283 (cdr f6284)))) #f)))
# emit-expr (closure (f6283 f6284) () (let ((f6283 f6283) (f6284 f6284)) (if (not (null? f6284)) (begin (begin (f6283 (car f6284)) ((primitive-ref for-each) f6283 (cdr f6284)))) #f)))
# emit-closure
# si = 0
# env = ()
# expr = (closure (f6283 f6284) () (let ((f6283 f6283) (f6284 f6284)) (if (not (null? f6284)) (begin (begin (f6283 (car f6284)) ((primitive-ref for-each) f6283 (cdr f6284)))) #f)))
    movl $_L_38305, 0(%ebp)  # closure label
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $8, %ebp     # bump ebp
    jmp _L_38306            # jump around closure body
_L_38305:
# check argument count
    cmp $8,%eax
    je _L_38307
# invoke error handler eh_argcount
    .extern mrc_eh$uargcount
    movl mrc_eh$uargcount, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_38307:
# emit-tail-expr
# si=-16
# env=((f6284 . -12) (f6283 . -8))
# expr=(let ((f6283 f6283) (f6284 f6284)) (if (not (null? f6284)) (begin (begin (f6283 (car f6284)) ((primitive-ref for-each) f6283 (cdr f6284)))) #f))
# emit-tail-let
#  si   = -16
#  env  = ((f6284 . -12) (f6283 . -8))
#  bindings = ((f6283 f6283) (f6284 f6284))
#  body = (if (not (null? f6284)) (begin (begin (f6283 (car f6284)) ((primitive-ref for-each) f6283 (cdr f6284)))) #f)
# emit-expr f6283
# emit-variable-ref
# env=((f6284 . -12) (f6283 . -8))
# var=f6283
    movl -8(%esp), %eax  # stack load f6283
# end emit-variable-ref
    movl %eax, -16(%esp)  # stack save
# emit-expr f6284
# emit-variable-ref
# env=((f6284 . -12) (f6283 . -8))
# var=f6284
    movl -12(%esp), %eax  # stack load f6284
# end emit-variable-ref
    movl %eax, -20(%esp)  # stack save
# emit-tail-expr
# si=-24
# env=((f6284 . -20) (f6283 . -16) (f6284 . -12) (f6283 . -8))
# expr=(if (not (null? f6284)) (begin (begin (f6283 (car f6284)) ((primitive-ref for-each) f6283 (cdr f6284)))) #f)
# emit-expr (not (null? f6284))
# emit-expr (null? f6284)
# emit-expr f6284
# emit-variable-ref
# env=((f6284 . -20) (f6283 . -16) (f6284 . -12) (f6283 . -8))
# var=f6284
    movl -20(%esp), %eax  # stack load f6284
# end emit-variable-ref
    cmp $63, %eax
    mov $0, %eax
    sete %al
    movzbl %al, %eax
    sal $6, %al
    or $47, %al
    cmp $47, %eax
    sete %al
    movzbl %al, %eax
    sal $6, %al
    or $47, %al
    cmp $47, %al
    je _L_38308
# emit-tail-expr
# si=-24
# env=((f6284 . -20) (f6283 . -16) (f6284 . -12) (f6283 . -8))
# expr=(begin (begin (f6283 (car f6284)) ((primitive-ref for-each) f6283 (cdr f6284))))
# tail-begin (begin (begin (f6283 (car f6284)) ((primitive-ref for-each) f6283 (cdr f6284))))
#   env=((f6284 . -20) (f6283 . -16) (f6284 . -12) (f6283 . -8))
# emit-tail-expr
# si=-24
# env=((f6284 . -20) (f6283 . -16) (f6284 . -12) (f6283 . -8))
# expr=(begin (f6283 (car f6284)) ((primitive-ref for-each) f6283 (cdr f6284)))
# tail-begin (begin (f6283 (car f6284)) ((primitive-ref for-each) f6283 (cdr f6284)))
#   env=((f6284 . -20) (f6283 . -16) (f6284 . -12) (f6283 . -8))
# emit-expr (f6283 (car f6284))
# funcall
#    si   =-24
#    env  = ((f6284 . -20) (f6283 . -16) (f6284 . -12) (f6283 . -8))
#    expr = (funcall f6283 (car f6284))
# emit-expr f6283
# emit-variable-ref
# env=((f6284 . -20) (f6283 . -16) (f6284 . -12) (f6283 . -8))
# var=f6283
    movl -16(%esp), %eax  # stack load f6283
# end emit-variable-ref
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_38310"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_38310":
   movl %eax,  -32(%esp)  # stash funcall-oper in closure slot
# emit-expr (car f6284)
# emit-expr f6284
# emit-variable-ref
# env=((f6284 . -20) (f6283 . -16) (f6284 . -12) (f6283 . -8))
# var=f6284
    movl -20(%esp), %eax  # stack load f6284
# end emit-variable-ref
# check the argument is a pair
    movl %eax,%ebx
    and $7, %bl
    cmp $1, %bl
    je _L_38311
# invoke error handler eh_pair
    .extern mrc_eh$upair
    movl mrc_eh$upair, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $116,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_38311:
    movl -1(%eax), %eax
    mov %eax, -36(%esp)  # arg (car f6284)
    movl -32(%esp), %edi   # load new closure to %edi
    add $-24, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $24, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
# emit-tail-expr
# si=-24
# env=((f6284 . -20) (f6283 . -16) (f6284 . -12) (f6283 . -8))
# expr=(begin ((primitive-ref for-each) f6283 (cdr f6284)))
# tail-begin (begin ((primitive-ref for-each) f6283 (cdr f6284)))
#   env=((f6284 . -20) (f6283 . -16) (f6284 . -12) (f6283 . -8))
# emit-tail-expr
# si=-24
# env=((f6284 . -20) (f6283 . -16) (f6284 . -12) (f6283 . -8))
# expr=((primitive-ref for-each) f6283 (cdr f6284))
# emit-tail-funcall
#    si   =-24
#    env  = ((f6284 . -20) (f6283 . -16) (f6284 . -12) (f6283 . -8))
#    expr = (funcall (primitive-ref for-each) f6283 (cdr f6284))
# emit-expr (primitive-ref for-each)
    .extern mrc_for$meach
    movl mrc_for$meach,%eax
   movl %eax,  -24(%esp)  # stash funcall-oper in next closure slot
# emit-expr f6283
# emit-variable-ref
# env=((f6284 . -20) (f6283 . -16) (f6284 . -12) (f6283 . -8))
# var=f6283
    movl -16(%esp), %eax  # stack load f6283
# end emit-variable-ref
    mov %eax, -28(%esp)    # arg f6283
# emit-expr (cdr f6284)
# emit-expr f6284
# emit-variable-ref
# env=((f6284 . -20) (f6283 . -16) (f6284 . -12) (f6283 . -8))
# var=f6284
    movl -20(%esp), %eax  # stack load f6284
# end emit-variable-ref
# check the argument is a pair
    movl %eax,%ebx
    and $7, %bl
    cmp $1, %bl
    je _L_38312
# invoke error handler eh_pair
    .extern mrc_eh$upair
    movl mrc_eh$upair, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $120,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_38312:
    movl 3(%eax), %eax
    mov %eax, -32(%esp)    # arg (cdr f6284)
    movl -24(%esp), %edi   # load new closure to %edi
# emit-shift-args:  size=3   si=-24  delta=20
    mov -24(%esp), %ebx  # shift frame cell
    mov %ebx, -4(%esp)  # down to base
# emit-shift-args:  size=2   si=-28  delta=20
    mov -28(%esp), %ebx  # shift frame cell
    mov %ebx, -8(%esp)  # down to base
# emit-shift-args:  size=1   si=-32  delta=20
    mov -32(%esp), %ebx  # shift frame cell
    mov %ebx, -12(%esp)  # down to base
# emit-shift-args:  size=0   si=-36  delta=20
    movl $8,%eax   # save arg count
    jmp *-2(%edi)  # tail-funcall
     ret   # return thru stack
     ret   # return thru stack
    jmp _L_38309
_L_38308:
# emit-tail-expr
# si=-24
# env=((f6284 . -20) (f6283 . -16) (f6284 . -12) (f6283 . -8))
# expr=#f
    movl $47, %eax     # immed #f
    ret                  # immediate tail return
_L_38309:
    .align 4,0x90
_L_38306:
     movl %eax, mrc_for$meach
# == explicit-begins  ==>
# (let ((p (make-vector 6)) (sz 1024)) (begin (vector-set! p 0 (quote output-port)) (vector-set! p 1 "/dev/stdout") (vector-set! p 2 1) (vector-set! p 3 (make-string sz)) (vector-set! p 4 0) (vector-set! p 5 sz) p))
# == eliminate-let*  ==>
# (let ((p (make-vector 6)) (sz 1024)) (begin (vector-set! p 0 (quote output-port)) (vector-set! p 1 "/dev/stdout") (vector-set! p 2 1) (vector-set! p 3 (make-string sz)) (vector-set! p 4 0) (vector-set! p 5 sz) p))
# == uniquify-variables  ==>
# (let ((f6286 (make-vector 6)) (f6285 1024)) (begin (vector-set! f6286 0 (quote output-port)) (vector-set! f6286 1 "/dev/stdout") (vector-set! f6286 2 1) (vector-set! f6286 3 (make-string f6285)) (vector-set! f6286 4 0) (vector-set! f6286 5 f6285) f6286))
# == vectorize-letrec  ==>
# (let ((f6286 (make-vector 6)) (f6285 1024)) (begin (vector-set! f6286 0 (quote output-port)) (vector-set! f6286 1 "/dev/stdout") (vector-set! f6286 2 1) (vector-set! f6286 3 (make-string f6285)) (vector-set! f6286 4 0) (vector-set! f6286 5 f6285) f6286))
# == eliminate-set!  ==>
# (let ((f6286 (make-vector 6)) (f6285 1024)) (begin (vector-set! f6286 0 (quote output-port)) (vector-set! f6286 1 "/dev/stdout") (vector-set! f6286 2 1) (vector-set! f6286 3 (make-string f6285)) (vector-set! f6286 4 0) (vector-set! f6286 5 f6285) f6286))
# == close-free-variables  ==>
# (let ((f6286 (make-vector 6)) (f6285 1024)) (begin (vector-set! f6286 0 (quote output-port)) (vector-set! f6286 1 "/dev/stdout") (vector-set! f6286 2 1) (vector-set! f6286 3 (make-string f6285)) (vector-set! f6286 4 0) (vector-set! f6286 5 f6285) f6286))
# == eliminate-quote  ==>
# (let ((f6286 (make-vector 6)) (f6285 1024)) (begin (vector-set! f6286 0 (string->symbol "output-port")) (vector-set! f6286 1 "/dev/stdout") (vector-set! f6286 2 1) (vector-set! f6286 3 (make-string f6285)) (vector-set! f6286 4 0) (vector-set! f6286 5 f6285) f6286))
# == eliminate-when/unless  ==>
# (let ((f6286 (make-vector 6)) (f6285 1024)) (begin (vector-set! f6286 0 (string->symbol "output-port")) (vector-set! f6286 1 "/dev/stdout") (vector-set! f6286 2 1) (vector-set! f6286 3 (make-string f6285)) (vector-set! f6286 4 0) (vector-set! f6286 5 f6285) f6286))
# == eliminate-cond  ==>
# (let ((f6286 (make-vector 6)) (f6285 1024)) (begin (vector-set! f6286 0 (string->symbol "output-port")) (vector-set! f6286 1 "/dev/stdout") (vector-set! f6286 2 1) (vector-set! f6286 3 (make-string f6285)) (vector-set! f6286 4 0) (vector-set! f6286 5 f6285) f6286))
# == external-symbols  ==>
# (let ((f6286 (make-vector 6)) (f6285 1024)) (begin (vector-set! f6286 0 ((primitive-ref string->symbol) "output-port")) (vector-set! f6286 1 "/dev/stdout") (vector-set! f6286 2 1) (vector-set! f6286 3 (make-string f6285)) (vector-set! f6286 4 0) (vector-set! f6286 5 f6285) f6286))
# emit-expr (let ((f6286 (make-vector 6)) (f6285 1024)) (begin (vector-set! f6286 0 ((primitive-ref string->symbol) "output-port")) (vector-set! f6286 1 "/dev/stdout") (vector-set! f6286 2 1) (vector-set! f6286 3 (make-string f6285)) (vector-set! f6286 4 0) (vector-set! f6286 5 f6285) f6286))
# emit-let
#  si   = 0
#  env  = ()
#  bindings = ((f6286 (make-vector 6)) (f6285 1024))
#  body = (begin (vector-set! f6286 0 ((primitive-ref string->symbol) "output-port")) (vector-set! f6286 1 "/dev/stdout") (vector-set! f6286 2 1) (vector-set! f6286 3 (make-string f6285)) (vector-set! f6286 4 0) (vector-set! f6286 5 f6285) f6286)
# emit-expr (make-vector 6)
# make-vector 6
# emit-expr 6
    movl $24, %eax     # immed 6
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_38313"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_38313:
# check the argument is a fixnum >= 0
    cmp $0,%eax
    jge _L_38314
# invoke error handler eh_length
    .extern mrc_eh$ulength
    movl mrc_eh$ulength, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_38314:
    movl %eax, %esi
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    orl  $5, %eax
    addl $4, %esi
    addl $4, %esi
    andl $-8, %esi
    addl %esi, %ebp
    movl %eax, 0(%esp)  # stack save
# emit-expr 1024
    movl $4096, %eax     # immed 1024
    movl %eax, -4(%esp)  # stack save
# emit-expr (begin (vector-set! f6286 0 ((primitive-ref string->symbol) "output-port")) (vector-set! f6286 1 "/dev/stdout") (vector-set! f6286 2 1) (vector-set! f6286 3 (make-string f6285)) (vector-set! f6286 4 0) (vector-set! f6286 5 f6285) f6286)
# emit-begin
#   expr=(begin (vector-set! f6286 0 ((primitive-ref string->symbol) "output-port")) (vector-set! f6286 1 "/dev/stdout") (vector-set! f6286 2 1) (vector-set! f6286 3 (make-string f6285)) (vector-set! f6286 4 0) (vector-set! f6286 5 f6285) f6286)
#   env=((f6285 . -4) (f6286 . 0))
# emit-expr (vector-set! f6286 0 ((primitive-ref string->symbol) "output-port"))
# emit-expr f6286
# emit-variable-ref
# env=((f6285 . -4) (f6286 . 0))
# var=f6286
    movl 0(%esp), %eax  # stack load f6286
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_38315
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_38315:
    movl %eax, -8(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_38316"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_38316:
# check bounds on vector index
    movl -8(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_38318
    cmp  $0,%eax
    jge _L_38317
_L_38318:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_38317:
    movl %eax, -12(%esp)
# emit-expr ((primitive-ref string->symbol) "output-port")
# funcall
#    si   =-16
#    env  = ((f6285 . -4) (f6286 . 0))
#    expr = (funcall (primitive-ref string->symbol) "output-port")
# emit-expr (primitive-ref string->symbol)
    .extern mrc_string$m$gsymbol
    movl mrc_string$m$gsymbol,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_38319"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_38319":
   movl %eax,  -24(%esp)  # stash funcall-oper in closure slot
# emit-expr "output-port"
# string literal
    jmp _L_38321
    .align 8,0x90
_L_38320 :
    .int 44
    .ascii "output-port"
_L_38321:
    movl $_L_38320, %eax
    orl $6, %eax
    mov %eax, -28(%esp)  # arg output-port
    movl -24(%esp), %edi   # load new closure to %edi
    add $-16, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $16, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    movl -8(%esp), %ebx
    movl -12(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin (vector-set! f6286 1 "/dev/stdout") (vector-set! f6286 2 1) (vector-set! f6286 3 (make-string f6285)) (vector-set! f6286 4 0) (vector-set! f6286 5 f6285) f6286)
# emit-begin
#   expr=(begin (vector-set! f6286 1 "/dev/stdout") (vector-set! f6286 2 1) (vector-set! f6286 3 (make-string f6285)) (vector-set! f6286 4 0) (vector-set! f6286 5 f6285) f6286)
#   env=((f6285 . -4) (f6286 . 0))
# emit-expr (vector-set! f6286 1 "/dev/stdout")
# emit-expr f6286
# emit-variable-ref
# env=((f6285 . -4) (f6286 . 0))
# var=f6286
    movl 0(%esp), %eax  # stack load f6286
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_38322
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_38322:
    movl %eax, -8(%esp)
# emit-expr 1
    movl $4, %eax     # immed 1
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_38323"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_38323:
# check bounds on vector index
    movl -8(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_38325
    cmp  $0,%eax
    jge _L_38324
_L_38325:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_38324:
    movl %eax, -12(%esp)
# emit-expr "/dev/stdout"
# string literal
    jmp _L_38327
    .align 8,0x90
_L_38326 :
    .int 44
    .ascii "/dev/stdout"
_L_38327:
    movl $_L_38326, %eax
    orl $6, %eax
    movl -8(%esp), %ebx
    movl -12(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin (vector-set! f6286 2 1) (vector-set! f6286 3 (make-string f6285)) (vector-set! f6286 4 0) (vector-set! f6286 5 f6285) f6286)
# emit-begin
#   expr=(begin (vector-set! f6286 2 1) (vector-set! f6286 3 (make-string f6285)) (vector-set! f6286 4 0) (vector-set! f6286 5 f6285) f6286)
#   env=((f6285 . -4) (f6286 . 0))
# emit-expr (vector-set! f6286 2 1)
# emit-expr f6286
# emit-variable-ref
# env=((f6285 . -4) (f6286 . 0))
# var=f6286
    movl 0(%esp), %eax  # stack load f6286
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_38328
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_38328:
    movl %eax, -8(%esp)
# emit-expr 2
    movl $8, %eax     # immed 2
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_38329"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_38329:
# check bounds on vector index
    movl -8(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_38331
    cmp  $0,%eax
    jge _L_38330
_L_38331:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_38330:
    movl %eax, -12(%esp)
# emit-expr 1
    movl $4, %eax     # immed 1
    movl -8(%esp), %ebx
    movl -12(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin (vector-set! f6286 3 (make-string f6285)) (vector-set! f6286 4 0) (vector-set! f6286 5 f6285) f6286)
# emit-begin
#   expr=(begin (vector-set! f6286 3 (make-string f6285)) (vector-set! f6286 4 0) (vector-set! f6286 5 f6285) f6286)
#   env=((f6285 . -4) (f6286 . 0))
# emit-expr (vector-set! f6286 3 (make-string f6285))
# emit-expr f6286
# emit-variable-ref
# env=((f6285 . -4) (f6286 . 0))
# var=f6286
    movl 0(%esp), %eax  # stack load f6286
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_38332
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_38332:
    movl %eax, -8(%esp)
# emit-expr 3
    movl $12, %eax     # immed 3
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_38333"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_38333:
# check bounds on vector index
    movl -8(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_38335
    cmp  $0,%eax
    jge _L_38334
_L_38335:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_38334:
    movl %eax, -12(%esp)
# emit-expr (make-string f6285)
# make-string len=f6285
# emit-expr f6285
# emit-variable-ref
# env=((f6285 . -4) (f6286 . 0))
# var=f6285
    movl -4(%esp), %eax  # stack load f6285
# end emit-variable-ref
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_38336"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $152,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_38336:
# check the argument is a fixnum >= 0
    cmp $0,%eax
    jge _L_38337
# invoke error handler eh_length
    .extern mrc_eh$ulength
    movl mrc_eh$ulength, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $152,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_38337:
    movl %eax, %esi
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    orl $6, %eax
    sar $2, %esi
    add $4, %esi
    add $7, %esi
    andl $-8, %esi
    add  %esi, %ebp
# make-string end
    movl -8(%esp), %ebx
    movl -12(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin (vector-set! f6286 4 0) (vector-set! f6286 5 f6285) f6286)
# emit-begin
#   expr=(begin (vector-set! f6286 4 0) (vector-set! f6286 5 f6285) f6286)
#   env=((f6285 . -4) (f6286 . 0))
# emit-expr (vector-set! f6286 4 0)
# emit-expr f6286
# emit-variable-ref
# env=((f6285 . -4) (f6286 . 0))
# var=f6286
    movl 0(%esp), %eax  # stack load f6286
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_38338
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_38338:
    movl %eax, -8(%esp)
# emit-expr 4
    movl $16, %eax     # immed 4
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_38339"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_38339:
# check bounds on vector index
    movl -8(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_38341
    cmp  $0,%eax
    jge _L_38340
_L_38341:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_38340:
    movl %eax, -12(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
    movl -8(%esp), %ebx
    movl -12(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin (vector-set! f6286 5 f6285) f6286)
# emit-begin
#   expr=(begin (vector-set! f6286 5 f6285) f6286)
#   env=((f6285 . -4) (f6286 . 0))
# emit-expr (vector-set! f6286 5 f6285)
# emit-expr f6286
# emit-variable-ref
# env=((f6285 . -4) (f6286 . 0))
# var=f6286
    movl 0(%esp), %eax  # stack load f6286
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_38342
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_38342:
    movl %eax, -8(%esp)
# emit-expr 5
    movl $20, %eax     # immed 5
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_38343"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_38343:
# check bounds on vector index
    movl -8(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_38345
    cmp  $0,%eax
    jge _L_38344
_L_38345:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_38344:
    movl %eax, -12(%esp)
# emit-expr f6285
# emit-variable-ref
# env=((f6285 . -4) (f6286 . 0))
# var=f6285
    movl -4(%esp), %eax  # stack load f6285
# end emit-variable-ref
    movl -8(%esp), %ebx
    movl -12(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin f6286)
# emit-begin
#   expr=(begin f6286)
#   env=((f6285 . -4) (f6286 . 0))
# emit-expr f6286
# emit-variable-ref
# env=((f6285 . -4) (f6286 . 0))
# var=f6286
    movl 0(%esp), %eax  # stack load f6286
# end emit-variable-ref
# emit-expr (begin)
# emit-begin
#   expr=(begin)
#   env=((f6285 . -4) (f6286 . 0))
     movl %eax, mrc_standard$mout
# == explicit-begins  ==>
# (let ((current-out standard-out)) (lambda () current-out))
# == eliminate-let*  ==>
# (let ((current-out standard-out)) (lambda () current-out))
# == uniquify-variables  ==>
# (let ((f6287 standard-out)) (lambda () f6287))
# == vectorize-letrec  ==>
# (let ((f6287 standard-out)) (lambda () f6287))
# == eliminate-set!  ==>
# (let ((f6287 standard-out)) (lambda () (let () f6287)))
# == close-free-variables  ==>
# (let ((f6287 standard-out)) (closure () (f6287) (let () f6287)))
# == eliminate-quote  ==>
# (let ((f6287 standard-out)) (closure () (f6287) (let () f6287)))
# == eliminate-when/unless  ==>
# (let ((f6287 standard-out)) (closure () (f6287) (let () f6287)))
# == eliminate-cond  ==>
# (let ((f6287 standard-out)) (closure () (f6287) (let () f6287)))
# == external-symbols  ==>
# (let ((f6287 (primitive-ref standard-out))) (closure () (f6287) (let () f6287)))
# emit-expr (let ((f6287 (primitive-ref standard-out))) (closure () (f6287) (let () f6287)))
# emit-let
#  si   = 0
#  env  = ()
#  bindings = ((f6287 (primitive-ref standard-out)))
#  body = (closure () (f6287) (let () f6287))
# emit-expr (primitive-ref standard-out)
    .extern mrc_standard$mout
    movl mrc_standard$mout,%eax
    movl %eax, 0(%esp)  # stack save
# emit-expr (closure () (f6287) (let () f6287))
# emit-closure
# si = -4
# env = ((f6287 . 0))
# expr = (closure () (f6287) (let () f6287))
    movl $_L_38346, 0(%ebp)  # closure label
# emit-variable-ref
# env=((f6287 . 0))
# var=f6287
    movl 0(%esp), %eax  # stack load f6287
# end emit-variable-ref
   movl  %eax, 4(%ebp)  # f6287
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $8, %ebp     # bump ebp
    jmp _L_38347            # jump around closure body
_L_38346:
# check argument count
    cmp $0,%eax
    je _L_38348
# invoke error handler eh_argcount
    .extern mrc_eh$uargcount
    movl mrc_eh$uargcount, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_38348:
# emit-tail-expr
# si=-8
# env=((f6287 . 4) (f6287 . 0))
# expr=(let () f6287)
# emit-tail-let
#  si   = -8
#  env  = ((f6287 . 4) (f6287 . 0))
#  bindings = ()
#  body = f6287
# emit-tail-expr
# si=-8
# env=((f6287 . 4) (f6287 . 0))
# expr=f6287
# emit-tail-variable-ref
# emit-variable-ref
# env=((f6287 . 4) (f6287 . 0))
# var=f6287
    movl 2(%edi), %eax  # frame load f6287
# end emit-variable-ref
    ret
# end emit-tail-variable ref
    .align 4,0x90
_L_38347:
     movl %eax, mrc_current$moutput$mport
# == explicit-begins  ==>
# (let ((current-in standard-in)) (lambda () current-in))
# == eliminate-let*  ==>
# (let ((current-in standard-in)) (lambda () current-in))
# == uniquify-variables  ==>
# (let ((f6288 standard-in)) (lambda () f6288))
# == vectorize-letrec  ==>
# (let ((f6288 standard-in)) (lambda () f6288))
# == eliminate-set!  ==>
# (let ((f6288 standard-in)) (lambda () (let () f6288)))
# == close-free-variables  ==>
# (let ((f6288 standard-in)) (closure () (f6288) (let () f6288)))
# == eliminate-quote  ==>
# (let ((f6288 standard-in)) (closure () (f6288) (let () f6288)))
# == eliminate-when/unless  ==>
# (let ((f6288 standard-in)) (closure () (f6288) (let () f6288)))
# == eliminate-cond  ==>
# (let ((f6288 standard-in)) (closure () (f6288) (let () f6288)))
# == external-symbols  ==>
# (let ((f6288 (primitive-ref standard-in))) (closure () (f6288) (let () f6288)))
# emit-expr (let ((f6288 (primitive-ref standard-in))) (closure () (f6288) (let () f6288)))
# emit-let
#  si   = 0
#  env  = ()
#  bindings = ((f6288 (primitive-ref standard-in)))
#  body = (closure () (f6288) (let () f6288))
# emit-expr (primitive-ref standard-in)
    .extern mrc_standard$min
    movl mrc_standard$min,%eax
    movl %eax, 0(%esp)  # stack save
# emit-expr (closure () (f6288) (let () f6288))
# emit-closure
# si = -4
# env = ((f6288 . 0))
# expr = (closure () (f6288) (let () f6288))
    movl $_L_38349, 0(%ebp)  # closure label
# emit-variable-ref
# env=((f6288 . 0))
# var=f6288
    movl 0(%esp), %eax  # stack load f6288
# end emit-variable-ref
   movl  %eax, 4(%ebp)  # f6288
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $8, %ebp     # bump ebp
    jmp _L_38350            # jump around closure body
_L_38349:
# check argument count
    cmp $0,%eax
    je _L_38351
# invoke error handler eh_argcount
    .extern mrc_eh$uargcount
    movl mrc_eh$uargcount, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_38351:
# emit-tail-expr
# si=-8
# env=((f6288 . 4) (f6288 . 0))
# expr=(let () f6288)
# emit-tail-let
#  si   = -8
#  env  = ((f6288 . 4) (f6288 . 0))
#  bindings = ()
#  body = f6288
# emit-tail-expr
# si=-8
# env=((f6288 . 4) (f6288 . 0))
# expr=f6288
# emit-tail-variable-ref
# emit-variable-ref
# env=((f6288 . 4) (f6288 . 0))
# var=f6288
    movl 2(%edi), %eax  # frame load f6288
# end emit-variable-ref
    ret
# end emit-tail-variable ref
    .align 4,0x90
_L_38350:
     movl %eax, mrc_current$minput$mport
# == explicit-begins  ==>
# (lambda (p) (vector-ref p 0))
# == eliminate-let*  ==>
# (lambda (p) (vector-ref p 0))
# == uniquify-variables  ==>
# (lambda (f6289) (vector-ref f6289 0))
# == vectorize-letrec  ==>
# (lambda (f6289) (vector-ref f6289 0))
# == eliminate-set!  ==>
# (lambda (f6289) (let ((f6289 f6289)) (vector-ref f6289 0)))
# == close-free-variables  ==>
# (closure (f6289) () (let ((f6289 f6289)) (vector-ref f6289 0)))
# == eliminate-quote  ==>
# (closure (f6289) () (let ((f6289 f6289)) (vector-ref f6289 0)))
# == eliminate-when/unless  ==>
# (closure (f6289) () (let ((f6289 f6289)) (vector-ref f6289 0)))
# == eliminate-cond  ==>
# (closure (f6289) () (let ((f6289 f6289)) (vector-ref f6289 0)))
# == external-symbols  ==>
# (closure (f6289) () (let ((f6289 f6289)) (vector-ref f6289 0)))
# emit-expr (closure (f6289) () (let ((f6289 f6289)) (vector-ref f6289 0)))
# emit-closure
# si = 0
# env = ()
# expr = (closure (f6289) () (let ((f6289 f6289)) (vector-ref f6289 0)))
    movl $_L_38352, 0(%ebp)  # closure label
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $8, %ebp     # bump ebp
    jmp _L_38353            # jump around closure body
_L_38352:
# check argument count
    cmp $4,%eax
    je _L_38354
# invoke error handler eh_argcount
    .extern mrc_eh$uargcount
    movl mrc_eh$uargcount, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_38354:
# emit-tail-expr
# si=-12
# env=((f6289 . -8))
# expr=(let ((f6289 f6289)) (vector-ref f6289 0))
# emit-tail-let
#  si   = -12
#  env  = ((f6289 . -8))
#  bindings = ((f6289 f6289))
#  body = (vector-ref f6289 0)
# emit-expr f6289
# emit-variable-ref
# env=((f6289 . -8))
# var=f6289
    movl -8(%esp), %eax  # stack load f6289
# end emit-variable-ref
    movl %eax, -12(%esp)  # stack save
# emit-tail-expr
# si=-16
# env=((f6289 . -12) (f6289 . -8))
# expr=(vector-ref f6289 0)
# tail primcall
# emit-expr f6289
# emit-variable-ref
# env=((f6289 . -12) (f6289 . -8))
# var=f6289
    movl -12(%esp), %eax  # stack load f6289
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_38355
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_38355:
    movl %eax, -16(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_38356"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_38356:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_38358
    cmp  $0,%eax
    jge _L_38357
_L_38358:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_38357:
    movl -16(%esp), %esi
    movl -1(%eax,%esi), %eax
#return from tail (vector-ref f6289 0)
    ret
    .align 4,0x90
_L_38353:
     movl %eax, mrc_port$mkind
# == explicit-begins  ==>
# (lambda (p) (vector-ref p 1))
# == eliminate-let*  ==>
# (lambda (p) (vector-ref p 1))
# == uniquify-variables  ==>
# (lambda (f6290) (vector-ref f6290 1))
# == vectorize-letrec  ==>
# (lambda (f6290) (vector-ref f6290 1))
# == eliminate-set!  ==>
# (lambda (f6290) (let ((f6290 f6290)) (vector-ref f6290 1)))
# == close-free-variables  ==>
# (closure (f6290) () (let ((f6290 f6290)) (vector-ref f6290 1)))
# == eliminate-quote  ==>
# (closure (f6290) () (let ((f6290 f6290)) (vector-ref f6290 1)))
# == eliminate-when/unless  ==>
# (closure (f6290) () (let ((f6290 f6290)) (vector-ref f6290 1)))
# == eliminate-cond  ==>
# (closure (f6290) () (let ((f6290 f6290)) (vector-ref f6290 1)))
# == external-symbols  ==>
# (closure (f6290) () (let ((f6290 f6290)) (vector-ref f6290 1)))
# emit-expr (closure (f6290) () (let ((f6290 f6290)) (vector-ref f6290 1)))
# emit-closure
# si = 0
# env = ()
# expr = (closure (f6290) () (let ((f6290 f6290)) (vector-ref f6290 1)))
    movl $_L_38359, 0(%ebp)  # closure label
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $8, %ebp     # bump ebp
    jmp _L_38360            # jump around closure body
_L_38359:
# check argument count
    cmp $4,%eax
    je _L_38361
# invoke error handler eh_argcount
    .extern mrc_eh$uargcount
    movl mrc_eh$uargcount, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_38361:
# emit-tail-expr
# si=-12
# env=((f6290 . -8))
# expr=(let ((f6290 f6290)) (vector-ref f6290 1))
# emit-tail-let
#  si   = -12
#  env  = ((f6290 . -8))
#  bindings = ((f6290 f6290))
#  body = (vector-ref f6290 1)
# emit-expr f6290
# emit-variable-ref
# env=((f6290 . -8))
# var=f6290
    movl -8(%esp), %eax  # stack load f6290
# end emit-variable-ref
    movl %eax, -12(%esp)  # stack save
# emit-tail-expr
# si=-16
# env=((f6290 . -12) (f6290 . -8))
# expr=(vector-ref f6290 1)
# tail primcall
# emit-expr f6290
# emit-variable-ref
# env=((f6290 . -12) (f6290 . -8))
# var=f6290
    movl -12(%esp), %eax  # stack load f6290
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_38362
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_38362:
    movl %eax, -16(%esp)
# emit-expr 1
    movl $4, %eax     # immed 1
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_38363"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_38363:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_38365
    cmp  $0,%eax
    jge _L_38364
_L_38365:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_38364:
    movl -16(%esp), %esi
    movl -1(%eax,%esi), %eax
#return from tail (vector-ref f6290 1)
    ret
    .align 4,0x90
_L_38360:
     movl %eax, mrc_port$mpath
# == explicit-begins  ==>
# (lambda (p) (vector-ref p 2))
# == eliminate-let*  ==>
# (lambda (p) (vector-ref p 2))
# == uniquify-variables  ==>
# (lambda (f6291) (vector-ref f6291 2))
# == vectorize-letrec  ==>
# (lambda (f6291) (vector-ref f6291 2))
# == eliminate-set!  ==>
# (lambda (f6291) (let ((f6291 f6291)) (vector-ref f6291 2)))
# == close-free-variables  ==>
# (closure (f6291) () (let ((f6291 f6291)) (vector-ref f6291 2)))
# == eliminate-quote  ==>
# (closure (f6291) () (let ((f6291 f6291)) (vector-ref f6291 2)))
# == eliminate-when/unless  ==>
# (closure (f6291) () (let ((f6291 f6291)) (vector-ref f6291 2)))
# == eliminate-cond  ==>
# (closure (f6291) () (let ((f6291 f6291)) (vector-ref f6291 2)))
# == external-symbols  ==>
# (closure (f6291) () (let ((f6291 f6291)) (vector-ref f6291 2)))
# emit-expr (closure (f6291) () (let ((f6291 f6291)) (vector-ref f6291 2)))
# emit-closure
# si = 0
# env = ()
# expr = (closure (f6291) () (let ((f6291 f6291)) (vector-ref f6291 2)))
    movl $_L_38366, 0(%ebp)  # closure label
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $8, %ebp     # bump ebp
    jmp _L_38367            # jump around closure body
_L_38366:
# check argument count
    cmp $4,%eax
    je _L_38368
# invoke error handler eh_argcount
    .extern mrc_eh$uargcount
    movl mrc_eh$uargcount, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_38368:
# emit-tail-expr
# si=-12
# env=((f6291 . -8))
# expr=(let ((f6291 f6291)) (vector-ref f6291 2))
# emit-tail-let
#  si   = -12
#  env  = ((f6291 . -8))
#  bindings = ((f6291 f6291))
#  body = (vector-ref f6291 2)
# emit-expr f6291
# emit-variable-ref
# env=((f6291 . -8))
# var=f6291
    movl -8(%esp), %eax  # stack load f6291
# end emit-variable-ref
    movl %eax, -12(%esp)  # stack save
# emit-tail-expr
# si=-16
# env=((f6291 . -12) (f6291 . -8))
# expr=(vector-ref f6291 2)
# tail primcall
# emit-expr f6291
# emit-variable-ref
# env=((f6291 . -12) (f6291 . -8))
# var=f6291
    movl -12(%esp), %eax  # stack load f6291
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_38369
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_38369:
    movl %eax, -16(%esp)
# emit-expr 2
    movl $8, %eax     # immed 2
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_38370"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_38370:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_38372
    cmp  $0,%eax
    jge _L_38371
_L_38372:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_38371:
    movl -16(%esp), %esi
    movl -1(%eax,%esi), %eax
#return from tail (vector-ref f6291 2)
    ret
    .align 4,0x90
_L_38367:
     movl %eax, mrc_port$mfd
# == explicit-begins  ==>
# (lambda (p) (vector-ref p 3))
# == eliminate-let*  ==>
# (lambda (p) (vector-ref p 3))
# == uniquify-variables  ==>
# (lambda (f6292) (vector-ref f6292 3))
# == vectorize-letrec  ==>
# (lambda (f6292) (vector-ref f6292 3))
# == eliminate-set!  ==>
# (lambda (f6292) (let ((f6292 f6292)) (vector-ref f6292 3)))
# == close-free-variables  ==>
# (closure (f6292) () (let ((f6292 f6292)) (vector-ref f6292 3)))
# == eliminate-quote  ==>
# (closure (f6292) () (let ((f6292 f6292)) (vector-ref f6292 3)))
# == eliminate-when/unless  ==>
# (closure (f6292) () (let ((f6292 f6292)) (vector-ref f6292 3)))
# == eliminate-cond  ==>
# (closure (f6292) () (let ((f6292 f6292)) (vector-ref f6292 3)))
# == external-symbols  ==>
# (closure (f6292) () (let ((f6292 f6292)) (vector-ref f6292 3)))
# emit-expr (closure (f6292) () (let ((f6292 f6292)) (vector-ref f6292 3)))
# emit-closure
# si = 0
# env = ()
# expr = (closure (f6292) () (let ((f6292 f6292)) (vector-ref f6292 3)))
    movl $_L_38373, 0(%ebp)  # closure label
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $8, %ebp     # bump ebp
    jmp _L_38374            # jump around closure body
_L_38373:
# check argument count
    cmp $4,%eax
    je _L_38375
# invoke error handler eh_argcount
    .extern mrc_eh$uargcount
    movl mrc_eh$uargcount, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_38375:
# emit-tail-expr
# si=-12
# env=((f6292 . -8))
# expr=(let ((f6292 f6292)) (vector-ref f6292 3))
# emit-tail-let
#  si   = -12
#  env  = ((f6292 . -8))
#  bindings = ((f6292 f6292))
#  body = (vector-ref f6292 3)
# emit-expr f6292
# emit-variable-ref
# env=((f6292 . -8))
# var=f6292
    movl -8(%esp), %eax  # stack load f6292
# end emit-variable-ref
    movl %eax, -12(%esp)  # stack save
# emit-tail-expr
# si=-16
# env=((f6292 . -12) (f6292 . -8))
# expr=(vector-ref f6292 3)
# tail primcall
# emit-expr f6292
# emit-variable-ref
# env=((f6292 . -12) (f6292 . -8))
# var=f6292
    movl -12(%esp), %eax  # stack load f6292
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_38376
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_38376:
    movl %eax, -16(%esp)
# emit-expr 3
    movl $12, %eax     # immed 3
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_38377"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_38377:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_38379
    cmp  $0,%eax
    jge _L_38378
_L_38379:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_38378:
    movl -16(%esp), %esi
    movl -1(%eax,%esi), %eax
#return from tail (vector-ref f6292 3)
    ret
    .align 4,0x90
_L_38374:
     movl %eax, mrc_port$mbuf
# == explicit-begins  ==>
# (lambda (p) (vector-ref p 4))
# == eliminate-let*  ==>
# (lambda (p) (vector-ref p 4))
# == uniquify-variables  ==>
# (lambda (f6293) (vector-ref f6293 4))
# == vectorize-letrec  ==>
# (lambda (f6293) (vector-ref f6293 4))
# == eliminate-set!  ==>
# (lambda (f6293) (let ((f6293 f6293)) (vector-ref f6293 4)))
# == close-free-variables  ==>
# (closure (f6293) () (let ((f6293 f6293)) (vector-ref f6293 4)))
# == eliminate-quote  ==>
# (closure (f6293) () (let ((f6293 f6293)) (vector-ref f6293 4)))
# == eliminate-when/unless  ==>
# (closure (f6293) () (let ((f6293 f6293)) (vector-ref f6293 4)))
# == eliminate-cond  ==>
# (closure (f6293) () (let ((f6293 f6293)) (vector-ref f6293 4)))
# == external-symbols  ==>
# (closure (f6293) () (let ((f6293 f6293)) (vector-ref f6293 4)))
# emit-expr (closure (f6293) () (let ((f6293 f6293)) (vector-ref f6293 4)))
# emit-closure
# si = 0
# env = ()
# expr = (closure (f6293) () (let ((f6293 f6293)) (vector-ref f6293 4)))
    movl $_L_38380, 0(%ebp)  # closure label
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $8, %ebp     # bump ebp
    jmp _L_38381            # jump around closure body
_L_38380:
# check argument count
    cmp $4,%eax
    je _L_38382
# invoke error handler eh_argcount
    .extern mrc_eh$uargcount
    movl mrc_eh$uargcount, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_38382:
# emit-tail-expr
# si=-12
# env=((f6293 . -8))
# expr=(let ((f6293 f6293)) (vector-ref f6293 4))
# emit-tail-let
#  si   = -12
#  env  = ((f6293 . -8))
#  bindings = ((f6293 f6293))
#  body = (vector-ref f6293 4)
# emit-expr f6293
# emit-variable-ref
# env=((f6293 . -8))
# var=f6293
    movl -8(%esp), %eax  # stack load f6293
# end emit-variable-ref
    movl %eax, -12(%esp)  # stack save
# emit-tail-expr
# si=-16
# env=((f6293 . -12) (f6293 . -8))
# expr=(vector-ref f6293 4)
# tail primcall
# emit-expr f6293
# emit-variable-ref
# env=((f6293 . -12) (f6293 . -8))
# var=f6293
    movl -12(%esp), %eax  # stack load f6293
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_38383
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_38383:
    movl %eax, -16(%esp)
# emit-expr 4
    movl $16, %eax     # immed 4
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_38384"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_38384:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_38386
    cmp  $0,%eax
    jge _L_38385
_L_38386:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_38385:
    movl -16(%esp), %esi
    movl -1(%eax,%esi), %eax
#return from tail (vector-ref f6293 4)
    ret
    .align 4,0x90
_L_38381:
     movl %eax, mrc_port$mndx
# == explicit-begins  ==>
# (lambda (p) (vector-set! p 4 (fxadd1 (vector-ref p 4))))
# == eliminate-let*  ==>
# (lambda (p) (vector-set! p 4 (fxadd1 (vector-ref p 4))))
# == uniquify-variables  ==>
# (lambda (f6294) (vector-set! f6294 4 (fxadd1 (vector-ref f6294 4))))
# == vectorize-letrec  ==>
# (lambda (f6294) (vector-set! f6294 4 (fxadd1 (vector-ref f6294 4))))
# == eliminate-set!  ==>
# (lambda (f6294) (let ((f6294 f6294)) (vector-set! f6294 4 (fxadd1 (vector-ref f6294 4)))))
# == close-free-variables  ==>
# (closure (f6294) () (let ((f6294 f6294)) (vector-set! f6294 4 (fxadd1 (vector-ref f6294 4)))))
# == eliminate-quote  ==>
# (closure (f6294) () (let ((f6294 f6294)) (vector-set! f6294 4 (fxadd1 (vector-ref f6294 4)))))
# == eliminate-when/unless  ==>
# (closure (f6294) () (let ((f6294 f6294)) (vector-set! f6294 4 (fxadd1 (vector-ref f6294 4)))))
# == eliminate-cond  ==>
# (closure (f6294) () (let ((f6294 f6294)) (vector-set! f6294 4 (fxadd1 (vector-ref f6294 4)))))
# == external-symbols  ==>
# (closure (f6294) () (let ((f6294 f6294)) (vector-set! f6294 4 (fxadd1 (vector-ref f6294 4)))))
# emit-expr (closure (f6294) () (let ((f6294 f6294)) (vector-set! f6294 4 (fxadd1 (vector-ref f6294 4)))))
# emit-closure
# si = 0
# env = ()
# expr = (closure (f6294) () (let ((f6294 f6294)) (vector-set! f6294 4 (fxadd1 (vector-ref f6294 4)))))
    movl $_L_38387, 0(%ebp)  # closure label
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $8, %ebp     # bump ebp
    jmp _L_38388            # jump around closure body
_L_38387:
# check argument count
    cmp $4,%eax
    je _L_38389
# invoke error handler eh_argcount
    .extern mrc_eh$uargcount
    movl mrc_eh$uargcount, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_38389:
# emit-tail-expr
# si=-12
# env=((f6294 . -8))
# expr=(let ((f6294 f6294)) (vector-set! f6294 4 (fxadd1 (vector-ref f6294 4))))
# emit-tail-let
#  si   = -12
#  env  = ((f6294 . -8))
#  bindings = ((f6294 f6294))
#  body = (vector-set! f6294 4 (fxadd1 (vector-ref f6294 4)))
# emit-expr f6294
# emit-variable-ref
# env=((f6294 . -8))
# var=f6294
    movl -8(%esp), %eax  # stack load f6294
# end emit-variable-ref
    movl %eax, -12(%esp)  # stack save
# emit-tail-expr
# si=-16
# env=((f6294 . -12) (f6294 . -8))
# expr=(vector-set! f6294 4 (fxadd1 (vector-ref f6294 4)))
# tail primcall
# emit-expr f6294
# emit-variable-ref
# env=((f6294 . -12) (f6294 . -8))
# var=f6294
    movl -12(%esp), %eax  # stack load f6294
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_38390
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_38390:
    movl %eax, -16(%esp)
# emit-expr 4
    movl $16, %eax     # immed 4
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_38391"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_38391:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_38393
    cmp  $0,%eax
    jge _L_38392
_L_38393:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_38392:
    movl %eax, -20(%esp)
# emit-expr (fxadd1 (vector-ref f6294 4))
# emit-expr (vector-ref f6294 4)
# emit-expr f6294
# emit-variable-ref
# env=((f6294 . -12) (f6294 . -8))
# var=f6294
    movl -12(%esp), %eax  # stack load f6294
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_38394
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_38394:
    movl %eax, -24(%esp)
# emit-expr 4
    movl $16, %eax     # immed 4
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_38395"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_38395:
# check bounds on vector index
    movl -24(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_38397
    cmp  $0,%eax
    jge _L_38396
_L_38397:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_38396:
    movl -24(%esp), %esi
    movl -1(%eax,%esi), %eax
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_38398"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $56,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_38398:
     addl $4, %eax
    movl -16(%esp), %ebx
    movl -20(%esp), %esi
    movl %eax, -1(%ebx,%esi)
#return from tail (vector-set! f6294 4 (fxadd1 (vector-ref f6294 4)))
    ret
    .align 4,0x90
_L_38388:
     movl %eax, mrc_port$mndx$madd1
# == explicit-begins  ==>
# (lambda (p) (vector-set! p 4 0))
# == eliminate-let*  ==>
# (lambda (p) (vector-set! p 4 0))
# == uniquify-variables  ==>
# (lambda (f6295) (vector-set! f6295 4 0))
# == vectorize-letrec  ==>
# (lambda (f6295) (vector-set! f6295 4 0))
# == eliminate-set!  ==>
# (lambda (f6295) (let ((f6295 f6295)) (vector-set! f6295 4 0)))
# == close-free-variables  ==>
# (closure (f6295) () (let ((f6295 f6295)) (vector-set! f6295 4 0)))
# == eliminate-quote  ==>
# (closure (f6295) () (let ((f6295 f6295)) (vector-set! f6295 4 0)))
# == eliminate-when/unless  ==>
# (closure (f6295) () (let ((f6295 f6295)) (vector-set! f6295 4 0)))
# == eliminate-cond  ==>
# (closure (f6295) () (let ((f6295 f6295)) (vector-set! f6295 4 0)))
# == external-symbols  ==>
# (closure (f6295) () (let ((f6295 f6295)) (vector-set! f6295 4 0)))
# emit-expr (closure (f6295) () (let ((f6295 f6295)) (vector-set! f6295 4 0)))
# emit-closure
# si = 0
# env = ()
# expr = (closure (f6295) () (let ((f6295 f6295)) (vector-set! f6295 4 0)))
    movl $_L_38399, 0(%ebp)  # closure label
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $8, %ebp     # bump ebp
    jmp _L_38400            # jump around closure body
_L_38399:
# check argument count
    cmp $4,%eax
    je _L_38401
# invoke error handler eh_argcount
    .extern mrc_eh$uargcount
    movl mrc_eh$uargcount, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_38401:
# emit-tail-expr
# si=-12
# env=((f6295 . -8))
# expr=(let ((f6295 f6295)) (vector-set! f6295 4 0))
# emit-tail-let
#  si   = -12
#  env  = ((f6295 . -8))
#  bindings = ((f6295 f6295))
#  body = (vector-set! f6295 4 0)
# emit-expr f6295
# emit-variable-ref
# env=((f6295 . -8))
# var=f6295
    movl -8(%esp), %eax  # stack load f6295
# end emit-variable-ref
    movl %eax, -12(%esp)  # stack save
# emit-tail-expr
# si=-16
# env=((f6295 . -12) (f6295 . -8))
# expr=(vector-set! f6295 4 0)
# tail primcall
# emit-expr f6295
# emit-variable-ref
# env=((f6295 . -12) (f6295 . -8))
# var=f6295
    movl -12(%esp), %eax  # stack load f6295
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_38402
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_38402:
    movl %eax, -16(%esp)
# emit-expr 4
    movl $16, %eax     # immed 4
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_38403"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_38403:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_38405
    cmp  $0,%eax
    jge _L_38404
_L_38405:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_38404:
    movl %eax, -20(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
    movl -16(%esp), %ebx
    movl -20(%esp), %esi
    movl %eax, -1(%ebx,%esi)
#return from tail (vector-set! f6295 4 0)
    ret
    .align 4,0x90
_L_38400:
     movl %eax, mrc_port$mndx$mreset
# == explicit-begins  ==>
# (lambda (p) (vector-ref p 5))
# == eliminate-let*  ==>
# (lambda (p) (vector-ref p 5))
# == uniquify-variables  ==>
# (lambda (f6296) (vector-ref f6296 5))
# == vectorize-letrec  ==>
# (lambda (f6296) (vector-ref f6296 5))
# == eliminate-set!  ==>
# (lambda (f6296) (let ((f6296 f6296)) (vector-ref f6296 5)))
# == close-free-variables  ==>
# (closure (f6296) () (let ((f6296 f6296)) (vector-ref f6296 5)))
# == eliminate-quote  ==>
# (closure (f6296) () (let ((f6296 f6296)) (vector-ref f6296 5)))
# == eliminate-when/unless  ==>
# (closure (f6296) () (let ((f6296 f6296)) (vector-ref f6296 5)))
# == eliminate-cond  ==>
# (closure (f6296) () (let ((f6296 f6296)) (vector-ref f6296 5)))
# == external-symbols  ==>
# (closure (f6296) () (let ((f6296 f6296)) (vector-ref f6296 5)))
# emit-expr (closure (f6296) () (let ((f6296 f6296)) (vector-ref f6296 5)))
# emit-closure
# si = 0
# env = ()
# expr = (closure (f6296) () (let ((f6296 f6296)) (vector-ref f6296 5)))
    movl $_L_38406, 0(%ebp)  # closure label
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $8, %ebp     # bump ebp
    jmp _L_38407            # jump around closure body
_L_38406:
# check argument count
    cmp $4,%eax
    je _L_38408
# invoke error handler eh_argcount
    .extern mrc_eh$uargcount
    movl mrc_eh$uargcount, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_38408:
# emit-tail-expr
# si=-12
# env=((f6296 . -8))
# expr=(let ((f6296 f6296)) (vector-ref f6296 5))
# emit-tail-let
#  si   = -12
#  env  = ((f6296 . -8))
#  bindings = ((f6296 f6296))
#  body = (vector-ref f6296 5)
# emit-expr f6296
# emit-variable-ref
# env=((f6296 . -8))
# var=f6296
    movl -8(%esp), %eax  # stack load f6296
# end emit-variable-ref
    movl %eax, -12(%esp)  # stack save
# emit-tail-expr
# si=-16
# env=((f6296 . -12) (f6296 . -8))
# expr=(vector-ref f6296 5)
# tail primcall
# emit-expr f6296
# emit-variable-ref
# env=((f6296 . -12) (f6296 . -8))
# var=f6296
    movl -12(%esp), %eax  # stack load f6296
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_38409
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_38409:
    movl %eax, -16(%esp)
# emit-expr 5
    movl $20, %eax     # immed 5
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_38410"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_38410:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_38412
    cmp  $0,%eax
    jge _L_38411
_L_38412:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_38411:
    movl -16(%esp), %esi
    movl -1(%eax,%esi), %eax
#return from tail (vector-ref f6296 5)
    ret
    .align 4,0x90
_L_38407:
     movl %eax, mrc_port$msize
# == explicit-begins  ==>
# (lambda (ch . args) (let ((p (if (null? args) (current-output-port) (car args)))) (begin (when (fx= (port-ndx p) (port-size p)) (flush-output-port p)) (string-set! (port-buf p) (port-ndx p) ch) (port-ndx-add1 p))))
# == eliminate-let*  ==>
# (lambda (ch . args) (let ((p (if (null? args) (current-output-port) (car args)))) (begin (when (fx= (port-ndx p) (port-size p)) (flush-output-port p)) (string-set! (port-buf p) (port-ndx p) ch) (port-ndx-add1 p))))
# == uniquify-variables  ==>
# (lambda (f6297 . f6298) (let ((f6300 (if (null? f6298) (current-output-port) (car f6298)))) (begin (when (fx= (port-ndx f6300) (port-size f6300)) (flush-output-port f6300)) (string-set! (port-buf f6300) (port-ndx f6300) f6297) (port-ndx-add1 f6300))))
# == vectorize-letrec  ==>
# (lambda (f6297 . f6298) (let ((f6300 (if (null? f6298) (current-output-port) (car f6298)))) (begin (when (fx= (port-ndx f6300) (port-size f6300)) (flush-output-port f6300)) (string-set! (port-buf f6300) (port-ndx f6300) f6297) (port-ndx-add1 f6300))))
# == eliminate-set!  ==>
# (lambda (f6297 . f6298) (let ((f6297 f6297)) (let ((f6300 (if (null? f6298) (current-output-port) (car f6298)))) (begin (when (fx= (port-ndx f6300) (port-size f6300)) (flush-output-port f6300)) (string-set! (port-buf f6300) (port-ndx f6300) f6297) (port-ndx-add1 f6300)))))
# == close-free-variables  ==>
# (closure (f6297 . f6298) () (let ((f6297 f6297)) (let ((f6300 (if (null? f6298) (current-output-port) (car f6298)))) (begin (when (fx= (port-ndx f6300) (port-size f6300)) (flush-output-port f6300)) (string-set! (port-buf f6300) (port-ndx f6300) f6297) (port-ndx-add1 f6300)))))
# == eliminate-quote  ==>
# (closure (f6297 . f6298) () (let ((f6297 f6297)) (let ((f6300 (if (null? f6298) (current-output-port) (car f6298)))) (begin (when (fx= (port-ndx f6300) (port-size f6300)) (flush-output-port f6300)) (string-set! (port-buf f6300) (port-ndx f6300) f6297) (port-ndx-add1 f6300)))))
# == eliminate-when/unless  ==>
# (closure (f6297 . f6298) () (let ((f6297 f6297)) (let ((f6300 (if (null? f6298) (current-output-port) (car f6298)))) (begin (if (fx= (port-ndx f6300) (port-size f6300)) (begin (flush-output-port f6300)) #f) (string-set! (port-buf f6300) (port-ndx f6300) f6297) (port-ndx-add1 f6300)))))
# == eliminate-cond  ==>
# (closure (f6297 . f6298) () (let ((f6297 f6297)) (let ((f6300 (if (null? f6298) (current-output-port) (car f6298)))) (begin (if (fx= (port-ndx f6300) (port-size f6300)) (begin (flush-output-port f6300)) #f) (string-set! (port-buf f6300) (port-ndx f6300) f6297) (port-ndx-add1 f6300)))))
# == external-symbols  ==>
# (closure (f6297 . f6298) () (let ((f6297 f6297)) (let ((f6300 (if (null? f6298) ((primitive-ref current-output-port)) (car f6298)))) (begin (if (fx= ((primitive-ref port-ndx) f6300) ((primitive-ref port-size) f6300)) (begin ((primitive-ref flush-output-port) f6300)) #f) (string-set! ((primitive-ref port-buf) f6300) ((primitive-ref port-ndx) f6300) f6297) ((primitive-ref port-ndx-add1) f6300)))))
# emit-expr (closure (f6297 . f6298) () (let ((f6297 f6297)) (let ((f6300 (if (null? f6298) ((primitive-ref current-output-port)) (car f6298)))) (begin (if (fx= ((primitive-ref port-ndx) f6300) ((primitive-ref port-size) f6300)) (begin ((primitive-ref flush-output-port) f6300)) #f) (string-set! ((primitive-ref port-buf) f6300) ((primitive-ref port-ndx) f6300) f6297) ((primitive-ref port-ndx-add1) f6300)))))
# emit-closure
# si = 0
# env = ()
# expr = (closure (f6297 . f6298) () (let ((f6297 f6297)) (let ((f6300 (if (null? f6298) ((primitive-ref current-output-port)) (car f6298)))) (begin (if (fx= ((primitive-ref port-ndx) f6300) ((primitive-ref port-size) f6300)) (begin ((primitive-ref flush-output-port) f6300)) #f) (string-set! ((primitive-ref port-buf) f6300) ((primitive-ref port-ndx) f6300) f6297) ((primitive-ref port-ndx-add1) f6300)))))
    movl $_L_38413, 0(%ebp)  # closure label
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $8, %ebp     # bump ebp
    jmp _L_38414            # jump around closure body
_L_38413:
# check argument count
    cmp $4,%eax
    jge _L_38415
# invoke error handler eh_argcount_min
    .extern mrc_eh$uargcount$umin
    movl mrc_eh$uargcount$umin, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_38415:
# emit-build-varargs-list
    movl $63, %esi       # args <- () 
    lea -4(%esp),%edi    # edi <- esp-4
    subl %eax, %edi      # edi <- esp-4-eax    addr of arg[K+N] on stack
_L_38417:
    lea -8(%esp),%ebx    # addr of arg[K] on stack
    cmp %edi, %ebx       # while edi <> esp+(si+4)
    je _L_38416
    movl (%edi),%ebx     # arg i -> car
    movl %ebx, 0(%ebp)
    movl %esi, 4(%ebp)  # esi -> cdr
    movl %ebp, %esi
    addl $1, %esi       # tag as pair
    addl $8,%ebp         # bump heap ptr
    addl $4,%edi         # move to next previous arg from the end
    jmp _L_38417
_L_38416:
    movl %esi, -12(%esp)  # set args
# emit-tail-expr
# si=-16
# env=((f6298 . -12) (f6297 . -8))
# expr=(let ((f6297 f6297)) (let ((f6300 (if (null? f6298) ((primitive-ref current-output-port)) (car f6298)))) (begin (if (fx= ((primitive-ref port-ndx) f6300) ((primitive-ref port-size) f6300)) (begin ((primitive-ref flush-output-port) f6300)) #f) (string-set! ((primitive-ref port-buf) f6300) ((primitive-ref port-ndx) f6300) f6297) ((primitive-ref port-ndx-add1) f6300))))
# emit-tail-let
#  si   = -16
#  env  = ((f6298 . -12) (f6297 . -8))
#  bindings = ((f6297 f6297))
#  body = (let ((f6300 (if (null? f6298) ((primitive-ref current-output-port)) (car f6298)))) (begin (if (fx= ((primitive-ref port-ndx) f6300) ((primitive-ref port-size) f6300)) (begin ((primitive-ref flush-output-port) f6300)) #f) (string-set! ((primitive-ref port-buf) f6300) ((primitive-ref port-ndx) f6300) f6297) ((primitive-ref port-ndx-add1) f6300)))
# emit-expr f6297
# emit-variable-ref
# env=((f6298 . -12) (f6297 . -8))
# var=f6297
    movl -8(%esp), %eax  # stack load f6297
# end emit-variable-ref
    movl %eax, -16(%esp)  # stack save
# emit-tail-expr
# si=-20
# env=((f6297 . -16) (f6298 . -12) (f6297 . -8))
# expr=(let ((f6300 (if (null? f6298) ((primitive-ref current-output-port)) (car f6298)))) (begin (if (fx= ((primitive-ref port-ndx) f6300) ((primitive-ref port-size) f6300)) (begin ((primitive-ref flush-output-port) f6300)) #f) (string-set! ((primitive-ref port-buf) f6300) ((primitive-ref port-ndx) f6300) f6297) ((primitive-ref port-ndx-add1) f6300)))
# emit-tail-let
#  si   = -20
#  env  = ((f6297 . -16) (f6298 . -12) (f6297 . -8))
#  bindings = ((f6300 (if (null? f6298) ((primitive-ref current-output-port)) (car f6298))))
#  body = (begin (if (fx= ((primitive-ref port-ndx) f6300) ((primitive-ref port-size) f6300)) (begin ((primitive-ref flush-output-port) f6300)) #f) (string-set! ((primitive-ref port-buf) f6300) ((primitive-ref port-ndx) f6300) f6297) ((primitive-ref port-ndx-add1) f6300))
# emit-expr (if (null? f6298) ((primitive-ref current-output-port)) (car f6298))
# emit-expr (null? f6298)
# emit-expr f6298
# emit-variable-ref
# env=((f6297 . -16) (f6298 . -12) (f6297 . -8))
# var=f6298
    movl -12(%esp), %eax  # stack load f6298
# end emit-variable-ref
    cmp $63, %eax
    mov $0, %eax
    sete %al
    movzbl %al, %eax
    sal $6, %al
    or $47, %al
    cmp $47, %al
    je _L_38418
# emit-expr ((primitive-ref current-output-port))
# funcall
#    si   =-20
#    env  = ((f6297 . -16) (f6298 . -12) (f6297 . -8))
#    expr = (funcall (primitive-ref current-output-port))
# emit-expr (primitive-ref current-output-port)
    .extern mrc_current$moutput$mport
    movl mrc_current$moutput$mport,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_38420"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_38420":
   movl %eax,  -28(%esp)  # stash funcall-oper in closure slot
    movl -28(%esp), %edi   # load new closure to %edi
    add $-20, %esp   # adjust base
    movl $0,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $20, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    jmp _L_38419
_L_38418:
# emit-expr (car f6298)
# emit-expr f6298
# emit-variable-ref
# env=((f6297 . -16) (f6298 . -12) (f6297 . -8))
# var=f6298
    movl -12(%esp), %eax  # stack load f6298
# end emit-variable-ref
# check the argument is a pair
    movl %eax,%ebx
    and $7, %bl
    cmp $1, %bl
    je _L_38421
# invoke error handler eh_pair
    .extern mrc_eh$upair
    movl mrc_eh$upair, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $116,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_38421:
    movl -1(%eax), %eax
_L_38419:
    movl %eax, -20(%esp)  # stack save
# emit-tail-expr
# si=-24
# env=((f6300 . -20) (f6297 . -16) (f6298 . -12) (f6297 . -8))
# expr=(begin (if (fx= ((primitive-ref port-ndx) f6300) ((primitive-ref port-size) f6300)) (begin ((primitive-ref flush-output-port) f6300)) #f) (string-set! ((primitive-ref port-buf) f6300) ((primitive-ref port-ndx) f6300) f6297) ((primitive-ref port-ndx-add1) f6300))
# tail-begin (begin (if (fx= ((primitive-ref port-ndx) f6300) ((primitive-ref port-size) f6300)) (begin ((primitive-ref flush-output-port) f6300)) #f) (string-set! ((primitive-ref port-buf) f6300) ((primitive-ref port-ndx) f6300) f6297) ((primitive-ref port-ndx-add1) f6300))
#   env=((f6300 . -20) (f6297 . -16) (f6298 . -12) (f6297 . -8))
# emit-expr (if (fx= ((primitive-ref port-ndx) f6300) ((primitive-ref port-size) f6300)) (begin ((primitive-ref flush-output-port) f6300)) #f)
# emit-expr (fx= ((primitive-ref port-ndx) f6300) ((primitive-ref port-size) f6300))
# emit-expr ((primitive-ref port-size) f6300)
# funcall
#    si   =-24
#    env  = ((f6300 . -20) (f6297 . -16) (f6298 . -12) (f6297 . -8))
#    expr = (funcall (primitive-ref port-size) f6300)
# emit-expr (primitive-ref port-size)
    .extern mrc_port$msize
    movl mrc_port$msize,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_38424"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_38424":
   movl %eax,  -32(%esp)  # stash funcall-oper in closure slot
# emit-expr f6300
# emit-variable-ref
# env=((f6300 . -20) (f6297 . -16) (f6298 . -12) (f6297 . -8))
# var=f6300
    movl -20(%esp), %eax  # stack load f6300
# end emit-variable-ref
    mov %eax, -36(%esp)  # arg f6300
    movl -32(%esp), %edi   # load new closure to %edi
    add $-24, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $24, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_38425"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $68,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_38425:
    movl %eax, -24(%esp)
# emit-expr ((primitive-ref port-ndx) f6300)
# funcall
#    si   =-28
#    env  = ((f6300 . -20) (f6297 . -16) (f6298 . -12) (f6297 . -8))
#    expr = (funcall (primitive-ref port-ndx) f6300)
# emit-expr (primitive-ref port-ndx)
    .extern mrc_port$mndx
    movl mrc_port$mndx,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_38426"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_38426":
   movl %eax,  -36(%esp)  # stash funcall-oper in closure slot
# emit-expr f6300
# emit-variable-ref
# env=((f6300 . -20) (f6297 . -16) (f6298 . -12) (f6297 . -8))
# var=f6300
    movl -20(%esp), %eax  # stack load f6300
# end emit-variable-ref
    mov %eax, -40(%esp)  # arg f6300
    movl -36(%esp), %edi   # load new closure to %edi
    add $-28, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $28, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_38427"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $68,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_38427:
    cmp -24(%esp), %eax
    sete %al
    movzbl %al, %eax
    sal $6, %al
    or $47, %al
    cmp $47, %al
    je _L_38422
# emit-expr (begin ((primitive-ref flush-output-port) f6300))
# emit-begin
#   expr=(begin ((primitive-ref flush-output-port) f6300))
#   env=((f6300 . -20) (f6297 . -16) (f6298 . -12) (f6297 . -8))
# emit-expr ((primitive-ref flush-output-port) f6300)
# funcall
#    si   =-24
#    env  = ((f6300 . -20) (f6297 . -16) (f6298 . -12) (f6297 . -8))
#    expr = (funcall (primitive-ref flush-output-port) f6300)
# emit-expr (primitive-ref flush-output-port)
    .extern mrc_flush$moutput$mport
    movl mrc_flush$moutput$mport,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_38428"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_38428":
   movl %eax,  -32(%esp)  # stash funcall-oper in closure slot
# emit-expr f6300
# emit-variable-ref
# env=((f6300 . -20) (f6297 . -16) (f6298 . -12) (f6297 . -8))
# var=f6300
    movl -20(%esp), %eax  # stack load f6300
# end emit-variable-ref
    mov %eax, -36(%esp)  # arg f6300
    movl -32(%esp), %edi   # load new closure to %edi
    add $-24, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $24, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
# emit-expr (begin)
# emit-begin
#   expr=(begin)
#   env=((f6300 . -20) (f6297 . -16) (f6298 . -12) (f6297 . -8))
    jmp _L_38423
_L_38422:
# emit-expr #f
    movl $47, %eax     # immed #f
_L_38423:
# emit-tail-expr
# si=-24
# env=((f6300 . -20) (f6297 . -16) (f6298 . -12) (f6297 . -8))
# expr=(begin (string-set! ((primitive-ref port-buf) f6300) ((primitive-ref port-ndx) f6300) f6297) ((primitive-ref port-ndx-add1) f6300))
# tail-begin (begin (string-set! ((primitive-ref port-buf) f6300) ((primitive-ref port-ndx) f6300) f6297) ((primitive-ref port-ndx-add1) f6300))
#   env=((f6300 . -20) (f6297 . -16) (f6298 . -12) (f6297 . -8))
# emit-expr (string-set! ((primitive-ref port-buf) f6300) ((primitive-ref port-ndx) f6300) f6297)
# emit-expr ((primitive-ref port-buf) f6300)
# funcall
#    si   =-24
#    env  = ((f6300 . -20) (f6297 . -16) (f6298 . -12) (f6297 . -8))
#    expr = (funcall (primitive-ref port-buf) f6300)
# emit-expr (primitive-ref port-buf)
    .extern mrc_port$mbuf
    movl mrc_port$mbuf,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_38429"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_38429":
   movl %eax,  -32(%esp)  # stash funcall-oper in closure slot
# emit-expr f6300
# emit-variable-ref
# env=((f6300 . -20) (f6297 . -16) (f6298 . -12) (f6297 . -8))
# var=f6300
    movl -20(%esp), %eax  # stack load f6300
# end emit-variable-ref
    mov %eax, -36(%esp)  # arg f6300
    movl -32(%esp), %edi   # load new closure to %edi
    add $-24, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $24, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
# check the argument is a string
    movl %eax,%ebx
    and $7, %bl
    cmp $6, %bl
    je _L_38430
# invoke error handler eh_string
    .extern mrc_eh$ustring
    movl mrc_eh$ustring, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $168,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_38430:
    movl %eax, -24(%esp)
# emit-expr ((primitive-ref port-ndx) f6300)
# funcall
#    si   =-24
#    env  = ((f6300 . -20) (f6297 . -16) (f6298 . -12) (f6297 . -8))
#    expr = (funcall (primitive-ref port-ndx) f6300)
# emit-expr (primitive-ref port-ndx)
    .extern mrc_port$mndx
    movl mrc_port$mndx,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_38431"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_38431":
   movl %eax,  -32(%esp)  # stash funcall-oper in closure slot
# emit-expr f6300
# emit-variable-ref
# env=((f6300 . -20) (f6297 . -16) (f6298 . -12) (f6297 . -8))
# var=f6300
    movl -20(%esp), %eax  # stack load f6300
# end emit-variable-ref
    mov %eax, -36(%esp)  # arg f6300
    movl -32(%esp), %edi   # load new closure to %edi
    add $-24, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $24, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_38432"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $168,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_38432:
# check bounds on string index
    movl -24(%esp), %ebx
    cmp  %eax,-6(%ebx) 
    jle _L_38434
    cmp  $0,%eax
    jge _L_38433
_L_38434:
# invoke error handler eh_string_index
    .extern mrc_eh$ustring$uindex
    movl mrc_eh$ustring$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $168,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_38433:
    movl %eax, -28(%esp)
# emit-expr f6297
# emit-variable-ref
# env=((f6300 . -20) (f6297 . -16) (f6298 . -12) (f6297 . -8))
# var=f6297
    movl -16(%esp), %eax  # stack load f6297
# end emit-variable-ref
# check the argument is a char
    movl %eax,%ebx
    and $255, %bl
    cmp $15, %bl
    je "_L_38435"
# invoke error handler eh_character
    .extern mrc_eh$ucharacter
    movl mrc_eh$ucharacter, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $168,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_38435:
    movl -24(%esp), %ebx
    movl -28(%esp), %esi
    sar $2, %esi
    movb  %ah, -2(%ebx,%esi)
# emit-tail-expr
# si=-24
# env=((f6300 . -20) (f6297 . -16) (f6298 . -12) (f6297 . -8))
# expr=(begin ((primitive-ref port-ndx-add1) f6300))
# tail-begin (begin ((primitive-ref port-ndx-add1) f6300))
#   env=((f6300 . -20) (f6297 . -16) (f6298 . -12) (f6297 . -8))
# emit-tail-expr
# si=-24
# env=((f6300 . -20) (f6297 . -16) (f6298 . -12) (f6297 . -8))
# expr=((primitive-ref port-ndx-add1) f6300)
# emit-tail-funcall
#    si   =-24
#    env  = ((f6300 . -20) (f6297 . -16) (f6298 . -12) (f6297 . -8))
#    expr = (funcall (primitive-ref port-ndx-add1) f6300)
# emit-expr (primitive-ref port-ndx-add1)
    .extern mrc_port$mndx$madd1
    movl mrc_port$mndx$madd1,%eax
   movl %eax,  -24(%esp)  # stash funcall-oper in next closure slot
# emit-expr f6300
# emit-variable-ref
# env=((f6300 . -20) (f6297 . -16) (f6298 . -12) (f6297 . -8))
# var=f6300
    movl -20(%esp), %eax  # stack load f6300
# end emit-variable-ref
    mov %eax, -28(%esp)    # arg f6300
    movl -24(%esp), %edi   # load new closure to %edi
# emit-shift-args:  size=2   si=-24  delta=20
    mov -24(%esp), %ebx  # shift frame cell
    mov %ebx, -4(%esp)  # down to base
# emit-shift-args:  size=1   si=-28  delta=20
    mov -28(%esp), %ebx  # shift frame cell
    mov %ebx, -8(%esp)  # down to base
# emit-shift-args:  size=0   si=-32  delta=20
    movl $4,%eax   # save arg count
    jmp *-2(%edi)  # tail-funcall
     ret   # return thru stack
    .align 4,0x90
_L_38414:
     movl %eax, mrc_write$mchar
# == explicit-begins  ==>
# (lambda args (let ((p (if (null? args) (current-output-port) (car args)))) (begin (foreign-call "s_write" (port-fd p) (port-buf p) (port-ndx p)) (port-ndx-reset p))))
# == eliminate-let*  ==>
# (lambda args (let ((p (if (null? args) (current-output-port) (car args)))) (begin (foreign-call "s_write" (port-fd p) (port-buf p) (port-ndx p)) (port-ndx-reset p))))
# == uniquify-variables  ==>
# (lambda f6301 (let ((f6303 (if (null? f6301) (current-output-port) (car f6301)))) (begin (foreign-call "s_write" (port-fd f6303) (port-buf f6303) (port-ndx f6303)) (port-ndx-reset f6303))))
# == vectorize-letrec  ==>
# (lambda f6301 (let ((f6303 (if (null? f6301) (current-output-port) (car f6301)))) (begin (foreign-call "s_write" (port-fd f6303) (port-buf f6303) (port-ndx f6303)) (port-ndx-reset f6303))))
# == eliminate-set!  ==>
# (lambda f6301 (let () (let ((f6303 (if (null? f6301) (current-output-port) (car f6301)))) (begin (foreign-call "s_write" (port-fd f6303) (port-buf f6303) (port-ndx f6303)) (port-ndx-reset f6303)))))
# == close-free-variables  ==>
# (closure f6301 () (let () (let ((f6303 (if (null? f6301) (current-output-port) (car f6301)))) (begin (foreign-call "s_write" (port-fd f6303) (port-buf f6303) (port-ndx f6303)) (port-ndx-reset f6303)))))
# == eliminate-quote  ==>
# (closure f6301 () (let () (let ((f6303 (if (null? f6301) (current-output-port) (car f6301)))) (begin (foreign-call "s_write" (port-fd f6303) (port-buf f6303) (port-ndx f6303)) (port-ndx-reset f6303)))))
# == eliminate-when/unless  ==>
# (closure f6301 () (let () (let ((f6303 (if (null? f6301) (current-output-port) (car f6301)))) (begin (foreign-call "s_write" (port-fd f6303) (port-buf f6303) (port-ndx f6303)) (port-ndx-reset f6303)))))
# == eliminate-cond  ==>
# (closure f6301 () (let () (let ((f6303 (if (null? f6301) (current-output-port) (car f6301)))) (begin (foreign-call "s_write" (port-fd f6303) (port-buf f6303) (port-ndx f6303)) (port-ndx-reset f6303)))))
# == external-symbols  ==>
# (closure f6301 () (let () (let ((f6303 (if (null? f6301) ((primitive-ref current-output-port)) (car f6301)))) (begin (foreign-call "s_write" ((primitive-ref port-fd) f6303) ((primitive-ref port-buf) f6303) ((primitive-ref port-ndx) f6303)) ((primitive-ref port-ndx-reset) f6303)))))
# emit-expr (closure f6301 () (let () (let ((f6303 (if (null? f6301) ((primitive-ref current-output-port)) (car f6301)))) (begin (foreign-call "s_write" ((primitive-ref port-fd) f6303) ((primitive-ref port-buf) f6303) ((primitive-ref port-ndx) f6303)) ((primitive-ref port-ndx-reset) f6303)))))
# emit-closure
# si = 0
# env = ()
# expr = (closure f6301 () (let () (let ((f6303 (if (null? f6301) ((primitive-ref current-output-port)) (car f6301)))) (begin (foreign-call "s_write" ((primitive-ref port-fd) f6303) ((primitive-ref port-buf) f6303) ((primitive-ref port-ndx) f6303)) ((primitive-ref port-ndx-reset) f6303)))))
    movl $_L_38436, 0(%ebp)  # closure label
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $8, %ebp     # bump ebp
    jmp _L_38437            # jump around closure body
_L_38436:
# check argument count
    cmp $0,%eax
    jge _L_38438
# invoke error handler eh_argcount_min
    .extern mrc_eh$uargcount$umin
    movl mrc_eh$uargcount$umin, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_38438:
# emit-build-varargs-list
    movl $63, %esi       # args <- () 
    lea -4(%esp),%edi    # edi <- esp-4
    subl %eax, %edi      # edi <- esp-4-eax    addr of arg[K+N] on stack
_L_38440:
    lea -4(%esp),%ebx    # addr of arg[K] on stack
    cmp %edi, %ebx       # while edi <> esp+(si+4)
    je _L_38439
    movl (%edi),%ebx     # arg i -> car
    movl %ebx, 0(%ebp)
    movl %esi, 4(%ebp)  # esi -> cdr
    movl %ebp, %esi
    addl $1, %esi       # tag as pair
    addl $8,%ebp         # bump heap ptr
    addl $4,%edi         # move to next previous arg from the end
    jmp _L_38440
_L_38439:
    movl %esi, -8(%esp)  # set args
# emit-tail-expr
# si=-12
# env=((f6301 . -8))
# expr=(let () (let ((f6303 (if (null? f6301) ((primitive-ref current-output-port)) (car f6301)))) (begin (foreign-call "s_write" ((primitive-ref port-fd) f6303) ((primitive-ref port-buf) f6303) ((primitive-ref port-ndx) f6303)) ((primitive-ref port-ndx-reset) f6303))))
# emit-tail-let
#  si   = -12
#  env  = ((f6301 . -8))
#  bindings = ()
#  body = (let ((f6303 (if (null? f6301) ((primitive-ref current-output-port)) (car f6301)))) (begin (foreign-call "s_write" ((primitive-ref port-fd) f6303) ((primitive-ref port-buf) f6303) ((primitive-ref port-ndx) f6303)) ((primitive-ref port-ndx-reset) f6303)))
# emit-tail-expr
# si=-12
# env=((f6301 . -8))
# expr=(let ((f6303 (if (null? f6301) ((primitive-ref current-output-port)) (car f6301)))) (begin (foreign-call "s_write" ((primitive-ref port-fd) f6303) ((primitive-ref port-buf) f6303) ((primitive-ref port-ndx) f6303)) ((primitive-ref port-ndx-reset) f6303)))
# emit-tail-let
#  si   = -12
#  env  = ((f6301 . -8))
#  bindings = ((f6303 (if (null? f6301) ((primitive-ref current-output-port)) (car f6301))))
#  body = (begin (foreign-call "s_write" ((primitive-ref port-fd) f6303) ((primitive-ref port-buf) f6303) ((primitive-ref port-ndx) f6303)) ((primitive-ref port-ndx-reset) f6303))
# emit-expr (if (null? f6301) ((primitive-ref current-output-port)) (car f6301))
# emit-expr (null? f6301)
# emit-expr f6301
# emit-variable-ref
# env=((f6301 . -8))
# var=f6301
    movl -8(%esp), %eax  # stack load f6301
# end emit-variable-ref
    cmp $63, %eax
    mov $0, %eax
    sete %al
    movzbl %al, %eax
    sal $6, %al
    or $47, %al
    cmp $47, %al
    je _L_38441
# emit-expr ((primitive-ref current-output-port))
# funcall
#    si   =-12
#    env  = ((f6301 . -8))
#    expr = (funcall (primitive-ref current-output-port))
# emit-expr (primitive-ref current-output-port)
    .extern mrc_current$moutput$mport
    movl mrc_current$moutput$mport,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_38443"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_38443":
   movl %eax,  -20(%esp)  # stash funcall-oper in closure slot
    movl -20(%esp), %edi   # load new closure to %edi
    add $-12, %esp   # adjust base
    movl $0,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $12, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    jmp _L_38442
_L_38441:
# emit-expr (car f6301)
# emit-expr f6301
# emit-variable-ref
# env=((f6301 . -8))
# var=f6301
    movl -8(%esp), %eax  # stack load f6301
# end emit-variable-ref
# check the argument is a pair
    movl %eax,%ebx
    and $7, %bl
    cmp $1, %bl
    je _L_38444
# invoke error handler eh_pair
    .extern mrc_eh$upair
    movl mrc_eh$upair, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $116,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_38444:
    movl -1(%eax), %eax
_L_38442:
    movl %eax, -12(%esp)  # stack save
# emit-tail-expr
# si=-16
# env=((f6303 . -12) (f6301 . -8))
# expr=(begin (foreign-call "s_write" ((primitive-ref port-fd) f6303) ((primitive-ref port-buf) f6303) ((primitive-ref port-ndx) f6303)) ((primitive-ref port-ndx-reset) f6303))
# tail-begin (begin (foreign-call "s_write" ((primitive-ref port-fd) f6303) ((primitive-ref port-buf) f6303) ((primitive-ref port-ndx) f6303)) ((primitive-ref port-ndx-reset) f6303))
#   env=((f6303 . -12) (f6301 . -8))
# emit-expr (foreign-call "s_write" ((primitive-ref port-fd) f6303) ((primitive-ref port-buf) f6303) ((primitive-ref port-ndx) f6303))
    movl %ecx,-16(%esp)
    movl %esp,-20(%esp)
# emit-expr ((primitive-ref port-ndx) f6303)
# funcall
#    si   =-24
#    env  = ((f6303 . -12) (f6301 . -8))
#    expr = (funcall (primitive-ref port-ndx) f6303)
# emit-expr (primitive-ref port-ndx)
    .extern mrc_port$mndx
    movl mrc_port$mndx,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_38445"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_38445":
   movl %eax,  -32(%esp)  # stash funcall-oper in closure slot
# emit-expr f6303
# emit-variable-ref
# env=((f6303 . -12) (f6301 . -8))
# var=f6303
    movl -12(%esp), %eax  # stack load f6303
# end emit-variable-ref
    mov %eax, -36(%esp)  # arg f6303
    movl -32(%esp), %edi   # load new closure to %edi
    add $-24, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $24, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    movl %eax, -24(%esp)
# emit-expr ((primitive-ref port-buf) f6303)
# funcall
#    si   =-28
#    env  = ((f6303 . -12) (f6301 . -8))
#    expr = (funcall (primitive-ref port-buf) f6303)
# emit-expr (primitive-ref port-buf)
    .extern mrc_port$mbuf
    movl mrc_port$mbuf,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_38446"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_38446":
   movl %eax,  -36(%esp)  # stash funcall-oper in closure slot
# emit-expr f6303
# emit-variable-ref
# env=((f6303 . -12) (f6301 . -8))
# var=f6303
    movl -12(%esp), %eax  # stack load f6303
# end emit-variable-ref
    mov %eax, -40(%esp)  # arg f6303
    movl -36(%esp), %edi   # load new closure to %edi
    add $-28, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $28, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    movl %eax, -28(%esp)
# emit-expr ((primitive-ref port-fd) f6303)
# funcall
#    si   =-32
#    env  = ((f6303 . -12) (f6301 . -8))
#    expr = (funcall (primitive-ref port-fd) f6303)
# emit-expr (primitive-ref port-fd)
    .extern mrc_port$mfd
    movl mrc_port$mfd,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_38447"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_38447":
   movl %eax,  -40(%esp)  # stash funcall-oper in closure slot
# emit-expr f6303
# emit-variable-ref
# env=((f6303 . -12) (f6301 . -8))
# var=f6303
    movl -12(%esp), %eax  # stack load f6303
# end emit-variable-ref
    mov %eax, -44(%esp)  # arg f6303
    movl -40(%esp), %edi   # load new closure to %edi
    add $-32, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $32, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    movl %eax, -32(%esp)
    leal -32(%esp),%edi
    movl %edi,%esi
    andl $-16,%esi
    movl 0(%edi),%eax
    movl %eax,0(%esi)
    movl 4(%edi),%eax
    movl %eax,4(%esi)
    movl 8(%edi),%eax
    movl %eax,8(%esi)
    movl 12(%edi),%eax
    movl %eax,12(%esi)
    movl %esi,%esp
    .extern _s_write
    call _s_write
    movl 12(%esi),%esp
    movl -16(%esp),%ecx
# emit-tail-expr
# si=-16
# env=((f6303 . -12) (f6301 . -8))
# expr=(begin ((primitive-ref port-ndx-reset) f6303))
# tail-begin (begin ((primitive-ref port-ndx-reset) f6303))
#   env=((f6303 . -12) (f6301 . -8))
# emit-tail-expr
# si=-16
# env=((f6303 . -12) (f6301 . -8))
# expr=((primitive-ref port-ndx-reset) f6303)
# emit-tail-funcall
#    si   =-16
#    env  = ((f6303 . -12) (f6301 . -8))
#    expr = (funcall (primitive-ref port-ndx-reset) f6303)
# emit-expr (primitive-ref port-ndx-reset)
    .extern mrc_port$mndx$mreset
    movl mrc_port$mndx$mreset,%eax
   movl %eax,  -16(%esp)  # stash funcall-oper in next closure slot
# emit-expr f6303
# emit-variable-ref
# env=((f6303 . -12) (f6301 . -8))
# var=f6303
    movl -12(%esp), %eax  # stack load f6303
# end emit-variable-ref
    mov %eax, -20(%esp)    # arg f6303
    movl -16(%esp), %edi   # load new closure to %edi
# emit-shift-args:  size=2   si=-16  delta=12
    mov -16(%esp), %ebx  # shift frame cell
    mov %ebx, -4(%esp)  # down to base
# emit-shift-args:  size=1   si=-20  delta=12
    mov -20(%esp), %ebx  # shift frame cell
    mov %ebx, -8(%esp)  # down to base
# emit-shift-args:  size=0   si=-24  delta=12
    movl $4,%eax   # save arg count
    jmp *-2(%edi)  # tail-funcall
     ret   # return thru stack
    .align 4,0x90
_L_38437:
     movl %eax, mrc_flush$moutput$mport
# == explicit-begins  ==>
# (lambda () (begin (flush-output-port) (foreign-call "s_exit")))
# == eliminate-let*  ==>
# (lambda () (begin (flush-output-port) (foreign-call "s_exit")))
# == uniquify-variables  ==>
# (lambda () (begin (flush-output-port) (foreign-call "s_exit")))
# == vectorize-letrec  ==>
# (lambda () (begin (flush-output-port) (foreign-call "s_exit")))
# == eliminate-set!  ==>
# (lambda () (let () (begin (flush-output-port) (foreign-call "s_exit"))))
# == close-free-variables  ==>
# (closure () () (let () (begin (flush-output-port) (foreign-call "s_exit"))))
# == eliminate-quote  ==>
# (closure () () (let () (begin (flush-output-port) (foreign-call "s_exit"))))
# == eliminate-when/unless  ==>
# (closure () () (let () (begin (flush-output-port) (foreign-call "s_exit"))))
# == eliminate-cond  ==>
# (closure () () (let () (begin (flush-output-port) (foreign-call "s_exit"))))
# == external-symbols  ==>
# (closure () () (let () (begin ((primitive-ref flush-output-port)) (foreign-call "s_exit"))))
# emit-expr (closure () () (let () (begin ((primitive-ref flush-output-port)) (foreign-call "s_exit"))))
# emit-closure
# si = 0
# env = ()
# expr = (closure () () (let () (begin ((primitive-ref flush-output-port)) (foreign-call "s_exit"))))
    movl $_L_38448, 0(%ebp)  # closure label
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $8, %ebp     # bump ebp
    jmp _L_38449            # jump around closure body
_L_38448:
# check argument count
    cmp $0,%eax
    je _L_38450
# invoke error handler eh_argcount
    .extern mrc_eh$uargcount
    movl mrc_eh$uargcount, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_38450:
# emit-tail-expr
# si=-8
# env=()
# expr=(let () (begin ((primitive-ref flush-output-port)) (foreign-call "s_exit")))
# emit-tail-let
#  si   = -8
#  env  = ()
#  bindings = ()
#  body = (begin ((primitive-ref flush-output-port)) (foreign-call "s_exit"))
# emit-tail-expr
# si=-8
# env=()
# expr=(begin ((primitive-ref flush-output-port)) (foreign-call "s_exit"))
# tail-begin (begin ((primitive-ref flush-output-port)) (foreign-call "s_exit"))
#   env=()
# emit-expr ((primitive-ref flush-output-port))
# funcall
#    si   =-8
#    env  = ()
#    expr = (funcall (primitive-ref flush-output-port))
# emit-expr (primitive-ref flush-output-port)
    .extern mrc_flush$moutput$mport
    movl mrc_flush$moutput$mport,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_38451"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_38451":
   movl %eax,  -16(%esp)  # stash funcall-oper in closure slot
    movl -16(%esp), %edi   # load new closure to %edi
    add $-8, %esp   # adjust base
    movl $0,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $8, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
# emit-tail-expr
# si=-8
# env=()
# expr=(begin (foreign-call "s_exit"))
# tail-begin (begin (foreign-call "s_exit"))
#   env=()
# emit-tail-expr
# si=-8
# env=()
# expr=(foreign-call "s_exit")
    movl %ecx,-8(%esp)
    movl %esp,-12(%esp)
    leal -12(%esp),%edi
    movl %edi,%esi
    andl $-16,%esi
    movl 0(%edi),%eax
    movl %eax,0(%esi)
    movl %esi,%esp
    .extern _s_exit
    call _s_exit
    movl 0(%esi),%esp
    movl -8(%esp),%ecx
     ret
     ret   # return thru stack
    .align 4,0x90
_L_38449:
     movl %eax, mrc_exit
# == explicit-begins  ==>
# (lambda (filename) (begin (unless (string? filename) (error (quote open-output-file) "filename must be a string")) (let ((fd (foreign-call "s_open" filename))) (begin (when (negative? fd) (error (quote open-output-file) "open failed")) (let ((p (make-vector 6)) (sz 1024)) (begin (vector-set! p 0 (quote output-port)) (vector-set! p 1 filename) (vector-set! p 2 fd) (vector-set! p 3 (make-string sz)) (vector-set! p 4 0) (vector-set! p 5 sz) p))))))
# == eliminate-let*  ==>
# (lambda (filename) (begin (unless (string? filename) (error (quote open-output-file) "filename must be a string")) (let ((fd (foreign-call "s_open" filename))) (begin (when (negative? fd) (error (quote open-output-file) "open failed")) (let ((p (make-vector 6)) (sz 1024)) (begin (vector-set! p 0 (quote output-port)) (vector-set! p 1 filename) (vector-set! p 2 fd) (vector-set! p 3 (make-string sz)) (vector-set! p 4 0) (vector-set! p 5 sz) p))))))
# == uniquify-variables  ==>
# (lambda (f6304) (begin (unless (string? f6304) (error (quote open-output-file) "filename must be a string")) (let ((f6310 (foreign-call "s_open" f6304))) (begin (when (negative? f6310) (error (quote open-output-file) "open failed")) (let ((f6314 (make-vector 6)) (f6313 1024)) (begin (vector-set! f6314 0 (quote output-port)) (vector-set! f6314 1 f6304) (vector-set! f6314 2 f6310) (vector-set! f6314 3 (make-string f6313)) (vector-set! f6314 4 0) (vector-set! f6314 5 f6313) f6314))))))
# == vectorize-letrec  ==>
# (lambda (f6304) (begin (unless (string? f6304) (error (quote open-output-file) "filename must be a string")) (let ((f6310 (foreign-call "s_open" f6304))) (begin (when (negative? f6310) (error (quote open-output-file) "open failed")) (let ((f6314 (make-vector 6)) (f6313 1024)) (begin (vector-set! f6314 0 (quote output-port)) (vector-set! f6314 1 f6304) (vector-set! f6314 2 f6310) (vector-set! f6314 3 (make-string f6313)) (vector-set! f6314 4 0) (vector-set! f6314 5 f6313) f6314))))))
# == eliminate-set!  ==>
# (lambda (f6304) (let ((f6304 f6304)) (begin (unless (string? f6304) (error (quote open-output-file) "filename must be a string")) (let ((f6310 (foreign-call "s_open" f6304))) (begin (when (negative? f6310) (error (quote open-output-file) "open failed")) (let ((f6314 (make-vector 6)) (f6313 1024)) (begin (vector-set! f6314 0 (quote output-port)) (vector-set! f6314 1 f6304) (vector-set! f6314 2 f6310) (vector-set! f6314 3 (make-string f6313)) (vector-set! f6314 4 0) (vector-set! f6314 5 f6313) f6314)))))))
# == close-free-variables  ==>
# (closure (f6304) (output-port) (let ((f6304 f6304)) (begin (unless (string? f6304) (error (quote open-output-file) "filename must be a string")) (let ((f6310 (foreign-call "s_open" f6304))) (begin (when (negative? f6310) (error (quote open-output-file) "open failed")) (let ((f6314 (make-vector 6)) (f6313 1024)) (begin (vector-set! f6314 0 (quote output-port)) (vector-set! f6314 1 f6304) (vector-set! f6314 2 f6310) (vector-set! f6314 3 (make-string f6313)) (vector-set! f6314 4 0) (vector-set! f6314 5 f6313) f6314)))))))
# == eliminate-quote  ==>
# (closure (f6304) (output-port) (let ((f6304 f6304)) (begin (unless (string? f6304) (error (string->symbol "open-output-file") "filename must be a string")) (let ((f6310 (foreign-call "s_open" f6304))) (begin (when (negative? f6310) (error (string->symbol "open-output-file") "open failed")) (let ((f6314 (make-vector 6)) (f6313 1024)) (begin (vector-set! f6314 0 (string->symbol "output-port")) (vector-set! f6314 1 f6304) (vector-set! f6314 2 f6310) (vector-set! f6314 3 (make-string f6313)) (vector-set! f6314 4 0) (vector-set! f6314 5 f6313) f6314)))))))
# == eliminate-when/unless  ==>
# (closure (f6304) (output-port) (let ((f6304 f6304)) (begin (if (not (string? f6304)) (begin (error (string->symbol "open-output-file") "filename must be a string")) #f) (let ((f6310 (foreign-call "s_open" f6304))) (begin (if (negative? f6310) (begin (error (string->symbol "open-output-file") "open failed")) #f) (let ((f6314 (make-vector 6)) (f6313 1024)) (begin (vector-set! f6314 0 (string->symbol "output-port")) (vector-set! f6314 1 f6304) (vector-set! f6314 2 f6310) (vector-set! f6314 3 (make-string f6313)) (vector-set! f6314 4 0) (vector-set! f6314 5 f6313) f6314)))))))
# == eliminate-cond  ==>
# (closure (f6304) (output-port) (let ((f6304 f6304)) (begin (if (not (string? f6304)) (begin (error (string->symbol "open-output-file") "filename must be a string")) #f) (let ((f6310 (foreign-call "s_open" f6304))) (begin (if (negative? f6310) (begin (error (string->symbol "open-output-file") "open failed")) #f) (let ((f6314 (make-vector 6)) (f6313 1024)) (begin (vector-set! f6314 0 (string->symbol "output-port")) (vector-set! f6314 1 f6304) (vector-set! f6314 2 f6310) (vector-set! f6314 3 (make-string f6313)) (vector-set! f6314 4 0) (vector-set! f6314 5 f6313) f6314)))))))
# == external-symbols  ==>
# (closure (f6304) (output-port) (let ((f6304 f6304)) (begin (if (not (string? f6304)) (begin ((primitive-ref error) ((primitive-ref string->symbol) "open-output-file") "filename must be a string")) #f) (let ((f6310 (foreign-call "s_open" f6304))) (begin (if ((primitive-ref negative?) f6310) (begin ((primitive-ref error) ((primitive-ref string->symbol) "open-output-file") "open failed")) #f) (let ((f6314 (make-vector 6)) (f6313 1024)) (begin (vector-set! f6314 0 ((primitive-ref string->symbol) "output-port")) (vector-set! f6314 1 f6304) (vector-set! f6314 2 f6310) (vector-set! f6314 3 (make-string f6313)) (vector-set! f6314 4 0) (vector-set! f6314 5 f6313) f6314)))))))
# emit-expr (closure (f6304) (output-port) (let ((f6304 f6304)) (begin (if (not (string? f6304)) (begin ((primitive-ref error) ((primitive-ref string->symbol) "open-output-file") "filename must be a string")) #f) (let ((f6310 (foreign-call "s_open" f6304))) (begin (if ((primitive-ref negative?) f6310) (begin ((primitive-ref error) ((primitive-ref string->symbol) "open-output-file") "open failed")) #f) (let ((f6314 (make-vector 6)) (f6313 1024)) (begin (vector-set! f6314 0 ((primitive-ref string->symbol) "output-port")) (vector-set! f6314 1 f6304) (vector-set! f6314 2 f6310) (vector-set! f6314 3 (make-string f6313)) (vector-set! f6314 4 0) (vector-set! f6314 5 f6313) f6314)))))))
# emit-closure
# si = 0
# env = ()
# expr = (closure (f6304) (output-port) (let ((f6304 f6304)) (begin (if (not (string? f6304)) (begin ((primitive-ref error) ((primitive-ref string->symbol) "open-output-file") "filename must be a string")) #f) (let ((f6310 (foreign-call "s_open" f6304))) (begin (if ((primitive-ref negative?) f6310) (begin ((primitive-ref error) ((primitive-ref string->symbol) "open-output-file") "open failed")) #f) (let ((f6314 (make-vector 6)) (f6313 1024)) (begin (vector-set! f6314 0 ((primitive-ref string->symbol) "output-port")) (vector-set! f6314 1 f6304) (vector-set! f6314 2 f6310) (vector-set! f6314 3 (make-string f6313)) (vector-set! f6314 4 0) (vector-set! f6314 5 f6313) f6314)))))))
    movl $_L_38452, 0(%ebp)  # closure label
# WARNING: free var output-port not defined in the environmnet
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $8, %ebp     # bump ebp
    jmp _L_38453            # jump around closure body
_L_38452:
# check argument count
    cmp $4,%eax
    je _L_38454
# invoke error handler eh_argcount
    .extern mrc_eh$uargcount
    movl mrc_eh$uargcount, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_38454:
# emit-tail-expr
# si=-12
# env=((f6304 . -8) (output-port . 4))
# expr=(let ((f6304 f6304)) (begin (if (not (string? f6304)) (begin ((primitive-ref error) ((primitive-ref string->symbol) "open-output-file") "filename must be a string")) #f) (let ((f6310 (foreign-call "s_open" f6304))) (begin (if ((primitive-ref negative?) f6310) (begin ((primitive-ref error) ((primitive-ref string->symbol) "open-output-file") "open failed")) #f) (let ((f6314 (make-vector 6)) (f6313 1024)) (begin (vector-set! f6314 0 ((primitive-ref string->symbol) "output-port")) (vector-set! f6314 1 f6304) (vector-set! f6314 2 f6310) (vector-set! f6314 3 (make-string f6313)) (vector-set! f6314 4 0) (vector-set! f6314 5 f6313) f6314))))))
# emit-tail-let
#  si   = -12
#  env  = ((f6304 . -8) (output-port . 4))
#  bindings = ((f6304 f6304))
#  body = (begin (if (not (string? f6304)) (begin ((primitive-ref error) ((primitive-ref string->symbol) "open-output-file") "filename must be a string")) #f) (let ((f6310 (foreign-call "s_open" f6304))) (begin (if ((primitive-ref negative?) f6310) (begin ((primitive-ref error) ((primitive-ref string->symbol) "open-output-file") "open failed")) #f) (let ((f6314 (make-vector 6)) (f6313 1024)) (begin (vector-set! f6314 0 ((primitive-ref string->symbol) "output-port")) (vector-set! f6314 1 f6304) (vector-set! f6314 2 f6310) (vector-set! f6314 3 (make-string f6313)) (vector-set! f6314 4 0) (vector-set! f6314 5 f6313) f6314)))))
# emit-expr f6304
# emit-variable-ref
# env=((f6304 . -8) (output-port . 4))
# var=f6304
    movl -8(%esp), %eax  # stack load f6304
# end emit-variable-ref
    movl %eax, -12(%esp)  # stack save
# emit-tail-expr
# si=-16
# env=((f6304 . -12) (f6304 . -8) (output-port . 4))
# expr=(begin (if (not (string? f6304)) (begin ((primitive-ref error) ((primitive-ref string->symbol) "open-output-file") "filename must be a string")) #f) (let ((f6310 (foreign-call "s_open" f6304))) (begin (if ((primitive-ref negative?) f6310) (begin ((primitive-ref error) ((primitive-ref string->symbol) "open-output-file") "open failed")) #f) (let ((f6314 (make-vector 6)) (f6313 1024)) (begin (vector-set! f6314 0 ((primitive-ref string->symbol) "output-port")) (vector-set! f6314 1 f6304) (vector-set! f6314 2 f6310) (vector-set! f6314 3 (make-string f6313)) (vector-set! f6314 4 0) (vector-set! f6314 5 f6313) f6314)))))
# tail-begin (begin (if (not (string? f6304)) (begin ((primitive-ref error) ((primitive-ref string->symbol) "open-output-file") "filename must be a string")) #f) (let ((f6310 (foreign-call "s_open" f6304))) (begin (if ((primitive-ref negative?) f6310) (begin ((primitive-ref error) ((primitive-ref string->symbol) "open-output-file") "open failed")) #f) (let ((f6314 (make-vector 6)) (f6313 1024)) (begin (vector-set! f6314 0 ((primitive-ref string->symbol) "output-port")) (vector-set! f6314 1 f6304) (vector-set! f6314 2 f6310) (vector-set! f6314 3 (make-string f6313)) (vector-set! f6314 4 0) (vector-set! f6314 5 f6313) f6314)))))
#   env=((f6304 . -12) (f6304 . -8) (output-port . 4))
# emit-expr (if (not (string? f6304)) (begin ((primitive-ref error) ((primitive-ref string->symbol) "open-output-file") "filename must be a string")) #f)
# emit-expr (not (string? f6304))
# emit-expr (string? f6304)
# emit-expr f6304
# emit-variable-ref
# env=((f6304 . -12) (f6304 . -8) (output-port . 4))
# var=f6304
    movl -12(%esp), %eax  # stack load f6304
# end emit-variable-ref
    and $7, %al
    cmp $6, %al
    sete %al
    movzbl %al, %eax
    sal $6, %al
    or $47, %al
    cmp $47, %eax
    sete %al
    movzbl %al, %eax
    sal $6, %al
    or $47, %al
    cmp $47, %al
    je _L_38455
# emit-expr (begin ((primitive-ref error) ((primitive-ref string->symbol) "open-output-file") "filename must be a string"))
# emit-begin
#   expr=(begin ((primitive-ref error) ((primitive-ref string->symbol) "open-output-file") "filename must be a string"))
#   env=((f6304 . -12) (f6304 . -8) (output-port . 4))
# emit-expr ((primitive-ref error) ((primitive-ref string->symbol) "open-output-file") "filename must be a string")
# funcall
#    si   =-16
#    env  = ((f6304 . -12) (f6304 . -8) (output-port . 4))
#    expr = (funcall (primitive-ref error) ((primitive-ref string->symbol) "open-output-file") "filename must be a string")
# emit-expr (primitive-ref error)
    .extern mrc_error
    movl mrc_error,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_38457"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_38457":
   movl %eax,  -24(%esp)  # stash funcall-oper in closure slot
# emit-expr ((primitive-ref string->symbol) "open-output-file")
# funcall
#    si   =-28
#    env  = ((f6304 . -12) (f6304 . -8) (output-port . 4))
#    expr = (funcall (primitive-ref string->symbol) "open-output-file")
# emit-expr (primitive-ref string->symbol)
    .extern mrc_string$m$gsymbol
    movl mrc_string$m$gsymbol,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_38458"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_38458":
   movl %eax,  -36(%esp)  # stash funcall-oper in closure slot
# emit-expr "open-output-file"
# string literal
    jmp _L_38460
    .align 8,0x90
_L_38459 :
    .int 64
    .ascii "open-output-file"
_L_38460:
    movl $_L_38459, %eax
    orl $6, %eax
    mov %eax, -40(%esp)  # arg open-output-file
    movl -36(%esp), %edi   # load new closure to %edi
    add $-28, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $28, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    mov %eax, -28(%esp)  # arg ((primitive-ref string->symbol) open-output-file)
# emit-expr "filename must be a string"
# string literal
    jmp _L_38462
    .align 8,0x90
_L_38461 :
    .int 100
    .ascii "filename must be a string"
_L_38462:
    movl $_L_38461, %eax
    orl $6, %eax
    mov %eax, -32(%esp)  # arg filename must be a string
    movl -24(%esp), %edi   # load new closure to %edi
    add $-16, %esp   # adjust base
    movl $8,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $16, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
# emit-expr (begin)
# emit-begin
#   expr=(begin)
#   env=((f6304 . -12) (f6304 . -8) (output-port . 4))
    jmp _L_38456
_L_38455:
# emit-expr #f
    movl $47, %eax     # immed #f
_L_38456:
# emit-tail-expr
# si=-16
# env=((f6304 . -12) (f6304 . -8) (output-port . 4))
# expr=(begin (let ((f6310 (foreign-call "s_open" f6304))) (begin (if ((primitive-ref negative?) f6310) (begin ((primitive-ref error) ((primitive-ref string->symbol) "open-output-file") "open failed")) #f) (let ((f6314 (make-vector 6)) (f6313 1024)) (begin (vector-set! f6314 0 ((primitive-ref string->symbol) "output-port")) (vector-set! f6314 1 f6304) (vector-set! f6314 2 f6310) (vector-set! f6314 3 (make-string f6313)) (vector-set! f6314 4 0) (vector-set! f6314 5 f6313) f6314)))))
# tail-begin (begin (let ((f6310 (foreign-call "s_open" f6304))) (begin (if ((primitive-ref negative?) f6310) (begin ((primitive-ref error) ((primitive-ref string->symbol) "open-output-file") "open failed")) #f) (let ((f6314 (make-vector 6)) (f6313 1024)) (begin (vector-set! f6314 0 ((primitive-ref string->symbol) "output-port")) (vector-set! f6314 1 f6304) (vector-set! f6314 2 f6310) (vector-set! f6314 3 (make-string f6313)) (vector-set! f6314 4 0) (vector-set! f6314 5 f6313) f6314)))))
#   env=((f6304 . -12) (f6304 . -8) (output-port . 4))
# emit-tail-expr
# si=-16
# env=((f6304 . -12) (f6304 . -8) (output-port . 4))
# expr=(let ((f6310 (foreign-call "s_open" f6304))) (begin (if ((primitive-ref negative?) f6310) (begin ((primitive-ref error) ((primitive-ref string->symbol) "open-output-file") "open failed")) #f) (let ((f6314 (make-vector 6)) (f6313 1024)) (begin (vector-set! f6314 0 ((primitive-ref string->symbol) "output-port")) (vector-set! f6314 1 f6304) (vector-set! f6314 2 f6310) (vector-set! f6314 3 (make-string f6313)) (vector-set! f6314 4 0) (vector-set! f6314 5 f6313) f6314))))
# emit-tail-let
#  si   = -16
#  env  = ((f6304 . -12) (f6304 . -8) (output-port . 4))
#  bindings = ((f6310 (foreign-call "s_open" f6304)))
#  body = (begin (if ((primitive-ref negative?) f6310) (begin ((primitive-ref error) ((primitive-ref string->symbol) "open-output-file") "open failed")) #f) (let ((f6314 (make-vector 6)) (f6313 1024)) (begin (vector-set! f6314 0 ((primitive-ref string->symbol) "output-port")) (vector-set! f6314 1 f6304) (vector-set! f6314 2 f6310) (vector-set! f6314 3 (make-string f6313)) (vector-set! f6314 4 0) (vector-set! f6314 5 f6313) f6314)))
# emit-expr (foreign-call "s_open" f6304)
    movl %ecx,-16(%esp)
    movl %esp,-20(%esp)
# emit-expr f6304
# emit-variable-ref
# env=((f6304 . -12) (f6304 . -8) (output-port . 4))
# var=f6304
    movl -12(%esp), %eax  # stack load f6304
# end emit-variable-ref
    movl %eax, -24(%esp)
    leal -24(%esp),%edi
    movl %edi,%esi
    andl $-16,%esi
    movl 0(%edi),%eax
    movl %eax,0(%esi)
    movl 4(%edi),%eax
    movl %eax,4(%esi)
    movl %esi,%esp
    .extern _s_open
    call _s_open
    movl 4(%esi),%esp
    movl -16(%esp),%ecx
    movl %eax, -16(%esp)  # stack save
# emit-tail-expr
# si=-20
# env=((f6310 . -16) (f6304 . -12) (f6304 . -8) (output-port . 4))
# expr=(begin (if ((primitive-ref negative?) f6310) (begin ((primitive-ref error) ((primitive-ref string->symbol) "open-output-file") "open failed")) #f) (let ((f6314 (make-vector 6)) (f6313 1024)) (begin (vector-set! f6314 0 ((primitive-ref string->symbol) "output-port")) (vector-set! f6314 1 f6304) (vector-set! f6314 2 f6310) (vector-set! f6314 3 (make-string f6313)) (vector-set! f6314 4 0) (vector-set! f6314 5 f6313) f6314)))
# tail-begin (begin (if ((primitive-ref negative?) f6310) (begin ((primitive-ref error) ((primitive-ref string->symbol) "open-output-file") "open failed")) #f) (let ((f6314 (make-vector 6)) (f6313 1024)) (begin (vector-set! f6314 0 ((primitive-ref string->symbol) "output-port")) (vector-set! f6314 1 f6304) (vector-set! f6314 2 f6310) (vector-set! f6314 3 (make-string f6313)) (vector-set! f6314 4 0) (vector-set! f6314 5 f6313) f6314)))
#   env=((f6310 . -16) (f6304 . -12) (f6304 . -8) (output-port . 4))
# emit-expr (if ((primitive-ref negative?) f6310) (begin ((primitive-ref error) ((primitive-ref string->symbol) "open-output-file") "open failed")) #f)
# emit-expr ((primitive-ref negative?) f6310)
# funcall
#    si   =-20
#    env  = ((f6310 . -16) (f6304 . -12) (f6304 . -8) (output-port . 4))
#    expr = (funcall (primitive-ref negative?) f6310)
# emit-expr (primitive-ref negative?)
    .extern mrc_negative$q
    movl mrc_negative$q,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_38465"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_38465":
   movl %eax,  -28(%esp)  # stash funcall-oper in closure slot
# emit-expr f6310
# emit-variable-ref
# env=((f6310 . -16) (f6304 . -12) (f6304 . -8) (output-port . 4))
# var=f6310
    movl -16(%esp), %eax  # stack load f6310
# end emit-variable-ref
    mov %eax, -32(%esp)  # arg f6310
    movl -28(%esp), %edi   # load new closure to %edi
    add $-20, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $20, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    cmp $47, %al
    je _L_38463
# emit-expr (begin ((primitive-ref error) ((primitive-ref string->symbol) "open-output-file") "open failed"))
# emit-begin
#   expr=(begin ((primitive-ref error) ((primitive-ref string->symbol) "open-output-file") "open failed"))
#   env=((f6310 . -16) (f6304 . -12) (f6304 . -8) (output-port . 4))
# emit-expr ((primitive-ref error) ((primitive-ref string->symbol) "open-output-file") "open failed")
# funcall
#    si   =-20
#    env  = ((f6310 . -16) (f6304 . -12) (f6304 . -8) (output-port . 4))
#    expr = (funcall (primitive-ref error) ((primitive-ref string->symbol) "open-output-file") "open failed")
# emit-expr (primitive-ref error)
    .extern mrc_error
    movl mrc_error,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_38466"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_38466":
   movl %eax,  -28(%esp)  # stash funcall-oper in closure slot
# emit-expr ((primitive-ref string->symbol) "open-output-file")
# funcall
#    si   =-32
#    env  = ((f6310 . -16) (f6304 . -12) (f6304 . -8) (output-port . 4))
#    expr = (funcall (primitive-ref string->symbol) "open-output-file")
# emit-expr (primitive-ref string->symbol)
    .extern mrc_string$m$gsymbol
    movl mrc_string$m$gsymbol,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_38467"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_38467":
   movl %eax,  -40(%esp)  # stash funcall-oper in closure slot
# emit-expr "open-output-file"
# string literal
    jmp _L_38469
    .align 8,0x90
_L_38468 :
    .int 64
    .ascii "open-output-file"
_L_38469:
    movl $_L_38468, %eax
    orl $6, %eax
    mov %eax, -44(%esp)  # arg open-output-file
    movl -40(%esp), %edi   # load new closure to %edi
    add $-32, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $32, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    mov %eax, -32(%esp)  # arg ((primitive-ref string->symbol) open-output-file)
# emit-expr "open failed"
# string literal
    jmp _L_38471
    .align 8,0x90
_L_38470 :
    .int 44
    .ascii "open failed"
_L_38471:
    movl $_L_38470, %eax
    orl $6, %eax
    mov %eax, -36(%esp)  # arg open failed
    movl -28(%esp), %edi   # load new closure to %edi
    add $-20, %esp   # adjust base
    movl $8,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $20, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
# emit-expr (begin)
# emit-begin
#   expr=(begin)
#   env=((f6310 . -16) (f6304 . -12) (f6304 . -8) (output-port . 4))
    jmp _L_38464
_L_38463:
# emit-expr #f
    movl $47, %eax     # immed #f
_L_38464:
# emit-tail-expr
# si=-20
# env=((f6310 . -16) (f6304 . -12) (f6304 . -8) (output-port . 4))
# expr=(begin (let ((f6314 (make-vector 6)) (f6313 1024)) (begin (vector-set! f6314 0 ((primitive-ref string->symbol) "output-port")) (vector-set! f6314 1 f6304) (vector-set! f6314 2 f6310) (vector-set! f6314 3 (make-string f6313)) (vector-set! f6314 4 0) (vector-set! f6314 5 f6313) f6314)))
# tail-begin (begin (let ((f6314 (make-vector 6)) (f6313 1024)) (begin (vector-set! f6314 0 ((primitive-ref string->symbol) "output-port")) (vector-set! f6314 1 f6304) (vector-set! f6314 2 f6310) (vector-set! f6314 3 (make-string f6313)) (vector-set! f6314 4 0) (vector-set! f6314 5 f6313) f6314)))
#   env=((f6310 . -16) (f6304 . -12) (f6304 . -8) (output-port . 4))
# emit-tail-expr
# si=-20
# env=((f6310 . -16) (f6304 . -12) (f6304 . -8) (output-port . 4))
# expr=(let ((f6314 (make-vector 6)) (f6313 1024)) (begin (vector-set! f6314 0 ((primitive-ref string->symbol) "output-port")) (vector-set! f6314 1 f6304) (vector-set! f6314 2 f6310) (vector-set! f6314 3 (make-string f6313)) (vector-set! f6314 4 0) (vector-set! f6314 5 f6313) f6314))
# emit-tail-let
#  si   = -20
#  env  = ((f6310 . -16) (f6304 . -12) (f6304 . -8) (output-port . 4))
#  bindings = ((f6314 (make-vector 6)) (f6313 1024))
#  body = (begin (vector-set! f6314 0 ((primitive-ref string->symbol) "output-port")) (vector-set! f6314 1 f6304) (vector-set! f6314 2 f6310) (vector-set! f6314 3 (make-string f6313)) (vector-set! f6314 4 0) (vector-set! f6314 5 f6313) f6314)
# emit-expr (make-vector 6)
# make-vector 6
# emit-expr 6
    movl $24, %eax     # immed 6
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_38472"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_38472:
# check the argument is a fixnum >= 0
    cmp $0,%eax
    jge _L_38473
# invoke error handler eh_length
    .extern mrc_eh$ulength
    movl mrc_eh$ulength, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_38473:
    movl %eax, %esi
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    orl  $5, %eax
    addl $4, %esi
    addl $4, %esi
    andl $-8, %esi
    addl %esi, %ebp
    movl %eax, -20(%esp)  # stack save
# emit-expr 1024
    movl $4096, %eax     # immed 1024
    movl %eax, -24(%esp)  # stack save
# emit-tail-expr
# si=-28
# env=((f6313 . -24) (f6314 . -20) (f6310 . -16) (f6304 . -12) (f6304 . -8) (output-port . 4))
# expr=(begin (vector-set! f6314 0 ((primitive-ref string->symbol) "output-port")) (vector-set! f6314 1 f6304) (vector-set! f6314 2 f6310) (vector-set! f6314 3 (make-string f6313)) (vector-set! f6314 4 0) (vector-set! f6314 5 f6313) f6314)
# tail-begin (begin (vector-set! f6314 0 ((primitive-ref string->symbol) "output-port")) (vector-set! f6314 1 f6304) (vector-set! f6314 2 f6310) (vector-set! f6314 3 (make-string f6313)) (vector-set! f6314 4 0) (vector-set! f6314 5 f6313) f6314)
#   env=((f6313 . -24) (f6314 . -20) (f6310 . -16) (f6304 . -12) (f6304 . -8) (output-port . 4))
# emit-expr (vector-set! f6314 0 ((primitive-ref string->symbol) "output-port"))
# emit-expr f6314
# emit-variable-ref
# env=((f6313 . -24) (f6314 . -20) (f6310 . -16) (f6304 . -12) (f6304 . -8) (output-port . 4))
# var=f6314
    movl -20(%esp), %eax  # stack load f6314
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_38474
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_38474:
    movl %eax, -28(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_38475"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_38475:
# check bounds on vector index
    movl -28(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_38477
    cmp  $0,%eax
    jge _L_38476
_L_38477:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_38476:
    movl %eax, -32(%esp)
# emit-expr ((primitive-ref string->symbol) "output-port")
# funcall
#    si   =-36
#    env  = ((f6313 . -24) (f6314 . -20) (f6310 . -16) (f6304 . -12) (f6304 . -8) (output-port . 4))
#    expr = (funcall (primitive-ref string->symbol) "output-port")
# emit-expr (primitive-ref string->symbol)
    .extern mrc_string$m$gsymbol
    movl mrc_string$m$gsymbol,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_38478"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_38478":
   movl %eax,  -44(%esp)  # stash funcall-oper in closure slot
# emit-expr "output-port"
# string literal
    jmp _L_38480
    .align 8,0x90
_L_38479 :
    .int 44
    .ascii "output-port"
_L_38480:
    movl $_L_38479, %eax
    orl $6, %eax
    mov %eax, -48(%esp)  # arg output-port
    movl -44(%esp), %edi   # load new closure to %edi
    add $-36, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $36, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    movl -28(%esp), %ebx
    movl -32(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-tail-expr
# si=-28
# env=((f6313 . -24) (f6314 . -20) (f6310 . -16) (f6304 . -12) (f6304 . -8) (output-port . 4))
# expr=(begin (vector-set! f6314 1 f6304) (vector-set! f6314 2 f6310) (vector-set! f6314 3 (make-string f6313)) (vector-set! f6314 4 0) (vector-set! f6314 5 f6313) f6314)
# tail-begin (begin (vector-set! f6314 1 f6304) (vector-set! f6314 2 f6310) (vector-set! f6314 3 (make-string f6313)) (vector-set! f6314 4 0) (vector-set! f6314 5 f6313) f6314)
#   env=((f6313 . -24) (f6314 . -20) (f6310 . -16) (f6304 . -12) (f6304 . -8) (output-port . 4))
# emit-expr (vector-set! f6314 1 f6304)
# emit-expr f6314
# emit-variable-ref
# env=((f6313 . -24) (f6314 . -20) (f6310 . -16) (f6304 . -12) (f6304 . -8) (output-port . 4))
# var=f6314
    movl -20(%esp), %eax  # stack load f6314
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_38481
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_38481:
    movl %eax, -28(%esp)
# emit-expr 1
    movl $4, %eax     # immed 1
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_38482"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_38482:
# check bounds on vector index
    movl -28(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_38484
    cmp  $0,%eax
    jge _L_38483
_L_38484:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_38483:
    movl %eax, -32(%esp)
# emit-expr f6304
# emit-variable-ref
# env=((f6313 . -24) (f6314 . -20) (f6310 . -16) (f6304 . -12) (f6304 . -8) (output-port . 4))
# var=f6304
    movl -12(%esp), %eax  # stack load f6304
# end emit-variable-ref
    movl -28(%esp), %ebx
    movl -32(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-tail-expr
# si=-28
# env=((f6313 . -24) (f6314 . -20) (f6310 . -16) (f6304 . -12) (f6304 . -8) (output-port . 4))
# expr=(begin (vector-set! f6314 2 f6310) (vector-set! f6314 3 (make-string f6313)) (vector-set! f6314 4 0) (vector-set! f6314 5 f6313) f6314)
# tail-begin (begin (vector-set! f6314 2 f6310) (vector-set! f6314 3 (make-string f6313)) (vector-set! f6314 4 0) (vector-set! f6314 5 f6313) f6314)
#   env=((f6313 . -24) (f6314 . -20) (f6310 . -16) (f6304 . -12) (f6304 . -8) (output-port . 4))
# emit-expr (vector-set! f6314 2 f6310)
# emit-expr f6314
# emit-variable-ref
# env=((f6313 . -24) (f6314 . -20) (f6310 . -16) (f6304 . -12) (f6304 . -8) (output-port . 4))
# var=f6314
    movl -20(%esp), %eax  # stack load f6314
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_38485
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_38485:
    movl %eax, -28(%esp)
# emit-expr 2
    movl $8, %eax     # immed 2
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_38486"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_38486:
# check bounds on vector index
    movl -28(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_38488
    cmp  $0,%eax
    jge _L_38487
_L_38488:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_38487:
    movl %eax, -32(%esp)
# emit-expr f6310
# emit-variable-ref
# env=((f6313 . -24) (f6314 . -20) (f6310 . -16) (f6304 . -12) (f6304 . -8) (output-port . 4))
# var=f6310
    movl -16(%esp), %eax  # stack load f6310
# end emit-variable-ref
    movl -28(%esp), %ebx
    movl -32(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-tail-expr
# si=-28
# env=((f6313 . -24) (f6314 . -20) (f6310 . -16) (f6304 . -12) (f6304 . -8) (output-port . 4))
# expr=(begin (vector-set! f6314 3 (make-string f6313)) (vector-set! f6314 4 0) (vector-set! f6314 5 f6313) f6314)
# tail-begin (begin (vector-set! f6314 3 (make-string f6313)) (vector-set! f6314 4 0) (vector-set! f6314 5 f6313) f6314)
#   env=((f6313 . -24) (f6314 . -20) (f6310 . -16) (f6304 . -12) (f6304 . -8) (output-port . 4))
# emit-expr (vector-set! f6314 3 (make-string f6313))
# emit-expr f6314
# emit-variable-ref
# env=((f6313 . -24) (f6314 . -20) (f6310 . -16) (f6304 . -12) (f6304 . -8) (output-port . 4))
# var=f6314
    movl -20(%esp), %eax  # stack load f6314
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_38489
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_38489:
    movl %eax, -28(%esp)
# emit-expr 3
    movl $12, %eax     # immed 3
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_38490"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_38490:
# check bounds on vector index
    movl -28(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_38492
    cmp  $0,%eax
    jge _L_38491
_L_38492:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_38491:
    movl %eax, -32(%esp)
# emit-expr (make-string f6313)
# make-string len=f6313
# emit-expr f6313
# emit-variable-ref
# env=((f6313 . -24) (f6314 . -20) (f6310 . -16) (f6304 . -12) (f6304 . -8) (output-port . 4))
# var=f6313
    movl -24(%esp), %eax  # stack load f6313
# end emit-variable-ref
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_38493"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $152,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_38493:
# check the argument is a fixnum >= 0
    cmp $0,%eax
    jge _L_38494
# invoke error handler eh_length
    .extern mrc_eh$ulength
    movl mrc_eh$ulength, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $152,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_38494:
    movl %eax, %esi
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    orl $6, %eax
    sar $2, %esi
    add $4, %esi
    add $7, %esi
    andl $-8, %esi
    add  %esi, %ebp
# make-string end
    movl -28(%esp), %ebx
    movl -32(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-tail-expr
# si=-28
# env=((f6313 . -24) (f6314 . -20) (f6310 . -16) (f6304 . -12) (f6304 . -8) (output-port . 4))
# expr=(begin (vector-set! f6314 4 0) (vector-set! f6314 5 f6313) f6314)
# tail-begin (begin (vector-set! f6314 4 0) (vector-set! f6314 5 f6313) f6314)
#   env=((f6313 . -24) (f6314 . -20) (f6310 . -16) (f6304 . -12) (f6304 . -8) (output-port . 4))
# emit-expr (vector-set! f6314 4 0)
# emit-expr f6314
# emit-variable-ref
# env=((f6313 . -24) (f6314 . -20) (f6310 . -16) (f6304 . -12) (f6304 . -8) (output-port . 4))
# var=f6314
    movl -20(%esp), %eax  # stack load f6314
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_38495
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_38495:
    movl %eax, -28(%esp)
# emit-expr 4
    movl $16, %eax     # immed 4
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_38496"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_38496:
# check bounds on vector index
    movl -28(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_38498
    cmp  $0,%eax
    jge _L_38497
_L_38498:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_38497:
    movl %eax, -32(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
    movl -28(%esp), %ebx
    movl -32(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-tail-expr
# si=-28
# env=((f6313 . -24) (f6314 . -20) (f6310 . -16) (f6304 . -12) (f6304 . -8) (output-port . 4))
# expr=(begin (vector-set! f6314 5 f6313) f6314)
# tail-begin (begin (vector-set! f6314 5 f6313) f6314)
#   env=((f6313 . -24) (f6314 . -20) (f6310 . -16) (f6304 . -12) (f6304 . -8) (output-port . 4))
# emit-expr (vector-set! f6314 5 f6313)
# emit-expr f6314
# emit-variable-ref
# env=((f6313 . -24) (f6314 . -20) (f6310 . -16) (f6304 . -12) (f6304 . -8) (output-port . 4))
# var=f6314
    movl -20(%esp), %eax  # stack load f6314
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_38499
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_38499:
    movl %eax, -28(%esp)
# emit-expr 5
    movl $20, %eax     # immed 5
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_38500"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_38500:
# check bounds on vector index
    movl -28(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_38502
    cmp  $0,%eax
    jge _L_38501
_L_38502:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_38501:
    movl %eax, -32(%esp)
# emit-expr f6313
# emit-variable-ref
# env=((f6313 . -24) (f6314 . -20) (f6310 . -16) (f6304 . -12) (f6304 . -8) (output-port . 4))
# var=f6313
    movl -24(%esp), %eax  # stack load f6313
# end emit-variable-ref
    movl -28(%esp), %ebx
    movl -32(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-tail-expr
# si=-28
# env=((f6313 . -24) (f6314 . -20) (f6310 . -16) (f6304 . -12) (f6304 . -8) (output-port . 4))
# expr=(begin f6314)
# tail-begin (begin f6314)
#   env=((f6313 . -24) (f6314 . -20) (f6310 . -16) (f6304 . -12) (f6304 . -8) (output-port . 4))
# emit-tail-expr
# si=-28
# env=((f6313 . -24) (f6314 . -20) (f6310 . -16) (f6304 . -12) (f6304 . -8) (output-port . 4))
# expr=f6314
# emit-tail-variable-ref
# emit-variable-ref
# env=((f6313 . -24) (f6314 . -20) (f6310 . -16) (f6304 . -12) (f6304 . -8) (output-port . 4))
# var=f6314
    movl -20(%esp), %eax  # stack load f6314
# end emit-variable-ref
    ret
# end emit-tail-variable ref
     ret   # return thru stack
     ret   # return thru stack
     ret   # return thru stack
    .align 4,0x90
_L_38453:
     movl %eax, mrc_open$moutput$mfile
# == explicit-begins  ==>
# (lambda (p) (foreign-call "s_close" (port-fd p)))
# == eliminate-let*  ==>
# (lambda (p) (foreign-call "s_close" (port-fd p)))
# == uniquify-variables  ==>
# (lambda (f6315) (foreign-call "s_close" (port-fd f6315)))
# == vectorize-letrec  ==>
# (lambda (f6315) (foreign-call "s_close" (port-fd f6315)))
# == eliminate-set!  ==>
# (lambda (f6315) (let ((f6315 f6315)) (foreign-call "s_close" (port-fd f6315))))
# == close-free-variables  ==>
# (closure (f6315) () (let ((f6315 f6315)) (foreign-call "s_close" (port-fd f6315))))
# == eliminate-quote  ==>
# (closure (f6315) () (let ((f6315 f6315)) (foreign-call "s_close" (port-fd f6315))))
# == eliminate-when/unless  ==>
# (closure (f6315) () (let ((f6315 f6315)) (foreign-call "s_close" (port-fd f6315))))
# == eliminate-cond  ==>
# (closure (f6315) () (let ((f6315 f6315)) (foreign-call "s_close" (port-fd f6315))))
# == external-symbols  ==>
# (closure (f6315) () (let ((f6315 f6315)) (foreign-call "s_close" ((primitive-ref port-fd) f6315))))
# emit-expr (closure (f6315) () (let ((f6315 f6315)) (foreign-call "s_close" ((primitive-ref port-fd) f6315))))
# emit-closure
# si = 0
# env = ()
# expr = (closure (f6315) () (let ((f6315 f6315)) (foreign-call "s_close" ((primitive-ref port-fd) f6315))))
    movl $_L_38503, 0(%ebp)  # closure label
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $8, %ebp     # bump ebp
    jmp _L_38504            # jump around closure body
_L_38503:
# check argument count
    cmp $4,%eax
    je _L_38505
# invoke error handler eh_argcount
    .extern mrc_eh$uargcount
    movl mrc_eh$uargcount, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_38505:
# emit-tail-expr
# si=-12
# env=((f6315 . -8))
# expr=(let ((f6315 f6315)) (foreign-call "s_close" ((primitive-ref port-fd) f6315)))
# emit-tail-let
#  si   = -12
#  env  = ((f6315 . -8))
#  bindings = ((f6315 f6315))
#  body = (foreign-call "s_close" ((primitive-ref port-fd) f6315))
# emit-expr f6315
# emit-variable-ref
# env=((f6315 . -8))
# var=f6315
    movl -8(%esp), %eax  # stack load f6315
# end emit-variable-ref
    movl %eax, -12(%esp)  # stack save
# emit-tail-expr
# si=-16
# env=((f6315 . -12) (f6315 . -8))
# expr=(foreign-call "s_close" ((primitive-ref port-fd) f6315))
    movl %ecx,-16(%esp)
    movl %esp,-20(%esp)
# emit-expr ((primitive-ref port-fd) f6315)
# funcall
#    si   =-24
#    env  = ((f6315 . -12) (f6315 . -8))
#    expr = (funcall (primitive-ref port-fd) f6315)
# emit-expr (primitive-ref port-fd)
    .extern mrc_port$mfd
    movl mrc_port$mfd,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_38506"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_38506":
   movl %eax,  -32(%esp)  # stash funcall-oper in closure slot
# emit-expr f6315
# emit-variable-ref
# env=((f6315 . -12) (f6315 . -8))
# var=f6315
    movl -12(%esp), %eax  # stack load f6315
# end emit-variable-ref
    mov %eax, -36(%esp)  # arg f6315
    movl -32(%esp), %edi   # load new closure to %edi
    add $-24, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $24, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    movl %eax, -24(%esp)
    leal -24(%esp),%edi
    movl %edi,%esi
    andl $-16,%esi
    movl 0(%edi),%eax
    movl %eax,0(%esi)
    movl 4(%edi),%eax
    movl %eax,4(%esi)
    movl %esi,%esp
    .extern _s_close
    call _s_close
    movl 4(%esi),%esp
    movl -16(%esp),%ecx
     ret
    .align 4,0x90
_L_38504:
     movl %eax, mrc_close$minput$mport
# == explicit-begins  ==>
# (lambda (p) (begin (flush-output-port p) (foreign-call "s_close" (port-fd p))))
# == eliminate-let*  ==>
# (lambda (p) (begin (flush-output-port p) (foreign-call "s_close" (port-fd p))))
# == uniquify-variables  ==>
# (lambda (f6316) (begin (flush-output-port f6316) (foreign-call "s_close" (port-fd f6316))))
# == vectorize-letrec  ==>
# (lambda (f6316) (begin (flush-output-port f6316) (foreign-call "s_close" (port-fd f6316))))
# == eliminate-set!  ==>
# (lambda (f6316) (let ((f6316 f6316)) (begin (flush-output-port f6316) (foreign-call "s_close" (port-fd f6316)))))
# == close-free-variables  ==>
# (closure (f6316) () (let ((f6316 f6316)) (begin (flush-output-port f6316) (foreign-call "s_close" (port-fd f6316)))))
# == eliminate-quote  ==>
# (closure (f6316) () (let ((f6316 f6316)) (begin (flush-output-port f6316) (foreign-call "s_close" (port-fd f6316)))))
# == eliminate-when/unless  ==>
# (closure (f6316) () (let ((f6316 f6316)) (begin (flush-output-port f6316) (foreign-call "s_close" (port-fd f6316)))))
# == eliminate-cond  ==>
# (closure (f6316) () (let ((f6316 f6316)) (begin (flush-output-port f6316) (foreign-call "s_close" (port-fd f6316)))))
# == external-symbols  ==>
# (closure (f6316) () (let ((f6316 f6316)) (begin ((primitive-ref flush-output-port) f6316) (foreign-call "s_close" ((primitive-ref port-fd) f6316)))))
# emit-expr (closure (f6316) () (let ((f6316 f6316)) (begin ((primitive-ref flush-output-port) f6316) (foreign-call "s_close" ((primitive-ref port-fd) f6316)))))
# emit-closure
# si = 0
# env = ()
# expr = (closure (f6316) () (let ((f6316 f6316)) (begin ((primitive-ref flush-output-port) f6316) (foreign-call "s_close" ((primitive-ref port-fd) f6316)))))
    movl $_L_38507, 0(%ebp)  # closure label
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $8, %ebp     # bump ebp
    jmp _L_38508            # jump around closure body
_L_38507:
# check argument count
    cmp $4,%eax
    je _L_38509
# invoke error handler eh_argcount
    .extern mrc_eh$uargcount
    movl mrc_eh$uargcount, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_38509:
# emit-tail-expr
# si=-12
# env=((f6316 . -8))
# expr=(let ((f6316 f6316)) (begin ((primitive-ref flush-output-port) f6316) (foreign-call "s_close" ((primitive-ref port-fd) f6316))))
# emit-tail-let
#  si   = -12
#  env  = ((f6316 . -8))
#  bindings = ((f6316 f6316))
#  body = (begin ((primitive-ref flush-output-port) f6316) (foreign-call "s_close" ((primitive-ref port-fd) f6316)))
# emit-expr f6316
# emit-variable-ref
# env=((f6316 . -8))
# var=f6316
    movl -8(%esp), %eax  # stack load f6316
# end emit-variable-ref
    movl %eax, -12(%esp)  # stack save
# emit-tail-expr
# si=-16
# env=((f6316 . -12) (f6316 . -8))
# expr=(begin ((primitive-ref flush-output-port) f6316) (foreign-call "s_close" ((primitive-ref port-fd) f6316)))
# tail-begin (begin ((primitive-ref flush-output-port) f6316) (foreign-call "s_close" ((primitive-ref port-fd) f6316)))
#   env=((f6316 . -12) (f6316 . -8))
# emit-expr ((primitive-ref flush-output-port) f6316)
# funcall
#    si   =-16
#    env  = ((f6316 . -12) (f6316 . -8))
#    expr = (funcall (primitive-ref flush-output-port) f6316)
# emit-expr (primitive-ref flush-output-port)
    .extern mrc_flush$moutput$mport
    movl mrc_flush$moutput$mport,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_38510"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_38510":
   movl %eax,  -24(%esp)  # stash funcall-oper in closure slot
# emit-expr f6316
# emit-variable-ref
# env=((f6316 . -12) (f6316 . -8))
# var=f6316
    movl -12(%esp), %eax  # stack load f6316
# end emit-variable-ref
    mov %eax, -28(%esp)  # arg f6316
    movl -24(%esp), %edi   # load new closure to %edi
    add $-16, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $16, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
# emit-tail-expr
# si=-16
# env=((f6316 . -12) (f6316 . -8))
# expr=(begin (foreign-call "s_close" ((primitive-ref port-fd) f6316)))
# tail-begin (begin (foreign-call "s_close" ((primitive-ref port-fd) f6316)))
#   env=((f6316 . -12) (f6316 . -8))
# emit-tail-expr
# si=-16
# env=((f6316 . -12) (f6316 . -8))
# expr=(foreign-call "s_close" ((primitive-ref port-fd) f6316))
    movl %ecx,-16(%esp)
    movl %esp,-20(%esp)
# emit-expr ((primitive-ref port-fd) f6316)
# funcall
#    si   =-24
#    env  = ((f6316 . -12) (f6316 . -8))
#    expr = (funcall (primitive-ref port-fd) f6316)
# emit-expr (primitive-ref port-fd)
    .extern mrc_port$mfd
    movl mrc_port$mfd,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_38511"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_38511":
   movl %eax,  -32(%esp)  # stash funcall-oper in closure slot
# emit-expr f6316
# emit-variable-ref
# env=((f6316 . -12) (f6316 . -8))
# var=f6316
    movl -12(%esp), %eax  # stack load f6316
# end emit-variable-ref
    mov %eax, -36(%esp)  # arg f6316
    movl -32(%esp), %edi   # load new closure to %edi
    add $-24, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $24, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    movl %eax, -24(%esp)
    leal -24(%esp),%edi
    movl %edi,%esi
    andl $-16,%esi
    movl 0(%edi),%eax
    movl %eax,0(%esi)
    movl 4(%edi),%eax
    movl %eax,4(%esi)
    movl %esi,%esp
    .extern _s_close
    call _s_close
    movl 4(%esi),%esp
    movl -16(%esp),%ecx
     ret
     ret   # return thru stack
    .align 4,0x90
_L_38508:
     movl %eax, mrc_close$moutput$mport
# == explicit-begins  ==>
# (letrec ((print-boolean (lambda (expr p) (begin (write-char #\# p) (if expr (write-char #\t p) (write-char #\f p))))) (print-null (lambda (p) (begin (write-char #\( p) (write-char #\) p)))) (print-char (lambda (expr p) (begin (write-char #\# p) (write-char #\\ p) (write-char expr p)))) (print-fixnum (lambda (i p) (if (negative? i) (begin (write-char #\- p) (print-fixnum (fx* -1 i) p)) (map (lambda (x) (write-char (fixnum->char (fx+ (char->fixnum #\0) x)) p)) (integer->list i))))) (print-string (lambda (s p) (begin (write-char #\" p) (for-each (lambda (c) (write-char c p)) (string->list s)) (write-char #\" p)))) (print-string-alpha (lambda (s p) (for-each (lambda (c) (write-char c p)) (string->list s)))) (print-pair (lambda (pr p) (begin (write-char #\( p) (print-pairs pr p) (write-char #\) p)))) (print-pairs (lambda (pr p) (begin (write (car pr) p) (cond ((null? (cdr pr)) #t) ((pair? (cdr pr)) (begin (write-char #\space p) (print-pairs (cdr pr) p))) (else (begin (write-char #\space p) (write-char #\. p) (write-char #\space p) (write (cdr pr) p)))))))) (lambda (expr p alpha) (cond ((boolean? expr) (print-boolean expr p)) ((null? expr) (print-null p)) ((char? expr) (if alpha (write-char expr p) (print-char expr p))) ((fixnum? expr) (print-fixnum expr p)) ((string? expr) (if alpha (print-string-alpha expr p) (print-string expr p))) ((pair? expr) (print-pair expr p)) (else (error (quote write) "unrecognized expression")))))
# == eliminate-let*  ==>
# (letrec ((print-boolean (lambda (expr p) (begin (write-char #\# p) (if expr (write-char #\t p) (write-char #\f p))))) (print-null (lambda (p) (begin (write-char #\( p) (write-char #\) p)))) (print-char (lambda (expr p) (begin (write-char #\# p) (write-char #\\ p) (write-char expr p)))) (print-fixnum (lambda (i p) (if (negative? i) (begin (write-char #\- p) (print-fixnum (fx* -1 i) p)) (map (lambda (x) (write-char (fixnum->char (fx+ (char->fixnum #\0) x)) p)) (integer->list i))))) (print-string (lambda (s p) (begin (write-char #\" p) (for-each (lambda (c) (write-char c p)) (string->list s)) (write-char #\" p)))) (print-string-alpha (lambda (s p) (for-each (lambda (c) (write-char c p)) (string->list s)))) (print-pair (lambda (pr p) (begin (write-char #\( p) (print-pairs pr p) (write-char #\) p)))) (print-pairs (lambda (pr p) (begin (write (car pr) p) (cond ((null? (cdr pr)) #t) ((pair? (cdr pr)) (begin (write-char #\space p) (print-pairs (cdr pr) p))) (else (begin (write-char #\space p) (write-char #\. p) (write-char #\space p) (write (cdr pr) p)))))))) (lambda (expr p alpha) (cond ((boolean? expr) (print-boolean expr p)) ((null? expr) (print-null p)) ((char? expr) (if alpha (write-char expr p) (print-char expr p))) ((fixnum? expr) (print-fixnum expr p)) ((string? expr) (if alpha (print-string-alpha expr p) (print-string expr p))) ((pair? expr) (print-pair expr p)) (else (error (quote write) "unrecognized expression")))))
# == uniquify-variables  ==>
# (letrec ((f6324 (lambda (f6365 f6366) (begin (write-char #\# f6366) (if f6365 (write-char #\t f6366) (write-char #\f f6366))))) (f6323 (lambda (f6364) (begin (write-char #\( f6364) (write-char #\) f6364)))) (f6322 (lambda (f6362 f6363) (begin (write-char #\# f6363) (write-char #\\ f6363) (write-char f6362 f6363)))) (f6321 (lambda (f6358 f6359) (if (negative? f6358) (begin (write-char #\- f6359) (f6321 (fx* -1 f6358) f6359)) (map (lambda (f6361) (write-char (fixnum->char (fx+ (char->fixnum #\0) f6361)) f6359)) (integer->list f6358))))) (f6320 (lambda (f6354 f6355) (begin (write-char #\" f6355) (for-each (lambda (f6357) (write-char f6357 f6355)) (string->list f6354)) (write-char #\" f6355)))) (f6319 (lambda (f6350 f6351) (for-each (lambda (f6353) (write-char f6353 f6351)) (string->list f6350)))) (f6318 (lambda (f6348 f6349) (begin (write-char #\( f6349) (f6317 f6348 f6349) (write-char #\) f6349)))) (f6317 (lambda (f6346 f6347) (begin (write (car f6346) f6347) (cond ((null? (cdr f6346)) #t) ((pair? (cdr f6346)) (begin (write-char #\space f6347) (f6317 (cdr f6346) f6347))) (else (begin (write-char #\space f6347) (write-char #\. f6347) (write-char #\space f6347) (write (cdr f6346) f6347)))))))) (lambda (f6370 f6371 f6372) (cond ((boolean? f6370) (f6324 f6370 f6371)) ((null? f6370) (f6323 f6371)) ((char? f6370) (if f6372 (write-char f6370 f6371) (f6322 f6370 f6371))) ((fixnum? f6370) (f6321 f6370 f6371)) ((string? f6370) (if f6372 (f6319 f6370 f6371) (f6320 f6370 f6371))) ((pair? f6370) (f6318 f6370 f6371)) (else (error (quote write) "unrecognized expression")))))
# == vectorize-letrec  ==>
# (let ((f6324 (make-vector 1)) (f6323 (make-vector 1)) (f6322 (make-vector 1)) (f6321 (make-vector 1)) (f6320 (make-vector 1)) (f6319 (make-vector 1)) (f6318 (make-vector 1)) (f6317 (make-vector 1))) (begin (begin (vector-set! f6324 0 (lambda (f6365 f6366) (begin (write-char #\# f6366) (if f6365 (write-char #\t f6366) (write-char #\f f6366))))) (vector-set! f6323 0 (lambda (f6364) (begin (write-char #\( f6364) (write-char #\) f6364)))) (vector-set! f6322 0 (lambda (f6362 f6363) (begin (write-char #\# f6363) (write-char #\\ f6363) (write-char f6362 f6363)))) (vector-set! f6321 0 (lambda (f6358 f6359) (if (negative? f6358) (begin (write-char #\- f6359) ((vector-ref f6321 0) (fx* -1 f6358) f6359)) (map (lambda (f6361) (write-char (fixnum->char (fx+ (char->fixnum #\0) f6361)) f6359)) (integer->list f6358))))) (vector-set! f6320 0 (lambda (f6354 f6355) (begin (write-char #\" f6355) (for-each (lambda (f6357) (write-char f6357 f6355)) (string->list f6354)) (write-char #\" f6355)))) (vector-set! f6319 0 (lambda (f6350 f6351) (for-each (lambda (f6353) (write-char f6353 f6351)) (string->list f6350)))) (vector-set! f6318 0 (lambda (f6348 f6349) (begin (write-char #\( f6349) ((vector-ref f6317 0) f6348 f6349) (write-char #\) f6349)))) (vector-set! f6317 0 (lambda (f6346 f6347) (begin (write (car f6346) f6347) (cond ((null? (cdr f6346)) #t) ((pair? (cdr f6346)) (begin (write-char #\space f6347) ((vector-ref f6317 0) (cdr f6346) f6347))) (else (begin (write-char #\space f6347) (write-char #\. f6347) (write-char #\space f6347) (write (cdr f6346) f6347)))))))) (lambda (f6370 f6371 f6372) (cond ((boolean? f6370) ((vector-ref f6324 0) f6370 f6371)) ((null? f6370) ((vector-ref f6323 0) f6371)) ((char? f6370) (if f6372 (write-char f6370 f6371) ((vector-ref f6322 0) f6370 f6371))) ((fixnum? f6370) ((vector-ref f6321 0) f6370 f6371)) ((string? f6370) (if f6372 ((vector-ref f6319 0) f6370 f6371) ((vector-ref f6320 0) f6370 f6371))) ((pair? f6370) ((vector-ref f6318 0) f6370 f6371)) (else (error (quote write) "unrecognized expression"))))))
# == eliminate-set!  ==>
# (let ((f6324 (make-vector 1)) (f6323 (make-vector 1)) (f6322 (make-vector 1)) (f6321 (make-vector 1)) (f6320 (make-vector 1)) (f6319 (make-vector 1)) (f6318 (make-vector 1)) (f6317 (make-vector 1))) (begin (begin (vector-set! f6324 0 (lambda (f6365 f6366) (let ((f6365 f6365) (f6366 f6366)) (begin (write-char #\# f6366) (if f6365 (write-char #\t f6366) (write-char #\f f6366)))))) (vector-set! f6323 0 (lambda (f6364) (let ((f6364 f6364)) (begin (write-char #\( f6364) (write-char #\) f6364))))) (vector-set! f6322 0 (lambda (f6362 f6363) (let ((f6362 f6362) (f6363 f6363)) (begin (write-char #\# f6363) (write-char #\\ f6363) (write-char f6362 f6363))))) (vector-set! f6321 0 (lambda (f6358 f6359) (let ((f6358 f6358) (f6359 f6359)) (if (negative? f6358) (begin (write-char #\- f6359) ((vector-ref f6321 0) (fx* -1 f6358) f6359)) (map (lambda (f6361) (let ((f6361 f6361)) (write-char (fixnum->char (fx+ (char->fixnum #\0) f6361)) f6359))) (integer->list f6358)))))) (vector-set! f6320 0 (lambda (f6354 f6355) (let ((f6354 f6354) (f6355 f6355)) (begin (write-char #\" f6355) (for-each (lambda (f6357) (let ((f6357 f6357)) (write-char f6357 f6355))) (string->list f6354)) (write-char #\" f6355))))) (vector-set! f6319 0 (lambda (f6350 f6351) (let ((f6350 f6350) (f6351 f6351)) (for-each (lambda (f6353) (let ((f6353 f6353)) (write-char f6353 f6351))) (string->list f6350))))) (vector-set! f6318 0 (lambda (f6348 f6349) (let ((f6348 f6348) (f6349 f6349)) (begin (write-char #\( f6349) ((vector-ref f6317 0) f6348 f6349) (write-char #\) f6349))))) (vector-set! f6317 0 (lambda (f6346 f6347) (let ((f6346 f6346) (f6347 f6347)) (begin (write (car f6346) f6347) (cond ((null? (cdr f6346)) #t) ((pair? (cdr f6346)) (begin (write-char #\space f6347) ((vector-ref f6317 0) (cdr f6346) f6347))) (else (begin (write-char #\space f6347) (write-char #\. f6347) (write-char #\space f6347) (write (cdr f6346) f6347))))))))) (lambda (f6370 f6371 f6372) (let ((f6370 f6370) (f6371 f6371) (f6372 f6372)) (cond ((boolean? f6370) ((vector-ref f6324 0) f6370 f6371)) ((null? f6370) ((vector-ref f6323 0) f6371)) ((char? f6370) (if f6372 (write-char f6370 f6371) ((vector-ref f6322 0) f6370 f6371))) ((fixnum? f6370) ((vector-ref f6321 0) f6370 f6371)) ((string? f6370) (if f6372 ((vector-ref f6319 0) f6370 f6371) ((vector-ref f6320 0) f6370 f6371))) ((pair? f6370) ((vector-ref f6318 0) f6370 f6371)) (else (error (quote write) "unrecognized expression")))))))
# == close-free-variables  ==>
# (let ((f6324 (make-vector 1)) (f6323 (make-vector 1)) (f6322 (make-vector 1)) (f6321 (make-vector 1)) (f6320 (make-vector 1)) (f6319 (make-vector 1)) (f6318 (make-vector 1)) (f6317 (make-vector 1))) (begin (begin (vector-set! f6324 0 (closure (f6365 f6366) () (let ((f6365 f6365) (f6366 f6366)) (begin (write-char #\# f6366) (if f6365 (write-char #\t f6366) (write-char #\f f6366)))))) (vector-set! f6323 0 (closure (f6364) () (let ((f6364 f6364)) (begin (write-char #\( f6364) (write-char #\) f6364))))) (vector-set! f6322 0 (closure (f6362 f6363) () (let ((f6362 f6362) (f6363 f6363)) (begin (write-char #\# f6363) (write-char #\\ f6363) (write-char f6362 f6363))))) (vector-set! f6321 0 (closure (f6358 f6359) (f6321) (let ((f6358 f6358) (f6359 f6359)) (if (negative? f6358) (begin (write-char #\- f6359) ((vector-ref f6321 0) (fx* -1 f6358) f6359)) (map (closure (f6361) (f6359) (let ((f6361 f6361)) (write-char (fixnum->char (fx+ (char->fixnum #\0) f6361)) f6359))) (integer->list f6358)))))) (vector-set! f6320 0 (closure (f6354 f6355) () (let ((f6354 f6354) (f6355 f6355)) (begin (write-char #\" f6355) (for-each (closure (f6357) (f6355) (let ((f6357 f6357)) (write-char f6357 f6355))) (string->list f6354)) (write-char #\" f6355))))) (vector-set! f6319 0 (closure (f6350 f6351) () (let ((f6350 f6350) (f6351 f6351)) (for-each (closure (f6353) (f6351) (let ((f6353 f6353)) (write-char f6353 f6351))) (string->list f6350))))) (vector-set! f6318 0 (closure (f6348 f6349) (f6317) (let ((f6348 f6348) (f6349 f6349)) (begin (write-char #\( f6349) ((vector-ref f6317 0) f6348 f6349) (write-char #\) f6349))))) (vector-set! f6317 0 (closure (f6346 f6347) (f6317) (let ((f6346 f6346) (f6347 f6347)) (begin (write (car f6346) f6347) (cond ((null? (cdr f6346)) #t) ((pair? (cdr f6346)) (begin (write-char #\space f6347) ((vector-ref f6317 0) (cdr f6346) f6347))) (else (begin (write-char #\space f6347) (write-char #\. f6347) (write-char #\space f6347) (write (cdr f6346) f6347))))))))) (closure (f6370 f6371 f6372) (f6324 f6323 f6322 f6321 f6319 f6320 f6318) (let ((f6370 f6370) (f6371 f6371) (f6372 f6372)) (cond ((boolean? f6370) ((vector-ref f6324 0) f6370 f6371)) ((null? f6370) ((vector-ref f6323 0) f6371)) ((char? f6370) (if f6372 (write-char f6370 f6371) ((vector-ref f6322 0) f6370 f6371))) ((fixnum? f6370) ((vector-ref f6321 0) f6370 f6371)) ((string? f6370) (if f6372 ((vector-ref f6319 0) f6370 f6371) ((vector-ref f6320 0) f6370 f6371))) ((pair? f6370) ((vector-ref f6318 0) f6370 f6371)) (else (error (quote write) "unrecognized expression")))))))
# == eliminate-quote  ==>
# (let ((f6324 (make-vector 1)) (f6323 (make-vector 1)) (f6322 (make-vector 1)) (f6321 (make-vector 1)) (f6320 (make-vector 1)) (f6319 (make-vector 1)) (f6318 (make-vector 1)) (f6317 (make-vector 1))) (begin (begin (vector-set! f6324 0 (closure (f6365 f6366) () (let ((f6365 f6365) (f6366 f6366)) (begin (write-char #\# f6366) (if f6365 (write-char #\t f6366) (write-char #\f f6366)))))) (vector-set! f6323 0 (closure (f6364) () (let ((f6364 f6364)) (begin (write-char #\( f6364) (write-char #\) f6364))))) (vector-set! f6322 0 (closure (f6362 f6363) () (let ((f6362 f6362) (f6363 f6363)) (begin (write-char #\# f6363) (write-char #\\ f6363) (write-char f6362 f6363))))) (vector-set! f6321 0 (closure (f6358 f6359) (f6321) (let ((f6358 f6358) (f6359 f6359)) (if (negative? f6358) (begin (write-char #\- f6359) ((vector-ref f6321 0) (fx* -1 f6358) f6359)) (map (closure (f6361) (f6359) (let ((f6361 f6361)) (write-char (fixnum->char (fx+ (char->fixnum #\0) f6361)) f6359))) (integer->list f6358)))))) (vector-set! f6320 0 (closure (f6354 f6355) () (let ((f6354 f6354) (f6355 f6355)) (begin (write-char #\" f6355) (for-each (closure (f6357) (f6355) (let ((f6357 f6357)) (write-char f6357 f6355))) (string->list f6354)) (write-char #\" f6355))))) (vector-set! f6319 0 (closure (f6350 f6351) () (let ((f6350 f6350) (f6351 f6351)) (for-each (closure (f6353) (f6351) (let ((f6353 f6353)) (write-char f6353 f6351))) (string->list f6350))))) (vector-set! f6318 0 (closure (f6348 f6349) (f6317) (let ((f6348 f6348) (f6349 f6349)) (begin (write-char #\( f6349) ((vector-ref f6317 0) f6348 f6349) (write-char #\) f6349))))) (vector-set! f6317 0 (closure (f6346 f6347) (f6317) (let ((f6346 f6346) (f6347 f6347)) (begin (write (car f6346) f6347) (cond ((null? (cdr f6346)) #t) ((pair? (cdr f6346)) (begin (write-char #\space f6347) ((vector-ref f6317 0) (cdr f6346) f6347))) (else (begin (write-char #\space f6347) (write-char #\. f6347) (write-char #\space f6347) (write (cdr f6346) f6347))))))))) (closure (f6370 f6371 f6372) (f6324 f6323 f6322 f6321 f6319 f6320 f6318) (let ((f6370 f6370) (f6371 f6371) (f6372 f6372)) (cond ((boolean? f6370) ((vector-ref f6324 0) f6370 f6371)) ((null? f6370) ((vector-ref f6323 0) f6371)) ((char? f6370) (if f6372 (write-char f6370 f6371) ((vector-ref f6322 0) f6370 f6371))) ((fixnum? f6370) ((vector-ref f6321 0) f6370 f6371)) ((string? f6370) (if f6372 ((vector-ref f6319 0) f6370 f6371) ((vector-ref f6320 0) f6370 f6371))) ((pair? f6370) ((vector-ref f6318 0) f6370 f6371)) (else (error (string->symbol "write") "unrecognized expression")))))))
# == eliminate-when/unless  ==>
# (let ((f6324 (make-vector 1)) (f6323 (make-vector 1)) (f6322 (make-vector 1)) (f6321 (make-vector 1)) (f6320 (make-vector 1)) (f6319 (make-vector 1)) (f6318 (make-vector 1)) (f6317 (make-vector 1))) (begin (begin (vector-set! f6324 0 (closure (f6365 f6366) () (let ((f6365 f6365) (f6366 f6366)) (begin (write-char #\# f6366) (if f6365 (write-char #\t f6366) (write-char #\f f6366)))))) (vector-set! f6323 0 (closure (f6364) () (let ((f6364 f6364)) (begin (write-char #\( f6364) (write-char #\) f6364))))) (vector-set! f6322 0 (closure (f6362 f6363) () (let ((f6362 f6362) (f6363 f6363)) (begin (write-char #\# f6363) (write-char #\\ f6363) (write-char f6362 f6363))))) (vector-set! f6321 0 (closure (f6358 f6359) (f6321) (let ((f6358 f6358) (f6359 f6359)) (if (negative? f6358) (begin (write-char #\- f6359) ((vector-ref f6321 0) (fx* -1 f6358) f6359)) (map (closure (f6361) (f6359) (let ((f6361 f6361)) (write-char (fixnum->char (fx+ (char->fixnum #\0) f6361)) f6359))) (integer->list f6358)))))) (vector-set! f6320 0 (closure (f6354 f6355) () (let ((f6354 f6354) (f6355 f6355)) (begin (write-char #\" f6355) (for-each (closure (f6357) (f6355) (let ((f6357 f6357)) (write-char f6357 f6355))) (string->list f6354)) (write-char #\" f6355))))) (vector-set! f6319 0 (closure (f6350 f6351) () (let ((f6350 f6350) (f6351 f6351)) (for-each (closure (f6353) (f6351) (let ((f6353 f6353)) (write-char f6353 f6351))) (string->list f6350))))) (vector-set! f6318 0 (closure (f6348 f6349) (f6317) (let ((f6348 f6348) (f6349 f6349)) (begin (write-char #\( f6349) ((vector-ref f6317 0) f6348 f6349) (write-char #\) f6349))))) (vector-set! f6317 0 (closure (f6346 f6347) (f6317) (let ((f6346 f6346) (f6347 f6347)) (begin (write (car f6346) f6347) (cond ((null? (cdr f6346)) #t) ((pair? (cdr f6346)) (begin (write-char #\space f6347) ((vector-ref f6317 0) (cdr f6346) f6347))) (else (begin (write-char #\space f6347) (write-char #\. f6347) (write-char #\space f6347) (write (cdr f6346) f6347))))))))) (closure (f6370 f6371 f6372) (f6324 f6323 f6322 f6321 f6319 f6320 f6318) (let ((f6370 f6370) (f6371 f6371) (f6372 f6372)) (cond ((boolean? f6370) ((vector-ref f6324 0) f6370 f6371)) ((null? f6370) ((vector-ref f6323 0) f6371)) ((char? f6370) (if f6372 (write-char f6370 f6371) ((vector-ref f6322 0) f6370 f6371))) ((fixnum? f6370) ((vector-ref f6321 0) f6370 f6371)) ((string? f6370) (if f6372 ((vector-ref f6319 0) f6370 f6371) ((vector-ref f6320 0) f6370 f6371))) ((pair? f6370) ((vector-ref f6318 0) f6370 f6371)) (else (error (string->symbol "write") "unrecognized expression")))))))
# == eliminate-cond  ==>
# (let ((f6324 (make-vector 1)) (f6323 (make-vector 1)) (f6322 (make-vector 1)) (f6321 (make-vector 1)) (f6320 (make-vector 1)) (f6319 (make-vector 1)) (f6318 (make-vector 1)) (f6317 (make-vector 1))) (begin (begin (vector-set! f6324 0 (closure (f6365 f6366) () (let ((f6365 f6365) (f6366 f6366)) (begin (write-char #\# f6366) (if f6365 (write-char #\t f6366) (write-char #\f f6366)))))) (vector-set! f6323 0 (closure (f6364) () (let ((f6364 f6364)) (begin (write-char #\( f6364) (write-char #\) f6364))))) (vector-set! f6322 0 (closure (f6362 f6363) () (let ((f6362 f6362) (f6363 f6363)) (begin (write-char #\# f6363) (write-char #\\ f6363) (write-char f6362 f6363))))) (vector-set! f6321 0 (closure (f6358 f6359) (f6321) (let ((f6358 f6358) (f6359 f6359)) (if (negative? f6358) (begin (write-char #\- f6359) ((vector-ref f6321 0) (fx* -1 f6358) f6359)) (map (closure (f6361) (f6359) (let ((f6361 f6361)) (write-char (fixnum->char (fx+ (char->fixnum #\0) f6361)) f6359))) (integer->list f6358)))))) (vector-set! f6320 0 (closure (f6354 f6355) () (let ((f6354 f6354) (f6355 f6355)) (begin (write-char #\" f6355) (for-each (closure (f6357) (f6355) (let ((f6357 f6357)) (write-char f6357 f6355))) (string->list f6354)) (write-char #\" f6355))))) (vector-set! f6319 0 (closure (f6350 f6351) () (let ((f6350 f6350) (f6351 f6351)) (for-each (closure (f6353) (f6351) (let ((f6353 f6353)) (write-char f6353 f6351))) (string->list f6350))))) (vector-set! f6318 0 (closure (f6348 f6349) (f6317) (let ((f6348 f6348) (f6349 f6349)) (begin (write-char #\( f6349) ((vector-ref f6317 0) f6348 f6349) (write-char #\) f6349))))) (vector-set! f6317 0 (closure (f6346 f6347) (f6317) (let ((f6346 f6346) (f6347 f6347)) (begin (write (car f6346) f6347) (if (null? (cdr f6346)) #t (if (pair? (cdr f6346)) (begin (write-char #\space f6347) ((vector-ref f6317 0) (cdr f6346) f6347)) (begin (write-char #\space f6347) (write-char #\. f6347) (write-char #\space f6347) (write (cdr f6346) f6347))))))))) (closure (f6370 f6371 f6372) (f6324 f6323 f6322 f6321 f6319 f6320 f6318) (let ((f6370 f6370) (f6371 f6371) (f6372 f6372)) (if (boolean? f6370) ((vector-ref f6324 0) f6370 f6371) (if (null? f6370) ((vector-ref f6323 0) f6371) (if (char? f6370) (if f6372 (write-char f6370 f6371) ((vector-ref f6322 0) f6370 f6371)) (if (fixnum? f6370) ((vector-ref f6321 0) f6370 f6371) (if (string? f6370) (if f6372 ((vector-ref f6319 0) f6370 f6371) ((vector-ref f6320 0) f6370 f6371)) (if (pair? f6370) ((vector-ref f6318 0) f6370 f6371) (error (string->symbol "write") "unrecognized expression")))))))))))
# == external-symbols  ==>
# (let ((f6324 (make-vector 1)) (f6323 (make-vector 1)) (f6322 (make-vector 1)) (f6321 (make-vector 1)) (f6320 (make-vector 1)) (f6319 (make-vector 1)) (f6318 (make-vector 1)) (f6317 (make-vector 1))) (begin (begin (vector-set! f6324 0 (closure (f6365 f6366) () (let ((f6365 f6365) (f6366 f6366)) (begin ((primitive-ref write-char) #\# f6366) (if f6365 ((primitive-ref write-char) #\t f6366) ((primitive-ref write-char) #\f f6366)))))) (vector-set! f6323 0 (closure (f6364) () (let ((f6364 f6364)) (begin ((primitive-ref write-char) #\( f6364) ((primitive-ref write-char) #\) f6364))))) (vector-set! f6322 0 (closure (f6362 f6363) () (let ((f6362 f6362) (f6363 f6363)) (begin ((primitive-ref write-char) #\# f6363) ((primitive-ref write-char) #\\ f6363) ((primitive-ref write-char) f6362 f6363))))) (vector-set! f6321 0 (closure (f6358 f6359) (f6321) (let ((f6358 f6358) (f6359 f6359)) (if ((primitive-ref negative?) f6358) (begin ((primitive-ref write-char) #\- f6359) ((vector-ref f6321 0) (fx* -1 f6358) f6359)) ((primitive-ref map) (closure (f6361) (f6359) (let ((f6361 f6361)) ((primitive-ref write-char) (fixnum->char (fx+ (char->fixnum #\0) f6361)) f6359))) ((primitive-ref integer->list) f6358)))))) (vector-set! f6320 0 (closure (f6354 f6355) () (let ((f6354 f6354) (f6355 f6355)) (begin ((primitive-ref write-char) #\" f6355) ((primitive-ref for-each) (closure (f6357) (f6355) (let ((f6357 f6357)) ((primitive-ref write-char) f6357 f6355))) ((primitive-ref string->list) f6354)) ((primitive-ref write-char) #\" f6355))))) (vector-set! f6319 0 (closure (f6350 f6351) () (let ((f6350 f6350) (f6351 f6351)) ((primitive-ref for-each) (closure (f6353) (f6351) (let ((f6353 f6353)) ((primitive-ref write-char) f6353 f6351))) ((primitive-ref string->list) f6350))))) (vector-set! f6318 0 (closure (f6348 f6349) (f6317) (let ((f6348 f6348) (f6349 f6349)) (begin ((primitive-ref write-char) #\( f6349) ((vector-ref f6317 0) f6348 f6349) ((primitive-ref write-char) #\) f6349))))) (vector-set! f6317 0 (closure (f6346 f6347) (f6317) (let ((f6346 f6346) (f6347 f6347)) (begin ((primitive-ref write) (car f6346) f6347) (if (null? (cdr f6346)) #t (if (pair? (cdr f6346)) (begin ((primitive-ref write-char) #\space f6347) ((vector-ref f6317 0) (cdr f6346) f6347)) (begin ((primitive-ref write-char) #\space f6347) ((primitive-ref write-char) #\. f6347) ((primitive-ref write-char) #\space f6347) ((primitive-ref write) (cdr f6346) f6347))))))))) (closure (f6370 f6371 f6372) (f6324 f6323 f6322 f6321 f6319 f6320 f6318) (let ((f6370 f6370) (f6371 f6371) (f6372 f6372)) (if (boolean? f6370) ((vector-ref f6324 0) f6370 f6371) (if (null? f6370) ((vector-ref f6323 0) f6371) (if (char? f6370) (if f6372 ((primitive-ref write-char) f6370 f6371) ((vector-ref f6322 0) f6370 f6371)) (if (fixnum? f6370) ((vector-ref f6321 0) f6370 f6371) (if (string? f6370) (if f6372 ((vector-ref f6319 0) f6370 f6371) ((vector-ref f6320 0) f6370 f6371)) (if (pair? f6370) ((vector-ref f6318 0) f6370 f6371) ((primitive-ref error) ((primitive-ref string->symbol) "write") "unrecognized expression")))))))))))
# emit-expr (let ((f6324 (make-vector 1)) (f6323 (make-vector 1)) (f6322 (make-vector 1)) (f6321 (make-vector 1)) (f6320 (make-vector 1)) (f6319 (make-vector 1)) (f6318 (make-vector 1)) (f6317 (make-vector 1))) (begin (begin (vector-set! f6324 0 (closure (f6365 f6366) () (let ((f6365 f6365) (f6366 f6366)) (begin ((primitive-ref write-char) #\# f6366) (if f6365 ((primitive-ref write-char) #\t f6366) ((primitive-ref write-char) #\f f6366)))))) (vector-set! f6323 0 (closure (f6364) () (let ((f6364 f6364)) (begin ((primitive-ref write-char) #\( f6364) ((primitive-ref write-char) #\) f6364))))) (vector-set! f6322 0 (closure (f6362 f6363) () (let ((f6362 f6362) (f6363 f6363)) (begin ((primitive-ref write-char) #\# f6363) ((primitive-ref write-char) #\\ f6363) ((primitive-ref write-char) f6362 f6363))))) (vector-set! f6321 0 (closure (f6358 f6359) (f6321) (let ((f6358 f6358) (f6359 f6359)) (if ((primitive-ref negative?) f6358) (begin ((primitive-ref write-char) #\- f6359) ((vector-ref f6321 0) (fx* -1 f6358) f6359)) ((primitive-ref map) (closure (f6361) (f6359) (let ((f6361 f6361)) ((primitive-ref write-char) (fixnum->char (fx+ (char->fixnum #\0) f6361)) f6359))) ((primitive-ref integer->list) f6358)))))) (vector-set! f6320 0 (closure (f6354 f6355) () (let ((f6354 f6354) (f6355 f6355)) (begin ((primitive-ref write-char) #\" f6355) ((primitive-ref for-each) (closure (f6357) (f6355) (let ((f6357 f6357)) ((primitive-ref write-char) f6357 f6355))) ((primitive-ref string->list) f6354)) ((primitive-ref write-char) #\" f6355))))) (vector-set! f6319 0 (closure (f6350 f6351) () (let ((f6350 f6350) (f6351 f6351)) ((primitive-ref for-each) (closure (f6353) (f6351) (let ((f6353 f6353)) ((primitive-ref write-char) f6353 f6351))) ((primitive-ref string->list) f6350))))) (vector-set! f6318 0 (closure (f6348 f6349) (f6317) (let ((f6348 f6348) (f6349 f6349)) (begin ((primitive-ref write-char) #\( f6349) ((vector-ref f6317 0) f6348 f6349) ((primitive-ref write-char) #\) f6349))))) (vector-set! f6317 0 (closure (f6346 f6347) (f6317) (let ((f6346 f6346) (f6347 f6347)) (begin ((primitive-ref write) (car f6346) f6347) (if (null? (cdr f6346)) #t (if (pair? (cdr f6346)) (begin ((primitive-ref write-char) #\space f6347) ((vector-ref f6317 0) (cdr f6346) f6347)) (begin ((primitive-ref write-char) #\space f6347) ((primitive-ref write-char) #\. f6347) ((primitive-ref write-char) #\space f6347) ((primitive-ref write) (cdr f6346) f6347))))))))) (closure (f6370 f6371 f6372) (f6324 f6323 f6322 f6321 f6319 f6320 f6318) (let ((f6370 f6370) (f6371 f6371) (f6372 f6372)) (if (boolean? f6370) ((vector-ref f6324 0) f6370 f6371) (if (null? f6370) ((vector-ref f6323 0) f6371) (if (char? f6370) (if f6372 ((primitive-ref write-char) f6370 f6371) ((vector-ref f6322 0) f6370 f6371)) (if (fixnum? f6370) ((vector-ref f6321 0) f6370 f6371) (if (string? f6370) (if f6372 ((vector-ref f6319 0) f6370 f6371) ((vector-ref f6320 0) f6370 f6371)) (if (pair? f6370) ((vector-ref f6318 0) f6370 f6371) ((primitive-ref error) ((primitive-ref string->symbol) "write") "unrecognized expression")))))))))))
# emit-let
#  si   = 0
#  env  = ()
#  bindings = ((f6324 (make-vector 1)) (f6323 (make-vector 1)) (f6322 (make-vector 1)) (f6321 (make-vector 1)) (f6320 (make-vector 1)) (f6319 (make-vector 1)) (f6318 (make-vector 1)) (f6317 (make-vector 1)))
#  body = (begin (begin (vector-set! f6324 0 (closure (f6365 f6366) () (let ((f6365 f6365) (f6366 f6366)) (begin ((primitive-ref write-char) #\# f6366) (if f6365 ((primitive-ref write-char) #\t f6366) ((primitive-ref write-char) #\f f6366)))))) (vector-set! f6323 0 (closure (f6364) () (let ((f6364 f6364)) (begin ((primitive-ref write-char) #\( f6364) ((primitive-ref write-char) #\) f6364))))) (vector-set! f6322 0 (closure (f6362 f6363) () (let ((f6362 f6362) (f6363 f6363)) (begin ((primitive-ref write-char) #\# f6363) ((primitive-ref write-char) #\\ f6363) ((primitive-ref write-char) f6362 f6363))))) (vector-set! f6321 0 (closure (f6358 f6359) (f6321) (let ((f6358 f6358) (f6359 f6359)) (if ((primitive-ref negative?) f6358) (begin ((primitive-ref write-char) #\- f6359) ((vector-ref f6321 0) (fx* -1 f6358) f6359)) ((primitive-ref map) (closure (f6361) (f6359) (let ((f6361 f6361)) ((primitive-ref write-char) (fixnum->char (fx+ (char->fixnum #\0) f6361)) f6359))) ((primitive-ref integer->list) f6358)))))) (vector-set! f6320 0 (closure (f6354 f6355) () (let ((f6354 f6354) (f6355 f6355)) (begin ((primitive-ref write-char) #\" f6355) ((primitive-ref for-each) (closure (f6357) (f6355) (let ((f6357 f6357)) ((primitive-ref write-char) f6357 f6355))) ((primitive-ref string->list) f6354)) ((primitive-ref write-char) #\" f6355))))) (vector-set! f6319 0 (closure (f6350 f6351) () (let ((f6350 f6350) (f6351 f6351)) ((primitive-ref for-each) (closure (f6353) (f6351) (let ((f6353 f6353)) ((primitive-ref write-char) f6353 f6351))) ((primitive-ref string->list) f6350))))) (vector-set! f6318 0 (closure (f6348 f6349) (f6317) (let ((f6348 f6348) (f6349 f6349)) (begin ((primitive-ref write-char) #\( f6349) ((vector-ref f6317 0) f6348 f6349) ((primitive-ref write-char) #\) f6349))))) (vector-set! f6317 0 (closure (f6346 f6347) (f6317) (let ((f6346 f6346) (f6347 f6347)) (begin ((primitive-ref write) (car f6346) f6347) (if (null? (cdr f6346)) #t (if (pair? (cdr f6346)) (begin ((primitive-ref write-char) #\space f6347) ((vector-ref f6317 0) (cdr f6346) f6347)) (begin ((primitive-ref write-char) #\space f6347) ((primitive-ref write-char) #\. f6347) ((primitive-ref write-char) #\space f6347) ((primitive-ref write) (cdr f6346) f6347))))))))) (closure (f6370 f6371 f6372) (f6324 f6323 f6322 f6321 f6319 f6320 f6318) (let ((f6370 f6370) (f6371 f6371) (f6372 f6372)) (if (boolean? f6370) ((vector-ref f6324 0) f6370 f6371) (if (null? f6370) ((vector-ref f6323 0) f6371) (if (char? f6370) (if f6372 ((primitive-ref write-char) f6370 f6371) ((vector-ref f6322 0) f6370 f6371)) (if (fixnum? f6370) ((vector-ref f6321 0) f6370 f6371) (if (string? f6370) (if f6372 ((vector-ref f6319 0) f6370 f6371) ((vector-ref f6320 0) f6370 f6371)) (if (pair? f6370) ((vector-ref f6318 0) f6370 f6371) ((primitive-ref error) ((primitive-ref string->symbol) "write") "unrecognized expression"))))))))))
# emit-expr (make-vector 1)
# make-vector 1
# emit-expr 1
    movl $4, %eax     # immed 1
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_38512"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_38512:
# check the argument is a fixnum >= 0
    cmp $0,%eax
    jge _L_38513
# invoke error handler eh_length
    .extern mrc_eh$ulength
    movl mrc_eh$ulength, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_38513:
    movl %eax, %esi
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    orl  $5, %eax
    addl $4, %esi
    addl $4, %esi
    andl $-8, %esi
    addl %esi, %ebp
    movl %eax, 0(%esp)  # stack save
# emit-expr (make-vector 1)
# make-vector 1
# emit-expr 1
    movl $4, %eax     # immed 1
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_38514"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_38514:
# check the argument is a fixnum >= 0
    cmp $0,%eax
    jge _L_38515
# invoke error handler eh_length
    .extern mrc_eh$ulength
    movl mrc_eh$ulength, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_38515:
    movl %eax, %esi
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    orl  $5, %eax
    addl $4, %esi
    addl $4, %esi
    andl $-8, %esi
    addl %esi, %ebp
    movl %eax, -4(%esp)  # stack save
# emit-expr (make-vector 1)
# make-vector 1
# emit-expr 1
    movl $4, %eax     # immed 1
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_38516"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_38516:
# check the argument is a fixnum >= 0
    cmp $0,%eax
    jge _L_38517
# invoke error handler eh_length
    .extern mrc_eh$ulength
    movl mrc_eh$ulength, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_38517:
    movl %eax, %esi
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    orl  $5, %eax
    addl $4, %esi
    addl $4, %esi
    andl $-8, %esi
    addl %esi, %ebp
    movl %eax, -8(%esp)  # stack save
# emit-expr (make-vector 1)
# make-vector 1
# emit-expr 1
    movl $4, %eax     # immed 1
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_38518"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_38518:
# check the argument is a fixnum >= 0
    cmp $0,%eax
    jge _L_38519
# invoke error handler eh_length
    .extern mrc_eh$ulength
    movl mrc_eh$ulength, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_38519:
    movl %eax, %esi
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    orl  $5, %eax
    addl $4, %esi
    addl $4, %esi
    andl $-8, %esi
    addl %esi, %ebp
    movl %eax, -12(%esp)  # stack save
# emit-expr (make-vector 1)
# make-vector 1
# emit-expr 1
    movl $4, %eax     # immed 1
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_38520"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_38520:
# check the argument is a fixnum >= 0
    cmp $0,%eax
    jge _L_38521
# invoke error handler eh_length
    .extern mrc_eh$ulength
    movl mrc_eh$ulength, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_38521:
    movl %eax, %esi
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    orl  $5, %eax
    addl $4, %esi
    addl $4, %esi
    andl $-8, %esi
    addl %esi, %ebp
    movl %eax, -16(%esp)  # stack save
# emit-expr (make-vector 1)
# make-vector 1
# emit-expr 1
    movl $4, %eax     # immed 1
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_38522"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_38522:
# check the argument is a fixnum >= 0
    cmp $0,%eax
    jge _L_38523
# invoke error handler eh_length
    .extern mrc_eh$ulength
    movl mrc_eh$ulength, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_38523:
    movl %eax, %esi
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    orl  $5, %eax
    addl $4, %esi
    addl $4, %esi
    andl $-8, %esi
    addl %esi, %ebp
    movl %eax, -20(%esp)  # stack save
# emit-expr (make-vector 1)
# make-vector 1
# emit-expr 1
    movl $4, %eax     # immed 1
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_38524"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_38524:
# check the argument is a fixnum >= 0
    cmp $0,%eax
    jge _L_38525
# invoke error handler eh_length
    .extern mrc_eh$ulength
    movl mrc_eh$ulength, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_38525:
    movl %eax, %esi
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    orl  $5, %eax
    addl $4, %esi
    addl $4, %esi
    andl $-8, %esi
    addl %esi, %ebp
    movl %eax, -24(%esp)  # stack save
# emit-expr (make-vector 1)
# make-vector 1
# emit-expr 1
    movl $4, %eax     # immed 1
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_38526"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_38526:
# check the argument is a fixnum >= 0
    cmp $0,%eax
    jge _L_38527
# invoke error handler eh_length
    .extern mrc_eh$ulength
    movl mrc_eh$ulength, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_38527:
    movl %eax, %esi
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    orl  $5, %eax
    addl $4, %esi
    addl $4, %esi
    andl $-8, %esi
    addl %esi, %ebp
    movl %eax, -28(%esp)  # stack save
# emit-expr (begin (begin (vector-set! f6324 0 (closure (f6365 f6366) () (let ((f6365 f6365) (f6366 f6366)) (begin ((primitive-ref write-char) #\# f6366) (if f6365 ((primitive-ref write-char) #\t f6366) ((primitive-ref write-char) #\f f6366)))))) (vector-set! f6323 0 (closure (f6364) () (let ((f6364 f6364)) (begin ((primitive-ref write-char) #\( f6364) ((primitive-ref write-char) #\) f6364))))) (vector-set! f6322 0 (closure (f6362 f6363) () (let ((f6362 f6362) (f6363 f6363)) (begin ((primitive-ref write-char) #\# f6363) ((primitive-ref write-char) #\\ f6363) ((primitive-ref write-char) f6362 f6363))))) (vector-set! f6321 0 (closure (f6358 f6359) (f6321) (let ((f6358 f6358) (f6359 f6359)) (if ((primitive-ref negative?) f6358) (begin ((primitive-ref write-char) #\- f6359) ((vector-ref f6321 0) (fx* -1 f6358) f6359)) ((primitive-ref map) (closure (f6361) (f6359) (let ((f6361 f6361)) ((primitive-ref write-char) (fixnum->char (fx+ (char->fixnum #\0) f6361)) f6359))) ((primitive-ref integer->list) f6358)))))) (vector-set! f6320 0 (closure (f6354 f6355) () (let ((f6354 f6354) (f6355 f6355)) (begin ((primitive-ref write-char) #\" f6355) ((primitive-ref for-each) (closure (f6357) (f6355) (let ((f6357 f6357)) ((primitive-ref write-char) f6357 f6355))) ((primitive-ref string->list) f6354)) ((primitive-ref write-char) #\" f6355))))) (vector-set! f6319 0 (closure (f6350 f6351) () (let ((f6350 f6350) (f6351 f6351)) ((primitive-ref for-each) (closure (f6353) (f6351) (let ((f6353 f6353)) ((primitive-ref write-char) f6353 f6351))) ((primitive-ref string->list) f6350))))) (vector-set! f6318 0 (closure (f6348 f6349) (f6317) (let ((f6348 f6348) (f6349 f6349)) (begin ((primitive-ref write-char) #\( f6349) ((vector-ref f6317 0) f6348 f6349) ((primitive-ref write-char) #\) f6349))))) (vector-set! f6317 0 (closure (f6346 f6347) (f6317) (let ((f6346 f6346) (f6347 f6347)) (begin ((primitive-ref write) (car f6346) f6347) (if (null? (cdr f6346)) #t (if (pair? (cdr f6346)) (begin ((primitive-ref write-char) #\space f6347) ((vector-ref f6317 0) (cdr f6346) f6347)) (begin ((primitive-ref write-char) #\space f6347) ((primitive-ref write-char) #\. f6347) ((primitive-ref write-char) #\space f6347) ((primitive-ref write) (cdr f6346) f6347))))))))) (closure (f6370 f6371 f6372) (f6324 f6323 f6322 f6321 f6319 f6320 f6318) (let ((f6370 f6370) (f6371 f6371) (f6372 f6372)) (if (boolean? f6370) ((vector-ref f6324 0) f6370 f6371) (if (null? f6370) ((vector-ref f6323 0) f6371) (if (char? f6370) (if f6372 ((primitive-ref write-char) f6370 f6371) ((vector-ref f6322 0) f6370 f6371)) (if (fixnum? f6370) ((vector-ref f6321 0) f6370 f6371) (if (string? f6370) (if f6372 ((vector-ref f6319 0) f6370 f6371) ((vector-ref f6320 0) f6370 f6371)) (if (pair? f6370) ((vector-ref f6318 0) f6370 f6371) ((primitive-ref error) ((primitive-ref string->symbol) "write") "unrecognized expression"))))))))))
# emit-begin
#   expr=(begin (begin (vector-set! f6324 0 (closure (f6365 f6366) () (let ((f6365 f6365) (f6366 f6366)) (begin ((primitive-ref write-char) #\# f6366) (if f6365 ((primitive-ref write-char) #\t f6366) ((primitive-ref write-char) #\f f6366)))))) (vector-set! f6323 0 (closure (f6364) () (let ((f6364 f6364)) (begin ((primitive-ref write-char) #\( f6364) ((primitive-ref write-char) #\) f6364))))) (vector-set! f6322 0 (closure (f6362 f6363) () (let ((f6362 f6362) (f6363 f6363)) (begin ((primitive-ref write-char) #\# f6363) ((primitive-ref write-char) #\\ f6363) ((primitive-ref write-char) f6362 f6363))))) (vector-set! f6321 0 (closure (f6358 f6359) (f6321) (let ((f6358 f6358) (f6359 f6359)) (if ((primitive-ref negative?) f6358) (begin ((primitive-ref write-char) #\- f6359) ((vector-ref f6321 0) (fx* -1 f6358) f6359)) ((primitive-ref map) (closure (f6361) (f6359) (let ((f6361 f6361)) ((primitive-ref write-char) (fixnum->char (fx+ (char->fixnum #\0) f6361)) f6359))) ((primitive-ref integer->list) f6358)))))) (vector-set! f6320 0 (closure (f6354 f6355) () (let ((f6354 f6354) (f6355 f6355)) (begin ((primitive-ref write-char) #\" f6355) ((primitive-ref for-each) (closure (f6357) (f6355) (let ((f6357 f6357)) ((primitive-ref write-char) f6357 f6355))) ((primitive-ref string->list) f6354)) ((primitive-ref write-char) #\" f6355))))) (vector-set! f6319 0 (closure (f6350 f6351) () (let ((f6350 f6350) (f6351 f6351)) ((primitive-ref for-each) (closure (f6353) (f6351) (let ((f6353 f6353)) ((primitive-ref write-char) f6353 f6351))) ((primitive-ref string->list) f6350))))) (vector-set! f6318 0 (closure (f6348 f6349) (f6317) (let ((f6348 f6348) (f6349 f6349)) (begin ((primitive-ref write-char) #\( f6349) ((vector-ref f6317 0) f6348 f6349) ((primitive-ref write-char) #\) f6349))))) (vector-set! f6317 0 (closure (f6346 f6347) (f6317) (let ((f6346 f6346) (f6347 f6347)) (begin ((primitive-ref write) (car f6346) f6347) (if (null? (cdr f6346)) #t (if (pair? (cdr f6346)) (begin ((primitive-ref write-char) #\space f6347) ((vector-ref f6317 0) (cdr f6346) f6347)) (begin ((primitive-ref write-char) #\space f6347) ((primitive-ref write-char) #\. f6347) ((primitive-ref write-char) #\space f6347) ((primitive-ref write) (cdr f6346) f6347))))))))) (closure (f6370 f6371 f6372) (f6324 f6323 f6322 f6321 f6319 f6320 f6318) (let ((f6370 f6370) (f6371 f6371) (f6372 f6372)) (if (boolean? f6370) ((vector-ref f6324 0) f6370 f6371) (if (null? f6370) ((vector-ref f6323 0) f6371) (if (char? f6370) (if f6372 ((primitive-ref write-char) f6370 f6371) ((vector-ref f6322 0) f6370 f6371)) (if (fixnum? f6370) ((vector-ref f6321 0) f6370 f6371) (if (string? f6370) (if f6372 ((vector-ref f6319 0) f6370 f6371) ((vector-ref f6320 0) f6370 f6371)) (if (pair? f6370) ((vector-ref f6318 0) f6370 f6371) ((primitive-ref error) ((primitive-ref string->symbol) "write") "unrecognized expression"))))))))))
#   env=((f6317 . -28) (f6318 . -24) (f6319 . -20) (f6320 . -16) (f6321 . -12) (f6322 . -8) (f6323 . -4) (f6324 . 0))
# emit-expr (begin (vector-set! f6324 0 (closure (f6365 f6366) () (let ((f6365 f6365) (f6366 f6366)) (begin ((primitive-ref write-char) #\# f6366) (if f6365 ((primitive-ref write-char) #\t f6366) ((primitive-ref write-char) #\f f6366)))))) (vector-set! f6323 0 (closure (f6364) () (let ((f6364 f6364)) (begin ((primitive-ref write-char) #\( f6364) ((primitive-ref write-char) #\) f6364))))) (vector-set! f6322 0 (closure (f6362 f6363) () (let ((f6362 f6362) (f6363 f6363)) (begin ((primitive-ref write-char) #\# f6363) ((primitive-ref write-char) #\\ f6363) ((primitive-ref write-char) f6362 f6363))))) (vector-set! f6321 0 (closure (f6358 f6359) (f6321) (let ((f6358 f6358) (f6359 f6359)) (if ((primitive-ref negative?) f6358) (begin ((primitive-ref write-char) #\- f6359) ((vector-ref f6321 0) (fx* -1 f6358) f6359)) ((primitive-ref map) (closure (f6361) (f6359) (let ((f6361 f6361)) ((primitive-ref write-char) (fixnum->char (fx+ (char->fixnum #\0) f6361)) f6359))) ((primitive-ref integer->list) f6358)))))) (vector-set! f6320 0 (closure (f6354 f6355) () (let ((f6354 f6354) (f6355 f6355)) (begin ((primitive-ref write-char) #\" f6355) ((primitive-ref for-each) (closure (f6357) (f6355) (let ((f6357 f6357)) ((primitive-ref write-char) f6357 f6355))) ((primitive-ref string->list) f6354)) ((primitive-ref write-char) #\" f6355))))) (vector-set! f6319 0 (closure (f6350 f6351) () (let ((f6350 f6350) (f6351 f6351)) ((primitive-ref for-each) (closure (f6353) (f6351) (let ((f6353 f6353)) ((primitive-ref write-char) f6353 f6351))) ((primitive-ref string->list) f6350))))) (vector-set! f6318 0 (closure (f6348 f6349) (f6317) (let ((f6348 f6348) (f6349 f6349)) (begin ((primitive-ref write-char) #\( f6349) ((vector-ref f6317 0) f6348 f6349) ((primitive-ref write-char) #\) f6349))))) (vector-set! f6317 0 (closure (f6346 f6347) (f6317) (let ((f6346 f6346) (f6347 f6347)) (begin ((primitive-ref write) (car f6346) f6347) (if (null? (cdr f6346)) #t (if (pair? (cdr f6346)) (begin ((primitive-ref write-char) #\space f6347) ((vector-ref f6317 0) (cdr f6346) f6347)) (begin ((primitive-ref write-char) #\space f6347) ((primitive-ref write-char) #\. f6347) ((primitive-ref write-char) #\space f6347) ((primitive-ref write) (cdr f6346) f6347)))))))))
# emit-begin
#   expr=(begin (vector-set! f6324 0 (closure (f6365 f6366) () (let ((f6365 f6365) (f6366 f6366)) (begin ((primitive-ref write-char) #\# f6366) (if f6365 ((primitive-ref write-char) #\t f6366) ((primitive-ref write-char) #\f f6366)))))) (vector-set! f6323 0 (closure (f6364) () (let ((f6364 f6364)) (begin ((primitive-ref write-char) #\( f6364) ((primitive-ref write-char) #\) f6364))))) (vector-set! f6322 0 (closure (f6362 f6363) () (let ((f6362 f6362) (f6363 f6363)) (begin ((primitive-ref write-char) #\# f6363) ((primitive-ref write-char) #\\ f6363) ((primitive-ref write-char) f6362 f6363))))) (vector-set! f6321 0 (closure (f6358 f6359) (f6321) (let ((f6358 f6358) (f6359 f6359)) (if ((primitive-ref negative?) f6358) (begin ((primitive-ref write-char) #\- f6359) ((vector-ref f6321 0) (fx* -1 f6358) f6359)) ((primitive-ref map) (closure (f6361) (f6359) (let ((f6361 f6361)) ((primitive-ref write-char) (fixnum->char (fx+ (char->fixnum #\0) f6361)) f6359))) ((primitive-ref integer->list) f6358)))))) (vector-set! f6320 0 (closure (f6354 f6355) () (let ((f6354 f6354) (f6355 f6355)) (begin ((primitive-ref write-char) #\" f6355) ((primitive-ref for-each) (closure (f6357) (f6355) (let ((f6357 f6357)) ((primitive-ref write-char) f6357 f6355))) ((primitive-ref string->list) f6354)) ((primitive-ref write-char) #\" f6355))))) (vector-set! f6319 0 (closure (f6350 f6351) () (let ((f6350 f6350) (f6351 f6351)) ((primitive-ref for-each) (closure (f6353) (f6351) (let ((f6353 f6353)) ((primitive-ref write-char) f6353 f6351))) ((primitive-ref string->list) f6350))))) (vector-set! f6318 0 (closure (f6348 f6349) (f6317) (let ((f6348 f6348) (f6349 f6349)) (begin ((primitive-ref write-char) #\( f6349) ((vector-ref f6317 0) f6348 f6349) ((primitive-ref write-char) #\) f6349))))) (vector-set! f6317 0 (closure (f6346 f6347) (f6317) (let ((f6346 f6346) (f6347 f6347)) (begin ((primitive-ref write) (car f6346) f6347) (if (null? (cdr f6346)) #t (if (pair? (cdr f6346)) (begin ((primitive-ref write-char) #\space f6347) ((vector-ref f6317 0) (cdr f6346) f6347)) (begin ((primitive-ref write-char) #\space f6347) ((primitive-ref write-char) #\. f6347) ((primitive-ref write-char) #\space f6347) ((primitive-ref write) (cdr f6346) f6347)))))))))
#   env=((f6317 . -28) (f6318 . -24) (f6319 . -20) (f6320 . -16) (f6321 . -12) (f6322 . -8) (f6323 . -4) (f6324 . 0))
# emit-expr (vector-set! f6324 0 (closure (f6365 f6366) () (let ((f6365 f6365) (f6366 f6366)) (begin ((primitive-ref write-char) #\# f6366) (if f6365 ((primitive-ref write-char) #\t f6366) ((primitive-ref write-char) #\f f6366))))))
# emit-expr f6324
# emit-variable-ref
# env=((f6317 . -28) (f6318 . -24) (f6319 . -20) (f6320 . -16) (f6321 . -12) (f6322 . -8) (f6323 . -4) (f6324 . 0))
# var=f6324
    movl 0(%esp), %eax  # stack load f6324
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_38528
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_38528:
    movl %eax, -32(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_38529"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_38529:
# check bounds on vector index
    movl -32(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_38531
    cmp  $0,%eax
    jge _L_38530
_L_38531:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_38530:
    movl %eax, -36(%esp)
# emit-expr (closure (f6365 f6366) () (let ((f6365 f6365) (f6366 f6366)) (begin ((primitive-ref write-char) #\# f6366) (if f6365 ((primitive-ref write-char) #\t f6366) ((primitive-ref write-char) #\f f6366)))))
# emit-closure
# si = -40
# env = ((f6317 . -28) (f6318 . -24) (f6319 . -20) (f6320 . -16) (f6321 . -12) (f6322 . -8) (f6323 . -4) (f6324 . 0))
# expr = (closure (f6365 f6366) () (let ((f6365 f6365) (f6366 f6366)) (begin ((primitive-ref write-char) #\# f6366) (if f6365 ((primitive-ref write-char) #\t f6366) ((primitive-ref write-char) #\f f6366)))))
    movl $_L_38532, 0(%ebp)  # closure label
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $8, %ebp     # bump ebp
    jmp _L_38533            # jump around closure body
_L_38532:
# check argument count
    cmp $8,%eax
    je _L_38534
# invoke error handler eh_argcount
    .extern mrc_eh$uargcount
    movl mrc_eh$uargcount, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_38534:
# emit-tail-expr
# si=-16
# env=((f6366 . -12) (f6365 . -8) (f6317 . -28) (f6318 . -24) (f6319 . -20) (f6320 . -16) (f6321 . -12) (f6322 . -8) (f6323 . -4) (f6324 . 0))
# expr=(let ((f6365 f6365) (f6366 f6366)) (begin ((primitive-ref write-char) #\# f6366) (if f6365 ((primitive-ref write-char) #\t f6366) ((primitive-ref write-char) #\f f6366))))
# emit-tail-let
#  si   = -16
#  env  = ((f6366 . -12) (f6365 . -8) (f6317 . -28) (f6318 . -24) (f6319 . -20) (f6320 . -16) (f6321 . -12) (f6322 . -8) (f6323 . -4) (f6324 . 0))
#  bindings = ((f6365 f6365) (f6366 f6366))
#  body = (begin ((primitive-ref write-char) #\# f6366) (if f6365 ((primitive-ref write-char) #\t f6366) ((primitive-ref write-char) #\f f6366)))
# emit-expr f6365
# emit-variable-ref
# env=((f6366 . -12) (f6365 . -8) (f6317 . -28) (f6318 . -24) (f6319 . -20) (f6320 . -16) (f6321 . -12) (f6322 . -8) (f6323 . -4) (f6324 . 0))
# var=f6365
    movl -8(%esp), %eax  # stack load f6365
# end emit-variable-ref
    movl %eax, -16(%esp)  # stack save
# emit-expr f6366
# emit-variable-ref
# env=((f6366 . -12) (f6365 . -8) (f6317 . -28) (f6318 . -24) (f6319 . -20) (f6320 . -16) (f6321 . -12) (f6322 . -8) (f6323 . -4) (f6324 . 0))
# var=f6366
    movl -12(%esp), %eax  # stack load f6366
# end emit-variable-ref
    movl %eax, -20(%esp)  # stack save
# emit-tail-expr
# si=-24
# env=((f6366 . -20) (f6365 . -16) (f6366 . -12) (f6365 . -8) (f6317 . -28) (f6318 . -24) (f6319 . -20) (f6320 . -16) (f6321 . -12) (f6322 . -8) (f6323 . -4) (f6324 . 0))
# expr=(begin ((primitive-ref write-char) #\# f6366) (if f6365 ((primitive-ref write-char) #\t f6366) ((primitive-ref write-char) #\f f6366)))
# tail-begin (begin ((primitive-ref write-char) #\# f6366) (if f6365 ((primitive-ref write-char) #\t f6366) ((primitive-ref write-char) #\f f6366)))
#   env=((f6366 . -20) (f6365 . -16) (f6366 . -12) (f6365 . -8) (f6317 . -28) (f6318 . -24) (f6319 . -20) (f6320 . -16) (f6321 . -12) (f6322 . -8) (f6323 . -4) (f6324 . 0))
# emit-expr ((primitive-ref write-char) #\# f6366)
# funcall
#    si   =-24
#    env  = ((f6366 . -20) (f6365 . -16) (f6366 . -12) (f6365 . -8) (f6317 . -28) (f6318 . -24) (f6319 . -20) (f6320 . -16) (f6321 . -12) (f6322 . -8) (f6323 . -4) (f6324 . 0))
#    expr = (funcall (primitive-ref write-char) #\# f6366)
# emit-expr (primitive-ref write-char)
    .extern mrc_write$mchar
    movl mrc_write$mchar,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_38535"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_38535":
   movl %eax,  -32(%esp)  # stash funcall-oper in closure slot
# emit-expr #\#
    movl $8975, %eax     # immed #\#
    mov %eax, -36(%esp)  # arg #
# emit-expr f6366
# emit-variable-ref
# env=((f6366 . -20) (f6365 . -16) (f6366 . -12) (f6365 . -8) (f6317 . -28) (f6318 . -24) (f6319 . -20) (f6320 . -16) (f6321 . -12) (f6322 . -8) (f6323 . -4) (f6324 . 0))
# var=f6366
    movl -20(%esp), %eax  # stack load f6366
# end emit-variable-ref
    mov %eax, -40(%esp)  # arg f6366
    movl -32(%esp), %edi   # load new closure to %edi
    add $-24, %esp   # adjust base
    movl $8,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $24, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
# emit-tail-expr
# si=-24
# env=((f6366 . -20) (f6365 . -16) (f6366 . -12) (f6365 . -8) (f6317 . -28) (f6318 . -24) (f6319 . -20) (f6320 . -16) (f6321 . -12) (f6322 . -8) (f6323 . -4) (f6324 . 0))
# expr=(begin (if f6365 ((primitive-ref write-char) #\t f6366) ((primitive-ref write-char) #\f f6366)))
# tail-begin (begin (if f6365 ((primitive-ref write-char) #\t f6366) ((primitive-ref write-char) #\f f6366)))
#   env=((f6366 . -20) (f6365 . -16) (f6366 . -12) (f6365 . -8) (f6317 . -28) (f6318 . -24) (f6319 . -20) (f6320 . -16) (f6321 . -12) (f6322 . -8) (f6323 . -4) (f6324 . 0))
# emit-tail-expr
# si=-24
# env=((f6366 . -20) (f6365 . -16) (f6366 . -12) (f6365 . -8) (f6317 . -28) (f6318 . -24) (f6319 . -20) (f6320 . -16) (f6321 . -12) (f6322 . -8) (f6323 . -4) (f6324 . 0))
# expr=(if f6365 ((primitive-ref write-char) #\t f6366) ((primitive-ref write-char) #\f f6366))
# emit-expr f6365
# emit-variable-ref
# env=((f6366 . -20) (f6365 . -16) (f6366 . -12) (f6365 . -8) (f6317 . -28) (f6318 . -24) (f6319 . -20) (f6320 . -16) (f6321 . -12) (f6322 . -8) (f6323 . -4) (f6324 . 0))
# var=f6365
    movl -16(%esp), %eax  # stack load f6365
# end emit-variable-ref
    cmp $47, %al
    je _L_38536
# emit-tail-expr
# si=-24
# env=((f6366 . -20) (f6365 . -16) (f6366 . -12) (f6365 . -8) (f6317 . -28) (f6318 . -24) (f6319 . -20) (f6320 . -16) (f6321 . -12) (f6322 . -8) (f6323 . -4) (f6324 . 0))
# expr=((primitive-ref write-char) #\t f6366)
# emit-tail-funcall
#    si   =-24
#    env  = ((f6366 . -20) (f6365 . -16) (f6366 . -12) (f6365 . -8) (f6317 . -28) (f6318 . -24) (f6319 . -20) (f6320 . -16) (f6321 . -12) (f6322 . -8) (f6323 . -4) (f6324 . 0))
#    expr = (funcall (primitive-ref write-char) #\t f6366)
# emit-expr (primitive-ref write-char)
    .extern mrc_write$mchar
    movl mrc_write$mchar,%eax
   movl %eax,  -24(%esp)  # stash funcall-oper in next closure slot
# emit-expr #\t
    movl $29711, %eax     # immed #\t
    mov %eax, -28(%esp)    # arg t
# emit-expr f6366
# emit-variable-ref
# env=((f6366 . -20) (f6365 . -16) (f6366 . -12) (f6365 . -8) (f6317 . -28) (f6318 . -24) (f6319 . -20) (f6320 . -16) (f6321 . -12) (f6322 . -8) (f6323 . -4) (f6324 . 0))
# var=f6366
    movl -20(%esp), %eax  # stack load f6366
# end emit-variable-ref
    mov %eax, -32(%esp)    # arg f6366
    movl -24(%esp), %edi   # load new closure to %edi
# emit-shift-args:  size=3   si=-24  delta=20
    mov -24(%esp), %ebx  # shift frame cell
    mov %ebx, -4(%esp)  # down to base
# emit-shift-args:  size=2   si=-28  delta=20
    mov -28(%esp), %ebx  # shift frame cell
    mov %ebx, -8(%esp)  # down to base
# emit-shift-args:  size=1   si=-32  delta=20
    mov -32(%esp), %ebx  # shift frame cell
    mov %ebx, -12(%esp)  # down to base
# emit-shift-args:  size=0   si=-36  delta=20
    movl $8,%eax   # save arg count
    jmp *-2(%edi)  # tail-funcall
    jmp _L_38537
_L_38536:
# emit-tail-expr
# si=-24
# env=((f6366 . -20) (f6365 . -16) (f6366 . -12) (f6365 . -8) (f6317 . -28) (f6318 . -24) (f6319 . -20) (f6320 . -16) (f6321 . -12) (f6322 . -8) (f6323 . -4) (f6324 . 0))
# expr=((primitive-ref write-char) #\f f6366)
# emit-tail-funcall
#    si   =-24
#    env  = ((f6366 . -20) (f6365 . -16) (f6366 . -12) (f6365 . -8) (f6317 . -28) (f6318 . -24) (f6319 . -20) (f6320 . -16) (f6321 . -12) (f6322 . -8) (f6323 . -4) (f6324 . 0))
#    expr = (funcall (primitive-ref write-char) #\f f6366)
# emit-expr (primitive-ref write-char)
    .extern mrc_write$mchar
    movl mrc_write$mchar,%eax
   movl %eax,  -24(%esp)  # stash funcall-oper in next closure slot
# emit-expr #\f
    movl $26127, %eax     # immed #\f
    mov %eax, -28(%esp)    # arg f
# emit-expr f6366
# emit-variable-ref
# env=((f6366 . -20) (f6365 . -16) (f6366 . -12) (f6365 . -8) (f6317 . -28) (f6318 . -24) (f6319 . -20) (f6320 . -16) (f6321 . -12) (f6322 . -8) (f6323 . -4) (f6324 . 0))
# var=f6366
    movl -20(%esp), %eax  # stack load f6366
# end emit-variable-ref
    mov %eax, -32(%esp)    # arg f6366
    movl -24(%esp), %edi   # load new closure to %edi
# emit-shift-args:  size=3   si=-24  delta=20
    mov -24(%esp), %ebx  # shift frame cell
    mov %ebx, -4(%esp)  # down to base
# emit-shift-args:  size=2   si=-28  delta=20
    mov -28(%esp), %ebx  # shift frame cell
    mov %ebx, -8(%esp)  # down to base
# emit-shift-args:  size=1   si=-32  delta=20
    mov -32(%esp), %ebx  # shift frame cell
    mov %ebx, -12(%esp)  # down to base
# emit-shift-args:  size=0   si=-36  delta=20
    movl $8,%eax   # save arg count
    jmp *-2(%edi)  # tail-funcall
_L_38537:
     ret   # return thru stack
    .align 4,0x90
_L_38533:
    movl -32(%esp), %ebx
    movl -36(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin (vector-set! f6323 0 (closure (f6364) () (let ((f6364 f6364)) (begin ((primitive-ref write-char) #\( f6364) ((primitive-ref write-char) #\) f6364))))) (vector-set! f6322 0 (closure (f6362 f6363) () (let ((f6362 f6362) (f6363 f6363)) (begin ((primitive-ref write-char) #\# f6363) ((primitive-ref write-char) #\\ f6363) ((primitive-ref write-char) f6362 f6363))))) (vector-set! f6321 0 (closure (f6358 f6359) (f6321) (let ((f6358 f6358) (f6359 f6359)) (if ((primitive-ref negative?) f6358) (begin ((primitive-ref write-char) #\- f6359) ((vector-ref f6321 0) (fx* -1 f6358) f6359)) ((primitive-ref map) (closure (f6361) (f6359) (let ((f6361 f6361)) ((primitive-ref write-char) (fixnum->char (fx+ (char->fixnum #\0) f6361)) f6359))) ((primitive-ref integer->list) f6358)))))) (vector-set! f6320 0 (closure (f6354 f6355) () (let ((f6354 f6354) (f6355 f6355)) (begin ((primitive-ref write-char) #\" f6355) ((primitive-ref for-each) (closure (f6357) (f6355) (let ((f6357 f6357)) ((primitive-ref write-char) f6357 f6355))) ((primitive-ref string->list) f6354)) ((primitive-ref write-char) #\" f6355))))) (vector-set! f6319 0 (closure (f6350 f6351) () (let ((f6350 f6350) (f6351 f6351)) ((primitive-ref for-each) (closure (f6353) (f6351) (let ((f6353 f6353)) ((primitive-ref write-char) f6353 f6351))) ((primitive-ref string->list) f6350))))) (vector-set! f6318 0 (closure (f6348 f6349) (f6317) (let ((f6348 f6348) (f6349 f6349)) (begin ((primitive-ref write-char) #\( f6349) ((vector-ref f6317 0) f6348 f6349) ((primitive-ref write-char) #\) f6349))))) (vector-set! f6317 0 (closure (f6346 f6347) (f6317) (let ((f6346 f6346) (f6347 f6347)) (begin ((primitive-ref write) (car f6346) f6347) (if (null? (cdr f6346)) #t (if (pair? (cdr f6346)) (begin ((primitive-ref write-char) #\space f6347) ((vector-ref f6317 0) (cdr f6346) f6347)) (begin ((primitive-ref write-char) #\space f6347) ((primitive-ref write-char) #\. f6347) ((primitive-ref write-char) #\space f6347) ((primitive-ref write) (cdr f6346) f6347)))))))))
# emit-begin
#   expr=(begin (vector-set! f6323 0 (closure (f6364) () (let ((f6364 f6364)) (begin ((primitive-ref write-char) #\( f6364) ((primitive-ref write-char) #\) f6364))))) (vector-set! f6322 0 (closure (f6362 f6363) () (let ((f6362 f6362) (f6363 f6363)) (begin ((primitive-ref write-char) #\# f6363) ((primitive-ref write-char) #\\ f6363) ((primitive-ref write-char) f6362 f6363))))) (vector-set! f6321 0 (closure (f6358 f6359) (f6321) (let ((f6358 f6358) (f6359 f6359)) (if ((primitive-ref negative?) f6358) (begin ((primitive-ref write-char) #\- f6359) ((vector-ref f6321 0) (fx* -1 f6358) f6359)) ((primitive-ref map) (closure (f6361) (f6359) (let ((f6361 f6361)) ((primitive-ref write-char) (fixnum->char (fx+ (char->fixnum #\0) f6361)) f6359))) ((primitive-ref integer->list) f6358)))))) (vector-set! f6320 0 (closure (f6354 f6355) () (let ((f6354 f6354) (f6355 f6355)) (begin ((primitive-ref write-char) #\" f6355) ((primitive-ref for-each) (closure (f6357) (f6355) (let ((f6357 f6357)) ((primitive-ref write-char) f6357 f6355))) ((primitive-ref string->list) f6354)) ((primitive-ref write-char) #\" f6355))))) (vector-set! f6319 0 (closure (f6350 f6351) () (let ((f6350 f6350) (f6351 f6351)) ((primitive-ref for-each) (closure (f6353) (f6351) (let ((f6353 f6353)) ((primitive-ref write-char) f6353 f6351))) ((primitive-ref string->list) f6350))))) (vector-set! f6318 0 (closure (f6348 f6349) (f6317) (let ((f6348 f6348) (f6349 f6349)) (begin ((primitive-ref write-char) #\( f6349) ((vector-ref f6317 0) f6348 f6349) ((primitive-ref write-char) #\) f6349))))) (vector-set! f6317 0 (closure (f6346 f6347) (f6317) (let ((f6346 f6346) (f6347 f6347)) (begin ((primitive-ref write) (car f6346) f6347) (if (null? (cdr f6346)) #t (if (pair? (cdr f6346)) (begin ((primitive-ref write-char) #\space f6347) ((vector-ref f6317 0) (cdr f6346) f6347)) (begin ((primitive-ref write-char) #\space f6347) ((primitive-ref write-char) #\. f6347) ((primitive-ref write-char) #\space f6347) ((primitive-ref write) (cdr f6346) f6347)))))))))
#   env=((f6317 . -28) (f6318 . -24) (f6319 . -20) (f6320 . -16) (f6321 . -12) (f6322 . -8) (f6323 . -4) (f6324 . 0))
# emit-expr (vector-set! f6323 0 (closure (f6364) () (let ((f6364 f6364)) (begin ((primitive-ref write-char) #\( f6364) ((primitive-ref write-char) #\) f6364)))))
# emit-expr f6323
# emit-variable-ref
# env=((f6317 . -28) (f6318 . -24) (f6319 . -20) (f6320 . -16) (f6321 . -12) (f6322 . -8) (f6323 . -4) (f6324 . 0))
# var=f6323
    movl -4(%esp), %eax  # stack load f6323
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_38538
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_38538:
    movl %eax, -32(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_38539"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_38539:
# check bounds on vector index
    movl -32(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_38541
    cmp  $0,%eax
    jge _L_38540
_L_38541:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_38540:
    movl %eax, -36(%esp)
# emit-expr (closure (f6364) () (let ((f6364 f6364)) (begin ((primitive-ref write-char) #\( f6364) ((primitive-ref write-char) #\) f6364))))
# emit-closure
# si = -40
# env = ((f6317 . -28) (f6318 . -24) (f6319 . -20) (f6320 . -16) (f6321 . -12) (f6322 . -8) (f6323 . -4) (f6324 . 0))
# expr = (closure (f6364) () (let ((f6364 f6364)) (begin ((primitive-ref write-char) #\( f6364) ((primitive-ref write-char) #\) f6364))))
    movl $_L_38542, 0(%ebp)  # closure label
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $8, %ebp     # bump ebp
    jmp _L_38543            # jump around closure body
_L_38542:
# check argument count
    cmp $4,%eax
    je _L_38544
# invoke error handler eh_argcount
    .extern mrc_eh$uargcount
    movl mrc_eh$uargcount, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_38544:
# emit-tail-expr
# si=-12
# env=((f6364 . -8) (f6317 . -28) (f6318 . -24) (f6319 . -20) (f6320 . -16) (f6321 . -12) (f6322 . -8) (f6323 . -4) (f6324 . 0))
# expr=(let ((f6364 f6364)) (begin ((primitive-ref write-char) #\( f6364) ((primitive-ref write-char) #\) f6364)))
# emit-tail-let
#  si   = -12
#  env  = ((f6364 . -8) (f6317 . -28) (f6318 . -24) (f6319 . -20) (f6320 . -16) (f6321 . -12) (f6322 . -8) (f6323 . -4) (f6324 . 0))
#  bindings = ((f6364 f6364))
#  body = (begin ((primitive-ref write-char) #\( f6364) ((primitive-ref write-char) #\) f6364))
# emit-expr f6364
# emit-variable-ref
# env=((f6364 . -8) (f6317 . -28) (f6318 . -24) (f6319 . -20) (f6320 . -16) (f6321 . -12) (f6322 . -8) (f6323 . -4) (f6324 . 0))
# var=f6364
    movl -8(%esp), %eax  # stack load f6364
# end emit-variable-ref
    movl %eax, -12(%esp)  # stack save
# emit-tail-expr
# si=-16
# env=((f6364 . -12) (f6364 . -8) (f6317 . -28) (f6318 . -24) (f6319 . -20) (f6320 . -16) (f6321 . -12) (f6322 . -8) (f6323 . -4) (f6324 . 0))
# expr=(begin ((primitive-ref write-char) #\( f6364) ((primitive-ref write-char) #\) f6364))
# tail-begin (begin ((primitive-ref write-char) #\( f6364) ((primitive-ref write-char) #\) f6364))
#   env=((f6364 . -12) (f6364 . -8) (f6317 . -28) (f6318 . -24) (f6319 . -20) (f6320 . -16) (f6321 . -12) (f6322 . -8) (f6323 . -4) (f6324 . 0))
# emit-expr ((primitive-ref write-char) #\( f6364)
# funcall
#    si   =-16
#    env  = ((f6364 . -12) (f6364 . -8) (f6317 . -28) (f6318 . -24) (f6319 . -20) (f6320 . -16) (f6321 . -12) (f6322 . -8) (f6323 . -4) (f6324 . 0))
#    expr = (funcall (primitive-ref write-char) #\( f6364)
# emit-expr (primitive-ref write-char)
    .extern mrc_write$mchar
    movl mrc_write$mchar,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_38545"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_38545":
   movl %eax,  -24(%esp)  # stash funcall-oper in closure slot
# emit-expr #\(
    movl $10255, %eax     # immed #\(
    mov %eax, -28(%esp)  # arg (
# emit-expr f6364
# emit-variable-ref
# env=((f6364 . -12) (f6364 . -8) (f6317 . -28) (f6318 . -24) (f6319 . -20) (f6320 . -16) (f6321 . -12) (f6322 . -8) (f6323 . -4) (f6324 . 0))
# var=f6364
    movl -12(%esp), %eax  # stack load f6364
# end emit-variable-ref
    mov %eax, -32(%esp)  # arg f6364
    movl -24(%esp), %edi   # load new closure to %edi
    add $-16, %esp   # adjust base
    movl $8,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $16, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
# emit-tail-expr
# si=-16
# env=((f6364 . -12) (f6364 . -8) (f6317 . -28) (f6318 . -24) (f6319 . -20) (f6320 . -16) (f6321 . -12) (f6322 . -8) (f6323 . -4) (f6324 . 0))
# expr=(begin ((primitive-ref write-char) #\) f6364))
# tail-begin (begin ((primitive-ref write-char) #\) f6364))
#   env=((f6364 . -12) (f6364 . -8) (f6317 . -28) (f6318 . -24) (f6319 . -20) (f6320 . -16) (f6321 . -12) (f6322 . -8) (f6323 . -4) (f6324 . 0))
# emit-tail-expr
# si=-16
# env=((f6364 . -12) (f6364 . -8) (f6317 . -28) (f6318 . -24) (f6319 . -20) (f6320 . -16) (f6321 . -12) (f6322 . -8) (f6323 . -4) (f6324 . 0))
# expr=((primitive-ref write-char) #\) f6364)
# emit-tail-funcall
#    si   =-16
#    env  = ((f6364 . -12) (f6364 . -8) (f6317 . -28) (f6318 . -24) (f6319 . -20) (f6320 . -16) (f6321 . -12) (f6322 . -8) (f6323 . -4) (f6324 . 0))
#    expr = (funcall (primitive-ref write-char) #\) f6364)
# emit-expr (primitive-ref write-char)
    .extern mrc_write$mchar
    movl mrc_write$mchar,%eax
   movl %eax,  -16(%esp)  # stash funcall-oper in next closure slot
# emit-expr #\)
    movl $10511, %eax     # immed #\)
    mov %eax, -20(%esp)    # arg )
# emit-expr f6364
# emit-variable-ref
# env=((f6364 . -12) (f6364 . -8) (f6317 . -28) (f6318 . -24) (f6319 . -20) (f6320 . -16) (f6321 . -12) (f6322 . -8) (f6323 . -4) (f6324 . 0))
# var=f6364
    movl -12(%esp), %eax  # stack load f6364
# end emit-variable-ref
    mov %eax, -24(%esp)    # arg f6364
    movl -16(%esp), %edi   # load new closure to %edi
# emit-shift-args:  size=3   si=-16  delta=12
    mov -16(%esp), %ebx  # shift frame cell
    mov %ebx, -4(%esp)  # down to base
# emit-shift-args:  size=2   si=-20  delta=12
    mov -20(%esp), %ebx  # shift frame cell
    mov %ebx, -8(%esp)  # down to base
# emit-shift-args:  size=1   si=-24  delta=12
    mov -24(%esp), %ebx  # shift frame cell
    mov %ebx, -12(%esp)  # down to base
# emit-shift-args:  size=0   si=-28  delta=12
    movl $8,%eax   # save arg count
    jmp *-2(%edi)  # tail-funcall
     ret   # return thru stack
    .align 4,0x90
_L_38543:
    movl -32(%esp), %ebx
    movl -36(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin (vector-set! f6322 0 (closure (f6362 f6363) () (let ((f6362 f6362) (f6363 f6363)) (begin ((primitive-ref write-char) #\# f6363) ((primitive-ref write-char) #\\ f6363) ((primitive-ref write-char) f6362 f6363))))) (vector-set! f6321 0 (closure (f6358 f6359) (f6321) (let ((f6358 f6358) (f6359 f6359)) (if ((primitive-ref negative?) f6358) (begin ((primitive-ref write-char) #\- f6359) ((vector-ref f6321 0) (fx* -1 f6358) f6359)) ((primitive-ref map) (closure (f6361) (f6359) (let ((f6361 f6361)) ((primitive-ref write-char) (fixnum->char (fx+ (char->fixnum #\0) f6361)) f6359))) ((primitive-ref integer->list) f6358)))))) (vector-set! f6320 0 (closure (f6354 f6355) () (let ((f6354 f6354) (f6355 f6355)) (begin ((primitive-ref write-char) #\" f6355) ((primitive-ref for-each) (closure (f6357) (f6355) (let ((f6357 f6357)) ((primitive-ref write-char) f6357 f6355))) ((primitive-ref string->list) f6354)) ((primitive-ref write-char) #\" f6355))))) (vector-set! f6319 0 (closure (f6350 f6351) () (let ((f6350 f6350) (f6351 f6351)) ((primitive-ref for-each) (closure (f6353) (f6351) (let ((f6353 f6353)) ((primitive-ref write-char) f6353 f6351))) ((primitive-ref string->list) f6350))))) (vector-set! f6318 0 (closure (f6348 f6349) (f6317) (let ((f6348 f6348) (f6349 f6349)) (begin ((primitive-ref write-char) #\( f6349) ((vector-ref f6317 0) f6348 f6349) ((primitive-ref write-char) #\) f6349))))) (vector-set! f6317 0 (closure (f6346 f6347) (f6317) (let ((f6346 f6346) (f6347 f6347)) (begin ((primitive-ref write) (car f6346) f6347) (if (null? (cdr f6346)) #t (if (pair? (cdr f6346)) (begin ((primitive-ref write-char) #\space f6347) ((vector-ref f6317 0) (cdr f6346) f6347)) (begin ((primitive-ref write-char) #\space f6347) ((primitive-ref write-char) #\. f6347) ((primitive-ref write-char) #\space f6347) ((primitive-ref write) (cdr f6346) f6347)))))))))
# emit-begin
#   expr=(begin (vector-set! f6322 0 (closure (f6362 f6363) () (let ((f6362 f6362) (f6363 f6363)) (begin ((primitive-ref write-char) #\# f6363) ((primitive-ref write-char) #\\ f6363) ((primitive-ref write-char) f6362 f6363))))) (vector-set! f6321 0 (closure (f6358 f6359) (f6321) (let ((f6358 f6358) (f6359 f6359)) (if ((primitive-ref negative?) f6358) (begin ((primitive-ref write-char) #\- f6359) ((vector-ref f6321 0) (fx* -1 f6358) f6359)) ((primitive-ref map) (closure (f6361) (f6359) (let ((f6361 f6361)) ((primitive-ref write-char) (fixnum->char (fx+ (char->fixnum #\0) f6361)) f6359))) ((primitive-ref integer->list) f6358)))))) (vector-set! f6320 0 (closure (f6354 f6355) () (let ((f6354 f6354) (f6355 f6355)) (begin ((primitive-ref write-char) #\" f6355) ((primitive-ref for-each) (closure (f6357) (f6355) (let ((f6357 f6357)) ((primitive-ref write-char) f6357 f6355))) ((primitive-ref string->list) f6354)) ((primitive-ref write-char) #\" f6355))))) (vector-set! f6319 0 (closure (f6350 f6351) () (let ((f6350 f6350) (f6351 f6351)) ((primitive-ref for-each) (closure (f6353) (f6351) (let ((f6353 f6353)) ((primitive-ref write-char) f6353 f6351))) ((primitive-ref string->list) f6350))))) (vector-set! f6318 0 (closure (f6348 f6349) (f6317) (let ((f6348 f6348) (f6349 f6349)) (begin ((primitive-ref write-char) #\( f6349) ((vector-ref f6317 0) f6348 f6349) ((primitive-ref write-char) #\) f6349))))) (vector-set! f6317 0 (closure (f6346 f6347) (f6317) (let ((f6346 f6346) (f6347 f6347)) (begin ((primitive-ref write) (car f6346) f6347) (if (null? (cdr f6346)) #t (if (pair? (cdr f6346)) (begin ((primitive-ref write-char) #\space f6347) ((vector-ref f6317 0) (cdr f6346) f6347)) (begin ((primitive-ref write-char) #\space f6347) ((primitive-ref write-char) #\. f6347) ((primitive-ref write-char) #\space f6347) ((primitive-ref write) (cdr f6346) f6347)))))))))
#   env=((f6317 . -28) (f6318 . -24) (f6319 . -20) (f6320 . -16) (f6321 . -12) (f6322 . -8) (f6323 . -4) (f6324 . 0))
# emit-expr (vector-set! f6322 0 (closure (f6362 f6363) () (let ((f6362 f6362) (f6363 f6363)) (begin ((primitive-ref write-char) #\# f6363) ((primitive-ref write-char) #\\ f6363) ((primitive-ref write-char) f6362 f6363)))))
# emit-expr f6322
# emit-variable-ref
# env=((f6317 . -28) (f6318 . -24) (f6319 . -20) (f6320 . -16) (f6321 . -12) (f6322 . -8) (f6323 . -4) (f6324 . 0))
# var=f6322
    movl -8(%esp), %eax  # stack load f6322
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_38546
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_38546:
    movl %eax, -32(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_38547"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_38547:
# check bounds on vector index
    movl -32(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_38549
    cmp  $0,%eax
    jge _L_38548
_L_38549:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_38548:
    movl %eax, -36(%esp)
# emit-expr (closure (f6362 f6363) () (let ((f6362 f6362) (f6363 f6363)) (begin ((primitive-ref write-char) #\# f6363) ((primitive-ref write-char) #\\ f6363) ((primitive-ref write-char) f6362 f6363))))
# emit-closure
# si = -40
# env = ((f6317 . -28) (f6318 . -24) (f6319 . -20) (f6320 . -16) (f6321 . -12) (f6322 . -8) (f6323 . -4) (f6324 . 0))
# expr = (closure (f6362 f6363) () (let ((f6362 f6362) (f6363 f6363)) (begin ((primitive-ref write-char) #\# f6363) ((primitive-ref write-char) #\\ f6363) ((primitive-ref write-char) f6362 f6363))))
    movl $_L_38550, 0(%ebp)  # closure label
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $8, %ebp     # bump ebp
    jmp _L_38551            # jump around closure body
_L_38550:
# check argument count
    cmp $8,%eax
    je _L_38552
# invoke error handler eh_argcount
    .extern mrc_eh$uargcount
    movl mrc_eh$uargcount, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_38552:
# emit-tail-expr
# si=-16
# env=((f6363 . -12) (f6362 . -8) (f6317 . -28) (f6318 . -24) (f6319 . -20) (f6320 . -16) (f6321 . -12) (f6322 . -8) (f6323 . -4) (f6324 . 0))
# expr=(let ((f6362 f6362) (f6363 f6363)) (begin ((primitive-ref write-char) #\# f6363) ((primitive-ref write-char) #\\ f6363) ((primitive-ref write-char) f6362 f6363)))
# emit-tail-let
#  si   = -16
#  env  = ((f6363 . -12) (f6362 . -8) (f6317 . -28) (f6318 . -24) (f6319 . -20) (f6320 . -16) (f6321 . -12) (f6322 . -8) (f6323 . -4) (f6324 . 0))
#  bindings = ((f6362 f6362) (f6363 f6363))
#  body = (begin ((primitive-ref write-char) #\# f6363) ((primitive-ref write-char) #\\ f6363) ((primitive-ref write-char) f6362 f6363))
# emit-expr f6362
# emit-variable-ref
# env=((f6363 . -12) (f6362 . -8) (f6317 . -28) (f6318 . -24) (f6319 . -20) (f6320 . -16) (f6321 . -12) (f6322 . -8) (f6323 . -4) (f6324 . 0))
# var=f6362
    movl -8(%esp), %eax  # stack load f6362
# end emit-variable-ref
    movl %eax, -16(%esp)  # stack save
# emit-expr f6363
# emit-variable-ref
# env=((f6363 . -12) (f6362 . -8) (f6317 . -28) (f6318 . -24) (f6319 . -20) (f6320 . -16) (f6321 . -12) (f6322 . -8) (f6323 . -4) (f6324 . 0))
# var=f6363
    movl -12(%esp), %eax  # stack load f6363
# end emit-variable-ref
    movl %eax, -20(%esp)  # stack save
# emit-tail-expr
# si=-24
# env=((f6363 . -20) (f6362 . -16) (f6363 . -12) (f6362 . -8) (f6317 . -28) (f6318 . -24) (f6319 . -20) (f6320 . -16) (f6321 . -12) (f6322 . -8) (f6323 . -4) (f6324 . 0))
# expr=(begin ((primitive-ref write-char) #\# f6363) ((primitive-ref write-char) #\\ f6363) ((primitive-ref write-char) f6362 f6363))
# tail-begin (begin ((primitive-ref write-char) #\# f6363) ((primitive-ref write-char) #\\ f6363) ((primitive-ref write-char) f6362 f6363))
#   env=((f6363 . -20) (f6362 . -16) (f6363 . -12) (f6362 . -8) (f6317 . -28) (f6318 . -24) (f6319 . -20) (f6320 . -16) (f6321 . -12) (f6322 . -8) (f6323 . -4) (f6324 . 0))
# emit-expr ((primitive-ref write-char) #\# f6363)
# funcall
#    si   =-24
#    env  = ((f6363 . -20) (f6362 . -16) (f6363 . -12) (f6362 . -8) (f6317 . -28) (f6318 . -24) (f6319 . -20) (f6320 . -16) (f6321 . -12) (f6322 . -8) (f6323 . -4) (f6324 . 0))
#    expr = (funcall (primitive-ref write-char) #\# f6363)
# emit-expr (primitive-ref write-char)
    .extern mrc_write$mchar
    movl mrc_write$mchar,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_38553"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_38553":
   movl %eax,  -32(%esp)  # stash funcall-oper in closure slot
# emit-expr #\#
    movl $8975, %eax     # immed #\#
    mov %eax, -36(%esp)  # arg #
# emit-expr f6363
# emit-variable-ref
# env=((f6363 . -20) (f6362 . -16) (f6363 . -12) (f6362 . -8) (f6317 . -28) (f6318 . -24) (f6319 . -20) (f6320 . -16) (f6321 . -12) (f6322 . -8) (f6323 . -4) (f6324 . 0))
# var=f6363
    movl -20(%esp), %eax  # stack load f6363
# end emit-variable-ref
    mov %eax, -40(%esp)  # arg f6363
    movl -32(%esp), %edi   # load new closure to %edi
    add $-24, %esp   # adjust base
    movl $8,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $24, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
# emit-tail-expr
# si=-24
# env=((f6363 . -20) (f6362 . -16) (f6363 . -12) (f6362 . -8) (f6317 . -28) (f6318 . -24) (f6319 . -20) (f6320 . -16) (f6321 . -12) (f6322 . -8) (f6323 . -4) (f6324 . 0))
# expr=(begin ((primitive-ref write-char) #\\ f6363) ((primitive-ref write-char) f6362 f6363))
# tail-begin (begin ((primitive-ref write-char) #\\ f6363) ((primitive-ref write-char) f6362 f6363))
#   env=((f6363 . -20) (f6362 . -16) (f6363 . -12) (f6362 . -8) (f6317 . -28) (f6318 . -24) (f6319 . -20) (f6320 . -16) (f6321 . -12) (f6322 . -8) (f6323 . -4) (f6324 . 0))
# emit-expr ((primitive-ref write-char) #\\ f6363)
# funcall
#    si   =-24
#    env  = ((f6363 . -20) (f6362 . -16) (f6363 . -12) (f6362 . -8) (f6317 . -28) (f6318 . -24) (f6319 . -20) (f6320 . -16) (f6321 . -12) (f6322 . -8) (f6323 . -4) (f6324 . 0))
#    expr = (funcall (primitive-ref write-char) #\\ f6363)
# emit-expr (primitive-ref write-char)
    .extern mrc_write$mchar
    movl mrc_write$mchar,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_38554"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_38554":
   movl %eax,  -32(%esp)  # stash funcall-oper in closure slot
# emit-expr #\\
    movl $23567, %eax     # immed #\\
    mov %eax, -36(%esp)  # arg \
# emit-expr f6363
# emit-variable-ref
# env=((f6363 . -20) (f6362 . -16) (f6363 . -12) (f6362 . -8) (f6317 . -28) (f6318 . -24) (f6319 . -20) (f6320 . -16) (f6321 . -12) (f6322 . -8) (f6323 . -4) (f6324 . 0))
# var=f6363
    movl -20(%esp), %eax  # stack load f6363
# end emit-variable-ref
    mov %eax, -40(%esp)  # arg f6363
    movl -32(%esp), %edi   # load new closure to %edi
    add $-24, %esp   # adjust base
    movl $8,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $24, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
# emit-tail-expr
# si=-24
# env=((f6363 . -20) (f6362 . -16) (f6363 . -12) (f6362 . -8) (f6317 . -28) (f6318 . -24) (f6319 . -20) (f6320 . -16) (f6321 . -12) (f6322 . -8) (f6323 . -4) (f6324 . 0))
# expr=(begin ((primitive-ref write-char) f6362 f6363))
# tail-begin (begin ((primitive-ref write-char) f6362 f6363))
#   env=((f6363 . -20) (f6362 . -16) (f6363 . -12) (f6362 . -8) (f6317 . -28) (f6318 . -24) (f6319 . -20) (f6320 . -16) (f6321 . -12) (f6322 . -8) (f6323 . -4) (f6324 . 0))
# emit-tail-expr
# si=-24
# env=((f6363 . -20) (f6362 . -16) (f6363 . -12) (f6362 . -8) (f6317 . -28) (f6318 . -24) (f6319 . -20) (f6320 . -16) (f6321 . -12) (f6322 . -8) (f6323 . -4) (f6324 . 0))
# expr=((primitive-ref write-char) f6362 f6363)
# emit-tail-funcall
#    si   =-24
#    env  = ((f6363 . -20) (f6362 . -16) (f6363 . -12) (f6362 . -8) (f6317 . -28) (f6318 . -24) (f6319 . -20) (f6320 . -16) (f6321 . -12) (f6322 . -8) (f6323 . -4) (f6324 . 0))
#    expr = (funcall (primitive-ref write-char) f6362 f6363)
# emit-expr (primitive-ref write-char)
    .extern mrc_write$mchar
    movl mrc_write$mchar,%eax
   movl %eax,  -24(%esp)  # stash funcall-oper in next closure slot
# emit-expr f6362
# emit-variable-ref
# env=((f6363 . -20) (f6362 . -16) (f6363 . -12) (f6362 . -8) (f6317 . -28) (f6318 . -24) (f6319 . -20) (f6320 . -16) (f6321 . -12) (f6322 . -8) (f6323 . -4) (f6324 . 0))
# var=f6362
    movl -16(%esp), %eax  # stack load f6362
# end emit-variable-ref
    mov %eax, -28(%esp)    # arg f6362
# emit-expr f6363
# emit-variable-ref
# env=((f6363 . -20) (f6362 . -16) (f6363 . -12) (f6362 . -8) (f6317 . -28) (f6318 . -24) (f6319 . -20) (f6320 . -16) (f6321 . -12) (f6322 . -8) (f6323 . -4) (f6324 . 0))
# var=f6363
    movl -20(%esp), %eax  # stack load f6363
# end emit-variable-ref
    mov %eax, -32(%esp)    # arg f6363
    movl -24(%esp), %edi   # load new closure to %edi
# emit-shift-args:  size=3   si=-24  delta=20
    mov -24(%esp), %ebx  # shift frame cell
    mov %ebx, -4(%esp)  # down to base
# emit-shift-args:  size=2   si=-28  delta=20
    mov -28(%esp), %ebx  # shift frame cell
    mov %ebx, -8(%esp)  # down to base
# emit-shift-args:  size=1   si=-32  delta=20
    mov -32(%esp), %ebx  # shift frame cell
    mov %ebx, -12(%esp)  # down to base
# emit-shift-args:  size=0   si=-36  delta=20
    movl $8,%eax   # save arg count
    jmp *-2(%edi)  # tail-funcall
     ret   # return thru stack
    .align 4,0x90
_L_38551:
    movl -32(%esp), %ebx
    movl -36(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin (vector-set! f6321 0 (closure (f6358 f6359) (f6321) (let ((f6358 f6358) (f6359 f6359)) (if ((primitive-ref negative?) f6358) (begin ((primitive-ref write-char) #\- f6359) ((vector-ref f6321 0) (fx* -1 f6358) f6359)) ((primitive-ref map) (closure (f6361) (f6359) (let ((f6361 f6361)) ((primitive-ref write-char) (fixnum->char (fx+ (char->fixnum #\0) f6361)) f6359))) ((primitive-ref integer->list) f6358)))))) (vector-set! f6320 0 (closure (f6354 f6355) () (let ((f6354 f6354) (f6355 f6355)) (begin ((primitive-ref write-char) #\" f6355) ((primitive-ref for-each) (closure (f6357) (f6355) (let ((f6357 f6357)) ((primitive-ref write-char) f6357 f6355))) ((primitive-ref string->list) f6354)) ((primitive-ref write-char) #\" f6355))))) (vector-set! f6319 0 (closure (f6350 f6351) () (let ((f6350 f6350) (f6351 f6351)) ((primitive-ref for-each) (closure (f6353) (f6351) (let ((f6353 f6353)) ((primitive-ref write-char) f6353 f6351))) ((primitive-ref string->list) f6350))))) (vector-set! f6318 0 (closure (f6348 f6349) (f6317) (let ((f6348 f6348) (f6349 f6349)) (begin ((primitive-ref write-char) #\( f6349) ((vector-ref f6317 0) f6348 f6349) ((primitive-ref write-char) #\) f6349))))) (vector-set! f6317 0 (closure (f6346 f6347) (f6317) (let ((f6346 f6346) (f6347 f6347)) (begin ((primitive-ref write) (car f6346) f6347) (if (null? (cdr f6346)) #t (if (pair? (cdr f6346)) (begin ((primitive-ref write-char) #\space f6347) ((vector-ref f6317 0) (cdr f6346) f6347)) (begin ((primitive-ref write-char) #\space f6347) ((primitive-ref write-char) #\. f6347) ((primitive-ref write-char) #\space f6347) ((primitive-ref write) (cdr f6346) f6347)))))))))
# emit-begin
#   expr=(begin (vector-set! f6321 0 (closure (f6358 f6359) (f6321) (let ((f6358 f6358) (f6359 f6359)) (if ((primitive-ref negative?) f6358) (begin ((primitive-ref write-char) #\- f6359) ((vector-ref f6321 0) (fx* -1 f6358) f6359)) ((primitive-ref map) (closure (f6361) (f6359) (let ((f6361 f6361)) ((primitive-ref write-char) (fixnum->char (fx+ (char->fixnum #\0) f6361)) f6359))) ((primitive-ref integer->list) f6358)))))) (vector-set! f6320 0 (closure (f6354 f6355) () (let ((f6354 f6354) (f6355 f6355)) (begin ((primitive-ref write-char) #\" f6355) ((primitive-ref for-each) (closure (f6357) (f6355) (let ((f6357 f6357)) ((primitive-ref write-char) f6357 f6355))) ((primitive-ref string->list) f6354)) ((primitive-ref write-char) #\" f6355))))) (vector-set! f6319 0 (closure (f6350 f6351) () (let ((f6350 f6350) (f6351 f6351)) ((primitive-ref for-each) (closure (f6353) (f6351) (let ((f6353 f6353)) ((primitive-ref write-char) f6353 f6351))) ((primitive-ref string->list) f6350))))) (vector-set! f6318 0 (closure (f6348 f6349) (f6317) (let ((f6348 f6348) (f6349 f6349)) (begin ((primitive-ref write-char) #\( f6349) ((vector-ref f6317 0) f6348 f6349) ((primitive-ref write-char) #\) f6349))))) (vector-set! f6317 0 (closure (f6346 f6347) (f6317) (let ((f6346 f6346) (f6347 f6347)) (begin ((primitive-ref write) (car f6346) f6347) (if (null? (cdr f6346)) #t (if (pair? (cdr f6346)) (begin ((primitive-ref write-char) #\space f6347) ((vector-ref f6317 0) (cdr f6346) f6347)) (begin ((primitive-ref write-char) #\space f6347) ((primitive-ref write-char) #\. f6347) ((primitive-ref write-char) #\space f6347) ((primitive-ref write) (cdr f6346) f6347)))))))))
#   env=((f6317 . -28) (f6318 . -24) (f6319 . -20) (f6320 . -16) (f6321 . -12) (f6322 . -8) (f6323 . -4) (f6324 . 0))
# emit-expr (vector-set! f6321 0 (closure (f6358 f6359) (f6321) (let ((f6358 f6358) (f6359 f6359)) (if ((primitive-ref negative?) f6358) (begin ((primitive-ref write-char) #\- f6359) ((vector-ref f6321 0) (fx* -1 f6358) f6359)) ((primitive-ref map) (closure (f6361) (f6359) (let ((f6361 f6361)) ((primitive-ref write-char) (fixnum->char (fx+ (char->fixnum #\0) f6361)) f6359))) ((primitive-ref integer->list) f6358))))))
# emit-expr f6321
# emit-variable-ref
# env=((f6317 . -28) (f6318 . -24) (f6319 . -20) (f6320 . -16) (f6321 . -12) (f6322 . -8) (f6323 . -4) (f6324 . 0))
# var=f6321
    movl -12(%esp), %eax  # stack load f6321
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_38555
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_38555:
    movl %eax, -32(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_38556"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_38556:
# check bounds on vector index
    movl -32(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_38558
    cmp  $0,%eax
    jge _L_38557
_L_38558:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_38557:
    movl %eax, -36(%esp)
# emit-expr (closure (f6358 f6359) (f6321) (let ((f6358 f6358) (f6359 f6359)) (if ((primitive-ref negative?) f6358) (begin ((primitive-ref write-char) #\- f6359) ((vector-ref f6321 0) (fx* -1 f6358) f6359)) ((primitive-ref map) (closure (f6361) (f6359) (let ((f6361 f6361)) ((primitive-ref write-char) (fixnum->char (fx+ (char->fixnum #\0) f6361)) f6359))) ((primitive-ref integer->list) f6358)))))
# emit-closure
# si = -40
# env = ((f6317 . -28) (f6318 . -24) (f6319 . -20) (f6320 . -16) (f6321 . -12) (f6322 . -8) (f6323 . -4) (f6324 . 0))
# expr = (closure (f6358 f6359) (f6321) (let ((f6358 f6358) (f6359 f6359)) (if ((primitive-ref negative?) f6358) (begin ((primitive-ref write-char) #\- f6359) ((vector-ref f6321 0) (fx* -1 f6358) f6359)) ((primitive-ref map) (closure (f6361) (f6359) (let ((f6361 f6361)) ((primitive-ref write-char) (fixnum->char (fx+ (char->fixnum #\0) f6361)) f6359))) ((primitive-ref integer->list) f6358)))))
    movl $_L_38559, 0(%ebp)  # closure label
# emit-variable-ref
# env=((f6317 . -28) (f6318 . -24) (f6319 . -20) (f6320 . -16) (f6321 . -12) (f6322 . -8) (f6323 . -4) (f6324 . 0))
# var=f6321
    movl -12(%esp), %eax  # stack load f6321
# end emit-variable-ref
   movl  %eax, 4(%ebp)  # f6321
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $8, %ebp     # bump ebp
    jmp _L_38560            # jump around closure body
_L_38559:
# check argument count
    cmp $8,%eax
    je _L_38561
# invoke error handler eh_argcount
    .extern mrc_eh$uargcount
    movl mrc_eh$uargcount, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_38561:
# emit-tail-expr
# si=-16
# env=((f6359 . -12) (f6358 . -8) (f6321 . 4) (f6317 . -28) (f6318 . -24) (f6319 . -20) (f6320 . -16) (f6321 . -12) (f6322 . -8) (f6323 . -4) (f6324 . 0))
# expr=(let ((f6358 f6358) (f6359 f6359)) (if ((primitive-ref negative?) f6358) (begin ((primitive-ref write-char) #\- f6359) ((vector-ref f6321 0) (fx* -1 f6358) f6359)) ((primitive-ref map) (closure (f6361) (f6359) (let ((f6361 f6361)) ((primitive-ref write-char) (fixnum->char (fx+ (char->fixnum #\0) f6361)) f6359))) ((primitive-ref integer->list) f6358))))
# emit-tail-let
#  si   = -16
#  env  = ((f6359 . -12) (f6358 . -8) (f6321 . 4) (f6317 . -28) (f6318 . -24) (f6319 . -20) (f6320 . -16) (f6321 . -12) (f6322 . -8) (f6323 . -4) (f6324 . 0))
#  bindings = ((f6358 f6358) (f6359 f6359))
#  body = (if ((primitive-ref negative?) f6358) (begin ((primitive-ref write-char) #\- f6359) ((vector-ref f6321 0) (fx* -1 f6358) f6359)) ((primitive-ref map) (closure (f6361) (f6359) (let ((f6361 f6361)) ((primitive-ref write-char) (fixnum->char (fx+ (char->fixnum #\0) f6361)) f6359))) ((primitive-ref integer->list) f6358)))
# emit-expr f6358
# emit-variable-ref
# env=((f6359 . -12) (f6358 . -8) (f6321 . 4) (f6317 . -28) (f6318 . -24) (f6319 . -20) (f6320 . -16) (f6321 . -12) (f6322 . -8) (f6323 . -4) (f6324 . 0))
# var=f6358
    movl -8(%esp), %eax  # stack load f6358
# end emit-variable-ref
    movl %eax, -16(%esp)  # stack save
# emit-expr f6359
# emit-variable-ref
# env=((f6359 . -12) (f6358 . -8) (f6321 . 4) (f6317 . -28) (f6318 . -24) (f6319 . -20) (f6320 . -16) (f6321 . -12) (f6322 . -8) (f6323 . -4) (f6324 . 0))
# var=f6359
    movl -12(%esp), %eax  # stack load f6359
# end emit-variable-ref
    movl %eax, -20(%esp)  # stack save
# emit-tail-expr
# si=-24
# env=((f6359 . -20) (f6358 . -16) (f6359 . -12) (f6358 . -8) (f6321 . 4) (f6317 . -28) (f6318 . -24) (f6319 . -20) (f6320 . -16) (f6321 . -12) (f6322 . -8) (f6323 . -4) (f6324 . 0))
# expr=(if ((primitive-ref negative?) f6358) (begin ((primitive-ref write-char) #\- f6359) ((vector-ref f6321 0) (fx* -1 f6358) f6359)) ((primitive-ref map) (closure (f6361) (f6359) (let ((f6361 f6361)) ((primitive-ref write-char) (fixnum->char (fx+ (char->fixnum #\0) f6361)) f6359))) ((primitive-ref integer->list) f6358)))
# emit-expr ((primitive-ref negative?) f6358)
# funcall
#    si   =-24
#    env  = ((f6359 . -20) (f6358 . -16) (f6359 . -12) (f6358 . -8) (f6321 . 4) (f6317 . -28) (f6318 . -24) (f6319 . -20) (f6320 . -16) (f6321 . -12) (f6322 . -8) (f6323 . -4) (f6324 . 0))
#    expr = (funcall (primitive-ref negative?) f6358)
# emit-expr (primitive-ref negative?)
    .extern mrc_negative$q
    movl mrc_negative$q,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_38564"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_38564":
   movl %eax,  -32(%esp)  # stash funcall-oper in closure slot
# emit-expr f6358
# emit-variable-ref
# env=((f6359 . -20) (f6358 . -16) (f6359 . -12) (f6358 . -8) (f6321 . 4) (f6317 . -28) (f6318 . -24) (f6319 . -20) (f6320 . -16) (f6321 . -12) (f6322 . -8) (f6323 . -4) (f6324 . 0))
# var=f6358
    movl -16(%esp), %eax  # stack load f6358
# end emit-variable-ref
    mov %eax, -36(%esp)  # arg f6358
    movl -32(%esp), %edi   # load new closure to %edi
    add $-24, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $24, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    cmp $47, %al
    je _L_38562
# emit-tail-expr
# si=-24
# env=((f6359 . -20) (f6358 . -16) (f6359 . -12) (f6358 . -8) (f6321 . 4) (f6317 . -28) (f6318 . -24) (f6319 . -20) (f6320 . -16) (f6321 . -12) (f6322 . -8) (f6323 . -4) (f6324 . 0))
# expr=(begin ((primitive-ref write-char) #\- f6359) ((vector-ref f6321 0) (fx* -1 f6358) f6359))
# tail-begin (begin ((primitive-ref write-char) #\- f6359) ((vector-ref f6321 0) (fx* -1 f6358) f6359))
#   env=((f6359 . -20) (f6358 . -16) (f6359 . -12) (f6358 . -8) (f6321 . 4) (f6317 . -28) (f6318 . -24) (f6319 . -20) (f6320 . -16) (f6321 . -12) (f6322 . -8) (f6323 . -4) (f6324 . 0))
# emit-expr ((primitive-ref write-char) #\- f6359)
# funcall
#    si   =-24
#    env  = ((f6359 . -20) (f6358 . -16) (f6359 . -12) (f6358 . -8) (f6321 . 4) (f6317 . -28) (f6318 . -24) (f6319 . -20) (f6320 . -16) (f6321 . -12) (f6322 . -8) (f6323 . -4) (f6324 . 0))
#    expr = (funcall (primitive-ref write-char) #\- f6359)
# emit-expr (primitive-ref write-char)
    .extern mrc_write$mchar
    movl mrc_write$mchar,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_38565"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_38565":
   movl %eax,  -32(%esp)  # stash funcall-oper in closure slot
# emit-expr #\-
    movl $11535, %eax     # immed #\-
    mov %eax, -36(%esp)  # arg -
# emit-expr f6359
# emit-variable-ref
# env=((f6359 . -20) (f6358 . -16) (f6359 . -12) (f6358 . -8) (f6321 . 4) (f6317 . -28) (f6318 . -24) (f6319 . -20) (f6320 . -16) (f6321 . -12) (f6322 . -8) (f6323 . -4) (f6324 . 0))
# var=f6359
    movl -20(%esp), %eax  # stack load f6359
# end emit-variable-ref
    mov %eax, -40(%esp)  # arg f6359
    movl -32(%esp), %edi   # load new closure to %edi
    add $-24, %esp   # adjust base
    movl $8,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $24, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
# emit-tail-expr
# si=-24
# env=((f6359 . -20) (f6358 . -16) (f6359 . -12) (f6358 . -8) (f6321 . 4) (f6317 . -28) (f6318 . -24) (f6319 . -20) (f6320 . -16) (f6321 . -12) (f6322 . -8) (f6323 . -4) (f6324 . 0))
# expr=(begin ((vector-ref f6321 0) (fx* -1 f6358) f6359))
# tail-begin (begin ((vector-ref f6321 0) (fx* -1 f6358) f6359))
#   env=((f6359 . -20) (f6358 . -16) (f6359 . -12) (f6358 . -8) (f6321 . 4) (f6317 . -28) (f6318 . -24) (f6319 . -20) (f6320 . -16) (f6321 . -12) (f6322 . -8) (f6323 . -4) (f6324 . 0))
# emit-tail-expr
# si=-24
# env=((f6359 . -20) (f6358 . -16) (f6359 . -12) (f6358 . -8) (f6321 . 4) (f6317 . -28) (f6318 . -24) (f6319 . -20) (f6320 . -16) (f6321 . -12) (f6322 . -8) (f6323 . -4) (f6324 . 0))
# expr=((vector-ref f6321 0) (fx* -1 f6358) f6359)
# emit-tail-funcall
#    si   =-24
#    env  = ((f6359 . -20) (f6358 . -16) (f6359 . -12) (f6358 . -8) (f6321 . 4) (f6317 . -28) (f6318 . -24) (f6319 . -20) (f6320 . -16) (f6321 . -12) (f6322 . -8) (f6323 . -4) (f6324 . 0))
#    expr = (funcall (vector-ref f6321 0) (fx* -1 f6358) f6359)
# emit-expr (vector-ref f6321 0)
# emit-expr f6321
# emit-variable-ref
# env=((f6359 . -20) (f6358 . -16) (f6359 . -12) (f6358 . -8) (f6321 . 4) (f6317 . -28) (f6318 . -24) (f6319 . -20) (f6320 . -16) (f6321 . -12) (f6322 . -8) (f6323 . -4) (f6324 . 0))
# var=f6321
    movl 2(%edi), %eax  # frame load f6321
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_38566
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_38566:
    movl %eax, -24(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_38567"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_38567:
# check bounds on vector index
    movl -24(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_38569
    cmp  $0,%eax
    jge _L_38568
_L_38569:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_38568:
    movl -24(%esp), %esi
    movl -1(%eax,%esi), %eax
   movl %eax,  -24(%esp)  # stash funcall-oper in next closure slot
# emit-expr (fx* -1 f6358)
# emit-expr f6358
# emit-variable-ref
# env=((f6359 . -20) (f6358 . -16) (f6359 . -12) (f6358 . -8) (f6321 . 4) (f6317 . -28) (f6318 . -24) (f6319 . -20) (f6320 . -16) (f6321 . -12) (f6322 . -8) (f6323 . -4) (f6324 . 0))
# var=f6358
    movl -16(%esp), %eax  # stack load f6358
# end emit-variable-ref
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_38570"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $96,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_38570:
    sar $2, %eax
    movl %eax, -28(%esp)
# emit-expr -1
    movl $-4, %eax     # immed -1
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_38571"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $96,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_38571:
    imul -28(%esp), %eax
    mov %eax, -28(%esp)    # arg (fx* -1 f6358)
# emit-expr f6359
# emit-variable-ref
# env=((f6359 . -20) (f6358 . -16) (f6359 . -12) (f6358 . -8) (f6321 . 4) (f6317 . -28) (f6318 . -24) (f6319 . -20) (f6320 . -16) (f6321 . -12) (f6322 . -8) (f6323 . -4) (f6324 . 0))
# var=f6359
    movl -20(%esp), %eax  # stack load f6359
# end emit-variable-ref
    mov %eax, -32(%esp)    # arg f6359
    movl -24(%esp), %edi   # load new closure to %edi
# emit-shift-args:  size=3   si=-24  delta=20
    mov -24(%esp), %ebx  # shift frame cell
    mov %ebx, -4(%esp)  # down to base
# emit-shift-args:  size=2   si=-28  delta=20
    mov -28(%esp), %ebx  # shift frame cell
    mov %ebx, -8(%esp)  # down to base
# emit-shift-args:  size=1   si=-32  delta=20
    mov -32(%esp), %ebx  # shift frame cell
    mov %ebx, -12(%esp)  # down to base
# emit-shift-args:  size=0   si=-36  delta=20
    movl $8,%eax   # save arg count
    jmp *-2(%edi)  # tail-funcall
     ret   # return thru stack
    jmp _L_38563
_L_38562:
# emit-tail-expr
# si=-24
# env=((f6359 . -20) (f6358 . -16) (f6359 . -12) (f6358 . -8) (f6321 . 4) (f6317 . -28) (f6318 . -24) (f6319 . -20) (f6320 . -16) (f6321 . -12) (f6322 . -8) (f6323 . -4) (f6324 . 0))
# expr=((primitive-ref map) (closure (f6361) (f6359) (let ((f6361 f6361)) ((primitive-ref write-char) (fixnum->char (fx+ (char->fixnum #\0) f6361)) f6359))) ((primitive-ref integer->list) f6358))
# emit-tail-funcall
#    si   =-24
#    env  = ((f6359 . -20) (f6358 . -16) (f6359 . -12) (f6358 . -8) (f6321 . 4) (f6317 . -28) (f6318 . -24) (f6319 . -20) (f6320 . -16) (f6321 . -12) (f6322 . -8) (f6323 . -4) (f6324 . 0))
#    expr = (funcall (primitive-ref map) (closure (f6361) (f6359) (let ((f6361 f6361)) ((primitive-ref write-char) (fixnum->char (fx+ (char->fixnum #\0) f6361)) f6359))) ((primitive-ref integer->list) f6358))
# emit-expr (primitive-ref map)
    .extern mrc_map
    movl mrc_map,%eax
   movl %eax,  -24(%esp)  # stash funcall-oper in next closure slot
# emit-expr (closure (f6361) (f6359) (let ((f6361 f6361)) ((primitive-ref write-char) (fixnum->char (fx+ (char->fixnum #\0) f6361)) f6359)))
# emit-closure
# si = -28
# env = ((f6359 . -20) (f6358 . -16) (f6359 . -12) (f6358 . -8) (f6321 . 4) (f6317 . -28) (f6318 . -24) (f6319 . -20) (f6320 . -16) (f6321 . -12) (f6322 . -8) (f6323 . -4) (f6324 . 0))
# expr = (closure (f6361) (f6359) (let ((f6361 f6361)) ((primitive-ref write-char) (fixnum->char (fx+ (char->fixnum #\0) f6361)) f6359)))
    movl $_L_38572, 0(%ebp)  # closure label
# emit-variable-ref
# env=((f6359 . -20) (f6358 . -16) (f6359 . -12) (f6358 . -8) (f6321 . 4) (f6317 . -28) (f6318 . -24) (f6319 . -20) (f6320 . -16) (f6321 . -12) (f6322 . -8) (f6323 . -4) (f6324 . 0))
# var=f6359
    movl -20(%esp), %eax  # stack load f6359
# end emit-variable-ref
   movl  %eax, 4(%ebp)  # f6359
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $8, %ebp     # bump ebp
    jmp _L_38573            # jump around closure body
_L_38572:
# check argument count
    cmp $4,%eax
    je _L_38574
# invoke error handler eh_argcount
    .extern mrc_eh$uargcount
    movl mrc_eh$uargcount, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_38574:
# emit-tail-expr
# si=-12
# env=((f6361 . -8) (f6359 . 4) (f6359 . -20) (f6358 . -16) (f6359 . -12) (f6358 . -8) (f6321 . 4) (f6317 . -28) (f6318 . -24) (f6319 . -20) (f6320 . -16) (f6321 . -12) (f6322 . -8) (f6323 . -4) (f6324 . 0))
# expr=(let ((f6361 f6361)) ((primitive-ref write-char) (fixnum->char (fx+ (char->fixnum #\0) f6361)) f6359))
# emit-tail-let
#  si   = -12
#  env  = ((f6361 . -8) (f6359 . 4) (f6359 . -20) (f6358 . -16) (f6359 . -12) (f6358 . -8) (f6321 . 4) (f6317 . -28) (f6318 . -24) (f6319 . -20) (f6320 . -16) (f6321 . -12) (f6322 . -8) (f6323 . -4) (f6324 . 0))
#  bindings = ((f6361 f6361))
#  body = ((primitive-ref write-char) (fixnum->char (fx+ (char->fixnum #\0) f6361)) f6359)
# emit-expr f6361
# emit-variable-ref
# env=((f6361 . -8) (f6359 . 4) (f6359 . -20) (f6358 . -16) (f6359 . -12) (f6358 . -8) (f6321 . 4) (f6317 . -28) (f6318 . -24) (f6319 . -20) (f6320 . -16) (f6321 . -12) (f6322 . -8) (f6323 . -4) (f6324 . 0))
# var=f6361
    movl -8(%esp), %eax  # stack load f6361
# end emit-variable-ref
    movl %eax, -12(%esp)  # stack save
# emit-tail-expr
# si=-16
# env=((f6361 . -12) (f6361 . -8) (f6359 . 4) (f6359 . -20) (f6358 . -16) (f6359 . -12) (f6358 . -8) (f6321 . 4) (f6317 . -28) (f6318 . -24) (f6319 . -20) (f6320 . -16) (f6321 . -12) (f6322 . -8) (f6323 . -4) (f6324 . 0))
# expr=((primitive-ref write-char) (fixnum->char (fx+ (char->fixnum #\0) f6361)) f6359)
# emit-tail-funcall
#    si   =-16
#    env  = ((f6361 . -12) (f6361 . -8) (f6359 . 4) (f6359 . -20) (f6358 . -16) (f6359 . -12) (f6358 . -8) (f6321 . 4) (f6317 . -28) (f6318 . -24) (f6319 . -20) (f6320 . -16) (f6321 . -12) (f6322 . -8) (f6323 . -4) (f6324 . 0))
#    expr = (funcall (primitive-ref write-char) (fixnum->char (fx+ (char->fixnum #\0) f6361)) f6359)
# emit-expr (primitive-ref write-char)
    .extern mrc_write$mchar
    movl mrc_write$mchar,%eax
   movl %eax,  -16(%esp)  # stash funcall-oper in next closure slot
# emit-expr (fixnum->char (fx+ (char->fixnum #\0) f6361))
# emit-expr (fx+ (char->fixnum #\0) f6361)
# emit-expr f6361
# emit-variable-ref
# env=((f6361 . -12) (f6361 . -8) (f6359 . 4) (f6359 . -20) (f6358 . -16) (f6359 . -12) (f6358 . -8) (f6321 . 4) (f6317 . -28) (f6318 . -24) (f6319 . -20) (f6320 . -16) (f6321 . -12) (f6322 . -8) (f6323 . -4) (f6324 . 0))
# var=f6361
    movl -12(%esp), %eax  # stack load f6361
# end emit-variable-ref
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_38575"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $88,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_38575:
    movl %eax, -20(%esp)  # fx+ push arg1
# emit-expr (char->fixnum #\0)
# emit-expr #\0
    movl $12303, %eax     # immed #\0
# check the argument is a char
    movl %eax,%ebx
    and $255, %bl
    cmp $15, %bl
    je "_L_38576"
# invoke error handler eh_character
    .extern mrc_eh$ucharacter
    movl mrc_eh$ucharacter, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $4,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_38576:
   shrl $8, %eax
   shll $2, %eax
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_38577"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $88,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_38577:
    addl -20(%esp), %eax  # fx+ arg1 arg2
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_38578"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $0,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_38578:
    shll $6, %eax
    orl $15, %eax
    mov %eax, -20(%esp)    # arg (fixnum->char (fx+ (char->fixnum 0) f6361))
# emit-expr f6359
# emit-variable-ref
# env=((f6361 . -12) (f6361 . -8) (f6359 . 4) (f6359 . -20) (f6358 . -16) (f6359 . -12) (f6358 . -8) (f6321 . 4) (f6317 . -28) (f6318 . -24) (f6319 . -20) (f6320 . -16) (f6321 . -12) (f6322 . -8) (f6323 . -4) (f6324 . 0))
# var=f6359
    movl 2(%edi), %eax  # frame load f6359
# end emit-variable-ref
    mov %eax, -24(%esp)    # arg f6359
    movl -16(%esp), %edi   # load new closure to %edi
# emit-shift-args:  size=3   si=-16  delta=12
    mov -16(%esp), %ebx  # shift frame cell
    mov %ebx, -4(%esp)  # down to base
# emit-shift-args:  size=2   si=-20  delta=12
    mov -20(%esp), %ebx  # shift frame cell
    mov %ebx, -8(%esp)  # down to base
# emit-shift-args:  size=1   si=-24  delta=12
    mov -24(%esp), %ebx  # shift frame cell
    mov %ebx, -12(%esp)  # down to base
# emit-shift-args:  size=0   si=-28  delta=12
    movl $8,%eax   # save arg count
    jmp *-2(%edi)  # tail-funcall
    .align 4,0x90
_L_38573:
    mov %eax, -28(%esp)    # arg (closure (f6361) (f6359) (let ((f6361 f6361)) ((primitive-ref write-char) (fixnum->char (fx+ (char->fixnum 0) f6361)) f6359)))
# emit-expr ((primitive-ref integer->list) f6358)
# funcall
#    si   =-32
#    env  = ((f6359 . -20) (f6358 . -16) (f6359 . -12) (f6358 . -8) (f6321 . 4) (f6317 . -28) (f6318 . -24) (f6319 . -20) (f6320 . -16) (f6321 . -12) (f6322 . -8) (f6323 . -4) (f6324 . 0))
#    expr = (funcall (primitive-ref integer->list) f6358)
# emit-expr (primitive-ref integer->list)
    .extern mrc_integer$m$glist
    movl mrc_integer$m$glist,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_38579"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_38579":
   movl %eax,  -40(%esp)  # stash funcall-oper in closure slot
# emit-expr f6358
# emit-variable-ref
# env=((f6359 . -20) (f6358 . -16) (f6359 . -12) (f6358 . -8) (f6321 . 4) (f6317 . -28) (f6318 . -24) (f6319 . -20) (f6320 . -16) (f6321 . -12) (f6322 . -8) (f6323 . -4) (f6324 . 0))
# var=f6358
    movl -16(%esp), %eax  # stack load f6358
# end emit-variable-ref
    mov %eax, -44(%esp)  # arg f6358
    movl -40(%esp), %edi   # load new closure to %edi
    add $-32, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $32, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    mov %eax, -32(%esp)    # arg ((primitive-ref integer->list) f6358)
    movl -24(%esp), %edi   # load new closure to %edi
# emit-shift-args:  size=3   si=-24  delta=20
    mov -24(%esp), %ebx  # shift frame cell
    mov %ebx, -4(%esp)  # down to base
# emit-shift-args:  size=2   si=-28  delta=20
    mov -28(%esp), %ebx  # shift frame cell
    mov %ebx, -8(%esp)  # down to base
# emit-shift-args:  size=1   si=-32  delta=20
    mov -32(%esp), %ebx  # shift frame cell
    mov %ebx, -12(%esp)  # down to base
# emit-shift-args:  size=0   si=-36  delta=20
    movl $8,%eax   # save arg count
    jmp *-2(%edi)  # tail-funcall
_L_38563:
    .align 4,0x90
_L_38560:
    movl -32(%esp), %ebx
    movl -36(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin (vector-set! f6320 0 (closure (f6354 f6355) () (let ((f6354 f6354) (f6355 f6355)) (begin ((primitive-ref write-char) #\" f6355) ((primitive-ref for-each) (closure (f6357) (f6355) (let ((f6357 f6357)) ((primitive-ref write-char) f6357 f6355))) ((primitive-ref string->list) f6354)) ((primitive-ref write-char) #\" f6355))))) (vector-set! f6319 0 (closure (f6350 f6351) () (let ((f6350 f6350) (f6351 f6351)) ((primitive-ref for-each) (closure (f6353) (f6351) (let ((f6353 f6353)) ((primitive-ref write-char) f6353 f6351))) ((primitive-ref string->list) f6350))))) (vector-set! f6318 0 (closure (f6348 f6349) (f6317) (let ((f6348 f6348) (f6349 f6349)) (begin ((primitive-ref write-char) #\( f6349) ((vector-ref f6317 0) f6348 f6349) ((primitive-ref write-char) #\) f6349))))) (vector-set! f6317 0 (closure (f6346 f6347) (f6317) (let ((f6346 f6346) (f6347 f6347)) (begin ((primitive-ref write) (car f6346) f6347) (if (null? (cdr f6346)) #t (if (pair? (cdr f6346)) (begin ((primitive-ref write-char) #\space f6347) ((vector-ref f6317 0) (cdr f6346) f6347)) (begin ((primitive-ref write-char) #\space f6347) ((primitive-ref write-char) #\. f6347) ((primitive-ref write-char) #\space f6347) ((primitive-ref write) (cdr f6346) f6347)))))))))
# emit-begin
#   expr=(begin (vector-set! f6320 0 (closure (f6354 f6355) () (let ((f6354 f6354) (f6355 f6355)) (begin ((primitive-ref write-char) #\" f6355) ((primitive-ref for-each) (closure (f6357) (f6355) (let ((f6357 f6357)) ((primitive-ref write-char) f6357 f6355))) ((primitive-ref string->list) f6354)) ((primitive-ref write-char) #\" f6355))))) (vector-set! f6319 0 (closure (f6350 f6351) () (let ((f6350 f6350) (f6351 f6351)) ((primitive-ref for-each) (closure (f6353) (f6351) (let ((f6353 f6353)) ((primitive-ref write-char) f6353 f6351))) ((primitive-ref string->list) f6350))))) (vector-set! f6318 0 (closure (f6348 f6349) (f6317) (let ((f6348 f6348) (f6349 f6349)) (begin ((primitive-ref write-char) #\( f6349) ((vector-ref f6317 0) f6348 f6349) ((primitive-ref write-char) #\) f6349))))) (vector-set! f6317 0 (closure (f6346 f6347) (f6317) (let ((f6346 f6346) (f6347 f6347)) (begin ((primitive-ref write) (car f6346) f6347) (if (null? (cdr f6346)) #t (if (pair? (cdr f6346)) (begin ((primitive-ref write-char) #\space f6347) ((vector-ref f6317 0) (cdr f6346) f6347)) (begin ((primitive-ref write-char) #\space f6347) ((primitive-ref write-char) #\. f6347) ((primitive-ref write-char) #\space f6347) ((primitive-ref write) (cdr f6346) f6347)))))))))
#   env=((f6317 . -28) (f6318 . -24) (f6319 . -20) (f6320 . -16) (f6321 . -12) (f6322 . -8) (f6323 . -4) (f6324 . 0))
# emit-expr (vector-set! f6320 0 (closure (f6354 f6355) () (let ((f6354 f6354) (f6355 f6355)) (begin ((primitive-ref write-char) #\" f6355) ((primitive-ref for-each) (closure (f6357) (f6355) (let ((f6357 f6357)) ((primitive-ref write-char) f6357 f6355))) ((primitive-ref string->list) f6354)) ((primitive-ref write-char) #\" f6355)))))
# emit-expr f6320
# emit-variable-ref
# env=((f6317 . -28) (f6318 . -24) (f6319 . -20) (f6320 . -16) (f6321 . -12) (f6322 . -8) (f6323 . -4) (f6324 . 0))
# var=f6320
    movl -16(%esp), %eax  # stack load f6320
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_38580
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_38580:
    movl %eax, -32(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_38581"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_38581:
# check bounds on vector index
    movl -32(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_38583
    cmp  $0,%eax
    jge _L_38582
_L_38583:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_38582:
    movl %eax, -36(%esp)
# emit-expr (closure (f6354 f6355) () (let ((f6354 f6354) (f6355 f6355)) (begin ((primitive-ref write-char) #\" f6355) ((primitive-ref for-each) (closure (f6357) (f6355) (let ((f6357 f6357)) ((primitive-ref write-char) f6357 f6355))) ((primitive-ref string->list) f6354)) ((primitive-ref write-char) #\" f6355))))
# emit-closure
# si = -40
# env = ((f6317 . -28) (f6318 . -24) (f6319 . -20) (f6320 . -16) (f6321 . -12) (f6322 . -8) (f6323 . -4) (f6324 . 0))
# expr = (closure (f6354 f6355) () (let ((f6354 f6354) (f6355 f6355)) (begin ((primitive-ref write-char) #\" f6355) ((primitive-ref for-each) (closure (f6357) (f6355) (let ((f6357 f6357)) ((primitive-ref write-char) f6357 f6355))) ((primitive-ref string->list) f6354)) ((primitive-ref write-char) #\" f6355))))
    movl $_L_38584, 0(%ebp)  # closure label
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $8, %ebp     # bump ebp
    jmp _L_38585            # jump around closure body
_L_38584:
# check argument count
    cmp $8,%eax
    je _L_38586
# invoke error handler eh_argcount
    .extern mrc_eh$uargcount
    movl mrc_eh$uargcount, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_38586:
# emit-tail-expr
# si=-16
# env=((f6355 . -12) (f6354 . -8) (f6317 . -28) (f6318 . -24) (f6319 . -20) (f6320 . -16) (f6321 . -12) (f6322 . -8) (f6323 . -4) (f6324 . 0))
# expr=(let ((f6354 f6354) (f6355 f6355)) (begin ((primitive-ref write-char) #\" f6355) ((primitive-ref for-each) (closure (f6357) (f6355) (let ((f6357 f6357)) ((primitive-ref write-char) f6357 f6355))) ((primitive-ref string->list) f6354)) ((primitive-ref write-char) #\" f6355)))
# emit-tail-let
#  si   = -16
#  env  = ((f6355 . -12) (f6354 . -8) (f6317 . -28) (f6318 . -24) (f6319 . -20) (f6320 . -16) (f6321 . -12) (f6322 . -8) (f6323 . -4) (f6324 . 0))
#  bindings = ((f6354 f6354) (f6355 f6355))
#  body = (begin ((primitive-ref write-char) #\" f6355) ((primitive-ref for-each) (closure (f6357) (f6355) (let ((f6357 f6357)) ((primitive-ref write-char) f6357 f6355))) ((primitive-ref string->list) f6354)) ((primitive-ref write-char) #\" f6355))
# emit-expr f6354
# emit-variable-ref
# env=((f6355 . -12) (f6354 . -8) (f6317 . -28) (f6318 . -24) (f6319 . -20) (f6320 . -16) (f6321 . -12) (f6322 . -8) (f6323 . -4) (f6324 . 0))
# var=f6354
    movl -8(%esp), %eax  # stack load f6354
# end emit-variable-ref
    movl %eax, -16(%esp)  # stack save
# emit-expr f6355
# emit-variable-ref
# env=((f6355 . -12) (f6354 . -8) (f6317 . -28) (f6318 . -24) (f6319 . -20) (f6320 . -16) (f6321 . -12) (f6322 . -8) (f6323 . -4) (f6324 . 0))
# var=f6355
    movl -12(%esp), %eax  # stack load f6355
# end emit-variable-ref
    movl %eax, -20(%esp)  # stack save
# emit-tail-expr
# si=-24
# env=((f6355 . -20) (f6354 . -16) (f6355 . -12) (f6354 . -8) (f6317 . -28) (f6318 . -24) (f6319 . -20) (f6320 . -16) (f6321 . -12) (f6322 . -8) (f6323 . -4) (f6324 . 0))
# expr=(begin ((primitive-ref write-char) #\" f6355) ((primitive-ref for-each) (closure (f6357) (f6355) (let ((f6357 f6357)) ((primitive-ref write-char) f6357 f6355))) ((primitive-ref string->list) f6354)) ((primitive-ref write-char) #\" f6355))
# tail-begin (begin ((primitive-ref write-char) #\" f6355) ((primitive-ref for-each) (closure (f6357) (f6355) (let ((f6357 f6357)) ((primitive-ref write-char) f6357 f6355))) ((primitive-ref string->list) f6354)) ((primitive-ref write-char) #\" f6355))
#   env=((f6355 . -20) (f6354 . -16) (f6355 . -12) (f6354 . -8) (f6317 . -28) (f6318 . -24) (f6319 . -20) (f6320 . -16) (f6321 . -12) (f6322 . -8) (f6323 . -4) (f6324 . 0))
# emit-expr ((primitive-ref write-char) #\" f6355)
# funcall
#    si   =-24
#    env  = ((f6355 . -20) (f6354 . -16) (f6355 . -12) (f6354 . -8) (f6317 . -28) (f6318 . -24) (f6319 . -20) (f6320 . -16) (f6321 . -12) (f6322 . -8) (f6323 . -4) (f6324 . 0))
#    expr = (funcall (primitive-ref write-char) #\" f6355)
# emit-expr (primitive-ref write-char)
    .extern mrc_write$mchar
    movl mrc_write$mchar,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_38587"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_38587":
   movl %eax,  -32(%esp)  # stash funcall-oper in closure slot
# emit-expr #\"
    movl $8719, %eax     # immed #\"
    mov %eax, -36(%esp)  # arg "
# emit-expr f6355
# emit-variable-ref
# env=((f6355 . -20) (f6354 . -16) (f6355 . -12) (f6354 . -8) (f6317 . -28) (f6318 . -24) (f6319 . -20) (f6320 . -16) (f6321 . -12) (f6322 . -8) (f6323 . -4) (f6324 . 0))
# var=f6355
    movl -20(%esp), %eax  # stack load f6355
# end emit-variable-ref
    mov %eax, -40(%esp)  # arg f6355
    movl -32(%esp), %edi   # load new closure to %edi
    add $-24, %esp   # adjust base
    movl $8,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $24, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
# emit-tail-expr
# si=-24
# env=((f6355 . -20) (f6354 . -16) (f6355 . -12) (f6354 . -8) (f6317 . -28) (f6318 . -24) (f6319 . -20) (f6320 . -16) (f6321 . -12) (f6322 . -8) (f6323 . -4) (f6324 . 0))
# expr=(begin ((primitive-ref for-each) (closure (f6357) (f6355) (let ((f6357 f6357)) ((primitive-ref write-char) f6357 f6355))) ((primitive-ref string->list) f6354)) ((primitive-ref write-char) #\" f6355))
# tail-begin (begin ((primitive-ref for-each) (closure (f6357) (f6355) (let ((f6357 f6357)) ((primitive-ref write-char) f6357 f6355))) ((primitive-ref string->list) f6354)) ((primitive-ref write-char) #\" f6355))
#   env=((f6355 . -20) (f6354 . -16) (f6355 . -12) (f6354 . -8) (f6317 . -28) (f6318 . -24) (f6319 . -20) (f6320 . -16) (f6321 . -12) (f6322 . -8) (f6323 . -4) (f6324 . 0))
# emit-expr ((primitive-ref for-each) (closure (f6357) (f6355) (let ((f6357 f6357)) ((primitive-ref write-char) f6357 f6355))) ((primitive-ref string->list) f6354))
# funcall
#    si   =-24
#    env  = ((f6355 . -20) (f6354 . -16) (f6355 . -12) (f6354 . -8) (f6317 . -28) (f6318 . -24) (f6319 . -20) (f6320 . -16) (f6321 . -12) (f6322 . -8) (f6323 . -4) (f6324 . 0))
#    expr = (funcall (primitive-ref for-each) (closure (f6357) (f6355) (let ((f6357 f6357)) ((primitive-ref write-char) f6357 f6355))) ((primitive-ref string->list) f6354))
# emit-expr (primitive-ref for-each)
    .extern mrc_for$meach
    movl mrc_for$meach,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_38588"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_38588":
   movl %eax,  -32(%esp)  # stash funcall-oper in closure slot
# emit-expr (closure (f6357) (f6355) (let ((f6357 f6357)) ((primitive-ref write-char) f6357 f6355)))
# emit-closure
# si = -36
# env = ((f6355 . -20) (f6354 . -16) (f6355 . -12) (f6354 . -8) (f6317 . -28) (f6318 . -24) (f6319 . -20) (f6320 . -16) (f6321 . -12) (f6322 . -8) (f6323 . -4) (f6324 . 0))
# expr = (closure (f6357) (f6355) (let ((f6357 f6357)) ((primitive-ref write-char) f6357 f6355)))
    movl $_L_38589, 0(%ebp)  # closure label
# emit-variable-ref
# env=((f6355 . -20) (f6354 . -16) (f6355 . -12) (f6354 . -8) (f6317 . -28) (f6318 . -24) (f6319 . -20) (f6320 . -16) (f6321 . -12) (f6322 . -8) (f6323 . -4) (f6324 . 0))
# var=f6355
    movl -20(%esp), %eax  # stack load f6355
# end emit-variable-ref
   movl  %eax, 4(%ebp)  # f6355
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $8, %ebp     # bump ebp
    jmp _L_38590            # jump around closure body
_L_38589:
# check argument count
    cmp $4,%eax
    je _L_38591
# invoke error handler eh_argcount
    .extern mrc_eh$uargcount
    movl mrc_eh$uargcount, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_38591:
# emit-tail-expr
# si=-12
# env=((f6357 . -8) (f6355 . 4) (f6355 . -20) (f6354 . -16) (f6355 . -12) (f6354 . -8) (f6317 . -28) (f6318 . -24) (f6319 . -20) (f6320 . -16) (f6321 . -12) (f6322 . -8) (f6323 . -4) (f6324 . 0))
# expr=(let ((f6357 f6357)) ((primitive-ref write-char) f6357 f6355))
# emit-tail-let
#  si   = -12
#  env  = ((f6357 . -8) (f6355 . 4) (f6355 . -20) (f6354 . -16) (f6355 . -12) (f6354 . -8) (f6317 . -28) (f6318 . -24) (f6319 . -20) (f6320 . -16) (f6321 . -12) (f6322 . -8) (f6323 . -4) (f6324 . 0))
#  bindings = ((f6357 f6357))
#  body = ((primitive-ref write-char) f6357 f6355)
# emit-expr f6357
# emit-variable-ref
# env=((f6357 . -8) (f6355 . 4) (f6355 . -20) (f6354 . -16) (f6355 . -12) (f6354 . -8) (f6317 . -28) (f6318 . -24) (f6319 . -20) (f6320 . -16) (f6321 . -12) (f6322 . -8) (f6323 . -4) (f6324 . 0))
# var=f6357
    movl -8(%esp), %eax  # stack load f6357
# end emit-variable-ref
    movl %eax, -12(%esp)  # stack save
# emit-tail-expr
# si=-16
# env=((f6357 . -12) (f6357 . -8) (f6355 . 4) (f6355 . -20) (f6354 . -16) (f6355 . -12) (f6354 . -8) (f6317 . -28) (f6318 . -24) (f6319 . -20) (f6320 . -16) (f6321 . -12) (f6322 . -8) (f6323 . -4) (f6324 . 0))
# expr=((primitive-ref write-char) f6357 f6355)
# emit-tail-funcall
#    si   =-16
#    env  = ((f6357 . -12) (f6357 . -8) (f6355 . 4) (f6355 . -20) (f6354 . -16) (f6355 . -12) (f6354 . -8) (f6317 . -28) (f6318 . -24) (f6319 . -20) (f6320 . -16) (f6321 . -12) (f6322 . -8) (f6323 . -4) (f6324 . 0))
#    expr = (funcall (primitive-ref write-char) f6357 f6355)
# emit-expr (primitive-ref write-char)
    .extern mrc_write$mchar
    movl mrc_write$mchar,%eax
   movl %eax,  -16(%esp)  # stash funcall-oper in next closure slot
# emit-expr f6357
# emit-variable-ref
# env=((f6357 . -12) (f6357 . -8) (f6355 . 4) (f6355 . -20) (f6354 . -16) (f6355 . -12) (f6354 . -8) (f6317 . -28) (f6318 . -24) (f6319 . -20) (f6320 . -16) (f6321 . -12) (f6322 . -8) (f6323 . -4) (f6324 . 0))
# var=f6357
    movl -12(%esp), %eax  # stack load f6357
# end emit-variable-ref
    mov %eax, -20(%esp)    # arg f6357
# emit-expr f6355
# emit-variable-ref
# env=((f6357 . -12) (f6357 . -8) (f6355 . 4) (f6355 . -20) (f6354 . -16) (f6355 . -12) (f6354 . -8) (f6317 . -28) (f6318 . -24) (f6319 . -20) (f6320 . -16) (f6321 . -12) (f6322 . -8) (f6323 . -4) (f6324 . 0))
# var=f6355
    movl 2(%edi), %eax  # frame load f6355
# end emit-variable-ref
    mov %eax, -24(%esp)    # arg f6355
    movl -16(%esp), %edi   # load new closure to %edi
# emit-shift-args:  size=3   si=-16  delta=12
    mov -16(%esp), %ebx  # shift frame cell
    mov %ebx, -4(%esp)  # down to base
# emit-shift-args:  size=2   si=-20  delta=12
    mov -20(%esp), %ebx  # shift frame cell
    mov %ebx, -8(%esp)  # down to base
# emit-shift-args:  size=1   si=-24  delta=12
    mov -24(%esp), %ebx  # shift frame cell
    mov %ebx, -12(%esp)  # down to base
# emit-shift-args:  size=0   si=-28  delta=12
    movl $8,%eax   # save arg count
    jmp *-2(%edi)  # tail-funcall
    .align 4,0x90
_L_38590:
    mov %eax, -36(%esp)  # arg (closure (f6357) (f6355) (let ((f6357 f6357)) ((primitive-ref write-char) f6357 f6355)))
# emit-expr ((primitive-ref string->list) f6354)
# funcall
#    si   =-40
#    env  = ((f6355 . -20) (f6354 . -16) (f6355 . -12) (f6354 . -8) (f6317 . -28) (f6318 . -24) (f6319 . -20) (f6320 . -16) (f6321 . -12) (f6322 . -8) (f6323 . -4) (f6324 . 0))
#    expr = (funcall (primitive-ref string->list) f6354)
# emit-expr (primitive-ref string->list)
    .extern mrc_string$m$glist
    movl mrc_string$m$glist,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_38592"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_38592":
   movl %eax,  -48(%esp)  # stash funcall-oper in closure slot
# emit-expr f6354
# emit-variable-ref
# env=((f6355 . -20) (f6354 . -16) (f6355 . -12) (f6354 . -8) (f6317 . -28) (f6318 . -24) (f6319 . -20) (f6320 . -16) (f6321 . -12) (f6322 . -8) (f6323 . -4) (f6324 . 0))
# var=f6354
    movl -16(%esp), %eax  # stack load f6354
# end emit-variable-ref
    mov %eax, -52(%esp)  # arg f6354
    movl -48(%esp), %edi   # load new closure to %edi
    add $-40, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $40, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    mov %eax, -40(%esp)  # arg ((primitive-ref string->list) f6354)
    movl -32(%esp), %edi   # load new closure to %edi
    add $-24, %esp   # adjust base
    movl $8,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $24, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
# emit-tail-expr
# si=-24
# env=((f6355 . -20) (f6354 . -16) (f6355 . -12) (f6354 . -8) (f6317 . -28) (f6318 . -24) (f6319 . -20) (f6320 . -16) (f6321 . -12) (f6322 . -8) (f6323 . -4) (f6324 . 0))
# expr=(begin ((primitive-ref write-char) #\" f6355))
# tail-begin (begin ((primitive-ref write-char) #\" f6355))
#   env=((f6355 . -20) (f6354 . -16) (f6355 . -12) (f6354 . -8) (f6317 . -28) (f6318 . -24) (f6319 . -20) (f6320 . -16) (f6321 . -12) (f6322 . -8) (f6323 . -4) (f6324 . 0))
# emit-tail-expr
# si=-24
# env=((f6355 . -20) (f6354 . -16) (f6355 . -12) (f6354 . -8) (f6317 . -28) (f6318 . -24) (f6319 . -20) (f6320 . -16) (f6321 . -12) (f6322 . -8) (f6323 . -4) (f6324 . 0))
# expr=((primitive-ref write-char) #\" f6355)
# emit-tail-funcall
#    si   =-24
#    env  = ((f6355 . -20) (f6354 . -16) (f6355 . -12) (f6354 . -8) (f6317 . -28) (f6318 . -24) (f6319 . -20) (f6320 . -16) (f6321 . -12) (f6322 . -8) (f6323 . -4) (f6324 . 0))
#    expr = (funcall (primitive-ref write-char) #\" f6355)
# emit-expr (primitive-ref write-char)
    .extern mrc_write$mchar
    movl mrc_write$mchar,%eax
   movl %eax,  -24(%esp)  # stash funcall-oper in next closure slot
# emit-expr #\"
    movl $8719, %eax     # immed #\"
    mov %eax, -28(%esp)    # arg "
# emit-expr f6355
# emit-variable-ref
# env=((f6355 . -20) (f6354 . -16) (f6355 . -12) (f6354 . -8) (f6317 . -28) (f6318 . -24) (f6319 . -20) (f6320 . -16) (f6321 . -12) (f6322 . -8) (f6323 . -4) (f6324 . 0))
# var=f6355
    movl -20(%esp), %eax  # stack load f6355
# end emit-variable-ref
    mov %eax, -32(%esp)    # arg f6355
    movl -24(%esp), %edi   # load new closure to %edi
# emit-shift-args:  size=3   si=-24  delta=20
    mov -24(%esp), %ebx  # shift frame cell
    mov %ebx, -4(%esp)  # down to base
# emit-shift-args:  size=2   si=-28  delta=20
    mov -28(%esp), %ebx  # shift frame cell
    mov %ebx, -8(%esp)  # down to base
# emit-shift-args:  size=1   si=-32  delta=20
    mov -32(%esp), %ebx  # shift frame cell
    mov %ebx, -12(%esp)  # down to base
# emit-shift-args:  size=0   si=-36  delta=20
    movl $8,%eax   # save arg count
    jmp *-2(%edi)  # tail-funcall
     ret   # return thru stack
    .align 4,0x90
_L_38585:
    movl -32(%esp), %ebx
    movl -36(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin (vector-set! f6319 0 (closure (f6350 f6351) () (let ((f6350 f6350) (f6351 f6351)) ((primitive-ref for-each) (closure (f6353) (f6351) (let ((f6353 f6353)) ((primitive-ref write-char) f6353 f6351))) ((primitive-ref string->list) f6350))))) (vector-set! f6318 0 (closure (f6348 f6349) (f6317) (let ((f6348 f6348) (f6349 f6349)) (begin ((primitive-ref write-char) #\( f6349) ((vector-ref f6317 0) f6348 f6349) ((primitive-ref write-char) #\) f6349))))) (vector-set! f6317 0 (closure (f6346 f6347) (f6317) (let ((f6346 f6346) (f6347 f6347)) (begin ((primitive-ref write) (car f6346) f6347) (if (null? (cdr f6346)) #t (if (pair? (cdr f6346)) (begin ((primitive-ref write-char) #\space f6347) ((vector-ref f6317 0) (cdr f6346) f6347)) (begin ((primitive-ref write-char) #\space f6347) ((primitive-ref write-char) #\. f6347) ((primitive-ref write-char) #\space f6347) ((primitive-ref write) (cdr f6346) f6347)))))))))
# emit-begin
#   expr=(begin (vector-set! f6319 0 (closure (f6350 f6351) () (let ((f6350 f6350) (f6351 f6351)) ((primitive-ref for-each) (closure (f6353) (f6351) (let ((f6353 f6353)) ((primitive-ref write-char) f6353 f6351))) ((primitive-ref string->list) f6350))))) (vector-set! f6318 0 (closure (f6348 f6349) (f6317) (let ((f6348 f6348) (f6349 f6349)) (begin ((primitive-ref write-char) #\( f6349) ((vector-ref f6317 0) f6348 f6349) ((primitive-ref write-char) #\) f6349))))) (vector-set! f6317 0 (closure (f6346 f6347) (f6317) (let ((f6346 f6346) (f6347 f6347)) (begin ((primitive-ref write) (car f6346) f6347) (if (null? (cdr f6346)) #t (if (pair? (cdr f6346)) (begin ((primitive-ref write-char) #\space f6347) ((vector-ref f6317 0) (cdr f6346) f6347)) (begin ((primitive-ref write-char) #\space f6347) ((primitive-ref write-char) #\. f6347) ((primitive-ref write-char) #\space f6347) ((primitive-ref write) (cdr f6346) f6347)))))))))
#   env=((f6317 . -28) (f6318 . -24) (f6319 . -20) (f6320 . -16) (f6321 . -12) (f6322 . -8) (f6323 . -4) (f6324 . 0))
# emit-expr (vector-set! f6319 0 (closure (f6350 f6351) () (let ((f6350 f6350) (f6351 f6351)) ((primitive-ref for-each) (closure (f6353) (f6351) (let ((f6353 f6353)) ((primitive-ref write-char) f6353 f6351))) ((primitive-ref string->list) f6350)))))
# emit-expr f6319
# emit-variable-ref
# env=((f6317 . -28) (f6318 . -24) (f6319 . -20) (f6320 . -16) (f6321 . -12) (f6322 . -8) (f6323 . -4) (f6324 . 0))
# var=f6319
    movl -20(%esp), %eax  # stack load f6319
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_38593
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_38593:
    movl %eax, -32(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_38594"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_38594:
# check bounds on vector index
    movl -32(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_38596
    cmp  $0,%eax
    jge _L_38595
_L_38596:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_38595:
    movl %eax, -36(%esp)
# emit-expr (closure (f6350 f6351) () (let ((f6350 f6350) (f6351 f6351)) ((primitive-ref for-each) (closure (f6353) (f6351) (let ((f6353 f6353)) ((primitive-ref write-char) f6353 f6351))) ((primitive-ref string->list) f6350))))
# emit-closure
# si = -40
# env = ((f6317 . -28) (f6318 . -24) (f6319 . -20) (f6320 . -16) (f6321 . -12) (f6322 . -8) (f6323 . -4) (f6324 . 0))
# expr = (closure (f6350 f6351) () (let ((f6350 f6350) (f6351 f6351)) ((primitive-ref for-each) (closure (f6353) (f6351) (let ((f6353 f6353)) ((primitive-ref write-char) f6353 f6351))) ((primitive-ref string->list) f6350))))
    movl $_L_38597, 0(%ebp)  # closure label
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $8, %ebp     # bump ebp
    jmp _L_38598            # jump around closure body
_L_38597:
# check argument count
    cmp $8,%eax
    je _L_38599
# invoke error handler eh_argcount
    .extern mrc_eh$uargcount
    movl mrc_eh$uargcount, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_38599:
# emit-tail-expr
# si=-16
# env=((f6351 . -12) (f6350 . -8) (f6317 . -28) (f6318 . -24) (f6319 . -20) (f6320 . -16) (f6321 . -12) (f6322 . -8) (f6323 . -4) (f6324 . 0))
# expr=(let ((f6350 f6350) (f6351 f6351)) ((primitive-ref for-each) (closure (f6353) (f6351) (let ((f6353 f6353)) ((primitive-ref write-char) f6353 f6351))) ((primitive-ref string->list) f6350)))
# emit-tail-let
#  si   = -16
#  env  = ((f6351 . -12) (f6350 . -8) (f6317 . -28) (f6318 . -24) (f6319 . -20) (f6320 . -16) (f6321 . -12) (f6322 . -8) (f6323 . -4) (f6324 . 0))
#  bindings = ((f6350 f6350) (f6351 f6351))
#  body = ((primitive-ref for-each) (closure (f6353) (f6351) (let ((f6353 f6353)) ((primitive-ref write-char) f6353 f6351))) ((primitive-ref string->list) f6350))
# emit-expr f6350
# emit-variable-ref
# env=((f6351 . -12) (f6350 . -8) (f6317 . -28) (f6318 . -24) (f6319 . -20) (f6320 . -16) (f6321 . -12) (f6322 . -8) (f6323 . -4) (f6324 . 0))
# var=f6350
    movl -8(%esp), %eax  # stack load f6350
# end emit-variable-ref
    movl %eax, -16(%esp)  # stack save
# emit-expr f6351
# emit-variable-ref
# env=((f6351 . -12) (f6350 . -8) (f6317 . -28) (f6318 . -24) (f6319 . -20) (f6320 . -16) (f6321 . -12) (f6322 . -8) (f6323 . -4) (f6324 . 0))
# var=f6351
    movl -12(%esp), %eax  # stack load f6351
# end emit-variable-ref
    movl %eax, -20(%esp)  # stack save
# emit-tail-expr
# si=-24
# env=((f6351 . -20) (f6350 . -16) (f6351 . -12) (f6350 . -8) (f6317 . -28) (f6318 . -24) (f6319 . -20) (f6320 . -16) (f6321 . -12) (f6322 . -8) (f6323 . -4) (f6324 . 0))
# expr=((primitive-ref for-each) (closure (f6353) (f6351) (let ((f6353 f6353)) ((primitive-ref write-char) f6353 f6351))) ((primitive-ref string->list) f6350))
# emit-tail-funcall
#    si   =-24
#    env  = ((f6351 . -20) (f6350 . -16) (f6351 . -12) (f6350 . -8) (f6317 . -28) (f6318 . -24) (f6319 . -20) (f6320 . -16) (f6321 . -12) (f6322 . -8) (f6323 . -4) (f6324 . 0))
#    expr = (funcall (primitive-ref for-each) (closure (f6353) (f6351) (let ((f6353 f6353)) ((primitive-ref write-char) f6353 f6351))) ((primitive-ref string->list) f6350))
# emit-expr (primitive-ref for-each)
    .extern mrc_for$meach
    movl mrc_for$meach,%eax
   movl %eax,  -24(%esp)  # stash funcall-oper in next closure slot
# emit-expr (closure (f6353) (f6351) (let ((f6353 f6353)) ((primitive-ref write-char) f6353 f6351)))
# emit-closure
# si = -28
# env = ((f6351 . -20) (f6350 . -16) (f6351 . -12) (f6350 . -8) (f6317 . -28) (f6318 . -24) (f6319 . -20) (f6320 . -16) (f6321 . -12) (f6322 . -8) (f6323 . -4) (f6324 . 0))
# expr = (closure (f6353) (f6351) (let ((f6353 f6353)) ((primitive-ref write-char) f6353 f6351)))
    movl $_L_38600, 0(%ebp)  # closure label
# emit-variable-ref
# env=((f6351 . -20) (f6350 . -16) (f6351 . -12) (f6350 . -8) (f6317 . -28) (f6318 . -24) (f6319 . -20) (f6320 . -16) (f6321 . -12) (f6322 . -8) (f6323 . -4) (f6324 . 0))
# var=f6351
    movl -20(%esp), %eax  # stack load f6351
# end emit-variable-ref
   movl  %eax, 4(%ebp)  # f6351
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $8, %ebp     # bump ebp
    jmp _L_38601            # jump around closure body
_L_38600:
# check argument count
    cmp $4,%eax
    je _L_38602
# invoke error handler eh_argcount
    .extern mrc_eh$uargcount
    movl mrc_eh$uargcount, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_38602:
# emit-tail-expr
# si=-12
# env=((f6353 . -8) (f6351 . 4) (f6351 . -20) (f6350 . -16) (f6351 . -12) (f6350 . -8) (f6317 . -28) (f6318 . -24) (f6319 . -20) (f6320 . -16) (f6321 . -12) (f6322 . -8) (f6323 . -4) (f6324 . 0))
# expr=(let ((f6353 f6353)) ((primitive-ref write-char) f6353 f6351))
# emit-tail-let
#  si   = -12
#  env  = ((f6353 . -8) (f6351 . 4) (f6351 . -20) (f6350 . -16) (f6351 . -12) (f6350 . -8) (f6317 . -28) (f6318 . -24) (f6319 . -20) (f6320 . -16) (f6321 . -12) (f6322 . -8) (f6323 . -4) (f6324 . 0))
#  bindings = ((f6353 f6353))
#  body = ((primitive-ref write-char) f6353 f6351)
# emit-expr f6353
# emit-variable-ref
# env=((f6353 . -8) (f6351 . 4) (f6351 . -20) (f6350 . -16) (f6351 . -12) (f6350 . -8) (f6317 . -28) (f6318 . -24) (f6319 . -20) (f6320 . -16) (f6321 . -12) (f6322 . -8) (f6323 . -4) (f6324 . 0))
# var=f6353
    movl -8(%esp), %eax  # stack load f6353
# end emit-variable-ref
    movl %eax, -12(%esp)  # stack save
# emit-tail-expr
# si=-16
# env=((f6353 . -12) (f6353 . -8) (f6351 . 4) (f6351 . -20) (f6350 . -16) (f6351 . -12) (f6350 . -8) (f6317 . -28) (f6318 . -24) (f6319 . -20) (f6320 . -16) (f6321 . -12) (f6322 . -8) (f6323 . -4) (f6324 . 0))
# expr=((primitive-ref write-char) f6353 f6351)
# emit-tail-funcall
#    si   =-16
#    env  = ((f6353 . -12) (f6353 . -8) (f6351 . 4) (f6351 . -20) (f6350 . -16) (f6351 . -12) (f6350 . -8) (f6317 . -28) (f6318 . -24) (f6319 . -20) (f6320 . -16) (f6321 . -12) (f6322 . -8) (f6323 . -4) (f6324 . 0))
#    expr = (funcall (primitive-ref write-char) f6353 f6351)
# emit-expr (primitive-ref write-char)
    .extern mrc_write$mchar
    movl mrc_write$mchar,%eax
   movl %eax,  -16(%esp)  # stash funcall-oper in next closure slot
# emit-expr f6353
# emit-variable-ref
# env=((f6353 . -12) (f6353 . -8) (f6351 . 4) (f6351 . -20) (f6350 . -16) (f6351 . -12) (f6350 . -8) (f6317 . -28) (f6318 . -24) (f6319 . -20) (f6320 . -16) (f6321 . -12) (f6322 . -8) (f6323 . -4) (f6324 . 0))
# var=f6353
    movl -12(%esp), %eax  # stack load f6353
# end emit-variable-ref
    mov %eax, -20(%esp)    # arg f6353
# emit-expr f6351
# emit-variable-ref
# env=((f6353 . -12) (f6353 . -8) (f6351 . 4) (f6351 . -20) (f6350 . -16) (f6351 . -12) (f6350 . -8) (f6317 . -28) (f6318 . -24) (f6319 . -20) (f6320 . -16) (f6321 . -12) (f6322 . -8) (f6323 . -4) (f6324 . 0))
# var=f6351
    movl 2(%edi), %eax  # frame load f6351
# end emit-variable-ref
    mov %eax, -24(%esp)    # arg f6351
    movl -16(%esp), %edi   # load new closure to %edi
# emit-shift-args:  size=3   si=-16  delta=12
    mov -16(%esp), %ebx  # shift frame cell
    mov %ebx, -4(%esp)  # down to base
# emit-shift-args:  size=2   si=-20  delta=12
    mov -20(%esp), %ebx  # shift frame cell
    mov %ebx, -8(%esp)  # down to base
# emit-shift-args:  size=1   si=-24  delta=12
    mov -24(%esp), %ebx  # shift frame cell
    mov %ebx, -12(%esp)  # down to base
# emit-shift-args:  size=0   si=-28  delta=12
    movl $8,%eax   # save arg count
    jmp *-2(%edi)  # tail-funcall
    .align 4,0x90
_L_38601:
    mov %eax, -28(%esp)    # arg (closure (f6353) (f6351) (let ((f6353 f6353)) ((primitive-ref write-char) f6353 f6351)))
# emit-expr ((primitive-ref string->list) f6350)
# funcall
#    si   =-32
#    env  = ((f6351 . -20) (f6350 . -16) (f6351 . -12) (f6350 . -8) (f6317 . -28) (f6318 . -24) (f6319 . -20) (f6320 . -16) (f6321 . -12) (f6322 . -8) (f6323 . -4) (f6324 . 0))
#    expr = (funcall (primitive-ref string->list) f6350)
# emit-expr (primitive-ref string->list)
    .extern mrc_string$m$glist
    movl mrc_string$m$glist,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_38603"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_38603":
   movl %eax,  -40(%esp)  # stash funcall-oper in closure slot
# emit-expr f6350
# emit-variable-ref
# env=((f6351 . -20) (f6350 . -16) (f6351 . -12) (f6350 . -8) (f6317 . -28) (f6318 . -24) (f6319 . -20) (f6320 . -16) (f6321 . -12) (f6322 . -8) (f6323 . -4) (f6324 . 0))
# var=f6350
    movl -16(%esp), %eax  # stack load f6350
# end emit-variable-ref
    mov %eax, -44(%esp)  # arg f6350
    movl -40(%esp), %edi   # load new closure to %edi
    add $-32, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $32, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    mov %eax, -32(%esp)    # arg ((primitive-ref string->list) f6350)
    movl -24(%esp), %edi   # load new closure to %edi
# emit-shift-args:  size=3   si=-24  delta=20
    mov -24(%esp), %ebx  # shift frame cell
    mov %ebx, -4(%esp)  # down to base
# emit-shift-args:  size=2   si=-28  delta=20
    mov -28(%esp), %ebx  # shift frame cell
    mov %ebx, -8(%esp)  # down to base
# emit-shift-args:  size=1   si=-32  delta=20
    mov -32(%esp), %ebx  # shift frame cell
    mov %ebx, -12(%esp)  # down to base
# emit-shift-args:  size=0   si=-36  delta=20
    movl $8,%eax   # save arg count
    jmp *-2(%edi)  # tail-funcall
    .align 4,0x90
_L_38598:
    movl -32(%esp), %ebx
    movl -36(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin (vector-set! f6318 0 (closure (f6348 f6349) (f6317) (let ((f6348 f6348) (f6349 f6349)) (begin ((primitive-ref write-char) #\( f6349) ((vector-ref f6317 0) f6348 f6349) ((primitive-ref write-char) #\) f6349))))) (vector-set! f6317 0 (closure (f6346 f6347) (f6317) (let ((f6346 f6346) (f6347 f6347)) (begin ((primitive-ref write) (car f6346) f6347) (if (null? (cdr f6346)) #t (if (pair? (cdr f6346)) (begin ((primitive-ref write-char) #\space f6347) ((vector-ref f6317 0) (cdr f6346) f6347)) (begin ((primitive-ref write-char) #\space f6347) ((primitive-ref write-char) #\. f6347) ((primitive-ref write-char) #\space f6347) ((primitive-ref write) (cdr f6346) f6347)))))))))
# emit-begin
#   expr=(begin (vector-set! f6318 0 (closure (f6348 f6349) (f6317) (let ((f6348 f6348) (f6349 f6349)) (begin ((primitive-ref write-char) #\( f6349) ((vector-ref f6317 0) f6348 f6349) ((primitive-ref write-char) #\) f6349))))) (vector-set! f6317 0 (closure (f6346 f6347) (f6317) (let ((f6346 f6346) (f6347 f6347)) (begin ((primitive-ref write) (car f6346) f6347) (if (null? (cdr f6346)) #t (if (pair? (cdr f6346)) (begin ((primitive-ref write-char) #\space f6347) ((vector-ref f6317 0) (cdr f6346) f6347)) (begin ((primitive-ref write-char) #\space f6347) ((primitive-ref write-char) #\. f6347) ((primitive-ref write-char) #\space f6347) ((primitive-ref write) (cdr f6346) f6347)))))))))
#   env=((f6317 . -28) (f6318 . -24) (f6319 . -20) (f6320 . -16) (f6321 . -12) (f6322 . -8) (f6323 . -4) (f6324 . 0))
# emit-expr (vector-set! f6318 0 (closure (f6348 f6349) (f6317) (let ((f6348 f6348) (f6349 f6349)) (begin ((primitive-ref write-char) #\( f6349) ((vector-ref f6317 0) f6348 f6349) ((primitive-ref write-char) #\) f6349)))))
# emit-expr f6318
# emit-variable-ref
# env=((f6317 . -28) (f6318 . -24) (f6319 . -20) (f6320 . -16) (f6321 . -12) (f6322 . -8) (f6323 . -4) (f6324 . 0))
# var=f6318
    movl -24(%esp), %eax  # stack load f6318
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_38604
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_38604:
    movl %eax, -32(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_38605"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_38605:
# check bounds on vector index
    movl -32(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_38607
    cmp  $0,%eax
    jge _L_38606
_L_38607:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_38606:
    movl %eax, -36(%esp)
# emit-expr (closure (f6348 f6349) (f6317) (let ((f6348 f6348) (f6349 f6349)) (begin ((primitive-ref write-char) #\( f6349) ((vector-ref f6317 0) f6348 f6349) ((primitive-ref write-char) #\) f6349))))
# emit-closure
# si = -40
# env = ((f6317 . -28) (f6318 . -24) (f6319 . -20) (f6320 . -16) (f6321 . -12) (f6322 . -8) (f6323 . -4) (f6324 . 0))
# expr = (closure (f6348 f6349) (f6317) (let ((f6348 f6348) (f6349 f6349)) (begin ((primitive-ref write-char) #\( f6349) ((vector-ref f6317 0) f6348 f6349) ((primitive-ref write-char) #\) f6349))))
    movl $_L_38608, 0(%ebp)  # closure label
# emit-variable-ref
# env=((f6317 . -28) (f6318 . -24) (f6319 . -20) (f6320 . -16) (f6321 . -12) (f6322 . -8) (f6323 . -4) (f6324 . 0))
# var=f6317
    movl -28(%esp), %eax  # stack load f6317
# end emit-variable-ref
   movl  %eax, 4(%ebp)  # f6317
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $8, %ebp     # bump ebp
    jmp _L_38609            # jump around closure body
_L_38608:
# check argument count
    cmp $8,%eax
    je _L_38610
# invoke error handler eh_argcount
    .extern mrc_eh$uargcount
    movl mrc_eh$uargcount, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_38610:
# emit-tail-expr
# si=-16
# env=((f6349 . -12) (f6348 . -8) (f6317 . 4) (f6317 . -28) (f6318 . -24) (f6319 . -20) (f6320 . -16) (f6321 . -12) (f6322 . -8) (f6323 . -4) (f6324 . 0))
# expr=(let ((f6348 f6348) (f6349 f6349)) (begin ((primitive-ref write-char) #\( f6349) ((vector-ref f6317 0) f6348 f6349) ((primitive-ref write-char) #\) f6349)))
# emit-tail-let
#  si   = -16
#  env  = ((f6349 . -12) (f6348 . -8) (f6317 . 4) (f6317 . -28) (f6318 . -24) (f6319 . -20) (f6320 . -16) (f6321 . -12) (f6322 . -8) (f6323 . -4) (f6324 . 0))
#  bindings = ((f6348 f6348) (f6349 f6349))
#  body = (begin ((primitive-ref write-char) #\( f6349) ((vector-ref f6317 0) f6348 f6349) ((primitive-ref write-char) #\) f6349))
# emit-expr f6348
# emit-variable-ref
# env=((f6349 . -12) (f6348 . -8) (f6317 . 4) (f6317 . -28) (f6318 . -24) (f6319 . -20) (f6320 . -16) (f6321 . -12) (f6322 . -8) (f6323 . -4) (f6324 . 0))
# var=f6348
    movl -8(%esp), %eax  # stack load f6348
# end emit-variable-ref
    movl %eax, -16(%esp)  # stack save
# emit-expr f6349
# emit-variable-ref
# env=((f6349 . -12) (f6348 . -8) (f6317 . 4) (f6317 . -28) (f6318 . -24) (f6319 . -20) (f6320 . -16) (f6321 . -12) (f6322 . -8) (f6323 . -4) (f6324 . 0))
# var=f6349
    movl -12(%esp), %eax  # stack load f6349
# end emit-variable-ref
    movl %eax, -20(%esp)  # stack save
# emit-tail-expr
# si=-24
# env=((f6349 . -20) (f6348 . -16) (f6349 . -12) (f6348 . -8) (f6317 . 4) (f6317 . -28) (f6318 . -24) (f6319 . -20) (f6320 . -16) (f6321 . -12) (f6322 . -8) (f6323 . -4) (f6324 . 0))
# expr=(begin ((primitive-ref write-char) #\( f6349) ((vector-ref f6317 0) f6348 f6349) ((primitive-ref write-char) #\) f6349))
# tail-begin (begin ((primitive-ref write-char) #\( f6349) ((vector-ref f6317 0) f6348 f6349) ((primitive-ref write-char) #\) f6349))
#   env=((f6349 . -20) (f6348 . -16) (f6349 . -12) (f6348 . -8) (f6317 . 4) (f6317 . -28) (f6318 . -24) (f6319 . -20) (f6320 . -16) (f6321 . -12) (f6322 . -8) (f6323 . -4) (f6324 . 0))
# emit-expr ((primitive-ref write-char) #\( f6349)
# funcall
#    si   =-24
#    env  = ((f6349 . -20) (f6348 . -16) (f6349 . -12) (f6348 . -8) (f6317 . 4) (f6317 . -28) (f6318 . -24) (f6319 . -20) (f6320 . -16) (f6321 . -12) (f6322 . -8) (f6323 . -4) (f6324 . 0))
#    expr = (funcall (primitive-ref write-char) #\( f6349)
# emit-expr (primitive-ref write-char)
    .extern mrc_write$mchar
    movl mrc_write$mchar,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_38611"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_38611":
   movl %eax,  -32(%esp)  # stash funcall-oper in closure slot
# emit-expr #\(
    movl $10255, %eax     # immed #\(
    mov %eax, -36(%esp)  # arg (
# emit-expr f6349
# emit-variable-ref
# env=((f6349 . -20) (f6348 . -16) (f6349 . -12) (f6348 . -8) (f6317 . 4) (f6317 . -28) (f6318 . -24) (f6319 . -20) (f6320 . -16) (f6321 . -12) (f6322 . -8) (f6323 . -4) (f6324 . 0))
# var=f6349
    movl -20(%esp), %eax  # stack load f6349
# end emit-variable-ref
    mov %eax, -40(%esp)  # arg f6349
    movl -32(%esp), %edi   # load new closure to %edi
    add $-24, %esp   # adjust base
    movl $8,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $24, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
# emit-tail-expr
# si=-24
# env=((f6349 . -20) (f6348 . -16) (f6349 . -12) (f6348 . -8) (f6317 . 4) (f6317 . -28) (f6318 . -24) (f6319 . -20) (f6320 . -16) (f6321 . -12) (f6322 . -8) (f6323 . -4) (f6324 . 0))
# expr=(begin ((vector-ref f6317 0) f6348 f6349) ((primitive-ref write-char) #\) f6349))
# tail-begin (begin ((vector-ref f6317 0) f6348 f6349) ((primitive-ref write-char) #\) f6349))
#   env=((f6349 . -20) (f6348 . -16) (f6349 . -12) (f6348 . -8) (f6317 . 4) (f6317 . -28) (f6318 . -24) (f6319 . -20) (f6320 . -16) (f6321 . -12) (f6322 . -8) (f6323 . -4) (f6324 . 0))
# emit-expr ((vector-ref f6317 0) f6348 f6349)
# funcall
#    si   =-24
#    env  = ((f6349 . -20) (f6348 . -16) (f6349 . -12) (f6348 . -8) (f6317 . 4) (f6317 . -28) (f6318 . -24) (f6319 . -20) (f6320 . -16) (f6321 . -12) (f6322 . -8) (f6323 . -4) (f6324 . 0))
#    expr = (funcall (vector-ref f6317 0) f6348 f6349)
# emit-expr (vector-ref f6317 0)
# emit-expr f6317
# emit-variable-ref
# env=((f6349 . -20) (f6348 . -16) (f6349 . -12) (f6348 . -8) (f6317 . 4) (f6317 . -28) (f6318 . -24) (f6319 . -20) (f6320 . -16) (f6321 . -12) (f6322 . -8) (f6323 . -4) (f6324 . 0))
# var=f6317
    movl 2(%edi), %eax  # frame load f6317
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_38612
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_38612:
    movl %eax, -32(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_38613"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_38613:
# check bounds on vector index
    movl -32(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_38615
    cmp  $0,%eax
    jge _L_38614
_L_38615:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_38614:
    movl -32(%esp), %esi
    movl -1(%eax,%esi), %eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_38616"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_38616":
   movl %eax,  -32(%esp)  # stash funcall-oper in closure slot
# emit-expr f6348
# emit-variable-ref
# env=((f6349 . -20) (f6348 . -16) (f6349 . -12) (f6348 . -8) (f6317 . 4) (f6317 . -28) (f6318 . -24) (f6319 . -20) (f6320 . -16) (f6321 . -12) (f6322 . -8) (f6323 . -4) (f6324 . 0))
# var=f6348
    movl -16(%esp), %eax  # stack load f6348
# end emit-variable-ref
    mov %eax, -36(%esp)  # arg f6348
# emit-expr f6349
# emit-variable-ref
# env=((f6349 . -20) (f6348 . -16) (f6349 . -12) (f6348 . -8) (f6317 . 4) (f6317 . -28) (f6318 . -24) (f6319 . -20) (f6320 . -16) (f6321 . -12) (f6322 . -8) (f6323 . -4) (f6324 . 0))
# var=f6349
    movl -20(%esp), %eax  # stack load f6349
# end emit-variable-ref
    mov %eax, -40(%esp)  # arg f6349
    movl -32(%esp), %edi   # load new closure to %edi
    add $-24, %esp   # adjust base
    movl $8,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $24, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
# emit-tail-expr
# si=-24
# env=((f6349 . -20) (f6348 . -16) (f6349 . -12) (f6348 . -8) (f6317 . 4) (f6317 . -28) (f6318 . -24) (f6319 . -20) (f6320 . -16) (f6321 . -12) (f6322 . -8) (f6323 . -4) (f6324 . 0))
# expr=(begin ((primitive-ref write-char) #\) f6349))
# tail-begin (begin ((primitive-ref write-char) #\) f6349))
#   env=((f6349 . -20) (f6348 . -16) (f6349 . -12) (f6348 . -8) (f6317 . 4) (f6317 . -28) (f6318 . -24) (f6319 . -20) (f6320 . -16) (f6321 . -12) (f6322 . -8) (f6323 . -4) (f6324 . 0))
# emit-tail-expr
# si=-24
# env=((f6349 . -20) (f6348 . -16) (f6349 . -12) (f6348 . -8) (f6317 . 4) (f6317 . -28) (f6318 . -24) (f6319 . -20) (f6320 . -16) (f6321 . -12) (f6322 . -8) (f6323 . -4) (f6324 . 0))
# expr=((primitive-ref write-char) #\) f6349)
# emit-tail-funcall
#    si   =-24
#    env  = ((f6349 . -20) (f6348 . -16) (f6349 . -12) (f6348 . -8) (f6317 . 4) (f6317 . -28) (f6318 . -24) (f6319 . -20) (f6320 . -16) (f6321 . -12) (f6322 . -8) (f6323 . -4) (f6324 . 0))
#    expr = (funcall (primitive-ref write-char) #\) f6349)
# emit-expr (primitive-ref write-char)
    .extern mrc_write$mchar
    movl mrc_write$mchar,%eax
   movl %eax,  -24(%esp)  # stash funcall-oper in next closure slot
# emit-expr #\)
    movl $10511, %eax     # immed #\)
    mov %eax, -28(%esp)    # arg )
# emit-expr f6349
# emit-variable-ref
# env=((f6349 . -20) (f6348 . -16) (f6349 . -12) (f6348 . -8) (f6317 . 4) (f6317 . -28) (f6318 . -24) (f6319 . -20) (f6320 . -16) (f6321 . -12) (f6322 . -8) (f6323 . -4) (f6324 . 0))
# var=f6349
    movl -20(%esp), %eax  # stack load f6349
# end emit-variable-ref
    mov %eax, -32(%esp)    # arg f6349
    movl -24(%esp), %edi   # load new closure to %edi
# emit-shift-args:  size=3   si=-24  delta=20
    mov -24(%esp), %ebx  # shift frame cell
    mov %ebx, -4(%esp)  # down to base
# emit-shift-args:  size=2   si=-28  delta=20
    mov -28(%esp), %ebx  # shift frame cell
    mov %ebx, -8(%esp)  # down to base
# emit-shift-args:  size=1   si=-32  delta=20
    mov -32(%esp), %ebx  # shift frame cell
    mov %ebx, -12(%esp)  # down to base
# emit-shift-args:  size=0   si=-36  delta=20
    movl $8,%eax   # save arg count
    jmp *-2(%edi)  # tail-funcall
     ret   # return thru stack
    .align 4,0x90
_L_38609:
    movl -32(%esp), %ebx
    movl -36(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin (vector-set! f6317 0 (closure (f6346 f6347) (f6317) (let ((f6346 f6346) (f6347 f6347)) (begin ((primitive-ref write) (car f6346) f6347) (if (null? (cdr f6346)) #t (if (pair? (cdr f6346)) (begin ((primitive-ref write-char) #\space f6347) ((vector-ref f6317 0) (cdr f6346) f6347)) (begin ((primitive-ref write-char) #\space f6347) ((primitive-ref write-char) #\. f6347) ((primitive-ref write-char) #\space f6347) ((primitive-ref write) (cdr f6346) f6347)))))))))
# emit-begin
#   expr=(begin (vector-set! f6317 0 (closure (f6346 f6347) (f6317) (let ((f6346 f6346) (f6347 f6347)) (begin ((primitive-ref write) (car f6346) f6347) (if (null? (cdr f6346)) #t (if (pair? (cdr f6346)) (begin ((primitive-ref write-char) #\space f6347) ((vector-ref f6317 0) (cdr f6346) f6347)) (begin ((primitive-ref write-char) #\space f6347) ((primitive-ref write-char) #\. f6347) ((primitive-ref write-char) #\space f6347) ((primitive-ref write) (cdr f6346) f6347)))))))))
#   env=((f6317 . -28) (f6318 . -24) (f6319 . -20) (f6320 . -16) (f6321 . -12) (f6322 . -8) (f6323 . -4) (f6324 . 0))
# emit-expr (vector-set! f6317 0 (closure (f6346 f6347) (f6317) (let ((f6346 f6346) (f6347 f6347)) (begin ((primitive-ref write) (car f6346) f6347) (if (null? (cdr f6346)) #t (if (pair? (cdr f6346)) (begin ((primitive-ref write-char) #\space f6347) ((vector-ref f6317 0) (cdr f6346) f6347)) (begin ((primitive-ref write-char) #\space f6347) ((primitive-ref write-char) #\. f6347) ((primitive-ref write-char) #\space f6347) ((primitive-ref write) (cdr f6346) f6347))))))))
# emit-expr f6317
# emit-variable-ref
# env=((f6317 . -28) (f6318 . -24) (f6319 . -20) (f6320 . -16) (f6321 . -12) (f6322 . -8) (f6323 . -4) (f6324 . 0))
# var=f6317
    movl -28(%esp), %eax  # stack load f6317
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_38617
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_38617:
    movl %eax, -32(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_38618"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_38618:
# check bounds on vector index
    movl -32(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_38620
    cmp  $0,%eax
    jge _L_38619
_L_38620:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_38619:
    movl %eax, -36(%esp)
# emit-expr (closure (f6346 f6347) (f6317) (let ((f6346 f6346) (f6347 f6347)) (begin ((primitive-ref write) (car f6346) f6347) (if (null? (cdr f6346)) #t (if (pair? (cdr f6346)) (begin ((primitive-ref write-char) #\space f6347) ((vector-ref f6317 0) (cdr f6346) f6347)) (begin ((primitive-ref write-char) #\space f6347) ((primitive-ref write-char) #\. f6347) ((primitive-ref write-char) #\space f6347) ((primitive-ref write) (cdr f6346) f6347)))))))
# emit-closure
# si = -40
# env = ((f6317 . -28) (f6318 . -24) (f6319 . -20) (f6320 . -16) (f6321 . -12) (f6322 . -8) (f6323 . -4) (f6324 . 0))
# expr = (closure (f6346 f6347) (f6317) (let ((f6346 f6346) (f6347 f6347)) (begin ((primitive-ref write) (car f6346) f6347) (if (null? (cdr f6346)) #t (if (pair? (cdr f6346)) (begin ((primitive-ref write-char) #\space f6347) ((vector-ref f6317 0) (cdr f6346) f6347)) (begin ((primitive-ref write-char) #\space f6347) ((primitive-ref write-char) #\. f6347) ((primitive-ref write-char) #\space f6347) ((primitive-ref write) (cdr f6346) f6347)))))))
    movl $_L_38621, 0(%ebp)  # closure label
# emit-variable-ref
# env=((f6317 . -28) (f6318 . -24) (f6319 . -20) (f6320 . -16) (f6321 . -12) (f6322 . -8) (f6323 . -4) (f6324 . 0))
# var=f6317
    movl -28(%esp), %eax  # stack load f6317
# end emit-variable-ref
   movl  %eax, 4(%ebp)  # f6317
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $8, %ebp     # bump ebp
    jmp _L_38622            # jump around closure body
_L_38621:
# check argument count
    cmp $8,%eax
    je _L_38623
# invoke error handler eh_argcount
    .extern mrc_eh$uargcount
    movl mrc_eh$uargcount, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_38623:
# emit-tail-expr
# si=-16
# env=((f6347 . -12) (f6346 . -8) (f6317 . 4) (f6317 . -28) (f6318 . -24) (f6319 . -20) (f6320 . -16) (f6321 . -12) (f6322 . -8) (f6323 . -4) (f6324 . 0))
# expr=(let ((f6346 f6346) (f6347 f6347)) (begin ((primitive-ref write) (car f6346) f6347) (if (null? (cdr f6346)) #t (if (pair? (cdr f6346)) (begin ((primitive-ref write-char) #\space f6347) ((vector-ref f6317 0) (cdr f6346) f6347)) (begin ((primitive-ref write-char) #\space f6347) ((primitive-ref write-char) #\. f6347) ((primitive-ref write-char) #\space f6347) ((primitive-ref write) (cdr f6346) f6347))))))
# emit-tail-let
#  si   = -16
#  env  = ((f6347 . -12) (f6346 . -8) (f6317 . 4) (f6317 . -28) (f6318 . -24) (f6319 . -20) (f6320 . -16) (f6321 . -12) (f6322 . -8) (f6323 . -4) (f6324 . 0))
#  bindings = ((f6346 f6346) (f6347 f6347))
#  body = (begin ((primitive-ref write) (car f6346) f6347) (if (null? (cdr f6346)) #t (if (pair? (cdr f6346)) (begin ((primitive-ref write-char) #\space f6347) ((vector-ref f6317 0) (cdr f6346) f6347)) (begin ((primitive-ref write-char) #\space f6347) ((primitive-ref write-char) #\. f6347) ((primitive-ref write-char) #\space f6347) ((primitive-ref write) (cdr f6346) f6347)))))
# emit-expr f6346
# emit-variable-ref
# env=((f6347 . -12) (f6346 . -8) (f6317 . 4) (f6317 . -28) (f6318 . -24) (f6319 . -20) (f6320 . -16) (f6321 . -12) (f6322 . -8) (f6323 . -4) (f6324 . 0))
# var=f6346
    movl -8(%esp), %eax  # stack load f6346
# end emit-variable-ref
    movl %eax, -16(%esp)  # stack save
# emit-expr f6347
# emit-variable-ref
# env=((f6347 . -12) (f6346 . -8) (f6317 . 4) (f6317 . -28) (f6318 . -24) (f6319 . -20) (f6320 . -16) (f6321 . -12) (f6322 . -8) (f6323 . -4) (f6324 . 0))
# var=f6347
    movl -12(%esp), %eax  # stack load f6347
# end emit-variable-ref
    movl %eax, -20(%esp)  # stack save
# emit-tail-expr
# si=-24
# env=((f6347 . -20) (f6346 . -16) (f6347 . -12) (f6346 . -8) (f6317 . 4) (f6317 . -28) (f6318 . -24) (f6319 . -20) (f6320 . -16) (f6321 . -12) (f6322 . -8) (f6323 . -4) (f6324 . 0))
# expr=(begin ((primitive-ref write) (car f6346) f6347) (if (null? (cdr f6346)) #t (if (pair? (cdr f6346)) (begin ((primitive-ref write-char) #\space f6347) ((vector-ref f6317 0) (cdr f6346) f6347)) (begin ((primitive-ref write-char) #\space f6347) ((primitive-ref write-char) #\. f6347) ((primitive-ref write-char) #\space f6347) ((primitive-ref write) (cdr f6346) f6347)))))
# tail-begin (begin ((primitive-ref write) (car f6346) f6347) (if (null? (cdr f6346)) #t (if (pair? (cdr f6346)) (begin ((primitive-ref write-char) #\space f6347) ((vector-ref f6317 0) (cdr f6346) f6347)) (begin ((primitive-ref write-char) #\space f6347) ((primitive-ref write-char) #\. f6347) ((primitive-ref write-char) #\space f6347) ((primitive-ref write) (cdr f6346) f6347)))))
#   env=((f6347 . -20) (f6346 . -16) (f6347 . -12) (f6346 . -8) (f6317 . 4) (f6317 . -28) (f6318 . -24) (f6319 . -20) (f6320 . -16) (f6321 . -12) (f6322 . -8) (f6323 . -4) (f6324 . 0))
# emit-expr ((primitive-ref write) (car f6346) f6347)
# funcall
#    si   =-24
#    env  = ((f6347 . -20) (f6346 . -16) (f6347 . -12) (f6346 . -8) (f6317 . 4) (f6317 . -28) (f6318 . -24) (f6319 . -20) (f6320 . -16) (f6321 . -12) (f6322 . -8) (f6323 . -4) (f6324 . 0))
#    expr = (funcall (primitive-ref write) (car f6346) f6347)
# emit-expr (primitive-ref write)
    .extern mrc_write
    movl mrc_write,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_38624"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_38624":
   movl %eax,  -32(%esp)  # stash funcall-oper in closure slot
# emit-expr (car f6346)
# emit-expr f6346
# emit-variable-ref
# env=((f6347 . -20) (f6346 . -16) (f6347 . -12) (f6346 . -8) (f6317 . 4) (f6317 . -28) (f6318 . -24) (f6319 . -20) (f6320 . -16) (f6321 . -12) (f6322 . -8) (f6323 . -4) (f6324 . 0))
# var=f6346
    movl -16(%esp), %eax  # stack load f6346
# end emit-variable-ref
# check the argument is a pair
    movl %eax,%ebx
    and $7, %bl
    cmp $1, %bl
    je _L_38625
# invoke error handler eh_pair
    .extern mrc_eh$upair
    movl mrc_eh$upair, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $116,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_38625:
    movl -1(%eax), %eax
    mov %eax, -36(%esp)  # arg (car f6346)
# emit-expr f6347
# emit-variable-ref
# env=((f6347 . -20) (f6346 . -16) (f6347 . -12) (f6346 . -8) (f6317 . 4) (f6317 . -28) (f6318 . -24) (f6319 . -20) (f6320 . -16) (f6321 . -12) (f6322 . -8) (f6323 . -4) (f6324 . 0))
# var=f6347
    movl -20(%esp), %eax  # stack load f6347
# end emit-variable-ref
    mov %eax, -40(%esp)  # arg f6347
    movl -32(%esp), %edi   # load new closure to %edi
    add $-24, %esp   # adjust base
    movl $8,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $24, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
# emit-tail-expr
# si=-24
# env=((f6347 . -20) (f6346 . -16) (f6347 . -12) (f6346 . -8) (f6317 . 4) (f6317 . -28) (f6318 . -24) (f6319 . -20) (f6320 . -16) (f6321 . -12) (f6322 . -8) (f6323 . -4) (f6324 . 0))
# expr=(begin (if (null? (cdr f6346)) #t (if (pair? (cdr f6346)) (begin ((primitive-ref write-char) #\space f6347) ((vector-ref f6317 0) (cdr f6346) f6347)) (begin ((primitive-ref write-char) #\space f6347) ((primitive-ref write-char) #\. f6347) ((primitive-ref write-char) #\space f6347) ((primitive-ref write) (cdr f6346) f6347)))))
# tail-begin (begin (if (null? (cdr f6346)) #t (if (pair? (cdr f6346)) (begin ((primitive-ref write-char) #\space f6347) ((vector-ref f6317 0) (cdr f6346) f6347)) (begin ((primitive-ref write-char) #\space f6347) ((primitive-ref write-char) #\. f6347) ((primitive-ref write-char) #\space f6347) ((primitive-ref write) (cdr f6346) f6347)))))
#   env=((f6347 . -20) (f6346 . -16) (f6347 . -12) (f6346 . -8) (f6317 . 4) (f6317 . -28) (f6318 . -24) (f6319 . -20) (f6320 . -16) (f6321 . -12) (f6322 . -8) (f6323 . -4) (f6324 . 0))
# emit-tail-expr
# si=-24
# env=((f6347 . -20) (f6346 . -16) (f6347 . -12) (f6346 . -8) (f6317 . 4) (f6317 . -28) (f6318 . -24) (f6319 . -20) (f6320 . -16) (f6321 . -12) (f6322 . -8) (f6323 . -4) (f6324 . 0))
# expr=(if (null? (cdr f6346)) #t (if (pair? (cdr f6346)) (begin ((primitive-ref write-char) #\space f6347) ((vector-ref f6317 0) (cdr f6346) f6347)) (begin ((primitive-ref write-char) #\space f6347) ((primitive-ref write-char) #\. f6347) ((primitive-ref write-char) #\space f6347) ((primitive-ref write) (cdr f6346) f6347))))
# emit-expr (null? (cdr f6346))
# emit-expr (cdr f6346)
# emit-expr f6346
# emit-variable-ref
# env=((f6347 . -20) (f6346 . -16) (f6347 . -12) (f6346 . -8) (f6317 . 4) (f6317 . -28) (f6318 . -24) (f6319 . -20) (f6320 . -16) (f6321 . -12) (f6322 . -8) (f6323 . -4) (f6324 . 0))
# var=f6346
    movl -16(%esp), %eax  # stack load f6346
# end emit-variable-ref
# check the argument is a pair
    movl %eax,%ebx
    and $7, %bl
    cmp $1, %bl
    je _L_38628
# invoke error handler eh_pair
    .extern mrc_eh$upair
    movl mrc_eh$upair, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $120,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_38628:
    movl 3(%eax), %eax
    cmp $63, %eax
    mov $0, %eax
    sete %al
    movzbl %al, %eax
    sal $6, %al
    or $47, %al
    cmp $47, %al
    je _L_38626
# emit-tail-expr
# si=-24
# env=((f6347 . -20) (f6346 . -16) (f6347 . -12) (f6346 . -8) (f6317 . 4) (f6317 . -28) (f6318 . -24) (f6319 . -20) (f6320 . -16) (f6321 . -12) (f6322 . -8) (f6323 . -4) (f6324 . 0))
# expr=#t
    movl $111, %eax     # immed #t
    ret                  # immediate tail return
    jmp _L_38627
_L_38626:
# emit-tail-expr
# si=-24
# env=((f6347 . -20) (f6346 . -16) (f6347 . -12) (f6346 . -8) (f6317 . 4) (f6317 . -28) (f6318 . -24) (f6319 . -20) (f6320 . -16) (f6321 . -12) (f6322 . -8) (f6323 . -4) (f6324 . 0))
# expr=(if (pair? (cdr f6346)) (begin ((primitive-ref write-char) #\space f6347) ((vector-ref f6317 0) (cdr f6346) f6347)) (begin ((primitive-ref write-char) #\space f6347) ((primitive-ref write-char) #\. f6347) ((primitive-ref write-char) #\space f6347) ((primitive-ref write) (cdr f6346) f6347)))
# emit-expr (pair? (cdr f6346))
# emit-expr (cdr f6346)
# emit-expr f6346
# emit-variable-ref
# env=((f6347 . -20) (f6346 . -16) (f6347 . -12) (f6346 . -8) (f6317 . 4) (f6317 . -28) (f6318 . -24) (f6319 . -20) (f6320 . -16) (f6321 . -12) (f6322 . -8) (f6323 . -4) (f6324 . 0))
# var=f6346
    movl -16(%esp), %eax  # stack load f6346
# end emit-variable-ref
# check the argument is a pair
    movl %eax,%ebx
    and $7, %bl
    cmp $1, %bl
    je _L_38631
# invoke error handler eh_pair
    .extern mrc_eh$upair
    movl mrc_eh$upair, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $120,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_38631:
    movl 3(%eax), %eax
    and $7, %al
    cmp $1, %al
    sete %al
    movzbl %al, %eax
    sal $6, %al
    or $47, %al
    cmp $47, %al
    je _L_38629
# emit-tail-expr
# si=-24
# env=((f6347 . -20) (f6346 . -16) (f6347 . -12) (f6346 . -8) (f6317 . 4) (f6317 . -28) (f6318 . -24) (f6319 . -20) (f6320 . -16) (f6321 . -12) (f6322 . -8) (f6323 . -4) (f6324 . 0))
# expr=(begin ((primitive-ref write-char) #\space f6347) ((vector-ref f6317 0) (cdr f6346) f6347))
# tail-begin (begin ((primitive-ref write-char) #\space f6347) ((vector-ref f6317 0) (cdr f6346) f6347))
#   env=((f6347 . -20) (f6346 . -16) (f6347 . -12) (f6346 . -8) (f6317 . 4) (f6317 . -28) (f6318 . -24) (f6319 . -20) (f6320 . -16) (f6321 . -12) (f6322 . -8) (f6323 . -4) (f6324 . 0))
# emit-expr ((primitive-ref write-char) #\space f6347)
# funcall
#    si   =-24
#    env  = ((f6347 . -20) (f6346 . -16) (f6347 . -12) (f6346 . -8) (f6317 . 4) (f6317 . -28) (f6318 . -24) (f6319 . -20) (f6320 . -16) (f6321 . -12) (f6322 . -8) (f6323 . -4) (f6324 . 0))
#    expr = (funcall (primitive-ref write-char) #\space f6347)
# emit-expr (primitive-ref write-char)
    .extern mrc_write$mchar
    movl mrc_write$mchar,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_38632"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_38632":
   movl %eax,  -32(%esp)  # stash funcall-oper in closure slot
# emit-expr #\space
    movl $8207, %eax     # immed #\space
    mov %eax, -36(%esp)  # arg  
# emit-expr f6347
# emit-variable-ref
# env=((f6347 . -20) (f6346 . -16) (f6347 . -12) (f6346 . -8) (f6317 . 4) (f6317 . -28) (f6318 . -24) (f6319 . -20) (f6320 . -16) (f6321 . -12) (f6322 . -8) (f6323 . -4) (f6324 . 0))
# var=f6347
    movl -20(%esp), %eax  # stack load f6347
# end emit-variable-ref
    mov %eax, -40(%esp)  # arg f6347
    movl -32(%esp), %edi   # load new closure to %edi
    add $-24, %esp   # adjust base
    movl $8,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $24, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
# emit-tail-expr
# si=-24
# env=((f6347 . -20) (f6346 . -16) (f6347 . -12) (f6346 . -8) (f6317 . 4) (f6317 . -28) (f6318 . -24) (f6319 . -20) (f6320 . -16) (f6321 . -12) (f6322 . -8) (f6323 . -4) (f6324 . 0))
# expr=(begin ((vector-ref f6317 0) (cdr f6346) f6347))
# tail-begin (begin ((vector-ref f6317 0) (cdr f6346) f6347))
#   env=((f6347 . -20) (f6346 . -16) (f6347 . -12) (f6346 . -8) (f6317 . 4) (f6317 . -28) (f6318 . -24) (f6319 . -20) (f6320 . -16) (f6321 . -12) (f6322 . -8) (f6323 . -4) (f6324 . 0))
# emit-tail-expr
# si=-24
# env=((f6347 . -20) (f6346 . -16) (f6347 . -12) (f6346 . -8) (f6317 . 4) (f6317 . -28) (f6318 . -24) (f6319 . -20) (f6320 . -16) (f6321 . -12) (f6322 . -8) (f6323 . -4) (f6324 . 0))
# expr=((vector-ref f6317 0) (cdr f6346) f6347)
# emit-tail-funcall
#    si   =-24
#    env  = ((f6347 . -20) (f6346 . -16) (f6347 . -12) (f6346 . -8) (f6317 . 4) (f6317 . -28) (f6318 . -24) (f6319 . -20) (f6320 . -16) (f6321 . -12) (f6322 . -8) (f6323 . -4) (f6324 . 0))
#    expr = (funcall (vector-ref f6317 0) (cdr f6346) f6347)
# emit-expr (vector-ref f6317 0)
# emit-expr f6317
# emit-variable-ref
# env=((f6347 . -20) (f6346 . -16) (f6347 . -12) (f6346 . -8) (f6317 . 4) (f6317 . -28) (f6318 . -24) (f6319 . -20) (f6320 . -16) (f6321 . -12) (f6322 . -8) (f6323 . -4) (f6324 . 0))
# var=f6317
    movl 2(%edi), %eax  # frame load f6317
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_38633
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_38633:
    movl %eax, -24(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_38634"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_38634:
# check bounds on vector index
    movl -24(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_38636
    cmp  $0,%eax
    jge _L_38635
_L_38636:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_38635:
    movl -24(%esp), %esi
    movl -1(%eax,%esi), %eax
   movl %eax,  -24(%esp)  # stash funcall-oper in next closure slot
# emit-expr (cdr f6346)
# emit-expr f6346
# emit-variable-ref
# env=((f6347 . -20) (f6346 . -16) (f6347 . -12) (f6346 . -8) (f6317 . 4) (f6317 . -28) (f6318 . -24) (f6319 . -20) (f6320 . -16) (f6321 . -12) (f6322 . -8) (f6323 . -4) (f6324 . 0))
# var=f6346
    movl -16(%esp), %eax  # stack load f6346
# end emit-variable-ref
# check the argument is a pair
    movl %eax,%ebx
    and $7, %bl
    cmp $1, %bl
    je _L_38637
# invoke error handler eh_pair
    .extern mrc_eh$upair
    movl mrc_eh$upair, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $120,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_38637:
    movl 3(%eax), %eax
    mov %eax, -28(%esp)    # arg (cdr f6346)
# emit-expr f6347
# emit-variable-ref
# env=((f6347 . -20) (f6346 . -16) (f6347 . -12) (f6346 . -8) (f6317 . 4) (f6317 . -28) (f6318 . -24) (f6319 . -20) (f6320 . -16) (f6321 . -12) (f6322 . -8) (f6323 . -4) (f6324 . 0))
# var=f6347
    movl -20(%esp), %eax  # stack load f6347
# end emit-variable-ref
    mov %eax, -32(%esp)    # arg f6347
    movl -24(%esp), %edi   # load new closure to %edi
# emit-shift-args:  size=3   si=-24  delta=20
    mov -24(%esp), %ebx  # shift frame cell
    mov %ebx, -4(%esp)  # down to base
# emit-shift-args:  size=2   si=-28  delta=20
    mov -28(%esp), %ebx  # shift frame cell
    mov %ebx, -8(%esp)  # down to base
# emit-shift-args:  size=1   si=-32  delta=20
    mov -32(%esp), %ebx  # shift frame cell
    mov %ebx, -12(%esp)  # down to base
# emit-shift-args:  size=0   si=-36  delta=20
    movl $8,%eax   # save arg count
    jmp *-2(%edi)  # tail-funcall
     ret   # return thru stack
    jmp _L_38630
_L_38629:
# emit-tail-expr
# si=-24
# env=((f6347 . -20) (f6346 . -16) (f6347 . -12) (f6346 . -8) (f6317 . 4) (f6317 . -28) (f6318 . -24) (f6319 . -20) (f6320 . -16) (f6321 . -12) (f6322 . -8) (f6323 . -4) (f6324 . 0))
# expr=(begin ((primitive-ref write-char) #\space f6347) ((primitive-ref write-char) #\. f6347) ((primitive-ref write-char) #\space f6347) ((primitive-ref write) (cdr f6346) f6347))
# tail-begin (begin ((primitive-ref write-char) #\space f6347) ((primitive-ref write-char) #\. f6347) ((primitive-ref write-char) #\space f6347) ((primitive-ref write) (cdr f6346) f6347))
#   env=((f6347 . -20) (f6346 . -16) (f6347 . -12) (f6346 . -8) (f6317 . 4) (f6317 . -28) (f6318 . -24) (f6319 . -20) (f6320 . -16) (f6321 . -12) (f6322 . -8) (f6323 . -4) (f6324 . 0))
# emit-expr ((primitive-ref write-char) #\space f6347)
# funcall
#    si   =-24
#    env  = ((f6347 . -20) (f6346 . -16) (f6347 . -12) (f6346 . -8) (f6317 . 4) (f6317 . -28) (f6318 . -24) (f6319 . -20) (f6320 . -16) (f6321 . -12) (f6322 . -8) (f6323 . -4) (f6324 . 0))
#    expr = (funcall (primitive-ref write-char) #\space f6347)
# emit-expr (primitive-ref write-char)
    .extern mrc_write$mchar
    movl mrc_write$mchar,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_38638"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_38638":
   movl %eax,  -32(%esp)  # stash funcall-oper in closure slot
# emit-expr #\space
    movl $8207, %eax     # immed #\space
    mov %eax, -36(%esp)  # arg  
# emit-expr f6347
# emit-variable-ref
# env=((f6347 . -20) (f6346 . -16) (f6347 . -12) (f6346 . -8) (f6317 . 4) (f6317 . -28) (f6318 . -24) (f6319 . -20) (f6320 . -16) (f6321 . -12) (f6322 . -8) (f6323 . -4) (f6324 . 0))
# var=f6347
    movl -20(%esp), %eax  # stack load f6347
# end emit-variable-ref
    mov %eax, -40(%esp)  # arg f6347
    movl -32(%esp), %edi   # load new closure to %edi
    add $-24, %esp   # adjust base
    movl $8,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $24, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
# emit-tail-expr
# si=-24
# env=((f6347 . -20) (f6346 . -16) (f6347 . -12) (f6346 . -8) (f6317 . 4) (f6317 . -28) (f6318 . -24) (f6319 . -20) (f6320 . -16) (f6321 . -12) (f6322 . -8) (f6323 . -4) (f6324 . 0))
# expr=(begin ((primitive-ref write-char) #\. f6347) ((primitive-ref write-char) #\space f6347) ((primitive-ref write) (cdr f6346) f6347))
# tail-begin (begin ((primitive-ref write-char) #\. f6347) ((primitive-ref write-char) #\space f6347) ((primitive-ref write) (cdr f6346) f6347))
#   env=((f6347 . -20) (f6346 . -16) (f6347 . -12) (f6346 . -8) (f6317 . 4) (f6317 . -28) (f6318 . -24) (f6319 . -20) (f6320 . -16) (f6321 . -12) (f6322 . -8) (f6323 . -4) (f6324 . 0))
# emit-expr ((primitive-ref write-char) #\. f6347)
# funcall
#    si   =-24
#    env  = ((f6347 . -20) (f6346 . -16) (f6347 . -12) (f6346 . -8) (f6317 . 4) (f6317 . -28) (f6318 . -24) (f6319 . -20) (f6320 . -16) (f6321 . -12) (f6322 . -8) (f6323 . -4) (f6324 . 0))
#    expr = (funcall (primitive-ref write-char) #\. f6347)
# emit-expr (primitive-ref write-char)
    .extern mrc_write$mchar
    movl mrc_write$mchar,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_38639"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_38639":
   movl %eax,  -32(%esp)  # stash funcall-oper in closure slot
# emit-expr #\.
    movl $11791, %eax     # immed #\.
    mov %eax, -36(%esp)  # arg .
# emit-expr f6347
# emit-variable-ref
# env=((f6347 . -20) (f6346 . -16) (f6347 . -12) (f6346 . -8) (f6317 . 4) (f6317 . -28) (f6318 . -24) (f6319 . -20) (f6320 . -16) (f6321 . -12) (f6322 . -8) (f6323 . -4) (f6324 . 0))
# var=f6347
    movl -20(%esp), %eax  # stack load f6347
# end emit-variable-ref
    mov %eax, -40(%esp)  # arg f6347
    movl -32(%esp), %edi   # load new closure to %edi
    add $-24, %esp   # adjust base
    movl $8,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $24, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
# emit-tail-expr
# si=-24
# env=((f6347 . -20) (f6346 . -16) (f6347 . -12) (f6346 . -8) (f6317 . 4) (f6317 . -28) (f6318 . -24) (f6319 . -20) (f6320 . -16) (f6321 . -12) (f6322 . -8) (f6323 . -4) (f6324 . 0))
# expr=(begin ((primitive-ref write-char) #\space f6347) ((primitive-ref write) (cdr f6346) f6347))
# tail-begin (begin ((primitive-ref write-char) #\space f6347) ((primitive-ref write) (cdr f6346) f6347))
#   env=((f6347 . -20) (f6346 . -16) (f6347 . -12) (f6346 . -8) (f6317 . 4) (f6317 . -28) (f6318 . -24) (f6319 . -20) (f6320 . -16) (f6321 . -12) (f6322 . -8) (f6323 . -4) (f6324 . 0))
# emit-expr ((primitive-ref write-char) #\space f6347)
# funcall
#    si   =-24
#    env  = ((f6347 . -20) (f6346 . -16) (f6347 . -12) (f6346 . -8) (f6317 . 4) (f6317 . -28) (f6318 . -24) (f6319 . -20) (f6320 . -16) (f6321 . -12) (f6322 . -8) (f6323 . -4) (f6324 . 0))
#    expr = (funcall (primitive-ref write-char) #\space f6347)
# emit-expr (primitive-ref write-char)
    .extern mrc_write$mchar
    movl mrc_write$mchar,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_38640"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_38640":
   movl %eax,  -32(%esp)  # stash funcall-oper in closure slot
# emit-expr #\space
    movl $8207, %eax     # immed #\space
    mov %eax, -36(%esp)  # arg  
# emit-expr f6347
# emit-variable-ref
# env=((f6347 . -20) (f6346 . -16) (f6347 . -12) (f6346 . -8) (f6317 . 4) (f6317 . -28) (f6318 . -24) (f6319 . -20) (f6320 . -16) (f6321 . -12) (f6322 . -8) (f6323 . -4) (f6324 . 0))
# var=f6347
    movl -20(%esp), %eax  # stack load f6347
# end emit-variable-ref
    mov %eax, -40(%esp)  # arg f6347
    movl -32(%esp), %edi   # load new closure to %edi
    add $-24, %esp   # adjust base
    movl $8,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $24, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
# emit-tail-expr
# si=-24
# env=((f6347 . -20) (f6346 . -16) (f6347 . -12) (f6346 . -8) (f6317 . 4) (f6317 . -28) (f6318 . -24) (f6319 . -20) (f6320 . -16) (f6321 . -12) (f6322 . -8) (f6323 . -4) (f6324 . 0))
# expr=(begin ((primitive-ref write) (cdr f6346) f6347))
# tail-begin (begin ((primitive-ref write) (cdr f6346) f6347))
#   env=((f6347 . -20) (f6346 . -16) (f6347 . -12) (f6346 . -8) (f6317 . 4) (f6317 . -28) (f6318 . -24) (f6319 . -20) (f6320 . -16) (f6321 . -12) (f6322 . -8) (f6323 . -4) (f6324 . 0))
# emit-tail-expr
# si=-24
# env=((f6347 . -20) (f6346 . -16) (f6347 . -12) (f6346 . -8) (f6317 . 4) (f6317 . -28) (f6318 . -24) (f6319 . -20) (f6320 . -16) (f6321 . -12) (f6322 . -8) (f6323 . -4) (f6324 . 0))
# expr=((primitive-ref write) (cdr f6346) f6347)
# emit-tail-funcall
#    si   =-24
#    env  = ((f6347 . -20) (f6346 . -16) (f6347 . -12) (f6346 . -8) (f6317 . 4) (f6317 . -28) (f6318 . -24) (f6319 . -20) (f6320 . -16) (f6321 . -12) (f6322 . -8) (f6323 . -4) (f6324 . 0))
#    expr = (funcall (primitive-ref write) (cdr f6346) f6347)
# emit-expr (primitive-ref write)
    .extern mrc_write
    movl mrc_write,%eax
   movl %eax,  -24(%esp)  # stash funcall-oper in next closure slot
# emit-expr (cdr f6346)
# emit-expr f6346
# emit-variable-ref
# env=((f6347 . -20) (f6346 . -16) (f6347 . -12) (f6346 . -8) (f6317 . 4) (f6317 . -28) (f6318 . -24) (f6319 . -20) (f6320 . -16) (f6321 . -12) (f6322 . -8) (f6323 . -4) (f6324 . 0))
# var=f6346
    movl -16(%esp), %eax  # stack load f6346
# end emit-variable-ref
# check the argument is a pair
    movl %eax,%ebx
    and $7, %bl
    cmp $1, %bl
    je _L_38641
# invoke error handler eh_pair
    .extern mrc_eh$upair
    movl mrc_eh$upair, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $120,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_38641:
    movl 3(%eax), %eax
    mov %eax, -28(%esp)    # arg (cdr f6346)
# emit-expr f6347
# emit-variable-ref
# env=((f6347 . -20) (f6346 . -16) (f6347 . -12) (f6346 . -8) (f6317 . 4) (f6317 . -28) (f6318 . -24) (f6319 . -20) (f6320 . -16) (f6321 . -12) (f6322 . -8) (f6323 . -4) (f6324 . 0))
# var=f6347
    movl -20(%esp), %eax  # stack load f6347
# end emit-variable-ref
    mov %eax, -32(%esp)    # arg f6347
    movl -24(%esp), %edi   # load new closure to %edi
# emit-shift-args:  size=3   si=-24  delta=20
    mov -24(%esp), %ebx  # shift frame cell
    mov %ebx, -4(%esp)  # down to base
# emit-shift-args:  size=2   si=-28  delta=20
    mov -28(%esp), %ebx  # shift frame cell
    mov %ebx, -8(%esp)  # down to base
# emit-shift-args:  size=1   si=-32  delta=20
    mov -32(%esp), %ebx  # shift frame cell
    mov %ebx, -12(%esp)  # down to base
# emit-shift-args:  size=0   si=-36  delta=20
    movl $8,%eax   # save arg count
    jmp *-2(%edi)  # tail-funcall
     ret   # return thru stack
_L_38630:
_L_38627:
     ret   # return thru stack
    .align 4,0x90
_L_38622:
    movl -32(%esp), %ebx
    movl -36(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin)
# emit-begin
#   expr=(begin)
#   env=((f6317 . -28) (f6318 . -24) (f6319 . -20) (f6320 . -16) (f6321 . -12) (f6322 . -8) (f6323 . -4) (f6324 . 0))
# emit-expr (begin (closure (f6370 f6371 f6372) (f6324 f6323 f6322 f6321 f6319 f6320 f6318) (let ((f6370 f6370) (f6371 f6371) (f6372 f6372)) (if (boolean? f6370) ((vector-ref f6324 0) f6370 f6371) (if (null? f6370) ((vector-ref f6323 0) f6371) (if (char? f6370) (if f6372 ((primitive-ref write-char) f6370 f6371) ((vector-ref f6322 0) f6370 f6371)) (if (fixnum? f6370) ((vector-ref f6321 0) f6370 f6371) (if (string? f6370) (if f6372 ((vector-ref f6319 0) f6370 f6371) ((vector-ref f6320 0) f6370 f6371)) (if (pair? f6370) ((vector-ref f6318 0) f6370 f6371) ((primitive-ref error) ((primitive-ref string->symbol) "write") "unrecognized expression"))))))))))
# emit-begin
#   expr=(begin (closure (f6370 f6371 f6372) (f6324 f6323 f6322 f6321 f6319 f6320 f6318) (let ((f6370 f6370) (f6371 f6371) (f6372 f6372)) (if (boolean? f6370) ((vector-ref f6324 0) f6370 f6371) (if (null? f6370) ((vector-ref f6323 0) f6371) (if (char? f6370) (if f6372 ((primitive-ref write-char) f6370 f6371) ((vector-ref f6322 0) f6370 f6371)) (if (fixnum? f6370) ((vector-ref f6321 0) f6370 f6371) (if (string? f6370) (if f6372 ((vector-ref f6319 0) f6370 f6371) ((vector-ref f6320 0) f6370 f6371)) (if (pair? f6370) ((vector-ref f6318 0) f6370 f6371) ((primitive-ref error) ((primitive-ref string->symbol) "write") "unrecognized expression"))))))))))
#   env=((f6317 . -28) (f6318 . -24) (f6319 . -20) (f6320 . -16) (f6321 . -12) (f6322 . -8) (f6323 . -4) (f6324 . 0))
# emit-expr (closure (f6370 f6371 f6372) (f6324 f6323 f6322 f6321 f6319 f6320 f6318) (let ((f6370 f6370) (f6371 f6371) (f6372 f6372)) (if (boolean? f6370) ((vector-ref f6324 0) f6370 f6371) (if (null? f6370) ((vector-ref f6323 0) f6371) (if (char? f6370) (if f6372 ((primitive-ref write-char) f6370 f6371) ((vector-ref f6322 0) f6370 f6371)) (if (fixnum? f6370) ((vector-ref f6321 0) f6370 f6371) (if (string? f6370) (if f6372 ((vector-ref f6319 0) f6370 f6371) ((vector-ref f6320 0) f6370 f6371)) (if (pair? f6370) ((vector-ref f6318 0) f6370 f6371) ((primitive-ref error) ((primitive-ref string->symbol) "write") "unrecognized expression")))))))))
# emit-closure
# si = -32
# env = ((f6317 . -28) (f6318 . -24) (f6319 . -20) (f6320 . -16) (f6321 . -12) (f6322 . -8) (f6323 . -4) (f6324 . 0))
# expr = (closure (f6370 f6371 f6372) (f6324 f6323 f6322 f6321 f6319 f6320 f6318) (let ((f6370 f6370) (f6371 f6371) (f6372 f6372)) (if (boolean? f6370) ((vector-ref f6324 0) f6370 f6371) (if (null? f6370) ((vector-ref f6323 0) f6371) (if (char? f6370) (if f6372 ((primitive-ref write-char) f6370 f6371) ((vector-ref f6322 0) f6370 f6371)) (if (fixnum? f6370) ((vector-ref f6321 0) f6370 f6371) (if (string? f6370) (if f6372 ((vector-ref f6319 0) f6370 f6371) ((vector-ref f6320 0) f6370 f6371)) (if (pair? f6370) ((vector-ref f6318 0) f6370 f6371) ((primitive-ref error) ((primitive-ref string->symbol) "write") "unrecognized expression")))))))))
    movl $_L_38642, 0(%ebp)  # closure label
# emit-variable-ref
# env=((f6317 . -28) (f6318 . -24) (f6319 . -20) (f6320 . -16) (f6321 . -12) (f6322 . -8) (f6323 . -4) (f6324 . 0))
# var=f6324
    movl 0(%esp), %eax  # stack load f6324
# end emit-variable-ref
   movl  %eax, 4(%ebp)  # f6324
# emit-variable-ref
# env=((f6317 . -28) (f6318 . -24) (f6319 . -20) (f6320 . -16) (f6321 . -12) (f6322 . -8) (f6323 . -4) (f6324 . 0))
# var=f6323
    movl -4(%esp), %eax  # stack load f6323
# end emit-variable-ref
   movl  %eax, 8(%ebp)  # f6323
# emit-variable-ref
# env=((f6317 . -28) (f6318 . -24) (f6319 . -20) (f6320 . -16) (f6321 . -12) (f6322 . -8) (f6323 . -4) (f6324 . 0))
# var=f6322
    movl -8(%esp), %eax  # stack load f6322
# end emit-variable-ref
   movl  %eax, 12(%ebp)  # f6322
# emit-variable-ref
# env=((f6317 . -28) (f6318 . -24) (f6319 . -20) (f6320 . -16) (f6321 . -12) (f6322 . -8) (f6323 . -4) (f6324 . 0))
# var=f6321
    movl -12(%esp), %eax  # stack load f6321
# end emit-variable-ref
   movl  %eax, 16(%ebp)  # f6321
# emit-variable-ref
# env=((f6317 . -28) (f6318 . -24) (f6319 . -20) (f6320 . -16) (f6321 . -12) (f6322 . -8) (f6323 . -4) (f6324 . 0))
# var=f6319
    movl -20(%esp), %eax  # stack load f6319
# end emit-variable-ref
   movl  %eax, 20(%ebp)  # f6319
# emit-variable-ref
# env=((f6317 . -28) (f6318 . -24) (f6319 . -20) (f6320 . -16) (f6321 . -12) (f6322 . -8) (f6323 . -4) (f6324 . 0))
# var=f6320
    movl -16(%esp), %eax  # stack load f6320
# end emit-variable-ref
   movl  %eax, 24(%ebp)  # f6320
# emit-variable-ref
# env=((f6317 . -28) (f6318 . -24) (f6319 . -20) (f6320 . -16) (f6321 . -12) (f6322 . -8) (f6323 . -4) (f6324 . 0))
# var=f6318
    movl -24(%esp), %eax  # stack load f6318
# end emit-variable-ref
   movl  %eax, 28(%ebp)  # f6318
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $32, %ebp     # bump ebp
    jmp _L_38643            # jump around closure body
_L_38642:
# check argument count
    cmp $12,%eax
    je _L_38644
# invoke error handler eh_argcount
    .extern mrc_eh$uargcount
    movl mrc_eh$uargcount, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_38644:
# emit-tail-expr
# si=-20
# env=((f6372 . -16) (f6371 . -12) (f6370 . -8) (f6318 . 28) (f6320 . 24) (f6319 . 20) (f6321 . 16) (f6322 . 12) (f6323 . 8) (f6324 . 4) (f6317 . -28) (f6318 . -24) (f6319 . -20) (f6320 . -16) (f6321 . -12) (f6322 . -8) (f6323 . -4) (f6324 . 0))
# expr=(let ((f6370 f6370) (f6371 f6371) (f6372 f6372)) (if (boolean? f6370) ((vector-ref f6324 0) f6370 f6371) (if (null? f6370) ((vector-ref f6323 0) f6371) (if (char? f6370) (if f6372 ((primitive-ref write-char) f6370 f6371) ((vector-ref f6322 0) f6370 f6371)) (if (fixnum? f6370) ((vector-ref f6321 0) f6370 f6371) (if (string? f6370) (if f6372 ((vector-ref f6319 0) f6370 f6371) ((vector-ref f6320 0) f6370 f6371)) (if (pair? f6370) ((vector-ref f6318 0) f6370 f6371) ((primitive-ref error) ((primitive-ref string->symbol) "write") "unrecognized expression"))))))))
# emit-tail-let
#  si   = -20
#  env  = ((f6372 . -16) (f6371 . -12) (f6370 . -8) (f6318 . 28) (f6320 . 24) (f6319 . 20) (f6321 . 16) (f6322 . 12) (f6323 . 8) (f6324 . 4) (f6317 . -28) (f6318 . -24) (f6319 . -20) (f6320 . -16) (f6321 . -12) (f6322 . -8) (f6323 . -4) (f6324 . 0))
#  bindings = ((f6370 f6370) (f6371 f6371) (f6372 f6372))
#  body = (if (boolean? f6370) ((vector-ref f6324 0) f6370 f6371) (if (null? f6370) ((vector-ref f6323 0) f6371) (if (char? f6370) (if f6372 ((primitive-ref write-char) f6370 f6371) ((vector-ref f6322 0) f6370 f6371)) (if (fixnum? f6370) ((vector-ref f6321 0) f6370 f6371) (if (string? f6370) (if f6372 ((vector-ref f6319 0) f6370 f6371) ((vector-ref f6320 0) f6370 f6371)) (if (pair? f6370) ((vector-ref f6318 0) f6370 f6371) ((primitive-ref error) ((primitive-ref string->symbol) "write") "unrecognized expression")))))))
# emit-expr f6370
# emit-variable-ref
# env=((f6372 . -16) (f6371 . -12) (f6370 . -8) (f6318 . 28) (f6320 . 24) (f6319 . 20) (f6321 . 16) (f6322 . 12) (f6323 . 8) (f6324 . 4) (f6317 . -28) (f6318 . -24) (f6319 . -20) (f6320 . -16) (f6321 . -12) (f6322 . -8) (f6323 . -4) (f6324 . 0))
# var=f6370
    movl -8(%esp), %eax  # stack load f6370
# end emit-variable-ref
    movl %eax, -20(%esp)  # stack save
# emit-expr f6371
# emit-variable-ref
# env=((f6372 . -16) (f6371 . -12) (f6370 . -8) (f6318 . 28) (f6320 . 24) (f6319 . 20) (f6321 . 16) (f6322 . 12) (f6323 . 8) (f6324 . 4) (f6317 . -28) (f6318 . -24) (f6319 . -20) (f6320 . -16) (f6321 . -12) (f6322 . -8) (f6323 . -4) (f6324 . 0))
# var=f6371
    movl -12(%esp), %eax  # stack load f6371
# end emit-variable-ref
    movl %eax, -24(%esp)  # stack save
# emit-expr f6372
# emit-variable-ref
# env=((f6372 . -16) (f6371 . -12) (f6370 . -8) (f6318 . 28) (f6320 . 24) (f6319 . 20) (f6321 . 16) (f6322 . 12) (f6323 . 8) (f6324 . 4) (f6317 . -28) (f6318 . -24) (f6319 . -20) (f6320 . -16) (f6321 . -12) (f6322 . -8) (f6323 . -4) (f6324 . 0))
# var=f6372
    movl -16(%esp), %eax  # stack load f6372
# end emit-variable-ref
    movl %eax, -28(%esp)  # stack save
# emit-tail-expr
# si=-32
# env=((f6372 . -28) (f6371 . -24) (f6370 . -20) (f6372 . -16) (f6371 . -12) (f6370 . -8) (f6318 . 28) (f6320 . 24) (f6319 . 20) (f6321 . 16) (f6322 . 12) (f6323 . 8) (f6324 . 4) (f6317 . -28) (f6318 . -24) (f6319 . -20) (f6320 . -16) (f6321 . -12) (f6322 . -8) (f6323 . -4) (f6324 . 0))
# expr=(if (boolean? f6370) ((vector-ref f6324 0) f6370 f6371) (if (null? f6370) ((vector-ref f6323 0) f6371) (if (char? f6370) (if f6372 ((primitive-ref write-char) f6370 f6371) ((vector-ref f6322 0) f6370 f6371)) (if (fixnum? f6370) ((vector-ref f6321 0) f6370 f6371) (if (string? f6370) (if f6372 ((vector-ref f6319 0) f6370 f6371) ((vector-ref f6320 0) f6370 f6371)) (if (pair? f6370) ((vector-ref f6318 0) f6370 f6371) ((primitive-ref error) ((primitive-ref string->symbol) "write") "unrecognized expression")))))))
# emit-expr (boolean? f6370)
# emit-expr f6370
# emit-variable-ref
# env=((f6372 . -28) (f6371 . -24) (f6370 . -20) (f6372 . -16) (f6371 . -12) (f6370 . -8) (f6318 . 28) (f6320 . 24) (f6319 . 20) (f6321 . 16) (f6322 . 12) (f6323 . 8) (f6324 . 4) (f6317 . -28) (f6318 . -24) (f6319 . -20) (f6320 . -16) (f6321 . -12) (f6322 . -8) (f6323 . -4) (f6324 . 0))
# var=f6370
    movl -20(%esp), %eax  # stack load f6370
# end emit-variable-ref
    and $191, %eax
    cmp $47, %eax
    sete %al
    movzbl %al, %eax
    sal $6, %al
    or $47, %al
    cmp $47, %al
    je _L_38645
# emit-tail-expr
# si=-32
# env=((f6372 . -28) (f6371 . -24) (f6370 . -20) (f6372 . -16) (f6371 . -12) (f6370 . -8) (f6318 . 28) (f6320 . 24) (f6319 . 20) (f6321 . 16) (f6322 . 12) (f6323 . 8) (f6324 . 4) (f6317 . -28) (f6318 . -24) (f6319 . -20) (f6320 . -16) (f6321 . -12) (f6322 . -8) (f6323 . -4) (f6324 . 0))
# expr=((vector-ref f6324 0) f6370 f6371)
# emit-tail-funcall
#    si   =-32
#    env  = ((f6372 . -28) (f6371 . -24) (f6370 . -20) (f6372 . -16) (f6371 . -12) (f6370 . -8) (f6318 . 28) (f6320 . 24) (f6319 . 20) (f6321 . 16) (f6322 . 12) (f6323 . 8) (f6324 . 4) (f6317 . -28) (f6318 . -24) (f6319 . -20) (f6320 . -16) (f6321 . -12) (f6322 . -8) (f6323 . -4) (f6324 . 0))
#    expr = (funcall (vector-ref f6324 0) f6370 f6371)
# emit-expr (vector-ref f6324 0)
# emit-expr f6324
# emit-variable-ref
# env=((f6372 . -28) (f6371 . -24) (f6370 . -20) (f6372 . -16) (f6371 . -12) (f6370 . -8) (f6318 . 28) (f6320 . 24) (f6319 . 20) (f6321 . 16) (f6322 . 12) (f6323 . 8) (f6324 . 4) (f6317 . -28) (f6318 . -24) (f6319 . -20) (f6320 . -16) (f6321 . -12) (f6322 . -8) (f6323 . -4) (f6324 . 0))
# var=f6324
    movl 2(%edi), %eax  # frame load f6324
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_38647
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_38647:
    movl %eax, -32(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_38648"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_38648:
# check bounds on vector index
    movl -32(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_38650
    cmp  $0,%eax
    jge _L_38649
_L_38650:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_38649:
    movl -32(%esp), %esi
    movl -1(%eax,%esi), %eax
   movl %eax,  -32(%esp)  # stash funcall-oper in next closure slot
# emit-expr f6370
# emit-variable-ref
# env=((f6372 . -28) (f6371 . -24) (f6370 . -20) (f6372 . -16) (f6371 . -12) (f6370 . -8) (f6318 . 28) (f6320 . 24) (f6319 . 20) (f6321 . 16) (f6322 . 12) (f6323 . 8) (f6324 . 4) (f6317 . -28) (f6318 . -24) (f6319 . -20) (f6320 . -16) (f6321 . -12) (f6322 . -8) (f6323 . -4) (f6324 . 0))
# var=f6370
    movl -20(%esp), %eax  # stack load f6370
# end emit-variable-ref
    mov %eax, -36(%esp)    # arg f6370
# emit-expr f6371
# emit-variable-ref
# env=((f6372 . -28) (f6371 . -24) (f6370 . -20) (f6372 . -16) (f6371 . -12) (f6370 . -8) (f6318 . 28) (f6320 . 24) (f6319 . 20) (f6321 . 16) (f6322 . 12) (f6323 . 8) (f6324 . 4) (f6317 . -28) (f6318 . -24) (f6319 . -20) (f6320 . -16) (f6321 . -12) (f6322 . -8) (f6323 . -4) (f6324 . 0))
# var=f6371
    movl -24(%esp), %eax  # stack load f6371
# end emit-variable-ref
    mov %eax, -40(%esp)    # arg f6371
    movl -32(%esp), %edi   # load new closure to %edi
# emit-shift-args:  size=3   si=-32  delta=28
    mov -32(%esp), %ebx  # shift frame cell
    mov %ebx, -4(%esp)  # down to base
# emit-shift-args:  size=2   si=-36  delta=28
    mov -36(%esp), %ebx  # shift frame cell
    mov %ebx, -8(%esp)  # down to base
# emit-shift-args:  size=1   si=-40  delta=28
    mov -40(%esp), %ebx  # shift frame cell
    mov %ebx, -12(%esp)  # down to base
# emit-shift-args:  size=0   si=-44  delta=28
    movl $8,%eax   # save arg count
    jmp *-2(%edi)  # tail-funcall
    jmp _L_38646
_L_38645:
# emit-tail-expr
# si=-32
# env=((f6372 . -28) (f6371 . -24) (f6370 . -20) (f6372 . -16) (f6371 . -12) (f6370 . -8) (f6318 . 28) (f6320 . 24) (f6319 . 20) (f6321 . 16) (f6322 . 12) (f6323 . 8) (f6324 . 4) (f6317 . -28) (f6318 . -24) (f6319 . -20) (f6320 . -16) (f6321 . -12) (f6322 . -8) (f6323 . -4) (f6324 . 0))
# expr=(if (null? f6370) ((vector-ref f6323 0) f6371) (if (char? f6370) (if f6372 ((primitive-ref write-char) f6370 f6371) ((vector-ref f6322 0) f6370 f6371)) (if (fixnum? f6370) ((vector-ref f6321 0) f6370 f6371) (if (string? f6370) (if f6372 ((vector-ref f6319 0) f6370 f6371) ((vector-ref f6320 0) f6370 f6371)) (if (pair? f6370) ((vector-ref f6318 0) f6370 f6371) ((primitive-ref error) ((primitive-ref string->symbol) "write") "unrecognized expression"))))))
# emit-expr (null? f6370)
# emit-expr f6370
# emit-variable-ref
# env=((f6372 . -28) (f6371 . -24) (f6370 . -20) (f6372 . -16) (f6371 . -12) (f6370 . -8) (f6318 . 28) (f6320 . 24) (f6319 . 20) (f6321 . 16) (f6322 . 12) (f6323 . 8) (f6324 . 4) (f6317 . -28) (f6318 . -24) (f6319 . -20) (f6320 . -16) (f6321 . -12) (f6322 . -8) (f6323 . -4) (f6324 . 0))
# var=f6370
    movl -20(%esp), %eax  # stack load f6370
# end emit-variable-ref
    cmp $63, %eax
    mov $0, %eax
    sete %al
    movzbl %al, %eax
    sal $6, %al
    or $47, %al
    cmp $47, %al
    je _L_38651
# emit-tail-expr
# si=-32
# env=((f6372 . -28) (f6371 . -24) (f6370 . -20) (f6372 . -16) (f6371 . -12) (f6370 . -8) (f6318 . 28) (f6320 . 24) (f6319 . 20) (f6321 . 16) (f6322 . 12) (f6323 . 8) (f6324 . 4) (f6317 . -28) (f6318 . -24) (f6319 . -20) (f6320 . -16) (f6321 . -12) (f6322 . -8) (f6323 . -4) (f6324 . 0))
# expr=((vector-ref f6323 0) f6371)
# emit-tail-funcall
#    si   =-32
#    env  = ((f6372 . -28) (f6371 . -24) (f6370 . -20) (f6372 . -16) (f6371 . -12) (f6370 . -8) (f6318 . 28) (f6320 . 24) (f6319 . 20) (f6321 . 16) (f6322 . 12) (f6323 . 8) (f6324 . 4) (f6317 . -28) (f6318 . -24) (f6319 . -20) (f6320 . -16) (f6321 . -12) (f6322 . -8) (f6323 . -4) (f6324 . 0))
#    expr = (funcall (vector-ref f6323 0) f6371)
# emit-expr (vector-ref f6323 0)
# emit-expr f6323
# emit-variable-ref
# env=((f6372 . -28) (f6371 . -24) (f6370 . -20) (f6372 . -16) (f6371 . -12) (f6370 . -8) (f6318 . 28) (f6320 . 24) (f6319 . 20) (f6321 . 16) (f6322 . 12) (f6323 . 8) (f6324 . 4) (f6317 . -28) (f6318 . -24) (f6319 . -20) (f6320 . -16) (f6321 . -12) (f6322 . -8) (f6323 . -4) (f6324 . 0))
# var=f6323
    movl 6(%edi), %eax  # frame load f6323
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_38653
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_38653:
    movl %eax, -32(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_38654"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_38654:
# check bounds on vector index
    movl -32(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_38656
    cmp  $0,%eax
    jge _L_38655
_L_38656:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_38655:
    movl -32(%esp), %esi
    movl -1(%eax,%esi), %eax
   movl %eax,  -32(%esp)  # stash funcall-oper in next closure slot
# emit-expr f6371
# emit-variable-ref
# env=((f6372 . -28) (f6371 . -24) (f6370 . -20) (f6372 . -16) (f6371 . -12) (f6370 . -8) (f6318 . 28) (f6320 . 24) (f6319 . 20) (f6321 . 16) (f6322 . 12) (f6323 . 8) (f6324 . 4) (f6317 . -28) (f6318 . -24) (f6319 . -20) (f6320 . -16) (f6321 . -12) (f6322 . -8) (f6323 . -4) (f6324 . 0))
# var=f6371
    movl -24(%esp), %eax  # stack load f6371
# end emit-variable-ref
    mov %eax, -36(%esp)    # arg f6371
    movl -32(%esp), %edi   # load new closure to %edi
# emit-shift-args:  size=2   si=-32  delta=28
    mov -32(%esp), %ebx  # shift frame cell
    mov %ebx, -4(%esp)  # down to base
# emit-shift-args:  size=1   si=-36  delta=28
    mov -36(%esp), %ebx  # shift frame cell
    mov %ebx, -8(%esp)  # down to base
# emit-shift-args:  size=0   si=-40  delta=28
    movl $4,%eax   # save arg count
    jmp *-2(%edi)  # tail-funcall
    jmp _L_38652
_L_38651:
# emit-tail-expr
# si=-32
# env=((f6372 . -28) (f6371 . -24) (f6370 . -20) (f6372 . -16) (f6371 . -12) (f6370 . -8) (f6318 . 28) (f6320 . 24) (f6319 . 20) (f6321 . 16) (f6322 . 12) (f6323 . 8) (f6324 . 4) (f6317 . -28) (f6318 . -24) (f6319 . -20) (f6320 . -16) (f6321 . -12) (f6322 . -8) (f6323 . -4) (f6324 . 0))
# expr=(if (char? f6370) (if f6372 ((primitive-ref write-char) f6370 f6371) ((vector-ref f6322 0) f6370 f6371)) (if (fixnum? f6370) ((vector-ref f6321 0) f6370 f6371) (if (string? f6370) (if f6372 ((vector-ref f6319 0) f6370 f6371) ((vector-ref f6320 0) f6370 f6371)) (if (pair? f6370) ((vector-ref f6318 0) f6370 f6371) ((primitive-ref error) ((primitive-ref string->symbol) "write") "unrecognized expression")))))
# emit-expr (char? f6370)
# emit-expr f6370
# emit-variable-ref
# env=((f6372 . -28) (f6371 . -24) (f6370 . -20) (f6372 . -16) (f6371 . -12) (f6370 . -8) (f6318 . 28) (f6320 . 24) (f6319 . 20) (f6321 . 16) (f6322 . 12) (f6323 . 8) (f6324 . 4) (f6317 . -28) (f6318 . -24) (f6319 . -20) (f6320 . -16) (f6321 . -12) (f6322 . -8) (f6323 . -4) (f6324 . 0))
# var=f6370
    movl -20(%esp), %eax  # stack load f6370
# end emit-variable-ref
    and $255, %eax
    cmp $15, %eax
    sete %al
    movzbl %al, %eax
    sal $6, %al
    or $47, %al
    cmp $47, %al
    je _L_38657
# emit-tail-expr
# si=-32
# env=((f6372 . -28) (f6371 . -24) (f6370 . -20) (f6372 . -16) (f6371 . -12) (f6370 . -8) (f6318 . 28) (f6320 . 24) (f6319 . 20) (f6321 . 16) (f6322 . 12) (f6323 . 8) (f6324 . 4) (f6317 . -28) (f6318 . -24) (f6319 . -20) (f6320 . -16) (f6321 . -12) (f6322 . -8) (f6323 . -4) (f6324 . 0))
# expr=(if f6372 ((primitive-ref write-char) f6370 f6371) ((vector-ref f6322 0) f6370 f6371))
# emit-expr f6372
# emit-variable-ref
# env=((f6372 . -28) (f6371 . -24) (f6370 . -20) (f6372 . -16) (f6371 . -12) (f6370 . -8) (f6318 . 28) (f6320 . 24) (f6319 . 20) (f6321 . 16) (f6322 . 12) (f6323 . 8) (f6324 . 4) (f6317 . -28) (f6318 . -24) (f6319 . -20) (f6320 . -16) (f6321 . -12) (f6322 . -8) (f6323 . -4) (f6324 . 0))
# var=f6372
    movl -28(%esp), %eax  # stack load f6372
# end emit-variable-ref
    cmp $47, %al
    je _L_38659
# emit-tail-expr
# si=-32
# env=((f6372 . -28) (f6371 . -24) (f6370 . -20) (f6372 . -16) (f6371 . -12) (f6370 . -8) (f6318 . 28) (f6320 . 24) (f6319 . 20) (f6321 . 16) (f6322 . 12) (f6323 . 8) (f6324 . 4) (f6317 . -28) (f6318 . -24) (f6319 . -20) (f6320 . -16) (f6321 . -12) (f6322 . -8) (f6323 . -4) (f6324 . 0))
# expr=((primitive-ref write-char) f6370 f6371)
# emit-tail-funcall
#    si   =-32
#    env  = ((f6372 . -28) (f6371 . -24) (f6370 . -20) (f6372 . -16) (f6371 . -12) (f6370 . -8) (f6318 . 28) (f6320 . 24) (f6319 . 20) (f6321 . 16) (f6322 . 12) (f6323 . 8) (f6324 . 4) (f6317 . -28) (f6318 . -24) (f6319 . -20) (f6320 . -16) (f6321 . -12) (f6322 . -8) (f6323 . -4) (f6324 . 0))
#    expr = (funcall (primitive-ref write-char) f6370 f6371)
# emit-expr (primitive-ref write-char)
    .extern mrc_write$mchar
    movl mrc_write$mchar,%eax
   movl %eax,  -32(%esp)  # stash funcall-oper in next closure slot
# emit-expr f6370
# emit-variable-ref
# env=((f6372 . -28) (f6371 . -24) (f6370 . -20) (f6372 . -16) (f6371 . -12) (f6370 . -8) (f6318 . 28) (f6320 . 24) (f6319 . 20) (f6321 . 16) (f6322 . 12) (f6323 . 8) (f6324 . 4) (f6317 . -28) (f6318 . -24) (f6319 . -20) (f6320 . -16) (f6321 . -12) (f6322 . -8) (f6323 . -4) (f6324 . 0))
# var=f6370
    movl -20(%esp), %eax  # stack load f6370
# end emit-variable-ref
    mov %eax, -36(%esp)    # arg f6370
# emit-expr f6371
# emit-variable-ref
# env=((f6372 . -28) (f6371 . -24) (f6370 . -20) (f6372 . -16) (f6371 . -12) (f6370 . -8) (f6318 . 28) (f6320 . 24) (f6319 . 20) (f6321 . 16) (f6322 . 12) (f6323 . 8) (f6324 . 4) (f6317 . -28) (f6318 . -24) (f6319 . -20) (f6320 . -16) (f6321 . -12) (f6322 . -8) (f6323 . -4) (f6324 . 0))
# var=f6371
    movl -24(%esp), %eax  # stack load f6371
# end emit-variable-ref
    mov %eax, -40(%esp)    # arg f6371
    movl -32(%esp), %edi   # load new closure to %edi
# emit-shift-args:  size=3   si=-32  delta=28
    mov -32(%esp), %ebx  # shift frame cell
    mov %ebx, -4(%esp)  # down to base
# emit-shift-args:  size=2   si=-36  delta=28
    mov -36(%esp), %ebx  # shift frame cell
    mov %ebx, -8(%esp)  # down to base
# emit-shift-args:  size=1   si=-40  delta=28
    mov -40(%esp), %ebx  # shift frame cell
    mov %ebx, -12(%esp)  # down to base
# emit-shift-args:  size=0   si=-44  delta=28
    movl $8,%eax   # save arg count
    jmp *-2(%edi)  # tail-funcall
    jmp _L_38660
_L_38659:
# emit-tail-expr
# si=-32
# env=((f6372 . -28) (f6371 . -24) (f6370 . -20) (f6372 . -16) (f6371 . -12) (f6370 . -8) (f6318 . 28) (f6320 . 24) (f6319 . 20) (f6321 . 16) (f6322 . 12) (f6323 . 8) (f6324 . 4) (f6317 . -28) (f6318 . -24) (f6319 . -20) (f6320 . -16) (f6321 . -12) (f6322 . -8) (f6323 . -4) (f6324 . 0))
# expr=((vector-ref f6322 0) f6370 f6371)
# emit-tail-funcall
#    si   =-32
#    env  = ((f6372 . -28) (f6371 . -24) (f6370 . -20) (f6372 . -16) (f6371 . -12) (f6370 . -8) (f6318 . 28) (f6320 . 24) (f6319 . 20) (f6321 . 16) (f6322 . 12) (f6323 . 8) (f6324 . 4) (f6317 . -28) (f6318 . -24) (f6319 . -20) (f6320 . -16) (f6321 . -12) (f6322 . -8) (f6323 . -4) (f6324 . 0))
#    expr = (funcall (vector-ref f6322 0) f6370 f6371)
# emit-expr (vector-ref f6322 0)
# emit-expr f6322
# emit-variable-ref
# env=((f6372 . -28) (f6371 . -24) (f6370 . -20) (f6372 . -16) (f6371 . -12) (f6370 . -8) (f6318 . 28) (f6320 . 24) (f6319 . 20) (f6321 . 16) (f6322 . 12) (f6323 . 8) (f6324 . 4) (f6317 . -28) (f6318 . -24) (f6319 . -20) (f6320 . -16) (f6321 . -12) (f6322 . -8) (f6323 . -4) (f6324 . 0))
# var=f6322
    movl 10(%edi), %eax  # frame load f6322
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_38661
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_38661:
    movl %eax, -32(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_38662"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_38662:
# check bounds on vector index
    movl -32(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_38664
    cmp  $0,%eax
    jge _L_38663
_L_38664:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_38663:
    movl -32(%esp), %esi
    movl -1(%eax,%esi), %eax
   movl %eax,  -32(%esp)  # stash funcall-oper in next closure slot
# emit-expr f6370
# emit-variable-ref
# env=((f6372 . -28) (f6371 . -24) (f6370 . -20) (f6372 . -16) (f6371 . -12) (f6370 . -8) (f6318 . 28) (f6320 . 24) (f6319 . 20) (f6321 . 16) (f6322 . 12) (f6323 . 8) (f6324 . 4) (f6317 . -28) (f6318 . -24) (f6319 . -20) (f6320 . -16) (f6321 . -12) (f6322 . -8) (f6323 . -4) (f6324 . 0))
# var=f6370
    movl -20(%esp), %eax  # stack load f6370
# end emit-variable-ref
    mov %eax, -36(%esp)    # arg f6370
# emit-expr f6371
# emit-variable-ref
# env=((f6372 . -28) (f6371 . -24) (f6370 . -20) (f6372 . -16) (f6371 . -12) (f6370 . -8) (f6318 . 28) (f6320 . 24) (f6319 . 20) (f6321 . 16) (f6322 . 12) (f6323 . 8) (f6324 . 4) (f6317 . -28) (f6318 . -24) (f6319 . -20) (f6320 . -16) (f6321 . -12) (f6322 . -8) (f6323 . -4) (f6324 . 0))
# var=f6371
    movl -24(%esp), %eax  # stack load f6371
# end emit-variable-ref
    mov %eax, -40(%esp)    # arg f6371
    movl -32(%esp), %edi   # load new closure to %edi
# emit-shift-args:  size=3   si=-32  delta=28
    mov -32(%esp), %ebx  # shift frame cell
    mov %ebx, -4(%esp)  # down to base
# emit-shift-args:  size=2   si=-36  delta=28
    mov -36(%esp), %ebx  # shift frame cell
    mov %ebx, -8(%esp)  # down to base
# emit-shift-args:  size=1   si=-40  delta=28
    mov -40(%esp), %ebx  # shift frame cell
    mov %ebx, -12(%esp)  # down to base
# emit-shift-args:  size=0   si=-44  delta=28
    movl $8,%eax   # save arg count
    jmp *-2(%edi)  # tail-funcall
_L_38660:
    jmp _L_38658
_L_38657:
# emit-tail-expr
# si=-32
# env=((f6372 . -28) (f6371 . -24) (f6370 . -20) (f6372 . -16) (f6371 . -12) (f6370 . -8) (f6318 . 28) (f6320 . 24) (f6319 . 20) (f6321 . 16) (f6322 . 12) (f6323 . 8) (f6324 . 4) (f6317 . -28) (f6318 . -24) (f6319 . -20) (f6320 . -16) (f6321 . -12) (f6322 . -8) (f6323 . -4) (f6324 . 0))
# expr=(if (fixnum? f6370) ((vector-ref f6321 0) f6370 f6371) (if (string? f6370) (if f6372 ((vector-ref f6319 0) f6370 f6371) ((vector-ref f6320 0) f6370 f6371)) (if (pair? f6370) ((vector-ref f6318 0) f6370 f6371) ((primitive-ref error) ((primitive-ref string->symbol) "write") "unrecognized expression"))))
# emit-expr (fixnum? f6370)
# emit-expr f6370
# emit-variable-ref
# env=((f6372 . -28) (f6371 . -24) (f6370 . -20) (f6372 . -16) (f6371 . -12) (f6370 . -8) (f6318 . 28) (f6320 . 24) (f6319 . 20) (f6321 . 16) (f6322 . 12) (f6323 . 8) (f6324 . 4) (f6317 . -28) (f6318 . -24) (f6319 . -20) (f6320 . -16) (f6321 . -12) (f6322 . -8) (f6323 . -4) (f6324 . 0))
# var=f6370
    movl -20(%esp), %eax  # stack load f6370
# end emit-variable-ref
    and $3, %al
    cmp $0, %al
    sete %al
    movzbl %al, %eax
    sal $6, %al
    or $47, %al
    cmp $47, %al
    je _L_38665
# emit-tail-expr
# si=-32
# env=((f6372 . -28) (f6371 . -24) (f6370 . -20) (f6372 . -16) (f6371 . -12) (f6370 . -8) (f6318 . 28) (f6320 . 24) (f6319 . 20) (f6321 . 16) (f6322 . 12) (f6323 . 8) (f6324 . 4) (f6317 . -28) (f6318 . -24) (f6319 . -20) (f6320 . -16) (f6321 . -12) (f6322 . -8) (f6323 . -4) (f6324 . 0))
# expr=((vector-ref f6321 0) f6370 f6371)
# emit-tail-funcall
#    si   =-32
#    env  = ((f6372 . -28) (f6371 . -24) (f6370 . -20) (f6372 . -16) (f6371 . -12) (f6370 . -8) (f6318 . 28) (f6320 . 24) (f6319 . 20) (f6321 . 16) (f6322 . 12) (f6323 . 8) (f6324 . 4) (f6317 . -28) (f6318 . -24) (f6319 . -20) (f6320 . -16) (f6321 . -12) (f6322 . -8) (f6323 . -4) (f6324 . 0))
#    expr = (funcall (vector-ref f6321 0) f6370 f6371)
# emit-expr (vector-ref f6321 0)
# emit-expr f6321
# emit-variable-ref
# env=((f6372 . -28) (f6371 . -24) (f6370 . -20) (f6372 . -16) (f6371 . -12) (f6370 . -8) (f6318 . 28) (f6320 . 24) (f6319 . 20) (f6321 . 16) (f6322 . 12) (f6323 . 8) (f6324 . 4) (f6317 . -28) (f6318 . -24) (f6319 . -20) (f6320 . -16) (f6321 . -12) (f6322 . -8) (f6323 . -4) (f6324 . 0))
# var=f6321
    movl 14(%edi), %eax  # frame load f6321
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_38667
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_38667:
    movl %eax, -32(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_38668"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_38668:
# check bounds on vector index
    movl -32(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_38670
    cmp  $0,%eax
    jge _L_38669
_L_38670:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_38669:
    movl -32(%esp), %esi
    movl -1(%eax,%esi), %eax
   movl %eax,  -32(%esp)  # stash funcall-oper in next closure slot
# emit-expr f6370
# emit-variable-ref
# env=((f6372 . -28) (f6371 . -24) (f6370 . -20) (f6372 . -16) (f6371 . -12) (f6370 . -8) (f6318 . 28) (f6320 . 24) (f6319 . 20) (f6321 . 16) (f6322 . 12) (f6323 . 8) (f6324 . 4) (f6317 . -28) (f6318 . -24) (f6319 . -20) (f6320 . -16) (f6321 . -12) (f6322 . -8) (f6323 . -4) (f6324 . 0))
# var=f6370
    movl -20(%esp), %eax  # stack load f6370
# end emit-variable-ref
    mov %eax, -36(%esp)    # arg f6370
# emit-expr f6371
# emit-variable-ref
# env=((f6372 . -28) (f6371 . -24) (f6370 . -20) (f6372 . -16) (f6371 . -12) (f6370 . -8) (f6318 . 28) (f6320 . 24) (f6319 . 20) (f6321 . 16) (f6322 . 12) (f6323 . 8) (f6324 . 4) (f6317 . -28) (f6318 . -24) (f6319 . -20) (f6320 . -16) (f6321 . -12) (f6322 . -8) (f6323 . -4) (f6324 . 0))
# var=f6371
    movl -24(%esp), %eax  # stack load f6371
# end emit-variable-ref
    mov %eax, -40(%esp)    # arg f6371
    movl -32(%esp), %edi   # load new closure to %edi
# emit-shift-args:  size=3   si=-32  delta=28
    mov -32(%esp), %ebx  # shift frame cell
    mov %ebx, -4(%esp)  # down to base
# emit-shift-args:  size=2   si=-36  delta=28
    mov -36(%esp), %ebx  # shift frame cell
    mov %ebx, -8(%esp)  # down to base
# emit-shift-args:  size=1   si=-40  delta=28
    mov -40(%esp), %ebx  # shift frame cell
    mov %ebx, -12(%esp)  # down to base
# emit-shift-args:  size=0   si=-44  delta=28
    movl $8,%eax   # save arg count
    jmp *-2(%edi)  # tail-funcall
    jmp _L_38666
_L_38665:
# emit-tail-expr
# si=-32
# env=((f6372 . -28) (f6371 . -24) (f6370 . -20) (f6372 . -16) (f6371 . -12) (f6370 . -8) (f6318 . 28) (f6320 . 24) (f6319 . 20) (f6321 . 16) (f6322 . 12) (f6323 . 8) (f6324 . 4) (f6317 . -28) (f6318 . -24) (f6319 . -20) (f6320 . -16) (f6321 . -12) (f6322 . -8) (f6323 . -4) (f6324 . 0))
# expr=(if (string? f6370) (if f6372 ((vector-ref f6319 0) f6370 f6371) ((vector-ref f6320 0) f6370 f6371)) (if (pair? f6370) ((vector-ref f6318 0) f6370 f6371) ((primitive-ref error) ((primitive-ref string->symbol) "write") "unrecognized expression")))
# emit-expr (string? f6370)
# emit-expr f6370
# emit-variable-ref
# env=((f6372 . -28) (f6371 . -24) (f6370 . -20) (f6372 . -16) (f6371 . -12) (f6370 . -8) (f6318 . 28) (f6320 . 24) (f6319 . 20) (f6321 . 16) (f6322 . 12) (f6323 . 8) (f6324 . 4) (f6317 . -28) (f6318 . -24) (f6319 . -20) (f6320 . -16) (f6321 . -12) (f6322 . -8) (f6323 . -4) (f6324 . 0))
# var=f6370
    movl -20(%esp), %eax  # stack load f6370
# end emit-variable-ref
    and $7, %al
    cmp $6, %al
    sete %al
    movzbl %al, %eax
    sal $6, %al
    or $47, %al
    cmp $47, %al
    je _L_38671
# emit-tail-expr
# si=-32
# env=((f6372 . -28) (f6371 . -24) (f6370 . -20) (f6372 . -16) (f6371 . -12) (f6370 . -8) (f6318 . 28) (f6320 . 24) (f6319 . 20) (f6321 . 16) (f6322 . 12) (f6323 . 8) (f6324 . 4) (f6317 . -28) (f6318 . -24) (f6319 . -20) (f6320 . -16) (f6321 . -12) (f6322 . -8) (f6323 . -4) (f6324 . 0))
# expr=(if f6372 ((vector-ref f6319 0) f6370 f6371) ((vector-ref f6320 0) f6370 f6371))
# emit-expr f6372
# emit-variable-ref
# env=((f6372 . -28) (f6371 . -24) (f6370 . -20) (f6372 . -16) (f6371 . -12) (f6370 . -8) (f6318 . 28) (f6320 . 24) (f6319 . 20) (f6321 . 16) (f6322 . 12) (f6323 . 8) (f6324 . 4) (f6317 . -28) (f6318 . -24) (f6319 . -20) (f6320 . -16) (f6321 . -12) (f6322 . -8) (f6323 . -4) (f6324 . 0))
# var=f6372
    movl -28(%esp), %eax  # stack load f6372
# end emit-variable-ref
    cmp $47, %al
    je _L_38673
# emit-tail-expr
# si=-32
# env=((f6372 . -28) (f6371 . -24) (f6370 . -20) (f6372 . -16) (f6371 . -12) (f6370 . -8) (f6318 . 28) (f6320 . 24) (f6319 . 20) (f6321 . 16) (f6322 . 12) (f6323 . 8) (f6324 . 4) (f6317 . -28) (f6318 . -24) (f6319 . -20) (f6320 . -16) (f6321 . -12) (f6322 . -8) (f6323 . -4) (f6324 . 0))
# expr=((vector-ref f6319 0) f6370 f6371)
# emit-tail-funcall
#    si   =-32
#    env  = ((f6372 . -28) (f6371 . -24) (f6370 . -20) (f6372 . -16) (f6371 . -12) (f6370 . -8) (f6318 . 28) (f6320 . 24) (f6319 . 20) (f6321 . 16) (f6322 . 12) (f6323 . 8) (f6324 . 4) (f6317 . -28) (f6318 . -24) (f6319 . -20) (f6320 . -16) (f6321 . -12) (f6322 . -8) (f6323 . -4) (f6324 . 0))
#    expr = (funcall (vector-ref f6319 0) f6370 f6371)
# emit-expr (vector-ref f6319 0)
# emit-expr f6319
# emit-variable-ref
# env=((f6372 . -28) (f6371 . -24) (f6370 . -20) (f6372 . -16) (f6371 . -12) (f6370 . -8) (f6318 . 28) (f6320 . 24) (f6319 . 20) (f6321 . 16) (f6322 . 12) (f6323 . 8) (f6324 . 4) (f6317 . -28) (f6318 . -24) (f6319 . -20) (f6320 . -16) (f6321 . -12) (f6322 . -8) (f6323 . -4) (f6324 . 0))
# var=f6319
    movl 18(%edi), %eax  # frame load f6319
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_38675
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_38675:
    movl %eax, -32(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_38676"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_38676:
# check bounds on vector index
    movl -32(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_38678
    cmp  $0,%eax
    jge _L_38677
_L_38678:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_38677:
    movl -32(%esp), %esi
    movl -1(%eax,%esi), %eax
   movl %eax,  -32(%esp)  # stash funcall-oper in next closure slot
# emit-expr f6370
# emit-variable-ref
# env=((f6372 . -28) (f6371 . -24) (f6370 . -20) (f6372 . -16) (f6371 . -12) (f6370 . -8) (f6318 . 28) (f6320 . 24) (f6319 . 20) (f6321 . 16) (f6322 . 12) (f6323 . 8) (f6324 . 4) (f6317 . -28) (f6318 . -24) (f6319 . -20) (f6320 . -16) (f6321 . -12) (f6322 . -8) (f6323 . -4) (f6324 . 0))
# var=f6370
    movl -20(%esp), %eax  # stack load f6370
# end emit-variable-ref
    mov %eax, -36(%esp)    # arg f6370
# emit-expr f6371
# emit-variable-ref
# env=((f6372 . -28) (f6371 . -24) (f6370 . -20) (f6372 . -16) (f6371 . -12) (f6370 . -8) (f6318 . 28) (f6320 . 24) (f6319 . 20) (f6321 . 16) (f6322 . 12) (f6323 . 8) (f6324 . 4) (f6317 . -28) (f6318 . -24) (f6319 . -20) (f6320 . -16) (f6321 . -12) (f6322 . -8) (f6323 . -4) (f6324 . 0))
# var=f6371
    movl -24(%esp), %eax  # stack load f6371
# end emit-variable-ref
    mov %eax, -40(%esp)    # arg f6371
    movl -32(%esp), %edi   # load new closure to %edi
# emit-shift-args:  size=3   si=-32  delta=28
    mov -32(%esp), %ebx  # shift frame cell
    mov %ebx, -4(%esp)  # down to base
# emit-shift-args:  size=2   si=-36  delta=28
    mov -36(%esp), %ebx  # shift frame cell
    mov %ebx, -8(%esp)  # down to base
# emit-shift-args:  size=1   si=-40  delta=28
    mov -40(%esp), %ebx  # shift frame cell
    mov %ebx, -12(%esp)  # down to base
# emit-shift-args:  size=0   si=-44  delta=28
    movl $8,%eax   # save arg count
    jmp *-2(%edi)  # tail-funcall
    jmp _L_38674
_L_38673:
# emit-tail-expr
# si=-32
# env=((f6372 . -28) (f6371 . -24) (f6370 . -20) (f6372 . -16) (f6371 . -12) (f6370 . -8) (f6318 . 28) (f6320 . 24) (f6319 . 20) (f6321 . 16) (f6322 . 12) (f6323 . 8) (f6324 . 4) (f6317 . -28) (f6318 . -24) (f6319 . -20) (f6320 . -16) (f6321 . -12) (f6322 . -8) (f6323 . -4) (f6324 . 0))
# expr=((vector-ref f6320 0) f6370 f6371)
# emit-tail-funcall
#    si   =-32
#    env  = ((f6372 . -28) (f6371 . -24) (f6370 . -20) (f6372 . -16) (f6371 . -12) (f6370 . -8) (f6318 . 28) (f6320 . 24) (f6319 . 20) (f6321 . 16) (f6322 . 12) (f6323 . 8) (f6324 . 4) (f6317 . -28) (f6318 . -24) (f6319 . -20) (f6320 . -16) (f6321 . -12) (f6322 . -8) (f6323 . -4) (f6324 . 0))
#    expr = (funcall (vector-ref f6320 0) f6370 f6371)
# emit-expr (vector-ref f6320 0)
# emit-expr f6320
# emit-variable-ref
# env=((f6372 . -28) (f6371 . -24) (f6370 . -20) (f6372 . -16) (f6371 . -12) (f6370 . -8) (f6318 . 28) (f6320 . 24) (f6319 . 20) (f6321 . 16) (f6322 . 12) (f6323 . 8) (f6324 . 4) (f6317 . -28) (f6318 . -24) (f6319 . -20) (f6320 . -16) (f6321 . -12) (f6322 . -8) (f6323 . -4) (f6324 . 0))
# var=f6320
    movl 22(%edi), %eax  # frame load f6320
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_38679
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_38679:
    movl %eax, -32(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_38680"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_38680:
# check bounds on vector index
    movl -32(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_38682
    cmp  $0,%eax
    jge _L_38681
_L_38682:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_38681:
    movl -32(%esp), %esi
    movl -1(%eax,%esi), %eax
   movl %eax,  -32(%esp)  # stash funcall-oper in next closure slot
# emit-expr f6370
# emit-variable-ref
# env=((f6372 . -28) (f6371 . -24) (f6370 . -20) (f6372 . -16) (f6371 . -12) (f6370 . -8) (f6318 . 28) (f6320 . 24) (f6319 . 20) (f6321 . 16) (f6322 . 12) (f6323 . 8) (f6324 . 4) (f6317 . -28) (f6318 . -24) (f6319 . -20) (f6320 . -16) (f6321 . -12) (f6322 . -8) (f6323 . -4) (f6324 . 0))
# var=f6370
    movl -20(%esp), %eax  # stack load f6370
# end emit-variable-ref
    mov %eax, -36(%esp)    # arg f6370
# emit-expr f6371
# emit-variable-ref
# env=((f6372 . -28) (f6371 . -24) (f6370 . -20) (f6372 . -16) (f6371 . -12) (f6370 . -8) (f6318 . 28) (f6320 . 24) (f6319 . 20) (f6321 . 16) (f6322 . 12) (f6323 . 8) (f6324 . 4) (f6317 . -28) (f6318 . -24) (f6319 . -20) (f6320 . -16) (f6321 . -12) (f6322 . -8) (f6323 . -4) (f6324 . 0))
# var=f6371
    movl -24(%esp), %eax  # stack load f6371
# end emit-variable-ref
    mov %eax, -40(%esp)    # arg f6371
    movl -32(%esp), %edi   # load new closure to %edi
# emit-shift-args:  size=3   si=-32  delta=28
    mov -32(%esp), %ebx  # shift frame cell
    mov %ebx, -4(%esp)  # down to base
# emit-shift-args:  size=2   si=-36  delta=28
    mov -36(%esp), %ebx  # shift frame cell
    mov %ebx, -8(%esp)  # down to base
# emit-shift-args:  size=1   si=-40  delta=28
    mov -40(%esp), %ebx  # shift frame cell
    mov %ebx, -12(%esp)  # down to base
# emit-shift-args:  size=0   si=-44  delta=28
    movl $8,%eax   # save arg count
    jmp *-2(%edi)  # tail-funcall
_L_38674:
    jmp _L_38672
_L_38671:
# emit-tail-expr
# si=-32
# env=((f6372 . -28) (f6371 . -24) (f6370 . -20) (f6372 . -16) (f6371 . -12) (f6370 . -8) (f6318 . 28) (f6320 . 24) (f6319 . 20) (f6321 . 16) (f6322 . 12) (f6323 . 8) (f6324 . 4) (f6317 . -28) (f6318 . -24) (f6319 . -20) (f6320 . -16) (f6321 . -12) (f6322 . -8) (f6323 . -4) (f6324 . 0))
# expr=(if (pair? f6370) ((vector-ref f6318 0) f6370 f6371) ((primitive-ref error) ((primitive-ref string->symbol) "write") "unrecognized expression"))
# emit-expr (pair? f6370)
# emit-expr f6370
# emit-variable-ref
# env=((f6372 . -28) (f6371 . -24) (f6370 . -20) (f6372 . -16) (f6371 . -12) (f6370 . -8) (f6318 . 28) (f6320 . 24) (f6319 . 20) (f6321 . 16) (f6322 . 12) (f6323 . 8) (f6324 . 4) (f6317 . -28) (f6318 . -24) (f6319 . -20) (f6320 . -16) (f6321 . -12) (f6322 . -8) (f6323 . -4) (f6324 . 0))
# var=f6370
    movl -20(%esp), %eax  # stack load f6370
# end emit-variable-ref
    and $7, %al
    cmp $1, %al
    sete %al
    movzbl %al, %eax
    sal $6, %al
    or $47, %al
    cmp $47, %al
    je _L_38683
# emit-tail-expr
# si=-32
# env=((f6372 . -28) (f6371 . -24) (f6370 . -20) (f6372 . -16) (f6371 . -12) (f6370 . -8) (f6318 . 28) (f6320 . 24) (f6319 . 20) (f6321 . 16) (f6322 . 12) (f6323 . 8) (f6324 . 4) (f6317 . -28) (f6318 . -24) (f6319 . -20) (f6320 . -16) (f6321 . -12) (f6322 . -8) (f6323 . -4) (f6324 . 0))
# expr=((vector-ref f6318 0) f6370 f6371)
# emit-tail-funcall
#    si   =-32
#    env  = ((f6372 . -28) (f6371 . -24) (f6370 . -20) (f6372 . -16) (f6371 . -12) (f6370 . -8) (f6318 . 28) (f6320 . 24) (f6319 . 20) (f6321 . 16) (f6322 . 12) (f6323 . 8) (f6324 . 4) (f6317 . -28) (f6318 . -24) (f6319 . -20) (f6320 . -16) (f6321 . -12) (f6322 . -8) (f6323 . -4) (f6324 . 0))
#    expr = (funcall (vector-ref f6318 0) f6370 f6371)
# emit-expr (vector-ref f6318 0)
# emit-expr f6318
# emit-variable-ref
# env=((f6372 . -28) (f6371 . -24) (f6370 . -20) (f6372 . -16) (f6371 . -12) (f6370 . -8) (f6318 . 28) (f6320 . 24) (f6319 . 20) (f6321 . 16) (f6322 . 12) (f6323 . 8) (f6324 . 4) (f6317 . -28) (f6318 . -24) (f6319 . -20) (f6320 . -16) (f6321 . -12) (f6322 . -8) (f6323 . -4) (f6324 . 0))
# var=f6318
    movl 26(%edi), %eax  # frame load f6318
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_38685
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_38685:
    movl %eax, -32(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_38686"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_38686:
# check bounds on vector index
    movl -32(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_38688
    cmp  $0,%eax
    jge _L_38687
_L_38688:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_38687:
    movl -32(%esp), %esi
    movl -1(%eax,%esi), %eax
   movl %eax,  -32(%esp)  # stash funcall-oper in next closure slot
# emit-expr f6370
# emit-variable-ref
# env=((f6372 . -28) (f6371 . -24) (f6370 . -20) (f6372 . -16) (f6371 . -12) (f6370 . -8) (f6318 . 28) (f6320 . 24) (f6319 . 20) (f6321 . 16) (f6322 . 12) (f6323 . 8) (f6324 . 4) (f6317 . -28) (f6318 . -24) (f6319 . -20) (f6320 . -16) (f6321 . -12) (f6322 . -8) (f6323 . -4) (f6324 . 0))
# var=f6370
    movl -20(%esp), %eax  # stack load f6370
# end emit-variable-ref
    mov %eax, -36(%esp)    # arg f6370
# emit-expr f6371
# emit-variable-ref
# env=((f6372 . -28) (f6371 . -24) (f6370 . -20) (f6372 . -16) (f6371 . -12) (f6370 . -8) (f6318 . 28) (f6320 . 24) (f6319 . 20) (f6321 . 16) (f6322 . 12) (f6323 . 8) (f6324 . 4) (f6317 . -28) (f6318 . -24) (f6319 . -20) (f6320 . -16) (f6321 . -12) (f6322 . -8) (f6323 . -4) (f6324 . 0))
# var=f6371
    movl -24(%esp), %eax  # stack load f6371
# end emit-variable-ref
    mov %eax, -40(%esp)    # arg f6371
    movl -32(%esp), %edi   # load new closure to %edi
# emit-shift-args:  size=3   si=-32  delta=28
    mov -32(%esp), %ebx  # shift frame cell
    mov %ebx, -4(%esp)  # down to base
# emit-shift-args:  size=2   si=-36  delta=28
    mov -36(%esp), %ebx  # shift frame cell
    mov %ebx, -8(%esp)  # down to base
# emit-shift-args:  size=1   si=-40  delta=28
    mov -40(%esp), %ebx  # shift frame cell
    mov %ebx, -12(%esp)  # down to base
# emit-shift-args:  size=0   si=-44  delta=28
    movl $8,%eax   # save arg count
    jmp *-2(%edi)  # tail-funcall
    jmp _L_38684
_L_38683:
# emit-tail-expr
# si=-32
# env=((f6372 . -28) (f6371 . -24) (f6370 . -20) (f6372 . -16) (f6371 . -12) (f6370 . -8) (f6318 . 28) (f6320 . 24) (f6319 . 20) (f6321 . 16) (f6322 . 12) (f6323 . 8) (f6324 . 4) (f6317 . -28) (f6318 . -24) (f6319 . -20) (f6320 . -16) (f6321 . -12) (f6322 . -8) (f6323 . -4) (f6324 . 0))
# expr=((primitive-ref error) ((primitive-ref string->symbol) "write") "unrecognized expression")
# emit-tail-funcall
#    si   =-32
#    env  = ((f6372 . -28) (f6371 . -24) (f6370 . -20) (f6372 . -16) (f6371 . -12) (f6370 . -8) (f6318 . 28) (f6320 . 24) (f6319 . 20) (f6321 . 16) (f6322 . 12) (f6323 . 8) (f6324 . 4) (f6317 . -28) (f6318 . -24) (f6319 . -20) (f6320 . -16) (f6321 . -12) (f6322 . -8) (f6323 . -4) (f6324 . 0))
#    expr = (funcall (primitive-ref error) ((primitive-ref string->symbol) "write") "unrecognized expression")
# emit-expr (primitive-ref error)
    .extern mrc_error
    movl mrc_error,%eax
   movl %eax,  -32(%esp)  # stash funcall-oper in next closure slot
# emit-expr ((primitive-ref string->symbol) "write")
# funcall
#    si   =-36
#    env  = ((f6372 . -28) (f6371 . -24) (f6370 . -20) (f6372 . -16) (f6371 . -12) (f6370 . -8) (f6318 . 28) (f6320 . 24) (f6319 . 20) (f6321 . 16) (f6322 . 12) (f6323 . 8) (f6324 . 4) (f6317 . -28) (f6318 . -24) (f6319 . -20) (f6320 . -16) (f6321 . -12) (f6322 . -8) (f6323 . -4) (f6324 . 0))
#    expr = (funcall (primitive-ref string->symbol) "write")
# emit-expr (primitive-ref string->symbol)
    .extern mrc_string$m$gsymbol
    movl mrc_string$m$gsymbol,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_38689"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_38689":
   movl %eax,  -44(%esp)  # stash funcall-oper in closure slot
# emit-expr "write"
# string literal
    jmp _L_38691
    .align 8,0x90
_L_38690 :
    .int 20
    .ascii "write"
_L_38691:
    movl $_L_38690, %eax
    orl $6, %eax
    mov %eax, -48(%esp)  # arg write
    movl -44(%esp), %edi   # load new closure to %edi
    add $-36, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $36, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    mov %eax, -36(%esp)    # arg ((primitive-ref string->symbol) write)
# emit-expr "unrecognized expression"
# string literal
    jmp _L_38693
    .align 8,0x90
_L_38692 :
    .int 92
    .ascii "unrecognized expression"
_L_38693:
    movl $_L_38692, %eax
    orl $6, %eax
    mov %eax, -40(%esp)    # arg unrecognized expression
    movl -32(%esp), %edi   # load new closure to %edi
# emit-shift-args:  size=3   si=-32  delta=28
    mov -32(%esp), %ebx  # shift frame cell
    mov %ebx, -4(%esp)  # down to base
# emit-shift-args:  size=2   si=-36  delta=28
    mov -36(%esp), %ebx  # shift frame cell
    mov %ebx, -8(%esp)  # down to base
# emit-shift-args:  size=1   si=-40  delta=28
    mov -40(%esp), %ebx  # shift frame cell
    mov %ebx, -12(%esp)  # down to base
# emit-shift-args:  size=0   si=-44  delta=28
    movl $8,%eax   # save arg count
    jmp *-2(%edi)  # tail-funcall
_L_38684:
_L_38672:
_L_38666:
_L_38658:
_L_38652:
_L_38646:
    .align 4,0x90
_L_38643:
# emit-expr (begin)
# emit-begin
#   expr=(begin)
#   env=((f6317 . -28) (f6318 . -24) (f6319 . -20) (f6320 . -16) (f6321 . -12) (f6322 . -8) (f6323 . -4) (f6324 . 0))
     movl %eax, mrc_base$mwrite
# == explicit-begins  ==>
# (lambda (expr . args) (let ((p (if (null? args) (current-output-port) (car args)))) (base-write expr p #f)))
# == eliminate-let*  ==>
# (lambda (expr . args) (let ((p (if (null? args) (current-output-port) (car args)))) (base-write expr p #f)))
# == uniquify-variables  ==>
# (lambda (f6373 . f6374) (let ((f6376 (if (null? f6374) (current-output-port) (car f6374)))) (base-write f6373 f6376 #f)))
# == vectorize-letrec  ==>
# (lambda (f6373 . f6374) (let ((f6376 (if (null? f6374) (current-output-port) (car f6374)))) (base-write f6373 f6376 #f)))
# == eliminate-set!  ==>
# (lambda (f6373 . f6374) (let ((f6373 f6373)) (let ((f6376 (if (null? f6374) (current-output-port) (car f6374)))) (base-write f6373 f6376 #f))))
# == close-free-variables  ==>
# (closure (f6373 . f6374) () (let ((f6373 f6373)) (let ((f6376 (if (null? f6374) (current-output-port) (car f6374)))) (base-write f6373 f6376 #f))))
# == eliminate-quote  ==>
# (closure (f6373 . f6374) () (let ((f6373 f6373)) (let ((f6376 (if (null? f6374) (current-output-port) (car f6374)))) (base-write f6373 f6376 #f))))
# == eliminate-when/unless  ==>
# (closure (f6373 . f6374) () (let ((f6373 f6373)) (let ((f6376 (if (null? f6374) (current-output-port) (car f6374)))) (base-write f6373 f6376 #f))))
# == eliminate-cond  ==>
# (closure (f6373 . f6374) () (let ((f6373 f6373)) (let ((f6376 (if (null? f6374) (current-output-port) (car f6374)))) (base-write f6373 f6376 #f))))
# == external-symbols  ==>
# (closure (f6373 . f6374) () (let ((f6373 f6373)) (let ((f6376 (if (null? f6374) ((primitive-ref current-output-port)) (car f6374)))) ((primitive-ref base-write) f6373 f6376 #f))))
# emit-expr (closure (f6373 . f6374) () (let ((f6373 f6373)) (let ((f6376 (if (null? f6374) ((primitive-ref current-output-port)) (car f6374)))) ((primitive-ref base-write) f6373 f6376 #f))))
# emit-closure
# si = 0
# env = ()
# expr = (closure (f6373 . f6374) () (let ((f6373 f6373)) (let ((f6376 (if (null? f6374) ((primitive-ref current-output-port)) (car f6374)))) ((primitive-ref base-write) f6373 f6376 #f))))
    movl $_L_38694, 0(%ebp)  # closure label
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $8, %ebp     # bump ebp
    jmp _L_38695            # jump around closure body
_L_38694:
# check argument count
    cmp $4,%eax
    jge _L_38696
# invoke error handler eh_argcount_min
    .extern mrc_eh$uargcount$umin
    movl mrc_eh$uargcount$umin, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_38696:
# emit-build-varargs-list
    movl $63, %esi       # args <- () 
    lea -4(%esp),%edi    # edi <- esp-4
    subl %eax, %edi      # edi <- esp-4-eax    addr of arg[K+N] on stack
_L_38698:
    lea -8(%esp),%ebx    # addr of arg[K] on stack
    cmp %edi, %ebx       # while edi <> esp+(si+4)
    je _L_38697
    movl (%edi),%ebx     # arg i -> car
    movl %ebx, 0(%ebp)
    movl %esi, 4(%ebp)  # esi -> cdr
    movl %ebp, %esi
    addl $1, %esi       # tag as pair
    addl $8,%ebp         # bump heap ptr
    addl $4,%edi         # move to next previous arg from the end
    jmp _L_38698
_L_38697:
    movl %esi, -12(%esp)  # set args
# emit-tail-expr
# si=-16
# env=((f6374 . -12) (f6373 . -8))
# expr=(let ((f6373 f6373)) (let ((f6376 (if (null? f6374) ((primitive-ref current-output-port)) (car f6374)))) ((primitive-ref base-write) f6373 f6376 #f)))
# emit-tail-let
#  si   = -16
#  env  = ((f6374 . -12) (f6373 . -8))
#  bindings = ((f6373 f6373))
#  body = (let ((f6376 (if (null? f6374) ((primitive-ref current-output-port)) (car f6374)))) ((primitive-ref base-write) f6373 f6376 #f))
# emit-expr f6373
# emit-variable-ref
# env=((f6374 . -12) (f6373 . -8))
# var=f6373
    movl -8(%esp), %eax  # stack load f6373
# end emit-variable-ref
    movl %eax, -16(%esp)  # stack save
# emit-tail-expr
# si=-20
# env=((f6373 . -16) (f6374 . -12) (f6373 . -8))
# expr=(let ((f6376 (if (null? f6374) ((primitive-ref current-output-port)) (car f6374)))) ((primitive-ref base-write) f6373 f6376 #f))
# emit-tail-let
#  si   = -20
#  env  = ((f6373 . -16) (f6374 . -12) (f6373 . -8))
#  bindings = ((f6376 (if (null? f6374) ((primitive-ref current-output-port)) (car f6374))))
#  body = ((primitive-ref base-write) f6373 f6376 #f)
# emit-expr (if (null? f6374) ((primitive-ref current-output-port)) (car f6374))
# emit-expr (null? f6374)
# emit-expr f6374
# emit-variable-ref
# env=((f6373 . -16) (f6374 . -12) (f6373 . -8))
# var=f6374
    movl -12(%esp), %eax  # stack load f6374
# end emit-variable-ref
    cmp $63, %eax
    mov $0, %eax
    sete %al
    movzbl %al, %eax
    sal $6, %al
    or $47, %al
    cmp $47, %al
    je _L_38699
# emit-expr ((primitive-ref current-output-port))
# funcall
#    si   =-20
#    env  = ((f6373 . -16) (f6374 . -12) (f6373 . -8))
#    expr = (funcall (primitive-ref current-output-port))
# emit-expr (primitive-ref current-output-port)
    .extern mrc_current$moutput$mport
    movl mrc_current$moutput$mport,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_38701"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_38701":
   movl %eax,  -28(%esp)  # stash funcall-oper in closure slot
    movl -28(%esp), %edi   # load new closure to %edi
    add $-20, %esp   # adjust base
    movl $0,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $20, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    jmp _L_38700
_L_38699:
# emit-expr (car f6374)
# emit-expr f6374
# emit-variable-ref
# env=((f6373 . -16) (f6374 . -12) (f6373 . -8))
# var=f6374
    movl -12(%esp), %eax  # stack load f6374
# end emit-variable-ref
# check the argument is a pair
    movl %eax,%ebx
    and $7, %bl
    cmp $1, %bl
    je _L_38702
# invoke error handler eh_pair
    .extern mrc_eh$upair
    movl mrc_eh$upair, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $116,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_38702:
    movl -1(%eax), %eax
_L_38700:
    movl %eax, -20(%esp)  # stack save
# emit-tail-expr
# si=-24
# env=((f6376 . -20) (f6373 . -16) (f6374 . -12) (f6373 . -8))
# expr=((primitive-ref base-write) f6373 f6376 #f)
# emit-tail-funcall
#    si   =-24
#    env  = ((f6376 . -20) (f6373 . -16) (f6374 . -12) (f6373 . -8))
#    expr = (funcall (primitive-ref base-write) f6373 f6376 #f)
# emit-expr (primitive-ref base-write)
    .extern mrc_base$mwrite
    movl mrc_base$mwrite,%eax
   movl %eax,  -24(%esp)  # stash funcall-oper in next closure slot
# emit-expr f6373
# emit-variable-ref
# env=((f6376 . -20) (f6373 . -16) (f6374 . -12) (f6373 . -8))
# var=f6373
    movl -16(%esp), %eax  # stack load f6373
# end emit-variable-ref
    mov %eax, -28(%esp)    # arg f6373
# emit-expr f6376
# emit-variable-ref
# env=((f6376 . -20) (f6373 . -16) (f6374 . -12) (f6373 . -8))
# var=f6376
    movl -20(%esp), %eax  # stack load f6376
# end emit-variable-ref
    mov %eax, -32(%esp)    # arg f6376
# emit-expr #f
    movl $47, %eax     # immed #f
    mov %eax, -36(%esp)    # arg #f
    movl -24(%esp), %edi   # load new closure to %edi
# emit-shift-args:  size=4   si=-24  delta=20
    mov -24(%esp), %ebx  # shift frame cell
    mov %ebx, -4(%esp)  # down to base
# emit-shift-args:  size=3   si=-28  delta=20
    mov -28(%esp), %ebx  # shift frame cell
    mov %ebx, -8(%esp)  # down to base
# emit-shift-args:  size=2   si=-32  delta=20
    mov -32(%esp), %ebx  # shift frame cell
    mov %ebx, -12(%esp)  # down to base
# emit-shift-args:  size=1   si=-36  delta=20
    mov -36(%esp), %ebx  # shift frame cell
    mov %ebx, -16(%esp)  # down to base
# emit-shift-args:  size=0   si=-40  delta=20
    movl $12,%eax   # save arg count
    jmp *-2(%edi)  # tail-funcall
    .align 4,0x90
_L_38695:
     movl %eax, mrc_write
# == explicit-begins  ==>
# (lambda (expr . args) (let ((p (if (null? args) (current-output-port) (car args)))) (base-write expr p #t)))
# == eliminate-let*  ==>
# (lambda (expr . args) (let ((p (if (null? args) (current-output-port) (car args)))) (base-write expr p #t)))
# == uniquify-variables  ==>
# (lambda (f6377 . f6378) (let ((f6380 (if (null? f6378) (current-output-port) (car f6378)))) (base-write f6377 f6380 #t)))
# == vectorize-letrec  ==>
# (lambda (f6377 . f6378) (let ((f6380 (if (null? f6378) (current-output-port) (car f6378)))) (base-write f6377 f6380 #t)))
# == eliminate-set!  ==>
# (lambda (f6377 . f6378) (let ((f6377 f6377)) (let ((f6380 (if (null? f6378) (current-output-port) (car f6378)))) (base-write f6377 f6380 #t))))
# == close-free-variables  ==>
# (closure (f6377 . f6378) () (let ((f6377 f6377)) (let ((f6380 (if (null? f6378) (current-output-port) (car f6378)))) (base-write f6377 f6380 #t))))
# == eliminate-quote  ==>
# (closure (f6377 . f6378) () (let ((f6377 f6377)) (let ((f6380 (if (null? f6378) (current-output-port) (car f6378)))) (base-write f6377 f6380 #t))))
# == eliminate-when/unless  ==>
# (closure (f6377 . f6378) () (let ((f6377 f6377)) (let ((f6380 (if (null? f6378) (current-output-port) (car f6378)))) (base-write f6377 f6380 #t))))
# == eliminate-cond  ==>
# (closure (f6377 . f6378) () (let ((f6377 f6377)) (let ((f6380 (if (null? f6378) (current-output-port) (car f6378)))) (base-write f6377 f6380 #t))))
# == external-symbols  ==>
# (closure (f6377 . f6378) () (let ((f6377 f6377)) (let ((f6380 (if (null? f6378) ((primitive-ref current-output-port)) (car f6378)))) ((primitive-ref base-write) f6377 f6380 #t))))
# emit-expr (closure (f6377 . f6378) () (let ((f6377 f6377)) (let ((f6380 (if (null? f6378) ((primitive-ref current-output-port)) (car f6378)))) ((primitive-ref base-write) f6377 f6380 #t))))
# emit-closure
# si = 0
# env = ()
# expr = (closure (f6377 . f6378) () (let ((f6377 f6377)) (let ((f6380 (if (null? f6378) ((primitive-ref current-output-port)) (car f6378)))) ((primitive-ref base-write) f6377 f6380 #t))))
    movl $_L_38703, 0(%ebp)  # closure label
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $8, %ebp     # bump ebp
    jmp _L_38704            # jump around closure body
_L_38703:
# check argument count
    cmp $4,%eax
    jge _L_38705
# invoke error handler eh_argcount_min
    .extern mrc_eh$uargcount$umin
    movl mrc_eh$uargcount$umin, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_38705:
# emit-build-varargs-list
    movl $63, %esi       # args <- () 
    lea -4(%esp),%edi    # edi <- esp-4
    subl %eax, %edi      # edi <- esp-4-eax    addr of arg[K+N] on stack
_L_38707:
    lea -8(%esp),%ebx    # addr of arg[K] on stack
    cmp %edi, %ebx       # while edi <> esp+(si+4)
    je _L_38706
    movl (%edi),%ebx     # arg i -> car
    movl %ebx, 0(%ebp)
    movl %esi, 4(%ebp)  # esi -> cdr
    movl %ebp, %esi
    addl $1, %esi       # tag as pair
    addl $8,%ebp         # bump heap ptr
    addl $4,%edi         # move to next previous arg from the end
    jmp _L_38707
_L_38706:
    movl %esi, -12(%esp)  # set args
# emit-tail-expr
# si=-16
# env=((f6378 . -12) (f6377 . -8))
# expr=(let ((f6377 f6377)) (let ((f6380 (if (null? f6378) ((primitive-ref current-output-port)) (car f6378)))) ((primitive-ref base-write) f6377 f6380 #t)))
# emit-tail-let
#  si   = -16
#  env  = ((f6378 . -12) (f6377 . -8))
#  bindings = ((f6377 f6377))
#  body = (let ((f6380 (if (null? f6378) ((primitive-ref current-output-port)) (car f6378)))) ((primitive-ref base-write) f6377 f6380 #t))
# emit-expr f6377
# emit-variable-ref
# env=((f6378 . -12) (f6377 . -8))
# var=f6377
    movl -8(%esp), %eax  # stack load f6377
# end emit-variable-ref
    movl %eax, -16(%esp)  # stack save
# emit-tail-expr
# si=-20
# env=((f6377 . -16) (f6378 . -12) (f6377 . -8))
# expr=(let ((f6380 (if (null? f6378) ((primitive-ref current-output-port)) (car f6378)))) ((primitive-ref base-write) f6377 f6380 #t))
# emit-tail-let
#  si   = -20
#  env  = ((f6377 . -16) (f6378 . -12) (f6377 . -8))
#  bindings = ((f6380 (if (null? f6378) ((primitive-ref current-output-port)) (car f6378))))
#  body = ((primitive-ref base-write) f6377 f6380 #t)
# emit-expr (if (null? f6378) ((primitive-ref current-output-port)) (car f6378))
# emit-expr (null? f6378)
# emit-expr f6378
# emit-variable-ref
# env=((f6377 . -16) (f6378 . -12) (f6377 . -8))
# var=f6378
    movl -12(%esp), %eax  # stack load f6378
# end emit-variable-ref
    cmp $63, %eax
    mov $0, %eax
    sete %al
    movzbl %al, %eax
    sal $6, %al
    or $47, %al
    cmp $47, %al
    je _L_38708
# emit-expr ((primitive-ref current-output-port))
# funcall
#    si   =-20
#    env  = ((f6377 . -16) (f6378 . -12) (f6377 . -8))
#    expr = (funcall (primitive-ref current-output-port))
# emit-expr (primitive-ref current-output-port)
    .extern mrc_current$moutput$mport
    movl mrc_current$moutput$mport,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_38710"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_38710":
   movl %eax,  -28(%esp)  # stash funcall-oper in closure slot
    movl -28(%esp), %edi   # load new closure to %edi
    add $-20, %esp   # adjust base
    movl $0,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $20, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    jmp _L_38709
_L_38708:
# emit-expr (car f6378)
# emit-expr f6378
# emit-variable-ref
# env=((f6377 . -16) (f6378 . -12) (f6377 . -8))
# var=f6378
    movl -12(%esp), %eax  # stack load f6378
# end emit-variable-ref
# check the argument is a pair
    movl %eax,%ebx
    and $7, %bl
    cmp $1, %bl
    je _L_38711
# invoke error handler eh_pair
    .extern mrc_eh$upair
    movl mrc_eh$upair, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $116,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_38711:
    movl -1(%eax), %eax
_L_38709:
    movl %eax, -20(%esp)  # stack save
# emit-tail-expr
# si=-24
# env=((f6380 . -20) (f6377 . -16) (f6378 . -12) (f6377 . -8))
# expr=((primitive-ref base-write) f6377 f6380 #t)
# emit-tail-funcall
#    si   =-24
#    env  = ((f6380 . -20) (f6377 . -16) (f6378 . -12) (f6377 . -8))
#    expr = (funcall (primitive-ref base-write) f6377 f6380 #t)
# emit-expr (primitive-ref base-write)
    .extern mrc_base$mwrite
    movl mrc_base$mwrite,%eax
   movl %eax,  -24(%esp)  # stash funcall-oper in next closure slot
# emit-expr f6377
# emit-variable-ref
# env=((f6380 . -20) (f6377 . -16) (f6378 . -12) (f6377 . -8))
# var=f6377
    movl -16(%esp), %eax  # stack load f6377
# end emit-variable-ref
    mov %eax, -28(%esp)    # arg f6377
# emit-expr f6380
# emit-variable-ref
# env=((f6380 . -20) (f6377 . -16) (f6378 . -12) (f6377 . -8))
# var=f6380
    movl -20(%esp), %eax  # stack load f6380
# end emit-variable-ref
    mov %eax, -32(%esp)    # arg f6380
# emit-expr #t
    movl $111, %eax     # immed #t
    mov %eax, -36(%esp)    # arg #t
    movl -24(%esp), %edi   # load new closure to %edi
# emit-shift-args:  size=4   si=-24  delta=20
    mov -24(%esp), %ebx  # shift frame cell
    mov %ebx, -4(%esp)  # down to base
# emit-shift-args:  size=3   si=-28  delta=20
    mov -28(%esp), %ebx  # shift frame cell
    mov %ebx, -8(%esp)  # down to base
# emit-shift-args:  size=2   si=-32  delta=20
    mov -32(%esp), %ebx  # shift frame cell
    mov %ebx, -12(%esp)  # down to base
# emit-shift-args:  size=1   si=-36  delta=20
    mov -36(%esp), %ebx  # shift frame cell
    mov %ebx, -16(%esp)  # down to base
# emit-shift-args:  size=0   si=-40  delta=20
    movl $12,%eax   # save arg count
    jmp *-2(%edi)  # tail-funcall
    .align 4,0x90
_L_38704:
     movl %eax, mrc_display
# == explicit-begins  ==>
# (lambda (i) (fixnum->char i))
# == eliminate-let*  ==>
# (lambda (i) (fixnum->char i))
# == uniquify-variables  ==>
# (lambda (f6381) (fixnum->char f6381))
# == vectorize-letrec  ==>
# (lambda (f6381) (fixnum->char f6381))
# == eliminate-set!  ==>
# (lambda (f6381) (let ((f6381 f6381)) (fixnum->char f6381)))
# == close-free-variables  ==>
# (closure (f6381) () (let ((f6381 f6381)) (fixnum->char f6381)))
# == eliminate-quote  ==>
# (closure (f6381) () (let ((f6381 f6381)) (fixnum->char f6381)))
# == eliminate-when/unless  ==>
# (closure (f6381) () (let ((f6381 f6381)) (fixnum->char f6381)))
# == eliminate-cond  ==>
# (closure (f6381) () (let ((f6381 f6381)) (fixnum->char f6381)))
# == external-symbols  ==>
# (closure (f6381) () (let ((f6381 f6381)) (fixnum->char f6381)))
# emit-expr (closure (f6381) () (let ((f6381 f6381)) (fixnum->char f6381)))
# emit-closure
# si = 0
# env = ()
# expr = (closure (f6381) () (let ((f6381 f6381)) (fixnum->char f6381)))
    movl $_L_38712, 0(%ebp)  # closure label
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $8, %ebp     # bump ebp
    jmp _L_38713            # jump around closure body
_L_38712:
# check argument count
    cmp $4,%eax
    je _L_38714
# invoke error handler eh_argcount
    .extern mrc_eh$uargcount
    movl mrc_eh$uargcount, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_38714:
# emit-tail-expr
# si=-12
# env=((f6381 . -8))
# expr=(let ((f6381 f6381)) (fixnum->char f6381))
# emit-tail-let
#  si   = -12
#  env  = ((f6381 . -8))
#  bindings = ((f6381 f6381))
#  body = (fixnum->char f6381)
# emit-expr f6381
# emit-variable-ref
# env=((f6381 . -8))
# var=f6381
    movl -8(%esp), %eax  # stack load f6381
# end emit-variable-ref
    movl %eax, -12(%esp)  # stack save
# emit-tail-expr
# si=-16
# env=((f6381 . -12) (f6381 . -8))
# expr=(fixnum->char f6381)
# tail primcall
# emit-expr f6381
# emit-variable-ref
# env=((f6381 . -12) (f6381 . -8))
# var=f6381
    movl -12(%esp), %eax  # stack load f6381
# end emit-variable-ref
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_38715"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $0,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_38715:
    shll $6, %eax
    orl $15, %eax
#return from tail (fixnum->char f6381)
    ret
    .align 4,0x90
_L_38713:
     movl %eax, mrc_integer$m$gchar
# == explicit-begins  ==>
# (let* ((p (make-vector 8)) (sz 1024)) (begin (vector-set! p 0 (quote input-port)) (vector-set! p 1 "/dev/stdin") (vector-set! p 2 0) (vector-set! p 3 (make-string sz)) (vector-set! p 4 0) (vector-set! p 5 sz) (vector-set! p 6 #f) (vector-set! p 7 -1) p))
# == eliminate-let*  ==>
# (let ((p (make-vector 8))) (let ((sz 1024)) (begin (vector-set! p 0 (quote input-port)) (vector-set! p 1 "/dev/stdin") (vector-set! p 2 0) (vector-set! p 3 (make-string sz)) (vector-set! p 4 0) (vector-set! p 5 sz) (vector-set! p 6 #f) (vector-set! p 7 -1) p)))
# == uniquify-variables  ==>
# (let ((f6382 (make-vector 8))) (let ((f6384 1024)) (begin (vector-set! f6382 0 (quote input-port)) (vector-set! f6382 1 "/dev/stdin") (vector-set! f6382 2 0) (vector-set! f6382 3 (make-string f6384)) (vector-set! f6382 4 0) (vector-set! f6382 5 f6384) (vector-set! f6382 6 #f) (vector-set! f6382 7 -1) f6382)))
# == vectorize-letrec  ==>
# (let ((f6382 (make-vector 8))) (let ((f6384 1024)) (begin (vector-set! f6382 0 (quote input-port)) (vector-set! f6382 1 "/dev/stdin") (vector-set! f6382 2 0) (vector-set! f6382 3 (make-string f6384)) (vector-set! f6382 4 0) (vector-set! f6382 5 f6384) (vector-set! f6382 6 #f) (vector-set! f6382 7 -1) f6382)))
# == eliminate-set!  ==>
# (let ((f6382 (make-vector 8))) (let ((f6384 1024)) (begin (vector-set! f6382 0 (quote input-port)) (vector-set! f6382 1 "/dev/stdin") (vector-set! f6382 2 0) (vector-set! f6382 3 (make-string f6384)) (vector-set! f6382 4 0) (vector-set! f6382 5 f6384) (vector-set! f6382 6 #f) (vector-set! f6382 7 -1) f6382)))
# == close-free-variables  ==>
# (let ((f6382 (make-vector 8))) (let ((f6384 1024)) (begin (vector-set! f6382 0 (quote input-port)) (vector-set! f6382 1 "/dev/stdin") (vector-set! f6382 2 0) (vector-set! f6382 3 (make-string f6384)) (vector-set! f6382 4 0) (vector-set! f6382 5 f6384) (vector-set! f6382 6 #f) (vector-set! f6382 7 -1) f6382)))
# == eliminate-quote  ==>
# (let ((f6382 (make-vector 8))) (let ((f6384 1024)) (begin (vector-set! f6382 0 (string->symbol "input-port")) (vector-set! f6382 1 "/dev/stdin") (vector-set! f6382 2 0) (vector-set! f6382 3 (make-string f6384)) (vector-set! f6382 4 0) (vector-set! f6382 5 f6384) (vector-set! f6382 6 #f) (vector-set! f6382 7 -1) f6382)))
# == eliminate-when/unless  ==>
# (let ((f6382 (make-vector 8))) (let ((f6384 1024)) (begin (vector-set! f6382 0 (string->symbol "input-port")) (vector-set! f6382 1 "/dev/stdin") (vector-set! f6382 2 0) (vector-set! f6382 3 (make-string f6384)) (vector-set! f6382 4 0) (vector-set! f6382 5 f6384) (vector-set! f6382 6 #f) (vector-set! f6382 7 -1) f6382)))
# == eliminate-cond  ==>
# (let ((f6382 (make-vector 8))) (let ((f6384 1024)) (begin (vector-set! f6382 0 (string->symbol "input-port")) (vector-set! f6382 1 "/dev/stdin") (vector-set! f6382 2 0) (vector-set! f6382 3 (make-string f6384)) (vector-set! f6382 4 0) (vector-set! f6382 5 f6384) (vector-set! f6382 6 #f) (vector-set! f6382 7 -1) f6382)))
# == external-symbols  ==>
# (let ((f6382 (make-vector 8))) (let ((f6384 1024)) (begin (vector-set! f6382 0 ((primitive-ref string->symbol) "input-port")) (vector-set! f6382 1 "/dev/stdin") (vector-set! f6382 2 0) (vector-set! f6382 3 (make-string f6384)) (vector-set! f6382 4 0) (vector-set! f6382 5 f6384) (vector-set! f6382 6 #f) (vector-set! f6382 7 -1) f6382)))
# emit-expr (let ((f6382 (make-vector 8))) (let ((f6384 1024)) (begin (vector-set! f6382 0 ((primitive-ref string->symbol) "input-port")) (vector-set! f6382 1 "/dev/stdin") (vector-set! f6382 2 0) (vector-set! f6382 3 (make-string f6384)) (vector-set! f6382 4 0) (vector-set! f6382 5 f6384) (vector-set! f6382 6 #f) (vector-set! f6382 7 -1) f6382)))
# emit-let
#  si   = 0
#  env  = ()
#  bindings = ((f6382 (make-vector 8)))
#  body = (let ((f6384 1024)) (begin (vector-set! f6382 0 ((primitive-ref string->symbol) "input-port")) (vector-set! f6382 1 "/dev/stdin") (vector-set! f6382 2 0) (vector-set! f6382 3 (make-string f6384)) (vector-set! f6382 4 0) (vector-set! f6382 5 f6384) (vector-set! f6382 6 #f) (vector-set! f6382 7 -1) f6382))
# emit-expr (make-vector 8)
# make-vector 8
# emit-expr 8
    movl $32, %eax     # immed 8
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_38716"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_38716:
# check the argument is a fixnum >= 0
    cmp $0,%eax
    jge _L_38717
# invoke error handler eh_length
    .extern mrc_eh$ulength
    movl mrc_eh$ulength, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_38717:
    movl %eax, %esi
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    orl  $5, %eax
    addl $4, %esi
    addl $4, %esi
    andl $-8, %esi
    addl %esi, %ebp
    movl %eax, 0(%esp)  # stack save
# emit-expr (let ((f6384 1024)) (begin (vector-set! f6382 0 ((primitive-ref string->symbol) "input-port")) (vector-set! f6382 1 "/dev/stdin") (vector-set! f6382 2 0) (vector-set! f6382 3 (make-string f6384)) (vector-set! f6382 4 0) (vector-set! f6382 5 f6384) (vector-set! f6382 6 #f) (vector-set! f6382 7 -1) f6382))
# emit-let
#  si   = -4
#  env  = ((f6382 . 0))
#  bindings = ((f6384 1024))
#  body = (begin (vector-set! f6382 0 ((primitive-ref string->symbol) "input-port")) (vector-set! f6382 1 "/dev/stdin") (vector-set! f6382 2 0) (vector-set! f6382 3 (make-string f6384)) (vector-set! f6382 4 0) (vector-set! f6382 5 f6384) (vector-set! f6382 6 #f) (vector-set! f6382 7 -1) f6382)
# emit-expr 1024
    movl $4096, %eax     # immed 1024
    movl %eax, -4(%esp)  # stack save
# emit-expr (begin (vector-set! f6382 0 ((primitive-ref string->symbol) "input-port")) (vector-set! f6382 1 "/dev/stdin") (vector-set! f6382 2 0) (vector-set! f6382 3 (make-string f6384)) (vector-set! f6382 4 0) (vector-set! f6382 5 f6384) (vector-set! f6382 6 #f) (vector-set! f6382 7 -1) f6382)
# emit-begin
#   expr=(begin (vector-set! f6382 0 ((primitive-ref string->symbol) "input-port")) (vector-set! f6382 1 "/dev/stdin") (vector-set! f6382 2 0) (vector-set! f6382 3 (make-string f6384)) (vector-set! f6382 4 0) (vector-set! f6382 5 f6384) (vector-set! f6382 6 #f) (vector-set! f6382 7 -1) f6382)
#   env=((f6384 . -4) (f6382 . 0))
# emit-expr (vector-set! f6382 0 ((primitive-ref string->symbol) "input-port"))
# emit-expr f6382
# emit-variable-ref
# env=((f6384 . -4) (f6382 . 0))
# var=f6382
    movl 0(%esp), %eax  # stack load f6382
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_38718
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_38718:
    movl %eax, -8(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_38719"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_38719:
# check bounds on vector index
    movl -8(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_38721
    cmp  $0,%eax
    jge _L_38720
_L_38721:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_38720:
    movl %eax, -12(%esp)
# emit-expr ((primitive-ref string->symbol) "input-port")
# funcall
#    si   =-16
#    env  = ((f6384 . -4) (f6382 . 0))
#    expr = (funcall (primitive-ref string->symbol) "input-port")
# emit-expr (primitive-ref string->symbol)
    .extern mrc_string$m$gsymbol
    movl mrc_string$m$gsymbol,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_38722"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_38722":
   movl %eax,  -24(%esp)  # stash funcall-oper in closure slot
# emit-expr "input-port"
# string literal
    jmp _L_38724
    .align 8,0x90
_L_38723 :
    .int 40
    .ascii "input-port"
_L_38724:
    movl $_L_38723, %eax
    orl $6, %eax
    mov %eax, -28(%esp)  # arg input-port
    movl -24(%esp), %edi   # load new closure to %edi
    add $-16, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $16, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    movl -8(%esp), %ebx
    movl -12(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin (vector-set! f6382 1 "/dev/stdin") (vector-set! f6382 2 0) (vector-set! f6382 3 (make-string f6384)) (vector-set! f6382 4 0) (vector-set! f6382 5 f6384) (vector-set! f6382 6 #f) (vector-set! f6382 7 -1) f6382)
# emit-begin
#   expr=(begin (vector-set! f6382 1 "/dev/stdin") (vector-set! f6382 2 0) (vector-set! f6382 3 (make-string f6384)) (vector-set! f6382 4 0) (vector-set! f6382 5 f6384) (vector-set! f6382 6 #f) (vector-set! f6382 7 -1) f6382)
#   env=((f6384 . -4) (f6382 . 0))
# emit-expr (vector-set! f6382 1 "/dev/stdin")
# emit-expr f6382
# emit-variable-ref
# env=((f6384 . -4) (f6382 . 0))
# var=f6382
    movl 0(%esp), %eax  # stack load f6382
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_38725
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_38725:
    movl %eax, -8(%esp)
# emit-expr 1
    movl $4, %eax     # immed 1
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_38726"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_38726:
# check bounds on vector index
    movl -8(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_38728
    cmp  $0,%eax
    jge _L_38727
_L_38728:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_38727:
    movl %eax, -12(%esp)
# emit-expr "/dev/stdin"
# string literal
    jmp _L_38730
    .align 8,0x90
_L_38729 :
    .int 40
    .ascii "/dev/stdin"
_L_38730:
    movl $_L_38729, %eax
    orl $6, %eax
    movl -8(%esp), %ebx
    movl -12(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin (vector-set! f6382 2 0) (vector-set! f6382 3 (make-string f6384)) (vector-set! f6382 4 0) (vector-set! f6382 5 f6384) (vector-set! f6382 6 #f) (vector-set! f6382 7 -1) f6382)
# emit-begin
#   expr=(begin (vector-set! f6382 2 0) (vector-set! f6382 3 (make-string f6384)) (vector-set! f6382 4 0) (vector-set! f6382 5 f6384) (vector-set! f6382 6 #f) (vector-set! f6382 7 -1) f6382)
#   env=((f6384 . -4) (f6382 . 0))
# emit-expr (vector-set! f6382 2 0)
# emit-expr f6382
# emit-variable-ref
# env=((f6384 . -4) (f6382 . 0))
# var=f6382
    movl 0(%esp), %eax  # stack load f6382
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_38731
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_38731:
    movl %eax, -8(%esp)
# emit-expr 2
    movl $8, %eax     # immed 2
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_38732"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_38732:
# check bounds on vector index
    movl -8(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_38734
    cmp  $0,%eax
    jge _L_38733
_L_38734:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_38733:
    movl %eax, -12(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
    movl -8(%esp), %ebx
    movl -12(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin (vector-set! f6382 3 (make-string f6384)) (vector-set! f6382 4 0) (vector-set! f6382 5 f6384) (vector-set! f6382 6 #f) (vector-set! f6382 7 -1) f6382)
# emit-begin
#   expr=(begin (vector-set! f6382 3 (make-string f6384)) (vector-set! f6382 4 0) (vector-set! f6382 5 f6384) (vector-set! f6382 6 #f) (vector-set! f6382 7 -1) f6382)
#   env=((f6384 . -4) (f6382 . 0))
# emit-expr (vector-set! f6382 3 (make-string f6384))
# emit-expr f6382
# emit-variable-ref
# env=((f6384 . -4) (f6382 . 0))
# var=f6382
    movl 0(%esp), %eax  # stack load f6382
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_38735
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_38735:
    movl %eax, -8(%esp)
# emit-expr 3
    movl $12, %eax     # immed 3
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_38736"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_38736:
# check bounds on vector index
    movl -8(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_38738
    cmp  $0,%eax
    jge _L_38737
_L_38738:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_38737:
    movl %eax, -12(%esp)
# emit-expr (make-string f6384)
# make-string len=f6384
# emit-expr f6384
# emit-variable-ref
# env=((f6384 . -4) (f6382 . 0))
# var=f6384
    movl -4(%esp), %eax  # stack load f6384
# end emit-variable-ref
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_38739"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $152,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_38739:
# check the argument is a fixnum >= 0
    cmp $0,%eax
    jge _L_38740
# invoke error handler eh_length
    .extern mrc_eh$ulength
    movl mrc_eh$ulength, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $152,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_38740:
    movl %eax, %esi
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    orl $6, %eax
    sar $2, %esi
    add $4, %esi
    add $7, %esi
    andl $-8, %esi
    add  %esi, %ebp
# make-string end
    movl -8(%esp), %ebx
    movl -12(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin (vector-set! f6382 4 0) (vector-set! f6382 5 f6384) (vector-set! f6382 6 #f) (vector-set! f6382 7 -1) f6382)
# emit-begin
#   expr=(begin (vector-set! f6382 4 0) (vector-set! f6382 5 f6384) (vector-set! f6382 6 #f) (vector-set! f6382 7 -1) f6382)
#   env=((f6384 . -4) (f6382 . 0))
# emit-expr (vector-set! f6382 4 0)
# emit-expr f6382
# emit-variable-ref
# env=((f6384 . -4) (f6382 . 0))
# var=f6382
    movl 0(%esp), %eax  # stack load f6382
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_38741
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_38741:
    movl %eax, -8(%esp)
# emit-expr 4
    movl $16, %eax     # immed 4
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_38742"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_38742:
# check bounds on vector index
    movl -8(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_38744
    cmp  $0,%eax
    jge _L_38743
_L_38744:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_38743:
    movl %eax, -12(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
    movl -8(%esp), %ebx
    movl -12(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin (vector-set! f6382 5 f6384) (vector-set! f6382 6 #f) (vector-set! f6382 7 -1) f6382)
# emit-begin
#   expr=(begin (vector-set! f6382 5 f6384) (vector-set! f6382 6 #f) (vector-set! f6382 7 -1) f6382)
#   env=((f6384 . -4) (f6382 . 0))
# emit-expr (vector-set! f6382 5 f6384)
# emit-expr f6382
# emit-variable-ref
# env=((f6384 . -4) (f6382 . 0))
# var=f6382
    movl 0(%esp), %eax  # stack load f6382
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_38745
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_38745:
    movl %eax, -8(%esp)
# emit-expr 5
    movl $20, %eax     # immed 5
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_38746"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_38746:
# check bounds on vector index
    movl -8(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_38748
    cmp  $0,%eax
    jge _L_38747
_L_38748:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_38747:
    movl %eax, -12(%esp)
# emit-expr f6384
# emit-variable-ref
# env=((f6384 . -4) (f6382 . 0))
# var=f6384
    movl -4(%esp), %eax  # stack load f6384
# end emit-variable-ref
    movl -8(%esp), %ebx
    movl -12(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin (vector-set! f6382 6 #f) (vector-set! f6382 7 -1) f6382)
# emit-begin
#   expr=(begin (vector-set! f6382 6 #f) (vector-set! f6382 7 -1) f6382)
#   env=((f6384 . -4) (f6382 . 0))
# emit-expr (vector-set! f6382 6 #f)
# emit-expr f6382
# emit-variable-ref
# env=((f6384 . -4) (f6382 . 0))
# var=f6382
    movl 0(%esp), %eax  # stack load f6382
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_38749
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_38749:
    movl %eax, -8(%esp)
# emit-expr 6
    movl $24, %eax     # immed 6
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_38750"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_38750:
# check bounds on vector index
    movl -8(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_38752
    cmp  $0,%eax
    jge _L_38751
_L_38752:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_38751:
    movl %eax, -12(%esp)
# emit-expr #f
    movl $47, %eax     # immed #f
    movl -8(%esp), %ebx
    movl -12(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin (vector-set! f6382 7 -1) f6382)
# emit-begin
#   expr=(begin (vector-set! f6382 7 -1) f6382)
#   env=((f6384 . -4) (f6382 . 0))
# emit-expr (vector-set! f6382 7 -1)
# emit-expr f6382
# emit-variable-ref
# env=((f6384 . -4) (f6382 . 0))
# var=f6382
    movl 0(%esp), %eax  # stack load f6382
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_38753
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_38753:
    movl %eax, -8(%esp)
# emit-expr 7
    movl $28, %eax     # immed 7
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_38754"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_38754:
# check bounds on vector index
    movl -8(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_38756
    cmp  $0,%eax
    jge _L_38755
_L_38756:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_38755:
    movl %eax, -12(%esp)
# emit-expr -1
    movl $-4, %eax     # immed -1
    movl -8(%esp), %ebx
    movl -12(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin f6382)
# emit-begin
#   expr=(begin f6382)
#   env=((f6384 . -4) (f6382 . 0))
# emit-expr f6382
# emit-variable-ref
# env=((f6384 . -4) (f6382 . 0))
# var=f6382
    movl 0(%esp), %eax  # stack load f6382
# end emit-variable-ref
# emit-expr (begin)
# emit-begin
#   expr=(begin)
#   env=((f6384 . -4) (f6382 . 0))
     movl %eax, mrc_standard$min
# == explicit-begins  ==>
# (lambda (p) (vector-ref p 6))
# == eliminate-let*  ==>
# (lambda (p) (vector-ref p 6))
# == uniquify-variables  ==>
# (lambda (f6385) (vector-ref f6385 6))
# == vectorize-letrec  ==>
# (lambda (f6385) (vector-ref f6385 6))
# == eliminate-set!  ==>
# (lambda (f6385) (let ((f6385 f6385)) (vector-ref f6385 6)))
# == close-free-variables  ==>
# (closure (f6385) () (let ((f6385 f6385)) (vector-ref f6385 6)))
# == eliminate-quote  ==>
# (closure (f6385) () (let ((f6385 f6385)) (vector-ref f6385 6)))
# == eliminate-when/unless  ==>
# (closure (f6385) () (let ((f6385 f6385)) (vector-ref f6385 6)))
# == eliminate-cond  ==>
# (closure (f6385) () (let ((f6385 f6385)) (vector-ref f6385 6)))
# == external-symbols  ==>
# (closure (f6385) () (let ((f6385 f6385)) (vector-ref f6385 6)))
# emit-expr (closure (f6385) () (let ((f6385 f6385)) (vector-ref f6385 6)))
# emit-closure
# si = 0
# env = ()
# expr = (closure (f6385) () (let ((f6385 f6385)) (vector-ref f6385 6)))
    movl $_L_38757, 0(%ebp)  # closure label
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $8, %ebp     # bump ebp
    jmp _L_38758            # jump around closure body
_L_38757:
# check argument count
    cmp $4,%eax
    je _L_38759
# invoke error handler eh_argcount
    .extern mrc_eh$uargcount
    movl mrc_eh$uargcount, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_38759:
# emit-tail-expr
# si=-12
# env=((f6385 . -8))
# expr=(let ((f6385 f6385)) (vector-ref f6385 6))
# emit-tail-let
#  si   = -12
#  env  = ((f6385 . -8))
#  bindings = ((f6385 f6385))
#  body = (vector-ref f6385 6)
# emit-expr f6385
# emit-variable-ref
# env=((f6385 . -8))
# var=f6385
    movl -8(%esp), %eax  # stack load f6385
# end emit-variable-ref
    movl %eax, -12(%esp)  # stack save
# emit-tail-expr
# si=-16
# env=((f6385 . -12) (f6385 . -8))
# expr=(vector-ref f6385 6)
# tail primcall
# emit-expr f6385
# emit-variable-ref
# env=((f6385 . -12) (f6385 . -8))
# var=f6385
    movl -12(%esp), %eax  # stack load f6385
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_38760
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_38760:
    movl %eax, -16(%esp)
# emit-expr 6
    movl $24, %eax     # immed 6
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_38761"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_38761:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_38763
    cmp  $0,%eax
    jge _L_38762
_L_38763:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_38762:
    movl -16(%esp), %esi
    movl -1(%eax,%esi), %eax
#return from tail (vector-ref f6385 6)
    ret
    .align 4,0x90
_L_38758:
     movl %eax, mrc_port$munread
# == explicit-begins  ==>
# (lambda (p) (vector-set! p 6 #f))
# == eliminate-let*  ==>
# (lambda (p) (vector-set! p 6 #f))
# == uniquify-variables  ==>
# (lambda (f6386) (vector-set! f6386 6 #f))
# == vectorize-letrec  ==>
# (lambda (f6386) (vector-set! f6386 6 #f))
# == eliminate-set!  ==>
# (lambda (f6386) (let ((f6386 f6386)) (vector-set! f6386 6 #f)))
# == close-free-variables  ==>
# (closure (f6386) () (let ((f6386 f6386)) (vector-set! f6386 6 #f)))
# == eliminate-quote  ==>
# (closure (f6386) () (let ((f6386 f6386)) (vector-set! f6386 6 #f)))
# == eliminate-when/unless  ==>
# (closure (f6386) () (let ((f6386 f6386)) (vector-set! f6386 6 #f)))
# == eliminate-cond  ==>
# (closure (f6386) () (let ((f6386 f6386)) (vector-set! f6386 6 #f)))
# == external-symbols  ==>
# (closure (f6386) () (let ((f6386 f6386)) (vector-set! f6386 6 #f)))
# emit-expr (closure (f6386) () (let ((f6386 f6386)) (vector-set! f6386 6 #f)))
# emit-closure
# si = 0
# env = ()
# expr = (closure (f6386) () (let ((f6386 f6386)) (vector-set! f6386 6 #f)))
    movl $_L_38764, 0(%ebp)  # closure label
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $8, %ebp     # bump ebp
    jmp _L_38765            # jump around closure body
_L_38764:
# check argument count
    cmp $4,%eax
    je _L_38766
# invoke error handler eh_argcount
    .extern mrc_eh$uargcount
    movl mrc_eh$uargcount, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_38766:
# emit-tail-expr
# si=-12
# env=((f6386 . -8))
# expr=(let ((f6386 f6386)) (vector-set! f6386 6 #f))
# emit-tail-let
#  si   = -12
#  env  = ((f6386 . -8))
#  bindings = ((f6386 f6386))
#  body = (vector-set! f6386 6 #f)
# emit-expr f6386
# emit-variable-ref
# env=((f6386 . -8))
# var=f6386
    movl -8(%esp), %eax  # stack load f6386
# end emit-variable-ref
    movl %eax, -12(%esp)  # stack save
# emit-tail-expr
# si=-16
# env=((f6386 . -12) (f6386 . -8))
# expr=(vector-set! f6386 6 #f)
# tail primcall
# emit-expr f6386
# emit-variable-ref
# env=((f6386 . -12) (f6386 . -8))
# var=f6386
    movl -12(%esp), %eax  # stack load f6386
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_38767
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_38767:
    movl %eax, -16(%esp)
# emit-expr 6
    movl $24, %eax     # immed 6
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_38768"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_38768:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_38770
    cmp  $0,%eax
    jge _L_38769
_L_38770:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_38769:
    movl %eax, -20(%esp)
# emit-expr #f
    movl $47, %eax     # immed #f
    movl -16(%esp), %ebx
    movl -20(%esp), %esi
    movl %eax, -1(%ebx,%esi)
#return from tail (vector-set! f6386 6 #f)
    ret
    .align 4,0x90
_L_38765:
     movl %eax, mrc_port$munread$mclear
# == explicit-begins  ==>
# (lambda (p x) (vector-set! p 6 x))
# == eliminate-let*  ==>
# (lambda (p x) (vector-set! p 6 x))
# == uniquify-variables  ==>
# (lambda (f6387 f6388) (vector-set! f6387 6 f6388))
# == vectorize-letrec  ==>
# (lambda (f6387 f6388) (vector-set! f6387 6 f6388))
# == eliminate-set!  ==>
# (lambda (f6387 f6388) (let ((f6387 f6387) (f6388 f6388)) (vector-set! f6387 6 f6388)))
# == close-free-variables  ==>
# (closure (f6387 f6388) () (let ((f6387 f6387) (f6388 f6388)) (vector-set! f6387 6 f6388)))
# == eliminate-quote  ==>
# (closure (f6387 f6388) () (let ((f6387 f6387) (f6388 f6388)) (vector-set! f6387 6 f6388)))
# == eliminate-when/unless  ==>
# (closure (f6387 f6388) () (let ((f6387 f6387) (f6388 f6388)) (vector-set! f6387 6 f6388)))
# == eliminate-cond  ==>
# (closure (f6387 f6388) () (let ((f6387 f6387) (f6388 f6388)) (vector-set! f6387 6 f6388)))
# == external-symbols  ==>
# (closure (f6387 f6388) () (let ((f6387 f6387) (f6388 f6388)) (vector-set! f6387 6 f6388)))
# emit-expr (closure (f6387 f6388) () (let ((f6387 f6387) (f6388 f6388)) (vector-set! f6387 6 f6388)))
# emit-closure
# si = 0
# env = ()
# expr = (closure (f6387 f6388) () (let ((f6387 f6387) (f6388 f6388)) (vector-set! f6387 6 f6388)))
    movl $_L_38771, 0(%ebp)  # closure label
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $8, %ebp     # bump ebp
    jmp _L_38772            # jump around closure body
_L_38771:
# check argument count
    cmp $8,%eax
    je _L_38773
# invoke error handler eh_argcount
    .extern mrc_eh$uargcount
    movl mrc_eh$uargcount, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_38773:
# emit-tail-expr
# si=-16
# env=((f6388 . -12) (f6387 . -8))
# expr=(let ((f6387 f6387) (f6388 f6388)) (vector-set! f6387 6 f6388))
# emit-tail-let
#  si   = -16
#  env  = ((f6388 . -12) (f6387 . -8))
#  bindings = ((f6387 f6387) (f6388 f6388))
#  body = (vector-set! f6387 6 f6388)
# emit-expr f6387
# emit-variable-ref
# env=((f6388 . -12) (f6387 . -8))
# var=f6387
    movl -8(%esp), %eax  # stack load f6387
# end emit-variable-ref
    movl %eax, -16(%esp)  # stack save
# emit-expr f6388
# emit-variable-ref
# env=((f6388 . -12) (f6387 . -8))
# var=f6388
    movl -12(%esp), %eax  # stack load f6388
# end emit-variable-ref
    movl %eax, -20(%esp)  # stack save
# emit-tail-expr
# si=-24
# env=((f6388 . -20) (f6387 . -16) (f6388 . -12) (f6387 . -8))
# expr=(vector-set! f6387 6 f6388)
# tail primcall
# emit-expr f6387
# emit-variable-ref
# env=((f6388 . -20) (f6387 . -16) (f6388 . -12) (f6387 . -8))
# var=f6387
    movl -16(%esp), %eax  # stack load f6387
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_38774
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_38774:
    movl %eax, -24(%esp)
# emit-expr 6
    movl $24, %eax     # immed 6
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_38775"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_38775:
# check bounds on vector index
    movl -24(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_38777
    cmp  $0,%eax
    jge _L_38776
_L_38777:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_38776:
    movl %eax, -28(%esp)
# emit-expr f6388
# emit-variable-ref
# env=((f6388 . -20) (f6387 . -16) (f6388 . -12) (f6387 . -8))
# var=f6388
    movl -20(%esp), %eax  # stack load f6388
# end emit-variable-ref
    movl -24(%esp), %ebx
    movl -28(%esp), %esi
    movl %eax, -1(%ebx,%esi)
#return from tail (vector-set! f6387 6 f6388)
    ret
    .align 4,0x90
_L_38772:
     movl %eax, mrc_port$munread$mset$b
# == explicit-begins  ==>
# (lambda (p) (vector-ref p 7))
# == eliminate-let*  ==>
# (lambda (p) (vector-ref p 7))
# == uniquify-variables  ==>
# (lambda (f6389) (vector-ref f6389 7))
# == vectorize-letrec  ==>
# (lambda (f6389) (vector-ref f6389 7))
# == eliminate-set!  ==>
# (lambda (f6389) (let ((f6389 f6389)) (vector-ref f6389 7)))
# == close-free-variables  ==>
# (closure (f6389) () (let ((f6389 f6389)) (vector-ref f6389 7)))
# == eliminate-quote  ==>
# (closure (f6389) () (let ((f6389 f6389)) (vector-ref f6389 7)))
# == eliminate-when/unless  ==>
# (closure (f6389) () (let ((f6389 f6389)) (vector-ref f6389 7)))
# == eliminate-cond  ==>
# (closure (f6389) () (let ((f6389 f6389)) (vector-ref f6389 7)))
# == external-symbols  ==>
# (closure (f6389) () (let ((f6389 f6389)) (vector-ref f6389 7)))
# emit-expr (closure (f6389) () (let ((f6389 f6389)) (vector-ref f6389 7)))
# emit-closure
# si = 0
# env = ()
# expr = (closure (f6389) () (let ((f6389 f6389)) (vector-ref f6389 7)))
    movl $_L_38778, 0(%ebp)  # closure label
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $8, %ebp     # bump ebp
    jmp _L_38779            # jump around closure body
_L_38778:
# check argument count
    cmp $4,%eax
    je _L_38780
# invoke error handler eh_argcount
    .extern mrc_eh$uargcount
    movl mrc_eh$uargcount, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_38780:
# emit-tail-expr
# si=-12
# env=((f6389 . -8))
# expr=(let ((f6389 f6389)) (vector-ref f6389 7))
# emit-tail-let
#  si   = -12
#  env  = ((f6389 . -8))
#  bindings = ((f6389 f6389))
#  body = (vector-ref f6389 7)
# emit-expr f6389
# emit-variable-ref
# env=((f6389 . -8))
# var=f6389
    movl -8(%esp), %eax  # stack load f6389
# end emit-variable-ref
    movl %eax, -12(%esp)  # stack save
# emit-tail-expr
# si=-16
# env=((f6389 . -12) (f6389 . -8))
# expr=(vector-ref f6389 7)
# tail primcall
# emit-expr f6389
# emit-variable-ref
# env=((f6389 . -12) (f6389 . -8))
# var=f6389
    movl -12(%esp), %eax  # stack load f6389
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_38781
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_38781:
    movl %eax, -16(%esp)
# emit-expr 7
    movl $28, %eax     # immed 7
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_38782"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_38782:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_38784
    cmp  $0,%eax
    jge _L_38783
_L_38784:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $148,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_38783:
    movl -16(%esp), %esi
    movl -1(%eax,%esi), %eax
#return from tail (vector-ref f6389 7)
    ret
    .align 4,0x90
_L_38779:
     movl %eax, mrc_port$mlast
# == explicit-begins  ==>
# (lambda (p i) (vector-set! p 7 i))
# == eliminate-let*  ==>
# (lambda (p i) (vector-set! p 7 i))
# == uniquify-variables  ==>
# (lambda (f6390 f6391) (vector-set! f6390 7 f6391))
# == vectorize-letrec  ==>
# (lambda (f6390 f6391) (vector-set! f6390 7 f6391))
# == eliminate-set!  ==>
# (lambda (f6390 f6391) (let ((f6390 f6390) (f6391 f6391)) (vector-set! f6390 7 f6391)))
# == close-free-variables  ==>
# (closure (f6390 f6391) () (let ((f6390 f6390) (f6391 f6391)) (vector-set! f6390 7 f6391)))
# == eliminate-quote  ==>
# (closure (f6390 f6391) () (let ((f6390 f6390) (f6391 f6391)) (vector-set! f6390 7 f6391)))
# == eliminate-when/unless  ==>
# (closure (f6390 f6391) () (let ((f6390 f6390) (f6391 f6391)) (vector-set! f6390 7 f6391)))
# == eliminate-cond  ==>
# (closure (f6390 f6391) () (let ((f6390 f6390) (f6391 f6391)) (vector-set! f6390 7 f6391)))
# == external-symbols  ==>
# (closure (f6390 f6391) () (let ((f6390 f6390) (f6391 f6391)) (vector-set! f6390 7 f6391)))
# emit-expr (closure (f6390 f6391) () (let ((f6390 f6390) (f6391 f6391)) (vector-set! f6390 7 f6391)))
# emit-closure
# si = 0
# env = ()
# expr = (closure (f6390 f6391) () (let ((f6390 f6390) (f6391 f6391)) (vector-set! f6390 7 f6391)))
    movl $_L_38785, 0(%ebp)  # closure label
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $8, %ebp     # bump ebp
    jmp _L_38786            # jump around closure body
_L_38785:
# check argument count
    cmp $8,%eax
    je _L_38787
# invoke error handler eh_argcount
    .extern mrc_eh$uargcount
    movl mrc_eh$uargcount, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_38787:
# emit-tail-expr
# si=-16
# env=((f6391 . -12) (f6390 . -8))
# expr=(let ((f6390 f6390) (f6391 f6391)) (vector-set! f6390 7 f6391))
# emit-tail-let
#  si   = -16
#  env  = ((f6391 . -12) (f6390 . -8))
#  bindings = ((f6390 f6390) (f6391 f6391))
#  body = (vector-set! f6390 7 f6391)
# emit-expr f6390
# emit-variable-ref
# env=((f6391 . -12) (f6390 . -8))
# var=f6390
    movl -8(%esp), %eax  # stack load f6390
# end emit-variable-ref
    movl %eax, -16(%esp)  # stack save
# emit-expr f6391
# emit-variable-ref
# env=((f6391 . -12) (f6390 . -8))
# var=f6391
    movl -12(%esp), %eax  # stack load f6391
# end emit-variable-ref
    movl %eax, -20(%esp)  # stack save
# emit-tail-expr
# si=-24
# env=((f6391 . -20) (f6390 . -16) (f6391 . -12) (f6390 . -8))
# expr=(vector-set! f6390 7 f6391)
# tail primcall
# emit-expr f6390
# emit-variable-ref
# env=((f6391 . -20) (f6390 . -16) (f6391 . -12) (f6390 . -8))
# var=f6390
    movl -16(%esp), %eax  # stack load f6390
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_38788
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_38788:
    movl %eax, -24(%esp)
# emit-expr 7
    movl $28, %eax     # immed 7
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_38789"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_38789:
# check bounds on vector index
    movl -24(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_38791
    cmp  $0,%eax
    jge _L_38790
_L_38791:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_38790:
    movl %eax, -28(%esp)
# emit-expr f6391
# emit-variable-ref
# env=((f6391 . -20) (f6390 . -16) (f6391 . -12) (f6390 . -8))
# var=f6391
    movl -20(%esp), %eax  # stack load f6391
# end emit-variable-ref
    movl -24(%esp), %ebx
    movl -28(%esp), %esi
    movl %eax, -1(%ebx,%esi)
#return from tail (vector-set! f6390 7 f6391)
    ret
    .align 4,0x90
_L_38786:
     movl %eax, mrc_port$mlast$mset$b
# == explicit-begins  ==>
# (lambda (p) (and (vector? p) (and (fx= (vector-length p) 8) (eq? (port-kind p) (quote input-port)))))
# == eliminate-let*  ==>
# (lambda (p) (and (vector? p) (and (fx= (vector-length p) 8) (eq? (port-kind p) (quote input-port)))))
# == uniquify-variables  ==>
# (lambda (f6392) (and (vector? f6392) (and (fx= (vector-length f6392) 8) (eq? (port-kind f6392) (quote input-port)))))
# == vectorize-letrec  ==>
# (lambda (f6392) (and (vector? f6392) (and (fx= (vector-length f6392) 8) (eq? (port-kind f6392) (quote input-port)))))
# == eliminate-set!  ==>
# (lambda (f6392) (let ((f6392 f6392)) (and (vector? f6392) (and (fx= (vector-length f6392) 8) (eq? (port-kind f6392) (quote input-port))))))
# == close-free-variables  ==>
# (closure (f6392) (and and input-port) (let ((f6392 f6392)) (and (vector? f6392) (and (fx= (vector-length f6392) 8) (eq? (port-kind f6392) (quote input-port))))))
# == eliminate-quote  ==>
# (closure (f6392) (and and input-port) (let ((f6392 f6392)) (and (vector? f6392) (and (fx= (vector-length f6392) 8) (eq? (port-kind f6392) (string->symbol "input-port"))))))
# == eliminate-when/unless  ==>
# (closure (f6392) (and and input-port) (let ((f6392 f6392)) (and (vector? f6392) (and (fx= (vector-length f6392) 8) (eq? (port-kind f6392) (string->symbol "input-port"))))))
# == eliminate-cond  ==>
# (closure (f6392) (and and input-port) (let ((f6392 f6392)) (and (vector? f6392) (and (fx= (vector-length f6392) 8) (eq? (port-kind f6392) (string->symbol "input-port"))))))
# == external-symbols  ==>
# (closure (f6392) (and and input-port) (let ((f6392 f6392)) (and (vector? f6392) (and (fx= (vector-length f6392) 8) (eq? ((primitive-ref port-kind) f6392) ((primitive-ref string->symbol) "input-port"))))))
# emit-expr (closure (f6392) (and and input-port) (let ((f6392 f6392)) (and (vector? f6392) (and (fx= (vector-length f6392) 8) (eq? ((primitive-ref port-kind) f6392) ((primitive-ref string->symbol) "input-port"))))))
# emit-closure
# si = 0
# env = ()
# expr = (closure (f6392) (and and input-port) (let ((f6392 f6392)) (and (vector? f6392) (and (fx= (vector-length f6392) 8) (eq? ((primitive-ref port-kind) f6392) ((primitive-ref string->symbol) "input-port"))))))
    movl $_L_38792, 0(%ebp)  # closure label
# WARNING: free var and not defined in the environmnet
# WARNING: free var and not defined in the environmnet
# WARNING: free var input-port not defined in the environmnet
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $16, %ebp     # bump ebp
    jmp _L_38793            # jump around closure body
_L_38792:
# check argument count
    cmp $4,%eax
    je _L_38794
# invoke error handler eh_argcount
    .extern mrc_eh$uargcount
    movl mrc_eh$uargcount, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_38794:
# emit-tail-expr
# si=-12
# env=((f6392 . -8) (input-port . 12) (and . 8) (and . 4))
# expr=(let ((f6392 f6392)) (and (vector? f6392) (and (fx= (vector-length f6392) 8) (eq? ((primitive-ref port-kind) f6392) ((primitive-ref string->symbol) "input-port")))))
# emit-tail-let
#  si   = -12
#  env  = ((f6392 . -8) (input-port . 12) (and . 8) (and . 4))
#  bindings = ((f6392 f6392))
#  body = (and (vector? f6392) (and (fx= (vector-length f6392) 8) (eq? ((primitive-ref port-kind) f6392) ((primitive-ref string->symbol) "input-port"))))
# emit-expr f6392
# emit-variable-ref
# env=((f6392 . -8) (input-port . 12) (and . 8) (and . 4))
# var=f6392
    movl -8(%esp), %eax  # stack load f6392
# end emit-variable-ref
    movl %eax, -12(%esp)  # stack save
# emit-tail-expr
# si=-16
# env=((f6392 . -12) (f6392 . -8) (input-port . 12) (and . 8) (and . 4))
# expr=(and (vector? f6392) (and (fx= (vector-length f6392) 8) (eq? ((primitive-ref port-kind) f6392) ((primitive-ref string->symbol) "input-port"))))
# emit-tail-expr
# si=-16
# env=((f6392 . -12) (f6392 . -8) (input-port . 12) (and . 8) (and . 4))
# expr=(if (vector? f6392) (and (and (fx= (vector-length f6392) 8) (eq? ((primitive-ref port-kind) f6392) ((primitive-ref string->symbol) "input-port")))) #f)
# emit-expr (vector? f6392)
# emit-expr f6392
# emit-variable-ref
# env=((f6392 . -12) (f6392 . -8) (input-port . 12) (and . 8) (and . 4))
# var=f6392
    movl -12(%esp), %eax  # stack load f6392
# end emit-variable-ref
    and $7, %al
    cmp $5, %al
    sete %al
    movzbl %al, %eax
    sal $6, %al
    or $47, %al
    cmp $47, %al
    je _L_38795
# emit-tail-expr
# si=-16
# env=((f6392 . -12) (f6392 . -8) (input-port . 12) (and . 8) (and . 4))
# expr=(and (and (fx= (vector-length f6392) 8) (eq? ((primitive-ref port-kind) f6392) ((primitive-ref string->symbol) "input-port"))))
# emit-tail-expr
# si=-16
# env=((f6392 . -12) (f6392 . -8) (input-port . 12) (and . 8) (and . 4))
# expr=(and (fx= (vector-length f6392) 8) (eq? ((primitive-ref port-kind) f6392) ((primitive-ref string->symbol) "input-port")))
# emit-tail-expr
# si=-16
# env=((f6392 . -12) (f6392 . -8) (input-port . 12) (and . 8) (and . 4))
# expr=(if (fx= (vector-length f6392) 8) (and (eq? ((primitive-ref port-kind) f6392) ((primitive-ref string->symbol) "input-port"))) #f)
# emit-expr (fx= (vector-length f6392) 8)
# emit-expr 8
    movl $32, %eax     # immed 8
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_38799"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $68,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_38799:
    movl %eax, -16(%esp)
# emit-expr (vector-length f6392)
# emit-expr f6392
# emit-variable-ref
# env=((f6392 . -12) (f6392 . -8) (input-port . 12) (and . 8) (and . 4))
# var=f6392
    movl -12(%esp), %eax  # stack load f6392
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_38800
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_38800:
andl $-8, %eax
movl 0(%eax), %eax
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_38801"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $68,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_38801:
    cmp -16(%esp), %eax
    sete %al
    movzbl %al, %eax
    sal $6, %al
    or $47, %al
    cmp $47, %al
    je _L_38797
# emit-tail-expr
# si=-16
# env=((f6392 . -12) (f6392 . -8) (input-port . 12) (and . 8) (and . 4))
# expr=(and (eq? ((primitive-ref port-kind) f6392) ((primitive-ref string->symbol) "input-port")))
# emit-tail-expr
# si=-16
# env=((f6392 . -12) (f6392 . -8) (input-port . 12) (and . 8) (and . 4))
# expr=(eq? ((primitive-ref port-kind) f6392) ((primitive-ref string->symbol) "input-port"))
# tail primcall
# eq? arg1=((primitive-ref port-kind) f6392) arg2=((primitive-ref string->symbol) "input-port")
# emit-expr ((primitive-ref port-kind) f6392)
# funcall
#    si   =-16
#    env  = ((f6392 . -12) (f6392 . -8) (input-port . 12) (and . 8) (and . 4))
#    expr = (funcall (primitive-ref port-kind) f6392)
# emit-expr (primitive-ref port-kind)
    .extern mrc_port$mkind
    movl mrc_port$mkind,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_38802"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_38802":
   movl %eax,  -24(%esp)  # stash funcall-oper in closure slot
# emit-expr f6392
# emit-variable-ref
# env=((f6392 . -12) (f6392 . -8) (input-port . 12) (and . 8) (and . 4))
# var=f6392
    movl -12(%esp), %eax  # stack load f6392
# end emit-variable-ref
    mov %eax, -28(%esp)  # arg f6392
    movl -24(%esp), %edi   # load new closure to %edi
    add $-16, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $16, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    movl %eax, -16(%esp)
# emit-expr ((primitive-ref string->symbol) "input-port")
# funcall
#    si   =-20
#    env  = ((f6392 . -12) (f6392 . -8) (input-port . 12) (and . 8) (and . 4))
#    expr = (funcall (primitive-ref string->symbol) "input-port")
# emit-expr (primitive-ref string->symbol)
    .extern mrc_string$m$gsymbol
    movl mrc_string$m$gsymbol,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_38803"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_38803":
   movl %eax,  -28(%esp)  # stash funcall-oper in closure slot
# emit-expr "input-port"
# string literal
    jmp _L_38805
    .align 8,0x90
_L_38804 :
    .int 40
    .ascii "input-port"
_L_38805:
    movl $_L_38804, %eax
    orl $6, %eax
    mov %eax, -32(%esp)  # arg input-port
    movl -28(%esp), %edi   # load new closure to %edi
    add $-20, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $20, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    cmp %eax, -16(%esp)
    sete %al
    movzbl %al, %eax
    sal $6, %al
    or $47, %al
#return from tail (eq? ((primitive-ref port-kind) f6392) ((primitive-ref string->symbol) input-port))
    ret
    jmp _L_38798
_L_38797:
# emit-tail-expr
# si=-16
# env=((f6392 . -12) (f6392 . -8) (input-port . 12) (and . 8) (and . 4))
# expr=#f
    movl $47, %eax     # immed #f
    ret                  # immediate tail return
_L_38798:
    jmp _L_38796
_L_38795:
# emit-tail-expr
# si=-16
# env=((f6392 . -12) (f6392 . -8) (input-port . 12) (and . 8) (and . 4))
# expr=#f
    movl $47, %eax     # immed #f
    ret                  # immediate tail return
_L_38796:
    .align 4,0x90
_L_38793:
     movl %eax, mrc_input$mport$q
# == explicit-begins  ==>
# (lambda (p) (and (vector? p) (and (fx= (vector-length p) 6) (eq? (port-kind p) (quote output-port)))))
# == eliminate-let*  ==>
# (lambda (p) (and (vector? p) (and (fx= (vector-length p) 6) (eq? (port-kind p) (quote output-port)))))
# == uniquify-variables  ==>
# (lambda (f6393) (and (vector? f6393) (and (fx= (vector-length f6393) 6) (eq? (port-kind f6393) (quote output-port)))))
# == vectorize-letrec  ==>
# (lambda (f6393) (and (vector? f6393) (and (fx= (vector-length f6393) 6) (eq? (port-kind f6393) (quote output-port)))))
# == eliminate-set!  ==>
# (lambda (f6393) (let ((f6393 f6393)) (and (vector? f6393) (and (fx= (vector-length f6393) 6) (eq? (port-kind f6393) (quote output-port))))))
# == close-free-variables  ==>
# (closure (f6393) (and and output-port) (let ((f6393 f6393)) (and (vector? f6393) (and (fx= (vector-length f6393) 6) (eq? (port-kind f6393) (quote output-port))))))
# == eliminate-quote  ==>
# (closure (f6393) (and and output-port) (let ((f6393 f6393)) (and (vector? f6393) (and (fx= (vector-length f6393) 6) (eq? (port-kind f6393) (string->symbol "output-port"))))))
# == eliminate-when/unless  ==>
# (closure (f6393) (and and output-port) (let ((f6393 f6393)) (and (vector? f6393) (and (fx= (vector-length f6393) 6) (eq? (port-kind f6393) (string->symbol "output-port"))))))
# == eliminate-cond  ==>
# (closure (f6393) (and and output-port) (let ((f6393 f6393)) (and (vector? f6393) (and (fx= (vector-length f6393) 6) (eq? (port-kind f6393) (string->symbol "output-port"))))))
# == external-symbols  ==>
# (closure (f6393) (and and output-port) (let ((f6393 f6393)) (and (vector? f6393) (and (fx= (vector-length f6393) 6) (eq? ((primitive-ref port-kind) f6393) ((primitive-ref string->symbol) "output-port"))))))
# emit-expr (closure (f6393) (and and output-port) (let ((f6393 f6393)) (and (vector? f6393) (and (fx= (vector-length f6393) 6) (eq? ((primitive-ref port-kind) f6393) ((primitive-ref string->symbol) "output-port"))))))
# emit-closure
# si = 0
# env = ()
# expr = (closure (f6393) (and and output-port) (let ((f6393 f6393)) (and (vector? f6393) (and (fx= (vector-length f6393) 6) (eq? ((primitive-ref port-kind) f6393) ((primitive-ref string->symbol) "output-port"))))))
    movl $_L_38806, 0(%ebp)  # closure label
# WARNING: free var and not defined in the environmnet
# WARNING: free var and not defined in the environmnet
# WARNING: free var output-port not defined in the environmnet
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $16, %ebp     # bump ebp
    jmp _L_38807            # jump around closure body
_L_38806:
# check argument count
    cmp $4,%eax
    je _L_38808
# invoke error handler eh_argcount
    .extern mrc_eh$uargcount
    movl mrc_eh$uargcount, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_38808:
# emit-tail-expr
# si=-12
# env=((f6393 . -8) (output-port . 12) (and . 8) (and . 4))
# expr=(let ((f6393 f6393)) (and (vector? f6393) (and (fx= (vector-length f6393) 6) (eq? ((primitive-ref port-kind) f6393) ((primitive-ref string->symbol) "output-port")))))
# emit-tail-let
#  si   = -12
#  env  = ((f6393 . -8) (output-port . 12) (and . 8) (and . 4))
#  bindings = ((f6393 f6393))
#  body = (and (vector? f6393) (and (fx= (vector-length f6393) 6) (eq? ((primitive-ref port-kind) f6393) ((primitive-ref string->symbol) "output-port"))))
# emit-expr f6393
# emit-variable-ref
# env=((f6393 . -8) (output-port . 12) (and . 8) (and . 4))
# var=f6393
    movl -8(%esp), %eax  # stack load f6393
# end emit-variable-ref
    movl %eax, -12(%esp)  # stack save
# emit-tail-expr
# si=-16
# env=((f6393 . -12) (f6393 . -8) (output-port . 12) (and . 8) (and . 4))
# expr=(and (vector? f6393) (and (fx= (vector-length f6393) 6) (eq? ((primitive-ref port-kind) f6393) ((primitive-ref string->symbol) "output-port"))))
# emit-tail-expr
# si=-16
# env=((f6393 . -12) (f6393 . -8) (output-port . 12) (and . 8) (and . 4))
# expr=(if (vector? f6393) (and (and (fx= (vector-length f6393) 6) (eq? ((primitive-ref port-kind) f6393) ((primitive-ref string->symbol) "output-port")))) #f)
# emit-expr (vector? f6393)
# emit-expr f6393
# emit-variable-ref
# env=((f6393 . -12) (f6393 . -8) (output-port . 12) (and . 8) (and . 4))
# var=f6393
    movl -12(%esp), %eax  # stack load f6393
# end emit-variable-ref
    and $7, %al
    cmp $5, %al
    sete %al
    movzbl %al, %eax
    sal $6, %al
    or $47, %al
    cmp $47, %al
    je _L_38809
# emit-tail-expr
# si=-16
# env=((f6393 . -12) (f6393 . -8) (output-port . 12) (and . 8) (and . 4))
# expr=(and (and (fx= (vector-length f6393) 6) (eq? ((primitive-ref port-kind) f6393) ((primitive-ref string->symbol) "output-port"))))
# emit-tail-expr
# si=-16
# env=((f6393 . -12) (f6393 . -8) (output-port . 12) (and . 8) (and . 4))
# expr=(and (fx= (vector-length f6393) 6) (eq? ((primitive-ref port-kind) f6393) ((primitive-ref string->symbol) "output-port")))
# emit-tail-expr
# si=-16
# env=((f6393 . -12) (f6393 . -8) (output-port . 12) (and . 8) (and . 4))
# expr=(if (fx= (vector-length f6393) 6) (and (eq? ((primitive-ref port-kind) f6393) ((primitive-ref string->symbol) "output-port"))) #f)
# emit-expr (fx= (vector-length f6393) 6)
# emit-expr 6
    movl $24, %eax     # immed 6
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_38813"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $68,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_38813:
    movl %eax, -16(%esp)
# emit-expr (vector-length f6393)
# emit-expr f6393
# emit-variable-ref
# env=((f6393 . -12) (f6393 . -8) (output-port . 12) (and . 8) (and . 4))
# var=f6393
    movl -12(%esp), %eax  # stack load f6393
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_38814
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_38814:
andl $-8, %eax
movl 0(%eax), %eax
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_38815"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $68,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_38815:
    cmp -16(%esp), %eax
    sete %al
    movzbl %al, %eax
    sal $6, %al
    or $47, %al
    cmp $47, %al
    je _L_38811
# emit-tail-expr
# si=-16
# env=((f6393 . -12) (f6393 . -8) (output-port . 12) (and . 8) (and . 4))
# expr=(and (eq? ((primitive-ref port-kind) f6393) ((primitive-ref string->symbol) "output-port")))
# emit-tail-expr
# si=-16
# env=((f6393 . -12) (f6393 . -8) (output-port . 12) (and . 8) (and . 4))
# expr=(eq? ((primitive-ref port-kind) f6393) ((primitive-ref string->symbol) "output-port"))
# tail primcall
# eq? arg1=((primitive-ref port-kind) f6393) arg2=((primitive-ref string->symbol) "output-port")
# emit-expr ((primitive-ref port-kind) f6393)
# funcall
#    si   =-16
#    env  = ((f6393 . -12) (f6393 . -8) (output-port . 12) (and . 8) (and . 4))
#    expr = (funcall (primitive-ref port-kind) f6393)
# emit-expr (primitive-ref port-kind)
    .extern mrc_port$mkind
    movl mrc_port$mkind,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_38816"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_38816":
   movl %eax,  -24(%esp)  # stash funcall-oper in closure slot
# emit-expr f6393
# emit-variable-ref
# env=((f6393 . -12) (f6393 . -8) (output-port . 12) (and . 8) (and . 4))
# var=f6393
    movl -12(%esp), %eax  # stack load f6393
# end emit-variable-ref
    mov %eax, -28(%esp)  # arg f6393
    movl -24(%esp), %edi   # load new closure to %edi
    add $-16, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $16, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    movl %eax, -16(%esp)
# emit-expr ((primitive-ref string->symbol) "output-port")
# funcall
#    si   =-20
#    env  = ((f6393 . -12) (f6393 . -8) (output-port . 12) (and . 8) (and . 4))
#    expr = (funcall (primitive-ref string->symbol) "output-port")
# emit-expr (primitive-ref string->symbol)
    .extern mrc_string$m$gsymbol
    movl mrc_string$m$gsymbol,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_38817"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_38817":
   movl %eax,  -28(%esp)  # stash funcall-oper in closure slot
# emit-expr "output-port"
# string literal
    jmp _L_38819
    .align 8,0x90
_L_38818 :
    .int 44
    .ascii "output-port"
_L_38819:
    movl $_L_38818, %eax
    orl $6, %eax
    mov %eax, -32(%esp)  # arg output-port
    movl -28(%esp), %edi   # load new closure to %edi
    add $-20, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $20, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    cmp %eax, -16(%esp)
    sete %al
    movzbl %al, %eax
    sal $6, %al
    or $47, %al
#return from tail (eq? ((primitive-ref port-kind) f6393) ((primitive-ref string->symbol) output-port))
    ret
    jmp _L_38812
_L_38811:
# emit-tail-expr
# si=-16
# env=((f6393 . -12) (f6393 . -8) (output-port . 12) (and . 8) (and . 4))
# expr=#f
    movl $47, %eax     # immed #f
    ret                  # immediate tail return
_L_38812:
    jmp _L_38810
_L_38809:
# emit-tail-expr
# si=-16
# env=((f6393 . -12) (f6393 . -8) (output-port . 12) (and . 8) (and . 4))
# expr=#f
    movl $47, %eax     # immed #f
    ret                  # immediate tail return
_L_38810:
    .align 4,0x90
_L_38807:
     movl %eax, mrc_output$mport$q
# == explicit-begins  ==>
# (lambda (filename) (begin (unless (string? filename) (error (quote open-input-file) "filename must be a string")) (let ((fd (foreign-call "s_open" filename))) (begin (when (negative? fd) (error (quote open-input-file) "open failed")) (let ((p (make-vector 8)) (sz 1024)) (begin (vector-set! p 0 (quote input-port)) (vector-set! p 1 filename) (vector-set! p 2 fd) (vector-set! p 3 (make-string sz)) (vector-set! p 4 0) (vector-set! p 5 sz) (vector-set! p 6 #f) (vector-set! p 7 0) p))))))
# == eliminate-let*  ==>
# (lambda (filename) (begin (unless (string? filename) (error (quote open-input-file) "filename must be a string")) (let ((fd (foreign-call "s_open" filename))) (begin (when (negative? fd) (error (quote open-input-file) "open failed")) (let ((p (make-vector 8)) (sz 1024)) (begin (vector-set! p 0 (quote input-port)) (vector-set! p 1 filename) (vector-set! p 2 fd) (vector-set! p 3 (make-string sz)) (vector-set! p 4 0) (vector-set! p 5 sz) (vector-set! p 6 #f) (vector-set! p 7 0) p))))))
# == uniquify-variables  ==>
# (lambda (f6394) (begin (unless (string? f6394) (error (quote open-input-file) "filename must be a string")) (let ((f6400 (foreign-call "s_open" f6394))) (begin (when (negative? f6400) (error (quote open-input-file) "open failed")) (let ((f6404 (make-vector 8)) (f6403 1024)) (begin (vector-set! f6404 0 (quote input-port)) (vector-set! f6404 1 f6394) (vector-set! f6404 2 f6400) (vector-set! f6404 3 (make-string f6403)) (vector-set! f6404 4 0) (vector-set! f6404 5 f6403) (vector-set! f6404 6 #f) (vector-set! f6404 7 0) f6404))))))
# == vectorize-letrec  ==>
# (lambda (f6394) (begin (unless (string? f6394) (error (quote open-input-file) "filename must be a string")) (let ((f6400 (foreign-call "s_open" f6394))) (begin (when (negative? f6400) (error (quote open-input-file) "open failed")) (let ((f6404 (make-vector 8)) (f6403 1024)) (begin (vector-set! f6404 0 (quote input-port)) (vector-set! f6404 1 f6394) (vector-set! f6404 2 f6400) (vector-set! f6404 3 (make-string f6403)) (vector-set! f6404 4 0) (vector-set! f6404 5 f6403) (vector-set! f6404 6 #f) (vector-set! f6404 7 0) f6404))))))
# == eliminate-set!  ==>
# (lambda (f6394) (let ((f6394 f6394)) (begin (unless (string? f6394) (error (quote open-input-file) "filename must be a string")) (let ((f6400 (foreign-call "s_open" f6394))) (begin (when (negative? f6400) (error (quote open-input-file) "open failed")) (let ((f6404 (make-vector 8)) (f6403 1024)) (begin (vector-set! f6404 0 (quote input-port)) (vector-set! f6404 1 f6394) (vector-set! f6404 2 f6400) (vector-set! f6404 3 (make-string f6403)) (vector-set! f6404 4 0) (vector-set! f6404 5 f6403) (vector-set! f6404 6 #f) (vector-set! f6404 7 0) f6404)))))))
# == close-free-variables  ==>
# (closure (f6394) (input-port) (let ((f6394 f6394)) (begin (unless (string? f6394) (error (quote open-input-file) "filename must be a string")) (let ((f6400 (foreign-call "s_open" f6394))) (begin (when (negative? f6400) (error (quote open-input-file) "open failed")) (let ((f6404 (make-vector 8)) (f6403 1024)) (begin (vector-set! f6404 0 (quote input-port)) (vector-set! f6404 1 f6394) (vector-set! f6404 2 f6400) (vector-set! f6404 3 (make-string f6403)) (vector-set! f6404 4 0) (vector-set! f6404 5 f6403) (vector-set! f6404 6 #f) (vector-set! f6404 7 0) f6404)))))))
# == eliminate-quote  ==>
# (closure (f6394) (input-port) (let ((f6394 f6394)) (begin (unless (string? f6394) (error (string->symbol "open-input-file") "filename must be a string")) (let ((f6400 (foreign-call "s_open" f6394))) (begin (when (negative? f6400) (error (string->symbol "open-input-file") "open failed")) (let ((f6404 (make-vector 8)) (f6403 1024)) (begin (vector-set! f6404 0 (string->symbol "input-port")) (vector-set! f6404 1 f6394) (vector-set! f6404 2 f6400) (vector-set! f6404 3 (make-string f6403)) (vector-set! f6404 4 0) (vector-set! f6404 5 f6403) (vector-set! f6404 6 #f) (vector-set! f6404 7 0) f6404)))))))
# == eliminate-when/unless  ==>
# (closure (f6394) (input-port) (let ((f6394 f6394)) (begin (if (not (string? f6394)) (begin (error (string->symbol "open-input-file") "filename must be a string")) #f) (let ((f6400 (foreign-call "s_open" f6394))) (begin (if (negative? f6400) (begin (error (string->symbol "open-input-file") "open failed")) #f) (let ((f6404 (make-vector 8)) (f6403 1024)) (begin (vector-set! f6404 0 (string->symbol "input-port")) (vector-set! f6404 1 f6394) (vector-set! f6404 2 f6400) (vector-set! f6404 3 (make-string f6403)) (vector-set! f6404 4 0) (vector-set! f6404 5 f6403) (vector-set! f6404 6 #f) (vector-set! f6404 7 0) f6404)))))))
# == eliminate-cond  ==>
# (closure (f6394) (input-port) (let ((f6394 f6394)) (begin (if (not (string? f6394)) (begin (error (string->symbol "open-input-file") "filename must be a string")) #f) (let ((f6400 (foreign-call "s_open" f6394))) (begin (if (negative? f6400) (begin (error (string->symbol "open-input-file") "open failed")) #f) (let ((f6404 (make-vector 8)) (f6403 1024)) (begin (vector-set! f6404 0 (string->symbol "input-port")) (vector-set! f6404 1 f6394) (vector-set! f6404 2 f6400) (vector-set! f6404 3 (make-string f6403)) (vector-set! f6404 4 0) (vector-set! f6404 5 f6403) (vector-set! f6404 6 #f) (vector-set! f6404 7 0) f6404)))))))
# == external-symbols  ==>
# (closure (f6394) (input-port) (let ((f6394 f6394)) (begin (if (not (string? f6394)) (begin ((primitive-ref error) ((primitive-ref string->symbol) "open-input-file") "filename must be a string")) #f) (let ((f6400 (foreign-call "s_open" f6394))) (begin (if ((primitive-ref negative?) f6400) (begin ((primitive-ref error) ((primitive-ref string->symbol) "open-input-file") "open failed")) #f) (let ((f6404 (make-vector 8)) (f6403 1024)) (begin (vector-set! f6404 0 ((primitive-ref string->symbol) "input-port")) (vector-set! f6404 1 f6394) (vector-set! f6404 2 f6400) (vector-set! f6404 3 (make-string f6403)) (vector-set! f6404 4 0) (vector-set! f6404 5 f6403) (vector-set! f6404 6 #f) (vector-set! f6404 7 0) f6404)))))))
# emit-expr (closure (f6394) (input-port) (let ((f6394 f6394)) (begin (if (not (string? f6394)) (begin ((primitive-ref error) ((primitive-ref string->symbol) "open-input-file") "filename must be a string")) #f) (let ((f6400 (foreign-call "s_open" f6394))) (begin (if ((primitive-ref negative?) f6400) (begin ((primitive-ref error) ((primitive-ref string->symbol) "open-input-file") "open failed")) #f) (let ((f6404 (make-vector 8)) (f6403 1024)) (begin (vector-set! f6404 0 ((primitive-ref string->symbol) "input-port")) (vector-set! f6404 1 f6394) (vector-set! f6404 2 f6400) (vector-set! f6404 3 (make-string f6403)) (vector-set! f6404 4 0) (vector-set! f6404 5 f6403) (vector-set! f6404 6 #f) (vector-set! f6404 7 0) f6404)))))))
# emit-closure
# si = 0
# env = ()
# expr = (closure (f6394) (input-port) (let ((f6394 f6394)) (begin (if (not (string? f6394)) (begin ((primitive-ref error) ((primitive-ref string->symbol) "open-input-file") "filename must be a string")) #f) (let ((f6400 (foreign-call "s_open" f6394))) (begin (if ((primitive-ref negative?) f6400) (begin ((primitive-ref error) ((primitive-ref string->symbol) "open-input-file") "open failed")) #f) (let ((f6404 (make-vector 8)) (f6403 1024)) (begin (vector-set! f6404 0 ((primitive-ref string->symbol) "input-port")) (vector-set! f6404 1 f6394) (vector-set! f6404 2 f6400) (vector-set! f6404 3 (make-string f6403)) (vector-set! f6404 4 0) (vector-set! f6404 5 f6403) (vector-set! f6404 6 #f) (vector-set! f6404 7 0) f6404)))))))
    movl $_L_38820, 0(%ebp)  # closure label
# WARNING: free var input-port not defined in the environmnet
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $8, %ebp     # bump ebp
    jmp _L_38821            # jump around closure body
_L_38820:
# check argument count
    cmp $4,%eax
    je _L_38822
# invoke error handler eh_argcount
    .extern mrc_eh$uargcount
    movl mrc_eh$uargcount, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_38822:
# emit-tail-expr
# si=-12
# env=((f6394 . -8) (input-port . 4))
# expr=(let ((f6394 f6394)) (begin (if (not (string? f6394)) (begin ((primitive-ref error) ((primitive-ref string->symbol) "open-input-file") "filename must be a string")) #f) (let ((f6400 (foreign-call "s_open" f6394))) (begin (if ((primitive-ref negative?) f6400) (begin ((primitive-ref error) ((primitive-ref string->symbol) "open-input-file") "open failed")) #f) (let ((f6404 (make-vector 8)) (f6403 1024)) (begin (vector-set! f6404 0 ((primitive-ref string->symbol) "input-port")) (vector-set! f6404 1 f6394) (vector-set! f6404 2 f6400) (vector-set! f6404 3 (make-string f6403)) (vector-set! f6404 4 0) (vector-set! f6404 5 f6403) (vector-set! f6404 6 #f) (vector-set! f6404 7 0) f6404))))))
# emit-tail-let
#  si   = -12
#  env  = ((f6394 . -8) (input-port . 4))
#  bindings = ((f6394 f6394))
#  body = (begin (if (not (string? f6394)) (begin ((primitive-ref error) ((primitive-ref string->symbol) "open-input-file") "filename must be a string")) #f) (let ((f6400 (foreign-call "s_open" f6394))) (begin (if ((primitive-ref negative?) f6400) (begin ((primitive-ref error) ((primitive-ref string->symbol) "open-input-file") "open failed")) #f) (let ((f6404 (make-vector 8)) (f6403 1024)) (begin (vector-set! f6404 0 ((primitive-ref string->symbol) "input-port")) (vector-set! f6404 1 f6394) (vector-set! f6404 2 f6400) (vector-set! f6404 3 (make-string f6403)) (vector-set! f6404 4 0) (vector-set! f6404 5 f6403) (vector-set! f6404 6 #f) (vector-set! f6404 7 0) f6404)))))
# emit-expr f6394
# emit-variable-ref
# env=((f6394 . -8) (input-port . 4))
# var=f6394
    movl -8(%esp), %eax  # stack load f6394
# end emit-variable-ref
    movl %eax, -12(%esp)  # stack save
# emit-tail-expr
# si=-16
# env=((f6394 . -12) (f6394 . -8) (input-port . 4))
# expr=(begin (if (not (string? f6394)) (begin ((primitive-ref error) ((primitive-ref string->symbol) "open-input-file") "filename must be a string")) #f) (let ((f6400 (foreign-call "s_open" f6394))) (begin (if ((primitive-ref negative?) f6400) (begin ((primitive-ref error) ((primitive-ref string->symbol) "open-input-file") "open failed")) #f) (let ((f6404 (make-vector 8)) (f6403 1024)) (begin (vector-set! f6404 0 ((primitive-ref string->symbol) "input-port")) (vector-set! f6404 1 f6394) (vector-set! f6404 2 f6400) (vector-set! f6404 3 (make-string f6403)) (vector-set! f6404 4 0) (vector-set! f6404 5 f6403) (vector-set! f6404 6 #f) (vector-set! f6404 7 0) f6404)))))
# tail-begin (begin (if (not (string? f6394)) (begin ((primitive-ref error) ((primitive-ref string->symbol) "open-input-file") "filename must be a string")) #f) (let ((f6400 (foreign-call "s_open" f6394))) (begin (if ((primitive-ref negative?) f6400) (begin ((primitive-ref error) ((primitive-ref string->symbol) "open-input-file") "open failed")) #f) (let ((f6404 (make-vector 8)) (f6403 1024)) (begin (vector-set! f6404 0 ((primitive-ref string->symbol) "input-port")) (vector-set! f6404 1 f6394) (vector-set! f6404 2 f6400) (vector-set! f6404 3 (make-string f6403)) (vector-set! f6404 4 0) (vector-set! f6404 5 f6403) (vector-set! f6404 6 #f) (vector-set! f6404 7 0) f6404)))))
#   env=((f6394 . -12) (f6394 . -8) (input-port . 4))
# emit-expr (if (not (string? f6394)) (begin ((primitive-ref error) ((primitive-ref string->symbol) "open-input-file") "filename must be a string")) #f)
# emit-expr (not (string? f6394))
# emit-expr (string? f6394)
# emit-expr f6394
# emit-variable-ref
# env=((f6394 . -12) (f6394 . -8) (input-port . 4))
# var=f6394
    movl -12(%esp), %eax  # stack load f6394
# end emit-variable-ref
    and $7, %al
    cmp $6, %al
    sete %al
    movzbl %al, %eax
    sal $6, %al
    or $47, %al
    cmp $47, %eax
    sete %al
    movzbl %al, %eax
    sal $6, %al
    or $47, %al
    cmp $47, %al
    je _L_38823
# emit-expr (begin ((primitive-ref error) ((primitive-ref string->symbol) "open-input-file") "filename must be a string"))
# emit-begin
#   expr=(begin ((primitive-ref error) ((primitive-ref string->symbol) "open-input-file") "filename must be a string"))
#   env=((f6394 . -12) (f6394 . -8) (input-port . 4))
# emit-expr ((primitive-ref error) ((primitive-ref string->symbol) "open-input-file") "filename must be a string")
# funcall
#    si   =-16
#    env  = ((f6394 . -12) (f6394 . -8) (input-port . 4))
#    expr = (funcall (primitive-ref error) ((primitive-ref string->symbol) "open-input-file") "filename must be a string")
# emit-expr (primitive-ref error)
    .extern mrc_error
    movl mrc_error,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_38825"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_38825":
   movl %eax,  -24(%esp)  # stash funcall-oper in closure slot
# emit-expr ((primitive-ref string->symbol) "open-input-file")
# funcall
#    si   =-28
#    env  = ((f6394 . -12) (f6394 . -8) (input-port . 4))
#    expr = (funcall (primitive-ref string->symbol) "open-input-file")
# emit-expr (primitive-ref string->symbol)
    .extern mrc_string$m$gsymbol
    movl mrc_string$m$gsymbol,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_38826"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_38826":
   movl %eax,  -36(%esp)  # stash funcall-oper in closure slot
# emit-expr "open-input-file"
# string literal
    jmp _L_38828
    .align 8,0x90
_L_38827 :
    .int 60
    .ascii "open-input-file"
_L_38828:
    movl $_L_38827, %eax
    orl $6, %eax
    mov %eax, -40(%esp)  # arg open-input-file
    movl -36(%esp), %edi   # load new closure to %edi
    add $-28, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $28, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    mov %eax, -28(%esp)  # arg ((primitive-ref string->symbol) open-input-file)
# emit-expr "filename must be a string"
# string literal
    jmp _L_38830
    .align 8,0x90
_L_38829 :
    .int 100
    .ascii "filename must be a string"
_L_38830:
    movl $_L_38829, %eax
    orl $6, %eax
    mov %eax, -32(%esp)  # arg filename must be a string
    movl -24(%esp), %edi   # load new closure to %edi
    add $-16, %esp   # adjust base
    movl $8,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $16, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
# emit-expr (begin)
# emit-begin
#   expr=(begin)
#   env=((f6394 . -12) (f6394 . -8) (input-port . 4))
    jmp _L_38824
_L_38823:
# emit-expr #f
    movl $47, %eax     # immed #f
_L_38824:
# emit-tail-expr
# si=-16
# env=((f6394 . -12) (f6394 . -8) (input-port . 4))
# expr=(begin (let ((f6400 (foreign-call "s_open" f6394))) (begin (if ((primitive-ref negative?) f6400) (begin ((primitive-ref error) ((primitive-ref string->symbol) "open-input-file") "open failed")) #f) (let ((f6404 (make-vector 8)) (f6403 1024)) (begin (vector-set! f6404 0 ((primitive-ref string->symbol) "input-port")) (vector-set! f6404 1 f6394) (vector-set! f6404 2 f6400) (vector-set! f6404 3 (make-string f6403)) (vector-set! f6404 4 0) (vector-set! f6404 5 f6403) (vector-set! f6404 6 #f) (vector-set! f6404 7 0) f6404)))))
# tail-begin (begin (let ((f6400 (foreign-call "s_open" f6394))) (begin (if ((primitive-ref negative?) f6400) (begin ((primitive-ref error) ((primitive-ref string->symbol) "open-input-file") "open failed")) #f) (let ((f6404 (make-vector 8)) (f6403 1024)) (begin (vector-set! f6404 0 ((primitive-ref string->symbol) "input-port")) (vector-set! f6404 1 f6394) (vector-set! f6404 2 f6400) (vector-set! f6404 3 (make-string f6403)) (vector-set! f6404 4 0) (vector-set! f6404 5 f6403) (vector-set! f6404 6 #f) (vector-set! f6404 7 0) f6404)))))
#   env=((f6394 . -12) (f6394 . -8) (input-port . 4))
# emit-tail-expr
# si=-16
# env=((f6394 . -12) (f6394 . -8) (input-port . 4))
# expr=(let ((f6400 (foreign-call "s_open" f6394))) (begin (if ((primitive-ref negative?) f6400) (begin ((primitive-ref error) ((primitive-ref string->symbol) "open-input-file") "open failed")) #f) (let ((f6404 (make-vector 8)) (f6403 1024)) (begin (vector-set! f6404 0 ((primitive-ref string->symbol) "input-port")) (vector-set! f6404 1 f6394) (vector-set! f6404 2 f6400) (vector-set! f6404 3 (make-string f6403)) (vector-set! f6404 4 0) (vector-set! f6404 5 f6403) (vector-set! f6404 6 #f) (vector-set! f6404 7 0) f6404))))
# emit-tail-let
#  si   = -16
#  env  = ((f6394 . -12) (f6394 . -8) (input-port . 4))
#  bindings = ((f6400 (foreign-call "s_open" f6394)))
#  body = (begin (if ((primitive-ref negative?) f6400) (begin ((primitive-ref error) ((primitive-ref string->symbol) "open-input-file") "open failed")) #f) (let ((f6404 (make-vector 8)) (f6403 1024)) (begin (vector-set! f6404 0 ((primitive-ref string->symbol) "input-port")) (vector-set! f6404 1 f6394) (vector-set! f6404 2 f6400) (vector-set! f6404 3 (make-string f6403)) (vector-set! f6404 4 0) (vector-set! f6404 5 f6403) (vector-set! f6404 6 #f) (vector-set! f6404 7 0) f6404)))
# emit-expr (foreign-call "s_open" f6394)
    movl %ecx,-16(%esp)
    movl %esp,-20(%esp)
# emit-expr f6394
# emit-variable-ref
# env=((f6394 . -12) (f6394 . -8) (input-port . 4))
# var=f6394
    movl -12(%esp), %eax  # stack load f6394
# end emit-variable-ref
    movl %eax, -24(%esp)
    leal -24(%esp),%edi
    movl %edi,%esi
    andl $-16,%esi
    movl 0(%edi),%eax
    movl %eax,0(%esi)
    movl 4(%edi),%eax
    movl %eax,4(%esi)
    movl %esi,%esp
    .extern _s_open
    call _s_open
    movl 4(%esi),%esp
    movl -16(%esp),%ecx
    movl %eax, -16(%esp)  # stack save
# emit-tail-expr
# si=-20
# env=((f6400 . -16) (f6394 . -12) (f6394 . -8) (input-port . 4))
# expr=(begin (if ((primitive-ref negative?) f6400) (begin ((primitive-ref error) ((primitive-ref string->symbol) "open-input-file") "open failed")) #f) (let ((f6404 (make-vector 8)) (f6403 1024)) (begin (vector-set! f6404 0 ((primitive-ref string->symbol) "input-port")) (vector-set! f6404 1 f6394) (vector-set! f6404 2 f6400) (vector-set! f6404 3 (make-string f6403)) (vector-set! f6404 4 0) (vector-set! f6404 5 f6403) (vector-set! f6404 6 #f) (vector-set! f6404 7 0) f6404)))
# tail-begin (begin (if ((primitive-ref negative?) f6400) (begin ((primitive-ref error) ((primitive-ref string->symbol) "open-input-file") "open failed")) #f) (let ((f6404 (make-vector 8)) (f6403 1024)) (begin (vector-set! f6404 0 ((primitive-ref string->symbol) "input-port")) (vector-set! f6404 1 f6394) (vector-set! f6404 2 f6400) (vector-set! f6404 3 (make-string f6403)) (vector-set! f6404 4 0) (vector-set! f6404 5 f6403) (vector-set! f6404 6 #f) (vector-set! f6404 7 0) f6404)))
#   env=((f6400 . -16) (f6394 . -12) (f6394 . -8) (input-port . 4))
# emit-expr (if ((primitive-ref negative?) f6400) (begin ((primitive-ref error) ((primitive-ref string->symbol) "open-input-file") "open failed")) #f)
# emit-expr ((primitive-ref negative?) f6400)
# funcall
#    si   =-20
#    env  = ((f6400 . -16) (f6394 . -12) (f6394 . -8) (input-port . 4))
#    expr = (funcall (primitive-ref negative?) f6400)
# emit-expr (primitive-ref negative?)
    .extern mrc_negative$q
    movl mrc_negative$q,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_38833"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_38833":
   movl %eax,  -28(%esp)  # stash funcall-oper in closure slot
# emit-expr f6400
# emit-variable-ref
# env=((f6400 . -16) (f6394 . -12) (f6394 . -8) (input-port . 4))
# var=f6400
    movl -16(%esp), %eax  # stack load f6400
# end emit-variable-ref
    mov %eax, -32(%esp)  # arg f6400
    movl -28(%esp), %edi   # load new closure to %edi
    add $-20, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $20, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    cmp $47, %al
    je _L_38831
# emit-expr (begin ((primitive-ref error) ((primitive-ref string->symbol) "open-input-file") "open failed"))
# emit-begin
#   expr=(begin ((primitive-ref error) ((primitive-ref string->symbol) "open-input-file") "open failed"))
#   env=((f6400 . -16) (f6394 . -12) (f6394 . -8) (input-port . 4))
# emit-expr ((primitive-ref error) ((primitive-ref string->symbol) "open-input-file") "open failed")
# funcall
#    si   =-20
#    env  = ((f6400 . -16) (f6394 . -12) (f6394 . -8) (input-port . 4))
#    expr = (funcall (primitive-ref error) ((primitive-ref string->symbol) "open-input-file") "open failed")
# emit-expr (primitive-ref error)
    .extern mrc_error
    movl mrc_error,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_38834"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_38834":
   movl %eax,  -28(%esp)  # stash funcall-oper in closure slot
# emit-expr ((primitive-ref string->symbol) "open-input-file")
# funcall
#    si   =-32
#    env  = ((f6400 . -16) (f6394 . -12) (f6394 . -8) (input-port . 4))
#    expr = (funcall (primitive-ref string->symbol) "open-input-file")
# emit-expr (primitive-ref string->symbol)
    .extern mrc_string$m$gsymbol
    movl mrc_string$m$gsymbol,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_38835"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_38835":
   movl %eax,  -40(%esp)  # stash funcall-oper in closure slot
# emit-expr "open-input-file"
# string literal
    jmp _L_38837
    .align 8,0x90
_L_38836 :
    .int 60
    .ascii "open-input-file"
_L_38837:
    movl $_L_38836, %eax
    orl $6, %eax
    mov %eax, -44(%esp)  # arg open-input-file
    movl -40(%esp), %edi   # load new closure to %edi
    add $-32, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $32, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    mov %eax, -32(%esp)  # arg ((primitive-ref string->symbol) open-input-file)
# emit-expr "open failed"
# string literal
    jmp _L_38839
    .align 8,0x90
_L_38838 :
    .int 44
    .ascii "open failed"
_L_38839:
    movl $_L_38838, %eax
    orl $6, %eax
    mov %eax, -36(%esp)  # arg open failed
    movl -28(%esp), %edi   # load new closure to %edi
    add $-20, %esp   # adjust base
    movl $8,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $20, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
# emit-expr (begin)
# emit-begin
#   expr=(begin)
#   env=((f6400 . -16) (f6394 . -12) (f6394 . -8) (input-port . 4))
    jmp _L_38832
_L_38831:
# emit-expr #f
    movl $47, %eax     # immed #f
_L_38832:
# emit-tail-expr
# si=-20
# env=((f6400 . -16) (f6394 . -12) (f6394 . -8) (input-port . 4))
# expr=(begin (let ((f6404 (make-vector 8)) (f6403 1024)) (begin (vector-set! f6404 0 ((primitive-ref string->symbol) "input-port")) (vector-set! f6404 1 f6394) (vector-set! f6404 2 f6400) (vector-set! f6404 3 (make-string f6403)) (vector-set! f6404 4 0) (vector-set! f6404 5 f6403) (vector-set! f6404 6 #f) (vector-set! f6404 7 0) f6404)))
# tail-begin (begin (let ((f6404 (make-vector 8)) (f6403 1024)) (begin (vector-set! f6404 0 ((primitive-ref string->symbol) "input-port")) (vector-set! f6404 1 f6394) (vector-set! f6404 2 f6400) (vector-set! f6404 3 (make-string f6403)) (vector-set! f6404 4 0) (vector-set! f6404 5 f6403) (vector-set! f6404 6 #f) (vector-set! f6404 7 0) f6404)))
#   env=((f6400 . -16) (f6394 . -12) (f6394 . -8) (input-port . 4))
# emit-tail-expr
# si=-20
# env=((f6400 . -16) (f6394 . -12) (f6394 . -8) (input-port . 4))
# expr=(let ((f6404 (make-vector 8)) (f6403 1024)) (begin (vector-set! f6404 0 ((primitive-ref string->symbol) "input-port")) (vector-set! f6404 1 f6394) (vector-set! f6404 2 f6400) (vector-set! f6404 3 (make-string f6403)) (vector-set! f6404 4 0) (vector-set! f6404 5 f6403) (vector-set! f6404 6 #f) (vector-set! f6404 7 0) f6404))
# emit-tail-let
#  si   = -20
#  env  = ((f6400 . -16) (f6394 . -12) (f6394 . -8) (input-port . 4))
#  bindings = ((f6404 (make-vector 8)) (f6403 1024))
#  body = (begin (vector-set! f6404 0 ((primitive-ref string->symbol) "input-port")) (vector-set! f6404 1 f6394) (vector-set! f6404 2 f6400) (vector-set! f6404 3 (make-string f6403)) (vector-set! f6404 4 0) (vector-set! f6404 5 f6403) (vector-set! f6404 6 #f) (vector-set! f6404 7 0) f6404)
# emit-expr (make-vector 8)
# make-vector 8
# emit-expr 8
    movl $32, %eax     # immed 8
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_38840"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_38840:
# check the argument is a fixnum >= 0
    cmp $0,%eax
    jge _L_38841
# invoke error handler eh_length
    .extern mrc_eh$ulength
    movl mrc_eh$ulength, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_38841:
    movl %eax, %esi
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    orl  $5, %eax
    addl $4, %esi
    addl $4, %esi
    andl $-8, %esi
    addl %esi, %ebp
    movl %eax, -20(%esp)  # stack save
# emit-expr 1024
    movl $4096, %eax     # immed 1024
    movl %eax, -24(%esp)  # stack save
# emit-tail-expr
# si=-28
# env=((f6403 . -24) (f6404 . -20) (f6400 . -16) (f6394 . -12) (f6394 . -8) (input-port . 4))
# expr=(begin (vector-set! f6404 0 ((primitive-ref string->symbol) "input-port")) (vector-set! f6404 1 f6394) (vector-set! f6404 2 f6400) (vector-set! f6404 3 (make-string f6403)) (vector-set! f6404 4 0) (vector-set! f6404 5 f6403) (vector-set! f6404 6 #f) (vector-set! f6404 7 0) f6404)
# tail-begin (begin (vector-set! f6404 0 ((primitive-ref string->symbol) "input-port")) (vector-set! f6404 1 f6394) (vector-set! f6404 2 f6400) (vector-set! f6404 3 (make-string f6403)) (vector-set! f6404 4 0) (vector-set! f6404 5 f6403) (vector-set! f6404 6 #f) (vector-set! f6404 7 0) f6404)
#   env=((f6403 . -24) (f6404 . -20) (f6400 . -16) (f6394 . -12) (f6394 . -8) (input-port . 4))
# emit-expr (vector-set! f6404 0 ((primitive-ref string->symbol) "input-port"))
# emit-expr f6404
# emit-variable-ref
# env=((f6403 . -24) (f6404 . -20) (f6400 . -16) (f6394 . -12) (f6394 . -8) (input-port . 4))
# var=f6404
    movl -20(%esp), %eax  # stack load f6404
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_38842
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_38842:
    movl %eax, -28(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_38843"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_38843:
# check bounds on vector index
    movl -28(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_38845
    cmp  $0,%eax
    jge _L_38844
_L_38845:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_38844:
    movl %eax, -32(%esp)
# emit-expr ((primitive-ref string->symbol) "input-port")
# funcall
#    si   =-36
#    env  = ((f6403 . -24) (f6404 . -20) (f6400 . -16) (f6394 . -12) (f6394 . -8) (input-port . 4))
#    expr = (funcall (primitive-ref string->symbol) "input-port")
# emit-expr (primitive-ref string->symbol)
    .extern mrc_string$m$gsymbol
    movl mrc_string$m$gsymbol,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_38846"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_38846":
   movl %eax,  -44(%esp)  # stash funcall-oper in closure slot
# emit-expr "input-port"
# string literal
    jmp _L_38848
    .align 8,0x90
_L_38847 :
    .int 40
    .ascii "input-port"
_L_38848:
    movl $_L_38847, %eax
    orl $6, %eax
    mov %eax, -48(%esp)  # arg input-port
    movl -44(%esp), %edi   # load new closure to %edi
    add $-36, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $36, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    movl -28(%esp), %ebx
    movl -32(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-tail-expr
# si=-28
# env=((f6403 . -24) (f6404 . -20) (f6400 . -16) (f6394 . -12) (f6394 . -8) (input-port . 4))
# expr=(begin (vector-set! f6404 1 f6394) (vector-set! f6404 2 f6400) (vector-set! f6404 3 (make-string f6403)) (vector-set! f6404 4 0) (vector-set! f6404 5 f6403) (vector-set! f6404 6 #f) (vector-set! f6404 7 0) f6404)
# tail-begin (begin (vector-set! f6404 1 f6394) (vector-set! f6404 2 f6400) (vector-set! f6404 3 (make-string f6403)) (vector-set! f6404 4 0) (vector-set! f6404 5 f6403) (vector-set! f6404 6 #f) (vector-set! f6404 7 0) f6404)
#   env=((f6403 . -24) (f6404 . -20) (f6400 . -16) (f6394 . -12) (f6394 . -8) (input-port . 4))
# emit-expr (vector-set! f6404 1 f6394)
# emit-expr f6404
# emit-variable-ref
# env=((f6403 . -24) (f6404 . -20) (f6400 . -16) (f6394 . -12) (f6394 . -8) (input-port . 4))
# var=f6404
    movl -20(%esp), %eax  # stack load f6404
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_38849
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_38849:
    movl %eax, -28(%esp)
# emit-expr 1
    movl $4, %eax     # immed 1
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_38850"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_38850:
# check bounds on vector index
    movl -28(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_38852
    cmp  $0,%eax
    jge _L_38851
_L_38852:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_38851:
    movl %eax, -32(%esp)
# emit-expr f6394
# emit-variable-ref
# env=((f6403 . -24) (f6404 . -20) (f6400 . -16) (f6394 . -12) (f6394 . -8) (input-port . 4))
# var=f6394
    movl -12(%esp), %eax  # stack load f6394
# end emit-variable-ref
    movl -28(%esp), %ebx
    movl -32(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-tail-expr
# si=-28
# env=((f6403 . -24) (f6404 . -20) (f6400 . -16) (f6394 . -12) (f6394 . -8) (input-port . 4))
# expr=(begin (vector-set! f6404 2 f6400) (vector-set! f6404 3 (make-string f6403)) (vector-set! f6404 4 0) (vector-set! f6404 5 f6403) (vector-set! f6404 6 #f) (vector-set! f6404 7 0) f6404)
# tail-begin (begin (vector-set! f6404 2 f6400) (vector-set! f6404 3 (make-string f6403)) (vector-set! f6404 4 0) (vector-set! f6404 5 f6403) (vector-set! f6404 6 #f) (vector-set! f6404 7 0) f6404)
#   env=((f6403 . -24) (f6404 . -20) (f6400 . -16) (f6394 . -12) (f6394 . -8) (input-port . 4))
# emit-expr (vector-set! f6404 2 f6400)
# emit-expr f6404
# emit-variable-ref
# env=((f6403 . -24) (f6404 . -20) (f6400 . -16) (f6394 . -12) (f6394 . -8) (input-port . 4))
# var=f6404
    movl -20(%esp), %eax  # stack load f6404
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_38853
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_38853:
    movl %eax, -28(%esp)
# emit-expr 2
    movl $8, %eax     # immed 2
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_38854"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_38854:
# check bounds on vector index
    movl -28(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_38856
    cmp  $0,%eax
    jge _L_38855
_L_38856:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_38855:
    movl %eax, -32(%esp)
# emit-expr f6400
# emit-variable-ref
# env=((f6403 . -24) (f6404 . -20) (f6400 . -16) (f6394 . -12) (f6394 . -8) (input-port . 4))
# var=f6400
    movl -16(%esp), %eax  # stack load f6400
# end emit-variable-ref
    movl -28(%esp), %ebx
    movl -32(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-tail-expr
# si=-28
# env=((f6403 . -24) (f6404 . -20) (f6400 . -16) (f6394 . -12) (f6394 . -8) (input-port . 4))
# expr=(begin (vector-set! f6404 3 (make-string f6403)) (vector-set! f6404 4 0) (vector-set! f6404 5 f6403) (vector-set! f6404 6 #f) (vector-set! f6404 7 0) f6404)
# tail-begin (begin (vector-set! f6404 3 (make-string f6403)) (vector-set! f6404 4 0) (vector-set! f6404 5 f6403) (vector-set! f6404 6 #f) (vector-set! f6404 7 0) f6404)
#   env=((f6403 . -24) (f6404 . -20) (f6400 . -16) (f6394 . -12) (f6394 . -8) (input-port . 4))
# emit-expr (vector-set! f6404 3 (make-string f6403))
# emit-expr f6404
# emit-variable-ref
# env=((f6403 . -24) (f6404 . -20) (f6400 . -16) (f6394 . -12) (f6394 . -8) (input-port . 4))
# var=f6404
    movl -20(%esp), %eax  # stack load f6404
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_38857
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_38857:
    movl %eax, -28(%esp)
# emit-expr 3
    movl $12, %eax     # immed 3
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_38858"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_38858:
# check bounds on vector index
    movl -28(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_38860
    cmp  $0,%eax
    jge _L_38859
_L_38860:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_38859:
    movl %eax, -32(%esp)
# emit-expr (make-string f6403)
# make-string len=f6403
# emit-expr f6403
# emit-variable-ref
# env=((f6403 . -24) (f6404 . -20) (f6400 . -16) (f6394 . -12) (f6394 . -8) (input-port . 4))
# var=f6403
    movl -24(%esp), %eax  # stack load f6403
# end emit-variable-ref
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_38861"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $152,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_38861:
# check the argument is a fixnum >= 0
    cmp $0,%eax
    jge _L_38862
# invoke error handler eh_length
    .extern mrc_eh$ulength
    movl mrc_eh$ulength, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $152,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_38862:
    movl %eax, %esi
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    orl $6, %eax
    sar $2, %esi
    add $4, %esi
    add $7, %esi
    andl $-8, %esi
    add  %esi, %ebp
# make-string end
    movl -28(%esp), %ebx
    movl -32(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-tail-expr
# si=-28
# env=((f6403 . -24) (f6404 . -20) (f6400 . -16) (f6394 . -12) (f6394 . -8) (input-port . 4))
# expr=(begin (vector-set! f6404 4 0) (vector-set! f6404 5 f6403) (vector-set! f6404 6 #f) (vector-set! f6404 7 0) f6404)
# tail-begin (begin (vector-set! f6404 4 0) (vector-set! f6404 5 f6403) (vector-set! f6404 6 #f) (vector-set! f6404 7 0) f6404)
#   env=((f6403 . -24) (f6404 . -20) (f6400 . -16) (f6394 . -12) (f6394 . -8) (input-port . 4))
# emit-expr (vector-set! f6404 4 0)
# emit-expr f6404
# emit-variable-ref
# env=((f6403 . -24) (f6404 . -20) (f6400 . -16) (f6394 . -12) (f6394 . -8) (input-port . 4))
# var=f6404
    movl -20(%esp), %eax  # stack load f6404
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_38863
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_38863:
    movl %eax, -28(%esp)
# emit-expr 4
    movl $16, %eax     # immed 4
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_38864"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_38864:
# check bounds on vector index
    movl -28(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_38866
    cmp  $0,%eax
    jge _L_38865
_L_38866:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_38865:
    movl %eax, -32(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
    movl -28(%esp), %ebx
    movl -32(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-tail-expr
# si=-28
# env=((f6403 . -24) (f6404 . -20) (f6400 . -16) (f6394 . -12) (f6394 . -8) (input-port . 4))
# expr=(begin (vector-set! f6404 5 f6403) (vector-set! f6404 6 #f) (vector-set! f6404 7 0) f6404)
# tail-begin (begin (vector-set! f6404 5 f6403) (vector-set! f6404 6 #f) (vector-set! f6404 7 0) f6404)
#   env=((f6403 . -24) (f6404 . -20) (f6400 . -16) (f6394 . -12) (f6394 . -8) (input-port . 4))
# emit-expr (vector-set! f6404 5 f6403)
# emit-expr f6404
# emit-variable-ref
# env=((f6403 . -24) (f6404 . -20) (f6400 . -16) (f6394 . -12) (f6394 . -8) (input-port . 4))
# var=f6404
    movl -20(%esp), %eax  # stack load f6404
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_38867
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_38867:
    movl %eax, -28(%esp)
# emit-expr 5
    movl $20, %eax     # immed 5
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_38868"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_38868:
# check bounds on vector index
    movl -28(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_38870
    cmp  $0,%eax
    jge _L_38869
_L_38870:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_38869:
    movl %eax, -32(%esp)
# emit-expr f6403
# emit-variable-ref
# env=((f6403 . -24) (f6404 . -20) (f6400 . -16) (f6394 . -12) (f6394 . -8) (input-port . 4))
# var=f6403
    movl -24(%esp), %eax  # stack load f6403
# end emit-variable-ref
    movl -28(%esp), %ebx
    movl -32(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-tail-expr
# si=-28
# env=((f6403 . -24) (f6404 . -20) (f6400 . -16) (f6394 . -12) (f6394 . -8) (input-port . 4))
# expr=(begin (vector-set! f6404 6 #f) (vector-set! f6404 7 0) f6404)
# tail-begin (begin (vector-set! f6404 6 #f) (vector-set! f6404 7 0) f6404)
#   env=((f6403 . -24) (f6404 . -20) (f6400 . -16) (f6394 . -12) (f6394 . -8) (input-port . 4))
# emit-expr (vector-set! f6404 6 #f)
# emit-expr f6404
# emit-variable-ref
# env=((f6403 . -24) (f6404 . -20) (f6400 . -16) (f6394 . -12) (f6394 . -8) (input-port . 4))
# var=f6404
    movl -20(%esp), %eax  # stack load f6404
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_38871
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_38871:
    movl %eax, -28(%esp)
# emit-expr 6
    movl $24, %eax     # immed 6
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_38872"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_38872:
# check bounds on vector index
    movl -28(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_38874
    cmp  $0,%eax
    jge _L_38873
_L_38874:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_38873:
    movl %eax, -32(%esp)
# emit-expr #f
    movl $47, %eax     # immed #f
    movl -28(%esp), %ebx
    movl -32(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-tail-expr
# si=-28
# env=((f6403 . -24) (f6404 . -20) (f6400 . -16) (f6394 . -12) (f6394 . -8) (input-port . 4))
# expr=(begin (vector-set! f6404 7 0) f6404)
# tail-begin (begin (vector-set! f6404 7 0) f6404)
#   env=((f6403 . -24) (f6404 . -20) (f6400 . -16) (f6394 . -12) (f6394 . -8) (input-port . 4))
# emit-expr (vector-set! f6404 7 0)
# emit-expr f6404
# emit-variable-ref
# env=((f6403 . -24) (f6404 . -20) (f6400 . -16) (f6394 . -12) (f6394 . -8) (input-port . 4))
# var=f6404
    movl -20(%esp), %eax  # stack load f6404
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_38875
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_38875:
    movl %eax, -28(%esp)
# emit-expr 7
    movl $28, %eax     # immed 7
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_38876"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_38876:
# check bounds on vector index
    movl -28(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_38878
    cmp  $0,%eax
    jge _L_38877
_L_38878:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_38877:
    movl %eax, -32(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
    movl -28(%esp), %ebx
    movl -32(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-tail-expr
# si=-28
# env=((f6403 . -24) (f6404 . -20) (f6400 . -16) (f6394 . -12) (f6394 . -8) (input-port . 4))
# expr=(begin f6404)
# tail-begin (begin f6404)
#   env=((f6403 . -24) (f6404 . -20) (f6400 . -16) (f6394 . -12) (f6394 . -8) (input-port . 4))
# emit-tail-expr
# si=-28
# env=((f6403 . -24) (f6404 . -20) (f6400 . -16) (f6394 . -12) (f6394 . -8) (input-port . 4))
# expr=f6404
# emit-tail-variable-ref
# emit-variable-ref
# env=((f6403 . -24) (f6404 . -20) (f6400 . -16) (f6394 . -12) (f6394 . -8) (input-port . 4))
# var=f6404
    movl -20(%esp), %eax  # stack load f6404
# end emit-variable-ref
    ret
# end emit-tail-variable ref
     ret   # return thru stack
     ret   # return thru stack
     ret   # return thru stack
    .align 4,0x90
_L_38821:
     movl %eax, mrc_open$minput$mfile
# == explicit-begins  ==>
# (lambda args (let ((p (if (null? args) (current-input-port) (car args)))) (cond ((port-unread p) (let ((ch (port-unread p))) (begin (unless (eof-object? (port-unread p)) (port-unread-clear p)) ch))) (else (begin (when (fx= (port-last p) (port-ndx p)) (fill-input-buffer p)) (if (port-unread p) (port-unread p) (let ((ch (string-ref (port-buf p) (port-ndx p)))) (begin (port-ndx-add1 p) ch))))))))
# == eliminate-let*  ==>
# (lambda args (let ((p (if (null? args) (current-input-port) (car args)))) (cond ((port-unread p) (let ((ch (port-unread p))) (begin (unless (eof-object? (port-unread p)) (port-unread-clear p)) ch))) (else (begin (when (fx= (port-last p) (port-ndx p)) (fill-input-buffer p)) (if (port-unread p) (port-unread p) (let ((ch (string-ref (port-buf p) (port-ndx p)))) (begin (port-ndx-add1 p) ch))))))))
# == uniquify-variables  ==>
# (lambda f6405 (let ((f6411 (if (null? f6405) (current-input-port) (car f6405)))) (cond ((port-unread f6411) (let ((f6414 (port-unread f6411))) (begin (unless (eof-object? (port-unread f6411)) (port-unread-clear f6411)) f6414))) (else (begin (when (fx= (port-last f6411) (port-ndx f6411)) (fill-input-buffer f6411)) (if (port-unread f6411) (port-unread f6411) (let ((f6415 (string-ref (port-buf f6411) (port-ndx f6411)))) (begin (port-ndx-add1 f6411) f6415))))))))
# == vectorize-letrec  ==>
# (lambda f6405 (let ((f6411 (if (null? f6405) (current-input-port) (car f6405)))) (cond ((port-unread f6411) (let ((f6414 (port-unread f6411))) (begin (unless (eof-object? (port-unread f6411)) (port-unread-clear f6411)) f6414))) (else (begin (when (fx= (port-last f6411) (port-ndx f6411)) (fill-input-buffer f6411)) (if (port-unread f6411) (port-unread f6411) (let ((f6415 (string-ref (port-buf f6411) (port-ndx f6411)))) (begin (port-ndx-add1 f6411) f6415))))))))
# == eliminate-set!  ==>
# (lambda f6405 (let () (let ((f6411 (if (null? f6405) (current-input-port) (car f6405)))) (cond ((port-unread f6411) (let ((f6414 (port-unread f6411))) (begin (unless (eof-object? (port-unread f6411)) (port-unread-clear f6411)) f6414))) (else (begin (when (fx= (port-last f6411) (port-ndx f6411)) (fill-input-buffer f6411)) (if (port-unread f6411) (port-unread f6411) (let ((f6415 (string-ref (port-buf f6411) (port-ndx f6411)))) (begin (port-ndx-add1 f6411) f6415)))))))))
# == close-free-variables  ==>
# (closure f6405 () (let () (let ((f6411 (if (null? f6405) (current-input-port) (car f6405)))) (cond ((port-unread f6411) (let ((f6414 (port-unread f6411))) (begin (unless (eof-object? (port-unread f6411)) (port-unread-clear f6411)) f6414))) (else (begin (when (fx= (port-last f6411) (port-ndx f6411)) (fill-input-buffer f6411)) (if (port-unread f6411) (port-unread f6411) (let ((f6415 (string-ref (port-buf f6411) (port-ndx f6411)))) (begin (port-ndx-add1 f6411) f6415)))))))))
# == eliminate-quote  ==>
# (closure f6405 () (let () (let ((f6411 (if (null? f6405) (current-input-port) (car f6405)))) (cond ((port-unread f6411) (let ((f6414 (port-unread f6411))) (begin (unless (eof-object? (port-unread f6411)) (port-unread-clear f6411)) f6414))) (else (begin (when (fx= (port-last f6411) (port-ndx f6411)) (fill-input-buffer f6411)) (if (port-unread f6411) (port-unread f6411) (let ((f6415 (string-ref (port-buf f6411) (port-ndx f6411)))) (begin (port-ndx-add1 f6411) f6415)))))))))
# == eliminate-when/unless  ==>
# (closure f6405 () (let () (let ((f6411 (if (null? f6405) (current-input-port) (car f6405)))) (cond ((port-unread f6411) (let ((f6414 (port-unread f6411))) (begin (if (not (eof-object? (port-unread f6411))) (begin (port-unread-clear f6411)) #f) f6414))) (else (begin (if (fx= (port-last f6411) (port-ndx f6411)) (begin (fill-input-buffer f6411)) #f) (if (port-unread f6411) (port-unread f6411) (let ((f6415 (string-ref (port-buf f6411) (port-ndx f6411)))) (begin (port-ndx-add1 f6411) f6415)))))))))
# == eliminate-cond  ==>
# (closure f6405 () (let () (let ((f6411 (if (null? f6405) (current-input-port) (car f6405)))) (if (port-unread f6411) (let ((f6414 (port-unread f6411))) (begin (if (not (eof-object? (port-unread f6411))) (begin (port-unread-clear f6411)) #f) f6414)) (begin (if (fx= (port-last f6411) (port-ndx f6411)) (begin (fill-input-buffer f6411)) #f) (if (port-unread f6411) (port-unread f6411) (let ((f6415 (string-ref (port-buf f6411) (port-ndx f6411)))) (begin (port-ndx-add1 f6411) f6415))))))))
# == external-symbols  ==>
# (closure f6405 () (let () (let ((f6411 (if (null? f6405) ((primitive-ref current-input-port)) (car f6405)))) (if ((primitive-ref port-unread) f6411) (let ((f6414 ((primitive-ref port-unread) f6411))) (begin (if (not (eof-object? ((primitive-ref port-unread) f6411))) (begin ((primitive-ref port-unread-clear) f6411)) #f) f6414)) (begin (if (fx= ((primitive-ref port-last) f6411) ((primitive-ref port-ndx) f6411)) (begin ((primitive-ref fill-input-buffer) f6411)) #f) (if ((primitive-ref port-unread) f6411) ((primitive-ref port-unread) f6411) (let ((f6415 (string-ref ((primitive-ref port-buf) f6411) ((primitive-ref port-ndx) f6411)))) (begin ((primitive-ref port-ndx-add1) f6411) f6415))))))))
# emit-expr (closure f6405 () (let () (let ((f6411 (if (null? f6405) ((primitive-ref current-input-port)) (car f6405)))) (if ((primitive-ref port-unread) f6411) (let ((f6414 ((primitive-ref port-unread) f6411))) (begin (if (not (eof-object? ((primitive-ref port-unread) f6411))) (begin ((primitive-ref port-unread-clear) f6411)) #f) f6414)) (begin (if (fx= ((primitive-ref port-last) f6411) ((primitive-ref port-ndx) f6411)) (begin ((primitive-ref fill-input-buffer) f6411)) #f) (if ((primitive-ref port-unread) f6411) ((primitive-ref port-unread) f6411) (let ((f6415 (string-ref ((primitive-ref port-buf) f6411) ((primitive-ref port-ndx) f6411)))) (begin ((primitive-ref port-ndx-add1) f6411) f6415))))))))
# emit-closure
# si = 0
# env = ()
# expr = (closure f6405 () (let () (let ((f6411 (if (null? f6405) ((primitive-ref current-input-port)) (car f6405)))) (if ((primitive-ref port-unread) f6411) (let ((f6414 ((primitive-ref port-unread) f6411))) (begin (if (not (eof-object? ((primitive-ref port-unread) f6411))) (begin ((primitive-ref port-unread-clear) f6411)) #f) f6414)) (begin (if (fx= ((primitive-ref port-last) f6411) ((primitive-ref port-ndx) f6411)) (begin ((primitive-ref fill-input-buffer) f6411)) #f) (if ((primitive-ref port-unread) f6411) ((primitive-ref port-unread) f6411) (let ((f6415 (string-ref ((primitive-ref port-buf) f6411) ((primitive-ref port-ndx) f6411)))) (begin ((primitive-ref port-ndx-add1) f6411) f6415))))))))
    movl $_L_38879, 0(%ebp)  # closure label
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $8, %ebp     # bump ebp
    jmp _L_38880            # jump around closure body
_L_38879:
# check argument count
    cmp $0,%eax
    jge _L_38881
# invoke error handler eh_argcount_min
    .extern mrc_eh$uargcount$umin
    movl mrc_eh$uargcount$umin, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_38881:
# emit-build-varargs-list
    movl $63, %esi       # args <- () 
    lea -4(%esp),%edi    # edi <- esp-4
    subl %eax, %edi      # edi <- esp-4-eax    addr of arg[K+N] on stack
_L_38883:
    lea -4(%esp),%ebx    # addr of arg[K] on stack
    cmp %edi, %ebx       # while edi <> esp+(si+4)
    je _L_38882
    movl (%edi),%ebx     # arg i -> car
    movl %ebx, 0(%ebp)
    movl %esi, 4(%ebp)  # esi -> cdr
    movl %ebp, %esi
    addl $1, %esi       # tag as pair
    addl $8,%ebp         # bump heap ptr
    addl $4,%edi         # move to next previous arg from the end
    jmp _L_38883
_L_38882:
    movl %esi, -8(%esp)  # set args
# emit-tail-expr
# si=-12
# env=((f6405 . -8))
# expr=(let () (let ((f6411 (if (null? f6405) ((primitive-ref current-input-port)) (car f6405)))) (if ((primitive-ref port-unread) f6411) (let ((f6414 ((primitive-ref port-unread) f6411))) (begin (if (not (eof-object? ((primitive-ref port-unread) f6411))) (begin ((primitive-ref port-unread-clear) f6411)) #f) f6414)) (begin (if (fx= ((primitive-ref port-last) f6411) ((primitive-ref port-ndx) f6411)) (begin ((primitive-ref fill-input-buffer) f6411)) #f) (if ((primitive-ref port-unread) f6411) ((primitive-ref port-unread) f6411) (let ((f6415 (string-ref ((primitive-ref port-buf) f6411) ((primitive-ref port-ndx) f6411)))) (begin ((primitive-ref port-ndx-add1) f6411) f6415)))))))
# emit-tail-let
#  si   = -12
#  env  = ((f6405 . -8))
#  bindings = ()
#  body = (let ((f6411 (if (null? f6405) ((primitive-ref current-input-port)) (car f6405)))) (if ((primitive-ref port-unread) f6411) (let ((f6414 ((primitive-ref port-unread) f6411))) (begin (if (not (eof-object? ((primitive-ref port-unread) f6411))) (begin ((primitive-ref port-unread-clear) f6411)) #f) f6414)) (begin (if (fx= ((primitive-ref port-last) f6411) ((primitive-ref port-ndx) f6411)) (begin ((primitive-ref fill-input-buffer) f6411)) #f) (if ((primitive-ref port-unread) f6411) ((primitive-ref port-unread) f6411) (let ((f6415 (string-ref ((primitive-ref port-buf) f6411) ((primitive-ref port-ndx) f6411)))) (begin ((primitive-ref port-ndx-add1) f6411) f6415))))))
# emit-tail-expr
# si=-12
# env=((f6405 . -8))
# expr=(let ((f6411 (if (null? f6405) ((primitive-ref current-input-port)) (car f6405)))) (if ((primitive-ref port-unread) f6411) (let ((f6414 ((primitive-ref port-unread) f6411))) (begin (if (not (eof-object? ((primitive-ref port-unread) f6411))) (begin ((primitive-ref port-unread-clear) f6411)) #f) f6414)) (begin (if (fx= ((primitive-ref port-last) f6411) ((primitive-ref port-ndx) f6411)) (begin ((primitive-ref fill-input-buffer) f6411)) #f) (if ((primitive-ref port-unread) f6411) ((primitive-ref port-unread) f6411) (let ((f6415 (string-ref ((primitive-ref port-buf) f6411) ((primitive-ref port-ndx) f6411)))) (begin ((primitive-ref port-ndx-add1) f6411) f6415))))))
# emit-tail-let
#  si   = -12
#  env  = ((f6405 . -8))
#  bindings = ((f6411 (if (null? f6405) ((primitive-ref current-input-port)) (car f6405))))
#  body = (if ((primitive-ref port-unread) f6411) (let ((f6414 ((primitive-ref port-unread) f6411))) (begin (if (not (eof-object? ((primitive-ref port-unread) f6411))) (begin ((primitive-ref port-unread-clear) f6411)) #f) f6414)) (begin (if (fx= ((primitive-ref port-last) f6411) ((primitive-ref port-ndx) f6411)) (begin ((primitive-ref fill-input-buffer) f6411)) #f) (if ((primitive-ref port-unread) f6411) ((primitive-ref port-unread) f6411) (let ((f6415 (string-ref ((primitive-ref port-buf) f6411) ((primitive-ref port-ndx) f6411)))) (begin ((primitive-ref port-ndx-add1) f6411) f6415)))))
# emit-expr (if (null? f6405) ((primitive-ref current-input-port)) (car f6405))
# emit-expr (null? f6405)
# emit-expr f6405
# emit-variable-ref
# env=((f6405 . -8))
# var=f6405
    movl -8(%esp), %eax  # stack load f6405
# end emit-variable-ref
    cmp $63, %eax
    mov $0, %eax
    sete %al
    movzbl %al, %eax
    sal $6, %al
    or $47, %al
    cmp $47, %al
    je _L_38884
# emit-expr ((primitive-ref current-input-port))
# funcall
#    si   =-12
#    env  = ((f6405 . -8))
#    expr = (funcall (primitive-ref current-input-port))
# emit-expr (primitive-ref current-input-port)
    .extern mrc_current$minput$mport
    movl mrc_current$minput$mport,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_38886"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_38886":
   movl %eax,  -20(%esp)  # stash funcall-oper in closure slot
    movl -20(%esp), %edi   # load new closure to %edi
    add $-12, %esp   # adjust base
    movl $0,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $12, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    jmp _L_38885
_L_38884:
# emit-expr (car f6405)
# emit-expr f6405
# emit-variable-ref
# env=((f6405 . -8))
# var=f6405
    movl -8(%esp), %eax  # stack load f6405
# end emit-variable-ref
# check the argument is a pair
    movl %eax,%ebx
    and $7, %bl
    cmp $1, %bl
    je _L_38887
# invoke error handler eh_pair
    .extern mrc_eh$upair
    movl mrc_eh$upair, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $116,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_38887:
    movl -1(%eax), %eax
_L_38885:
    movl %eax, -12(%esp)  # stack save
# emit-tail-expr
# si=-16
# env=((f6411 . -12) (f6405 . -8))
# expr=(if ((primitive-ref port-unread) f6411) (let ((f6414 ((primitive-ref port-unread) f6411))) (begin (if (not (eof-object? ((primitive-ref port-unread) f6411))) (begin ((primitive-ref port-unread-clear) f6411)) #f) f6414)) (begin (if (fx= ((primitive-ref port-last) f6411) ((primitive-ref port-ndx) f6411)) (begin ((primitive-ref fill-input-buffer) f6411)) #f) (if ((primitive-ref port-unread) f6411) ((primitive-ref port-unread) f6411) (let ((f6415 (string-ref ((primitive-ref port-buf) f6411) ((primitive-ref port-ndx) f6411)))) (begin ((primitive-ref port-ndx-add1) f6411) f6415)))))
# emit-expr ((primitive-ref port-unread) f6411)
# funcall
#    si   =-16
#    env  = ((f6411 . -12) (f6405 . -8))
#    expr = (funcall (primitive-ref port-unread) f6411)
# emit-expr (primitive-ref port-unread)
    .extern mrc_port$munread
    movl mrc_port$munread,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_38890"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_38890":
   movl %eax,  -24(%esp)  # stash funcall-oper in closure slot
# emit-expr f6411
# emit-variable-ref
# env=((f6411 . -12) (f6405 . -8))
# var=f6411
    movl -12(%esp), %eax  # stack load f6411
# end emit-variable-ref
    mov %eax, -28(%esp)  # arg f6411
    movl -24(%esp), %edi   # load new closure to %edi
    add $-16, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $16, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    cmp $47, %al
    je _L_38888
# emit-tail-expr
# si=-16
# env=((f6411 . -12) (f6405 . -8))
# expr=(let ((f6414 ((primitive-ref port-unread) f6411))) (begin (if (not (eof-object? ((primitive-ref port-unread) f6411))) (begin ((primitive-ref port-unread-clear) f6411)) #f) f6414))
# emit-tail-let
#  si   = -16
#  env  = ((f6411 . -12) (f6405 . -8))
#  bindings = ((f6414 ((primitive-ref port-unread) f6411)))
#  body = (begin (if (not (eof-object? ((primitive-ref port-unread) f6411))) (begin ((primitive-ref port-unread-clear) f6411)) #f) f6414)
# emit-expr ((primitive-ref port-unread) f6411)
# funcall
#    si   =-16
#    env  = ((f6411 . -12) (f6405 . -8))
#    expr = (funcall (primitive-ref port-unread) f6411)
# emit-expr (primitive-ref port-unread)
    .extern mrc_port$munread
    movl mrc_port$munread,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_38891"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_38891":
   movl %eax,  -24(%esp)  # stash funcall-oper in closure slot
# emit-expr f6411
# emit-variable-ref
# env=((f6411 . -12) (f6405 . -8))
# var=f6411
    movl -12(%esp), %eax  # stack load f6411
# end emit-variable-ref
    mov %eax, -28(%esp)  # arg f6411
    movl -24(%esp), %edi   # load new closure to %edi
    add $-16, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $16, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    movl %eax, -16(%esp)  # stack save
# emit-tail-expr
# si=-20
# env=((f6414 . -16) (f6411 . -12) (f6405 . -8))
# expr=(begin (if (not (eof-object? ((primitive-ref port-unread) f6411))) (begin ((primitive-ref port-unread-clear) f6411)) #f) f6414)
# tail-begin (begin (if (not (eof-object? ((primitive-ref port-unread) f6411))) (begin ((primitive-ref port-unread-clear) f6411)) #f) f6414)
#   env=((f6414 . -16) (f6411 . -12) (f6405 . -8))
# emit-expr (if (not (eof-object? ((primitive-ref port-unread) f6411))) (begin ((primitive-ref port-unread-clear) f6411)) #f)
# emit-expr (not (eof-object? ((primitive-ref port-unread) f6411)))
# emit-expr (eof-object? ((primitive-ref port-unread) f6411))
# emit-expr ((primitive-ref port-unread) f6411)
# funcall
#    si   =-20
#    env  = ((f6414 . -16) (f6411 . -12) (f6405 . -8))
#    expr = (funcall (primitive-ref port-unread) f6411)
# emit-expr (primitive-ref port-unread)
    .extern mrc_port$munread
    movl mrc_port$munread,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_38894"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_38894":
   movl %eax,  -28(%esp)  # stash funcall-oper in closure slot
# emit-expr f6411
# emit-variable-ref
# env=((f6414 . -16) (f6411 . -12) (f6405 . -8))
# var=f6411
    movl -12(%esp), %eax  # stack load f6411
# end emit-variable-ref
    mov %eax, -32(%esp)  # arg f6411
    movl -28(%esp), %edi   # load new closure to %edi
    add $-20, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $20, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    cmp $95, %eax
    mov $0, %eax
    sete %al
    movzbl %al, %eax
    sal $6, %al
    or $47, %al
    cmp $47, %eax
    sete %al
    movzbl %al, %eax
    sal $6, %al
    or $47, %al
    cmp $47, %al
    je _L_38892
# emit-expr (begin ((primitive-ref port-unread-clear) f6411))
# emit-begin
#   expr=(begin ((primitive-ref port-unread-clear) f6411))
#   env=((f6414 . -16) (f6411 . -12) (f6405 . -8))
# emit-expr ((primitive-ref port-unread-clear) f6411)
# funcall
#    si   =-20
#    env  = ((f6414 . -16) (f6411 . -12) (f6405 . -8))
#    expr = (funcall (primitive-ref port-unread-clear) f6411)
# emit-expr (primitive-ref port-unread-clear)
    .extern mrc_port$munread$mclear
    movl mrc_port$munread$mclear,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_38895"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_38895":
   movl %eax,  -28(%esp)  # stash funcall-oper in closure slot
# emit-expr f6411
# emit-variable-ref
# env=((f6414 . -16) (f6411 . -12) (f6405 . -8))
# var=f6411
    movl -12(%esp), %eax  # stack load f6411
# end emit-variable-ref
    mov %eax, -32(%esp)  # arg f6411
    movl -28(%esp), %edi   # load new closure to %edi
    add $-20, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $20, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
# emit-expr (begin)
# emit-begin
#   expr=(begin)
#   env=((f6414 . -16) (f6411 . -12) (f6405 . -8))
    jmp _L_38893
_L_38892:
# emit-expr #f
    movl $47, %eax     # immed #f
_L_38893:
# emit-tail-expr
# si=-20
# env=((f6414 . -16) (f6411 . -12) (f6405 . -8))
# expr=(begin f6414)
# tail-begin (begin f6414)
#   env=((f6414 . -16) (f6411 . -12) (f6405 . -8))
# emit-tail-expr
# si=-20
# env=((f6414 . -16) (f6411 . -12) (f6405 . -8))
# expr=f6414
# emit-tail-variable-ref
# emit-variable-ref
# env=((f6414 . -16) (f6411 . -12) (f6405 . -8))
# var=f6414
    movl -16(%esp), %eax  # stack load f6414
# end emit-variable-ref
    ret
# end emit-tail-variable ref
     ret   # return thru stack
    jmp _L_38889
_L_38888:
# emit-tail-expr
# si=-16
# env=((f6411 . -12) (f6405 . -8))
# expr=(begin (if (fx= ((primitive-ref port-last) f6411) ((primitive-ref port-ndx) f6411)) (begin ((primitive-ref fill-input-buffer) f6411)) #f) (if ((primitive-ref port-unread) f6411) ((primitive-ref port-unread) f6411) (let ((f6415 (string-ref ((primitive-ref port-buf) f6411) ((primitive-ref port-ndx) f6411)))) (begin ((primitive-ref port-ndx-add1) f6411) f6415))))
# tail-begin (begin (if (fx= ((primitive-ref port-last) f6411) ((primitive-ref port-ndx) f6411)) (begin ((primitive-ref fill-input-buffer) f6411)) #f) (if ((primitive-ref port-unread) f6411) ((primitive-ref port-unread) f6411) (let ((f6415 (string-ref ((primitive-ref port-buf) f6411) ((primitive-ref port-ndx) f6411)))) (begin ((primitive-ref port-ndx-add1) f6411) f6415))))
#   env=((f6411 . -12) (f6405 . -8))
# emit-expr (if (fx= ((primitive-ref port-last) f6411) ((primitive-ref port-ndx) f6411)) (begin ((primitive-ref fill-input-buffer) f6411)) #f)
# emit-expr (fx= ((primitive-ref port-last) f6411) ((primitive-ref port-ndx) f6411))
# emit-expr ((primitive-ref port-ndx) f6411)
# funcall
#    si   =-16
#    env  = ((f6411 . -12) (f6405 . -8))
#    expr = (funcall (primitive-ref port-ndx) f6411)
# emit-expr (primitive-ref port-ndx)
    .extern mrc_port$mndx
    movl mrc_port$mndx,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_38898"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_38898":
   movl %eax,  -24(%esp)  # stash funcall-oper in closure slot
# emit-expr f6411
# emit-variable-ref
# env=((f6411 . -12) (f6405 . -8))
# var=f6411
    movl -12(%esp), %eax  # stack load f6411
# end emit-variable-ref
    mov %eax, -28(%esp)  # arg f6411
    movl -24(%esp), %edi   # load new closure to %edi
    add $-16, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $16, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_38899"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $68,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_38899:
    movl %eax, -16(%esp)
# emit-expr ((primitive-ref port-last) f6411)
# funcall
#    si   =-20
#    env  = ((f6411 . -12) (f6405 . -8))
#    expr = (funcall (primitive-ref port-last) f6411)
# emit-expr (primitive-ref port-last)
    .extern mrc_port$mlast
    movl mrc_port$mlast,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_38900"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_38900":
   movl %eax,  -28(%esp)  # stash funcall-oper in closure slot
# emit-expr f6411
# emit-variable-ref
# env=((f6411 . -12) (f6405 . -8))
# var=f6411
    movl -12(%esp), %eax  # stack load f6411
# end emit-variable-ref
    mov %eax, -32(%esp)  # arg f6411
    movl -28(%esp), %edi   # load new closure to %edi
    add $-20, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $20, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_38901"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $68,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_38901:
    cmp -16(%esp), %eax
    sete %al
    movzbl %al, %eax
    sal $6, %al
    or $47, %al
    cmp $47, %al
    je _L_38896
# emit-expr (begin ((primitive-ref fill-input-buffer) f6411))
# emit-begin
#   expr=(begin ((primitive-ref fill-input-buffer) f6411))
#   env=((f6411 . -12) (f6405 . -8))
# emit-expr ((primitive-ref fill-input-buffer) f6411)
# funcall
#    si   =-16
#    env  = ((f6411 . -12) (f6405 . -8))
#    expr = (funcall (primitive-ref fill-input-buffer) f6411)
# emit-expr (primitive-ref fill-input-buffer)
    .extern mrc_fill$minput$mbuffer
    movl mrc_fill$minput$mbuffer,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_38902"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_38902":
   movl %eax,  -24(%esp)  # stash funcall-oper in closure slot
# emit-expr f6411
# emit-variable-ref
# env=((f6411 . -12) (f6405 . -8))
# var=f6411
    movl -12(%esp), %eax  # stack load f6411
# end emit-variable-ref
    mov %eax, -28(%esp)  # arg f6411
    movl -24(%esp), %edi   # load new closure to %edi
    add $-16, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $16, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
# emit-expr (begin)
# emit-begin
#   expr=(begin)
#   env=((f6411 . -12) (f6405 . -8))
    jmp _L_38897
_L_38896:
# emit-expr #f
    movl $47, %eax     # immed #f
_L_38897:
# emit-tail-expr
# si=-16
# env=((f6411 . -12) (f6405 . -8))
# expr=(begin (if ((primitive-ref port-unread) f6411) ((primitive-ref port-unread) f6411) (let ((f6415 (string-ref ((primitive-ref port-buf) f6411) ((primitive-ref port-ndx) f6411)))) (begin ((primitive-ref port-ndx-add1) f6411) f6415))))
# tail-begin (begin (if ((primitive-ref port-unread) f6411) ((primitive-ref port-unread) f6411) (let ((f6415 (string-ref ((primitive-ref port-buf) f6411) ((primitive-ref port-ndx) f6411)))) (begin ((primitive-ref port-ndx-add1) f6411) f6415))))
#   env=((f6411 . -12) (f6405 . -8))
# emit-tail-expr
# si=-16
# env=((f6411 . -12) (f6405 . -8))
# expr=(if ((primitive-ref port-unread) f6411) ((primitive-ref port-unread) f6411) (let ((f6415 (string-ref ((primitive-ref port-buf) f6411) ((primitive-ref port-ndx) f6411)))) (begin ((primitive-ref port-ndx-add1) f6411) f6415)))
# emit-expr ((primitive-ref port-unread) f6411)
# funcall
#    si   =-16
#    env  = ((f6411 . -12) (f6405 . -8))
#    expr = (funcall (primitive-ref port-unread) f6411)
# emit-expr (primitive-ref port-unread)
    .extern mrc_port$munread
    movl mrc_port$munread,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_38905"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_38905":
   movl %eax,  -24(%esp)  # stash funcall-oper in closure slot
# emit-expr f6411
# emit-variable-ref
# env=((f6411 . -12) (f6405 . -8))
# var=f6411
    movl -12(%esp), %eax  # stack load f6411
# end emit-variable-ref
    mov %eax, -28(%esp)  # arg f6411
    movl -24(%esp), %edi   # load new closure to %edi
    add $-16, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $16, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    cmp $47, %al
    je _L_38903
# emit-tail-expr
# si=-16
# env=((f6411 . -12) (f6405 . -8))
# expr=((primitive-ref port-unread) f6411)
# emit-tail-funcall
#    si   =-16
#    env  = ((f6411 . -12) (f6405 . -8))
#    expr = (funcall (primitive-ref port-unread) f6411)
# emit-expr (primitive-ref port-unread)
    .extern mrc_port$munread
    movl mrc_port$munread,%eax
   movl %eax,  -16(%esp)  # stash funcall-oper in next closure slot
# emit-expr f6411
# emit-variable-ref
# env=((f6411 . -12) (f6405 . -8))
# var=f6411
    movl -12(%esp), %eax  # stack load f6411
# end emit-variable-ref
    mov %eax, -20(%esp)    # arg f6411
    movl -16(%esp), %edi   # load new closure to %edi
# emit-shift-args:  size=2   si=-16  delta=12
    mov -16(%esp), %ebx  # shift frame cell
    mov %ebx, -4(%esp)  # down to base
# emit-shift-args:  size=1   si=-20  delta=12
    mov -20(%esp), %ebx  # shift frame cell
    mov %ebx, -8(%esp)  # down to base
# emit-shift-args:  size=0   si=-24  delta=12
    movl $4,%eax   # save arg count
    jmp *-2(%edi)  # tail-funcall
    jmp _L_38904
_L_38903:
# emit-tail-expr
# si=-16
# env=((f6411 . -12) (f6405 . -8))
# expr=(let ((f6415 (string-ref ((primitive-ref port-buf) f6411) ((primitive-ref port-ndx) f6411)))) (begin ((primitive-ref port-ndx-add1) f6411) f6415))
# emit-tail-let
#  si   = -16
#  env  = ((f6411 . -12) (f6405 . -8))
#  bindings = ((f6415 (string-ref ((primitive-ref port-buf) f6411) ((primitive-ref port-ndx) f6411))))
#  body = (begin ((primitive-ref port-ndx-add1) f6411) f6415)
# emit-expr (string-ref ((primitive-ref port-buf) f6411) ((primitive-ref port-ndx) f6411))
# emit-expr ((primitive-ref port-buf) f6411)
# funcall
#    si   =-16
#    env  = ((f6411 . -12) (f6405 . -8))
#    expr = (funcall (primitive-ref port-buf) f6411)
# emit-expr (primitive-ref port-buf)
    .extern mrc_port$mbuf
    movl mrc_port$mbuf,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_38906"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_38906":
   movl %eax,  -24(%esp)  # stash funcall-oper in closure slot
# emit-expr f6411
# emit-variable-ref
# env=((f6411 . -12) (f6405 . -8))
# var=f6411
    movl -12(%esp), %eax  # stack load f6411
# end emit-variable-ref
    mov %eax, -28(%esp)  # arg f6411
    movl -24(%esp), %edi   # load new closure to %edi
    add $-16, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $16, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
# check the argument is a string
    movl %eax,%ebx
    and $7, %bl
    cmp $6, %bl
    je _L_38907
# invoke error handler eh_string
    .extern mrc_eh$ustring
    movl mrc_eh$ustring, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $164,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_38907:
    movl %eax, -16(%esp)
# emit-expr ((primitive-ref port-ndx) f6411)
# funcall
#    si   =-16
#    env  = ((f6411 . -12) (f6405 . -8))
#    expr = (funcall (primitive-ref port-ndx) f6411)
# emit-expr (primitive-ref port-ndx)
    .extern mrc_port$mndx
    movl mrc_port$mndx,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_38908"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_38908":
   movl %eax,  -24(%esp)  # stash funcall-oper in closure slot
# emit-expr f6411
# emit-variable-ref
# env=((f6411 . -12) (f6405 . -8))
# var=f6411
    movl -12(%esp), %eax  # stack load f6411
# end emit-variable-ref
    mov %eax, -28(%esp)  # arg f6411
    movl -24(%esp), %edi   # load new closure to %edi
    add $-16, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $16, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_38909"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $164,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_38909:
# check bounds on string index
    movl -16(%esp), %ebx
    cmp  %eax,-6(%ebx) 
    jle _L_38911
    cmp  $0,%eax
    jge _L_38910
_L_38911:
# invoke error handler eh_string_index
    .extern mrc_eh$ustring$uindex
    movl mrc_eh$ustring$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $164,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_38910:
    sar $2, %eax
    movl -16(%esp), %esi
    movl -2(%eax,%esi), %eax
    sal $8, %eax
    or  $15, %eax
    movl %eax, -16(%esp)  # stack save
# emit-tail-expr
# si=-20
# env=((f6415 . -16) (f6411 . -12) (f6405 . -8))
# expr=(begin ((primitive-ref port-ndx-add1) f6411) f6415)
# tail-begin (begin ((primitive-ref port-ndx-add1) f6411) f6415)
#   env=((f6415 . -16) (f6411 . -12) (f6405 . -8))
# emit-expr ((primitive-ref port-ndx-add1) f6411)
# funcall
#    si   =-20
#    env  = ((f6415 . -16) (f6411 . -12) (f6405 . -8))
#    expr = (funcall (primitive-ref port-ndx-add1) f6411)
# emit-expr (primitive-ref port-ndx-add1)
    .extern mrc_port$mndx$madd1
    movl mrc_port$mndx$madd1,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_38912"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_38912":
   movl %eax,  -28(%esp)  # stash funcall-oper in closure slot
# emit-expr f6411
# emit-variable-ref
# env=((f6415 . -16) (f6411 . -12) (f6405 . -8))
# var=f6411
    movl -12(%esp), %eax  # stack load f6411
# end emit-variable-ref
    mov %eax, -32(%esp)  # arg f6411
    movl -28(%esp), %edi   # load new closure to %edi
    add $-20, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $20, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
# emit-tail-expr
# si=-20
# env=((f6415 . -16) (f6411 . -12) (f6405 . -8))
# expr=(begin f6415)
# tail-begin (begin f6415)
#   env=((f6415 . -16) (f6411 . -12) (f6405 . -8))
# emit-tail-expr
# si=-20
# env=((f6415 . -16) (f6411 . -12) (f6405 . -8))
# expr=f6415
# emit-tail-variable-ref
# emit-variable-ref
# env=((f6415 . -16) (f6411 . -12) (f6405 . -8))
# var=f6415
    movl -16(%esp), %eax  # stack load f6415
# end emit-variable-ref
    ret
# end emit-tail-variable ref
     ret   # return thru stack
_L_38904:
     ret   # return thru stack
_L_38889:
    .align 4,0x90
_L_38880:
     movl %eax, mrc_read$mchar
# == explicit-begins  ==>
# (lambda (p) (let ((nbytes (foreign-call "s_read" (port-fd p) (port-buf p) (port-size p)))) (begin (port-ndx-reset p) (port-last-set! p nbytes) (when (fxzero? nbytes) (port-unread-set! p (eof-object))))))
# == eliminate-let*  ==>
# (lambda (p) (let ((nbytes (foreign-call "s_read" (port-fd p) (port-buf p) (port-size p)))) (begin (port-ndx-reset p) (port-last-set! p nbytes) (when (fxzero? nbytes) (port-unread-set! p (eof-object))))))
# == uniquify-variables  ==>
# (lambda (f6416) (let ((f6418 (foreign-call "s_read" (port-fd f6416) (port-buf f6416) (port-size f6416)))) (begin (port-ndx-reset f6416) (port-last-set! f6416 f6418) (when (fxzero? f6418) (port-unread-set! f6416 (eof-object))))))
# == vectorize-letrec  ==>
# (lambda (f6416) (let ((f6418 (foreign-call "s_read" (port-fd f6416) (port-buf f6416) (port-size f6416)))) (begin (port-ndx-reset f6416) (port-last-set! f6416 f6418) (when (fxzero? f6418) (port-unread-set! f6416 (eof-object))))))
# == eliminate-set!  ==>
# (lambda (f6416) (let ((f6416 f6416)) (let ((f6418 (foreign-call "s_read" (port-fd f6416) (port-buf f6416) (port-size f6416)))) (begin (port-ndx-reset f6416) (port-last-set! f6416 f6418) (when (fxzero? f6418) (port-unread-set! f6416 (eof-object)))))))
# == close-free-variables  ==>
# (closure (f6416) () (let ((f6416 f6416)) (let ((f6418 (foreign-call "s_read" (port-fd f6416) (port-buf f6416) (port-size f6416)))) (begin (port-ndx-reset f6416) (port-last-set! f6416 f6418) (when (fxzero? f6418) (port-unread-set! f6416 (eof-object)))))))
# == eliminate-quote  ==>
# (closure (f6416) () (let ((f6416 f6416)) (let ((f6418 (foreign-call "s_read" (port-fd f6416) (port-buf f6416) (port-size f6416)))) (begin (port-ndx-reset f6416) (port-last-set! f6416 f6418) (when (fxzero? f6418) (port-unread-set! f6416 (eof-object)))))))
# == eliminate-when/unless  ==>
# (closure (f6416) () (let ((f6416 f6416)) (let ((f6418 (foreign-call "s_read" (port-fd f6416) (port-buf f6416) (port-size f6416)))) (begin (port-ndx-reset f6416) (port-last-set! f6416 f6418) (if (fxzero? f6418) (begin (port-unread-set! f6416 (eof-object))) #f)))))
# == eliminate-cond  ==>
# (closure (f6416) () (let ((f6416 f6416)) (let ((f6418 (foreign-call "s_read" (port-fd f6416) (port-buf f6416) (port-size f6416)))) (begin (port-ndx-reset f6416) (port-last-set! f6416 f6418) (if (fxzero? f6418) (begin (port-unread-set! f6416 (eof-object))) #f)))))
# == external-symbols  ==>
# (closure (f6416) () (let ((f6416 f6416)) (let ((f6418 (foreign-call "s_read" ((primitive-ref port-fd) f6416) ((primitive-ref port-buf) f6416) ((primitive-ref port-size) f6416)))) (begin ((primitive-ref port-ndx-reset) f6416) ((primitive-ref port-last-set!) f6416 f6418) (if (fxzero? f6418) (begin ((primitive-ref port-unread-set!) f6416 (eof-object))) #f)))))
# emit-expr (closure (f6416) () (let ((f6416 f6416)) (let ((f6418 (foreign-call "s_read" ((primitive-ref port-fd) f6416) ((primitive-ref port-buf) f6416) ((primitive-ref port-size) f6416)))) (begin ((primitive-ref port-ndx-reset) f6416) ((primitive-ref port-last-set!) f6416 f6418) (if (fxzero? f6418) (begin ((primitive-ref port-unread-set!) f6416 (eof-object))) #f)))))
# emit-closure
# si = 0
# env = ()
# expr = (closure (f6416) () (let ((f6416 f6416)) (let ((f6418 (foreign-call "s_read" ((primitive-ref port-fd) f6416) ((primitive-ref port-buf) f6416) ((primitive-ref port-size) f6416)))) (begin ((primitive-ref port-ndx-reset) f6416) ((primitive-ref port-last-set!) f6416 f6418) (if (fxzero? f6418) (begin ((primitive-ref port-unread-set!) f6416 (eof-object))) #f)))))
    movl $_L_38913, 0(%ebp)  # closure label
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $8, %ebp     # bump ebp
    jmp _L_38914            # jump around closure body
_L_38913:
# check argument count
    cmp $4,%eax
    je _L_38915
# invoke error handler eh_argcount
    .extern mrc_eh$uargcount
    movl mrc_eh$uargcount, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_38915:
# emit-tail-expr
# si=-12
# env=((f6416 . -8))
# expr=(let ((f6416 f6416)) (let ((f6418 (foreign-call "s_read" ((primitive-ref port-fd) f6416) ((primitive-ref port-buf) f6416) ((primitive-ref port-size) f6416)))) (begin ((primitive-ref port-ndx-reset) f6416) ((primitive-ref port-last-set!) f6416 f6418) (if (fxzero? f6418) (begin ((primitive-ref port-unread-set!) f6416 (eof-object))) #f))))
# emit-tail-let
#  si   = -12
#  env  = ((f6416 . -8))
#  bindings = ((f6416 f6416))
#  body = (let ((f6418 (foreign-call "s_read" ((primitive-ref port-fd) f6416) ((primitive-ref port-buf) f6416) ((primitive-ref port-size) f6416)))) (begin ((primitive-ref port-ndx-reset) f6416) ((primitive-ref port-last-set!) f6416 f6418) (if (fxzero? f6418) (begin ((primitive-ref port-unread-set!) f6416 (eof-object))) #f)))
# emit-expr f6416
# emit-variable-ref
# env=((f6416 . -8))
# var=f6416
    movl -8(%esp), %eax  # stack load f6416
# end emit-variable-ref
    movl %eax, -12(%esp)  # stack save
# emit-tail-expr
# si=-16
# env=((f6416 . -12) (f6416 . -8))
# expr=(let ((f6418 (foreign-call "s_read" ((primitive-ref port-fd) f6416) ((primitive-ref port-buf) f6416) ((primitive-ref port-size) f6416)))) (begin ((primitive-ref port-ndx-reset) f6416) ((primitive-ref port-last-set!) f6416 f6418) (if (fxzero? f6418) (begin ((primitive-ref port-unread-set!) f6416 (eof-object))) #f)))
# emit-tail-let
#  si   = -16
#  env  = ((f6416 . -12) (f6416 . -8))
#  bindings = ((f6418 (foreign-call "s_read" ((primitive-ref port-fd) f6416) ((primitive-ref port-buf) f6416) ((primitive-ref port-size) f6416))))
#  body = (begin ((primitive-ref port-ndx-reset) f6416) ((primitive-ref port-last-set!) f6416 f6418) (if (fxzero? f6418) (begin ((primitive-ref port-unread-set!) f6416 (eof-object))) #f))
# emit-expr (foreign-call "s_read" ((primitive-ref port-fd) f6416) ((primitive-ref port-buf) f6416) ((primitive-ref port-size) f6416))
    movl %ecx,-16(%esp)
    movl %esp,-20(%esp)
# emit-expr ((primitive-ref port-size) f6416)
# funcall
#    si   =-24
#    env  = ((f6416 . -12) (f6416 . -8))
#    expr = (funcall (primitive-ref port-size) f6416)
# emit-expr (primitive-ref port-size)
    .extern mrc_port$msize
    movl mrc_port$msize,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_38916"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_38916":
   movl %eax,  -32(%esp)  # stash funcall-oper in closure slot
# emit-expr f6416
# emit-variable-ref
# env=((f6416 . -12) (f6416 . -8))
# var=f6416
    movl -12(%esp), %eax  # stack load f6416
# end emit-variable-ref
    mov %eax, -36(%esp)  # arg f6416
    movl -32(%esp), %edi   # load new closure to %edi
    add $-24, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $24, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    movl %eax, -24(%esp)
# emit-expr ((primitive-ref port-buf) f6416)
# funcall
#    si   =-28
#    env  = ((f6416 . -12) (f6416 . -8))
#    expr = (funcall (primitive-ref port-buf) f6416)
# emit-expr (primitive-ref port-buf)
    .extern mrc_port$mbuf
    movl mrc_port$mbuf,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_38917"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_38917":
   movl %eax,  -36(%esp)  # stash funcall-oper in closure slot
# emit-expr f6416
# emit-variable-ref
# env=((f6416 . -12) (f6416 . -8))
# var=f6416
    movl -12(%esp), %eax  # stack load f6416
# end emit-variable-ref
    mov %eax, -40(%esp)  # arg f6416
    movl -36(%esp), %edi   # load new closure to %edi
    add $-28, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $28, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    movl %eax, -28(%esp)
# emit-expr ((primitive-ref port-fd) f6416)
# funcall
#    si   =-32
#    env  = ((f6416 . -12) (f6416 . -8))
#    expr = (funcall (primitive-ref port-fd) f6416)
# emit-expr (primitive-ref port-fd)
    .extern mrc_port$mfd
    movl mrc_port$mfd,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_38918"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_38918":
   movl %eax,  -40(%esp)  # stash funcall-oper in closure slot
# emit-expr f6416
# emit-variable-ref
# env=((f6416 . -12) (f6416 . -8))
# var=f6416
    movl -12(%esp), %eax  # stack load f6416
# end emit-variable-ref
    mov %eax, -44(%esp)  # arg f6416
    movl -40(%esp), %edi   # load new closure to %edi
    add $-32, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $32, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    movl %eax, -32(%esp)
    leal -32(%esp),%edi
    movl %edi,%esi
    andl $-16,%esi
    movl 0(%edi),%eax
    movl %eax,0(%esi)
    movl 4(%edi),%eax
    movl %eax,4(%esi)
    movl 8(%edi),%eax
    movl %eax,8(%esi)
    movl 12(%edi),%eax
    movl %eax,12(%esi)
    movl %esi,%esp
    .extern _s_read
    call _s_read
    movl 12(%esi),%esp
    movl -16(%esp),%ecx
    movl %eax, -16(%esp)  # stack save
# emit-tail-expr
# si=-20
# env=((f6418 . -16) (f6416 . -12) (f6416 . -8))
# expr=(begin ((primitive-ref port-ndx-reset) f6416) ((primitive-ref port-last-set!) f6416 f6418) (if (fxzero? f6418) (begin ((primitive-ref port-unread-set!) f6416 (eof-object))) #f))
# tail-begin (begin ((primitive-ref port-ndx-reset) f6416) ((primitive-ref port-last-set!) f6416 f6418) (if (fxzero? f6418) (begin ((primitive-ref port-unread-set!) f6416 (eof-object))) #f))
#   env=((f6418 . -16) (f6416 . -12) (f6416 . -8))
# emit-expr ((primitive-ref port-ndx-reset) f6416)
# funcall
#    si   =-20
#    env  = ((f6418 . -16) (f6416 . -12) (f6416 . -8))
#    expr = (funcall (primitive-ref port-ndx-reset) f6416)
# emit-expr (primitive-ref port-ndx-reset)
    .extern mrc_port$mndx$mreset
    movl mrc_port$mndx$mreset,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_38919"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_38919":
   movl %eax,  -28(%esp)  # stash funcall-oper in closure slot
# emit-expr f6416
# emit-variable-ref
# env=((f6418 . -16) (f6416 . -12) (f6416 . -8))
# var=f6416
    movl -12(%esp), %eax  # stack load f6416
# end emit-variable-ref
    mov %eax, -32(%esp)  # arg f6416
    movl -28(%esp), %edi   # load new closure to %edi
    add $-20, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $20, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
# emit-tail-expr
# si=-20
# env=((f6418 . -16) (f6416 . -12) (f6416 . -8))
# expr=(begin ((primitive-ref port-last-set!) f6416 f6418) (if (fxzero? f6418) (begin ((primitive-ref port-unread-set!) f6416 (eof-object))) #f))
# tail-begin (begin ((primitive-ref port-last-set!) f6416 f6418) (if (fxzero? f6418) (begin ((primitive-ref port-unread-set!) f6416 (eof-object))) #f))
#   env=((f6418 . -16) (f6416 . -12) (f6416 . -8))
# emit-expr ((primitive-ref port-last-set!) f6416 f6418)
# funcall
#    si   =-20
#    env  = ((f6418 . -16) (f6416 . -12) (f6416 . -8))
#    expr = (funcall (primitive-ref port-last-set!) f6416 f6418)
# emit-expr (primitive-ref port-last-set!)
    .extern mrc_port$mlast$mset$b
    movl mrc_port$mlast$mset$b,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_38920"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_38920":
   movl %eax,  -28(%esp)  # stash funcall-oper in closure slot
# emit-expr f6416
# emit-variable-ref
# env=((f6418 . -16) (f6416 . -12) (f6416 . -8))
# var=f6416
    movl -12(%esp), %eax  # stack load f6416
# end emit-variable-ref
    mov %eax, -32(%esp)  # arg f6416
# emit-expr f6418
# emit-variable-ref
# env=((f6418 . -16) (f6416 . -12) (f6416 . -8))
# var=f6418
    movl -16(%esp), %eax  # stack load f6418
# end emit-variable-ref
    mov %eax, -36(%esp)  # arg f6418
    movl -28(%esp), %edi   # load new closure to %edi
    add $-20, %esp   # adjust base
    movl $8,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $20, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
# emit-tail-expr
# si=-20
# env=((f6418 . -16) (f6416 . -12) (f6416 . -8))
# expr=(begin (if (fxzero? f6418) (begin ((primitive-ref port-unread-set!) f6416 (eof-object))) #f))
# tail-begin (begin (if (fxzero? f6418) (begin ((primitive-ref port-unread-set!) f6416 (eof-object))) #f))
#   env=((f6418 . -16) (f6416 . -12) (f6416 . -8))
# emit-tail-expr
# si=-20
# env=((f6418 . -16) (f6416 . -12) (f6416 . -8))
# expr=(if (fxzero? f6418) (begin ((primitive-ref port-unread-set!) f6416 (eof-object))) #f)
# emit-expr (fxzero? f6418)
# emit-expr f6418
# emit-variable-ref
# env=((f6418 . -16) (f6416 . -12) (f6416 . -8))
# var=f6418
    movl -16(%esp), %eax  # stack load f6418
# end emit-variable-ref
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_38923"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $64,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_38923:
    cmp $0, %eax
    sete %al
    movzbl %al, %eax
    sal $6, %al
    or $47, %al
    cmp $47, %al
    je _L_38921
# emit-tail-expr
# si=-20
# env=((f6418 . -16) (f6416 . -12) (f6416 . -8))
# expr=(begin ((primitive-ref port-unread-set!) f6416 (eof-object)))
# tail-begin (begin ((primitive-ref port-unread-set!) f6416 (eof-object)))
#   env=((f6418 . -16) (f6416 . -12) (f6416 . -8))
# emit-tail-expr
# si=-20
# env=((f6418 . -16) (f6416 . -12) (f6416 . -8))
# expr=((primitive-ref port-unread-set!) f6416 (eof-object))
# emit-tail-funcall
#    si   =-20
#    env  = ((f6418 . -16) (f6416 . -12) (f6416 . -8))
#    expr = (funcall (primitive-ref port-unread-set!) f6416 (eof-object))
# emit-expr (primitive-ref port-unread-set!)
    .extern mrc_port$munread$mset$b
    movl mrc_port$munread$mset$b,%eax
   movl %eax,  -20(%esp)  # stash funcall-oper in next closure slot
# emit-expr f6416
# emit-variable-ref
# env=((f6418 . -16) (f6416 . -12) (f6416 . -8))
# var=f6416
    movl -12(%esp), %eax  # stack load f6416
# end emit-variable-ref
    mov %eax, -24(%esp)    # arg f6416
# emit-expr (eof-object)
    movl $95,%eax
    mov %eax, -28(%esp)    # arg (eof-object)
    movl -20(%esp), %edi   # load new closure to %edi
# emit-shift-args:  size=3   si=-20  delta=16
    mov -20(%esp), %ebx  # shift frame cell
    mov %ebx, -4(%esp)  # down to base
# emit-shift-args:  size=2   si=-24  delta=16
    mov -24(%esp), %ebx  # shift frame cell
    mov %ebx, -8(%esp)  # down to base
# emit-shift-args:  size=1   si=-28  delta=16
    mov -28(%esp), %ebx  # shift frame cell
    mov %ebx, -12(%esp)  # down to base
# emit-shift-args:  size=0   si=-32  delta=16
    movl $8,%eax   # save arg count
    jmp *-2(%edi)  # tail-funcall
     ret   # return thru stack
    jmp _L_38922
_L_38921:
# emit-tail-expr
# si=-20
# env=((f6418 . -16) (f6416 . -12) (f6416 . -8))
# expr=#f
    movl $47, %eax     # immed #f
    ret                  # immediate tail return
_L_38922:
     ret   # return thru stack
    .align 4,0x90
_L_38914:
     movl %eax, mrc_fill$minput$mbuffer
# == explicit-begins  ==>
# (quote TBD)
# == eliminate-let*  ==>
# (quote TBD)
# == uniquify-variables  ==>
# (quote TBD)
# == vectorize-letrec  ==>
# (quote TBD)
# == eliminate-set!  ==>
# (quote TBD)
# == close-free-variables  ==>
# (quote TBD)
# == eliminate-quote  ==>
# (string->symbol "TBD")
# == eliminate-when/unless  ==>
# (string->symbol "TBD")
# == eliminate-cond  ==>
# (string->symbol "TBD")
# == external-symbols  ==>
# ((primitive-ref string->symbol) "TBD")
# emit-expr ((primitive-ref string->symbol) "TBD")
# funcall
#    si   =0
#    env  = ()
#    expr = (funcall (primitive-ref string->symbol) "TBD")
# emit-expr (primitive-ref string->symbol)
    .extern mrc_string$m$gsymbol
    movl mrc_string$m$gsymbol,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_38924"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_38924":
   movl %eax,  -8(%esp)  # stash funcall-oper in closure slot
# emit-expr "TBD"
# string literal
    jmp _L_38926
    .align 8,0x90
_L_38925 :
    .int 12
    .ascii "TBD"
_L_38926:
    movl $_L_38925, %eax
    orl $6, %eax
    mov %eax, -12(%esp)  # arg TBD
    movl -8(%esp), %edi   # load new closure to %edi
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    movl -4(%esp), %edi   # restore closure frame ptr
     movl %eax, mrc_unread$mchar
# emit-expr (begin #t)
# emit-begin
#   expr=(begin #t)
#   env=()
# emit-expr #t
    movl $111, %eax     # immed #t
# emit-expr (begin)
# emit-begin
#   expr=(begin)
#   env=()
    .extern base_init_callback
    jmp base_init_callback
