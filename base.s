     .data
     .global "mrc_symbols"
     .align 8
mrc_symbols:
     .int 0xFF
     .global "mrc_string$e$q"
     .align 8
mrc_string$e$q:
     .int 0xFF
     .global "mrc_string$m$gsymbol"
     .align 8
mrc_string$m$gsymbol:
     .int 0xFF
     .global "mrc_append1"
     .align 8
mrc_append1:
     .int 0xFF
     .global "mrc_list$mref"
     .align 8
mrc_list$mref:
     .int 0xFF
     .global "mrc_list$mlength"
     .align 8
mrc_list$mlength:
     .int 0xFF
     .global "mrc_reverse"
     .align 8
mrc_reverse:
     .int 0xFF
     .global "mrc_vector"
     .align 8
mrc_vector:
     .int 0xFF
     .global "mrc_string"
     .align 8
mrc_string:
     .int 0xFF
     .global "mrc_string$m$glist"
     .align 8
mrc_string$m$glist:
     .int 0xFF
     .global "mrc_integer$m$glist"
     .align 8
mrc_integer$m$glist:
     .int 0xFF
     .global "mrc_error"
     .align 8
mrc_error:
     .int 0xFF
     .global "mrc_primitives"
     .align 8
mrc_primitives:
     .int 0xFF
     .global "mrc_eh$uprocedure"
     .align 8
mrc_eh$uprocedure:
     .int 0xFF
     .global "mrc_eh$uargcount"
     .align 8
mrc_eh$uargcount:
     .int 0xFF
     .global "mrc_eh$uargcount$umin"
     .align 8
mrc_eh$uargcount$umin:
     .int 0xFF
     .global "mrc_eh$ufixnum"
     .align 8
mrc_eh$ufixnum:
     .int 0xFF
     .global "mrc_eh$ustring"
     .align 8
mrc_eh$ustring:
     .int 0xFF
     .global "mrc_eh$ucharacter"
     .align 8
mrc_eh$ucharacter:
     .int 0xFF
     .global "mrc_eh$upair"
     .align 8
mrc_eh$upair:
     .int 0xFF
     .global "mrc_eh$uvector"
     .align 8
mrc_eh$uvector:
     .int 0xFF
     .global "mrc_eh$ulength"
     .align 8
mrc_eh$ulength:
     .int 0xFF
     .global "mrc_eh$uvector$uindex"
     .align 8
mrc_eh$uvector$uindex:
     .int 0xFF
     .global "mrc_eh$ustring$uindex"
     .align 8
mrc_eh$ustring$uindex:
     .int 0xFF
     .global "mrc_zero$q"
     .align 8
mrc_zero$q:
     .int 0xFF
     .global "mrc_positive$q"
     .align 8
mrc_positive$q:
     .int 0xFF
     .global "mrc_negative$q"
     .align 8
mrc_negative$q:
     .int 0xFF
     .global "mrc_map"
     .align 8
mrc_map:
     .int 0xFF
     .global "mrc_for$meach"
     .align 8
mrc_for$meach:
     .int 0xFF
     .global "mrc_standard$mout"
     .align 8
mrc_standard$mout:
     .int 0xFF
     .global "mrc_current$moutput$mport"
     .align 8
mrc_current$moutput$mport:
     .int 0xFF
     .global "mrc_port$mfd"
     .align 8
mrc_port$mfd:
     .int 0xFF
     .global "mrc_port$mbuf"
     .align 8
mrc_port$mbuf:
     .int 0xFF
     .global "mrc_port$mndx"
     .align 8
mrc_port$mndx:
     .int 0xFF
     .global "mrc_port$mndx$madd1"
     .align 8
mrc_port$mndx$madd1:
     .int 0xFF
     .global "mrc_port$mndx$mreset"
     .align 8
mrc_port$mndx$mreset:
     .int 0xFF
     .global "mrc_port$msize"
     .align 8
mrc_port$msize:
     .int 0xFF
     .global "mrc_write$mchar"
     .align 8
mrc_write$mchar:
     .int 0xFF
     .global "mrc_flush$moutput$mport"
     .align 8
mrc_flush$moutput$mport:
     .int 0xFF
     .global "mrc_exit"
     .align 8
mrc_exit:
     .int 0xFF
     .global "mrc_output$mport$q"
     .align 8
mrc_output$mport$q:
     .int 0xFF
     .global "mrc_open$moutput$mfile"
     .align 8
mrc_open$moutput$mfile:
     .int 0xFF
     .global "mrc_close$moutput$mport"
     .align 8
mrc_close$moutput$mport:
     .int 0xFF
     .global "mrc_write"
     .align 8
mrc_write:
     .int 0xFF
     .global "mrc_integer$m$gchar"
     .align 8
mrc_integer$m$gchar:
     .int 0xFF
     .text
     .global base_init
     .align 4
base_init:
# == explicit-begins  ==>
# (let ((interned-symbols (cons (make-symbol "nil" ()) ()))) (lambda () interned-symbols))
# == eliminate-let*  ==>
# (let ((interned-symbols (cons (make-symbol "nil" ()) ()))) (lambda () interned-symbols))
# == uniquify-variables  ==>
# (let ((f195865 (cons (make-symbol "nil" ()) ()))) (lambda () f195865))
# == vectorize-letrec  ==>
# (let ((f195865 (cons (make-symbol "nil" ()) ()))) (lambda () f195865))
# == eliminate-set!  ==>
# (let ((f195865 (cons (make-symbol "nil" ()) ()))) (lambda () (let () f195865)))
# == close-free-variables  ==>
# (let ((f195865 (cons (make-symbol "nil" ()) ()))) (closure () (f195865) (let () f195865)))
# == eliminate-quote  ==>
# (let ((f195865 (cons (make-symbol "nil" ()) ()))) (closure () (f195865) (let () f195865)))
# == eliminate-when/unless  ==>
# (let ((f195865 (cons (make-symbol "nil" ()) ()))) (closure () (f195865) (let () f195865)))
# == eliminate-cond  ==>
# (let ((f195865 (cons (make-symbol "nil" ()) ()))) (closure () (f195865) (let () f195865)))
# == external-symbols  ==>
# (let ((f195865 (cons (make-symbol "nil" ()) ()))) (closure () (f195865) (let () f195865)))
# emit-expr (let ((f195865 (cons (make-symbol "nil" ()) ()))) (closure () (f195865) (let () f195865)))
# emit-let
#  si   = 0
#  env  = ()
#  bindings = ((f195865 (cons (make-symbol "nil" ()) ())))
#  body = (closure () (f195865) (let () f195865))
# emit-expr (cons (make-symbol "nil" ()) ())
# cons arg1=(make-symbol "nil" ()) arg2=()
# emit-expr (make-symbol "nil" ())
# make-symbol arg1="nil" arg2=()
# emit-expr "nil"
# string literal
    jmp _L_1431453
    .align 8,0x90
_L_1431452 :
    .int 12
    .ascii "nil"
_L_1431453:
    movl $_L_1431452, %eax
    orl $6, %eax
    movl %eax, 0(%esp)
# emit-expr ()
    movl $63, %eax     # immed ()
    movl %eax, 4(%ebp)
    movl 0(%esp), %eax
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    orl  $3, %eax
    add  $8, %ebp
# make-symbol end
    movl %eax, 0(%esp)
# emit-expr ()
    movl $63, %eax     # immed ()
    movl %eax, 4(%ebp)
    movl 0(%esp), %eax
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    or   $1, %al
    add  $8, %ebp
# cons end
    movl %eax, 0(%esp)  # stack save
# emit-expr (closure () (f195865) (let () f195865))
# emit-closure
# si = -4
# env = ((f195865 . 0))
# expr = (closure () (f195865) (let () f195865))
    movl $_L_1431454, 0(%ebp)  # closure label
# emit-variable-ref
# env=((f195865 . 0))
# var=f195865
    movl 0(%esp), %eax  # stack load f195865
# end emit-variable-ref
   movl  %eax, 4(%ebp)  # f195865
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $8, %ebp     # bump ebp
    jmp _L_1431455            # jump around closure body
_L_1431454:
# check argument count
    cmp $0,%eax
    je _L_1431456
# invoke error handler eh_argcount
    .extern mrc_eh$uargcount
    movl mrc_eh$uargcount, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_1431456:
# emit-tail-expr
# si=-8
# env=((f195865 . 4) (f195865 . 0))
# expr=(let () f195865)
# emit-tail-let
#  si   = -8
#  env  = ((f195865 . 4) (f195865 . 0))
#  bindings = ()
#  body = f195865
# emit-tail-expr
# si=-8
# env=((f195865 . 4) (f195865 . 0))
# expr=f195865
# emit-tail-variable-ref
# emit-variable-ref
# env=((f195865 . 4) (f195865 . 0))
# var=f195865
    movl 2(%edi), %eax  # frame load f195865
# end emit-variable-ref
    ret
# end emit-tail-variable ref
    .align 4,0x90
_L_1431455:
     movl %eax, mrc_symbols
# == explicit-begins  ==>
# (letrec ((slen= (lambda (s1 s2) (fx= (string-length s1) (string-length s2)))) (si= (lambda (s1 s2 i) (char=? (string-ref s1 i) (string-ref s2 i)))) (si<n= (lambda (s1 s2 i n) (if (fx= i n) #t (if (si= s1 s2 i) (si<n= s1 s2 (fx+ i 1) n) #f)))) (ss= (lambda (s1 s2) (if (slen= s1 s2) (si<n= s1 s2 0 (string-length s1)) #f)))) ss=)
# == eliminate-let*  ==>
# (letrec ((slen= (lambda (s1 s2) (fx= (string-length s1) (string-length s2)))) (si= (lambda (s1 s2 i) (char=? (string-ref s1 i) (string-ref s2 i)))) (si<n= (lambda (s1 s2 i n) (if (fx= i n) #t (if (si= s1 s2 i) (si<n= s1 s2 (fx+ i 1) n) #f)))) (ss= (lambda (s1 s2) (if (slen= s1 s2) (si<n= s1 s2 0 (string-length s1)) #f)))) ss=)
# == uniquify-variables  ==>
# (letrec ((f195869 (lambda (f195890 f195891) (fx= (string-length f195890) (string-length f195891)))) (f195868 (lambda (f195887 f195888 f195889) (char=? (string-ref f195887 f195889) (string-ref f195888 f195889)))) (f195867 (lambda (f195883 f195884 f195885 f195886) (if (fx= f195885 f195886) #t (if (f195868 f195883 f195884 f195885) (f195867 f195883 f195884 (fx+ f195885 1) f195886) #f)))) (f195866 (lambda (f195881 f195882) (if (f195869 f195881 f195882) (f195867 f195881 f195882 0 (string-length f195881)) #f)))) f195866)
# == vectorize-letrec  ==>
# (let ((f195869 (make-vector 1)) (f195868 (make-vector 1)) (f195867 (make-vector 1)) (f195866 (make-vector 1))) (begin (begin (vector-set! f195869 0 (lambda (f195890 f195891) (fx= (string-length f195890) (string-length f195891)))) (vector-set! f195868 0 (lambda (f195887 f195888 f195889) (char=? (string-ref f195887 f195889) (string-ref f195888 f195889)))) (vector-set! f195867 0 (lambda (f195883 f195884 f195885 f195886) (if (fx= f195885 f195886) #t (if ((vector-ref f195868 0) f195883 f195884 f195885) ((vector-ref f195867 0) f195883 f195884 (fx+ f195885 1) f195886) #f)))) (vector-set! f195866 0 (lambda (f195881 f195882) (if ((vector-ref f195869 0) f195881 f195882) ((vector-ref f195867 0) f195881 f195882 0 (string-length f195881)) #f)))) (vector-ref f195866 0)))
# == eliminate-set!  ==>
# (let ((f195869 (make-vector 1)) (f195868 (make-vector 1)) (f195867 (make-vector 1)) (f195866 (make-vector 1))) (begin (begin (vector-set! f195869 0 (lambda (f195890 f195891) (let ((f195890 f195890) (f195891 f195891)) (fx= (string-length f195890) (string-length f195891))))) (vector-set! f195868 0 (lambda (f195887 f195888 f195889) (let ((f195887 f195887) (f195888 f195888) (f195889 f195889)) (char=? (string-ref f195887 f195889) (string-ref f195888 f195889))))) (vector-set! f195867 0 (lambda (f195883 f195884 f195885 f195886) (let ((f195883 f195883) (f195884 f195884) (f195885 f195885) (f195886 f195886)) (if (fx= f195885 f195886) #t (if ((vector-ref f195868 0) f195883 f195884 f195885) ((vector-ref f195867 0) f195883 f195884 (fx+ f195885 1) f195886) #f))))) (vector-set! f195866 0 (lambda (f195881 f195882) (let ((f195881 f195881) (f195882 f195882)) (if ((vector-ref f195869 0) f195881 f195882) ((vector-ref f195867 0) f195881 f195882 0 (string-length f195881)) #f))))) (vector-ref f195866 0)))
# == close-free-variables  ==>
# (let ((f195869 (make-vector 1)) (f195868 (make-vector 1)) (f195867 (make-vector 1)) (f195866 (make-vector 1))) (begin (begin (vector-set! f195869 0 (closure (f195890 f195891) () (let ((f195890 f195890) (f195891 f195891)) (fx= (string-length f195890) (string-length f195891))))) (vector-set! f195868 0 (closure (f195887 f195888 f195889) () (let ((f195887 f195887) (f195888 f195888) (f195889 f195889)) (char=? (string-ref f195887 f195889) (string-ref f195888 f195889))))) (vector-set! f195867 0 (closure (f195883 f195884 f195885 f195886) (f195868 f195867) (let ((f195883 f195883) (f195884 f195884) (f195885 f195885) (f195886 f195886)) (if (fx= f195885 f195886) #t (if ((vector-ref f195868 0) f195883 f195884 f195885) ((vector-ref f195867 0) f195883 f195884 (fx+ f195885 1) f195886) #f))))) (vector-set! f195866 0 (closure (f195881 f195882) (f195869 f195867) (let ((f195881 f195881) (f195882 f195882)) (if ((vector-ref f195869 0) f195881 f195882) ((vector-ref f195867 0) f195881 f195882 0 (string-length f195881)) #f))))) (vector-ref f195866 0)))
# == eliminate-quote  ==>
# (let ((f195869 (make-vector 1)) (f195868 (make-vector 1)) (f195867 (make-vector 1)) (f195866 (make-vector 1))) (begin (begin (vector-set! f195869 0 (closure (f195890 f195891) () (let ((f195890 f195890) (f195891 f195891)) (fx= (string-length f195890) (string-length f195891))))) (vector-set! f195868 0 (closure (f195887 f195888 f195889) () (let ((f195887 f195887) (f195888 f195888) (f195889 f195889)) (char=? (string-ref f195887 f195889) (string-ref f195888 f195889))))) (vector-set! f195867 0 (closure (f195883 f195884 f195885 f195886) (f195868 f195867) (let ((f195883 f195883) (f195884 f195884) (f195885 f195885) (f195886 f195886)) (if (fx= f195885 f195886) #t (if ((vector-ref f195868 0) f195883 f195884 f195885) ((vector-ref f195867 0) f195883 f195884 (fx+ f195885 1) f195886) #f))))) (vector-set! f195866 0 (closure (f195881 f195882) (f195869 f195867) (let ((f195881 f195881) (f195882 f195882)) (if ((vector-ref f195869 0) f195881 f195882) ((vector-ref f195867 0) f195881 f195882 0 (string-length f195881)) #f))))) (vector-ref f195866 0)))
# == eliminate-when/unless  ==>
# (let ((f195869 (make-vector 1)) (f195868 (make-vector 1)) (f195867 (make-vector 1)) (f195866 (make-vector 1))) (begin (begin (vector-set! f195869 0 (closure (f195890 f195891) () (let ((f195890 f195890) (f195891 f195891)) (fx= (string-length f195890) (string-length f195891))))) (vector-set! f195868 0 (closure (f195887 f195888 f195889) () (let ((f195887 f195887) (f195888 f195888) (f195889 f195889)) (char=? (string-ref f195887 f195889) (string-ref f195888 f195889))))) (vector-set! f195867 0 (closure (f195883 f195884 f195885 f195886) (f195868 f195867) (let ((f195883 f195883) (f195884 f195884) (f195885 f195885) (f195886 f195886)) (if (fx= f195885 f195886) #t (if ((vector-ref f195868 0) f195883 f195884 f195885) ((vector-ref f195867 0) f195883 f195884 (fx+ f195885 1) f195886) #f))))) (vector-set! f195866 0 (closure (f195881 f195882) (f195869 f195867) (let ((f195881 f195881) (f195882 f195882)) (if ((vector-ref f195869 0) f195881 f195882) ((vector-ref f195867 0) f195881 f195882 0 (string-length f195881)) #f))))) (vector-ref f195866 0)))
# == eliminate-cond  ==>
# (let ((f195869 (make-vector 1)) (f195868 (make-vector 1)) (f195867 (make-vector 1)) (f195866 (make-vector 1))) (begin (begin (vector-set! f195869 0 (closure (f195890 f195891) () (let ((f195890 f195890) (f195891 f195891)) (fx= (string-length f195890) (string-length f195891))))) (vector-set! f195868 0 (closure (f195887 f195888 f195889) () (let ((f195887 f195887) (f195888 f195888) (f195889 f195889)) (char=? (string-ref f195887 f195889) (string-ref f195888 f195889))))) (vector-set! f195867 0 (closure (f195883 f195884 f195885 f195886) (f195868 f195867) (let ((f195883 f195883) (f195884 f195884) (f195885 f195885) (f195886 f195886)) (if (fx= f195885 f195886) #t (if ((vector-ref f195868 0) f195883 f195884 f195885) ((vector-ref f195867 0) f195883 f195884 (fx+ f195885 1) f195886) #f))))) (vector-set! f195866 0 (closure (f195881 f195882) (f195869 f195867) (let ((f195881 f195881) (f195882 f195882)) (if ((vector-ref f195869 0) f195881 f195882) ((vector-ref f195867 0) f195881 f195882 0 (string-length f195881)) #f))))) (vector-ref f195866 0)))
# == external-symbols  ==>
# (let ((f195869 (make-vector 1)) (f195868 (make-vector 1)) (f195867 (make-vector 1)) (f195866 (make-vector 1))) (begin (begin (vector-set! f195869 0 (closure (f195890 f195891) () (let ((f195890 f195890) (f195891 f195891)) (fx= (string-length f195890) (string-length f195891))))) (vector-set! f195868 0 (closure (f195887 f195888 f195889) () (let ((f195887 f195887) (f195888 f195888) (f195889 f195889)) (char=? (string-ref f195887 f195889) (string-ref f195888 f195889))))) (vector-set! f195867 0 (closure (f195883 f195884 f195885 f195886) (f195868 f195867) (let ((f195883 f195883) (f195884 f195884) (f195885 f195885) (f195886 f195886)) (if (fx= f195885 f195886) #t (if ((vector-ref f195868 0) f195883 f195884 f195885) ((vector-ref f195867 0) f195883 f195884 (fx+ f195885 1) f195886) #f))))) (vector-set! f195866 0 (closure (f195881 f195882) (f195869 f195867) (let ((f195881 f195881) (f195882 f195882)) (if ((vector-ref f195869 0) f195881 f195882) ((vector-ref f195867 0) f195881 f195882 0 (string-length f195881)) #f))))) (vector-ref f195866 0)))
# emit-expr (let ((f195869 (make-vector 1)) (f195868 (make-vector 1)) (f195867 (make-vector 1)) (f195866 (make-vector 1))) (begin (begin (vector-set! f195869 0 (closure (f195890 f195891) () (let ((f195890 f195890) (f195891 f195891)) (fx= (string-length f195890) (string-length f195891))))) (vector-set! f195868 0 (closure (f195887 f195888 f195889) () (let ((f195887 f195887) (f195888 f195888) (f195889 f195889)) (char=? (string-ref f195887 f195889) (string-ref f195888 f195889))))) (vector-set! f195867 0 (closure (f195883 f195884 f195885 f195886) (f195868 f195867) (let ((f195883 f195883) (f195884 f195884) (f195885 f195885) (f195886 f195886)) (if (fx= f195885 f195886) #t (if ((vector-ref f195868 0) f195883 f195884 f195885) ((vector-ref f195867 0) f195883 f195884 (fx+ f195885 1) f195886) #f))))) (vector-set! f195866 0 (closure (f195881 f195882) (f195869 f195867) (let ((f195881 f195881) (f195882 f195882)) (if ((vector-ref f195869 0) f195881 f195882) ((vector-ref f195867 0) f195881 f195882 0 (string-length f195881)) #f))))) (vector-ref f195866 0)))
# emit-let
#  si   = 0
#  env  = ()
#  bindings = ((f195869 (make-vector 1)) (f195868 (make-vector 1)) (f195867 (make-vector 1)) (f195866 (make-vector 1)))
#  body = (begin (begin (vector-set! f195869 0 (closure (f195890 f195891) () (let ((f195890 f195890) (f195891 f195891)) (fx= (string-length f195890) (string-length f195891))))) (vector-set! f195868 0 (closure (f195887 f195888 f195889) () (let ((f195887 f195887) (f195888 f195888) (f195889 f195889)) (char=? (string-ref f195887 f195889) (string-ref f195888 f195889))))) (vector-set! f195867 0 (closure (f195883 f195884 f195885 f195886) (f195868 f195867) (let ((f195883 f195883) (f195884 f195884) (f195885 f195885) (f195886 f195886)) (if (fx= f195885 f195886) #t (if ((vector-ref f195868 0) f195883 f195884 f195885) ((vector-ref f195867 0) f195883 f195884 (fx+ f195885 1) f195886) #f))))) (vector-set! f195866 0 (closure (f195881 f195882) (f195869 f195867) (let ((f195881 f195881) (f195882 f195882)) (if ((vector-ref f195869 0) f195881 f195882) ((vector-ref f195867 0) f195881 f195882 0 (string-length f195881)) #f))))) (vector-ref f195866 0))
# emit-expr (make-vector 1)
# make-vector 1
# emit-expr 1
    movl $4, %eax     # immed 1
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1431457"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $128,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1431457:
# check the argument is a fixnum >= 0
    cmp $0,%eax
    jge _L_1431458
# invoke error handler eh_length
    .extern mrc_eh$ulength
    movl mrc_eh$ulength, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $128,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1431458:
    movl %eax, %esi
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    orl  $5, %eax
    addl $4, %esi
    addl $4, %esi
    andl $-8, %esi
    addl %esi, %ebp
    movl %eax, 0(%esp)  # stack save
# emit-expr (make-vector 1)
# make-vector 1
# emit-expr 1
    movl $4, %eax     # immed 1
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1431459"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $128,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1431459:
# check the argument is a fixnum >= 0
    cmp $0,%eax
    jge _L_1431460
# invoke error handler eh_length
    .extern mrc_eh$ulength
    movl mrc_eh$ulength, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $128,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1431460:
    movl %eax, %esi
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    orl  $5, %eax
    addl $4, %esi
    addl $4, %esi
    andl $-8, %esi
    addl %esi, %ebp
    movl %eax, -4(%esp)  # stack save
# emit-expr (make-vector 1)
# make-vector 1
# emit-expr 1
    movl $4, %eax     # immed 1
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1431461"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $128,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1431461:
# check the argument is a fixnum >= 0
    cmp $0,%eax
    jge _L_1431462
# invoke error handler eh_length
    .extern mrc_eh$ulength
    movl mrc_eh$ulength, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $128,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1431462:
    movl %eax, %esi
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    orl  $5, %eax
    addl $4, %esi
    addl $4, %esi
    andl $-8, %esi
    addl %esi, %ebp
    movl %eax, -8(%esp)  # stack save
# emit-expr (make-vector 1)
# make-vector 1
# emit-expr 1
    movl $4, %eax     # immed 1
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1431463"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $128,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1431463:
# check the argument is a fixnum >= 0
    cmp $0,%eax
    jge _L_1431464
# invoke error handler eh_length
    .extern mrc_eh$ulength
    movl mrc_eh$ulength, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $128,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1431464:
    movl %eax, %esi
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    orl  $5, %eax
    addl $4, %esi
    addl $4, %esi
    andl $-8, %esi
    addl %esi, %ebp
    movl %eax, -12(%esp)  # stack save
# emit-expr (begin (begin (vector-set! f195869 0 (closure (f195890 f195891) () (let ((f195890 f195890) (f195891 f195891)) (fx= (string-length f195890) (string-length f195891))))) (vector-set! f195868 0 (closure (f195887 f195888 f195889) () (let ((f195887 f195887) (f195888 f195888) (f195889 f195889)) (char=? (string-ref f195887 f195889) (string-ref f195888 f195889))))) (vector-set! f195867 0 (closure (f195883 f195884 f195885 f195886) (f195868 f195867) (let ((f195883 f195883) (f195884 f195884) (f195885 f195885) (f195886 f195886)) (if (fx= f195885 f195886) #t (if ((vector-ref f195868 0) f195883 f195884 f195885) ((vector-ref f195867 0) f195883 f195884 (fx+ f195885 1) f195886) #f))))) (vector-set! f195866 0 (closure (f195881 f195882) (f195869 f195867) (let ((f195881 f195881) (f195882 f195882)) (if ((vector-ref f195869 0) f195881 f195882) ((vector-ref f195867 0) f195881 f195882 0 (string-length f195881)) #f))))) (vector-ref f195866 0))
# emit-begin
#   expr=(begin (begin (vector-set! f195869 0 (closure (f195890 f195891) () (let ((f195890 f195890) (f195891 f195891)) (fx= (string-length f195890) (string-length f195891))))) (vector-set! f195868 0 (closure (f195887 f195888 f195889) () (let ((f195887 f195887) (f195888 f195888) (f195889 f195889)) (char=? (string-ref f195887 f195889) (string-ref f195888 f195889))))) (vector-set! f195867 0 (closure (f195883 f195884 f195885 f195886) (f195868 f195867) (let ((f195883 f195883) (f195884 f195884) (f195885 f195885) (f195886 f195886)) (if (fx= f195885 f195886) #t (if ((vector-ref f195868 0) f195883 f195884 f195885) ((vector-ref f195867 0) f195883 f195884 (fx+ f195885 1) f195886) #f))))) (vector-set! f195866 0 (closure (f195881 f195882) (f195869 f195867) (let ((f195881 f195881) (f195882 f195882)) (if ((vector-ref f195869 0) f195881 f195882) ((vector-ref f195867 0) f195881 f195882 0 (string-length f195881)) #f))))) (vector-ref f195866 0))
#   env=((f195866 . -12) (f195867 . -8) (f195868 . -4) (f195869 . 0))
# emit-expr (begin (vector-set! f195869 0 (closure (f195890 f195891) () (let ((f195890 f195890) (f195891 f195891)) (fx= (string-length f195890) (string-length f195891))))) (vector-set! f195868 0 (closure (f195887 f195888 f195889) () (let ((f195887 f195887) (f195888 f195888) (f195889 f195889)) (char=? (string-ref f195887 f195889) (string-ref f195888 f195889))))) (vector-set! f195867 0 (closure (f195883 f195884 f195885 f195886) (f195868 f195867) (let ((f195883 f195883) (f195884 f195884) (f195885 f195885) (f195886 f195886)) (if (fx= f195885 f195886) #t (if ((vector-ref f195868 0) f195883 f195884 f195885) ((vector-ref f195867 0) f195883 f195884 (fx+ f195885 1) f195886) #f))))) (vector-set! f195866 0 (closure (f195881 f195882) (f195869 f195867) (let ((f195881 f195881) (f195882 f195882)) (if ((vector-ref f195869 0) f195881 f195882) ((vector-ref f195867 0) f195881 f195882 0 (string-length f195881)) #f)))))
# emit-begin
#   expr=(begin (vector-set! f195869 0 (closure (f195890 f195891) () (let ((f195890 f195890) (f195891 f195891)) (fx= (string-length f195890) (string-length f195891))))) (vector-set! f195868 0 (closure (f195887 f195888 f195889) () (let ((f195887 f195887) (f195888 f195888) (f195889 f195889)) (char=? (string-ref f195887 f195889) (string-ref f195888 f195889))))) (vector-set! f195867 0 (closure (f195883 f195884 f195885 f195886) (f195868 f195867) (let ((f195883 f195883) (f195884 f195884) (f195885 f195885) (f195886 f195886)) (if (fx= f195885 f195886) #t (if ((vector-ref f195868 0) f195883 f195884 f195885) ((vector-ref f195867 0) f195883 f195884 (fx+ f195885 1) f195886) #f))))) (vector-set! f195866 0 (closure (f195881 f195882) (f195869 f195867) (let ((f195881 f195881) (f195882 f195882)) (if ((vector-ref f195869 0) f195881 f195882) ((vector-ref f195867 0) f195881 f195882 0 (string-length f195881)) #f)))))
#   env=((f195866 . -12) (f195867 . -8) (f195868 . -4) (f195869 . 0))
# emit-expr (vector-set! f195869 0 (closure (f195890 f195891) () (let ((f195890 f195890) (f195891 f195891)) (fx= (string-length f195890) (string-length f195891)))))
# emit-expr f195869
# emit-variable-ref
# env=((f195866 . -12) (f195867 . -8) (f195868 . -4) (f195869 . 0))
# var=f195869
    movl 0(%esp), %eax  # stack load f195869
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1431465
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1431465:
    movl %eax, -16(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1431466"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1431466:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1431468
    cmp  $0,%eax
    jge _L_1431467
_L_1431468:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1431467:
    movl %eax, -20(%esp)
# emit-expr (closure (f195890 f195891) () (let ((f195890 f195890) (f195891 f195891)) (fx= (string-length f195890) (string-length f195891))))
# emit-closure
# si = -24
# env = ((f195866 . -12) (f195867 . -8) (f195868 . -4) (f195869 . 0))
# expr = (closure (f195890 f195891) () (let ((f195890 f195890) (f195891 f195891)) (fx= (string-length f195890) (string-length f195891))))
    movl $_L_1431469, 0(%ebp)  # closure label
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $8, %ebp     # bump ebp
    jmp _L_1431470            # jump around closure body
_L_1431469:
# check argument count
    cmp $8,%eax
    je _L_1431471
# invoke error handler eh_argcount
    .extern mrc_eh$uargcount
    movl mrc_eh$uargcount, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_1431471:
# emit-tail-expr
# si=-16
# env=((f195891 . -12) (f195890 . -8) (f195866 . -12) (f195867 . -8) (f195868 . -4) (f195869 . 0))
# expr=(let ((f195890 f195890) (f195891 f195891)) (fx= (string-length f195890) (string-length f195891)))
# emit-tail-let
#  si   = -16
#  env  = ((f195891 . -12) (f195890 . -8) (f195866 . -12) (f195867 . -8) (f195868 . -4) (f195869 . 0))
#  bindings = ((f195890 f195890) (f195891 f195891))
#  body = (fx= (string-length f195890) (string-length f195891))
# emit-expr f195890
# emit-variable-ref
# env=((f195891 . -12) (f195890 . -8) (f195866 . -12) (f195867 . -8) (f195868 . -4) (f195869 . 0))
# var=f195890
    movl -8(%esp), %eax  # stack load f195890
# end emit-variable-ref
    movl %eax, -16(%esp)  # stack save
# emit-expr f195891
# emit-variable-ref
# env=((f195891 . -12) (f195890 . -8) (f195866 . -12) (f195867 . -8) (f195868 . -4) (f195869 . 0))
# var=f195891
    movl -12(%esp), %eax  # stack load f195891
# end emit-variable-ref
    movl %eax, -20(%esp)  # stack save
# emit-tail-expr
# si=-24
# env=((f195891 . -20) (f195890 . -16) (f195891 . -12) (f195890 . -8) (f195866 . -12) (f195867 . -8) (f195868 . -4) (f195869 . 0))
# expr=(fx= (string-length f195890) (string-length f195891))
# tail primcall
# emit-expr (string-length f195891)
# emit-expr f195891
# emit-variable-ref
# env=((f195891 . -20) (f195890 . -16) (f195891 . -12) (f195890 . -8) (f195866 . -12) (f195867 . -8) (f195868 . -4) (f195869 . 0))
# var=f195891
    movl -20(%esp), %eax  # stack load f195891
# end emit-variable-ref
# check the argument is a string
    movl %eax,%ebx
    and $7, %bl
    cmp $6, %bl
    je _L_1431472
# invoke error handler eh_string
    .extern mrc_eh$ustring
    movl mrc_eh$ustring, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $152,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1431472:
    movl -6(%eax), %eax
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1431473"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $60,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1431473:
    movl %eax, -24(%esp)
# emit-expr (string-length f195890)
# emit-expr f195890
# emit-variable-ref
# env=((f195891 . -20) (f195890 . -16) (f195891 . -12) (f195890 . -8) (f195866 . -12) (f195867 . -8) (f195868 . -4) (f195869 . 0))
# var=f195890
    movl -16(%esp), %eax  # stack load f195890
# end emit-variable-ref
# check the argument is a string
    movl %eax,%ebx
    and $7, %bl
    cmp $6, %bl
    je _L_1431474
# invoke error handler eh_string
    .extern mrc_eh$ustring
    movl mrc_eh$ustring, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $152,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1431474:
    movl -6(%eax), %eax
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1431475"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $60,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1431475:
    cmp -24(%esp), %eax
    sete %al
    movzbl %al, %eax
    sal $6, %al
    or $47, %al
#return from tail (fx= (string-length f195890) (string-length f195891))
    ret
    .align 4,0x90
_L_1431470:
    movl -16(%esp), %ebx
    movl -20(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin (vector-set! f195868 0 (closure (f195887 f195888 f195889) () (let ((f195887 f195887) (f195888 f195888) (f195889 f195889)) (char=? (string-ref f195887 f195889) (string-ref f195888 f195889))))) (vector-set! f195867 0 (closure (f195883 f195884 f195885 f195886) (f195868 f195867) (let ((f195883 f195883) (f195884 f195884) (f195885 f195885) (f195886 f195886)) (if (fx= f195885 f195886) #t (if ((vector-ref f195868 0) f195883 f195884 f195885) ((vector-ref f195867 0) f195883 f195884 (fx+ f195885 1) f195886) #f))))) (vector-set! f195866 0 (closure (f195881 f195882) (f195869 f195867) (let ((f195881 f195881) (f195882 f195882)) (if ((vector-ref f195869 0) f195881 f195882) ((vector-ref f195867 0) f195881 f195882 0 (string-length f195881)) #f)))))
# emit-begin
#   expr=(begin (vector-set! f195868 0 (closure (f195887 f195888 f195889) () (let ((f195887 f195887) (f195888 f195888) (f195889 f195889)) (char=? (string-ref f195887 f195889) (string-ref f195888 f195889))))) (vector-set! f195867 0 (closure (f195883 f195884 f195885 f195886) (f195868 f195867) (let ((f195883 f195883) (f195884 f195884) (f195885 f195885) (f195886 f195886)) (if (fx= f195885 f195886) #t (if ((vector-ref f195868 0) f195883 f195884 f195885) ((vector-ref f195867 0) f195883 f195884 (fx+ f195885 1) f195886) #f))))) (vector-set! f195866 0 (closure (f195881 f195882) (f195869 f195867) (let ((f195881 f195881) (f195882 f195882)) (if ((vector-ref f195869 0) f195881 f195882) ((vector-ref f195867 0) f195881 f195882 0 (string-length f195881)) #f)))))
#   env=((f195866 . -12) (f195867 . -8) (f195868 . -4) (f195869 . 0))
# emit-expr (vector-set! f195868 0 (closure (f195887 f195888 f195889) () (let ((f195887 f195887) (f195888 f195888) (f195889 f195889)) (char=? (string-ref f195887 f195889) (string-ref f195888 f195889)))))
# emit-expr f195868
# emit-variable-ref
# env=((f195866 . -12) (f195867 . -8) (f195868 . -4) (f195869 . 0))
# var=f195868
    movl -4(%esp), %eax  # stack load f195868
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1431476
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1431476:
    movl %eax, -16(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1431477"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1431477:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1431479
    cmp  $0,%eax
    jge _L_1431478
_L_1431479:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1431478:
    movl %eax, -20(%esp)
# emit-expr (closure (f195887 f195888 f195889) () (let ((f195887 f195887) (f195888 f195888) (f195889 f195889)) (char=? (string-ref f195887 f195889) (string-ref f195888 f195889))))
# emit-closure
# si = -24
# env = ((f195866 . -12) (f195867 . -8) (f195868 . -4) (f195869 . 0))
# expr = (closure (f195887 f195888 f195889) () (let ((f195887 f195887) (f195888 f195888) (f195889 f195889)) (char=? (string-ref f195887 f195889) (string-ref f195888 f195889))))
    movl $_L_1431480, 0(%ebp)  # closure label
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $8, %ebp     # bump ebp
    jmp _L_1431481            # jump around closure body
_L_1431480:
# check argument count
    cmp $12,%eax
    je _L_1431482
# invoke error handler eh_argcount
    .extern mrc_eh$uargcount
    movl mrc_eh$uargcount, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_1431482:
# emit-tail-expr
# si=-20
# env=((f195889 . -16) (f195888 . -12) (f195887 . -8) (f195866 . -12) (f195867 . -8) (f195868 . -4) (f195869 . 0))
# expr=(let ((f195887 f195887) (f195888 f195888) (f195889 f195889)) (char=? (string-ref f195887 f195889) (string-ref f195888 f195889)))
# emit-tail-let
#  si   = -20
#  env  = ((f195889 . -16) (f195888 . -12) (f195887 . -8) (f195866 . -12) (f195867 . -8) (f195868 . -4) (f195869 . 0))
#  bindings = ((f195887 f195887) (f195888 f195888) (f195889 f195889))
#  body = (char=? (string-ref f195887 f195889) (string-ref f195888 f195889))
# emit-expr f195887
# emit-variable-ref
# env=((f195889 . -16) (f195888 . -12) (f195887 . -8) (f195866 . -12) (f195867 . -8) (f195868 . -4) (f195869 . 0))
# var=f195887
    movl -8(%esp), %eax  # stack load f195887
# end emit-variable-ref
    movl %eax, -20(%esp)  # stack save
# emit-expr f195888
# emit-variable-ref
# env=((f195889 . -16) (f195888 . -12) (f195887 . -8) (f195866 . -12) (f195867 . -8) (f195868 . -4) (f195869 . 0))
# var=f195888
    movl -12(%esp), %eax  # stack load f195888
# end emit-variable-ref
    movl %eax, -24(%esp)  # stack save
# emit-expr f195889
# emit-variable-ref
# env=((f195889 . -16) (f195888 . -12) (f195887 . -8) (f195866 . -12) (f195867 . -8) (f195868 . -4) (f195869 . 0))
# var=f195889
    movl -16(%esp), %eax  # stack load f195889
# end emit-variable-ref
    movl %eax, -28(%esp)  # stack save
# emit-tail-expr
# si=-32
# env=((f195889 . -28) (f195888 . -24) (f195887 . -20) (f195889 . -16) (f195888 . -12) (f195887 . -8) (f195866 . -12) (f195867 . -8) (f195868 . -4) (f195869 . 0))
# expr=(char=? (string-ref f195887 f195889) (string-ref f195888 f195889))
# tail primcall
# char= c1=(string-ref f195887 f195889) c2=(string-ref f195888 f195889)
# emit-expr (string-ref f195887 f195889)
# emit-expr f195887
# emit-variable-ref
# env=((f195889 . -28) (f195888 . -24) (f195887 . -20) (f195889 . -16) (f195888 . -12) (f195887 . -8) (f195866 . -12) (f195867 . -8) (f195868 . -4) (f195869 . 0))
# var=f195887
    movl -20(%esp), %eax  # stack load f195887
# end emit-variable-ref
# check the argument is a string
    movl %eax,%ebx
    and $7, %bl
    cmp $6, %bl
    je _L_1431483
# invoke error handler eh_string
    .extern mrc_eh$ustring
    movl mrc_eh$ustring, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $156,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1431483:
    movl %eax, -32(%esp)
# emit-expr f195889
# emit-variable-ref
# env=((f195889 . -28) (f195888 . -24) (f195887 . -20) (f195889 . -16) (f195888 . -12) (f195887 . -8) (f195866 . -12) (f195867 . -8) (f195868 . -4) (f195869 . 0))
# var=f195889
    movl -28(%esp), %eax  # stack load f195889
# end emit-variable-ref
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1431484"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $156,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1431484:
# check bounds on string index
    movl -32(%esp), %ebx
    cmp  %eax,-6(%ebx) 
    jle _L_1431486
    cmp  $0,%eax
    jge _L_1431485
_L_1431486:
# invoke error handler eh_string_index
    .extern mrc_eh$ustring$uindex
    movl mrc_eh$ustring$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $156,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1431485:
    sar $2, %eax
    movl -32(%esp), %esi
    movl -2(%eax,%esi), %eax
    sal $8, %eax
    or  $15, %eax
# check the argument is a char
    movl %eax,%ebx
    and $255, %bl
    cmp $15, %bl
    je "_L_1431487"
# invoke error handler eh_character
    .extern mrc_eh$ucharacter
    movl mrc_eh$ucharacter, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $32,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1431487:
    movb %ah, -32(%esp)
# emit-expr (string-ref f195888 f195889)
# emit-expr f195888
# emit-variable-ref
# env=((f195889 . -28) (f195888 . -24) (f195887 . -20) (f195889 . -16) (f195888 . -12) (f195887 . -8) (f195866 . -12) (f195867 . -8) (f195868 . -4) (f195869 . 0))
# var=f195888
    movl -24(%esp), %eax  # stack load f195888
# end emit-variable-ref
# check the argument is a string
    movl %eax,%ebx
    and $7, %bl
    cmp $6, %bl
    je _L_1431488
# invoke error handler eh_string
    .extern mrc_eh$ustring
    movl mrc_eh$ustring, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $156,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1431488:
    movl %eax, -36(%esp)
# emit-expr f195889
# emit-variable-ref
# env=((f195889 . -28) (f195888 . -24) (f195887 . -20) (f195889 . -16) (f195888 . -12) (f195887 . -8) (f195866 . -12) (f195867 . -8) (f195868 . -4) (f195869 . 0))
# var=f195889
    movl -28(%esp), %eax  # stack load f195889
# end emit-variable-ref
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1431489"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $156,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1431489:
# check bounds on string index
    movl -36(%esp), %ebx
    cmp  %eax,-6(%ebx) 
    jle _L_1431491
    cmp  $0,%eax
    jge _L_1431490
_L_1431491:
# invoke error handler eh_string_index
    .extern mrc_eh$ustring$uindex
    movl mrc_eh$ustring$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $156,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1431490:
    sar $2, %eax
    movl -36(%esp), %esi
    movl -2(%eax,%esi), %eax
    sal $8, %eax
    or  $15, %eax
# check the argument is a char
    movl %eax,%ebx
    and $255, %bl
    cmp $15, %bl
    je "_L_1431492"
# invoke error handler eh_character
    .extern mrc_eh$ucharacter
    movl mrc_eh$ucharacter, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $32,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1431492:
    cmp %ah, -32(%esp)
    sete %al
    movzbl %al, %eax
    sal $6, %al
    or $47, %al
#return from tail (char=? (string-ref f195887 f195889) (string-ref f195888 f195889))
    ret
    .align 4,0x90
_L_1431481:
    movl -16(%esp), %ebx
    movl -20(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin (vector-set! f195867 0 (closure (f195883 f195884 f195885 f195886) (f195868 f195867) (let ((f195883 f195883) (f195884 f195884) (f195885 f195885) (f195886 f195886)) (if (fx= f195885 f195886) #t (if ((vector-ref f195868 0) f195883 f195884 f195885) ((vector-ref f195867 0) f195883 f195884 (fx+ f195885 1) f195886) #f))))) (vector-set! f195866 0 (closure (f195881 f195882) (f195869 f195867) (let ((f195881 f195881) (f195882 f195882)) (if ((vector-ref f195869 0) f195881 f195882) ((vector-ref f195867 0) f195881 f195882 0 (string-length f195881)) #f)))))
# emit-begin
#   expr=(begin (vector-set! f195867 0 (closure (f195883 f195884 f195885 f195886) (f195868 f195867) (let ((f195883 f195883) (f195884 f195884) (f195885 f195885) (f195886 f195886)) (if (fx= f195885 f195886) #t (if ((vector-ref f195868 0) f195883 f195884 f195885) ((vector-ref f195867 0) f195883 f195884 (fx+ f195885 1) f195886) #f))))) (vector-set! f195866 0 (closure (f195881 f195882) (f195869 f195867) (let ((f195881 f195881) (f195882 f195882)) (if ((vector-ref f195869 0) f195881 f195882) ((vector-ref f195867 0) f195881 f195882 0 (string-length f195881)) #f)))))
#   env=((f195866 . -12) (f195867 . -8) (f195868 . -4) (f195869 . 0))
# emit-expr (vector-set! f195867 0 (closure (f195883 f195884 f195885 f195886) (f195868 f195867) (let ((f195883 f195883) (f195884 f195884) (f195885 f195885) (f195886 f195886)) (if (fx= f195885 f195886) #t (if ((vector-ref f195868 0) f195883 f195884 f195885) ((vector-ref f195867 0) f195883 f195884 (fx+ f195885 1) f195886) #f)))))
# emit-expr f195867
# emit-variable-ref
# env=((f195866 . -12) (f195867 . -8) (f195868 . -4) (f195869 . 0))
# var=f195867
    movl -8(%esp), %eax  # stack load f195867
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1431493
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1431493:
    movl %eax, -16(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1431494"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1431494:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1431496
    cmp  $0,%eax
    jge _L_1431495
_L_1431496:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1431495:
    movl %eax, -20(%esp)
# emit-expr (closure (f195883 f195884 f195885 f195886) (f195868 f195867) (let ((f195883 f195883) (f195884 f195884) (f195885 f195885) (f195886 f195886)) (if (fx= f195885 f195886) #t (if ((vector-ref f195868 0) f195883 f195884 f195885) ((vector-ref f195867 0) f195883 f195884 (fx+ f195885 1) f195886) #f))))
# emit-closure
# si = -24
# env = ((f195866 . -12) (f195867 . -8) (f195868 . -4) (f195869 . 0))
# expr = (closure (f195883 f195884 f195885 f195886) (f195868 f195867) (let ((f195883 f195883) (f195884 f195884) (f195885 f195885) (f195886 f195886)) (if (fx= f195885 f195886) #t (if ((vector-ref f195868 0) f195883 f195884 f195885) ((vector-ref f195867 0) f195883 f195884 (fx+ f195885 1) f195886) #f))))
    movl $_L_1431497, 0(%ebp)  # closure label
# emit-variable-ref
# env=((f195866 . -12) (f195867 . -8) (f195868 . -4) (f195869 . 0))
# var=f195868
    movl -4(%esp), %eax  # stack load f195868
# end emit-variable-ref
   movl  %eax, 4(%ebp)  # f195868
# emit-variable-ref
# env=((f195866 . -12) (f195867 . -8) (f195868 . -4) (f195869 . 0))
# var=f195867
    movl -8(%esp), %eax  # stack load f195867
# end emit-variable-ref
   movl  %eax, 8(%ebp)  # f195867
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $16, %ebp     # bump ebp
    jmp _L_1431498            # jump around closure body
_L_1431497:
# check argument count
    cmp $16,%eax
    je _L_1431499
# invoke error handler eh_argcount
    .extern mrc_eh$uargcount
    movl mrc_eh$uargcount, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_1431499:
# emit-tail-expr
# si=-24
# env=((f195886 . -20) (f195885 . -16) (f195884 . -12) (f195883 . -8) (f195867 . 8) (f195868 . 4) (f195866 . -12) (f195867 . -8) (f195868 . -4) (f195869 . 0))
# expr=(let ((f195883 f195883) (f195884 f195884) (f195885 f195885) (f195886 f195886)) (if (fx= f195885 f195886) #t (if ((vector-ref f195868 0) f195883 f195884 f195885) ((vector-ref f195867 0) f195883 f195884 (fx+ f195885 1) f195886) #f)))
# emit-tail-let
#  si   = -24
#  env  = ((f195886 . -20) (f195885 . -16) (f195884 . -12) (f195883 . -8) (f195867 . 8) (f195868 . 4) (f195866 . -12) (f195867 . -8) (f195868 . -4) (f195869 . 0))
#  bindings = ((f195883 f195883) (f195884 f195884) (f195885 f195885) (f195886 f195886))
#  body = (if (fx= f195885 f195886) #t (if ((vector-ref f195868 0) f195883 f195884 f195885) ((vector-ref f195867 0) f195883 f195884 (fx+ f195885 1) f195886) #f))
# emit-expr f195883
# emit-variable-ref
# env=((f195886 . -20) (f195885 . -16) (f195884 . -12) (f195883 . -8) (f195867 . 8) (f195868 . 4) (f195866 . -12) (f195867 . -8) (f195868 . -4) (f195869 . 0))
# var=f195883
    movl -8(%esp), %eax  # stack load f195883
# end emit-variable-ref
    movl %eax, -24(%esp)  # stack save
# emit-expr f195884
# emit-variable-ref
# env=((f195886 . -20) (f195885 . -16) (f195884 . -12) (f195883 . -8) (f195867 . 8) (f195868 . 4) (f195866 . -12) (f195867 . -8) (f195868 . -4) (f195869 . 0))
# var=f195884
    movl -12(%esp), %eax  # stack load f195884
# end emit-variable-ref
    movl %eax, -28(%esp)  # stack save
# emit-expr f195885
# emit-variable-ref
# env=((f195886 . -20) (f195885 . -16) (f195884 . -12) (f195883 . -8) (f195867 . 8) (f195868 . 4) (f195866 . -12) (f195867 . -8) (f195868 . -4) (f195869 . 0))
# var=f195885
    movl -16(%esp), %eax  # stack load f195885
# end emit-variable-ref
    movl %eax, -32(%esp)  # stack save
# emit-expr f195886
# emit-variable-ref
# env=((f195886 . -20) (f195885 . -16) (f195884 . -12) (f195883 . -8) (f195867 . 8) (f195868 . 4) (f195866 . -12) (f195867 . -8) (f195868 . -4) (f195869 . 0))
# var=f195886
    movl -20(%esp), %eax  # stack load f195886
# end emit-variable-ref
    movl %eax, -36(%esp)  # stack save
# emit-tail-expr
# si=-40
# env=((f195886 . -36) (f195885 . -32) (f195884 . -28) (f195883 . -24) (f195886 . -20) (f195885 . -16) (f195884 . -12) (f195883 . -8) (f195867 . 8) (f195868 . 4) (f195866 . -12) (f195867 . -8) (f195868 . -4) (f195869 . 0))
# expr=(if (fx= f195885 f195886) #t (if ((vector-ref f195868 0) f195883 f195884 f195885) ((vector-ref f195867 0) f195883 f195884 (fx+ f195885 1) f195886) #f))
# emit-expr (fx= f195885 f195886)
# emit-expr f195886
# emit-variable-ref
# env=((f195886 . -36) (f195885 . -32) (f195884 . -28) (f195883 . -24) (f195886 . -20) (f195885 . -16) (f195884 . -12) (f195883 . -8) (f195867 . 8) (f195868 . 4) (f195866 . -12) (f195867 . -8) (f195868 . -4) (f195869 . 0))
# var=f195886
    movl -36(%esp), %eax  # stack load f195886
# end emit-variable-ref
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1431502"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $60,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1431502:
    movl %eax, -40(%esp)
# emit-expr f195885
# emit-variable-ref
# env=((f195886 . -36) (f195885 . -32) (f195884 . -28) (f195883 . -24) (f195886 . -20) (f195885 . -16) (f195884 . -12) (f195883 . -8) (f195867 . 8) (f195868 . 4) (f195866 . -12) (f195867 . -8) (f195868 . -4) (f195869 . 0))
# var=f195885
    movl -32(%esp), %eax  # stack load f195885
# end emit-variable-ref
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1431503"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $60,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1431503:
    cmp -40(%esp), %eax
    sete %al
    movzbl %al, %eax
    sal $6, %al
    or $47, %al
    cmp $47, %al
    je _L_1431500
# emit-tail-expr
# si=-40
# env=((f195886 . -36) (f195885 . -32) (f195884 . -28) (f195883 . -24) (f195886 . -20) (f195885 . -16) (f195884 . -12) (f195883 . -8) (f195867 . 8) (f195868 . 4) (f195866 . -12) (f195867 . -8) (f195868 . -4) (f195869 . 0))
# expr=#t
    movl $111, %eax     # immed #t
    ret                  # immediate tail return
    jmp _L_1431501
_L_1431500:
# emit-tail-expr
# si=-40
# env=((f195886 . -36) (f195885 . -32) (f195884 . -28) (f195883 . -24) (f195886 . -20) (f195885 . -16) (f195884 . -12) (f195883 . -8) (f195867 . 8) (f195868 . 4) (f195866 . -12) (f195867 . -8) (f195868 . -4) (f195869 . 0))
# expr=(if ((vector-ref f195868 0) f195883 f195884 f195885) ((vector-ref f195867 0) f195883 f195884 (fx+ f195885 1) f195886) #f)
# emit-expr ((vector-ref f195868 0) f195883 f195884 f195885)
# funcall
#    si   =-40
#    env  = ((f195886 . -36) (f195885 . -32) (f195884 . -28) (f195883 . -24) (f195886 . -20) (f195885 . -16) (f195884 . -12) (f195883 . -8) (f195867 . 8) (f195868 . 4) (f195866 . -12) (f195867 . -8) (f195868 . -4) (f195869 . 0))
#    expr = (funcall (vector-ref f195868 0) f195883 f195884 f195885)
# emit-expr (vector-ref f195868 0)
# emit-expr f195868
# emit-variable-ref
# env=((f195886 . -36) (f195885 . -32) (f195884 . -28) (f195883 . -24) (f195886 . -20) (f195885 . -16) (f195884 . -12) (f195883 . -8) (f195867 . 8) (f195868 . 4) (f195866 . -12) (f195867 . -8) (f195868 . -4) (f195869 . 0))
# var=f195868
    movl 2(%edi), %eax  # frame load f195868
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1431506
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1431506:
    movl %eax, -48(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1431507"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1431507:
# check bounds on vector index
    movl -48(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1431509
    cmp  $0,%eax
    jge _L_1431508
_L_1431509:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1431508:
    movl -48(%esp), %esi
    movl -1(%eax,%esi), %eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1431510"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1431510":
   movl %eax,  -48(%esp)  # stash funcall-oper in closure slot
# emit-expr f195883
# emit-variable-ref
# env=((f195886 . -36) (f195885 . -32) (f195884 . -28) (f195883 . -24) (f195886 . -20) (f195885 . -16) (f195884 . -12) (f195883 . -8) (f195867 . 8) (f195868 . 4) (f195866 . -12) (f195867 . -8) (f195868 . -4) (f195869 . 0))
# var=f195883
    movl -24(%esp), %eax  # stack load f195883
# end emit-variable-ref
    mov %eax, -52(%esp)  # arg f195883
# emit-expr f195884
# emit-variable-ref
# env=((f195886 . -36) (f195885 . -32) (f195884 . -28) (f195883 . -24) (f195886 . -20) (f195885 . -16) (f195884 . -12) (f195883 . -8) (f195867 . 8) (f195868 . 4) (f195866 . -12) (f195867 . -8) (f195868 . -4) (f195869 . 0))
# var=f195884
    movl -28(%esp), %eax  # stack load f195884
# end emit-variable-ref
    mov %eax, -56(%esp)  # arg f195884
# emit-expr f195885
# emit-variable-ref
# env=((f195886 . -36) (f195885 . -32) (f195884 . -28) (f195883 . -24) (f195886 . -20) (f195885 . -16) (f195884 . -12) (f195883 . -8) (f195867 . 8) (f195868 . 4) (f195866 . -12) (f195867 . -8) (f195868 . -4) (f195869 . 0))
# var=f195885
    movl -32(%esp), %eax  # stack load f195885
# end emit-variable-ref
    mov %eax, -60(%esp)  # arg f195885
    movl -48(%esp), %edi   # load new closure to %edi
    add $-40, %esp   # adjust base
    movl $12,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $40, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    cmp $47, %al
    je _L_1431504
# emit-tail-expr
# si=-40
# env=((f195886 . -36) (f195885 . -32) (f195884 . -28) (f195883 . -24) (f195886 . -20) (f195885 . -16) (f195884 . -12) (f195883 . -8) (f195867 . 8) (f195868 . 4) (f195866 . -12) (f195867 . -8) (f195868 . -4) (f195869 . 0))
# expr=((vector-ref f195867 0) f195883 f195884 (fx+ f195885 1) f195886)
# emit-tail-funcall
#    si   =-40
#    env  = ((f195886 . -36) (f195885 . -32) (f195884 . -28) (f195883 . -24) (f195886 . -20) (f195885 . -16) (f195884 . -12) (f195883 . -8) (f195867 . 8) (f195868 . 4) (f195866 . -12) (f195867 . -8) (f195868 . -4) (f195869 . 0))
#    expr = (funcall (vector-ref f195867 0) f195883 f195884 (fx+ f195885 1) f195886)
# emit-expr (vector-ref f195867 0)
# emit-expr f195867
# emit-variable-ref
# env=((f195886 . -36) (f195885 . -32) (f195884 . -28) (f195883 . -24) (f195886 . -20) (f195885 . -16) (f195884 . -12) (f195883 . -8) (f195867 . 8) (f195868 . 4) (f195866 . -12) (f195867 . -8) (f195868 . -4) (f195869 . 0))
# var=f195867
    movl 6(%edi), %eax  # frame load f195867
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1431511
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1431511:
    movl %eax, -40(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1431512"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1431512:
# check bounds on vector index
    movl -40(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1431514
    cmp  $0,%eax
    jge _L_1431513
_L_1431514:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1431513:
    movl -40(%esp), %esi
    movl -1(%eax,%esi), %eax
   movl %eax,  -40(%esp)  # stash funcall-oper in next closure slot
# emit-expr f195883
# emit-variable-ref
# env=((f195886 . -36) (f195885 . -32) (f195884 . -28) (f195883 . -24) (f195886 . -20) (f195885 . -16) (f195884 . -12) (f195883 . -8) (f195867 . 8) (f195868 . 4) (f195866 . -12) (f195867 . -8) (f195868 . -4) (f195869 . 0))
# var=f195883
    movl -24(%esp), %eax  # stack load f195883
# end emit-variable-ref
    mov %eax, -44(%esp)    # arg f195883
# emit-expr f195884
# emit-variable-ref
# env=((f195886 . -36) (f195885 . -32) (f195884 . -28) (f195883 . -24) (f195886 . -20) (f195885 . -16) (f195884 . -12) (f195883 . -8) (f195867 . 8) (f195868 . 4) (f195866 . -12) (f195867 . -8) (f195868 . -4) (f195869 . 0))
# var=f195884
    movl -28(%esp), %eax  # stack load f195884
# end emit-variable-ref
    mov %eax, -48(%esp)    # arg f195884
# emit-expr (fx+ f195885 1)
# emit-expr 1
    movl $4, %eax     # immed 1
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1431515"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $80,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1431515:
    movl %eax, -52(%esp)  # fx+ push arg1
# emit-expr f195885
# emit-variable-ref
# env=((f195886 . -36) (f195885 . -32) (f195884 . -28) (f195883 . -24) (f195886 . -20) (f195885 . -16) (f195884 . -12) (f195883 . -8) (f195867 . 8) (f195868 . 4) (f195866 . -12) (f195867 . -8) (f195868 . -4) (f195869 . 0))
# var=f195885
    movl -32(%esp), %eax  # stack load f195885
# end emit-variable-ref
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1431516"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $80,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1431516:
    addl -52(%esp), %eax  # fx+ arg1 arg2
    mov %eax, -52(%esp)    # arg (fx+ f195885 1)
# emit-expr f195886
# emit-variable-ref
# env=((f195886 . -36) (f195885 . -32) (f195884 . -28) (f195883 . -24) (f195886 . -20) (f195885 . -16) (f195884 . -12) (f195883 . -8) (f195867 . 8) (f195868 . 4) (f195866 . -12) (f195867 . -8) (f195868 . -4) (f195869 . 0))
# var=f195886
    movl -36(%esp), %eax  # stack load f195886
# end emit-variable-ref
    mov %eax, -56(%esp)    # arg f195886
    movl -40(%esp), %edi   # load new closure to %edi
# emit-shift-args:  size=5   si=-40  delta=36
    mov -40(%esp), %ebx  # shift frame cell
    mov %ebx, -4(%esp)  # down to base
# emit-shift-args:  size=4   si=-44  delta=36
    mov -44(%esp), %ebx  # shift frame cell
    mov %ebx, -8(%esp)  # down to base
# emit-shift-args:  size=3   si=-48  delta=36
    mov -48(%esp), %ebx  # shift frame cell
    mov %ebx, -12(%esp)  # down to base
# emit-shift-args:  size=2   si=-52  delta=36
    mov -52(%esp), %ebx  # shift frame cell
    mov %ebx, -16(%esp)  # down to base
# emit-shift-args:  size=1   si=-56  delta=36
    mov -56(%esp), %ebx  # shift frame cell
    mov %ebx, -20(%esp)  # down to base
# emit-shift-args:  size=0   si=-60  delta=36
    movl $16,%eax   # save arg count
    jmp *-2(%edi)  # tail-funcall
    jmp _L_1431505
_L_1431504:
# emit-tail-expr
# si=-40
# env=((f195886 . -36) (f195885 . -32) (f195884 . -28) (f195883 . -24) (f195886 . -20) (f195885 . -16) (f195884 . -12) (f195883 . -8) (f195867 . 8) (f195868 . 4) (f195866 . -12) (f195867 . -8) (f195868 . -4) (f195869 . 0))
# expr=#f
    movl $47, %eax     # immed #f
    ret                  # immediate tail return
_L_1431505:
_L_1431501:
    .align 4,0x90
_L_1431498:
    movl -16(%esp), %ebx
    movl -20(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin (vector-set! f195866 0 (closure (f195881 f195882) (f195869 f195867) (let ((f195881 f195881) (f195882 f195882)) (if ((vector-ref f195869 0) f195881 f195882) ((vector-ref f195867 0) f195881 f195882 0 (string-length f195881)) #f)))))
# emit-begin
#   expr=(begin (vector-set! f195866 0 (closure (f195881 f195882) (f195869 f195867) (let ((f195881 f195881) (f195882 f195882)) (if ((vector-ref f195869 0) f195881 f195882) ((vector-ref f195867 0) f195881 f195882 0 (string-length f195881)) #f)))))
#   env=((f195866 . -12) (f195867 . -8) (f195868 . -4) (f195869 . 0))
# emit-expr (vector-set! f195866 0 (closure (f195881 f195882) (f195869 f195867) (let ((f195881 f195881) (f195882 f195882)) (if ((vector-ref f195869 0) f195881 f195882) ((vector-ref f195867 0) f195881 f195882 0 (string-length f195881)) #f))))
# emit-expr f195866
# emit-variable-ref
# env=((f195866 . -12) (f195867 . -8) (f195868 . -4) (f195869 . 0))
# var=f195866
    movl -12(%esp), %eax  # stack load f195866
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1431517
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1431517:
    movl %eax, -16(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1431518"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1431518:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1431520
    cmp  $0,%eax
    jge _L_1431519
_L_1431520:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1431519:
    movl %eax, -20(%esp)
# emit-expr (closure (f195881 f195882) (f195869 f195867) (let ((f195881 f195881) (f195882 f195882)) (if ((vector-ref f195869 0) f195881 f195882) ((vector-ref f195867 0) f195881 f195882 0 (string-length f195881)) #f)))
# emit-closure
# si = -24
# env = ((f195866 . -12) (f195867 . -8) (f195868 . -4) (f195869 . 0))
# expr = (closure (f195881 f195882) (f195869 f195867) (let ((f195881 f195881) (f195882 f195882)) (if ((vector-ref f195869 0) f195881 f195882) ((vector-ref f195867 0) f195881 f195882 0 (string-length f195881)) #f)))
    movl $_L_1431521, 0(%ebp)  # closure label
# emit-variable-ref
# env=((f195866 . -12) (f195867 . -8) (f195868 . -4) (f195869 . 0))
# var=f195869
    movl 0(%esp), %eax  # stack load f195869
# end emit-variable-ref
   movl  %eax, 4(%ebp)  # f195869
# emit-variable-ref
# env=((f195866 . -12) (f195867 . -8) (f195868 . -4) (f195869 . 0))
# var=f195867
    movl -8(%esp), %eax  # stack load f195867
# end emit-variable-ref
   movl  %eax, 8(%ebp)  # f195867
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $16, %ebp     # bump ebp
    jmp _L_1431522            # jump around closure body
_L_1431521:
# check argument count
    cmp $8,%eax
    je _L_1431523
# invoke error handler eh_argcount
    .extern mrc_eh$uargcount
    movl mrc_eh$uargcount, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_1431523:
# emit-tail-expr
# si=-16
# env=((f195882 . -12) (f195881 . -8) (f195867 . 8) (f195869 . 4) (f195866 . -12) (f195867 . -8) (f195868 . -4) (f195869 . 0))
# expr=(let ((f195881 f195881) (f195882 f195882)) (if ((vector-ref f195869 0) f195881 f195882) ((vector-ref f195867 0) f195881 f195882 0 (string-length f195881)) #f))
# emit-tail-let
#  si   = -16
#  env  = ((f195882 . -12) (f195881 . -8) (f195867 . 8) (f195869 . 4) (f195866 . -12) (f195867 . -8) (f195868 . -4) (f195869 . 0))
#  bindings = ((f195881 f195881) (f195882 f195882))
#  body = (if ((vector-ref f195869 0) f195881 f195882) ((vector-ref f195867 0) f195881 f195882 0 (string-length f195881)) #f)
# emit-expr f195881
# emit-variable-ref
# env=((f195882 . -12) (f195881 . -8) (f195867 . 8) (f195869 . 4) (f195866 . -12) (f195867 . -8) (f195868 . -4) (f195869 . 0))
# var=f195881
    movl -8(%esp), %eax  # stack load f195881
# end emit-variable-ref
    movl %eax, -16(%esp)  # stack save
# emit-expr f195882
# emit-variable-ref
# env=((f195882 . -12) (f195881 . -8) (f195867 . 8) (f195869 . 4) (f195866 . -12) (f195867 . -8) (f195868 . -4) (f195869 . 0))
# var=f195882
    movl -12(%esp), %eax  # stack load f195882
# end emit-variable-ref
    movl %eax, -20(%esp)  # stack save
# emit-tail-expr
# si=-24
# env=((f195882 . -20) (f195881 . -16) (f195882 . -12) (f195881 . -8) (f195867 . 8) (f195869 . 4) (f195866 . -12) (f195867 . -8) (f195868 . -4) (f195869 . 0))
# expr=(if ((vector-ref f195869 0) f195881 f195882) ((vector-ref f195867 0) f195881 f195882 0 (string-length f195881)) #f)
# emit-expr ((vector-ref f195869 0) f195881 f195882)
# funcall
#    si   =-24
#    env  = ((f195882 . -20) (f195881 . -16) (f195882 . -12) (f195881 . -8) (f195867 . 8) (f195869 . 4) (f195866 . -12) (f195867 . -8) (f195868 . -4) (f195869 . 0))
#    expr = (funcall (vector-ref f195869 0) f195881 f195882)
# emit-expr (vector-ref f195869 0)
# emit-expr f195869
# emit-variable-ref
# env=((f195882 . -20) (f195881 . -16) (f195882 . -12) (f195881 . -8) (f195867 . 8) (f195869 . 4) (f195866 . -12) (f195867 . -8) (f195868 . -4) (f195869 . 0))
# var=f195869
    movl 2(%edi), %eax  # frame load f195869
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1431526
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1431526:
    movl %eax, -32(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1431527"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1431527:
# check bounds on vector index
    movl -32(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1431529
    cmp  $0,%eax
    jge _L_1431528
_L_1431529:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1431528:
    movl -32(%esp), %esi
    movl -1(%eax,%esi), %eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1431530"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1431530":
   movl %eax,  -32(%esp)  # stash funcall-oper in closure slot
# emit-expr f195881
# emit-variable-ref
# env=((f195882 . -20) (f195881 . -16) (f195882 . -12) (f195881 . -8) (f195867 . 8) (f195869 . 4) (f195866 . -12) (f195867 . -8) (f195868 . -4) (f195869 . 0))
# var=f195881
    movl -16(%esp), %eax  # stack load f195881
# end emit-variable-ref
    mov %eax, -36(%esp)  # arg f195881
# emit-expr f195882
# emit-variable-ref
# env=((f195882 . -20) (f195881 . -16) (f195882 . -12) (f195881 . -8) (f195867 . 8) (f195869 . 4) (f195866 . -12) (f195867 . -8) (f195868 . -4) (f195869 . 0))
# var=f195882
    movl -20(%esp), %eax  # stack load f195882
# end emit-variable-ref
    mov %eax, -40(%esp)  # arg f195882
    movl -32(%esp), %edi   # load new closure to %edi
    add $-24, %esp   # adjust base
    movl $8,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $24, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    cmp $47, %al
    je _L_1431524
# emit-tail-expr
# si=-24
# env=((f195882 . -20) (f195881 . -16) (f195882 . -12) (f195881 . -8) (f195867 . 8) (f195869 . 4) (f195866 . -12) (f195867 . -8) (f195868 . -4) (f195869 . 0))
# expr=((vector-ref f195867 0) f195881 f195882 0 (string-length f195881))
# emit-tail-funcall
#    si   =-24
#    env  = ((f195882 . -20) (f195881 . -16) (f195882 . -12) (f195881 . -8) (f195867 . 8) (f195869 . 4) (f195866 . -12) (f195867 . -8) (f195868 . -4) (f195869 . 0))
#    expr = (funcall (vector-ref f195867 0) f195881 f195882 0 (string-length f195881))
# emit-expr (vector-ref f195867 0)
# emit-expr f195867
# emit-variable-ref
# env=((f195882 . -20) (f195881 . -16) (f195882 . -12) (f195881 . -8) (f195867 . 8) (f195869 . 4) (f195866 . -12) (f195867 . -8) (f195868 . -4) (f195869 . 0))
# var=f195867
    movl 6(%edi), %eax  # frame load f195867
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1431531
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1431531:
    movl %eax, -24(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1431532"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1431532:
# check bounds on vector index
    movl -24(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1431534
    cmp  $0,%eax
    jge _L_1431533
_L_1431534:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1431533:
    movl -24(%esp), %esi
    movl -1(%eax,%esi), %eax
   movl %eax,  -24(%esp)  # stash funcall-oper in next closure slot
# emit-expr f195881
# emit-variable-ref
# env=((f195882 . -20) (f195881 . -16) (f195882 . -12) (f195881 . -8) (f195867 . 8) (f195869 . 4) (f195866 . -12) (f195867 . -8) (f195868 . -4) (f195869 . 0))
# var=f195881
    movl -16(%esp), %eax  # stack load f195881
# end emit-variable-ref
    mov %eax, -28(%esp)    # arg f195881
# emit-expr f195882
# emit-variable-ref
# env=((f195882 . -20) (f195881 . -16) (f195882 . -12) (f195881 . -8) (f195867 . 8) (f195869 . 4) (f195866 . -12) (f195867 . -8) (f195868 . -4) (f195869 . 0))
# var=f195882
    movl -20(%esp), %eax  # stack load f195882
# end emit-variable-ref
    mov %eax, -32(%esp)    # arg f195882
# emit-expr 0
    movl $0, %eax     # immed 0
    mov %eax, -36(%esp)    # arg 0
# emit-expr (string-length f195881)
# emit-expr f195881
# emit-variable-ref
# env=((f195882 . -20) (f195881 . -16) (f195882 . -12) (f195881 . -8) (f195867 . 8) (f195869 . 4) (f195866 . -12) (f195867 . -8) (f195868 . -4) (f195869 . 0))
# var=f195881
    movl -16(%esp), %eax  # stack load f195881
# end emit-variable-ref
# check the argument is a string
    movl %eax,%ebx
    and $7, %bl
    cmp $6, %bl
    je _L_1431535
# invoke error handler eh_string
    .extern mrc_eh$ustring
    movl mrc_eh$ustring, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $152,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1431535:
    movl -6(%eax), %eax
    mov %eax, -40(%esp)    # arg (string-length f195881)
    movl -24(%esp), %edi   # load new closure to %edi
# emit-shift-args:  size=5   si=-24  delta=20
    mov -24(%esp), %ebx  # shift frame cell
    mov %ebx, -4(%esp)  # down to base
# emit-shift-args:  size=4   si=-28  delta=20
    mov -28(%esp), %ebx  # shift frame cell
    mov %ebx, -8(%esp)  # down to base
# emit-shift-args:  size=3   si=-32  delta=20
    mov -32(%esp), %ebx  # shift frame cell
    mov %ebx, -12(%esp)  # down to base
# emit-shift-args:  size=2   si=-36  delta=20
    mov -36(%esp), %ebx  # shift frame cell
    mov %ebx, -16(%esp)  # down to base
# emit-shift-args:  size=1   si=-40  delta=20
    mov -40(%esp), %ebx  # shift frame cell
    mov %ebx, -20(%esp)  # down to base
# emit-shift-args:  size=0   si=-44  delta=20
    movl $16,%eax   # save arg count
    jmp *-2(%edi)  # tail-funcall
    jmp _L_1431525
_L_1431524:
# emit-tail-expr
# si=-24
# env=((f195882 . -20) (f195881 . -16) (f195882 . -12) (f195881 . -8) (f195867 . 8) (f195869 . 4) (f195866 . -12) (f195867 . -8) (f195868 . -4) (f195869 . 0))
# expr=#f
    movl $47, %eax     # immed #f
    ret                  # immediate tail return
_L_1431525:
    .align 4,0x90
_L_1431522:
    movl -16(%esp), %ebx
    movl -20(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin)
# emit-begin
#   expr=(begin)
#   env=((f195866 . -12) (f195867 . -8) (f195868 . -4) (f195869 . 0))
# emit-expr (begin (vector-ref f195866 0))
# emit-begin
#   expr=(begin (vector-ref f195866 0))
#   env=((f195866 . -12) (f195867 . -8) (f195868 . -4) (f195869 . 0))
# emit-expr (vector-ref f195866 0)
# emit-expr f195866
# emit-variable-ref
# env=((f195866 . -12) (f195867 . -8) (f195868 . -4) (f195869 . 0))
# var=f195866
    movl -12(%esp), %eax  # stack load f195866
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1431536
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1431536:
    movl %eax, -16(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1431537"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1431537:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1431539
    cmp  $0,%eax
    jge _L_1431538
_L_1431539:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1431538:
    movl -16(%esp), %esi
    movl -1(%eax,%esi), %eax
# emit-expr (begin)
# emit-begin
#   expr=(begin)
#   env=((f195866 . -12) (f195867 . -8) (f195868 . -4) (f195869 . 0))
     movl %eax, mrc_string$e$q
# == explicit-begins  ==>
# (letrec ((str->sym (lambda (str symlist) (if (string=? str (symbol->string (car symlist))) (car symlist) (if (null? (cdr symlist)) (let* ((new-sym (make-symbol str #f)) (new-cdr (cons new-sym ()))) (begin (set-cdr! symlist new-cdr) new-sym)) (str->sym str (cdr symlist))))))) (lambda (str) (str->sym str (symbols))))
# == eliminate-let*  ==>
# (letrec ((str->sym (lambda (str symlist) (if (string=? str (symbol->string (car symlist))) (car symlist) (if (null? (cdr symlist)) (let ((new-sym (make-symbol str #f))) (let ((new-cdr (cons new-sym ()))) (begin (set-cdr! symlist new-cdr) new-sym))) (str->sym str (cdr symlist))))))) (lambda (str) (str->sym str (symbols))))
# == uniquify-variables  ==>
# (letrec ((f195892 (lambda (f195901 f195902) (if (string=? f195901 (symbol->string (car f195902))) (car f195902) (if (null? (cdr f195902)) (let ((f195906 (make-symbol f195901 #f))) (let ((f195908 (cons f195906 ()))) (begin (set-cdr! f195902 f195908) f195906))) (f195892 f195901 (cdr f195902))))))) (lambda (f195910) (f195892 f195910 (symbols))))
# == vectorize-letrec  ==>
# (let ((f195892 (make-vector 1))) (begin (begin (vector-set! f195892 0 (lambda (f195901 f195902) (if (string=? f195901 (symbol->string (car f195902))) (car f195902) (if (null? (cdr f195902)) (let ((f195906 (make-symbol f195901 #f))) (let ((f195908 (cons f195906 ()))) (begin (set-cdr! f195902 f195908) f195906))) ((vector-ref f195892 0) f195901 (cdr f195902))))))) (lambda (f195910) ((vector-ref f195892 0) f195910 (symbols)))))
# == eliminate-set!  ==>
# (let ((f195892 (make-vector 1))) (begin (begin (vector-set! f195892 0 (lambda (f195901 f195902) (let ((f195901 f195901) (f195902 f195902)) (if (string=? f195901 (symbol->string (car f195902))) (car f195902) (if (null? (cdr f195902)) (let ((f195906 (make-symbol f195901 #f))) (let ((f195908 (cons f195906 ()))) (begin (set-cdr! f195902 f195908) f195906))) ((vector-ref f195892 0) f195901 (cdr f195902)))))))) (lambda (f195910) (let ((f195910 f195910)) ((vector-ref f195892 0) f195910 (symbols))))))
# == close-free-variables  ==>
# (let ((f195892 (make-vector 1))) (begin (begin (vector-set! f195892 0 (closure (f195901 f195902) (string=? f195892) (let ((f195901 f195901) (f195902 f195902)) (if (string=? f195901 (symbol->string (car f195902))) (car f195902) (if (null? (cdr f195902)) (let ((f195906 (make-symbol f195901 #f))) (let ((f195908 (cons f195906 ()))) (begin (set-cdr! f195902 f195908) f195906))) ((vector-ref f195892 0) f195901 (cdr f195902)))))))) (closure (f195910) (f195892 symbols) (let ((f195910 f195910)) ((vector-ref f195892 0) f195910 (symbols))))))
# == eliminate-quote  ==>
# (let ((f195892 (make-vector 1))) (begin (begin (vector-set! f195892 0 (closure (f195901 f195902) (string=? f195892) (let ((f195901 f195901) (f195902 f195902)) (if (string=? f195901 (symbol->string (car f195902))) (car f195902) (if (null? (cdr f195902)) (let ((f195906 (make-symbol f195901 #f))) (let ((f195908 (cons f195906 ()))) (begin (set-cdr! f195902 f195908) f195906))) ((vector-ref f195892 0) f195901 (cdr f195902)))))))) (closure (f195910) (f195892 symbols) (let ((f195910 f195910)) ((vector-ref f195892 0) f195910 (symbols))))))
# == eliminate-when/unless  ==>
# (let ((f195892 (make-vector 1))) (begin (begin (vector-set! f195892 0 (closure (f195901 f195902) (string=? f195892) (let ((f195901 f195901) (f195902 f195902)) (if (string=? f195901 (symbol->string (car f195902))) (car f195902) (if (null? (cdr f195902)) (let ((f195906 (make-symbol f195901 #f))) (let ((f195908 (cons f195906 ()))) (begin (set-cdr! f195902 f195908) f195906))) ((vector-ref f195892 0) f195901 (cdr f195902)))))))) (closure (f195910) (f195892 symbols) (let ((f195910 f195910)) ((vector-ref f195892 0) f195910 (symbols))))))
# == eliminate-cond  ==>
# (let ((f195892 (make-vector 1))) (begin (begin (vector-set! f195892 0 (closure (f195901 f195902) (string=? f195892) (let ((f195901 f195901) (f195902 f195902)) (if (string=? f195901 (symbol->string (car f195902))) (car f195902) (if (null? (cdr f195902)) (let ((f195906 (make-symbol f195901 #f))) (let ((f195908 (cons f195906 ()))) (begin (set-cdr! f195902 f195908) f195906))) ((vector-ref f195892 0) f195901 (cdr f195902)))))))) (closure (f195910) (f195892 symbols) (let ((f195910 f195910)) ((vector-ref f195892 0) f195910 (symbols))))))
# == external-symbols  ==>
# (let ((f195892 (make-vector 1))) (begin (begin (vector-set! f195892 0 (closure (f195901 f195902) ((primitive-ref string=?) f195892) (let ((f195901 f195901) (f195902 f195902)) (if ((primitive-ref string=?) f195901 (symbol->string (car f195902))) (car f195902) (if (null? (cdr f195902)) (let ((f195906 (make-symbol f195901 #f))) (let ((f195908 (cons f195906 ()))) (begin (set-cdr! f195902 f195908) f195906))) ((vector-ref f195892 0) f195901 (cdr f195902)))))))) (closure (f195910) (f195892 (primitive-ref symbols)) (let ((f195910 f195910)) ((vector-ref f195892 0) f195910 ((primitive-ref symbols)))))))
# emit-expr (let ((f195892 (make-vector 1))) (begin (begin (vector-set! f195892 0 (closure (f195901 f195902) ((primitive-ref string=?) f195892) (let ((f195901 f195901) (f195902 f195902)) (if ((primitive-ref string=?) f195901 (symbol->string (car f195902))) (car f195902) (if (null? (cdr f195902)) (let ((f195906 (make-symbol f195901 #f))) (let ((f195908 (cons f195906 ()))) (begin (set-cdr! f195902 f195908) f195906))) ((vector-ref f195892 0) f195901 (cdr f195902)))))))) (closure (f195910) (f195892 (primitive-ref symbols)) (let ((f195910 f195910)) ((vector-ref f195892 0) f195910 ((primitive-ref symbols)))))))
# emit-let
#  si   = 0
#  env  = ()
#  bindings = ((f195892 (make-vector 1)))
#  body = (begin (begin (vector-set! f195892 0 (closure (f195901 f195902) ((primitive-ref string=?) f195892) (let ((f195901 f195901) (f195902 f195902)) (if ((primitive-ref string=?) f195901 (symbol->string (car f195902))) (car f195902) (if (null? (cdr f195902)) (let ((f195906 (make-symbol f195901 #f))) (let ((f195908 (cons f195906 ()))) (begin (set-cdr! f195902 f195908) f195906))) ((vector-ref f195892 0) f195901 (cdr f195902)))))))) (closure (f195910) (f195892 (primitive-ref symbols)) (let ((f195910 f195910)) ((vector-ref f195892 0) f195910 ((primitive-ref symbols))))))
# emit-expr (make-vector 1)
# make-vector 1
# emit-expr 1
    movl $4, %eax     # immed 1
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1431540"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $128,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1431540:
# check the argument is a fixnum >= 0
    cmp $0,%eax
    jge _L_1431541
# invoke error handler eh_length
    .extern mrc_eh$ulength
    movl mrc_eh$ulength, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $128,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1431541:
    movl %eax, %esi
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    orl  $5, %eax
    addl $4, %esi
    addl $4, %esi
    andl $-8, %esi
    addl %esi, %ebp
    movl %eax, 0(%esp)  # stack save
# emit-expr (begin (begin (vector-set! f195892 0 (closure (f195901 f195902) ((primitive-ref string=?) f195892) (let ((f195901 f195901) (f195902 f195902)) (if ((primitive-ref string=?) f195901 (symbol->string (car f195902))) (car f195902) (if (null? (cdr f195902)) (let ((f195906 (make-symbol f195901 #f))) (let ((f195908 (cons f195906 ()))) (begin (set-cdr! f195902 f195908) f195906))) ((vector-ref f195892 0) f195901 (cdr f195902)))))))) (closure (f195910) (f195892 (primitive-ref symbols)) (let ((f195910 f195910)) ((vector-ref f195892 0) f195910 ((primitive-ref symbols))))))
# emit-begin
#   expr=(begin (begin (vector-set! f195892 0 (closure (f195901 f195902) ((primitive-ref string=?) f195892) (let ((f195901 f195901) (f195902 f195902)) (if ((primitive-ref string=?) f195901 (symbol->string (car f195902))) (car f195902) (if (null? (cdr f195902)) (let ((f195906 (make-symbol f195901 #f))) (let ((f195908 (cons f195906 ()))) (begin (set-cdr! f195902 f195908) f195906))) ((vector-ref f195892 0) f195901 (cdr f195902)))))))) (closure (f195910) (f195892 (primitive-ref symbols)) (let ((f195910 f195910)) ((vector-ref f195892 0) f195910 ((primitive-ref symbols))))))
#   env=((f195892 . 0))
# emit-expr (begin (vector-set! f195892 0 (closure (f195901 f195902) ((primitive-ref string=?) f195892) (let ((f195901 f195901) (f195902 f195902)) (if ((primitive-ref string=?) f195901 (symbol->string (car f195902))) (car f195902) (if (null? (cdr f195902)) (let ((f195906 (make-symbol f195901 #f))) (let ((f195908 (cons f195906 ()))) (begin (set-cdr! f195902 f195908) f195906))) ((vector-ref f195892 0) f195901 (cdr f195902))))))))
# emit-begin
#   expr=(begin (vector-set! f195892 0 (closure (f195901 f195902) ((primitive-ref string=?) f195892) (let ((f195901 f195901) (f195902 f195902)) (if ((primitive-ref string=?) f195901 (symbol->string (car f195902))) (car f195902) (if (null? (cdr f195902)) (let ((f195906 (make-symbol f195901 #f))) (let ((f195908 (cons f195906 ()))) (begin (set-cdr! f195902 f195908) f195906))) ((vector-ref f195892 0) f195901 (cdr f195902))))))))
#   env=((f195892 . 0))
# emit-expr (vector-set! f195892 0 (closure (f195901 f195902) ((primitive-ref string=?) f195892) (let ((f195901 f195901) (f195902 f195902)) (if ((primitive-ref string=?) f195901 (symbol->string (car f195902))) (car f195902) (if (null? (cdr f195902)) (let ((f195906 (make-symbol f195901 #f))) (let ((f195908 (cons f195906 ()))) (begin (set-cdr! f195902 f195908) f195906))) ((vector-ref f195892 0) f195901 (cdr f195902)))))))
# emit-expr f195892
# emit-variable-ref
# env=((f195892 . 0))
# var=f195892
    movl 0(%esp), %eax  # stack load f195892
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1431542
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1431542:
    movl %eax, -4(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1431543"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1431543:
# check bounds on vector index
    movl -4(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1431545
    cmp  $0,%eax
    jge _L_1431544
_L_1431545:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1431544:
    movl %eax, -8(%esp)
# emit-expr (closure (f195901 f195902) ((primitive-ref string=?) f195892) (let ((f195901 f195901) (f195902 f195902)) (if ((primitive-ref string=?) f195901 (symbol->string (car f195902))) (car f195902) (if (null? (cdr f195902)) (let ((f195906 (make-symbol f195901 #f))) (let ((f195908 (cons f195906 ()))) (begin (set-cdr! f195902 f195908) f195906))) ((vector-ref f195892 0) f195901 (cdr f195902))))))
# emit-closure
# si = -12
# env = ((f195892 . 0))
# expr = (closure (f195901 f195902) ((primitive-ref string=?) f195892) (let ((f195901 f195901) (f195902 f195902)) (if ((primitive-ref string=?) f195901 (symbol->string (car f195902))) (car f195902) (if (null? (cdr f195902)) (let ((f195906 (make-symbol f195901 #f))) (let ((f195908 (cons f195906 ()))) (begin (set-cdr! f195902 f195908) f195906))) ((vector-ref f195892 0) f195901 (cdr f195902))))))
    movl $_L_1431546, 0(%ebp)  # closure label
# WARNING: free var (primitive-ref string=?) not defined in the environmnet
# emit-variable-ref
# env=((f195892 . 0))
# var=f195892
    movl 0(%esp), %eax  # stack load f195892
# end emit-variable-ref
   movl  %eax, 8(%ebp)  # f195892
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $16, %ebp     # bump ebp
    jmp _L_1431547            # jump around closure body
_L_1431546:
# check argument count
    cmp $8,%eax
    je _L_1431548
# invoke error handler eh_argcount
    .extern mrc_eh$uargcount
    movl mrc_eh$uargcount, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_1431548:
# emit-tail-expr
# si=-16
# env=((f195902 . -12) (f195901 . -8) (f195892 . 8) ((primitive-ref string=?) . 4) (f195892 . 0))
# expr=(let ((f195901 f195901) (f195902 f195902)) (if ((primitive-ref string=?) f195901 (symbol->string (car f195902))) (car f195902) (if (null? (cdr f195902)) (let ((f195906 (make-symbol f195901 #f))) (let ((f195908 (cons f195906 ()))) (begin (set-cdr! f195902 f195908) f195906))) ((vector-ref f195892 0) f195901 (cdr f195902)))))
# emit-tail-let
#  si   = -16
#  env  = ((f195902 . -12) (f195901 . -8) (f195892 . 8) ((primitive-ref string=?) . 4) (f195892 . 0))
#  bindings = ((f195901 f195901) (f195902 f195902))
#  body = (if ((primitive-ref string=?) f195901 (symbol->string (car f195902))) (car f195902) (if (null? (cdr f195902)) (let ((f195906 (make-symbol f195901 #f))) (let ((f195908 (cons f195906 ()))) (begin (set-cdr! f195902 f195908) f195906))) ((vector-ref f195892 0) f195901 (cdr f195902))))
# emit-expr f195901
# emit-variable-ref
# env=((f195902 . -12) (f195901 . -8) (f195892 . 8) ((primitive-ref string=?) . 4) (f195892 . 0))
# var=f195901
    movl -8(%esp), %eax  # stack load f195901
# end emit-variable-ref
    movl %eax, -16(%esp)  # stack save
# emit-expr f195902
# emit-variable-ref
# env=((f195902 . -12) (f195901 . -8) (f195892 . 8) ((primitive-ref string=?) . 4) (f195892 . 0))
# var=f195902
    movl -12(%esp), %eax  # stack load f195902
# end emit-variable-ref
    movl %eax, -20(%esp)  # stack save
# emit-tail-expr
# si=-24
# env=((f195902 . -20) (f195901 . -16) (f195902 . -12) (f195901 . -8) (f195892 . 8) ((primitive-ref string=?) . 4) (f195892 . 0))
# expr=(if ((primitive-ref string=?) f195901 (symbol->string (car f195902))) (car f195902) (if (null? (cdr f195902)) (let ((f195906 (make-symbol f195901 #f))) (let ((f195908 (cons f195906 ()))) (begin (set-cdr! f195902 f195908) f195906))) ((vector-ref f195892 0) f195901 (cdr f195902))))
# emit-expr ((primitive-ref string=?) f195901 (symbol->string (car f195902)))
# funcall
#    si   =-24
#    env  = ((f195902 . -20) (f195901 . -16) (f195902 . -12) (f195901 . -8) (f195892 . 8) ((primitive-ref string=?) . 4) (f195892 . 0))
#    expr = (funcall (primitive-ref string=?) f195901 (symbol->string (car f195902)))
# emit-expr (primitive-ref string=?)
    .extern mrc_string$e$q
    movl mrc_string$e$q,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1431551"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1431551":
   movl %eax,  -32(%esp)  # stash funcall-oper in closure slot
# emit-expr f195901
# emit-variable-ref
# env=((f195902 . -20) (f195901 . -16) (f195902 . -12) (f195901 . -8) (f195892 . 8) ((primitive-ref string=?) . 4) (f195892 . 0))
# var=f195901
    movl -16(%esp), %eax  # stack load f195901
# end emit-variable-ref
    mov %eax, -36(%esp)  # arg f195901
# emit-expr (symbol->string (car f195902))
# symbol->string (car f195902)
# emit-expr (car f195902)
# emit-expr f195902
# emit-variable-ref
# env=((f195902 . -20) (f195901 . -16) (f195902 . -12) (f195901 . -8) (f195892 . 8) ((primitive-ref string=?) . 4) (f195892 . 0))
# var=f195902
    movl -20(%esp), %eax  # stack load f195902
# end emit-variable-ref
# check the argument is a pair
    movl %eax,%ebx
    and $7, %bl
    cmp $1, %bl
    je _L_1431552
# invoke error handler eh_pair
    .extern mrc_eh$upair
    movl mrc_eh$upair, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $108,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1431552:
    movl -1(%eax), %eax
    movl -3(%eax), %eax
    mov %eax, -40(%esp)  # arg (symbol->string (car f195902))
    movl -32(%esp), %edi   # load new closure to %edi
    add $-24, %esp   # adjust base
    movl $8,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $24, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    cmp $47, %al
    je _L_1431549
# emit-tail-expr
# si=-24
# env=((f195902 . -20) (f195901 . -16) (f195902 . -12) (f195901 . -8) (f195892 . 8) ((primitive-ref string=?) . 4) (f195892 . 0))
# expr=(car f195902)
# tail primcall
# emit-expr f195902
# emit-variable-ref
# env=((f195902 . -20) (f195901 . -16) (f195902 . -12) (f195901 . -8) (f195892 . 8) ((primitive-ref string=?) . 4) (f195892 . 0))
# var=f195902
    movl -20(%esp), %eax  # stack load f195902
# end emit-variable-ref
# check the argument is a pair
    movl %eax,%ebx
    and $7, %bl
    cmp $1, %bl
    je _L_1431553
# invoke error handler eh_pair
    .extern mrc_eh$upair
    movl mrc_eh$upair, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $108,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1431553:
    movl -1(%eax), %eax
#return from tail (car f195902)
    ret
    jmp _L_1431550
_L_1431549:
# emit-tail-expr
# si=-24
# env=((f195902 . -20) (f195901 . -16) (f195902 . -12) (f195901 . -8) (f195892 . 8) ((primitive-ref string=?) . 4) (f195892 . 0))
# expr=(if (null? (cdr f195902)) (let ((f195906 (make-symbol f195901 #f))) (let ((f195908 (cons f195906 ()))) (begin (set-cdr! f195902 f195908) f195906))) ((vector-ref f195892 0) f195901 (cdr f195902)))
# emit-expr (null? (cdr f195902))
# emit-expr (cdr f195902)
# emit-expr f195902
# emit-variable-ref
# env=((f195902 . -20) (f195901 . -16) (f195902 . -12) (f195901 . -8) (f195892 . 8) ((primitive-ref string=?) . 4) (f195892 . 0))
# var=f195902
    movl -20(%esp), %eax  # stack load f195902
# end emit-variable-ref
# check the argument is a pair
    movl %eax,%ebx
    and $7, %bl
    cmp $1, %bl
    je _L_1431556
# invoke error handler eh_pair
    .extern mrc_eh$upair
    movl mrc_eh$upair, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $112,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1431556:
    movl 3(%eax), %eax
    cmp $63, %eax
    mov $0, %eax
    sete %al
    movzbl %al, %eax
    sal $6, %al
    or $47, %al
    cmp $47, %al
    je _L_1431554
# emit-tail-expr
# si=-24
# env=((f195902 . -20) (f195901 . -16) (f195902 . -12) (f195901 . -8) (f195892 . 8) ((primitive-ref string=?) . 4) (f195892 . 0))
# expr=(let ((f195906 (make-symbol f195901 #f))) (let ((f195908 (cons f195906 ()))) (begin (set-cdr! f195902 f195908) f195906)))
# emit-tail-let
#  si   = -24
#  env  = ((f195902 . -20) (f195901 . -16) (f195902 . -12) (f195901 . -8) (f195892 . 8) ((primitive-ref string=?) . 4) (f195892 . 0))
#  bindings = ((f195906 (make-symbol f195901 #f)))
#  body = (let ((f195908 (cons f195906 ()))) (begin (set-cdr! f195902 f195908) f195906))
# emit-expr (make-symbol f195901 #f)
# make-symbol arg1=f195901 arg2=#f
# emit-expr f195901
# emit-variable-ref
# env=((f195902 . -20) (f195901 . -16) (f195902 . -12) (f195901 . -8) (f195892 . 8) ((primitive-ref string=?) . 4) (f195892 . 0))
# var=f195901
    movl -16(%esp), %eax  # stack load f195901
# end emit-variable-ref
    movl %eax, -24(%esp)
# emit-expr #f
    movl $47, %eax     # immed #f
    movl %eax, 4(%ebp)
    movl -24(%esp), %eax
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    orl  $3, %eax
    add  $8, %ebp
# make-symbol end
    movl %eax, -24(%esp)  # stack save
# emit-tail-expr
# si=-28
# env=((f195906 . -24) (f195902 . -20) (f195901 . -16) (f195902 . -12) (f195901 . -8) (f195892 . 8) ((primitive-ref string=?) . 4) (f195892 . 0))
# expr=(let ((f195908 (cons f195906 ()))) (begin (set-cdr! f195902 f195908) f195906))
# emit-tail-let
#  si   = -28
#  env  = ((f195906 . -24) (f195902 . -20) (f195901 . -16) (f195902 . -12) (f195901 . -8) (f195892 . 8) ((primitive-ref string=?) . 4) (f195892 . 0))
#  bindings = ((f195908 (cons f195906 ())))
#  body = (begin (set-cdr! f195902 f195908) f195906)
# emit-expr (cons f195906 ())
# cons arg1=f195906 arg2=()
# emit-expr f195906
# emit-variable-ref
# env=((f195906 . -24) (f195902 . -20) (f195901 . -16) (f195902 . -12) (f195901 . -8) (f195892 . 8) ((primitive-ref string=?) . 4) (f195892 . 0))
# var=f195906
    movl -24(%esp), %eax  # stack load f195906
# end emit-variable-ref
    movl %eax, -28(%esp)
# emit-expr ()
    movl $63, %eax     # immed ()
    movl %eax, 4(%ebp)
    movl -28(%esp), %eax
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    or   $1, %al
    add  $8, %ebp
# cons end
    movl %eax, -28(%esp)  # stack save
# emit-tail-expr
# si=-32
# env=((f195908 . -28) (f195906 . -24) (f195902 . -20) (f195901 . -16) (f195902 . -12) (f195901 . -8) (f195892 . 8) ((primitive-ref string=?) . 4) (f195892 . 0))
# expr=(begin (set-cdr! f195902 f195908) f195906)
# tail-begin (begin (set-cdr! f195902 f195908) f195906)
#   env=((f195908 . -28) (f195906 . -24) (f195902 . -20) (f195901 . -16) (f195902 . -12) (f195901 . -8) (f195892 . 8) ((primitive-ref string=?) . 4) (f195892 . 0))
# emit-expr (set-cdr! f195902 f195908)
# emit-expr f195902
# emit-variable-ref
# env=((f195908 . -28) (f195906 . -24) (f195902 . -20) (f195901 . -16) (f195902 . -12) (f195901 . -8) (f195892 . 8) ((primitive-ref string=?) . 4) (f195892 . 0))
# var=f195902
    movl -20(%esp), %eax  # stack load f195902
# end emit-variable-ref
# check the argument is a pair
    movl %eax,%ebx
    and $7, %bl
    cmp $1, %bl
    je _L_1431557
# invoke error handler eh_pair
    .extern mrc_eh$upair
    movl mrc_eh$upair, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $120,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1431557:
    movl %eax, -32(%esp)
# emit-expr f195908
# emit-variable-ref
# env=((f195908 . -28) (f195906 . -24) (f195902 . -20) (f195901 . -16) (f195902 . -12) (f195901 . -8) (f195892 . 8) ((primitive-ref string=?) . 4) (f195892 . 0))
# var=f195908
    movl -28(%esp), %eax  # stack load f195908
# end emit-variable-ref
    movl -32(%esp), %ebx
    movl %eax, 3(%ebx)
# emit-tail-expr
# si=-32
# env=((f195908 . -28) (f195906 . -24) (f195902 . -20) (f195901 . -16) (f195902 . -12) (f195901 . -8) (f195892 . 8) ((primitive-ref string=?) . 4) (f195892 . 0))
# expr=(begin f195906)
# tail-begin (begin f195906)
#   env=((f195908 . -28) (f195906 . -24) (f195902 . -20) (f195901 . -16) (f195902 . -12) (f195901 . -8) (f195892 . 8) ((primitive-ref string=?) . 4) (f195892 . 0))
# emit-tail-expr
# si=-32
# env=((f195908 . -28) (f195906 . -24) (f195902 . -20) (f195901 . -16) (f195902 . -12) (f195901 . -8) (f195892 . 8) ((primitive-ref string=?) . 4) (f195892 . 0))
# expr=f195906
# emit-tail-variable-ref
# emit-variable-ref
# env=((f195908 . -28) (f195906 . -24) (f195902 . -20) (f195901 . -16) (f195902 . -12) (f195901 . -8) (f195892 . 8) ((primitive-ref string=?) . 4) (f195892 . 0))
# var=f195906
    movl -24(%esp), %eax  # stack load f195906
# end emit-variable-ref
    ret
# end emit-tail-variable ref
     ret   # return thru stack
    jmp _L_1431555
_L_1431554:
# emit-tail-expr
# si=-24
# env=((f195902 . -20) (f195901 . -16) (f195902 . -12) (f195901 . -8) (f195892 . 8) ((primitive-ref string=?) . 4) (f195892 . 0))
# expr=((vector-ref f195892 0) f195901 (cdr f195902))
# emit-tail-funcall
#    si   =-24
#    env  = ((f195902 . -20) (f195901 . -16) (f195902 . -12) (f195901 . -8) (f195892 . 8) ((primitive-ref string=?) . 4) (f195892 . 0))
#    expr = (funcall (vector-ref f195892 0) f195901 (cdr f195902))
# emit-expr (vector-ref f195892 0)
# emit-expr f195892
# emit-variable-ref
# env=((f195902 . -20) (f195901 . -16) (f195902 . -12) (f195901 . -8) (f195892 . 8) ((primitive-ref string=?) . 4) (f195892 . 0))
# var=f195892
    movl 6(%edi), %eax  # frame load f195892
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1431558
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1431558:
    movl %eax, -24(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1431559"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1431559:
# check bounds on vector index
    movl -24(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1431561
    cmp  $0,%eax
    jge _L_1431560
_L_1431561:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1431560:
    movl -24(%esp), %esi
    movl -1(%eax,%esi), %eax
   movl %eax,  -24(%esp)  # stash funcall-oper in next closure slot
# emit-expr f195901
# emit-variable-ref
# env=((f195902 . -20) (f195901 . -16) (f195902 . -12) (f195901 . -8) (f195892 . 8) ((primitive-ref string=?) . 4) (f195892 . 0))
# var=f195901
    movl -16(%esp), %eax  # stack load f195901
# end emit-variable-ref
    mov %eax, -28(%esp)    # arg f195901
# emit-expr (cdr f195902)
# emit-expr f195902
# emit-variable-ref
# env=((f195902 . -20) (f195901 . -16) (f195902 . -12) (f195901 . -8) (f195892 . 8) ((primitive-ref string=?) . 4) (f195892 . 0))
# var=f195902
    movl -20(%esp), %eax  # stack load f195902
# end emit-variable-ref
# check the argument is a pair
    movl %eax,%ebx
    and $7, %bl
    cmp $1, %bl
    je _L_1431562
# invoke error handler eh_pair
    .extern mrc_eh$upair
    movl mrc_eh$upair, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $112,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1431562:
    movl 3(%eax), %eax
    mov %eax, -32(%esp)    # arg (cdr f195902)
    movl -24(%esp), %edi   # load new closure to %edi
# emit-shift-args:  size=3   si=-24  delta=20
    mov -24(%esp), %ebx  # shift frame cell
    mov %ebx, -4(%esp)  # down to base
# emit-shift-args:  size=2   si=-28  delta=20
    mov -28(%esp), %ebx  # shift frame cell
    mov %ebx, -8(%esp)  # down to base
# emit-shift-args:  size=1   si=-32  delta=20
    mov -32(%esp), %ebx  # shift frame cell
    mov %ebx, -12(%esp)  # down to base
# emit-shift-args:  size=0   si=-36  delta=20
    movl $8,%eax   # save arg count
    jmp *-2(%edi)  # tail-funcall
_L_1431555:
_L_1431550:
    .align 4,0x90
_L_1431547:
    movl -4(%esp), %ebx
    movl -8(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin)
# emit-begin
#   expr=(begin)
#   env=((f195892 . 0))
# emit-expr (begin (closure (f195910) (f195892 (primitive-ref symbols)) (let ((f195910 f195910)) ((vector-ref f195892 0) f195910 ((primitive-ref symbols))))))
# emit-begin
#   expr=(begin (closure (f195910) (f195892 (primitive-ref symbols)) (let ((f195910 f195910)) ((vector-ref f195892 0) f195910 ((primitive-ref symbols))))))
#   env=((f195892 . 0))
# emit-expr (closure (f195910) (f195892 (primitive-ref symbols)) (let ((f195910 f195910)) ((vector-ref f195892 0) f195910 ((primitive-ref symbols)))))
# emit-closure
# si = -4
# env = ((f195892 . 0))
# expr = (closure (f195910) (f195892 (primitive-ref symbols)) (let ((f195910 f195910)) ((vector-ref f195892 0) f195910 ((primitive-ref symbols)))))
    movl $_L_1431563, 0(%ebp)  # closure label
# emit-variable-ref
# env=((f195892 . 0))
# var=f195892
    movl 0(%esp), %eax  # stack load f195892
# end emit-variable-ref
   movl  %eax, 4(%ebp)  # f195892
# WARNING: free var (primitive-ref symbols) not defined in the environmnet
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $16, %ebp     # bump ebp
    jmp _L_1431564            # jump around closure body
_L_1431563:
# check argument count
    cmp $4,%eax
    je _L_1431565
# invoke error handler eh_argcount
    .extern mrc_eh$uargcount
    movl mrc_eh$uargcount, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_1431565:
# emit-tail-expr
# si=-12
# env=((f195910 . -8) ((primitive-ref symbols) . 8) (f195892 . 4) (f195892 . 0))
# expr=(let ((f195910 f195910)) ((vector-ref f195892 0) f195910 ((primitive-ref symbols))))
# emit-tail-let
#  si   = -12
#  env  = ((f195910 . -8) ((primitive-ref symbols) . 8) (f195892 . 4) (f195892 . 0))
#  bindings = ((f195910 f195910))
#  body = ((vector-ref f195892 0) f195910 ((primitive-ref symbols)))
# emit-expr f195910
# emit-variable-ref
# env=((f195910 . -8) ((primitive-ref symbols) . 8) (f195892 . 4) (f195892 . 0))
# var=f195910
    movl -8(%esp), %eax  # stack load f195910
# end emit-variable-ref
    movl %eax, -12(%esp)  # stack save
# emit-tail-expr
# si=-16
# env=((f195910 . -12) (f195910 . -8) ((primitive-ref symbols) . 8) (f195892 . 4) (f195892 . 0))
# expr=((vector-ref f195892 0) f195910 ((primitive-ref symbols)))
# emit-tail-funcall
#    si   =-16
#    env  = ((f195910 . -12) (f195910 . -8) ((primitive-ref symbols) . 8) (f195892 . 4) (f195892 . 0))
#    expr = (funcall (vector-ref f195892 0) f195910 ((primitive-ref symbols)))
# emit-expr (vector-ref f195892 0)
# emit-expr f195892
# emit-variable-ref
# env=((f195910 . -12) (f195910 . -8) ((primitive-ref symbols) . 8) (f195892 . 4) (f195892 . 0))
# var=f195892
    movl 2(%edi), %eax  # frame load f195892
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1431566
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1431566:
    movl %eax, -16(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1431567"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1431567:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1431569
    cmp  $0,%eax
    jge _L_1431568
_L_1431569:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1431568:
    movl -16(%esp), %esi
    movl -1(%eax,%esi), %eax
   movl %eax,  -16(%esp)  # stash funcall-oper in next closure slot
# emit-expr f195910
# emit-variable-ref
# env=((f195910 . -12) (f195910 . -8) ((primitive-ref symbols) . 8) (f195892 . 4) (f195892 . 0))
# var=f195910
    movl -12(%esp), %eax  # stack load f195910
# end emit-variable-ref
    mov %eax, -20(%esp)    # arg f195910
# emit-expr ((primitive-ref symbols))
# funcall
#    si   =-24
#    env  = ((f195910 . -12) (f195910 . -8) ((primitive-ref symbols) . 8) (f195892 . 4) (f195892 . 0))
#    expr = (funcall (primitive-ref symbols))
# emit-expr (primitive-ref symbols)
    .extern mrc_symbols
    movl mrc_symbols,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1431570"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1431570":
   movl %eax,  -32(%esp)  # stash funcall-oper in closure slot
    movl -32(%esp), %edi   # load new closure to %edi
    add $-24, %esp   # adjust base
    movl $0,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $24, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    mov %eax, -24(%esp)    # arg ((primitive-ref symbols))
    movl -16(%esp), %edi   # load new closure to %edi
# emit-shift-args:  size=3   si=-16  delta=12
    mov -16(%esp), %ebx  # shift frame cell
    mov %ebx, -4(%esp)  # down to base
# emit-shift-args:  size=2   si=-20  delta=12
    mov -20(%esp), %ebx  # shift frame cell
    mov %ebx, -8(%esp)  # down to base
# emit-shift-args:  size=1   si=-24  delta=12
    mov -24(%esp), %ebx  # shift frame cell
    mov %ebx, -12(%esp)  # down to base
# emit-shift-args:  size=0   si=-28  delta=12
    movl $8,%eax   # save arg count
    jmp *-2(%edi)  # tail-funcall
    .align 4,0x90
_L_1431564:
# emit-expr (begin)
# emit-begin
#   expr=(begin)
#   env=((f195892 . 0))
     movl %eax, mrc_string$m$gsymbol
# == explicit-begins  ==>
# (lambda (lst elt) (if (null? lst) (cons elt nil) (cons (car lst) (append1 (cdr lst) elt))))
# == eliminate-let*  ==>
# (lambda (lst elt) (if (null? lst) (cons elt nil) (cons (car lst) (append1 (cdr lst) elt))))
# == uniquify-variables  ==>
# (lambda (f195911 f195912) (if (null? f195911) (cons f195912 nil) (cons (car f195911) (append1 (cdr f195911) f195912))))
# == vectorize-letrec  ==>
# (lambda (f195911 f195912) (if (null? f195911) (cons f195912 nil) (cons (car f195911) (append1 (cdr f195911) f195912))))
# == eliminate-set!  ==>
# (lambda (f195911 f195912) (let ((f195911 f195911) (f195912 f195912)) (if (null? f195911) (cons f195912 nil) (cons (car f195911) (append1 (cdr f195911) f195912)))))
# == close-free-variables  ==>
# (closure (f195911 f195912) (nil append1) (let ((f195911 f195911) (f195912 f195912)) (if (null? f195911) (cons f195912 nil) (cons (car f195911) (append1 (cdr f195911) f195912)))))
# == eliminate-quote  ==>
# (closure (f195911 f195912) (nil append1) (let ((f195911 f195911) (f195912 f195912)) (if (null? f195911) (cons f195912 nil) (cons (car f195911) (append1 (cdr f195911) f195912)))))
# == eliminate-when/unless  ==>
# (closure (f195911 f195912) (nil append1) (let ((f195911 f195911) (f195912 f195912)) (if (null? f195911) (cons f195912 nil) (cons (car f195911) (append1 (cdr f195911) f195912)))))
# == eliminate-cond  ==>
# (closure (f195911 f195912) (nil append1) (let ((f195911 f195911) (f195912 f195912)) (if (null? f195911) (cons f195912 nil) (cons (car f195911) (append1 (cdr f195911) f195912)))))
# == external-symbols  ==>
# (closure (f195911 f195912) (nil (primitive-ref append1)) (let ((f195911 f195911) (f195912 f195912)) (if (null? f195911) (cons f195912 nil) (cons (car f195911) ((primitive-ref append1) (cdr f195911) f195912)))))
# emit-expr (closure (f195911 f195912) (nil (primitive-ref append1)) (let ((f195911 f195911) (f195912 f195912)) (if (null? f195911) (cons f195912 nil) (cons (car f195911) ((primitive-ref append1) (cdr f195911) f195912)))))
# emit-closure
# si = 0
# env = ()
# expr = (closure (f195911 f195912) (nil (primitive-ref append1)) (let ((f195911 f195911) (f195912 f195912)) (if (null? f195911) (cons f195912 nil) (cons (car f195911) ((primitive-ref append1) (cdr f195911) f195912)))))
    movl $_L_1431571, 0(%ebp)  # closure label
# WARNING: free var nil not defined in the environmnet
# WARNING: free var (primitive-ref append1) not defined in the environmnet
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $16, %ebp     # bump ebp
    jmp _L_1431572            # jump around closure body
_L_1431571:
# check argument count
    cmp $8,%eax
    je _L_1431573
# invoke error handler eh_argcount
    .extern mrc_eh$uargcount
    movl mrc_eh$uargcount, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_1431573:
# emit-tail-expr
# si=-16
# env=((f195912 . -12) (f195911 . -8) ((primitive-ref append1) . 8) (nil . 4))
# expr=(let ((f195911 f195911) (f195912 f195912)) (if (null? f195911) (cons f195912 nil) (cons (car f195911) ((primitive-ref append1) (cdr f195911) f195912))))
# emit-tail-let
#  si   = -16
#  env  = ((f195912 . -12) (f195911 . -8) ((primitive-ref append1) . 8) (nil . 4))
#  bindings = ((f195911 f195911) (f195912 f195912))
#  body = (if (null? f195911) (cons f195912 nil) (cons (car f195911) ((primitive-ref append1) (cdr f195911) f195912)))
# emit-expr f195911
# emit-variable-ref
# env=((f195912 . -12) (f195911 . -8) ((primitive-ref append1) . 8) (nil . 4))
# var=f195911
    movl -8(%esp), %eax  # stack load f195911
# end emit-variable-ref
    movl %eax, -16(%esp)  # stack save
# emit-expr f195912
# emit-variable-ref
# env=((f195912 . -12) (f195911 . -8) ((primitive-ref append1) . 8) (nil . 4))
# var=f195912
    movl -12(%esp), %eax  # stack load f195912
# end emit-variable-ref
    movl %eax, -20(%esp)  # stack save
# emit-tail-expr
# si=-24
# env=((f195912 . -20) (f195911 . -16) (f195912 . -12) (f195911 . -8) ((primitive-ref append1) . 8) (nil . 4))
# expr=(if (null? f195911) (cons f195912 nil) (cons (car f195911) ((primitive-ref append1) (cdr f195911) f195912)))
# emit-expr (null? f195911)
# emit-expr f195911
# emit-variable-ref
# env=((f195912 . -20) (f195911 . -16) (f195912 . -12) (f195911 . -8) ((primitive-ref append1) . 8) (nil . 4))
# var=f195911
    movl -16(%esp), %eax  # stack load f195911
# end emit-variable-ref
    cmp $63, %eax
    mov $0, %eax
    sete %al
    movzbl %al, %eax
    sal $6, %al
    or $47, %al
    cmp $47, %al
    je _L_1431574
# emit-tail-expr
# si=-24
# env=((f195912 . -20) (f195911 . -16) (f195912 . -12) (f195911 . -8) ((primitive-ref append1) . 8) (nil . 4))
# expr=(cons f195912 nil)
# tail primcall
# cons arg1=f195912 arg2=nil
# emit-expr f195912
# emit-variable-ref
# env=((f195912 . -20) (f195911 . -16) (f195912 . -12) (f195911 . -8) ((primitive-ref append1) . 8) (nil . 4))
# var=f195912
    movl -20(%esp), %eax  # stack load f195912
# end emit-variable-ref
    movl %eax, -24(%esp)
# emit-expr nil
# emit-variable-ref
# env=((f195912 . -20) (f195911 . -16) (f195912 . -12) (f195911 . -8) ((primitive-ref append1) . 8) (nil . 4))
# var=nil
    movl 2(%edi), %eax  # frame load nil
# end emit-variable-ref
    movl %eax, 4(%ebp)
    movl -24(%esp), %eax
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    or   $1, %al
    add  $8, %ebp
# cons end
#return from tail (cons f195912 nil)
    ret
    jmp _L_1431575
_L_1431574:
# emit-tail-expr
# si=-24
# env=((f195912 . -20) (f195911 . -16) (f195912 . -12) (f195911 . -8) ((primitive-ref append1) . 8) (nil . 4))
# expr=(cons (car f195911) ((primitive-ref append1) (cdr f195911) f195912))
# tail primcall
# cons arg1=(car f195911) arg2=((primitive-ref append1) (cdr f195911) f195912)
# emit-expr (car f195911)
# emit-expr f195911
# emit-variable-ref
# env=((f195912 . -20) (f195911 . -16) (f195912 . -12) (f195911 . -8) ((primitive-ref append1) . 8) (nil . 4))
# var=f195911
    movl -16(%esp), %eax  # stack load f195911
# end emit-variable-ref
# check the argument is a pair
    movl %eax,%ebx
    and $7, %bl
    cmp $1, %bl
    je _L_1431576
# invoke error handler eh_pair
    .extern mrc_eh$upair
    movl mrc_eh$upair, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $108,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1431576:
    movl -1(%eax), %eax
    movl %eax, -24(%esp)
# emit-expr ((primitive-ref append1) (cdr f195911) f195912)
# funcall
#    si   =-28
#    env  = ((f195912 . -20) (f195911 . -16) (f195912 . -12) (f195911 . -8) ((primitive-ref append1) . 8) (nil . 4))
#    expr = (funcall (primitive-ref append1) (cdr f195911) f195912)
# emit-expr (primitive-ref append1)
    .extern mrc_append1
    movl mrc_append1,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1431577"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1431577":
   movl %eax,  -36(%esp)  # stash funcall-oper in closure slot
# emit-expr (cdr f195911)
# emit-expr f195911
# emit-variable-ref
# env=((f195912 . -20) (f195911 . -16) (f195912 . -12) (f195911 . -8) ((primitive-ref append1) . 8) (nil . 4))
# var=f195911
    movl -16(%esp), %eax  # stack load f195911
# end emit-variable-ref
# check the argument is a pair
    movl %eax,%ebx
    and $7, %bl
    cmp $1, %bl
    je _L_1431578
# invoke error handler eh_pair
    .extern mrc_eh$upair
    movl mrc_eh$upair, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $112,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1431578:
    movl 3(%eax), %eax
    mov %eax, -40(%esp)  # arg (cdr f195911)
# emit-expr f195912
# emit-variable-ref
# env=((f195912 . -20) (f195911 . -16) (f195912 . -12) (f195911 . -8) ((primitive-ref append1) . 8) (nil . 4))
# var=f195912
    movl -20(%esp), %eax  # stack load f195912
# end emit-variable-ref
    mov %eax, -44(%esp)  # arg f195912
    movl -36(%esp), %edi   # load new closure to %edi
    add $-28, %esp   # adjust base
    movl $8,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $28, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    movl %eax, 4(%ebp)
    movl -24(%esp), %eax
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    or   $1, %al
    add  $8, %ebp
# cons end
#return from tail (cons (car f195911) ((primitive-ref append1) (cdr f195911) f195912))
    ret
_L_1431575:
    .align 4,0x90
_L_1431572:
     movl %eax, mrc_append1
# == explicit-begins  ==>
# (lambda (l k) (if (fx= k 0) (car l) (list-ref (cdr l) (fx- k 1))))
# == eliminate-let*  ==>
# (lambda (l k) (if (fx= k 0) (car l) (list-ref (cdr l) (fx- k 1))))
# == uniquify-variables  ==>
# (lambda (f195913 f195914) (if (fx= f195914 0) (car f195913) (list-ref (cdr f195913) (fx- f195914 1))))
# == vectorize-letrec  ==>
# (lambda (f195913 f195914) (if (fx= f195914 0) (car f195913) (list-ref (cdr f195913) (fx- f195914 1))))
# == eliminate-set!  ==>
# (lambda (f195913 f195914) (let ((f195913 f195913) (f195914 f195914)) (if (fx= f195914 0) (car f195913) (list-ref (cdr f195913) (fx- f195914 1)))))
# == close-free-variables  ==>
# (closure (f195913 f195914) (list-ref) (let ((f195913 f195913) (f195914 f195914)) (if (fx= f195914 0) (car f195913) (list-ref (cdr f195913) (fx- f195914 1)))))
# == eliminate-quote  ==>
# (closure (f195913 f195914) (list-ref) (let ((f195913 f195913) (f195914 f195914)) (if (fx= f195914 0) (car f195913) (list-ref (cdr f195913) (fx- f195914 1)))))
# == eliminate-when/unless  ==>
# (closure (f195913 f195914) (list-ref) (let ((f195913 f195913) (f195914 f195914)) (if (fx= f195914 0) (car f195913) (list-ref (cdr f195913) (fx- f195914 1)))))
# == eliminate-cond  ==>
# (closure (f195913 f195914) (list-ref) (let ((f195913 f195913) (f195914 f195914)) (if (fx= f195914 0) (car f195913) (list-ref (cdr f195913) (fx- f195914 1)))))
# == external-symbols  ==>
# (closure (f195913 f195914) ((primitive-ref list-ref)) (let ((f195913 f195913) (f195914 f195914)) (if (fx= f195914 0) (car f195913) ((primitive-ref list-ref) (cdr f195913) (fx- f195914 1)))))
# emit-expr (closure (f195913 f195914) ((primitive-ref list-ref)) (let ((f195913 f195913) (f195914 f195914)) (if (fx= f195914 0) (car f195913) ((primitive-ref list-ref) (cdr f195913) (fx- f195914 1)))))
# emit-closure
# si = 0
# env = ()
# expr = (closure (f195913 f195914) ((primitive-ref list-ref)) (let ((f195913 f195913) (f195914 f195914)) (if (fx= f195914 0) (car f195913) ((primitive-ref list-ref) (cdr f195913) (fx- f195914 1)))))
    movl $_L_1431579, 0(%ebp)  # closure label
# WARNING: free var (primitive-ref list-ref) not defined in the environmnet
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $8, %ebp     # bump ebp
    jmp _L_1431580            # jump around closure body
_L_1431579:
# check argument count
    cmp $8,%eax
    je _L_1431581
# invoke error handler eh_argcount
    .extern mrc_eh$uargcount
    movl mrc_eh$uargcount, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_1431581:
# emit-tail-expr
# si=-16
# env=((f195914 . -12) (f195913 . -8) ((primitive-ref list-ref) . 4))
# expr=(let ((f195913 f195913) (f195914 f195914)) (if (fx= f195914 0) (car f195913) ((primitive-ref list-ref) (cdr f195913) (fx- f195914 1))))
# emit-tail-let
#  si   = -16
#  env  = ((f195914 . -12) (f195913 . -8) ((primitive-ref list-ref) . 4))
#  bindings = ((f195913 f195913) (f195914 f195914))
#  body = (if (fx= f195914 0) (car f195913) ((primitive-ref list-ref) (cdr f195913) (fx- f195914 1)))
# emit-expr f195913
# emit-variable-ref
# env=((f195914 . -12) (f195913 . -8) ((primitive-ref list-ref) . 4))
# var=f195913
    movl -8(%esp), %eax  # stack load f195913
# end emit-variable-ref
    movl %eax, -16(%esp)  # stack save
# emit-expr f195914
# emit-variable-ref
# env=((f195914 . -12) (f195913 . -8) ((primitive-ref list-ref) . 4))
# var=f195914
    movl -12(%esp), %eax  # stack load f195914
# end emit-variable-ref
    movl %eax, -20(%esp)  # stack save
# emit-tail-expr
# si=-24
# env=((f195914 . -20) (f195913 . -16) (f195914 . -12) (f195913 . -8) ((primitive-ref list-ref) . 4))
# expr=(if (fx= f195914 0) (car f195913) ((primitive-ref list-ref) (cdr f195913) (fx- f195914 1)))
# emit-expr (fx= f195914 0)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1431584"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $60,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1431584:
    movl %eax, -24(%esp)
# emit-expr f195914
# emit-variable-ref
# env=((f195914 . -20) (f195913 . -16) (f195914 . -12) (f195913 . -8) ((primitive-ref list-ref) . 4))
# var=f195914
    movl -20(%esp), %eax  # stack load f195914
# end emit-variable-ref
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1431585"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $60,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1431585:
    cmp -24(%esp), %eax
    sete %al
    movzbl %al, %eax
    sal $6, %al
    or $47, %al
    cmp $47, %al
    je _L_1431582
# emit-tail-expr
# si=-24
# env=((f195914 . -20) (f195913 . -16) (f195914 . -12) (f195913 . -8) ((primitive-ref list-ref) . 4))
# expr=(car f195913)
# tail primcall
# emit-expr f195913
# emit-variable-ref
# env=((f195914 . -20) (f195913 . -16) (f195914 . -12) (f195913 . -8) ((primitive-ref list-ref) . 4))
# var=f195913
    movl -16(%esp), %eax  # stack load f195913
# end emit-variable-ref
# check the argument is a pair
    movl %eax,%ebx
    and $7, %bl
    cmp $1, %bl
    je _L_1431586
# invoke error handler eh_pair
    .extern mrc_eh$upair
    movl mrc_eh$upair, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $108,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1431586:
    movl -1(%eax), %eax
#return from tail (car f195913)
    ret
    jmp _L_1431583
_L_1431582:
# emit-tail-expr
# si=-24
# env=((f195914 . -20) (f195913 . -16) (f195914 . -12) (f195913 . -8) ((primitive-ref list-ref) . 4))
# expr=((primitive-ref list-ref) (cdr f195913) (fx- f195914 1))
# emit-tail-funcall
#    si   =-24
#    env  = ((f195914 . -20) (f195913 . -16) (f195914 . -12) (f195913 . -8) ((primitive-ref list-ref) . 4))
#    expr = (funcall (primitive-ref list-ref) (cdr f195913) (fx- f195914 1))
# emit-expr (primitive-ref list-ref)
    .extern mrc_list$mref
    movl mrc_list$mref,%eax
   movl %eax,  -24(%esp)  # stash funcall-oper in next closure slot
# emit-expr (cdr f195913)
# emit-expr f195913
# emit-variable-ref
# env=((f195914 . -20) (f195913 . -16) (f195914 . -12) (f195913 . -8) ((primitive-ref list-ref) . 4))
# var=f195913
    movl -16(%esp), %eax  # stack load f195913
# end emit-variable-ref
# check the argument is a pair
    movl %eax,%ebx
    and $7, %bl
    cmp $1, %bl
    je _L_1431587
# invoke error handler eh_pair
    .extern mrc_eh$upair
    movl mrc_eh$upair, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $112,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1431587:
    movl 3(%eax), %eax
    mov %eax, -28(%esp)    # arg (cdr f195913)
# emit-expr (fx- f195914 1)
# emit-expr 1
    movl $4, %eax     # immed 1
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1431588"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $84,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1431588:
    movl %eax, -32(%esp)
# emit-expr f195914
# emit-variable-ref
# env=((f195914 . -20) (f195913 . -16) (f195914 . -12) (f195913 . -8) ((primitive-ref list-ref) . 4))
# var=f195914
    movl -20(%esp), %eax  # stack load f195914
# end emit-variable-ref
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1431589"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $84,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1431589:
    subl -32(%esp), %eax
    mov %eax, -32(%esp)    # arg (fx- f195914 1)
    movl -24(%esp), %edi   # load new closure to %edi
# emit-shift-args:  size=3   si=-24  delta=20
    mov -24(%esp), %ebx  # shift frame cell
    mov %ebx, -4(%esp)  # down to base
# emit-shift-args:  size=2   si=-28  delta=20
    mov -28(%esp), %ebx  # shift frame cell
    mov %ebx, -8(%esp)  # down to base
# emit-shift-args:  size=1   si=-32  delta=20
    mov -32(%esp), %ebx  # shift frame cell
    mov %ebx, -12(%esp)  # down to base
# emit-shift-args:  size=0   si=-36  delta=20
    movl $8,%eax   # save arg count
    jmp *-2(%edi)  # tail-funcall
_L_1431583:
    .align 4,0x90
_L_1431580:
     movl %eax, mrc_list$mref
# == explicit-begins  ==>
# (lambda (l) (if (null? l) 0 (fxadd1 (list-length (cdr l)))))
# == eliminate-let*  ==>
# (lambda (l) (if (null? l) 0 (fxadd1 (list-length (cdr l)))))
# == uniquify-variables  ==>
# (lambda (f195915) (if (null? f195915) 0 (fxadd1 (list-length (cdr f195915)))))
# == vectorize-letrec  ==>
# (lambda (f195915) (if (null? f195915) 0 (fxadd1 (list-length (cdr f195915)))))
# == eliminate-set!  ==>
# (lambda (f195915) (let ((f195915 f195915)) (if (null? f195915) 0 (fxadd1 (list-length (cdr f195915))))))
# == close-free-variables  ==>
# (closure (f195915) (list-length) (let ((f195915 f195915)) (if (null? f195915) 0 (fxadd1 (list-length (cdr f195915))))))
# == eliminate-quote  ==>
# (closure (f195915) (list-length) (let ((f195915 f195915)) (if (null? f195915) 0 (fxadd1 (list-length (cdr f195915))))))
# == eliminate-when/unless  ==>
# (closure (f195915) (list-length) (let ((f195915 f195915)) (if (null? f195915) 0 (fxadd1 (list-length (cdr f195915))))))
# == eliminate-cond  ==>
# (closure (f195915) (list-length) (let ((f195915 f195915)) (if (null? f195915) 0 (fxadd1 (list-length (cdr f195915))))))
# == external-symbols  ==>
# (closure (f195915) ((primitive-ref list-length)) (let ((f195915 f195915)) (if (null? f195915) 0 (fxadd1 ((primitive-ref list-length) (cdr f195915))))))
# emit-expr (closure (f195915) ((primitive-ref list-length)) (let ((f195915 f195915)) (if (null? f195915) 0 (fxadd1 ((primitive-ref list-length) (cdr f195915))))))
# emit-closure
# si = 0
# env = ()
# expr = (closure (f195915) ((primitive-ref list-length)) (let ((f195915 f195915)) (if (null? f195915) 0 (fxadd1 ((primitive-ref list-length) (cdr f195915))))))
    movl $_L_1431590, 0(%ebp)  # closure label
# WARNING: free var (primitive-ref list-length) not defined in the environmnet
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $8, %ebp     # bump ebp
    jmp _L_1431591            # jump around closure body
_L_1431590:
# check argument count
    cmp $4,%eax
    je _L_1431592
# invoke error handler eh_argcount
    .extern mrc_eh$uargcount
    movl mrc_eh$uargcount, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_1431592:
# emit-tail-expr
# si=-12
# env=((f195915 . -8) ((primitive-ref list-length) . 4))
# expr=(let ((f195915 f195915)) (if (null? f195915) 0 (fxadd1 ((primitive-ref list-length) (cdr f195915)))))
# emit-tail-let
#  si   = -12
#  env  = ((f195915 . -8) ((primitive-ref list-length) . 4))
#  bindings = ((f195915 f195915))
#  body = (if (null? f195915) 0 (fxadd1 ((primitive-ref list-length) (cdr f195915))))
# emit-expr f195915
# emit-variable-ref
# env=((f195915 . -8) ((primitive-ref list-length) . 4))
# var=f195915
    movl -8(%esp), %eax  # stack load f195915
# end emit-variable-ref
    movl %eax, -12(%esp)  # stack save
# emit-tail-expr
# si=-16
# env=((f195915 . -12) (f195915 . -8) ((primitive-ref list-length) . 4))
# expr=(if (null? f195915) 0 (fxadd1 ((primitive-ref list-length) (cdr f195915))))
# emit-expr (null? f195915)
# emit-expr f195915
# emit-variable-ref
# env=((f195915 . -12) (f195915 . -8) ((primitive-ref list-length) . 4))
# var=f195915
    movl -12(%esp), %eax  # stack load f195915
# end emit-variable-ref
    cmp $63, %eax
    mov $0, %eax
    sete %al
    movzbl %al, %eax
    sal $6, %al
    or $47, %al
    cmp $47, %al
    je _L_1431593
# emit-tail-expr
# si=-16
# env=((f195915 . -12) (f195915 . -8) ((primitive-ref list-length) . 4))
# expr=0
    movl $0, %eax     # immed 0
    ret                  # immediate tail return
    jmp _L_1431594
_L_1431593:
# emit-tail-expr
# si=-16
# env=((f195915 . -12) (f195915 . -8) ((primitive-ref list-length) . 4))
# expr=(fxadd1 ((primitive-ref list-length) (cdr f195915)))
# tail primcall
# emit-expr ((primitive-ref list-length) (cdr f195915))
# funcall
#    si   =-16
#    env  = ((f195915 . -12) (f195915 . -8) ((primitive-ref list-length) . 4))
#    expr = (funcall (primitive-ref list-length) (cdr f195915))
# emit-expr (primitive-ref list-length)
    .extern mrc_list$mlength
    movl mrc_list$mlength,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1431595"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1431595":
   movl %eax,  -24(%esp)  # stash funcall-oper in closure slot
# emit-expr (cdr f195915)
# emit-expr f195915
# emit-variable-ref
# env=((f195915 . -12) (f195915 . -8) ((primitive-ref list-length) . 4))
# var=f195915
    movl -12(%esp), %eax  # stack load f195915
# end emit-variable-ref
# check the argument is a pair
    movl %eax,%ebx
    and $7, %bl
    cmp $1, %bl
    je _L_1431596
# invoke error handler eh_pair
    .extern mrc_eh$upair
    movl mrc_eh$upair, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $112,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1431596:
    movl 3(%eax), %eax
    mov %eax, -28(%esp)  # arg (cdr f195915)
    movl -24(%esp), %edi   # load new closure to %edi
    add $-16, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $16, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1431597"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $48,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1431597:
     addl $4, %eax
#return from tail (fxadd1 ((primitive-ref list-length) (cdr f195915)))
    ret
_L_1431594:
    .align 4,0x90
_L_1431591:
     movl %eax, mrc_list$mlength
# == explicit-begins  ==>
# (letrec ((f (lambda (l lrev) (if (null? l) lrev (f (cdr l) (cons (car l) lrev)))))) (lambda (l) (f l (quote ()))))
# == eliminate-let*  ==>
# (letrec ((f (lambda (l lrev) (if (null? l) lrev (f (cdr l) (cons (car l) lrev)))))) (lambda (l) (f l (quote ()))))
# == uniquify-variables  ==>
# (letrec ((f195916 (lambda (f195919 f195920) (if (null? f195919) f195920 (f195916 (cdr f195919) (cons (car f195919) f195920)))))) (lambda (f195922) (f195916 f195922 (quote ()))))
# == vectorize-letrec  ==>
# (let ((f195916 (make-vector 1))) (begin (begin (vector-set! f195916 0 (lambda (f195919 f195920) (if (null? f195919) f195920 ((vector-ref f195916 0) (cdr f195919) (cons (car f195919) f195920)))))) (lambda (f195922) ((vector-ref f195916 0) f195922 (quote ())))))
# == eliminate-set!  ==>
# (let ((f195916 (make-vector 1))) (begin (begin (vector-set! f195916 0 (lambda (f195919 f195920) (let ((f195919 f195919) (f195920 f195920)) (if (null? f195919) f195920 ((vector-ref f195916 0) (cdr f195919) (cons (car f195919) f195920))))))) (lambda (f195922) (let ((f195922 f195922)) ((vector-ref f195916 0) f195922 (quote ()))))))
# == close-free-variables  ==>
# (let ((f195916 (make-vector 1))) (begin (begin (vector-set! f195916 0 (closure (f195919 f195920) (f195916) (let ((f195919 f195919) (f195920 f195920)) (if (null? f195919) f195920 ((vector-ref f195916 0) (cdr f195919) (cons (car f195919) f195920))))))) (closure (f195922) (f195916) (let ((f195922 f195922)) ((vector-ref f195916 0) f195922 (quote ()))))))
# == eliminate-quote  ==>
# (let ((f195916 (make-vector 1))) (begin (begin (vector-set! f195916 0 (closure (f195919 f195920) (f195916) (let ((f195919 f195919) (f195920 f195920)) (if (null? f195919) f195920 ((vector-ref f195916 0) (cdr f195919) (cons (car f195919) f195920))))))) (closure (f195922) (f195916) (let ((f195922 f195922)) ((vector-ref f195916 0) f195922 ())))))
# == eliminate-when/unless  ==>
# (let ((f195916 (make-vector 1))) (begin (begin (vector-set! f195916 0 (closure (f195919 f195920) (f195916) (let ((f195919 f195919) (f195920 f195920)) (if (null? f195919) f195920 ((vector-ref f195916 0) (cdr f195919) (cons (car f195919) f195920))))))) (closure (f195922) (f195916) (let ((f195922 f195922)) ((vector-ref f195916 0) f195922 ())))))
# == eliminate-cond  ==>
# (let ((f195916 (make-vector 1))) (begin (begin (vector-set! f195916 0 (closure (f195919 f195920) (f195916) (let ((f195919 f195919) (f195920 f195920)) (if (null? f195919) f195920 ((vector-ref f195916 0) (cdr f195919) (cons (car f195919) f195920))))))) (closure (f195922) (f195916) (let ((f195922 f195922)) ((vector-ref f195916 0) f195922 ())))))
# == external-symbols  ==>
# (let ((f195916 (make-vector 1))) (begin (begin (vector-set! f195916 0 (closure (f195919 f195920) (f195916) (let ((f195919 f195919) (f195920 f195920)) (if (null? f195919) f195920 ((vector-ref f195916 0) (cdr f195919) (cons (car f195919) f195920))))))) (closure (f195922) (f195916) (let ((f195922 f195922)) ((vector-ref f195916 0) f195922 ())))))
# emit-expr (let ((f195916 (make-vector 1))) (begin (begin (vector-set! f195916 0 (closure (f195919 f195920) (f195916) (let ((f195919 f195919) (f195920 f195920)) (if (null? f195919) f195920 ((vector-ref f195916 0) (cdr f195919) (cons (car f195919) f195920))))))) (closure (f195922) (f195916) (let ((f195922 f195922)) ((vector-ref f195916 0) f195922 ())))))
# emit-let
#  si   = 0
#  env  = ()
#  bindings = ((f195916 (make-vector 1)))
#  body = (begin (begin (vector-set! f195916 0 (closure (f195919 f195920) (f195916) (let ((f195919 f195919) (f195920 f195920)) (if (null? f195919) f195920 ((vector-ref f195916 0) (cdr f195919) (cons (car f195919) f195920))))))) (closure (f195922) (f195916) (let ((f195922 f195922)) ((vector-ref f195916 0) f195922 ()))))
# emit-expr (make-vector 1)
# make-vector 1
# emit-expr 1
    movl $4, %eax     # immed 1
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1431598"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $128,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1431598:
# check the argument is a fixnum >= 0
    cmp $0,%eax
    jge _L_1431599
# invoke error handler eh_length
    .extern mrc_eh$ulength
    movl mrc_eh$ulength, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $128,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1431599:
    movl %eax, %esi
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    orl  $5, %eax
    addl $4, %esi
    addl $4, %esi
    andl $-8, %esi
    addl %esi, %ebp
    movl %eax, 0(%esp)  # stack save
# emit-expr (begin (begin (vector-set! f195916 0 (closure (f195919 f195920) (f195916) (let ((f195919 f195919) (f195920 f195920)) (if (null? f195919) f195920 ((vector-ref f195916 0) (cdr f195919) (cons (car f195919) f195920))))))) (closure (f195922) (f195916) (let ((f195922 f195922)) ((vector-ref f195916 0) f195922 ()))))
# emit-begin
#   expr=(begin (begin (vector-set! f195916 0 (closure (f195919 f195920) (f195916) (let ((f195919 f195919) (f195920 f195920)) (if (null? f195919) f195920 ((vector-ref f195916 0) (cdr f195919) (cons (car f195919) f195920))))))) (closure (f195922) (f195916) (let ((f195922 f195922)) ((vector-ref f195916 0) f195922 ()))))
#   env=((f195916 . 0))
# emit-expr (begin (vector-set! f195916 0 (closure (f195919 f195920) (f195916) (let ((f195919 f195919) (f195920 f195920)) (if (null? f195919) f195920 ((vector-ref f195916 0) (cdr f195919) (cons (car f195919) f195920)))))))
# emit-begin
#   expr=(begin (vector-set! f195916 0 (closure (f195919 f195920) (f195916) (let ((f195919 f195919) (f195920 f195920)) (if (null? f195919) f195920 ((vector-ref f195916 0) (cdr f195919) (cons (car f195919) f195920)))))))
#   env=((f195916 . 0))
# emit-expr (vector-set! f195916 0 (closure (f195919 f195920) (f195916) (let ((f195919 f195919) (f195920 f195920)) (if (null? f195919) f195920 ((vector-ref f195916 0) (cdr f195919) (cons (car f195919) f195920))))))
# emit-expr f195916
# emit-variable-ref
# env=((f195916 . 0))
# var=f195916
    movl 0(%esp), %eax  # stack load f195916
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1431600
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1431600:
    movl %eax, -4(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1431601"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1431601:
# check bounds on vector index
    movl -4(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1431603
    cmp  $0,%eax
    jge _L_1431602
_L_1431603:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1431602:
    movl %eax, -8(%esp)
# emit-expr (closure (f195919 f195920) (f195916) (let ((f195919 f195919) (f195920 f195920)) (if (null? f195919) f195920 ((vector-ref f195916 0) (cdr f195919) (cons (car f195919) f195920)))))
# emit-closure
# si = -12
# env = ((f195916 . 0))
# expr = (closure (f195919 f195920) (f195916) (let ((f195919 f195919) (f195920 f195920)) (if (null? f195919) f195920 ((vector-ref f195916 0) (cdr f195919) (cons (car f195919) f195920)))))
    movl $_L_1431604, 0(%ebp)  # closure label
# emit-variable-ref
# env=((f195916 . 0))
# var=f195916
    movl 0(%esp), %eax  # stack load f195916
# end emit-variable-ref
   movl  %eax, 4(%ebp)  # f195916
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $8, %ebp     # bump ebp
    jmp _L_1431605            # jump around closure body
_L_1431604:
# check argument count
    cmp $8,%eax
    je _L_1431606
# invoke error handler eh_argcount
    .extern mrc_eh$uargcount
    movl mrc_eh$uargcount, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_1431606:
# emit-tail-expr
# si=-16
# env=((f195920 . -12) (f195919 . -8) (f195916 . 4) (f195916 . 0))
# expr=(let ((f195919 f195919) (f195920 f195920)) (if (null? f195919) f195920 ((vector-ref f195916 0) (cdr f195919) (cons (car f195919) f195920))))
# emit-tail-let
#  si   = -16
#  env  = ((f195920 . -12) (f195919 . -8) (f195916 . 4) (f195916 . 0))
#  bindings = ((f195919 f195919) (f195920 f195920))
#  body = (if (null? f195919) f195920 ((vector-ref f195916 0) (cdr f195919) (cons (car f195919) f195920)))
# emit-expr f195919
# emit-variable-ref
# env=((f195920 . -12) (f195919 . -8) (f195916 . 4) (f195916 . 0))
# var=f195919
    movl -8(%esp), %eax  # stack load f195919
# end emit-variable-ref
    movl %eax, -16(%esp)  # stack save
# emit-expr f195920
# emit-variable-ref
# env=((f195920 . -12) (f195919 . -8) (f195916 . 4) (f195916 . 0))
# var=f195920
    movl -12(%esp), %eax  # stack load f195920
# end emit-variable-ref
    movl %eax, -20(%esp)  # stack save
# emit-tail-expr
# si=-24
# env=((f195920 . -20) (f195919 . -16) (f195920 . -12) (f195919 . -8) (f195916 . 4) (f195916 . 0))
# expr=(if (null? f195919) f195920 ((vector-ref f195916 0) (cdr f195919) (cons (car f195919) f195920)))
# emit-expr (null? f195919)
# emit-expr f195919
# emit-variable-ref
# env=((f195920 . -20) (f195919 . -16) (f195920 . -12) (f195919 . -8) (f195916 . 4) (f195916 . 0))
# var=f195919
    movl -16(%esp), %eax  # stack load f195919
# end emit-variable-ref
    cmp $63, %eax
    mov $0, %eax
    sete %al
    movzbl %al, %eax
    sal $6, %al
    or $47, %al
    cmp $47, %al
    je _L_1431607
# emit-tail-expr
# si=-24
# env=((f195920 . -20) (f195919 . -16) (f195920 . -12) (f195919 . -8) (f195916 . 4) (f195916 . 0))
# expr=f195920
# emit-tail-variable-ref
# emit-variable-ref
# env=((f195920 . -20) (f195919 . -16) (f195920 . -12) (f195919 . -8) (f195916 . 4) (f195916 . 0))
# var=f195920
    movl -20(%esp), %eax  # stack load f195920
# end emit-variable-ref
    ret
# end emit-tail-variable ref
    jmp _L_1431608
_L_1431607:
# emit-tail-expr
# si=-24
# env=((f195920 . -20) (f195919 . -16) (f195920 . -12) (f195919 . -8) (f195916 . 4) (f195916 . 0))
# expr=((vector-ref f195916 0) (cdr f195919) (cons (car f195919) f195920))
# emit-tail-funcall
#    si   =-24
#    env  = ((f195920 . -20) (f195919 . -16) (f195920 . -12) (f195919 . -8) (f195916 . 4) (f195916 . 0))
#    expr = (funcall (vector-ref f195916 0) (cdr f195919) (cons (car f195919) f195920))
# emit-expr (vector-ref f195916 0)
# emit-expr f195916
# emit-variable-ref
# env=((f195920 . -20) (f195919 . -16) (f195920 . -12) (f195919 . -8) (f195916 . 4) (f195916 . 0))
# var=f195916
    movl 2(%edi), %eax  # frame load f195916
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1431609
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1431609:
    movl %eax, -24(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1431610"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1431610:
# check bounds on vector index
    movl -24(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1431612
    cmp  $0,%eax
    jge _L_1431611
_L_1431612:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1431611:
    movl -24(%esp), %esi
    movl -1(%eax,%esi), %eax
   movl %eax,  -24(%esp)  # stash funcall-oper in next closure slot
# emit-expr (cdr f195919)
# emit-expr f195919
# emit-variable-ref
# env=((f195920 . -20) (f195919 . -16) (f195920 . -12) (f195919 . -8) (f195916 . 4) (f195916 . 0))
# var=f195919
    movl -16(%esp), %eax  # stack load f195919
# end emit-variable-ref
# check the argument is a pair
    movl %eax,%ebx
    and $7, %bl
    cmp $1, %bl
    je _L_1431613
# invoke error handler eh_pair
    .extern mrc_eh$upair
    movl mrc_eh$upair, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $112,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1431613:
    movl 3(%eax), %eax
    mov %eax, -28(%esp)    # arg (cdr f195919)
# emit-expr (cons (car f195919) f195920)
# cons arg1=(car f195919) arg2=f195920
# emit-expr (car f195919)
# emit-expr f195919
# emit-variable-ref
# env=((f195920 . -20) (f195919 . -16) (f195920 . -12) (f195919 . -8) (f195916 . 4) (f195916 . 0))
# var=f195919
    movl -16(%esp), %eax  # stack load f195919
# end emit-variable-ref
# check the argument is a pair
    movl %eax,%ebx
    and $7, %bl
    cmp $1, %bl
    je _L_1431614
# invoke error handler eh_pair
    .extern mrc_eh$upair
    movl mrc_eh$upair, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $108,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1431614:
    movl -1(%eax), %eax
    movl %eax, -32(%esp)
# emit-expr f195920
# emit-variable-ref
# env=((f195920 . -20) (f195919 . -16) (f195920 . -12) (f195919 . -8) (f195916 . 4) (f195916 . 0))
# var=f195920
    movl -20(%esp), %eax  # stack load f195920
# end emit-variable-ref
    movl %eax, 4(%ebp)
    movl -32(%esp), %eax
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    or   $1, %al
    add  $8, %ebp
# cons end
    mov %eax, -32(%esp)    # arg (cons (car f195919) f195920)
    movl -24(%esp), %edi   # load new closure to %edi
# emit-shift-args:  size=3   si=-24  delta=20
    mov -24(%esp), %ebx  # shift frame cell
    mov %ebx, -4(%esp)  # down to base
# emit-shift-args:  size=2   si=-28  delta=20
    mov -28(%esp), %ebx  # shift frame cell
    mov %ebx, -8(%esp)  # down to base
# emit-shift-args:  size=1   si=-32  delta=20
    mov -32(%esp), %ebx  # shift frame cell
    mov %ebx, -12(%esp)  # down to base
# emit-shift-args:  size=0   si=-36  delta=20
    movl $8,%eax   # save arg count
    jmp *-2(%edi)  # tail-funcall
_L_1431608:
    .align 4,0x90
_L_1431605:
    movl -4(%esp), %ebx
    movl -8(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin)
# emit-begin
#   expr=(begin)
#   env=((f195916 . 0))
# emit-expr (begin (closure (f195922) (f195916) (let ((f195922 f195922)) ((vector-ref f195916 0) f195922 ()))))
# emit-begin
#   expr=(begin (closure (f195922) (f195916) (let ((f195922 f195922)) ((vector-ref f195916 0) f195922 ()))))
#   env=((f195916 . 0))
# emit-expr (closure (f195922) (f195916) (let ((f195922 f195922)) ((vector-ref f195916 0) f195922 ())))
# emit-closure
# si = -4
# env = ((f195916 . 0))
# expr = (closure (f195922) (f195916) (let ((f195922 f195922)) ((vector-ref f195916 0) f195922 ())))
    movl $_L_1431615, 0(%ebp)  # closure label
# emit-variable-ref
# env=((f195916 . 0))
# var=f195916
    movl 0(%esp), %eax  # stack load f195916
# end emit-variable-ref
   movl  %eax, 4(%ebp)  # f195916
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $8, %ebp     # bump ebp
    jmp _L_1431616            # jump around closure body
_L_1431615:
# check argument count
    cmp $4,%eax
    je _L_1431617
# invoke error handler eh_argcount
    .extern mrc_eh$uargcount
    movl mrc_eh$uargcount, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_1431617:
# emit-tail-expr
# si=-12
# env=((f195922 . -8) (f195916 . 4) (f195916 . 0))
# expr=(let ((f195922 f195922)) ((vector-ref f195916 0) f195922 ()))
# emit-tail-let
#  si   = -12
#  env  = ((f195922 . -8) (f195916 . 4) (f195916 . 0))
#  bindings = ((f195922 f195922))
#  body = ((vector-ref f195916 0) f195922 ())
# emit-expr f195922
# emit-variable-ref
# env=((f195922 . -8) (f195916 . 4) (f195916 . 0))
# var=f195922
    movl -8(%esp), %eax  # stack load f195922
# end emit-variable-ref
    movl %eax, -12(%esp)  # stack save
# emit-tail-expr
# si=-16
# env=((f195922 . -12) (f195922 . -8) (f195916 . 4) (f195916 . 0))
# expr=((vector-ref f195916 0) f195922 ())
# emit-tail-funcall
#    si   =-16
#    env  = ((f195922 . -12) (f195922 . -8) (f195916 . 4) (f195916 . 0))
#    expr = (funcall (vector-ref f195916 0) f195922 ())
# emit-expr (vector-ref f195916 0)
# emit-expr f195916
# emit-variable-ref
# env=((f195922 . -12) (f195922 . -8) (f195916 . 4) (f195916 . 0))
# var=f195916
    movl 2(%edi), %eax  # frame load f195916
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1431618
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1431618:
    movl %eax, -16(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1431619"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1431619:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1431621
    cmp  $0,%eax
    jge _L_1431620
_L_1431621:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1431620:
    movl -16(%esp), %esi
    movl -1(%eax,%esi), %eax
   movl %eax,  -16(%esp)  # stash funcall-oper in next closure slot
# emit-expr f195922
# emit-variable-ref
# env=((f195922 . -12) (f195922 . -8) (f195916 . 4) (f195916 . 0))
# var=f195922
    movl -12(%esp), %eax  # stack load f195922
# end emit-variable-ref
    mov %eax, -20(%esp)    # arg f195922
# emit-expr ()
    movl $63, %eax     # immed ()
    mov %eax, -24(%esp)    # arg ()
    movl -16(%esp), %edi   # load new closure to %edi
# emit-shift-args:  size=3   si=-16  delta=12
    mov -16(%esp), %ebx  # shift frame cell
    mov %ebx, -4(%esp)  # down to base
# emit-shift-args:  size=2   si=-20  delta=12
    mov -20(%esp), %ebx  # shift frame cell
    mov %ebx, -8(%esp)  # down to base
# emit-shift-args:  size=1   si=-24  delta=12
    mov -24(%esp), %ebx  # shift frame cell
    mov %ebx, -12(%esp)  # down to base
# emit-shift-args:  size=0   si=-28  delta=12
    movl $8,%eax   # save arg count
    jmp *-2(%edi)  # tail-funcall
    .align 4,0x90
_L_1431616:
# emit-expr (begin)
# emit-begin
#   expr=(begin)
#   env=((f195916 . 0))
     movl %eax, mrc_reverse
# == explicit-begins  ==>
# (letrec ((fill-vector (lambda (v k args) (if (null? args) v (begin (vector-set! v k (car args)) (fill-vector v (fxadd1 k) (cdr args))))))) (lambda args (let ((v (make-vector (list-length args)))) (fill-vector v 0 args))))
# == eliminate-let*  ==>
# (letrec ((fill-vector (lambda (v k args) (if (null? args) v (begin (vector-set! v k (car args)) (fill-vector v (fxadd1 k) (cdr args))))))) (lambda args (let ((v (make-vector (list-length args)))) (fill-vector v 0 args))))
# == uniquify-variables  ==>
# (letrec ((f195923 (lambda (f195927 f195928 f195929) (if (null? f195929) f195927 (begin (vector-set! f195927 f195928 (car f195929)) (f195923 f195927 (fxadd1 f195928) (cdr f195929))))))) (lambda f195933 (let ((f195935 (make-vector (list-length f195933)))) (f195923 f195935 0 f195933))))
# == vectorize-letrec  ==>
# (let ((f195923 (make-vector 1))) (begin (begin (vector-set! f195923 0 (lambda (f195927 f195928 f195929) (if (null? f195929) f195927 (begin (vector-set! f195927 f195928 (car f195929)) ((vector-ref f195923 0) f195927 (fxadd1 f195928) (cdr f195929))))))) (lambda f195933 (let ((f195935 (make-vector (list-length f195933)))) ((vector-ref f195923 0) f195935 0 f195933)))))
# == eliminate-set!  ==>
# (let ((f195923 (make-vector 1))) (begin (begin (vector-set! f195923 0 (lambda (f195927 f195928 f195929) (let ((f195927 f195927) (f195928 f195928) (f195929 f195929)) (if (null? f195929) f195927 (begin (vector-set! f195927 f195928 (car f195929)) ((vector-ref f195923 0) f195927 (fxadd1 f195928) (cdr f195929)))))))) (lambda f195933 (let () (let ((f195935 (make-vector (list-length f195933)))) ((vector-ref f195923 0) f195935 0 f195933))))))
# == close-free-variables  ==>
# (let ((f195923 (make-vector 1))) (begin (begin (vector-set! f195923 0 (closure (f195927 f195928 f195929) (f195923) (let ((f195927 f195927) (f195928 f195928) (f195929 f195929)) (if (null? f195929) f195927 (begin (vector-set! f195927 f195928 (car f195929)) ((vector-ref f195923 0) f195927 (fxadd1 f195928) (cdr f195929)))))))) (closure f195933 (f195923) (let () (let ((f195935 (make-vector (list-length f195933)))) ((vector-ref f195923 0) f195935 0 f195933))))))
# == eliminate-quote  ==>
# (let ((f195923 (make-vector 1))) (begin (begin (vector-set! f195923 0 (closure (f195927 f195928 f195929) (f195923) (let ((f195927 f195927) (f195928 f195928) (f195929 f195929)) (if (null? f195929) f195927 (begin (vector-set! f195927 f195928 (car f195929)) ((vector-ref f195923 0) f195927 (fxadd1 f195928) (cdr f195929)))))))) (closure f195933 (f195923) (let () (let ((f195935 (make-vector (list-length f195933)))) ((vector-ref f195923 0) f195935 0 f195933))))))
# == eliminate-when/unless  ==>
# (let ((f195923 (make-vector 1))) (begin (begin (vector-set! f195923 0 (closure (f195927 f195928 f195929) (f195923) (let ((f195927 f195927) (f195928 f195928) (f195929 f195929)) (if (null? f195929) f195927 (begin (vector-set! f195927 f195928 (car f195929)) ((vector-ref f195923 0) f195927 (fxadd1 f195928) (cdr f195929)))))))) (closure f195933 (f195923) (let () (let ((f195935 (make-vector (list-length f195933)))) ((vector-ref f195923 0) f195935 0 f195933))))))
# == eliminate-cond  ==>
# (let ((f195923 (make-vector 1))) (begin (begin (vector-set! f195923 0 (closure (f195927 f195928 f195929) (f195923) (let ((f195927 f195927) (f195928 f195928) (f195929 f195929)) (if (null? f195929) f195927 (begin (vector-set! f195927 f195928 (car f195929)) ((vector-ref f195923 0) f195927 (fxadd1 f195928) (cdr f195929)))))))) (closure f195933 (f195923) (let () (let ((f195935 (make-vector (list-length f195933)))) ((vector-ref f195923 0) f195935 0 f195933))))))
# == external-symbols  ==>
# (let ((f195923 (make-vector 1))) (begin (begin (vector-set! f195923 0 (closure (f195927 f195928 f195929) (f195923) (let ((f195927 f195927) (f195928 f195928) (f195929 f195929)) (if (null? f195929) f195927 (begin (vector-set! f195927 f195928 (car f195929)) ((vector-ref f195923 0) f195927 (fxadd1 f195928) (cdr f195929)))))))) (closure f195933 (f195923) (let () (let ((f195935 (make-vector ((primitive-ref list-length) f195933)))) ((vector-ref f195923 0) f195935 0 f195933))))))
# emit-expr (let ((f195923 (make-vector 1))) (begin (begin (vector-set! f195923 0 (closure (f195927 f195928 f195929) (f195923) (let ((f195927 f195927) (f195928 f195928) (f195929 f195929)) (if (null? f195929) f195927 (begin (vector-set! f195927 f195928 (car f195929)) ((vector-ref f195923 0) f195927 (fxadd1 f195928) (cdr f195929)))))))) (closure f195933 (f195923) (let () (let ((f195935 (make-vector ((primitive-ref list-length) f195933)))) ((vector-ref f195923 0) f195935 0 f195933))))))
# emit-let
#  si   = 0
#  env  = ()
#  bindings = ((f195923 (make-vector 1)))
#  body = (begin (begin (vector-set! f195923 0 (closure (f195927 f195928 f195929) (f195923) (let ((f195927 f195927) (f195928 f195928) (f195929 f195929)) (if (null? f195929) f195927 (begin (vector-set! f195927 f195928 (car f195929)) ((vector-ref f195923 0) f195927 (fxadd1 f195928) (cdr f195929)))))))) (closure f195933 (f195923) (let () (let ((f195935 (make-vector ((primitive-ref list-length) f195933)))) ((vector-ref f195923 0) f195935 0 f195933)))))
# emit-expr (make-vector 1)
# make-vector 1
# emit-expr 1
    movl $4, %eax     # immed 1
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1431622"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $128,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1431622:
# check the argument is a fixnum >= 0
    cmp $0,%eax
    jge _L_1431623
# invoke error handler eh_length
    .extern mrc_eh$ulength
    movl mrc_eh$ulength, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $128,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1431623:
    movl %eax, %esi
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    orl  $5, %eax
    addl $4, %esi
    addl $4, %esi
    andl $-8, %esi
    addl %esi, %ebp
    movl %eax, 0(%esp)  # stack save
# emit-expr (begin (begin (vector-set! f195923 0 (closure (f195927 f195928 f195929) (f195923) (let ((f195927 f195927) (f195928 f195928) (f195929 f195929)) (if (null? f195929) f195927 (begin (vector-set! f195927 f195928 (car f195929)) ((vector-ref f195923 0) f195927 (fxadd1 f195928) (cdr f195929)))))))) (closure f195933 (f195923) (let () (let ((f195935 (make-vector ((primitive-ref list-length) f195933)))) ((vector-ref f195923 0) f195935 0 f195933)))))
# emit-begin
#   expr=(begin (begin (vector-set! f195923 0 (closure (f195927 f195928 f195929) (f195923) (let ((f195927 f195927) (f195928 f195928) (f195929 f195929)) (if (null? f195929) f195927 (begin (vector-set! f195927 f195928 (car f195929)) ((vector-ref f195923 0) f195927 (fxadd1 f195928) (cdr f195929)))))))) (closure f195933 (f195923) (let () (let ((f195935 (make-vector ((primitive-ref list-length) f195933)))) ((vector-ref f195923 0) f195935 0 f195933)))))
#   env=((f195923 . 0))
# emit-expr (begin (vector-set! f195923 0 (closure (f195927 f195928 f195929) (f195923) (let ((f195927 f195927) (f195928 f195928) (f195929 f195929)) (if (null? f195929) f195927 (begin (vector-set! f195927 f195928 (car f195929)) ((vector-ref f195923 0) f195927 (fxadd1 f195928) (cdr f195929))))))))
# emit-begin
#   expr=(begin (vector-set! f195923 0 (closure (f195927 f195928 f195929) (f195923) (let ((f195927 f195927) (f195928 f195928) (f195929 f195929)) (if (null? f195929) f195927 (begin (vector-set! f195927 f195928 (car f195929)) ((vector-ref f195923 0) f195927 (fxadd1 f195928) (cdr f195929))))))))
#   env=((f195923 . 0))
# emit-expr (vector-set! f195923 0 (closure (f195927 f195928 f195929) (f195923) (let ((f195927 f195927) (f195928 f195928) (f195929 f195929)) (if (null? f195929) f195927 (begin (vector-set! f195927 f195928 (car f195929)) ((vector-ref f195923 0) f195927 (fxadd1 f195928) (cdr f195929)))))))
# emit-expr f195923
# emit-variable-ref
# env=((f195923 . 0))
# var=f195923
    movl 0(%esp), %eax  # stack load f195923
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1431624
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1431624:
    movl %eax, -4(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1431625"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1431625:
# check bounds on vector index
    movl -4(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1431627
    cmp  $0,%eax
    jge _L_1431626
_L_1431627:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1431626:
    movl %eax, -8(%esp)
# emit-expr (closure (f195927 f195928 f195929) (f195923) (let ((f195927 f195927) (f195928 f195928) (f195929 f195929)) (if (null? f195929) f195927 (begin (vector-set! f195927 f195928 (car f195929)) ((vector-ref f195923 0) f195927 (fxadd1 f195928) (cdr f195929))))))
# emit-closure
# si = -12
# env = ((f195923 . 0))
# expr = (closure (f195927 f195928 f195929) (f195923) (let ((f195927 f195927) (f195928 f195928) (f195929 f195929)) (if (null? f195929) f195927 (begin (vector-set! f195927 f195928 (car f195929)) ((vector-ref f195923 0) f195927 (fxadd1 f195928) (cdr f195929))))))
    movl $_L_1431628, 0(%ebp)  # closure label
# emit-variable-ref
# env=((f195923 . 0))
# var=f195923
    movl 0(%esp), %eax  # stack load f195923
# end emit-variable-ref
   movl  %eax, 4(%ebp)  # f195923
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $8, %ebp     # bump ebp
    jmp _L_1431629            # jump around closure body
_L_1431628:
# check argument count
    cmp $12,%eax
    je _L_1431630
# invoke error handler eh_argcount
    .extern mrc_eh$uargcount
    movl mrc_eh$uargcount, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_1431630:
# emit-tail-expr
# si=-20
# env=((f195929 . -16) (f195928 . -12) (f195927 . -8) (f195923 . 4) (f195923 . 0))
# expr=(let ((f195927 f195927) (f195928 f195928) (f195929 f195929)) (if (null? f195929) f195927 (begin (vector-set! f195927 f195928 (car f195929)) ((vector-ref f195923 0) f195927 (fxadd1 f195928) (cdr f195929)))))
# emit-tail-let
#  si   = -20
#  env  = ((f195929 . -16) (f195928 . -12) (f195927 . -8) (f195923 . 4) (f195923 . 0))
#  bindings = ((f195927 f195927) (f195928 f195928) (f195929 f195929))
#  body = (if (null? f195929) f195927 (begin (vector-set! f195927 f195928 (car f195929)) ((vector-ref f195923 0) f195927 (fxadd1 f195928) (cdr f195929))))
# emit-expr f195927
# emit-variable-ref
# env=((f195929 . -16) (f195928 . -12) (f195927 . -8) (f195923 . 4) (f195923 . 0))
# var=f195927
    movl -8(%esp), %eax  # stack load f195927
# end emit-variable-ref
    movl %eax, -20(%esp)  # stack save
# emit-expr f195928
# emit-variable-ref
# env=((f195929 . -16) (f195928 . -12) (f195927 . -8) (f195923 . 4) (f195923 . 0))
# var=f195928
    movl -12(%esp), %eax  # stack load f195928
# end emit-variable-ref
    movl %eax, -24(%esp)  # stack save
# emit-expr f195929
# emit-variable-ref
# env=((f195929 . -16) (f195928 . -12) (f195927 . -8) (f195923 . 4) (f195923 . 0))
# var=f195929
    movl -16(%esp), %eax  # stack load f195929
# end emit-variable-ref
    movl %eax, -28(%esp)  # stack save
# emit-tail-expr
# si=-32
# env=((f195929 . -28) (f195928 . -24) (f195927 . -20) (f195929 . -16) (f195928 . -12) (f195927 . -8) (f195923 . 4) (f195923 . 0))
# expr=(if (null? f195929) f195927 (begin (vector-set! f195927 f195928 (car f195929)) ((vector-ref f195923 0) f195927 (fxadd1 f195928) (cdr f195929))))
# emit-expr (null? f195929)
# emit-expr f195929
# emit-variable-ref
# env=((f195929 . -28) (f195928 . -24) (f195927 . -20) (f195929 . -16) (f195928 . -12) (f195927 . -8) (f195923 . 4) (f195923 . 0))
# var=f195929
    movl -28(%esp), %eax  # stack load f195929
# end emit-variable-ref
    cmp $63, %eax
    mov $0, %eax
    sete %al
    movzbl %al, %eax
    sal $6, %al
    or $47, %al
    cmp $47, %al
    je _L_1431631
# emit-tail-expr
# si=-32
# env=((f195929 . -28) (f195928 . -24) (f195927 . -20) (f195929 . -16) (f195928 . -12) (f195927 . -8) (f195923 . 4) (f195923 . 0))
# expr=f195927
# emit-tail-variable-ref
# emit-variable-ref
# env=((f195929 . -28) (f195928 . -24) (f195927 . -20) (f195929 . -16) (f195928 . -12) (f195927 . -8) (f195923 . 4) (f195923 . 0))
# var=f195927
    movl -20(%esp), %eax  # stack load f195927
# end emit-variable-ref
    ret
# end emit-tail-variable ref
    jmp _L_1431632
_L_1431631:
# emit-tail-expr
# si=-32
# env=((f195929 . -28) (f195928 . -24) (f195927 . -20) (f195929 . -16) (f195928 . -12) (f195927 . -8) (f195923 . 4) (f195923 . 0))
# expr=(begin (vector-set! f195927 f195928 (car f195929)) ((vector-ref f195923 0) f195927 (fxadd1 f195928) (cdr f195929)))
# tail-begin (begin (vector-set! f195927 f195928 (car f195929)) ((vector-ref f195923 0) f195927 (fxadd1 f195928) (cdr f195929)))
#   env=((f195929 . -28) (f195928 . -24) (f195927 . -20) (f195929 . -16) (f195928 . -12) (f195927 . -8) (f195923 . 4) (f195923 . 0))
# emit-expr (vector-set! f195927 f195928 (car f195929))
# emit-expr f195927
# emit-variable-ref
# env=((f195929 . -28) (f195928 . -24) (f195927 . -20) (f195929 . -16) (f195928 . -12) (f195927 . -8) (f195923 . 4) (f195923 . 0))
# var=f195927
    movl -20(%esp), %eax  # stack load f195927
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1431633
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1431633:
    movl %eax, -32(%esp)
# emit-expr f195928
# emit-variable-ref
# env=((f195929 . -28) (f195928 . -24) (f195927 . -20) (f195929 . -16) (f195928 . -12) (f195927 . -8) (f195923 . 4) (f195923 . 0))
# var=f195928
    movl -24(%esp), %eax  # stack load f195928
# end emit-variable-ref
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1431634"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1431634:
# check bounds on vector index
    movl -32(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1431636
    cmp  $0,%eax
    jge _L_1431635
_L_1431636:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1431635:
    movl %eax, -36(%esp)
# emit-expr (car f195929)
# emit-expr f195929
# emit-variable-ref
# env=((f195929 . -28) (f195928 . -24) (f195927 . -20) (f195929 . -16) (f195928 . -12) (f195927 . -8) (f195923 . 4) (f195923 . 0))
# var=f195929
    movl -28(%esp), %eax  # stack load f195929
# end emit-variable-ref
# check the argument is a pair
    movl %eax,%ebx
    and $7, %bl
    cmp $1, %bl
    je _L_1431637
# invoke error handler eh_pair
    .extern mrc_eh$upair
    movl mrc_eh$upair, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $108,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1431637:
    movl -1(%eax), %eax
    movl -32(%esp), %ebx
    movl -36(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-tail-expr
# si=-32
# env=((f195929 . -28) (f195928 . -24) (f195927 . -20) (f195929 . -16) (f195928 . -12) (f195927 . -8) (f195923 . 4) (f195923 . 0))
# expr=(begin ((vector-ref f195923 0) f195927 (fxadd1 f195928) (cdr f195929)))
# tail-begin (begin ((vector-ref f195923 0) f195927 (fxadd1 f195928) (cdr f195929)))
#   env=((f195929 . -28) (f195928 . -24) (f195927 . -20) (f195929 . -16) (f195928 . -12) (f195927 . -8) (f195923 . 4) (f195923 . 0))
# emit-tail-expr
# si=-32
# env=((f195929 . -28) (f195928 . -24) (f195927 . -20) (f195929 . -16) (f195928 . -12) (f195927 . -8) (f195923 . 4) (f195923 . 0))
# expr=((vector-ref f195923 0) f195927 (fxadd1 f195928) (cdr f195929))
# emit-tail-funcall
#    si   =-32
#    env  = ((f195929 . -28) (f195928 . -24) (f195927 . -20) (f195929 . -16) (f195928 . -12) (f195927 . -8) (f195923 . 4) (f195923 . 0))
#    expr = (funcall (vector-ref f195923 0) f195927 (fxadd1 f195928) (cdr f195929))
# emit-expr (vector-ref f195923 0)
# emit-expr f195923
# emit-variable-ref
# env=((f195929 . -28) (f195928 . -24) (f195927 . -20) (f195929 . -16) (f195928 . -12) (f195927 . -8) (f195923 . 4) (f195923 . 0))
# var=f195923
    movl 2(%edi), %eax  # frame load f195923
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1431638
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1431638:
    movl %eax, -32(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1431639"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1431639:
# check bounds on vector index
    movl -32(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1431641
    cmp  $0,%eax
    jge _L_1431640
_L_1431641:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1431640:
    movl -32(%esp), %esi
    movl -1(%eax,%esi), %eax
   movl %eax,  -32(%esp)  # stash funcall-oper in next closure slot
# emit-expr f195927
# emit-variable-ref
# env=((f195929 . -28) (f195928 . -24) (f195927 . -20) (f195929 . -16) (f195928 . -12) (f195927 . -8) (f195923 . 4) (f195923 . 0))
# var=f195927
    movl -20(%esp), %eax  # stack load f195927
# end emit-variable-ref
    mov %eax, -36(%esp)    # arg f195927
# emit-expr (fxadd1 f195928)
# emit-expr f195928
# emit-variable-ref
# env=((f195929 . -28) (f195928 . -24) (f195927 . -20) (f195929 . -16) (f195928 . -12) (f195927 . -8) (f195923 . 4) (f195923 . 0))
# var=f195928
    movl -24(%esp), %eax  # stack load f195928
# end emit-variable-ref
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1431642"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $48,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1431642:
     addl $4, %eax
    mov %eax, -40(%esp)    # arg (fxadd1 f195928)
# emit-expr (cdr f195929)
# emit-expr f195929
# emit-variable-ref
# env=((f195929 . -28) (f195928 . -24) (f195927 . -20) (f195929 . -16) (f195928 . -12) (f195927 . -8) (f195923 . 4) (f195923 . 0))
# var=f195929
    movl -28(%esp), %eax  # stack load f195929
# end emit-variable-ref
# check the argument is a pair
    movl %eax,%ebx
    and $7, %bl
    cmp $1, %bl
    je _L_1431643
# invoke error handler eh_pair
    .extern mrc_eh$upair
    movl mrc_eh$upair, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $112,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1431643:
    movl 3(%eax), %eax
    mov %eax, -44(%esp)    # arg (cdr f195929)
    movl -32(%esp), %edi   # load new closure to %edi
# emit-shift-args:  size=4   si=-32  delta=28
    mov -32(%esp), %ebx  # shift frame cell
    mov %ebx, -4(%esp)  # down to base
# emit-shift-args:  size=3   si=-36  delta=28
    mov -36(%esp), %ebx  # shift frame cell
    mov %ebx, -8(%esp)  # down to base
# emit-shift-args:  size=2   si=-40  delta=28
    mov -40(%esp), %ebx  # shift frame cell
    mov %ebx, -12(%esp)  # down to base
# emit-shift-args:  size=1   si=-44  delta=28
    mov -44(%esp), %ebx  # shift frame cell
    mov %ebx, -16(%esp)  # down to base
# emit-shift-args:  size=0   si=-48  delta=28
    movl $12,%eax   # save arg count
    jmp *-2(%edi)  # tail-funcall
     ret   # return thru stack
_L_1431632:
    .align 4,0x90
_L_1431629:
    movl -4(%esp), %ebx
    movl -8(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin)
# emit-begin
#   expr=(begin)
#   env=((f195923 . 0))
# emit-expr (begin (closure f195933 (f195923) (let () (let ((f195935 (make-vector ((primitive-ref list-length) f195933)))) ((vector-ref f195923 0) f195935 0 f195933)))))
# emit-begin
#   expr=(begin (closure f195933 (f195923) (let () (let ((f195935 (make-vector ((primitive-ref list-length) f195933)))) ((vector-ref f195923 0) f195935 0 f195933)))))
#   env=((f195923 . 0))
# emit-expr (closure f195933 (f195923) (let () (let ((f195935 (make-vector ((primitive-ref list-length) f195933)))) ((vector-ref f195923 0) f195935 0 f195933))))
# emit-closure
# si = -4
# env = ((f195923 . 0))
# expr = (closure f195933 (f195923) (let () (let ((f195935 (make-vector ((primitive-ref list-length) f195933)))) ((vector-ref f195923 0) f195935 0 f195933))))
    movl $_L_1431644, 0(%ebp)  # closure label
# emit-variable-ref
# env=((f195923 . 0))
# var=f195923
    movl 0(%esp), %eax  # stack load f195923
# end emit-variable-ref
   movl  %eax, 4(%ebp)  # f195923
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $8, %ebp     # bump ebp
    jmp _L_1431645            # jump around closure body
_L_1431644:
# check argument count
    cmp $0,%eax
    jge _L_1431646
# invoke error handler eh_argcount_min
    .extern mrc_eh$uargcount$umin
    movl mrc_eh$uargcount$umin, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_1431646:
# emit-build-varargs-list
    movl $63, %esi       # args <- () 
    lea -4(%esp),%edi    # edi <- esp-4
    subl %eax, %edi      # edi <- esp-4-eax    addr of arg[K+N] on stack
_L_1431648:
    lea -4(%esp),%ebx    # addr of arg[K] on stack
    cmp %edi, %ebx       # while edi <> esp+(si+4)
    je _L_1431647
    movl (%edi),%ebx     # arg i -> car
    movl %ebx, 0(%ebp)
    movl %esi, 4(%ebp)  # esi -> cdr
    movl %ebp, %esi
    addl $1, %esi       # tag as pair
    addl $8,%ebp         # bump heap ptr
    addl $4,%edi         # move to next previous arg from the end
    jmp _L_1431648
_L_1431647:
    movl %esi, -8(%esp)  # set args
# emit-tail-expr
# si=-12
# env=((f195933 . -8) (f195923 . 4) (f195923 . 0))
# expr=(let () (let ((f195935 (make-vector ((primitive-ref list-length) f195933)))) ((vector-ref f195923 0) f195935 0 f195933)))
# emit-tail-let
#  si   = -12
#  env  = ((f195933 . -8) (f195923 . 4) (f195923 . 0))
#  bindings = ()
#  body = (let ((f195935 (make-vector ((primitive-ref list-length) f195933)))) ((vector-ref f195923 0) f195935 0 f195933))
# emit-tail-expr
# si=-12
# env=((f195933 . -8) (f195923 . 4) (f195923 . 0))
# expr=(let ((f195935 (make-vector ((primitive-ref list-length) f195933)))) ((vector-ref f195923 0) f195935 0 f195933))
# emit-tail-let
#  si   = -12
#  env  = ((f195933 . -8) (f195923 . 4) (f195923 . 0))
#  bindings = ((f195935 (make-vector ((primitive-ref list-length) f195933))))
#  body = ((vector-ref f195923 0) f195935 0 f195933)
# emit-expr (make-vector ((primitive-ref list-length) f195933))
# make-vector ((primitive-ref list-length) f195933)
# emit-expr ((primitive-ref list-length) f195933)
# funcall
#    si   =-12
#    env  = ((f195933 . -8) (f195923 . 4) (f195923 . 0))
#    expr = (funcall (primitive-ref list-length) f195933)
# emit-expr (primitive-ref list-length)
    .extern mrc_list$mlength
    movl mrc_list$mlength,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1431649"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1431649":
   movl %eax,  -20(%esp)  # stash funcall-oper in closure slot
# emit-expr f195933
# emit-variable-ref
# env=((f195933 . -8) (f195923 . 4) (f195923 . 0))
# var=f195933
    movl -8(%esp), %eax  # stack load f195933
# end emit-variable-ref
    mov %eax, -24(%esp)  # arg f195933
    movl -20(%esp), %edi   # load new closure to %edi
    add $-12, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $12, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1431650"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $128,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1431650:
# check the argument is a fixnum >= 0
    cmp $0,%eax
    jge _L_1431651
# invoke error handler eh_length
    .extern mrc_eh$ulength
    movl mrc_eh$ulength, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $128,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1431651:
    movl %eax, %esi
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    orl  $5, %eax
    addl $4, %esi
    addl $4, %esi
    andl $-8, %esi
    addl %esi, %ebp
    movl %eax, -12(%esp)  # stack save
# emit-tail-expr
# si=-16
# env=((f195935 . -12) (f195933 . -8) (f195923 . 4) (f195923 . 0))
# expr=((vector-ref f195923 0) f195935 0 f195933)
# emit-tail-funcall
#    si   =-16
#    env  = ((f195935 . -12) (f195933 . -8) (f195923 . 4) (f195923 . 0))
#    expr = (funcall (vector-ref f195923 0) f195935 0 f195933)
# emit-expr (vector-ref f195923 0)
# emit-expr f195923
# emit-variable-ref
# env=((f195935 . -12) (f195933 . -8) (f195923 . 4) (f195923 . 0))
# var=f195923
    movl 2(%edi), %eax  # frame load f195923
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1431652
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1431652:
    movl %eax, -16(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1431653"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1431653:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1431655
    cmp  $0,%eax
    jge _L_1431654
_L_1431655:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1431654:
    movl -16(%esp), %esi
    movl -1(%eax,%esi), %eax
   movl %eax,  -16(%esp)  # stash funcall-oper in next closure slot
# emit-expr f195935
# emit-variable-ref
# env=((f195935 . -12) (f195933 . -8) (f195923 . 4) (f195923 . 0))
# var=f195935
    movl -12(%esp), %eax  # stack load f195935
# end emit-variable-ref
    mov %eax, -20(%esp)    # arg f195935
# emit-expr 0
    movl $0, %eax     # immed 0
    mov %eax, -24(%esp)    # arg 0
# emit-expr f195933
# emit-variable-ref
# env=((f195935 . -12) (f195933 . -8) (f195923 . 4) (f195923 . 0))
# var=f195933
    movl -8(%esp), %eax  # stack load f195933
# end emit-variable-ref
    mov %eax, -28(%esp)    # arg f195933
    movl -16(%esp), %edi   # load new closure to %edi
# emit-shift-args:  size=4   si=-16  delta=12
    mov -16(%esp), %ebx  # shift frame cell
    mov %ebx, -4(%esp)  # down to base
# emit-shift-args:  size=3   si=-20  delta=12
    mov -20(%esp), %ebx  # shift frame cell
    mov %ebx, -8(%esp)  # down to base
# emit-shift-args:  size=2   si=-24  delta=12
    mov -24(%esp), %ebx  # shift frame cell
    mov %ebx, -12(%esp)  # down to base
# emit-shift-args:  size=1   si=-28  delta=12
    mov -28(%esp), %ebx  # shift frame cell
    mov %ebx, -16(%esp)  # down to base
# emit-shift-args:  size=0   si=-32  delta=12
    movl $12,%eax   # save arg count
    jmp *-2(%edi)  # tail-funcall
    .align 4,0x90
_L_1431645:
# emit-expr (begin)
# emit-begin
#   expr=(begin)
#   env=((f195923 . 0))
     movl %eax, mrc_vector
# == explicit-begins  ==>
# (letrec ((fill-string (lambda (s k args) (if (null? args) s (begin (string-set! s k (car args)) (fill-string s (fxadd1 k) (cdr args))))))) (lambda args (let ((s (make-string (list-length args)))) (fill-string s 0 args))))
# == eliminate-let*  ==>
# (letrec ((fill-string (lambda (s k args) (if (null? args) s (begin (string-set! s k (car args)) (fill-string s (fxadd1 k) (cdr args))))))) (lambda args (let ((s (make-string (list-length args)))) (fill-string s 0 args))))
# == uniquify-variables  ==>
# (letrec ((f195936 (lambda (f195940 f195941 f195942) (if (null? f195942) f195940 (begin (string-set! f195940 f195941 (car f195942)) (f195936 f195940 (fxadd1 f195941) (cdr f195942))))))) (lambda f195946 (let ((f195948 (make-string (list-length f195946)))) (f195936 f195948 0 f195946))))
# == vectorize-letrec  ==>
# (let ((f195936 (make-vector 1))) (begin (begin (vector-set! f195936 0 (lambda (f195940 f195941 f195942) (if (null? f195942) f195940 (begin (string-set! f195940 f195941 (car f195942)) ((vector-ref f195936 0) f195940 (fxadd1 f195941) (cdr f195942))))))) (lambda f195946 (let ((f195948 (make-string (list-length f195946)))) ((vector-ref f195936 0) f195948 0 f195946)))))
# == eliminate-set!  ==>
# (let ((f195936 (make-vector 1))) (begin (begin (vector-set! f195936 0 (lambda (f195940 f195941 f195942) (let ((f195940 f195940) (f195941 f195941) (f195942 f195942)) (if (null? f195942) f195940 (begin (string-set! f195940 f195941 (car f195942)) ((vector-ref f195936 0) f195940 (fxadd1 f195941) (cdr f195942)))))))) (lambda f195946 (let () (let ((f195948 (make-string (list-length f195946)))) ((vector-ref f195936 0) f195948 0 f195946))))))
# == close-free-variables  ==>
# (let ((f195936 (make-vector 1))) (begin (begin (vector-set! f195936 0 (closure (f195940 f195941 f195942) (f195936) (let ((f195940 f195940) (f195941 f195941) (f195942 f195942)) (if (null? f195942) f195940 (begin (string-set! f195940 f195941 (car f195942)) ((vector-ref f195936 0) f195940 (fxadd1 f195941) (cdr f195942)))))))) (closure f195946 (f195936) (let () (let ((f195948 (make-string (list-length f195946)))) ((vector-ref f195936 0) f195948 0 f195946))))))
# == eliminate-quote  ==>
# (let ((f195936 (make-vector 1))) (begin (begin (vector-set! f195936 0 (closure (f195940 f195941 f195942) (f195936) (let ((f195940 f195940) (f195941 f195941) (f195942 f195942)) (if (null? f195942) f195940 (begin (string-set! f195940 f195941 (car f195942)) ((vector-ref f195936 0) f195940 (fxadd1 f195941) (cdr f195942)))))))) (closure f195946 (f195936) (let () (let ((f195948 (make-string (list-length f195946)))) ((vector-ref f195936 0) f195948 0 f195946))))))
# == eliminate-when/unless  ==>
# (let ((f195936 (make-vector 1))) (begin (begin (vector-set! f195936 0 (closure (f195940 f195941 f195942) (f195936) (let ((f195940 f195940) (f195941 f195941) (f195942 f195942)) (if (null? f195942) f195940 (begin (string-set! f195940 f195941 (car f195942)) ((vector-ref f195936 0) f195940 (fxadd1 f195941) (cdr f195942)))))))) (closure f195946 (f195936) (let () (let ((f195948 (make-string (list-length f195946)))) ((vector-ref f195936 0) f195948 0 f195946))))))
# == eliminate-cond  ==>
# (let ((f195936 (make-vector 1))) (begin (begin (vector-set! f195936 0 (closure (f195940 f195941 f195942) (f195936) (let ((f195940 f195940) (f195941 f195941) (f195942 f195942)) (if (null? f195942) f195940 (begin (string-set! f195940 f195941 (car f195942)) ((vector-ref f195936 0) f195940 (fxadd1 f195941) (cdr f195942)))))))) (closure f195946 (f195936) (let () (let ((f195948 (make-string (list-length f195946)))) ((vector-ref f195936 0) f195948 0 f195946))))))
# == external-symbols  ==>
# (let ((f195936 (make-vector 1))) (begin (begin (vector-set! f195936 0 (closure (f195940 f195941 f195942) (f195936) (let ((f195940 f195940) (f195941 f195941) (f195942 f195942)) (if (null? f195942) f195940 (begin (string-set! f195940 f195941 (car f195942)) ((vector-ref f195936 0) f195940 (fxadd1 f195941) (cdr f195942)))))))) (closure f195946 (f195936) (let () (let ((f195948 (make-string ((primitive-ref list-length) f195946)))) ((vector-ref f195936 0) f195948 0 f195946))))))
# emit-expr (let ((f195936 (make-vector 1))) (begin (begin (vector-set! f195936 0 (closure (f195940 f195941 f195942) (f195936) (let ((f195940 f195940) (f195941 f195941) (f195942 f195942)) (if (null? f195942) f195940 (begin (string-set! f195940 f195941 (car f195942)) ((vector-ref f195936 0) f195940 (fxadd1 f195941) (cdr f195942)))))))) (closure f195946 (f195936) (let () (let ((f195948 (make-string ((primitive-ref list-length) f195946)))) ((vector-ref f195936 0) f195948 0 f195946))))))
# emit-let
#  si   = 0
#  env  = ()
#  bindings = ((f195936 (make-vector 1)))
#  body = (begin (begin (vector-set! f195936 0 (closure (f195940 f195941 f195942) (f195936) (let ((f195940 f195940) (f195941 f195941) (f195942 f195942)) (if (null? f195942) f195940 (begin (string-set! f195940 f195941 (car f195942)) ((vector-ref f195936 0) f195940 (fxadd1 f195941) (cdr f195942)))))))) (closure f195946 (f195936) (let () (let ((f195948 (make-string ((primitive-ref list-length) f195946)))) ((vector-ref f195936 0) f195948 0 f195946)))))
# emit-expr (make-vector 1)
# make-vector 1
# emit-expr 1
    movl $4, %eax     # immed 1
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1431656"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $128,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1431656:
# check the argument is a fixnum >= 0
    cmp $0,%eax
    jge _L_1431657
# invoke error handler eh_length
    .extern mrc_eh$ulength
    movl mrc_eh$ulength, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $128,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1431657:
    movl %eax, %esi
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    orl  $5, %eax
    addl $4, %esi
    addl $4, %esi
    andl $-8, %esi
    addl %esi, %ebp
    movl %eax, 0(%esp)  # stack save
# emit-expr (begin (begin (vector-set! f195936 0 (closure (f195940 f195941 f195942) (f195936) (let ((f195940 f195940) (f195941 f195941) (f195942 f195942)) (if (null? f195942) f195940 (begin (string-set! f195940 f195941 (car f195942)) ((vector-ref f195936 0) f195940 (fxadd1 f195941) (cdr f195942)))))))) (closure f195946 (f195936) (let () (let ((f195948 (make-string ((primitive-ref list-length) f195946)))) ((vector-ref f195936 0) f195948 0 f195946)))))
# emit-begin
#   expr=(begin (begin (vector-set! f195936 0 (closure (f195940 f195941 f195942) (f195936) (let ((f195940 f195940) (f195941 f195941) (f195942 f195942)) (if (null? f195942) f195940 (begin (string-set! f195940 f195941 (car f195942)) ((vector-ref f195936 0) f195940 (fxadd1 f195941) (cdr f195942)))))))) (closure f195946 (f195936) (let () (let ((f195948 (make-string ((primitive-ref list-length) f195946)))) ((vector-ref f195936 0) f195948 0 f195946)))))
#   env=((f195936 . 0))
# emit-expr (begin (vector-set! f195936 0 (closure (f195940 f195941 f195942) (f195936) (let ((f195940 f195940) (f195941 f195941) (f195942 f195942)) (if (null? f195942) f195940 (begin (string-set! f195940 f195941 (car f195942)) ((vector-ref f195936 0) f195940 (fxadd1 f195941) (cdr f195942))))))))
# emit-begin
#   expr=(begin (vector-set! f195936 0 (closure (f195940 f195941 f195942) (f195936) (let ((f195940 f195940) (f195941 f195941) (f195942 f195942)) (if (null? f195942) f195940 (begin (string-set! f195940 f195941 (car f195942)) ((vector-ref f195936 0) f195940 (fxadd1 f195941) (cdr f195942))))))))
#   env=((f195936 . 0))
# emit-expr (vector-set! f195936 0 (closure (f195940 f195941 f195942) (f195936) (let ((f195940 f195940) (f195941 f195941) (f195942 f195942)) (if (null? f195942) f195940 (begin (string-set! f195940 f195941 (car f195942)) ((vector-ref f195936 0) f195940 (fxadd1 f195941) (cdr f195942)))))))
# emit-expr f195936
# emit-variable-ref
# env=((f195936 . 0))
# var=f195936
    movl 0(%esp), %eax  # stack load f195936
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1431658
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1431658:
    movl %eax, -4(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1431659"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1431659:
# check bounds on vector index
    movl -4(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1431661
    cmp  $0,%eax
    jge _L_1431660
_L_1431661:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1431660:
    movl %eax, -8(%esp)
# emit-expr (closure (f195940 f195941 f195942) (f195936) (let ((f195940 f195940) (f195941 f195941) (f195942 f195942)) (if (null? f195942) f195940 (begin (string-set! f195940 f195941 (car f195942)) ((vector-ref f195936 0) f195940 (fxadd1 f195941) (cdr f195942))))))
# emit-closure
# si = -12
# env = ((f195936 . 0))
# expr = (closure (f195940 f195941 f195942) (f195936) (let ((f195940 f195940) (f195941 f195941) (f195942 f195942)) (if (null? f195942) f195940 (begin (string-set! f195940 f195941 (car f195942)) ((vector-ref f195936 0) f195940 (fxadd1 f195941) (cdr f195942))))))
    movl $_L_1431662, 0(%ebp)  # closure label
# emit-variable-ref
# env=((f195936 . 0))
# var=f195936
    movl 0(%esp), %eax  # stack load f195936
# end emit-variable-ref
   movl  %eax, 4(%ebp)  # f195936
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $8, %ebp     # bump ebp
    jmp _L_1431663            # jump around closure body
_L_1431662:
# check argument count
    cmp $12,%eax
    je _L_1431664
# invoke error handler eh_argcount
    .extern mrc_eh$uargcount
    movl mrc_eh$uargcount, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_1431664:
# emit-tail-expr
# si=-20
# env=((f195942 . -16) (f195941 . -12) (f195940 . -8) (f195936 . 4) (f195936 . 0))
# expr=(let ((f195940 f195940) (f195941 f195941) (f195942 f195942)) (if (null? f195942) f195940 (begin (string-set! f195940 f195941 (car f195942)) ((vector-ref f195936 0) f195940 (fxadd1 f195941) (cdr f195942)))))
# emit-tail-let
#  si   = -20
#  env  = ((f195942 . -16) (f195941 . -12) (f195940 . -8) (f195936 . 4) (f195936 . 0))
#  bindings = ((f195940 f195940) (f195941 f195941) (f195942 f195942))
#  body = (if (null? f195942) f195940 (begin (string-set! f195940 f195941 (car f195942)) ((vector-ref f195936 0) f195940 (fxadd1 f195941) (cdr f195942))))
# emit-expr f195940
# emit-variable-ref
# env=((f195942 . -16) (f195941 . -12) (f195940 . -8) (f195936 . 4) (f195936 . 0))
# var=f195940
    movl -8(%esp), %eax  # stack load f195940
# end emit-variable-ref
    movl %eax, -20(%esp)  # stack save
# emit-expr f195941
# emit-variable-ref
# env=((f195942 . -16) (f195941 . -12) (f195940 . -8) (f195936 . 4) (f195936 . 0))
# var=f195941
    movl -12(%esp), %eax  # stack load f195941
# end emit-variable-ref
    movl %eax, -24(%esp)  # stack save
# emit-expr f195942
# emit-variable-ref
# env=((f195942 . -16) (f195941 . -12) (f195940 . -8) (f195936 . 4) (f195936 . 0))
# var=f195942
    movl -16(%esp), %eax  # stack load f195942
# end emit-variable-ref
    movl %eax, -28(%esp)  # stack save
# emit-tail-expr
# si=-32
# env=((f195942 . -28) (f195941 . -24) (f195940 . -20) (f195942 . -16) (f195941 . -12) (f195940 . -8) (f195936 . 4) (f195936 . 0))
# expr=(if (null? f195942) f195940 (begin (string-set! f195940 f195941 (car f195942)) ((vector-ref f195936 0) f195940 (fxadd1 f195941) (cdr f195942))))
# emit-expr (null? f195942)
# emit-expr f195942
# emit-variable-ref
# env=((f195942 . -28) (f195941 . -24) (f195940 . -20) (f195942 . -16) (f195941 . -12) (f195940 . -8) (f195936 . 4) (f195936 . 0))
# var=f195942
    movl -28(%esp), %eax  # stack load f195942
# end emit-variable-ref
    cmp $63, %eax
    mov $0, %eax
    sete %al
    movzbl %al, %eax
    sal $6, %al
    or $47, %al
    cmp $47, %al
    je _L_1431665
# emit-tail-expr
# si=-32
# env=((f195942 . -28) (f195941 . -24) (f195940 . -20) (f195942 . -16) (f195941 . -12) (f195940 . -8) (f195936 . 4) (f195936 . 0))
# expr=f195940
# emit-tail-variable-ref
# emit-variable-ref
# env=((f195942 . -28) (f195941 . -24) (f195940 . -20) (f195942 . -16) (f195941 . -12) (f195940 . -8) (f195936 . 4) (f195936 . 0))
# var=f195940
    movl -20(%esp), %eax  # stack load f195940
# end emit-variable-ref
    ret
# end emit-tail-variable ref
    jmp _L_1431666
_L_1431665:
# emit-tail-expr
# si=-32
# env=((f195942 . -28) (f195941 . -24) (f195940 . -20) (f195942 . -16) (f195941 . -12) (f195940 . -8) (f195936 . 4) (f195936 . 0))
# expr=(begin (string-set! f195940 f195941 (car f195942)) ((vector-ref f195936 0) f195940 (fxadd1 f195941) (cdr f195942)))
# tail-begin (begin (string-set! f195940 f195941 (car f195942)) ((vector-ref f195936 0) f195940 (fxadd1 f195941) (cdr f195942)))
#   env=((f195942 . -28) (f195941 . -24) (f195940 . -20) (f195942 . -16) (f195941 . -12) (f195940 . -8) (f195936 . 4) (f195936 . 0))
# emit-expr (string-set! f195940 f195941 (car f195942))
# emit-expr f195940
# emit-variable-ref
# env=((f195942 . -28) (f195941 . -24) (f195940 . -20) (f195942 . -16) (f195941 . -12) (f195940 . -8) (f195936 . 4) (f195936 . 0))
# var=f195940
    movl -20(%esp), %eax  # stack load f195940
# end emit-variable-ref
# check the argument is a string
    movl %eax,%ebx
    and $7, %bl
    cmp $6, %bl
    je _L_1431667
# invoke error handler eh_string
    .extern mrc_eh$ustring
    movl mrc_eh$ustring, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $160,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1431667:
    movl %eax, -32(%esp)
# emit-expr f195941
# emit-variable-ref
# env=((f195942 . -28) (f195941 . -24) (f195940 . -20) (f195942 . -16) (f195941 . -12) (f195940 . -8) (f195936 . 4) (f195936 . 0))
# var=f195941
    movl -24(%esp), %eax  # stack load f195941
# end emit-variable-ref
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1431668"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $160,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1431668:
# check bounds on string index
    movl -32(%esp), %ebx
    cmp  %eax,-6(%ebx) 
    jle _L_1431670
    cmp  $0,%eax
    jge _L_1431669
_L_1431670:
# invoke error handler eh_string_index
    .extern mrc_eh$ustring$uindex
    movl mrc_eh$ustring$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $160,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1431669:
    movl %eax, -36(%esp)
# emit-expr (car f195942)
# emit-expr f195942
# emit-variable-ref
# env=((f195942 . -28) (f195941 . -24) (f195940 . -20) (f195942 . -16) (f195941 . -12) (f195940 . -8) (f195936 . 4) (f195936 . 0))
# var=f195942
    movl -28(%esp), %eax  # stack load f195942
# end emit-variable-ref
# check the argument is a pair
    movl %eax,%ebx
    and $7, %bl
    cmp $1, %bl
    je _L_1431671
# invoke error handler eh_pair
    .extern mrc_eh$upair
    movl mrc_eh$upair, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $108,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1431671:
    movl -1(%eax), %eax
# check the argument is a char
    movl %eax,%ebx
    and $255, %bl
    cmp $15, %bl
    je "_L_1431672"
# invoke error handler eh_character
    .extern mrc_eh$ucharacter
    movl mrc_eh$ucharacter, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $160,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1431672:
    movl -32(%esp), %ebx
    movl -36(%esp), %esi
    sar $2, %esi
    movb  %ah, -2(%ebx,%esi)
# emit-tail-expr
# si=-32
# env=((f195942 . -28) (f195941 . -24) (f195940 . -20) (f195942 . -16) (f195941 . -12) (f195940 . -8) (f195936 . 4) (f195936 . 0))
# expr=(begin ((vector-ref f195936 0) f195940 (fxadd1 f195941) (cdr f195942)))
# tail-begin (begin ((vector-ref f195936 0) f195940 (fxadd1 f195941) (cdr f195942)))
#   env=((f195942 . -28) (f195941 . -24) (f195940 . -20) (f195942 . -16) (f195941 . -12) (f195940 . -8) (f195936 . 4) (f195936 . 0))
# emit-tail-expr
# si=-32
# env=((f195942 . -28) (f195941 . -24) (f195940 . -20) (f195942 . -16) (f195941 . -12) (f195940 . -8) (f195936 . 4) (f195936 . 0))
# expr=((vector-ref f195936 0) f195940 (fxadd1 f195941) (cdr f195942))
# emit-tail-funcall
#    si   =-32
#    env  = ((f195942 . -28) (f195941 . -24) (f195940 . -20) (f195942 . -16) (f195941 . -12) (f195940 . -8) (f195936 . 4) (f195936 . 0))
#    expr = (funcall (vector-ref f195936 0) f195940 (fxadd1 f195941) (cdr f195942))
# emit-expr (vector-ref f195936 0)
# emit-expr f195936
# emit-variable-ref
# env=((f195942 . -28) (f195941 . -24) (f195940 . -20) (f195942 . -16) (f195941 . -12) (f195940 . -8) (f195936 . 4) (f195936 . 0))
# var=f195936
    movl 2(%edi), %eax  # frame load f195936
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1431673
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1431673:
    movl %eax, -32(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1431674"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1431674:
# check bounds on vector index
    movl -32(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1431676
    cmp  $0,%eax
    jge _L_1431675
_L_1431676:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1431675:
    movl -32(%esp), %esi
    movl -1(%eax,%esi), %eax
   movl %eax,  -32(%esp)  # stash funcall-oper in next closure slot
# emit-expr f195940
# emit-variable-ref
# env=((f195942 . -28) (f195941 . -24) (f195940 . -20) (f195942 . -16) (f195941 . -12) (f195940 . -8) (f195936 . 4) (f195936 . 0))
# var=f195940
    movl -20(%esp), %eax  # stack load f195940
# end emit-variable-ref
    mov %eax, -36(%esp)    # arg f195940
# emit-expr (fxadd1 f195941)
# emit-expr f195941
# emit-variable-ref
# env=((f195942 . -28) (f195941 . -24) (f195940 . -20) (f195942 . -16) (f195941 . -12) (f195940 . -8) (f195936 . 4) (f195936 . 0))
# var=f195941
    movl -24(%esp), %eax  # stack load f195941
# end emit-variable-ref
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1431677"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $48,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1431677:
     addl $4, %eax
    mov %eax, -40(%esp)    # arg (fxadd1 f195941)
# emit-expr (cdr f195942)
# emit-expr f195942
# emit-variable-ref
# env=((f195942 . -28) (f195941 . -24) (f195940 . -20) (f195942 . -16) (f195941 . -12) (f195940 . -8) (f195936 . 4) (f195936 . 0))
# var=f195942
    movl -28(%esp), %eax  # stack load f195942
# end emit-variable-ref
# check the argument is a pair
    movl %eax,%ebx
    and $7, %bl
    cmp $1, %bl
    je _L_1431678
# invoke error handler eh_pair
    .extern mrc_eh$upair
    movl mrc_eh$upair, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $112,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1431678:
    movl 3(%eax), %eax
    mov %eax, -44(%esp)    # arg (cdr f195942)
    movl -32(%esp), %edi   # load new closure to %edi
# emit-shift-args:  size=4   si=-32  delta=28
    mov -32(%esp), %ebx  # shift frame cell
    mov %ebx, -4(%esp)  # down to base
# emit-shift-args:  size=3   si=-36  delta=28
    mov -36(%esp), %ebx  # shift frame cell
    mov %ebx, -8(%esp)  # down to base
# emit-shift-args:  size=2   si=-40  delta=28
    mov -40(%esp), %ebx  # shift frame cell
    mov %ebx, -12(%esp)  # down to base
# emit-shift-args:  size=1   si=-44  delta=28
    mov -44(%esp), %ebx  # shift frame cell
    mov %ebx, -16(%esp)  # down to base
# emit-shift-args:  size=0   si=-48  delta=28
    movl $12,%eax   # save arg count
    jmp *-2(%edi)  # tail-funcall
     ret   # return thru stack
_L_1431666:
    .align 4,0x90
_L_1431663:
    movl -4(%esp), %ebx
    movl -8(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin)
# emit-begin
#   expr=(begin)
#   env=((f195936 . 0))
# emit-expr (begin (closure f195946 (f195936) (let () (let ((f195948 (make-string ((primitive-ref list-length) f195946)))) ((vector-ref f195936 0) f195948 0 f195946)))))
# emit-begin
#   expr=(begin (closure f195946 (f195936) (let () (let ((f195948 (make-string ((primitive-ref list-length) f195946)))) ((vector-ref f195936 0) f195948 0 f195946)))))
#   env=((f195936 . 0))
# emit-expr (closure f195946 (f195936) (let () (let ((f195948 (make-string ((primitive-ref list-length) f195946)))) ((vector-ref f195936 0) f195948 0 f195946))))
# emit-closure
# si = -4
# env = ((f195936 . 0))
# expr = (closure f195946 (f195936) (let () (let ((f195948 (make-string ((primitive-ref list-length) f195946)))) ((vector-ref f195936 0) f195948 0 f195946))))
    movl $_L_1431679, 0(%ebp)  # closure label
# emit-variable-ref
# env=((f195936 . 0))
# var=f195936
    movl 0(%esp), %eax  # stack load f195936
# end emit-variable-ref
   movl  %eax, 4(%ebp)  # f195936
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $8, %ebp     # bump ebp
    jmp _L_1431680            # jump around closure body
_L_1431679:
# check argument count
    cmp $0,%eax
    jge _L_1431681
# invoke error handler eh_argcount_min
    .extern mrc_eh$uargcount$umin
    movl mrc_eh$uargcount$umin, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_1431681:
# emit-build-varargs-list
    movl $63, %esi       # args <- () 
    lea -4(%esp),%edi    # edi <- esp-4
    subl %eax, %edi      # edi <- esp-4-eax    addr of arg[K+N] on stack
_L_1431683:
    lea -4(%esp),%ebx    # addr of arg[K] on stack
    cmp %edi, %ebx       # while edi <> esp+(si+4)
    je _L_1431682
    movl (%edi),%ebx     # arg i -> car
    movl %ebx, 0(%ebp)
    movl %esi, 4(%ebp)  # esi -> cdr
    movl %ebp, %esi
    addl $1, %esi       # tag as pair
    addl $8,%ebp         # bump heap ptr
    addl $4,%edi         # move to next previous arg from the end
    jmp _L_1431683
_L_1431682:
    movl %esi, -8(%esp)  # set args
# emit-tail-expr
# si=-12
# env=((f195946 . -8) (f195936 . 4) (f195936 . 0))
# expr=(let () (let ((f195948 (make-string ((primitive-ref list-length) f195946)))) ((vector-ref f195936 0) f195948 0 f195946)))
# emit-tail-let
#  si   = -12
#  env  = ((f195946 . -8) (f195936 . 4) (f195936 . 0))
#  bindings = ()
#  body = (let ((f195948 (make-string ((primitive-ref list-length) f195946)))) ((vector-ref f195936 0) f195948 0 f195946))
# emit-tail-expr
# si=-12
# env=((f195946 . -8) (f195936 . 4) (f195936 . 0))
# expr=(let ((f195948 (make-string ((primitive-ref list-length) f195946)))) ((vector-ref f195936 0) f195948 0 f195946))
# emit-tail-let
#  si   = -12
#  env  = ((f195946 . -8) (f195936 . 4) (f195936 . 0))
#  bindings = ((f195948 (make-string ((primitive-ref list-length) f195946))))
#  body = ((vector-ref f195936 0) f195948 0 f195946)
# emit-expr (make-string ((primitive-ref list-length) f195946))
# make-string len=((primitive-ref list-length) f195946)
# emit-expr ((primitive-ref list-length) f195946)
# funcall
#    si   =-12
#    env  = ((f195946 . -8) (f195936 . 4) (f195936 . 0))
#    expr = (funcall (primitive-ref list-length) f195946)
# emit-expr (primitive-ref list-length)
    .extern mrc_list$mlength
    movl mrc_list$mlength,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1431684"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1431684":
   movl %eax,  -20(%esp)  # stash funcall-oper in closure slot
# emit-expr f195946
# emit-variable-ref
# env=((f195946 . -8) (f195936 . 4) (f195936 . 0))
# var=f195946
    movl -8(%esp), %eax  # stack load f195946
# end emit-variable-ref
    mov %eax, -24(%esp)  # arg f195946
    movl -20(%esp), %edi   # load new closure to %edi
    add $-12, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $12, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1431685"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1431685:
# check the argument is a fixnum >= 0
    cmp $0,%eax
    jge _L_1431686
# invoke error handler eh_length
    .extern mrc_eh$ulength
    movl mrc_eh$ulength, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1431686:
    movl %eax, %esi
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    orl $6, %eax
    sar $2, %esi
    add $4, %esi
    add $7, %esi
    andl $-8, %esi
    add  %esi, %ebp
# make-string end
    movl %eax, -12(%esp)  # stack save
# emit-tail-expr
# si=-16
# env=((f195948 . -12) (f195946 . -8) (f195936 . 4) (f195936 . 0))
# expr=((vector-ref f195936 0) f195948 0 f195946)
# emit-tail-funcall
#    si   =-16
#    env  = ((f195948 . -12) (f195946 . -8) (f195936 . 4) (f195936 . 0))
#    expr = (funcall (vector-ref f195936 0) f195948 0 f195946)
# emit-expr (vector-ref f195936 0)
# emit-expr f195936
# emit-variable-ref
# env=((f195948 . -12) (f195946 . -8) (f195936 . 4) (f195936 . 0))
# var=f195936
    movl 2(%edi), %eax  # frame load f195936
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1431687
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1431687:
    movl %eax, -16(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1431688"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1431688:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1431690
    cmp  $0,%eax
    jge _L_1431689
_L_1431690:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1431689:
    movl -16(%esp), %esi
    movl -1(%eax,%esi), %eax
   movl %eax,  -16(%esp)  # stash funcall-oper in next closure slot
# emit-expr f195948
# emit-variable-ref
# env=((f195948 . -12) (f195946 . -8) (f195936 . 4) (f195936 . 0))
# var=f195948
    movl -12(%esp), %eax  # stack load f195948
# end emit-variable-ref
    mov %eax, -20(%esp)    # arg f195948
# emit-expr 0
    movl $0, %eax     # immed 0
    mov %eax, -24(%esp)    # arg 0
# emit-expr f195946
# emit-variable-ref
# env=((f195948 . -12) (f195946 . -8) (f195936 . 4) (f195936 . 0))
# var=f195946
    movl -8(%esp), %eax  # stack load f195946
# end emit-variable-ref
    mov %eax, -28(%esp)    # arg f195946
    movl -16(%esp), %edi   # load new closure to %edi
# emit-shift-args:  size=4   si=-16  delta=12
    mov -16(%esp), %ebx  # shift frame cell
    mov %ebx, -4(%esp)  # down to base
# emit-shift-args:  size=3   si=-20  delta=12
    mov -20(%esp), %ebx  # shift frame cell
    mov %ebx, -8(%esp)  # down to base
# emit-shift-args:  size=2   si=-24  delta=12
    mov -24(%esp), %ebx  # shift frame cell
    mov %ebx, -12(%esp)  # down to base
# emit-shift-args:  size=1   si=-28  delta=12
    mov -28(%esp), %ebx  # shift frame cell
    mov %ebx, -16(%esp)  # down to base
# emit-shift-args:  size=0   si=-32  delta=12
    movl $12,%eax   # save arg count
    jmp *-2(%edi)  # tail-funcall
    .align 4,0x90
_L_1431680:
# emit-expr (begin)
# emit-begin
#   expr=(begin)
#   env=((f195936 . 0))
     movl %eax, mrc_string
# == explicit-begins  ==>
# (letrec ((f (lambda (s i) (if (fx= i (string-length s)) (quote ()) (cons (string-ref s i) (f s (fxadd1 i))))))) (lambda (s) (f s 0)))
# == eliminate-let*  ==>
# (letrec ((f (lambda (s i) (if (fx= i (string-length s)) (quote ()) (cons (string-ref s i) (f s (fxadd1 i))))))) (lambda (s) (f s 0)))
# == uniquify-variables  ==>
# (letrec ((f195949 (lambda (f195952 f195953) (if (fx= f195953 (string-length f195952)) (quote ()) (cons (string-ref f195952 f195953) (f195949 f195952 (fxadd1 f195953))))))) (lambda (f195955) (f195949 f195955 0)))
# == vectorize-letrec  ==>
# (let ((f195949 (make-vector 1))) (begin (begin (vector-set! f195949 0 (lambda (f195952 f195953) (if (fx= f195953 (string-length f195952)) (quote ()) (cons (string-ref f195952 f195953) ((vector-ref f195949 0) f195952 (fxadd1 f195953))))))) (lambda (f195955) ((vector-ref f195949 0) f195955 0))))
# == eliminate-set!  ==>
# (let ((f195949 (make-vector 1))) (begin (begin (vector-set! f195949 0 (lambda (f195952 f195953) (let ((f195952 f195952) (f195953 f195953)) (if (fx= f195953 (string-length f195952)) (quote ()) (cons (string-ref f195952 f195953) ((vector-ref f195949 0) f195952 (fxadd1 f195953)))))))) (lambda (f195955) (let ((f195955 f195955)) ((vector-ref f195949 0) f195955 0)))))
# == close-free-variables  ==>
# (let ((f195949 (make-vector 1))) (begin (begin (vector-set! f195949 0 (closure (f195952 f195953) (f195949) (let ((f195952 f195952) (f195953 f195953)) (if (fx= f195953 (string-length f195952)) (quote ()) (cons (string-ref f195952 f195953) ((vector-ref f195949 0) f195952 (fxadd1 f195953)))))))) (closure (f195955) (f195949) (let ((f195955 f195955)) ((vector-ref f195949 0) f195955 0)))))
# == eliminate-quote  ==>
# (let ((f195949 (make-vector 1))) (begin (begin (vector-set! f195949 0 (closure (f195952 f195953) (f195949) (let ((f195952 f195952) (f195953 f195953)) (if (fx= f195953 (string-length f195952)) () (cons (string-ref f195952 f195953) ((vector-ref f195949 0) f195952 (fxadd1 f195953)))))))) (closure (f195955) (f195949) (let ((f195955 f195955)) ((vector-ref f195949 0) f195955 0)))))
# == eliminate-when/unless  ==>
# (let ((f195949 (make-vector 1))) (begin (begin (vector-set! f195949 0 (closure (f195952 f195953) (f195949) (let ((f195952 f195952) (f195953 f195953)) (if (fx= f195953 (string-length f195952)) () (cons (string-ref f195952 f195953) ((vector-ref f195949 0) f195952 (fxadd1 f195953)))))))) (closure (f195955) (f195949) (let ((f195955 f195955)) ((vector-ref f195949 0) f195955 0)))))
# == eliminate-cond  ==>
# (let ((f195949 (make-vector 1))) (begin (begin (vector-set! f195949 0 (closure (f195952 f195953) (f195949) (let ((f195952 f195952) (f195953 f195953)) (if (fx= f195953 (string-length f195952)) () (cons (string-ref f195952 f195953) ((vector-ref f195949 0) f195952 (fxadd1 f195953)))))))) (closure (f195955) (f195949) (let ((f195955 f195955)) ((vector-ref f195949 0) f195955 0)))))
# == external-symbols  ==>
# (let ((f195949 (make-vector 1))) (begin (begin (vector-set! f195949 0 (closure (f195952 f195953) (f195949) (let ((f195952 f195952) (f195953 f195953)) (if (fx= f195953 (string-length f195952)) () (cons (string-ref f195952 f195953) ((vector-ref f195949 0) f195952 (fxadd1 f195953)))))))) (closure (f195955) (f195949) (let ((f195955 f195955)) ((vector-ref f195949 0) f195955 0)))))
# emit-expr (let ((f195949 (make-vector 1))) (begin (begin (vector-set! f195949 0 (closure (f195952 f195953) (f195949) (let ((f195952 f195952) (f195953 f195953)) (if (fx= f195953 (string-length f195952)) () (cons (string-ref f195952 f195953) ((vector-ref f195949 0) f195952 (fxadd1 f195953)))))))) (closure (f195955) (f195949) (let ((f195955 f195955)) ((vector-ref f195949 0) f195955 0)))))
# emit-let
#  si   = 0
#  env  = ()
#  bindings = ((f195949 (make-vector 1)))
#  body = (begin (begin (vector-set! f195949 0 (closure (f195952 f195953) (f195949) (let ((f195952 f195952) (f195953 f195953)) (if (fx= f195953 (string-length f195952)) () (cons (string-ref f195952 f195953) ((vector-ref f195949 0) f195952 (fxadd1 f195953)))))))) (closure (f195955) (f195949) (let ((f195955 f195955)) ((vector-ref f195949 0) f195955 0))))
# emit-expr (make-vector 1)
# make-vector 1
# emit-expr 1
    movl $4, %eax     # immed 1
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1431691"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $128,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1431691:
# check the argument is a fixnum >= 0
    cmp $0,%eax
    jge _L_1431692
# invoke error handler eh_length
    .extern mrc_eh$ulength
    movl mrc_eh$ulength, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $128,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1431692:
    movl %eax, %esi
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    orl  $5, %eax
    addl $4, %esi
    addl $4, %esi
    andl $-8, %esi
    addl %esi, %ebp
    movl %eax, 0(%esp)  # stack save
# emit-expr (begin (begin (vector-set! f195949 0 (closure (f195952 f195953) (f195949) (let ((f195952 f195952) (f195953 f195953)) (if (fx= f195953 (string-length f195952)) () (cons (string-ref f195952 f195953) ((vector-ref f195949 0) f195952 (fxadd1 f195953)))))))) (closure (f195955) (f195949) (let ((f195955 f195955)) ((vector-ref f195949 0) f195955 0))))
# emit-begin
#   expr=(begin (begin (vector-set! f195949 0 (closure (f195952 f195953) (f195949) (let ((f195952 f195952) (f195953 f195953)) (if (fx= f195953 (string-length f195952)) () (cons (string-ref f195952 f195953) ((vector-ref f195949 0) f195952 (fxadd1 f195953)))))))) (closure (f195955) (f195949) (let ((f195955 f195955)) ((vector-ref f195949 0) f195955 0))))
#   env=((f195949 . 0))
# emit-expr (begin (vector-set! f195949 0 (closure (f195952 f195953) (f195949) (let ((f195952 f195952) (f195953 f195953)) (if (fx= f195953 (string-length f195952)) () (cons (string-ref f195952 f195953) ((vector-ref f195949 0) f195952 (fxadd1 f195953))))))))
# emit-begin
#   expr=(begin (vector-set! f195949 0 (closure (f195952 f195953) (f195949) (let ((f195952 f195952) (f195953 f195953)) (if (fx= f195953 (string-length f195952)) () (cons (string-ref f195952 f195953) ((vector-ref f195949 0) f195952 (fxadd1 f195953))))))))
#   env=((f195949 . 0))
# emit-expr (vector-set! f195949 0 (closure (f195952 f195953) (f195949) (let ((f195952 f195952) (f195953 f195953)) (if (fx= f195953 (string-length f195952)) () (cons (string-ref f195952 f195953) ((vector-ref f195949 0) f195952 (fxadd1 f195953)))))))
# emit-expr f195949
# emit-variable-ref
# env=((f195949 . 0))
# var=f195949
    movl 0(%esp), %eax  # stack load f195949
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1431693
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1431693:
    movl %eax, -4(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1431694"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1431694:
# check bounds on vector index
    movl -4(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1431696
    cmp  $0,%eax
    jge _L_1431695
_L_1431696:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1431695:
    movl %eax, -8(%esp)
# emit-expr (closure (f195952 f195953) (f195949) (let ((f195952 f195952) (f195953 f195953)) (if (fx= f195953 (string-length f195952)) () (cons (string-ref f195952 f195953) ((vector-ref f195949 0) f195952 (fxadd1 f195953))))))
# emit-closure
# si = -12
# env = ((f195949 . 0))
# expr = (closure (f195952 f195953) (f195949) (let ((f195952 f195952) (f195953 f195953)) (if (fx= f195953 (string-length f195952)) () (cons (string-ref f195952 f195953) ((vector-ref f195949 0) f195952 (fxadd1 f195953))))))
    movl $_L_1431697, 0(%ebp)  # closure label
# emit-variable-ref
# env=((f195949 . 0))
# var=f195949
    movl 0(%esp), %eax  # stack load f195949
# end emit-variable-ref
   movl  %eax, 4(%ebp)  # f195949
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $8, %ebp     # bump ebp
    jmp _L_1431698            # jump around closure body
_L_1431697:
# check argument count
    cmp $8,%eax
    je _L_1431699
# invoke error handler eh_argcount
    .extern mrc_eh$uargcount
    movl mrc_eh$uargcount, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_1431699:
# emit-tail-expr
# si=-16
# env=((f195953 . -12) (f195952 . -8) (f195949 . 4) (f195949 . 0))
# expr=(let ((f195952 f195952) (f195953 f195953)) (if (fx= f195953 (string-length f195952)) () (cons (string-ref f195952 f195953) ((vector-ref f195949 0) f195952 (fxadd1 f195953)))))
# emit-tail-let
#  si   = -16
#  env  = ((f195953 . -12) (f195952 . -8) (f195949 . 4) (f195949 . 0))
#  bindings = ((f195952 f195952) (f195953 f195953))
#  body = (if (fx= f195953 (string-length f195952)) () (cons (string-ref f195952 f195953) ((vector-ref f195949 0) f195952 (fxadd1 f195953))))
# emit-expr f195952
# emit-variable-ref
# env=((f195953 . -12) (f195952 . -8) (f195949 . 4) (f195949 . 0))
# var=f195952
    movl -8(%esp), %eax  # stack load f195952
# end emit-variable-ref
    movl %eax, -16(%esp)  # stack save
# emit-expr f195953
# emit-variable-ref
# env=((f195953 . -12) (f195952 . -8) (f195949 . 4) (f195949 . 0))
# var=f195953
    movl -12(%esp), %eax  # stack load f195953
# end emit-variable-ref
    movl %eax, -20(%esp)  # stack save
# emit-tail-expr
# si=-24
# env=((f195953 . -20) (f195952 . -16) (f195953 . -12) (f195952 . -8) (f195949 . 4) (f195949 . 0))
# expr=(if (fx= f195953 (string-length f195952)) () (cons (string-ref f195952 f195953) ((vector-ref f195949 0) f195952 (fxadd1 f195953))))
# emit-expr (fx= f195953 (string-length f195952))
# emit-expr (string-length f195952)
# emit-expr f195952
# emit-variable-ref
# env=((f195953 . -20) (f195952 . -16) (f195953 . -12) (f195952 . -8) (f195949 . 4) (f195949 . 0))
# var=f195952
    movl -16(%esp), %eax  # stack load f195952
# end emit-variable-ref
# check the argument is a string
    movl %eax,%ebx
    and $7, %bl
    cmp $6, %bl
    je _L_1431702
# invoke error handler eh_string
    .extern mrc_eh$ustring
    movl mrc_eh$ustring, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $152,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1431702:
    movl -6(%eax), %eax
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1431703"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $60,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1431703:
    movl %eax, -24(%esp)
# emit-expr f195953
# emit-variable-ref
# env=((f195953 . -20) (f195952 . -16) (f195953 . -12) (f195952 . -8) (f195949 . 4) (f195949 . 0))
# var=f195953
    movl -20(%esp), %eax  # stack load f195953
# end emit-variable-ref
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1431704"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $60,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1431704:
    cmp -24(%esp), %eax
    sete %al
    movzbl %al, %eax
    sal $6, %al
    or $47, %al
    cmp $47, %al
    je _L_1431700
# emit-tail-expr
# si=-24
# env=((f195953 . -20) (f195952 . -16) (f195953 . -12) (f195952 . -8) (f195949 . 4) (f195949 . 0))
# expr=()
    movl $63, %eax     # immed ()
    ret                  # immediate tail return
    jmp _L_1431701
_L_1431700:
# emit-tail-expr
# si=-24
# env=((f195953 . -20) (f195952 . -16) (f195953 . -12) (f195952 . -8) (f195949 . 4) (f195949 . 0))
# expr=(cons (string-ref f195952 f195953) ((vector-ref f195949 0) f195952 (fxadd1 f195953)))
# tail primcall
# cons arg1=(string-ref f195952 f195953) arg2=((vector-ref f195949 0) f195952 (fxadd1 f195953))
# emit-expr (string-ref f195952 f195953)
# emit-expr f195952
# emit-variable-ref
# env=((f195953 . -20) (f195952 . -16) (f195953 . -12) (f195952 . -8) (f195949 . 4) (f195949 . 0))
# var=f195952
    movl -16(%esp), %eax  # stack load f195952
# end emit-variable-ref
# check the argument is a string
    movl %eax,%ebx
    and $7, %bl
    cmp $6, %bl
    je _L_1431705
# invoke error handler eh_string
    .extern mrc_eh$ustring
    movl mrc_eh$ustring, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $156,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1431705:
    movl %eax, -24(%esp)
# emit-expr f195953
# emit-variable-ref
# env=((f195953 . -20) (f195952 . -16) (f195953 . -12) (f195952 . -8) (f195949 . 4) (f195949 . 0))
# var=f195953
    movl -20(%esp), %eax  # stack load f195953
# end emit-variable-ref
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1431706"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $156,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1431706:
# check bounds on string index
    movl -24(%esp), %ebx
    cmp  %eax,-6(%ebx) 
    jle _L_1431708
    cmp  $0,%eax
    jge _L_1431707
_L_1431708:
# invoke error handler eh_string_index
    .extern mrc_eh$ustring$uindex
    movl mrc_eh$ustring$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $156,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1431707:
    sar $2, %eax
    movl -24(%esp), %esi
    movl -2(%eax,%esi), %eax
    sal $8, %eax
    or  $15, %eax
    movl %eax, -24(%esp)
# emit-expr ((vector-ref f195949 0) f195952 (fxadd1 f195953))
# funcall
#    si   =-28
#    env  = ((f195953 . -20) (f195952 . -16) (f195953 . -12) (f195952 . -8) (f195949 . 4) (f195949 . 0))
#    expr = (funcall (vector-ref f195949 0) f195952 (fxadd1 f195953))
# emit-expr (vector-ref f195949 0)
# emit-expr f195949
# emit-variable-ref
# env=((f195953 . -20) (f195952 . -16) (f195953 . -12) (f195952 . -8) (f195949 . 4) (f195949 . 0))
# var=f195949
    movl 2(%edi), %eax  # frame load f195949
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1431709
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1431709:
    movl %eax, -36(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1431710"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1431710:
# check bounds on vector index
    movl -36(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1431712
    cmp  $0,%eax
    jge _L_1431711
_L_1431712:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1431711:
    movl -36(%esp), %esi
    movl -1(%eax,%esi), %eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1431713"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1431713":
   movl %eax,  -36(%esp)  # stash funcall-oper in closure slot
# emit-expr f195952
# emit-variable-ref
# env=((f195953 . -20) (f195952 . -16) (f195953 . -12) (f195952 . -8) (f195949 . 4) (f195949 . 0))
# var=f195952
    movl -16(%esp), %eax  # stack load f195952
# end emit-variable-ref
    mov %eax, -40(%esp)  # arg f195952
# emit-expr (fxadd1 f195953)
# emit-expr f195953
# emit-variable-ref
# env=((f195953 . -20) (f195952 . -16) (f195953 . -12) (f195952 . -8) (f195949 . 4) (f195949 . 0))
# var=f195953
    movl -20(%esp), %eax  # stack load f195953
# end emit-variable-ref
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1431714"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $48,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1431714:
     addl $4, %eax
    mov %eax, -44(%esp)  # arg (fxadd1 f195953)
    movl -36(%esp), %edi   # load new closure to %edi
    add $-28, %esp   # adjust base
    movl $8,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $28, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    movl %eax, 4(%ebp)
    movl -24(%esp), %eax
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    or   $1, %al
    add  $8, %ebp
# cons end
#return from tail (cons (string-ref f195952 f195953) ((vector-ref f195949 0) f195952 (fxadd1 f195953)))
    ret
_L_1431701:
    .align 4,0x90
_L_1431698:
    movl -4(%esp), %ebx
    movl -8(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin)
# emit-begin
#   expr=(begin)
#   env=((f195949 . 0))
# emit-expr (begin (closure (f195955) (f195949) (let ((f195955 f195955)) ((vector-ref f195949 0) f195955 0))))
# emit-begin
#   expr=(begin (closure (f195955) (f195949) (let ((f195955 f195955)) ((vector-ref f195949 0) f195955 0))))
#   env=((f195949 . 0))
# emit-expr (closure (f195955) (f195949) (let ((f195955 f195955)) ((vector-ref f195949 0) f195955 0)))
# emit-closure
# si = -4
# env = ((f195949 . 0))
# expr = (closure (f195955) (f195949) (let ((f195955 f195955)) ((vector-ref f195949 0) f195955 0)))
    movl $_L_1431715, 0(%ebp)  # closure label
# emit-variable-ref
# env=((f195949 . 0))
# var=f195949
    movl 0(%esp), %eax  # stack load f195949
# end emit-variable-ref
   movl  %eax, 4(%ebp)  # f195949
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $8, %ebp     # bump ebp
    jmp _L_1431716            # jump around closure body
_L_1431715:
# check argument count
    cmp $4,%eax
    je _L_1431717
# invoke error handler eh_argcount
    .extern mrc_eh$uargcount
    movl mrc_eh$uargcount, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_1431717:
# emit-tail-expr
# si=-12
# env=((f195955 . -8) (f195949 . 4) (f195949 . 0))
# expr=(let ((f195955 f195955)) ((vector-ref f195949 0) f195955 0))
# emit-tail-let
#  si   = -12
#  env  = ((f195955 . -8) (f195949 . 4) (f195949 . 0))
#  bindings = ((f195955 f195955))
#  body = ((vector-ref f195949 0) f195955 0)
# emit-expr f195955
# emit-variable-ref
# env=((f195955 . -8) (f195949 . 4) (f195949 . 0))
# var=f195955
    movl -8(%esp), %eax  # stack load f195955
# end emit-variable-ref
    movl %eax, -12(%esp)  # stack save
# emit-tail-expr
# si=-16
# env=((f195955 . -12) (f195955 . -8) (f195949 . 4) (f195949 . 0))
# expr=((vector-ref f195949 0) f195955 0)
# emit-tail-funcall
#    si   =-16
#    env  = ((f195955 . -12) (f195955 . -8) (f195949 . 4) (f195949 . 0))
#    expr = (funcall (vector-ref f195949 0) f195955 0)
# emit-expr (vector-ref f195949 0)
# emit-expr f195949
# emit-variable-ref
# env=((f195955 . -12) (f195955 . -8) (f195949 . 4) (f195949 . 0))
# var=f195949
    movl 2(%edi), %eax  # frame load f195949
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1431718
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1431718:
    movl %eax, -16(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1431719"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1431719:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1431721
    cmp  $0,%eax
    jge _L_1431720
_L_1431721:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1431720:
    movl -16(%esp), %esi
    movl -1(%eax,%esi), %eax
   movl %eax,  -16(%esp)  # stash funcall-oper in next closure slot
# emit-expr f195955
# emit-variable-ref
# env=((f195955 . -12) (f195955 . -8) (f195949 . 4) (f195949 . 0))
# var=f195955
    movl -12(%esp), %eax  # stack load f195955
# end emit-variable-ref
    mov %eax, -20(%esp)    # arg f195955
# emit-expr 0
    movl $0, %eax     # immed 0
    mov %eax, -24(%esp)    # arg 0
    movl -16(%esp), %edi   # load new closure to %edi
# emit-shift-args:  size=3   si=-16  delta=12
    mov -16(%esp), %ebx  # shift frame cell
    mov %ebx, -4(%esp)  # down to base
# emit-shift-args:  size=2   si=-20  delta=12
    mov -20(%esp), %ebx  # shift frame cell
    mov %ebx, -8(%esp)  # down to base
# emit-shift-args:  size=1   si=-24  delta=12
    mov -24(%esp), %ebx  # shift frame cell
    mov %ebx, -12(%esp)  # down to base
# emit-shift-args:  size=0   si=-28  delta=12
    movl $8,%eax   # save arg count
    jmp *-2(%edi)  # tail-funcall
    .align 4,0x90
_L_1431716:
# emit-expr (begin)
# emit-begin
#   expr=(begin)
#   env=((f195949 . 0))
     movl %eax, mrc_string$m$glist
# == explicit-begins  ==>
# (letrec ((f (lambda (i l) (cond ((fx< i 10) (cons i l)) (else (f (fxquotient i 10) (cons (fxremainder i 10) l))))))) (lambda (i) (f i (quote ()))))
# == eliminate-let*  ==>
# (letrec ((f (lambda (i l) (cond ((fx< i 10) (cons i l)) (else (f (fxquotient i 10) (cons (fxremainder i 10) l))))))) (lambda (i) (f i (quote ()))))
# == uniquify-variables  ==>
# (letrec ((f195956 (lambda (f195959 f195960) (cond ((fx< f195959 10) (cons f195959 f195960)) (else (f195956 (fxquotient f195959 10) (cons (fxremainder f195959 10) f195960))))))) (lambda (f195962) (f195956 f195962 (quote ()))))
# == vectorize-letrec  ==>
# (let ((f195956 (make-vector 1))) (begin (begin (vector-set! f195956 0 (lambda (f195959 f195960) (cond ((fx< f195959 10) (cons f195959 f195960)) (else ((vector-ref f195956 0) (fxquotient f195959 10) (cons (fxremainder f195959 10) f195960))))))) (lambda (f195962) ((vector-ref f195956 0) f195962 (quote ())))))
# == eliminate-set!  ==>
# (let ((f195956 (make-vector 1))) (begin (begin (vector-set! f195956 0 (lambda (f195959 f195960) (let ((f195959 f195959) (f195960 f195960)) (cond ((fx< f195959 10) (cons f195959 f195960)) (else ((vector-ref f195956 0) (fxquotient f195959 10) (cons (fxremainder f195959 10) f195960)))))))) (lambda (f195962) (let ((f195962 f195962)) ((vector-ref f195956 0) f195962 (quote ()))))))
# == close-free-variables  ==>
# (let ((f195956 (make-vector 1))) (begin (begin (vector-set! f195956 0 (closure (f195959 f195960) (else f195956) (let ((f195959 f195959) (f195960 f195960)) (cond ((fx< f195959 10) (cons f195959 f195960)) (else ((vector-ref f195956 0) (fxquotient f195959 10) (cons (fxremainder f195959 10) f195960)))))))) (closure (f195962) (f195956) (let ((f195962 f195962)) ((vector-ref f195956 0) f195962 (quote ()))))))
# == eliminate-quote  ==>
# (let ((f195956 (make-vector 1))) (begin (begin (vector-set! f195956 0 (closure (f195959 f195960) (else f195956) (let ((f195959 f195959) (f195960 f195960)) (cond ((fx< f195959 10) (cons f195959 f195960)) (else ((vector-ref f195956 0) (fxquotient f195959 10) (cons (fxremainder f195959 10) f195960)))))))) (closure (f195962) (f195956) (let ((f195962 f195962)) ((vector-ref f195956 0) f195962 ())))))
# == eliminate-when/unless  ==>
# (let ((f195956 (make-vector 1))) (begin (begin (vector-set! f195956 0 (closure (f195959 f195960) (else f195956) (let ((f195959 f195959) (f195960 f195960)) (cond ((fx< f195959 10) (cons f195959 f195960)) (else ((vector-ref f195956 0) (fxquotient f195959 10) (cons (fxremainder f195959 10) f195960)))))))) (closure (f195962) (f195956) (let ((f195962 f195962)) ((vector-ref f195956 0) f195962 ())))))
# == eliminate-cond  ==>
# (let ((f195956 (make-vector 1))) (begin (begin (vector-set! f195956 0 (closure (f195959 f195960) (else f195956) (let ((f195959 f195959) (f195960 f195960)) (if (fx< f195959 10) (cons f195959 f195960) ((vector-ref f195956 0) (fxquotient f195959 10) (cons (fxremainder f195959 10) f195960))))))) (closure (f195962) (f195956) (let ((f195962 f195962)) ((vector-ref f195956 0) f195962 ())))))
# == external-symbols  ==>
# (let ((f195956 (make-vector 1))) (begin (begin (vector-set! f195956 0 (closure (f195959 f195960) (else f195956) (let ((f195959 f195959) (f195960 f195960)) (if (fx< f195959 10) (cons f195959 f195960) ((vector-ref f195956 0) (fxquotient f195959 10) (cons (fxremainder f195959 10) f195960))))))) (closure (f195962) (f195956) (let ((f195962 f195962)) ((vector-ref f195956 0) f195962 ())))))
# emit-expr (let ((f195956 (make-vector 1))) (begin (begin (vector-set! f195956 0 (closure (f195959 f195960) (else f195956) (let ((f195959 f195959) (f195960 f195960)) (if (fx< f195959 10) (cons f195959 f195960) ((vector-ref f195956 0) (fxquotient f195959 10) (cons (fxremainder f195959 10) f195960))))))) (closure (f195962) (f195956) (let ((f195962 f195962)) ((vector-ref f195956 0) f195962 ())))))
# emit-let
#  si   = 0
#  env  = ()
#  bindings = ((f195956 (make-vector 1)))
#  body = (begin (begin (vector-set! f195956 0 (closure (f195959 f195960) (else f195956) (let ((f195959 f195959) (f195960 f195960)) (if (fx< f195959 10) (cons f195959 f195960) ((vector-ref f195956 0) (fxquotient f195959 10) (cons (fxremainder f195959 10) f195960))))))) (closure (f195962) (f195956) (let ((f195962 f195962)) ((vector-ref f195956 0) f195962 ()))))
# emit-expr (make-vector 1)
# make-vector 1
# emit-expr 1
    movl $4, %eax     # immed 1
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1431722"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $128,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1431722:
# check the argument is a fixnum >= 0
    cmp $0,%eax
    jge _L_1431723
# invoke error handler eh_length
    .extern mrc_eh$ulength
    movl mrc_eh$ulength, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $128,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1431723:
    movl %eax, %esi
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    orl  $5, %eax
    addl $4, %esi
    addl $4, %esi
    andl $-8, %esi
    addl %esi, %ebp
    movl %eax, 0(%esp)  # stack save
# emit-expr (begin (begin (vector-set! f195956 0 (closure (f195959 f195960) (else f195956) (let ((f195959 f195959) (f195960 f195960)) (if (fx< f195959 10) (cons f195959 f195960) ((vector-ref f195956 0) (fxquotient f195959 10) (cons (fxremainder f195959 10) f195960))))))) (closure (f195962) (f195956) (let ((f195962 f195962)) ((vector-ref f195956 0) f195962 ()))))
# emit-begin
#   expr=(begin (begin (vector-set! f195956 0 (closure (f195959 f195960) (else f195956) (let ((f195959 f195959) (f195960 f195960)) (if (fx< f195959 10) (cons f195959 f195960) ((vector-ref f195956 0) (fxquotient f195959 10) (cons (fxremainder f195959 10) f195960))))))) (closure (f195962) (f195956) (let ((f195962 f195962)) ((vector-ref f195956 0) f195962 ()))))
#   env=((f195956 . 0))
# emit-expr (begin (vector-set! f195956 0 (closure (f195959 f195960) (else f195956) (let ((f195959 f195959) (f195960 f195960)) (if (fx< f195959 10) (cons f195959 f195960) ((vector-ref f195956 0) (fxquotient f195959 10) (cons (fxremainder f195959 10) f195960)))))))
# emit-begin
#   expr=(begin (vector-set! f195956 0 (closure (f195959 f195960) (else f195956) (let ((f195959 f195959) (f195960 f195960)) (if (fx< f195959 10) (cons f195959 f195960) ((vector-ref f195956 0) (fxquotient f195959 10) (cons (fxremainder f195959 10) f195960)))))))
#   env=((f195956 . 0))
# emit-expr (vector-set! f195956 0 (closure (f195959 f195960) (else f195956) (let ((f195959 f195959) (f195960 f195960)) (if (fx< f195959 10) (cons f195959 f195960) ((vector-ref f195956 0) (fxquotient f195959 10) (cons (fxremainder f195959 10) f195960))))))
# emit-expr f195956
# emit-variable-ref
# env=((f195956 . 0))
# var=f195956
    movl 0(%esp), %eax  # stack load f195956
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1431724
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1431724:
    movl %eax, -4(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1431725"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1431725:
# check bounds on vector index
    movl -4(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1431727
    cmp  $0,%eax
    jge _L_1431726
_L_1431727:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1431726:
    movl %eax, -8(%esp)
# emit-expr (closure (f195959 f195960) (else f195956) (let ((f195959 f195959) (f195960 f195960)) (if (fx< f195959 10) (cons f195959 f195960) ((vector-ref f195956 0) (fxquotient f195959 10) (cons (fxremainder f195959 10) f195960)))))
# emit-closure
# si = -12
# env = ((f195956 . 0))
# expr = (closure (f195959 f195960) (else f195956) (let ((f195959 f195959) (f195960 f195960)) (if (fx< f195959 10) (cons f195959 f195960) ((vector-ref f195956 0) (fxquotient f195959 10) (cons (fxremainder f195959 10) f195960)))))
    movl $_L_1431728, 0(%ebp)  # closure label
# WARNING: free var else not defined in the environmnet
# emit-variable-ref
# env=((f195956 . 0))
# var=f195956
    movl 0(%esp), %eax  # stack load f195956
# end emit-variable-ref
   movl  %eax, 8(%ebp)  # f195956
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $16, %ebp     # bump ebp
    jmp _L_1431729            # jump around closure body
_L_1431728:
# check argument count
    cmp $8,%eax
    je _L_1431730
# invoke error handler eh_argcount
    .extern mrc_eh$uargcount
    movl mrc_eh$uargcount, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_1431730:
# emit-tail-expr
# si=-16
# env=((f195960 . -12) (f195959 . -8) (f195956 . 8) (else . 4) (f195956 . 0))
# expr=(let ((f195959 f195959) (f195960 f195960)) (if (fx< f195959 10) (cons f195959 f195960) ((vector-ref f195956 0) (fxquotient f195959 10) (cons (fxremainder f195959 10) f195960))))
# emit-tail-let
#  si   = -16
#  env  = ((f195960 . -12) (f195959 . -8) (f195956 . 8) (else . 4) (f195956 . 0))
#  bindings = ((f195959 f195959) (f195960 f195960))
#  body = (if (fx< f195959 10) (cons f195959 f195960) ((vector-ref f195956 0) (fxquotient f195959 10) (cons (fxremainder f195959 10) f195960)))
# emit-expr f195959
# emit-variable-ref
# env=((f195960 . -12) (f195959 . -8) (f195956 . 8) (else . 4) (f195956 . 0))
# var=f195959
    movl -8(%esp), %eax  # stack load f195959
# end emit-variable-ref
    movl %eax, -16(%esp)  # stack save
# emit-expr f195960
# emit-variable-ref
# env=((f195960 . -12) (f195959 . -8) (f195956 . 8) (else . 4) (f195956 . 0))
# var=f195960
    movl -12(%esp), %eax  # stack load f195960
# end emit-variable-ref
    movl %eax, -20(%esp)  # stack save
# emit-tail-expr
# si=-24
# env=((f195960 . -20) (f195959 . -16) (f195960 . -12) (f195959 . -8) (f195956 . 8) (else . 4) (f195956 . 0))
# expr=(if (fx< f195959 10) (cons f195959 f195960) ((vector-ref f195956 0) (fxquotient f195959 10) (cons (fxremainder f195959 10) f195960)))
# emit-expr (fx< f195959 10)
# emit-expr 10
    movl $40, %eax     # immed 10
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1431733"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $64,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1431733:
    movl %eax, -24(%esp)
# emit-expr f195959
# emit-variable-ref
# env=((f195960 . -20) (f195959 . -16) (f195960 . -12) (f195959 . -8) (f195956 . 8) (else . 4) (f195956 . 0))
# var=f195959
    movl -16(%esp), %eax  # stack load f195959
# end emit-variable-ref
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1431734"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $64,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1431734:
    cmp -24(%esp), %eax
    setl %al
    movzbl %al, %eax
    sal $6, %al
    or $47, %al
    cmp $47, %al
    je _L_1431731
# emit-tail-expr
# si=-24
# env=((f195960 . -20) (f195959 . -16) (f195960 . -12) (f195959 . -8) (f195956 . 8) (else . 4) (f195956 . 0))
# expr=(cons f195959 f195960)
# tail primcall
# cons arg1=f195959 arg2=f195960
# emit-expr f195959
# emit-variable-ref
# env=((f195960 . -20) (f195959 . -16) (f195960 . -12) (f195959 . -8) (f195956 . 8) (else . 4) (f195956 . 0))
# var=f195959
    movl -16(%esp), %eax  # stack load f195959
# end emit-variable-ref
    movl %eax, -24(%esp)
# emit-expr f195960
# emit-variable-ref
# env=((f195960 . -20) (f195959 . -16) (f195960 . -12) (f195959 . -8) (f195956 . 8) (else . 4) (f195956 . 0))
# var=f195960
    movl -20(%esp), %eax  # stack load f195960
# end emit-variable-ref
    movl %eax, 4(%ebp)
    movl -24(%esp), %eax
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    or   $1, %al
    add  $8, %ebp
# cons end
#return from tail (cons f195959 f195960)
    ret
    jmp _L_1431732
_L_1431731:
# emit-tail-expr
# si=-24
# env=((f195960 . -20) (f195959 . -16) (f195960 . -12) (f195959 . -8) (f195956 . 8) (else . 4) (f195956 . 0))
# expr=((vector-ref f195956 0) (fxquotient f195959 10) (cons (fxremainder f195959 10) f195960))
# emit-tail-funcall
#    si   =-24
#    env  = ((f195960 . -20) (f195959 . -16) (f195960 . -12) (f195959 . -8) (f195956 . 8) (else . 4) (f195956 . 0))
#    expr = (funcall (vector-ref f195956 0) (fxquotient f195959 10) (cons (fxremainder f195959 10) f195960))
# emit-expr (vector-ref f195956 0)
# emit-expr f195956
# emit-variable-ref
# env=((f195960 . -20) (f195959 . -16) (f195960 . -12) (f195959 . -8) (f195956 . 8) (else . 4) (f195956 . 0))
# var=f195956
    movl 6(%edi), %eax  # frame load f195956
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1431735
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1431735:
    movl %eax, -24(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1431736"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1431736:
# check bounds on vector index
    movl -24(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1431738
    cmp  $0,%eax
    jge _L_1431737
_L_1431738:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1431737:
    movl -24(%esp), %esi
    movl -1(%eax,%esi), %eax
   movl %eax,  -24(%esp)  # stash funcall-oper in next closure slot
# emit-expr (fxquotient f195959 10)
# emit-expr 10
    movl $40, %eax     # immed 10
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1431740"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $92,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1431740:
    movl %eax, -28(%esp)  # denominator
# emit-expr f195959
# emit-variable-ref
# env=((f195960 . -20) (f195959 . -16) (f195960 . -12) (f195959 . -8) (f195956 . 8) (else . 4) (f195956 . 0))
# var=f195959
    movl -16(%esp), %eax  # stack load f195959
# end emit-variable-ref
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1431741"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $92,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1431741:
    movl -28(%esp),%ebx   # ebx <- denominator
    xor %edx,%edx        # edx <- 0
    cmp $0,%eax
    jge _L_1431739
    not %edx
_L_1431739:
    idiv %ebx            # eax <- edx:eax/ebx
    sal $2,%eax          # eax <- eax*4 (since it was divided away)
    mov %eax, -28(%esp)    # arg (fxquotient f195959 10)
# emit-expr (cons (fxremainder f195959 10) f195960)
# cons arg1=(fxremainder f195959 10) arg2=f195960
# emit-expr (fxremainder f195959 10)
# emit-expr 10
    movl $40, %eax     # immed 10
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1431743"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $92,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1431743:
    movl %eax, -32(%esp)  # denominator
# emit-expr f195959
# emit-variable-ref
# env=((f195960 . -20) (f195959 . -16) (f195960 . -12) (f195959 . -8) (f195956 . 8) (else . 4) (f195956 . 0))
# var=f195959
    movl -16(%esp), %eax  # stack load f195959
# end emit-variable-ref
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1431744"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $92,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1431744:
    movl -32(%esp),%ebx   # ebx <- denominator
    xor %edx,%edx        # edx <- 0
    cmp $0,%eax
    jge _L_1431742
    not %edx
_L_1431742:
    idiv %ebx            # edx <- edx:eax/ebx  remainder
    movl %edx,%eax
    movl %eax, -32(%esp)
# emit-expr f195960
# emit-variable-ref
# env=((f195960 . -20) (f195959 . -16) (f195960 . -12) (f195959 . -8) (f195956 . 8) (else . 4) (f195956 . 0))
# var=f195960
    movl -20(%esp), %eax  # stack load f195960
# end emit-variable-ref
    movl %eax, 4(%ebp)
    movl -32(%esp), %eax
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    or   $1, %al
    add  $8, %ebp
# cons end
    mov %eax, -32(%esp)    # arg (cons (fxremainder f195959 10) f195960)
    movl -24(%esp), %edi   # load new closure to %edi
# emit-shift-args:  size=3   si=-24  delta=20
    mov -24(%esp), %ebx  # shift frame cell
    mov %ebx, -4(%esp)  # down to base
# emit-shift-args:  size=2   si=-28  delta=20
    mov -28(%esp), %ebx  # shift frame cell
    mov %ebx, -8(%esp)  # down to base
# emit-shift-args:  size=1   si=-32  delta=20
    mov -32(%esp), %ebx  # shift frame cell
    mov %ebx, -12(%esp)  # down to base
# emit-shift-args:  size=0   si=-36  delta=20
    movl $8,%eax   # save arg count
    jmp *-2(%edi)  # tail-funcall
_L_1431732:
    .align 4,0x90
_L_1431729:
    movl -4(%esp), %ebx
    movl -8(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin)
# emit-begin
#   expr=(begin)
#   env=((f195956 . 0))
# emit-expr (begin (closure (f195962) (f195956) (let ((f195962 f195962)) ((vector-ref f195956 0) f195962 ()))))
# emit-begin
#   expr=(begin (closure (f195962) (f195956) (let ((f195962 f195962)) ((vector-ref f195956 0) f195962 ()))))
#   env=((f195956 . 0))
# emit-expr (closure (f195962) (f195956) (let ((f195962 f195962)) ((vector-ref f195956 0) f195962 ())))
# emit-closure
# si = -4
# env = ((f195956 . 0))
# expr = (closure (f195962) (f195956) (let ((f195962 f195962)) ((vector-ref f195956 0) f195962 ())))
    movl $_L_1431745, 0(%ebp)  # closure label
# emit-variable-ref
# env=((f195956 . 0))
# var=f195956
    movl 0(%esp), %eax  # stack load f195956
# end emit-variable-ref
   movl  %eax, 4(%ebp)  # f195956
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $8, %ebp     # bump ebp
    jmp _L_1431746            # jump around closure body
_L_1431745:
# check argument count
    cmp $4,%eax
    je _L_1431747
# invoke error handler eh_argcount
    .extern mrc_eh$uargcount
    movl mrc_eh$uargcount, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_1431747:
# emit-tail-expr
# si=-12
# env=((f195962 . -8) (f195956 . 4) (f195956 . 0))
# expr=(let ((f195962 f195962)) ((vector-ref f195956 0) f195962 ()))
# emit-tail-let
#  si   = -12
#  env  = ((f195962 . -8) (f195956 . 4) (f195956 . 0))
#  bindings = ((f195962 f195962))
#  body = ((vector-ref f195956 0) f195962 ())
# emit-expr f195962
# emit-variable-ref
# env=((f195962 . -8) (f195956 . 4) (f195956 . 0))
# var=f195962
    movl -8(%esp), %eax  # stack load f195962
# end emit-variable-ref
    movl %eax, -12(%esp)  # stack save
# emit-tail-expr
# si=-16
# env=((f195962 . -12) (f195962 . -8) (f195956 . 4) (f195956 . 0))
# expr=((vector-ref f195956 0) f195962 ())
# emit-tail-funcall
#    si   =-16
#    env  = ((f195962 . -12) (f195962 . -8) (f195956 . 4) (f195956 . 0))
#    expr = (funcall (vector-ref f195956 0) f195962 ())
# emit-expr (vector-ref f195956 0)
# emit-expr f195956
# emit-variable-ref
# env=((f195962 . -12) (f195962 . -8) (f195956 . 4) (f195956 . 0))
# var=f195956
    movl 2(%edi), %eax  # frame load f195956
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1431748
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1431748:
    movl %eax, -16(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1431749"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1431749:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1431751
    cmp  $0,%eax
    jge _L_1431750
_L_1431751:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1431750:
    movl -16(%esp), %esi
    movl -1(%eax,%esi), %eax
   movl %eax,  -16(%esp)  # stash funcall-oper in next closure slot
# emit-expr f195962
# emit-variable-ref
# env=((f195962 . -12) (f195962 . -8) (f195956 . 4) (f195956 . 0))
# var=f195962
    movl -12(%esp), %eax  # stack load f195962
# end emit-variable-ref
    mov %eax, -20(%esp)    # arg f195962
# emit-expr ()
    movl $63, %eax     # immed ()
    mov %eax, -24(%esp)    # arg ()
    movl -16(%esp), %edi   # load new closure to %edi
# emit-shift-args:  size=3   si=-16  delta=12
    mov -16(%esp), %ebx  # shift frame cell
    mov %ebx, -4(%esp)  # down to base
# emit-shift-args:  size=2   si=-20  delta=12
    mov -20(%esp), %ebx  # shift frame cell
    mov %ebx, -8(%esp)  # down to base
# emit-shift-args:  size=1   si=-24  delta=12
    mov -24(%esp), %ebx  # shift frame cell
    mov %ebx, -12(%esp)  # down to base
# emit-shift-args:  size=0   si=-28  delta=12
    movl $8,%eax   # save arg count
    jmp *-2(%edi)  # tail-funcall
    .align 4,0x90
_L_1431746:
# emit-expr (begin)
# emit-begin
#   expr=(begin)
#   env=((f195956 . 0))
     movl %eax, mrc_integer$m$glist
# == explicit-begins  ==>
# (let* ((write-stderr (lambda (s) (foreign-call "s_write" 2 s (string-length s)))) (write-errmsg (lambda (sym emsg) (begin (write-stderr "error:") (write-stderr (symbol->string sym)) (write-stderr ": ") (write-stderr emsg) (write-stderr "\n"))))) (lambda (sym emsg) (begin (write-errmsg sym emsg) (foreign-call "s_exit" 1))))
# == eliminate-let*  ==>
# (let ((write-stderr (lambda (s) (foreign-call "s_write" 2 s (string-length s))))) (let ((write-errmsg (lambda (sym emsg) (begin (write-stderr "error:") (write-stderr (symbol->string sym)) (write-stderr ": ") (write-stderr emsg) (write-stderr "\n"))))) (lambda (sym emsg) (begin (write-errmsg sym emsg) (foreign-call "s_exit" 1)))))
# == uniquify-variables  ==>
# (let ((f195963 (lambda (f195964) (foreign-call "s_write" 2 f195964 (string-length f195964))))) (let ((f195972 (lambda (f195973 f195974) (begin (f195963 "error:") (f195963 (symbol->string f195973)) (f195963 ": ") (f195963 f195974) (f195963 "\n"))))) (lambda (f195977 f195978) (begin (f195972 f195977 f195978) (foreign-call "s_exit" 1)))))
# == vectorize-letrec  ==>
# (let ((f195963 (lambda (f195964) (foreign-call "s_write" 2 f195964 (string-length f195964))))) (let ((f195972 (lambda (f195973 f195974) (begin (f195963 "error:") (f195963 (symbol->string f195973)) (f195963 ": ") (f195963 f195974) (f195963 "\n"))))) (lambda (f195977 f195978) (begin (f195972 f195977 f195978) (foreign-call "s_exit" 1)))))
# == eliminate-set!  ==>
# (let ((f195963 (lambda (f195964) (let ((f195964 f195964)) (foreign-call "s_write" 2 f195964 (string-length f195964)))))) (let ((f195972 (lambda (f195973 f195974) (let ((f195973 f195973) (f195974 f195974)) (begin (f195963 "error:") (f195963 (symbol->string f195973)) (f195963 ": ") (f195963 f195974) (f195963 "\n")))))) (lambda (f195977 f195978) (let ((f195977 f195977) (f195978 f195978)) (begin (f195972 f195977 f195978) (foreign-call "s_exit" 1))))))
# == close-free-variables  ==>
# (let ((f195963 (closure (f195964) () (let ((f195964 f195964)) (foreign-call "s_write" 2 f195964 (string-length f195964)))))) (let ((f195972 (closure (f195973 f195974) (f195963 f195963 f195963 f195963 f195963) (let ((f195973 f195973) (f195974 f195974)) (begin (f195963 "error:") (f195963 (symbol->string f195973)) (f195963 ": ") (f195963 f195974) (f195963 "\n")))))) (closure (f195977 f195978) (f195972) (let ((f195977 f195977) (f195978 f195978)) (begin (f195972 f195977 f195978) (foreign-call "s_exit" 1))))))
# == eliminate-quote  ==>
# (let ((f195963 (closure (f195964) () (let ((f195964 f195964)) (foreign-call "s_write" 2 f195964 (string-length f195964)))))) (let ((f195972 (closure (f195973 f195974) (f195963 f195963 f195963 f195963 f195963) (let ((f195973 f195973) (f195974 f195974)) (begin (f195963 "error:") (f195963 (symbol->string f195973)) (f195963 ": ") (f195963 f195974) (f195963 "\n")))))) (closure (f195977 f195978) (f195972) (let ((f195977 f195977) (f195978 f195978)) (begin (f195972 f195977 f195978) (foreign-call "s_exit" 1))))))
# == eliminate-when/unless  ==>
# (let ((f195963 (closure (f195964) () (let ((f195964 f195964)) (foreign-call "s_write" 2 f195964 (string-length f195964)))))) (let ((f195972 (closure (f195973 f195974) (f195963 f195963 f195963 f195963 f195963) (let ((f195973 f195973) (f195974 f195974)) (begin (f195963 "error:") (f195963 (symbol->string f195973)) (f195963 ": ") (f195963 f195974) (f195963 "\n")))))) (closure (f195977 f195978) (f195972) (let ((f195977 f195977) (f195978 f195978)) (begin (f195972 f195977 f195978) (foreign-call "s_exit" 1))))))
# == eliminate-cond  ==>
# (let ((f195963 (closure (f195964) () (let ((f195964 f195964)) (foreign-call "s_write" 2 f195964 (string-length f195964)))))) (let ((f195972 (closure (f195973 f195974) (f195963 f195963 f195963 f195963 f195963) (let ((f195973 f195973) (f195974 f195974)) (begin (f195963 "error:") (f195963 (symbol->string f195973)) (f195963 ": ") (f195963 f195974) (f195963 "\n")))))) (closure (f195977 f195978) (f195972) (let ((f195977 f195977) (f195978 f195978)) (begin (f195972 f195977 f195978) (foreign-call "s_exit" 1))))))
# == external-symbols  ==>
# (let ((f195963 (closure (f195964) () (let ((f195964 f195964)) (foreign-call "s_write" 2 f195964 (string-length f195964)))))) (let ((f195972 (closure (f195973 f195974) (f195963 f195963 f195963 f195963 f195963) (let ((f195973 f195973) (f195974 f195974)) (begin (f195963 "error:") (f195963 (symbol->string f195973)) (f195963 ": ") (f195963 f195974) (f195963 "\n")))))) (closure (f195977 f195978) (f195972) (let ((f195977 f195977) (f195978 f195978)) (begin (f195972 f195977 f195978) (foreign-call "s_exit" 1))))))
# emit-expr (let ((f195963 (closure (f195964) () (let ((f195964 f195964)) (foreign-call "s_write" 2 f195964 (string-length f195964)))))) (let ((f195972 (closure (f195973 f195974) (f195963 f195963 f195963 f195963 f195963) (let ((f195973 f195973) (f195974 f195974)) (begin (f195963 "error:") (f195963 (symbol->string f195973)) (f195963 ": ") (f195963 f195974) (f195963 "\n")))))) (closure (f195977 f195978) (f195972) (let ((f195977 f195977) (f195978 f195978)) (begin (f195972 f195977 f195978) (foreign-call "s_exit" 1))))))
# emit-let
#  si   = 0
#  env  = ()
#  bindings = ((f195963 (closure (f195964) () (let ((f195964 f195964)) (foreign-call "s_write" 2 f195964 (string-length f195964))))))
#  body = (let ((f195972 (closure (f195973 f195974) (f195963 f195963 f195963 f195963 f195963) (let ((f195973 f195973) (f195974 f195974)) (begin (f195963 "error:") (f195963 (symbol->string f195973)) (f195963 ": ") (f195963 f195974) (f195963 "\n")))))) (closure (f195977 f195978) (f195972) (let ((f195977 f195977) (f195978 f195978)) (begin (f195972 f195977 f195978) (foreign-call "s_exit" 1)))))
# emit-expr (closure (f195964) () (let ((f195964 f195964)) (foreign-call "s_write" 2 f195964 (string-length f195964))))
# emit-closure
# si = 0
# env = ()
# expr = (closure (f195964) () (let ((f195964 f195964)) (foreign-call "s_write" 2 f195964 (string-length f195964))))
    movl $_L_1431752, 0(%ebp)  # closure label
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $8, %ebp     # bump ebp
    jmp _L_1431753            # jump around closure body
_L_1431752:
# check argument count
    cmp $4,%eax
    je _L_1431754
# invoke error handler eh_argcount
    .extern mrc_eh$uargcount
    movl mrc_eh$uargcount, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_1431754:
# emit-tail-expr
# si=-12
# env=((f195964 . -8))
# expr=(let ((f195964 f195964)) (foreign-call "s_write" 2 f195964 (string-length f195964)))
# emit-tail-let
#  si   = -12
#  env  = ((f195964 . -8))
#  bindings = ((f195964 f195964))
#  body = (foreign-call "s_write" 2 f195964 (string-length f195964))
# emit-expr f195964
# emit-variable-ref
# env=((f195964 . -8))
# var=f195964
    movl -8(%esp), %eax  # stack load f195964
# end emit-variable-ref
    movl %eax, -12(%esp)  # stack save
# emit-tail-expr
# si=-16
# env=((f195964 . -12) (f195964 . -8))
# expr=(foreign-call "s_write" 2 f195964 (string-length f195964))
    movl %ecx,-16(%esp)
    movl %esp,-20(%esp)
# emit-expr (string-length f195964)
# emit-expr f195964
# emit-variable-ref
# env=((f195964 . -12) (f195964 . -8))
# var=f195964
    movl -12(%esp), %eax  # stack load f195964
# end emit-variable-ref
# check the argument is a string
    movl %eax,%ebx
    and $7, %bl
    cmp $6, %bl
    je _L_1431755
# invoke error handler eh_string
    .extern mrc_eh$ustring
    movl mrc_eh$ustring, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $152,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1431755:
    movl -6(%eax), %eax
    movl %eax, -24(%esp)
# emit-expr f195964
# emit-variable-ref
# env=((f195964 . -12) (f195964 . -8))
# var=f195964
    movl -12(%esp), %eax  # stack load f195964
# end emit-variable-ref
    movl %eax, -28(%esp)
# emit-expr 2
    movl $8, %eax     # immed 2
    movl %eax, -32(%esp)
    leal -32(%esp),%edi
    movl %edi,%esi
    andl $-16,%esi
    movl 0(%edi),%eax
    movl %eax,0(%esi)
    movl 4(%edi),%eax
    movl %eax,4(%esi)
    movl 8(%edi),%eax
    movl %eax,8(%esi)
    movl 12(%edi),%eax
    movl %eax,12(%esi)
    movl %esi,%esp
    .extern _s_write
    call _s_write
    movl 12(%esi),%esp
    movl -16(%esp),%ecx
     ret
    .align 4,0x90
_L_1431753:
    movl %eax, 0(%esp)  # stack save
# emit-expr (let ((f195972 (closure (f195973 f195974) (f195963 f195963 f195963 f195963 f195963) (let ((f195973 f195973) (f195974 f195974)) (begin (f195963 "error:") (f195963 (symbol->string f195973)) (f195963 ": ") (f195963 f195974) (f195963 "\n")))))) (closure (f195977 f195978) (f195972) (let ((f195977 f195977) (f195978 f195978)) (begin (f195972 f195977 f195978) (foreign-call "s_exit" 1)))))
# emit-let
#  si   = -4
#  env  = ((f195963 . 0))
#  bindings = ((f195972 (closure (f195973 f195974) (f195963 f195963 f195963 f195963 f195963) (let ((f195973 f195973) (f195974 f195974)) (begin (f195963 "error:") (f195963 (symbol->string f195973)) (f195963 ": ") (f195963 f195974) (f195963 "\n"))))))
#  body = (closure (f195977 f195978) (f195972) (let ((f195977 f195977) (f195978 f195978)) (begin (f195972 f195977 f195978) (foreign-call "s_exit" 1))))
# emit-expr (closure (f195973 f195974) (f195963 f195963 f195963 f195963 f195963) (let ((f195973 f195973) (f195974 f195974)) (begin (f195963 "error:") (f195963 (symbol->string f195973)) (f195963 ": ") (f195963 f195974) (f195963 "\n"))))
# emit-closure
# si = -4
# env = ((f195963 . 0))
# expr = (closure (f195973 f195974) (f195963 f195963 f195963 f195963 f195963) (let ((f195973 f195973) (f195974 f195974)) (begin (f195963 "error:") (f195963 (symbol->string f195973)) (f195963 ": ") (f195963 f195974) (f195963 "\n"))))
    movl $_L_1431756, 0(%ebp)  # closure label
# emit-variable-ref
# env=((f195963 . 0))
# var=f195963
    movl 0(%esp), %eax  # stack load f195963
# end emit-variable-ref
   movl  %eax, 4(%ebp)  # f195963
# emit-variable-ref
# env=((f195963 . 0))
# var=f195963
    movl 0(%esp), %eax  # stack load f195963
# end emit-variable-ref
   movl  %eax, 8(%ebp)  # f195963
# emit-variable-ref
# env=((f195963 . 0))
# var=f195963
    movl 0(%esp), %eax  # stack load f195963
# end emit-variable-ref
   movl  %eax, 12(%ebp)  # f195963
# emit-variable-ref
# env=((f195963 . 0))
# var=f195963
    movl 0(%esp), %eax  # stack load f195963
# end emit-variable-ref
   movl  %eax, 16(%ebp)  # f195963
# emit-variable-ref
# env=((f195963 . 0))
# var=f195963
    movl 0(%esp), %eax  # stack load f195963
# end emit-variable-ref
   movl  %eax, 20(%ebp)  # f195963
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $24, %ebp     # bump ebp
    jmp _L_1431757            # jump around closure body
_L_1431756:
# check argument count
    cmp $8,%eax
    je _L_1431758
# invoke error handler eh_argcount
    .extern mrc_eh$uargcount
    movl mrc_eh$uargcount, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_1431758:
# emit-tail-expr
# si=-16
# env=((f195974 . -12) (f195973 . -8) (f195963 . 20) (f195963 . 16) (f195963 . 12) (f195963 . 8) (f195963 . 4) (f195963 . 0))
# expr=(let ((f195973 f195973) (f195974 f195974)) (begin (f195963 "error:") (f195963 (symbol->string f195973)) (f195963 ": ") (f195963 f195974) (f195963 "\n")))
# emit-tail-let
#  si   = -16
#  env  = ((f195974 . -12) (f195973 . -8) (f195963 . 20) (f195963 . 16) (f195963 . 12) (f195963 . 8) (f195963 . 4) (f195963 . 0))
#  bindings = ((f195973 f195973) (f195974 f195974))
#  body = (begin (f195963 "error:") (f195963 (symbol->string f195973)) (f195963 ": ") (f195963 f195974) (f195963 "\n"))
# emit-expr f195973
# emit-variable-ref
# env=((f195974 . -12) (f195973 . -8) (f195963 . 20) (f195963 . 16) (f195963 . 12) (f195963 . 8) (f195963 . 4) (f195963 . 0))
# var=f195973
    movl -8(%esp), %eax  # stack load f195973
# end emit-variable-ref
    movl %eax, -16(%esp)  # stack save
# emit-expr f195974
# emit-variable-ref
# env=((f195974 . -12) (f195973 . -8) (f195963 . 20) (f195963 . 16) (f195963 . 12) (f195963 . 8) (f195963 . 4) (f195963 . 0))
# var=f195974
    movl -12(%esp), %eax  # stack load f195974
# end emit-variable-ref
    movl %eax, -20(%esp)  # stack save
# emit-tail-expr
# si=-24
# env=((f195974 . -20) (f195973 . -16) (f195974 . -12) (f195973 . -8) (f195963 . 20) (f195963 . 16) (f195963 . 12) (f195963 . 8) (f195963 . 4) (f195963 . 0))
# expr=(begin (f195963 "error:") (f195963 (symbol->string f195973)) (f195963 ": ") (f195963 f195974) (f195963 "\n"))
# tail-begin (begin (f195963 "error:") (f195963 (symbol->string f195973)) (f195963 ": ") (f195963 f195974) (f195963 "\n"))
#   env=((f195974 . -20) (f195973 . -16) (f195974 . -12) (f195973 . -8) (f195963 . 20) (f195963 . 16) (f195963 . 12) (f195963 . 8) (f195963 . 4) (f195963 . 0))
# emit-expr (f195963 "error:")
# funcall
#    si   =-24
#    env  = ((f195974 . -20) (f195973 . -16) (f195974 . -12) (f195973 . -8) (f195963 . 20) (f195963 . 16) (f195963 . 12) (f195963 . 8) (f195963 . 4) (f195963 . 0))
#    expr = (funcall f195963 "error:")
# emit-expr f195963
# emit-variable-ref
# env=((f195974 . -20) (f195973 . -16) (f195974 . -12) (f195973 . -8) (f195963 . 20) (f195963 . 16) (f195963 . 12) (f195963 . 8) (f195963 . 4) (f195963 . 0))
# var=f195963
    movl 18(%edi), %eax  # frame load f195963
# end emit-variable-ref
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1431759"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1431759":
   movl %eax,  -32(%esp)  # stash funcall-oper in closure slot
# emit-expr "error:"
# string literal
    jmp _L_1431761
    .align 8,0x90
_L_1431760 :
    .int 24
    .ascii "error:"
_L_1431761:
    movl $_L_1431760, %eax
    orl $6, %eax
    mov %eax, -36(%esp)  # arg error:
    movl -32(%esp), %edi   # load new closure to %edi
    add $-24, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $24, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
# emit-tail-expr
# si=-24
# env=((f195974 . -20) (f195973 . -16) (f195974 . -12) (f195973 . -8) (f195963 . 20) (f195963 . 16) (f195963 . 12) (f195963 . 8) (f195963 . 4) (f195963 . 0))
# expr=(begin (f195963 (symbol->string f195973)) (f195963 ": ") (f195963 f195974) (f195963 "\n"))
# tail-begin (begin (f195963 (symbol->string f195973)) (f195963 ": ") (f195963 f195974) (f195963 "\n"))
#   env=((f195974 . -20) (f195973 . -16) (f195974 . -12) (f195973 . -8) (f195963 . 20) (f195963 . 16) (f195963 . 12) (f195963 . 8) (f195963 . 4) (f195963 . 0))
# emit-expr (f195963 (symbol->string f195973))
# funcall
#    si   =-24
#    env  = ((f195974 . -20) (f195973 . -16) (f195974 . -12) (f195973 . -8) (f195963 . 20) (f195963 . 16) (f195963 . 12) (f195963 . 8) (f195963 . 4) (f195963 . 0))
#    expr = (funcall f195963 (symbol->string f195973))
# emit-expr f195963
# emit-variable-ref
# env=((f195974 . -20) (f195973 . -16) (f195974 . -12) (f195973 . -8) (f195963 . 20) (f195963 . 16) (f195963 . 12) (f195963 . 8) (f195963 . 4) (f195963 . 0))
# var=f195963
    movl 18(%edi), %eax  # frame load f195963
# end emit-variable-ref
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1431762"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1431762":
   movl %eax,  -32(%esp)  # stash funcall-oper in closure slot
# emit-expr (symbol->string f195973)
# symbol->string f195973
# emit-expr f195973
# emit-variable-ref
# env=((f195974 . -20) (f195973 . -16) (f195974 . -12) (f195973 . -8) (f195963 . 20) (f195963 . 16) (f195963 . 12) (f195963 . 8) (f195963 . 4) (f195963 . 0))
# var=f195973
    movl -16(%esp), %eax  # stack load f195973
# end emit-variable-ref
    movl -3(%eax), %eax
    mov %eax, -36(%esp)  # arg (symbol->string f195973)
    movl -32(%esp), %edi   # load new closure to %edi
    add $-24, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $24, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
# emit-tail-expr
# si=-24
# env=((f195974 . -20) (f195973 . -16) (f195974 . -12) (f195973 . -8) (f195963 . 20) (f195963 . 16) (f195963 . 12) (f195963 . 8) (f195963 . 4) (f195963 . 0))
# expr=(begin (f195963 ": ") (f195963 f195974) (f195963 "\n"))
# tail-begin (begin (f195963 ": ") (f195963 f195974) (f195963 "\n"))
#   env=((f195974 . -20) (f195973 . -16) (f195974 . -12) (f195973 . -8) (f195963 . 20) (f195963 . 16) (f195963 . 12) (f195963 . 8) (f195963 . 4) (f195963 . 0))
# emit-expr (f195963 ": ")
# funcall
#    si   =-24
#    env  = ((f195974 . -20) (f195973 . -16) (f195974 . -12) (f195973 . -8) (f195963 . 20) (f195963 . 16) (f195963 . 12) (f195963 . 8) (f195963 . 4) (f195963 . 0))
#    expr = (funcall f195963 ": ")
# emit-expr f195963
# emit-variable-ref
# env=((f195974 . -20) (f195973 . -16) (f195974 . -12) (f195973 . -8) (f195963 . 20) (f195963 . 16) (f195963 . 12) (f195963 . 8) (f195963 . 4) (f195963 . 0))
# var=f195963
    movl 18(%edi), %eax  # frame load f195963
# end emit-variable-ref
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1431763"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1431763":
   movl %eax,  -32(%esp)  # stash funcall-oper in closure slot
# emit-expr ": "
# string literal
    jmp _L_1431765
    .align 8,0x90
_L_1431764 :
    .int 8
    .ascii ": "
_L_1431765:
    movl $_L_1431764, %eax
    orl $6, %eax
    mov %eax, -36(%esp)  # arg : 
    movl -32(%esp), %edi   # load new closure to %edi
    add $-24, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $24, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
# emit-tail-expr
# si=-24
# env=((f195974 . -20) (f195973 . -16) (f195974 . -12) (f195973 . -8) (f195963 . 20) (f195963 . 16) (f195963 . 12) (f195963 . 8) (f195963 . 4) (f195963 . 0))
# expr=(begin (f195963 f195974) (f195963 "\n"))
# tail-begin (begin (f195963 f195974) (f195963 "\n"))
#   env=((f195974 . -20) (f195973 . -16) (f195974 . -12) (f195973 . -8) (f195963 . 20) (f195963 . 16) (f195963 . 12) (f195963 . 8) (f195963 . 4) (f195963 . 0))
# emit-expr (f195963 f195974)
# funcall
#    si   =-24
#    env  = ((f195974 . -20) (f195973 . -16) (f195974 . -12) (f195973 . -8) (f195963 . 20) (f195963 . 16) (f195963 . 12) (f195963 . 8) (f195963 . 4) (f195963 . 0))
#    expr = (funcall f195963 f195974)
# emit-expr f195963
# emit-variable-ref
# env=((f195974 . -20) (f195973 . -16) (f195974 . -12) (f195973 . -8) (f195963 . 20) (f195963 . 16) (f195963 . 12) (f195963 . 8) (f195963 . 4) (f195963 . 0))
# var=f195963
    movl 18(%edi), %eax  # frame load f195963
# end emit-variable-ref
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1431766"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1431766":
   movl %eax,  -32(%esp)  # stash funcall-oper in closure slot
# emit-expr f195974
# emit-variable-ref
# env=((f195974 . -20) (f195973 . -16) (f195974 . -12) (f195973 . -8) (f195963 . 20) (f195963 . 16) (f195963 . 12) (f195963 . 8) (f195963 . 4) (f195963 . 0))
# var=f195974
    movl -20(%esp), %eax  # stack load f195974
# end emit-variable-ref
    mov %eax, -36(%esp)  # arg f195974
    movl -32(%esp), %edi   # load new closure to %edi
    add $-24, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $24, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
# emit-tail-expr
# si=-24
# env=((f195974 . -20) (f195973 . -16) (f195974 . -12) (f195973 . -8) (f195963 . 20) (f195963 . 16) (f195963 . 12) (f195963 . 8) (f195963 . 4) (f195963 . 0))
# expr=(begin (f195963 "\n"))
# tail-begin (begin (f195963 "\n"))
#   env=((f195974 . -20) (f195973 . -16) (f195974 . -12) (f195973 . -8) (f195963 . 20) (f195963 . 16) (f195963 . 12) (f195963 . 8) (f195963 . 4) (f195963 . 0))
# emit-tail-expr
# si=-24
# env=((f195974 . -20) (f195973 . -16) (f195974 . -12) (f195973 . -8) (f195963 . 20) (f195963 . 16) (f195963 . 12) (f195963 . 8) (f195963 . 4) (f195963 . 0))
# expr=(f195963 "\n")
# emit-tail-funcall
#    si   =-24
#    env  = ((f195974 . -20) (f195973 . -16) (f195974 . -12) (f195973 . -8) (f195963 . 20) (f195963 . 16) (f195963 . 12) (f195963 . 8) (f195963 . 4) (f195963 . 0))
#    expr = (funcall f195963 "\n")
# emit-expr f195963
# emit-variable-ref
# env=((f195974 . -20) (f195973 . -16) (f195974 . -12) (f195973 . -8) (f195963 . 20) (f195963 . 16) (f195963 . 12) (f195963 . 8) (f195963 . 4) (f195963 . 0))
# var=f195963
    movl 18(%edi), %eax  # frame load f195963
# end emit-variable-ref
   movl %eax,  -24(%esp)  # stash funcall-oper in next closure slot
# emit-expr "\n"
# string literal
    jmp _L_1431768
    .align 8,0x90
_L_1431767 :
    .int 4
    .ascii "\n"
_L_1431768:
    movl $_L_1431767, %eax
    orl $6, %eax
    mov %eax, -28(%esp)    # arg 

    movl -24(%esp), %edi   # load new closure to %edi
# emit-shift-args:  size=2   si=-24  delta=20
    mov -24(%esp), %ebx  # shift frame cell
    mov %ebx, -4(%esp)  # down to base
# emit-shift-args:  size=1   si=-28  delta=20
    mov -28(%esp), %ebx  # shift frame cell
    mov %ebx, -8(%esp)  # down to base
# emit-shift-args:  size=0   si=-32  delta=20
    movl $4,%eax   # save arg count
    jmp *-2(%edi)  # tail-funcall
     ret   # return thru stack
    .align 4,0x90
_L_1431757:
    movl %eax, -4(%esp)  # stack save
# emit-expr (closure (f195977 f195978) (f195972) (let ((f195977 f195977) (f195978 f195978)) (begin (f195972 f195977 f195978) (foreign-call "s_exit" 1))))
# emit-closure
# si = -8
# env = ((f195972 . -4) (f195963 . 0))
# expr = (closure (f195977 f195978) (f195972) (let ((f195977 f195977) (f195978 f195978)) (begin (f195972 f195977 f195978) (foreign-call "s_exit" 1))))
    movl $_L_1431769, 0(%ebp)  # closure label
# emit-variable-ref
# env=((f195972 . -4) (f195963 . 0))
# var=f195972
    movl -4(%esp), %eax  # stack load f195972
# end emit-variable-ref
   movl  %eax, 4(%ebp)  # f195972
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $8, %ebp     # bump ebp
    jmp _L_1431770            # jump around closure body
_L_1431769:
# check argument count
    cmp $8,%eax
    je _L_1431771
# invoke error handler eh_argcount
    .extern mrc_eh$uargcount
    movl mrc_eh$uargcount, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_1431771:
# emit-tail-expr
# si=-16
# env=((f195978 . -12) (f195977 . -8) (f195972 . 4) (f195972 . -4) (f195963 . 0))
# expr=(let ((f195977 f195977) (f195978 f195978)) (begin (f195972 f195977 f195978) (foreign-call "s_exit" 1)))
# emit-tail-let
#  si   = -16
#  env  = ((f195978 . -12) (f195977 . -8) (f195972 . 4) (f195972 . -4) (f195963 . 0))
#  bindings = ((f195977 f195977) (f195978 f195978))
#  body = (begin (f195972 f195977 f195978) (foreign-call "s_exit" 1))
# emit-expr f195977
# emit-variable-ref
# env=((f195978 . -12) (f195977 . -8) (f195972 . 4) (f195972 . -4) (f195963 . 0))
# var=f195977
    movl -8(%esp), %eax  # stack load f195977
# end emit-variable-ref
    movl %eax, -16(%esp)  # stack save
# emit-expr f195978
# emit-variable-ref
# env=((f195978 . -12) (f195977 . -8) (f195972 . 4) (f195972 . -4) (f195963 . 0))
# var=f195978
    movl -12(%esp), %eax  # stack load f195978
# end emit-variable-ref
    movl %eax, -20(%esp)  # stack save
# emit-tail-expr
# si=-24
# env=((f195978 . -20) (f195977 . -16) (f195978 . -12) (f195977 . -8) (f195972 . 4) (f195972 . -4) (f195963 . 0))
# expr=(begin (f195972 f195977 f195978) (foreign-call "s_exit" 1))
# tail-begin (begin (f195972 f195977 f195978) (foreign-call "s_exit" 1))
#   env=((f195978 . -20) (f195977 . -16) (f195978 . -12) (f195977 . -8) (f195972 . 4) (f195972 . -4) (f195963 . 0))
# emit-expr (f195972 f195977 f195978)
# funcall
#    si   =-24
#    env  = ((f195978 . -20) (f195977 . -16) (f195978 . -12) (f195977 . -8) (f195972 . 4) (f195972 . -4) (f195963 . 0))
#    expr = (funcall f195972 f195977 f195978)
# emit-expr f195972
# emit-variable-ref
# env=((f195978 . -20) (f195977 . -16) (f195978 . -12) (f195977 . -8) (f195972 . 4) (f195972 . -4) (f195963 . 0))
# var=f195972
    movl 2(%edi), %eax  # frame load f195972
# end emit-variable-ref
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1431772"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1431772":
   movl %eax,  -32(%esp)  # stash funcall-oper in closure slot
# emit-expr f195977
# emit-variable-ref
# env=((f195978 . -20) (f195977 . -16) (f195978 . -12) (f195977 . -8) (f195972 . 4) (f195972 . -4) (f195963 . 0))
# var=f195977
    movl -16(%esp), %eax  # stack load f195977
# end emit-variable-ref
    mov %eax, -36(%esp)  # arg f195977
# emit-expr f195978
# emit-variable-ref
# env=((f195978 . -20) (f195977 . -16) (f195978 . -12) (f195977 . -8) (f195972 . 4) (f195972 . -4) (f195963 . 0))
# var=f195978
    movl -20(%esp), %eax  # stack load f195978
# end emit-variable-ref
    mov %eax, -40(%esp)  # arg f195978
    movl -32(%esp), %edi   # load new closure to %edi
    add $-24, %esp   # adjust base
    movl $8,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $24, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
# emit-tail-expr
# si=-24
# env=((f195978 . -20) (f195977 . -16) (f195978 . -12) (f195977 . -8) (f195972 . 4) (f195972 . -4) (f195963 . 0))
# expr=(begin (foreign-call "s_exit" 1))
# tail-begin (begin (foreign-call "s_exit" 1))
#   env=((f195978 . -20) (f195977 . -16) (f195978 . -12) (f195977 . -8) (f195972 . 4) (f195972 . -4) (f195963 . 0))
# emit-tail-expr
# si=-24
# env=((f195978 . -20) (f195977 . -16) (f195978 . -12) (f195977 . -8) (f195972 . 4) (f195972 . -4) (f195963 . 0))
# expr=(foreign-call "s_exit" 1)
    movl %ecx,-24(%esp)
    movl %esp,-28(%esp)
# emit-expr 1
    movl $4, %eax     # immed 1
    movl %eax, -32(%esp)
    leal -32(%esp),%edi
    movl %edi,%esi
    andl $-16,%esi
    movl 0(%edi),%eax
    movl %eax,0(%esi)
    movl 4(%edi),%eax
    movl %eax,4(%esi)
    movl %esi,%esp
    .extern _s_exit
    call _s_exit
    movl 4(%esi),%esp
    movl -24(%esp),%ecx
     ret
     ret   # return thru stack
    .align 4,0x90
_L_1431770:
     movl %eax, mrc_error
# == explicit-begins  ==>
# (let ((p (quote ()))) (begin (set! p (cons (quote procedure?) p)) (set! p (cons (quote cdr) p)) (set! p (cons (quote car) p)) (set! p (cons (quote symbol-value) p)) (set! p (cons (quote symbol->string) p)) (set! p (cons (quote make-symbol) p)) (set! p (cons (quote symbol?) p)) (set! p (cons (quote string-set!) p)) (set! p (cons (quote string-ref) p)) (set! p (cons (quote string-length) p)) (set! p (cons (quote string?) p)) (set! p (cons (quote make-string) p)) (set! p (cons (quote vector-ref) p)) (set! p (cons (quote vector-set!) p)) (set! p (cons (quote vector-length) p)) (set! p (cons (quote make-vector) p)) (set! p (cons (quote vector?) p)) (set! p (cons (quote set-cdr!) p)) (set! p (cons (quote set-car!) p)) (set! p (cons (quote cdr) p)) (set! p (cons (quote car) p)) (set! p (cons (quote cons) p)) (set! p (cons (quote pair?) p)) (set! p (cons (quote fxremainder) p)) (set! p (cons (quote fxquotient) p)) (set! p (cons (quote fx*) p)) (set! p (cons (quote fx-) p)) (set! p (cons (quote fx+) p)) (set! p (cons (quote fx>=) p)) (set! p (cons (quote fx>) p)) (set! p (cons (quote fx<=) p)) (set! p (cons (quote fx<) p)) (set! p (cons (quote fx=) p)) (set! p (cons (quote fxzero?) p)) (set! p (cons (quote fxsub1) p)) (set! p (cons (quote fxadd1) p)) (set! p (cons (quote fxlogor) p)) (set! p (cons (quote fxlogand) p)) (set! p (cons (quote fxlognot) p)) (set! p (cons (quote char=?) p)) (set! p (cons (quote eq?) p)) (set! p (cons (quote not) p)) (set! p (cons (quote boolean?) p)) (set! p (cons (quote fixnum?) p)) (set! p (cons (quote char?) p)) (set! p (cons (quote null?) p)) (set! p (cons (quote char->fixnum) p)) (set! p (cons (quote fixnum->char) p)) (lambda () p)))
# == eliminate-let*  ==>
# (let ((p (quote ()))) (begin (set! p (cons (quote procedure?) p)) (set! p (cons (quote cdr) p)) (set! p (cons (quote car) p)) (set! p (cons (quote symbol-value) p)) (set! p (cons (quote symbol->string) p)) (set! p (cons (quote make-symbol) p)) (set! p (cons (quote symbol?) p)) (set! p (cons (quote string-set!) p)) (set! p (cons (quote string-ref) p)) (set! p (cons (quote string-length) p)) (set! p (cons (quote string?) p)) (set! p (cons (quote make-string) p)) (set! p (cons (quote vector-ref) p)) (set! p (cons (quote vector-set!) p)) (set! p (cons (quote vector-length) p)) (set! p (cons (quote make-vector) p)) (set! p (cons (quote vector?) p)) (set! p (cons (quote set-cdr!) p)) (set! p (cons (quote set-car!) p)) (set! p (cons (quote cdr) p)) (set! p (cons (quote car) p)) (set! p (cons (quote cons) p)) (set! p (cons (quote pair?) p)) (set! p (cons (quote fxremainder) p)) (set! p (cons (quote fxquotient) p)) (set! p (cons (quote fx*) p)) (set! p (cons (quote fx-) p)) (set! p (cons (quote fx+) p)) (set! p (cons (quote fx>=) p)) (set! p (cons (quote fx>) p)) (set! p (cons (quote fx<=) p)) (set! p (cons (quote fx<) p)) (set! p (cons (quote fx=) p)) (set! p (cons (quote fxzero?) p)) (set! p (cons (quote fxsub1) p)) (set! p (cons (quote fxadd1) p)) (set! p (cons (quote fxlogor) p)) (set! p (cons (quote fxlogand) p)) (set! p (cons (quote fxlognot) p)) (set! p (cons (quote char=?) p)) (set! p (cons (quote eq?) p)) (set! p (cons (quote not) p)) (set! p (cons (quote boolean?) p)) (set! p (cons (quote fixnum?) p)) (set! p (cons (quote char?) p)) (set! p (cons (quote null?) p)) (set! p (cons (quote char->fixnum) p)) (set! p (cons (quote fixnum->char) p)) (lambda () p)))
# == uniquify-variables  ==>
# (let ((f195979 (quote ()))) (begin (set! f195979 (cons (quote procedure?) f195979)) (set! f195979 (cons (quote cdr) f195979)) (set! f195979 (cons (quote car) f195979)) (set! f195979 (cons (quote symbol-value) f195979)) (set! f195979 (cons (quote symbol->string) f195979)) (set! f195979 (cons (quote make-symbol) f195979)) (set! f195979 (cons (quote symbol?) f195979)) (set! f195979 (cons (quote string-set!) f195979)) (set! f195979 (cons (quote string-ref) f195979)) (set! f195979 (cons (quote string-length) f195979)) (set! f195979 (cons (quote string?) f195979)) (set! f195979 (cons (quote make-string) f195979)) (set! f195979 (cons (quote vector-ref) f195979)) (set! f195979 (cons (quote vector-set!) f195979)) (set! f195979 (cons (quote vector-length) f195979)) (set! f195979 (cons (quote make-vector) f195979)) (set! f195979 (cons (quote vector?) f195979)) (set! f195979 (cons (quote set-cdr!) f195979)) (set! f195979 (cons (quote set-car!) f195979)) (set! f195979 (cons (quote cdr) f195979)) (set! f195979 (cons (quote car) f195979)) (set! f195979 (cons (quote cons) f195979)) (set! f195979 (cons (quote pair?) f195979)) (set! f195979 (cons (quote fxremainder) f195979)) (set! f195979 (cons (quote fxquotient) f195979)) (set! f195979 (cons (quote fx*) f195979)) (set! f195979 (cons (quote fx-) f195979)) (set! f195979 (cons (quote fx+) f195979)) (set! f195979 (cons (quote fx>=) f195979)) (set! f195979 (cons (quote fx>) f195979)) (set! f195979 (cons (quote fx<=) f195979)) (set! f195979 (cons (quote fx<) f195979)) (set! f195979 (cons (quote fx=) f195979)) (set! f195979 (cons (quote fxzero?) f195979)) (set! f195979 (cons (quote fxsub1) f195979)) (set! f195979 (cons (quote fxadd1) f195979)) (set! f195979 (cons (quote fxlogor) f195979)) (set! f195979 (cons (quote fxlogand) f195979)) (set! f195979 (cons (quote fxlognot) f195979)) (set! f195979 (cons (quote char=?) f195979)) (set! f195979 (cons (quote eq?) f195979)) (set! f195979 (cons (quote not) f195979)) (set! f195979 (cons (quote boolean?) f195979)) (set! f195979 (cons (quote fixnum?) f195979)) (set! f195979 (cons (quote char?) f195979)) (set! f195979 (cons (quote null?) f195979)) (set! f195979 (cons (quote char->fixnum) f195979)) (set! f195979 (cons (quote fixnum->char) f195979)) (lambda () f195979)))
# == vectorize-letrec  ==>
# (let ((f195979 (quote ()))) (begin (set! f195979 (cons (quote procedure?) f195979)) (set! f195979 (cons (quote cdr) f195979)) (set! f195979 (cons (quote car) f195979)) (set! f195979 (cons (quote symbol-value) f195979)) (set! f195979 (cons (quote symbol->string) f195979)) (set! f195979 (cons (quote make-symbol) f195979)) (set! f195979 (cons (quote symbol?) f195979)) (set! f195979 (cons (quote string-set!) f195979)) (set! f195979 (cons (quote string-ref) f195979)) (set! f195979 (cons (quote string-length) f195979)) (set! f195979 (cons (quote string?) f195979)) (set! f195979 (cons (quote make-string) f195979)) (set! f195979 (cons (quote vector-ref) f195979)) (set! f195979 (cons (quote vector-set!) f195979)) (set! f195979 (cons (quote vector-length) f195979)) (set! f195979 (cons (quote make-vector) f195979)) (set! f195979 (cons (quote vector?) f195979)) (set! f195979 (cons (quote set-cdr!) f195979)) (set! f195979 (cons (quote set-car!) f195979)) (set! f195979 (cons (quote cdr) f195979)) (set! f195979 (cons (quote car) f195979)) (set! f195979 (cons (quote cons) f195979)) (set! f195979 (cons (quote pair?) f195979)) (set! f195979 (cons (quote fxremainder) f195979)) (set! f195979 (cons (quote fxquotient) f195979)) (set! f195979 (cons (quote fx*) f195979)) (set! f195979 (cons (quote fx-) f195979)) (set! f195979 (cons (quote fx+) f195979)) (set! f195979 (cons (quote fx>=) f195979)) (set! f195979 (cons (quote fx>) f195979)) (set! f195979 (cons (quote fx<=) f195979)) (set! f195979 (cons (quote fx<) f195979)) (set! f195979 (cons (quote fx=) f195979)) (set! f195979 (cons (quote fxzero?) f195979)) (set! f195979 (cons (quote fxsub1) f195979)) (set! f195979 (cons (quote fxadd1) f195979)) (set! f195979 (cons (quote fxlogor) f195979)) (set! f195979 (cons (quote fxlogand) f195979)) (set! f195979 (cons (quote fxlognot) f195979)) (set! f195979 (cons (quote char=?) f195979)) (set! f195979 (cons (quote eq?) f195979)) (set! f195979 (cons (quote not) f195979)) (set! f195979 (cons (quote boolean?) f195979)) (set! f195979 (cons (quote fixnum?) f195979)) (set! f195979 (cons (quote char?) f195979)) (set! f195979 (cons (quote null?) f195979)) (set! f195979 (cons (quote char->fixnum) f195979)) (set! f195979 (cons (quote fixnum->char) f195979)) (lambda () f195979)))
# == eliminate-set!  ==>
# (let ((f195979 (vector (quote ())))) (begin (vector-set! f195979 0 (cons (quote procedure?) (vector-ref f195979 0))) (vector-set! f195979 0 (cons (quote cdr) (vector-ref f195979 0))) (vector-set! f195979 0 (cons (quote car) (vector-ref f195979 0))) (vector-set! f195979 0 (cons (quote symbol-value) (vector-ref f195979 0))) (vector-set! f195979 0 (cons (quote symbol->string) (vector-ref f195979 0))) (vector-set! f195979 0 (cons (quote make-symbol) (vector-ref f195979 0))) (vector-set! f195979 0 (cons (quote symbol?) (vector-ref f195979 0))) (vector-set! f195979 0 (cons (quote string-set!) (vector-ref f195979 0))) (vector-set! f195979 0 (cons (quote string-ref) (vector-ref f195979 0))) (vector-set! f195979 0 (cons (quote string-length) (vector-ref f195979 0))) (vector-set! f195979 0 (cons (quote string?) (vector-ref f195979 0))) (vector-set! f195979 0 (cons (quote make-string) (vector-ref f195979 0))) (vector-set! f195979 0 (cons (quote vector-ref) (vector-ref f195979 0))) (vector-set! f195979 0 (cons (quote vector-set!) (vector-ref f195979 0))) (vector-set! f195979 0 (cons (quote vector-length) (vector-ref f195979 0))) (vector-set! f195979 0 (cons (quote make-vector) (vector-ref f195979 0))) (vector-set! f195979 0 (cons (quote vector?) (vector-ref f195979 0))) (vector-set! f195979 0 (cons (quote set-cdr!) (vector-ref f195979 0))) (vector-set! f195979 0 (cons (quote set-car!) (vector-ref f195979 0))) (vector-set! f195979 0 (cons (quote cdr) (vector-ref f195979 0))) (vector-set! f195979 0 (cons (quote car) (vector-ref f195979 0))) (vector-set! f195979 0 (cons (quote cons) (vector-ref f195979 0))) (vector-set! f195979 0 (cons (quote pair?) (vector-ref f195979 0))) (vector-set! f195979 0 (cons (quote fxremainder) (vector-ref f195979 0))) (vector-set! f195979 0 (cons (quote fxquotient) (vector-ref f195979 0))) (vector-set! f195979 0 (cons (quote fx*) (vector-ref f195979 0))) (vector-set! f195979 0 (cons (quote fx-) (vector-ref f195979 0))) (vector-set! f195979 0 (cons (quote fx+) (vector-ref f195979 0))) (vector-set! f195979 0 (cons (quote fx>=) (vector-ref f195979 0))) (vector-set! f195979 0 (cons (quote fx>) (vector-ref f195979 0))) (vector-set! f195979 0 (cons (quote fx<=) (vector-ref f195979 0))) (vector-set! f195979 0 (cons (quote fx<) (vector-ref f195979 0))) (vector-set! f195979 0 (cons (quote fx=) (vector-ref f195979 0))) (vector-set! f195979 0 (cons (quote fxzero?) (vector-ref f195979 0))) (vector-set! f195979 0 (cons (quote fxsub1) (vector-ref f195979 0))) (vector-set! f195979 0 (cons (quote fxadd1) (vector-ref f195979 0))) (vector-set! f195979 0 (cons (quote fxlogor) (vector-ref f195979 0))) (vector-set! f195979 0 (cons (quote fxlogand) (vector-ref f195979 0))) (vector-set! f195979 0 (cons (quote fxlognot) (vector-ref f195979 0))) (vector-set! f195979 0 (cons (quote char=?) (vector-ref f195979 0))) (vector-set! f195979 0 (cons (quote eq?) (vector-ref f195979 0))) (vector-set! f195979 0 (cons (quote not) (vector-ref f195979 0))) (vector-set! f195979 0 (cons (quote boolean?) (vector-ref f195979 0))) (vector-set! f195979 0 (cons (quote fixnum?) (vector-ref f195979 0))) (vector-set! f195979 0 (cons (quote char?) (vector-ref f195979 0))) (vector-set! f195979 0 (cons (quote null?) (vector-ref f195979 0))) (vector-set! f195979 0 (cons (quote char->fixnum) (vector-ref f195979 0))) (vector-set! f195979 0 (cons (quote fixnum->char) (vector-ref f195979 0))) (lambda () (let () (vector-ref f195979 0)))))
# == close-free-variables  ==>
# (let ((f195979 (vector (quote ())))) (begin (vector-set! f195979 0 (cons (quote procedure?) (vector-ref f195979 0))) (vector-set! f195979 0 (cons (quote cdr) (vector-ref f195979 0))) (vector-set! f195979 0 (cons (quote car) (vector-ref f195979 0))) (vector-set! f195979 0 (cons (quote symbol-value) (vector-ref f195979 0))) (vector-set! f195979 0 (cons (quote symbol->string) (vector-ref f195979 0))) (vector-set! f195979 0 (cons (quote make-symbol) (vector-ref f195979 0))) (vector-set! f195979 0 (cons (quote symbol?) (vector-ref f195979 0))) (vector-set! f195979 0 (cons (quote string-set!) (vector-ref f195979 0))) (vector-set! f195979 0 (cons (quote string-ref) (vector-ref f195979 0))) (vector-set! f195979 0 (cons (quote string-length) (vector-ref f195979 0))) (vector-set! f195979 0 (cons (quote string?) (vector-ref f195979 0))) (vector-set! f195979 0 (cons (quote make-string) (vector-ref f195979 0))) (vector-set! f195979 0 (cons (quote vector-ref) (vector-ref f195979 0))) (vector-set! f195979 0 (cons (quote vector-set!) (vector-ref f195979 0))) (vector-set! f195979 0 (cons (quote vector-length) (vector-ref f195979 0))) (vector-set! f195979 0 (cons (quote make-vector) (vector-ref f195979 0))) (vector-set! f195979 0 (cons (quote vector?) (vector-ref f195979 0))) (vector-set! f195979 0 (cons (quote set-cdr!) (vector-ref f195979 0))) (vector-set! f195979 0 (cons (quote set-car!) (vector-ref f195979 0))) (vector-set! f195979 0 (cons (quote cdr) (vector-ref f195979 0))) (vector-set! f195979 0 (cons (quote car) (vector-ref f195979 0))) (vector-set! f195979 0 (cons (quote cons) (vector-ref f195979 0))) (vector-set! f195979 0 (cons (quote pair?) (vector-ref f195979 0))) (vector-set! f195979 0 (cons (quote fxremainder) (vector-ref f195979 0))) (vector-set! f195979 0 (cons (quote fxquotient) (vector-ref f195979 0))) (vector-set! f195979 0 (cons (quote fx*) (vector-ref f195979 0))) (vector-set! f195979 0 (cons (quote fx-) (vector-ref f195979 0))) (vector-set! f195979 0 (cons (quote fx+) (vector-ref f195979 0))) (vector-set! f195979 0 (cons (quote fx>=) (vector-ref f195979 0))) (vector-set! f195979 0 (cons (quote fx>) (vector-ref f195979 0))) (vector-set! f195979 0 (cons (quote fx<=) (vector-ref f195979 0))) (vector-set! f195979 0 (cons (quote fx<) (vector-ref f195979 0))) (vector-set! f195979 0 (cons (quote fx=) (vector-ref f195979 0))) (vector-set! f195979 0 (cons (quote fxzero?) (vector-ref f195979 0))) (vector-set! f195979 0 (cons (quote fxsub1) (vector-ref f195979 0))) (vector-set! f195979 0 (cons (quote fxadd1) (vector-ref f195979 0))) (vector-set! f195979 0 (cons (quote fxlogor) (vector-ref f195979 0))) (vector-set! f195979 0 (cons (quote fxlogand) (vector-ref f195979 0))) (vector-set! f195979 0 (cons (quote fxlognot) (vector-ref f195979 0))) (vector-set! f195979 0 (cons (quote char=?) (vector-ref f195979 0))) (vector-set! f195979 0 (cons (quote eq?) (vector-ref f195979 0))) (vector-set! f195979 0 (cons (quote not) (vector-ref f195979 0))) (vector-set! f195979 0 (cons (quote boolean?) (vector-ref f195979 0))) (vector-set! f195979 0 (cons (quote fixnum?) (vector-ref f195979 0))) (vector-set! f195979 0 (cons (quote char?) (vector-ref f195979 0))) (vector-set! f195979 0 (cons (quote null?) (vector-ref f195979 0))) (vector-set! f195979 0 (cons (quote char->fixnum) (vector-ref f195979 0))) (vector-set! f195979 0 (cons (quote fixnum->char) (vector-ref f195979 0))) (closure () (f195979) (let () (vector-ref f195979 0)))))
# == eliminate-quote  ==>
# (let ((f195979 (vector ()))) (begin (vector-set! f195979 0 (cons (string->symbol "procedure?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons (string->symbol "cdr") (vector-ref f195979 0))) (vector-set! f195979 0 (cons (string->symbol "car") (vector-ref f195979 0))) (vector-set! f195979 0 (cons (string->symbol "symbol-value") (vector-ref f195979 0))) (vector-set! f195979 0 (cons (string->symbol "symbol->string") (vector-ref f195979 0))) (vector-set! f195979 0 (cons (string->symbol "make-symbol") (vector-ref f195979 0))) (vector-set! f195979 0 (cons (string->symbol "symbol?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons (string->symbol "string-set!") (vector-ref f195979 0))) (vector-set! f195979 0 (cons (string->symbol "string-ref") (vector-ref f195979 0))) (vector-set! f195979 0 (cons (string->symbol "string-length") (vector-ref f195979 0))) (vector-set! f195979 0 (cons (string->symbol "string?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons (string->symbol "make-string") (vector-ref f195979 0))) (vector-set! f195979 0 (cons (string->symbol "vector-ref") (vector-ref f195979 0))) (vector-set! f195979 0 (cons (string->symbol "vector-set!") (vector-ref f195979 0))) (vector-set! f195979 0 (cons (string->symbol "vector-length") (vector-ref f195979 0))) (vector-set! f195979 0 (cons (string->symbol "make-vector") (vector-ref f195979 0))) (vector-set! f195979 0 (cons (string->symbol "vector?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons (string->symbol "set-cdr!") (vector-ref f195979 0))) (vector-set! f195979 0 (cons (string->symbol "set-car!") (vector-ref f195979 0))) (vector-set! f195979 0 (cons (string->symbol "cdr") (vector-ref f195979 0))) (vector-set! f195979 0 (cons (string->symbol "car") (vector-ref f195979 0))) (vector-set! f195979 0 (cons (string->symbol "cons") (vector-ref f195979 0))) (vector-set! f195979 0 (cons (string->symbol "pair?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons (string->symbol "fxremainder") (vector-ref f195979 0))) (vector-set! f195979 0 (cons (string->symbol "fxquotient") (vector-ref f195979 0))) (vector-set! f195979 0 (cons (string->symbol "fx*") (vector-ref f195979 0))) (vector-set! f195979 0 (cons (string->symbol "fx-") (vector-ref f195979 0))) (vector-set! f195979 0 (cons (string->symbol "fx+") (vector-ref f195979 0))) (vector-set! f195979 0 (cons (string->symbol "fx>=") (vector-ref f195979 0))) (vector-set! f195979 0 (cons (string->symbol "fx>") (vector-ref f195979 0))) (vector-set! f195979 0 (cons (string->symbol "fx<=") (vector-ref f195979 0))) (vector-set! f195979 0 (cons (string->symbol "fx<") (vector-ref f195979 0))) (vector-set! f195979 0 (cons (string->symbol "fx=") (vector-ref f195979 0))) (vector-set! f195979 0 (cons (string->symbol "fxzero?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons (string->symbol "fxsub1") (vector-ref f195979 0))) (vector-set! f195979 0 (cons (string->symbol "fxadd1") (vector-ref f195979 0))) (vector-set! f195979 0 (cons (string->symbol "fxlogor") (vector-ref f195979 0))) (vector-set! f195979 0 (cons (string->symbol "fxlogand") (vector-ref f195979 0))) (vector-set! f195979 0 (cons (string->symbol "fxlognot") (vector-ref f195979 0))) (vector-set! f195979 0 (cons (string->symbol "char=?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons (string->symbol "eq?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons (string->symbol "not") (vector-ref f195979 0))) (vector-set! f195979 0 (cons (string->symbol "boolean?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons (string->symbol "fixnum?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons (string->symbol "char?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons (string->symbol "null?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons (string->symbol "char->fixnum") (vector-ref f195979 0))) (vector-set! f195979 0 (cons (string->symbol "fixnum->char") (vector-ref f195979 0))) (closure () (f195979) (let () (vector-ref f195979 0)))))
# == eliminate-when/unless  ==>
# (let ((f195979 (vector ()))) (begin (vector-set! f195979 0 (cons (string->symbol "procedure?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons (string->symbol "cdr") (vector-ref f195979 0))) (vector-set! f195979 0 (cons (string->symbol "car") (vector-ref f195979 0))) (vector-set! f195979 0 (cons (string->symbol "symbol-value") (vector-ref f195979 0))) (vector-set! f195979 0 (cons (string->symbol "symbol->string") (vector-ref f195979 0))) (vector-set! f195979 0 (cons (string->symbol "make-symbol") (vector-ref f195979 0))) (vector-set! f195979 0 (cons (string->symbol "symbol?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons (string->symbol "string-set!") (vector-ref f195979 0))) (vector-set! f195979 0 (cons (string->symbol "string-ref") (vector-ref f195979 0))) (vector-set! f195979 0 (cons (string->symbol "string-length") (vector-ref f195979 0))) (vector-set! f195979 0 (cons (string->symbol "string?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons (string->symbol "make-string") (vector-ref f195979 0))) (vector-set! f195979 0 (cons (string->symbol "vector-ref") (vector-ref f195979 0))) (vector-set! f195979 0 (cons (string->symbol "vector-set!") (vector-ref f195979 0))) (vector-set! f195979 0 (cons (string->symbol "vector-length") (vector-ref f195979 0))) (vector-set! f195979 0 (cons (string->symbol "make-vector") (vector-ref f195979 0))) (vector-set! f195979 0 (cons (string->symbol "vector?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons (string->symbol "set-cdr!") (vector-ref f195979 0))) (vector-set! f195979 0 (cons (string->symbol "set-car!") (vector-ref f195979 0))) (vector-set! f195979 0 (cons (string->symbol "cdr") (vector-ref f195979 0))) (vector-set! f195979 0 (cons (string->symbol "car") (vector-ref f195979 0))) (vector-set! f195979 0 (cons (string->symbol "cons") (vector-ref f195979 0))) (vector-set! f195979 0 (cons (string->symbol "pair?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons (string->symbol "fxremainder") (vector-ref f195979 0))) (vector-set! f195979 0 (cons (string->symbol "fxquotient") (vector-ref f195979 0))) (vector-set! f195979 0 (cons (string->symbol "fx*") (vector-ref f195979 0))) (vector-set! f195979 0 (cons (string->symbol "fx-") (vector-ref f195979 0))) (vector-set! f195979 0 (cons (string->symbol "fx+") (vector-ref f195979 0))) (vector-set! f195979 0 (cons (string->symbol "fx>=") (vector-ref f195979 0))) (vector-set! f195979 0 (cons (string->symbol "fx>") (vector-ref f195979 0))) (vector-set! f195979 0 (cons (string->symbol "fx<=") (vector-ref f195979 0))) (vector-set! f195979 0 (cons (string->symbol "fx<") (vector-ref f195979 0))) (vector-set! f195979 0 (cons (string->symbol "fx=") (vector-ref f195979 0))) (vector-set! f195979 0 (cons (string->symbol "fxzero?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons (string->symbol "fxsub1") (vector-ref f195979 0))) (vector-set! f195979 0 (cons (string->symbol "fxadd1") (vector-ref f195979 0))) (vector-set! f195979 0 (cons (string->symbol "fxlogor") (vector-ref f195979 0))) (vector-set! f195979 0 (cons (string->symbol "fxlogand") (vector-ref f195979 0))) (vector-set! f195979 0 (cons (string->symbol "fxlognot") (vector-ref f195979 0))) (vector-set! f195979 0 (cons (string->symbol "char=?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons (string->symbol "eq?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons (string->symbol "not") (vector-ref f195979 0))) (vector-set! f195979 0 (cons (string->symbol "boolean?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons (string->symbol "fixnum?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons (string->symbol "char?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons (string->symbol "null?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons (string->symbol "char->fixnum") (vector-ref f195979 0))) (vector-set! f195979 0 (cons (string->symbol "fixnum->char") (vector-ref f195979 0))) (closure () (f195979) (let () (vector-ref f195979 0)))))
# == eliminate-cond  ==>
# (let ((f195979 (vector ()))) (begin (vector-set! f195979 0 (cons (string->symbol "procedure?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons (string->symbol "cdr") (vector-ref f195979 0))) (vector-set! f195979 0 (cons (string->symbol "car") (vector-ref f195979 0))) (vector-set! f195979 0 (cons (string->symbol "symbol-value") (vector-ref f195979 0))) (vector-set! f195979 0 (cons (string->symbol "symbol->string") (vector-ref f195979 0))) (vector-set! f195979 0 (cons (string->symbol "make-symbol") (vector-ref f195979 0))) (vector-set! f195979 0 (cons (string->symbol "symbol?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons (string->symbol "string-set!") (vector-ref f195979 0))) (vector-set! f195979 0 (cons (string->symbol "string-ref") (vector-ref f195979 0))) (vector-set! f195979 0 (cons (string->symbol "string-length") (vector-ref f195979 0))) (vector-set! f195979 0 (cons (string->symbol "string?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons (string->symbol "make-string") (vector-ref f195979 0))) (vector-set! f195979 0 (cons (string->symbol "vector-ref") (vector-ref f195979 0))) (vector-set! f195979 0 (cons (string->symbol "vector-set!") (vector-ref f195979 0))) (vector-set! f195979 0 (cons (string->symbol "vector-length") (vector-ref f195979 0))) (vector-set! f195979 0 (cons (string->symbol "make-vector") (vector-ref f195979 0))) (vector-set! f195979 0 (cons (string->symbol "vector?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons (string->symbol "set-cdr!") (vector-ref f195979 0))) (vector-set! f195979 0 (cons (string->symbol "set-car!") (vector-ref f195979 0))) (vector-set! f195979 0 (cons (string->symbol "cdr") (vector-ref f195979 0))) (vector-set! f195979 0 (cons (string->symbol "car") (vector-ref f195979 0))) (vector-set! f195979 0 (cons (string->symbol "cons") (vector-ref f195979 0))) (vector-set! f195979 0 (cons (string->symbol "pair?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons (string->symbol "fxremainder") (vector-ref f195979 0))) (vector-set! f195979 0 (cons (string->symbol "fxquotient") (vector-ref f195979 0))) (vector-set! f195979 0 (cons (string->symbol "fx*") (vector-ref f195979 0))) (vector-set! f195979 0 (cons (string->symbol "fx-") (vector-ref f195979 0))) (vector-set! f195979 0 (cons (string->symbol "fx+") (vector-ref f195979 0))) (vector-set! f195979 0 (cons (string->symbol "fx>=") (vector-ref f195979 0))) (vector-set! f195979 0 (cons (string->symbol "fx>") (vector-ref f195979 0))) (vector-set! f195979 0 (cons (string->symbol "fx<=") (vector-ref f195979 0))) (vector-set! f195979 0 (cons (string->symbol "fx<") (vector-ref f195979 0))) (vector-set! f195979 0 (cons (string->symbol "fx=") (vector-ref f195979 0))) (vector-set! f195979 0 (cons (string->symbol "fxzero?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons (string->symbol "fxsub1") (vector-ref f195979 0))) (vector-set! f195979 0 (cons (string->symbol "fxadd1") (vector-ref f195979 0))) (vector-set! f195979 0 (cons (string->symbol "fxlogor") (vector-ref f195979 0))) (vector-set! f195979 0 (cons (string->symbol "fxlogand") (vector-ref f195979 0))) (vector-set! f195979 0 (cons (string->symbol "fxlognot") (vector-ref f195979 0))) (vector-set! f195979 0 (cons (string->symbol "char=?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons (string->symbol "eq?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons (string->symbol "not") (vector-ref f195979 0))) (vector-set! f195979 0 (cons (string->symbol "boolean?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons (string->symbol "fixnum?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons (string->symbol "char?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons (string->symbol "null?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons (string->symbol "char->fixnum") (vector-ref f195979 0))) (vector-set! f195979 0 (cons (string->symbol "fixnum->char") (vector-ref f195979 0))) (closure () (f195979) (let () (vector-ref f195979 0)))))
# == external-symbols  ==>
# (let ((f195979 ((primitive-ref vector) ()))) (begin (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "procedure?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "cdr") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "car") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "symbol-value") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "symbol->string") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "make-symbol") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "symbol?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "string-set!") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "string-ref") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "string-length") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "string?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "make-string") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "vector-ref") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "vector-set!") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "vector-length") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "make-vector") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "vector?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "set-cdr!") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "set-car!") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "cdr") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "car") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "cons") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "pair?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxremainder") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxquotient") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx*") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx-") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx+") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx>=") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx>") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx<=") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx<") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx=") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f195979 0))) (closure () (f195979) (let () (vector-ref f195979 0)))))
# emit-expr (let ((f195979 ((primitive-ref vector) ()))) (begin (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "procedure?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "cdr") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "car") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "symbol-value") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "symbol->string") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "make-symbol") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "symbol?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "string-set!") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "string-ref") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "string-length") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "string?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "make-string") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "vector-ref") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "vector-set!") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "vector-length") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "make-vector") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "vector?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "set-cdr!") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "set-car!") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "cdr") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "car") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "cons") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "pair?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxremainder") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxquotient") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx*") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx-") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx+") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx>=") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx>") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx<=") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx<") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx=") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f195979 0))) (closure () (f195979) (let () (vector-ref f195979 0)))))
# emit-let
#  si   = 0
#  env  = ()
#  bindings = ((f195979 ((primitive-ref vector) ())))
#  body = (begin (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "procedure?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "cdr") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "car") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "symbol-value") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "symbol->string") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "make-symbol") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "symbol?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "string-set!") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "string-ref") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "string-length") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "string?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "make-string") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "vector-ref") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "vector-set!") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "vector-length") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "make-vector") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "vector?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "set-cdr!") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "set-car!") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "cdr") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "car") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "cons") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "pair?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxremainder") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxquotient") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx*") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx-") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx+") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx>=") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx>") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx<=") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx<") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx=") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f195979 0))) (closure () (f195979) (let () (vector-ref f195979 0))))
# emit-expr ((primitive-ref vector) ())
# funcall
#    si   =0
#    env  = ()
#    expr = (funcall (primitive-ref vector) ())
# emit-expr (primitive-ref vector)
    .extern mrc_vector
    movl mrc_vector,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1431773"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1431773":
   movl %eax,  -8(%esp)  # stash funcall-oper in closure slot
# emit-expr ()
    movl $63, %eax     # immed ()
    mov %eax, -12(%esp)  # arg ()
    movl -8(%esp), %edi   # load new closure to %edi
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    movl -4(%esp), %edi   # restore closure frame ptr
    movl %eax, 0(%esp)  # stack save
# emit-expr (begin (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "procedure?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "cdr") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "car") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "symbol-value") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "symbol->string") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "make-symbol") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "symbol?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "string-set!") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "string-ref") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "string-length") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "string?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "make-string") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "vector-ref") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "vector-set!") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "vector-length") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "make-vector") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "vector?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "set-cdr!") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "set-car!") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "cdr") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "car") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "cons") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "pair?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxremainder") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxquotient") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx*") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx-") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx+") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx>=") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx>") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx<=") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx<") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx=") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f195979 0))) (closure () (f195979) (let () (vector-ref f195979 0))))
# emit-begin
#   expr=(begin (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "procedure?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "cdr") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "car") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "symbol-value") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "symbol->string") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "make-symbol") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "symbol?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "string-set!") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "string-ref") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "string-length") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "string?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "make-string") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "vector-ref") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "vector-set!") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "vector-length") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "make-vector") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "vector?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "set-cdr!") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "set-car!") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "cdr") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "car") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "cons") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "pair?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxremainder") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxquotient") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx*") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx-") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx+") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx>=") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx>") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx<=") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx<") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx=") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f195979 0))) (closure () (f195979) (let () (vector-ref f195979 0))))
#   env=((f195979 . 0))
# emit-expr (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "procedure?") (vector-ref f195979 0)))
# emit-expr f195979
# emit-variable-ref
# env=((f195979 . 0))
# var=f195979
    movl 0(%esp), %eax  # stack load f195979
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1431774
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1431774:
    movl %eax, -4(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1431775"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1431775:
# check bounds on vector index
    movl -4(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1431777
    cmp  $0,%eax
    jge _L_1431776
_L_1431777:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1431776:
    movl %eax, -8(%esp)
# emit-expr (cons ((primitive-ref string->symbol) "procedure?") (vector-ref f195979 0))
# cons arg1=((primitive-ref string->symbol) "procedure?") arg2=(vector-ref f195979 0)
# emit-expr ((primitive-ref string->symbol) "procedure?")
# funcall
#    si   =-12
#    env  = ((f195979 . 0))
#    expr = (funcall (primitive-ref string->symbol) "procedure?")
# emit-expr (primitive-ref string->symbol)
    .extern mrc_string$m$gsymbol
    movl mrc_string$m$gsymbol,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1431778"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1431778":
   movl %eax,  -20(%esp)  # stash funcall-oper in closure slot
# emit-expr "procedure?"
# string literal
    jmp _L_1431780
    .align 8,0x90
_L_1431779 :
    .int 40
    .ascii "procedure?"
_L_1431780:
    movl $_L_1431779, %eax
    orl $6, %eax
    mov %eax, -24(%esp)  # arg procedure?
    movl -20(%esp), %edi   # load new closure to %edi
    add $-12, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $12, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    movl %eax, -12(%esp)
# emit-expr (vector-ref f195979 0)
# emit-expr f195979
# emit-variable-ref
# env=((f195979 . 0))
# var=f195979
    movl 0(%esp), %eax  # stack load f195979
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1431781
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1431781:
    movl %eax, -16(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1431782"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1431782:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1431784
    cmp  $0,%eax
    jge _L_1431783
_L_1431784:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1431783:
    movl -16(%esp), %esi
    movl -1(%eax,%esi), %eax
    movl %eax, 4(%ebp)
    movl -12(%esp), %eax
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    or   $1, %al
    add  $8, %ebp
# cons end
    movl -4(%esp), %ebx
    movl -8(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "cdr") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "car") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "symbol-value") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "symbol->string") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "make-symbol") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "symbol?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "string-set!") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "string-ref") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "string-length") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "string?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "make-string") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "vector-ref") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "vector-set!") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "vector-length") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "make-vector") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "vector?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "set-cdr!") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "set-car!") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "cdr") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "car") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "cons") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "pair?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxremainder") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxquotient") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx*") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx-") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx+") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx>=") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx>") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx<=") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx<") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx=") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f195979 0))) (closure () (f195979) (let () (vector-ref f195979 0))))
# emit-begin
#   expr=(begin (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "cdr") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "car") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "symbol-value") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "symbol->string") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "make-symbol") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "symbol?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "string-set!") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "string-ref") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "string-length") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "string?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "make-string") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "vector-ref") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "vector-set!") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "vector-length") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "make-vector") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "vector?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "set-cdr!") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "set-car!") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "cdr") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "car") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "cons") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "pair?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxremainder") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxquotient") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx*") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx-") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx+") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx>=") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx>") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx<=") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx<") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx=") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f195979 0))) (closure () (f195979) (let () (vector-ref f195979 0))))
#   env=((f195979 . 0))
# emit-expr (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "cdr") (vector-ref f195979 0)))
# emit-expr f195979
# emit-variable-ref
# env=((f195979 . 0))
# var=f195979
    movl 0(%esp), %eax  # stack load f195979
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1431785
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1431785:
    movl %eax, -4(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1431786"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1431786:
# check bounds on vector index
    movl -4(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1431788
    cmp  $0,%eax
    jge _L_1431787
_L_1431788:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1431787:
    movl %eax, -8(%esp)
# emit-expr (cons ((primitive-ref string->symbol) "cdr") (vector-ref f195979 0))
# cons arg1=((primitive-ref string->symbol) "cdr") arg2=(vector-ref f195979 0)
# emit-expr ((primitive-ref string->symbol) "cdr")
# funcall
#    si   =-12
#    env  = ((f195979 . 0))
#    expr = (funcall (primitive-ref string->symbol) "cdr")
# emit-expr (primitive-ref string->symbol)
    .extern mrc_string$m$gsymbol
    movl mrc_string$m$gsymbol,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1431789"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1431789":
   movl %eax,  -20(%esp)  # stash funcall-oper in closure slot
# emit-expr "cdr"
# string literal
    jmp _L_1431791
    .align 8,0x90
_L_1431790 :
    .int 12
    .ascii "cdr"
_L_1431791:
    movl $_L_1431790, %eax
    orl $6, %eax
    mov %eax, -24(%esp)  # arg cdr
    movl -20(%esp), %edi   # load new closure to %edi
    add $-12, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $12, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    movl %eax, -12(%esp)
# emit-expr (vector-ref f195979 0)
# emit-expr f195979
# emit-variable-ref
# env=((f195979 . 0))
# var=f195979
    movl 0(%esp), %eax  # stack load f195979
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1431792
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1431792:
    movl %eax, -16(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1431793"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1431793:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1431795
    cmp  $0,%eax
    jge _L_1431794
_L_1431795:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1431794:
    movl -16(%esp), %esi
    movl -1(%eax,%esi), %eax
    movl %eax, 4(%ebp)
    movl -12(%esp), %eax
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    or   $1, %al
    add  $8, %ebp
# cons end
    movl -4(%esp), %ebx
    movl -8(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "car") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "symbol-value") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "symbol->string") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "make-symbol") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "symbol?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "string-set!") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "string-ref") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "string-length") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "string?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "make-string") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "vector-ref") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "vector-set!") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "vector-length") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "make-vector") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "vector?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "set-cdr!") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "set-car!") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "cdr") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "car") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "cons") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "pair?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxremainder") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxquotient") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx*") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx-") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx+") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx>=") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx>") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx<=") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx<") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx=") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f195979 0))) (closure () (f195979) (let () (vector-ref f195979 0))))
# emit-begin
#   expr=(begin (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "car") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "symbol-value") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "symbol->string") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "make-symbol") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "symbol?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "string-set!") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "string-ref") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "string-length") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "string?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "make-string") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "vector-ref") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "vector-set!") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "vector-length") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "make-vector") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "vector?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "set-cdr!") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "set-car!") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "cdr") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "car") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "cons") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "pair?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxremainder") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxquotient") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx*") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx-") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx+") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx>=") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx>") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx<=") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx<") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx=") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f195979 0))) (closure () (f195979) (let () (vector-ref f195979 0))))
#   env=((f195979 . 0))
# emit-expr (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "car") (vector-ref f195979 0)))
# emit-expr f195979
# emit-variable-ref
# env=((f195979 . 0))
# var=f195979
    movl 0(%esp), %eax  # stack load f195979
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1431796
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1431796:
    movl %eax, -4(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1431797"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1431797:
# check bounds on vector index
    movl -4(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1431799
    cmp  $0,%eax
    jge _L_1431798
_L_1431799:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1431798:
    movl %eax, -8(%esp)
# emit-expr (cons ((primitive-ref string->symbol) "car") (vector-ref f195979 0))
# cons arg1=((primitive-ref string->symbol) "car") arg2=(vector-ref f195979 0)
# emit-expr ((primitive-ref string->symbol) "car")
# funcall
#    si   =-12
#    env  = ((f195979 . 0))
#    expr = (funcall (primitive-ref string->symbol) "car")
# emit-expr (primitive-ref string->symbol)
    .extern mrc_string$m$gsymbol
    movl mrc_string$m$gsymbol,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1431800"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1431800":
   movl %eax,  -20(%esp)  # stash funcall-oper in closure slot
# emit-expr "car"
# string literal
    jmp _L_1431802
    .align 8,0x90
_L_1431801 :
    .int 12
    .ascii "car"
_L_1431802:
    movl $_L_1431801, %eax
    orl $6, %eax
    mov %eax, -24(%esp)  # arg car
    movl -20(%esp), %edi   # load new closure to %edi
    add $-12, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $12, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    movl %eax, -12(%esp)
# emit-expr (vector-ref f195979 0)
# emit-expr f195979
# emit-variable-ref
# env=((f195979 . 0))
# var=f195979
    movl 0(%esp), %eax  # stack load f195979
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1431803
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1431803:
    movl %eax, -16(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1431804"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1431804:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1431806
    cmp  $0,%eax
    jge _L_1431805
_L_1431806:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1431805:
    movl -16(%esp), %esi
    movl -1(%eax,%esi), %eax
    movl %eax, 4(%ebp)
    movl -12(%esp), %eax
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    or   $1, %al
    add  $8, %ebp
# cons end
    movl -4(%esp), %ebx
    movl -8(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "symbol-value") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "symbol->string") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "make-symbol") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "symbol?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "string-set!") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "string-ref") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "string-length") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "string?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "make-string") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "vector-ref") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "vector-set!") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "vector-length") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "make-vector") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "vector?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "set-cdr!") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "set-car!") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "cdr") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "car") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "cons") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "pair?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxremainder") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxquotient") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx*") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx-") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx+") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx>=") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx>") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx<=") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx<") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx=") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f195979 0))) (closure () (f195979) (let () (vector-ref f195979 0))))
# emit-begin
#   expr=(begin (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "symbol-value") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "symbol->string") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "make-symbol") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "symbol?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "string-set!") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "string-ref") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "string-length") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "string?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "make-string") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "vector-ref") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "vector-set!") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "vector-length") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "make-vector") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "vector?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "set-cdr!") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "set-car!") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "cdr") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "car") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "cons") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "pair?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxremainder") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxquotient") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx*") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx-") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx+") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx>=") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx>") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx<=") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx<") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx=") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f195979 0))) (closure () (f195979) (let () (vector-ref f195979 0))))
#   env=((f195979 . 0))
# emit-expr (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "symbol-value") (vector-ref f195979 0)))
# emit-expr f195979
# emit-variable-ref
# env=((f195979 . 0))
# var=f195979
    movl 0(%esp), %eax  # stack load f195979
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1431807
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1431807:
    movl %eax, -4(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1431808"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1431808:
# check bounds on vector index
    movl -4(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1431810
    cmp  $0,%eax
    jge _L_1431809
_L_1431810:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1431809:
    movl %eax, -8(%esp)
# emit-expr (cons ((primitive-ref string->symbol) "symbol-value") (vector-ref f195979 0))
# cons arg1=((primitive-ref string->symbol) "symbol-value") arg2=(vector-ref f195979 0)
# emit-expr ((primitive-ref string->symbol) "symbol-value")
# funcall
#    si   =-12
#    env  = ((f195979 . 0))
#    expr = (funcall (primitive-ref string->symbol) "symbol-value")
# emit-expr (primitive-ref string->symbol)
    .extern mrc_string$m$gsymbol
    movl mrc_string$m$gsymbol,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1431811"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1431811":
   movl %eax,  -20(%esp)  # stash funcall-oper in closure slot
# emit-expr "symbol-value"
# string literal
    jmp _L_1431813
    .align 8,0x90
_L_1431812 :
    .int 48
    .ascii "symbol-value"
_L_1431813:
    movl $_L_1431812, %eax
    orl $6, %eax
    mov %eax, -24(%esp)  # arg symbol-value
    movl -20(%esp), %edi   # load new closure to %edi
    add $-12, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $12, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    movl %eax, -12(%esp)
# emit-expr (vector-ref f195979 0)
# emit-expr f195979
# emit-variable-ref
# env=((f195979 . 0))
# var=f195979
    movl 0(%esp), %eax  # stack load f195979
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1431814
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1431814:
    movl %eax, -16(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1431815"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1431815:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1431817
    cmp  $0,%eax
    jge _L_1431816
_L_1431817:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1431816:
    movl -16(%esp), %esi
    movl -1(%eax,%esi), %eax
    movl %eax, 4(%ebp)
    movl -12(%esp), %eax
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    or   $1, %al
    add  $8, %ebp
# cons end
    movl -4(%esp), %ebx
    movl -8(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "symbol->string") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "make-symbol") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "symbol?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "string-set!") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "string-ref") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "string-length") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "string?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "make-string") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "vector-ref") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "vector-set!") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "vector-length") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "make-vector") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "vector?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "set-cdr!") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "set-car!") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "cdr") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "car") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "cons") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "pair?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxremainder") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxquotient") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx*") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx-") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx+") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx>=") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx>") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx<=") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx<") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx=") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f195979 0))) (closure () (f195979) (let () (vector-ref f195979 0))))
# emit-begin
#   expr=(begin (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "symbol->string") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "make-symbol") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "symbol?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "string-set!") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "string-ref") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "string-length") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "string?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "make-string") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "vector-ref") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "vector-set!") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "vector-length") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "make-vector") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "vector?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "set-cdr!") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "set-car!") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "cdr") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "car") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "cons") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "pair?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxremainder") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxquotient") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx*") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx-") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx+") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx>=") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx>") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx<=") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx<") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx=") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f195979 0))) (closure () (f195979) (let () (vector-ref f195979 0))))
#   env=((f195979 . 0))
# emit-expr (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "symbol->string") (vector-ref f195979 0)))
# emit-expr f195979
# emit-variable-ref
# env=((f195979 . 0))
# var=f195979
    movl 0(%esp), %eax  # stack load f195979
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1431818
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1431818:
    movl %eax, -4(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1431819"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1431819:
# check bounds on vector index
    movl -4(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1431821
    cmp  $0,%eax
    jge _L_1431820
_L_1431821:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1431820:
    movl %eax, -8(%esp)
# emit-expr (cons ((primitive-ref string->symbol) "symbol->string") (vector-ref f195979 0))
# cons arg1=((primitive-ref string->symbol) "symbol->string") arg2=(vector-ref f195979 0)
# emit-expr ((primitive-ref string->symbol) "symbol->string")
# funcall
#    si   =-12
#    env  = ((f195979 . 0))
#    expr = (funcall (primitive-ref string->symbol) "symbol->string")
# emit-expr (primitive-ref string->symbol)
    .extern mrc_string$m$gsymbol
    movl mrc_string$m$gsymbol,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1431822"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1431822":
   movl %eax,  -20(%esp)  # stash funcall-oper in closure slot
# emit-expr "symbol->string"
# string literal
    jmp _L_1431824
    .align 8,0x90
_L_1431823 :
    .int 56
    .ascii "symbol->string"
_L_1431824:
    movl $_L_1431823, %eax
    orl $6, %eax
    mov %eax, -24(%esp)  # arg symbol->string
    movl -20(%esp), %edi   # load new closure to %edi
    add $-12, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $12, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    movl %eax, -12(%esp)
# emit-expr (vector-ref f195979 0)
# emit-expr f195979
# emit-variable-ref
# env=((f195979 . 0))
# var=f195979
    movl 0(%esp), %eax  # stack load f195979
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1431825
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1431825:
    movl %eax, -16(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1431826"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1431826:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1431828
    cmp  $0,%eax
    jge _L_1431827
_L_1431828:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1431827:
    movl -16(%esp), %esi
    movl -1(%eax,%esi), %eax
    movl %eax, 4(%ebp)
    movl -12(%esp), %eax
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    or   $1, %al
    add  $8, %ebp
# cons end
    movl -4(%esp), %ebx
    movl -8(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "make-symbol") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "symbol?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "string-set!") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "string-ref") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "string-length") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "string?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "make-string") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "vector-ref") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "vector-set!") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "vector-length") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "make-vector") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "vector?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "set-cdr!") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "set-car!") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "cdr") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "car") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "cons") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "pair?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxremainder") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxquotient") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx*") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx-") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx+") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx>=") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx>") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx<=") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx<") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx=") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f195979 0))) (closure () (f195979) (let () (vector-ref f195979 0))))
# emit-begin
#   expr=(begin (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "make-symbol") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "symbol?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "string-set!") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "string-ref") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "string-length") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "string?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "make-string") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "vector-ref") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "vector-set!") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "vector-length") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "make-vector") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "vector?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "set-cdr!") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "set-car!") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "cdr") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "car") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "cons") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "pair?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxremainder") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxquotient") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx*") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx-") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx+") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx>=") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx>") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx<=") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx<") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx=") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f195979 0))) (closure () (f195979) (let () (vector-ref f195979 0))))
#   env=((f195979 . 0))
# emit-expr (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "make-symbol") (vector-ref f195979 0)))
# emit-expr f195979
# emit-variable-ref
# env=((f195979 . 0))
# var=f195979
    movl 0(%esp), %eax  # stack load f195979
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1431829
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1431829:
    movl %eax, -4(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1431830"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1431830:
# check bounds on vector index
    movl -4(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1431832
    cmp  $0,%eax
    jge _L_1431831
_L_1431832:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1431831:
    movl %eax, -8(%esp)
# emit-expr (cons ((primitive-ref string->symbol) "make-symbol") (vector-ref f195979 0))
# cons arg1=((primitive-ref string->symbol) "make-symbol") arg2=(vector-ref f195979 0)
# emit-expr ((primitive-ref string->symbol) "make-symbol")
# funcall
#    si   =-12
#    env  = ((f195979 . 0))
#    expr = (funcall (primitive-ref string->symbol) "make-symbol")
# emit-expr (primitive-ref string->symbol)
    .extern mrc_string$m$gsymbol
    movl mrc_string$m$gsymbol,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1431833"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1431833":
   movl %eax,  -20(%esp)  # stash funcall-oper in closure slot
# emit-expr "make-symbol"
# string literal
    jmp _L_1431835
    .align 8,0x90
_L_1431834 :
    .int 44
    .ascii "make-symbol"
_L_1431835:
    movl $_L_1431834, %eax
    orl $6, %eax
    mov %eax, -24(%esp)  # arg make-symbol
    movl -20(%esp), %edi   # load new closure to %edi
    add $-12, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $12, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    movl %eax, -12(%esp)
# emit-expr (vector-ref f195979 0)
# emit-expr f195979
# emit-variable-ref
# env=((f195979 . 0))
# var=f195979
    movl 0(%esp), %eax  # stack load f195979
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1431836
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1431836:
    movl %eax, -16(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1431837"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1431837:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1431839
    cmp  $0,%eax
    jge _L_1431838
_L_1431839:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1431838:
    movl -16(%esp), %esi
    movl -1(%eax,%esi), %eax
    movl %eax, 4(%ebp)
    movl -12(%esp), %eax
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    or   $1, %al
    add  $8, %ebp
# cons end
    movl -4(%esp), %ebx
    movl -8(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "symbol?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "string-set!") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "string-ref") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "string-length") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "string?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "make-string") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "vector-ref") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "vector-set!") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "vector-length") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "make-vector") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "vector?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "set-cdr!") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "set-car!") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "cdr") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "car") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "cons") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "pair?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxremainder") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxquotient") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx*") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx-") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx+") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx>=") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx>") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx<=") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx<") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx=") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f195979 0))) (closure () (f195979) (let () (vector-ref f195979 0))))
# emit-begin
#   expr=(begin (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "symbol?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "string-set!") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "string-ref") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "string-length") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "string?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "make-string") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "vector-ref") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "vector-set!") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "vector-length") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "make-vector") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "vector?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "set-cdr!") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "set-car!") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "cdr") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "car") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "cons") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "pair?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxremainder") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxquotient") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx*") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx-") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx+") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx>=") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx>") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx<=") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx<") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx=") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f195979 0))) (closure () (f195979) (let () (vector-ref f195979 0))))
#   env=((f195979 . 0))
# emit-expr (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "symbol?") (vector-ref f195979 0)))
# emit-expr f195979
# emit-variable-ref
# env=((f195979 . 0))
# var=f195979
    movl 0(%esp), %eax  # stack load f195979
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1431840
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1431840:
    movl %eax, -4(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1431841"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1431841:
# check bounds on vector index
    movl -4(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1431843
    cmp  $0,%eax
    jge _L_1431842
_L_1431843:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1431842:
    movl %eax, -8(%esp)
# emit-expr (cons ((primitive-ref string->symbol) "symbol?") (vector-ref f195979 0))
# cons arg1=((primitive-ref string->symbol) "symbol?") arg2=(vector-ref f195979 0)
# emit-expr ((primitive-ref string->symbol) "symbol?")
# funcall
#    si   =-12
#    env  = ((f195979 . 0))
#    expr = (funcall (primitive-ref string->symbol) "symbol?")
# emit-expr (primitive-ref string->symbol)
    .extern mrc_string$m$gsymbol
    movl mrc_string$m$gsymbol,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1431844"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1431844":
   movl %eax,  -20(%esp)  # stash funcall-oper in closure slot
# emit-expr "symbol?"
# string literal
    jmp _L_1431846
    .align 8,0x90
_L_1431845 :
    .int 28
    .ascii "symbol?"
_L_1431846:
    movl $_L_1431845, %eax
    orl $6, %eax
    mov %eax, -24(%esp)  # arg symbol?
    movl -20(%esp), %edi   # load new closure to %edi
    add $-12, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $12, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    movl %eax, -12(%esp)
# emit-expr (vector-ref f195979 0)
# emit-expr f195979
# emit-variable-ref
# env=((f195979 . 0))
# var=f195979
    movl 0(%esp), %eax  # stack load f195979
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1431847
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1431847:
    movl %eax, -16(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1431848"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1431848:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1431850
    cmp  $0,%eax
    jge _L_1431849
_L_1431850:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1431849:
    movl -16(%esp), %esi
    movl -1(%eax,%esi), %eax
    movl %eax, 4(%ebp)
    movl -12(%esp), %eax
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    or   $1, %al
    add  $8, %ebp
# cons end
    movl -4(%esp), %ebx
    movl -8(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "string-set!") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "string-ref") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "string-length") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "string?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "make-string") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "vector-ref") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "vector-set!") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "vector-length") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "make-vector") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "vector?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "set-cdr!") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "set-car!") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "cdr") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "car") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "cons") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "pair?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxremainder") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxquotient") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx*") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx-") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx+") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx>=") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx>") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx<=") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx<") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx=") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f195979 0))) (closure () (f195979) (let () (vector-ref f195979 0))))
# emit-begin
#   expr=(begin (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "string-set!") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "string-ref") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "string-length") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "string?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "make-string") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "vector-ref") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "vector-set!") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "vector-length") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "make-vector") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "vector?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "set-cdr!") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "set-car!") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "cdr") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "car") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "cons") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "pair?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxremainder") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxquotient") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx*") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx-") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx+") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx>=") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx>") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx<=") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx<") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx=") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f195979 0))) (closure () (f195979) (let () (vector-ref f195979 0))))
#   env=((f195979 . 0))
# emit-expr (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "string-set!") (vector-ref f195979 0)))
# emit-expr f195979
# emit-variable-ref
# env=((f195979 . 0))
# var=f195979
    movl 0(%esp), %eax  # stack load f195979
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1431851
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1431851:
    movl %eax, -4(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1431852"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1431852:
# check bounds on vector index
    movl -4(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1431854
    cmp  $0,%eax
    jge _L_1431853
_L_1431854:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1431853:
    movl %eax, -8(%esp)
# emit-expr (cons ((primitive-ref string->symbol) "string-set!") (vector-ref f195979 0))
# cons arg1=((primitive-ref string->symbol) "string-set!") arg2=(vector-ref f195979 0)
# emit-expr ((primitive-ref string->symbol) "string-set!")
# funcall
#    si   =-12
#    env  = ((f195979 . 0))
#    expr = (funcall (primitive-ref string->symbol) "string-set!")
# emit-expr (primitive-ref string->symbol)
    .extern mrc_string$m$gsymbol
    movl mrc_string$m$gsymbol,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1431855"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1431855":
   movl %eax,  -20(%esp)  # stash funcall-oper in closure slot
# emit-expr "string-set!"
# string literal
    jmp _L_1431857
    .align 8,0x90
_L_1431856 :
    .int 44
    .ascii "string-set!"
_L_1431857:
    movl $_L_1431856, %eax
    orl $6, %eax
    mov %eax, -24(%esp)  # arg string-set!
    movl -20(%esp), %edi   # load new closure to %edi
    add $-12, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $12, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    movl %eax, -12(%esp)
# emit-expr (vector-ref f195979 0)
# emit-expr f195979
# emit-variable-ref
# env=((f195979 . 0))
# var=f195979
    movl 0(%esp), %eax  # stack load f195979
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1431858
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1431858:
    movl %eax, -16(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1431859"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1431859:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1431861
    cmp  $0,%eax
    jge _L_1431860
_L_1431861:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1431860:
    movl -16(%esp), %esi
    movl -1(%eax,%esi), %eax
    movl %eax, 4(%ebp)
    movl -12(%esp), %eax
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    or   $1, %al
    add  $8, %ebp
# cons end
    movl -4(%esp), %ebx
    movl -8(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "string-ref") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "string-length") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "string?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "make-string") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "vector-ref") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "vector-set!") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "vector-length") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "make-vector") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "vector?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "set-cdr!") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "set-car!") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "cdr") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "car") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "cons") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "pair?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxremainder") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxquotient") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx*") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx-") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx+") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx>=") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx>") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx<=") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx<") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx=") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f195979 0))) (closure () (f195979) (let () (vector-ref f195979 0))))
# emit-begin
#   expr=(begin (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "string-ref") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "string-length") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "string?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "make-string") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "vector-ref") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "vector-set!") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "vector-length") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "make-vector") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "vector?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "set-cdr!") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "set-car!") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "cdr") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "car") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "cons") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "pair?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxremainder") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxquotient") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx*") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx-") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx+") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx>=") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx>") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx<=") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx<") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx=") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f195979 0))) (closure () (f195979) (let () (vector-ref f195979 0))))
#   env=((f195979 . 0))
# emit-expr (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "string-ref") (vector-ref f195979 0)))
# emit-expr f195979
# emit-variable-ref
# env=((f195979 . 0))
# var=f195979
    movl 0(%esp), %eax  # stack load f195979
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1431862
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1431862:
    movl %eax, -4(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1431863"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1431863:
# check bounds on vector index
    movl -4(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1431865
    cmp  $0,%eax
    jge _L_1431864
_L_1431865:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1431864:
    movl %eax, -8(%esp)
# emit-expr (cons ((primitive-ref string->symbol) "string-ref") (vector-ref f195979 0))
# cons arg1=((primitive-ref string->symbol) "string-ref") arg2=(vector-ref f195979 0)
# emit-expr ((primitive-ref string->symbol) "string-ref")
# funcall
#    si   =-12
#    env  = ((f195979 . 0))
#    expr = (funcall (primitive-ref string->symbol) "string-ref")
# emit-expr (primitive-ref string->symbol)
    .extern mrc_string$m$gsymbol
    movl mrc_string$m$gsymbol,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1431866"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1431866":
   movl %eax,  -20(%esp)  # stash funcall-oper in closure slot
# emit-expr "string-ref"
# string literal
    jmp _L_1431868
    .align 8,0x90
_L_1431867 :
    .int 40
    .ascii "string-ref"
_L_1431868:
    movl $_L_1431867, %eax
    orl $6, %eax
    mov %eax, -24(%esp)  # arg string-ref
    movl -20(%esp), %edi   # load new closure to %edi
    add $-12, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $12, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    movl %eax, -12(%esp)
# emit-expr (vector-ref f195979 0)
# emit-expr f195979
# emit-variable-ref
# env=((f195979 . 0))
# var=f195979
    movl 0(%esp), %eax  # stack load f195979
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1431869
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1431869:
    movl %eax, -16(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1431870"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1431870:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1431872
    cmp  $0,%eax
    jge _L_1431871
_L_1431872:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1431871:
    movl -16(%esp), %esi
    movl -1(%eax,%esi), %eax
    movl %eax, 4(%ebp)
    movl -12(%esp), %eax
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    or   $1, %al
    add  $8, %ebp
# cons end
    movl -4(%esp), %ebx
    movl -8(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "string-length") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "string?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "make-string") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "vector-ref") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "vector-set!") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "vector-length") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "make-vector") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "vector?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "set-cdr!") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "set-car!") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "cdr") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "car") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "cons") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "pair?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxremainder") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxquotient") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx*") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx-") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx+") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx>=") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx>") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx<=") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx<") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx=") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f195979 0))) (closure () (f195979) (let () (vector-ref f195979 0))))
# emit-begin
#   expr=(begin (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "string-length") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "string?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "make-string") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "vector-ref") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "vector-set!") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "vector-length") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "make-vector") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "vector?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "set-cdr!") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "set-car!") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "cdr") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "car") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "cons") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "pair?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxremainder") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxquotient") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx*") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx-") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx+") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx>=") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx>") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx<=") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx<") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx=") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f195979 0))) (closure () (f195979) (let () (vector-ref f195979 0))))
#   env=((f195979 . 0))
# emit-expr (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "string-length") (vector-ref f195979 0)))
# emit-expr f195979
# emit-variable-ref
# env=((f195979 . 0))
# var=f195979
    movl 0(%esp), %eax  # stack load f195979
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1431873
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1431873:
    movl %eax, -4(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1431874"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1431874:
# check bounds on vector index
    movl -4(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1431876
    cmp  $0,%eax
    jge _L_1431875
_L_1431876:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1431875:
    movl %eax, -8(%esp)
# emit-expr (cons ((primitive-ref string->symbol) "string-length") (vector-ref f195979 0))
# cons arg1=((primitive-ref string->symbol) "string-length") arg2=(vector-ref f195979 0)
# emit-expr ((primitive-ref string->symbol) "string-length")
# funcall
#    si   =-12
#    env  = ((f195979 . 0))
#    expr = (funcall (primitive-ref string->symbol) "string-length")
# emit-expr (primitive-ref string->symbol)
    .extern mrc_string$m$gsymbol
    movl mrc_string$m$gsymbol,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1431877"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1431877":
   movl %eax,  -20(%esp)  # stash funcall-oper in closure slot
# emit-expr "string-length"
# string literal
    jmp _L_1431879
    .align 8,0x90
_L_1431878 :
    .int 52
    .ascii "string-length"
_L_1431879:
    movl $_L_1431878, %eax
    orl $6, %eax
    mov %eax, -24(%esp)  # arg string-length
    movl -20(%esp), %edi   # load new closure to %edi
    add $-12, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $12, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    movl %eax, -12(%esp)
# emit-expr (vector-ref f195979 0)
# emit-expr f195979
# emit-variable-ref
# env=((f195979 . 0))
# var=f195979
    movl 0(%esp), %eax  # stack load f195979
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1431880
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1431880:
    movl %eax, -16(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1431881"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1431881:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1431883
    cmp  $0,%eax
    jge _L_1431882
_L_1431883:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1431882:
    movl -16(%esp), %esi
    movl -1(%eax,%esi), %eax
    movl %eax, 4(%ebp)
    movl -12(%esp), %eax
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    or   $1, %al
    add  $8, %ebp
# cons end
    movl -4(%esp), %ebx
    movl -8(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "string?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "make-string") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "vector-ref") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "vector-set!") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "vector-length") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "make-vector") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "vector?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "set-cdr!") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "set-car!") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "cdr") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "car") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "cons") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "pair?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxremainder") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxquotient") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx*") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx-") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx+") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx>=") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx>") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx<=") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx<") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx=") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f195979 0))) (closure () (f195979) (let () (vector-ref f195979 0))))
# emit-begin
#   expr=(begin (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "string?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "make-string") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "vector-ref") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "vector-set!") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "vector-length") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "make-vector") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "vector?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "set-cdr!") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "set-car!") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "cdr") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "car") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "cons") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "pair?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxremainder") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxquotient") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx*") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx-") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx+") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx>=") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx>") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx<=") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx<") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx=") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f195979 0))) (closure () (f195979) (let () (vector-ref f195979 0))))
#   env=((f195979 . 0))
# emit-expr (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "string?") (vector-ref f195979 0)))
# emit-expr f195979
# emit-variable-ref
# env=((f195979 . 0))
# var=f195979
    movl 0(%esp), %eax  # stack load f195979
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1431884
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1431884:
    movl %eax, -4(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1431885"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1431885:
# check bounds on vector index
    movl -4(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1431887
    cmp  $0,%eax
    jge _L_1431886
_L_1431887:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1431886:
    movl %eax, -8(%esp)
# emit-expr (cons ((primitive-ref string->symbol) "string?") (vector-ref f195979 0))
# cons arg1=((primitive-ref string->symbol) "string?") arg2=(vector-ref f195979 0)
# emit-expr ((primitive-ref string->symbol) "string?")
# funcall
#    si   =-12
#    env  = ((f195979 . 0))
#    expr = (funcall (primitive-ref string->symbol) "string?")
# emit-expr (primitive-ref string->symbol)
    .extern mrc_string$m$gsymbol
    movl mrc_string$m$gsymbol,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1431888"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1431888":
   movl %eax,  -20(%esp)  # stash funcall-oper in closure slot
# emit-expr "string?"
# string literal
    jmp _L_1431890
    .align 8,0x90
_L_1431889 :
    .int 28
    .ascii "string?"
_L_1431890:
    movl $_L_1431889, %eax
    orl $6, %eax
    mov %eax, -24(%esp)  # arg string?
    movl -20(%esp), %edi   # load new closure to %edi
    add $-12, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $12, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    movl %eax, -12(%esp)
# emit-expr (vector-ref f195979 0)
# emit-expr f195979
# emit-variable-ref
# env=((f195979 . 0))
# var=f195979
    movl 0(%esp), %eax  # stack load f195979
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1431891
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1431891:
    movl %eax, -16(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1431892"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1431892:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1431894
    cmp  $0,%eax
    jge _L_1431893
_L_1431894:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1431893:
    movl -16(%esp), %esi
    movl -1(%eax,%esi), %eax
    movl %eax, 4(%ebp)
    movl -12(%esp), %eax
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    or   $1, %al
    add  $8, %ebp
# cons end
    movl -4(%esp), %ebx
    movl -8(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "make-string") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "vector-ref") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "vector-set!") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "vector-length") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "make-vector") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "vector?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "set-cdr!") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "set-car!") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "cdr") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "car") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "cons") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "pair?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxremainder") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxquotient") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx*") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx-") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx+") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx>=") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx>") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx<=") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx<") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx=") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f195979 0))) (closure () (f195979) (let () (vector-ref f195979 0))))
# emit-begin
#   expr=(begin (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "make-string") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "vector-ref") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "vector-set!") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "vector-length") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "make-vector") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "vector?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "set-cdr!") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "set-car!") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "cdr") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "car") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "cons") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "pair?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxremainder") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxquotient") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx*") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx-") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx+") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx>=") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx>") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx<=") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx<") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx=") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f195979 0))) (closure () (f195979) (let () (vector-ref f195979 0))))
#   env=((f195979 . 0))
# emit-expr (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "make-string") (vector-ref f195979 0)))
# emit-expr f195979
# emit-variable-ref
# env=((f195979 . 0))
# var=f195979
    movl 0(%esp), %eax  # stack load f195979
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1431895
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1431895:
    movl %eax, -4(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1431896"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1431896:
# check bounds on vector index
    movl -4(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1431898
    cmp  $0,%eax
    jge _L_1431897
_L_1431898:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1431897:
    movl %eax, -8(%esp)
# emit-expr (cons ((primitive-ref string->symbol) "make-string") (vector-ref f195979 0))
# cons arg1=((primitive-ref string->symbol) "make-string") arg2=(vector-ref f195979 0)
# emit-expr ((primitive-ref string->symbol) "make-string")
# funcall
#    si   =-12
#    env  = ((f195979 . 0))
#    expr = (funcall (primitive-ref string->symbol) "make-string")
# emit-expr (primitive-ref string->symbol)
    .extern mrc_string$m$gsymbol
    movl mrc_string$m$gsymbol,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1431899"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1431899":
   movl %eax,  -20(%esp)  # stash funcall-oper in closure slot
# emit-expr "make-string"
# string literal
    jmp _L_1431901
    .align 8,0x90
_L_1431900 :
    .int 44
    .ascii "make-string"
_L_1431901:
    movl $_L_1431900, %eax
    orl $6, %eax
    mov %eax, -24(%esp)  # arg make-string
    movl -20(%esp), %edi   # load new closure to %edi
    add $-12, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $12, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    movl %eax, -12(%esp)
# emit-expr (vector-ref f195979 0)
# emit-expr f195979
# emit-variable-ref
# env=((f195979 . 0))
# var=f195979
    movl 0(%esp), %eax  # stack load f195979
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1431902
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1431902:
    movl %eax, -16(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1431903"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1431903:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1431905
    cmp  $0,%eax
    jge _L_1431904
_L_1431905:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1431904:
    movl -16(%esp), %esi
    movl -1(%eax,%esi), %eax
    movl %eax, 4(%ebp)
    movl -12(%esp), %eax
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    or   $1, %al
    add  $8, %ebp
# cons end
    movl -4(%esp), %ebx
    movl -8(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "vector-ref") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "vector-set!") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "vector-length") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "make-vector") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "vector?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "set-cdr!") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "set-car!") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "cdr") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "car") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "cons") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "pair?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxremainder") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxquotient") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx*") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx-") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx+") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx>=") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx>") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx<=") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx<") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx=") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f195979 0))) (closure () (f195979) (let () (vector-ref f195979 0))))
# emit-begin
#   expr=(begin (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "vector-ref") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "vector-set!") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "vector-length") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "make-vector") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "vector?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "set-cdr!") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "set-car!") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "cdr") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "car") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "cons") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "pair?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxremainder") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxquotient") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx*") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx-") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx+") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx>=") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx>") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx<=") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx<") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx=") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f195979 0))) (closure () (f195979) (let () (vector-ref f195979 0))))
#   env=((f195979 . 0))
# emit-expr (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "vector-ref") (vector-ref f195979 0)))
# emit-expr f195979
# emit-variable-ref
# env=((f195979 . 0))
# var=f195979
    movl 0(%esp), %eax  # stack load f195979
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1431906
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1431906:
    movl %eax, -4(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1431907"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1431907:
# check bounds on vector index
    movl -4(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1431909
    cmp  $0,%eax
    jge _L_1431908
_L_1431909:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1431908:
    movl %eax, -8(%esp)
# emit-expr (cons ((primitive-ref string->symbol) "vector-ref") (vector-ref f195979 0))
# cons arg1=((primitive-ref string->symbol) "vector-ref") arg2=(vector-ref f195979 0)
# emit-expr ((primitive-ref string->symbol) "vector-ref")
# funcall
#    si   =-12
#    env  = ((f195979 . 0))
#    expr = (funcall (primitive-ref string->symbol) "vector-ref")
# emit-expr (primitive-ref string->symbol)
    .extern mrc_string$m$gsymbol
    movl mrc_string$m$gsymbol,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1431910"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1431910":
   movl %eax,  -20(%esp)  # stash funcall-oper in closure slot
# emit-expr "vector-ref"
# string literal
    jmp _L_1431912
    .align 8,0x90
_L_1431911 :
    .int 40
    .ascii "vector-ref"
_L_1431912:
    movl $_L_1431911, %eax
    orl $6, %eax
    mov %eax, -24(%esp)  # arg vector-ref
    movl -20(%esp), %edi   # load new closure to %edi
    add $-12, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $12, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    movl %eax, -12(%esp)
# emit-expr (vector-ref f195979 0)
# emit-expr f195979
# emit-variable-ref
# env=((f195979 . 0))
# var=f195979
    movl 0(%esp), %eax  # stack load f195979
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1431913
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1431913:
    movl %eax, -16(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1431914"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1431914:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1431916
    cmp  $0,%eax
    jge _L_1431915
_L_1431916:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1431915:
    movl -16(%esp), %esi
    movl -1(%eax,%esi), %eax
    movl %eax, 4(%ebp)
    movl -12(%esp), %eax
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    or   $1, %al
    add  $8, %ebp
# cons end
    movl -4(%esp), %ebx
    movl -8(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "vector-set!") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "vector-length") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "make-vector") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "vector?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "set-cdr!") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "set-car!") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "cdr") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "car") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "cons") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "pair?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxremainder") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxquotient") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx*") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx-") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx+") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx>=") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx>") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx<=") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx<") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx=") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f195979 0))) (closure () (f195979) (let () (vector-ref f195979 0))))
# emit-begin
#   expr=(begin (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "vector-set!") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "vector-length") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "make-vector") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "vector?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "set-cdr!") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "set-car!") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "cdr") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "car") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "cons") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "pair?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxremainder") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxquotient") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx*") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx-") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx+") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx>=") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx>") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx<=") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx<") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx=") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f195979 0))) (closure () (f195979) (let () (vector-ref f195979 0))))
#   env=((f195979 . 0))
# emit-expr (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "vector-set!") (vector-ref f195979 0)))
# emit-expr f195979
# emit-variable-ref
# env=((f195979 . 0))
# var=f195979
    movl 0(%esp), %eax  # stack load f195979
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1431917
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1431917:
    movl %eax, -4(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1431918"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1431918:
# check bounds on vector index
    movl -4(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1431920
    cmp  $0,%eax
    jge _L_1431919
_L_1431920:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1431919:
    movl %eax, -8(%esp)
# emit-expr (cons ((primitive-ref string->symbol) "vector-set!") (vector-ref f195979 0))
# cons arg1=((primitive-ref string->symbol) "vector-set!") arg2=(vector-ref f195979 0)
# emit-expr ((primitive-ref string->symbol) "vector-set!")
# funcall
#    si   =-12
#    env  = ((f195979 . 0))
#    expr = (funcall (primitive-ref string->symbol) "vector-set!")
# emit-expr (primitive-ref string->symbol)
    .extern mrc_string$m$gsymbol
    movl mrc_string$m$gsymbol,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1431921"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1431921":
   movl %eax,  -20(%esp)  # stash funcall-oper in closure slot
# emit-expr "vector-set!"
# string literal
    jmp _L_1431923
    .align 8,0x90
_L_1431922 :
    .int 44
    .ascii "vector-set!"
_L_1431923:
    movl $_L_1431922, %eax
    orl $6, %eax
    mov %eax, -24(%esp)  # arg vector-set!
    movl -20(%esp), %edi   # load new closure to %edi
    add $-12, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $12, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    movl %eax, -12(%esp)
# emit-expr (vector-ref f195979 0)
# emit-expr f195979
# emit-variable-ref
# env=((f195979 . 0))
# var=f195979
    movl 0(%esp), %eax  # stack load f195979
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1431924
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1431924:
    movl %eax, -16(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1431925"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1431925:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1431927
    cmp  $0,%eax
    jge _L_1431926
_L_1431927:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1431926:
    movl -16(%esp), %esi
    movl -1(%eax,%esi), %eax
    movl %eax, 4(%ebp)
    movl -12(%esp), %eax
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    or   $1, %al
    add  $8, %ebp
# cons end
    movl -4(%esp), %ebx
    movl -8(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "vector-length") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "make-vector") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "vector?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "set-cdr!") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "set-car!") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "cdr") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "car") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "cons") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "pair?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxremainder") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxquotient") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx*") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx-") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx+") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx>=") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx>") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx<=") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx<") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx=") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f195979 0))) (closure () (f195979) (let () (vector-ref f195979 0))))
# emit-begin
#   expr=(begin (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "vector-length") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "make-vector") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "vector?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "set-cdr!") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "set-car!") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "cdr") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "car") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "cons") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "pair?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxremainder") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxquotient") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx*") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx-") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx+") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx>=") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx>") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx<=") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx<") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx=") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f195979 0))) (closure () (f195979) (let () (vector-ref f195979 0))))
#   env=((f195979 . 0))
# emit-expr (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "vector-length") (vector-ref f195979 0)))
# emit-expr f195979
# emit-variable-ref
# env=((f195979 . 0))
# var=f195979
    movl 0(%esp), %eax  # stack load f195979
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1431928
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1431928:
    movl %eax, -4(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1431929"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1431929:
# check bounds on vector index
    movl -4(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1431931
    cmp  $0,%eax
    jge _L_1431930
_L_1431931:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1431930:
    movl %eax, -8(%esp)
# emit-expr (cons ((primitive-ref string->symbol) "vector-length") (vector-ref f195979 0))
# cons arg1=((primitive-ref string->symbol) "vector-length") arg2=(vector-ref f195979 0)
# emit-expr ((primitive-ref string->symbol) "vector-length")
# funcall
#    si   =-12
#    env  = ((f195979 . 0))
#    expr = (funcall (primitive-ref string->symbol) "vector-length")
# emit-expr (primitive-ref string->symbol)
    .extern mrc_string$m$gsymbol
    movl mrc_string$m$gsymbol,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1431932"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1431932":
   movl %eax,  -20(%esp)  # stash funcall-oper in closure slot
# emit-expr "vector-length"
# string literal
    jmp _L_1431934
    .align 8,0x90
_L_1431933 :
    .int 52
    .ascii "vector-length"
_L_1431934:
    movl $_L_1431933, %eax
    orl $6, %eax
    mov %eax, -24(%esp)  # arg vector-length
    movl -20(%esp), %edi   # load new closure to %edi
    add $-12, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $12, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    movl %eax, -12(%esp)
# emit-expr (vector-ref f195979 0)
# emit-expr f195979
# emit-variable-ref
# env=((f195979 . 0))
# var=f195979
    movl 0(%esp), %eax  # stack load f195979
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1431935
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1431935:
    movl %eax, -16(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1431936"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1431936:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1431938
    cmp  $0,%eax
    jge _L_1431937
_L_1431938:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1431937:
    movl -16(%esp), %esi
    movl -1(%eax,%esi), %eax
    movl %eax, 4(%ebp)
    movl -12(%esp), %eax
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    or   $1, %al
    add  $8, %ebp
# cons end
    movl -4(%esp), %ebx
    movl -8(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "make-vector") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "vector?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "set-cdr!") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "set-car!") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "cdr") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "car") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "cons") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "pair?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxremainder") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxquotient") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx*") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx-") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx+") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx>=") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx>") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx<=") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx<") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx=") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f195979 0))) (closure () (f195979) (let () (vector-ref f195979 0))))
# emit-begin
#   expr=(begin (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "make-vector") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "vector?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "set-cdr!") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "set-car!") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "cdr") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "car") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "cons") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "pair?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxremainder") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxquotient") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx*") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx-") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx+") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx>=") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx>") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx<=") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx<") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx=") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f195979 0))) (closure () (f195979) (let () (vector-ref f195979 0))))
#   env=((f195979 . 0))
# emit-expr (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "make-vector") (vector-ref f195979 0)))
# emit-expr f195979
# emit-variable-ref
# env=((f195979 . 0))
# var=f195979
    movl 0(%esp), %eax  # stack load f195979
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1431939
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1431939:
    movl %eax, -4(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1431940"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1431940:
# check bounds on vector index
    movl -4(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1431942
    cmp  $0,%eax
    jge _L_1431941
_L_1431942:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1431941:
    movl %eax, -8(%esp)
# emit-expr (cons ((primitive-ref string->symbol) "make-vector") (vector-ref f195979 0))
# cons arg1=((primitive-ref string->symbol) "make-vector") arg2=(vector-ref f195979 0)
# emit-expr ((primitive-ref string->symbol) "make-vector")
# funcall
#    si   =-12
#    env  = ((f195979 . 0))
#    expr = (funcall (primitive-ref string->symbol) "make-vector")
# emit-expr (primitive-ref string->symbol)
    .extern mrc_string$m$gsymbol
    movl mrc_string$m$gsymbol,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1431943"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1431943":
   movl %eax,  -20(%esp)  # stash funcall-oper in closure slot
# emit-expr "make-vector"
# string literal
    jmp _L_1431945
    .align 8,0x90
_L_1431944 :
    .int 44
    .ascii "make-vector"
_L_1431945:
    movl $_L_1431944, %eax
    orl $6, %eax
    mov %eax, -24(%esp)  # arg make-vector
    movl -20(%esp), %edi   # load new closure to %edi
    add $-12, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $12, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    movl %eax, -12(%esp)
# emit-expr (vector-ref f195979 0)
# emit-expr f195979
# emit-variable-ref
# env=((f195979 . 0))
# var=f195979
    movl 0(%esp), %eax  # stack load f195979
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1431946
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1431946:
    movl %eax, -16(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1431947"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1431947:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1431949
    cmp  $0,%eax
    jge _L_1431948
_L_1431949:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1431948:
    movl -16(%esp), %esi
    movl -1(%eax,%esi), %eax
    movl %eax, 4(%ebp)
    movl -12(%esp), %eax
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    or   $1, %al
    add  $8, %ebp
# cons end
    movl -4(%esp), %ebx
    movl -8(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "vector?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "set-cdr!") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "set-car!") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "cdr") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "car") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "cons") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "pair?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxremainder") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxquotient") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx*") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx-") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx+") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx>=") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx>") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx<=") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx<") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx=") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f195979 0))) (closure () (f195979) (let () (vector-ref f195979 0))))
# emit-begin
#   expr=(begin (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "vector?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "set-cdr!") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "set-car!") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "cdr") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "car") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "cons") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "pair?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxremainder") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxquotient") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx*") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx-") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx+") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx>=") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx>") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx<=") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx<") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx=") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f195979 0))) (closure () (f195979) (let () (vector-ref f195979 0))))
#   env=((f195979 . 0))
# emit-expr (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "vector?") (vector-ref f195979 0)))
# emit-expr f195979
# emit-variable-ref
# env=((f195979 . 0))
# var=f195979
    movl 0(%esp), %eax  # stack load f195979
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1431950
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1431950:
    movl %eax, -4(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1431951"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1431951:
# check bounds on vector index
    movl -4(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1431953
    cmp  $0,%eax
    jge _L_1431952
_L_1431953:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1431952:
    movl %eax, -8(%esp)
# emit-expr (cons ((primitive-ref string->symbol) "vector?") (vector-ref f195979 0))
# cons arg1=((primitive-ref string->symbol) "vector?") arg2=(vector-ref f195979 0)
# emit-expr ((primitive-ref string->symbol) "vector?")
# funcall
#    si   =-12
#    env  = ((f195979 . 0))
#    expr = (funcall (primitive-ref string->symbol) "vector?")
# emit-expr (primitive-ref string->symbol)
    .extern mrc_string$m$gsymbol
    movl mrc_string$m$gsymbol,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1431954"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1431954":
   movl %eax,  -20(%esp)  # stash funcall-oper in closure slot
# emit-expr "vector?"
# string literal
    jmp _L_1431956
    .align 8,0x90
_L_1431955 :
    .int 28
    .ascii "vector?"
_L_1431956:
    movl $_L_1431955, %eax
    orl $6, %eax
    mov %eax, -24(%esp)  # arg vector?
    movl -20(%esp), %edi   # load new closure to %edi
    add $-12, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $12, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    movl %eax, -12(%esp)
# emit-expr (vector-ref f195979 0)
# emit-expr f195979
# emit-variable-ref
# env=((f195979 . 0))
# var=f195979
    movl 0(%esp), %eax  # stack load f195979
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1431957
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1431957:
    movl %eax, -16(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1431958"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1431958:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1431960
    cmp  $0,%eax
    jge _L_1431959
_L_1431960:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1431959:
    movl -16(%esp), %esi
    movl -1(%eax,%esi), %eax
    movl %eax, 4(%ebp)
    movl -12(%esp), %eax
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    or   $1, %al
    add  $8, %ebp
# cons end
    movl -4(%esp), %ebx
    movl -8(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "set-cdr!") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "set-car!") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "cdr") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "car") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "cons") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "pair?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxremainder") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxquotient") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx*") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx-") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx+") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx>=") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx>") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx<=") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx<") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx=") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f195979 0))) (closure () (f195979) (let () (vector-ref f195979 0))))
# emit-begin
#   expr=(begin (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "set-cdr!") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "set-car!") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "cdr") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "car") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "cons") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "pair?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxremainder") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxquotient") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx*") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx-") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx+") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx>=") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx>") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx<=") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx<") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx=") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f195979 0))) (closure () (f195979) (let () (vector-ref f195979 0))))
#   env=((f195979 . 0))
# emit-expr (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "set-cdr!") (vector-ref f195979 0)))
# emit-expr f195979
# emit-variable-ref
# env=((f195979 . 0))
# var=f195979
    movl 0(%esp), %eax  # stack load f195979
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1431961
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1431961:
    movl %eax, -4(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1431962"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1431962:
# check bounds on vector index
    movl -4(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1431964
    cmp  $0,%eax
    jge _L_1431963
_L_1431964:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1431963:
    movl %eax, -8(%esp)
# emit-expr (cons ((primitive-ref string->symbol) "set-cdr!") (vector-ref f195979 0))
# cons arg1=((primitive-ref string->symbol) "set-cdr!") arg2=(vector-ref f195979 0)
# emit-expr ((primitive-ref string->symbol) "set-cdr!")
# funcall
#    si   =-12
#    env  = ((f195979 . 0))
#    expr = (funcall (primitive-ref string->symbol) "set-cdr!")
# emit-expr (primitive-ref string->symbol)
    .extern mrc_string$m$gsymbol
    movl mrc_string$m$gsymbol,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1431965"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1431965":
   movl %eax,  -20(%esp)  # stash funcall-oper in closure slot
# emit-expr "set-cdr!"
# string literal
    jmp _L_1431967
    .align 8,0x90
_L_1431966 :
    .int 32
    .ascii "set-cdr!"
_L_1431967:
    movl $_L_1431966, %eax
    orl $6, %eax
    mov %eax, -24(%esp)  # arg set-cdr!
    movl -20(%esp), %edi   # load new closure to %edi
    add $-12, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $12, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    movl %eax, -12(%esp)
# emit-expr (vector-ref f195979 0)
# emit-expr f195979
# emit-variable-ref
# env=((f195979 . 0))
# var=f195979
    movl 0(%esp), %eax  # stack load f195979
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1431968
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1431968:
    movl %eax, -16(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1431969"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1431969:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1431971
    cmp  $0,%eax
    jge _L_1431970
_L_1431971:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1431970:
    movl -16(%esp), %esi
    movl -1(%eax,%esi), %eax
    movl %eax, 4(%ebp)
    movl -12(%esp), %eax
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    or   $1, %al
    add  $8, %ebp
# cons end
    movl -4(%esp), %ebx
    movl -8(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "set-car!") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "cdr") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "car") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "cons") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "pair?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxremainder") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxquotient") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx*") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx-") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx+") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx>=") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx>") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx<=") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx<") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx=") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f195979 0))) (closure () (f195979) (let () (vector-ref f195979 0))))
# emit-begin
#   expr=(begin (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "set-car!") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "cdr") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "car") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "cons") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "pair?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxremainder") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxquotient") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx*") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx-") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx+") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx>=") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx>") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx<=") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx<") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx=") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f195979 0))) (closure () (f195979) (let () (vector-ref f195979 0))))
#   env=((f195979 . 0))
# emit-expr (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "set-car!") (vector-ref f195979 0)))
# emit-expr f195979
# emit-variable-ref
# env=((f195979 . 0))
# var=f195979
    movl 0(%esp), %eax  # stack load f195979
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1431972
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1431972:
    movl %eax, -4(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1431973"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1431973:
# check bounds on vector index
    movl -4(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1431975
    cmp  $0,%eax
    jge _L_1431974
_L_1431975:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1431974:
    movl %eax, -8(%esp)
# emit-expr (cons ((primitive-ref string->symbol) "set-car!") (vector-ref f195979 0))
# cons arg1=((primitive-ref string->symbol) "set-car!") arg2=(vector-ref f195979 0)
# emit-expr ((primitive-ref string->symbol) "set-car!")
# funcall
#    si   =-12
#    env  = ((f195979 . 0))
#    expr = (funcall (primitive-ref string->symbol) "set-car!")
# emit-expr (primitive-ref string->symbol)
    .extern mrc_string$m$gsymbol
    movl mrc_string$m$gsymbol,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1431976"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1431976":
   movl %eax,  -20(%esp)  # stash funcall-oper in closure slot
# emit-expr "set-car!"
# string literal
    jmp _L_1431978
    .align 8,0x90
_L_1431977 :
    .int 32
    .ascii "set-car!"
_L_1431978:
    movl $_L_1431977, %eax
    orl $6, %eax
    mov %eax, -24(%esp)  # arg set-car!
    movl -20(%esp), %edi   # load new closure to %edi
    add $-12, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $12, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    movl %eax, -12(%esp)
# emit-expr (vector-ref f195979 0)
# emit-expr f195979
# emit-variable-ref
# env=((f195979 . 0))
# var=f195979
    movl 0(%esp), %eax  # stack load f195979
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1431979
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1431979:
    movl %eax, -16(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1431980"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1431980:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1431982
    cmp  $0,%eax
    jge _L_1431981
_L_1431982:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1431981:
    movl -16(%esp), %esi
    movl -1(%eax,%esi), %eax
    movl %eax, 4(%ebp)
    movl -12(%esp), %eax
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    or   $1, %al
    add  $8, %ebp
# cons end
    movl -4(%esp), %ebx
    movl -8(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "cdr") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "car") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "cons") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "pair?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxremainder") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxquotient") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx*") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx-") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx+") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx>=") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx>") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx<=") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx<") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx=") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f195979 0))) (closure () (f195979) (let () (vector-ref f195979 0))))
# emit-begin
#   expr=(begin (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "cdr") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "car") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "cons") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "pair?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxremainder") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxquotient") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx*") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx-") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx+") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx>=") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx>") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx<=") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx<") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx=") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f195979 0))) (closure () (f195979) (let () (vector-ref f195979 0))))
#   env=((f195979 . 0))
# emit-expr (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "cdr") (vector-ref f195979 0)))
# emit-expr f195979
# emit-variable-ref
# env=((f195979 . 0))
# var=f195979
    movl 0(%esp), %eax  # stack load f195979
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1431983
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1431983:
    movl %eax, -4(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1431984"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1431984:
# check bounds on vector index
    movl -4(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1431986
    cmp  $0,%eax
    jge _L_1431985
_L_1431986:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1431985:
    movl %eax, -8(%esp)
# emit-expr (cons ((primitive-ref string->symbol) "cdr") (vector-ref f195979 0))
# cons arg1=((primitive-ref string->symbol) "cdr") arg2=(vector-ref f195979 0)
# emit-expr ((primitive-ref string->symbol) "cdr")
# funcall
#    si   =-12
#    env  = ((f195979 . 0))
#    expr = (funcall (primitive-ref string->symbol) "cdr")
# emit-expr (primitive-ref string->symbol)
    .extern mrc_string$m$gsymbol
    movl mrc_string$m$gsymbol,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1431987"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1431987":
   movl %eax,  -20(%esp)  # stash funcall-oper in closure slot
# emit-expr "cdr"
# string literal
    jmp _L_1431989
    .align 8,0x90
_L_1431988 :
    .int 12
    .ascii "cdr"
_L_1431989:
    movl $_L_1431988, %eax
    orl $6, %eax
    mov %eax, -24(%esp)  # arg cdr
    movl -20(%esp), %edi   # load new closure to %edi
    add $-12, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $12, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    movl %eax, -12(%esp)
# emit-expr (vector-ref f195979 0)
# emit-expr f195979
# emit-variable-ref
# env=((f195979 . 0))
# var=f195979
    movl 0(%esp), %eax  # stack load f195979
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1431990
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1431990:
    movl %eax, -16(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1431991"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1431991:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1431993
    cmp  $0,%eax
    jge _L_1431992
_L_1431993:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1431992:
    movl -16(%esp), %esi
    movl -1(%eax,%esi), %eax
    movl %eax, 4(%ebp)
    movl -12(%esp), %eax
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    or   $1, %al
    add  $8, %ebp
# cons end
    movl -4(%esp), %ebx
    movl -8(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "car") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "cons") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "pair?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxremainder") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxquotient") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx*") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx-") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx+") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx>=") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx>") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx<=") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx<") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx=") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f195979 0))) (closure () (f195979) (let () (vector-ref f195979 0))))
# emit-begin
#   expr=(begin (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "car") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "cons") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "pair?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxremainder") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxquotient") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx*") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx-") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx+") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx>=") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx>") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx<=") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx<") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx=") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f195979 0))) (closure () (f195979) (let () (vector-ref f195979 0))))
#   env=((f195979 . 0))
# emit-expr (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "car") (vector-ref f195979 0)))
# emit-expr f195979
# emit-variable-ref
# env=((f195979 . 0))
# var=f195979
    movl 0(%esp), %eax  # stack load f195979
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1431994
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1431994:
    movl %eax, -4(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1431995"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1431995:
# check bounds on vector index
    movl -4(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1431997
    cmp  $0,%eax
    jge _L_1431996
_L_1431997:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1431996:
    movl %eax, -8(%esp)
# emit-expr (cons ((primitive-ref string->symbol) "car") (vector-ref f195979 0))
# cons arg1=((primitive-ref string->symbol) "car") arg2=(vector-ref f195979 0)
# emit-expr ((primitive-ref string->symbol) "car")
# funcall
#    si   =-12
#    env  = ((f195979 . 0))
#    expr = (funcall (primitive-ref string->symbol) "car")
# emit-expr (primitive-ref string->symbol)
    .extern mrc_string$m$gsymbol
    movl mrc_string$m$gsymbol,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1431998"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1431998":
   movl %eax,  -20(%esp)  # stash funcall-oper in closure slot
# emit-expr "car"
# string literal
    jmp _L_1432000
    .align 8,0x90
_L_1431999 :
    .int 12
    .ascii "car"
_L_1432000:
    movl $_L_1431999, %eax
    orl $6, %eax
    mov %eax, -24(%esp)  # arg car
    movl -20(%esp), %edi   # load new closure to %edi
    add $-12, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $12, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    movl %eax, -12(%esp)
# emit-expr (vector-ref f195979 0)
# emit-expr f195979
# emit-variable-ref
# env=((f195979 . 0))
# var=f195979
    movl 0(%esp), %eax  # stack load f195979
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1432001
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1432001:
    movl %eax, -16(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1432002"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1432002:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1432004
    cmp  $0,%eax
    jge _L_1432003
_L_1432004:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1432003:
    movl -16(%esp), %esi
    movl -1(%eax,%esi), %eax
    movl %eax, 4(%ebp)
    movl -12(%esp), %eax
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    or   $1, %al
    add  $8, %ebp
# cons end
    movl -4(%esp), %ebx
    movl -8(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "cons") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "pair?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxremainder") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxquotient") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx*") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx-") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx+") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx>=") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx>") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx<=") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx<") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx=") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f195979 0))) (closure () (f195979) (let () (vector-ref f195979 0))))
# emit-begin
#   expr=(begin (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "cons") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "pair?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxremainder") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxquotient") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx*") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx-") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx+") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx>=") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx>") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx<=") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx<") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx=") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f195979 0))) (closure () (f195979) (let () (vector-ref f195979 0))))
#   env=((f195979 . 0))
# emit-expr (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "cons") (vector-ref f195979 0)))
# emit-expr f195979
# emit-variable-ref
# env=((f195979 . 0))
# var=f195979
    movl 0(%esp), %eax  # stack load f195979
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1432005
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1432005:
    movl %eax, -4(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1432006"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1432006:
# check bounds on vector index
    movl -4(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1432008
    cmp  $0,%eax
    jge _L_1432007
_L_1432008:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1432007:
    movl %eax, -8(%esp)
# emit-expr (cons ((primitive-ref string->symbol) "cons") (vector-ref f195979 0))
# cons arg1=((primitive-ref string->symbol) "cons") arg2=(vector-ref f195979 0)
# emit-expr ((primitive-ref string->symbol) "cons")
# funcall
#    si   =-12
#    env  = ((f195979 . 0))
#    expr = (funcall (primitive-ref string->symbol) "cons")
# emit-expr (primitive-ref string->symbol)
    .extern mrc_string$m$gsymbol
    movl mrc_string$m$gsymbol,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1432009"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1432009":
   movl %eax,  -20(%esp)  # stash funcall-oper in closure slot
# emit-expr "cons"
# string literal
    jmp _L_1432011
    .align 8,0x90
_L_1432010 :
    .int 16
    .ascii "cons"
_L_1432011:
    movl $_L_1432010, %eax
    orl $6, %eax
    mov %eax, -24(%esp)  # arg cons
    movl -20(%esp), %edi   # load new closure to %edi
    add $-12, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $12, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    movl %eax, -12(%esp)
# emit-expr (vector-ref f195979 0)
# emit-expr f195979
# emit-variable-ref
# env=((f195979 . 0))
# var=f195979
    movl 0(%esp), %eax  # stack load f195979
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1432012
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1432012:
    movl %eax, -16(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1432013"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1432013:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1432015
    cmp  $0,%eax
    jge _L_1432014
_L_1432015:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1432014:
    movl -16(%esp), %esi
    movl -1(%eax,%esi), %eax
    movl %eax, 4(%ebp)
    movl -12(%esp), %eax
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    or   $1, %al
    add  $8, %ebp
# cons end
    movl -4(%esp), %ebx
    movl -8(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "pair?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxremainder") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxquotient") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx*") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx-") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx+") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx>=") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx>") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx<=") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx<") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx=") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f195979 0))) (closure () (f195979) (let () (vector-ref f195979 0))))
# emit-begin
#   expr=(begin (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "pair?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxremainder") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxquotient") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx*") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx-") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx+") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx>=") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx>") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx<=") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx<") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx=") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f195979 0))) (closure () (f195979) (let () (vector-ref f195979 0))))
#   env=((f195979 . 0))
# emit-expr (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "pair?") (vector-ref f195979 0)))
# emit-expr f195979
# emit-variable-ref
# env=((f195979 . 0))
# var=f195979
    movl 0(%esp), %eax  # stack load f195979
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1432016
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1432016:
    movl %eax, -4(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1432017"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1432017:
# check bounds on vector index
    movl -4(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1432019
    cmp  $0,%eax
    jge _L_1432018
_L_1432019:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1432018:
    movl %eax, -8(%esp)
# emit-expr (cons ((primitive-ref string->symbol) "pair?") (vector-ref f195979 0))
# cons arg1=((primitive-ref string->symbol) "pair?") arg2=(vector-ref f195979 0)
# emit-expr ((primitive-ref string->symbol) "pair?")
# funcall
#    si   =-12
#    env  = ((f195979 . 0))
#    expr = (funcall (primitive-ref string->symbol) "pair?")
# emit-expr (primitive-ref string->symbol)
    .extern mrc_string$m$gsymbol
    movl mrc_string$m$gsymbol,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1432020"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1432020":
   movl %eax,  -20(%esp)  # stash funcall-oper in closure slot
# emit-expr "pair?"
# string literal
    jmp _L_1432022
    .align 8,0x90
_L_1432021 :
    .int 20
    .ascii "pair?"
_L_1432022:
    movl $_L_1432021, %eax
    orl $6, %eax
    mov %eax, -24(%esp)  # arg pair?
    movl -20(%esp), %edi   # load new closure to %edi
    add $-12, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $12, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    movl %eax, -12(%esp)
# emit-expr (vector-ref f195979 0)
# emit-expr f195979
# emit-variable-ref
# env=((f195979 . 0))
# var=f195979
    movl 0(%esp), %eax  # stack load f195979
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1432023
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1432023:
    movl %eax, -16(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1432024"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1432024:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1432026
    cmp  $0,%eax
    jge _L_1432025
_L_1432026:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1432025:
    movl -16(%esp), %esi
    movl -1(%eax,%esi), %eax
    movl %eax, 4(%ebp)
    movl -12(%esp), %eax
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    or   $1, %al
    add  $8, %ebp
# cons end
    movl -4(%esp), %ebx
    movl -8(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxremainder") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxquotient") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx*") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx-") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx+") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx>=") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx>") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx<=") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx<") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx=") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f195979 0))) (closure () (f195979) (let () (vector-ref f195979 0))))
# emit-begin
#   expr=(begin (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxremainder") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxquotient") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx*") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx-") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx+") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx>=") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx>") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx<=") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx<") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx=") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f195979 0))) (closure () (f195979) (let () (vector-ref f195979 0))))
#   env=((f195979 . 0))
# emit-expr (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxremainder") (vector-ref f195979 0)))
# emit-expr f195979
# emit-variable-ref
# env=((f195979 . 0))
# var=f195979
    movl 0(%esp), %eax  # stack load f195979
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1432027
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1432027:
    movl %eax, -4(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1432028"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1432028:
# check bounds on vector index
    movl -4(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1432030
    cmp  $0,%eax
    jge _L_1432029
_L_1432030:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1432029:
    movl %eax, -8(%esp)
# emit-expr (cons ((primitive-ref string->symbol) "fxremainder") (vector-ref f195979 0))
# cons arg1=((primitive-ref string->symbol) "fxremainder") arg2=(vector-ref f195979 0)
# emit-expr ((primitive-ref string->symbol) "fxremainder")
# funcall
#    si   =-12
#    env  = ((f195979 . 0))
#    expr = (funcall (primitive-ref string->symbol) "fxremainder")
# emit-expr (primitive-ref string->symbol)
    .extern mrc_string$m$gsymbol
    movl mrc_string$m$gsymbol,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1432031"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1432031":
   movl %eax,  -20(%esp)  # stash funcall-oper in closure slot
# emit-expr "fxremainder"
# string literal
    jmp _L_1432033
    .align 8,0x90
_L_1432032 :
    .int 44
    .ascii "fxremainder"
_L_1432033:
    movl $_L_1432032, %eax
    orl $6, %eax
    mov %eax, -24(%esp)  # arg fxremainder
    movl -20(%esp), %edi   # load new closure to %edi
    add $-12, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $12, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    movl %eax, -12(%esp)
# emit-expr (vector-ref f195979 0)
# emit-expr f195979
# emit-variable-ref
# env=((f195979 . 0))
# var=f195979
    movl 0(%esp), %eax  # stack load f195979
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1432034
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1432034:
    movl %eax, -16(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1432035"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1432035:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1432037
    cmp  $0,%eax
    jge _L_1432036
_L_1432037:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1432036:
    movl -16(%esp), %esi
    movl -1(%eax,%esi), %eax
    movl %eax, 4(%ebp)
    movl -12(%esp), %eax
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    or   $1, %al
    add  $8, %ebp
# cons end
    movl -4(%esp), %ebx
    movl -8(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxquotient") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx*") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx-") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx+") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx>=") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx>") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx<=") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx<") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx=") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f195979 0))) (closure () (f195979) (let () (vector-ref f195979 0))))
# emit-begin
#   expr=(begin (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxquotient") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx*") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx-") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx+") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx>=") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx>") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx<=") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx<") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx=") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f195979 0))) (closure () (f195979) (let () (vector-ref f195979 0))))
#   env=((f195979 . 0))
# emit-expr (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxquotient") (vector-ref f195979 0)))
# emit-expr f195979
# emit-variable-ref
# env=((f195979 . 0))
# var=f195979
    movl 0(%esp), %eax  # stack load f195979
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1432038
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1432038:
    movl %eax, -4(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1432039"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1432039:
# check bounds on vector index
    movl -4(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1432041
    cmp  $0,%eax
    jge _L_1432040
_L_1432041:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1432040:
    movl %eax, -8(%esp)
# emit-expr (cons ((primitive-ref string->symbol) "fxquotient") (vector-ref f195979 0))
# cons arg1=((primitive-ref string->symbol) "fxquotient") arg2=(vector-ref f195979 0)
# emit-expr ((primitive-ref string->symbol) "fxquotient")
# funcall
#    si   =-12
#    env  = ((f195979 . 0))
#    expr = (funcall (primitive-ref string->symbol) "fxquotient")
# emit-expr (primitive-ref string->symbol)
    .extern mrc_string$m$gsymbol
    movl mrc_string$m$gsymbol,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1432042"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1432042":
   movl %eax,  -20(%esp)  # stash funcall-oper in closure slot
# emit-expr "fxquotient"
# string literal
    jmp _L_1432044
    .align 8,0x90
_L_1432043 :
    .int 40
    .ascii "fxquotient"
_L_1432044:
    movl $_L_1432043, %eax
    orl $6, %eax
    mov %eax, -24(%esp)  # arg fxquotient
    movl -20(%esp), %edi   # load new closure to %edi
    add $-12, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $12, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    movl %eax, -12(%esp)
# emit-expr (vector-ref f195979 0)
# emit-expr f195979
# emit-variable-ref
# env=((f195979 . 0))
# var=f195979
    movl 0(%esp), %eax  # stack load f195979
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1432045
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1432045:
    movl %eax, -16(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1432046"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1432046:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1432048
    cmp  $0,%eax
    jge _L_1432047
_L_1432048:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1432047:
    movl -16(%esp), %esi
    movl -1(%eax,%esi), %eax
    movl %eax, 4(%ebp)
    movl -12(%esp), %eax
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    or   $1, %al
    add  $8, %ebp
# cons end
    movl -4(%esp), %ebx
    movl -8(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx*") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx-") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx+") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx>=") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx>") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx<=") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx<") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx=") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f195979 0))) (closure () (f195979) (let () (vector-ref f195979 0))))
# emit-begin
#   expr=(begin (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx*") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx-") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx+") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx>=") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx>") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx<=") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx<") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx=") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f195979 0))) (closure () (f195979) (let () (vector-ref f195979 0))))
#   env=((f195979 . 0))
# emit-expr (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx*") (vector-ref f195979 0)))
# emit-expr f195979
# emit-variable-ref
# env=((f195979 . 0))
# var=f195979
    movl 0(%esp), %eax  # stack load f195979
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1432049
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1432049:
    movl %eax, -4(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1432050"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1432050:
# check bounds on vector index
    movl -4(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1432052
    cmp  $0,%eax
    jge _L_1432051
_L_1432052:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1432051:
    movl %eax, -8(%esp)
# emit-expr (cons ((primitive-ref string->symbol) "fx*") (vector-ref f195979 0))
# cons arg1=((primitive-ref string->symbol) "fx*") arg2=(vector-ref f195979 0)
# emit-expr ((primitive-ref string->symbol) "fx*")
# funcall
#    si   =-12
#    env  = ((f195979 . 0))
#    expr = (funcall (primitive-ref string->symbol) "fx*")
# emit-expr (primitive-ref string->symbol)
    .extern mrc_string$m$gsymbol
    movl mrc_string$m$gsymbol,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1432053"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1432053":
   movl %eax,  -20(%esp)  # stash funcall-oper in closure slot
# emit-expr "fx*"
# string literal
    jmp _L_1432055
    .align 8,0x90
_L_1432054 :
    .int 12
    .ascii "fx*"
_L_1432055:
    movl $_L_1432054, %eax
    orl $6, %eax
    mov %eax, -24(%esp)  # arg fx*
    movl -20(%esp), %edi   # load new closure to %edi
    add $-12, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $12, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    movl %eax, -12(%esp)
# emit-expr (vector-ref f195979 0)
# emit-expr f195979
# emit-variable-ref
# env=((f195979 . 0))
# var=f195979
    movl 0(%esp), %eax  # stack load f195979
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1432056
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1432056:
    movl %eax, -16(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1432057"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1432057:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1432059
    cmp  $0,%eax
    jge _L_1432058
_L_1432059:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1432058:
    movl -16(%esp), %esi
    movl -1(%eax,%esi), %eax
    movl %eax, 4(%ebp)
    movl -12(%esp), %eax
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    or   $1, %al
    add  $8, %ebp
# cons end
    movl -4(%esp), %ebx
    movl -8(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx-") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx+") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx>=") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx>") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx<=") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx<") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx=") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f195979 0))) (closure () (f195979) (let () (vector-ref f195979 0))))
# emit-begin
#   expr=(begin (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx-") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx+") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx>=") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx>") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx<=") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx<") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx=") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f195979 0))) (closure () (f195979) (let () (vector-ref f195979 0))))
#   env=((f195979 . 0))
# emit-expr (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx-") (vector-ref f195979 0)))
# emit-expr f195979
# emit-variable-ref
# env=((f195979 . 0))
# var=f195979
    movl 0(%esp), %eax  # stack load f195979
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1432060
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1432060:
    movl %eax, -4(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1432061"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1432061:
# check bounds on vector index
    movl -4(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1432063
    cmp  $0,%eax
    jge _L_1432062
_L_1432063:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1432062:
    movl %eax, -8(%esp)
# emit-expr (cons ((primitive-ref string->symbol) "fx-") (vector-ref f195979 0))
# cons arg1=((primitive-ref string->symbol) "fx-") arg2=(vector-ref f195979 0)
# emit-expr ((primitive-ref string->symbol) "fx-")
# funcall
#    si   =-12
#    env  = ((f195979 . 0))
#    expr = (funcall (primitive-ref string->symbol) "fx-")
# emit-expr (primitive-ref string->symbol)
    .extern mrc_string$m$gsymbol
    movl mrc_string$m$gsymbol,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1432064"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1432064":
   movl %eax,  -20(%esp)  # stash funcall-oper in closure slot
# emit-expr "fx-"
# string literal
    jmp _L_1432066
    .align 8,0x90
_L_1432065 :
    .int 12
    .ascii "fx-"
_L_1432066:
    movl $_L_1432065, %eax
    orl $6, %eax
    mov %eax, -24(%esp)  # arg fx-
    movl -20(%esp), %edi   # load new closure to %edi
    add $-12, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $12, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    movl %eax, -12(%esp)
# emit-expr (vector-ref f195979 0)
# emit-expr f195979
# emit-variable-ref
# env=((f195979 . 0))
# var=f195979
    movl 0(%esp), %eax  # stack load f195979
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1432067
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1432067:
    movl %eax, -16(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1432068"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1432068:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1432070
    cmp  $0,%eax
    jge _L_1432069
_L_1432070:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1432069:
    movl -16(%esp), %esi
    movl -1(%eax,%esi), %eax
    movl %eax, 4(%ebp)
    movl -12(%esp), %eax
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    or   $1, %al
    add  $8, %ebp
# cons end
    movl -4(%esp), %ebx
    movl -8(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx+") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx>=") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx>") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx<=") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx<") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx=") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f195979 0))) (closure () (f195979) (let () (vector-ref f195979 0))))
# emit-begin
#   expr=(begin (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx+") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx>=") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx>") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx<=") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx<") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx=") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f195979 0))) (closure () (f195979) (let () (vector-ref f195979 0))))
#   env=((f195979 . 0))
# emit-expr (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx+") (vector-ref f195979 0)))
# emit-expr f195979
# emit-variable-ref
# env=((f195979 . 0))
# var=f195979
    movl 0(%esp), %eax  # stack load f195979
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1432071
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1432071:
    movl %eax, -4(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1432072"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1432072:
# check bounds on vector index
    movl -4(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1432074
    cmp  $0,%eax
    jge _L_1432073
_L_1432074:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1432073:
    movl %eax, -8(%esp)
# emit-expr (cons ((primitive-ref string->symbol) "fx+") (vector-ref f195979 0))
# cons arg1=((primitive-ref string->symbol) "fx+") arg2=(vector-ref f195979 0)
# emit-expr ((primitive-ref string->symbol) "fx+")
# funcall
#    si   =-12
#    env  = ((f195979 . 0))
#    expr = (funcall (primitive-ref string->symbol) "fx+")
# emit-expr (primitive-ref string->symbol)
    .extern mrc_string$m$gsymbol
    movl mrc_string$m$gsymbol,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1432075"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1432075":
   movl %eax,  -20(%esp)  # stash funcall-oper in closure slot
# emit-expr "fx+"
# string literal
    jmp _L_1432077
    .align 8,0x90
_L_1432076 :
    .int 12
    .ascii "fx+"
_L_1432077:
    movl $_L_1432076, %eax
    orl $6, %eax
    mov %eax, -24(%esp)  # arg fx+
    movl -20(%esp), %edi   # load new closure to %edi
    add $-12, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $12, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    movl %eax, -12(%esp)
# emit-expr (vector-ref f195979 0)
# emit-expr f195979
# emit-variable-ref
# env=((f195979 . 0))
# var=f195979
    movl 0(%esp), %eax  # stack load f195979
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1432078
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1432078:
    movl %eax, -16(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1432079"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1432079:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1432081
    cmp  $0,%eax
    jge _L_1432080
_L_1432081:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1432080:
    movl -16(%esp), %esi
    movl -1(%eax,%esi), %eax
    movl %eax, 4(%ebp)
    movl -12(%esp), %eax
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    or   $1, %al
    add  $8, %ebp
# cons end
    movl -4(%esp), %ebx
    movl -8(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx>=") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx>") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx<=") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx<") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx=") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f195979 0))) (closure () (f195979) (let () (vector-ref f195979 0))))
# emit-begin
#   expr=(begin (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx>=") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx>") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx<=") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx<") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx=") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f195979 0))) (closure () (f195979) (let () (vector-ref f195979 0))))
#   env=((f195979 . 0))
# emit-expr (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx>=") (vector-ref f195979 0)))
# emit-expr f195979
# emit-variable-ref
# env=((f195979 . 0))
# var=f195979
    movl 0(%esp), %eax  # stack load f195979
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1432082
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1432082:
    movl %eax, -4(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1432083"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1432083:
# check bounds on vector index
    movl -4(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1432085
    cmp  $0,%eax
    jge _L_1432084
_L_1432085:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1432084:
    movl %eax, -8(%esp)
# emit-expr (cons ((primitive-ref string->symbol) "fx>=") (vector-ref f195979 0))
# cons arg1=((primitive-ref string->symbol) "fx>=") arg2=(vector-ref f195979 0)
# emit-expr ((primitive-ref string->symbol) "fx>=")
# funcall
#    si   =-12
#    env  = ((f195979 . 0))
#    expr = (funcall (primitive-ref string->symbol) "fx>=")
# emit-expr (primitive-ref string->symbol)
    .extern mrc_string$m$gsymbol
    movl mrc_string$m$gsymbol,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1432086"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1432086":
   movl %eax,  -20(%esp)  # stash funcall-oper in closure slot
# emit-expr "fx>="
# string literal
    jmp _L_1432088
    .align 8,0x90
_L_1432087 :
    .int 16
    .ascii "fx>="
_L_1432088:
    movl $_L_1432087, %eax
    orl $6, %eax
    mov %eax, -24(%esp)  # arg fx>=
    movl -20(%esp), %edi   # load new closure to %edi
    add $-12, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $12, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    movl %eax, -12(%esp)
# emit-expr (vector-ref f195979 0)
# emit-expr f195979
# emit-variable-ref
# env=((f195979 . 0))
# var=f195979
    movl 0(%esp), %eax  # stack load f195979
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1432089
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1432089:
    movl %eax, -16(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1432090"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1432090:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1432092
    cmp  $0,%eax
    jge _L_1432091
_L_1432092:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1432091:
    movl -16(%esp), %esi
    movl -1(%eax,%esi), %eax
    movl %eax, 4(%ebp)
    movl -12(%esp), %eax
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    or   $1, %al
    add  $8, %ebp
# cons end
    movl -4(%esp), %ebx
    movl -8(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx>") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx<=") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx<") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx=") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f195979 0))) (closure () (f195979) (let () (vector-ref f195979 0))))
# emit-begin
#   expr=(begin (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx>") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx<=") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx<") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx=") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f195979 0))) (closure () (f195979) (let () (vector-ref f195979 0))))
#   env=((f195979 . 0))
# emit-expr (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx>") (vector-ref f195979 0)))
# emit-expr f195979
# emit-variable-ref
# env=((f195979 . 0))
# var=f195979
    movl 0(%esp), %eax  # stack load f195979
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1432093
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1432093:
    movl %eax, -4(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1432094"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1432094:
# check bounds on vector index
    movl -4(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1432096
    cmp  $0,%eax
    jge _L_1432095
_L_1432096:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1432095:
    movl %eax, -8(%esp)
# emit-expr (cons ((primitive-ref string->symbol) "fx>") (vector-ref f195979 0))
# cons arg1=((primitive-ref string->symbol) "fx>") arg2=(vector-ref f195979 0)
# emit-expr ((primitive-ref string->symbol) "fx>")
# funcall
#    si   =-12
#    env  = ((f195979 . 0))
#    expr = (funcall (primitive-ref string->symbol) "fx>")
# emit-expr (primitive-ref string->symbol)
    .extern mrc_string$m$gsymbol
    movl mrc_string$m$gsymbol,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1432097"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1432097":
   movl %eax,  -20(%esp)  # stash funcall-oper in closure slot
# emit-expr "fx>"
# string literal
    jmp _L_1432099
    .align 8,0x90
_L_1432098 :
    .int 12
    .ascii "fx>"
_L_1432099:
    movl $_L_1432098, %eax
    orl $6, %eax
    mov %eax, -24(%esp)  # arg fx>
    movl -20(%esp), %edi   # load new closure to %edi
    add $-12, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $12, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    movl %eax, -12(%esp)
# emit-expr (vector-ref f195979 0)
# emit-expr f195979
# emit-variable-ref
# env=((f195979 . 0))
# var=f195979
    movl 0(%esp), %eax  # stack load f195979
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1432100
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1432100:
    movl %eax, -16(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1432101"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1432101:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1432103
    cmp  $0,%eax
    jge _L_1432102
_L_1432103:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1432102:
    movl -16(%esp), %esi
    movl -1(%eax,%esi), %eax
    movl %eax, 4(%ebp)
    movl -12(%esp), %eax
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    or   $1, %al
    add  $8, %ebp
# cons end
    movl -4(%esp), %ebx
    movl -8(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx<=") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx<") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx=") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f195979 0))) (closure () (f195979) (let () (vector-ref f195979 0))))
# emit-begin
#   expr=(begin (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx<=") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx<") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx=") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f195979 0))) (closure () (f195979) (let () (vector-ref f195979 0))))
#   env=((f195979 . 0))
# emit-expr (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx<=") (vector-ref f195979 0)))
# emit-expr f195979
# emit-variable-ref
# env=((f195979 . 0))
# var=f195979
    movl 0(%esp), %eax  # stack load f195979
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1432104
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1432104:
    movl %eax, -4(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1432105"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1432105:
# check bounds on vector index
    movl -4(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1432107
    cmp  $0,%eax
    jge _L_1432106
_L_1432107:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1432106:
    movl %eax, -8(%esp)
# emit-expr (cons ((primitive-ref string->symbol) "fx<=") (vector-ref f195979 0))
# cons arg1=((primitive-ref string->symbol) "fx<=") arg2=(vector-ref f195979 0)
# emit-expr ((primitive-ref string->symbol) "fx<=")
# funcall
#    si   =-12
#    env  = ((f195979 . 0))
#    expr = (funcall (primitive-ref string->symbol) "fx<=")
# emit-expr (primitive-ref string->symbol)
    .extern mrc_string$m$gsymbol
    movl mrc_string$m$gsymbol,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1432108"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1432108":
   movl %eax,  -20(%esp)  # stash funcall-oper in closure slot
# emit-expr "fx<="
# string literal
    jmp _L_1432110
    .align 8,0x90
_L_1432109 :
    .int 16
    .ascii "fx<="
_L_1432110:
    movl $_L_1432109, %eax
    orl $6, %eax
    mov %eax, -24(%esp)  # arg fx<=
    movl -20(%esp), %edi   # load new closure to %edi
    add $-12, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $12, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    movl %eax, -12(%esp)
# emit-expr (vector-ref f195979 0)
# emit-expr f195979
# emit-variable-ref
# env=((f195979 . 0))
# var=f195979
    movl 0(%esp), %eax  # stack load f195979
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1432111
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1432111:
    movl %eax, -16(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1432112"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1432112:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1432114
    cmp  $0,%eax
    jge _L_1432113
_L_1432114:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1432113:
    movl -16(%esp), %esi
    movl -1(%eax,%esi), %eax
    movl %eax, 4(%ebp)
    movl -12(%esp), %eax
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    or   $1, %al
    add  $8, %ebp
# cons end
    movl -4(%esp), %ebx
    movl -8(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx<") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx=") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f195979 0))) (closure () (f195979) (let () (vector-ref f195979 0))))
# emit-begin
#   expr=(begin (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx<") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx=") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f195979 0))) (closure () (f195979) (let () (vector-ref f195979 0))))
#   env=((f195979 . 0))
# emit-expr (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx<") (vector-ref f195979 0)))
# emit-expr f195979
# emit-variable-ref
# env=((f195979 . 0))
# var=f195979
    movl 0(%esp), %eax  # stack load f195979
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1432115
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1432115:
    movl %eax, -4(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1432116"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1432116:
# check bounds on vector index
    movl -4(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1432118
    cmp  $0,%eax
    jge _L_1432117
_L_1432118:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1432117:
    movl %eax, -8(%esp)
# emit-expr (cons ((primitive-ref string->symbol) "fx<") (vector-ref f195979 0))
# cons arg1=((primitive-ref string->symbol) "fx<") arg2=(vector-ref f195979 0)
# emit-expr ((primitive-ref string->symbol) "fx<")
# funcall
#    si   =-12
#    env  = ((f195979 . 0))
#    expr = (funcall (primitive-ref string->symbol) "fx<")
# emit-expr (primitive-ref string->symbol)
    .extern mrc_string$m$gsymbol
    movl mrc_string$m$gsymbol,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1432119"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1432119":
   movl %eax,  -20(%esp)  # stash funcall-oper in closure slot
# emit-expr "fx<"
# string literal
    jmp _L_1432121
    .align 8,0x90
_L_1432120 :
    .int 12
    .ascii "fx<"
_L_1432121:
    movl $_L_1432120, %eax
    orl $6, %eax
    mov %eax, -24(%esp)  # arg fx<
    movl -20(%esp), %edi   # load new closure to %edi
    add $-12, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $12, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    movl %eax, -12(%esp)
# emit-expr (vector-ref f195979 0)
# emit-expr f195979
# emit-variable-ref
# env=((f195979 . 0))
# var=f195979
    movl 0(%esp), %eax  # stack load f195979
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1432122
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1432122:
    movl %eax, -16(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1432123"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1432123:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1432125
    cmp  $0,%eax
    jge _L_1432124
_L_1432125:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1432124:
    movl -16(%esp), %esi
    movl -1(%eax,%esi), %eax
    movl %eax, 4(%ebp)
    movl -12(%esp), %eax
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    or   $1, %al
    add  $8, %ebp
# cons end
    movl -4(%esp), %ebx
    movl -8(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx=") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f195979 0))) (closure () (f195979) (let () (vector-ref f195979 0))))
# emit-begin
#   expr=(begin (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx=") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f195979 0))) (closure () (f195979) (let () (vector-ref f195979 0))))
#   env=((f195979 . 0))
# emit-expr (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fx=") (vector-ref f195979 0)))
# emit-expr f195979
# emit-variable-ref
# env=((f195979 . 0))
# var=f195979
    movl 0(%esp), %eax  # stack load f195979
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1432126
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1432126:
    movl %eax, -4(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1432127"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1432127:
# check bounds on vector index
    movl -4(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1432129
    cmp  $0,%eax
    jge _L_1432128
_L_1432129:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1432128:
    movl %eax, -8(%esp)
# emit-expr (cons ((primitive-ref string->symbol) "fx=") (vector-ref f195979 0))
# cons arg1=((primitive-ref string->symbol) "fx=") arg2=(vector-ref f195979 0)
# emit-expr ((primitive-ref string->symbol) "fx=")
# funcall
#    si   =-12
#    env  = ((f195979 . 0))
#    expr = (funcall (primitive-ref string->symbol) "fx=")
# emit-expr (primitive-ref string->symbol)
    .extern mrc_string$m$gsymbol
    movl mrc_string$m$gsymbol,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1432130"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1432130":
   movl %eax,  -20(%esp)  # stash funcall-oper in closure slot
# emit-expr "fx="
# string literal
    jmp _L_1432132
    .align 8,0x90
_L_1432131 :
    .int 12
    .ascii "fx="
_L_1432132:
    movl $_L_1432131, %eax
    orl $6, %eax
    mov %eax, -24(%esp)  # arg fx=
    movl -20(%esp), %edi   # load new closure to %edi
    add $-12, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $12, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    movl %eax, -12(%esp)
# emit-expr (vector-ref f195979 0)
# emit-expr f195979
# emit-variable-ref
# env=((f195979 . 0))
# var=f195979
    movl 0(%esp), %eax  # stack load f195979
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1432133
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1432133:
    movl %eax, -16(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1432134"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1432134:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1432136
    cmp  $0,%eax
    jge _L_1432135
_L_1432136:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1432135:
    movl -16(%esp), %esi
    movl -1(%eax,%esi), %eax
    movl %eax, 4(%ebp)
    movl -12(%esp), %eax
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    or   $1, %al
    add  $8, %ebp
# cons end
    movl -4(%esp), %ebx
    movl -8(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f195979 0))) (closure () (f195979) (let () (vector-ref f195979 0))))
# emit-begin
#   expr=(begin (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f195979 0))) (closure () (f195979) (let () (vector-ref f195979 0))))
#   env=((f195979 . 0))
# emit-expr (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f195979 0)))
# emit-expr f195979
# emit-variable-ref
# env=((f195979 . 0))
# var=f195979
    movl 0(%esp), %eax  # stack load f195979
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1432137
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1432137:
    movl %eax, -4(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1432138"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1432138:
# check bounds on vector index
    movl -4(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1432140
    cmp  $0,%eax
    jge _L_1432139
_L_1432140:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1432139:
    movl %eax, -8(%esp)
# emit-expr (cons ((primitive-ref string->symbol) "fxzero?") (vector-ref f195979 0))
# cons arg1=((primitive-ref string->symbol) "fxzero?") arg2=(vector-ref f195979 0)
# emit-expr ((primitive-ref string->symbol) "fxzero?")
# funcall
#    si   =-12
#    env  = ((f195979 . 0))
#    expr = (funcall (primitive-ref string->symbol) "fxzero?")
# emit-expr (primitive-ref string->symbol)
    .extern mrc_string$m$gsymbol
    movl mrc_string$m$gsymbol,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1432141"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1432141":
   movl %eax,  -20(%esp)  # stash funcall-oper in closure slot
# emit-expr "fxzero?"
# string literal
    jmp _L_1432143
    .align 8,0x90
_L_1432142 :
    .int 28
    .ascii "fxzero?"
_L_1432143:
    movl $_L_1432142, %eax
    orl $6, %eax
    mov %eax, -24(%esp)  # arg fxzero?
    movl -20(%esp), %edi   # load new closure to %edi
    add $-12, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $12, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    movl %eax, -12(%esp)
# emit-expr (vector-ref f195979 0)
# emit-expr f195979
# emit-variable-ref
# env=((f195979 . 0))
# var=f195979
    movl 0(%esp), %eax  # stack load f195979
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1432144
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1432144:
    movl %eax, -16(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1432145"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1432145:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1432147
    cmp  $0,%eax
    jge _L_1432146
_L_1432147:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1432146:
    movl -16(%esp), %esi
    movl -1(%eax,%esi), %eax
    movl %eax, 4(%ebp)
    movl -12(%esp), %eax
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    or   $1, %al
    add  $8, %ebp
# cons end
    movl -4(%esp), %ebx
    movl -8(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f195979 0))) (closure () (f195979) (let () (vector-ref f195979 0))))
# emit-begin
#   expr=(begin (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f195979 0))) (closure () (f195979) (let () (vector-ref f195979 0))))
#   env=((f195979 . 0))
# emit-expr (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f195979 0)))
# emit-expr f195979
# emit-variable-ref
# env=((f195979 . 0))
# var=f195979
    movl 0(%esp), %eax  # stack load f195979
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1432148
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1432148:
    movl %eax, -4(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1432149"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1432149:
# check bounds on vector index
    movl -4(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1432151
    cmp  $0,%eax
    jge _L_1432150
_L_1432151:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1432150:
    movl %eax, -8(%esp)
# emit-expr (cons ((primitive-ref string->symbol) "fxsub1") (vector-ref f195979 0))
# cons arg1=((primitive-ref string->symbol) "fxsub1") arg2=(vector-ref f195979 0)
# emit-expr ((primitive-ref string->symbol) "fxsub1")
# funcall
#    si   =-12
#    env  = ((f195979 . 0))
#    expr = (funcall (primitive-ref string->symbol) "fxsub1")
# emit-expr (primitive-ref string->symbol)
    .extern mrc_string$m$gsymbol
    movl mrc_string$m$gsymbol,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1432152"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1432152":
   movl %eax,  -20(%esp)  # stash funcall-oper in closure slot
# emit-expr "fxsub1"
# string literal
    jmp _L_1432154
    .align 8,0x90
_L_1432153 :
    .int 24
    .ascii "fxsub1"
_L_1432154:
    movl $_L_1432153, %eax
    orl $6, %eax
    mov %eax, -24(%esp)  # arg fxsub1
    movl -20(%esp), %edi   # load new closure to %edi
    add $-12, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $12, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    movl %eax, -12(%esp)
# emit-expr (vector-ref f195979 0)
# emit-expr f195979
# emit-variable-ref
# env=((f195979 . 0))
# var=f195979
    movl 0(%esp), %eax  # stack load f195979
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1432155
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1432155:
    movl %eax, -16(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1432156"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1432156:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1432158
    cmp  $0,%eax
    jge _L_1432157
_L_1432158:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1432157:
    movl -16(%esp), %esi
    movl -1(%eax,%esi), %eax
    movl %eax, 4(%ebp)
    movl -12(%esp), %eax
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    or   $1, %al
    add  $8, %ebp
# cons end
    movl -4(%esp), %ebx
    movl -8(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f195979 0))) (closure () (f195979) (let () (vector-ref f195979 0))))
# emit-begin
#   expr=(begin (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f195979 0))) (closure () (f195979) (let () (vector-ref f195979 0))))
#   env=((f195979 . 0))
# emit-expr (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f195979 0)))
# emit-expr f195979
# emit-variable-ref
# env=((f195979 . 0))
# var=f195979
    movl 0(%esp), %eax  # stack load f195979
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1432159
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1432159:
    movl %eax, -4(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1432160"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1432160:
# check bounds on vector index
    movl -4(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1432162
    cmp  $0,%eax
    jge _L_1432161
_L_1432162:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1432161:
    movl %eax, -8(%esp)
# emit-expr (cons ((primitive-ref string->symbol) "fxadd1") (vector-ref f195979 0))
# cons arg1=((primitive-ref string->symbol) "fxadd1") arg2=(vector-ref f195979 0)
# emit-expr ((primitive-ref string->symbol) "fxadd1")
# funcall
#    si   =-12
#    env  = ((f195979 . 0))
#    expr = (funcall (primitive-ref string->symbol) "fxadd1")
# emit-expr (primitive-ref string->symbol)
    .extern mrc_string$m$gsymbol
    movl mrc_string$m$gsymbol,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1432163"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1432163":
   movl %eax,  -20(%esp)  # stash funcall-oper in closure slot
# emit-expr "fxadd1"
# string literal
    jmp _L_1432165
    .align 8,0x90
_L_1432164 :
    .int 24
    .ascii "fxadd1"
_L_1432165:
    movl $_L_1432164, %eax
    orl $6, %eax
    mov %eax, -24(%esp)  # arg fxadd1
    movl -20(%esp), %edi   # load new closure to %edi
    add $-12, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $12, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    movl %eax, -12(%esp)
# emit-expr (vector-ref f195979 0)
# emit-expr f195979
# emit-variable-ref
# env=((f195979 . 0))
# var=f195979
    movl 0(%esp), %eax  # stack load f195979
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1432166
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1432166:
    movl %eax, -16(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1432167"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1432167:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1432169
    cmp  $0,%eax
    jge _L_1432168
_L_1432169:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1432168:
    movl -16(%esp), %esi
    movl -1(%eax,%esi), %eax
    movl %eax, 4(%ebp)
    movl -12(%esp), %eax
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    or   $1, %al
    add  $8, %ebp
# cons end
    movl -4(%esp), %ebx
    movl -8(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f195979 0))) (closure () (f195979) (let () (vector-ref f195979 0))))
# emit-begin
#   expr=(begin (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f195979 0))) (closure () (f195979) (let () (vector-ref f195979 0))))
#   env=((f195979 . 0))
# emit-expr (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f195979 0)))
# emit-expr f195979
# emit-variable-ref
# env=((f195979 . 0))
# var=f195979
    movl 0(%esp), %eax  # stack load f195979
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1432170
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1432170:
    movl %eax, -4(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1432171"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1432171:
# check bounds on vector index
    movl -4(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1432173
    cmp  $0,%eax
    jge _L_1432172
_L_1432173:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1432172:
    movl %eax, -8(%esp)
# emit-expr (cons ((primitive-ref string->symbol) "fxlogor") (vector-ref f195979 0))
# cons arg1=((primitive-ref string->symbol) "fxlogor") arg2=(vector-ref f195979 0)
# emit-expr ((primitive-ref string->symbol) "fxlogor")
# funcall
#    si   =-12
#    env  = ((f195979 . 0))
#    expr = (funcall (primitive-ref string->symbol) "fxlogor")
# emit-expr (primitive-ref string->symbol)
    .extern mrc_string$m$gsymbol
    movl mrc_string$m$gsymbol,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1432174"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1432174":
   movl %eax,  -20(%esp)  # stash funcall-oper in closure slot
# emit-expr "fxlogor"
# string literal
    jmp _L_1432176
    .align 8,0x90
_L_1432175 :
    .int 28
    .ascii "fxlogor"
_L_1432176:
    movl $_L_1432175, %eax
    orl $6, %eax
    mov %eax, -24(%esp)  # arg fxlogor
    movl -20(%esp), %edi   # load new closure to %edi
    add $-12, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $12, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    movl %eax, -12(%esp)
# emit-expr (vector-ref f195979 0)
# emit-expr f195979
# emit-variable-ref
# env=((f195979 . 0))
# var=f195979
    movl 0(%esp), %eax  # stack load f195979
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1432177
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1432177:
    movl %eax, -16(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1432178"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1432178:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1432180
    cmp  $0,%eax
    jge _L_1432179
_L_1432180:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1432179:
    movl -16(%esp), %esi
    movl -1(%eax,%esi), %eax
    movl %eax, 4(%ebp)
    movl -12(%esp), %eax
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    or   $1, %al
    add  $8, %ebp
# cons end
    movl -4(%esp), %ebx
    movl -8(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f195979 0))) (closure () (f195979) (let () (vector-ref f195979 0))))
# emit-begin
#   expr=(begin (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f195979 0))) (closure () (f195979) (let () (vector-ref f195979 0))))
#   env=((f195979 . 0))
# emit-expr (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f195979 0)))
# emit-expr f195979
# emit-variable-ref
# env=((f195979 . 0))
# var=f195979
    movl 0(%esp), %eax  # stack load f195979
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1432181
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1432181:
    movl %eax, -4(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1432182"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1432182:
# check bounds on vector index
    movl -4(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1432184
    cmp  $0,%eax
    jge _L_1432183
_L_1432184:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1432183:
    movl %eax, -8(%esp)
# emit-expr (cons ((primitive-ref string->symbol) "fxlogand") (vector-ref f195979 0))
# cons arg1=((primitive-ref string->symbol) "fxlogand") arg2=(vector-ref f195979 0)
# emit-expr ((primitive-ref string->symbol) "fxlogand")
# funcall
#    si   =-12
#    env  = ((f195979 . 0))
#    expr = (funcall (primitive-ref string->symbol) "fxlogand")
# emit-expr (primitive-ref string->symbol)
    .extern mrc_string$m$gsymbol
    movl mrc_string$m$gsymbol,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1432185"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1432185":
   movl %eax,  -20(%esp)  # stash funcall-oper in closure slot
# emit-expr "fxlogand"
# string literal
    jmp _L_1432187
    .align 8,0x90
_L_1432186 :
    .int 32
    .ascii "fxlogand"
_L_1432187:
    movl $_L_1432186, %eax
    orl $6, %eax
    mov %eax, -24(%esp)  # arg fxlogand
    movl -20(%esp), %edi   # load new closure to %edi
    add $-12, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $12, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    movl %eax, -12(%esp)
# emit-expr (vector-ref f195979 0)
# emit-expr f195979
# emit-variable-ref
# env=((f195979 . 0))
# var=f195979
    movl 0(%esp), %eax  # stack load f195979
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1432188
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1432188:
    movl %eax, -16(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1432189"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1432189:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1432191
    cmp  $0,%eax
    jge _L_1432190
_L_1432191:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1432190:
    movl -16(%esp), %esi
    movl -1(%eax,%esi), %eax
    movl %eax, 4(%ebp)
    movl -12(%esp), %eax
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    or   $1, %al
    add  $8, %ebp
# cons end
    movl -4(%esp), %ebx
    movl -8(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f195979 0))) (closure () (f195979) (let () (vector-ref f195979 0))))
# emit-begin
#   expr=(begin (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f195979 0))) (closure () (f195979) (let () (vector-ref f195979 0))))
#   env=((f195979 . 0))
# emit-expr (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f195979 0)))
# emit-expr f195979
# emit-variable-ref
# env=((f195979 . 0))
# var=f195979
    movl 0(%esp), %eax  # stack load f195979
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1432192
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1432192:
    movl %eax, -4(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1432193"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1432193:
# check bounds on vector index
    movl -4(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1432195
    cmp  $0,%eax
    jge _L_1432194
_L_1432195:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1432194:
    movl %eax, -8(%esp)
# emit-expr (cons ((primitive-ref string->symbol) "fxlognot") (vector-ref f195979 0))
# cons arg1=((primitive-ref string->symbol) "fxlognot") arg2=(vector-ref f195979 0)
# emit-expr ((primitive-ref string->symbol) "fxlognot")
# funcall
#    si   =-12
#    env  = ((f195979 . 0))
#    expr = (funcall (primitive-ref string->symbol) "fxlognot")
# emit-expr (primitive-ref string->symbol)
    .extern mrc_string$m$gsymbol
    movl mrc_string$m$gsymbol,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1432196"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1432196":
   movl %eax,  -20(%esp)  # stash funcall-oper in closure slot
# emit-expr "fxlognot"
# string literal
    jmp _L_1432198
    .align 8,0x90
_L_1432197 :
    .int 32
    .ascii "fxlognot"
_L_1432198:
    movl $_L_1432197, %eax
    orl $6, %eax
    mov %eax, -24(%esp)  # arg fxlognot
    movl -20(%esp), %edi   # load new closure to %edi
    add $-12, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $12, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    movl %eax, -12(%esp)
# emit-expr (vector-ref f195979 0)
# emit-expr f195979
# emit-variable-ref
# env=((f195979 . 0))
# var=f195979
    movl 0(%esp), %eax  # stack load f195979
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1432199
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1432199:
    movl %eax, -16(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1432200"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1432200:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1432202
    cmp  $0,%eax
    jge _L_1432201
_L_1432202:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1432201:
    movl -16(%esp), %esi
    movl -1(%eax,%esi), %eax
    movl %eax, 4(%ebp)
    movl -12(%esp), %eax
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    or   $1, %al
    add  $8, %ebp
# cons end
    movl -4(%esp), %ebx
    movl -8(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f195979 0))) (closure () (f195979) (let () (vector-ref f195979 0))))
# emit-begin
#   expr=(begin (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f195979 0))) (closure () (f195979) (let () (vector-ref f195979 0))))
#   env=((f195979 . 0))
# emit-expr (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "char=?") (vector-ref f195979 0)))
# emit-expr f195979
# emit-variable-ref
# env=((f195979 . 0))
# var=f195979
    movl 0(%esp), %eax  # stack load f195979
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1432203
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1432203:
    movl %eax, -4(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1432204"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1432204:
# check bounds on vector index
    movl -4(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1432206
    cmp  $0,%eax
    jge _L_1432205
_L_1432206:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1432205:
    movl %eax, -8(%esp)
# emit-expr (cons ((primitive-ref string->symbol) "char=?") (vector-ref f195979 0))
# cons arg1=((primitive-ref string->symbol) "char=?") arg2=(vector-ref f195979 0)
# emit-expr ((primitive-ref string->symbol) "char=?")
# funcall
#    si   =-12
#    env  = ((f195979 . 0))
#    expr = (funcall (primitive-ref string->symbol) "char=?")
# emit-expr (primitive-ref string->symbol)
    .extern mrc_string$m$gsymbol
    movl mrc_string$m$gsymbol,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1432207"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1432207":
   movl %eax,  -20(%esp)  # stash funcall-oper in closure slot
# emit-expr "char=?"
# string literal
    jmp _L_1432209
    .align 8,0x90
_L_1432208 :
    .int 24
    .ascii "char=?"
_L_1432209:
    movl $_L_1432208, %eax
    orl $6, %eax
    mov %eax, -24(%esp)  # arg char=?
    movl -20(%esp), %edi   # load new closure to %edi
    add $-12, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $12, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    movl %eax, -12(%esp)
# emit-expr (vector-ref f195979 0)
# emit-expr f195979
# emit-variable-ref
# env=((f195979 . 0))
# var=f195979
    movl 0(%esp), %eax  # stack load f195979
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1432210
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1432210:
    movl %eax, -16(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1432211"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1432211:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1432213
    cmp  $0,%eax
    jge _L_1432212
_L_1432213:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1432212:
    movl -16(%esp), %esi
    movl -1(%eax,%esi), %eax
    movl %eax, 4(%ebp)
    movl -12(%esp), %eax
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    or   $1, %al
    add  $8, %ebp
# cons end
    movl -4(%esp), %ebx
    movl -8(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f195979 0))) (closure () (f195979) (let () (vector-ref f195979 0))))
# emit-begin
#   expr=(begin (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f195979 0))) (closure () (f195979) (let () (vector-ref f195979 0))))
#   env=((f195979 . 0))
# emit-expr (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "eq?") (vector-ref f195979 0)))
# emit-expr f195979
# emit-variable-ref
# env=((f195979 . 0))
# var=f195979
    movl 0(%esp), %eax  # stack load f195979
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1432214
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1432214:
    movl %eax, -4(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1432215"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1432215:
# check bounds on vector index
    movl -4(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1432217
    cmp  $0,%eax
    jge _L_1432216
_L_1432217:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1432216:
    movl %eax, -8(%esp)
# emit-expr (cons ((primitive-ref string->symbol) "eq?") (vector-ref f195979 0))
# cons arg1=((primitive-ref string->symbol) "eq?") arg2=(vector-ref f195979 0)
# emit-expr ((primitive-ref string->symbol) "eq?")
# funcall
#    si   =-12
#    env  = ((f195979 . 0))
#    expr = (funcall (primitive-ref string->symbol) "eq?")
# emit-expr (primitive-ref string->symbol)
    .extern mrc_string$m$gsymbol
    movl mrc_string$m$gsymbol,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1432218"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1432218":
   movl %eax,  -20(%esp)  # stash funcall-oper in closure slot
# emit-expr "eq?"
# string literal
    jmp _L_1432220
    .align 8,0x90
_L_1432219 :
    .int 12
    .ascii "eq?"
_L_1432220:
    movl $_L_1432219, %eax
    orl $6, %eax
    mov %eax, -24(%esp)  # arg eq?
    movl -20(%esp), %edi   # load new closure to %edi
    add $-12, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $12, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    movl %eax, -12(%esp)
# emit-expr (vector-ref f195979 0)
# emit-expr f195979
# emit-variable-ref
# env=((f195979 . 0))
# var=f195979
    movl 0(%esp), %eax  # stack load f195979
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1432221
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1432221:
    movl %eax, -16(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1432222"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1432222:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1432224
    cmp  $0,%eax
    jge _L_1432223
_L_1432224:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1432223:
    movl -16(%esp), %esi
    movl -1(%eax,%esi), %eax
    movl %eax, 4(%ebp)
    movl -12(%esp), %eax
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    or   $1, %al
    add  $8, %ebp
# cons end
    movl -4(%esp), %ebx
    movl -8(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f195979 0))) (closure () (f195979) (let () (vector-ref f195979 0))))
# emit-begin
#   expr=(begin (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f195979 0))) (closure () (f195979) (let () (vector-ref f195979 0))))
#   env=((f195979 . 0))
# emit-expr (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "not") (vector-ref f195979 0)))
# emit-expr f195979
# emit-variable-ref
# env=((f195979 . 0))
# var=f195979
    movl 0(%esp), %eax  # stack load f195979
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1432225
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1432225:
    movl %eax, -4(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1432226"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1432226:
# check bounds on vector index
    movl -4(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1432228
    cmp  $0,%eax
    jge _L_1432227
_L_1432228:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1432227:
    movl %eax, -8(%esp)
# emit-expr (cons ((primitive-ref string->symbol) "not") (vector-ref f195979 0))
# cons arg1=((primitive-ref string->symbol) "not") arg2=(vector-ref f195979 0)
# emit-expr ((primitive-ref string->symbol) "not")
# funcall
#    si   =-12
#    env  = ((f195979 . 0))
#    expr = (funcall (primitive-ref string->symbol) "not")
# emit-expr (primitive-ref string->symbol)
    .extern mrc_string$m$gsymbol
    movl mrc_string$m$gsymbol,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1432229"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1432229":
   movl %eax,  -20(%esp)  # stash funcall-oper in closure slot
# emit-expr "not"
# string literal
    jmp _L_1432231
    .align 8,0x90
_L_1432230 :
    .int 12
    .ascii "not"
_L_1432231:
    movl $_L_1432230, %eax
    orl $6, %eax
    mov %eax, -24(%esp)  # arg not
    movl -20(%esp), %edi   # load new closure to %edi
    add $-12, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $12, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    movl %eax, -12(%esp)
# emit-expr (vector-ref f195979 0)
# emit-expr f195979
# emit-variable-ref
# env=((f195979 . 0))
# var=f195979
    movl 0(%esp), %eax  # stack load f195979
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1432232
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1432232:
    movl %eax, -16(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1432233"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1432233:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1432235
    cmp  $0,%eax
    jge _L_1432234
_L_1432235:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1432234:
    movl -16(%esp), %esi
    movl -1(%eax,%esi), %eax
    movl %eax, 4(%ebp)
    movl -12(%esp), %eax
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    or   $1, %al
    add  $8, %ebp
# cons end
    movl -4(%esp), %ebx
    movl -8(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f195979 0))) (closure () (f195979) (let () (vector-ref f195979 0))))
# emit-begin
#   expr=(begin (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f195979 0))) (closure () (f195979) (let () (vector-ref f195979 0))))
#   env=((f195979 . 0))
# emit-expr (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f195979 0)))
# emit-expr f195979
# emit-variable-ref
# env=((f195979 . 0))
# var=f195979
    movl 0(%esp), %eax  # stack load f195979
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1432236
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1432236:
    movl %eax, -4(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1432237"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1432237:
# check bounds on vector index
    movl -4(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1432239
    cmp  $0,%eax
    jge _L_1432238
_L_1432239:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1432238:
    movl %eax, -8(%esp)
# emit-expr (cons ((primitive-ref string->symbol) "boolean?") (vector-ref f195979 0))
# cons arg1=((primitive-ref string->symbol) "boolean?") arg2=(vector-ref f195979 0)
# emit-expr ((primitive-ref string->symbol) "boolean?")
# funcall
#    si   =-12
#    env  = ((f195979 . 0))
#    expr = (funcall (primitive-ref string->symbol) "boolean?")
# emit-expr (primitive-ref string->symbol)
    .extern mrc_string$m$gsymbol
    movl mrc_string$m$gsymbol,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1432240"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1432240":
   movl %eax,  -20(%esp)  # stash funcall-oper in closure slot
# emit-expr "boolean?"
# string literal
    jmp _L_1432242
    .align 8,0x90
_L_1432241 :
    .int 32
    .ascii "boolean?"
_L_1432242:
    movl $_L_1432241, %eax
    orl $6, %eax
    mov %eax, -24(%esp)  # arg boolean?
    movl -20(%esp), %edi   # load new closure to %edi
    add $-12, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $12, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    movl %eax, -12(%esp)
# emit-expr (vector-ref f195979 0)
# emit-expr f195979
# emit-variable-ref
# env=((f195979 . 0))
# var=f195979
    movl 0(%esp), %eax  # stack load f195979
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1432243
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1432243:
    movl %eax, -16(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1432244"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1432244:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1432246
    cmp  $0,%eax
    jge _L_1432245
_L_1432246:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1432245:
    movl -16(%esp), %esi
    movl -1(%eax,%esi), %eax
    movl %eax, 4(%ebp)
    movl -12(%esp), %eax
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    or   $1, %al
    add  $8, %ebp
# cons end
    movl -4(%esp), %ebx
    movl -8(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f195979 0))) (closure () (f195979) (let () (vector-ref f195979 0))))
# emit-begin
#   expr=(begin (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f195979 0))) (closure () (f195979) (let () (vector-ref f195979 0))))
#   env=((f195979 . 0))
# emit-expr (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f195979 0)))
# emit-expr f195979
# emit-variable-ref
# env=((f195979 . 0))
# var=f195979
    movl 0(%esp), %eax  # stack load f195979
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1432247
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1432247:
    movl %eax, -4(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1432248"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1432248:
# check bounds on vector index
    movl -4(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1432250
    cmp  $0,%eax
    jge _L_1432249
_L_1432250:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1432249:
    movl %eax, -8(%esp)
# emit-expr (cons ((primitive-ref string->symbol) "fixnum?") (vector-ref f195979 0))
# cons arg1=((primitive-ref string->symbol) "fixnum?") arg2=(vector-ref f195979 0)
# emit-expr ((primitive-ref string->symbol) "fixnum?")
# funcall
#    si   =-12
#    env  = ((f195979 . 0))
#    expr = (funcall (primitive-ref string->symbol) "fixnum?")
# emit-expr (primitive-ref string->symbol)
    .extern mrc_string$m$gsymbol
    movl mrc_string$m$gsymbol,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1432251"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1432251":
   movl %eax,  -20(%esp)  # stash funcall-oper in closure slot
# emit-expr "fixnum?"
# string literal
    jmp _L_1432253
    .align 8,0x90
_L_1432252 :
    .int 28
    .ascii "fixnum?"
_L_1432253:
    movl $_L_1432252, %eax
    orl $6, %eax
    mov %eax, -24(%esp)  # arg fixnum?
    movl -20(%esp), %edi   # load new closure to %edi
    add $-12, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $12, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    movl %eax, -12(%esp)
# emit-expr (vector-ref f195979 0)
# emit-expr f195979
# emit-variable-ref
# env=((f195979 . 0))
# var=f195979
    movl 0(%esp), %eax  # stack load f195979
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1432254
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1432254:
    movl %eax, -16(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1432255"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1432255:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1432257
    cmp  $0,%eax
    jge _L_1432256
_L_1432257:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1432256:
    movl -16(%esp), %esi
    movl -1(%eax,%esi), %eax
    movl %eax, 4(%ebp)
    movl -12(%esp), %eax
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    or   $1, %al
    add  $8, %ebp
# cons end
    movl -4(%esp), %ebx
    movl -8(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f195979 0))) (closure () (f195979) (let () (vector-ref f195979 0))))
# emit-begin
#   expr=(begin (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f195979 0))) (closure () (f195979) (let () (vector-ref f195979 0))))
#   env=((f195979 . 0))
# emit-expr (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "char?") (vector-ref f195979 0)))
# emit-expr f195979
# emit-variable-ref
# env=((f195979 . 0))
# var=f195979
    movl 0(%esp), %eax  # stack load f195979
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1432258
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1432258:
    movl %eax, -4(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1432259"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1432259:
# check bounds on vector index
    movl -4(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1432261
    cmp  $0,%eax
    jge _L_1432260
_L_1432261:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1432260:
    movl %eax, -8(%esp)
# emit-expr (cons ((primitive-ref string->symbol) "char?") (vector-ref f195979 0))
# cons arg1=((primitive-ref string->symbol) "char?") arg2=(vector-ref f195979 0)
# emit-expr ((primitive-ref string->symbol) "char?")
# funcall
#    si   =-12
#    env  = ((f195979 . 0))
#    expr = (funcall (primitive-ref string->symbol) "char?")
# emit-expr (primitive-ref string->symbol)
    .extern mrc_string$m$gsymbol
    movl mrc_string$m$gsymbol,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1432262"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1432262":
   movl %eax,  -20(%esp)  # stash funcall-oper in closure slot
# emit-expr "char?"
# string literal
    jmp _L_1432264
    .align 8,0x90
_L_1432263 :
    .int 20
    .ascii "char?"
_L_1432264:
    movl $_L_1432263, %eax
    orl $6, %eax
    mov %eax, -24(%esp)  # arg char?
    movl -20(%esp), %edi   # load new closure to %edi
    add $-12, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $12, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    movl %eax, -12(%esp)
# emit-expr (vector-ref f195979 0)
# emit-expr f195979
# emit-variable-ref
# env=((f195979 . 0))
# var=f195979
    movl 0(%esp), %eax  # stack load f195979
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1432265
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1432265:
    movl %eax, -16(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1432266"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1432266:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1432268
    cmp  $0,%eax
    jge _L_1432267
_L_1432268:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1432267:
    movl -16(%esp), %esi
    movl -1(%eax,%esi), %eax
    movl %eax, 4(%ebp)
    movl -12(%esp), %eax
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    or   $1, %al
    add  $8, %ebp
# cons end
    movl -4(%esp), %ebx
    movl -8(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f195979 0))) (closure () (f195979) (let () (vector-ref f195979 0))))
# emit-begin
#   expr=(begin (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f195979 0))) (closure () (f195979) (let () (vector-ref f195979 0))))
#   env=((f195979 . 0))
# emit-expr (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "null?") (vector-ref f195979 0)))
# emit-expr f195979
# emit-variable-ref
# env=((f195979 . 0))
# var=f195979
    movl 0(%esp), %eax  # stack load f195979
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1432269
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1432269:
    movl %eax, -4(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1432270"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1432270:
# check bounds on vector index
    movl -4(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1432272
    cmp  $0,%eax
    jge _L_1432271
_L_1432272:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1432271:
    movl %eax, -8(%esp)
# emit-expr (cons ((primitive-ref string->symbol) "null?") (vector-ref f195979 0))
# cons arg1=((primitive-ref string->symbol) "null?") arg2=(vector-ref f195979 0)
# emit-expr ((primitive-ref string->symbol) "null?")
# funcall
#    si   =-12
#    env  = ((f195979 . 0))
#    expr = (funcall (primitive-ref string->symbol) "null?")
# emit-expr (primitive-ref string->symbol)
    .extern mrc_string$m$gsymbol
    movl mrc_string$m$gsymbol,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1432273"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1432273":
   movl %eax,  -20(%esp)  # stash funcall-oper in closure slot
# emit-expr "null?"
# string literal
    jmp _L_1432275
    .align 8,0x90
_L_1432274 :
    .int 20
    .ascii "null?"
_L_1432275:
    movl $_L_1432274, %eax
    orl $6, %eax
    mov %eax, -24(%esp)  # arg null?
    movl -20(%esp), %edi   # load new closure to %edi
    add $-12, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $12, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    movl %eax, -12(%esp)
# emit-expr (vector-ref f195979 0)
# emit-expr f195979
# emit-variable-ref
# env=((f195979 . 0))
# var=f195979
    movl 0(%esp), %eax  # stack load f195979
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1432276
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1432276:
    movl %eax, -16(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1432277"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1432277:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1432279
    cmp  $0,%eax
    jge _L_1432278
_L_1432279:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1432278:
    movl -16(%esp), %esi
    movl -1(%eax,%esi), %eax
    movl %eax, 4(%ebp)
    movl -12(%esp), %eax
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    or   $1, %al
    add  $8, %ebp
# cons end
    movl -4(%esp), %ebx
    movl -8(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f195979 0))) (closure () (f195979) (let () (vector-ref f195979 0))))
# emit-begin
#   expr=(begin (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f195979 0))) (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f195979 0))) (closure () (f195979) (let () (vector-ref f195979 0))))
#   env=((f195979 . 0))
# emit-expr (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f195979 0)))
# emit-expr f195979
# emit-variable-ref
# env=((f195979 . 0))
# var=f195979
    movl 0(%esp), %eax  # stack load f195979
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1432280
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1432280:
    movl %eax, -4(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1432281"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1432281:
# check bounds on vector index
    movl -4(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1432283
    cmp  $0,%eax
    jge _L_1432282
_L_1432283:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1432282:
    movl %eax, -8(%esp)
# emit-expr (cons ((primitive-ref string->symbol) "char->fixnum") (vector-ref f195979 0))
# cons arg1=((primitive-ref string->symbol) "char->fixnum") arg2=(vector-ref f195979 0)
# emit-expr ((primitive-ref string->symbol) "char->fixnum")
# funcall
#    si   =-12
#    env  = ((f195979 . 0))
#    expr = (funcall (primitive-ref string->symbol) "char->fixnum")
# emit-expr (primitive-ref string->symbol)
    .extern mrc_string$m$gsymbol
    movl mrc_string$m$gsymbol,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1432284"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1432284":
   movl %eax,  -20(%esp)  # stash funcall-oper in closure slot
# emit-expr "char->fixnum"
# string literal
    jmp _L_1432286
    .align 8,0x90
_L_1432285 :
    .int 48
    .ascii "char->fixnum"
_L_1432286:
    movl $_L_1432285, %eax
    orl $6, %eax
    mov %eax, -24(%esp)  # arg char->fixnum
    movl -20(%esp), %edi   # load new closure to %edi
    add $-12, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $12, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    movl %eax, -12(%esp)
# emit-expr (vector-ref f195979 0)
# emit-expr f195979
# emit-variable-ref
# env=((f195979 . 0))
# var=f195979
    movl 0(%esp), %eax  # stack load f195979
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1432287
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1432287:
    movl %eax, -16(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1432288"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1432288:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1432290
    cmp  $0,%eax
    jge _L_1432289
_L_1432290:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1432289:
    movl -16(%esp), %esi
    movl -1(%eax,%esi), %eax
    movl %eax, 4(%ebp)
    movl -12(%esp), %eax
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    or   $1, %al
    add  $8, %ebp
# cons end
    movl -4(%esp), %ebx
    movl -8(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f195979 0))) (closure () (f195979) (let () (vector-ref f195979 0))))
# emit-begin
#   expr=(begin (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f195979 0))) (closure () (f195979) (let () (vector-ref f195979 0))))
#   env=((f195979 . 0))
# emit-expr (vector-set! f195979 0 (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f195979 0)))
# emit-expr f195979
# emit-variable-ref
# env=((f195979 . 0))
# var=f195979
    movl 0(%esp), %eax  # stack load f195979
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1432291
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1432291:
    movl %eax, -4(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1432292"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1432292:
# check bounds on vector index
    movl -4(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1432294
    cmp  $0,%eax
    jge _L_1432293
_L_1432294:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1432293:
    movl %eax, -8(%esp)
# emit-expr (cons ((primitive-ref string->symbol) "fixnum->char") (vector-ref f195979 0))
# cons arg1=((primitive-ref string->symbol) "fixnum->char") arg2=(vector-ref f195979 0)
# emit-expr ((primitive-ref string->symbol) "fixnum->char")
# funcall
#    si   =-12
#    env  = ((f195979 . 0))
#    expr = (funcall (primitive-ref string->symbol) "fixnum->char")
# emit-expr (primitive-ref string->symbol)
    .extern mrc_string$m$gsymbol
    movl mrc_string$m$gsymbol,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1432295"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1432295":
   movl %eax,  -20(%esp)  # stash funcall-oper in closure slot
# emit-expr "fixnum->char"
# string literal
    jmp _L_1432297
    .align 8,0x90
_L_1432296 :
    .int 48
    .ascii "fixnum->char"
_L_1432297:
    movl $_L_1432296, %eax
    orl $6, %eax
    mov %eax, -24(%esp)  # arg fixnum->char
    movl -20(%esp), %edi   # load new closure to %edi
    add $-12, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $12, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    movl %eax, -12(%esp)
# emit-expr (vector-ref f195979 0)
# emit-expr f195979
# emit-variable-ref
# env=((f195979 . 0))
# var=f195979
    movl 0(%esp), %eax  # stack load f195979
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1432298
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1432298:
    movl %eax, -16(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1432299"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1432299:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1432301
    cmp  $0,%eax
    jge _L_1432300
_L_1432301:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1432300:
    movl -16(%esp), %esi
    movl -1(%eax,%esi), %eax
    movl %eax, 4(%ebp)
    movl -12(%esp), %eax
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    or   $1, %al
    add  $8, %ebp
# cons end
    movl -4(%esp), %ebx
    movl -8(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin (closure () (f195979) (let () (vector-ref f195979 0))))
# emit-begin
#   expr=(begin (closure () (f195979) (let () (vector-ref f195979 0))))
#   env=((f195979 . 0))
# emit-expr (closure () (f195979) (let () (vector-ref f195979 0)))
# emit-closure
# si = -4
# env = ((f195979 . 0))
# expr = (closure () (f195979) (let () (vector-ref f195979 0)))
    movl $_L_1432302, 0(%ebp)  # closure label
# emit-variable-ref
# env=((f195979 . 0))
# var=f195979
    movl 0(%esp), %eax  # stack load f195979
# end emit-variable-ref
   movl  %eax, 4(%ebp)  # f195979
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $8, %ebp     # bump ebp
    jmp _L_1432303            # jump around closure body
_L_1432302:
# check argument count
    cmp $0,%eax
    je _L_1432304
# invoke error handler eh_argcount
    .extern mrc_eh$uargcount
    movl mrc_eh$uargcount, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_1432304:
# emit-tail-expr
# si=-8
# env=((f195979 . 4) (f195979 . 0))
# expr=(let () (vector-ref f195979 0))
# emit-tail-let
#  si   = -8
#  env  = ((f195979 . 4) (f195979 . 0))
#  bindings = ()
#  body = (vector-ref f195979 0)
# emit-tail-expr
# si=-8
# env=((f195979 . 4) (f195979 . 0))
# expr=(vector-ref f195979 0)
# tail primcall
# emit-expr f195979
# emit-variable-ref
# env=((f195979 . 4) (f195979 . 0))
# var=f195979
    movl 2(%edi), %eax  # frame load f195979
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1432305
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1432305:
    movl %eax, -8(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1432306"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1432306:
# check bounds on vector index
    movl -8(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1432308
    cmp  $0,%eax
    jge _L_1432307
_L_1432308:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1432307:
    movl -8(%esp), %esi
    movl -1(%eax,%esi), %eax
#return from tail (vector-ref f195979 0)
    ret
    .align 4,0x90
_L_1432303:
# emit-expr (begin)
# emit-begin
#   expr=(begin)
#   env=((f195979 . 0))
     movl %eax, mrc_primitives
# == explicit-begins  ==>
# (lambda () (error (quote funcall) "arg 1 must be a procedure"))
# == eliminate-let*  ==>
# (lambda () (error (quote funcall) "arg 1 must be a procedure"))
# == uniquify-variables  ==>
# (lambda () (error (quote funcall) "arg 1 must be a procedure"))
# == vectorize-letrec  ==>
# (lambda () (error (quote funcall) "arg 1 must be a procedure"))
# == eliminate-set!  ==>
# (lambda () (let () (error (quote funcall) "arg 1 must be a procedure")))
# == close-free-variables  ==>
# (closure () (error funcall) (let () (error (quote funcall) "arg 1 must be a procedure")))
# == eliminate-quote  ==>
# (closure () (error funcall) (let () (error (string->symbol "funcall") "arg 1 must be a procedure")))
# == eliminate-when/unless  ==>
# (closure () (error funcall) (let () (error (string->symbol "funcall") "arg 1 must be a procedure")))
# == eliminate-cond  ==>
# (closure () (error funcall) (let () (error (string->symbol "funcall") "arg 1 must be a procedure")))
# == external-symbols  ==>
# (closure () ((primitive-ref error) funcall) (let () ((primitive-ref error) ((primitive-ref string->symbol) "funcall") "arg 1 must be a procedure")))
# emit-expr (closure () ((primitive-ref error) funcall) (let () ((primitive-ref error) ((primitive-ref string->symbol) "funcall") "arg 1 must be a procedure")))
# emit-closure
# si = 0
# env = ()
# expr = (closure () ((primitive-ref error) funcall) (let () ((primitive-ref error) ((primitive-ref string->symbol) "funcall") "arg 1 must be a procedure")))
    movl $_L_1432309, 0(%ebp)  # closure label
# WARNING: free var (primitive-ref error) not defined in the environmnet
# WARNING: free var funcall not defined in the environmnet
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $16, %ebp     # bump ebp
    jmp _L_1432310            # jump around closure body
_L_1432309:
# check argument count
    cmp $0,%eax
    je _L_1432311
# invoke error handler eh_argcount
    .extern mrc_eh$uargcount
    movl mrc_eh$uargcount, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_1432311:
# emit-tail-expr
# si=-8
# env=((funcall . 8) ((primitive-ref error) . 4))
# expr=(let () ((primitive-ref error) ((primitive-ref string->symbol) "funcall") "arg 1 must be a procedure"))
# emit-tail-let
#  si   = -8
#  env  = ((funcall . 8) ((primitive-ref error) . 4))
#  bindings = ()
#  body = ((primitive-ref error) ((primitive-ref string->symbol) "funcall") "arg 1 must be a procedure")
# emit-tail-expr
# si=-8
# env=((funcall . 8) ((primitive-ref error) . 4))
# expr=((primitive-ref error) ((primitive-ref string->symbol) "funcall") "arg 1 must be a procedure")
# emit-tail-funcall
#    si   =-8
#    env  = ((funcall . 8) ((primitive-ref error) . 4))
#    expr = (funcall (primitive-ref error) ((primitive-ref string->symbol) "funcall") "arg 1 must be a procedure")
# emit-expr (primitive-ref error)
    .extern mrc_error
    movl mrc_error,%eax
   movl %eax,  -8(%esp)  # stash funcall-oper in next closure slot
# emit-expr ((primitive-ref string->symbol) "funcall")
# funcall
#    si   =-12
#    env  = ((funcall . 8) ((primitive-ref error) . 4))
#    expr = (funcall (primitive-ref string->symbol) "funcall")
# emit-expr (primitive-ref string->symbol)
    .extern mrc_string$m$gsymbol
    movl mrc_string$m$gsymbol,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1432312"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1432312":
   movl %eax,  -20(%esp)  # stash funcall-oper in closure slot
# emit-expr "funcall"
# string literal
    jmp _L_1432314
    .align 8,0x90
_L_1432313 :
    .int 28
    .ascii "funcall"
_L_1432314:
    movl $_L_1432313, %eax
    orl $6, %eax
    mov %eax, -24(%esp)  # arg funcall
    movl -20(%esp), %edi   # load new closure to %edi
    add $-12, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $12, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    mov %eax, -12(%esp)    # arg ((primitive-ref string->symbol) funcall)
# emit-expr "arg 1 must be a procedure"
# string literal
    jmp _L_1432316
    .align 8,0x90
_L_1432315 :
    .int 100
    .ascii "arg 1 must be a procedure"
_L_1432316:
    movl $_L_1432315, %eax
    orl $6, %eax
    mov %eax, -16(%esp)    # arg arg 1 must be a procedure
    movl -8(%esp), %edi   # load new closure to %edi
# emit-shift-args:  size=3   si=-8  delta=4
    mov -8(%esp), %ebx  # shift frame cell
    mov %ebx, -4(%esp)  # down to base
# emit-shift-args:  size=2   si=-12  delta=4
    mov -12(%esp), %ebx  # shift frame cell
    mov %ebx, -8(%esp)  # down to base
# emit-shift-args:  size=1   si=-16  delta=4
    mov -16(%esp), %ebx  # shift frame cell
    mov %ebx, -12(%esp)  # down to base
# emit-shift-args:  size=0   si=-20  delta=4
    movl $8,%eax   # save arg count
    jmp *-2(%edi)  # tail-funcall
    .align 4,0x90
_L_1432310:
     movl %eax, mrc_eh$uprocedure
# == explicit-begins  ==>
# (lambda () (error (quote funcall) "wrong number of args"))
# == eliminate-let*  ==>
# (lambda () (error (quote funcall) "wrong number of args"))
# == uniquify-variables  ==>
# (lambda () (error (quote funcall) "wrong number of args"))
# == vectorize-letrec  ==>
# (lambda () (error (quote funcall) "wrong number of args"))
# == eliminate-set!  ==>
# (lambda () (let () (error (quote funcall) "wrong number of args")))
# == close-free-variables  ==>
# (closure () (error funcall) (let () (error (quote funcall) "wrong number of args")))
# == eliminate-quote  ==>
# (closure () (error funcall) (let () (error (string->symbol "funcall") "wrong number of args")))
# == eliminate-when/unless  ==>
# (closure () (error funcall) (let () (error (string->symbol "funcall") "wrong number of args")))
# == eliminate-cond  ==>
# (closure () (error funcall) (let () (error (string->symbol "funcall") "wrong number of args")))
# == external-symbols  ==>
# (closure () ((primitive-ref error) funcall) (let () ((primitive-ref error) ((primitive-ref string->symbol) "funcall") "wrong number of args")))
# emit-expr (closure () ((primitive-ref error) funcall) (let () ((primitive-ref error) ((primitive-ref string->symbol) "funcall") "wrong number of args")))
# emit-closure
# si = 0
# env = ()
# expr = (closure () ((primitive-ref error) funcall) (let () ((primitive-ref error) ((primitive-ref string->symbol) "funcall") "wrong number of args")))
    movl $_L_1432317, 0(%ebp)  # closure label
# WARNING: free var (primitive-ref error) not defined in the environmnet
# WARNING: free var funcall not defined in the environmnet
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $16, %ebp     # bump ebp
    jmp _L_1432318            # jump around closure body
_L_1432317:
# check argument count
    cmp $0,%eax
    je _L_1432319
# invoke error handler eh_argcount
    .extern mrc_eh$uargcount
    movl mrc_eh$uargcount, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_1432319:
# emit-tail-expr
# si=-8
# env=((funcall . 8) ((primitive-ref error) . 4))
# expr=(let () ((primitive-ref error) ((primitive-ref string->symbol) "funcall") "wrong number of args"))
# emit-tail-let
#  si   = -8
#  env  = ((funcall . 8) ((primitive-ref error) . 4))
#  bindings = ()
#  body = ((primitive-ref error) ((primitive-ref string->symbol) "funcall") "wrong number of args")
# emit-tail-expr
# si=-8
# env=((funcall . 8) ((primitive-ref error) . 4))
# expr=((primitive-ref error) ((primitive-ref string->symbol) "funcall") "wrong number of args")
# emit-tail-funcall
#    si   =-8
#    env  = ((funcall . 8) ((primitive-ref error) . 4))
#    expr = (funcall (primitive-ref error) ((primitive-ref string->symbol) "funcall") "wrong number of args")
# emit-expr (primitive-ref error)
    .extern mrc_error
    movl mrc_error,%eax
   movl %eax,  -8(%esp)  # stash funcall-oper in next closure slot
# emit-expr ((primitive-ref string->symbol) "funcall")
# funcall
#    si   =-12
#    env  = ((funcall . 8) ((primitive-ref error) . 4))
#    expr = (funcall (primitive-ref string->symbol) "funcall")
# emit-expr (primitive-ref string->symbol)
    .extern mrc_string$m$gsymbol
    movl mrc_string$m$gsymbol,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1432320"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1432320":
   movl %eax,  -20(%esp)  # stash funcall-oper in closure slot
# emit-expr "funcall"
# string literal
    jmp _L_1432322
    .align 8,0x90
_L_1432321 :
    .int 28
    .ascii "funcall"
_L_1432322:
    movl $_L_1432321, %eax
    orl $6, %eax
    mov %eax, -24(%esp)  # arg funcall
    movl -20(%esp), %edi   # load new closure to %edi
    add $-12, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $12, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    mov %eax, -12(%esp)    # arg ((primitive-ref string->symbol) funcall)
# emit-expr "wrong number of args"
# string literal
    jmp _L_1432324
    .align 8,0x90
_L_1432323 :
    .int 80
    .ascii "wrong number of args"
_L_1432324:
    movl $_L_1432323, %eax
    orl $6, %eax
    mov %eax, -16(%esp)    # arg wrong number of args
    movl -8(%esp), %edi   # load new closure to %edi
# emit-shift-args:  size=3   si=-8  delta=4
    mov -8(%esp), %ebx  # shift frame cell
    mov %ebx, -4(%esp)  # down to base
# emit-shift-args:  size=2   si=-12  delta=4
    mov -12(%esp), %ebx  # shift frame cell
    mov %ebx, -8(%esp)  # down to base
# emit-shift-args:  size=1   si=-16  delta=4
    mov -16(%esp), %ebx  # shift frame cell
    mov %ebx, -12(%esp)  # down to base
# emit-shift-args:  size=0   si=-20  delta=4
    movl $8,%eax   # save arg count
    jmp *-2(%edi)  # tail-funcall
    .align 4,0x90
_L_1432318:
     movl %eax, mrc_eh$uargcount
# == explicit-begins  ==>
# (lambda () (error (quote funcall) "too few args"))
# == eliminate-let*  ==>
# (lambda () (error (quote funcall) "too few args"))
# == uniquify-variables  ==>
# (lambda () (error (quote funcall) "too few args"))
# == vectorize-letrec  ==>
# (lambda () (error (quote funcall) "too few args"))
# == eliminate-set!  ==>
# (lambda () (let () (error (quote funcall) "too few args")))
# == close-free-variables  ==>
# (closure () (error funcall) (let () (error (quote funcall) "too few args")))
# == eliminate-quote  ==>
# (closure () (error funcall) (let () (error (string->symbol "funcall") "too few args")))
# == eliminate-when/unless  ==>
# (closure () (error funcall) (let () (error (string->symbol "funcall") "too few args")))
# == eliminate-cond  ==>
# (closure () (error funcall) (let () (error (string->symbol "funcall") "too few args")))
# == external-symbols  ==>
# (closure () ((primitive-ref error) funcall) (let () ((primitive-ref error) ((primitive-ref string->symbol) "funcall") "too few args")))
# emit-expr (closure () ((primitive-ref error) funcall) (let () ((primitive-ref error) ((primitive-ref string->symbol) "funcall") "too few args")))
# emit-closure
# si = 0
# env = ()
# expr = (closure () ((primitive-ref error) funcall) (let () ((primitive-ref error) ((primitive-ref string->symbol) "funcall") "too few args")))
    movl $_L_1432325, 0(%ebp)  # closure label
# WARNING: free var (primitive-ref error) not defined in the environmnet
# WARNING: free var funcall not defined in the environmnet
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $16, %ebp     # bump ebp
    jmp _L_1432326            # jump around closure body
_L_1432325:
# check argument count
    cmp $0,%eax
    je _L_1432327
# invoke error handler eh_argcount
    .extern mrc_eh$uargcount
    movl mrc_eh$uargcount, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_1432327:
# emit-tail-expr
# si=-8
# env=((funcall . 8) ((primitive-ref error) . 4))
# expr=(let () ((primitive-ref error) ((primitive-ref string->symbol) "funcall") "too few args"))
# emit-tail-let
#  si   = -8
#  env  = ((funcall . 8) ((primitive-ref error) . 4))
#  bindings = ()
#  body = ((primitive-ref error) ((primitive-ref string->symbol) "funcall") "too few args")
# emit-tail-expr
# si=-8
# env=((funcall . 8) ((primitive-ref error) . 4))
# expr=((primitive-ref error) ((primitive-ref string->symbol) "funcall") "too few args")
# emit-tail-funcall
#    si   =-8
#    env  = ((funcall . 8) ((primitive-ref error) . 4))
#    expr = (funcall (primitive-ref error) ((primitive-ref string->symbol) "funcall") "too few args")
# emit-expr (primitive-ref error)
    .extern mrc_error
    movl mrc_error,%eax
   movl %eax,  -8(%esp)  # stash funcall-oper in next closure slot
# emit-expr ((primitive-ref string->symbol) "funcall")
# funcall
#    si   =-12
#    env  = ((funcall . 8) ((primitive-ref error) . 4))
#    expr = (funcall (primitive-ref string->symbol) "funcall")
# emit-expr (primitive-ref string->symbol)
    .extern mrc_string$m$gsymbol
    movl mrc_string$m$gsymbol,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1432328"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1432328":
   movl %eax,  -20(%esp)  # stash funcall-oper in closure slot
# emit-expr "funcall"
# string literal
    jmp _L_1432330
    .align 8,0x90
_L_1432329 :
    .int 28
    .ascii "funcall"
_L_1432330:
    movl $_L_1432329, %eax
    orl $6, %eax
    mov %eax, -24(%esp)  # arg funcall
    movl -20(%esp), %edi   # load new closure to %edi
    add $-12, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $12, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    mov %eax, -12(%esp)    # arg ((primitive-ref string->symbol) funcall)
# emit-expr "too few args"
# string literal
    jmp _L_1432332
    .align 8,0x90
_L_1432331 :
    .int 48
    .ascii "too few args"
_L_1432332:
    movl $_L_1432331, %eax
    orl $6, %eax
    mov %eax, -16(%esp)    # arg too few args
    movl -8(%esp), %edi   # load new closure to %edi
# emit-shift-args:  size=3   si=-8  delta=4
    mov -8(%esp), %ebx  # shift frame cell
    mov %ebx, -4(%esp)  # down to base
# emit-shift-args:  size=2   si=-12  delta=4
    mov -12(%esp), %ebx  # shift frame cell
    mov %ebx, -8(%esp)  # down to base
# emit-shift-args:  size=1   si=-16  delta=4
    mov -16(%esp), %ebx  # shift frame cell
    mov %ebx, -12(%esp)  # down to base
# emit-shift-args:  size=0   si=-20  delta=4
    movl $8,%eax   # save arg count
    jmp *-2(%edi)  # tail-funcall
    .align 4,0x90
_L_1432326:
     movl %eax, mrc_eh$uargcount$umin
# == explicit-begins  ==>
# (lambda (i) (error (list-ref (primitives) i) "arg must be a fixnum"))
# == eliminate-let*  ==>
# (lambda (i) (error (list-ref (primitives) i) "arg must be a fixnum"))
# == uniquify-variables  ==>
# (lambda (f195980) (error (list-ref (primitives) f195980) "arg must be a fixnum"))
# == vectorize-letrec  ==>
# (lambda (f195980) (error (list-ref (primitives) f195980) "arg must be a fixnum"))
# == eliminate-set!  ==>
# (lambda (f195980) (let ((f195980 f195980)) (error (list-ref (primitives) f195980) "arg must be a fixnum")))
# == close-free-variables  ==>
# (closure (f195980) (error list-ref primitives) (let ((f195980 f195980)) (error (list-ref (primitives) f195980) "arg must be a fixnum")))
# == eliminate-quote  ==>
# (closure (f195980) (error list-ref primitives) (let ((f195980 f195980)) (error (list-ref (primitives) f195980) "arg must be a fixnum")))
# == eliminate-when/unless  ==>
# (closure (f195980) (error list-ref primitives) (let ((f195980 f195980)) (error (list-ref (primitives) f195980) "arg must be a fixnum")))
# == eliminate-cond  ==>
# (closure (f195980) (error list-ref primitives) (let ((f195980 f195980)) (error (list-ref (primitives) f195980) "arg must be a fixnum")))
# == external-symbols  ==>
# (closure (f195980) ((primitive-ref error) (primitive-ref list-ref) (primitive-ref primitives)) (let ((f195980 f195980)) ((primitive-ref error) ((primitive-ref list-ref) ((primitive-ref primitives)) f195980) "arg must be a fixnum")))
# emit-expr (closure (f195980) ((primitive-ref error) (primitive-ref list-ref) (primitive-ref primitives)) (let ((f195980 f195980)) ((primitive-ref error) ((primitive-ref list-ref) ((primitive-ref primitives)) f195980) "arg must be a fixnum")))
# emit-closure
# si = 0
# env = ()
# expr = (closure (f195980) ((primitive-ref error) (primitive-ref list-ref) (primitive-ref primitives)) (let ((f195980 f195980)) ((primitive-ref error) ((primitive-ref list-ref) ((primitive-ref primitives)) f195980) "arg must be a fixnum")))
    movl $_L_1432333, 0(%ebp)  # closure label
# WARNING: free var (primitive-ref error) not defined in the environmnet
# WARNING: free var (primitive-ref list-ref) not defined in the environmnet
# WARNING: free var (primitive-ref primitives) not defined in the environmnet
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $16, %ebp     # bump ebp
    jmp _L_1432334            # jump around closure body
_L_1432333:
# check argument count
    cmp $4,%eax
    je _L_1432335
# invoke error handler eh_argcount
    .extern mrc_eh$uargcount
    movl mrc_eh$uargcount, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_1432335:
# emit-tail-expr
# si=-12
# env=((f195980 . -8) ((primitive-ref primitives) . 12) ((primitive-ref list-ref) . 8) ((primitive-ref error) . 4))
# expr=(let ((f195980 f195980)) ((primitive-ref error) ((primitive-ref list-ref) ((primitive-ref primitives)) f195980) "arg must be a fixnum"))
# emit-tail-let
#  si   = -12
#  env  = ((f195980 . -8) ((primitive-ref primitives) . 12) ((primitive-ref list-ref) . 8) ((primitive-ref error) . 4))
#  bindings = ((f195980 f195980))
#  body = ((primitive-ref error) ((primitive-ref list-ref) ((primitive-ref primitives)) f195980) "arg must be a fixnum")
# emit-expr f195980
# emit-variable-ref
# env=((f195980 . -8) ((primitive-ref primitives) . 12) ((primitive-ref list-ref) . 8) ((primitive-ref error) . 4))
# var=f195980
    movl -8(%esp), %eax  # stack load f195980
# end emit-variable-ref
    movl %eax, -12(%esp)  # stack save
# emit-tail-expr
# si=-16
# env=((f195980 . -12) (f195980 . -8) ((primitive-ref primitives) . 12) ((primitive-ref list-ref) . 8) ((primitive-ref error) . 4))
# expr=((primitive-ref error) ((primitive-ref list-ref) ((primitive-ref primitives)) f195980) "arg must be a fixnum")
# emit-tail-funcall
#    si   =-16
#    env  = ((f195980 . -12) (f195980 . -8) ((primitive-ref primitives) . 12) ((primitive-ref list-ref) . 8) ((primitive-ref error) . 4))
#    expr = (funcall (primitive-ref error) ((primitive-ref list-ref) ((primitive-ref primitives)) f195980) "arg must be a fixnum")
# emit-expr (primitive-ref error)
    .extern mrc_error
    movl mrc_error,%eax
   movl %eax,  -16(%esp)  # stash funcall-oper in next closure slot
# emit-expr ((primitive-ref list-ref) ((primitive-ref primitives)) f195980)
# funcall
#    si   =-20
#    env  = ((f195980 . -12) (f195980 . -8) ((primitive-ref primitives) . 12) ((primitive-ref list-ref) . 8) ((primitive-ref error) . 4))
#    expr = (funcall (primitive-ref list-ref) ((primitive-ref primitives)) f195980)
# emit-expr (primitive-ref list-ref)
    .extern mrc_list$mref
    movl mrc_list$mref,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1432336"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1432336":
   movl %eax,  -28(%esp)  # stash funcall-oper in closure slot
# emit-expr ((primitive-ref primitives))
# funcall
#    si   =-32
#    env  = ((f195980 . -12) (f195980 . -8) ((primitive-ref primitives) . 12) ((primitive-ref list-ref) . 8) ((primitive-ref error) . 4))
#    expr = (funcall (primitive-ref primitives))
# emit-expr (primitive-ref primitives)
    .extern mrc_primitives
    movl mrc_primitives,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1432337"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1432337":
   movl %eax,  -40(%esp)  # stash funcall-oper in closure slot
    movl -40(%esp), %edi   # load new closure to %edi
    add $-32, %esp   # adjust base
    movl $0,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $32, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    mov %eax, -32(%esp)  # arg ((primitive-ref primitives))
# emit-expr f195980
# emit-variable-ref
# env=((f195980 . -12) (f195980 . -8) ((primitive-ref primitives) . 12) ((primitive-ref list-ref) . 8) ((primitive-ref error) . 4))
# var=f195980
    movl -12(%esp), %eax  # stack load f195980
# end emit-variable-ref
    mov %eax, -36(%esp)  # arg f195980
    movl -28(%esp), %edi   # load new closure to %edi
    add $-20, %esp   # adjust base
    movl $8,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $20, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    mov %eax, -20(%esp)    # arg ((primitive-ref list-ref) ((primitive-ref primitives)) f195980)
# emit-expr "arg must be a fixnum"
# string literal
    jmp _L_1432339
    .align 8,0x90
_L_1432338 :
    .int 80
    .ascii "arg must be a fixnum"
_L_1432339:
    movl $_L_1432338, %eax
    orl $6, %eax
    mov %eax, -24(%esp)    # arg arg must be a fixnum
    movl -16(%esp), %edi   # load new closure to %edi
# emit-shift-args:  size=3   si=-16  delta=12
    mov -16(%esp), %ebx  # shift frame cell
    mov %ebx, -4(%esp)  # down to base
# emit-shift-args:  size=2   si=-20  delta=12
    mov -20(%esp), %ebx  # shift frame cell
    mov %ebx, -8(%esp)  # down to base
# emit-shift-args:  size=1   si=-24  delta=12
    mov -24(%esp), %ebx  # shift frame cell
    mov %ebx, -12(%esp)  # down to base
# emit-shift-args:  size=0   si=-28  delta=12
    movl $8,%eax   # save arg count
    jmp *-2(%edi)  # tail-funcall
    .align 4,0x90
_L_1432334:
     movl %eax, mrc_eh$ufixnum
# == explicit-begins  ==>
# (lambda (i) (error (list-ref (primitives) i) "arg must be a string"))
# == eliminate-let*  ==>
# (lambda (i) (error (list-ref (primitives) i) "arg must be a string"))
# == uniquify-variables  ==>
# (lambda (f195981) (error (list-ref (primitives) f195981) "arg must be a string"))
# == vectorize-letrec  ==>
# (lambda (f195981) (error (list-ref (primitives) f195981) "arg must be a string"))
# == eliminate-set!  ==>
# (lambda (f195981) (let ((f195981 f195981)) (error (list-ref (primitives) f195981) "arg must be a string")))
# == close-free-variables  ==>
# (closure (f195981) (error list-ref primitives) (let ((f195981 f195981)) (error (list-ref (primitives) f195981) "arg must be a string")))
# == eliminate-quote  ==>
# (closure (f195981) (error list-ref primitives) (let ((f195981 f195981)) (error (list-ref (primitives) f195981) "arg must be a string")))
# == eliminate-when/unless  ==>
# (closure (f195981) (error list-ref primitives) (let ((f195981 f195981)) (error (list-ref (primitives) f195981) "arg must be a string")))
# == eliminate-cond  ==>
# (closure (f195981) (error list-ref primitives) (let ((f195981 f195981)) (error (list-ref (primitives) f195981) "arg must be a string")))
# == external-symbols  ==>
# (closure (f195981) ((primitive-ref error) (primitive-ref list-ref) (primitive-ref primitives)) (let ((f195981 f195981)) ((primitive-ref error) ((primitive-ref list-ref) ((primitive-ref primitives)) f195981) "arg must be a string")))
# emit-expr (closure (f195981) ((primitive-ref error) (primitive-ref list-ref) (primitive-ref primitives)) (let ((f195981 f195981)) ((primitive-ref error) ((primitive-ref list-ref) ((primitive-ref primitives)) f195981) "arg must be a string")))
# emit-closure
# si = 0
# env = ()
# expr = (closure (f195981) ((primitive-ref error) (primitive-ref list-ref) (primitive-ref primitives)) (let ((f195981 f195981)) ((primitive-ref error) ((primitive-ref list-ref) ((primitive-ref primitives)) f195981) "arg must be a string")))
    movl $_L_1432340, 0(%ebp)  # closure label
# WARNING: free var (primitive-ref error) not defined in the environmnet
# WARNING: free var (primitive-ref list-ref) not defined in the environmnet
# WARNING: free var (primitive-ref primitives) not defined in the environmnet
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $16, %ebp     # bump ebp
    jmp _L_1432341            # jump around closure body
_L_1432340:
# check argument count
    cmp $4,%eax
    je _L_1432342
# invoke error handler eh_argcount
    .extern mrc_eh$uargcount
    movl mrc_eh$uargcount, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_1432342:
# emit-tail-expr
# si=-12
# env=((f195981 . -8) ((primitive-ref primitives) . 12) ((primitive-ref list-ref) . 8) ((primitive-ref error) . 4))
# expr=(let ((f195981 f195981)) ((primitive-ref error) ((primitive-ref list-ref) ((primitive-ref primitives)) f195981) "arg must be a string"))
# emit-tail-let
#  si   = -12
#  env  = ((f195981 . -8) ((primitive-ref primitives) . 12) ((primitive-ref list-ref) . 8) ((primitive-ref error) . 4))
#  bindings = ((f195981 f195981))
#  body = ((primitive-ref error) ((primitive-ref list-ref) ((primitive-ref primitives)) f195981) "arg must be a string")
# emit-expr f195981
# emit-variable-ref
# env=((f195981 . -8) ((primitive-ref primitives) . 12) ((primitive-ref list-ref) . 8) ((primitive-ref error) . 4))
# var=f195981
    movl -8(%esp), %eax  # stack load f195981
# end emit-variable-ref
    movl %eax, -12(%esp)  # stack save
# emit-tail-expr
# si=-16
# env=((f195981 . -12) (f195981 . -8) ((primitive-ref primitives) . 12) ((primitive-ref list-ref) . 8) ((primitive-ref error) . 4))
# expr=((primitive-ref error) ((primitive-ref list-ref) ((primitive-ref primitives)) f195981) "arg must be a string")
# emit-tail-funcall
#    si   =-16
#    env  = ((f195981 . -12) (f195981 . -8) ((primitive-ref primitives) . 12) ((primitive-ref list-ref) . 8) ((primitive-ref error) . 4))
#    expr = (funcall (primitive-ref error) ((primitive-ref list-ref) ((primitive-ref primitives)) f195981) "arg must be a string")
# emit-expr (primitive-ref error)
    .extern mrc_error
    movl mrc_error,%eax
   movl %eax,  -16(%esp)  # stash funcall-oper in next closure slot
# emit-expr ((primitive-ref list-ref) ((primitive-ref primitives)) f195981)
# funcall
#    si   =-20
#    env  = ((f195981 . -12) (f195981 . -8) ((primitive-ref primitives) . 12) ((primitive-ref list-ref) . 8) ((primitive-ref error) . 4))
#    expr = (funcall (primitive-ref list-ref) ((primitive-ref primitives)) f195981)
# emit-expr (primitive-ref list-ref)
    .extern mrc_list$mref
    movl mrc_list$mref,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1432343"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1432343":
   movl %eax,  -28(%esp)  # stash funcall-oper in closure slot
# emit-expr ((primitive-ref primitives))
# funcall
#    si   =-32
#    env  = ((f195981 . -12) (f195981 . -8) ((primitive-ref primitives) . 12) ((primitive-ref list-ref) . 8) ((primitive-ref error) . 4))
#    expr = (funcall (primitive-ref primitives))
# emit-expr (primitive-ref primitives)
    .extern mrc_primitives
    movl mrc_primitives,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1432344"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1432344":
   movl %eax,  -40(%esp)  # stash funcall-oper in closure slot
    movl -40(%esp), %edi   # load new closure to %edi
    add $-32, %esp   # adjust base
    movl $0,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $32, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    mov %eax, -32(%esp)  # arg ((primitive-ref primitives))
# emit-expr f195981
# emit-variable-ref
# env=((f195981 . -12) (f195981 . -8) ((primitive-ref primitives) . 12) ((primitive-ref list-ref) . 8) ((primitive-ref error) . 4))
# var=f195981
    movl -12(%esp), %eax  # stack load f195981
# end emit-variable-ref
    mov %eax, -36(%esp)  # arg f195981
    movl -28(%esp), %edi   # load new closure to %edi
    add $-20, %esp   # adjust base
    movl $8,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $20, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    mov %eax, -20(%esp)    # arg ((primitive-ref list-ref) ((primitive-ref primitives)) f195981)
# emit-expr "arg must be a string"
# string literal
    jmp _L_1432346
    .align 8,0x90
_L_1432345 :
    .int 80
    .ascii "arg must be a string"
_L_1432346:
    movl $_L_1432345, %eax
    orl $6, %eax
    mov %eax, -24(%esp)    # arg arg must be a string
    movl -16(%esp), %edi   # load new closure to %edi
# emit-shift-args:  size=3   si=-16  delta=12
    mov -16(%esp), %ebx  # shift frame cell
    mov %ebx, -4(%esp)  # down to base
# emit-shift-args:  size=2   si=-20  delta=12
    mov -20(%esp), %ebx  # shift frame cell
    mov %ebx, -8(%esp)  # down to base
# emit-shift-args:  size=1   si=-24  delta=12
    mov -24(%esp), %ebx  # shift frame cell
    mov %ebx, -12(%esp)  # down to base
# emit-shift-args:  size=0   si=-28  delta=12
    movl $8,%eax   # save arg count
    jmp *-2(%edi)  # tail-funcall
    .align 4,0x90
_L_1432341:
     movl %eax, mrc_eh$ustring
# == explicit-begins  ==>
# (lambda (i) (error (list-ref (primitives) i) "arg must be a character"))
# == eliminate-let*  ==>
# (lambda (i) (error (list-ref (primitives) i) "arg must be a character"))
# == uniquify-variables  ==>
# (lambda (f195982) (error (list-ref (primitives) f195982) "arg must be a character"))
# == vectorize-letrec  ==>
# (lambda (f195982) (error (list-ref (primitives) f195982) "arg must be a character"))
# == eliminate-set!  ==>
# (lambda (f195982) (let ((f195982 f195982)) (error (list-ref (primitives) f195982) "arg must be a character")))
# == close-free-variables  ==>
# (closure (f195982) (error list-ref primitives) (let ((f195982 f195982)) (error (list-ref (primitives) f195982) "arg must be a character")))
# == eliminate-quote  ==>
# (closure (f195982) (error list-ref primitives) (let ((f195982 f195982)) (error (list-ref (primitives) f195982) "arg must be a character")))
# == eliminate-when/unless  ==>
# (closure (f195982) (error list-ref primitives) (let ((f195982 f195982)) (error (list-ref (primitives) f195982) "arg must be a character")))
# == eliminate-cond  ==>
# (closure (f195982) (error list-ref primitives) (let ((f195982 f195982)) (error (list-ref (primitives) f195982) "arg must be a character")))
# == external-symbols  ==>
# (closure (f195982) ((primitive-ref error) (primitive-ref list-ref) (primitive-ref primitives)) (let ((f195982 f195982)) ((primitive-ref error) ((primitive-ref list-ref) ((primitive-ref primitives)) f195982) "arg must be a character")))
# emit-expr (closure (f195982) ((primitive-ref error) (primitive-ref list-ref) (primitive-ref primitives)) (let ((f195982 f195982)) ((primitive-ref error) ((primitive-ref list-ref) ((primitive-ref primitives)) f195982) "arg must be a character")))
# emit-closure
# si = 0
# env = ()
# expr = (closure (f195982) ((primitive-ref error) (primitive-ref list-ref) (primitive-ref primitives)) (let ((f195982 f195982)) ((primitive-ref error) ((primitive-ref list-ref) ((primitive-ref primitives)) f195982) "arg must be a character")))
    movl $_L_1432347, 0(%ebp)  # closure label
# WARNING: free var (primitive-ref error) not defined in the environmnet
# WARNING: free var (primitive-ref list-ref) not defined in the environmnet
# WARNING: free var (primitive-ref primitives) not defined in the environmnet
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $16, %ebp     # bump ebp
    jmp _L_1432348            # jump around closure body
_L_1432347:
# check argument count
    cmp $4,%eax
    je _L_1432349
# invoke error handler eh_argcount
    .extern mrc_eh$uargcount
    movl mrc_eh$uargcount, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_1432349:
# emit-tail-expr
# si=-12
# env=((f195982 . -8) ((primitive-ref primitives) . 12) ((primitive-ref list-ref) . 8) ((primitive-ref error) . 4))
# expr=(let ((f195982 f195982)) ((primitive-ref error) ((primitive-ref list-ref) ((primitive-ref primitives)) f195982) "arg must be a character"))
# emit-tail-let
#  si   = -12
#  env  = ((f195982 . -8) ((primitive-ref primitives) . 12) ((primitive-ref list-ref) . 8) ((primitive-ref error) . 4))
#  bindings = ((f195982 f195982))
#  body = ((primitive-ref error) ((primitive-ref list-ref) ((primitive-ref primitives)) f195982) "arg must be a character")
# emit-expr f195982
# emit-variable-ref
# env=((f195982 . -8) ((primitive-ref primitives) . 12) ((primitive-ref list-ref) . 8) ((primitive-ref error) . 4))
# var=f195982
    movl -8(%esp), %eax  # stack load f195982
# end emit-variable-ref
    movl %eax, -12(%esp)  # stack save
# emit-tail-expr
# si=-16
# env=((f195982 . -12) (f195982 . -8) ((primitive-ref primitives) . 12) ((primitive-ref list-ref) . 8) ((primitive-ref error) . 4))
# expr=((primitive-ref error) ((primitive-ref list-ref) ((primitive-ref primitives)) f195982) "arg must be a character")
# emit-tail-funcall
#    si   =-16
#    env  = ((f195982 . -12) (f195982 . -8) ((primitive-ref primitives) . 12) ((primitive-ref list-ref) . 8) ((primitive-ref error) . 4))
#    expr = (funcall (primitive-ref error) ((primitive-ref list-ref) ((primitive-ref primitives)) f195982) "arg must be a character")
# emit-expr (primitive-ref error)
    .extern mrc_error
    movl mrc_error,%eax
   movl %eax,  -16(%esp)  # stash funcall-oper in next closure slot
# emit-expr ((primitive-ref list-ref) ((primitive-ref primitives)) f195982)
# funcall
#    si   =-20
#    env  = ((f195982 . -12) (f195982 . -8) ((primitive-ref primitives) . 12) ((primitive-ref list-ref) . 8) ((primitive-ref error) . 4))
#    expr = (funcall (primitive-ref list-ref) ((primitive-ref primitives)) f195982)
# emit-expr (primitive-ref list-ref)
    .extern mrc_list$mref
    movl mrc_list$mref,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1432350"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1432350":
   movl %eax,  -28(%esp)  # stash funcall-oper in closure slot
# emit-expr ((primitive-ref primitives))
# funcall
#    si   =-32
#    env  = ((f195982 . -12) (f195982 . -8) ((primitive-ref primitives) . 12) ((primitive-ref list-ref) . 8) ((primitive-ref error) . 4))
#    expr = (funcall (primitive-ref primitives))
# emit-expr (primitive-ref primitives)
    .extern mrc_primitives
    movl mrc_primitives,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1432351"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1432351":
   movl %eax,  -40(%esp)  # stash funcall-oper in closure slot
    movl -40(%esp), %edi   # load new closure to %edi
    add $-32, %esp   # adjust base
    movl $0,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $32, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    mov %eax, -32(%esp)  # arg ((primitive-ref primitives))
# emit-expr f195982
# emit-variable-ref
# env=((f195982 . -12) (f195982 . -8) ((primitive-ref primitives) . 12) ((primitive-ref list-ref) . 8) ((primitive-ref error) . 4))
# var=f195982
    movl -12(%esp), %eax  # stack load f195982
# end emit-variable-ref
    mov %eax, -36(%esp)  # arg f195982
    movl -28(%esp), %edi   # load new closure to %edi
    add $-20, %esp   # adjust base
    movl $8,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $20, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    mov %eax, -20(%esp)    # arg ((primitive-ref list-ref) ((primitive-ref primitives)) f195982)
# emit-expr "arg must be a character"
# string literal
    jmp _L_1432353
    .align 8,0x90
_L_1432352 :
    .int 92
    .ascii "arg must be a character"
_L_1432353:
    movl $_L_1432352, %eax
    orl $6, %eax
    mov %eax, -24(%esp)    # arg arg must be a character
    movl -16(%esp), %edi   # load new closure to %edi
# emit-shift-args:  size=3   si=-16  delta=12
    mov -16(%esp), %ebx  # shift frame cell
    mov %ebx, -4(%esp)  # down to base
# emit-shift-args:  size=2   si=-20  delta=12
    mov -20(%esp), %ebx  # shift frame cell
    mov %ebx, -8(%esp)  # down to base
# emit-shift-args:  size=1   si=-24  delta=12
    mov -24(%esp), %ebx  # shift frame cell
    mov %ebx, -12(%esp)  # down to base
# emit-shift-args:  size=0   si=-28  delta=12
    movl $8,%eax   # save arg count
    jmp *-2(%edi)  # tail-funcall
    .align 4,0x90
_L_1432348:
     movl %eax, mrc_eh$ucharacter
# == explicit-begins  ==>
# (lambda (i) (error (list-ref (primitives) i) "arg must be a pair"))
# == eliminate-let*  ==>
# (lambda (i) (error (list-ref (primitives) i) "arg must be a pair"))
# == uniquify-variables  ==>
# (lambda (f195983) (error (list-ref (primitives) f195983) "arg must be a pair"))
# == vectorize-letrec  ==>
# (lambda (f195983) (error (list-ref (primitives) f195983) "arg must be a pair"))
# == eliminate-set!  ==>
# (lambda (f195983) (let ((f195983 f195983)) (error (list-ref (primitives) f195983) "arg must be a pair")))
# == close-free-variables  ==>
# (closure (f195983) (error list-ref primitives) (let ((f195983 f195983)) (error (list-ref (primitives) f195983) "arg must be a pair")))
# == eliminate-quote  ==>
# (closure (f195983) (error list-ref primitives) (let ((f195983 f195983)) (error (list-ref (primitives) f195983) "arg must be a pair")))
# == eliminate-when/unless  ==>
# (closure (f195983) (error list-ref primitives) (let ((f195983 f195983)) (error (list-ref (primitives) f195983) "arg must be a pair")))
# == eliminate-cond  ==>
# (closure (f195983) (error list-ref primitives) (let ((f195983 f195983)) (error (list-ref (primitives) f195983) "arg must be a pair")))
# == external-symbols  ==>
# (closure (f195983) ((primitive-ref error) (primitive-ref list-ref) (primitive-ref primitives)) (let ((f195983 f195983)) ((primitive-ref error) ((primitive-ref list-ref) ((primitive-ref primitives)) f195983) "arg must be a pair")))
# emit-expr (closure (f195983) ((primitive-ref error) (primitive-ref list-ref) (primitive-ref primitives)) (let ((f195983 f195983)) ((primitive-ref error) ((primitive-ref list-ref) ((primitive-ref primitives)) f195983) "arg must be a pair")))
# emit-closure
# si = 0
# env = ()
# expr = (closure (f195983) ((primitive-ref error) (primitive-ref list-ref) (primitive-ref primitives)) (let ((f195983 f195983)) ((primitive-ref error) ((primitive-ref list-ref) ((primitive-ref primitives)) f195983) "arg must be a pair")))
    movl $_L_1432354, 0(%ebp)  # closure label
# WARNING: free var (primitive-ref error) not defined in the environmnet
# WARNING: free var (primitive-ref list-ref) not defined in the environmnet
# WARNING: free var (primitive-ref primitives) not defined in the environmnet
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $16, %ebp     # bump ebp
    jmp _L_1432355            # jump around closure body
_L_1432354:
# check argument count
    cmp $4,%eax
    je _L_1432356
# invoke error handler eh_argcount
    .extern mrc_eh$uargcount
    movl mrc_eh$uargcount, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_1432356:
# emit-tail-expr
# si=-12
# env=((f195983 . -8) ((primitive-ref primitives) . 12) ((primitive-ref list-ref) . 8) ((primitive-ref error) . 4))
# expr=(let ((f195983 f195983)) ((primitive-ref error) ((primitive-ref list-ref) ((primitive-ref primitives)) f195983) "arg must be a pair"))
# emit-tail-let
#  si   = -12
#  env  = ((f195983 . -8) ((primitive-ref primitives) . 12) ((primitive-ref list-ref) . 8) ((primitive-ref error) . 4))
#  bindings = ((f195983 f195983))
#  body = ((primitive-ref error) ((primitive-ref list-ref) ((primitive-ref primitives)) f195983) "arg must be a pair")
# emit-expr f195983
# emit-variable-ref
# env=((f195983 . -8) ((primitive-ref primitives) . 12) ((primitive-ref list-ref) . 8) ((primitive-ref error) . 4))
# var=f195983
    movl -8(%esp), %eax  # stack load f195983
# end emit-variable-ref
    movl %eax, -12(%esp)  # stack save
# emit-tail-expr
# si=-16
# env=((f195983 . -12) (f195983 . -8) ((primitive-ref primitives) . 12) ((primitive-ref list-ref) . 8) ((primitive-ref error) . 4))
# expr=((primitive-ref error) ((primitive-ref list-ref) ((primitive-ref primitives)) f195983) "arg must be a pair")
# emit-tail-funcall
#    si   =-16
#    env  = ((f195983 . -12) (f195983 . -8) ((primitive-ref primitives) . 12) ((primitive-ref list-ref) . 8) ((primitive-ref error) . 4))
#    expr = (funcall (primitive-ref error) ((primitive-ref list-ref) ((primitive-ref primitives)) f195983) "arg must be a pair")
# emit-expr (primitive-ref error)
    .extern mrc_error
    movl mrc_error,%eax
   movl %eax,  -16(%esp)  # stash funcall-oper in next closure slot
# emit-expr ((primitive-ref list-ref) ((primitive-ref primitives)) f195983)
# funcall
#    si   =-20
#    env  = ((f195983 . -12) (f195983 . -8) ((primitive-ref primitives) . 12) ((primitive-ref list-ref) . 8) ((primitive-ref error) . 4))
#    expr = (funcall (primitive-ref list-ref) ((primitive-ref primitives)) f195983)
# emit-expr (primitive-ref list-ref)
    .extern mrc_list$mref
    movl mrc_list$mref,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1432357"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1432357":
   movl %eax,  -28(%esp)  # stash funcall-oper in closure slot
# emit-expr ((primitive-ref primitives))
# funcall
#    si   =-32
#    env  = ((f195983 . -12) (f195983 . -8) ((primitive-ref primitives) . 12) ((primitive-ref list-ref) . 8) ((primitive-ref error) . 4))
#    expr = (funcall (primitive-ref primitives))
# emit-expr (primitive-ref primitives)
    .extern mrc_primitives
    movl mrc_primitives,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1432358"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1432358":
   movl %eax,  -40(%esp)  # stash funcall-oper in closure slot
    movl -40(%esp), %edi   # load new closure to %edi
    add $-32, %esp   # adjust base
    movl $0,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $32, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    mov %eax, -32(%esp)  # arg ((primitive-ref primitives))
# emit-expr f195983
# emit-variable-ref
# env=((f195983 . -12) (f195983 . -8) ((primitive-ref primitives) . 12) ((primitive-ref list-ref) . 8) ((primitive-ref error) . 4))
# var=f195983
    movl -12(%esp), %eax  # stack load f195983
# end emit-variable-ref
    mov %eax, -36(%esp)  # arg f195983
    movl -28(%esp), %edi   # load new closure to %edi
    add $-20, %esp   # adjust base
    movl $8,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $20, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    mov %eax, -20(%esp)    # arg ((primitive-ref list-ref) ((primitive-ref primitives)) f195983)
# emit-expr "arg must be a pair"
# string literal
    jmp _L_1432360
    .align 8,0x90
_L_1432359 :
    .int 72
    .ascii "arg must be a pair"
_L_1432360:
    movl $_L_1432359, %eax
    orl $6, %eax
    mov %eax, -24(%esp)    # arg arg must be a pair
    movl -16(%esp), %edi   # load new closure to %edi
# emit-shift-args:  size=3   si=-16  delta=12
    mov -16(%esp), %ebx  # shift frame cell
    mov %ebx, -4(%esp)  # down to base
# emit-shift-args:  size=2   si=-20  delta=12
    mov -20(%esp), %ebx  # shift frame cell
    mov %ebx, -8(%esp)  # down to base
# emit-shift-args:  size=1   si=-24  delta=12
    mov -24(%esp), %ebx  # shift frame cell
    mov %ebx, -12(%esp)  # down to base
# emit-shift-args:  size=0   si=-28  delta=12
    movl $8,%eax   # save arg count
    jmp *-2(%edi)  # tail-funcall
    .align 4,0x90
_L_1432355:
     movl %eax, mrc_eh$upair
# == explicit-begins  ==>
# (lambda (i) (error (list-ref (primitives) i) "arg must be a vector"))
# == eliminate-let*  ==>
# (lambda (i) (error (list-ref (primitives) i) "arg must be a vector"))
# == uniquify-variables  ==>
# (lambda (f195984) (error (list-ref (primitives) f195984) "arg must be a vector"))
# == vectorize-letrec  ==>
# (lambda (f195984) (error (list-ref (primitives) f195984) "arg must be a vector"))
# == eliminate-set!  ==>
# (lambda (f195984) (let ((f195984 f195984)) (error (list-ref (primitives) f195984) "arg must be a vector")))
# == close-free-variables  ==>
# (closure (f195984) (error list-ref primitives) (let ((f195984 f195984)) (error (list-ref (primitives) f195984) "arg must be a vector")))
# == eliminate-quote  ==>
# (closure (f195984) (error list-ref primitives) (let ((f195984 f195984)) (error (list-ref (primitives) f195984) "arg must be a vector")))
# == eliminate-when/unless  ==>
# (closure (f195984) (error list-ref primitives) (let ((f195984 f195984)) (error (list-ref (primitives) f195984) "arg must be a vector")))
# == eliminate-cond  ==>
# (closure (f195984) (error list-ref primitives) (let ((f195984 f195984)) (error (list-ref (primitives) f195984) "arg must be a vector")))
# == external-symbols  ==>
# (closure (f195984) ((primitive-ref error) (primitive-ref list-ref) (primitive-ref primitives)) (let ((f195984 f195984)) ((primitive-ref error) ((primitive-ref list-ref) ((primitive-ref primitives)) f195984) "arg must be a vector")))
# emit-expr (closure (f195984) ((primitive-ref error) (primitive-ref list-ref) (primitive-ref primitives)) (let ((f195984 f195984)) ((primitive-ref error) ((primitive-ref list-ref) ((primitive-ref primitives)) f195984) "arg must be a vector")))
# emit-closure
# si = 0
# env = ()
# expr = (closure (f195984) ((primitive-ref error) (primitive-ref list-ref) (primitive-ref primitives)) (let ((f195984 f195984)) ((primitive-ref error) ((primitive-ref list-ref) ((primitive-ref primitives)) f195984) "arg must be a vector")))
    movl $_L_1432361, 0(%ebp)  # closure label
# WARNING: free var (primitive-ref error) not defined in the environmnet
# WARNING: free var (primitive-ref list-ref) not defined in the environmnet
# WARNING: free var (primitive-ref primitives) not defined in the environmnet
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $16, %ebp     # bump ebp
    jmp _L_1432362            # jump around closure body
_L_1432361:
# check argument count
    cmp $4,%eax
    je _L_1432363
# invoke error handler eh_argcount
    .extern mrc_eh$uargcount
    movl mrc_eh$uargcount, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_1432363:
# emit-tail-expr
# si=-12
# env=((f195984 . -8) ((primitive-ref primitives) . 12) ((primitive-ref list-ref) . 8) ((primitive-ref error) . 4))
# expr=(let ((f195984 f195984)) ((primitive-ref error) ((primitive-ref list-ref) ((primitive-ref primitives)) f195984) "arg must be a vector"))
# emit-tail-let
#  si   = -12
#  env  = ((f195984 . -8) ((primitive-ref primitives) . 12) ((primitive-ref list-ref) . 8) ((primitive-ref error) . 4))
#  bindings = ((f195984 f195984))
#  body = ((primitive-ref error) ((primitive-ref list-ref) ((primitive-ref primitives)) f195984) "arg must be a vector")
# emit-expr f195984
# emit-variable-ref
# env=((f195984 . -8) ((primitive-ref primitives) . 12) ((primitive-ref list-ref) . 8) ((primitive-ref error) . 4))
# var=f195984
    movl -8(%esp), %eax  # stack load f195984
# end emit-variable-ref
    movl %eax, -12(%esp)  # stack save
# emit-tail-expr
# si=-16
# env=((f195984 . -12) (f195984 . -8) ((primitive-ref primitives) . 12) ((primitive-ref list-ref) . 8) ((primitive-ref error) . 4))
# expr=((primitive-ref error) ((primitive-ref list-ref) ((primitive-ref primitives)) f195984) "arg must be a vector")
# emit-tail-funcall
#    si   =-16
#    env  = ((f195984 . -12) (f195984 . -8) ((primitive-ref primitives) . 12) ((primitive-ref list-ref) . 8) ((primitive-ref error) . 4))
#    expr = (funcall (primitive-ref error) ((primitive-ref list-ref) ((primitive-ref primitives)) f195984) "arg must be a vector")
# emit-expr (primitive-ref error)
    .extern mrc_error
    movl mrc_error,%eax
   movl %eax,  -16(%esp)  # stash funcall-oper in next closure slot
# emit-expr ((primitive-ref list-ref) ((primitive-ref primitives)) f195984)
# funcall
#    si   =-20
#    env  = ((f195984 . -12) (f195984 . -8) ((primitive-ref primitives) . 12) ((primitive-ref list-ref) . 8) ((primitive-ref error) . 4))
#    expr = (funcall (primitive-ref list-ref) ((primitive-ref primitives)) f195984)
# emit-expr (primitive-ref list-ref)
    .extern mrc_list$mref
    movl mrc_list$mref,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1432364"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1432364":
   movl %eax,  -28(%esp)  # stash funcall-oper in closure slot
# emit-expr ((primitive-ref primitives))
# funcall
#    si   =-32
#    env  = ((f195984 . -12) (f195984 . -8) ((primitive-ref primitives) . 12) ((primitive-ref list-ref) . 8) ((primitive-ref error) . 4))
#    expr = (funcall (primitive-ref primitives))
# emit-expr (primitive-ref primitives)
    .extern mrc_primitives
    movl mrc_primitives,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1432365"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1432365":
   movl %eax,  -40(%esp)  # stash funcall-oper in closure slot
    movl -40(%esp), %edi   # load new closure to %edi
    add $-32, %esp   # adjust base
    movl $0,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $32, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    mov %eax, -32(%esp)  # arg ((primitive-ref primitives))
# emit-expr f195984
# emit-variable-ref
# env=((f195984 . -12) (f195984 . -8) ((primitive-ref primitives) . 12) ((primitive-ref list-ref) . 8) ((primitive-ref error) . 4))
# var=f195984
    movl -12(%esp), %eax  # stack load f195984
# end emit-variable-ref
    mov %eax, -36(%esp)  # arg f195984
    movl -28(%esp), %edi   # load new closure to %edi
    add $-20, %esp   # adjust base
    movl $8,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $20, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    mov %eax, -20(%esp)    # arg ((primitive-ref list-ref) ((primitive-ref primitives)) f195984)
# emit-expr "arg must be a vector"
# string literal
    jmp _L_1432367
    .align 8,0x90
_L_1432366 :
    .int 80
    .ascii "arg must be a vector"
_L_1432367:
    movl $_L_1432366, %eax
    orl $6, %eax
    mov %eax, -24(%esp)    # arg arg must be a vector
    movl -16(%esp), %edi   # load new closure to %edi
# emit-shift-args:  size=3   si=-16  delta=12
    mov -16(%esp), %ebx  # shift frame cell
    mov %ebx, -4(%esp)  # down to base
# emit-shift-args:  size=2   si=-20  delta=12
    mov -20(%esp), %ebx  # shift frame cell
    mov %ebx, -8(%esp)  # down to base
# emit-shift-args:  size=1   si=-24  delta=12
    mov -24(%esp), %ebx  # shift frame cell
    mov %ebx, -12(%esp)  # down to base
# emit-shift-args:  size=0   si=-28  delta=12
    movl $8,%eax   # save arg count
    jmp *-2(%edi)  # tail-funcall
    .align 4,0x90
_L_1432362:
     movl %eax, mrc_eh$uvector
# == explicit-begins  ==>
# (lambda (i) (error (list-ref (primitives) i) "length must be a fixnum >= 0"))
# == eliminate-let*  ==>
# (lambda (i) (error (list-ref (primitives) i) "length must be a fixnum >= 0"))
# == uniquify-variables  ==>
# (lambda (f195985) (error (list-ref (primitives) f195985) "length must be a fixnum >= 0"))
# == vectorize-letrec  ==>
# (lambda (f195985) (error (list-ref (primitives) f195985) "length must be a fixnum >= 0"))
# == eliminate-set!  ==>
# (lambda (f195985) (let ((f195985 f195985)) (error (list-ref (primitives) f195985) "length must be a fixnum >= 0")))
# == close-free-variables  ==>
# (closure (f195985) (error list-ref primitives) (let ((f195985 f195985)) (error (list-ref (primitives) f195985) "length must be a fixnum >= 0")))
# == eliminate-quote  ==>
# (closure (f195985) (error list-ref primitives) (let ((f195985 f195985)) (error (list-ref (primitives) f195985) "length must be a fixnum >= 0")))
# == eliminate-when/unless  ==>
# (closure (f195985) (error list-ref primitives) (let ((f195985 f195985)) (error (list-ref (primitives) f195985) "length must be a fixnum >= 0")))
# == eliminate-cond  ==>
# (closure (f195985) (error list-ref primitives) (let ((f195985 f195985)) (error (list-ref (primitives) f195985) "length must be a fixnum >= 0")))
# == external-symbols  ==>
# (closure (f195985) ((primitive-ref error) (primitive-ref list-ref) (primitive-ref primitives)) (let ((f195985 f195985)) ((primitive-ref error) ((primitive-ref list-ref) ((primitive-ref primitives)) f195985) "length must be a fixnum >= 0")))
# emit-expr (closure (f195985) ((primitive-ref error) (primitive-ref list-ref) (primitive-ref primitives)) (let ((f195985 f195985)) ((primitive-ref error) ((primitive-ref list-ref) ((primitive-ref primitives)) f195985) "length must be a fixnum >= 0")))
# emit-closure
# si = 0
# env = ()
# expr = (closure (f195985) ((primitive-ref error) (primitive-ref list-ref) (primitive-ref primitives)) (let ((f195985 f195985)) ((primitive-ref error) ((primitive-ref list-ref) ((primitive-ref primitives)) f195985) "length must be a fixnum >= 0")))
    movl $_L_1432368, 0(%ebp)  # closure label
# WARNING: free var (primitive-ref error) not defined in the environmnet
# WARNING: free var (primitive-ref list-ref) not defined in the environmnet
# WARNING: free var (primitive-ref primitives) not defined in the environmnet
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $16, %ebp     # bump ebp
    jmp _L_1432369            # jump around closure body
_L_1432368:
# check argument count
    cmp $4,%eax
    je _L_1432370
# invoke error handler eh_argcount
    .extern mrc_eh$uargcount
    movl mrc_eh$uargcount, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_1432370:
# emit-tail-expr
# si=-12
# env=((f195985 . -8) ((primitive-ref primitives) . 12) ((primitive-ref list-ref) . 8) ((primitive-ref error) . 4))
# expr=(let ((f195985 f195985)) ((primitive-ref error) ((primitive-ref list-ref) ((primitive-ref primitives)) f195985) "length must be a fixnum >= 0"))
# emit-tail-let
#  si   = -12
#  env  = ((f195985 . -8) ((primitive-ref primitives) . 12) ((primitive-ref list-ref) . 8) ((primitive-ref error) . 4))
#  bindings = ((f195985 f195985))
#  body = ((primitive-ref error) ((primitive-ref list-ref) ((primitive-ref primitives)) f195985) "length must be a fixnum >= 0")
# emit-expr f195985
# emit-variable-ref
# env=((f195985 . -8) ((primitive-ref primitives) . 12) ((primitive-ref list-ref) . 8) ((primitive-ref error) . 4))
# var=f195985
    movl -8(%esp), %eax  # stack load f195985
# end emit-variable-ref
    movl %eax, -12(%esp)  # stack save
# emit-tail-expr
# si=-16
# env=((f195985 . -12) (f195985 . -8) ((primitive-ref primitives) . 12) ((primitive-ref list-ref) . 8) ((primitive-ref error) . 4))
# expr=((primitive-ref error) ((primitive-ref list-ref) ((primitive-ref primitives)) f195985) "length must be a fixnum >= 0")
# emit-tail-funcall
#    si   =-16
#    env  = ((f195985 . -12) (f195985 . -8) ((primitive-ref primitives) . 12) ((primitive-ref list-ref) . 8) ((primitive-ref error) . 4))
#    expr = (funcall (primitive-ref error) ((primitive-ref list-ref) ((primitive-ref primitives)) f195985) "length must be a fixnum >= 0")
# emit-expr (primitive-ref error)
    .extern mrc_error
    movl mrc_error,%eax
   movl %eax,  -16(%esp)  # stash funcall-oper in next closure slot
# emit-expr ((primitive-ref list-ref) ((primitive-ref primitives)) f195985)
# funcall
#    si   =-20
#    env  = ((f195985 . -12) (f195985 . -8) ((primitive-ref primitives) . 12) ((primitive-ref list-ref) . 8) ((primitive-ref error) . 4))
#    expr = (funcall (primitive-ref list-ref) ((primitive-ref primitives)) f195985)
# emit-expr (primitive-ref list-ref)
    .extern mrc_list$mref
    movl mrc_list$mref,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1432371"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1432371":
   movl %eax,  -28(%esp)  # stash funcall-oper in closure slot
# emit-expr ((primitive-ref primitives))
# funcall
#    si   =-32
#    env  = ((f195985 . -12) (f195985 . -8) ((primitive-ref primitives) . 12) ((primitive-ref list-ref) . 8) ((primitive-ref error) . 4))
#    expr = (funcall (primitive-ref primitives))
# emit-expr (primitive-ref primitives)
    .extern mrc_primitives
    movl mrc_primitives,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1432372"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1432372":
   movl %eax,  -40(%esp)  # stash funcall-oper in closure slot
    movl -40(%esp), %edi   # load new closure to %edi
    add $-32, %esp   # adjust base
    movl $0,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $32, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    mov %eax, -32(%esp)  # arg ((primitive-ref primitives))
# emit-expr f195985
# emit-variable-ref
# env=((f195985 . -12) (f195985 . -8) ((primitive-ref primitives) . 12) ((primitive-ref list-ref) . 8) ((primitive-ref error) . 4))
# var=f195985
    movl -12(%esp), %eax  # stack load f195985
# end emit-variable-ref
    mov %eax, -36(%esp)  # arg f195985
    movl -28(%esp), %edi   # load new closure to %edi
    add $-20, %esp   # adjust base
    movl $8,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $20, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    mov %eax, -20(%esp)    # arg ((primitive-ref list-ref) ((primitive-ref primitives)) f195985)
# emit-expr "length must be a fixnum >= 0"
# string literal
    jmp _L_1432374
    .align 8,0x90
_L_1432373 :
    .int 112
    .ascii "length must be a fixnum >= 0"
_L_1432374:
    movl $_L_1432373, %eax
    orl $6, %eax
    mov %eax, -24(%esp)    # arg length must be a fixnum >= 0
    movl -16(%esp), %edi   # load new closure to %edi
# emit-shift-args:  size=3   si=-16  delta=12
    mov -16(%esp), %ebx  # shift frame cell
    mov %ebx, -4(%esp)  # down to base
# emit-shift-args:  size=2   si=-20  delta=12
    mov -20(%esp), %ebx  # shift frame cell
    mov %ebx, -8(%esp)  # down to base
# emit-shift-args:  size=1   si=-24  delta=12
    mov -24(%esp), %ebx  # shift frame cell
    mov %ebx, -12(%esp)  # down to base
# emit-shift-args:  size=0   si=-28  delta=12
    movl $8,%eax   # save arg count
    jmp *-2(%edi)  # tail-funcall
    .align 4,0x90
_L_1432369:
     movl %eax, mrc_eh$ulength
# == explicit-begins  ==>
# (lambda (i) (error (list-ref (primitives) i) "index out of bounds"))
# == eliminate-let*  ==>
# (lambda (i) (error (list-ref (primitives) i) "index out of bounds"))
# == uniquify-variables  ==>
# (lambda (f195986) (error (list-ref (primitives) f195986) "index out of bounds"))
# == vectorize-letrec  ==>
# (lambda (f195986) (error (list-ref (primitives) f195986) "index out of bounds"))
# == eliminate-set!  ==>
# (lambda (f195986) (let ((f195986 f195986)) (error (list-ref (primitives) f195986) "index out of bounds")))
# == close-free-variables  ==>
# (closure (f195986) (error list-ref primitives) (let ((f195986 f195986)) (error (list-ref (primitives) f195986) "index out of bounds")))
# == eliminate-quote  ==>
# (closure (f195986) (error list-ref primitives) (let ((f195986 f195986)) (error (list-ref (primitives) f195986) "index out of bounds")))
# == eliminate-when/unless  ==>
# (closure (f195986) (error list-ref primitives) (let ((f195986 f195986)) (error (list-ref (primitives) f195986) "index out of bounds")))
# == eliminate-cond  ==>
# (closure (f195986) (error list-ref primitives) (let ((f195986 f195986)) (error (list-ref (primitives) f195986) "index out of bounds")))
# == external-symbols  ==>
# (closure (f195986) ((primitive-ref error) (primitive-ref list-ref) (primitive-ref primitives)) (let ((f195986 f195986)) ((primitive-ref error) ((primitive-ref list-ref) ((primitive-ref primitives)) f195986) "index out of bounds")))
# emit-expr (closure (f195986) ((primitive-ref error) (primitive-ref list-ref) (primitive-ref primitives)) (let ((f195986 f195986)) ((primitive-ref error) ((primitive-ref list-ref) ((primitive-ref primitives)) f195986) "index out of bounds")))
# emit-closure
# si = 0
# env = ()
# expr = (closure (f195986) ((primitive-ref error) (primitive-ref list-ref) (primitive-ref primitives)) (let ((f195986 f195986)) ((primitive-ref error) ((primitive-ref list-ref) ((primitive-ref primitives)) f195986) "index out of bounds")))
    movl $_L_1432375, 0(%ebp)  # closure label
# WARNING: free var (primitive-ref error) not defined in the environmnet
# WARNING: free var (primitive-ref list-ref) not defined in the environmnet
# WARNING: free var (primitive-ref primitives) not defined in the environmnet
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $16, %ebp     # bump ebp
    jmp _L_1432376            # jump around closure body
_L_1432375:
# check argument count
    cmp $4,%eax
    je _L_1432377
# invoke error handler eh_argcount
    .extern mrc_eh$uargcount
    movl mrc_eh$uargcount, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_1432377:
# emit-tail-expr
# si=-12
# env=((f195986 . -8) ((primitive-ref primitives) . 12) ((primitive-ref list-ref) . 8) ((primitive-ref error) . 4))
# expr=(let ((f195986 f195986)) ((primitive-ref error) ((primitive-ref list-ref) ((primitive-ref primitives)) f195986) "index out of bounds"))
# emit-tail-let
#  si   = -12
#  env  = ((f195986 . -8) ((primitive-ref primitives) . 12) ((primitive-ref list-ref) . 8) ((primitive-ref error) . 4))
#  bindings = ((f195986 f195986))
#  body = ((primitive-ref error) ((primitive-ref list-ref) ((primitive-ref primitives)) f195986) "index out of bounds")
# emit-expr f195986
# emit-variable-ref
# env=((f195986 . -8) ((primitive-ref primitives) . 12) ((primitive-ref list-ref) . 8) ((primitive-ref error) . 4))
# var=f195986
    movl -8(%esp), %eax  # stack load f195986
# end emit-variable-ref
    movl %eax, -12(%esp)  # stack save
# emit-tail-expr
# si=-16
# env=((f195986 . -12) (f195986 . -8) ((primitive-ref primitives) . 12) ((primitive-ref list-ref) . 8) ((primitive-ref error) . 4))
# expr=((primitive-ref error) ((primitive-ref list-ref) ((primitive-ref primitives)) f195986) "index out of bounds")
# emit-tail-funcall
#    si   =-16
#    env  = ((f195986 . -12) (f195986 . -8) ((primitive-ref primitives) . 12) ((primitive-ref list-ref) . 8) ((primitive-ref error) . 4))
#    expr = (funcall (primitive-ref error) ((primitive-ref list-ref) ((primitive-ref primitives)) f195986) "index out of bounds")
# emit-expr (primitive-ref error)
    .extern mrc_error
    movl mrc_error,%eax
   movl %eax,  -16(%esp)  # stash funcall-oper in next closure slot
# emit-expr ((primitive-ref list-ref) ((primitive-ref primitives)) f195986)
# funcall
#    si   =-20
#    env  = ((f195986 . -12) (f195986 . -8) ((primitive-ref primitives) . 12) ((primitive-ref list-ref) . 8) ((primitive-ref error) . 4))
#    expr = (funcall (primitive-ref list-ref) ((primitive-ref primitives)) f195986)
# emit-expr (primitive-ref list-ref)
    .extern mrc_list$mref
    movl mrc_list$mref,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1432378"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1432378":
   movl %eax,  -28(%esp)  # stash funcall-oper in closure slot
# emit-expr ((primitive-ref primitives))
# funcall
#    si   =-32
#    env  = ((f195986 . -12) (f195986 . -8) ((primitive-ref primitives) . 12) ((primitive-ref list-ref) . 8) ((primitive-ref error) . 4))
#    expr = (funcall (primitive-ref primitives))
# emit-expr (primitive-ref primitives)
    .extern mrc_primitives
    movl mrc_primitives,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1432379"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1432379":
   movl %eax,  -40(%esp)  # stash funcall-oper in closure slot
    movl -40(%esp), %edi   # load new closure to %edi
    add $-32, %esp   # adjust base
    movl $0,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $32, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    mov %eax, -32(%esp)  # arg ((primitive-ref primitives))
# emit-expr f195986
# emit-variable-ref
# env=((f195986 . -12) (f195986 . -8) ((primitive-ref primitives) . 12) ((primitive-ref list-ref) . 8) ((primitive-ref error) . 4))
# var=f195986
    movl -12(%esp), %eax  # stack load f195986
# end emit-variable-ref
    mov %eax, -36(%esp)  # arg f195986
    movl -28(%esp), %edi   # load new closure to %edi
    add $-20, %esp   # adjust base
    movl $8,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $20, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    mov %eax, -20(%esp)    # arg ((primitive-ref list-ref) ((primitive-ref primitives)) f195986)
# emit-expr "index out of bounds"
# string literal
    jmp _L_1432381
    .align 8,0x90
_L_1432380 :
    .int 76
    .ascii "index out of bounds"
_L_1432381:
    movl $_L_1432380, %eax
    orl $6, %eax
    mov %eax, -24(%esp)    # arg index out of bounds
    movl -16(%esp), %edi   # load new closure to %edi
# emit-shift-args:  size=3   si=-16  delta=12
    mov -16(%esp), %ebx  # shift frame cell
    mov %ebx, -4(%esp)  # down to base
# emit-shift-args:  size=2   si=-20  delta=12
    mov -20(%esp), %ebx  # shift frame cell
    mov %ebx, -8(%esp)  # down to base
# emit-shift-args:  size=1   si=-24  delta=12
    mov -24(%esp), %ebx  # shift frame cell
    mov %ebx, -12(%esp)  # down to base
# emit-shift-args:  size=0   si=-28  delta=12
    movl $8,%eax   # save arg count
    jmp *-2(%edi)  # tail-funcall
    .align 4,0x90
_L_1432376:
     movl %eax, mrc_eh$uvector$uindex
# == explicit-begins  ==>
# (lambda (i) (error (list-ref (primitives) i) "index out of bounds"))
# == eliminate-let*  ==>
# (lambda (i) (error (list-ref (primitives) i) "index out of bounds"))
# == uniquify-variables  ==>
# (lambda (f195987) (error (list-ref (primitives) f195987) "index out of bounds"))
# == vectorize-letrec  ==>
# (lambda (f195987) (error (list-ref (primitives) f195987) "index out of bounds"))
# == eliminate-set!  ==>
# (lambda (f195987) (let ((f195987 f195987)) (error (list-ref (primitives) f195987) "index out of bounds")))
# == close-free-variables  ==>
# (closure (f195987) (error list-ref primitives) (let ((f195987 f195987)) (error (list-ref (primitives) f195987) "index out of bounds")))
# == eliminate-quote  ==>
# (closure (f195987) (error list-ref primitives) (let ((f195987 f195987)) (error (list-ref (primitives) f195987) "index out of bounds")))
# == eliminate-when/unless  ==>
# (closure (f195987) (error list-ref primitives) (let ((f195987 f195987)) (error (list-ref (primitives) f195987) "index out of bounds")))
# == eliminate-cond  ==>
# (closure (f195987) (error list-ref primitives) (let ((f195987 f195987)) (error (list-ref (primitives) f195987) "index out of bounds")))
# == external-symbols  ==>
# (closure (f195987) ((primitive-ref error) (primitive-ref list-ref) (primitive-ref primitives)) (let ((f195987 f195987)) ((primitive-ref error) ((primitive-ref list-ref) ((primitive-ref primitives)) f195987) "index out of bounds")))
# emit-expr (closure (f195987) ((primitive-ref error) (primitive-ref list-ref) (primitive-ref primitives)) (let ((f195987 f195987)) ((primitive-ref error) ((primitive-ref list-ref) ((primitive-ref primitives)) f195987) "index out of bounds")))
# emit-closure
# si = 0
# env = ()
# expr = (closure (f195987) ((primitive-ref error) (primitive-ref list-ref) (primitive-ref primitives)) (let ((f195987 f195987)) ((primitive-ref error) ((primitive-ref list-ref) ((primitive-ref primitives)) f195987) "index out of bounds")))
    movl $_L_1432382, 0(%ebp)  # closure label
# WARNING: free var (primitive-ref error) not defined in the environmnet
# WARNING: free var (primitive-ref list-ref) not defined in the environmnet
# WARNING: free var (primitive-ref primitives) not defined in the environmnet
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $16, %ebp     # bump ebp
    jmp _L_1432383            # jump around closure body
_L_1432382:
# check argument count
    cmp $4,%eax
    je _L_1432384
# invoke error handler eh_argcount
    .extern mrc_eh$uargcount
    movl mrc_eh$uargcount, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_1432384:
# emit-tail-expr
# si=-12
# env=((f195987 . -8) ((primitive-ref primitives) . 12) ((primitive-ref list-ref) . 8) ((primitive-ref error) . 4))
# expr=(let ((f195987 f195987)) ((primitive-ref error) ((primitive-ref list-ref) ((primitive-ref primitives)) f195987) "index out of bounds"))
# emit-tail-let
#  si   = -12
#  env  = ((f195987 . -8) ((primitive-ref primitives) . 12) ((primitive-ref list-ref) . 8) ((primitive-ref error) . 4))
#  bindings = ((f195987 f195987))
#  body = ((primitive-ref error) ((primitive-ref list-ref) ((primitive-ref primitives)) f195987) "index out of bounds")
# emit-expr f195987
# emit-variable-ref
# env=((f195987 . -8) ((primitive-ref primitives) . 12) ((primitive-ref list-ref) . 8) ((primitive-ref error) . 4))
# var=f195987
    movl -8(%esp), %eax  # stack load f195987
# end emit-variable-ref
    movl %eax, -12(%esp)  # stack save
# emit-tail-expr
# si=-16
# env=((f195987 . -12) (f195987 . -8) ((primitive-ref primitives) . 12) ((primitive-ref list-ref) . 8) ((primitive-ref error) . 4))
# expr=((primitive-ref error) ((primitive-ref list-ref) ((primitive-ref primitives)) f195987) "index out of bounds")
# emit-tail-funcall
#    si   =-16
#    env  = ((f195987 . -12) (f195987 . -8) ((primitive-ref primitives) . 12) ((primitive-ref list-ref) . 8) ((primitive-ref error) . 4))
#    expr = (funcall (primitive-ref error) ((primitive-ref list-ref) ((primitive-ref primitives)) f195987) "index out of bounds")
# emit-expr (primitive-ref error)
    .extern mrc_error
    movl mrc_error,%eax
   movl %eax,  -16(%esp)  # stash funcall-oper in next closure slot
# emit-expr ((primitive-ref list-ref) ((primitive-ref primitives)) f195987)
# funcall
#    si   =-20
#    env  = ((f195987 . -12) (f195987 . -8) ((primitive-ref primitives) . 12) ((primitive-ref list-ref) . 8) ((primitive-ref error) . 4))
#    expr = (funcall (primitive-ref list-ref) ((primitive-ref primitives)) f195987)
# emit-expr (primitive-ref list-ref)
    .extern mrc_list$mref
    movl mrc_list$mref,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1432385"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1432385":
   movl %eax,  -28(%esp)  # stash funcall-oper in closure slot
# emit-expr ((primitive-ref primitives))
# funcall
#    si   =-32
#    env  = ((f195987 . -12) (f195987 . -8) ((primitive-ref primitives) . 12) ((primitive-ref list-ref) . 8) ((primitive-ref error) . 4))
#    expr = (funcall (primitive-ref primitives))
# emit-expr (primitive-ref primitives)
    .extern mrc_primitives
    movl mrc_primitives,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1432386"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1432386":
   movl %eax,  -40(%esp)  # stash funcall-oper in closure slot
    movl -40(%esp), %edi   # load new closure to %edi
    add $-32, %esp   # adjust base
    movl $0,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $32, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    mov %eax, -32(%esp)  # arg ((primitive-ref primitives))
# emit-expr f195987
# emit-variable-ref
# env=((f195987 . -12) (f195987 . -8) ((primitive-ref primitives) . 12) ((primitive-ref list-ref) . 8) ((primitive-ref error) . 4))
# var=f195987
    movl -12(%esp), %eax  # stack load f195987
# end emit-variable-ref
    mov %eax, -36(%esp)  # arg f195987
    movl -28(%esp), %edi   # load new closure to %edi
    add $-20, %esp   # adjust base
    movl $8,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $20, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    mov %eax, -20(%esp)    # arg ((primitive-ref list-ref) ((primitive-ref primitives)) f195987)
# emit-expr "index out of bounds"
# string literal
    jmp _L_1432388
    .align 8,0x90
_L_1432387 :
    .int 76
    .ascii "index out of bounds"
_L_1432388:
    movl $_L_1432387, %eax
    orl $6, %eax
    mov %eax, -24(%esp)    # arg index out of bounds
    movl -16(%esp), %edi   # load new closure to %edi
# emit-shift-args:  size=3   si=-16  delta=12
    mov -16(%esp), %ebx  # shift frame cell
    mov %ebx, -4(%esp)  # down to base
# emit-shift-args:  size=2   si=-20  delta=12
    mov -20(%esp), %ebx  # shift frame cell
    mov %ebx, -8(%esp)  # down to base
# emit-shift-args:  size=1   si=-24  delta=12
    mov -24(%esp), %ebx  # shift frame cell
    mov %ebx, -12(%esp)  # down to base
# emit-shift-args:  size=0   si=-28  delta=12
    movl $8,%eax   # save arg count
    jmp *-2(%edi)  # tail-funcall
    .align 4,0x90
_L_1432383:
     movl %eax, mrc_eh$ustring$uindex
# == explicit-begins  ==>
# (lambda (z) (fxzero? z))
# == eliminate-let*  ==>
# (lambda (z) (fxzero? z))
# == uniquify-variables  ==>
# (lambda (f195988) (fxzero? f195988))
# == vectorize-letrec  ==>
# (lambda (f195988) (fxzero? f195988))
# == eliminate-set!  ==>
# (lambda (f195988) (let ((f195988 f195988)) (fxzero? f195988)))
# == close-free-variables  ==>
# (closure (f195988) () (let ((f195988 f195988)) (fxzero? f195988)))
# == eliminate-quote  ==>
# (closure (f195988) () (let ((f195988 f195988)) (fxzero? f195988)))
# == eliminate-when/unless  ==>
# (closure (f195988) () (let ((f195988 f195988)) (fxzero? f195988)))
# == eliminate-cond  ==>
# (closure (f195988) () (let ((f195988 f195988)) (fxzero? f195988)))
# == external-symbols  ==>
# (closure (f195988) () (let ((f195988 f195988)) (fxzero? f195988)))
# emit-expr (closure (f195988) () (let ((f195988 f195988)) (fxzero? f195988)))
# emit-closure
# si = 0
# env = ()
# expr = (closure (f195988) () (let ((f195988 f195988)) (fxzero? f195988)))
    movl $_L_1432389, 0(%ebp)  # closure label
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $8, %ebp     # bump ebp
    jmp _L_1432390            # jump around closure body
_L_1432389:
# check argument count
    cmp $4,%eax
    je _L_1432391
# invoke error handler eh_argcount
    .extern mrc_eh$uargcount
    movl mrc_eh$uargcount, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_1432391:
# emit-tail-expr
# si=-12
# env=((f195988 . -8))
# expr=(let ((f195988 f195988)) (fxzero? f195988))
# emit-tail-let
#  si   = -12
#  env  = ((f195988 . -8))
#  bindings = ((f195988 f195988))
#  body = (fxzero? f195988)
# emit-expr f195988
# emit-variable-ref
# env=((f195988 . -8))
# var=f195988
    movl -8(%esp), %eax  # stack load f195988
# end emit-variable-ref
    movl %eax, -12(%esp)  # stack save
# emit-tail-expr
# si=-16
# env=((f195988 . -12) (f195988 . -8))
# expr=(fxzero? f195988)
# tail primcall
# emit-expr f195988
# emit-variable-ref
# env=((f195988 . -12) (f195988 . -8))
# var=f195988
    movl -12(%esp), %eax  # stack load f195988
# end emit-variable-ref
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1432392"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $56,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1432392:
    cmp $0, %eax
    sete %al
    movzbl %al, %eax
    sal $6, %al
    or $47, %al
#return from tail (fxzero? f195988)
    ret
    .align 4,0x90
_L_1432390:
     movl %eax, mrc_zero$q
# == explicit-begins  ==>
# (lambda (x) (fx> x 0))
# == eliminate-let*  ==>
# (lambda (x) (fx> x 0))
# == uniquify-variables  ==>
# (lambda (f195989) (fx> f195989 0))
# == vectorize-letrec  ==>
# (lambda (f195989) (fx> f195989 0))
# == eliminate-set!  ==>
# (lambda (f195989) (let ((f195989 f195989)) (fx> f195989 0)))
# == close-free-variables  ==>
# (closure (f195989) () (let ((f195989 f195989)) (fx> f195989 0)))
# == eliminate-quote  ==>
# (closure (f195989) () (let ((f195989 f195989)) (fx> f195989 0)))
# == eliminate-when/unless  ==>
# (closure (f195989) () (let ((f195989 f195989)) (fx> f195989 0)))
# == eliminate-cond  ==>
# (closure (f195989) () (let ((f195989 f195989)) (fx> f195989 0)))
# == external-symbols  ==>
# (closure (f195989) () (let ((f195989 f195989)) (fx> f195989 0)))
# emit-expr (closure (f195989) () (let ((f195989 f195989)) (fx> f195989 0)))
# emit-closure
# si = 0
# env = ()
# expr = (closure (f195989) () (let ((f195989 f195989)) (fx> f195989 0)))
    movl $_L_1432393, 0(%ebp)  # closure label
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $8, %ebp     # bump ebp
    jmp _L_1432394            # jump around closure body
_L_1432393:
# check argument count
    cmp $4,%eax
    je _L_1432395
# invoke error handler eh_argcount
    .extern mrc_eh$uargcount
    movl mrc_eh$uargcount, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_1432395:
# emit-tail-expr
# si=-12
# env=((f195989 . -8))
# expr=(let ((f195989 f195989)) (fx> f195989 0))
# emit-tail-let
#  si   = -12
#  env  = ((f195989 . -8))
#  bindings = ((f195989 f195989))
#  body = (fx> f195989 0)
# emit-expr f195989
# emit-variable-ref
# env=((f195989 . -8))
# var=f195989
    movl -8(%esp), %eax  # stack load f195989
# end emit-variable-ref
    movl %eax, -12(%esp)  # stack save
# emit-tail-expr
# si=-16
# env=((f195989 . -12) (f195989 . -8))
# expr=(fx> f195989 0)
# tail primcall
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1432396"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $72,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1432396:
    movl %eax, -16(%esp)
# emit-expr f195989
# emit-variable-ref
# env=((f195989 . -12) (f195989 . -8))
# var=f195989
    movl -12(%esp), %eax  # stack load f195989
# end emit-variable-ref
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1432397"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $72,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1432397:
    cmp -16(%esp), %eax
    setg %al
    movzbl %al, %eax
    sal $6, %al
    or $47, %al
#return from tail (fx> f195989 0)
    ret
    .align 4,0x90
_L_1432394:
     movl %eax, mrc_positive$q
# == explicit-begins  ==>
# (lambda (x) (fx< x 0))
# == eliminate-let*  ==>
# (lambda (x) (fx< x 0))
# == uniquify-variables  ==>
# (lambda (f195990) (fx< f195990 0))
# == vectorize-letrec  ==>
# (lambda (f195990) (fx< f195990 0))
# == eliminate-set!  ==>
# (lambda (f195990) (let ((f195990 f195990)) (fx< f195990 0)))
# == close-free-variables  ==>
# (closure (f195990) () (let ((f195990 f195990)) (fx< f195990 0)))
# == eliminate-quote  ==>
# (closure (f195990) () (let ((f195990 f195990)) (fx< f195990 0)))
# == eliminate-when/unless  ==>
# (closure (f195990) () (let ((f195990 f195990)) (fx< f195990 0)))
# == eliminate-cond  ==>
# (closure (f195990) () (let ((f195990 f195990)) (fx< f195990 0)))
# == external-symbols  ==>
# (closure (f195990) () (let ((f195990 f195990)) (fx< f195990 0)))
# emit-expr (closure (f195990) () (let ((f195990 f195990)) (fx< f195990 0)))
# emit-closure
# si = 0
# env = ()
# expr = (closure (f195990) () (let ((f195990 f195990)) (fx< f195990 0)))
    movl $_L_1432398, 0(%ebp)  # closure label
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $8, %ebp     # bump ebp
    jmp _L_1432399            # jump around closure body
_L_1432398:
# check argument count
    cmp $4,%eax
    je _L_1432400
# invoke error handler eh_argcount
    .extern mrc_eh$uargcount
    movl mrc_eh$uargcount, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_1432400:
# emit-tail-expr
# si=-12
# env=((f195990 . -8))
# expr=(let ((f195990 f195990)) (fx< f195990 0))
# emit-tail-let
#  si   = -12
#  env  = ((f195990 . -8))
#  bindings = ((f195990 f195990))
#  body = (fx< f195990 0)
# emit-expr f195990
# emit-variable-ref
# env=((f195990 . -8))
# var=f195990
    movl -8(%esp), %eax  # stack load f195990
# end emit-variable-ref
    movl %eax, -12(%esp)  # stack save
# emit-tail-expr
# si=-16
# env=((f195990 . -12) (f195990 . -8))
# expr=(fx< f195990 0)
# tail primcall
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1432401"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $64,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1432401:
    movl %eax, -16(%esp)
# emit-expr f195990
# emit-variable-ref
# env=((f195990 . -12) (f195990 . -8))
# var=f195990
    movl -12(%esp), %eax  # stack load f195990
# end emit-variable-ref
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1432402"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $64,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1432402:
    cmp -16(%esp), %eax
    setl %al
    movzbl %al, %eax
    sal $6, %al
    or $47, %al
#return from tail (fx< f195990 0)
    ret
    .align 4,0x90
_L_1432399:
     movl %eax, mrc_negative$q
# == explicit-begins  ==>
# (lambda (f l) (if (null? l) (quote ()) (cons (f (car l)) (map f (cdr l)))))
# == eliminate-let*  ==>
# (lambda (f l) (if (null? l) (quote ()) (cons (f (car l)) (map f (cdr l)))))
# == uniquify-variables  ==>
# (lambda (f195991 f195992) (if (null? f195992) (quote ()) (cons (f195991 (car f195992)) (map f195991 (cdr f195992)))))
# == vectorize-letrec  ==>
# (lambda (f195991 f195992) (if (null? f195992) (quote ()) (cons (f195991 (car f195992)) (map f195991 (cdr f195992)))))
# == eliminate-set!  ==>
# (lambda (f195991 f195992) (let ((f195991 f195991) (f195992 f195992)) (if (null? f195992) (quote ()) (cons (f195991 (car f195992)) (map f195991 (cdr f195992))))))
# == close-free-variables  ==>
# (closure (f195991 f195992) (map) (let ((f195991 f195991) (f195992 f195992)) (if (null? f195992) (quote ()) (cons (f195991 (car f195992)) (map f195991 (cdr f195992))))))
# == eliminate-quote  ==>
# (closure (f195991 f195992) (map) (let ((f195991 f195991) (f195992 f195992)) (if (null? f195992) () (cons (f195991 (car f195992)) (map f195991 (cdr f195992))))))
# == eliminate-when/unless  ==>
# (closure (f195991 f195992) (map) (let ((f195991 f195991) (f195992 f195992)) (if (null? f195992) () (cons (f195991 (car f195992)) (map f195991 (cdr f195992))))))
# == eliminate-cond  ==>
# (closure (f195991 f195992) (map) (let ((f195991 f195991) (f195992 f195992)) (if (null? f195992) () (cons (f195991 (car f195992)) (map f195991 (cdr f195992))))))
# == external-symbols  ==>
# (closure (f195991 f195992) ((primitive-ref map)) (let ((f195991 f195991) (f195992 f195992)) (if (null? f195992) () (cons (f195991 (car f195992)) ((primitive-ref map) f195991 (cdr f195992))))))
# emit-expr (closure (f195991 f195992) ((primitive-ref map)) (let ((f195991 f195991) (f195992 f195992)) (if (null? f195992) () (cons (f195991 (car f195992)) ((primitive-ref map) f195991 (cdr f195992))))))
# emit-closure
# si = 0
# env = ()
# expr = (closure (f195991 f195992) ((primitive-ref map)) (let ((f195991 f195991) (f195992 f195992)) (if (null? f195992) () (cons (f195991 (car f195992)) ((primitive-ref map) f195991 (cdr f195992))))))
    movl $_L_1432403, 0(%ebp)  # closure label
# WARNING: free var (primitive-ref map) not defined in the environmnet
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $8, %ebp     # bump ebp
    jmp _L_1432404            # jump around closure body
_L_1432403:
# check argument count
    cmp $8,%eax
    je _L_1432405
# invoke error handler eh_argcount
    .extern mrc_eh$uargcount
    movl mrc_eh$uargcount, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_1432405:
# emit-tail-expr
# si=-16
# env=((f195992 . -12) (f195991 . -8) ((primitive-ref map) . 4))
# expr=(let ((f195991 f195991) (f195992 f195992)) (if (null? f195992) () (cons (f195991 (car f195992)) ((primitive-ref map) f195991 (cdr f195992)))))
# emit-tail-let
#  si   = -16
#  env  = ((f195992 . -12) (f195991 . -8) ((primitive-ref map) . 4))
#  bindings = ((f195991 f195991) (f195992 f195992))
#  body = (if (null? f195992) () (cons (f195991 (car f195992)) ((primitive-ref map) f195991 (cdr f195992))))
# emit-expr f195991
# emit-variable-ref
# env=((f195992 . -12) (f195991 . -8) ((primitive-ref map) . 4))
# var=f195991
    movl -8(%esp), %eax  # stack load f195991
# end emit-variable-ref
    movl %eax, -16(%esp)  # stack save
# emit-expr f195992
# emit-variable-ref
# env=((f195992 . -12) (f195991 . -8) ((primitive-ref map) . 4))
# var=f195992
    movl -12(%esp), %eax  # stack load f195992
# end emit-variable-ref
    movl %eax, -20(%esp)  # stack save
# emit-tail-expr
# si=-24
# env=((f195992 . -20) (f195991 . -16) (f195992 . -12) (f195991 . -8) ((primitive-ref map) . 4))
# expr=(if (null? f195992) () (cons (f195991 (car f195992)) ((primitive-ref map) f195991 (cdr f195992))))
# emit-expr (null? f195992)
# emit-expr f195992
# emit-variable-ref
# env=((f195992 . -20) (f195991 . -16) (f195992 . -12) (f195991 . -8) ((primitive-ref map) . 4))
# var=f195992
    movl -20(%esp), %eax  # stack load f195992
# end emit-variable-ref
    cmp $63, %eax
    mov $0, %eax
    sete %al
    movzbl %al, %eax
    sal $6, %al
    or $47, %al
    cmp $47, %al
    je _L_1432406
# emit-tail-expr
# si=-24
# env=((f195992 . -20) (f195991 . -16) (f195992 . -12) (f195991 . -8) ((primitive-ref map) . 4))
# expr=()
    movl $63, %eax     # immed ()
    ret                  # immediate tail return
    jmp _L_1432407
_L_1432406:
# emit-tail-expr
# si=-24
# env=((f195992 . -20) (f195991 . -16) (f195992 . -12) (f195991 . -8) ((primitive-ref map) . 4))
# expr=(cons (f195991 (car f195992)) ((primitive-ref map) f195991 (cdr f195992)))
# tail primcall
# cons arg1=(f195991 (car f195992)) arg2=((primitive-ref map) f195991 (cdr f195992))
# emit-expr (f195991 (car f195992))
# funcall
#    si   =-24
#    env  = ((f195992 . -20) (f195991 . -16) (f195992 . -12) (f195991 . -8) ((primitive-ref map) . 4))
#    expr = (funcall f195991 (car f195992))
# emit-expr f195991
# emit-variable-ref
# env=((f195992 . -20) (f195991 . -16) (f195992 . -12) (f195991 . -8) ((primitive-ref map) . 4))
# var=f195991
    movl -16(%esp), %eax  # stack load f195991
# end emit-variable-ref
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1432408"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1432408":
   movl %eax,  -32(%esp)  # stash funcall-oper in closure slot
# emit-expr (car f195992)
# emit-expr f195992
# emit-variable-ref
# env=((f195992 . -20) (f195991 . -16) (f195992 . -12) (f195991 . -8) ((primitive-ref map) . 4))
# var=f195992
    movl -20(%esp), %eax  # stack load f195992
# end emit-variable-ref
# check the argument is a pair
    movl %eax,%ebx
    and $7, %bl
    cmp $1, %bl
    je _L_1432409
# invoke error handler eh_pair
    .extern mrc_eh$upair
    movl mrc_eh$upair, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $108,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1432409:
    movl -1(%eax), %eax
    mov %eax, -36(%esp)  # arg (car f195992)
    movl -32(%esp), %edi   # load new closure to %edi
    add $-24, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $24, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    movl %eax, -24(%esp)
# emit-expr ((primitive-ref map) f195991 (cdr f195992))
# funcall
#    si   =-28
#    env  = ((f195992 . -20) (f195991 . -16) (f195992 . -12) (f195991 . -8) ((primitive-ref map) . 4))
#    expr = (funcall (primitive-ref map) f195991 (cdr f195992))
# emit-expr (primitive-ref map)
    .extern mrc_map
    movl mrc_map,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1432410"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1432410":
   movl %eax,  -36(%esp)  # stash funcall-oper in closure slot
# emit-expr f195991
# emit-variable-ref
# env=((f195992 . -20) (f195991 . -16) (f195992 . -12) (f195991 . -8) ((primitive-ref map) . 4))
# var=f195991
    movl -16(%esp), %eax  # stack load f195991
# end emit-variable-ref
    mov %eax, -40(%esp)  # arg f195991
# emit-expr (cdr f195992)
# emit-expr f195992
# emit-variable-ref
# env=((f195992 . -20) (f195991 . -16) (f195992 . -12) (f195991 . -8) ((primitive-ref map) . 4))
# var=f195992
    movl -20(%esp), %eax  # stack load f195992
# end emit-variable-ref
# check the argument is a pair
    movl %eax,%ebx
    and $7, %bl
    cmp $1, %bl
    je _L_1432411
# invoke error handler eh_pair
    .extern mrc_eh$upair
    movl mrc_eh$upair, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $112,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1432411:
    movl 3(%eax), %eax
    mov %eax, -44(%esp)  # arg (cdr f195992)
    movl -36(%esp), %edi   # load new closure to %edi
    add $-28, %esp   # adjust base
    movl $8,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $28, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    movl %eax, 4(%ebp)
    movl -24(%esp), %eax
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    or   $1, %al
    add  $8, %ebp
# cons end
#return from tail (cons (f195991 (car f195992)) ((primitive-ref map) f195991 (cdr f195992)))
    ret
_L_1432407:
    .align 4,0x90
_L_1432404:
     movl %eax, mrc_map
# == explicit-begins  ==>
# (lambda (f l) (unless (null? l) (begin (f (car l)) (for-each f (cdr l)))))
# == eliminate-let*  ==>
# (lambda (f l) (unless (null? l) (begin (f (car l)) (for-each f (cdr l)))))
# == uniquify-variables  ==>
# (lambda (f195993 f195994) (unless (null? f195994) (begin (f195993 (car f195994)) (for-each f195993 (cdr f195994)))))
# == vectorize-letrec  ==>
# (lambda (f195993 f195994) (unless (null? f195994) (begin (f195993 (car f195994)) (for-each f195993 (cdr f195994)))))
# == eliminate-set!  ==>
# (lambda (f195993 f195994) (let ((f195993 f195993) (f195994 f195994)) (unless (null? f195994) (begin (f195993 (car f195994)) (for-each f195993 (cdr f195994))))))
# == close-free-variables  ==>
# (closure (f195993 f195994) (unless for-each) (let ((f195993 f195993) (f195994 f195994)) (unless (null? f195994) (begin (f195993 (car f195994)) (for-each f195993 (cdr f195994))))))
# == eliminate-quote  ==>
# (closure (f195993 f195994) (unless for-each) (let ((f195993 f195993) (f195994 f195994)) (unless (null? f195994) (begin (f195993 (car f195994)) (for-each f195993 (cdr f195994))))))
# == eliminate-when/unless  ==>
# (closure (f195993 f195994) (if (not for-each) (begin) #f) (let ((f195993 f195993) (f195994 f195994)) (if (not (null? f195994)) (begin (begin (f195993 (car f195994)) (for-each f195993 (cdr f195994)))) #f)))
# == eliminate-cond  ==>
# (closure (f195993 f195994) (if (not for-each) (begin) #f) (let ((f195993 f195993) (f195994 f195994)) (if (not (null? f195994)) (begin (begin (f195993 (car f195994)) (for-each f195993 (cdr f195994)))) #f)))
# == external-symbols  ==>
# (closure (f195993 f195994) (if (not (primitive-ref for-each)) (begin) #f) (let ((f195993 f195993) (f195994 f195994)) (if (not (null? f195994)) (begin (begin (f195993 (car f195994)) ((primitive-ref for-each) f195993 (cdr f195994)))) #f)))
# emit-expr (closure (f195993 f195994) (if (not (primitive-ref for-each)) (begin) #f) (let ((f195993 f195993) (f195994 f195994)) (if (not (null? f195994)) (begin (begin (f195993 (car f195994)) ((primitive-ref for-each) f195993 (cdr f195994)))) #f)))
# emit-closure
# si = 0
# env = ()
# expr = (closure (f195993 f195994) (if (not (primitive-ref for-each)) (begin) #f) (let ((f195993 f195993) (f195994 f195994)) (if (not (null? f195994)) (begin (begin (f195993 (car f195994)) ((primitive-ref for-each) f195993 (cdr f195994)))) #f)))
    movl $_L_1432412, 0(%ebp)  # closure label
# WARNING: free var if not defined in the environmnet
# WARNING: free var (not (primitive-ref for-each)) not defined in the environmnet
# WARNING: free var (begin) not defined in the environmnet
# WARNING: free var #f not defined in the environmnet
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $24, %ebp     # bump ebp
    jmp _L_1432413            # jump around closure body
_L_1432412:
# check argument count
    cmp $8,%eax
    je _L_1432414
# invoke error handler eh_argcount
    .extern mrc_eh$uargcount
    movl mrc_eh$uargcount, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_1432414:
# emit-tail-expr
# si=-16
# env=((f195994 . -12) (f195993 . -8) (#f . 16) ((begin) . 12) ((not (primitive-ref for-each)) . 8) (if . 4))
# expr=(let ((f195993 f195993) (f195994 f195994)) (if (not (null? f195994)) (begin (begin (f195993 (car f195994)) ((primitive-ref for-each) f195993 (cdr f195994)))) #f))
# emit-tail-let
#  si   = -16
#  env  = ((f195994 . -12) (f195993 . -8) (#f . 16) ((begin) . 12) ((not (primitive-ref for-each)) . 8) (if . 4))
#  bindings = ((f195993 f195993) (f195994 f195994))
#  body = (if (not (null? f195994)) (begin (begin (f195993 (car f195994)) ((primitive-ref for-each) f195993 (cdr f195994)))) #f)
# emit-expr f195993
# emit-variable-ref
# env=((f195994 . -12) (f195993 . -8) (#f . 16) ((begin) . 12) ((not (primitive-ref for-each)) . 8) (if . 4))
# var=f195993
    movl -8(%esp), %eax  # stack load f195993
# end emit-variable-ref
    movl %eax, -16(%esp)  # stack save
# emit-expr f195994
# emit-variable-ref
# env=((f195994 . -12) (f195993 . -8) (#f . 16) ((begin) . 12) ((not (primitive-ref for-each)) . 8) (if . 4))
# var=f195994
    movl -12(%esp), %eax  # stack load f195994
# end emit-variable-ref
    movl %eax, -20(%esp)  # stack save
# emit-tail-expr
# si=-24
# env=((f195994 . -20) (f195993 . -16) (f195994 . -12) (f195993 . -8) (#f . 16) ((begin) . 12) ((not (primitive-ref for-each)) . 8) (if . 4))
# expr=(if (not (null? f195994)) (begin (begin (f195993 (car f195994)) ((primitive-ref for-each) f195993 (cdr f195994)))) #f)
# emit-expr (not (null? f195994))
# emit-expr (null? f195994)
# emit-expr f195994
# emit-variable-ref
# env=((f195994 . -20) (f195993 . -16) (f195994 . -12) (f195993 . -8) (#f . 16) ((begin) . 12) ((not (primitive-ref for-each)) . 8) (if . 4))
# var=f195994
    movl -20(%esp), %eax  # stack load f195994
# end emit-variable-ref
    cmp $63, %eax
    mov $0, %eax
    sete %al
    movzbl %al, %eax
    sal $6, %al
    or $47, %al
    cmp $47, %eax
    sete %al
    movzbl %al, %eax
    sal $6, %al
    or $47, %al
    cmp $47, %al
    je _L_1432415
# emit-tail-expr
# si=-24
# env=((f195994 . -20) (f195993 . -16) (f195994 . -12) (f195993 . -8) (#f . 16) ((begin) . 12) ((not (primitive-ref for-each)) . 8) (if . 4))
# expr=(begin (begin (f195993 (car f195994)) ((primitive-ref for-each) f195993 (cdr f195994))))
# tail-begin (begin (begin (f195993 (car f195994)) ((primitive-ref for-each) f195993 (cdr f195994))))
#   env=((f195994 . -20) (f195993 . -16) (f195994 . -12) (f195993 . -8) (#f . 16) ((begin) . 12) ((not (primitive-ref for-each)) . 8) (if . 4))
# emit-tail-expr
# si=-24
# env=((f195994 . -20) (f195993 . -16) (f195994 . -12) (f195993 . -8) (#f . 16) ((begin) . 12) ((not (primitive-ref for-each)) . 8) (if . 4))
# expr=(begin (f195993 (car f195994)) ((primitive-ref for-each) f195993 (cdr f195994)))
# tail-begin (begin (f195993 (car f195994)) ((primitive-ref for-each) f195993 (cdr f195994)))
#   env=((f195994 . -20) (f195993 . -16) (f195994 . -12) (f195993 . -8) (#f . 16) ((begin) . 12) ((not (primitive-ref for-each)) . 8) (if . 4))
# emit-expr (f195993 (car f195994))
# funcall
#    si   =-24
#    env  = ((f195994 . -20) (f195993 . -16) (f195994 . -12) (f195993 . -8) (#f . 16) ((begin) . 12) ((not (primitive-ref for-each)) . 8) (if . 4))
#    expr = (funcall f195993 (car f195994))
# emit-expr f195993
# emit-variable-ref
# env=((f195994 . -20) (f195993 . -16) (f195994 . -12) (f195993 . -8) (#f . 16) ((begin) . 12) ((not (primitive-ref for-each)) . 8) (if . 4))
# var=f195993
    movl -16(%esp), %eax  # stack load f195993
# end emit-variable-ref
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1432417"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1432417":
   movl %eax,  -32(%esp)  # stash funcall-oper in closure slot
# emit-expr (car f195994)
# emit-expr f195994
# emit-variable-ref
# env=((f195994 . -20) (f195993 . -16) (f195994 . -12) (f195993 . -8) (#f . 16) ((begin) . 12) ((not (primitive-ref for-each)) . 8) (if . 4))
# var=f195994
    movl -20(%esp), %eax  # stack load f195994
# end emit-variable-ref
# check the argument is a pair
    movl %eax,%ebx
    and $7, %bl
    cmp $1, %bl
    je _L_1432418
# invoke error handler eh_pair
    .extern mrc_eh$upair
    movl mrc_eh$upair, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $108,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1432418:
    movl -1(%eax), %eax
    mov %eax, -36(%esp)  # arg (car f195994)
    movl -32(%esp), %edi   # load new closure to %edi
    add $-24, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $24, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
# emit-tail-expr
# si=-24
# env=((f195994 . -20) (f195993 . -16) (f195994 . -12) (f195993 . -8) (#f . 16) ((begin) . 12) ((not (primitive-ref for-each)) . 8) (if . 4))
# expr=(begin ((primitive-ref for-each) f195993 (cdr f195994)))
# tail-begin (begin ((primitive-ref for-each) f195993 (cdr f195994)))
#   env=((f195994 . -20) (f195993 . -16) (f195994 . -12) (f195993 . -8) (#f . 16) ((begin) . 12) ((not (primitive-ref for-each)) . 8) (if . 4))
# emit-tail-expr
# si=-24
# env=((f195994 . -20) (f195993 . -16) (f195994 . -12) (f195993 . -8) (#f . 16) ((begin) . 12) ((not (primitive-ref for-each)) . 8) (if . 4))
# expr=((primitive-ref for-each) f195993 (cdr f195994))
# emit-tail-funcall
#    si   =-24
#    env  = ((f195994 . -20) (f195993 . -16) (f195994 . -12) (f195993 . -8) (#f . 16) ((begin) . 12) ((not (primitive-ref for-each)) . 8) (if . 4))
#    expr = (funcall (primitive-ref for-each) f195993 (cdr f195994))
# emit-expr (primitive-ref for-each)
    .extern mrc_for$meach
    movl mrc_for$meach,%eax
   movl %eax,  -24(%esp)  # stash funcall-oper in next closure slot
# emit-expr f195993
# emit-variable-ref
# env=((f195994 . -20) (f195993 . -16) (f195994 . -12) (f195993 . -8) (#f . 16) ((begin) . 12) ((not (primitive-ref for-each)) . 8) (if . 4))
# var=f195993
    movl -16(%esp), %eax  # stack load f195993
# end emit-variable-ref
    mov %eax, -28(%esp)    # arg f195993
# emit-expr (cdr f195994)
# emit-expr f195994
# emit-variable-ref
# env=((f195994 . -20) (f195993 . -16) (f195994 . -12) (f195993 . -8) (#f . 16) ((begin) . 12) ((not (primitive-ref for-each)) . 8) (if . 4))
# var=f195994
    movl -20(%esp), %eax  # stack load f195994
# end emit-variable-ref
# check the argument is a pair
    movl %eax,%ebx
    and $7, %bl
    cmp $1, %bl
    je _L_1432419
# invoke error handler eh_pair
    .extern mrc_eh$upair
    movl mrc_eh$upair, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $112,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1432419:
    movl 3(%eax), %eax
    mov %eax, -32(%esp)    # arg (cdr f195994)
    movl -24(%esp), %edi   # load new closure to %edi
# emit-shift-args:  size=3   si=-24  delta=20
    mov -24(%esp), %ebx  # shift frame cell
    mov %ebx, -4(%esp)  # down to base
# emit-shift-args:  size=2   si=-28  delta=20
    mov -28(%esp), %ebx  # shift frame cell
    mov %ebx, -8(%esp)  # down to base
# emit-shift-args:  size=1   si=-32  delta=20
    mov -32(%esp), %ebx  # shift frame cell
    mov %ebx, -12(%esp)  # down to base
# emit-shift-args:  size=0   si=-36  delta=20
    movl $8,%eax   # save arg count
    jmp *-2(%edi)  # tail-funcall
     ret   # return thru stack
     ret   # return thru stack
    jmp _L_1432416
_L_1432415:
# emit-tail-expr
# si=-24
# env=((f195994 . -20) (f195993 . -16) (f195994 . -12) (f195993 . -8) (#f . 16) ((begin) . 12) ((not (primitive-ref for-each)) . 8) (if . 4))
# expr=#f
    movl $47, %eax     # immed #f
    ret                  # immediate tail return
_L_1432416:
    .align 4,0x90
_L_1432413:
     movl %eax, mrc_for$meach
# == explicit-begins  ==>
# (let ((p (make-vector 6)) (sz 1024)) (begin (vector-set! p 0 (quote output-port)) (vector-set! p 1 "/dev/stdout") (vector-set! p 2 1) (vector-set! p 3 (make-string sz)) (vector-set! p 4 0) (vector-set! p 5 sz) p))
# == eliminate-let*  ==>
# (let ((p (make-vector 6)) (sz 1024)) (begin (vector-set! p 0 (quote output-port)) (vector-set! p 1 "/dev/stdout") (vector-set! p 2 1) (vector-set! p 3 (make-string sz)) (vector-set! p 4 0) (vector-set! p 5 sz) p))
# == uniquify-variables  ==>
# (let ((f195996 (make-vector 6)) (f195995 1024)) (begin (vector-set! f195996 0 (quote output-port)) (vector-set! f195996 1 "/dev/stdout") (vector-set! f195996 2 1) (vector-set! f195996 3 (make-string f195995)) (vector-set! f195996 4 0) (vector-set! f195996 5 f195995) f195996))
# == vectorize-letrec  ==>
# (let ((f195996 (make-vector 6)) (f195995 1024)) (begin (vector-set! f195996 0 (quote output-port)) (vector-set! f195996 1 "/dev/stdout") (vector-set! f195996 2 1) (vector-set! f195996 3 (make-string f195995)) (vector-set! f195996 4 0) (vector-set! f195996 5 f195995) f195996))
# == eliminate-set!  ==>
# (let ((f195996 (make-vector 6)) (f195995 1024)) (begin (vector-set! f195996 0 (quote output-port)) (vector-set! f195996 1 "/dev/stdout") (vector-set! f195996 2 1) (vector-set! f195996 3 (make-string f195995)) (vector-set! f195996 4 0) (vector-set! f195996 5 f195995) f195996))
# == close-free-variables  ==>
# (let ((f195996 (make-vector 6)) (f195995 1024)) (begin (vector-set! f195996 0 (quote output-port)) (vector-set! f195996 1 "/dev/stdout") (vector-set! f195996 2 1) (vector-set! f195996 3 (make-string f195995)) (vector-set! f195996 4 0) (vector-set! f195996 5 f195995) f195996))
# == eliminate-quote  ==>
# (let ((f195996 (make-vector 6)) (f195995 1024)) (begin (vector-set! f195996 0 (string->symbol "output-port")) (vector-set! f195996 1 "/dev/stdout") (vector-set! f195996 2 1) (vector-set! f195996 3 (make-string f195995)) (vector-set! f195996 4 0) (vector-set! f195996 5 f195995) f195996))
# == eliminate-when/unless  ==>
# (let ((f195996 (make-vector 6)) (f195995 1024)) (begin (vector-set! f195996 0 (string->symbol "output-port")) (vector-set! f195996 1 "/dev/stdout") (vector-set! f195996 2 1) (vector-set! f195996 3 (make-string f195995)) (vector-set! f195996 4 0) (vector-set! f195996 5 f195995) f195996))
# == eliminate-cond  ==>
# (let ((f195996 (make-vector 6)) (f195995 1024)) (begin (vector-set! f195996 0 (string->symbol "output-port")) (vector-set! f195996 1 "/dev/stdout") (vector-set! f195996 2 1) (vector-set! f195996 3 (make-string f195995)) (vector-set! f195996 4 0) (vector-set! f195996 5 f195995) f195996))
# == external-symbols  ==>
# (let ((f195996 (make-vector 6)) (f195995 1024)) (begin (vector-set! f195996 0 ((primitive-ref string->symbol) "output-port")) (vector-set! f195996 1 "/dev/stdout") (vector-set! f195996 2 1) (vector-set! f195996 3 (make-string f195995)) (vector-set! f195996 4 0) (vector-set! f195996 5 f195995) f195996))
# emit-expr (let ((f195996 (make-vector 6)) (f195995 1024)) (begin (vector-set! f195996 0 ((primitive-ref string->symbol) "output-port")) (vector-set! f195996 1 "/dev/stdout") (vector-set! f195996 2 1) (vector-set! f195996 3 (make-string f195995)) (vector-set! f195996 4 0) (vector-set! f195996 5 f195995) f195996))
# emit-let
#  si   = 0
#  env  = ()
#  bindings = ((f195996 (make-vector 6)) (f195995 1024))
#  body = (begin (vector-set! f195996 0 ((primitive-ref string->symbol) "output-port")) (vector-set! f195996 1 "/dev/stdout") (vector-set! f195996 2 1) (vector-set! f195996 3 (make-string f195995)) (vector-set! f195996 4 0) (vector-set! f195996 5 f195995) f195996)
# emit-expr (make-vector 6)
# make-vector 6
# emit-expr 6
    movl $24, %eax     # immed 6
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1432420"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $128,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1432420:
# check the argument is a fixnum >= 0
    cmp $0,%eax
    jge _L_1432421
# invoke error handler eh_length
    .extern mrc_eh$ulength
    movl mrc_eh$ulength, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $128,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1432421:
    movl %eax, %esi
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    orl  $5, %eax
    addl $4, %esi
    addl $4, %esi
    andl $-8, %esi
    addl %esi, %ebp
    movl %eax, 0(%esp)  # stack save
# emit-expr 1024
    movl $4096, %eax     # immed 1024
    movl %eax, -4(%esp)  # stack save
# emit-expr (begin (vector-set! f195996 0 ((primitive-ref string->symbol) "output-port")) (vector-set! f195996 1 "/dev/stdout") (vector-set! f195996 2 1) (vector-set! f195996 3 (make-string f195995)) (vector-set! f195996 4 0) (vector-set! f195996 5 f195995) f195996)
# emit-begin
#   expr=(begin (vector-set! f195996 0 ((primitive-ref string->symbol) "output-port")) (vector-set! f195996 1 "/dev/stdout") (vector-set! f195996 2 1) (vector-set! f195996 3 (make-string f195995)) (vector-set! f195996 4 0) (vector-set! f195996 5 f195995) f195996)
#   env=((f195995 . -4) (f195996 . 0))
# emit-expr (vector-set! f195996 0 ((primitive-ref string->symbol) "output-port"))
# emit-expr f195996
# emit-variable-ref
# env=((f195995 . -4) (f195996 . 0))
# var=f195996
    movl 0(%esp), %eax  # stack load f195996
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1432422
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1432422:
    movl %eax, -8(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1432423"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1432423:
# check bounds on vector index
    movl -8(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1432425
    cmp  $0,%eax
    jge _L_1432424
_L_1432425:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1432424:
    movl %eax, -12(%esp)
# emit-expr ((primitive-ref string->symbol) "output-port")
# funcall
#    si   =-16
#    env  = ((f195995 . -4) (f195996 . 0))
#    expr = (funcall (primitive-ref string->symbol) "output-port")
# emit-expr (primitive-ref string->symbol)
    .extern mrc_string$m$gsymbol
    movl mrc_string$m$gsymbol,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1432426"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1432426":
   movl %eax,  -24(%esp)  # stash funcall-oper in closure slot
# emit-expr "output-port"
# string literal
    jmp _L_1432428
    .align 8,0x90
_L_1432427 :
    .int 44
    .ascii "output-port"
_L_1432428:
    movl $_L_1432427, %eax
    orl $6, %eax
    mov %eax, -28(%esp)  # arg output-port
    movl -24(%esp), %edi   # load new closure to %edi
    add $-16, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $16, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    movl -8(%esp), %ebx
    movl -12(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin (vector-set! f195996 1 "/dev/stdout") (vector-set! f195996 2 1) (vector-set! f195996 3 (make-string f195995)) (vector-set! f195996 4 0) (vector-set! f195996 5 f195995) f195996)
# emit-begin
#   expr=(begin (vector-set! f195996 1 "/dev/stdout") (vector-set! f195996 2 1) (vector-set! f195996 3 (make-string f195995)) (vector-set! f195996 4 0) (vector-set! f195996 5 f195995) f195996)
#   env=((f195995 . -4) (f195996 . 0))
# emit-expr (vector-set! f195996 1 "/dev/stdout")
# emit-expr f195996
# emit-variable-ref
# env=((f195995 . -4) (f195996 . 0))
# var=f195996
    movl 0(%esp), %eax  # stack load f195996
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1432429
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1432429:
    movl %eax, -8(%esp)
# emit-expr 1
    movl $4, %eax     # immed 1
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1432430"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1432430:
# check bounds on vector index
    movl -8(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1432432
    cmp  $0,%eax
    jge _L_1432431
_L_1432432:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1432431:
    movl %eax, -12(%esp)
# emit-expr "/dev/stdout"
# string literal
    jmp _L_1432434
    .align 8,0x90
_L_1432433 :
    .int 44
    .ascii "/dev/stdout"
_L_1432434:
    movl $_L_1432433, %eax
    orl $6, %eax
    movl -8(%esp), %ebx
    movl -12(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin (vector-set! f195996 2 1) (vector-set! f195996 3 (make-string f195995)) (vector-set! f195996 4 0) (vector-set! f195996 5 f195995) f195996)
# emit-begin
#   expr=(begin (vector-set! f195996 2 1) (vector-set! f195996 3 (make-string f195995)) (vector-set! f195996 4 0) (vector-set! f195996 5 f195995) f195996)
#   env=((f195995 . -4) (f195996 . 0))
# emit-expr (vector-set! f195996 2 1)
# emit-expr f195996
# emit-variable-ref
# env=((f195995 . -4) (f195996 . 0))
# var=f195996
    movl 0(%esp), %eax  # stack load f195996
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1432435
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1432435:
    movl %eax, -8(%esp)
# emit-expr 2
    movl $8, %eax     # immed 2
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1432436"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1432436:
# check bounds on vector index
    movl -8(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1432438
    cmp  $0,%eax
    jge _L_1432437
_L_1432438:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1432437:
    movl %eax, -12(%esp)
# emit-expr 1
    movl $4, %eax     # immed 1
    movl -8(%esp), %ebx
    movl -12(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin (vector-set! f195996 3 (make-string f195995)) (vector-set! f195996 4 0) (vector-set! f195996 5 f195995) f195996)
# emit-begin
#   expr=(begin (vector-set! f195996 3 (make-string f195995)) (vector-set! f195996 4 0) (vector-set! f195996 5 f195995) f195996)
#   env=((f195995 . -4) (f195996 . 0))
# emit-expr (vector-set! f195996 3 (make-string f195995))
# emit-expr f195996
# emit-variable-ref
# env=((f195995 . -4) (f195996 . 0))
# var=f195996
    movl 0(%esp), %eax  # stack load f195996
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1432439
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1432439:
    movl %eax, -8(%esp)
# emit-expr 3
    movl $12, %eax     # immed 3
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1432440"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1432440:
# check bounds on vector index
    movl -8(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1432442
    cmp  $0,%eax
    jge _L_1432441
_L_1432442:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1432441:
    movl %eax, -12(%esp)
# emit-expr (make-string f195995)
# make-string len=f195995
# emit-expr f195995
# emit-variable-ref
# env=((f195995 . -4) (f195996 . 0))
# var=f195995
    movl -4(%esp), %eax  # stack load f195995
# end emit-variable-ref
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1432443"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1432443:
# check the argument is a fixnum >= 0
    cmp $0,%eax
    jge _L_1432444
# invoke error handler eh_length
    .extern mrc_eh$ulength
    movl mrc_eh$ulength, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $144,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1432444:
    movl %eax, %esi
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    orl $6, %eax
    sar $2, %esi
    add $4, %esi
    add $7, %esi
    andl $-8, %esi
    add  %esi, %ebp
# make-string end
    movl -8(%esp), %ebx
    movl -12(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin (vector-set! f195996 4 0) (vector-set! f195996 5 f195995) f195996)
# emit-begin
#   expr=(begin (vector-set! f195996 4 0) (vector-set! f195996 5 f195995) f195996)
#   env=((f195995 . -4) (f195996 . 0))
# emit-expr (vector-set! f195996 4 0)
# emit-expr f195996
# emit-variable-ref
# env=((f195995 . -4) (f195996 . 0))
# var=f195996
    movl 0(%esp), %eax  # stack load f195996
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1432445
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1432445:
    movl %eax, -8(%esp)
# emit-expr 4
    movl $16, %eax     # immed 4
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1432446"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1432446:
# check bounds on vector index
    movl -8(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1432448
    cmp  $0,%eax
    jge _L_1432447
_L_1432448:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1432447:
    movl %eax, -12(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
    movl -8(%esp), %ebx
    movl -12(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin (vector-set! f195996 5 f195995) f195996)
# emit-begin
#   expr=(begin (vector-set! f195996 5 f195995) f195996)
#   env=((f195995 . -4) (f195996 . 0))
# emit-expr (vector-set! f195996 5 f195995)
# emit-expr f195996
# emit-variable-ref
# env=((f195995 . -4) (f195996 . 0))
# var=f195996
    movl 0(%esp), %eax  # stack load f195996
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1432449
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1432449:
    movl %eax, -8(%esp)
# emit-expr 5
    movl $20, %eax     # immed 5
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1432450"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1432450:
# check bounds on vector index
    movl -8(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1432452
    cmp  $0,%eax
    jge _L_1432451
_L_1432452:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1432451:
    movl %eax, -12(%esp)
# emit-expr f195995
# emit-variable-ref
# env=((f195995 . -4) (f195996 . 0))
# var=f195995
    movl -4(%esp), %eax  # stack load f195995
# end emit-variable-ref
    movl -8(%esp), %ebx
    movl -12(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin f195996)
# emit-begin
#   expr=(begin f195996)
#   env=((f195995 . -4) (f195996 . 0))
# emit-expr f195996
# emit-variable-ref
# env=((f195995 . -4) (f195996 . 0))
# var=f195996
    movl 0(%esp), %eax  # stack load f195996
# end emit-variable-ref
# emit-expr (begin)
# emit-begin
#   expr=(begin)
#   env=((f195995 . -4) (f195996 . 0))
     movl %eax, mrc_standard$mout
# == explicit-begins  ==>
# (let ((current-out standard-out)) (lambda () current-out))
# == eliminate-let*  ==>
# (let ((current-out standard-out)) (lambda () current-out))
# == uniquify-variables  ==>
# (let ((f195997 standard-out)) (lambda () f195997))
# == vectorize-letrec  ==>
# (let ((f195997 standard-out)) (lambda () f195997))
# == eliminate-set!  ==>
# (let ((f195997 standard-out)) (lambda () (let () f195997)))
# == close-free-variables  ==>
# (let ((f195997 standard-out)) (closure () (f195997) (let () f195997)))
# == eliminate-quote  ==>
# (let ((f195997 standard-out)) (closure () (f195997) (let () f195997)))
# == eliminate-when/unless  ==>
# (let ((f195997 standard-out)) (closure () (f195997) (let () f195997)))
# == eliminate-cond  ==>
# (let ((f195997 standard-out)) (closure () (f195997) (let () f195997)))
# == external-symbols  ==>
# (let ((f195997 (primitive-ref standard-out))) (closure () (f195997) (let () f195997)))
# emit-expr (let ((f195997 (primitive-ref standard-out))) (closure () (f195997) (let () f195997)))
# emit-let
#  si   = 0
#  env  = ()
#  bindings = ((f195997 (primitive-ref standard-out)))
#  body = (closure () (f195997) (let () f195997))
# emit-expr (primitive-ref standard-out)
    .extern mrc_standard$mout
    movl mrc_standard$mout,%eax
    movl %eax, 0(%esp)  # stack save
# emit-expr (closure () (f195997) (let () f195997))
# emit-closure
# si = -4
# env = ((f195997 . 0))
# expr = (closure () (f195997) (let () f195997))
    movl $_L_1432453, 0(%ebp)  # closure label
# emit-variable-ref
# env=((f195997 . 0))
# var=f195997
    movl 0(%esp), %eax  # stack load f195997
# end emit-variable-ref
   movl  %eax, 4(%ebp)  # f195997
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $8, %ebp     # bump ebp
    jmp _L_1432454            # jump around closure body
_L_1432453:
# check argument count
    cmp $0,%eax
    je _L_1432455
# invoke error handler eh_argcount
    .extern mrc_eh$uargcount
    movl mrc_eh$uargcount, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_1432455:
# emit-tail-expr
# si=-8
# env=((f195997 . 4) (f195997 . 0))
# expr=(let () f195997)
# emit-tail-let
#  si   = -8
#  env  = ((f195997 . 4) (f195997 . 0))
#  bindings = ()
#  body = f195997
# emit-tail-expr
# si=-8
# env=((f195997 . 4) (f195997 . 0))
# expr=f195997
# emit-tail-variable-ref
# emit-variable-ref
# env=((f195997 . 4) (f195997 . 0))
# var=f195997
    movl 2(%edi), %eax  # frame load f195997
# end emit-variable-ref
    ret
# end emit-tail-variable ref
    .align 4,0x90
_L_1432454:
     movl %eax, mrc_current$moutput$mport
# == explicit-begins  ==>
# (lambda (p) (vector-ref p 2))
# == eliminate-let*  ==>
# (lambda (p) (vector-ref p 2))
# == uniquify-variables  ==>
# (lambda (f195998) (vector-ref f195998 2))
# == vectorize-letrec  ==>
# (lambda (f195998) (vector-ref f195998 2))
# == eliminate-set!  ==>
# (lambda (f195998) (let ((f195998 f195998)) (vector-ref f195998 2)))
# == close-free-variables  ==>
# (closure (f195998) () (let ((f195998 f195998)) (vector-ref f195998 2)))
# == eliminate-quote  ==>
# (closure (f195998) () (let ((f195998 f195998)) (vector-ref f195998 2)))
# == eliminate-when/unless  ==>
# (closure (f195998) () (let ((f195998 f195998)) (vector-ref f195998 2)))
# == eliminate-cond  ==>
# (closure (f195998) () (let ((f195998 f195998)) (vector-ref f195998 2)))
# == external-symbols  ==>
# (closure (f195998) () (let ((f195998 f195998)) (vector-ref f195998 2)))
# emit-expr (closure (f195998) () (let ((f195998 f195998)) (vector-ref f195998 2)))
# emit-closure
# si = 0
# env = ()
# expr = (closure (f195998) () (let ((f195998 f195998)) (vector-ref f195998 2)))
    movl $_L_1432456, 0(%ebp)  # closure label
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $8, %ebp     # bump ebp
    jmp _L_1432457            # jump around closure body
_L_1432456:
# check argument count
    cmp $4,%eax
    je _L_1432458
# invoke error handler eh_argcount
    .extern mrc_eh$uargcount
    movl mrc_eh$uargcount, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_1432458:
# emit-tail-expr
# si=-12
# env=((f195998 . -8))
# expr=(let ((f195998 f195998)) (vector-ref f195998 2))
# emit-tail-let
#  si   = -12
#  env  = ((f195998 . -8))
#  bindings = ((f195998 f195998))
#  body = (vector-ref f195998 2)
# emit-expr f195998
# emit-variable-ref
# env=((f195998 . -8))
# var=f195998
    movl -8(%esp), %eax  # stack load f195998
# end emit-variable-ref
    movl %eax, -12(%esp)  # stack save
# emit-tail-expr
# si=-16
# env=((f195998 . -12) (f195998 . -8))
# expr=(vector-ref f195998 2)
# tail primcall
# emit-expr f195998
# emit-variable-ref
# env=((f195998 . -12) (f195998 . -8))
# var=f195998
    movl -12(%esp), %eax  # stack load f195998
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1432459
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1432459:
    movl %eax, -16(%esp)
# emit-expr 2
    movl $8, %eax     # immed 2
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1432460"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1432460:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1432462
    cmp  $0,%eax
    jge _L_1432461
_L_1432462:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1432461:
    movl -16(%esp), %esi
    movl -1(%eax,%esi), %eax
#return from tail (vector-ref f195998 2)
    ret
    .align 4,0x90
_L_1432457:
     movl %eax, mrc_port$mfd
# == explicit-begins  ==>
# (lambda (p) (vector-ref p 3))
# == eliminate-let*  ==>
# (lambda (p) (vector-ref p 3))
# == uniquify-variables  ==>
# (lambda (f195999) (vector-ref f195999 3))
# == vectorize-letrec  ==>
# (lambda (f195999) (vector-ref f195999 3))
# == eliminate-set!  ==>
# (lambda (f195999) (let ((f195999 f195999)) (vector-ref f195999 3)))
# == close-free-variables  ==>
# (closure (f195999) () (let ((f195999 f195999)) (vector-ref f195999 3)))
# == eliminate-quote  ==>
# (closure (f195999) () (let ((f195999 f195999)) (vector-ref f195999 3)))
# == eliminate-when/unless  ==>
# (closure (f195999) () (let ((f195999 f195999)) (vector-ref f195999 3)))
# == eliminate-cond  ==>
# (closure (f195999) () (let ((f195999 f195999)) (vector-ref f195999 3)))
# == external-symbols  ==>
# (closure (f195999) () (let ((f195999 f195999)) (vector-ref f195999 3)))
# emit-expr (closure (f195999) () (let ((f195999 f195999)) (vector-ref f195999 3)))
# emit-closure
# si = 0
# env = ()
# expr = (closure (f195999) () (let ((f195999 f195999)) (vector-ref f195999 3)))
    movl $_L_1432463, 0(%ebp)  # closure label
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $8, %ebp     # bump ebp
    jmp _L_1432464            # jump around closure body
_L_1432463:
# check argument count
    cmp $4,%eax
    je _L_1432465
# invoke error handler eh_argcount
    .extern mrc_eh$uargcount
    movl mrc_eh$uargcount, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_1432465:
# emit-tail-expr
# si=-12
# env=((f195999 . -8))
# expr=(let ((f195999 f195999)) (vector-ref f195999 3))
# emit-tail-let
#  si   = -12
#  env  = ((f195999 . -8))
#  bindings = ((f195999 f195999))
#  body = (vector-ref f195999 3)
# emit-expr f195999
# emit-variable-ref
# env=((f195999 . -8))
# var=f195999
    movl -8(%esp), %eax  # stack load f195999
# end emit-variable-ref
    movl %eax, -12(%esp)  # stack save
# emit-tail-expr
# si=-16
# env=((f195999 . -12) (f195999 . -8))
# expr=(vector-ref f195999 3)
# tail primcall
# emit-expr f195999
# emit-variable-ref
# env=((f195999 . -12) (f195999 . -8))
# var=f195999
    movl -12(%esp), %eax  # stack load f195999
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1432466
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1432466:
    movl %eax, -16(%esp)
# emit-expr 3
    movl $12, %eax     # immed 3
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1432467"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1432467:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1432469
    cmp  $0,%eax
    jge _L_1432468
_L_1432469:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1432468:
    movl -16(%esp), %esi
    movl -1(%eax,%esi), %eax
#return from tail (vector-ref f195999 3)
    ret
    .align 4,0x90
_L_1432464:
     movl %eax, mrc_port$mbuf
# == explicit-begins  ==>
# (lambda (p) (vector-ref p 4))
# == eliminate-let*  ==>
# (lambda (p) (vector-ref p 4))
# == uniquify-variables  ==>
# (lambda (f196000) (vector-ref f196000 4))
# == vectorize-letrec  ==>
# (lambda (f196000) (vector-ref f196000 4))
# == eliminate-set!  ==>
# (lambda (f196000) (let ((f196000 f196000)) (vector-ref f196000 4)))
# == close-free-variables  ==>
# (closure (f196000) () (let ((f196000 f196000)) (vector-ref f196000 4)))
# == eliminate-quote  ==>
# (closure (f196000) () (let ((f196000 f196000)) (vector-ref f196000 4)))
# == eliminate-when/unless  ==>
# (closure (f196000) () (let ((f196000 f196000)) (vector-ref f196000 4)))
# == eliminate-cond  ==>
# (closure (f196000) () (let ((f196000 f196000)) (vector-ref f196000 4)))
# == external-symbols  ==>
# (closure (f196000) () (let ((f196000 f196000)) (vector-ref f196000 4)))
# emit-expr (closure (f196000) () (let ((f196000 f196000)) (vector-ref f196000 4)))
# emit-closure
# si = 0
# env = ()
# expr = (closure (f196000) () (let ((f196000 f196000)) (vector-ref f196000 4)))
    movl $_L_1432470, 0(%ebp)  # closure label
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $8, %ebp     # bump ebp
    jmp _L_1432471            # jump around closure body
_L_1432470:
# check argument count
    cmp $4,%eax
    je _L_1432472
# invoke error handler eh_argcount
    .extern mrc_eh$uargcount
    movl mrc_eh$uargcount, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_1432472:
# emit-tail-expr
# si=-12
# env=((f196000 . -8))
# expr=(let ((f196000 f196000)) (vector-ref f196000 4))
# emit-tail-let
#  si   = -12
#  env  = ((f196000 . -8))
#  bindings = ((f196000 f196000))
#  body = (vector-ref f196000 4)
# emit-expr f196000
# emit-variable-ref
# env=((f196000 . -8))
# var=f196000
    movl -8(%esp), %eax  # stack load f196000
# end emit-variable-ref
    movl %eax, -12(%esp)  # stack save
# emit-tail-expr
# si=-16
# env=((f196000 . -12) (f196000 . -8))
# expr=(vector-ref f196000 4)
# tail primcall
# emit-expr f196000
# emit-variable-ref
# env=((f196000 . -12) (f196000 . -8))
# var=f196000
    movl -12(%esp), %eax  # stack load f196000
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1432473
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1432473:
    movl %eax, -16(%esp)
# emit-expr 4
    movl $16, %eax     # immed 4
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1432474"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1432474:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1432476
    cmp  $0,%eax
    jge _L_1432475
_L_1432476:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1432475:
    movl -16(%esp), %esi
    movl -1(%eax,%esi), %eax
#return from tail (vector-ref f196000 4)
    ret
    .align 4,0x90
_L_1432471:
     movl %eax, mrc_port$mndx
# == explicit-begins  ==>
# (lambda (p) (vector-set! p 4 (fxadd1 (vector-ref p 4))))
# == eliminate-let*  ==>
# (lambda (p) (vector-set! p 4 (fxadd1 (vector-ref p 4))))
# == uniquify-variables  ==>
# (lambda (f196001) (vector-set! f196001 4 (fxadd1 (vector-ref f196001 4))))
# == vectorize-letrec  ==>
# (lambda (f196001) (vector-set! f196001 4 (fxadd1 (vector-ref f196001 4))))
# == eliminate-set!  ==>
# (lambda (f196001) (let ((f196001 f196001)) (vector-set! f196001 4 (fxadd1 (vector-ref f196001 4)))))
# == close-free-variables  ==>
# (closure (f196001) () (let ((f196001 f196001)) (vector-set! f196001 4 (fxadd1 (vector-ref f196001 4)))))
# == eliminate-quote  ==>
# (closure (f196001) () (let ((f196001 f196001)) (vector-set! f196001 4 (fxadd1 (vector-ref f196001 4)))))
# == eliminate-when/unless  ==>
# (closure (f196001) () (let ((f196001 f196001)) (vector-set! f196001 4 (fxadd1 (vector-ref f196001 4)))))
# == eliminate-cond  ==>
# (closure (f196001) () (let ((f196001 f196001)) (vector-set! f196001 4 (fxadd1 (vector-ref f196001 4)))))
# == external-symbols  ==>
# (closure (f196001) () (let ((f196001 f196001)) (vector-set! f196001 4 (fxadd1 (vector-ref f196001 4)))))
# emit-expr (closure (f196001) () (let ((f196001 f196001)) (vector-set! f196001 4 (fxadd1 (vector-ref f196001 4)))))
# emit-closure
# si = 0
# env = ()
# expr = (closure (f196001) () (let ((f196001 f196001)) (vector-set! f196001 4 (fxadd1 (vector-ref f196001 4)))))
    movl $_L_1432477, 0(%ebp)  # closure label
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $8, %ebp     # bump ebp
    jmp _L_1432478            # jump around closure body
_L_1432477:
# check argument count
    cmp $4,%eax
    je _L_1432479
# invoke error handler eh_argcount
    .extern mrc_eh$uargcount
    movl mrc_eh$uargcount, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_1432479:
# emit-tail-expr
# si=-12
# env=((f196001 . -8))
# expr=(let ((f196001 f196001)) (vector-set! f196001 4 (fxadd1 (vector-ref f196001 4))))
# emit-tail-let
#  si   = -12
#  env  = ((f196001 . -8))
#  bindings = ((f196001 f196001))
#  body = (vector-set! f196001 4 (fxadd1 (vector-ref f196001 4)))
# emit-expr f196001
# emit-variable-ref
# env=((f196001 . -8))
# var=f196001
    movl -8(%esp), %eax  # stack load f196001
# end emit-variable-ref
    movl %eax, -12(%esp)  # stack save
# emit-tail-expr
# si=-16
# env=((f196001 . -12) (f196001 . -8))
# expr=(vector-set! f196001 4 (fxadd1 (vector-ref f196001 4)))
# tail primcall
# emit-expr f196001
# emit-variable-ref
# env=((f196001 . -12) (f196001 . -8))
# var=f196001
    movl -12(%esp), %eax  # stack load f196001
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1432480
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1432480:
    movl %eax, -16(%esp)
# emit-expr 4
    movl $16, %eax     # immed 4
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1432481"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1432481:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1432483
    cmp  $0,%eax
    jge _L_1432482
_L_1432483:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1432482:
    movl %eax, -20(%esp)
# emit-expr (fxadd1 (vector-ref f196001 4))
# emit-expr (vector-ref f196001 4)
# emit-expr f196001
# emit-variable-ref
# env=((f196001 . -12) (f196001 . -8))
# var=f196001
    movl -12(%esp), %eax  # stack load f196001
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1432484
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1432484:
    movl %eax, -24(%esp)
# emit-expr 4
    movl $16, %eax     # immed 4
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1432485"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1432485:
# check bounds on vector index
    movl -24(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1432487
    cmp  $0,%eax
    jge _L_1432486
_L_1432487:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1432486:
    movl -24(%esp), %esi
    movl -1(%eax,%esi), %eax
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1432488"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $48,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1432488:
     addl $4, %eax
    movl -16(%esp), %ebx
    movl -20(%esp), %esi
    movl %eax, -1(%ebx,%esi)
#return from tail (vector-set! f196001 4 (fxadd1 (vector-ref f196001 4)))
    ret
    .align 4,0x90
_L_1432478:
     movl %eax, mrc_port$mndx$madd1
# == explicit-begins  ==>
# (lambda (p) (vector-set! p 4 0))
# == eliminate-let*  ==>
# (lambda (p) (vector-set! p 4 0))
# == uniquify-variables  ==>
# (lambda (f196002) (vector-set! f196002 4 0))
# == vectorize-letrec  ==>
# (lambda (f196002) (vector-set! f196002 4 0))
# == eliminate-set!  ==>
# (lambda (f196002) (let ((f196002 f196002)) (vector-set! f196002 4 0)))
# == close-free-variables  ==>
# (closure (f196002) () (let ((f196002 f196002)) (vector-set! f196002 4 0)))
# == eliminate-quote  ==>
# (closure (f196002) () (let ((f196002 f196002)) (vector-set! f196002 4 0)))
# == eliminate-when/unless  ==>
# (closure (f196002) () (let ((f196002 f196002)) (vector-set! f196002 4 0)))
# == eliminate-cond  ==>
# (closure (f196002) () (let ((f196002 f196002)) (vector-set! f196002 4 0)))
# == external-symbols  ==>
# (closure (f196002) () (let ((f196002 f196002)) (vector-set! f196002 4 0)))
# emit-expr (closure (f196002) () (let ((f196002 f196002)) (vector-set! f196002 4 0)))
# emit-closure
# si = 0
# env = ()
# expr = (closure (f196002) () (let ((f196002 f196002)) (vector-set! f196002 4 0)))
    movl $_L_1432489, 0(%ebp)  # closure label
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $8, %ebp     # bump ebp
    jmp _L_1432490            # jump around closure body
_L_1432489:
# check argument count
    cmp $4,%eax
    je _L_1432491
# invoke error handler eh_argcount
    .extern mrc_eh$uargcount
    movl mrc_eh$uargcount, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_1432491:
# emit-tail-expr
# si=-12
# env=((f196002 . -8))
# expr=(let ((f196002 f196002)) (vector-set! f196002 4 0))
# emit-tail-let
#  si   = -12
#  env  = ((f196002 . -8))
#  bindings = ((f196002 f196002))
#  body = (vector-set! f196002 4 0)
# emit-expr f196002
# emit-variable-ref
# env=((f196002 . -8))
# var=f196002
    movl -8(%esp), %eax  # stack load f196002
# end emit-variable-ref
    movl %eax, -12(%esp)  # stack save
# emit-tail-expr
# si=-16
# env=((f196002 . -12) (f196002 . -8))
# expr=(vector-set! f196002 4 0)
# tail primcall
# emit-expr f196002
# emit-variable-ref
# env=((f196002 . -12) (f196002 . -8))
# var=f196002
    movl -12(%esp), %eax  # stack load f196002
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1432492
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1432492:
    movl %eax, -16(%esp)
# emit-expr 4
    movl $16, %eax     # immed 4
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1432493"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1432493:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1432495
    cmp  $0,%eax
    jge _L_1432494
_L_1432495:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1432494:
    movl %eax, -20(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
    movl -16(%esp), %ebx
    movl -20(%esp), %esi
    movl %eax, -1(%ebx,%esi)
#return from tail (vector-set! f196002 4 0)
    ret
    .align 4,0x90
_L_1432490:
     movl %eax, mrc_port$mndx$mreset
# == explicit-begins  ==>
# (lambda (p) (vector-ref p 5))
# == eliminate-let*  ==>
# (lambda (p) (vector-ref p 5))
# == uniquify-variables  ==>
# (lambda (f196003) (vector-ref f196003 5))
# == vectorize-letrec  ==>
# (lambda (f196003) (vector-ref f196003 5))
# == eliminate-set!  ==>
# (lambda (f196003) (let ((f196003 f196003)) (vector-ref f196003 5)))
# == close-free-variables  ==>
# (closure (f196003) () (let ((f196003 f196003)) (vector-ref f196003 5)))
# == eliminate-quote  ==>
# (closure (f196003) () (let ((f196003 f196003)) (vector-ref f196003 5)))
# == eliminate-when/unless  ==>
# (closure (f196003) () (let ((f196003 f196003)) (vector-ref f196003 5)))
# == eliminate-cond  ==>
# (closure (f196003) () (let ((f196003 f196003)) (vector-ref f196003 5)))
# == external-symbols  ==>
# (closure (f196003) () (let ((f196003 f196003)) (vector-ref f196003 5)))
# emit-expr (closure (f196003) () (let ((f196003 f196003)) (vector-ref f196003 5)))
# emit-closure
# si = 0
# env = ()
# expr = (closure (f196003) () (let ((f196003 f196003)) (vector-ref f196003 5)))
    movl $_L_1432496, 0(%ebp)  # closure label
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $8, %ebp     # bump ebp
    jmp _L_1432497            # jump around closure body
_L_1432496:
# check argument count
    cmp $4,%eax
    je _L_1432498
# invoke error handler eh_argcount
    .extern mrc_eh$uargcount
    movl mrc_eh$uargcount, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_1432498:
# emit-tail-expr
# si=-12
# env=((f196003 . -8))
# expr=(let ((f196003 f196003)) (vector-ref f196003 5))
# emit-tail-let
#  si   = -12
#  env  = ((f196003 . -8))
#  bindings = ((f196003 f196003))
#  body = (vector-ref f196003 5)
# emit-expr f196003
# emit-variable-ref
# env=((f196003 . -8))
# var=f196003
    movl -8(%esp), %eax  # stack load f196003
# end emit-variable-ref
    movl %eax, -12(%esp)  # stack save
# emit-tail-expr
# si=-16
# env=((f196003 . -12) (f196003 . -8))
# expr=(vector-ref f196003 5)
# tail primcall
# emit-expr f196003
# emit-variable-ref
# env=((f196003 . -12) (f196003 . -8))
# var=f196003
    movl -12(%esp), %eax  # stack load f196003
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1432499
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1432499:
    movl %eax, -16(%esp)
# emit-expr 5
    movl $20, %eax     # immed 5
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1432500"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1432500:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1432502
    cmp  $0,%eax
    jge _L_1432501
_L_1432502:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1432501:
    movl -16(%esp), %esi
    movl -1(%eax,%esi), %eax
#return from tail (vector-ref f196003 5)
    ret
    .align 4,0x90
_L_1432497:
     movl %eax, mrc_port$msize
# == explicit-begins  ==>
# (lambda (ch) (let ((p (current-output-port))) (begin (when (fx= (port-ndx p) (port-size p)) (flush-output-port p)) (string-set! (port-buf p) (port-ndx p) ch) (port-ndx-add1 p))))
# == eliminate-let*  ==>
# (lambda (ch) (let ((p (current-output-port))) (begin (when (fx= (port-ndx p) (port-size p)) (flush-output-port p)) (string-set! (port-buf p) (port-ndx p) ch) (port-ndx-add1 p))))
# == uniquify-variables  ==>
# (lambda (f196004) (let ((f196006 (current-output-port))) (begin (when (fx= (port-ndx f196006) (port-size f196006)) (flush-output-port f196006)) (string-set! (port-buf f196006) (port-ndx f196006) f196004) (port-ndx-add1 f196006))))
# == vectorize-letrec  ==>
# (lambda (f196004) (let ((f196006 (current-output-port))) (begin (when (fx= (port-ndx f196006) (port-size f196006)) (flush-output-port f196006)) (string-set! (port-buf f196006) (port-ndx f196006) f196004) (port-ndx-add1 f196006))))
# == eliminate-set!  ==>
# (lambda (f196004) (let ((f196004 f196004)) (let ((f196006 (current-output-port))) (begin (when (fx= (port-ndx f196006) (port-size f196006)) (flush-output-port f196006)) (string-set! (port-buf f196006) (port-ndx f196006) f196004) (port-ndx-add1 f196006)))))
# == close-free-variables  ==>
# (closure (f196004) (when port-ndx port-size flush-output-port port-buf port-ndx port-ndx-add1) (let ((f196004 f196004)) (let ((f196006 (current-output-port))) (begin (when (fx= (port-ndx f196006) (port-size f196006)) (flush-output-port f196006)) (string-set! (port-buf f196006) (port-ndx f196006) f196004) (port-ndx-add1 f196006)))))
# == eliminate-quote  ==>
# (closure (f196004) (when port-ndx port-size flush-output-port port-buf port-ndx port-ndx-add1) (let ((f196004 f196004)) (let ((f196006 (current-output-port))) (begin (when (fx= (port-ndx f196006) (port-size f196006)) (flush-output-port f196006)) (string-set! (port-buf f196006) (port-ndx f196006) f196004) (port-ndx-add1 f196006)))))
# == eliminate-when/unless  ==>
# (closure (f196004) (if port-ndx (begin port-size flush-output-port port-buf port-ndx port-ndx-add1) #f) (let ((f196004 f196004)) (let ((f196006 (current-output-port))) (begin (if (fx= (port-ndx f196006) (port-size f196006)) (begin (flush-output-port f196006)) #f) (string-set! (port-buf f196006) (port-ndx f196006) f196004) (port-ndx-add1 f196006)))))
# == eliminate-cond  ==>
# (closure (f196004) (if port-ndx (begin port-size flush-output-port port-buf port-ndx port-ndx-add1) #f) (let ((f196004 f196004)) (let ((f196006 (current-output-port))) (begin (if (fx= (port-ndx f196006) (port-size f196006)) (begin (flush-output-port f196006)) #f) (string-set! (port-buf f196006) (port-ndx f196006) f196004) (port-ndx-add1 f196006)))))
# == external-symbols  ==>
# (closure (f196004) (if (primitive-ref port-ndx) (begin (primitive-ref port-size) (primitive-ref flush-output-port) (primitive-ref port-buf) (primitive-ref port-ndx) (primitive-ref port-ndx-add1)) #f) (let ((f196004 f196004)) (let ((f196006 ((primitive-ref current-output-port)))) (begin (if (fx= ((primitive-ref port-ndx) f196006) ((primitive-ref port-size) f196006)) (begin ((primitive-ref flush-output-port) f196006)) #f) (string-set! ((primitive-ref port-buf) f196006) ((primitive-ref port-ndx) f196006) f196004) ((primitive-ref port-ndx-add1) f196006)))))
# emit-expr (closure (f196004) (if (primitive-ref port-ndx) (begin (primitive-ref port-size) (primitive-ref flush-output-port) (primitive-ref port-buf) (primitive-ref port-ndx) (primitive-ref port-ndx-add1)) #f) (let ((f196004 f196004)) (let ((f196006 ((primitive-ref current-output-port)))) (begin (if (fx= ((primitive-ref port-ndx) f196006) ((primitive-ref port-size) f196006)) (begin ((primitive-ref flush-output-port) f196006)) #f) (string-set! ((primitive-ref port-buf) f196006) ((primitive-ref port-ndx) f196006) f196004) ((primitive-ref port-ndx-add1) f196006)))))
# emit-closure
# si = 0
# env = ()
# expr = (closure (f196004) (if (primitive-ref port-ndx) (begin (primitive-ref port-size) (primitive-ref flush-output-port) (primitive-ref port-buf) (primitive-ref port-ndx) (primitive-ref port-ndx-add1)) #f) (let ((f196004 f196004)) (let ((f196006 ((primitive-ref current-output-port)))) (begin (if (fx= ((primitive-ref port-ndx) f196006) ((primitive-ref port-size) f196006)) (begin ((primitive-ref flush-output-port) f196006)) #f) (string-set! ((primitive-ref port-buf) f196006) ((primitive-ref port-ndx) f196006) f196004) ((primitive-ref port-ndx-add1) f196006)))))
    movl $_L_1432503, 0(%ebp)  # closure label
# WARNING: free var if not defined in the environmnet
# WARNING: free var (primitive-ref port-ndx) not defined in the environmnet
# WARNING: free var (begin (primitive-ref port-size) (primitive-ref flush-output-port) (primitive-ref port-buf) (primitive-ref port-ndx) (primitive-ref port-ndx-add1)) not defined in the environmnet
# WARNING: free var #f not defined in the environmnet
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $24, %ebp     # bump ebp
    jmp _L_1432504            # jump around closure body
_L_1432503:
# check argument count
    cmp $4,%eax
    je _L_1432505
# invoke error handler eh_argcount
    .extern mrc_eh$uargcount
    movl mrc_eh$uargcount, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_1432505:
# emit-tail-expr
# si=-12
# env=((f196004 . -8) (#f . 16) ((begin (primitive-ref port-size) (primitive-ref flush-output-port) (primitive-ref port-buf) (primitive-ref port-ndx) (primitive-ref port-ndx-add1)) . 12) ((primitive-ref port-ndx) . 8) (if . 4))
# expr=(let ((f196004 f196004)) (let ((f196006 ((primitive-ref current-output-port)))) (begin (if (fx= ((primitive-ref port-ndx) f196006) ((primitive-ref port-size) f196006)) (begin ((primitive-ref flush-output-port) f196006)) #f) (string-set! ((primitive-ref port-buf) f196006) ((primitive-ref port-ndx) f196006) f196004) ((primitive-ref port-ndx-add1) f196006))))
# emit-tail-let
#  si   = -12
#  env  = ((f196004 . -8) (#f . 16) ((begin (primitive-ref port-size) (primitive-ref flush-output-port) (primitive-ref port-buf) (primitive-ref port-ndx) (primitive-ref port-ndx-add1)) . 12) ((primitive-ref port-ndx) . 8) (if . 4))
#  bindings = ((f196004 f196004))
#  body = (let ((f196006 ((primitive-ref current-output-port)))) (begin (if (fx= ((primitive-ref port-ndx) f196006) ((primitive-ref port-size) f196006)) (begin ((primitive-ref flush-output-port) f196006)) #f) (string-set! ((primitive-ref port-buf) f196006) ((primitive-ref port-ndx) f196006) f196004) ((primitive-ref port-ndx-add1) f196006)))
# emit-expr f196004
# emit-variable-ref
# env=((f196004 . -8) (#f . 16) ((begin (primitive-ref port-size) (primitive-ref flush-output-port) (primitive-ref port-buf) (primitive-ref port-ndx) (primitive-ref port-ndx-add1)) . 12) ((primitive-ref port-ndx) . 8) (if . 4))
# var=f196004
    movl -8(%esp), %eax  # stack load f196004
# end emit-variable-ref
    movl %eax, -12(%esp)  # stack save
# emit-tail-expr
# si=-16
# env=((f196004 . -12) (f196004 . -8) (#f . 16) ((begin (primitive-ref port-size) (primitive-ref flush-output-port) (primitive-ref port-buf) (primitive-ref port-ndx) (primitive-ref port-ndx-add1)) . 12) ((primitive-ref port-ndx) . 8) (if . 4))
# expr=(let ((f196006 ((primitive-ref current-output-port)))) (begin (if (fx= ((primitive-ref port-ndx) f196006) ((primitive-ref port-size) f196006)) (begin ((primitive-ref flush-output-port) f196006)) #f) (string-set! ((primitive-ref port-buf) f196006) ((primitive-ref port-ndx) f196006) f196004) ((primitive-ref port-ndx-add1) f196006)))
# emit-tail-let
#  si   = -16
#  env  = ((f196004 . -12) (f196004 . -8) (#f . 16) ((begin (primitive-ref port-size) (primitive-ref flush-output-port) (primitive-ref port-buf) (primitive-ref port-ndx) (primitive-ref port-ndx-add1)) . 12) ((primitive-ref port-ndx) . 8) (if . 4))
#  bindings = ((f196006 ((primitive-ref current-output-port))))
#  body = (begin (if (fx= ((primitive-ref port-ndx) f196006) ((primitive-ref port-size) f196006)) (begin ((primitive-ref flush-output-port) f196006)) #f) (string-set! ((primitive-ref port-buf) f196006) ((primitive-ref port-ndx) f196006) f196004) ((primitive-ref port-ndx-add1) f196006))
# emit-expr ((primitive-ref current-output-port))
# funcall
#    si   =-16
#    env  = ((f196004 . -12) (f196004 . -8) (#f . 16) ((begin (primitive-ref port-size) (primitive-ref flush-output-port) (primitive-ref port-buf) (primitive-ref port-ndx) (primitive-ref port-ndx-add1)) . 12) ((primitive-ref port-ndx) . 8) (if . 4))
#    expr = (funcall (primitive-ref current-output-port))
# emit-expr (primitive-ref current-output-port)
    .extern mrc_current$moutput$mport
    movl mrc_current$moutput$mport,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1432506"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1432506":
   movl %eax,  -24(%esp)  # stash funcall-oper in closure slot
    movl -24(%esp), %edi   # load new closure to %edi
    add $-16, %esp   # adjust base
    movl $0,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $16, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    movl %eax, -16(%esp)  # stack save
# emit-tail-expr
# si=-20
# env=((f196006 . -16) (f196004 . -12) (f196004 . -8) (#f . 16) ((begin (primitive-ref port-size) (primitive-ref flush-output-port) (primitive-ref port-buf) (primitive-ref port-ndx) (primitive-ref port-ndx-add1)) . 12) ((primitive-ref port-ndx) . 8) (if . 4))
# expr=(begin (if (fx= ((primitive-ref port-ndx) f196006) ((primitive-ref port-size) f196006)) (begin ((primitive-ref flush-output-port) f196006)) #f) (string-set! ((primitive-ref port-buf) f196006) ((primitive-ref port-ndx) f196006) f196004) ((primitive-ref port-ndx-add1) f196006))
# tail-begin (begin (if (fx= ((primitive-ref port-ndx) f196006) ((primitive-ref port-size) f196006)) (begin ((primitive-ref flush-output-port) f196006)) #f) (string-set! ((primitive-ref port-buf) f196006) ((primitive-ref port-ndx) f196006) f196004) ((primitive-ref port-ndx-add1) f196006))
#   env=((f196006 . -16) (f196004 . -12) (f196004 . -8) (#f . 16) ((begin (primitive-ref port-size) (primitive-ref flush-output-port) (primitive-ref port-buf) (primitive-ref port-ndx) (primitive-ref port-ndx-add1)) . 12) ((primitive-ref port-ndx) . 8) (if . 4))
# emit-expr (if (fx= ((primitive-ref port-ndx) f196006) ((primitive-ref port-size) f196006)) (begin ((primitive-ref flush-output-port) f196006)) #f)
# emit-expr (fx= ((primitive-ref port-ndx) f196006) ((primitive-ref port-size) f196006))
# emit-expr ((primitive-ref port-size) f196006)
# funcall
#    si   =-20
#    env  = ((f196006 . -16) (f196004 . -12) (f196004 . -8) (#f . 16) ((begin (primitive-ref port-size) (primitive-ref flush-output-port) (primitive-ref port-buf) (primitive-ref port-ndx) (primitive-ref port-ndx-add1)) . 12) ((primitive-ref port-ndx) . 8) (if . 4))
#    expr = (funcall (primitive-ref port-size) f196006)
# emit-expr (primitive-ref port-size)
    .extern mrc_port$msize
    movl mrc_port$msize,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1432509"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1432509":
   movl %eax,  -28(%esp)  # stash funcall-oper in closure slot
# emit-expr f196006
# emit-variable-ref
# env=((f196006 . -16) (f196004 . -12) (f196004 . -8) (#f . 16) ((begin (primitive-ref port-size) (primitive-ref flush-output-port) (primitive-ref port-buf) (primitive-ref port-ndx) (primitive-ref port-ndx-add1)) . 12) ((primitive-ref port-ndx) . 8) (if . 4))
# var=f196006
    movl -16(%esp), %eax  # stack load f196006
# end emit-variable-ref
    mov %eax, -32(%esp)  # arg f196006
    movl -28(%esp), %edi   # load new closure to %edi
    add $-20, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $20, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1432510"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $60,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1432510:
    movl %eax, -20(%esp)
# emit-expr ((primitive-ref port-ndx) f196006)
# funcall
#    si   =-24
#    env  = ((f196006 . -16) (f196004 . -12) (f196004 . -8) (#f . 16) ((begin (primitive-ref port-size) (primitive-ref flush-output-port) (primitive-ref port-buf) (primitive-ref port-ndx) (primitive-ref port-ndx-add1)) . 12) ((primitive-ref port-ndx) . 8) (if . 4))
#    expr = (funcall (primitive-ref port-ndx) f196006)
# emit-expr (primitive-ref port-ndx)
    .extern mrc_port$mndx
    movl mrc_port$mndx,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1432511"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1432511":
   movl %eax,  -32(%esp)  # stash funcall-oper in closure slot
# emit-expr f196006
# emit-variable-ref
# env=((f196006 . -16) (f196004 . -12) (f196004 . -8) (#f . 16) ((begin (primitive-ref port-size) (primitive-ref flush-output-port) (primitive-ref port-buf) (primitive-ref port-ndx) (primitive-ref port-ndx-add1)) . 12) ((primitive-ref port-ndx) . 8) (if . 4))
# var=f196006
    movl -16(%esp), %eax  # stack load f196006
# end emit-variable-ref
    mov %eax, -36(%esp)  # arg f196006
    movl -32(%esp), %edi   # load new closure to %edi
    add $-24, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $24, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1432512"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $60,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1432512:
    cmp -20(%esp), %eax
    sete %al
    movzbl %al, %eax
    sal $6, %al
    or $47, %al
    cmp $47, %al
    je _L_1432507
# emit-expr (begin ((primitive-ref flush-output-port) f196006))
# emit-begin
#   expr=(begin ((primitive-ref flush-output-port) f196006))
#   env=((f196006 . -16) (f196004 . -12) (f196004 . -8) (#f . 16) ((begin (primitive-ref port-size) (primitive-ref flush-output-port) (primitive-ref port-buf) (primitive-ref port-ndx) (primitive-ref port-ndx-add1)) . 12) ((primitive-ref port-ndx) . 8) (if . 4))
# emit-expr ((primitive-ref flush-output-port) f196006)
# funcall
#    si   =-20
#    env  = ((f196006 . -16) (f196004 . -12) (f196004 . -8) (#f . 16) ((begin (primitive-ref port-size) (primitive-ref flush-output-port) (primitive-ref port-buf) (primitive-ref port-ndx) (primitive-ref port-ndx-add1)) . 12) ((primitive-ref port-ndx) . 8) (if . 4))
#    expr = (funcall (primitive-ref flush-output-port) f196006)
# emit-expr (primitive-ref flush-output-port)
    .extern mrc_flush$moutput$mport
    movl mrc_flush$moutput$mport,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1432513"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1432513":
   movl %eax,  -28(%esp)  # stash funcall-oper in closure slot
# emit-expr f196006
# emit-variable-ref
# env=((f196006 . -16) (f196004 . -12) (f196004 . -8) (#f . 16) ((begin (primitive-ref port-size) (primitive-ref flush-output-port) (primitive-ref port-buf) (primitive-ref port-ndx) (primitive-ref port-ndx-add1)) . 12) ((primitive-ref port-ndx) . 8) (if . 4))
# var=f196006
    movl -16(%esp), %eax  # stack load f196006
# end emit-variable-ref
    mov %eax, -32(%esp)  # arg f196006
    movl -28(%esp), %edi   # load new closure to %edi
    add $-20, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $20, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
# emit-expr (begin)
# emit-begin
#   expr=(begin)
#   env=((f196006 . -16) (f196004 . -12) (f196004 . -8) (#f . 16) ((begin (primitive-ref port-size) (primitive-ref flush-output-port) (primitive-ref port-buf) (primitive-ref port-ndx) (primitive-ref port-ndx-add1)) . 12) ((primitive-ref port-ndx) . 8) (if . 4))
    jmp _L_1432508
_L_1432507:
# emit-expr #f
    movl $47, %eax     # immed #f
_L_1432508:
# emit-tail-expr
# si=-20
# env=((f196006 . -16) (f196004 . -12) (f196004 . -8) (#f . 16) ((begin (primitive-ref port-size) (primitive-ref flush-output-port) (primitive-ref port-buf) (primitive-ref port-ndx) (primitive-ref port-ndx-add1)) . 12) ((primitive-ref port-ndx) . 8) (if . 4))
# expr=(begin (string-set! ((primitive-ref port-buf) f196006) ((primitive-ref port-ndx) f196006) f196004) ((primitive-ref port-ndx-add1) f196006))
# tail-begin (begin (string-set! ((primitive-ref port-buf) f196006) ((primitive-ref port-ndx) f196006) f196004) ((primitive-ref port-ndx-add1) f196006))
#   env=((f196006 . -16) (f196004 . -12) (f196004 . -8) (#f . 16) ((begin (primitive-ref port-size) (primitive-ref flush-output-port) (primitive-ref port-buf) (primitive-ref port-ndx) (primitive-ref port-ndx-add1)) . 12) ((primitive-ref port-ndx) . 8) (if . 4))
# emit-expr (string-set! ((primitive-ref port-buf) f196006) ((primitive-ref port-ndx) f196006) f196004)
# emit-expr ((primitive-ref port-buf) f196006)
# funcall
#    si   =-20
#    env  = ((f196006 . -16) (f196004 . -12) (f196004 . -8) (#f . 16) ((begin (primitive-ref port-size) (primitive-ref flush-output-port) (primitive-ref port-buf) (primitive-ref port-ndx) (primitive-ref port-ndx-add1)) . 12) ((primitive-ref port-ndx) . 8) (if . 4))
#    expr = (funcall (primitive-ref port-buf) f196006)
# emit-expr (primitive-ref port-buf)
    .extern mrc_port$mbuf
    movl mrc_port$mbuf,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1432514"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1432514":
   movl %eax,  -28(%esp)  # stash funcall-oper in closure slot
# emit-expr f196006
# emit-variable-ref
# env=((f196006 . -16) (f196004 . -12) (f196004 . -8) (#f . 16) ((begin (primitive-ref port-size) (primitive-ref flush-output-port) (primitive-ref port-buf) (primitive-ref port-ndx) (primitive-ref port-ndx-add1)) . 12) ((primitive-ref port-ndx) . 8) (if . 4))
# var=f196006
    movl -16(%esp), %eax  # stack load f196006
# end emit-variable-ref
    mov %eax, -32(%esp)  # arg f196006
    movl -28(%esp), %edi   # load new closure to %edi
    add $-20, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $20, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
# check the argument is a string
    movl %eax,%ebx
    and $7, %bl
    cmp $6, %bl
    je _L_1432515
# invoke error handler eh_string
    .extern mrc_eh$ustring
    movl mrc_eh$ustring, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $160,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1432515:
    movl %eax, -20(%esp)
# emit-expr ((primitive-ref port-ndx) f196006)
# funcall
#    si   =-20
#    env  = ((f196006 . -16) (f196004 . -12) (f196004 . -8) (#f . 16) ((begin (primitive-ref port-size) (primitive-ref flush-output-port) (primitive-ref port-buf) (primitive-ref port-ndx) (primitive-ref port-ndx-add1)) . 12) ((primitive-ref port-ndx) . 8) (if . 4))
#    expr = (funcall (primitive-ref port-ndx) f196006)
# emit-expr (primitive-ref port-ndx)
    .extern mrc_port$mndx
    movl mrc_port$mndx,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1432516"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1432516":
   movl %eax,  -28(%esp)  # stash funcall-oper in closure slot
# emit-expr f196006
# emit-variable-ref
# env=((f196006 . -16) (f196004 . -12) (f196004 . -8) (#f . 16) ((begin (primitive-ref port-size) (primitive-ref flush-output-port) (primitive-ref port-buf) (primitive-ref port-ndx) (primitive-ref port-ndx-add1)) . 12) ((primitive-ref port-ndx) . 8) (if . 4))
# var=f196006
    movl -16(%esp), %eax  # stack load f196006
# end emit-variable-ref
    mov %eax, -32(%esp)  # arg f196006
    movl -28(%esp), %edi   # load new closure to %edi
    add $-20, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $20, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1432517"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $160,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1432517:
# check bounds on string index
    movl -20(%esp), %ebx
    cmp  %eax,-6(%ebx) 
    jle _L_1432519
    cmp  $0,%eax
    jge _L_1432518
_L_1432519:
# invoke error handler eh_string_index
    .extern mrc_eh$ustring$uindex
    movl mrc_eh$ustring$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $160,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1432518:
    movl %eax, -24(%esp)
# emit-expr f196004
# emit-variable-ref
# env=((f196006 . -16) (f196004 . -12) (f196004 . -8) (#f . 16) ((begin (primitive-ref port-size) (primitive-ref flush-output-port) (primitive-ref port-buf) (primitive-ref port-ndx) (primitive-ref port-ndx-add1)) . 12) ((primitive-ref port-ndx) . 8) (if . 4))
# var=f196004
    movl -12(%esp), %eax  # stack load f196004
# end emit-variable-ref
# check the argument is a char
    movl %eax,%ebx
    and $255, %bl
    cmp $15, %bl
    je "_L_1432520"
# invoke error handler eh_character
    .extern mrc_eh$ucharacter
    movl mrc_eh$ucharacter, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $160,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1432520:
    movl -20(%esp), %ebx
    movl -24(%esp), %esi
    sar $2, %esi
    movb  %ah, -2(%ebx,%esi)
# emit-tail-expr
# si=-20
# env=((f196006 . -16) (f196004 . -12) (f196004 . -8) (#f . 16) ((begin (primitive-ref port-size) (primitive-ref flush-output-port) (primitive-ref port-buf) (primitive-ref port-ndx) (primitive-ref port-ndx-add1)) . 12) ((primitive-ref port-ndx) . 8) (if . 4))
# expr=(begin ((primitive-ref port-ndx-add1) f196006))
# tail-begin (begin ((primitive-ref port-ndx-add1) f196006))
#   env=((f196006 . -16) (f196004 . -12) (f196004 . -8) (#f . 16) ((begin (primitive-ref port-size) (primitive-ref flush-output-port) (primitive-ref port-buf) (primitive-ref port-ndx) (primitive-ref port-ndx-add1)) . 12) ((primitive-ref port-ndx) . 8) (if . 4))
# emit-tail-expr
# si=-20
# env=((f196006 . -16) (f196004 . -12) (f196004 . -8) (#f . 16) ((begin (primitive-ref port-size) (primitive-ref flush-output-port) (primitive-ref port-buf) (primitive-ref port-ndx) (primitive-ref port-ndx-add1)) . 12) ((primitive-ref port-ndx) . 8) (if . 4))
# expr=((primitive-ref port-ndx-add1) f196006)
# emit-tail-funcall
#    si   =-20
#    env  = ((f196006 . -16) (f196004 . -12) (f196004 . -8) (#f . 16) ((begin (primitive-ref port-size) (primitive-ref flush-output-port) (primitive-ref port-buf) (primitive-ref port-ndx) (primitive-ref port-ndx-add1)) . 12) ((primitive-ref port-ndx) . 8) (if . 4))
#    expr = (funcall (primitive-ref port-ndx-add1) f196006)
# emit-expr (primitive-ref port-ndx-add1)
    .extern mrc_port$mndx$madd1
    movl mrc_port$mndx$madd1,%eax
   movl %eax,  -20(%esp)  # stash funcall-oper in next closure slot
# emit-expr f196006
# emit-variable-ref
# env=((f196006 . -16) (f196004 . -12) (f196004 . -8) (#f . 16) ((begin (primitive-ref port-size) (primitive-ref flush-output-port) (primitive-ref port-buf) (primitive-ref port-ndx) (primitive-ref port-ndx-add1)) . 12) ((primitive-ref port-ndx) . 8) (if . 4))
# var=f196006
    movl -16(%esp), %eax  # stack load f196006
# end emit-variable-ref
    mov %eax, -24(%esp)    # arg f196006
    movl -20(%esp), %edi   # load new closure to %edi
# emit-shift-args:  size=2   si=-20  delta=16
    mov -20(%esp), %ebx  # shift frame cell
    mov %ebx, -4(%esp)  # down to base
# emit-shift-args:  size=1   si=-24  delta=16
    mov -24(%esp), %ebx  # shift frame cell
    mov %ebx, -8(%esp)  # down to base
# emit-shift-args:  size=0   si=-28  delta=16
    movl $4,%eax   # save arg count
    jmp *-2(%edi)  # tail-funcall
     ret   # return thru stack
    .align 4,0x90
_L_1432504:
     movl %eax, mrc_write$mchar
# == explicit-begins  ==>
# (lambda args (let ((p (if (null? args) (current-output-port) (car args)))) (begin (foreign-call "s_write" (port-fd p) (port-buf p) (port-ndx p)) (port-ndx-reset p))))
# == eliminate-let*  ==>
# (lambda args (let ((p (if (null? args) (current-output-port) (car args)))) (begin (foreign-call "s_write" (port-fd p) (port-buf p) (port-ndx p)) (port-ndx-reset p))))
# == uniquify-variables  ==>
# (lambda f196007 (let ((f196009 (if (null? f196007) (current-output-port) (car f196007)))) (begin (foreign-call "s_write" (port-fd f196009) (port-buf f196009) (port-ndx f196009)) (port-ndx-reset f196009))))
# == vectorize-letrec  ==>
# (lambda f196007 (let ((f196009 (if (null? f196007) (current-output-port) (car f196007)))) (begin (foreign-call "s_write" (port-fd f196009) (port-buf f196009) (port-ndx f196009)) (port-ndx-reset f196009))))
# == eliminate-set!  ==>
# (lambda f196007 (let () (let ((f196009 (if (null? f196007) (current-output-port) (car f196007)))) (begin (foreign-call "s_write" (port-fd f196009) (port-buf f196009) (port-ndx f196009)) (port-ndx-reset f196009)))))
# == close-free-variables  ==>
# (closure f196007 (port-fd port-buf port-ndx port-ndx-reset) (let () (let ((f196009 (if (null? f196007) (current-output-port) (car f196007)))) (begin (foreign-call "s_write" (port-fd f196009) (port-buf f196009) (port-ndx f196009)) (port-ndx-reset f196009)))))
# == eliminate-quote  ==>
# (closure f196007 (port-fd port-buf port-ndx port-ndx-reset) (let () (let ((f196009 (if (null? f196007) (current-output-port) (car f196007)))) (begin (foreign-call "s_write" (port-fd f196009) (port-buf f196009) (port-ndx f196009)) (port-ndx-reset f196009)))))
# == eliminate-when/unless  ==>
# (closure f196007 (port-fd port-buf port-ndx port-ndx-reset) (let () (let ((f196009 (if (null? f196007) (current-output-port) (car f196007)))) (begin (foreign-call "s_write" (port-fd f196009) (port-buf f196009) (port-ndx f196009)) (port-ndx-reset f196009)))))
# == eliminate-cond  ==>
# (closure f196007 (port-fd port-buf port-ndx port-ndx-reset) (let () (let ((f196009 (if (null? f196007) (current-output-port) (car f196007)))) (begin (foreign-call "s_write" (port-fd f196009) (port-buf f196009) (port-ndx f196009)) (port-ndx-reset f196009)))))
# == external-symbols  ==>
# (closure f196007 ((primitive-ref port-fd) (primitive-ref port-buf) (primitive-ref port-ndx) (primitive-ref port-ndx-reset)) (let () (let ((f196009 (if (null? f196007) ((primitive-ref current-output-port)) (car f196007)))) (begin (foreign-call "s_write" ((primitive-ref port-fd) f196009) ((primitive-ref port-buf) f196009) ((primitive-ref port-ndx) f196009)) ((primitive-ref port-ndx-reset) f196009)))))
# emit-expr (closure f196007 ((primitive-ref port-fd) (primitive-ref port-buf) (primitive-ref port-ndx) (primitive-ref port-ndx-reset)) (let () (let ((f196009 (if (null? f196007) ((primitive-ref current-output-port)) (car f196007)))) (begin (foreign-call "s_write" ((primitive-ref port-fd) f196009) ((primitive-ref port-buf) f196009) ((primitive-ref port-ndx) f196009)) ((primitive-ref port-ndx-reset) f196009)))))
# emit-closure
# si = 0
# env = ()
# expr = (closure f196007 ((primitive-ref port-fd) (primitive-ref port-buf) (primitive-ref port-ndx) (primitive-ref port-ndx-reset)) (let () (let ((f196009 (if (null? f196007) ((primitive-ref current-output-port)) (car f196007)))) (begin (foreign-call "s_write" ((primitive-ref port-fd) f196009) ((primitive-ref port-buf) f196009) ((primitive-ref port-ndx) f196009)) ((primitive-ref port-ndx-reset) f196009)))))
    movl $_L_1432521, 0(%ebp)  # closure label
# WARNING: free var (primitive-ref port-fd) not defined in the environmnet
# WARNING: free var (primitive-ref port-buf) not defined in the environmnet
# WARNING: free var (primitive-ref port-ndx) not defined in the environmnet
# WARNING: free var (primitive-ref port-ndx-reset) not defined in the environmnet
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $24, %ebp     # bump ebp
    jmp _L_1432522            # jump around closure body
_L_1432521:
# check argument count
    cmp $0,%eax
    jge _L_1432523
# invoke error handler eh_argcount_min
    .extern mrc_eh$uargcount$umin
    movl mrc_eh$uargcount$umin, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_1432523:
# emit-build-varargs-list
    movl $63, %esi       # args <- () 
    lea -4(%esp),%edi    # edi <- esp-4
    subl %eax, %edi      # edi <- esp-4-eax    addr of arg[K+N] on stack
_L_1432525:
    lea -4(%esp),%ebx    # addr of arg[K] on stack
    cmp %edi, %ebx       # while edi <> esp+(si+4)
    je _L_1432524
    movl (%edi),%ebx     # arg i -> car
    movl %ebx, 0(%ebp)
    movl %esi, 4(%ebp)  # esi -> cdr
    movl %ebp, %esi
    addl $1, %esi       # tag as pair
    addl $8,%ebp         # bump heap ptr
    addl $4,%edi         # move to next previous arg from the end
    jmp _L_1432525
_L_1432524:
    movl %esi, -8(%esp)  # set args
# emit-tail-expr
# si=-12
# env=((f196007 . -8) ((primitive-ref port-ndx-reset) . 16) ((primitive-ref port-ndx) . 12) ((primitive-ref port-buf) . 8) ((primitive-ref port-fd) . 4))
# expr=(let () (let ((f196009 (if (null? f196007) ((primitive-ref current-output-port)) (car f196007)))) (begin (foreign-call "s_write" ((primitive-ref port-fd) f196009) ((primitive-ref port-buf) f196009) ((primitive-ref port-ndx) f196009)) ((primitive-ref port-ndx-reset) f196009))))
# emit-tail-let
#  si   = -12
#  env  = ((f196007 . -8) ((primitive-ref port-ndx-reset) . 16) ((primitive-ref port-ndx) . 12) ((primitive-ref port-buf) . 8) ((primitive-ref port-fd) . 4))
#  bindings = ()
#  body = (let ((f196009 (if (null? f196007) ((primitive-ref current-output-port)) (car f196007)))) (begin (foreign-call "s_write" ((primitive-ref port-fd) f196009) ((primitive-ref port-buf) f196009) ((primitive-ref port-ndx) f196009)) ((primitive-ref port-ndx-reset) f196009)))
# emit-tail-expr
# si=-12
# env=((f196007 . -8) ((primitive-ref port-ndx-reset) . 16) ((primitive-ref port-ndx) . 12) ((primitive-ref port-buf) . 8) ((primitive-ref port-fd) . 4))
# expr=(let ((f196009 (if (null? f196007) ((primitive-ref current-output-port)) (car f196007)))) (begin (foreign-call "s_write" ((primitive-ref port-fd) f196009) ((primitive-ref port-buf) f196009) ((primitive-ref port-ndx) f196009)) ((primitive-ref port-ndx-reset) f196009)))
# emit-tail-let
#  si   = -12
#  env  = ((f196007 . -8) ((primitive-ref port-ndx-reset) . 16) ((primitive-ref port-ndx) . 12) ((primitive-ref port-buf) . 8) ((primitive-ref port-fd) . 4))
#  bindings = ((f196009 (if (null? f196007) ((primitive-ref current-output-port)) (car f196007))))
#  body = (begin (foreign-call "s_write" ((primitive-ref port-fd) f196009) ((primitive-ref port-buf) f196009) ((primitive-ref port-ndx) f196009)) ((primitive-ref port-ndx-reset) f196009))
# emit-expr (if (null? f196007) ((primitive-ref current-output-port)) (car f196007))
# emit-expr (null? f196007)
# emit-expr f196007
# emit-variable-ref
# env=((f196007 . -8) ((primitive-ref port-ndx-reset) . 16) ((primitive-ref port-ndx) . 12) ((primitive-ref port-buf) . 8) ((primitive-ref port-fd) . 4))
# var=f196007
    movl -8(%esp), %eax  # stack load f196007
# end emit-variable-ref
    cmp $63, %eax
    mov $0, %eax
    sete %al
    movzbl %al, %eax
    sal $6, %al
    or $47, %al
    cmp $47, %al
    je _L_1432526
# emit-expr ((primitive-ref current-output-port))
# funcall
#    si   =-12
#    env  = ((f196007 . -8) ((primitive-ref port-ndx-reset) . 16) ((primitive-ref port-ndx) . 12) ((primitive-ref port-buf) . 8) ((primitive-ref port-fd) . 4))
#    expr = (funcall (primitive-ref current-output-port))
# emit-expr (primitive-ref current-output-port)
    .extern mrc_current$moutput$mport
    movl mrc_current$moutput$mport,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1432528"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1432528":
   movl %eax,  -20(%esp)  # stash funcall-oper in closure slot
    movl -20(%esp), %edi   # load new closure to %edi
    add $-12, %esp   # adjust base
    movl $0,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $12, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    jmp _L_1432527
_L_1432526:
# emit-expr (car f196007)
# emit-expr f196007
# emit-variable-ref
# env=((f196007 . -8) ((primitive-ref port-ndx-reset) . 16) ((primitive-ref port-ndx) . 12) ((primitive-ref port-buf) . 8) ((primitive-ref port-fd) . 4))
# var=f196007
    movl -8(%esp), %eax  # stack load f196007
# end emit-variable-ref
# check the argument is a pair
    movl %eax,%ebx
    and $7, %bl
    cmp $1, %bl
    je _L_1432529
# invoke error handler eh_pair
    .extern mrc_eh$upair
    movl mrc_eh$upair, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $108,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1432529:
    movl -1(%eax), %eax
_L_1432527:
    movl %eax, -12(%esp)  # stack save
# emit-tail-expr
# si=-16
# env=((f196009 . -12) (f196007 . -8) ((primitive-ref port-ndx-reset) . 16) ((primitive-ref port-ndx) . 12) ((primitive-ref port-buf) . 8) ((primitive-ref port-fd) . 4))
# expr=(begin (foreign-call "s_write" ((primitive-ref port-fd) f196009) ((primitive-ref port-buf) f196009) ((primitive-ref port-ndx) f196009)) ((primitive-ref port-ndx-reset) f196009))
# tail-begin (begin (foreign-call "s_write" ((primitive-ref port-fd) f196009) ((primitive-ref port-buf) f196009) ((primitive-ref port-ndx) f196009)) ((primitive-ref port-ndx-reset) f196009))
#   env=((f196009 . -12) (f196007 . -8) ((primitive-ref port-ndx-reset) . 16) ((primitive-ref port-ndx) . 12) ((primitive-ref port-buf) . 8) ((primitive-ref port-fd) . 4))
# emit-expr (foreign-call "s_write" ((primitive-ref port-fd) f196009) ((primitive-ref port-buf) f196009) ((primitive-ref port-ndx) f196009))
    movl %ecx,-16(%esp)
    movl %esp,-20(%esp)
# emit-expr ((primitive-ref port-ndx) f196009)
# funcall
#    si   =-24
#    env  = ((f196009 . -12) (f196007 . -8) ((primitive-ref port-ndx-reset) . 16) ((primitive-ref port-ndx) . 12) ((primitive-ref port-buf) . 8) ((primitive-ref port-fd) . 4))
#    expr = (funcall (primitive-ref port-ndx) f196009)
# emit-expr (primitive-ref port-ndx)
    .extern mrc_port$mndx
    movl mrc_port$mndx,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1432530"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1432530":
   movl %eax,  -32(%esp)  # stash funcall-oper in closure slot
# emit-expr f196009
# emit-variable-ref
# env=((f196009 . -12) (f196007 . -8) ((primitive-ref port-ndx-reset) . 16) ((primitive-ref port-ndx) . 12) ((primitive-ref port-buf) . 8) ((primitive-ref port-fd) . 4))
# var=f196009
    movl -12(%esp), %eax  # stack load f196009
# end emit-variable-ref
    mov %eax, -36(%esp)  # arg f196009
    movl -32(%esp), %edi   # load new closure to %edi
    add $-24, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $24, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    movl %eax, -24(%esp)
# emit-expr ((primitive-ref port-buf) f196009)
# funcall
#    si   =-28
#    env  = ((f196009 . -12) (f196007 . -8) ((primitive-ref port-ndx-reset) . 16) ((primitive-ref port-ndx) . 12) ((primitive-ref port-buf) . 8) ((primitive-ref port-fd) . 4))
#    expr = (funcall (primitive-ref port-buf) f196009)
# emit-expr (primitive-ref port-buf)
    .extern mrc_port$mbuf
    movl mrc_port$mbuf,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1432531"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1432531":
   movl %eax,  -36(%esp)  # stash funcall-oper in closure slot
# emit-expr f196009
# emit-variable-ref
# env=((f196009 . -12) (f196007 . -8) ((primitive-ref port-ndx-reset) . 16) ((primitive-ref port-ndx) . 12) ((primitive-ref port-buf) . 8) ((primitive-ref port-fd) . 4))
# var=f196009
    movl -12(%esp), %eax  # stack load f196009
# end emit-variable-ref
    mov %eax, -40(%esp)  # arg f196009
    movl -36(%esp), %edi   # load new closure to %edi
    add $-28, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $28, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    movl %eax, -28(%esp)
# emit-expr ((primitive-ref port-fd) f196009)
# funcall
#    si   =-32
#    env  = ((f196009 . -12) (f196007 . -8) ((primitive-ref port-ndx-reset) . 16) ((primitive-ref port-ndx) . 12) ((primitive-ref port-buf) . 8) ((primitive-ref port-fd) . 4))
#    expr = (funcall (primitive-ref port-fd) f196009)
# emit-expr (primitive-ref port-fd)
    .extern mrc_port$mfd
    movl mrc_port$mfd,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1432532"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1432532":
   movl %eax,  -40(%esp)  # stash funcall-oper in closure slot
# emit-expr f196009
# emit-variable-ref
# env=((f196009 . -12) (f196007 . -8) ((primitive-ref port-ndx-reset) . 16) ((primitive-ref port-ndx) . 12) ((primitive-ref port-buf) . 8) ((primitive-ref port-fd) . 4))
# var=f196009
    movl -12(%esp), %eax  # stack load f196009
# end emit-variable-ref
    mov %eax, -44(%esp)  # arg f196009
    movl -40(%esp), %edi   # load new closure to %edi
    add $-32, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $32, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    movl %eax, -32(%esp)
    leal -32(%esp),%edi
    movl %edi,%esi
    andl $-16,%esi
    movl 0(%edi),%eax
    movl %eax,0(%esi)
    movl 4(%edi),%eax
    movl %eax,4(%esi)
    movl 8(%edi),%eax
    movl %eax,8(%esi)
    movl 12(%edi),%eax
    movl %eax,12(%esi)
    movl %esi,%esp
    .extern _s_write
    call _s_write
    movl 12(%esi),%esp
    movl -16(%esp),%ecx
# emit-tail-expr
# si=-16
# env=((f196009 . -12) (f196007 . -8) ((primitive-ref port-ndx-reset) . 16) ((primitive-ref port-ndx) . 12) ((primitive-ref port-buf) . 8) ((primitive-ref port-fd) . 4))
# expr=(begin ((primitive-ref port-ndx-reset) f196009))
# tail-begin (begin ((primitive-ref port-ndx-reset) f196009))
#   env=((f196009 . -12) (f196007 . -8) ((primitive-ref port-ndx-reset) . 16) ((primitive-ref port-ndx) . 12) ((primitive-ref port-buf) . 8) ((primitive-ref port-fd) . 4))
# emit-tail-expr
# si=-16
# env=((f196009 . -12) (f196007 . -8) ((primitive-ref port-ndx-reset) . 16) ((primitive-ref port-ndx) . 12) ((primitive-ref port-buf) . 8) ((primitive-ref port-fd) . 4))
# expr=((primitive-ref port-ndx-reset) f196009)
# emit-tail-funcall
#    si   =-16
#    env  = ((f196009 . -12) (f196007 . -8) ((primitive-ref port-ndx-reset) . 16) ((primitive-ref port-ndx) . 12) ((primitive-ref port-buf) . 8) ((primitive-ref port-fd) . 4))
#    expr = (funcall (primitive-ref port-ndx-reset) f196009)
# emit-expr (primitive-ref port-ndx-reset)
    .extern mrc_port$mndx$mreset
    movl mrc_port$mndx$mreset,%eax
   movl %eax,  -16(%esp)  # stash funcall-oper in next closure slot
# emit-expr f196009
# emit-variable-ref
# env=((f196009 . -12) (f196007 . -8) ((primitive-ref port-ndx-reset) . 16) ((primitive-ref port-ndx) . 12) ((primitive-ref port-buf) . 8) ((primitive-ref port-fd) . 4))
# var=f196009
    movl -12(%esp), %eax  # stack load f196009
# end emit-variable-ref
    mov %eax, -20(%esp)    # arg f196009
    movl -16(%esp), %edi   # load new closure to %edi
# emit-shift-args:  size=2   si=-16  delta=12
    mov -16(%esp), %ebx  # shift frame cell
    mov %ebx, -4(%esp)  # down to base
# emit-shift-args:  size=1   si=-20  delta=12
    mov -20(%esp), %ebx  # shift frame cell
    mov %ebx, -8(%esp)  # down to base
# emit-shift-args:  size=0   si=-24  delta=12
    movl $4,%eax   # save arg count
    jmp *-2(%edi)  # tail-funcall
     ret   # return thru stack
    .align 4,0x90
_L_1432522:
     movl %eax, mrc_flush$moutput$mport
# == explicit-begins  ==>
# (lambda () (begin (flush-output-port) (foreign-call "s_exit")))
# == eliminate-let*  ==>
# (lambda () (begin (flush-output-port) (foreign-call "s_exit")))
# == uniquify-variables  ==>
# (lambda () (begin (flush-output-port) (foreign-call "s_exit")))
# == vectorize-letrec  ==>
# (lambda () (begin (flush-output-port) (foreign-call "s_exit")))
# == eliminate-set!  ==>
# (lambda () (let () (begin (flush-output-port) (foreign-call "s_exit"))))
# == close-free-variables  ==>
# (closure () (flush-output-port) (let () (begin (flush-output-port) (foreign-call "s_exit"))))
# == eliminate-quote  ==>
# (closure () (flush-output-port) (let () (begin (flush-output-port) (foreign-call "s_exit"))))
# == eliminate-when/unless  ==>
# (closure () (flush-output-port) (let () (begin (flush-output-port) (foreign-call "s_exit"))))
# == eliminate-cond  ==>
# (closure () (flush-output-port) (let () (begin (flush-output-port) (foreign-call "s_exit"))))
# == external-symbols  ==>
# (closure () ((primitive-ref flush-output-port)) (let () (begin ((primitive-ref flush-output-port)) (foreign-call "s_exit"))))
# emit-expr (closure () ((primitive-ref flush-output-port)) (let () (begin ((primitive-ref flush-output-port)) (foreign-call "s_exit"))))
# emit-closure
# si = 0
# env = ()
# expr = (closure () ((primitive-ref flush-output-port)) (let () (begin ((primitive-ref flush-output-port)) (foreign-call "s_exit"))))
    movl $_L_1432533, 0(%ebp)  # closure label
# WARNING: free var (primitive-ref flush-output-port) not defined in the environmnet
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $8, %ebp     # bump ebp
    jmp _L_1432534            # jump around closure body
_L_1432533:
# check argument count
    cmp $0,%eax
    je _L_1432535
# invoke error handler eh_argcount
    .extern mrc_eh$uargcount
    movl mrc_eh$uargcount, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_1432535:
# emit-tail-expr
# si=-8
# env=(((primitive-ref flush-output-port) . 4))
# expr=(let () (begin ((primitive-ref flush-output-port)) (foreign-call "s_exit")))
# emit-tail-let
#  si   = -8
#  env  = (((primitive-ref flush-output-port) . 4))
#  bindings = ()
#  body = (begin ((primitive-ref flush-output-port)) (foreign-call "s_exit"))
# emit-tail-expr
# si=-8
# env=(((primitive-ref flush-output-port) . 4))
# expr=(begin ((primitive-ref flush-output-port)) (foreign-call "s_exit"))
# tail-begin (begin ((primitive-ref flush-output-port)) (foreign-call "s_exit"))
#   env=(((primitive-ref flush-output-port) . 4))
# emit-expr ((primitive-ref flush-output-port))
# funcall
#    si   =-8
#    env  = (((primitive-ref flush-output-port) . 4))
#    expr = (funcall (primitive-ref flush-output-port))
# emit-expr (primitive-ref flush-output-port)
    .extern mrc_flush$moutput$mport
    movl mrc_flush$moutput$mport,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1432536"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1432536":
   movl %eax,  -16(%esp)  # stash funcall-oper in closure slot
    movl -16(%esp), %edi   # load new closure to %edi
    add $-8, %esp   # adjust base
    movl $0,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $8, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
# emit-tail-expr
# si=-8
# env=(((primitive-ref flush-output-port) . 4))
# expr=(begin (foreign-call "s_exit"))
# tail-begin (begin (foreign-call "s_exit"))
#   env=(((primitive-ref flush-output-port) . 4))
# emit-tail-expr
# si=-8
# env=(((primitive-ref flush-output-port) . 4))
# expr=(foreign-call "s_exit")
    movl %ecx,-8(%esp)
    movl %esp,-12(%esp)
    leal -12(%esp),%edi
    movl %edi,%esi
    andl $-16,%esi
    movl 0(%edi),%eax
    movl %eax,0(%esi)
    movl %esi,%esp
    .extern _s_exit
    call _s_exit
    movl 0(%esi),%esp
    movl -8(%esp),%ecx
     ret
     ret   # return thru stack
    .align 4,0x90
_L_1432534:
     movl %eax, mrc_exit
# == explicit-begins  ==>
# (lambda (x) (if (vector? x) (if (fx= 6 (vector-length? x)) (symbol=? (vector-ref x 0) (quote output-port)) #f) #f))
# == eliminate-let*  ==>
# (lambda (x) (if (vector? x) (if (fx= 6 (vector-length? x)) (symbol=? (vector-ref x 0) (quote output-port)) #f) #f))
# == uniquify-variables  ==>
# (lambda (f196010) (if (vector? f196010) (if (fx= 6 (vector-length? f196010)) (symbol=? (vector-ref f196010 0) (quote output-port)) #f) #f))
# == vectorize-letrec  ==>
# (lambda (f196010) (if (vector? f196010) (if (fx= 6 (vector-length? f196010)) (symbol=? (vector-ref f196010 0) (quote output-port)) #f) #f))
# == eliminate-set!  ==>
# (lambda (f196010) (let ((f196010 f196010)) (if (vector? f196010) (if (fx= 6 (vector-length? f196010)) (symbol=? (vector-ref f196010 0) (quote output-port)) #f) #f)))
# == close-free-variables  ==>
# (closure (f196010) (vector-length? symbol=? output-port) (let ((f196010 f196010)) (if (vector? f196010) (if (fx= 6 (vector-length? f196010)) (symbol=? (vector-ref f196010 0) (quote output-port)) #f) #f)))
# == eliminate-quote  ==>
# (closure (f196010) (vector-length? symbol=? output-port) (let ((f196010 f196010)) (if (vector? f196010) (if (fx= 6 (vector-length? f196010)) (symbol=? (vector-ref f196010 0) (string->symbol "output-port")) #f) #f)))
# == eliminate-when/unless  ==>
# (closure (f196010) (vector-length? symbol=? output-port) (let ((f196010 f196010)) (if (vector? f196010) (if (fx= 6 (vector-length? f196010)) (symbol=? (vector-ref f196010 0) (string->symbol "output-port")) #f) #f)))
# == eliminate-cond  ==>
# (closure (f196010) (vector-length? symbol=? output-port) (let ((f196010 f196010)) (if (vector? f196010) (if (fx= 6 (vector-length? f196010)) (symbol=? (vector-ref f196010 0) (string->symbol "output-port")) #f) #f)))
# == external-symbols  ==>
# (closure (f196010) (vector-length? symbol=? output-port) (let ((f196010 f196010)) (if (vector? f196010) (if (fx= 6 (vector-length? f196010)) (symbol=? (vector-ref f196010 0) ((primitive-ref string->symbol) "output-port")) #f) #f)))
# emit-expr (closure (f196010) (vector-length? symbol=? output-port) (let ((f196010 f196010)) (if (vector? f196010) (if (fx= 6 (vector-length? f196010)) (symbol=? (vector-ref f196010 0) ((primitive-ref string->symbol) "output-port")) #f) #f)))
# emit-closure
# si = 0
# env = ()
# expr = (closure (f196010) (vector-length? symbol=? output-port) (let ((f196010 f196010)) (if (vector? f196010) (if (fx= 6 (vector-length? f196010)) (symbol=? (vector-ref f196010 0) ((primitive-ref string->symbol) "output-port")) #f) #f)))
    movl $_L_1432537, 0(%ebp)  # closure label
# WARNING: free var vector-length? not defined in the environmnet
# WARNING: free var symbol=? not defined in the environmnet
# WARNING: free var output-port not defined in the environmnet
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $16, %ebp     # bump ebp
    jmp _L_1432538            # jump around closure body
_L_1432537:
# check argument count
    cmp $4,%eax
    je _L_1432539
# invoke error handler eh_argcount
    .extern mrc_eh$uargcount
    movl mrc_eh$uargcount, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_1432539:
# emit-tail-expr
# si=-12
# env=((f196010 . -8) (output-port . 12) (symbol=? . 8) (vector-length? . 4))
# expr=(let ((f196010 f196010)) (if (vector? f196010) (if (fx= 6 (vector-length? f196010)) (symbol=? (vector-ref f196010 0) ((primitive-ref string->symbol) "output-port")) #f) #f))
# emit-tail-let
#  si   = -12
#  env  = ((f196010 . -8) (output-port . 12) (symbol=? . 8) (vector-length? . 4))
#  bindings = ((f196010 f196010))
#  body = (if (vector? f196010) (if (fx= 6 (vector-length? f196010)) (symbol=? (vector-ref f196010 0) ((primitive-ref string->symbol) "output-port")) #f) #f)
# emit-expr f196010
# emit-variable-ref
# env=((f196010 . -8) (output-port . 12) (symbol=? . 8) (vector-length? . 4))
# var=f196010
    movl -8(%esp), %eax  # stack load f196010
# end emit-variable-ref
    movl %eax, -12(%esp)  # stack save
# emit-tail-expr
# si=-16
# env=((f196010 . -12) (f196010 . -8) (output-port . 12) (symbol=? . 8) (vector-length? . 4))
# expr=(if (vector? f196010) (if (fx= 6 (vector-length? f196010)) (symbol=? (vector-ref f196010 0) ((primitive-ref string->symbol) "output-port")) #f) #f)
# emit-expr (vector? f196010)
# emit-expr f196010
# emit-variable-ref
# env=((f196010 . -12) (f196010 . -8) (output-port . 12) (symbol=? . 8) (vector-length? . 4))
# var=f196010
    movl -12(%esp), %eax  # stack load f196010
# end emit-variable-ref
    and $7, %al
    cmp $5, %al
    sete %al
    movzbl %al, %eax
    sal $6, %al
    or $47, %al
    cmp $47, %al
    je _L_1432540
# emit-tail-expr
# si=-16
# env=((f196010 . -12) (f196010 . -8) (output-port . 12) (symbol=? . 8) (vector-length? . 4))
# expr=(if (fx= 6 (vector-length? f196010)) (symbol=? (vector-ref f196010 0) ((primitive-ref string->symbol) "output-port")) #f)
# emit-expr (fx= 6 (vector-length? f196010))
# emit-expr (vector-length? f196010)
# funcall
#    si   =-16
#    env  = ((f196010 . -12) (f196010 . -8) (output-port . 12) (symbol=? . 8) (vector-length? . 4))
#    expr = (funcall vector-length? f196010)
# emit-expr vector-length?
# emit-variable-ref
# env=((f196010 . -12) (f196010 . -8) (output-port . 12) (symbol=? . 8) (vector-length? . 4))
# var=vector-length?
    movl 2(%edi), %eax  # frame load vector-length?
# end emit-variable-ref
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1432544"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1432544":
   movl %eax,  -24(%esp)  # stash funcall-oper in closure slot
# emit-expr f196010
# emit-variable-ref
# env=((f196010 . -12) (f196010 . -8) (output-port . 12) (symbol=? . 8) (vector-length? . 4))
# var=f196010
    movl -12(%esp), %eax  # stack load f196010
# end emit-variable-ref
    mov %eax, -28(%esp)  # arg f196010
    movl -24(%esp), %edi   # load new closure to %edi
    add $-16, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $16, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1432545"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $60,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1432545:
    movl %eax, -16(%esp)
# emit-expr 6
    movl $24, %eax     # immed 6
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1432546"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $60,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1432546:
    cmp -16(%esp), %eax
    sete %al
    movzbl %al, %eax
    sal $6, %al
    or $47, %al
    cmp $47, %al
    je _L_1432542
# emit-tail-expr
# si=-16
# env=((f196010 . -12) (f196010 . -8) (output-port . 12) (symbol=? . 8) (vector-length? . 4))
# expr=(symbol=? (vector-ref f196010 0) ((primitive-ref string->symbol) "output-port"))
# emit-tail-funcall
#    si   =-16
#    env  = ((f196010 . -12) (f196010 . -8) (output-port . 12) (symbol=? . 8) (vector-length? . 4))
#    expr = (funcall symbol=? (vector-ref f196010 0) ((primitive-ref string->symbol) "output-port"))
# emit-expr symbol=?
# emit-variable-ref
# env=((f196010 . -12) (f196010 . -8) (output-port . 12) (symbol=? . 8) (vector-length? . 4))
# var=symbol=?
    movl 6(%edi), %eax  # frame load symbol=?
# end emit-variable-ref
   movl %eax,  -16(%esp)  # stash funcall-oper in next closure slot
# emit-expr (vector-ref f196010 0)
# emit-expr f196010
# emit-variable-ref
# env=((f196010 . -12) (f196010 . -8) (output-port . 12) (symbol=? . 8) (vector-length? . 4))
# var=f196010
    movl -12(%esp), %eax  # stack load f196010
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1432547
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1432547:
    movl %eax, -20(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1432548"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1432548:
# check bounds on vector index
    movl -20(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1432550
    cmp  $0,%eax
    jge _L_1432549
_L_1432550:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1432549:
    movl -20(%esp), %esi
    movl -1(%eax,%esi), %eax
    mov %eax, -20(%esp)    # arg (vector-ref f196010 0)
# emit-expr ((primitive-ref string->symbol) "output-port")
# funcall
#    si   =-24
#    env  = ((f196010 . -12) (f196010 . -8) (output-port . 12) (symbol=? . 8) (vector-length? . 4))
#    expr = (funcall (primitive-ref string->symbol) "output-port")
# emit-expr (primitive-ref string->symbol)
    .extern mrc_string$m$gsymbol
    movl mrc_string$m$gsymbol,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1432551"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1432551":
   movl %eax,  -32(%esp)  # stash funcall-oper in closure slot
# emit-expr "output-port"
# string literal
    jmp _L_1432553
    .align 8,0x90
_L_1432552 :
    .int 44
    .ascii "output-port"
_L_1432553:
    movl $_L_1432552, %eax
    orl $6, %eax
    mov %eax, -36(%esp)  # arg output-port
    movl -32(%esp), %edi   # load new closure to %edi
    add $-24, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $24, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    mov %eax, -24(%esp)    # arg ((primitive-ref string->symbol) output-port)
    movl -16(%esp), %edi   # load new closure to %edi
# emit-shift-args:  size=3   si=-16  delta=12
    mov -16(%esp), %ebx  # shift frame cell
    mov %ebx, -4(%esp)  # down to base
# emit-shift-args:  size=2   si=-20  delta=12
    mov -20(%esp), %ebx  # shift frame cell
    mov %ebx, -8(%esp)  # down to base
# emit-shift-args:  size=1   si=-24  delta=12
    mov -24(%esp), %ebx  # shift frame cell
    mov %ebx, -12(%esp)  # down to base
# emit-shift-args:  size=0   si=-28  delta=12
    movl $8,%eax   # save arg count
    jmp *-2(%edi)  # tail-funcall
    jmp _L_1432543
_L_1432542:
# emit-tail-expr
# si=-16
# env=((f196010 . -12) (f196010 . -8) (output-port . 12) (symbol=? . 8) (vector-length? . 4))
# expr=#f
    movl $47, %eax     # immed #f
    ret                  # immediate tail return
_L_1432543:
    jmp _L_1432541
_L_1432540:
# emit-tail-expr
# si=-16
# env=((f196010 . -12) (f196010 . -8) (output-port . 12) (symbol=? . 8) (vector-length? . 4))
# expr=#f
    movl $47, %eax     # immed #f
    ret                  # immediate tail return
_L_1432541:
    .align 4,0x90
_L_1432538:
     movl %eax, mrc_output$mport$q
# == explicit-begins  ==>
# (lambda (x) (error (quote open-output) "not yet implemented"))
# == eliminate-let*  ==>
# (lambda (x) (error (quote open-output) "not yet implemented"))
# == uniquify-variables  ==>
# (lambda (f196011) (error (quote open-output) "not yet implemented"))
# == vectorize-letrec  ==>
# (lambda (f196011) (error (quote open-output) "not yet implemented"))
# == eliminate-set!  ==>
# (lambda (f196011) (let ((f196011 f196011)) (error (quote open-output) "not yet implemented")))
# == close-free-variables  ==>
# (closure (f196011) (error open-output) (let ((f196011 f196011)) (error (quote open-output) "not yet implemented")))
# == eliminate-quote  ==>
# (closure (f196011) (error open-output) (let ((f196011 f196011)) (error (string->symbol "open-output") "not yet implemented")))
# == eliminate-when/unless  ==>
# (closure (f196011) (error open-output) (let ((f196011 f196011)) (error (string->symbol "open-output") "not yet implemented")))
# == eliminate-cond  ==>
# (closure (f196011) (error open-output) (let ((f196011 f196011)) (error (string->symbol "open-output") "not yet implemented")))
# == external-symbols  ==>
# (closure (f196011) ((primitive-ref error) open-output) (let ((f196011 f196011)) ((primitive-ref error) ((primitive-ref string->symbol) "open-output") "not yet implemented")))
# emit-expr (closure (f196011) ((primitive-ref error) open-output) (let ((f196011 f196011)) ((primitive-ref error) ((primitive-ref string->symbol) "open-output") "not yet implemented")))
# emit-closure
# si = 0
# env = ()
# expr = (closure (f196011) ((primitive-ref error) open-output) (let ((f196011 f196011)) ((primitive-ref error) ((primitive-ref string->symbol) "open-output") "not yet implemented")))
    movl $_L_1432554, 0(%ebp)  # closure label
# WARNING: free var (primitive-ref error) not defined in the environmnet
# WARNING: free var open-output not defined in the environmnet
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $16, %ebp     # bump ebp
    jmp _L_1432555            # jump around closure body
_L_1432554:
# check argument count
    cmp $4,%eax
    je _L_1432556
# invoke error handler eh_argcount
    .extern mrc_eh$uargcount
    movl mrc_eh$uargcount, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_1432556:
# emit-tail-expr
# si=-12
# env=((f196011 . -8) (open-output . 8) ((primitive-ref error) . 4))
# expr=(let ((f196011 f196011)) ((primitive-ref error) ((primitive-ref string->symbol) "open-output") "not yet implemented"))
# emit-tail-let
#  si   = -12
#  env  = ((f196011 . -8) (open-output . 8) ((primitive-ref error) . 4))
#  bindings = ((f196011 f196011))
#  body = ((primitive-ref error) ((primitive-ref string->symbol) "open-output") "not yet implemented")
# emit-expr f196011
# emit-variable-ref
# env=((f196011 . -8) (open-output . 8) ((primitive-ref error) . 4))
# var=f196011
    movl -8(%esp), %eax  # stack load f196011
# end emit-variable-ref
    movl %eax, -12(%esp)  # stack save
# emit-tail-expr
# si=-16
# env=((f196011 . -12) (f196011 . -8) (open-output . 8) ((primitive-ref error) . 4))
# expr=((primitive-ref error) ((primitive-ref string->symbol) "open-output") "not yet implemented")
# emit-tail-funcall
#    si   =-16
#    env  = ((f196011 . -12) (f196011 . -8) (open-output . 8) ((primitive-ref error) . 4))
#    expr = (funcall (primitive-ref error) ((primitive-ref string->symbol) "open-output") "not yet implemented")
# emit-expr (primitive-ref error)
    .extern mrc_error
    movl mrc_error,%eax
   movl %eax,  -16(%esp)  # stash funcall-oper in next closure slot
# emit-expr ((primitive-ref string->symbol) "open-output")
# funcall
#    si   =-20
#    env  = ((f196011 . -12) (f196011 . -8) (open-output . 8) ((primitive-ref error) . 4))
#    expr = (funcall (primitive-ref string->symbol) "open-output")
# emit-expr (primitive-ref string->symbol)
    .extern mrc_string$m$gsymbol
    movl mrc_string$m$gsymbol,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1432557"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1432557":
   movl %eax,  -28(%esp)  # stash funcall-oper in closure slot
# emit-expr "open-output"
# string literal
    jmp _L_1432559
    .align 8,0x90
_L_1432558 :
    .int 44
    .ascii "open-output"
_L_1432559:
    movl $_L_1432558, %eax
    orl $6, %eax
    mov %eax, -32(%esp)  # arg open-output
    movl -28(%esp), %edi   # load new closure to %edi
    add $-20, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $20, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    mov %eax, -20(%esp)    # arg ((primitive-ref string->symbol) open-output)
# emit-expr "not yet implemented"
# string literal
    jmp _L_1432561
    .align 8,0x90
_L_1432560 :
    .int 76
    .ascii "not yet implemented"
_L_1432561:
    movl $_L_1432560, %eax
    orl $6, %eax
    mov %eax, -24(%esp)    # arg not yet implemented
    movl -16(%esp), %edi   # load new closure to %edi
# emit-shift-args:  size=3   si=-16  delta=12
    mov -16(%esp), %ebx  # shift frame cell
    mov %ebx, -4(%esp)  # down to base
# emit-shift-args:  size=2   si=-20  delta=12
    mov -20(%esp), %ebx  # shift frame cell
    mov %ebx, -8(%esp)  # down to base
# emit-shift-args:  size=1   si=-24  delta=12
    mov -24(%esp), %ebx  # shift frame cell
    mov %ebx, -12(%esp)  # down to base
# emit-shift-args:  size=0   si=-28  delta=12
    movl $8,%eax   # save arg count
    jmp *-2(%edi)  # tail-funcall
    .align 4,0x90
_L_1432555:
     movl %eax, mrc_open$moutput$mfile
# == explicit-begins  ==>
# (lambda (p) (flush-output-port p))
# == eliminate-let*  ==>
# (lambda (p) (flush-output-port p))
# == uniquify-variables  ==>
# (lambda (f196012) (flush-output-port f196012))
# == vectorize-letrec  ==>
# (lambda (f196012) (flush-output-port f196012))
# == eliminate-set!  ==>
# (lambda (f196012) (let ((f196012 f196012)) (flush-output-port f196012)))
# == close-free-variables  ==>
# (closure (f196012) (flush-output-port) (let ((f196012 f196012)) (flush-output-port f196012)))
# == eliminate-quote  ==>
# (closure (f196012) (flush-output-port) (let ((f196012 f196012)) (flush-output-port f196012)))
# == eliminate-when/unless  ==>
# (closure (f196012) (flush-output-port) (let ((f196012 f196012)) (flush-output-port f196012)))
# == eliminate-cond  ==>
# (closure (f196012) (flush-output-port) (let ((f196012 f196012)) (flush-output-port f196012)))
# == external-symbols  ==>
# (closure (f196012) ((primitive-ref flush-output-port)) (let ((f196012 f196012)) ((primitive-ref flush-output-port) f196012)))
# emit-expr (closure (f196012) ((primitive-ref flush-output-port)) (let ((f196012 f196012)) ((primitive-ref flush-output-port) f196012)))
# emit-closure
# si = 0
# env = ()
# expr = (closure (f196012) ((primitive-ref flush-output-port)) (let ((f196012 f196012)) ((primitive-ref flush-output-port) f196012)))
    movl $_L_1432562, 0(%ebp)  # closure label
# WARNING: free var (primitive-ref flush-output-port) not defined in the environmnet
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $8, %ebp     # bump ebp
    jmp _L_1432563            # jump around closure body
_L_1432562:
# check argument count
    cmp $4,%eax
    je _L_1432564
# invoke error handler eh_argcount
    .extern mrc_eh$uargcount
    movl mrc_eh$uargcount, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_1432564:
# emit-tail-expr
# si=-12
# env=((f196012 . -8) ((primitive-ref flush-output-port) . 4))
# expr=(let ((f196012 f196012)) ((primitive-ref flush-output-port) f196012))
# emit-tail-let
#  si   = -12
#  env  = ((f196012 . -8) ((primitive-ref flush-output-port) . 4))
#  bindings = ((f196012 f196012))
#  body = ((primitive-ref flush-output-port) f196012)
# emit-expr f196012
# emit-variable-ref
# env=((f196012 . -8) ((primitive-ref flush-output-port) . 4))
# var=f196012
    movl -8(%esp), %eax  # stack load f196012
# end emit-variable-ref
    movl %eax, -12(%esp)  # stack save
# emit-tail-expr
# si=-16
# env=((f196012 . -12) (f196012 . -8) ((primitive-ref flush-output-port) . 4))
# expr=((primitive-ref flush-output-port) f196012)
# emit-tail-funcall
#    si   =-16
#    env  = ((f196012 . -12) (f196012 . -8) ((primitive-ref flush-output-port) . 4))
#    expr = (funcall (primitive-ref flush-output-port) f196012)
# emit-expr (primitive-ref flush-output-port)
    .extern mrc_flush$moutput$mport
    movl mrc_flush$moutput$mport,%eax
   movl %eax,  -16(%esp)  # stash funcall-oper in next closure slot
# emit-expr f196012
# emit-variable-ref
# env=((f196012 . -12) (f196012 . -8) ((primitive-ref flush-output-port) . 4))
# var=f196012
    movl -12(%esp), %eax  # stack load f196012
# end emit-variable-ref
    mov %eax, -20(%esp)    # arg f196012
    movl -16(%esp), %edi   # load new closure to %edi
# emit-shift-args:  size=2   si=-16  delta=12
    mov -16(%esp), %ebx  # shift frame cell
    mov %ebx, -4(%esp)  # down to base
# emit-shift-args:  size=1   si=-20  delta=12
    mov -20(%esp), %ebx  # shift frame cell
    mov %ebx, -8(%esp)  # down to base
# emit-shift-args:  size=0   si=-24  delta=12
    movl $4,%eax   # save arg count
    jmp *-2(%edi)  # tail-funcall
    .align 4,0x90
_L_1432563:
     movl %eax, mrc_close$moutput$mport
# == explicit-begins  ==>
# (letrec ((print-boolean (lambda (expr) (begin (write-char #\#) (if expr (write-char #\t) (write-char #\f))))) (print-null (lambda () (begin (write-char #\() (write-char #\))))) (print-char (lambda (expr) (begin (write-char #\#) (write-char #\\) (write-char expr)))) (print-fixnum (lambda (i) (if (negative? i) (begin (write-char #\-) (print-fixnum (fx* -1 i))) (map (lambda (x) (write-char (fixnum->char (fx+ (char->fixnum #\0) x)))) (integer->list i))))) (print-string (lambda (s) (begin (write-char #\") (for-each write-char (string->list s)) (write-char #\")))) (print-pair (lambda (pr) (begin (write-char #\() (print-pairs pr) (write-char #\))))) (print-pairs (lambda (pr) (begin (write (car pr)) (cond ((null? (cdr pr)) #t) ((pair? (cdr pr)) (begin (write-char #\space) (print-pairs (cdr pr)))) (else (begin (write-char #\space) (write-char #\.) (write-char #\space) (write (cdr pr))))))))) (lambda (expr) (cond ((boolean? expr) (print-boolean expr)) ((null? expr) (print-null)) ((char? expr) (print-char expr)) ((fixnum? expr) (print-fixnum expr)) ((string? expr) (print-string expr)) ((pair? expr) (print-pair expr)) (else (error (quote write) "unrecognized expression")))))
# == eliminate-let*  ==>
# (letrec ((print-boolean (lambda (expr) (begin (write-char #\#) (if expr (write-char #\t) (write-char #\f))))) (print-null (lambda () (begin (write-char #\() (write-char #\))))) (print-char (lambda (expr) (begin (write-char #\#) (write-char #\\) (write-char expr)))) (print-fixnum (lambda (i) (if (negative? i) (begin (write-char #\-) (print-fixnum (fx* -1 i))) (map (lambda (x) (write-char (fixnum->char (fx+ (char->fixnum #\0) x)))) (integer->list i))))) (print-string (lambda (s) (begin (write-char #\") (for-each write-char (string->list s)) (write-char #\")))) (print-pair (lambda (pr) (begin (write-char #\() (print-pairs pr) (write-char #\))))) (print-pairs (lambda (pr) (begin (write (car pr)) (cond ((null? (cdr pr)) #t) ((pair? (cdr pr)) (begin (write-char #\space) (print-pairs (cdr pr)))) (else (begin (write-char #\space) (write-char #\.) (write-char #\space) (write (cdr pr))))))))) (lambda (expr) (cond ((boolean? expr) (print-boolean expr)) ((null? expr) (print-null)) ((char? expr) (print-char expr)) ((fixnum? expr) (print-fixnum expr)) ((string? expr) (print-string expr)) ((pair? expr) (print-pair expr)) (else (error (quote write) "unrecognized expression")))))
# == uniquify-variables  ==>
# (letrec ((f196019 (lambda (f196035) (begin (write-char #\#) (if f196035 (write-char #\t) (write-char #\f))))) (f196018 (lambda () (begin (write-char #\() (write-char #\))))) (f196017 (lambda (f196034) (begin (write-char #\#) (write-char #\\) (write-char f196034)))) (f196016 (lambda (f196031) (if (negative? f196031) (begin (write-char #\-) (f196016 (fx* -1 f196031))) (map (lambda (f196033) (write-char (fixnum->char (fx+ (char->fixnum #\0) f196033)))) (integer->list f196031))))) (f196015 (lambda (f196030) (begin (write-char #\") (for-each write-char (string->list f196030)) (write-char #\")))) (f196014 (lambda (f196029) (begin (write-char #\() (f196013 f196029) (write-char #\))))) (f196013 (lambda (f196028) (begin (write (car f196028)) (cond ((null? (cdr f196028)) #t) ((pair? (cdr f196028)) (begin (write-char #\space) (f196013 (cdr f196028)))) (else (begin (write-char #\space) (write-char #\.) (write-char #\space) (write (cdr f196028))))))))) (lambda (f196037) (cond ((boolean? f196037) (f196019 f196037)) ((null? f196037) (f196018)) ((char? f196037) (f196017 f196037)) ((fixnum? f196037) (f196016 f196037)) ((string? f196037) (f196015 f196037)) ((pair? f196037) (f196014 f196037)) (else (error (quote write) "unrecognized expression")))))
# == vectorize-letrec  ==>
# (let ((f196019 (make-vector 1)) (f196018 (make-vector 1)) (f196017 (make-vector 1)) (f196016 (make-vector 1)) (f196015 (make-vector 1)) (f196014 (make-vector 1)) (f196013 (make-vector 1))) (begin (begin (vector-set! f196019 0 (lambda (f196035) (begin (write-char #\#) (if f196035 (write-char #\t) (write-char #\f))))) (vector-set! f196018 0 (lambda () (begin (write-char #\() (write-char #\))))) (vector-set! f196017 0 (lambda (f196034) (begin (write-char #\#) (write-char #\\) (write-char f196034)))) (vector-set! f196016 0 (lambda (f196031) (if (negative? f196031) (begin (write-char #\-) ((vector-ref f196016 0) (fx* -1 f196031))) (map (lambda (f196033) (write-char (fixnum->char (fx+ (char->fixnum #\0) f196033)))) (integer->list f196031))))) (vector-set! f196015 0 (lambda (f196030) (begin (write-char #\") (for-each write-char (string->list f196030)) (write-char #\")))) (vector-set! f196014 0 (lambda (f196029) (begin (write-char #\() ((vector-ref f196013 0) f196029) (write-char #\))))) (vector-set! f196013 0 (lambda (f196028) (begin (write (car f196028)) (cond ((null? (cdr f196028)) #t) ((pair? (cdr f196028)) (begin (write-char #\space) ((vector-ref f196013 0) (cdr f196028)))) (else (begin (write-char #\space) (write-char #\.) (write-char #\space) (write (cdr f196028))))))))) (lambda (f196037) (cond ((boolean? f196037) ((vector-ref f196019 0) f196037)) ((null? f196037) ((vector-ref f196018 0))) ((char? f196037) ((vector-ref f196017 0) f196037)) ((fixnum? f196037) ((vector-ref f196016 0) f196037)) ((string? f196037) ((vector-ref f196015 0) f196037)) ((pair? f196037) ((vector-ref f196014 0) f196037)) (else (error (quote write) "unrecognized expression"))))))
# == eliminate-set!  ==>
# (let ((f196019 (make-vector 1)) (f196018 (make-vector 1)) (f196017 (make-vector 1)) (f196016 (make-vector 1)) (f196015 (make-vector 1)) (f196014 (make-vector 1)) (f196013 (make-vector 1))) (begin (begin (vector-set! f196019 0 (lambda (f196035) (let ((f196035 f196035)) (begin (write-char #\#) (if f196035 (write-char #\t) (write-char #\f)))))) (vector-set! f196018 0 (lambda () (let () (begin (write-char #\() (write-char #\)))))) (vector-set! f196017 0 (lambda (f196034) (let ((f196034 f196034)) (begin (write-char #\#) (write-char #\\) (write-char f196034))))) (vector-set! f196016 0 (lambda (f196031) (let ((f196031 f196031)) (if (negative? f196031) (begin (write-char #\-) ((vector-ref f196016 0) (fx* -1 f196031))) (map (lambda (f196033) (let ((f196033 f196033)) (write-char (fixnum->char (fx+ (char->fixnum #\0) f196033))))) (integer->list f196031)))))) (vector-set! f196015 0 (lambda (f196030) (let ((f196030 f196030)) (begin (write-char #\") (for-each write-char (string->list f196030)) (write-char #\"))))) (vector-set! f196014 0 (lambda (f196029) (let ((f196029 f196029)) (begin (write-char #\() ((vector-ref f196013 0) f196029) (write-char #\)))))) (vector-set! f196013 0 (lambda (f196028) (let ((f196028 f196028)) (begin (write (car f196028)) (cond ((null? (cdr f196028)) #t) ((pair? (cdr f196028)) (begin (write-char #\space) ((vector-ref f196013 0) (cdr f196028)))) (else (begin (write-char #\space) (write-char #\.) (write-char #\space) (write (cdr f196028)))))))))) (lambda (f196037) (let ((f196037 f196037)) (cond ((boolean? f196037) ((vector-ref f196019 0) f196037)) ((null? f196037) ((vector-ref f196018 0))) ((char? f196037) ((vector-ref f196017 0) f196037)) ((fixnum? f196037) ((vector-ref f196016 0) f196037)) ((string? f196037) ((vector-ref f196015 0) f196037)) ((pair? f196037) ((vector-ref f196014 0) f196037)) (else (error (quote write) "unrecognized expression")))))))
# == close-free-variables  ==>
# (let ((f196019 (make-vector 1)) (f196018 (make-vector 1)) (f196017 (make-vector 1)) (f196016 (make-vector 1)) (f196015 (make-vector 1)) (f196014 (make-vector 1)) (f196013 (make-vector 1))) (begin (begin (vector-set! f196019 0 (closure (f196035) (write-char write-char write-char) (let ((f196035 f196035)) (begin (write-char #\#) (if f196035 (write-char #\t) (write-char #\f)))))) (vector-set! f196018 0 (closure () (write-char write-char) (let () (begin (write-char #\() (write-char #\)))))) (vector-set! f196017 0 (closure (f196034) (write-char write-char write-char) (let ((f196034 f196034)) (begin (write-char #\#) (write-char #\\) (write-char f196034))))) (vector-set! f196016 0 (closure (f196031) (negative? write-char f196016 map write-char integer->list) (let ((f196031 f196031)) (if (negative? f196031) (begin (write-char #\-) ((vector-ref f196016 0) (fx* -1 f196031))) (map (closure (f196033) (write-char) (let ((f196033 f196033)) (write-char (fixnum->char (fx+ (char->fixnum #\0) f196033))))) (integer->list f196031)))))) (vector-set! f196015 0 (closure (f196030) (write-char for-each write-char string->list write-char) (let ((f196030 f196030)) (begin (write-char #\") (for-each write-char (string->list f196030)) (write-char #\"))))) (vector-set! f196014 0 (closure (f196029) (write-char f196013 write-char) (let ((f196029 f196029)) (begin (write-char #\() ((vector-ref f196013 0) f196029) (write-char #\)))))) (vector-set! f196013 0 (closure (f196028) (write write-char f196013 else write-char write-char write-char write) (let ((f196028 f196028)) (begin (write (car f196028)) (cond ((null? (cdr f196028)) #t) ((pair? (cdr f196028)) (begin (write-char #\space) ((vector-ref f196013 0) (cdr f196028)))) (else (begin (write-char #\space) (write-char #\.) (write-char #\space) (write (cdr f196028)))))))))) (closure (f196037) (f196019 f196018 f196017 f196016 f196015 f196014 else error write) (let ((f196037 f196037)) (cond ((boolean? f196037) ((vector-ref f196019 0) f196037)) ((null? f196037) ((vector-ref f196018 0))) ((char? f196037) ((vector-ref f196017 0) f196037)) ((fixnum? f196037) ((vector-ref f196016 0) f196037)) ((string? f196037) ((vector-ref f196015 0) f196037)) ((pair? f196037) ((vector-ref f196014 0) f196037)) (else (error (quote write) "unrecognized expression")))))))
# == eliminate-quote  ==>
# (let ((f196019 (make-vector 1)) (f196018 (make-vector 1)) (f196017 (make-vector 1)) (f196016 (make-vector 1)) (f196015 (make-vector 1)) (f196014 (make-vector 1)) (f196013 (make-vector 1))) (begin (begin (vector-set! f196019 0 (closure (f196035) (write-char write-char write-char) (let ((f196035 f196035)) (begin (write-char #\#) (if f196035 (write-char #\t) (write-char #\f)))))) (vector-set! f196018 0 (closure () (write-char write-char) (let () (begin (write-char #\() (write-char #\)))))) (vector-set! f196017 0 (closure (f196034) (write-char write-char write-char) (let ((f196034 f196034)) (begin (write-char #\#) (write-char #\\) (write-char f196034))))) (vector-set! f196016 0 (closure (f196031) (negative? write-char f196016 map write-char integer->list) (let ((f196031 f196031)) (if (negative? f196031) (begin (write-char #\-) ((vector-ref f196016 0) (fx* -1 f196031))) (map (closure (f196033) (write-char) (let ((f196033 f196033)) (write-char (fixnum->char (fx+ (char->fixnum #\0) f196033))))) (integer->list f196031)))))) (vector-set! f196015 0 (closure (f196030) (write-char for-each write-char string->list write-char) (let ((f196030 f196030)) (begin (write-char #\") (for-each write-char (string->list f196030)) (write-char #\"))))) (vector-set! f196014 0 (closure (f196029) (write-char f196013 write-char) (let ((f196029 f196029)) (begin (write-char #\() ((vector-ref f196013 0) f196029) (write-char #\)))))) (vector-set! f196013 0 (closure (f196028) (write write-char f196013 else write-char write-char write-char write) (let ((f196028 f196028)) (begin (write (car f196028)) (cond ((null? (cdr f196028)) #t) ((pair? (cdr f196028)) (begin (write-char #\space) ((vector-ref f196013 0) (cdr f196028)))) (else (begin (write-char #\space) (write-char #\.) (write-char #\space) (write (cdr f196028)))))))))) (closure (f196037) (f196019 f196018 f196017 f196016 f196015 f196014 else error write) (let ((f196037 f196037)) (cond ((boolean? f196037) ((vector-ref f196019 0) f196037)) ((null? f196037) ((vector-ref f196018 0))) ((char? f196037) ((vector-ref f196017 0) f196037)) ((fixnum? f196037) ((vector-ref f196016 0) f196037)) ((string? f196037) ((vector-ref f196015 0) f196037)) ((pair? f196037) ((vector-ref f196014 0) f196037)) (else (error (string->symbol "write") "unrecognized expression")))))))
# == eliminate-when/unless  ==>
# (let ((f196019 (make-vector 1)) (f196018 (make-vector 1)) (f196017 (make-vector 1)) (f196016 (make-vector 1)) (f196015 (make-vector 1)) (f196014 (make-vector 1)) (f196013 (make-vector 1))) (begin (begin (vector-set! f196019 0 (closure (f196035) (write-char write-char write-char) (let ((f196035 f196035)) (begin (write-char #\#) (if f196035 (write-char #\t) (write-char #\f)))))) (vector-set! f196018 0 (closure () (write-char write-char) (let () (begin (write-char #\() (write-char #\)))))) (vector-set! f196017 0 (closure (f196034) (write-char write-char write-char) (let ((f196034 f196034)) (begin (write-char #\#) (write-char #\\) (write-char f196034))))) (vector-set! f196016 0 (closure (f196031) (negative? write-char f196016 map write-char integer->list) (let ((f196031 f196031)) (if (negative? f196031) (begin (write-char #\-) ((vector-ref f196016 0) (fx* -1 f196031))) (map (closure (f196033) (write-char) (let ((f196033 f196033)) (write-char (fixnum->char (fx+ (char->fixnum #\0) f196033))))) (integer->list f196031)))))) (vector-set! f196015 0 (closure (f196030) (write-char for-each write-char string->list write-char) (let ((f196030 f196030)) (begin (write-char #\") (for-each write-char (string->list f196030)) (write-char #\"))))) (vector-set! f196014 0 (closure (f196029) (write-char f196013 write-char) (let ((f196029 f196029)) (begin (write-char #\() ((vector-ref f196013 0) f196029) (write-char #\)))))) (vector-set! f196013 0 (closure (f196028) (write write-char f196013 else write-char write-char write-char write) (let ((f196028 f196028)) (begin (write (car f196028)) (cond ((null? (cdr f196028)) #t) ((pair? (cdr f196028)) (begin (write-char #\space) ((vector-ref f196013 0) (cdr f196028)))) (else (begin (write-char #\space) (write-char #\.) (write-char #\space) (write (cdr f196028)))))))))) (closure (f196037) (f196019 f196018 f196017 f196016 f196015 f196014 else error write) (let ((f196037 f196037)) (cond ((boolean? f196037) ((vector-ref f196019 0) f196037)) ((null? f196037) ((vector-ref f196018 0))) ((char? f196037) ((vector-ref f196017 0) f196037)) ((fixnum? f196037) ((vector-ref f196016 0) f196037)) ((string? f196037) ((vector-ref f196015 0) f196037)) ((pair? f196037) ((vector-ref f196014 0) f196037)) (else (error (string->symbol "write") "unrecognized expression")))))))
# == eliminate-cond  ==>
# (let ((f196019 (make-vector 1)) (f196018 (make-vector 1)) (f196017 (make-vector 1)) (f196016 (make-vector 1)) (f196015 (make-vector 1)) (f196014 (make-vector 1)) (f196013 (make-vector 1))) (begin (begin (vector-set! f196019 0 (closure (f196035) (write-char write-char write-char) (let ((f196035 f196035)) (begin (write-char #\#) (if f196035 (write-char #\t) (write-char #\f)))))) (vector-set! f196018 0 (closure () (write-char write-char) (let () (begin (write-char #\() (write-char #\)))))) (vector-set! f196017 0 (closure (f196034) (write-char write-char write-char) (let ((f196034 f196034)) (begin (write-char #\#) (write-char #\\) (write-char f196034))))) (vector-set! f196016 0 (closure (f196031) (negative? write-char f196016 map write-char integer->list) (let ((f196031 f196031)) (if (negative? f196031) (begin (write-char #\-) ((vector-ref f196016 0) (fx* -1 f196031))) (map (closure (f196033) (write-char) (let ((f196033 f196033)) (write-char (fixnum->char (fx+ (char->fixnum #\0) f196033))))) (integer->list f196031)))))) (vector-set! f196015 0 (closure (f196030) (write-char for-each write-char string->list write-char) (let ((f196030 f196030)) (begin (write-char #\") (for-each write-char (string->list f196030)) (write-char #\"))))) (vector-set! f196014 0 (closure (f196029) (write-char f196013 write-char) (let ((f196029 f196029)) (begin (write-char #\() ((vector-ref f196013 0) f196029) (write-char #\)))))) (vector-set! f196013 0 (closure (f196028) (write write-char f196013 else write-char write-char write-char write) (let ((f196028 f196028)) (begin (write (car f196028)) (if (null? (cdr f196028)) #t (if (pair? (cdr f196028)) (begin (write-char #\space) ((vector-ref f196013 0) (cdr f196028))) (begin (write-char #\space) (write-char #\.) (write-char #\space) (write (cdr f196028)))))))))) (closure (f196037) (f196019 f196018 f196017 f196016 f196015 f196014 else error write) (let ((f196037 f196037)) (if (boolean? f196037) ((vector-ref f196019 0) f196037) (if (null? f196037) ((vector-ref f196018 0)) (if (char? f196037) ((vector-ref f196017 0) f196037) (if (fixnum? f196037) ((vector-ref f196016 0) f196037) (if (string? f196037) ((vector-ref f196015 0) f196037) (if (pair? f196037) ((vector-ref f196014 0) f196037) (error (string->symbol "write") "unrecognized expression")))))))))))
# == external-symbols  ==>
# (let ((f196019 (make-vector 1)) (f196018 (make-vector 1)) (f196017 (make-vector 1)) (f196016 (make-vector 1)) (f196015 (make-vector 1)) (f196014 (make-vector 1)) (f196013 (make-vector 1))) (begin (begin (vector-set! f196019 0 (closure (f196035) ((primitive-ref write-char) (primitive-ref write-char) (primitive-ref write-char)) (let ((f196035 f196035)) (begin ((primitive-ref write-char) #\#) (if f196035 ((primitive-ref write-char) #\t) ((primitive-ref write-char) #\f)))))) (vector-set! f196018 0 (closure () ((primitive-ref write-char) (primitive-ref write-char)) (let () (begin ((primitive-ref write-char) #\() ((primitive-ref write-char) #\)))))) (vector-set! f196017 0 (closure (f196034) ((primitive-ref write-char) (primitive-ref write-char) (primitive-ref write-char)) (let ((f196034 f196034)) (begin ((primitive-ref write-char) #\#) ((primitive-ref write-char) #\\) ((primitive-ref write-char) f196034))))) (vector-set! f196016 0 (closure (f196031) ((primitive-ref negative?) (primitive-ref write-char) f196016 (primitive-ref map) (primitive-ref write-char) (primitive-ref integer->list)) (let ((f196031 f196031)) (if ((primitive-ref negative?) f196031) (begin ((primitive-ref write-char) #\-) ((vector-ref f196016 0) (fx* -1 f196031))) ((primitive-ref map) (closure (f196033) ((primitive-ref write-char)) (let ((f196033 f196033)) ((primitive-ref write-char) (fixnum->char (fx+ (char->fixnum #\0) f196033))))) ((primitive-ref integer->list) f196031)))))) (vector-set! f196015 0 (closure (f196030) ((primitive-ref write-char) (primitive-ref for-each) (primitive-ref write-char) (primitive-ref string->list) (primitive-ref write-char)) (let ((f196030 f196030)) (begin ((primitive-ref write-char) #\") ((primitive-ref for-each) (primitive-ref write-char) ((primitive-ref string->list) f196030)) ((primitive-ref write-char) #\"))))) (vector-set! f196014 0 (closure (f196029) ((primitive-ref write-char) f196013 (primitive-ref write-char)) (let ((f196029 f196029)) (begin ((primitive-ref write-char) #\() ((vector-ref f196013 0) f196029) ((primitive-ref write-char) #\)))))) (vector-set! f196013 0 (closure (f196028) ((primitive-ref write) (primitive-ref write-char) f196013 else (primitive-ref write-char) (primitive-ref write-char) (primitive-ref write-char) (primitive-ref write)) (let ((f196028 f196028)) (begin ((primitive-ref write) (car f196028)) (if (null? (cdr f196028)) #t (if (pair? (cdr f196028)) (begin ((primitive-ref write-char) #\space) ((vector-ref f196013 0) (cdr f196028))) (begin ((primitive-ref write-char) #\space) ((primitive-ref write-char) #\.) ((primitive-ref write-char) #\space) ((primitive-ref write) (cdr f196028)))))))))) (closure (f196037) (f196019 f196018 f196017 f196016 f196015 f196014 else (primitive-ref error) (primitive-ref write)) (let ((f196037 f196037)) (if (boolean? f196037) ((vector-ref f196019 0) f196037) (if (null? f196037) ((vector-ref f196018 0)) (if (char? f196037) ((vector-ref f196017 0) f196037) (if (fixnum? f196037) ((vector-ref f196016 0) f196037) (if (string? f196037) ((vector-ref f196015 0) f196037) (if (pair? f196037) ((vector-ref f196014 0) f196037) ((primitive-ref error) ((primitive-ref string->symbol) "write") "unrecognized expression")))))))))))
# emit-expr (let ((f196019 (make-vector 1)) (f196018 (make-vector 1)) (f196017 (make-vector 1)) (f196016 (make-vector 1)) (f196015 (make-vector 1)) (f196014 (make-vector 1)) (f196013 (make-vector 1))) (begin (begin (vector-set! f196019 0 (closure (f196035) ((primitive-ref write-char) (primitive-ref write-char) (primitive-ref write-char)) (let ((f196035 f196035)) (begin ((primitive-ref write-char) #\#) (if f196035 ((primitive-ref write-char) #\t) ((primitive-ref write-char) #\f)))))) (vector-set! f196018 0 (closure () ((primitive-ref write-char) (primitive-ref write-char)) (let () (begin ((primitive-ref write-char) #\() ((primitive-ref write-char) #\)))))) (vector-set! f196017 0 (closure (f196034) ((primitive-ref write-char) (primitive-ref write-char) (primitive-ref write-char)) (let ((f196034 f196034)) (begin ((primitive-ref write-char) #\#) ((primitive-ref write-char) #\\) ((primitive-ref write-char) f196034))))) (vector-set! f196016 0 (closure (f196031) ((primitive-ref negative?) (primitive-ref write-char) f196016 (primitive-ref map) (primitive-ref write-char) (primitive-ref integer->list)) (let ((f196031 f196031)) (if ((primitive-ref negative?) f196031) (begin ((primitive-ref write-char) #\-) ((vector-ref f196016 0) (fx* -1 f196031))) ((primitive-ref map) (closure (f196033) ((primitive-ref write-char)) (let ((f196033 f196033)) ((primitive-ref write-char) (fixnum->char (fx+ (char->fixnum #\0) f196033))))) ((primitive-ref integer->list) f196031)))))) (vector-set! f196015 0 (closure (f196030) ((primitive-ref write-char) (primitive-ref for-each) (primitive-ref write-char) (primitive-ref string->list) (primitive-ref write-char)) (let ((f196030 f196030)) (begin ((primitive-ref write-char) #\") ((primitive-ref for-each) (primitive-ref write-char) ((primitive-ref string->list) f196030)) ((primitive-ref write-char) #\"))))) (vector-set! f196014 0 (closure (f196029) ((primitive-ref write-char) f196013 (primitive-ref write-char)) (let ((f196029 f196029)) (begin ((primitive-ref write-char) #\() ((vector-ref f196013 0) f196029) ((primitive-ref write-char) #\)))))) (vector-set! f196013 0 (closure (f196028) ((primitive-ref write) (primitive-ref write-char) f196013 else (primitive-ref write-char) (primitive-ref write-char) (primitive-ref write-char) (primitive-ref write)) (let ((f196028 f196028)) (begin ((primitive-ref write) (car f196028)) (if (null? (cdr f196028)) #t (if (pair? (cdr f196028)) (begin ((primitive-ref write-char) #\space) ((vector-ref f196013 0) (cdr f196028))) (begin ((primitive-ref write-char) #\space) ((primitive-ref write-char) #\.) ((primitive-ref write-char) #\space) ((primitive-ref write) (cdr f196028)))))))))) (closure (f196037) (f196019 f196018 f196017 f196016 f196015 f196014 else (primitive-ref error) (primitive-ref write)) (let ((f196037 f196037)) (if (boolean? f196037) ((vector-ref f196019 0) f196037) (if (null? f196037) ((vector-ref f196018 0)) (if (char? f196037) ((vector-ref f196017 0) f196037) (if (fixnum? f196037) ((vector-ref f196016 0) f196037) (if (string? f196037) ((vector-ref f196015 0) f196037) (if (pair? f196037) ((vector-ref f196014 0) f196037) ((primitive-ref error) ((primitive-ref string->symbol) "write") "unrecognized expression")))))))))))
# emit-let
#  si   = 0
#  env  = ()
#  bindings = ((f196019 (make-vector 1)) (f196018 (make-vector 1)) (f196017 (make-vector 1)) (f196016 (make-vector 1)) (f196015 (make-vector 1)) (f196014 (make-vector 1)) (f196013 (make-vector 1)))
#  body = (begin (begin (vector-set! f196019 0 (closure (f196035) ((primitive-ref write-char) (primitive-ref write-char) (primitive-ref write-char)) (let ((f196035 f196035)) (begin ((primitive-ref write-char) #\#) (if f196035 ((primitive-ref write-char) #\t) ((primitive-ref write-char) #\f)))))) (vector-set! f196018 0 (closure () ((primitive-ref write-char) (primitive-ref write-char)) (let () (begin ((primitive-ref write-char) #\() ((primitive-ref write-char) #\)))))) (vector-set! f196017 0 (closure (f196034) ((primitive-ref write-char) (primitive-ref write-char) (primitive-ref write-char)) (let ((f196034 f196034)) (begin ((primitive-ref write-char) #\#) ((primitive-ref write-char) #\\) ((primitive-ref write-char) f196034))))) (vector-set! f196016 0 (closure (f196031) ((primitive-ref negative?) (primitive-ref write-char) f196016 (primitive-ref map) (primitive-ref write-char) (primitive-ref integer->list)) (let ((f196031 f196031)) (if ((primitive-ref negative?) f196031) (begin ((primitive-ref write-char) #\-) ((vector-ref f196016 0) (fx* -1 f196031))) ((primitive-ref map) (closure (f196033) ((primitive-ref write-char)) (let ((f196033 f196033)) ((primitive-ref write-char) (fixnum->char (fx+ (char->fixnum #\0) f196033))))) ((primitive-ref integer->list) f196031)))))) (vector-set! f196015 0 (closure (f196030) ((primitive-ref write-char) (primitive-ref for-each) (primitive-ref write-char) (primitive-ref string->list) (primitive-ref write-char)) (let ((f196030 f196030)) (begin ((primitive-ref write-char) #\") ((primitive-ref for-each) (primitive-ref write-char) ((primitive-ref string->list) f196030)) ((primitive-ref write-char) #\"))))) (vector-set! f196014 0 (closure (f196029) ((primitive-ref write-char) f196013 (primitive-ref write-char)) (let ((f196029 f196029)) (begin ((primitive-ref write-char) #\() ((vector-ref f196013 0) f196029) ((primitive-ref write-char) #\)))))) (vector-set! f196013 0 (closure (f196028) ((primitive-ref write) (primitive-ref write-char) f196013 else (primitive-ref write-char) (primitive-ref write-char) (primitive-ref write-char) (primitive-ref write)) (let ((f196028 f196028)) (begin ((primitive-ref write) (car f196028)) (if (null? (cdr f196028)) #t (if (pair? (cdr f196028)) (begin ((primitive-ref write-char) #\space) ((vector-ref f196013 0) (cdr f196028))) (begin ((primitive-ref write-char) #\space) ((primitive-ref write-char) #\.) ((primitive-ref write-char) #\space) ((primitive-ref write) (cdr f196028)))))))))) (closure (f196037) (f196019 f196018 f196017 f196016 f196015 f196014 else (primitive-ref error) (primitive-ref write)) (let ((f196037 f196037)) (if (boolean? f196037) ((vector-ref f196019 0) f196037) (if (null? f196037) ((vector-ref f196018 0)) (if (char? f196037) ((vector-ref f196017 0) f196037) (if (fixnum? f196037) ((vector-ref f196016 0) f196037) (if (string? f196037) ((vector-ref f196015 0) f196037) (if (pair? f196037) ((vector-ref f196014 0) f196037) ((primitive-ref error) ((primitive-ref string->symbol) "write") "unrecognized expression"))))))))))
# emit-expr (make-vector 1)
# make-vector 1
# emit-expr 1
    movl $4, %eax     # immed 1
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1432565"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $128,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1432565:
# check the argument is a fixnum >= 0
    cmp $0,%eax
    jge _L_1432566
# invoke error handler eh_length
    .extern mrc_eh$ulength
    movl mrc_eh$ulength, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $128,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1432566:
    movl %eax, %esi
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    orl  $5, %eax
    addl $4, %esi
    addl $4, %esi
    andl $-8, %esi
    addl %esi, %ebp
    movl %eax, 0(%esp)  # stack save
# emit-expr (make-vector 1)
# make-vector 1
# emit-expr 1
    movl $4, %eax     # immed 1
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1432567"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $128,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1432567:
# check the argument is a fixnum >= 0
    cmp $0,%eax
    jge _L_1432568
# invoke error handler eh_length
    .extern mrc_eh$ulength
    movl mrc_eh$ulength, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $128,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1432568:
    movl %eax, %esi
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    orl  $5, %eax
    addl $4, %esi
    addl $4, %esi
    andl $-8, %esi
    addl %esi, %ebp
    movl %eax, -4(%esp)  # stack save
# emit-expr (make-vector 1)
# make-vector 1
# emit-expr 1
    movl $4, %eax     # immed 1
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1432569"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $128,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1432569:
# check the argument is a fixnum >= 0
    cmp $0,%eax
    jge _L_1432570
# invoke error handler eh_length
    .extern mrc_eh$ulength
    movl mrc_eh$ulength, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $128,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1432570:
    movl %eax, %esi
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    orl  $5, %eax
    addl $4, %esi
    addl $4, %esi
    andl $-8, %esi
    addl %esi, %ebp
    movl %eax, -8(%esp)  # stack save
# emit-expr (make-vector 1)
# make-vector 1
# emit-expr 1
    movl $4, %eax     # immed 1
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1432571"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $128,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1432571:
# check the argument is a fixnum >= 0
    cmp $0,%eax
    jge _L_1432572
# invoke error handler eh_length
    .extern mrc_eh$ulength
    movl mrc_eh$ulength, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $128,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1432572:
    movl %eax, %esi
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    orl  $5, %eax
    addl $4, %esi
    addl $4, %esi
    andl $-8, %esi
    addl %esi, %ebp
    movl %eax, -12(%esp)  # stack save
# emit-expr (make-vector 1)
# make-vector 1
# emit-expr 1
    movl $4, %eax     # immed 1
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1432573"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $128,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1432573:
# check the argument is a fixnum >= 0
    cmp $0,%eax
    jge _L_1432574
# invoke error handler eh_length
    .extern mrc_eh$ulength
    movl mrc_eh$ulength, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $128,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1432574:
    movl %eax, %esi
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    orl  $5, %eax
    addl $4, %esi
    addl $4, %esi
    andl $-8, %esi
    addl %esi, %ebp
    movl %eax, -16(%esp)  # stack save
# emit-expr (make-vector 1)
# make-vector 1
# emit-expr 1
    movl $4, %eax     # immed 1
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1432575"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $128,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1432575:
# check the argument is a fixnum >= 0
    cmp $0,%eax
    jge _L_1432576
# invoke error handler eh_length
    .extern mrc_eh$ulength
    movl mrc_eh$ulength, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $128,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1432576:
    movl %eax, %esi
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    orl  $5, %eax
    addl $4, %esi
    addl $4, %esi
    andl $-8, %esi
    addl %esi, %ebp
    movl %eax, -20(%esp)  # stack save
# emit-expr (make-vector 1)
# make-vector 1
# emit-expr 1
    movl $4, %eax     # immed 1
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1432577"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $128,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1432577:
# check the argument is a fixnum >= 0
    cmp $0,%eax
    jge _L_1432578
# invoke error handler eh_length
    .extern mrc_eh$ulength
    movl mrc_eh$ulength, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $128,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1432578:
    movl %eax, %esi
    movl %eax, 0(%ebp)
    movl %ebp, %eax
    orl  $5, %eax
    addl $4, %esi
    addl $4, %esi
    andl $-8, %esi
    addl %esi, %ebp
    movl %eax, -24(%esp)  # stack save
# emit-expr (begin (begin (vector-set! f196019 0 (closure (f196035) ((primitive-ref write-char) (primitive-ref write-char) (primitive-ref write-char)) (let ((f196035 f196035)) (begin ((primitive-ref write-char) #\#) (if f196035 ((primitive-ref write-char) #\t) ((primitive-ref write-char) #\f)))))) (vector-set! f196018 0 (closure () ((primitive-ref write-char) (primitive-ref write-char)) (let () (begin ((primitive-ref write-char) #\() ((primitive-ref write-char) #\)))))) (vector-set! f196017 0 (closure (f196034) ((primitive-ref write-char) (primitive-ref write-char) (primitive-ref write-char)) (let ((f196034 f196034)) (begin ((primitive-ref write-char) #\#) ((primitive-ref write-char) #\\) ((primitive-ref write-char) f196034))))) (vector-set! f196016 0 (closure (f196031) ((primitive-ref negative?) (primitive-ref write-char) f196016 (primitive-ref map) (primitive-ref write-char) (primitive-ref integer->list)) (let ((f196031 f196031)) (if ((primitive-ref negative?) f196031) (begin ((primitive-ref write-char) #\-) ((vector-ref f196016 0) (fx* -1 f196031))) ((primitive-ref map) (closure (f196033) ((primitive-ref write-char)) (let ((f196033 f196033)) ((primitive-ref write-char) (fixnum->char (fx+ (char->fixnum #\0) f196033))))) ((primitive-ref integer->list) f196031)))))) (vector-set! f196015 0 (closure (f196030) ((primitive-ref write-char) (primitive-ref for-each) (primitive-ref write-char) (primitive-ref string->list) (primitive-ref write-char)) (let ((f196030 f196030)) (begin ((primitive-ref write-char) #\") ((primitive-ref for-each) (primitive-ref write-char) ((primitive-ref string->list) f196030)) ((primitive-ref write-char) #\"))))) (vector-set! f196014 0 (closure (f196029) ((primitive-ref write-char) f196013 (primitive-ref write-char)) (let ((f196029 f196029)) (begin ((primitive-ref write-char) #\() ((vector-ref f196013 0) f196029) ((primitive-ref write-char) #\)))))) (vector-set! f196013 0 (closure (f196028) ((primitive-ref write) (primitive-ref write-char) f196013 else (primitive-ref write-char) (primitive-ref write-char) (primitive-ref write-char) (primitive-ref write)) (let ((f196028 f196028)) (begin ((primitive-ref write) (car f196028)) (if (null? (cdr f196028)) #t (if (pair? (cdr f196028)) (begin ((primitive-ref write-char) #\space) ((vector-ref f196013 0) (cdr f196028))) (begin ((primitive-ref write-char) #\space) ((primitive-ref write-char) #\.) ((primitive-ref write-char) #\space) ((primitive-ref write) (cdr f196028)))))))))) (closure (f196037) (f196019 f196018 f196017 f196016 f196015 f196014 else (primitive-ref error) (primitive-ref write)) (let ((f196037 f196037)) (if (boolean? f196037) ((vector-ref f196019 0) f196037) (if (null? f196037) ((vector-ref f196018 0)) (if (char? f196037) ((vector-ref f196017 0) f196037) (if (fixnum? f196037) ((vector-ref f196016 0) f196037) (if (string? f196037) ((vector-ref f196015 0) f196037) (if (pair? f196037) ((vector-ref f196014 0) f196037) ((primitive-ref error) ((primitive-ref string->symbol) "write") "unrecognized expression"))))))))))
# emit-begin
#   expr=(begin (begin (vector-set! f196019 0 (closure (f196035) ((primitive-ref write-char) (primitive-ref write-char) (primitive-ref write-char)) (let ((f196035 f196035)) (begin ((primitive-ref write-char) #\#) (if f196035 ((primitive-ref write-char) #\t) ((primitive-ref write-char) #\f)))))) (vector-set! f196018 0 (closure () ((primitive-ref write-char) (primitive-ref write-char)) (let () (begin ((primitive-ref write-char) #\() ((primitive-ref write-char) #\)))))) (vector-set! f196017 0 (closure (f196034) ((primitive-ref write-char) (primitive-ref write-char) (primitive-ref write-char)) (let ((f196034 f196034)) (begin ((primitive-ref write-char) #\#) ((primitive-ref write-char) #\\) ((primitive-ref write-char) f196034))))) (vector-set! f196016 0 (closure (f196031) ((primitive-ref negative?) (primitive-ref write-char) f196016 (primitive-ref map) (primitive-ref write-char) (primitive-ref integer->list)) (let ((f196031 f196031)) (if ((primitive-ref negative?) f196031) (begin ((primitive-ref write-char) #\-) ((vector-ref f196016 0) (fx* -1 f196031))) ((primitive-ref map) (closure (f196033) ((primitive-ref write-char)) (let ((f196033 f196033)) ((primitive-ref write-char) (fixnum->char (fx+ (char->fixnum #\0) f196033))))) ((primitive-ref integer->list) f196031)))))) (vector-set! f196015 0 (closure (f196030) ((primitive-ref write-char) (primitive-ref for-each) (primitive-ref write-char) (primitive-ref string->list) (primitive-ref write-char)) (let ((f196030 f196030)) (begin ((primitive-ref write-char) #\") ((primitive-ref for-each) (primitive-ref write-char) ((primitive-ref string->list) f196030)) ((primitive-ref write-char) #\"))))) (vector-set! f196014 0 (closure (f196029) ((primitive-ref write-char) f196013 (primitive-ref write-char)) (let ((f196029 f196029)) (begin ((primitive-ref write-char) #\() ((vector-ref f196013 0) f196029) ((primitive-ref write-char) #\)))))) (vector-set! f196013 0 (closure (f196028) ((primitive-ref write) (primitive-ref write-char) f196013 else (primitive-ref write-char) (primitive-ref write-char) (primitive-ref write-char) (primitive-ref write)) (let ((f196028 f196028)) (begin ((primitive-ref write) (car f196028)) (if (null? (cdr f196028)) #t (if (pair? (cdr f196028)) (begin ((primitive-ref write-char) #\space) ((vector-ref f196013 0) (cdr f196028))) (begin ((primitive-ref write-char) #\space) ((primitive-ref write-char) #\.) ((primitive-ref write-char) #\space) ((primitive-ref write) (cdr f196028)))))))))) (closure (f196037) (f196019 f196018 f196017 f196016 f196015 f196014 else (primitive-ref error) (primitive-ref write)) (let ((f196037 f196037)) (if (boolean? f196037) ((vector-ref f196019 0) f196037) (if (null? f196037) ((vector-ref f196018 0)) (if (char? f196037) ((vector-ref f196017 0) f196037) (if (fixnum? f196037) ((vector-ref f196016 0) f196037) (if (string? f196037) ((vector-ref f196015 0) f196037) (if (pair? f196037) ((vector-ref f196014 0) f196037) ((primitive-ref error) ((primitive-ref string->symbol) "write") "unrecognized expression"))))))))))
#   env=((f196013 . -24) (f196014 . -20) (f196015 . -16) (f196016 . -12) (f196017 . -8) (f196018 . -4) (f196019 . 0))
# emit-expr (begin (vector-set! f196019 0 (closure (f196035) ((primitive-ref write-char) (primitive-ref write-char) (primitive-ref write-char)) (let ((f196035 f196035)) (begin ((primitive-ref write-char) #\#) (if f196035 ((primitive-ref write-char) #\t) ((primitive-ref write-char) #\f)))))) (vector-set! f196018 0 (closure () ((primitive-ref write-char) (primitive-ref write-char)) (let () (begin ((primitive-ref write-char) #\() ((primitive-ref write-char) #\)))))) (vector-set! f196017 0 (closure (f196034) ((primitive-ref write-char) (primitive-ref write-char) (primitive-ref write-char)) (let ((f196034 f196034)) (begin ((primitive-ref write-char) #\#) ((primitive-ref write-char) #\\) ((primitive-ref write-char) f196034))))) (vector-set! f196016 0 (closure (f196031) ((primitive-ref negative?) (primitive-ref write-char) f196016 (primitive-ref map) (primitive-ref write-char) (primitive-ref integer->list)) (let ((f196031 f196031)) (if ((primitive-ref negative?) f196031) (begin ((primitive-ref write-char) #\-) ((vector-ref f196016 0) (fx* -1 f196031))) ((primitive-ref map) (closure (f196033) ((primitive-ref write-char)) (let ((f196033 f196033)) ((primitive-ref write-char) (fixnum->char (fx+ (char->fixnum #\0) f196033))))) ((primitive-ref integer->list) f196031)))))) (vector-set! f196015 0 (closure (f196030) ((primitive-ref write-char) (primitive-ref for-each) (primitive-ref write-char) (primitive-ref string->list) (primitive-ref write-char)) (let ((f196030 f196030)) (begin ((primitive-ref write-char) #\") ((primitive-ref for-each) (primitive-ref write-char) ((primitive-ref string->list) f196030)) ((primitive-ref write-char) #\"))))) (vector-set! f196014 0 (closure (f196029) ((primitive-ref write-char) f196013 (primitive-ref write-char)) (let ((f196029 f196029)) (begin ((primitive-ref write-char) #\() ((vector-ref f196013 0) f196029) ((primitive-ref write-char) #\)))))) (vector-set! f196013 0 (closure (f196028) ((primitive-ref write) (primitive-ref write-char) f196013 else (primitive-ref write-char) (primitive-ref write-char) (primitive-ref write-char) (primitive-ref write)) (let ((f196028 f196028)) (begin ((primitive-ref write) (car f196028)) (if (null? (cdr f196028)) #t (if (pair? (cdr f196028)) (begin ((primitive-ref write-char) #\space) ((vector-ref f196013 0) (cdr f196028))) (begin ((primitive-ref write-char) #\space) ((primitive-ref write-char) #\.) ((primitive-ref write-char) #\space) ((primitive-ref write) (cdr f196028))))))))))
# emit-begin
#   expr=(begin (vector-set! f196019 0 (closure (f196035) ((primitive-ref write-char) (primitive-ref write-char) (primitive-ref write-char)) (let ((f196035 f196035)) (begin ((primitive-ref write-char) #\#) (if f196035 ((primitive-ref write-char) #\t) ((primitive-ref write-char) #\f)))))) (vector-set! f196018 0 (closure () ((primitive-ref write-char) (primitive-ref write-char)) (let () (begin ((primitive-ref write-char) #\() ((primitive-ref write-char) #\)))))) (vector-set! f196017 0 (closure (f196034) ((primitive-ref write-char) (primitive-ref write-char) (primitive-ref write-char)) (let ((f196034 f196034)) (begin ((primitive-ref write-char) #\#) ((primitive-ref write-char) #\\) ((primitive-ref write-char) f196034))))) (vector-set! f196016 0 (closure (f196031) ((primitive-ref negative?) (primitive-ref write-char) f196016 (primitive-ref map) (primitive-ref write-char) (primitive-ref integer->list)) (let ((f196031 f196031)) (if ((primitive-ref negative?) f196031) (begin ((primitive-ref write-char) #\-) ((vector-ref f196016 0) (fx* -1 f196031))) ((primitive-ref map) (closure (f196033) ((primitive-ref write-char)) (let ((f196033 f196033)) ((primitive-ref write-char) (fixnum->char (fx+ (char->fixnum #\0) f196033))))) ((primitive-ref integer->list) f196031)))))) (vector-set! f196015 0 (closure (f196030) ((primitive-ref write-char) (primitive-ref for-each) (primitive-ref write-char) (primitive-ref string->list) (primitive-ref write-char)) (let ((f196030 f196030)) (begin ((primitive-ref write-char) #\") ((primitive-ref for-each) (primitive-ref write-char) ((primitive-ref string->list) f196030)) ((primitive-ref write-char) #\"))))) (vector-set! f196014 0 (closure (f196029) ((primitive-ref write-char) f196013 (primitive-ref write-char)) (let ((f196029 f196029)) (begin ((primitive-ref write-char) #\() ((vector-ref f196013 0) f196029) ((primitive-ref write-char) #\)))))) (vector-set! f196013 0 (closure (f196028) ((primitive-ref write) (primitive-ref write-char) f196013 else (primitive-ref write-char) (primitive-ref write-char) (primitive-ref write-char) (primitive-ref write)) (let ((f196028 f196028)) (begin ((primitive-ref write) (car f196028)) (if (null? (cdr f196028)) #t (if (pair? (cdr f196028)) (begin ((primitive-ref write-char) #\space) ((vector-ref f196013 0) (cdr f196028))) (begin ((primitive-ref write-char) #\space) ((primitive-ref write-char) #\.) ((primitive-ref write-char) #\space) ((primitive-ref write) (cdr f196028))))))))))
#   env=((f196013 . -24) (f196014 . -20) (f196015 . -16) (f196016 . -12) (f196017 . -8) (f196018 . -4) (f196019 . 0))
# emit-expr (vector-set! f196019 0 (closure (f196035) ((primitive-ref write-char) (primitive-ref write-char) (primitive-ref write-char)) (let ((f196035 f196035)) (begin ((primitive-ref write-char) #\#) (if f196035 ((primitive-ref write-char) #\t) ((primitive-ref write-char) #\f))))))
# emit-expr f196019
# emit-variable-ref
# env=((f196013 . -24) (f196014 . -20) (f196015 . -16) (f196016 . -12) (f196017 . -8) (f196018 . -4) (f196019 . 0))
# var=f196019
    movl 0(%esp), %eax  # stack load f196019
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1432579
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1432579:
    movl %eax, -28(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1432580"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1432580:
# check bounds on vector index
    movl -28(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1432582
    cmp  $0,%eax
    jge _L_1432581
_L_1432582:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1432581:
    movl %eax, -32(%esp)
# emit-expr (closure (f196035) ((primitive-ref write-char) (primitive-ref write-char) (primitive-ref write-char)) (let ((f196035 f196035)) (begin ((primitive-ref write-char) #\#) (if f196035 ((primitive-ref write-char) #\t) ((primitive-ref write-char) #\f)))))
# emit-closure
# si = -36
# env = ((f196013 . -24) (f196014 . -20) (f196015 . -16) (f196016 . -12) (f196017 . -8) (f196018 . -4) (f196019 . 0))
# expr = (closure (f196035) ((primitive-ref write-char) (primitive-ref write-char) (primitive-ref write-char)) (let ((f196035 f196035)) (begin ((primitive-ref write-char) #\#) (if f196035 ((primitive-ref write-char) #\t) ((primitive-ref write-char) #\f)))))
    movl $_L_1432583, 0(%ebp)  # closure label
# WARNING: free var (primitive-ref write-char) not defined in the environmnet
# WARNING: free var (primitive-ref write-char) not defined in the environmnet
# WARNING: free var (primitive-ref write-char) not defined in the environmnet
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $16, %ebp     # bump ebp
    jmp _L_1432584            # jump around closure body
_L_1432583:
# check argument count
    cmp $4,%eax
    je _L_1432585
# invoke error handler eh_argcount
    .extern mrc_eh$uargcount
    movl mrc_eh$uargcount, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_1432585:
# emit-tail-expr
# si=-12
# env=((f196035 . -8) ((primitive-ref write-char) . 12) ((primitive-ref write-char) . 8) ((primitive-ref write-char) . 4) (f196013 . -24) (f196014 . -20) (f196015 . -16) (f196016 . -12) (f196017 . -8) (f196018 . -4) (f196019 . 0))
# expr=(let ((f196035 f196035)) (begin ((primitive-ref write-char) #\#) (if f196035 ((primitive-ref write-char) #\t) ((primitive-ref write-char) #\f))))
# emit-tail-let
#  si   = -12
#  env  = ((f196035 . -8) ((primitive-ref write-char) . 12) ((primitive-ref write-char) . 8) ((primitive-ref write-char) . 4) (f196013 . -24) (f196014 . -20) (f196015 . -16) (f196016 . -12) (f196017 . -8) (f196018 . -4) (f196019 . 0))
#  bindings = ((f196035 f196035))
#  body = (begin ((primitive-ref write-char) #\#) (if f196035 ((primitive-ref write-char) #\t) ((primitive-ref write-char) #\f)))
# emit-expr f196035
# emit-variable-ref
# env=((f196035 . -8) ((primitive-ref write-char) . 12) ((primitive-ref write-char) . 8) ((primitive-ref write-char) . 4) (f196013 . -24) (f196014 . -20) (f196015 . -16) (f196016 . -12) (f196017 . -8) (f196018 . -4) (f196019 . 0))
# var=f196035
    movl -8(%esp), %eax  # stack load f196035
# end emit-variable-ref
    movl %eax, -12(%esp)  # stack save
# emit-tail-expr
# si=-16
# env=((f196035 . -12) (f196035 . -8) ((primitive-ref write-char) . 12) ((primitive-ref write-char) . 8) ((primitive-ref write-char) . 4) (f196013 . -24) (f196014 . -20) (f196015 . -16) (f196016 . -12) (f196017 . -8) (f196018 . -4) (f196019 . 0))
# expr=(begin ((primitive-ref write-char) #\#) (if f196035 ((primitive-ref write-char) #\t) ((primitive-ref write-char) #\f)))
# tail-begin (begin ((primitive-ref write-char) #\#) (if f196035 ((primitive-ref write-char) #\t) ((primitive-ref write-char) #\f)))
#   env=((f196035 . -12) (f196035 . -8) ((primitive-ref write-char) . 12) ((primitive-ref write-char) . 8) ((primitive-ref write-char) . 4) (f196013 . -24) (f196014 . -20) (f196015 . -16) (f196016 . -12) (f196017 . -8) (f196018 . -4) (f196019 . 0))
# emit-expr ((primitive-ref write-char) #\#)
# funcall
#    si   =-16
#    env  = ((f196035 . -12) (f196035 . -8) ((primitive-ref write-char) . 12) ((primitive-ref write-char) . 8) ((primitive-ref write-char) . 4) (f196013 . -24) (f196014 . -20) (f196015 . -16) (f196016 . -12) (f196017 . -8) (f196018 . -4) (f196019 . 0))
#    expr = (funcall (primitive-ref write-char) #\#)
# emit-expr (primitive-ref write-char)
    .extern mrc_write$mchar
    movl mrc_write$mchar,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1432586"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1432586":
   movl %eax,  -24(%esp)  # stash funcall-oper in closure slot
# emit-expr #\#
    movl $8975, %eax     # immed #\#
    mov %eax, -28(%esp)  # arg #
    movl -24(%esp), %edi   # load new closure to %edi
    add $-16, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $16, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
# emit-tail-expr
# si=-16
# env=((f196035 . -12) (f196035 . -8) ((primitive-ref write-char) . 12) ((primitive-ref write-char) . 8) ((primitive-ref write-char) . 4) (f196013 . -24) (f196014 . -20) (f196015 . -16) (f196016 . -12) (f196017 . -8) (f196018 . -4) (f196019 . 0))
# expr=(begin (if f196035 ((primitive-ref write-char) #\t) ((primitive-ref write-char) #\f)))
# tail-begin (begin (if f196035 ((primitive-ref write-char) #\t) ((primitive-ref write-char) #\f)))
#   env=((f196035 . -12) (f196035 . -8) ((primitive-ref write-char) . 12) ((primitive-ref write-char) . 8) ((primitive-ref write-char) . 4) (f196013 . -24) (f196014 . -20) (f196015 . -16) (f196016 . -12) (f196017 . -8) (f196018 . -4) (f196019 . 0))
# emit-tail-expr
# si=-16
# env=((f196035 . -12) (f196035 . -8) ((primitive-ref write-char) . 12) ((primitive-ref write-char) . 8) ((primitive-ref write-char) . 4) (f196013 . -24) (f196014 . -20) (f196015 . -16) (f196016 . -12) (f196017 . -8) (f196018 . -4) (f196019 . 0))
# expr=(if f196035 ((primitive-ref write-char) #\t) ((primitive-ref write-char) #\f))
# emit-expr f196035
# emit-variable-ref
# env=((f196035 . -12) (f196035 . -8) ((primitive-ref write-char) . 12) ((primitive-ref write-char) . 8) ((primitive-ref write-char) . 4) (f196013 . -24) (f196014 . -20) (f196015 . -16) (f196016 . -12) (f196017 . -8) (f196018 . -4) (f196019 . 0))
# var=f196035
    movl -12(%esp), %eax  # stack load f196035
# end emit-variable-ref
    cmp $47, %al
    je _L_1432587
# emit-tail-expr
# si=-16
# env=((f196035 . -12) (f196035 . -8) ((primitive-ref write-char) . 12) ((primitive-ref write-char) . 8) ((primitive-ref write-char) . 4) (f196013 . -24) (f196014 . -20) (f196015 . -16) (f196016 . -12) (f196017 . -8) (f196018 . -4) (f196019 . 0))
# expr=((primitive-ref write-char) #\t)
# emit-tail-funcall
#    si   =-16
#    env  = ((f196035 . -12) (f196035 . -8) ((primitive-ref write-char) . 12) ((primitive-ref write-char) . 8) ((primitive-ref write-char) . 4) (f196013 . -24) (f196014 . -20) (f196015 . -16) (f196016 . -12) (f196017 . -8) (f196018 . -4) (f196019 . 0))
#    expr = (funcall (primitive-ref write-char) #\t)
# emit-expr (primitive-ref write-char)
    .extern mrc_write$mchar
    movl mrc_write$mchar,%eax
   movl %eax,  -16(%esp)  # stash funcall-oper in next closure slot
# emit-expr #\t
    movl $29711, %eax     # immed #\t
    mov %eax, -20(%esp)    # arg t
    movl -16(%esp), %edi   # load new closure to %edi
# emit-shift-args:  size=2   si=-16  delta=12
    mov -16(%esp), %ebx  # shift frame cell
    mov %ebx, -4(%esp)  # down to base
# emit-shift-args:  size=1   si=-20  delta=12
    mov -20(%esp), %ebx  # shift frame cell
    mov %ebx, -8(%esp)  # down to base
# emit-shift-args:  size=0   si=-24  delta=12
    movl $4,%eax   # save arg count
    jmp *-2(%edi)  # tail-funcall
    jmp _L_1432588
_L_1432587:
# emit-tail-expr
# si=-16
# env=((f196035 . -12) (f196035 . -8) ((primitive-ref write-char) . 12) ((primitive-ref write-char) . 8) ((primitive-ref write-char) . 4) (f196013 . -24) (f196014 . -20) (f196015 . -16) (f196016 . -12) (f196017 . -8) (f196018 . -4) (f196019 . 0))
# expr=((primitive-ref write-char) #\f)
# emit-tail-funcall
#    si   =-16
#    env  = ((f196035 . -12) (f196035 . -8) ((primitive-ref write-char) . 12) ((primitive-ref write-char) . 8) ((primitive-ref write-char) . 4) (f196013 . -24) (f196014 . -20) (f196015 . -16) (f196016 . -12) (f196017 . -8) (f196018 . -4) (f196019 . 0))
#    expr = (funcall (primitive-ref write-char) #\f)
# emit-expr (primitive-ref write-char)
    .extern mrc_write$mchar
    movl mrc_write$mchar,%eax
   movl %eax,  -16(%esp)  # stash funcall-oper in next closure slot
# emit-expr #\f
    movl $26127, %eax     # immed #\f
    mov %eax, -20(%esp)    # arg f
    movl -16(%esp), %edi   # load new closure to %edi
# emit-shift-args:  size=2   si=-16  delta=12
    mov -16(%esp), %ebx  # shift frame cell
    mov %ebx, -4(%esp)  # down to base
# emit-shift-args:  size=1   si=-20  delta=12
    mov -20(%esp), %ebx  # shift frame cell
    mov %ebx, -8(%esp)  # down to base
# emit-shift-args:  size=0   si=-24  delta=12
    movl $4,%eax   # save arg count
    jmp *-2(%edi)  # tail-funcall
_L_1432588:
     ret   # return thru stack
    .align 4,0x90
_L_1432584:
    movl -28(%esp), %ebx
    movl -32(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin (vector-set! f196018 0 (closure () ((primitive-ref write-char) (primitive-ref write-char)) (let () (begin ((primitive-ref write-char) #\() ((primitive-ref write-char) #\)))))) (vector-set! f196017 0 (closure (f196034) ((primitive-ref write-char) (primitive-ref write-char) (primitive-ref write-char)) (let ((f196034 f196034)) (begin ((primitive-ref write-char) #\#) ((primitive-ref write-char) #\\) ((primitive-ref write-char) f196034))))) (vector-set! f196016 0 (closure (f196031) ((primitive-ref negative?) (primitive-ref write-char) f196016 (primitive-ref map) (primitive-ref write-char) (primitive-ref integer->list)) (let ((f196031 f196031)) (if ((primitive-ref negative?) f196031) (begin ((primitive-ref write-char) #\-) ((vector-ref f196016 0) (fx* -1 f196031))) ((primitive-ref map) (closure (f196033) ((primitive-ref write-char)) (let ((f196033 f196033)) ((primitive-ref write-char) (fixnum->char (fx+ (char->fixnum #\0) f196033))))) ((primitive-ref integer->list) f196031)))))) (vector-set! f196015 0 (closure (f196030) ((primitive-ref write-char) (primitive-ref for-each) (primitive-ref write-char) (primitive-ref string->list) (primitive-ref write-char)) (let ((f196030 f196030)) (begin ((primitive-ref write-char) #\") ((primitive-ref for-each) (primitive-ref write-char) ((primitive-ref string->list) f196030)) ((primitive-ref write-char) #\"))))) (vector-set! f196014 0 (closure (f196029) ((primitive-ref write-char) f196013 (primitive-ref write-char)) (let ((f196029 f196029)) (begin ((primitive-ref write-char) #\() ((vector-ref f196013 0) f196029) ((primitive-ref write-char) #\)))))) (vector-set! f196013 0 (closure (f196028) ((primitive-ref write) (primitive-ref write-char) f196013 else (primitive-ref write-char) (primitive-ref write-char) (primitive-ref write-char) (primitive-ref write)) (let ((f196028 f196028)) (begin ((primitive-ref write) (car f196028)) (if (null? (cdr f196028)) #t (if (pair? (cdr f196028)) (begin ((primitive-ref write-char) #\space) ((vector-ref f196013 0) (cdr f196028))) (begin ((primitive-ref write-char) #\space) ((primitive-ref write-char) #\.) ((primitive-ref write-char) #\space) ((primitive-ref write) (cdr f196028))))))))))
# emit-begin
#   expr=(begin (vector-set! f196018 0 (closure () ((primitive-ref write-char) (primitive-ref write-char)) (let () (begin ((primitive-ref write-char) #\() ((primitive-ref write-char) #\)))))) (vector-set! f196017 0 (closure (f196034) ((primitive-ref write-char) (primitive-ref write-char) (primitive-ref write-char)) (let ((f196034 f196034)) (begin ((primitive-ref write-char) #\#) ((primitive-ref write-char) #\\) ((primitive-ref write-char) f196034))))) (vector-set! f196016 0 (closure (f196031) ((primitive-ref negative?) (primitive-ref write-char) f196016 (primitive-ref map) (primitive-ref write-char) (primitive-ref integer->list)) (let ((f196031 f196031)) (if ((primitive-ref negative?) f196031) (begin ((primitive-ref write-char) #\-) ((vector-ref f196016 0) (fx* -1 f196031))) ((primitive-ref map) (closure (f196033) ((primitive-ref write-char)) (let ((f196033 f196033)) ((primitive-ref write-char) (fixnum->char (fx+ (char->fixnum #\0) f196033))))) ((primitive-ref integer->list) f196031)))))) (vector-set! f196015 0 (closure (f196030) ((primitive-ref write-char) (primitive-ref for-each) (primitive-ref write-char) (primitive-ref string->list) (primitive-ref write-char)) (let ((f196030 f196030)) (begin ((primitive-ref write-char) #\") ((primitive-ref for-each) (primitive-ref write-char) ((primitive-ref string->list) f196030)) ((primitive-ref write-char) #\"))))) (vector-set! f196014 0 (closure (f196029) ((primitive-ref write-char) f196013 (primitive-ref write-char)) (let ((f196029 f196029)) (begin ((primitive-ref write-char) #\() ((vector-ref f196013 0) f196029) ((primitive-ref write-char) #\)))))) (vector-set! f196013 0 (closure (f196028) ((primitive-ref write) (primitive-ref write-char) f196013 else (primitive-ref write-char) (primitive-ref write-char) (primitive-ref write-char) (primitive-ref write)) (let ((f196028 f196028)) (begin ((primitive-ref write) (car f196028)) (if (null? (cdr f196028)) #t (if (pair? (cdr f196028)) (begin ((primitive-ref write-char) #\space) ((vector-ref f196013 0) (cdr f196028))) (begin ((primitive-ref write-char) #\space) ((primitive-ref write-char) #\.) ((primitive-ref write-char) #\space) ((primitive-ref write) (cdr f196028))))))))))
#   env=((f196013 . -24) (f196014 . -20) (f196015 . -16) (f196016 . -12) (f196017 . -8) (f196018 . -4) (f196019 . 0))
# emit-expr (vector-set! f196018 0 (closure () ((primitive-ref write-char) (primitive-ref write-char)) (let () (begin ((primitive-ref write-char) #\() ((primitive-ref write-char) #\))))))
# emit-expr f196018
# emit-variable-ref
# env=((f196013 . -24) (f196014 . -20) (f196015 . -16) (f196016 . -12) (f196017 . -8) (f196018 . -4) (f196019 . 0))
# var=f196018
    movl -4(%esp), %eax  # stack load f196018
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1432589
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1432589:
    movl %eax, -28(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1432590"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1432590:
# check bounds on vector index
    movl -28(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1432592
    cmp  $0,%eax
    jge _L_1432591
_L_1432592:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1432591:
    movl %eax, -32(%esp)
# emit-expr (closure () ((primitive-ref write-char) (primitive-ref write-char)) (let () (begin ((primitive-ref write-char) #\() ((primitive-ref write-char) #\)))))
# emit-closure
# si = -36
# env = ((f196013 . -24) (f196014 . -20) (f196015 . -16) (f196016 . -12) (f196017 . -8) (f196018 . -4) (f196019 . 0))
# expr = (closure () ((primitive-ref write-char) (primitive-ref write-char)) (let () (begin ((primitive-ref write-char) #\() ((primitive-ref write-char) #\)))))
    movl $_L_1432593, 0(%ebp)  # closure label
# WARNING: free var (primitive-ref write-char) not defined in the environmnet
# WARNING: free var (primitive-ref write-char) not defined in the environmnet
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $16, %ebp     # bump ebp
    jmp _L_1432594            # jump around closure body
_L_1432593:
# check argument count
    cmp $0,%eax
    je _L_1432595
# invoke error handler eh_argcount
    .extern mrc_eh$uargcount
    movl mrc_eh$uargcount, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_1432595:
# emit-tail-expr
# si=-8
# env=(((primitive-ref write-char) . 8) ((primitive-ref write-char) . 4) (f196013 . -24) (f196014 . -20) (f196015 . -16) (f196016 . -12) (f196017 . -8) (f196018 . -4) (f196019 . 0))
# expr=(let () (begin ((primitive-ref write-char) #\() ((primitive-ref write-char) #\))))
# emit-tail-let
#  si   = -8
#  env  = (((primitive-ref write-char) . 8) ((primitive-ref write-char) . 4) (f196013 . -24) (f196014 . -20) (f196015 . -16) (f196016 . -12) (f196017 . -8) (f196018 . -4) (f196019 . 0))
#  bindings = ()
#  body = (begin ((primitive-ref write-char) #\() ((primitive-ref write-char) #\)))
# emit-tail-expr
# si=-8
# env=(((primitive-ref write-char) . 8) ((primitive-ref write-char) . 4) (f196013 . -24) (f196014 . -20) (f196015 . -16) (f196016 . -12) (f196017 . -8) (f196018 . -4) (f196019 . 0))
# expr=(begin ((primitive-ref write-char) #\() ((primitive-ref write-char) #\)))
# tail-begin (begin ((primitive-ref write-char) #\() ((primitive-ref write-char) #\)))
#   env=(((primitive-ref write-char) . 8) ((primitive-ref write-char) . 4) (f196013 . -24) (f196014 . -20) (f196015 . -16) (f196016 . -12) (f196017 . -8) (f196018 . -4) (f196019 . 0))
# emit-expr ((primitive-ref write-char) #\()
# funcall
#    si   =-8
#    env  = (((primitive-ref write-char) . 8) ((primitive-ref write-char) . 4) (f196013 . -24) (f196014 . -20) (f196015 . -16) (f196016 . -12) (f196017 . -8) (f196018 . -4) (f196019 . 0))
#    expr = (funcall (primitive-ref write-char) #\()
# emit-expr (primitive-ref write-char)
    .extern mrc_write$mchar
    movl mrc_write$mchar,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1432596"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1432596":
   movl %eax,  -16(%esp)  # stash funcall-oper in closure slot
# emit-expr #\(
    movl $10255, %eax     # immed #\(
    mov %eax, -20(%esp)  # arg (
    movl -16(%esp), %edi   # load new closure to %edi
    add $-8, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $8, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
# emit-tail-expr
# si=-8
# env=(((primitive-ref write-char) . 8) ((primitive-ref write-char) . 4) (f196013 . -24) (f196014 . -20) (f196015 . -16) (f196016 . -12) (f196017 . -8) (f196018 . -4) (f196019 . 0))
# expr=(begin ((primitive-ref write-char) #\)))
# tail-begin (begin ((primitive-ref write-char) #\)))
#   env=(((primitive-ref write-char) . 8) ((primitive-ref write-char) . 4) (f196013 . -24) (f196014 . -20) (f196015 . -16) (f196016 . -12) (f196017 . -8) (f196018 . -4) (f196019 . 0))
# emit-tail-expr
# si=-8
# env=(((primitive-ref write-char) . 8) ((primitive-ref write-char) . 4) (f196013 . -24) (f196014 . -20) (f196015 . -16) (f196016 . -12) (f196017 . -8) (f196018 . -4) (f196019 . 0))
# expr=((primitive-ref write-char) #\))
# emit-tail-funcall
#    si   =-8
#    env  = (((primitive-ref write-char) . 8) ((primitive-ref write-char) . 4) (f196013 . -24) (f196014 . -20) (f196015 . -16) (f196016 . -12) (f196017 . -8) (f196018 . -4) (f196019 . 0))
#    expr = (funcall (primitive-ref write-char) #\))
# emit-expr (primitive-ref write-char)
    .extern mrc_write$mchar
    movl mrc_write$mchar,%eax
   movl %eax,  -8(%esp)  # stash funcall-oper in next closure slot
# emit-expr #\)
    movl $10511, %eax     # immed #\)
    mov %eax, -12(%esp)    # arg )
    movl -8(%esp), %edi   # load new closure to %edi
# emit-shift-args:  size=2   si=-8  delta=4
    mov -8(%esp), %ebx  # shift frame cell
    mov %ebx, -4(%esp)  # down to base
# emit-shift-args:  size=1   si=-12  delta=4
    mov -12(%esp), %ebx  # shift frame cell
    mov %ebx, -8(%esp)  # down to base
# emit-shift-args:  size=0   si=-16  delta=4
    movl $4,%eax   # save arg count
    jmp *-2(%edi)  # tail-funcall
     ret   # return thru stack
    .align 4,0x90
_L_1432594:
    movl -28(%esp), %ebx
    movl -32(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin (vector-set! f196017 0 (closure (f196034) ((primitive-ref write-char) (primitive-ref write-char) (primitive-ref write-char)) (let ((f196034 f196034)) (begin ((primitive-ref write-char) #\#) ((primitive-ref write-char) #\\) ((primitive-ref write-char) f196034))))) (vector-set! f196016 0 (closure (f196031) ((primitive-ref negative?) (primitive-ref write-char) f196016 (primitive-ref map) (primitive-ref write-char) (primitive-ref integer->list)) (let ((f196031 f196031)) (if ((primitive-ref negative?) f196031) (begin ((primitive-ref write-char) #\-) ((vector-ref f196016 0) (fx* -1 f196031))) ((primitive-ref map) (closure (f196033) ((primitive-ref write-char)) (let ((f196033 f196033)) ((primitive-ref write-char) (fixnum->char (fx+ (char->fixnum #\0) f196033))))) ((primitive-ref integer->list) f196031)))))) (vector-set! f196015 0 (closure (f196030) ((primitive-ref write-char) (primitive-ref for-each) (primitive-ref write-char) (primitive-ref string->list) (primitive-ref write-char)) (let ((f196030 f196030)) (begin ((primitive-ref write-char) #\") ((primitive-ref for-each) (primitive-ref write-char) ((primitive-ref string->list) f196030)) ((primitive-ref write-char) #\"))))) (vector-set! f196014 0 (closure (f196029) ((primitive-ref write-char) f196013 (primitive-ref write-char)) (let ((f196029 f196029)) (begin ((primitive-ref write-char) #\() ((vector-ref f196013 0) f196029) ((primitive-ref write-char) #\)))))) (vector-set! f196013 0 (closure (f196028) ((primitive-ref write) (primitive-ref write-char) f196013 else (primitive-ref write-char) (primitive-ref write-char) (primitive-ref write-char) (primitive-ref write)) (let ((f196028 f196028)) (begin ((primitive-ref write) (car f196028)) (if (null? (cdr f196028)) #t (if (pair? (cdr f196028)) (begin ((primitive-ref write-char) #\space) ((vector-ref f196013 0) (cdr f196028))) (begin ((primitive-ref write-char) #\space) ((primitive-ref write-char) #\.) ((primitive-ref write-char) #\space) ((primitive-ref write) (cdr f196028))))))))))
# emit-begin
#   expr=(begin (vector-set! f196017 0 (closure (f196034) ((primitive-ref write-char) (primitive-ref write-char) (primitive-ref write-char)) (let ((f196034 f196034)) (begin ((primitive-ref write-char) #\#) ((primitive-ref write-char) #\\) ((primitive-ref write-char) f196034))))) (vector-set! f196016 0 (closure (f196031) ((primitive-ref negative?) (primitive-ref write-char) f196016 (primitive-ref map) (primitive-ref write-char) (primitive-ref integer->list)) (let ((f196031 f196031)) (if ((primitive-ref negative?) f196031) (begin ((primitive-ref write-char) #\-) ((vector-ref f196016 0) (fx* -1 f196031))) ((primitive-ref map) (closure (f196033) ((primitive-ref write-char)) (let ((f196033 f196033)) ((primitive-ref write-char) (fixnum->char (fx+ (char->fixnum #\0) f196033))))) ((primitive-ref integer->list) f196031)))))) (vector-set! f196015 0 (closure (f196030) ((primitive-ref write-char) (primitive-ref for-each) (primitive-ref write-char) (primitive-ref string->list) (primitive-ref write-char)) (let ((f196030 f196030)) (begin ((primitive-ref write-char) #\") ((primitive-ref for-each) (primitive-ref write-char) ((primitive-ref string->list) f196030)) ((primitive-ref write-char) #\"))))) (vector-set! f196014 0 (closure (f196029) ((primitive-ref write-char) f196013 (primitive-ref write-char)) (let ((f196029 f196029)) (begin ((primitive-ref write-char) #\() ((vector-ref f196013 0) f196029) ((primitive-ref write-char) #\)))))) (vector-set! f196013 0 (closure (f196028) ((primitive-ref write) (primitive-ref write-char) f196013 else (primitive-ref write-char) (primitive-ref write-char) (primitive-ref write-char) (primitive-ref write)) (let ((f196028 f196028)) (begin ((primitive-ref write) (car f196028)) (if (null? (cdr f196028)) #t (if (pair? (cdr f196028)) (begin ((primitive-ref write-char) #\space) ((vector-ref f196013 0) (cdr f196028))) (begin ((primitive-ref write-char) #\space) ((primitive-ref write-char) #\.) ((primitive-ref write-char) #\space) ((primitive-ref write) (cdr f196028))))))))))
#   env=((f196013 . -24) (f196014 . -20) (f196015 . -16) (f196016 . -12) (f196017 . -8) (f196018 . -4) (f196019 . 0))
# emit-expr (vector-set! f196017 0 (closure (f196034) ((primitive-ref write-char) (primitive-ref write-char) (primitive-ref write-char)) (let ((f196034 f196034)) (begin ((primitive-ref write-char) #\#) ((primitive-ref write-char) #\\) ((primitive-ref write-char) f196034)))))
# emit-expr f196017
# emit-variable-ref
# env=((f196013 . -24) (f196014 . -20) (f196015 . -16) (f196016 . -12) (f196017 . -8) (f196018 . -4) (f196019 . 0))
# var=f196017
    movl -8(%esp), %eax  # stack load f196017
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1432597
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1432597:
    movl %eax, -28(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1432598"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1432598:
# check bounds on vector index
    movl -28(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1432600
    cmp  $0,%eax
    jge _L_1432599
_L_1432600:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1432599:
    movl %eax, -32(%esp)
# emit-expr (closure (f196034) ((primitive-ref write-char) (primitive-ref write-char) (primitive-ref write-char)) (let ((f196034 f196034)) (begin ((primitive-ref write-char) #\#) ((primitive-ref write-char) #\\) ((primitive-ref write-char) f196034))))
# emit-closure
# si = -36
# env = ((f196013 . -24) (f196014 . -20) (f196015 . -16) (f196016 . -12) (f196017 . -8) (f196018 . -4) (f196019 . 0))
# expr = (closure (f196034) ((primitive-ref write-char) (primitive-ref write-char) (primitive-ref write-char)) (let ((f196034 f196034)) (begin ((primitive-ref write-char) #\#) ((primitive-ref write-char) #\\) ((primitive-ref write-char) f196034))))
    movl $_L_1432601, 0(%ebp)  # closure label
# WARNING: free var (primitive-ref write-char) not defined in the environmnet
# WARNING: free var (primitive-ref write-char) not defined in the environmnet
# WARNING: free var (primitive-ref write-char) not defined in the environmnet
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $16, %ebp     # bump ebp
    jmp _L_1432602            # jump around closure body
_L_1432601:
# check argument count
    cmp $4,%eax
    je _L_1432603
# invoke error handler eh_argcount
    .extern mrc_eh$uargcount
    movl mrc_eh$uargcount, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_1432603:
# emit-tail-expr
# si=-12
# env=((f196034 . -8) ((primitive-ref write-char) . 12) ((primitive-ref write-char) . 8) ((primitive-ref write-char) . 4) (f196013 . -24) (f196014 . -20) (f196015 . -16) (f196016 . -12) (f196017 . -8) (f196018 . -4) (f196019 . 0))
# expr=(let ((f196034 f196034)) (begin ((primitive-ref write-char) #\#) ((primitive-ref write-char) #\\) ((primitive-ref write-char) f196034)))
# emit-tail-let
#  si   = -12
#  env  = ((f196034 . -8) ((primitive-ref write-char) . 12) ((primitive-ref write-char) . 8) ((primitive-ref write-char) . 4) (f196013 . -24) (f196014 . -20) (f196015 . -16) (f196016 . -12) (f196017 . -8) (f196018 . -4) (f196019 . 0))
#  bindings = ((f196034 f196034))
#  body = (begin ((primitive-ref write-char) #\#) ((primitive-ref write-char) #\\) ((primitive-ref write-char) f196034))
# emit-expr f196034
# emit-variable-ref
# env=((f196034 . -8) ((primitive-ref write-char) . 12) ((primitive-ref write-char) . 8) ((primitive-ref write-char) . 4) (f196013 . -24) (f196014 . -20) (f196015 . -16) (f196016 . -12) (f196017 . -8) (f196018 . -4) (f196019 . 0))
# var=f196034
    movl -8(%esp), %eax  # stack load f196034
# end emit-variable-ref
    movl %eax, -12(%esp)  # stack save
# emit-tail-expr
# si=-16
# env=((f196034 . -12) (f196034 . -8) ((primitive-ref write-char) . 12) ((primitive-ref write-char) . 8) ((primitive-ref write-char) . 4) (f196013 . -24) (f196014 . -20) (f196015 . -16) (f196016 . -12) (f196017 . -8) (f196018 . -4) (f196019 . 0))
# expr=(begin ((primitive-ref write-char) #\#) ((primitive-ref write-char) #\\) ((primitive-ref write-char) f196034))
# tail-begin (begin ((primitive-ref write-char) #\#) ((primitive-ref write-char) #\\) ((primitive-ref write-char) f196034))
#   env=((f196034 . -12) (f196034 . -8) ((primitive-ref write-char) . 12) ((primitive-ref write-char) . 8) ((primitive-ref write-char) . 4) (f196013 . -24) (f196014 . -20) (f196015 . -16) (f196016 . -12) (f196017 . -8) (f196018 . -4) (f196019 . 0))
# emit-expr ((primitive-ref write-char) #\#)
# funcall
#    si   =-16
#    env  = ((f196034 . -12) (f196034 . -8) ((primitive-ref write-char) . 12) ((primitive-ref write-char) . 8) ((primitive-ref write-char) . 4) (f196013 . -24) (f196014 . -20) (f196015 . -16) (f196016 . -12) (f196017 . -8) (f196018 . -4) (f196019 . 0))
#    expr = (funcall (primitive-ref write-char) #\#)
# emit-expr (primitive-ref write-char)
    .extern mrc_write$mchar
    movl mrc_write$mchar,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1432604"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1432604":
   movl %eax,  -24(%esp)  # stash funcall-oper in closure slot
# emit-expr #\#
    movl $8975, %eax     # immed #\#
    mov %eax, -28(%esp)  # arg #
    movl -24(%esp), %edi   # load new closure to %edi
    add $-16, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $16, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
# emit-tail-expr
# si=-16
# env=((f196034 . -12) (f196034 . -8) ((primitive-ref write-char) . 12) ((primitive-ref write-char) . 8) ((primitive-ref write-char) . 4) (f196013 . -24) (f196014 . -20) (f196015 . -16) (f196016 . -12) (f196017 . -8) (f196018 . -4) (f196019 . 0))
# expr=(begin ((primitive-ref write-char) #\\) ((primitive-ref write-char) f196034))
# tail-begin (begin ((primitive-ref write-char) #\\) ((primitive-ref write-char) f196034))
#   env=((f196034 . -12) (f196034 . -8) ((primitive-ref write-char) . 12) ((primitive-ref write-char) . 8) ((primitive-ref write-char) . 4) (f196013 . -24) (f196014 . -20) (f196015 . -16) (f196016 . -12) (f196017 . -8) (f196018 . -4) (f196019 . 0))
# emit-expr ((primitive-ref write-char) #\\)
# funcall
#    si   =-16
#    env  = ((f196034 . -12) (f196034 . -8) ((primitive-ref write-char) . 12) ((primitive-ref write-char) . 8) ((primitive-ref write-char) . 4) (f196013 . -24) (f196014 . -20) (f196015 . -16) (f196016 . -12) (f196017 . -8) (f196018 . -4) (f196019 . 0))
#    expr = (funcall (primitive-ref write-char) #\\)
# emit-expr (primitive-ref write-char)
    .extern mrc_write$mchar
    movl mrc_write$mchar,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1432605"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1432605":
   movl %eax,  -24(%esp)  # stash funcall-oper in closure slot
# emit-expr #\\
    movl $23567, %eax     # immed #\\
    mov %eax, -28(%esp)  # arg \
    movl -24(%esp), %edi   # load new closure to %edi
    add $-16, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $16, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
# emit-tail-expr
# si=-16
# env=((f196034 . -12) (f196034 . -8) ((primitive-ref write-char) . 12) ((primitive-ref write-char) . 8) ((primitive-ref write-char) . 4) (f196013 . -24) (f196014 . -20) (f196015 . -16) (f196016 . -12) (f196017 . -8) (f196018 . -4) (f196019 . 0))
# expr=(begin ((primitive-ref write-char) f196034))
# tail-begin (begin ((primitive-ref write-char) f196034))
#   env=((f196034 . -12) (f196034 . -8) ((primitive-ref write-char) . 12) ((primitive-ref write-char) . 8) ((primitive-ref write-char) . 4) (f196013 . -24) (f196014 . -20) (f196015 . -16) (f196016 . -12) (f196017 . -8) (f196018 . -4) (f196019 . 0))
# emit-tail-expr
# si=-16
# env=((f196034 . -12) (f196034 . -8) ((primitive-ref write-char) . 12) ((primitive-ref write-char) . 8) ((primitive-ref write-char) . 4) (f196013 . -24) (f196014 . -20) (f196015 . -16) (f196016 . -12) (f196017 . -8) (f196018 . -4) (f196019 . 0))
# expr=((primitive-ref write-char) f196034)
# emit-tail-funcall
#    si   =-16
#    env  = ((f196034 . -12) (f196034 . -8) ((primitive-ref write-char) . 12) ((primitive-ref write-char) . 8) ((primitive-ref write-char) . 4) (f196013 . -24) (f196014 . -20) (f196015 . -16) (f196016 . -12) (f196017 . -8) (f196018 . -4) (f196019 . 0))
#    expr = (funcall (primitive-ref write-char) f196034)
# emit-expr (primitive-ref write-char)
    .extern mrc_write$mchar
    movl mrc_write$mchar,%eax
   movl %eax,  -16(%esp)  # stash funcall-oper in next closure slot
# emit-expr f196034
# emit-variable-ref
# env=((f196034 . -12) (f196034 . -8) ((primitive-ref write-char) . 12) ((primitive-ref write-char) . 8) ((primitive-ref write-char) . 4) (f196013 . -24) (f196014 . -20) (f196015 . -16) (f196016 . -12) (f196017 . -8) (f196018 . -4) (f196019 . 0))
# var=f196034
    movl -12(%esp), %eax  # stack load f196034
# end emit-variable-ref
    mov %eax, -20(%esp)    # arg f196034
    movl -16(%esp), %edi   # load new closure to %edi
# emit-shift-args:  size=2   si=-16  delta=12
    mov -16(%esp), %ebx  # shift frame cell
    mov %ebx, -4(%esp)  # down to base
# emit-shift-args:  size=1   si=-20  delta=12
    mov -20(%esp), %ebx  # shift frame cell
    mov %ebx, -8(%esp)  # down to base
# emit-shift-args:  size=0   si=-24  delta=12
    movl $4,%eax   # save arg count
    jmp *-2(%edi)  # tail-funcall
     ret   # return thru stack
    .align 4,0x90
_L_1432602:
    movl -28(%esp), %ebx
    movl -32(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin (vector-set! f196016 0 (closure (f196031) ((primitive-ref negative?) (primitive-ref write-char) f196016 (primitive-ref map) (primitive-ref write-char) (primitive-ref integer->list)) (let ((f196031 f196031)) (if ((primitive-ref negative?) f196031) (begin ((primitive-ref write-char) #\-) ((vector-ref f196016 0) (fx* -1 f196031))) ((primitive-ref map) (closure (f196033) ((primitive-ref write-char)) (let ((f196033 f196033)) ((primitive-ref write-char) (fixnum->char (fx+ (char->fixnum #\0) f196033))))) ((primitive-ref integer->list) f196031)))))) (vector-set! f196015 0 (closure (f196030) ((primitive-ref write-char) (primitive-ref for-each) (primitive-ref write-char) (primitive-ref string->list) (primitive-ref write-char)) (let ((f196030 f196030)) (begin ((primitive-ref write-char) #\") ((primitive-ref for-each) (primitive-ref write-char) ((primitive-ref string->list) f196030)) ((primitive-ref write-char) #\"))))) (vector-set! f196014 0 (closure (f196029) ((primitive-ref write-char) f196013 (primitive-ref write-char)) (let ((f196029 f196029)) (begin ((primitive-ref write-char) #\() ((vector-ref f196013 0) f196029) ((primitive-ref write-char) #\)))))) (vector-set! f196013 0 (closure (f196028) ((primitive-ref write) (primitive-ref write-char) f196013 else (primitive-ref write-char) (primitive-ref write-char) (primitive-ref write-char) (primitive-ref write)) (let ((f196028 f196028)) (begin ((primitive-ref write) (car f196028)) (if (null? (cdr f196028)) #t (if (pair? (cdr f196028)) (begin ((primitive-ref write-char) #\space) ((vector-ref f196013 0) (cdr f196028))) (begin ((primitive-ref write-char) #\space) ((primitive-ref write-char) #\.) ((primitive-ref write-char) #\space) ((primitive-ref write) (cdr f196028))))))))))
# emit-begin
#   expr=(begin (vector-set! f196016 0 (closure (f196031) ((primitive-ref negative?) (primitive-ref write-char) f196016 (primitive-ref map) (primitive-ref write-char) (primitive-ref integer->list)) (let ((f196031 f196031)) (if ((primitive-ref negative?) f196031) (begin ((primitive-ref write-char) #\-) ((vector-ref f196016 0) (fx* -1 f196031))) ((primitive-ref map) (closure (f196033) ((primitive-ref write-char)) (let ((f196033 f196033)) ((primitive-ref write-char) (fixnum->char (fx+ (char->fixnum #\0) f196033))))) ((primitive-ref integer->list) f196031)))))) (vector-set! f196015 0 (closure (f196030) ((primitive-ref write-char) (primitive-ref for-each) (primitive-ref write-char) (primitive-ref string->list) (primitive-ref write-char)) (let ((f196030 f196030)) (begin ((primitive-ref write-char) #\") ((primitive-ref for-each) (primitive-ref write-char) ((primitive-ref string->list) f196030)) ((primitive-ref write-char) #\"))))) (vector-set! f196014 0 (closure (f196029) ((primitive-ref write-char) f196013 (primitive-ref write-char)) (let ((f196029 f196029)) (begin ((primitive-ref write-char) #\() ((vector-ref f196013 0) f196029) ((primitive-ref write-char) #\)))))) (vector-set! f196013 0 (closure (f196028) ((primitive-ref write) (primitive-ref write-char) f196013 else (primitive-ref write-char) (primitive-ref write-char) (primitive-ref write-char) (primitive-ref write)) (let ((f196028 f196028)) (begin ((primitive-ref write) (car f196028)) (if (null? (cdr f196028)) #t (if (pair? (cdr f196028)) (begin ((primitive-ref write-char) #\space) ((vector-ref f196013 0) (cdr f196028))) (begin ((primitive-ref write-char) #\space) ((primitive-ref write-char) #\.) ((primitive-ref write-char) #\space) ((primitive-ref write) (cdr f196028))))))))))
#   env=((f196013 . -24) (f196014 . -20) (f196015 . -16) (f196016 . -12) (f196017 . -8) (f196018 . -4) (f196019 . 0))
# emit-expr (vector-set! f196016 0 (closure (f196031) ((primitive-ref negative?) (primitive-ref write-char) f196016 (primitive-ref map) (primitive-ref write-char) (primitive-ref integer->list)) (let ((f196031 f196031)) (if ((primitive-ref negative?) f196031) (begin ((primitive-ref write-char) #\-) ((vector-ref f196016 0) (fx* -1 f196031))) ((primitive-ref map) (closure (f196033) ((primitive-ref write-char)) (let ((f196033 f196033)) ((primitive-ref write-char) (fixnum->char (fx+ (char->fixnum #\0) f196033))))) ((primitive-ref integer->list) f196031))))))
# emit-expr f196016
# emit-variable-ref
# env=((f196013 . -24) (f196014 . -20) (f196015 . -16) (f196016 . -12) (f196017 . -8) (f196018 . -4) (f196019 . 0))
# var=f196016
    movl -12(%esp), %eax  # stack load f196016
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1432606
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1432606:
    movl %eax, -28(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1432607"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1432607:
# check bounds on vector index
    movl -28(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1432609
    cmp  $0,%eax
    jge _L_1432608
_L_1432609:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1432608:
    movl %eax, -32(%esp)
# emit-expr (closure (f196031) ((primitive-ref negative?) (primitive-ref write-char) f196016 (primitive-ref map) (primitive-ref write-char) (primitive-ref integer->list)) (let ((f196031 f196031)) (if ((primitive-ref negative?) f196031) (begin ((primitive-ref write-char) #\-) ((vector-ref f196016 0) (fx* -1 f196031))) ((primitive-ref map) (closure (f196033) ((primitive-ref write-char)) (let ((f196033 f196033)) ((primitive-ref write-char) (fixnum->char (fx+ (char->fixnum #\0) f196033))))) ((primitive-ref integer->list) f196031)))))
# emit-closure
# si = -36
# env = ((f196013 . -24) (f196014 . -20) (f196015 . -16) (f196016 . -12) (f196017 . -8) (f196018 . -4) (f196019 . 0))
# expr = (closure (f196031) ((primitive-ref negative?) (primitive-ref write-char) f196016 (primitive-ref map) (primitive-ref write-char) (primitive-ref integer->list)) (let ((f196031 f196031)) (if ((primitive-ref negative?) f196031) (begin ((primitive-ref write-char) #\-) ((vector-ref f196016 0) (fx* -1 f196031))) ((primitive-ref map) (closure (f196033) ((primitive-ref write-char)) (let ((f196033 f196033)) ((primitive-ref write-char) (fixnum->char (fx+ (char->fixnum #\0) f196033))))) ((primitive-ref integer->list) f196031)))))
    movl $_L_1432610, 0(%ebp)  # closure label
# WARNING: free var (primitive-ref negative?) not defined in the environmnet
# WARNING: free var (primitive-ref write-char) not defined in the environmnet
# emit-variable-ref
# env=((f196013 . -24) (f196014 . -20) (f196015 . -16) (f196016 . -12) (f196017 . -8) (f196018 . -4) (f196019 . 0))
# var=f196016
    movl -12(%esp), %eax  # stack load f196016
# end emit-variable-ref
   movl  %eax, 12(%ebp)  # f196016
# WARNING: free var (primitive-ref map) not defined in the environmnet
# WARNING: free var (primitive-ref write-char) not defined in the environmnet
# WARNING: free var (primitive-ref integer->list) not defined in the environmnet
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $32, %ebp     # bump ebp
    jmp _L_1432611            # jump around closure body
_L_1432610:
# check argument count
    cmp $4,%eax
    je _L_1432612
# invoke error handler eh_argcount
    .extern mrc_eh$uargcount
    movl mrc_eh$uargcount, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_1432612:
# emit-tail-expr
# si=-12
# env=((f196031 . -8) ((primitive-ref integer->list) . 24) ((primitive-ref write-char) . 20) ((primitive-ref map) . 16) (f196016 . 12) ((primitive-ref write-char) . 8) ((primitive-ref negative?) . 4) (f196013 . -24) (f196014 . -20) (f196015 . -16) (f196016 . -12) (f196017 . -8) (f196018 . -4) (f196019 . 0))
# expr=(let ((f196031 f196031)) (if ((primitive-ref negative?) f196031) (begin ((primitive-ref write-char) #\-) ((vector-ref f196016 0) (fx* -1 f196031))) ((primitive-ref map) (closure (f196033) ((primitive-ref write-char)) (let ((f196033 f196033)) ((primitive-ref write-char) (fixnum->char (fx+ (char->fixnum #\0) f196033))))) ((primitive-ref integer->list) f196031))))
# emit-tail-let
#  si   = -12
#  env  = ((f196031 . -8) ((primitive-ref integer->list) . 24) ((primitive-ref write-char) . 20) ((primitive-ref map) . 16) (f196016 . 12) ((primitive-ref write-char) . 8) ((primitive-ref negative?) . 4) (f196013 . -24) (f196014 . -20) (f196015 . -16) (f196016 . -12) (f196017 . -8) (f196018 . -4) (f196019 . 0))
#  bindings = ((f196031 f196031))
#  body = (if ((primitive-ref negative?) f196031) (begin ((primitive-ref write-char) #\-) ((vector-ref f196016 0) (fx* -1 f196031))) ((primitive-ref map) (closure (f196033) ((primitive-ref write-char)) (let ((f196033 f196033)) ((primitive-ref write-char) (fixnum->char (fx+ (char->fixnum #\0) f196033))))) ((primitive-ref integer->list) f196031)))
# emit-expr f196031
# emit-variable-ref
# env=((f196031 . -8) ((primitive-ref integer->list) . 24) ((primitive-ref write-char) . 20) ((primitive-ref map) . 16) (f196016 . 12) ((primitive-ref write-char) . 8) ((primitive-ref negative?) . 4) (f196013 . -24) (f196014 . -20) (f196015 . -16) (f196016 . -12) (f196017 . -8) (f196018 . -4) (f196019 . 0))
# var=f196031
    movl -8(%esp), %eax  # stack load f196031
# end emit-variable-ref
    movl %eax, -12(%esp)  # stack save
# emit-tail-expr
# si=-16
# env=((f196031 . -12) (f196031 . -8) ((primitive-ref integer->list) . 24) ((primitive-ref write-char) . 20) ((primitive-ref map) . 16) (f196016 . 12) ((primitive-ref write-char) . 8) ((primitive-ref negative?) . 4) (f196013 . -24) (f196014 . -20) (f196015 . -16) (f196016 . -12) (f196017 . -8) (f196018 . -4) (f196019 . 0))
# expr=(if ((primitive-ref negative?) f196031) (begin ((primitive-ref write-char) #\-) ((vector-ref f196016 0) (fx* -1 f196031))) ((primitive-ref map) (closure (f196033) ((primitive-ref write-char)) (let ((f196033 f196033)) ((primitive-ref write-char) (fixnum->char (fx+ (char->fixnum #\0) f196033))))) ((primitive-ref integer->list) f196031)))
# emit-expr ((primitive-ref negative?) f196031)
# funcall
#    si   =-16
#    env  = ((f196031 . -12) (f196031 . -8) ((primitive-ref integer->list) . 24) ((primitive-ref write-char) . 20) ((primitive-ref map) . 16) (f196016 . 12) ((primitive-ref write-char) . 8) ((primitive-ref negative?) . 4) (f196013 . -24) (f196014 . -20) (f196015 . -16) (f196016 . -12) (f196017 . -8) (f196018 . -4) (f196019 . 0))
#    expr = (funcall (primitive-ref negative?) f196031)
# emit-expr (primitive-ref negative?)
    .extern mrc_negative$q
    movl mrc_negative$q,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1432615"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1432615":
   movl %eax,  -24(%esp)  # stash funcall-oper in closure slot
# emit-expr f196031
# emit-variable-ref
# env=((f196031 . -12) (f196031 . -8) ((primitive-ref integer->list) . 24) ((primitive-ref write-char) . 20) ((primitive-ref map) . 16) (f196016 . 12) ((primitive-ref write-char) . 8) ((primitive-ref negative?) . 4) (f196013 . -24) (f196014 . -20) (f196015 . -16) (f196016 . -12) (f196017 . -8) (f196018 . -4) (f196019 . 0))
# var=f196031
    movl -12(%esp), %eax  # stack load f196031
# end emit-variable-ref
    mov %eax, -28(%esp)  # arg f196031
    movl -24(%esp), %edi   # load new closure to %edi
    add $-16, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $16, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    cmp $47, %al
    je _L_1432613
# emit-tail-expr
# si=-16
# env=((f196031 . -12) (f196031 . -8) ((primitive-ref integer->list) . 24) ((primitive-ref write-char) . 20) ((primitive-ref map) . 16) (f196016 . 12) ((primitive-ref write-char) . 8) ((primitive-ref negative?) . 4) (f196013 . -24) (f196014 . -20) (f196015 . -16) (f196016 . -12) (f196017 . -8) (f196018 . -4) (f196019 . 0))
# expr=(begin ((primitive-ref write-char) #\-) ((vector-ref f196016 0) (fx* -1 f196031)))
# tail-begin (begin ((primitive-ref write-char) #\-) ((vector-ref f196016 0) (fx* -1 f196031)))
#   env=((f196031 . -12) (f196031 . -8) ((primitive-ref integer->list) . 24) ((primitive-ref write-char) . 20) ((primitive-ref map) . 16) (f196016 . 12) ((primitive-ref write-char) . 8) ((primitive-ref negative?) . 4) (f196013 . -24) (f196014 . -20) (f196015 . -16) (f196016 . -12) (f196017 . -8) (f196018 . -4) (f196019 . 0))
# emit-expr ((primitive-ref write-char) #\-)
# funcall
#    si   =-16
#    env  = ((f196031 . -12) (f196031 . -8) ((primitive-ref integer->list) . 24) ((primitive-ref write-char) . 20) ((primitive-ref map) . 16) (f196016 . 12) ((primitive-ref write-char) . 8) ((primitive-ref negative?) . 4) (f196013 . -24) (f196014 . -20) (f196015 . -16) (f196016 . -12) (f196017 . -8) (f196018 . -4) (f196019 . 0))
#    expr = (funcall (primitive-ref write-char) #\-)
# emit-expr (primitive-ref write-char)
    .extern mrc_write$mchar
    movl mrc_write$mchar,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1432616"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1432616":
   movl %eax,  -24(%esp)  # stash funcall-oper in closure slot
# emit-expr #\-
    movl $11535, %eax     # immed #\-
    mov %eax, -28(%esp)  # arg -
    movl -24(%esp), %edi   # load new closure to %edi
    add $-16, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $16, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
# emit-tail-expr
# si=-16
# env=((f196031 . -12) (f196031 . -8) ((primitive-ref integer->list) . 24) ((primitive-ref write-char) . 20) ((primitive-ref map) . 16) (f196016 . 12) ((primitive-ref write-char) . 8) ((primitive-ref negative?) . 4) (f196013 . -24) (f196014 . -20) (f196015 . -16) (f196016 . -12) (f196017 . -8) (f196018 . -4) (f196019 . 0))
# expr=(begin ((vector-ref f196016 0) (fx* -1 f196031)))
# tail-begin (begin ((vector-ref f196016 0) (fx* -1 f196031)))
#   env=((f196031 . -12) (f196031 . -8) ((primitive-ref integer->list) . 24) ((primitive-ref write-char) . 20) ((primitive-ref map) . 16) (f196016 . 12) ((primitive-ref write-char) . 8) ((primitive-ref negative?) . 4) (f196013 . -24) (f196014 . -20) (f196015 . -16) (f196016 . -12) (f196017 . -8) (f196018 . -4) (f196019 . 0))
# emit-tail-expr
# si=-16
# env=((f196031 . -12) (f196031 . -8) ((primitive-ref integer->list) . 24) ((primitive-ref write-char) . 20) ((primitive-ref map) . 16) (f196016 . 12) ((primitive-ref write-char) . 8) ((primitive-ref negative?) . 4) (f196013 . -24) (f196014 . -20) (f196015 . -16) (f196016 . -12) (f196017 . -8) (f196018 . -4) (f196019 . 0))
# expr=((vector-ref f196016 0) (fx* -1 f196031))
# emit-tail-funcall
#    si   =-16
#    env  = ((f196031 . -12) (f196031 . -8) ((primitive-ref integer->list) . 24) ((primitive-ref write-char) . 20) ((primitive-ref map) . 16) (f196016 . 12) ((primitive-ref write-char) . 8) ((primitive-ref negative?) . 4) (f196013 . -24) (f196014 . -20) (f196015 . -16) (f196016 . -12) (f196017 . -8) (f196018 . -4) (f196019 . 0))
#    expr = (funcall (vector-ref f196016 0) (fx* -1 f196031))
# emit-expr (vector-ref f196016 0)
# emit-expr f196016
# emit-variable-ref
# env=((f196031 . -12) (f196031 . -8) ((primitive-ref integer->list) . 24) ((primitive-ref write-char) . 20) ((primitive-ref map) . 16) (f196016 . 12) ((primitive-ref write-char) . 8) ((primitive-ref negative?) . 4) (f196013 . -24) (f196014 . -20) (f196015 . -16) (f196016 . -12) (f196017 . -8) (f196018 . -4) (f196019 . 0))
# var=f196016
    movl 10(%edi), %eax  # frame load f196016
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1432617
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1432617:
    movl %eax, -16(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1432618"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1432618:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1432620
    cmp  $0,%eax
    jge _L_1432619
_L_1432620:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1432619:
    movl -16(%esp), %esi
    movl -1(%eax,%esi), %eax
   movl %eax,  -16(%esp)  # stash funcall-oper in next closure slot
# emit-expr (fx* -1 f196031)
# emit-expr f196031
# emit-variable-ref
# env=((f196031 . -12) (f196031 . -8) ((primitive-ref integer->list) . 24) ((primitive-ref write-char) . 20) ((primitive-ref map) . 16) (f196016 . 12) ((primitive-ref write-char) . 8) ((primitive-ref negative?) . 4) (f196013 . -24) (f196014 . -20) (f196015 . -16) (f196016 . -12) (f196017 . -8) (f196018 . -4) (f196019 . 0))
# var=f196031
    movl -12(%esp), %eax  # stack load f196031
# end emit-variable-ref
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1432621"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $88,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1432621:
    sar $2, %eax
    movl %eax, -20(%esp)
# emit-expr -1
    movl $-4, %eax     # immed -1
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1432622"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $88,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1432622:
    imul -20(%esp), %eax
    mov %eax, -20(%esp)    # arg (fx* -1 f196031)
    movl -16(%esp), %edi   # load new closure to %edi
# emit-shift-args:  size=2   si=-16  delta=12
    mov -16(%esp), %ebx  # shift frame cell
    mov %ebx, -4(%esp)  # down to base
# emit-shift-args:  size=1   si=-20  delta=12
    mov -20(%esp), %ebx  # shift frame cell
    mov %ebx, -8(%esp)  # down to base
# emit-shift-args:  size=0   si=-24  delta=12
    movl $4,%eax   # save arg count
    jmp *-2(%edi)  # tail-funcall
     ret   # return thru stack
    jmp _L_1432614
_L_1432613:
# emit-tail-expr
# si=-16
# env=((f196031 . -12) (f196031 . -8) ((primitive-ref integer->list) . 24) ((primitive-ref write-char) . 20) ((primitive-ref map) . 16) (f196016 . 12) ((primitive-ref write-char) . 8) ((primitive-ref negative?) . 4) (f196013 . -24) (f196014 . -20) (f196015 . -16) (f196016 . -12) (f196017 . -8) (f196018 . -4) (f196019 . 0))
# expr=((primitive-ref map) (closure (f196033) ((primitive-ref write-char)) (let ((f196033 f196033)) ((primitive-ref write-char) (fixnum->char (fx+ (char->fixnum #\0) f196033))))) ((primitive-ref integer->list) f196031))
# emit-tail-funcall
#    si   =-16
#    env  = ((f196031 . -12) (f196031 . -8) ((primitive-ref integer->list) . 24) ((primitive-ref write-char) . 20) ((primitive-ref map) . 16) (f196016 . 12) ((primitive-ref write-char) . 8) ((primitive-ref negative?) . 4) (f196013 . -24) (f196014 . -20) (f196015 . -16) (f196016 . -12) (f196017 . -8) (f196018 . -4) (f196019 . 0))
#    expr = (funcall (primitive-ref map) (closure (f196033) ((primitive-ref write-char)) (let ((f196033 f196033)) ((primitive-ref write-char) (fixnum->char (fx+ (char->fixnum #\0) f196033))))) ((primitive-ref integer->list) f196031))
# emit-expr (primitive-ref map)
    .extern mrc_map
    movl mrc_map,%eax
   movl %eax,  -16(%esp)  # stash funcall-oper in next closure slot
# emit-expr (closure (f196033) ((primitive-ref write-char)) (let ((f196033 f196033)) ((primitive-ref write-char) (fixnum->char (fx+ (char->fixnum #\0) f196033)))))
# emit-closure
# si = -20
# env = ((f196031 . -12) (f196031 . -8) ((primitive-ref integer->list) . 24) ((primitive-ref write-char) . 20) ((primitive-ref map) . 16) (f196016 . 12) ((primitive-ref write-char) . 8) ((primitive-ref negative?) . 4) (f196013 . -24) (f196014 . -20) (f196015 . -16) (f196016 . -12) (f196017 . -8) (f196018 . -4) (f196019 . 0))
# expr = (closure (f196033) ((primitive-ref write-char)) (let ((f196033 f196033)) ((primitive-ref write-char) (fixnum->char (fx+ (char->fixnum #\0) f196033)))))
    movl $_L_1432623, 0(%ebp)  # closure label
# emit-variable-ref
# env=((f196031 . -12) (f196031 . -8) ((primitive-ref integer->list) . 24) ((primitive-ref write-char) . 20) ((primitive-ref map) . 16) (f196016 . 12) ((primitive-ref write-char) . 8) ((primitive-ref negative?) . 4) (f196013 . -24) (f196014 . -20) (f196015 . -16) (f196016 . -12) (f196017 . -8) (f196018 . -4) (f196019 . 0))
# var=(primitive-ref write-char)
    movl 18(%edi), %eax  # frame load (primitive-ref write-char)
# end emit-variable-ref
   movl  %eax, 4(%ebp)  # (primitive-ref write-char)
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $8, %ebp     # bump ebp
    jmp _L_1432624            # jump around closure body
_L_1432623:
# check argument count
    cmp $4,%eax
    je _L_1432625
# invoke error handler eh_argcount
    .extern mrc_eh$uargcount
    movl mrc_eh$uargcount, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_1432625:
# emit-tail-expr
# si=-12
# env=((f196033 . -8) ((primitive-ref write-char) . 4) (f196031 . -12) (f196031 . -8) ((primitive-ref integer->list) . 24) ((primitive-ref write-char) . 20) ((primitive-ref map) . 16) (f196016 . 12) ((primitive-ref write-char) . 8) ((primitive-ref negative?) . 4) (f196013 . -24) (f196014 . -20) (f196015 . -16) (f196016 . -12) (f196017 . -8) (f196018 . -4) (f196019 . 0))
# expr=(let ((f196033 f196033)) ((primitive-ref write-char) (fixnum->char (fx+ (char->fixnum #\0) f196033))))
# emit-tail-let
#  si   = -12
#  env  = ((f196033 . -8) ((primitive-ref write-char) . 4) (f196031 . -12) (f196031 . -8) ((primitive-ref integer->list) . 24) ((primitive-ref write-char) . 20) ((primitive-ref map) . 16) (f196016 . 12) ((primitive-ref write-char) . 8) ((primitive-ref negative?) . 4) (f196013 . -24) (f196014 . -20) (f196015 . -16) (f196016 . -12) (f196017 . -8) (f196018 . -4) (f196019 . 0))
#  bindings = ((f196033 f196033))
#  body = ((primitive-ref write-char) (fixnum->char (fx+ (char->fixnum #\0) f196033)))
# emit-expr f196033
# emit-variable-ref
# env=((f196033 . -8) ((primitive-ref write-char) . 4) (f196031 . -12) (f196031 . -8) ((primitive-ref integer->list) . 24) ((primitive-ref write-char) . 20) ((primitive-ref map) . 16) (f196016 . 12) ((primitive-ref write-char) . 8) ((primitive-ref negative?) . 4) (f196013 . -24) (f196014 . -20) (f196015 . -16) (f196016 . -12) (f196017 . -8) (f196018 . -4) (f196019 . 0))
# var=f196033
    movl -8(%esp), %eax  # stack load f196033
# end emit-variable-ref
    movl %eax, -12(%esp)  # stack save
# emit-tail-expr
# si=-16
# env=((f196033 . -12) (f196033 . -8) ((primitive-ref write-char) . 4) (f196031 . -12) (f196031 . -8) ((primitive-ref integer->list) . 24) ((primitive-ref write-char) . 20) ((primitive-ref map) . 16) (f196016 . 12) ((primitive-ref write-char) . 8) ((primitive-ref negative?) . 4) (f196013 . -24) (f196014 . -20) (f196015 . -16) (f196016 . -12) (f196017 . -8) (f196018 . -4) (f196019 . 0))
# expr=((primitive-ref write-char) (fixnum->char (fx+ (char->fixnum #\0) f196033)))
# emit-tail-funcall
#    si   =-16
#    env  = ((f196033 . -12) (f196033 . -8) ((primitive-ref write-char) . 4) (f196031 . -12) (f196031 . -8) ((primitive-ref integer->list) . 24) ((primitive-ref write-char) . 20) ((primitive-ref map) . 16) (f196016 . 12) ((primitive-ref write-char) . 8) ((primitive-ref negative?) . 4) (f196013 . -24) (f196014 . -20) (f196015 . -16) (f196016 . -12) (f196017 . -8) (f196018 . -4) (f196019 . 0))
#    expr = (funcall (primitive-ref write-char) (fixnum->char (fx+ (char->fixnum #\0) f196033)))
# emit-expr (primitive-ref write-char)
    .extern mrc_write$mchar
    movl mrc_write$mchar,%eax
   movl %eax,  -16(%esp)  # stash funcall-oper in next closure slot
# emit-expr (fixnum->char (fx+ (char->fixnum #\0) f196033))
# emit-expr (fx+ (char->fixnum #\0) f196033)
# emit-expr f196033
# emit-variable-ref
# env=((f196033 . -12) (f196033 . -8) ((primitive-ref write-char) . 4) (f196031 . -12) (f196031 . -8) ((primitive-ref integer->list) . 24) ((primitive-ref write-char) . 20) ((primitive-ref map) . 16) (f196016 . 12) ((primitive-ref write-char) . 8) ((primitive-ref negative?) . 4) (f196013 . -24) (f196014 . -20) (f196015 . -16) (f196016 . -12) (f196017 . -8) (f196018 . -4) (f196019 . 0))
# var=f196033
    movl -12(%esp), %eax  # stack load f196033
# end emit-variable-ref
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1432626"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $80,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1432626:
    movl %eax, -20(%esp)  # fx+ push arg1
# emit-expr (char->fixnum #\0)
# emit-expr #\0
    movl $12303, %eax     # immed #\0
# check the argument is a char
    movl %eax,%ebx
    and $255, %bl
    cmp $15, %bl
    je "_L_1432627"
# invoke error handler eh_character
    .extern mrc_eh$ucharacter
    movl mrc_eh$ucharacter, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $4,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1432627:
   shrl $8, %eax
   shll $2, %eax
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1432628"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $80,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1432628:
    addl -20(%esp), %eax  # fx+ arg1 arg2
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1432629"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $0,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1432629:
    shll $6, %eax
    orl $15, %eax
    mov %eax, -20(%esp)    # arg (fixnum->char (fx+ (char->fixnum 0) f196033))
    movl -16(%esp), %edi   # load new closure to %edi
# emit-shift-args:  size=2   si=-16  delta=12
    mov -16(%esp), %ebx  # shift frame cell
    mov %ebx, -4(%esp)  # down to base
# emit-shift-args:  size=1   si=-20  delta=12
    mov -20(%esp), %ebx  # shift frame cell
    mov %ebx, -8(%esp)  # down to base
# emit-shift-args:  size=0   si=-24  delta=12
    movl $4,%eax   # save arg count
    jmp *-2(%edi)  # tail-funcall
    .align 4,0x90
_L_1432624:
    mov %eax, -20(%esp)    # arg (closure (f196033) ((primitive-ref write-char)) (let ((f196033 f196033)) ((primitive-ref write-char) (fixnum->char (fx+ (char->fixnum 0) f196033)))))
# emit-expr ((primitive-ref integer->list) f196031)
# funcall
#    si   =-24
#    env  = ((f196031 . -12) (f196031 . -8) ((primitive-ref integer->list) . 24) ((primitive-ref write-char) . 20) ((primitive-ref map) . 16) (f196016 . 12) ((primitive-ref write-char) . 8) ((primitive-ref negative?) . 4) (f196013 . -24) (f196014 . -20) (f196015 . -16) (f196016 . -12) (f196017 . -8) (f196018 . -4) (f196019 . 0))
#    expr = (funcall (primitive-ref integer->list) f196031)
# emit-expr (primitive-ref integer->list)
    .extern mrc_integer$m$glist
    movl mrc_integer$m$glist,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1432630"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1432630":
   movl %eax,  -32(%esp)  # stash funcall-oper in closure slot
# emit-expr f196031
# emit-variable-ref
# env=((f196031 . -12) (f196031 . -8) ((primitive-ref integer->list) . 24) ((primitive-ref write-char) . 20) ((primitive-ref map) . 16) (f196016 . 12) ((primitive-ref write-char) . 8) ((primitive-ref negative?) . 4) (f196013 . -24) (f196014 . -20) (f196015 . -16) (f196016 . -12) (f196017 . -8) (f196018 . -4) (f196019 . 0))
# var=f196031
    movl -12(%esp), %eax  # stack load f196031
# end emit-variable-ref
    mov %eax, -36(%esp)  # arg f196031
    movl -32(%esp), %edi   # load new closure to %edi
    add $-24, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $24, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    mov %eax, -24(%esp)    # arg ((primitive-ref integer->list) f196031)
    movl -16(%esp), %edi   # load new closure to %edi
# emit-shift-args:  size=3   si=-16  delta=12
    mov -16(%esp), %ebx  # shift frame cell
    mov %ebx, -4(%esp)  # down to base
# emit-shift-args:  size=2   si=-20  delta=12
    mov -20(%esp), %ebx  # shift frame cell
    mov %ebx, -8(%esp)  # down to base
# emit-shift-args:  size=1   si=-24  delta=12
    mov -24(%esp), %ebx  # shift frame cell
    mov %ebx, -12(%esp)  # down to base
# emit-shift-args:  size=0   si=-28  delta=12
    movl $8,%eax   # save arg count
    jmp *-2(%edi)  # tail-funcall
_L_1432614:
    .align 4,0x90
_L_1432611:
    movl -28(%esp), %ebx
    movl -32(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin (vector-set! f196015 0 (closure (f196030) ((primitive-ref write-char) (primitive-ref for-each) (primitive-ref write-char) (primitive-ref string->list) (primitive-ref write-char)) (let ((f196030 f196030)) (begin ((primitive-ref write-char) #\") ((primitive-ref for-each) (primitive-ref write-char) ((primitive-ref string->list) f196030)) ((primitive-ref write-char) #\"))))) (vector-set! f196014 0 (closure (f196029) ((primitive-ref write-char) f196013 (primitive-ref write-char)) (let ((f196029 f196029)) (begin ((primitive-ref write-char) #\() ((vector-ref f196013 0) f196029) ((primitive-ref write-char) #\)))))) (vector-set! f196013 0 (closure (f196028) ((primitive-ref write) (primitive-ref write-char) f196013 else (primitive-ref write-char) (primitive-ref write-char) (primitive-ref write-char) (primitive-ref write)) (let ((f196028 f196028)) (begin ((primitive-ref write) (car f196028)) (if (null? (cdr f196028)) #t (if (pair? (cdr f196028)) (begin ((primitive-ref write-char) #\space) ((vector-ref f196013 0) (cdr f196028))) (begin ((primitive-ref write-char) #\space) ((primitive-ref write-char) #\.) ((primitive-ref write-char) #\space) ((primitive-ref write) (cdr f196028))))))))))
# emit-begin
#   expr=(begin (vector-set! f196015 0 (closure (f196030) ((primitive-ref write-char) (primitive-ref for-each) (primitive-ref write-char) (primitive-ref string->list) (primitive-ref write-char)) (let ((f196030 f196030)) (begin ((primitive-ref write-char) #\") ((primitive-ref for-each) (primitive-ref write-char) ((primitive-ref string->list) f196030)) ((primitive-ref write-char) #\"))))) (vector-set! f196014 0 (closure (f196029) ((primitive-ref write-char) f196013 (primitive-ref write-char)) (let ((f196029 f196029)) (begin ((primitive-ref write-char) #\() ((vector-ref f196013 0) f196029) ((primitive-ref write-char) #\)))))) (vector-set! f196013 0 (closure (f196028) ((primitive-ref write) (primitive-ref write-char) f196013 else (primitive-ref write-char) (primitive-ref write-char) (primitive-ref write-char) (primitive-ref write)) (let ((f196028 f196028)) (begin ((primitive-ref write) (car f196028)) (if (null? (cdr f196028)) #t (if (pair? (cdr f196028)) (begin ((primitive-ref write-char) #\space) ((vector-ref f196013 0) (cdr f196028))) (begin ((primitive-ref write-char) #\space) ((primitive-ref write-char) #\.) ((primitive-ref write-char) #\space) ((primitive-ref write) (cdr f196028))))))))))
#   env=((f196013 . -24) (f196014 . -20) (f196015 . -16) (f196016 . -12) (f196017 . -8) (f196018 . -4) (f196019 . 0))
# emit-expr (vector-set! f196015 0 (closure (f196030) ((primitive-ref write-char) (primitive-ref for-each) (primitive-ref write-char) (primitive-ref string->list) (primitive-ref write-char)) (let ((f196030 f196030)) (begin ((primitive-ref write-char) #\") ((primitive-ref for-each) (primitive-ref write-char) ((primitive-ref string->list) f196030)) ((primitive-ref write-char) #\")))))
# emit-expr f196015
# emit-variable-ref
# env=((f196013 . -24) (f196014 . -20) (f196015 . -16) (f196016 . -12) (f196017 . -8) (f196018 . -4) (f196019 . 0))
# var=f196015
    movl -16(%esp), %eax  # stack load f196015
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1432631
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1432631:
    movl %eax, -28(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1432632"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1432632:
# check bounds on vector index
    movl -28(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1432634
    cmp  $0,%eax
    jge _L_1432633
_L_1432634:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1432633:
    movl %eax, -32(%esp)
# emit-expr (closure (f196030) ((primitive-ref write-char) (primitive-ref for-each) (primitive-ref write-char) (primitive-ref string->list) (primitive-ref write-char)) (let ((f196030 f196030)) (begin ((primitive-ref write-char) #\") ((primitive-ref for-each) (primitive-ref write-char) ((primitive-ref string->list) f196030)) ((primitive-ref write-char) #\"))))
# emit-closure
# si = -36
# env = ((f196013 . -24) (f196014 . -20) (f196015 . -16) (f196016 . -12) (f196017 . -8) (f196018 . -4) (f196019 . 0))
# expr = (closure (f196030) ((primitive-ref write-char) (primitive-ref for-each) (primitive-ref write-char) (primitive-ref string->list) (primitive-ref write-char)) (let ((f196030 f196030)) (begin ((primitive-ref write-char) #\") ((primitive-ref for-each) (primitive-ref write-char) ((primitive-ref string->list) f196030)) ((primitive-ref write-char) #\"))))
    movl $_L_1432635, 0(%ebp)  # closure label
# WARNING: free var (primitive-ref write-char) not defined in the environmnet
# WARNING: free var (primitive-ref for-each) not defined in the environmnet
# WARNING: free var (primitive-ref write-char) not defined in the environmnet
# WARNING: free var (primitive-ref string->list) not defined in the environmnet
# WARNING: free var (primitive-ref write-char) not defined in the environmnet
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $24, %ebp     # bump ebp
    jmp _L_1432636            # jump around closure body
_L_1432635:
# check argument count
    cmp $4,%eax
    je _L_1432637
# invoke error handler eh_argcount
    .extern mrc_eh$uargcount
    movl mrc_eh$uargcount, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_1432637:
# emit-tail-expr
# si=-12
# env=((f196030 . -8) ((primitive-ref write-char) . 20) ((primitive-ref string->list) . 16) ((primitive-ref write-char) . 12) ((primitive-ref for-each) . 8) ((primitive-ref write-char) . 4) (f196013 . -24) (f196014 . -20) (f196015 . -16) (f196016 . -12) (f196017 . -8) (f196018 . -4) (f196019 . 0))
# expr=(let ((f196030 f196030)) (begin ((primitive-ref write-char) #\") ((primitive-ref for-each) (primitive-ref write-char) ((primitive-ref string->list) f196030)) ((primitive-ref write-char) #\")))
# emit-tail-let
#  si   = -12
#  env  = ((f196030 . -8) ((primitive-ref write-char) . 20) ((primitive-ref string->list) . 16) ((primitive-ref write-char) . 12) ((primitive-ref for-each) . 8) ((primitive-ref write-char) . 4) (f196013 . -24) (f196014 . -20) (f196015 . -16) (f196016 . -12) (f196017 . -8) (f196018 . -4) (f196019 . 0))
#  bindings = ((f196030 f196030))
#  body = (begin ((primitive-ref write-char) #\") ((primitive-ref for-each) (primitive-ref write-char) ((primitive-ref string->list) f196030)) ((primitive-ref write-char) #\"))
# emit-expr f196030
# emit-variable-ref
# env=((f196030 . -8) ((primitive-ref write-char) . 20) ((primitive-ref string->list) . 16) ((primitive-ref write-char) . 12) ((primitive-ref for-each) . 8) ((primitive-ref write-char) . 4) (f196013 . -24) (f196014 . -20) (f196015 . -16) (f196016 . -12) (f196017 . -8) (f196018 . -4) (f196019 . 0))
# var=f196030
    movl -8(%esp), %eax  # stack load f196030
# end emit-variable-ref
    movl %eax, -12(%esp)  # stack save
# emit-tail-expr
# si=-16
# env=((f196030 . -12) (f196030 . -8) ((primitive-ref write-char) . 20) ((primitive-ref string->list) . 16) ((primitive-ref write-char) . 12) ((primitive-ref for-each) . 8) ((primitive-ref write-char) . 4) (f196013 . -24) (f196014 . -20) (f196015 . -16) (f196016 . -12) (f196017 . -8) (f196018 . -4) (f196019 . 0))
# expr=(begin ((primitive-ref write-char) #\") ((primitive-ref for-each) (primitive-ref write-char) ((primitive-ref string->list) f196030)) ((primitive-ref write-char) #\"))
# tail-begin (begin ((primitive-ref write-char) #\") ((primitive-ref for-each) (primitive-ref write-char) ((primitive-ref string->list) f196030)) ((primitive-ref write-char) #\"))
#   env=((f196030 . -12) (f196030 . -8) ((primitive-ref write-char) . 20) ((primitive-ref string->list) . 16) ((primitive-ref write-char) . 12) ((primitive-ref for-each) . 8) ((primitive-ref write-char) . 4) (f196013 . -24) (f196014 . -20) (f196015 . -16) (f196016 . -12) (f196017 . -8) (f196018 . -4) (f196019 . 0))
# emit-expr ((primitive-ref write-char) #\")
# funcall
#    si   =-16
#    env  = ((f196030 . -12) (f196030 . -8) ((primitive-ref write-char) . 20) ((primitive-ref string->list) . 16) ((primitive-ref write-char) . 12) ((primitive-ref for-each) . 8) ((primitive-ref write-char) . 4) (f196013 . -24) (f196014 . -20) (f196015 . -16) (f196016 . -12) (f196017 . -8) (f196018 . -4) (f196019 . 0))
#    expr = (funcall (primitive-ref write-char) #\")
# emit-expr (primitive-ref write-char)
    .extern mrc_write$mchar
    movl mrc_write$mchar,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1432638"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1432638":
   movl %eax,  -24(%esp)  # stash funcall-oper in closure slot
# emit-expr #\"
    movl $8719, %eax     # immed #\"
    mov %eax, -28(%esp)  # arg "
    movl -24(%esp), %edi   # load new closure to %edi
    add $-16, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $16, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
# emit-tail-expr
# si=-16
# env=((f196030 . -12) (f196030 . -8) ((primitive-ref write-char) . 20) ((primitive-ref string->list) . 16) ((primitive-ref write-char) . 12) ((primitive-ref for-each) . 8) ((primitive-ref write-char) . 4) (f196013 . -24) (f196014 . -20) (f196015 . -16) (f196016 . -12) (f196017 . -8) (f196018 . -4) (f196019 . 0))
# expr=(begin ((primitive-ref for-each) (primitive-ref write-char) ((primitive-ref string->list) f196030)) ((primitive-ref write-char) #\"))
# tail-begin (begin ((primitive-ref for-each) (primitive-ref write-char) ((primitive-ref string->list) f196030)) ((primitive-ref write-char) #\"))
#   env=((f196030 . -12) (f196030 . -8) ((primitive-ref write-char) . 20) ((primitive-ref string->list) . 16) ((primitive-ref write-char) . 12) ((primitive-ref for-each) . 8) ((primitive-ref write-char) . 4) (f196013 . -24) (f196014 . -20) (f196015 . -16) (f196016 . -12) (f196017 . -8) (f196018 . -4) (f196019 . 0))
# emit-expr ((primitive-ref for-each) (primitive-ref write-char) ((primitive-ref string->list) f196030))
# funcall
#    si   =-16
#    env  = ((f196030 . -12) (f196030 . -8) ((primitive-ref write-char) . 20) ((primitive-ref string->list) . 16) ((primitive-ref write-char) . 12) ((primitive-ref for-each) . 8) ((primitive-ref write-char) . 4) (f196013 . -24) (f196014 . -20) (f196015 . -16) (f196016 . -12) (f196017 . -8) (f196018 . -4) (f196019 . 0))
#    expr = (funcall (primitive-ref for-each) (primitive-ref write-char) ((primitive-ref string->list) f196030))
# emit-expr (primitive-ref for-each)
    .extern mrc_for$meach
    movl mrc_for$meach,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1432639"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1432639":
   movl %eax,  -24(%esp)  # stash funcall-oper in closure slot
# emit-expr (primitive-ref write-char)
    .extern mrc_write$mchar
    movl mrc_write$mchar,%eax
    mov %eax, -28(%esp)  # arg (primitive-ref write-char)
# emit-expr ((primitive-ref string->list) f196030)
# funcall
#    si   =-32
#    env  = ((f196030 . -12) (f196030 . -8) ((primitive-ref write-char) . 20) ((primitive-ref string->list) . 16) ((primitive-ref write-char) . 12) ((primitive-ref for-each) . 8) ((primitive-ref write-char) . 4) (f196013 . -24) (f196014 . -20) (f196015 . -16) (f196016 . -12) (f196017 . -8) (f196018 . -4) (f196019 . 0))
#    expr = (funcall (primitive-ref string->list) f196030)
# emit-expr (primitive-ref string->list)
    .extern mrc_string$m$glist
    movl mrc_string$m$glist,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1432640"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1432640":
   movl %eax,  -40(%esp)  # stash funcall-oper in closure slot
# emit-expr f196030
# emit-variable-ref
# env=((f196030 . -12) (f196030 . -8) ((primitive-ref write-char) . 20) ((primitive-ref string->list) . 16) ((primitive-ref write-char) . 12) ((primitive-ref for-each) . 8) ((primitive-ref write-char) . 4) (f196013 . -24) (f196014 . -20) (f196015 . -16) (f196016 . -12) (f196017 . -8) (f196018 . -4) (f196019 . 0))
# var=f196030
    movl -12(%esp), %eax  # stack load f196030
# end emit-variable-ref
    mov %eax, -44(%esp)  # arg f196030
    movl -40(%esp), %edi   # load new closure to %edi
    add $-32, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $32, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    mov %eax, -32(%esp)  # arg ((primitive-ref string->list) f196030)
    movl -24(%esp), %edi   # load new closure to %edi
    add $-16, %esp   # adjust base
    movl $8,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $16, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
# emit-tail-expr
# si=-16
# env=((f196030 . -12) (f196030 . -8) ((primitive-ref write-char) . 20) ((primitive-ref string->list) . 16) ((primitive-ref write-char) . 12) ((primitive-ref for-each) . 8) ((primitive-ref write-char) . 4) (f196013 . -24) (f196014 . -20) (f196015 . -16) (f196016 . -12) (f196017 . -8) (f196018 . -4) (f196019 . 0))
# expr=(begin ((primitive-ref write-char) #\"))
# tail-begin (begin ((primitive-ref write-char) #\"))
#   env=((f196030 . -12) (f196030 . -8) ((primitive-ref write-char) . 20) ((primitive-ref string->list) . 16) ((primitive-ref write-char) . 12) ((primitive-ref for-each) . 8) ((primitive-ref write-char) . 4) (f196013 . -24) (f196014 . -20) (f196015 . -16) (f196016 . -12) (f196017 . -8) (f196018 . -4) (f196019 . 0))
# emit-tail-expr
# si=-16
# env=((f196030 . -12) (f196030 . -8) ((primitive-ref write-char) . 20) ((primitive-ref string->list) . 16) ((primitive-ref write-char) . 12) ((primitive-ref for-each) . 8) ((primitive-ref write-char) . 4) (f196013 . -24) (f196014 . -20) (f196015 . -16) (f196016 . -12) (f196017 . -8) (f196018 . -4) (f196019 . 0))
# expr=((primitive-ref write-char) #\")
# emit-tail-funcall
#    si   =-16
#    env  = ((f196030 . -12) (f196030 . -8) ((primitive-ref write-char) . 20) ((primitive-ref string->list) . 16) ((primitive-ref write-char) . 12) ((primitive-ref for-each) . 8) ((primitive-ref write-char) . 4) (f196013 . -24) (f196014 . -20) (f196015 . -16) (f196016 . -12) (f196017 . -8) (f196018 . -4) (f196019 . 0))
#    expr = (funcall (primitive-ref write-char) #\")
# emit-expr (primitive-ref write-char)
    .extern mrc_write$mchar
    movl mrc_write$mchar,%eax
   movl %eax,  -16(%esp)  # stash funcall-oper in next closure slot
# emit-expr #\"
    movl $8719, %eax     # immed #\"
    mov %eax, -20(%esp)    # arg "
    movl -16(%esp), %edi   # load new closure to %edi
# emit-shift-args:  size=2   si=-16  delta=12
    mov -16(%esp), %ebx  # shift frame cell
    mov %ebx, -4(%esp)  # down to base
# emit-shift-args:  size=1   si=-20  delta=12
    mov -20(%esp), %ebx  # shift frame cell
    mov %ebx, -8(%esp)  # down to base
# emit-shift-args:  size=0   si=-24  delta=12
    movl $4,%eax   # save arg count
    jmp *-2(%edi)  # tail-funcall
     ret   # return thru stack
    .align 4,0x90
_L_1432636:
    movl -28(%esp), %ebx
    movl -32(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin (vector-set! f196014 0 (closure (f196029) ((primitive-ref write-char) f196013 (primitive-ref write-char)) (let ((f196029 f196029)) (begin ((primitive-ref write-char) #\() ((vector-ref f196013 0) f196029) ((primitive-ref write-char) #\)))))) (vector-set! f196013 0 (closure (f196028) ((primitive-ref write) (primitive-ref write-char) f196013 else (primitive-ref write-char) (primitive-ref write-char) (primitive-ref write-char) (primitive-ref write)) (let ((f196028 f196028)) (begin ((primitive-ref write) (car f196028)) (if (null? (cdr f196028)) #t (if (pair? (cdr f196028)) (begin ((primitive-ref write-char) #\space) ((vector-ref f196013 0) (cdr f196028))) (begin ((primitive-ref write-char) #\space) ((primitive-ref write-char) #\.) ((primitive-ref write-char) #\space) ((primitive-ref write) (cdr f196028))))))))))
# emit-begin
#   expr=(begin (vector-set! f196014 0 (closure (f196029) ((primitive-ref write-char) f196013 (primitive-ref write-char)) (let ((f196029 f196029)) (begin ((primitive-ref write-char) #\() ((vector-ref f196013 0) f196029) ((primitive-ref write-char) #\)))))) (vector-set! f196013 0 (closure (f196028) ((primitive-ref write) (primitive-ref write-char) f196013 else (primitive-ref write-char) (primitive-ref write-char) (primitive-ref write-char) (primitive-ref write)) (let ((f196028 f196028)) (begin ((primitive-ref write) (car f196028)) (if (null? (cdr f196028)) #t (if (pair? (cdr f196028)) (begin ((primitive-ref write-char) #\space) ((vector-ref f196013 0) (cdr f196028))) (begin ((primitive-ref write-char) #\space) ((primitive-ref write-char) #\.) ((primitive-ref write-char) #\space) ((primitive-ref write) (cdr f196028))))))))))
#   env=((f196013 . -24) (f196014 . -20) (f196015 . -16) (f196016 . -12) (f196017 . -8) (f196018 . -4) (f196019 . 0))
# emit-expr (vector-set! f196014 0 (closure (f196029) ((primitive-ref write-char) f196013 (primitive-ref write-char)) (let ((f196029 f196029)) (begin ((primitive-ref write-char) #\() ((vector-ref f196013 0) f196029) ((primitive-ref write-char) #\))))))
# emit-expr f196014
# emit-variable-ref
# env=((f196013 . -24) (f196014 . -20) (f196015 . -16) (f196016 . -12) (f196017 . -8) (f196018 . -4) (f196019 . 0))
# var=f196014
    movl -20(%esp), %eax  # stack load f196014
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1432641
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1432641:
    movl %eax, -28(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1432642"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1432642:
# check bounds on vector index
    movl -28(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1432644
    cmp  $0,%eax
    jge _L_1432643
_L_1432644:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1432643:
    movl %eax, -32(%esp)
# emit-expr (closure (f196029) ((primitive-ref write-char) f196013 (primitive-ref write-char)) (let ((f196029 f196029)) (begin ((primitive-ref write-char) #\() ((vector-ref f196013 0) f196029) ((primitive-ref write-char) #\)))))
# emit-closure
# si = -36
# env = ((f196013 . -24) (f196014 . -20) (f196015 . -16) (f196016 . -12) (f196017 . -8) (f196018 . -4) (f196019 . 0))
# expr = (closure (f196029) ((primitive-ref write-char) f196013 (primitive-ref write-char)) (let ((f196029 f196029)) (begin ((primitive-ref write-char) #\() ((vector-ref f196013 0) f196029) ((primitive-ref write-char) #\)))))
    movl $_L_1432645, 0(%ebp)  # closure label
# WARNING: free var (primitive-ref write-char) not defined in the environmnet
# emit-variable-ref
# env=((f196013 . -24) (f196014 . -20) (f196015 . -16) (f196016 . -12) (f196017 . -8) (f196018 . -4) (f196019 . 0))
# var=f196013
    movl -24(%esp), %eax  # stack load f196013
# end emit-variable-ref
   movl  %eax, 8(%ebp)  # f196013
# WARNING: free var (primitive-ref write-char) not defined in the environmnet
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $16, %ebp     # bump ebp
    jmp _L_1432646            # jump around closure body
_L_1432645:
# check argument count
    cmp $4,%eax
    je _L_1432647
# invoke error handler eh_argcount
    .extern mrc_eh$uargcount
    movl mrc_eh$uargcount, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_1432647:
# emit-tail-expr
# si=-12
# env=((f196029 . -8) ((primitive-ref write-char) . 12) (f196013 . 8) ((primitive-ref write-char) . 4) (f196013 . -24) (f196014 . -20) (f196015 . -16) (f196016 . -12) (f196017 . -8) (f196018 . -4) (f196019 . 0))
# expr=(let ((f196029 f196029)) (begin ((primitive-ref write-char) #\() ((vector-ref f196013 0) f196029) ((primitive-ref write-char) #\))))
# emit-tail-let
#  si   = -12
#  env  = ((f196029 . -8) ((primitive-ref write-char) . 12) (f196013 . 8) ((primitive-ref write-char) . 4) (f196013 . -24) (f196014 . -20) (f196015 . -16) (f196016 . -12) (f196017 . -8) (f196018 . -4) (f196019 . 0))
#  bindings = ((f196029 f196029))
#  body = (begin ((primitive-ref write-char) #\() ((vector-ref f196013 0) f196029) ((primitive-ref write-char) #\)))
# emit-expr f196029
# emit-variable-ref
# env=((f196029 . -8) ((primitive-ref write-char) . 12) (f196013 . 8) ((primitive-ref write-char) . 4) (f196013 . -24) (f196014 . -20) (f196015 . -16) (f196016 . -12) (f196017 . -8) (f196018 . -4) (f196019 . 0))
# var=f196029
    movl -8(%esp), %eax  # stack load f196029
# end emit-variable-ref
    movl %eax, -12(%esp)  # stack save
# emit-tail-expr
# si=-16
# env=((f196029 . -12) (f196029 . -8) ((primitive-ref write-char) . 12) (f196013 . 8) ((primitive-ref write-char) . 4) (f196013 . -24) (f196014 . -20) (f196015 . -16) (f196016 . -12) (f196017 . -8) (f196018 . -4) (f196019 . 0))
# expr=(begin ((primitive-ref write-char) #\() ((vector-ref f196013 0) f196029) ((primitive-ref write-char) #\)))
# tail-begin (begin ((primitive-ref write-char) #\() ((vector-ref f196013 0) f196029) ((primitive-ref write-char) #\)))
#   env=((f196029 . -12) (f196029 . -8) ((primitive-ref write-char) . 12) (f196013 . 8) ((primitive-ref write-char) . 4) (f196013 . -24) (f196014 . -20) (f196015 . -16) (f196016 . -12) (f196017 . -8) (f196018 . -4) (f196019 . 0))
# emit-expr ((primitive-ref write-char) #\()
# funcall
#    si   =-16
#    env  = ((f196029 . -12) (f196029 . -8) ((primitive-ref write-char) . 12) (f196013 . 8) ((primitive-ref write-char) . 4) (f196013 . -24) (f196014 . -20) (f196015 . -16) (f196016 . -12) (f196017 . -8) (f196018 . -4) (f196019 . 0))
#    expr = (funcall (primitive-ref write-char) #\()
# emit-expr (primitive-ref write-char)
    .extern mrc_write$mchar
    movl mrc_write$mchar,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1432648"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1432648":
   movl %eax,  -24(%esp)  # stash funcall-oper in closure slot
# emit-expr #\(
    movl $10255, %eax     # immed #\(
    mov %eax, -28(%esp)  # arg (
    movl -24(%esp), %edi   # load new closure to %edi
    add $-16, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $16, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
# emit-tail-expr
# si=-16
# env=((f196029 . -12) (f196029 . -8) ((primitive-ref write-char) . 12) (f196013 . 8) ((primitive-ref write-char) . 4) (f196013 . -24) (f196014 . -20) (f196015 . -16) (f196016 . -12) (f196017 . -8) (f196018 . -4) (f196019 . 0))
# expr=(begin ((vector-ref f196013 0) f196029) ((primitive-ref write-char) #\)))
# tail-begin (begin ((vector-ref f196013 0) f196029) ((primitive-ref write-char) #\)))
#   env=((f196029 . -12) (f196029 . -8) ((primitive-ref write-char) . 12) (f196013 . 8) ((primitive-ref write-char) . 4) (f196013 . -24) (f196014 . -20) (f196015 . -16) (f196016 . -12) (f196017 . -8) (f196018 . -4) (f196019 . 0))
# emit-expr ((vector-ref f196013 0) f196029)
# funcall
#    si   =-16
#    env  = ((f196029 . -12) (f196029 . -8) ((primitive-ref write-char) . 12) (f196013 . 8) ((primitive-ref write-char) . 4) (f196013 . -24) (f196014 . -20) (f196015 . -16) (f196016 . -12) (f196017 . -8) (f196018 . -4) (f196019 . 0))
#    expr = (funcall (vector-ref f196013 0) f196029)
# emit-expr (vector-ref f196013 0)
# emit-expr f196013
# emit-variable-ref
# env=((f196029 . -12) (f196029 . -8) ((primitive-ref write-char) . 12) (f196013 . 8) ((primitive-ref write-char) . 4) (f196013 . -24) (f196014 . -20) (f196015 . -16) (f196016 . -12) (f196017 . -8) (f196018 . -4) (f196019 . 0))
# var=f196013
    movl 6(%edi), %eax  # frame load f196013
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1432649
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1432649:
    movl %eax, -24(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1432650"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1432650:
# check bounds on vector index
    movl -24(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1432652
    cmp  $0,%eax
    jge _L_1432651
_L_1432652:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1432651:
    movl -24(%esp), %esi
    movl -1(%eax,%esi), %eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1432653"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1432653":
   movl %eax,  -24(%esp)  # stash funcall-oper in closure slot
# emit-expr f196029
# emit-variable-ref
# env=((f196029 . -12) (f196029 . -8) ((primitive-ref write-char) . 12) (f196013 . 8) ((primitive-ref write-char) . 4) (f196013 . -24) (f196014 . -20) (f196015 . -16) (f196016 . -12) (f196017 . -8) (f196018 . -4) (f196019 . 0))
# var=f196029
    movl -12(%esp), %eax  # stack load f196029
# end emit-variable-ref
    mov %eax, -28(%esp)  # arg f196029
    movl -24(%esp), %edi   # load new closure to %edi
    add $-16, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $16, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
# emit-tail-expr
# si=-16
# env=((f196029 . -12) (f196029 . -8) ((primitive-ref write-char) . 12) (f196013 . 8) ((primitive-ref write-char) . 4) (f196013 . -24) (f196014 . -20) (f196015 . -16) (f196016 . -12) (f196017 . -8) (f196018 . -4) (f196019 . 0))
# expr=(begin ((primitive-ref write-char) #\)))
# tail-begin (begin ((primitive-ref write-char) #\)))
#   env=((f196029 . -12) (f196029 . -8) ((primitive-ref write-char) . 12) (f196013 . 8) ((primitive-ref write-char) . 4) (f196013 . -24) (f196014 . -20) (f196015 . -16) (f196016 . -12) (f196017 . -8) (f196018 . -4) (f196019 . 0))
# emit-tail-expr
# si=-16
# env=((f196029 . -12) (f196029 . -8) ((primitive-ref write-char) . 12) (f196013 . 8) ((primitive-ref write-char) . 4) (f196013 . -24) (f196014 . -20) (f196015 . -16) (f196016 . -12) (f196017 . -8) (f196018 . -4) (f196019 . 0))
# expr=((primitive-ref write-char) #\))
# emit-tail-funcall
#    si   =-16
#    env  = ((f196029 . -12) (f196029 . -8) ((primitive-ref write-char) . 12) (f196013 . 8) ((primitive-ref write-char) . 4) (f196013 . -24) (f196014 . -20) (f196015 . -16) (f196016 . -12) (f196017 . -8) (f196018 . -4) (f196019 . 0))
#    expr = (funcall (primitive-ref write-char) #\))
# emit-expr (primitive-ref write-char)
    .extern mrc_write$mchar
    movl mrc_write$mchar,%eax
   movl %eax,  -16(%esp)  # stash funcall-oper in next closure slot
# emit-expr #\)
    movl $10511, %eax     # immed #\)
    mov %eax, -20(%esp)    # arg )
    movl -16(%esp), %edi   # load new closure to %edi
# emit-shift-args:  size=2   si=-16  delta=12
    mov -16(%esp), %ebx  # shift frame cell
    mov %ebx, -4(%esp)  # down to base
# emit-shift-args:  size=1   si=-20  delta=12
    mov -20(%esp), %ebx  # shift frame cell
    mov %ebx, -8(%esp)  # down to base
# emit-shift-args:  size=0   si=-24  delta=12
    movl $4,%eax   # save arg count
    jmp *-2(%edi)  # tail-funcall
     ret   # return thru stack
    .align 4,0x90
_L_1432646:
    movl -28(%esp), %ebx
    movl -32(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin (vector-set! f196013 0 (closure (f196028) ((primitive-ref write) (primitive-ref write-char) f196013 else (primitive-ref write-char) (primitive-ref write-char) (primitive-ref write-char) (primitive-ref write)) (let ((f196028 f196028)) (begin ((primitive-ref write) (car f196028)) (if (null? (cdr f196028)) #t (if (pair? (cdr f196028)) (begin ((primitive-ref write-char) #\space) ((vector-ref f196013 0) (cdr f196028))) (begin ((primitive-ref write-char) #\space) ((primitive-ref write-char) #\.) ((primitive-ref write-char) #\space) ((primitive-ref write) (cdr f196028))))))))))
# emit-begin
#   expr=(begin (vector-set! f196013 0 (closure (f196028) ((primitive-ref write) (primitive-ref write-char) f196013 else (primitive-ref write-char) (primitive-ref write-char) (primitive-ref write-char) (primitive-ref write)) (let ((f196028 f196028)) (begin ((primitive-ref write) (car f196028)) (if (null? (cdr f196028)) #t (if (pair? (cdr f196028)) (begin ((primitive-ref write-char) #\space) ((vector-ref f196013 0) (cdr f196028))) (begin ((primitive-ref write-char) #\space) ((primitive-ref write-char) #\.) ((primitive-ref write-char) #\space) ((primitive-ref write) (cdr f196028))))))))))
#   env=((f196013 . -24) (f196014 . -20) (f196015 . -16) (f196016 . -12) (f196017 . -8) (f196018 . -4) (f196019 . 0))
# emit-expr (vector-set! f196013 0 (closure (f196028) ((primitive-ref write) (primitive-ref write-char) f196013 else (primitive-ref write-char) (primitive-ref write-char) (primitive-ref write-char) (primitive-ref write)) (let ((f196028 f196028)) (begin ((primitive-ref write) (car f196028)) (if (null? (cdr f196028)) #t (if (pair? (cdr f196028)) (begin ((primitive-ref write-char) #\space) ((vector-ref f196013 0) (cdr f196028))) (begin ((primitive-ref write-char) #\space) ((primitive-ref write-char) #\.) ((primitive-ref write-char) #\space) ((primitive-ref write) (cdr f196028)))))))))
# emit-expr f196013
# emit-variable-ref
# env=((f196013 . -24) (f196014 . -20) (f196015 . -16) (f196016 . -12) (f196017 . -8) (f196018 . -4) (f196019 . 0))
# var=f196013
    movl -24(%esp), %eax  # stack load f196013
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1432654
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1432654:
    movl %eax, -28(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1432655"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1432655:
# check bounds on vector index
    movl -28(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1432657
    cmp  $0,%eax
    jge _L_1432656
_L_1432657:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $136,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1432656:
    movl %eax, -32(%esp)
# emit-expr (closure (f196028) ((primitive-ref write) (primitive-ref write-char) f196013 else (primitive-ref write-char) (primitive-ref write-char) (primitive-ref write-char) (primitive-ref write)) (let ((f196028 f196028)) (begin ((primitive-ref write) (car f196028)) (if (null? (cdr f196028)) #t (if (pair? (cdr f196028)) (begin ((primitive-ref write-char) #\space) ((vector-ref f196013 0) (cdr f196028))) (begin ((primitive-ref write-char) #\space) ((primitive-ref write-char) #\.) ((primitive-ref write-char) #\space) ((primitive-ref write) (cdr f196028))))))))
# emit-closure
# si = -36
# env = ((f196013 . -24) (f196014 . -20) (f196015 . -16) (f196016 . -12) (f196017 . -8) (f196018 . -4) (f196019 . 0))
# expr = (closure (f196028) ((primitive-ref write) (primitive-ref write-char) f196013 else (primitive-ref write-char) (primitive-ref write-char) (primitive-ref write-char) (primitive-ref write)) (let ((f196028 f196028)) (begin ((primitive-ref write) (car f196028)) (if (null? (cdr f196028)) #t (if (pair? (cdr f196028)) (begin ((primitive-ref write-char) #\space) ((vector-ref f196013 0) (cdr f196028))) (begin ((primitive-ref write-char) #\space) ((primitive-ref write-char) #\.) ((primitive-ref write-char) #\space) ((primitive-ref write) (cdr f196028))))))))
    movl $_L_1432658, 0(%ebp)  # closure label
# WARNING: free var (primitive-ref write) not defined in the environmnet
# WARNING: free var (primitive-ref write-char) not defined in the environmnet
# emit-variable-ref
# env=((f196013 . -24) (f196014 . -20) (f196015 . -16) (f196016 . -12) (f196017 . -8) (f196018 . -4) (f196019 . 0))
# var=f196013
    movl -24(%esp), %eax  # stack load f196013
# end emit-variable-ref
   movl  %eax, 12(%ebp)  # f196013
# WARNING: free var else not defined in the environmnet
# WARNING: free var (primitive-ref write-char) not defined in the environmnet
# WARNING: free var (primitive-ref write-char) not defined in the environmnet
# WARNING: free var (primitive-ref write-char) not defined in the environmnet
# WARNING: free var (primitive-ref write) not defined in the environmnet
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $40, %ebp     # bump ebp
    jmp _L_1432659            # jump around closure body
_L_1432658:
# check argument count
    cmp $4,%eax
    je _L_1432660
# invoke error handler eh_argcount
    .extern mrc_eh$uargcount
    movl mrc_eh$uargcount, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_1432660:
# emit-tail-expr
# si=-12
# env=((f196028 . -8) ((primitive-ref write) . 32) ((primitive-ref write-char) . 28) ((primitive-ref write-char) . 24) ((primitive-ref write-char) . 20) (else . 16) (f196013 . 12) ((primitive-ref write-char) . 8) ((primitive-ref write) . 4) (f196013 . -24) (f196014 . -20) (f196015 . -16) (f196016 . -12) (f196017 . -8) (f196018 . -4) (f196019 . 0))
# expr=(let ((f196028 f196028)) (begin ((primitive-ref write) (car f196028)) (if (null? (cdr f196028)) #t (if (pair? (cdr f196028)) (begin ((primitive-ref write-char) #\space) ((vector-ref f196013 0) (cdr f196028))) (begin ((primitive-ref write-char) #\space) ((primitive-ref write-char) #\.) ((primitive-ref write-char) #\space) ((primitive-ref write) (cdr f196028)))))))
# emit-tail-let
#  si   = -12
#  env  = ((f196028 . -8) ((primitive-ref write) . 32) ((primitive-ref write-char) . 28) ((primitive-ref write-char) . 24) ((primitive-ref write-char) . 20) (else . 16) (f196013 . 12) ((primitive-ref write-char) . 8) ((primitive-ref write) . 4) (f196013 . -24) (f196014 . -20) (f196015 . -16) (f196016 . -12) (f196017 . -8) (f196018 . -4) (f196019 . 0))
#  bindings = ((f196028 f196028))
#  body = (begin ((primitive-ref write) (car f196028)) (if (null? (cdr f196028)) #t (if (pair? (cdr f196028)) (begin ((primitive-ref write-char) #\space) ((vector-ref f196013 0) (cdr f196028))) (begin ((primitive-ref write-char) #\space) ((primitive-ref write-char) #\.) ((primitive-ref write-char) #\space) ((primitive-ref write) (cdr f196028))))))
# emit-expr f196028
# emit-variable-ref
# env=((f196028 . -8) ((primitive-ref write) . 32) ((primitive-ref write-char) . 28) ((primitive-ref write-char) . 24) ((primitive-ref write-char) . 20) (else . 16) (f196013 . 12) ((primitive-ref write-char) . 8) ((primitive-ref write) . 4) (f196013 . -24) (f196014 . -20) (f196015 . -16) (f196016 . -12) (f196017 . -8) (f196018 . -4) (f196019 . 0))
# var=f196028
    movl -8(%esp), %eax  # stack load f196028
# end emit-variable-ref
    movl %eax, -12(%esp)  # stack save
# emit-tail-expr
# si=-16
# env=((f196028 . -12) (f196028 . -8) ((primitive-ref write) . 32) ((primitive-ref write-char) . 28) ((primitive-ref write-char) . 24) ((primitive-ref write-char) . 20) (else . 16) (f196013 . 12) ((primitive-ref write-char) . 8) ((primitive-ref write) . 4) (f196013 . -24) (f196014 . -20) (f196015 . -16) (f196016 . -12) (f196017 . -8) (f196018 . -4) (f196019 . 0))
# expr=(begin ((primitive-ref write) (car f196028)) (if (null? (cdr f196028)) #t (if (pair? (cdr f196028)) (begin ((primitive-ref write-char) #\space) ((vector-ref f196013 0) (cdr f196028))) (begin ((primitive-ref write-char) #\space) ((primitive-ref write-char) #\.) ((primitive-ref write-char) #\space) ((primitive-ref write) (cdr f196028))))))
# tail-begin (begin ((primitive-ref write) (car f196028)) (if (null? (cdr f196028)) #t (if (pair? (cdr f196028)) (begin ((primitive-ref write-char) #\space) ((vector-ref f196013 0) (cdr f196028))) (begin ((primitive-ref write-char) #\space) ((primitive-ref write-char) #\.) ((primitive-ref write-char) #\space) ((primitive-ref write) (cdr f196028))))))
#   env=((f196028 . -12) (f196028 . -8) ((primitive-ref write) . 32) ((primitive-ref write-char) . 28) ((primitive-ref write-char) . 24) ((primitive-ref write-char) . 20) (else . 16) (f196013 . 12) ((primitive-ref write-char) . 8) ((primitive-ref write) . 4) (f196013 . -24) (f196014 . -20) (f196015 . -16) (f196016 . -12) (f196017 . -8) (f196018 . -4) (f196019 . 0))
# emit-expr ((primitive-ref write) (car f196028))
# funcall
#    si   =-16
#    env  = ((f196028 . -12) (f196028 . -8) ((primitive-ref write) . 32) ((primitive-ref write-char) . 28) ((primitive-ref write-char) . 24) ((primitive-ref write-char) . 20) (else . 16) (f196013 . 12) ((primitive-ref write-char) . 8) ((primitive-ref write) . 4) (f196013 . -24) (f196014 . -20) (f196015 . -16) (f196016 . -12) (f196017 . -8) (f196018 . -4) (f196019 . 0))
#    expr = (funcall (primitive-ref write) (car f196028))
# emit-expr (primitive-ref write)
    .extern mrc_write
    movl mrc_write,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1432661"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1432661":
   movl %eax,  -24(%esp)  # stash funcall-oper in closure slot
# emit-expr (car f196028)
# emit-expr f196028
# emit-variable-ref
# env=((f196028 . -12) (f196028 . -8) ((primitive-ref write) . 32) ((primitive-ref write-char) . 28) ((primitive-ref write-char) . 24) ((primitive-ref write-char) . 20) (else . 16) (f196013 . 12) ((primitive-ref write-char) . 8) ((primitive-ref write) . 4) (f196013 . -24) (f196014 . -20) (f196015 . -16) (f196016 . -12) (f196017 . -8) (f196018 . -4) (f196019 . 0))
# var=f196028
    movl -12(%esp), %eax  # stack load f196028
# end emit-variable-ref
# check the argument is a pair
    movl %eax,%ebx
    and $7, %bl
    cmp $1, %bl
    je _L_1432662
# invoke error handler eh_pair
    .extern mrc_eh$upair
    movl mrc_eh$upair, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $108,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1432662:
    movl -1(%eax), %eax
    mov %eax, -28(%esp)  # arg (car f196028)
    movl -24(%esp), %edi   # load new closure to %edi
    add $-16, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $16, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
# emit-tail-expr
# si=-16
# env=((f196028 . -12) (f196028 . -8) ((primitive-ref write) . 32) ((primitive-ref write-char) . 28) ((primitive-ref write-char) . 24) ((primitive-ref write-char) . 20) (else . 16) (f196013 . 12) ((primitive-ref write-char) . 8) ((primitive-ref write) . 4) (f196013 . -24) (f196014 . -20) (f196015 . -16) (f196016 . -12) (f196017 . -8) (f196018 . -4) (f196019 . 0))
# expr=(begin (if (null? (cdr f196028)) #t (if (pair? (cdr f196028)) (begin ((primitive-ref write-char) #\space) ((vector-ref f196013 0) (cdr f196028))) (begin ((primitive-ref write-char) #\space) ((primitive-ref write-char) #\.) ((primitive-ref write-char) #\space) ((primitive-ref write) (cdr f196028))))))
# tail-begin (begin (if (null? (cdr f196028)) #t (if (pair? (cdr f196028)) (begin ((primitive-ref write-char) #\space) ((vector-ref f196013 0) (cdr f196028))) (begin ((primitive-ref write-char) #\space) ((primitive-ref write-char) #\.) ((primitive-ref write-char) #\space) ((primitive-ref write) (cdr f196028))))))
#   env=((f196028 . -12) (f196028 . -8) ((primitive-ref write) . 32) ((primitive-ref write-char) . 28) ((primitive-ref write-char) . 24) ((primitive-ref write-char) . 20) (else . 16) (f196013 . 12) ((primitive-ref write-char) . 8) ((primitive-ref write) . 4) (f196013 . -24) (f196014 . -20) (f196015 . -16) (f196016 . -12) (f196017 . -8) (f196018 . -4) (f196019 . 0))
# emit-tail-expr
# si=-16
# env=((f196028 . -12) (f196028 . -8) ((primitive-ref write) . 32) ((primitive-ref write-char) . 28) ((primitive-ref write-char) . 24) ((primitive-ref write-char) . 20) (else . 16) (f196013 . 12) ((primitive-ref write-char) . 8) ((primitive-ref write) . 4) (f196013 . -24) (f196014 . -20) (f196015 . -16) (f196016 . -12) (f196017 . -8) (f196018 . -4) (f196019 . 0))
# expr=(if (null? (cdr f196028)) #t (if (pair? (cdr f196028)) (begin ((primitive-ref write-char) #\space) ((vector-ref f196013 0) (cdr f196028))) (begin ((primitive-ref write-char) #\space) ((primitive-ref write-char) #\.) ((primitive-ref write-char) #\space) ((primitive-ref write) (cdr f196028)))))
# emit-expr (null? (cdr f196028))
# emit-expr (cdr f196028)
# emit-expr f196028
# emit-variable-ref
# env=((f196028 . -12) (f196028 . -8) ((primitive-ref write) . 32) ((primitive-ref write-char) . 28) ((primitive-ref write-char) . 24) ((primitive-ref write-char) . 20) (else . 16) (f196013 . 12) ((primitive-ref write-char) . 8) ((primitive-ref write) . 4) (f196013 . -24) (f196014 . -20) (f196015 . -16) (f196016 . -12) (f196017 . -8) (f196018 . -4) (f196019 . 0))
# var=f196028
    movl -12(%esp), %eax  # stack load f196028
# end emit-variable-ref
# check the argument is a pair
    movl %eax,%ebx
    and $7, %bl
    cmp $1, %bl
    je _L_1432665
# invoke error handler eh_pair
    .extern mrc_eh$upair
    movl mrc_eh$upair, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $112,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1432665:
    movl 3(%eax), %eax
    cmp $63, %eax
    mov $0, %eax
    sete %al
    movzbl %al, %eax
    sal $6, %al
    or $47, %al
    cmp $47, %al
    je _L_1432663
# emit-tail-expr
# si=-16
# env=((f196028 . -12) (f196028 . -8) ((primitive-ref write) . 32) ((primitive-ref write-char) . 28) ((primitive-ref write-char) . 24) ((primitive-ref write-char) . 20) (else . 16) (f196013 . 12) ((primitive-ref write-char) . 8) ((primitive-ref write) . 4) (f196013 . -24) (f196014 . -20) (f196015 . -16) (f196016 . -12) (f196017 . -8) (f196018 . -4) (f196019 . 0))
# expr=#t
    movl $111, %eax     # immed #t
    ret                  # immediate tail return
    jmp _L_1432664
_L_1432663:
# emit-tail-expr
# si=-16
# env=((f196028 . -12) (f196028 . -8) ((primitive-ref write) . 32) ((primitive-ref write-char) . 28) ((primitive-ref write-char) . 24) ((primitive-ref write-char) . 20) (else . 16) (f196013 . 12) ((primitive-ref write-char) . 8) ((primitive-ref write) . 4) (f196013 . -24) (f196014 . -20) (f196015 . -16) (f196016 . -12) (f196017 . -8) (f196018 . -4) (f196019 . 0))
# expr=(if (pair? (cdr f196028)) (begin ((primitive-ref write-char) #\space) ((vector-ref f196013 0) (cdr f196028))) (begin ((primitive-ref write-char) #\space) ((primitive-ref write-char) #\.) ((primitive-ref write-char) #\space) ((primitive-ref write) (cdr f196028))))
# emit-expr (pair? (cdr f196028))
# emit-expr (cdr f196028)
# emit-expr f196028
# emit-variable-ref
# env=((f196028 . -12) (f196028 . -8) ((primitive-ref write) . 32) ((primitive-ref write-char) . 28) ((primitive-ref write-char) . 24) ((primitive-ref write-char) . 20) (else . 16) (f196013 . 12) ((primitive-ref write-char) . 8) ((primitive-ref write) . 4) (f196013 . -24) (f196014 . -20) (f196015 . -16) (f196016 . -12) (f196017 . -8) (f196018 . -4) (f196019 . 0))
# var=f196028
    movl -12(%esp), %eax  # stack load f196028
# end emit-variable-ref
# check the argument is a pair
    movl %eax,%ebx
    and $7, %bl
    cmp $1, %bl
    je _L_1432668
# invoke error handler eh_pair
    .extern mrc_eh$upair
    movl mrc_eh$upair, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $112,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1432668:
    movl 3(%eax), %eax
    and $7, %al
    cmp $1, %al
    sete %al
    movzbl %al, %eax
    sal $6, %al
    or $47, %al
    cmp $47, %al
    je _L_1432666
# emit-tail-expr
# si=-16
# env=((f196028 . -12) (f196028 . -8) ((primitive-ref write) . 32) ((primitive-ref write-char) . 28) ((primitive-ref write-char) . 24) ((primitive-ref write-char) . 20) (else . 16) (f196013 . 12) ((primitive-ref write-char) . 8) ((primitive-ref write) . 4) (f196013 . -24) (f196014 . -20) (f196015 . -16) (f196016 . -12) (f196017 . -8) (f196018 . -4) (f196019 . 0))
# expr=(begin ((primitive-ref write-char) #\space) ((vector-ref f196013 0) (cdr f196028)))
# tail-begin (begin ((primitive-ref write-char) #\space) ((vector-ref f196013 0) (cdr f196028)))
#   env=((f196028 . -12) (f196028 . -8) ((primitive-ref write) . 32) ((primitive-ref write-char) . 28) ((primitive-ref write-char) . 24) ((primitive-ref write-char) . 20) (else . 16) (f196013 . 12) ((primitive-ref write-char) . 8) ((primitive-ref write) . 4) (f196013 . -24) (f196014 . -20) (f196015 . -16) (f196016 . -12) (f196017 . -8) (f196018 . -4) (f196019 . 0))
# emit-expr ((primitive-ref write-char) #\space)
# funcall
#    si   =-16
#    env  = ((f196028 . -12) (f196028 . -8) ((primitive-ref write) . 32) ((primitive-ref write-char) . 28) ((primitive-ref write-char) . 24) ((primitive-ref write-char) . 20) (else . 16) (f196013 . 12) ((primitive-ref write-char) . 8) ((primitive-ref write) . 4) (f196013 . -24) (f196014 . -20) (f196015 . -16) (f196016 . -12) (f196017 . -8) (f196018 . -4) (f196019 . 0))
#    expr = (funcall (primitive-ref write-char) #\space)
# emit-expr (primitive-ref write-char)
    .extern mrc_write$mchar
    movl mrc_write$mchar,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1432669"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1432669":
   movl %eax,  -24(%esp)  # stash funcall-oper in closure slot
# emit-expr #\space
    movl $8207, %eax     # immed #\space
    mov %eax, -28(%esp)  # arg  
    movl -24(%esp), %edi   # load new closure to %edi
    add $-16, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $16, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
# emit-tail-expr
# si=-16
# env=((f196028 . -12) (f196028 . -8) ((primitive-ref write) . 32) ((primitive-ref write-char) . 28) ((primitive-ref write-char) . 24) ((primitive-ref write-char) . 20) (else . 16) (f196013 . 12) ((primitive-ref write-char) . 8) ((primitive-ref write) . 4) (f196013 . -24) (f196014 . -20) (f196015 . -16) (f196016 . -12) (f196017 . -8) (f196018 . -4) (f196019 . 0))
# expr=(begin ((vector-ref f196013 0) (cdr f196028)))
# tail-begin (begin ((vector-ref f196013 0) (cdr f196028)))
#   env=((f196028 . -12) (f196028 . -8) ((primitive-ref write) . 32) ((primitive-ref write-char) . 28) ((primitive-ref write-char) . 24) ((primitive-ref write-char) . 20) (else . 16) (f196013 . 12) ((primitive-ref write-char) . 8) ((primitive-ref write) . 4) (f196013 . -24) (f196014 . -20) (f196015 . -16) (f196016 . -12) (f196017 . -8) (f196018 . -4) (f196019 . 0))
# emit-tail-expr
# si=-16
# env=((f196028 . -12) (f196028 . -8) ((primitive-ref write) . 32) ((primitive-ref write-char) . 28) ((primitive-ref write-char) . 24) ((primitive-ref write-char) . 20) (else . 16) (f196013 . 12) ((primitive-ref write-char) . 8) ((primitive-ref write) . 4) (f196013 . -24) (f196014 . -20) (f196015 . -16) (f196016 . -12) (f196017 . -8) (f196018 . -4) (f196019 . 0))
# expr=((vector-ref f196013 0) (cdr f196028))
# emit-tail-funcall
#    si   =-16
#    env  = ((f196028 . -12) (f196028 . -8) ((primitive-ref write) . 32) ((primitive-ref write-char) . 28) ((primitive-ref write-char) . 24) ((primitive-ref write-char) . 20) (else . 16) (f196013 . 12) ((primitive-ref write-char) . 8) ((primitive-ref write) . 4) (f196013 . -24) (f196014 . -20) (f196015 . -16) (f196016 . -12) (f196017 . -8) (f196018 . -4) (f196019 . 0))
#    expr = (funcall (vector-ref f196013 0) (cdr f196028))
# emit-expr (vector-ref f196013 0)
# emit-expr f196013
# emit-variable-ref
# env=((f196028 . -12) (f196028 . -8) ((primitive-ref write) . 32) ((primitive-ref write-char) . 28) ((primitive-ref write-char) . 24) ((primitive-ref write-char) . 20) (else . 16) (f196013 . 12) ((primitive-ref write-char) . 8) ((primitive-ref write) . 4) (f196013 . -24) (f196014 . -20) (f196015 . -16) (f196016 . -12) (f196017 . -8) (f196018 . -4) (f196019 . 0))
# var=f196013
    movl 10(%edi), %eax  # frame load f196013
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1432670
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1432670:
    movl %eax, -16(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1432671"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1432671:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1432673
    cmp  $0,%eax
    jge _L_1432672
_L_1432673:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1432672:
    movl -16(%esp), %esi
    movl -1(%eax,%esi), %eax
   movl %eax,  -16(%esp)  # stash funcall-oper in next closure slot
# emit-expr (cdr f196028)
# emit-expr f196028
# emit-variable-ref
# env=((f196028 . -12) (f196028 . -8) ((primitive-ref write) . 32) ((primitive-ref write-char) . 28) ((primitive-ref write-char) . 24) ((primitive-ref write-char) . 20) (else . 16) (f196013 . 12) ((primitive-ref write-char) . 8) ((primitive-ref write) . 4) (f196013 . -24) (f196014 . -20) (f196015 . -16) (f196016 . -12) (f196017 . -8) (f196018 . -4) (f196019 . 0))
# var=f196028
    movl -12(%esp), %eax  # stack load f196028
# end emit-variable-ref
# check the argument is a pair
    movl %eax,%ebx
    and $7, %bl
    cmp $1, %bl
    je _L_1432674
# invoke error handler eh_pair
    .extern mrc_eh$upair
    movl mrc_eh$upair, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $112,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1432674:
    movl 3(%eax), %eax
    mov %eax, -20(%esp)    # arg (cdr f196028)
    movl -16(%esp), %edi   # load new closure to %edi
# emit-shift-args:  size=2   si=-16  delta=12
    mov -16(%esp), %ebx  # shift frame cell
    mov %ebx, -4(%esp)  # down to base
# emit-shift-args:  size=1   si=-20  delta=12
    mov -20(%esp), %ebx  # shift frame cell
    mov %ebx, -8(%esp)  # down to base
# emit-shift-args:  size=0   si=-24  delta=12
    movl $4,%eax   # save arg count
    jmp *-2(%edi)  # tail-funcall
     ret   # return thru stack
    jmp _L_1432667
_L_1432666:
# emit-tail-expr
# si=-16
# env=((f196028 . -12) (f196028 . -8) ((primitive-ref write) . 32) ((primitive-ref write-char) . 28) ((primitive-ref write-char) . 24) ((primitive-ref write-char) . 20) (else . 16) (f196013 . 12) ((primitive-ref write-char) . 8) ((primitive-ref write) . 4) (f196013 . -24) (f196014 . -20) (f196015 . -16) (f196016 . -12) (f196017 . -8) (f196018 . -4) (f196019 . 0))
# expr=(begin ((primitive-ref write-char) #\space) ((primitive-ref write-char) #\.) ((primitive-ref write-char) #\space) ((primitive-ref write) (cdr f196028)))
# tail-begin (begin ((primitive-ref write-char) #\space) ((primitive-ref write-char) #\.) ((primitive-ref write-char) #\space) ((primitive-ref write) (cdr f196028)))
#   env=((f196028 . -12) (f196028 . -8) ((primitive-ref write) . 32) ((primitive-ref write-char) . 28) ((primitive-ref write-char) . 24) ((primitive-ref write-char) . 20) (else . 16) (f196013 . 12) ((primitive-ref write-char) . 8) ((primitive-ref write) . 4) (f196013 . -24) (f196014 . -20) (f196015 . -16) (f196016 . -12) (f196017 . -8) (f196018 . -4) (f196019 . 0))
# emit-expr ((primitive-ref write-char) #\space)
# funcall
#    si   =-16
#    env  = ((f196028 . -12) (f196028 . -8) ((primitive-ref write) . 32) ((primitive-ref write-char) . 28) ((primitive-ref write-char) . 24) ((primitive-ref write-char) . 20) (else . 16) (f196013 . 12) ((primitive-ref write-char) . 8) ((primitive-ref write) . 4) (f196013 . -24) (f196014 . -20) (f196015 . -16) (f196016 . -12) (f196017 . -8) (f196018 . -4) (f196019 . 0))
#    expr = (funcall (primitive-ref write-char) #\space)
# emit-expr (primitive-ref write-char)
    .extern mrc_write$mchar
    movl mrc_write$mchar,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1432675"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1432675":
   movl %eax,  -24(%esp)  # stash funcall-oper in closure slot
# emit-expr #\space
    movl $8207, %eax     # immed #\space
    mov %eax, -28(%esp)  # arg  
    movl -24(%esp), %edi   # load new closure to %edi
    add $-16, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $16, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
# emit-tail-expr
# si=-16
# env=((f196028 . -12) (f196028 . -8) ((primitive-ref write) . 32) ((primitive-ref write-char) . 28) ((primitive-ref write-char) . 24) ((primitive-ref write-char) . 20) (else . 16) (f196013 . 12) ((primitive-ref write-char) . 8) ((primitive-ref write) . 4) (f196013 . -24) (f196014 . -20) (f196015 . -16) (f196016 . -12) (f196017 . -8) (f196018 . -4) (f196019 . 0))
# expr=(begin ((primitive-ref write-char) #\.) ((primitive-ref write-char) #\space) ((primitive-ref write) (cdr f196028)))
# tail-begin (begin ((primitive-ref write-char) #\.) ((primitive-ref write-char) #\space) ((primitive-ref write) (cdr f196028)))
#   env=((f196028 . -12) (f196028 . -8) ((primitive-ref write) . 32) ((primitive-ref write-char) . 28) ((primitive-ref write-char) . 24) ((primitive-ref write-char) . 20) (else . 16) (f196013 . 12) ((primitive-ref write-char) . 8) ((primitive-ref write) . 4) (f196013 . -24) (f196014 . -20) (f196015 . -16) (f196016 . -12) (f196017 . -8) (f196018 . -4) (f196019 . 0))
# emit-expr ((primitive-ref write-char) #\.)
# funcall
#    si   =-16
#    env  = ((f196028 . -12) (f196028 . -8) ((primitive-ref write) . 32) ((primitive-ref write-char) . 28) ((primitive-ref write-char) . 24) ((primitive-ref write-char) . 20) (else . 16) (f196013 . 12) ((primitive-ref write-char) . 8) ((primitive-ref write) . 4) (f196013 . -24) (f196014 . -20) (f196015 . -16) (f196016 . -12) (f196017 . -8) (f196018 . -4) (f196019 . 0))
#    expr = (funcall (primitive-ref write-char) #\.)
# emit-expr (primitive-ref write-char)
    .extern mrc_write$mchar
    movl mrc_write$mchar,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1432676"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1432676":
   movl %eax,  -24(%esp)  # stash funcall-oper in closure slot
# emit-expr #\.
    movl $11791, %eax     # immed #\.
    mov %eax, -28(%esp)  # arg .
    movl -24(%esp), %edi   # load new closure to %edi
    add $-16, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $16, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
# emit-tail-expr
# si=-16
# env=((f196028 . -12) (f196028 . -8) ((primitive-ref write) . 32) ((primitive-ref write-char) . 28) ((primitive-ref write-char) . 24) ((primitive-ref write-char) . 20) (else . 16) (f196013 . 12) ((primitive-ref write-char) . 8) ((primitive-ref write) . 4) (f196013 . -24) (f196014 . -20) (f196015 . -16) (f196016 . -12) (f196017 . -8) (f196018 . -4) (f196019 . 0))
# expr=(begin ((primitive-ref write-char) #\space) ((primitive-ref write) (cdr f196028)))
# tail-begin (begin ((primitive-ref write-char) #\space) ((primitive-ref write) (cdr f196028)))
#   env=((f196028 . -12) (f196028 . -8) ((primitive-ref write) . 32) ((primitive-ref write-char) . 28) ((primitive-ref write-char) . 24) ((primitive-ref write-char) . 20) (else . 16) (f196013 . 12) ((primitive-ref write-char) . 8) ((primitive-ref write) . 4) (f196013 . -24) (f196014 . -20) (f196015 . -16) (f196016 . -12) (f196017 . -8) (f196018 . -4) (f196019 . 0))
# emit-expr ((primitive-ref write-char) #\space)
# funcall
#    si   =-16
#    env  = ((f196028 . -12) (f196028 . -8) ((primitive-ref write) . 32) ((primitive-ref write-char) . 28) ((primitive-ref write-char) . 24) ((primitive-ref write-char) . 20) (else . 16) (f196013 . 12) ((primitive-ref write-char) . 8) ((primitive-ref write) . 4) (f196013 . -24) (f196014 . -20) (f196015 . -16) (f196016 . -12) (f196017 . -8) (f196018 . -4) (f196019 . 0))
#    expr = (funcall (primitive-ref write-char) #\space)
# emit-expr (primitive-ref write-char)
    .extern mrc_write$mchar
    movl mrc_write$mchar,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1432677"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1432677":
   movl %eax,  -24(%esp)  # stash funcall-oper in closure slot
# emit-expr #\space
    movl $8207, %eax     # immed #\space
    mov %eax, -28(%esp)  # arg  
    movl -24(%esp), %edi   # load new closure to %edi
    add $-16, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $16, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
# emit-tail-expr
# si=-16
# env=((f196028 . -12) (f196028 . -8) ((primitive-ref write) . 32) ((primitive-ref write-char) . 28) ((primitive-ref write-char) . 24) ((primitive-ref write-char) . 20) (else . 16) (f196013 . 12) ((primitive-ref write-char) . 8) ((primitive-ref write) . 4) (f196013 . -24) (f196014 . -20) (f196015 . -16) (f196016 . -12) (f196017 . -8) (f196018 . -4) (f196019 . 0))
# expr=(begin ((primitive-ref write) (cdr f196028)))
# tail-begin (begin ((primitive-ref write) (cdr f196028)))
#   env=((f196028 . -12) (f196028 . -8) ((primitive-ref write) . 32) ((primitive-ref write-char) . 28) ((primitive-ref write-char) . 24) ((primitive-ref write-char) . 20) (else . 16) (f196013 . 12) ((primitive-ref write-char) . 8) ((primitive-ref write) . 4) (f196013 . -24) (f196014 . -20) (f196015 . -16) (f196016 . -12) (f196017 . -8) (f196018 . -4) (f196019 . 0))
# emit-tail-expr
# si=-16
# env=((f196028 . -12) (f196028 . -8) ((primitive-ref write) . 32) ((primitive-ref write-char) . 28) ((primitive-ref write-char) . 24) ((primitive-ref write-char) . 20) (else . 16) (f196013 . 12) ((primitive-ref write-char) . 8) ((primitive-ref write) . 4) (f196013 . -24) (f196014 . -20) (f196015 . -16) (f196016 . -12) (f196017 . -8) (f196018 . -4) (f196019 . 0))
# expr=((primitive-ref write) (cdr f196028))
# emit-tail-funcall
#    si   =-16
#    env  = ((f196028 . -12) (f196028 . -8) ((primitive-ref write) . 32) ((primitive-ref write-char) . 28) ((primitive-ref write-char) . 24) ((primitive-ref write-char) . 20) (else . 16) (f196013 . 12) ((primitive-ref write-char) . 8) ((primitive-ref write) . 4) (f196013 . -24) (f196014 . -20) (f196015 . -16) (f196016 . -12) (f196017 . -8) (f196018 . -4) (f196019 . 0))
#    expr = (funcall (primitive-ref write) (cdr f196028))
# emit-expr (primitive-ref write)
    .extern mrc_write
    movl mrc_write,%eax
   movl %eax,  -16(%esp)  # stash funcall-oper in next closure slot
# emit-expr (cdr f196028)
# emit-expr f196028
# emit-variable-ref
# env=((f196028 . -12) (f196028 . -8) ((primitive-ref write) . 32) ((primitive-ref write-char) . 28) ((primitive-ref write-char) . 24) ((primitive-ref write-char) . 20) (else . 16) (f196013 . 12) ((primitive-ref write-char) . 8) ((primitive-ref write) . 4) (f196013 . -24) (f196014 . -20) (f196015 . -16) (f196016 . -12) (f196017 . -8) (f196018 . -4) (f196019 . 0))
# var=f196028
    movl -12(%esp), %eax  # stack load f196028
# end emit-variable-ref
# check the argument is a pair
    movl %eax,%ebx
    and $7, %bl
    cmp $1, %bl
    je _L_1432678
# invoke error handler eh_pair
    .extern mrc_eh$upair
    movl mrc_eh$upair, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $112,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1432678:
    movl 3(%eax), %eax
    mov %eax, -20(%esp)    # arg (cdr f196028)
    movl -16(%esp), %edi   # load new closure to %edi
# emit-shift-args:  size=2   si=-16  delta=12
    mov -16(%esp), %ebx  # shift frame cell
    mov %ebx, -4(%esp)  # down to base
# emit-shift-args:  size=1   si=-20  delta=12
    mov -20(%esp), %ebx  # shift frame cell
    mov %ebx, -8(%esp)  # down to base
# emit-shift-args:  size=0   si=-24  delta=12
    movl $4,%eax   # save arg count
    jmp *-2(%edi)  # tail-funcall
     ret   # return thru stack
_L_1432667:
_L_1432664:
     ret   # return thru stack
    .align 4,0x90
_L_1432659:
    movl -28(%esp), %ebx
    movl -32(%esp), %esi
    movl %eax, -1(%ebx,%esi)
# emit-expr (begin)
# emit-begin
#   expr=(begin)
#   env=((f196013 . -24) (f196014 . -20) (f196015 . -16) (f196016 . -12) (f196017 . -8) (f196018 . -4) (f196019 . 0))
# emit-expr (begin (closure (f196037) (f196019 f196018 f196017 f196016 f196015 f196014 else (primitive-ref error) (primitive-ref write)) (let ((f196037 f196037)) (if (boolean? f196037) ((vector-ref f196019 0) f196037) (if (null? f196037) ((vector-ref f196018 0)) (if (char? f196037) ((vector-ref f196017 0) f196037) (if (fixnum? f196037) ((vector-ref f196016 0) f196037) (if (string? f196037) ((vector-ref f196015 0) f196037) (if (pair? f196037) ((vector-ref f196014 0) f196037) ((primitive-ref error) ((primitive-ref string->symbol) "write") "unrecognized expression"))))))))))
# emit-begin
#   expr=(begin (closure (f196037) (f196019 f196018 f196017 f196016 f196015 f196014 else (primitive-ref error) (primitive-ref write)) (let ((f196037 f196037)) (if (boolean? f196037) ((vector-ref f196019 0) f196037) (if (null? f196037) ((vector-ref f196018 0)) (if (char? f196037) ((vector-ref f196017 0) f196037) (if (fixnum? f196037) ((vector-ref f196016 0) f196037) (if (string? f196037) ((vector-ref f196015 0) f196037) (if (pair? f196037) ((vector-ref f196014 0) f196037) ((primitive-ref error) ((primitive-ref string->symbol) "write") "unrecognized expression"))))))))))
#   env=((f196013 . -24) (f196014 . -20) (f196015 . -16) (f196016 . -12) (f196017 . -8) (f196018 . -4) (f196019 . 0))
# emit-expr (closure (f196037) (f196019 f196018 f196017 f196016 f196015 f196014 else (primitive-ref error) (primitive-ref write)) (let ((f196037 f196037)) (if (boolean? f196037) ((vector-ref f196019 0) f196037) (if (null? f196037) ((vector-ref f196018 0)) (if (char? f196037) ((vector-ref f196017 0) f196037) (if (fixnum? f196037) ((vector-ref f196016 0) f196037) (if (string? f196037) ((vector-ref f196015 0) f196037) (if (pair? f196037) ((vector-ref f196014 0) f196037) ((primitive-ref error) ((primitive-ref string->symbol) "write") "unrecognized expression")))))))))
# emit-closure
# si = -28
# env = ((f196013 . -24) (f196014 . -20) (f196015 . -16) (f196016 . -12) (f196017 . -8) (f196018 . -4) (f196019 . 0))
# expr = (closure (f196037) (f196019 f196018 f196017 f196016 f196015 f196014 else (primitive-ref error) (primitive-ref write)) (let ((f196037 f196037)) (if (boolean? f196037) ((vector-ref f196019 0) f196037) (if (null? f196037) ((vector-ref f196018 0)) (if (char? f196037) ((vector-ref f196017 0) f196037) (if (fixnum? f196037) ((vector-ref f196016 0) f196037) (if (string? f196037) ((vector-ref f196015 0) f196037) (if (pair? f196037) ((vector-ref f196014 0) f196037) ((primitive-ref error) ((primitive-ref string->symbol) "write") "unrecognized expression")))))))))
    movl $_L_1432679, 0(%ebp)  # closure label
# emit-variable-ref
# env=((f196013 . -24) (f196014 . -20) (f196015 . -16) (f196016 . -12) (f196017 . -8) (f196018 . -4) (f196019 . 0))
# var=f196019
    movl 0(%esp), %eax  # stack load f196019
# end emit-variable-ref
   movl  %eax, 4(%ebp)  # f196019
# emit-variable-ref
# env=((f196013 . -24) (f196014 . -20) (f196015 . -16) (f196016 . -12) (f196017 . -8) (f196018 . -4) (f196019 . 0))
# var=f196018
    movl -4(%esp), %eax  # stack load f196018
# end emit-variable-ref
   movl  %eax, 8(%ebp)  # f196018
# emit-variable-ref
# env=((f196013 . -24) (f196014 . -20) (f196015 . -16) (f196016 . -12) (f196017 . -8) (f196018 . -4) (f196019 . 0))
# var=f196017
    movl -8(%esp), %eax  # stack load f196017
# end emit-variable-ref
   movl  %eax, 12(%ebp)  # f196017
# emit-variable-ref
# env=((f196013 . -24) (f196014 . -20) (f196015 . -16) (f196016 . -12) (f196017 . -8) (f196018 . -4) (f196019 . 0))
# var=f196016
    movl -12(%esp), %eax  # stack load f196016
# end emit-variable-ref
   movl  %eax, 16(%ebp)  # f196016
# emit-variable-ref
# env=((f196013 . -24) (f196014 . -20) (f196015 . -16) (f196016 . -12) (f196017 . -8) (f196018 . -4) (f196019 . 0))
# var=f196015
    movl -16(%esp), %eax  # stack load f196015
# end emit-variable-ref
   movl  %eax, 20(%ebp)  # f196015
# emit-variable-ref
# env=((f196013 . -24) (f196014 . -20) (f196015 . -16) (f196016 . -12) (f196017 . -8) (f196018 . -4) (f196019 . 0))
# var=f196014
    movl -20(%esp), %eax  # stack load f196014
# end emit-variable-ref
   movl  %eax, 24(%ebp)  # f196014
# WARNING: free var else not defined in the environmnet
# WARNING: free var (primitive-ref error) not defined in the environmnet
# WARNING: free var (primitive-ref write) not defined in the environmnet
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $40, %ebp     # bump ebp
    jmp _L_1432680            # jump around closure body
_L_1432679:
# check argument count
    cmp $4,%eax
    je _L_1432681
# invoke error handler eh_argcount
    .extern mrc_eh$uargcount
    movl mrc_eh$uargcount, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_1432681:
# emit-tail-expr
# si=-12
# env=((f196037 . -8) ((primitive-ref write) . 36) ((primitive-ref error) . 32) (else . 28) (f196014 . 24) (f196015 . 20) (f196016 . 16) (f196017 . 12) (f196018 . 8) (f196019 . 4) (f196013 . -24) (f196014 . -20) (f196015 . -16) (f196016 . -12) (f196017 . -8) (f196018 . -4) (f196019 . 0))
# expr=(let ((f196037 f196037)) (if (boolean? f196037) ((vector-ref f196019 0) f196037) (if (null? f196037) ((vector-ref f196018 0)) (if (char? f196037) ((vector-ref f196017 0) f196037) (if (fixnum? f196037) ((vector-ref f196016 0) f196037) (if (string? f196037) ((vector-ref f196015 0) f196037) (if (pair? f196037) ((vector-ref f196014 0) f196037) ((primitive-ref error) ((primitive-ref string->symbol) "write") "unrecognized expression"))))))))
# emit-tail-let
#  si   = -12
#  env  = ((f196037 . -8) ((primitive-ref write) . 36) ((primitive-ref error) . 32) (else . 28) (f196014 . 24) (f196015 . 20) (f196016 . 16) (f196017 . 12) (f196018 . 8) (f196019 . 4) (f196013 . -24) (f196014 . -20) (f196015 . -16) (f196016 . -12) (f196017 . -8) (f196018 . -4) (f196019 . 0))
#  bindings = ((f196037 f196037))
#  body = (if (boolean? f196037) ((vector-ref f196019 0) f196037) (if (null? f196037) ((vector-ref f196018 0)) (if (char? f196037) ((vector-ref f196017 0) f196037) (if (fixnum? f196037) ((vector-ref f196016 0) f196037) (if (string? f196037) ((vector-ref f196015 0) f196037) (if (pair? f196037) ((vector-ref f196014 0) f196037) ((primitive-ref error) ((primitive-ref string->symbol) "write") "unrecognized expression")))))))
# emit-expr f196037
# emit-variable-ref
# env=((f196037 . -8) ((primitive-ref write) . 36) ((primitive-ref error) . 32) (else . 28) (f196014 . 24) (f196015 . 20) (f196016 . 16) (f196017 . 12) (f196018 . 8) (f196019 . 4) (f196013 . -24) (f196014 . -20) (f196015 . -16) (f196016 . -12) (f196017 . -8) (f196018 . -4) (f196019 . 0))
# var=f196037
    movl -8(%esp), %eax  # stack load f196037
# end emit-variable-ref
    movl %eax, -12(%esp)  # stack save
# emit-tail-expr
# si=-16
# env=((f196037 . -12) (f196037 . -8) ((primitive-ref write) . 36) ((primitive-ref error) . 32) (else . 28) (f196014 . 24) (f196015 . 20) (f196016 . 16) (f196017 . 12) (f196018 . 8) (f196019 . 4) (f196013 . -24) (f196014 . -20) (f196015 . -16) (f196016 . -12) (f196017 . -8) (f196018 . -4) (f196019 . 0))
# expr=(if (boolean? f196037) ((vector-ref f196019 0) f196037) (if (null? f196037) ((vector-ref f196018 0)) (if (char? f196037) ((vector-ref f196017 0) f196037) (if (fixnum? f196037) ((vector-ref f196016 0) f196037) (if (string? f196037) ((vector-ref f196015 0) f196037) (if (pair? f196037) ((vector-ref f196014 0) f196037) ((primitive-ref error) ((primitive-ref string->symbol) "write") "unrecognized expression")))))))
# emit-expr (boolean? f196037)
# emit-expr f196037
# emit-variable-ref
# env=((f196037 . -12) (f196037 . -8) ((primitive-ref write) . 36) ((primitive-ref error) . 32) (else . 28) (f196014 . 24) (f196015 . 20) (f196016 . 16) (f196017 . 12) (f196018 . 8) (f196019 . 4) (f196013 . -24) (f196014 . -20) (f196015 . -16) (f196016 . -12) (f196017 . -8) (f196018 . -4) (f196019 . 0))
# var=f196037
    movl -12(%esp), %eax  # stack load f196037
# end emit-variable-ref
    and $191, %eax
    cmp $47, %eax
    sete %al
    movzbl %al, %eax
    sal $6, %al
    or $47, %al
    cmp $47, %al
    je _L_1432682
# emit-tail-expr
# si=-16
# env=((f196037 . -12) (f196037 . -8) ((primitive-ref write) . 36) ((primitive-ref error) . 32) (else . 28) (f196014 . 24) (f196015 . 20) (f196016 . 16) (f196017 . 12) (f196018 . 8) (f196019 . 4) (f196013 . -24) (f196014 . -20) (f196015 . -16) (f196016 . -12) (f196017 . -8) (f196018 . -4) (f196019 . 0))
# expr=((vector-ref f196019 0) f196037)
# emit-tail-funcall
#    si   =-16
#    env  = ((f196037 . -12) (f196037 . -8) ((primitive-ref write) . 36) ((primitive-ref error) . 32) (else . 28) (f196014 . 24) (f196015 . 20) (f196016 . 16) (f196017 . 12) (f196018 . 8) (f196019 . 4) (f196013 . -24) (f196014 . -20) (f196015 . -16) (f196016 . -12) (f196017 . -8) (f196018 . -4) (f196019 . 0))
#    expr = (funcall (vector-ref f196019 0) f196037)
# emit-expr (vector-ref f196019 0)
# emit-expr f196019
# emit-variable-ref
# env=((f196037 . -12) (f196037 . -8) ((primitive-ref write) . 36) ((primitive-ref error) . 32) (else . 28) (f196014 . 24) (f196015 . 20) (f196016 . 16) (f196017 . 12) (f196018 . 8) (f196019 . 4) (f196013 . -24) (f196014 . -20) (f196015 . -16) (f196016 . -12) (f196017 . -8) (f196018 . -4) (f196019 . 0))
# var=f196019
    movl 2(%edi), %eax  # frame load f196019
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1432684
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1432684:
    movl %eax, -16(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1432685"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1432685:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1432687
    cmp  $0,%eax
    jge _L_1432686
_L_1432687:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1432686:
    movl -16(%esp), %esi
    movl -1(%eax,%esi), %eax
   movl %eax,  -16(%esp)  # stash funcall-oper in next closure slot
# emit-expr f196037
# emit-variable-ref
# env=((f196037 . -12) (f196037 . -8) ((primitive-ref write) . 36) ((primitive-ref error) . 32) (else . 28) (f196014 . 24) (f196015 . 20) (f196016 . 16) (f196017 . 12) (f196018 . 8) (f196019 . 4) (f196013 . -24) (f196014 . -20) (f196015 . -16) (f196016 . -12) (f196017 . -8) (f196018 . -4) (f196019 . 0))
# var=f196037
    movl -12(%esp), %eax  # stack load f196037
# end emit-variable-ref
    mov %eax, -20(%esp)    # arg f196037
    movl -16(%esp), %edi   # load new closure to %edi
# emit-shift-args:  size=2   si=-16  delta=12
    mov -16(%esp), %ebx  # shift frame cell
    mov %ebx, -4(%esp)  # down to base
# emit-shift-args:  size=1   si=-20  delta=12
    mov -20(%esp), %ebx  # shift frame cell
    mov %ebx, -8(%esp)  # down to base
# emit-shift-args:  size=0   si=-24  delta=12
    movl $4,%eax   # save arg count
    jmp *-2(%edi)  # tail-funcall
    jmp _L_1432683
_L_1432682:
# emit-tail-expr
# si=-16
# env=((f196037 . -12) (f196037 . -8) ((primitive-ref write) . 36) ((primitive-ref error) . 32) (else . 28) (f196014 . 24) (f196015 . 20) (f196016 . 16) (f196017 . 12) (f196018 . 8) (f196019 . 4) (f196013 . -24) (f196014 . -20) (f196015 . -16) (f196016 . -12) (f196017 . -8) (f196018 . -4) (f196019 . 0))
# expr=(if (null? f196037) ((vector-ref f196018 0)) (if (char? f196037) ((vector-ref f196017 0) f196037) (if (fixnum? f196037) ((vector-ref f196016 0) f196037) (if (string? f196037) ((vector-ref f196015 0) f196037) (if (pair? f196037) ((vector-ref f196014 0) f196037) ((primitive-ref error) ((primitive-ref string->symbol) "write") "unrecognized expression"))))))
# emit-expr (null? f196037)
# emit-expr f196037
# emit-variable-ref
# env=((f196037 . -12) (f196037 . -8) ((primitive-ref write) . 36) ((primitive-ref error) . 32) (else . 28) (f196014 . 24) (f196015 . 20) (f196016 . 16) (f196017 . 12) (f196018 . 8) (f196019 . 4) (f196013 . -24) (f196014 . -20) (f196015 . -16) (f196016 . -12) (f196017 . -8) (f196018 . -4) (f196019 . 0))
# var=f196037
    movl -12(%esp), %eax  # stack load f196037
# end emit-variable-ref
    cmp $63, %eax
    mov $0, %eax
    sete %al
    movzbl %al, %eax
    sal $6, %al
    or $47, %al
    cmp $47, %al
    je _L_1432688
# emit-tail-expr
# si=-16
# env=((f196037 . -12) (f196037 . -8) ((primitive-ref write) . 36) ((primitive-ref error) . 32) (else . 28) (f196014 . 24) (f196015 . 20) (f196016 . 16) (f196017 . 12) (f196018 . 8) (f196019 . 4) (f196013 . -24) (f196014 . -20) (f196015 . -16) (f196016 . -12) (f196017 . -8) (f196018 . -4) (f196019 . 0))
# expr=((vector-ref f196018 0))
# emit-tail-funcall
#    si   =-16
#    env  = ((f196037 . -12) (f196037 . -8) ((primitive-ref write) . 36) ((primitive-ref error) . 32) (else . 28) (f196014 . 24) (f196015 . 20) (f196016 . 16) (f196017 . 12) (f196018 . 8) (f196019 . 4) (f196013 . -24) (f196014 . -20) (f196015 . -16) (f196016 . -12) (f196017 . -8) (f196018 . -4) (f196019 . 0))
#    expr = (funcall (vector-ref f196018 0))
# emit-expr (vector-ref f196018 0)
# emit-expr f196018
# emit-variable-ref
# env=((f196037 . -12) (f196037 . -8) ((primitive-ref write) . 36) ((primitive-ref error) . 32) (else . 28) (f196014 . 24) (f196015 . 20) (f196016 . 16) (f196017 . 12) (f196018 . 8) (f196019 . 4) (f196013 . -24) (f196014 . -20) (f196015 . -16) (f196016 . -12) (f196017 . -8) (f196018 . -4) (f196019 . 0))
# var=f196018
    movl 6(%edi), %eax  # frame load f196018
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1432690
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1432690:
    movl %eax, -16(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1432691"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1432691:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1432693
    cmp  $0,%eax
    jge _L_1432692
_L_1432693:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1432692:
    movl -16(%esp), %esi
    movl -1(%eax,%esi), %eax
   movl %eax,  -16(%esp)  # stash funcall-oper in next closure slot
    movl -16(%esp), %edi   # load new closure to %edi
# emit-shift-args:  size=1   si=-16  delta=12
    mov -16(%esp), %ebx  # shift frame cell
    mov %ebx, -4(%esp)  # down to base
# emit-shift-args:  size=0   si=-20  delta=12
    movl $0,%eax   # save arg count
    jmp *-2(%edi)  # tail-funcall
    jmp _L_1432689
_L_1432688:
# emit-tail-expr
# si=-16
# env=((f196037 . -12) (f196037 . -8) ((primitive-ref write) . 36) ((primitive-ref error) . 32) (else . 28) (f196014 . 24) (f196015 . 20) (f196016 . 16) (f196017 . 12) (f196018 . 8) (f196019 . 4) (f196013 . -24) (f196014 . -20) (f196015 . -16) (f196016 . -12) (f196017 . -8) (f196018 . -4) (f196019 . 0))
# expr=(if (char? f196037) ((vector-ref f196017 0) f196037) (if (fixnum? f196037) ((vector-ref f196016 0) f196037) (if (string? f196037) ((vector-ref f196015 0) f196037) (if (pair? f196037) ((vector-ref f196014 0) f196037) ((primitive-ref error) ((primitive-ref string->symbol) "write") "unrecognized expression")))))
# emit-expr (char? f196037)
# emit-expr f196037
# emit-variable-ref
# env=((f196037 . -12) (f196037 . -8) ((primitive-ref write) . 36) ((primitive-ref error) . 32) (else . 28) (f196014 . 24) (f196015 . 20) (f196016 . 16) (f196017 . 12) (f196018 . 8) (f196019 . 4) (f196013 . -24) (f196014 . -20) (f196015 . -16) (f196016 . -12) (f196017 . -8) (f196018 . -4) (f196019 . 0))
# var=f196037
    movl -12(%esp), %eax  # stack load f196037
# end emit-variable-ref
    and $255, %eax
    cmp $15, %eax
    sete %al
    movzbl %al, %eax
    sal $6, %al
    or $47, %al
    cmp $47, %al
    je _L_1432694
# emit-tail-expr
# si=-16
# env=((f196037 . -12) (f196037 . -8) ((primitive-ref write) . 36) ((primitive-ref error) . 32) (else . 28) (f196014 . 24) (f196015 . 20) (f196016 . 16) (f196017 . 12) (f196018 . 8) (f196019 . 4) (f196013 . -24) (f196014 . -20) (f196015 . -16) (f196016 . -12) (f196017 . -8) (f196018 . -4) (f196019 . 0))
# expr=((vector-ref f196017 0) f196037)
# emit-tail-funcall
#    si   =-16
#    env  = ((f196037 . -12) (f196037 . -8) ((primitive-ref write) . 36) ((primitive-ref error) . 32) (else . 28) (f196014 . 24) (f196015 . 20) (f196016 . 16) (f196017 . 12) (f196018 . 8) (f196019 . 4) (f196013 . -24) (f196014 . -20) (f196015 . -16) (f196016 . -12) (f196017 . -8) (f196018 . -4) (f196019 . 0))
#    expr = (funcall (vector-ref f196017 0) f196037)
# emit-expr (vector-ref f196017 0)
# emit-expr f196017
# emit-variable-ref
# env=((f196037 . -12) (f196037 . -8) ((primitive-ref write) . 36) ((primitive-ref error) . 32) (else . 28) (f196014 . 24) (f196015 . 20) (f196016 . 16) (f196017 . 12) (f196018 . 8) (f196019 . 4) (f196013 . -24) (f196014 . -20) (f196015 . -16) (f196016 . -12) (f196017 . -8) (f196018 . -4) (f196019 . 0))
# var=f196017
    movl 10(%edi), %eax  # frame load f196017
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1432696
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1432696:
    movl %eax, -16(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1432697"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1432697:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1432699
    cmp  $0,%eax
    jge _L_1432698
_L_1432699:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1432698:
    movl -16(%esp), %esi
    movl -1(%eax,%esi), %eax
   movl %eax,  -16(%esp)  # stash funcall-oper in next closure slot
# emit-expr f196037
# emit-variable-ref
# env=((f196037 . -12) (f196037 . -8) ((primitive-ref write) . 36) ((primitive-ref error) . 32) (else . 28) (f196014 . 24) (f196015 . 20) (f196016 . 16) (f196017 . 12) (f196018 . 8) (f196019 . 4) (f196013 . -24) (f196014 . -20) (f196015 . -16) (f196016 . -12) (f196017 . -8) (f196018 . -4) (f196019 . 0))
# var=f196037
    movl -12(%esp), %eax  # stack load f196037
# end emit-variable-ref
    mov %eax, -20(%esp)    # arg f196037
    movl -16(%esp), %edi   # load new closure to %edi
# emit-shift-args:  size=2   si=-16  delta=12
    mov -16(%esp), %ebx  # shift frame cell
    mov %ebx, -4(%esp)  # down to base
# emit-shift-args:  size=1   si=-20  delta=12
    mov -20(%esp), %ebx  # shift frame cell
    mov %ebx, -8(%esp)  # down to base
# emit-shift-args:  size=0   si=-24  delta=12
    movl $4,%eax   # save arg count
    jmp *-2(%edi)  # tail-funcall
    jmp _L_1432695
_L_1432694:
# emit-tail-expr
# si=-16
# env=((f196037 . -12) (f196037 . -8) ((primitive-ref write) . 36) ((primitive-ref error) . 32) (else . 28) (f196014 . 24) (f196015 . 20) (f196016 . 16) (f196017 . 12) (f196018 . 8) (f196019 . 4) (f196013 . -24) (f196014 . -20) (f196015 . -16) (f196016 . -12) (f196017 . -8) (f196018 . -4) (f196019 . 0))
# expr=(if (fixnum? f196037) ((vector-ref f196016 0) f196037) (if (string? f196037) ((vector-ref f196015 0) f196037) (if (pair? f196037) ((vector-ref f196014 0) f196037) ((primitive-ref error) ((primitive-ref string->symbol) "write") "unrecognized expression"))))
# emit-expr (fixnum? f196037)
# emit-expr f196037
# emit-variable-ref
# env=((f196037 . -12) (f196037 . -8) ((primitive-ref write) . 36) ((primitive-ref error) . 32) (else . 28) (f196014 . 24) (f196015 . 20) (f196016 . 16) (f196017 . 12) (f196018 . 8) (f196019 . 4) (f196013 . -24) (f196014 . -20) (f196015 . -16) (f196016 . -12) (f196017 . -8) (f196018 . -4) (f196019 . 0))
# var=f196037
    movl -12(%esp), %eax  # stack load f196037
# end emit-variable-ref
    and $3, %al
    cmp $0, %al
    sete %al
    movzbl %al, %eax
    sal $6, %al
    or $47, %al
    cmp $47, %al
    je _L_1432700
# emit-tail-expr
# si=-16
# env=((f196037 . -12) (f196037 . -8) ((primitive-ref write) . 36) ((primitive-ref error) . 32) (else . 28) (f196014 . 24) (f196015 . 20) (f196016 . 16) (f196017 . 12) (f196018 . 8) (f196019 . 4) (f196013 . -24) (f196014 . -20) (f196015 . -16) (f196016 . -12) (f196017 . -8) (f196018 . -4) (f196019 . 0))
# expr=((vector-ref f196016 0) f196037)
# emit-tail-funcall
#    si   =-16
#    env  = ((f196037 . -12) (f196037 . -8) ((primitive-ref write) . 36) ((primitive-ref error) . 32) (else . 28) (f196014 . 24) (f196015 . 20) (f196016 . 16) (f196017 . 12) (f196018 . 8) (f196019 . 4) (f196013 . -24) (f196014 . -20) (f196015 . -16) (f196016 . -12) (f196017 . -8) (f196018 . -4) (f196019 . 0))
#    expr = (funcall (vector-ref f196016 0) f196037)
# emit-expr (vector-ref f196016 0)
# emit-expr f196016
# emit-variable-ref
# env=((f196037 . -12) (f196037 . -8) ((primitive-ref write) . 36) ((primitive-ref error) . 32) (else . 28) (f196014 . 24) (f196015 . 20) (f196016 . 16) (f196017 . 12) (f196018 . 8) (f196019 . 4) (f196013 . -24) (f196014 . -20) (f196015 . -16) (f196016 . -12) (f196017 . -8) (f196018 . -4) (f196019 . 0))
# var=f196016
    movl 14(%edi), %eax  # frame load f196016
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1432702
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1432702:
    movl %eax, -16(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1432703"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1432703:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1432705
    cmp  $0,%eax
    jge _L_1432704
_L_1432705:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1432704:
    movl -16(%esp), %esi
    movl -1(%eax,%esi), %eax
   movl %eax,  -16(%esp)  # stash funcall-oper in next closure slot
# emit-expr f196037
# emit-variable-ref
# env=((f196037 . -12) (f196037 . -8) ((primitive-ref write) . 36) ((primitive-ref error) . 32) (else . 28) (f196014 . 24) (f196015 . 20) (f196016 . 16) (f196017 . 12) (f196018 . 8) (f196019 . 4) (f196013 . -24) (f196014 . -20) (f196015 . -16) (f196016 . -12) (f196017 . -8) (f196018 . -4) (f196019 . 0))
# var=f196037
    movl -12(%esp), %eax  # stack load f196037
# end emit-variable-ref
    mov %eax, -20(%esp)    # arg f196037
    movl -16(%esp), %edi   # load new closure to %edi
# emit-shift-args:  size=2   si=-16  delta=12
    mov -16(%esp), %ebx  # shift frame cell
    mov %ebx, -4(%esp)  # down to base
# emit-shift-args:  size=1   si=-20  delta=12
    mov -20(%esp), %ebx  # shift frame cell
    mov %ebx, -8(%esp)  # down to base
# emit-shift-args:  size=0   si=-24  delta=12
    movl $4,%eax   # save arg count
    jmp *-2(%edi)  # tail-funcall
    jmp _L_1432701
_L_1432700:
# emit-tail-expr
# si=-16
# env=((f196037 . -12) (f196037 . -8) ((primitive-ref write) . 36) ((primitive-ref error) . 32) (else . 28) (f196014 . 24) (f196015 . 20) (f196016 . 16) (f196017 . 12) (f196018 . 8) (f196019 . 4) (f196013 . -24) (f196014 . -20) (f196015 . -16) (f196016 . -12) (f196017 . -8) (f196018 . -4) (f196019 . 0))
# expr=(if (string? f196037) ((vector-ref f196015 0) f196037) (if (pair? f196037) ((vector-ref f196014 0) f196037) ((primitive-ref error) ((primitive-ref string->symbol) "write") "unrecognized expression")))
# emit-expr (string? f196037)
# emit-expr f196037
# emit-variable-ref
# env=((f196037 . -12) (f196037 . -8) ((primitive-ref write) . 36) ((primitive-ref error) . 32) (else . 28) (f196014 . 24) (f196015 . 20) (f196016 . 16) (f196017 . 12) (f196018 . 8) (f196019 . 4) (f196013 . -24) (f196014 . -20) (f196015 . -16) (f196016 . -12) (f196017 . -8) (f196018 . -4) (f196019 . 0))
# var=f196037
    movl -12(%esp), %eax  # stack load f196037
# end emit-variable-ref
    and $7, %al
    cmp $6, %al
    sete %al
    movzbl %al, %eax
    sal $6, %al
    or $47, %al
    cmp $47, %al
    je _L_1432706
# emit-tail-expr
# si=-16
# env=((f196037 . -12) (f196037 . -8) ((primitive-ref write) . 36) ((primitive-ref error) . 32) (else . 28) (f196014 . 24) (f196015 . 20) (f196016 . 16) (f196017 . 12) (f196018 . 8) (f196019 . 4) (f196013 . -24) (f196014 . -20) (f196015 . -16) (f196016 . -12) (f196017 . -8) (f196018 . -4) (f196019 . 0))
# expr=((vector-ref f196015 0) f196037)
# emit-tail-funcall
#    si   =-16
#    env  = ((f196037 . -12) (f196037 . -8) ((primitive-ref write) . 36) ((primitive-ref error) . 32) (else . 28) (f196014 . 24) (f196015 . 20) (f196016 . 16) (f196017 . 12) (f196018 . 8) (f196019 . 4) (f196013 . -24) (f196014 . -20) (f196015 . -16) (f196016 . -12) (f196017 . -8) (f196018 . -4) (f196019 . 0))
#    expr = (funcall (vector-ref f196015 0) f196037)
# emit-expr (vector-ref f196015 0)
# emit-expr f196015
# emit-variable-ref
# env=((f196037 . -12) (f196037 . -8) ((primitive-ref write) . 36) ((primitive-ref error) . 32) (else . 28) (f196014 . 24) (f196015 . 20) (f196016 . 16) (f196017 . 12) (f196018 . 8) (f196019 . 4) (f196013 . -24) (f196014 . -20) (f196015 . -16) (f196016 . -12) (f196017 . -8) (f196018 . -4) (f196019 . 0))
# var=f196015
    movl 18(%edi), %eax  # frame load f196015
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1432708
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1432708:
    movl %eax, -16(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1432709"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1432709:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1432711
    cmp  $0,%eax
    jge _L_1432710
_L_1432711:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1432710:
    movl -16(%esp), %esi
    movl -1(%eax,%esi), %eax
   movl %eax,  -16(%esp)  # stash funcall-oper in next closure slot
# emit-expr f196037
# emit-variable-ref
# env=((f196037 . -12) (f196037 . -8) ((primitive-ref write) . 36) ((primitive-ref error) . 32) (else . 28) (f196014 . 24) (f196015 . 20) (f196016 . 16) (f196017 . 12) (f196018 . 8) (f196019 . 4) (f196013 . -24) (f196014 . -20) (f196015 . -16) (f196016 . -12) (f196017 . -8) (f196018 . -4) (f196019 . 0))
# var=f196037
    movl -12(%esp), %eax  # stack load f196037
# end emit-variable-ref
    mov %eax, -20(%esp)    # arg f196037
    movl -16(%esp), %edi   # load new closure to %edi
# emit-shift-args:  size=2   si=-16  delta=12
    mov -16(%esp), %ebx  # shift frame cell
    mov %ebx, -4(%esp)  # down to base
# emit-shift-args:  size=1   si=-20  delta=12
    mov -20(%esp), %ebx  # shift frame cell
    mov %ebx, -8(%esp)  # down to base
# emit-shift-args:  size=0   si=-24  delta=12
    movl $4,%eax   # save arg count
    jmp *-2(%edi)  # tail-funcall
    jmp _L_1432707
_L_1432706:
# emit-tail-expr
# si=-16
# env=((f196037 . -12) (f196037 . -8) ((primitive-ref write) . 36) ((primitive-ref error) . 32) (else . 28) (f196014 . 24) (f196015 . 20) (f196016 . 16) (f196017 . 12) (f196018 . 8) (f196019 . 4) (f196013 . -24) (f196014 . -20) (f196015 . -16) (f196016 . -12) (f196017 . -8) (f196018 . -4) (f196019 . 0))
# expr=(if (pair? f196037) ((vector-ref f196014 0) f196037) ((primitive-ref error) ((primitive-ref string->symbol) "write") "unrecognized expression"))
# emit-expr (pair? f196037)
# emit-expr f196037
# emit-variable-ref
# env=((f196037 . -12) (f196037 . -8) ((primitive-ref write) . 36) ((primitive-ref error) . 32) (else . 28) (f196014 . 24) (f196015 . 20) (f196016 . 16) (f196017 . 12) (f196018 . 8) (f196019 . 4) (f196013 . -24) (f196014 . -20) (f196015 . -16) (f196016 . -12) (f196017 . -8) (f196018 . -4) (f196019 . 0))
# var=f196037
    movl -12(%esp), %eax  # stack load f196037
# end emit-variable-ref
    and $7, %al
    cmp $1, %al
    sete %al
    movzbl %al, %eax
    sal $6, %al
    or $47, %al
    cmp $47, %al
    je _L_1432712
# emit-tail-expr
# si=-16
# env=((f196037 . -12) (f196037 . -8) ((primitive-ref write) . 36) ((primitive-ref error) . 32) (else . 28) (f196014 . 24) (f196015 . 20) (f196016 . 16) (f196017 . 12) (f196018 . 8) (f196019 . 4) (f196013 . -24) (f196014 . -20) (f196015 . -16) (f196016 . -12) (f196017 . -8) (f196018 . -4) (f196019 . 0))
# expr=((vector-ref f196014 0) f196037)
# emit-tail-funcall
#    si   =-16
#    env  = ((f196037 . -12) (f196037 . -8) ((primitive-ref write) . 36) ((primitive-ref error) . 32) (else . 28) (f196014 . 24) (f196015 . 20) (f196016 . 16) (f196017 . 12) (f196018 . 8) (f196019 . 4) (f196013 . -24) (f196014 . -20) (f196015 . -16) (f196016 . -12) (f196017 . -8) (f196018 . -4) (f196019 . 0))
#    expr = (funcall (vector-ref f196014 0) f196037)
# emit-expr (vector-ref f196014 0)
# emit-expr f196014
# emit-variable-ref
# env=((f196037 . -12) (f196037 . -8) ((primitive-ref write) . 36) ((primitive-ref error) . 32) (else . 28) (f196014 . 24) (f196015 . 20) (f196016 . 16) (f196017 . 12) (f196018 . 8) (f196019 . 4) (f196013 . -24) (f196014 . -20) (f196015 . -16) (f196016 . -12) (f196017 . -8) (f196018 . -4) (f196019 . 0))
# var=f196014
    movl 22(%edi), %eax  # frame load f196014
# end emit-variable-ref
# check the argument is a vector
    movl %eax,%ebx
    and $7, %bl
    cmp $5, %bl
    je _L_1432714
# invoke error handler eh_vector
    .extern mrc_eh$uvector
    movl mrc_eh$uvector, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1432714:
    movl %eax, -16(%esp)
# emit-expr 0
    movl $0, %eax     # immed 0
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1432715"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1432715:
# check bounds on vector index
    movl -16(%esp), %ebx
    cmp  %eax,-5(%ebx) 
    jle _L_1432717
    cmp  $0,%eax
    jge _L_1432716
_L_1432717:
# invoke error handler eh_vector_index
    .extern mrc_eh$uvector$uindex
    movl mrc_eh$uvector$uindex,%edi   # load handler
    movl $4, %eax  # set arg count
    movl $140,-8(%esp)
    jmp *-2(%edi)  # jump to handler
_L_1432716:
    movl -16(%esp), %esi
    movl -1(%eax,%esi), %eax
   movl %eax,  -16(%esp)  # stash funcall-oper in next closure slot
# emit-expr f196037
# emit-variable-ref
# env=((f196037 . -12) (f196037 . -8) ((primitive-ref write) . 36) ((primitive-ref error) . 32) (else . 28) (f196014 . 24) (f196015 . 20) (f196016 . 16) (f196017 . 12) (f196018 . 8) (f196019 . 4) (f196013 . -24) (f196014 . -20) (f196015 . -16) (f196016 . -12) (f196017 . -8) (f196018 . -4) (f196019 . 0))
# var=f196037
    movl -12(%esp), %eax  # stack load f196037
# end emit-variable-ref
    mov %eax, -20(%esp)    # arg f196037
    movl -16(%esp), %edi   # load new closure to %edi
# emit-shift-args:  size=2   si=-16  delta=12
    mov -16(%esp), %ebx  # shift frame cell
    mov %ebx, -4(%esp)  # down to base
# emit-shift-args:  size=1   si=-20  delta=12
    mov -20(%esp), %ebx  # shift frame cell
    mov %ebx, -8(%esp)  # down to base
# emit-shift-args:  size=0   si=-24  delta=12
    movl $4,%eax   # save arg count
    jmp *-2(%edi)  # tail-funcall
    jmp _L_1432713
_L_1432712:
# emit-tail-expr
# si=-16
# env=((f196037 . -12) (f196037 . -8) ((primitive-ref write) . 36) ((primitive-ref error) . 32) (else . 28) (f196014 . 24) (f196015 . 20) (f196016 . 16) (f196017 . 12) (f196018 . 8) (f196019 . 4) (f196013 . -24) (f196014 . -20) (f196015 . -16) (f196016 . -12) (f196017 . -8) (f196018 . -4) (f196019 . 0))
# expr=((primitive-ref error) ((primitive-ref string->symbol) "write") "unrecognized expression")
# emit-tail-funcall
#    si   =-16
#    env  = ((f196037 . -12) (f196037 . -8) ((primitive-ref write) . 36) ((primitive-ref error) . 32) (else . 28) (f196014 . 24) (f196015 . 20) (f196016 . 16) (f196017 . 12) (f196018 . 8) (f196019 . 4) (f196013 . -24) (f196014 . -20) (f196015 . -16) (f196016 . -12) (f196017 . -8) (f196018 . -4) (f196019 . 0))
#    expr = (funcall (primitive-ref error) ((primitive-ref string->symbol) "write") "unrecognized expression")
# emit-expr (primitive-ref error)
    .extern mrc_error
    movl mrc_error,%eax
   movl %eax,  -16(%esp)  # stash funcall-oper in next closure slot
# emit-expr ((primitive-ref string->symbol) "write")
# funcall
#    si   =-20
#    env  = ((f196037 . -12) (f196037 . -8) ((primitive-ref write) . 36) ((primitive-ref error) . 32) (else . 28) (f196014 . 24) (f196015 . 20) (f196016 . 16) (f196017 . 12) (f196018 . 8) (f196019 . 4) (f196013 . -24) (f196014 . -20) (f196015 . -16) (f196016 . -12) (f196017 . -8) (f196018 . -4) (f196019 . 0))
#    expr = (funcall (primitive-ref string->symbol) "write")
# emit-expr (primitive-ref string->symbol)
    .extern mrc_string$m$gsymbol
    movl mrc_string$m$gsymbol,%eax
# check the funcall op is a procedure
    movl %eax,%ebx
    and $7, %bl
    cmp $2, %bl
    je "_L_1432718"
# invoke error handler funcall_non_procedure
    .extern mrc_eh$uprocedure
    movl mrc_eh$uprocedure, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to the handler
"_L_1432718":
   movl %eax,  -28(%esp)  # stash funcall-oper in closure slot
# emit-expr "write"
# string literal
    jmp _L_1432720
    .align 8,0x90
_L_1432719 :
    .int 20
    .ascii "write"
_L_1432720:
    movl $_L_1432719, %eax
    orl $6, %eax
    mov %eax, -32(%esp)  # arg write
    movl -28(%esp), %edi   # load new closure to %edi
    add $-20, %esp   # adjust base
    movl $4,%eax   # save arg count
    call *-2(%edi)        # call thru closure ptr
    add $20, %esp   # adjust base
    movl -4(%esp), %edi   # restore closure frame ptr
    mov %eax, -20(%esp)    # arg ((primitive-ref string->symbol) write)
# emit-expr "unrecognized expression"
# string literal
    jmp _L_1432722
    .align 8,0x90
_L_1432721 :
    .int 92
    .ascii "unrecognized expression"
_L_1432722:
    movl $_L_1432721, %eax
    orl $6, %eax
    mov %eax, -24(%esp)    # arg unrecognized expression
    movl -16(%esp), %edi   # load new closure to %edi
# emit-shift-args:  size=3   si=-16  delta=12
    mov -16(%esp), %ebx  # shift frame cell
    mov %ebx, -4(%esp)  # down to base
# emit-shift-args:  size=2   si=-20  delta=12
    mov -20(%esp), %ebx  # shift frame cell
    mov %ebx, -8(%esp)  # down to base
# emit-shift-args:  size=1   si=-24  delta=12
    mov -24(%esp), %ebx  # shift frame cell
    mov %ebx, -12(%esp)  # down to base
# emit-shift-args:  size=0   si=-28  delta=12
    movl $8,%eax   # save arg count
    jmp *-2(%edi)  # tail-funcall
_L_1432713:
_L_1432707:
_L_1432701:
_L_1432695:
_L_1432689:
_L_1432683:
    .align 4,0x90
_L_1432680:
# emit-expr (begin)
# emit-begin
#   expr=(begin)
#   env=((f196013 . -24) (f196014 . -20) (f196015 . -16) (f196016 . -12) (f196017 . -8) (f196018 . -4) (f196019 . 0))
     movl %eax, mrc_write
# == explicit-begins  ==>
# (lambda (i) (fixnum->char i))
# == eliminate-let*  ==>
# (lambda (i) (fixnum->char i))
# == uniquify-variables  ==>
# (lambda (f196038) (fixnum->char f196038))
# == vectorize-letrec  ==>
# (lambda (f196038) (fixnum->char f196038))
# == eliminate-set!  ==>
# (lambda (f196038) (let ((f196038 f196038)) (fixnum->char f196038)))
# == close-free-variables  ==>
# (closure (f196038) () (let ((f196038 f196038)) (fixnum->char f196038)))
# == eliminate-quote  ==>
# (closure (f196038) () (let ((f196038 f196038)) (fixnum->char f196038)))
# == eliminate-when/unless  ==>
# (closure (f196038) () (let ((f196038 f196038)) (fixnum->char f196038)))
# == eliminate-cond  ==>
# (closure (f196038) () (let ((f196038 f196038)) (fixnum->char f196038)))
# == external-symbols  ==>
# (closure (f196038) () (let ((f196038 f196038)) (fixnum->char f196038)))
# emit-expr (closure (f196038) () (let ((f196038 f196038)) (fixnum->char f196038)))
# emit-closure
# si = 0
# env = ()
# expr = (closure (f196038) () (let ((f196038 f196038)) (fixnum->char f196038)))
    movl $_L_1432723, 0(%ebp)  # closure label
    movl %ebp, %eax   # get the base ptr
    add $2, %eax     # add the closure tag
    add $8, %ebp     # bump ebp
    jmp _L_1432724            # jump around closure body
_L_1432723:
# check argument count
    cmp $4,%eax
    je _L_1432725
# invoke error handler eh_argcount
    .extern mrc_eh$uargcount
    movl mrc_eh$uargcount, %edi  # load handler
    movl $0, %eax  # set arg count
    jmp *-2(%edi)  # jump to handler
_L_1432725:
# emit-tail-expr
# si=-12
# env=((f196038 . -8))
# expr=(let ((f196038 f196038)) (fixnum->char f196038))
# emit-tail-let
#  si   = -12
#  env  = ((f196038 . -8))
#  bindings = ((f196038 f196038))
#  body = (fixnum->char f196038)
# emit-expr f196038
# emit-variable-ref
# env=((f196038 . -8))
# var=f196038
    movl -8(%esp), %eax  # stack load f196038
# end emit-variable-ref
    movl %eax, -12(%esp)  # stack save
# emit-tail-expr
# si=-16
# env=((f196038 . -12) (f196038 . -8))
# expr=(fixnum->char f196038)
# tail primcall
# emit-expr f196038
# emit-variable-ref
# env=((f196038 . -12) (f196038 . -8))
# var=f196038
    movl -12(%esp), %eax  # stack load f196038
# end emit-variable-ref
# check the argument is a fixnum
    movl %eax,%ebx
    and $3, %bl
    cmp $0, %bl
    je "_L_1432726"
# error handler eh_fixnum
    .extern mrc_eh$ufixnum
    movl mrc_eh$ufixnum, %edi  # load handler
    movl $4, %eax  # set arg count
    movl $0,-8(%esp)
    jmp *-2(%edi)  # jump to the handler
_L_1432726:
    shll $6, %eax
    orl $15, %eax
#return from tail (fixnum->char f196038)
    ret
    .align 4,0x90
_L_1432724:
     movl %eax, mrc_integer$m$gchar
# emit-expr (begin #t)
# emit-begin
#   expr=(begin #t)
#   env=()
# emit-expr #t
    movl $111, %eax     # immed #t
# emit-expr (begin)
# emit-begin
#   expr=(begin)
#   env=()
    .extern base_init_callback
    jmp base_init_callback
